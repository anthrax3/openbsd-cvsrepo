head	1.48;
access;
symbols
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.45.0.6
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.10
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.8
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.12
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.10
	OPENBSD_5_0:1.36.0.8
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.6
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.16
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.12
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.10
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.8
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.6
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.4
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2017.04.03.17.23.39;	author tedu;	state Exp;
branches;
next	1.47;
commitid	oO1rT3FzcBu2ya3g;

1.47
date	2017.04.03.17.07.58;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	3crLKHZ2QLfALH1z;

1.46
date	2017.04.02.00.53.37;	author guenther;	state Exp;
branches;
next	1.45;
commitid	YfzrATOzyNe0CyAC;

1.45
date	2016.04.02.16.33.28;	author millert;	state Exp;
branches;
next	1.44;
commitid	q1qMaQLmBd2jmAYp;

1.44
date	2015.10.12.16.54.30;	author uebayasi;	state Exp;
branches;
next	1.43;
commitid	nAtPDcvVbsBAku26;

1.43
date	2015.10.10.20.35.00;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	m38BXhkh3XknrpM6;

1.42
date	2015.10.09.17.09.06;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Yr0k9u6sNHDfPzPW;

1.41
date	2015.10.09.17.07.21;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	dNBJtecHBUDcjkMi;

1.40
date	2015.07.06.15.42.20;	author millert;	state Exp;
branches;
next	1.39;
commitid	54zdVbql1A4liAZo;

1.39
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	6b2lLILbgCR1fvia;

1.38
date	2015.01.16.06.39.49;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.17.23.52.06;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.15.14.43.07;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.16.10.53.02;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.14.22.14.13;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.26.01.58.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.25.21.44.03;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.24.20.38.14;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.19.22.35.34;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.22.17.45.16;	author pb;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.20.18.26.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.19.22.44.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.18.21.25.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.17.19.54.56;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.08.21.18.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.12.01.46.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.28.19.34.27;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.17.19.21.48;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.11.22.36.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.08.17.09.13.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.06.23.20.39.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.02.21.08.30.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.13.02.11.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.10.08.06.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.20.23.31.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.05.23.35.23;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.08.04.19.25.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.03.41.12;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.11.43.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.27.10.22.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@check return from pread, don't divide -1 for count
@
text
@/*	$OpenBSD: comsat.c,v 1.47 2017/04/03 17:07:58 deraadt Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/limits.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <termios.h>
#include <unistd.h>
#include <utmp.h>
#include <vis.h>
#include <err.h>

int	debug = 0;
#define	dsyslog	if (debug) syslog

#define MAXIDLE	120

char	hostname[HOST_NAME_MAX+1];
struct	utmp *utmp = NULL;
time_t	lastmsgtime;
int	nutmp, uf;

void jkfprintf(FILE *, char[], off_t);
void mailfor(char *);
void notify(struct utmp *, off_t);
void readutmp(int);
void doreadutmp(void);
void reapchildren(int);

volatile sig_atomic_t wantreadutmp;

int
main(int argc, char *argv[])
{
	struct sockaddr_storage from;
	struct sigaction sa;
	ssize_t cc;
	socklen_t fromlen;
	char msgbuf[100];
	sigset_t sigset;

	/* verify proper invocation */
	fromlen = sizeof(from);
	if (getsockname(0, (struct sockaddr *)&from, &fromlen) == -1) {
		(void)fprintf(stderr,
		    "comsat: getsockname: %s.\n", strerror(errno));
		exit(1);
	}

	if (pledge("stdio rpath wpath proc tty", NULL) == -1)
		err(1, "pledge");

	openlog("comsat", LOG_PID, LOG_DAEMON);
	if (chdir(_PATH_MAILDIR)) {
		syslog(LOG_ERR, "chdir: %s: %m", _PATH_MAILDIR);
		(void) recv(0, msgbuf, sizeof(msgbuf) - 1, 0);
		exit(1);
	}
	if ((uf = open(_PATH_UTMP, O_RDONLY)) == -1) {
		syslog(LOG_ERR, "open: %s: %m", _PATH_UTMP);
		(void) recv(0, msgbuf, sizeof(msgbuf) - 1, 0);
		exit(1);
	}
	(void)time(&lastmsgtime);
	(void)gethostname(hostname, sizeof(hostname));
	doreadutmp();

	(void)signal(SIGTTOU, SIG_IGN);

	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = readutmp;
	sa.sa_flags = 0;			/* no SA_RESTART */
	(void)sigaction(SIGALRM, &sa, NULL);

	sa.sa_handler = reapchildren;
	sa.sa_flags = SA_RESTART;
	(void)sigaction(SIGCHLD, &sa, NULL);

	for (;;) {
		if (wantreadutmp) {
			wantreadutmp = 0;
			doreadutmp();
		}

		cc = recv(0, msgbuf, sizeof(msgbuf) - 1, 0);
		if (cc <= 0) {
			if (errno != EINTR)
				sleep(1);
			continue;
		}
		if (!nutmp)		/* no one has logged in yet */
			continue;
		sigemptyset(&sigset);
		sigaddset(&sigset, SIGALRM);
		sigprocmask(SIG_SETMASK, &sigset, NULL);
		msgbuf[cc] = '\0';
		(void)time(&lastmsgtime);
		mailfor(msgbuf);
		sigemptyset(&sigset);
		sigprocmask(SIG_SETMASK, &sigset, NULL);
	}
}

/* ARGSUSED */
void
reapchildren(int signo)
{
	int save_errno = errno;

	while (wait3(NULL, WNOHANG, NULL) > 0)
		;
	errno = save_errno;
}

/* ARGSUSED */
void
readutmp(int signo)
{
	wantreadutmp = 1;
}

void
doreadutmp(void)
{
	static u_int utmpsize;		/* last malloced size for utmp */
	static time_t utmpmtime;	/* last modification time for utmp */
	struct stat statbf;
	int n;

	if (time(NULL) - lastmsgtime >= MAXIDLE)
		exit(0);
	(void)fstat(uf, &statbf);
	if (statbf.st_mtime > utmpmtime) {
		utmpmtime = statbf.st_mtime;
		/* avoid int overflow */
		if (statbf.st_size > INT_MAX - 10 * sizeof(struct utmp)) {
			syslog(LOG_ALERT, "utmp file excessively large");
			exit(1);
		}
		if (statbf.st_size > utmpsize) {
			u_int nutmpsize = statbf.st_size + 10 *
			    sizeof(struct utmp);
			struct utmp *u;

			if ((u = recallocarray(utmp, utmpsize,
			    nutmpsize, 1)) == NULL) {
				free(utmp);
				syslog(LOG_ERR, "%s", strerror(errno));
				exit(1);
			}
			utmp = u;
			utmpsize = nutmpsize;
		}
		n = pread(uf, utmp, statbf.st_size, 0);
		if (n == -1)
			n = 0;
		nutmp = n / sizeof(struct utmp);
		dsyslog(LOG_DEBUG, "read %d utmp entries", nutmp);
	}
	(void)alarm(15);
}

void
mailfor(char *name)
{
	struct utmp *utp = &utmp[nutmp];
	char utname[UT_NAMESIZE+1];
	const char *errstr;
	char *cp;
	off_t offset;

	dsyslog(LOG_DEBUG, "mail for '%s'", name);
	if (!(cp = strchr(name, '@@')))
		return;
	*cp++ = '\0';
	cp[strcspn(cp, " \t\n")] = '\0';
	offset = strtonum(cp, 0, LLONG_MAX, &errstr);
	if (errstr) {
		syslog(LOG_ERR, "'%s' is %s", cp + 1, errstr);
		return;
	}
	while (--utp >= utmp) {
		memcpy(utname, utp->ut_name, UT_NAMESIZE);
		utname[UT_NAMESIZE] = '\0';
		dsyslog(LOG_DEBUG, "check %s against %s", name, utname);
		if (!strncmp(utname, name, UT_NAMESIZE))
			notify(utp, offset);
	}
}

static char *cr;

void
notify(struct utmp *utp, off_t offset)
{
	int fd;
	FILE *tp;
	struct stat stb;
	struct termios ttybuf;
	char tty[PATH_MAX], name[UT_NAMESIZE + 1];

	(void)snprintf(tty, sizeof(tty), "%s%.*s",
	    _PATH_DEV, (int)sizeof(utp->ut_line), utp->ut_line);
	if (strchr(tty + sizeof(_PATH_DEV) - 1, '/')) {
		/* A slash is an attempt to break security... */
		syslog(LOG_AUTH | LOG_NOTICE, "'/' in \"%s\"", tty);
		return;
	}
	if (stat(tty, &stb) || !(stb.st_mode & S_IEXEC)) {
		dsyslog(LOG_DEBUG, "%.*s: wrong mode on %s",
		    (int)sizeof(utp->ut_name), utp->ut_name, tty);
		return;
	}
	dsyslog(LOG_DEBUG, "notify %.*s on %s", (int)sizeof(utp->ut_name),
	    utp->ut_name, tty);
	if (fork())
		return;
	(void)signal(SIGALRM, SIG_DFL);
	(void)alarm(30);
	fd = open(tty, O_WRONLY);
	if (fd == -1 || (tp = fdopen(fd, "w")) == NULL) {
		dsyslog(LOG_ERR, "%s: %s", tty, strerror(errno));
		_exit(1);
	}
	(void)tcgetattr(fileno(tp), &ttybuf);
	cr = (ttybuf.c_oflag & ONLCR) && (ttybuf.c_oflag & OPOST) ?
	    "\n" : "\n\r";
	memcpy(name, utp->ut_name, UT_NAMESIZE);
	name[UT_NAMESIZE] = '\0';
	(void)fprintf(tp, "%s\007New mail for %s@@%.*s\007 has arrived:%s----%s",
	    cr, name, (int)sizeof(hostname), hostname, cr, cr);
	jkfprintf(tp, name, offset);
	(void)fclose(tp);
	_exit(0);
}

void
jkfprintf(FILE *tp, char name[], off_t offset)
{
	char *cp, ch;
	char visout[5], *s2;
	FILE *fi;
	int linecnt, charcnt, inheader;
	char line[BUFSIZ];

	if ((fi = fopen(name, "r")) == NULL)
		return;

	(void)fseeko(fi, offset, SEEK_SET);
	/*
	 * Print the first 7 lines or 560 characters of the new mail
	 * (whichever comes first).  Skip header crap other than
	 * From, Subject, To, and Date.
	 */
	linecnt = 7;
	charcnt = 560;
	inheader = 1;
	while (fgets(line, sizeof(line), fi) != NULL) {
		if (inheader) {
			if (line[0] == '\n') {
				inheader = 0;
				continue;
			}
			if (line[0] == ' ' || line[0] == '\t' ||
			    (strncmp(line, "From:", 5) &&
			    strncmp(line, "Subject:", 8)))
				continue;
		}
		if (linecnt <= 0 || charcnt <= 0) {
			(void)fprintf(tp, "...more...%s", cr);
			(void)fclose(fi);
			return;
		}
		/* strip weird stuff so can't trojan horse stupid terminals */
		for (cp = line; (ch = *cp) && ch != '\n'; ++cp, --charcnt) {
			ch = toascii(ch);
			vis(visout, ch, VIS_SAFE|VIS_NOSLASH, cp[1]);
			for (s2 = visout; *s2; s2++)
				(void)fputc(*s2, tp);
		}
		(void)fputs(cr, tp);
		--linecnt;
	}
	(void)fprintf(tp, "----%s\n", cr);
	(void)fclose(fi);
}
@


1.47
log
@use recallocarray() because the array contains data that can be observed
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.46 2017/04/02 00:53:37 guenther Exp $	*/
d173 1
d199 4
a202 1
		nutmp = pread(uf, utmp, statbf.st_size, 0)/sizeof(struct utmp);
@


1.46
log
@Prefer pread() over lseek()+read()
open() only needs the mode argument if O_CREAT is present

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.45 2016/04/02 16:33:28 millert Exp $	*/
d189 2
a190 1
			if ((u = realloc(utmp, nutmpsize)) == NULL) {
@


1.45
log
@Use open(tty, O_WRONLY) + fdopen() instead of fopen(tty, "w") to
keep stdio from opening with O_CREAT which would require pledge cpath.
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.44 2015/10/12 16:54:30 uebayasi Exp $	*/
d103 1
a103 1
	if ((uf = open(_PATH_UTMP, O_RDONLY, 0)) == -1) {
d197 1
a197 2
		(void)lseek(uf, 0, SEEK_SET);
		nutmp = read(uf, utmp, statbf.st_size)/sizeof(struct utmp);
@


1.44
log
@Call pledge(2) after initial getsockname(2) to avoid "inet" addition.

From & OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d237 1
d261 2
a262 1
	if ((tp = fopen(tty, "w")) == NULL) {
@


1.43
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.42 2015/10/09 17:09:06 deraadt Exp $	*/
a85 3
	if (pledge("stdio rpath wpath proc tty", NULL) == -1)
		err(1, "pledge");

d93 4
@


1.42
log
@With nfs spool (fork + seteuid/setuid balony) support gone, it becomes
possible to pledge "stdio rpath wpath tty proc"
Noone uses this code anymore.  This is a demonstration...
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.41 2015/10/09 17:07:21 deraadt Exp $	*/
d86 1
a86 1
	if (pledge("stdio rpath wpath tty proc", NULL) == -1)
@


1.41
log
@remove NFS spool support; it stands in the way of pledge(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.40 2015/07/06 15:42:20 millert Exp $	*/
d55 1
d85 3
@


1.40
log
@Trim trailing whitespace from the comsat message before calling
strtonum() to parse the offset since mail.local writes a trailing
newline.  Otherwise comsat just discards the message.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.39 2015/04/18 18:28:37 deraadt Exp $	*/
a277 1
	struct passwd *p;
a278 6

	/* Set effective uid to user in case mail drop is on nfs */
	if ((p = getpwnam(name)) != NULL) {
		(void) seteuid(p->pw_uid);
		(void) setuid(p->pw_uid);
	}
@


1.39
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.38 2015/01/16 06:39:49 deraadt Exp $	*/
d194 1
d208 1
d211 5
a215 3
	*cp = '\0';
	offset = strtonum(cp + 1, 0, LLONG_MAX, &errstr);
	if (errstr)
d217 1
d221 1
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.37 2012/12/04 02:24:47 deraadt Exp $	*/
d203 1
d210 3
a212 1
	offset = atoi(cp + 1);
@


1.37
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.36 2009/10/27 23:59:31 deraadt Exp $	*/
d43 1
d61 1
a61 1
char	hostname[MAXHOSTNAMELEN];
d226 1
a226 1
	char tty[MAXPATHLEN], name[UT_NAMESIZE + 1];
@


1.36
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.35 2006/08/17 23:52:06 ray Exp $	*/
a32 1
#include <sys/param.h>
@


1.35
log
@recv(2) returns a ssize_t, so match cc with it.
st.st_mtime is a time_t, so match utmpmtime with it.
Check for -1 instead of <0 for some system calls.
Remove pointless casts.

OK dhill@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.34 2005/11/15 14:43:07 millert Exp $	*/
a30 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)comsat.c	8.1 (Berkeley) 6/4/93";*/
static char rcsid[] = "$OpenBSD: comsat.c,v 1.34 2005/11/15 14:43:07 millert Exp $";
#endif /* not lint */
@


1.34
log
@the third arg of read() is size_t, not int (cast fix)
use UT_NAMESIZE more consistently
from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.33 2004/09/16 10:53:02 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.33 2004/09/16 10:53:02 otto Exp $";
d91 1
a91 1
	int cc;
d98 1
a98 1
	if (getsockname(0, (struct sockaddr *)&from, &fromlen) < 0) {
d109 1
a109 1
	if ((uf = open(_PATH_UTMP, O_RDONLY, 0)) < 0) {
d177 1
a177 1
	static u_int utmpmtime;		/* last modification time for utmp */
d203 2
a204 2
		(void)lseek(uf, (off_t)0, SEEK_SET);
		nutmp = read(uf, utmp, (size_t)statbf.st_size)/sizeof(struct utmp);
d206 1
a206 1
	(void)alarm((u_int)15);
d256 1
a256 1
	(void)alarm((u_int)30);
@


1.33
log
@more signal flag races; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.32 2004/09/14 22:14:13 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.32 2004/09/14 22:14:13 deraadt Exp $";
d204 1
a204 1
		nutmp = read(uf, utmp, (int)statbf.st_size)/sizeof(struct utmp);
d223 1
a223 1
		utname[sizeof(utname)-1] = '\0';
d265 1
a265 1
	name[sizeof(name)-1] = '\0';
@


1.32
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.31 2003/09/26 01:58:55 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.31 2003/09/26 01:58:55 deraadt Exp $";
d132 1
a133 1
			wantreadutmp = 0;
@


1.31
log
@free(NULL) allowed
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.30 2003/09/25 21:44:03 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.30 2003/09/25 21:44:03 millert Exp $";
d155 1
d166 1
@


1.30
log
@Fix typo in revision 1.29; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.29 2003/09/24 20:38:14 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.29 2003/09/24 20:38:14 deraadt Exp $";
d194 1
a194 2
				if (utmp)
					free(utmp);
@


1.29
log
@realloc fixes; ho ok
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.28 2003/06/19 22:35:34 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.28 2003/06/19 22:35:34 deraadt Exp $";
d199 1
a199 1
			u = utmp;
@


1.28
log
@use fseeko; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.27 2003/06/02 19:38:24 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.27 2003/06/02 19:38:24 millert Exp $";
d189 7
a195 2
			utmpsize = statbf.st_size + 10 * sizeof(struct utmp);
			if ((utmp = realloc(utmp, utmpsize)) == NULL) {
d199 2
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.26 2002/09/06 19:43:54 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.26 2002/09/06 19:43:54 deraadt Exp $";
d284 1
a284 1
	(void)fseek(fi, offset, SEEK_SET);
@


1.26
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.25 2002/08/22 17:45:16 pb Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.25 2002/08/22 17:45:16 pb Exp $";
@


1.25
log
@fix int overflow in statbf.st_size, from netbsd PR#17933

as by request from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $";
d96 1
a96 1
	int fromlen;
@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.23 2002/06/20 18:26:49 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.23 2002/06/20 18:26:49 deraadt Exp $";
d47 1
d187 5
@


1.23
log
@fix patch; moritz@@jodeit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.22 2002/06/19 22:44:04 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.22 2002/06/19 22:44:04 deraadt Exp $";
d90 1
a90 3
main(argc, argv)
	int argc;
	char *argv[];
d159 1
a159 2
reapchildren(signo)
	int signo;
d169 1
a169 2
readutmp(signo)
	int signo;
d200 1
a200 2
mailfor(name)
	char *name;
d222 1
a222 3
notify(utp, offset)
	struct utmp *utp;
	off_t offset;
d264 1
a264 4
jkfprintf(tp, name, offset)
	FILE *tp;
	char name[];
	off_t offset;
@


1.22
log
@handle non-terminated things better; moritz@@jodeit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.21 2002/02/16 21:27:29 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.21 2002/02/16 21:27:29 millert Exp $";
d248 2
a249 1
	dsyslog(LOG_DEBUG, "notify %s on %s", utp->ut_name, tty);
d255 1
a255 2
		dsyslog(LOG_ERR, "%.*s: %s", (int)sizeof(utp->ut_name),
		    tty, strerror(errno));
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.20 2001/12/07 18:45:32 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.20 2001/12/07 18:45:32 mpech Exp $";
d208 1
d216 4
a219 2
	while (--utp >= utmp)
		if (!strncmp(utp->ut_name, name, sizeof(utmp[0].ut_name)))
d221 1
d234 1
a234 1
	char tty[MAXPATHLEN], name[sizeof(utmp[0].ut_name) + 1];
d244 2
a245 1
		dsyslog(LOG_DEBUG, "%s: wrong mode on %s", utp->ut_name, tty);
d254 2
a255 1
		dsyslog(LOG_ERR, "%s: %s", tty, strerror(errno));
d261 2
a262 1
	(void)strlcpy(name, utp->ut_name, sizeof(name));
@


1.20
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.19 2001/11/18 21:25:55 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.19 2001/11/18 21:25:55 deraadt Exp $";
d80 6
a85 6
void jkfprintf __P((FILE *, char[], off_t));
void mailfor __P((char *));
void notify __P((struct utmp *, off_t));
void readutmp __P((int));
void doreadutmp __P((void));
void reapchildren __P((int));
@


1.19
log
@Ensure SA_RESTART is not set on SIGALRM.  With it set, the SIGALRM is not
seen after a successful recv().  This affects some other programs too..
but turning off SA_RESTART requires SIGNIFICANT analysis -- not for the
faint of heart.
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.17 2001/07/08 21:18:06 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.17 2001/07/08 21:18:06 deraadt Exp $";
d96 1
a96 1
	register int cc;
d207 2
a208 2
	register struct utmp *utp = &utmp[nutmp];
	register char *cp;
d224 1
a224 1
	register struct utmp *utp;
d265 1
a265 1
	register FILE *tp;
d269 1
a269 1
	register char *cp, ch;
d271 3
a273 3
	register FILE *fi;
	register int linecnt, charcnt, inheader;
	register struct passwd *p;
@


1.18
log
@volatile sig_atomic_t
@
text
@d95 1
d122 1
a122 1
	(void)signal(SIGALRM, readutmp);
d124 11
a134 1
	(void)signal(SIGCHLD, reapchildren);
a183 1
	int save_errno = errno;
a186 1
	(void)alarm((u_int)15);
d200 1
a200 1
	errno = save_errno;
d230 1
a230 1
	char tty[20], name[sizeof(utmp[0].ut_name) + 1];
@


1.17
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.16 2001/05/12 01:46:54 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.16 2001/05/12 01:46:54 deraadt Exp $";
d87 1
a87 1
sig_atomic_t wantreadutmp;
@


1.16
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.15 2001/01/28 19:34:27 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.15 2001/01/28 19:34:27 niklas Exp $";
d292 2
a293 2
			    strncmp(line, "From:", 5) &&
			    strncmp(line, "Subject:", 8))
@


1.15
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: comsat.c,v 1.14 2001/01/17 19:21:48 deraadt Exp $";
d246 1
a246 2
	(void)strncpy(name, utp->ut_name, sizeof(name) - 1);
	name[sizeof(name) - 1] = '\0';
@


1.14
log
@use sig_atomic_t, and check for signal flag more often
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: comsat.c,v 1.13 2001/01/11 22:36:22 deraadt Exp $";
@


1.13
log
@change signal handler to set a flag, and then in the main loop do
the work that this handler used to do.  many signal handlers in the
tree should be changed to this, since a large percentage of them
have raceable stuff in them; like mixing malloc's and stdio inside and
outside the handler.. terrrible stuff
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.12 1999/08/17 09:13:13 millert Exp $";
d85 1
a85 1
volatile int wantreadutmp;
d123 5
a131 4
			if (wantreadutmp) {
				doreadutmp();
				wantreadutmp = 0;
			}
@


1.12
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.11 1999/06/23 20:39:12 deraadt Exp $";
d81 2
a82 1
void onalrm __P((int));
d85 2
d118 2
a119 2
	onalrm(0);
	(void)signal(SIGALRM, onalrm);
d127 4
a130 1
			errno = 0;
d152 2
a153 1
	while (wait3(NULL, WNOHANG, NULL) > 0);
d158 1
a158 1
onalrm(signo)
d160 6
@


1.11
log
@use sockaddr_storage
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.10 1999/02/21 08:30:00 deraadt Exp $";
a47 1
#include <sys/file.h>
d54 1
@


1.10
log
@vis() buf overflow
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.9 1998/07/13 02:11:14 millert Exp $";
d89 1
a89 1
	struct sockaddr_in from;
@


1.9
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.8 1998/07/10 08:06:02 deraadt Exp $";
d246 1
a246 1
	char visout[4], *s2;
@


1.8
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.7 1997/11/20 23:31:50 deraadt Exp $";
d172 1
a172 1
		(void)lseek(uf, (off_t)0, L_SET);
d261 1
a261 1
	(void)fseek(fi, offset, L_SET);
@


1.7
log
@do not exit(-1)
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.6 1997/08/05 23:35:23 angelos Exp $";
d218 1
a218 1
	dsyslog(LOG_DEBUG, "notify %s on %s\n", utp->ut_name, tty);
@


1.6
log
@More errno saving.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.5 1997/08/04 19:25:07 deraadt Exp $";
d225 1
a225 1
		_exit(-1);
@


1.5
log
@save errno in sigchld handlers
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.4 1996/12/22 03:41:12 tholo Exp $";
d157 1
d175 1
@


1.4
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.3 1996/08/27 11:43:52 deraadt Exp $";
d144 2
d147 1
@


1.3
log
@vis
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.2 1996/08/27 10:22:04 deraadt Exp $";
d248 2
a249 1
	if ((p = getpwnam(name)) != NULL)
d251 1
@


1.2
log
@strncpy correctly
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.1.1.1 1995/10/18 08:43:15 deraadt Exp $";
d66 1
d241 1
d282 3
a284 3
			if (!isprint(ch) && !isspace(ch))
				ch |= 0x40;
			(void)fputc(ch, tp);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: comsat.c,v 1.8 1995/05/02 02:05:47 mycroft Exp $";
d224 1
a224 1
	(void)strncpy(name, utp->ut_name, sizeof(utp->ut_name));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
