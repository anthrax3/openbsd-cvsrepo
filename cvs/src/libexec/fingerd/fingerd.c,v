head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.10
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.10
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.8
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.6
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.31.0.8
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.6
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.11.13.01.26.33;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Z7Xj3bG4RRrIhR2z;

1.38
date	2015.11.13.01.23.59;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	O6qFUuaLCni31upv;

1.37
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.11.17.17.53;	author tobias;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.19.06.01.00;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.17.17.51.21;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.17.10.41.18;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.02.01.27.15;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.27.17.10.26;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.18.18.31.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.08.21.18.07;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.25.19.22.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.18.05.28.31;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.07.03.48.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.11.15.01.03.27;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.08.02.17.42.39;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	99.07.20.22.40.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.07.03.18.24.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.02.24.17.00.01;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	97.11.21.01.01.44;	author gene;	state Exp;
branches;
next	1.11;

1.11
date	97.11.17.00.43.25;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.08.16.21.38.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.08.16.20.34.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.25.19.41.14;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.20.36.22;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.40.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.08.13.29.54;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.07.16.17.55.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.24.17.41.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.08.44.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@4-step pledge in a program noone really uses anymore.
pledge "stdio inet dns proc exec" at startup.
In the logging codepath, "stdio dns proc exec" after getpeername()
drop to stdio proc exec(), before fork / execve
Parent moving data out of the pipe only needs "stdio"
@
text
@/*	$OpenBSD: fingerd.c,v 1.38 2015/11/13 01:23:59 deraadt Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

#include <err.h>
#include <unistd.h>
#include <syslog.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <limits.h>
#include "pathnames.h"

__dead void logerr(const char *, ...);
__dead void usage(void);

void
usage(void)
{
	syslog(LOG_ERR,
	    "usage: fingerd [-lMmpSsu] [-P filename]");
	exit(2);
}


int
main(int argc, char *argv[])
{
	FILE *fp;
	int ch, ac = 2;
	int p[2], logging, secure, user_required, short_list;
#define	ENTRIES	50
	char **comp, *prog;
	char **ap, *av[ENTRIES + 1], line[8192], *lp, *hname;
	char hostbuf[HOST_NAME_MAX+1];

	if (pledge("stdio inet dns proc exec", NULL) == -1)
		err(1, "pledge");

	prog = _PATH_FINGER;
	logging = secure = user_required = short_list = 0;
	openlog("fingerd", LOG_PID, LOG_DAEMON);
	opterr = 0;
	while ((ch = getopt(argc, argv, "sluSmMpP:")) != -1)
		switch (ch) {
		case 'l':
			logging = 1;
			break;
		case 'P':
			prog = optarg;
			break;
		case 's':
			secure = 1;
			break;
		case 'u':
			user_required = 1;
			break;
		case 'S':
			if (ac < ENTRIES) {
				short_list = 1;
				av[ac++] = "-s";
			}
			break;
		case 'm':
			if (ac < ENTRIES)
				av[ac++] = "-m";
			break;
		case 'M':
			if (ac < ENTRIES)
				av[ac++] = "-M";
			break;
		case 'p':
			if (ac < ENTRIES)
				av[ac++] = "-p";
			break;
		default:
			usage();
		}

	if (logging) {
		struct sockaddr_storage ss;
		struct sockaddr *sa;
		socklen_t sval;

		sval = sizeof(ss);
		if (getpeername(0, (struct sockaddr *)&ss, &sval) < 0)
			err(1, "getpeername");
		sa = (struct sockaddr *)&ss;

		if (pledge("stdio dns proc exec", NULL) == -1)
			err(1, "pledge");

		if (getnameinfo(sa, sa->sa_len, hostbuf, sizeof(hostbuf),
		    NULL, 0, 0) != 0) {
			strlcpy(hostbuf, "?", sizeof(hostbuf));
		}
		hname = hostbuf;
	}

	if (pledge("stdio proc exec", NULL) == -1)
		err(1, "pledge");

	if (fgets(line, sizeof(line), stdin) == NULL) {
		if (logging)
			syslog(LOG_NOTICE, "query from %s: %s", hname,
			    feof(stdin) ? "EOF" : strerror(errno));
		exit(1);
	}

	if (logging)
		syslog(LOG_NOTICE, "query from %s: `%.*s'", hname,
		    (int)strcspn(line, "\r\n"), line);

	/*
	 * Note: we assume that finger(1) will treat "--" as end of
	 * command args (ie: that it uses getopt(3)).
	 */
	av[ac++] = "--";
	comp = &av[1];
	for (lp = line, ap = &av[ac]; ac < ENTRIES;) {
		size_t len;

		if ((*ap = strtok(lp, " \t\r\n")) == NULL)
			break;
		lp = NULL;
		if (secure && strchr(*ap, '@@')) {
			(void) puts("forwarding service denied\r");
			exit(1);
		}

		len = strlen(*ap);
		while (len > 0 && (*ap)[len - 1] == '@@')
			(*ap)[--len] = '\0';
		if (**ap == '\0')
			continue;

		/* RFC1196: "/[Ww]" == "-l" */
		if ((*ap)[0] == '/' && ((*ap)[1] == 'W' || (*ap)[1] == 'w')) {
			if (!short_list) {
				av[1] = "-l";
				comp = &av[0];
			}
		} else {
			ap++;
			ac++;
		}
	}
	av[ENTRIES - 1] = NULL;

	if ((lp = strrchr(prog, '/')))
		*comp = ++lp;
	else
		*comp = prog;

	if (user_required) {
		for (ap = comp + 1; strcmp("--", *(ap++)); )
			;
		if (*ap == NULL) {
			(void) puts("must provide username\r");
			exit(1);
		}
	}

	if (pipe(p) < 0)
		logerr("pipe: %s", strerror(errno));

	switch (vfork()) {
	case 0:
		(void) close(p[0]);
		if (p[1] != 1) {
			(void) dup2(p[1], 1);
			(void) close(p[1]);
		}
		execv(prog, comp);
		syslog(LOG_ERR, "execv: %s: %s", prog, strerror(errno));
		_exit(1);
	case -1:
		logerr("fork: %s", strerror(errno));
	}
	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	(void) close(p[1]);
	if (!(fp = fdopen(p[0], "r")))
		logerr("fdopen: %s", strerror(errno));
	while ((ch = getc(fp)) != EOF) {
		if (ch == '\n')
			putchar('\r');
		putchar(ch);
	}
	exit(0);
}

void
logerr(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void) vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);
	exit(1);
}
@


1.38
log
@_exit() in the child; as a result, must use syslog() directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.37 2015/01/16 06:39:50 deraadt Exp $	*/
d71 3
d123 4
d134 3
d214 3
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.36 2012/12/04 02:24:47 deraadt Exp $	*/
d199 2
a200 1
		logerr("execv: %s: %s", prog, strerror(errno));
@


1.36
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.35 2009/10/27 23:59:31 deraadt Exp $	*/
d45 1
d69 1
a69 1
	char hostbuf[MAXHOSTNAMELEN];
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.34 2008/08/11 17:17:53 tobias Exp $	*/
a31 1
#include <sys/param.h>
@


1.34
log
@Prevent a buffer underrun if a line is received which only contains
(multiple) @@.

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.33 2006/08/19 06:01:00 ray Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)fingerd.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.33 2006/08/19 06:01:00 ray Exp $";
#endif
#endif /* not lint */
@


1.33
log
@Don't shadow err(3).
Store strlen() results in a size_t.
Add __dead to both usage() and logerr().
Get rid of /* NOTREACHED */.
Get rid of extraneous _exit().
Calls err(3) on getpeername failure.

``reads well to me!'' avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.32 2006/01/17 17:51:21 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.32 2006/01/17 17:51:21 millert Exp $";
d170 1
a170 1
		while ((*ap)[len - 1] == '@@')
@


1.32
log
@Incllude <sys/param.h> to get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.31 2003/10/17 10:41:18 jmc Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.31 2003/10/17 10:41:18 jmc Exp $";
d52 1
d62 2
a63 2
void err(const char *, ...);
void usage(void);
d131 2
a132 4
		if (getpeername(0, (struct sockaddr *)&ss, &sval) < 0) {
			/* err("getpeername: %s", strerror(errno)); */
			exit(1);
		}
d159 2
d169 3
a171 3
		ch = strlen(*ap);
		while ((*ap)[ch-1] == '@@')
			(*ap)[--ch] = '\0';
d203 1
a203 1
		err("pipe: %s", strerror(errno));
d213 1
a213 2
		err("execv: %s: %s", prog, strerror(errno));
		_exit(1);
d215 1
a215 1
		err("fork: %s", strerror(errno));
d219 1
a219 1
		err("fdopen: %s", strerror(errno));
d229 1
a229 1
err(const char *fmt, ...)
a236 1
	/* NOTREACHED */
@


1.31
log
@slight update for fingerd; sort options;
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.30 2003/06/02 19:38:24 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.30 2003/06/02 19:38:24 millert Exp $";
d46 1
a46 1
#include <sys/types.h>
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.29 2002/09/06 19:43:54 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.29 2002/09/06 19:43:54 deraadt Exp $";
d68 1
a68 1
	    "usage: fingerd [-slumMpS] [-P filename]");
@


1.29
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.28 2002/07/03 23:39:03 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.28 2002/07/03 23:39:03 deraadt Exp $";
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.27 2002/06/02 01:27:15 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.27 2002/06/02 01:27:15 deraadt Exp $";
d131 1
a131 1
		int sval;
@


1.27
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.26 2002/02/19 19:39:38 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.26 2002/02/19 19:39:38 millert Exp $";
d69 1
a69 1
usage()
d78 1
a78 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.26
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.25 2002/02/16 21:27:29 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.25 2002/02/16 21:27:29 millert Exp $";
d210 1
a210 1
	switch(vfork()) {
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.24 2001/12/07 18:45:32 mpech Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.24 2001/12/07 18:45:32 mpech Exp $";
d62 1
a233 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a234 1
#ifdef __STDC__
a235 5
#else
err(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d238 1
a238 1
#ifdef __STDC__
a239 3
#else
	va_start(ap);
#endif
@


1.24
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.23 2001/11/27 17:10:26 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.23 2001/11/27 17:10:26 millert Exp $";
d64 2
a65 2
void err __P((const char *, ...));
void usage __P((void));
@


1.23
log
@When copying command line arguments to out new argument vector,
don't go past the end of the buffer.  Not a security issue since
root controls the fingerd arguments.  Noticed by Brian Poole.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.22 2001/08/18 18:31:21 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.22 2001/08/18 18:31:21 deraadt Exp $";
d81 2
a82 2
	register FILE *fp;
	register int ch, ac = 2;
@


1.22
log
@strlcpy invades the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.21 2001/07/08 21:18:07 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.21 2001/07/08 21:18:07 deraadt Exp $";
d108 4
a111 2
			short_list = 1;
			av[ac++] = "-s";
d114 2
a115 1
			av[ac++] = "-m";
d118 2
a119 1
			av[ac++] = "-M";
d122 2
a123 1
			av[ac++] = "-p";
a124 1
		case '?':
@


1.21
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.20 2001/01/25 19:22:08 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.20 2001/01/25 19:22:08 deraadt Exp $";
d138 1
a138 1
			strncpy(hostbuf, "?", sizeof(hostbuf));
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.19 2000/08/18 05:28:31 itojun Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.19 2000/08/18 05:28:31 itojun Exp $";
d85 2
a86 1
	char **ap, *av[ENTRIES + 1], **comp, line[8192], *lp, *prog, *hname;
d194 2
a195 1
		for (ap = comp + 1; strcmp("--", *(ap++)); );
@


1.19
log
@check error result from getnameinfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.18 2000/07/07 03:48:12 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.18 2000/07/07 03:48:12 millert Exp $";
d151 1
a151 1
		    strcspn(line, "\r\n"), line);
@


1.18
log
@Change fingerd back to using fgets(3), not fgetln(3).  Using fgetln(3)
was a mistake since it allows an attacker to trivially drive up the
load on a machine.  Of course, this can still be done with multiple
connections but there's no reason to make it easier than it needs
to be.  This also simplifies the logging a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.17 1999/11/15 01:03:27 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.17 1999/11/15 01:03:27 deraadt Exp $";
d126 1
d134 5
a138 2
		(void)getnameinfo((struct sockaddr *)&ss, ss.ss_len,
		    hostbuf, sizeof(hostbuf), NULL, 0, 0);
@


1.17
log
@logging getpeername() failures is a waste of time
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.16 1999/08/02 17:42:39 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.16 1999/08/02 17:42:39 pjanzen Exp $";
a83 1
	size_t linesiz;
d85 1
a85 1
	char **ap, *av[ENTRIES + 1], **comp, *line, *prog, *lp, *hname;
d138 1
a138 1
	if ((lp = fgetln(stdin, &linesiz)) == NULL) {
a143 4
	if ((line = malloc(linesiz + 1)) == NULL)
		err("Out of memory");
	memcpy(line, lp, linesiz);
	line[linesiz] = '\0';
d145 3
a147 16
	if (logging) {
		char *tline;

		if ((tline = strdup(line)) == NULL)
			err("Out of memory");
		/* Replace NULL, \r and \n with ' ' */
		for (ch = 0; ch < linesiz; ch++) {
			if (tline[ch] == '\0' || tline[ch] == '\r' ||
			    tline[ch] == '\n')
				tline[ch] = ' ';
		}
		for (lp = tline + linesiz - 1; lp >= tline && *lp == ' '; lp--)
			*lp = '\0';
		syslog(LOG_NOTICE, "query from %s: `%s'", hname, tline);
		free(tline);
	}
@


1.16
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.15 1999/07/20 22:40:37 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.15 1999/07/20 22:40:37 deraadt Exp $";
d130 4
a133 2
		if (getpeername(0, (struct sockaddr *)&ss, &sval) < 0)
			err("getpeername: %s", strerror(errno));
@


1.15
log
@bad arguments? usage() should syslog()
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.14 1999/07/03 18:24:13 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.14 1999/07/03 18:24:13 deraadt Exp $";
d71 1
a71 1
	    "usage: ftpd [-slumMpS] [-P filename]");
@


1.14
log
@use getnameinfo()
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.13 1999/02/24 17:00:01 aaron Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.13 1999/02/24 17:00:01 aaron Exp $";
d65 10
d122 1
a122 1
			err("illegal option -- %c", ch);
@


1.13
log
@fowarding -> forwarding
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.12 1997/11/21 01:01:44 gene Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.12 1997/11/21 01:01:44 gene Exp $";
d77 1
d116 1
a116 2
		struct hostent *hp;
		struct sockaddr_in sin;
d119 2
a120 2
		sval = sizeof(sin);
		if (getpeername(0, (struct sockaddr *)&sin, &sval) < 0)
d122 3
a124 7
		if ((hp = gethostbyaddr((char *)&sin.sin_addr.s_addr,
		    sizeof(sin.sin_addr.s_addr), AF_INET)))
			hname = strdup(hp->h_name);
		else
			hname = strdup(inet_ntoa(sin.sin_addr));
		if (hname == NULL)
			err("Out of memory");
@


1.12
log
@Remove LOG_CONS from openlog() call so every darned finger connect message
doesn't go to console.  Change discussed and checked with millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.11 1997/11/17 00:43:25 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.11 1997/11/17 00:43:25 millert Exp $";
d170 1
a170 1
			(void) puts("fowarding service denied\r");
@


1.11
log
@1) use fgetln for arbitrary sized lines
2) do puts("foo\r") not puts("foo\r\n") as puts adds a \n itself
3) log the command given when -l is specified, replacing \r, \n, NULL with ' '
4) with -l, log possible probes (ie: EOF) that were previously ignored
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.10 1997/08/16 21:38:21 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.10 1997/08/16 21:38:21 millert Exp $";
d80 1
a80 1
	openlog("fingerd", LOG_PID | LOG_CONS, LOG_DAEMON);
@


1.10
log
@<string.h> not <strings.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: fingerd.c,v 1.9 1997/08/16 20:34:20 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.9 1997/08/16 20:34:20 millert Exp $";
d73 2
a74 4
	register char *lp;
	struct hostent *hp;
	struct sockaddr_in sin;
	int p[2], logging, secure, user_required, short_list, sval;
d76 1
a76 1
	char **ap, *av[ENTRIES + 1], **comp, line[1024], *prog;
d115 4
d124 1
a124 1
			lp = hp->h_name;
d126 3
a128 2
			lp = inet_ntoa(sin.sin_addr);
		syslog(LOG_NOTICE, "query from %s", lp);
d131 4
a134 1
	if (!fgets(line, sizeof(line), stdin))
d136 23
a158 1
	
d170 1
a170 1
			(void) puts("fowarding service denied\r\n");
d201 1
a201 1
			(void) puts("must provide username\r\n");
@


1.9
log
@OpenBSD tags and document assumption about finger(1) arg parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fingerd.c,v 1.8 1997/07/25 19:41:14 mickey Exp $";
d61 1
a61 1
#include <strings.h>
@


1.8
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 2
d43 5
a47 2
/*static char sccsid[] = "from: @@(#)fingerd.c	8.1 (Berkeley) 6/4/93";*/
static char rcsid[] = "$Id: fingerd.c,v 1.7 1997/07/23 20:36:22 kstailey Exp $";
d131 4
@


1.7
log
@tabify
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.6 1997/01/15 23:40:56 millert Exp $";
d196 1
a196 1
#if __STDC__
d203 1
a203 1
#if __STDC__
d212 1
a212 1
#if __STDC__
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.5 1996/12/08 13:29:54 downsj Exp $";
d208 1
a208 1
        va_dcl
@


1.5
log
@Add -M.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.4 1996/07/16 17:55:43 millert Exp $";
d79 1
a79 1
	while ((ch = getopt(argc, argv, "sluSmMpP:")) != EOF)
@


1.4
log
@Updated to 4.4BSD fingerd + Theo's @@@@@@@@ optimization and some
added options to further restrict the info given out.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.7 1996/07/16 17:51:47 millert Exp $";
d79 1
a79 1
	while ((ch = getopt(argc, argv, "sluSmpP:")) != EOF)
d99 3
@


1.3
log
@add -s flag; if specified in inetd, does not allow forwarding @@ requests
@
text
@d2 2
a3 2
 * Copyright (c) 1983 The Regents of the University of California.
 * All rights reserved.
d35 3
a37 3
char copyright[] =
"@@(#) Copyright (c) 1983 The Regents of the University of California.\n\
 All rights reserved.\n";
d41 2
a42 2
/*static char sccsid[] = "from: @@(#)fingerd.c	5.6 (Berkeley) 6/1/90";*/
static char rcsid[] = "$Id: fingerd.c,v 1.2 1996/05/30 08:44:11 deraadt Exp $";
d45 9
d55 2
d59 2
d67 1
a67 1
	register int ch;
d69 3
a71 1
	int p[2];
d73 1
a73 3
	char **ap, *av[ENTRIES + 1], line[1024], *strtok();
	int forward = 1, nvalid;
	int i, j, l;
d75 32
a106 4
#ifdef LOGGING					/* unused for now */
#include <netinet/in.h>
	struct sockaddr_in sin;
	int sval;
d108 11
a118 7
	sval = sizeof(sin);
	if (getpeername(0, &sin, &sval) < 0)
		fatal("getpeername");
#endif

	if (argc > 1 && strcmp(argv[1], "-s") == 0)
		forward = 0;
d122 5
a126 10

	av[0] = "finger";
	for (lp = line, ap = &av[1];;) {
		*ap = strtok(lp, " \t\r\n");
		if (!*ap)
			break;
		/* RFC742: "/[Ww]" == "-l" */
		if ((*ap)[0] == '/' && ((*ap)[1] == 'W' || (*ap)[1] == 'w'))
			*ap = "-l";
		if (++ap == av + ENTRIES)
d129 21
d151 1
d153 10
a162 11
	nvalid = 0;
	if (av[1] == NULL)
		nvalid = 1;
	for (i = 1; av[i];) {
		if (forward == 0 && strchr(av[i], '@@')) {
			/* no way, delete it! */
			for (j = i; av[j]; j++)
				av[j] = av[j+1];
			if (av[i])
				continue;
			break;
a163 8

		l = strlen(av[i]);
		while (av[i][l-1] == '@@')
			av[i][--l] = '\0';
		if (av[i][0] == '\0')
			av[i] = NULL;
		nvalid++;
		i++;
d167 1
a167 1
		fatal("pipe");
d169 1
a169 1
	switch(fork()) {
d171 1
a171 1
		(void)close(p[0]);
d173 2
a174 2
			(void)dup2(p[1], 1);
			(void)close(p[1]);
d176 2
a177 2
		if (nvalid)
			execv(_PATH_FINGER, av);
d180 1
a180 1
		fatal("fork");
d182 1
a182 1
	(void)close(p[1]);
d184 1
a184 1
		fatal("fdopen");
d193 14
a206 2
fatal(msg)
	char *msg;
d208 8
a215 4
	extern int errno;
	char *strerror();

	fprintf(stderr, "fingerd: %s: %s\r\n", msg, strerror(errno));
d217 1
@


1.2
log
@optimize something like "finger @@@@@@@@@@@@@@@@@@@@@@@@@@cvs@@@@@@@@@@@@cvs@@@@@@@@@@@@cvs' to hit
fewer hosts. Basically, chew @@ signs when possible.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.1.1.1 1995/10/18 08:43:15 deraadt Exp $";
d48 4
a51 1
main()
d59 2
a60 1
	int i;
d72 3
d91 12
a102 2
	for (i = 1; av[i]; i++) {
		int l = strlen(av[i]);
d104 1
d109 2
d123 2
a124 1
		execv(_PATH_FINGER, av);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: fingerd.c,v 1.2 1993/08/01 18:30:56 mycroft Exp $";
d56 1
d82 9
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
