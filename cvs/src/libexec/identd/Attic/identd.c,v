head	1.54;
access;
symbols
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.49.0.10
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.8
	OPENBSD_5_0:1.49.0.6
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.4
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.6
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.4
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.4
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.33.0.4
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2013.12.04.20.46.39;	author deraadt;	state dead;
branches;
next	1.53;

1.53
date	2013.03.11.21.24.24;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.11.17.40.10;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.09.17.40.57;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.06.07.05.40;	author jmc;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.20.20.37.43;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.24.02.33.05;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.26.02.46.29;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.25.14.21.30;	author jmc;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.26.07.38.38;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.28.21.43.36;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.06.22.05.22;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.16.08.25.05;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.14.22.14.29;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.28.01.05.21;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.07.18.31.17;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.13.01.31.39;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.17.02.53.36;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.16.10.36.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.16.10.24.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.16.10.21.20;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.16.10.16.10;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.22.20.34.31;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.12.19.45.09;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.12.18.45.17;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.07.17.08.28;	author mpech;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.07.08.13.31;	author mpech;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.17.19.54.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.12.17.53.16;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.08.07.02.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.15.23.48.15;	author hugh;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.13.20.16.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.28.21.48.31;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.28.19.34.28;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.17.19.48.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.18.04.43.28;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	99.07.20.22.40.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.16.20.22.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.06.10.03.49.40;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	97.08.09.22.59.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.06.19.22.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.06.10.24.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.01.19.08.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.29.07.49.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.20.36.27;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.03.41.14;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.07.25.09.50.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.54
log
@we now use the rewritten usr.sbin/identd
@
text
@/*	$OpenBSD: identd.c,v 1.53 2013/03/11 21:24:24 deraadt Exp $	*/

/*
 * This program is in the public domain and may be used freely by anyone
 * who wants to.
 *
 * Please send bug fixes/bug reports to: Peter Eriksson <pen@@lysator.liu.se>
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <poll.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <syslog.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

#include "identd.h"

extern char *__progname;

int	af = PF_UNSPEC;

int	verbose_flag;
int	debug_flag;
int	syslog_flag;
int	multi_flag;
int	unknown_flag;
int	number_flag;
int	noident_flag;
int	userident_flag;
int	token_flag;
int	no_user_token_flag;

int	lport;
int	fport;

const  char *opsys_name = "UNIX";
const  char *charset_sep = "";
char   *charset_name = "";

static pid_t child_pid;

void		usage(void);
void		sigchld(int);
char *		gethost(struct sockaddr_storage *ss);

void
usage(void)
{
	syslog(LOG_ERR,
	    "usage: %s [-46deHhlmNnoUv] [-b | -i | -w] [-a address] [-c charset] "
	    "[-p port] [-t seconds]", __progname);
	exit(2);
}

/*
 * Return the name of the connecting host, or the IP number as a string.
 */
char *
gethost4_addr(struct in_addr *addr)
{
	struct hostent *hp;

	hp = gethostbyaddr(addr, sizeof(struct in_addr), AF_INET);
	if (hp)
		return hp->h_name;
	return inet_ntoa(*addr);
}

char *
gethost(struct sockaddr_storage *ss)
{
	if (ss->ss_family == AF_INET6)
		return (gethost6((struct sockaddr_in6 *)ss));
	return (gethost4((struct sockaddr_in *)ss));
}

char *
gethost4(struct sockaddr_in *sin)
{
	struct hostent *hp;

	hp = gethostbyaddr(&sin->sin_addr, sizeof(struct in_addr), AF_INET);
	if (hp)
		return hp->h_name;
	return inet_ntoa(sin->sin_addr);
}

/*
 * Return the name of the connecting host, or the IP number as a string.
 */
char *
gethost6(struct sockaddr_in6 *addr)
{
	static char hbuf[2][NI_MAXHOST];
	const int niflags = NI_NUMERICHOST;
	static int bb = 0;
	int err;

	bb = (bb+1)%2;
	err = getnameinfo((struct sockaddr *)addr, addr->sin6_len,
	    hbuf[bb], sizeof(hbuf[bb]), NULL, 0, niflags);
	if (err != 0) {
		syslog(LOG_ERR, "getnameinfo failed (%s)", gai_strerror(err));
		strlcpy(hbuf[bb], "UNKNOWN", sizeof(hbuf[bb]));
	}
	return(hbuf[bb]);
}

volatile sig_atomic_t alarm_fired;

/*
 * Exit cleanly after our time's up.
 */
/* ARGSUSED */
static void
alarm_handler(int notused)
{
	alarm_fired = 1;
}

/*
 * Main entry point into this daemon
 */
int
main(int argc, char *argv[])
{
	struct sockaddr_storage sa, sa2;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	struct in_addr laddr, faddr;
	struct in6_addr laddr6, faddr6;
	struct passwd *pwd;
	struct pollfd *pfds = NULL;
	int	i, n = 0, background_flag = 0, timeout = 0, ch;
	char   *portno = "auth";
	char   *bind_address = NULL;
	uid_t   set_uid = 0;
	gid_t   set_gid = 0;
	extern char *optarg;
	socklen_t len;
	const char *errstr;

	openlog(__progname, LOG_PID, LOG_DAEMON);

	/* runs as _identd */
	if (getuid() == 0) {
		if ((pwd = getpwnam(DEFAULT_UID)) == NULL)
			error("no such user %s", DEFAULT_UID);
		set_uid = pwd->pw_uid;
		set_gid = pwd->pw_gid;
	}

	/*
	 * Parse the command line arguments
	 */
	while ((ch = getopt(argc, argv, "46hHbwit:p:a:u:g:c:loenvdmNU")) != -1) {
		switch (ch) {
		case '4':
			af = AF_INET;
			break;
		case '6':
			af = AF_INET6;
			break;
		case 'h':
			token_flag = 1;
			break;
		case 'H':
			no_user_token_flag = token_flag = 1;
			break;
		case 'b':	/* Start as standalone daemon */
			background_flag = 1;
			break;
		case 'w':	/* Start from Inetd, wait mode */
			background_flag = 2;
			break;
		case 'i':	/* Start from Inetd, nowait mode */
			background_flag = 0;
			break;
		case 't':
			timeout = strtonum(optarg, 0, 100000000, &errstr);
			if (errstr)
				error("timeout is %s: %s", errstr, optarg);
			break;
		case 'p':
			portno = optarg;
			break;
		case 'a':
			bind_address = optarg;
			break;
		case 'c':
			charset_name = optarg;
			charset_sep = " , ";
			break;
		case 'l':	/* Use the Syslog daemon for logging */
			syslog_flag++;
			break;
		case 'o':
			opsys_name = "OTHER";
			break;
		case 'e':
			unknown_flag = 1;
			break;
		case 'n':
			number_flag = 1;
			break;
		case 'v':	/* Be verbose */
			verbose_flag++;
			break;
		case 'd':	/* Enable debugging */
			debug_flag++;
			break;
		case 'm':	/* Enable multiline queries */
			multi_flag++;
			break;
		case 'N':	/* Enable users ".noident" files */
			noident_flag++;
			break;
		case 'U':	/* Enable user ".ident" files */
			userident_flag++;
			break;
		default:
			usage();
		}
	}

	/*
	 * Do the special handling needed for the "-b" flag
	 */
	if (background_flag == 1) {
		struct addrinfo hints, *res, *res0;
		int	true = 1;

		if (daemon(0, 0) != 0)
			exit(0);

		memset(&hints, 0, sizeof(hints));
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_family = af;
		hints.ai_flags = AI_PASSIVE;
		if (getaddrinfo(bind_address, portno, &hints, &res0) != 0)
			error("main: getaddrinfo");

		i = 0;
		for (res = res0; res; res = res->ai_next)
			i++;

		pfds = calloc(i, sizeof(pfds[0]));
		if (!pfds) {
			freeaddrinfo(res0);
			error("main: calloc");
		}

		i = 0;
		for (res = res0; res; res = res->ai_next) {
			if ((pfds[i].fd = socket(res->ai_family, res->ai_socktype,
			    res->ai_protocol)) < 0)
				continue;

			if (setsockopt(pfds[i].fd, SOL_SOCKET, SO_REUSEADDR,
			    (void *)&true, sizeof(true))) {
				close(pfds[i].fd);
				continue;
			}

#ifdef IPV6_V6ONLY
			if (res->ai_family == AF_INET6)
				(void)setsockopt(pfds[i].fd, IPPROTO_IPV6,
				    IPV6_V6ONLY, (void *)&true, sizeof(true));
#endif

			if (bind(pfds[i].fd, res->ai_addr, res->ai_addrlen)) {
				close(pfds[i].fd);
				continue;
			}

			if (listen(pfds[i].fd, 3)) {
				close(pfds[i].fd);
				continue;
			}

			pfds[i].events = POLLIN;
			i++;
		}
		freeaddrinfo(res0);

		if (i == 0)
			error("main: socket");

		n = i;
	}

	/*
	 * Do the special handling needed for the "-w" flag
	 */
	if (background_flag == 2) {
		pfds = calloc(1, sizeof(pfds[0]));
		if (!pfds)
			error("main: calloc");

		pfds[0].fd = 0;
		pfds[0].events = POLLIN;
		n = 1;
	}

	if (set_gid)
		if (setresgid(set_gid, set_gid, set_gid) == -1)
			error("main: setegid");
	if (set_uid)
		if (setresuid(set_uid, set_uid, set_uid) == -1)
			error("main: seteuid");
	/*
	 * Do some special handling if the "-b" or "-w" flags are used
	 */
	if (background_flag) {
		int	fd = 0;

		signal(SIGCHLD, sigchld);

		/*
		 * Loop and dispatch client handling processes
		 */
		do {
			/*
			 * Terminate if we've been idle for 'timeout' seconds
			 */
			if (background_flag == 2 && timeout) {
				signal(SIGALRM, alarm_handler);
				alarm(timeout);
			}

			/*
			 * Wait for a connection request to occur.
			 * Ignore EINTR (Interrupted System Call).
			 */
			do {
				if (alarm_fired) {
					if (syslog_flag)
						syslog(LOG_DEBUG,
						    "SIGALRM triggered, exiting");
					exit(0);
				}

				if (timeout)
					i = poll(pfds, n, timeout * 1000);
				else
					i = poll(pfds, n, INFTIM);
			} while (i < 0 && errno == EINTR);

			/*
			 * An error occurred in poll? Just die
			 */
			if (i < 0)
				error("main: poll");

			/*
			 * Timeout limit reached. Exit nicely
			 */
			if (i == 0)
				exit(0);

			/*
			 * Disable the alarm timeout
			 */
			alarm(0);

			for (i = 0; i < n; i++) {
				if ((pfds[i].revents & POLLIN) == 0)
					continue;

				/*
				 * Accept the new client
				 */
				fd = accept(pfds[i].fd, NULL, NULL);
				if (fd == -1) {
					if (errno == EWOULDBLOCK ||
					    errno == EINTR ||
					    errno == ECONNABORTED)
						continue;
					error("main: accept. errno = %d", errno);
				}

				/*
				 * Fork a child, parent continues
				 */
				child_pid = fork();
				if (child_pid == 0)
					break;

				close(fd);
			}
		} while (child_pid != 0);

		/*
		 * We are now in child, the parent has returned to "do" above.
		 */
		if (dup2(fd, 0) == -1)
			error("main: dup2: failed fd 0");

		if (dup2(fd, 1) == -1)
			error("main: dup2: failed fd 1");

		if (dup2(fd, 2) == -1)
			error("main: dup2: failed fd 2");
	}

	/*
	 * Get foreign internet address
	 */
	len = sizeof(sa);
	if (getpeername(0, (struct sockaddr *) &sa, &len) == -1) {
		/*
		 * A user has tried to start us from the command line or
		 * the network link died, in which case this message won't
		 * reach to other end anyway, so lets give the poor user some
		 * errors.
		 */
		perror("identd: getpeername()");
		exit(1);
	}
	if (sa.ss_family == AF_INET6) {
		sin6 = (struct sockaddr_in6 *)&sa;
		faddr6 = sin6->sin6_addr;
	} else {
		sin = (struct sockaddr_in *)&sa;
		faddr = sin->sin_addr;
	}

	/*
	 * Open the connection to the Syslog daemon if requested
	 */
	if (syslog_flag)
		syslog(LOG_INFO, "Connection from %s", gethost(&sa));

	/*
	 * Get local internet address
	 */
	len = sizeof(sa2);
	if (getsockname(0, (struct sockaddr *) &sa2, &len) == -1) {
		/*
		 * We can just die here, because if this fails then the
		 * network has died and we haven't got anyone to return
		 * errors to.
		 */
		exit(1);
	}
	/* are we v4 or v6? */
	if (sa2.ss_family == AF_INET6) {
		sin6 = (struct sockaddr_in6 *)&sa2;
		laddr6 = sin6->sin6_addr;
		/*
		 * Get the local/foreign port pair from the luser
		 */
		parse6(STDIN_FILENO, (struct sockaddr_in6 *)&sa2,
		    (struct sockaddr_in6 *)&sa);
	} else {
		sin = (struct sockaddr_in *)&sa2;
		laddr = sin->sin_addr;
		/*
		 * Get the local/foreign port pair from the luser
		 */
		parse(STDIN_FILENO, &laddr, &faddr);
	}

	exit(0);
}

void
error(char *fmt, ...)
{
	va_list ap, ap2;

	va_start(ap, fmt);
	
	if (syslog_flag) {
		va_copy(ap2, ap);
		vsyslog(LOG_ERR, fmt, ap2);
		va_end(ap2);
	}
	if (debug_flag) {
		fprintf(stderr, "%d , %d : ERROR : X-DBG : ", lport, fport);
		vfprintf(stderr, fmt, ap);
		perror(": ");
	} else
		printf("%d , %d : ERROR : UNKNOWN-ERROR\r\n", lport, fport);
	va_end(ap);
	exit(1);
}

void
sigchld(int signo)
{
	pid_t pid;

	do {
	    pid = waitpid(-1, NULL, WNOHANG);
	} while (pid > 0 || (pid == -1 && errno == EINTR));
}
@


1.53
log
@Report -u and -g support; running as another privdrop user or group is stupid.
ok millert  guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.52 2013/03/11 17:40:10 deraadt Exp $	*/
@


1.52
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.51 2013/03/09 17:40:57 deraadt Exp $	*/
d70 1
a70 1
	    "[-g gid] [-p port] [-t seconds] [-u uid]", __progname);
a151 1
	struct group *grp;
a208 28
		case 'u':
			pwd = getpwnam(optarg);
			if (pwd == NULL && isdigit(optarg[0])) {
				set_uid = atoi(optarg);
				if ((pwd = getpwuid(set_uid)) == NULL)
					break;
			}
			if (pwd == NULL)
				error("no such user (%s) for -u option",
				    optarg);
			else {
				set_uid = pwd->pw_uid;
				if (set_gid == 0)
					set_gid = pwd->pw_gid;
			}
			break;
		case 'g':
			grp = getgrnam(optarg);
			if (grp == NULL && isdigit(optarg[0])) {
				set_gid = atoi(optarg);
				break;
			}
			grp = getgrnam(optarg);
			if (!grp)
				error("no such group (%s) for -g option", optarg);
			else
				set_gid = grp->gr_gid;
			break;
d324 2
a325 2
	if (set_gid) {
		if (setegid(set_gid) == -1)
d327 2
a328 5
		if (setgid(set_gid) == -1)
			error("main: setgid");
	}
	if (set_uid) {
		if (seteuid(set_uid) == -1)
a329 4
		if (setuid(set_uid) == -1)
			error("main: setuid");
	}

@


1.51
log
@Code has not fallen back to "nobody" in a very long time;
jca at wxcvbn.org
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.50 2012/12/04 02:24:47 deraadt Exp $	*/
d429 5
a433 1
				if (fd == -1)
d435 1
@


1.50
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.49 2010/06/06 07:05:40 jmc Exp $	*/
d165 1
a165 1
	/* runs as _identd if possible, fallback to "nobody" */
@


1.49
log
@add -H to synopsis/usage(); from Rod Whitworth
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.48 2009/05/20 20:37:43 thib Exp $	*/
a10 1
#include <sys/param.h>
@


1.48
log
@Do not fall back to using nobody if _user is missing, but
error out.

Add a new user _rwalld for rpc.rwalld, and use that instead
of nobody, also unconditionally drop to _rwalld not only
if rpc.rwalld was started with euid 0 (as root).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.46 2007/09/26 02:46:29 ray Exp $	*/
d70 1
a70 1
	    "usage: %s [-46dehlmNnoUv] [-b | -i | -w] [-a address] [-c charset] "
@


1.47
log
@IPv6 support for standalone mode with assistance from millert@@ and deraadt@@
Tested by brad@@ and sobrado@@

ok deraadt@@
@
text
@d169 1
a169 4
			pwd = getpwnam("nobody");
		if (pwd == NULL)
			error("no such user: neither %s nor nobody",
			    DEFAULT_UID);
@


1.46
log
@From Tamas TEVESZ:
- atoi -> strtonum with proper bounds check
- Use vfprintf and vsyslog in the appropriate places.

OK millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.45 2007/09/25 14:21:30 jmc Exp $	*/
d40 2
d70 1
a70 1
	    "usage: %s [-dehlmNnoUv] [-b | -i | -w] [-a address] [-c charset] "
a147 1
	/* struct sockaddr_in sin;*/
d154 2
a155 1
	int	background_flag = 0, timeout = 0, ch;
d180 1
a180 1
	while ((ch = getopt(argc, argv, "hHbwit:p:a:u:g:c:loenvdmNU")) != -1) {
d182 6
d282 2
a283 3
		struct sockaddr_in addr;
		struct servent *sp;
		int	fd;
d288 16
a303 3
		fd = socket(AF_INET, SOCK_STREAM, 0);
		if (fd == -1)
			error("main: socket");
d305 11
a315 2
		if (fd != 0)
			dup2(fd, 0);
d317 10
a326 1
		memset(&addr, 0, sizeof(addr));
d328 3
a330 14
		addr.sin_len = sizeof(struct sockaddr_in);
		addr.sin_family = AF_INET;
		if (bind_address == NULL)
			addr.sin_addr.s_addr = htonl(INADDR_ANY);
		else {
			if (inet_aton(bind_address, &addr.sin_addr) == 0) {
				struct hostent *hp;

				hp = gethostbyname(bind_address);
				if (!hp)
					error("no such address (%s) for -a switch",
					    bind_address);
				memcpy(&addr.sin_addr, hp->h_addr,
				    sizeof(addr.sin_addr));
a331 1
		}
d333 2
a334 7
		if (isdigit(portno[0]))
			addr.sin_port = htons(atoi(portno));
		else {
			sp = getservbyname(portno, "tcp");
			if (sp == NULL)
				error("main: getservbyname: %s", portno);
			addr.sin_port = sp->s_port;
d336 1
d338 2
a339 2
		if (bind(0, (struct sockaddr *) &addr, sizeof(addr)) < 0)
			error("main: bind");
d341 1
a341 2
		if (listen(0, 3) < 0)
			error("main: listen");
d343 14
d369 1
d374 1
a374 2
		int	nfds, fd;
		struct	pollfd pfd[1];
a401 3
				pfd[0].fd = 0;
				pfd[0].events = POLLIN;

d403 1
a403 1
					nfds = poll(pfd, 1, timeout * 1000);
d405 2
a406 2
					nfds = poll(pfd, 1, INFTIM);
			} while (nfds < 0 && errno == EINTR);
d411 1
a411 1
			if (nfds < 0)
d417 1
a417 1
			if (nfds == 0)
d425 17
a441 6
			/*
			 * Accept the new client
			 */
			fd = accept(0, NULL, NULL);
			if (fd == -1)
				error("main: accept. errno = %d", errno);
d443 3
a445 5
			/*
			 * And fork, then close the fd if we are the parent.
			 */
			child_pid = fork();
		} while (child_pid && (close(fd), 1));
d459 1
d500 1
a500 1
	/* are we V4 or V6? */
@


1.45
log
@- sort options and sync usage()
- kill some .Tn whilst here
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.44 2007/08/26 07:38:38 ray Exp $	*/
d160 1
d196 3
a198 1
			timeout = atoi(optarg);
d488 1
a488 1
		syslog(LOG_ERR, fmt, ap2);
d493 1
a493 1
		fprintf(stderr, fmt, ap);
@


1.44
log
@Fix some error messages and comments, from Brad.

OK otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.43 2007/06/28 21:43:36 millert Exp $	*/
d68 2
a69 2
	    "%s [-i | -w | -b] [-t seconds] [-u uid] [-g gid] [-p port] "
	    "[-a address] [-c charset] [-noelvmNUdh]", __progname);
@


1.43
log
@Add a SIGCHLD handler for background mode instead of doing waitpid()
at a single point in the event loop (which would always leave
a single zombie around after the first connection).
Also use daemon() instead of doing it by hand.  OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.42 2005/12/06 22:05:22 deraadt Exp $	*/
d321 1
a321 1
			error("main: setgid");
d327 1
a327 1
			error("main: setuid");
d374 1
a374 1
			 * An error occurred in select? Just die
d377 1
a377 1
				error("main: select");
d426 1
a426 1
		perror("in.identd: getpeername()");
@


1.42
log
@avoid variable aliasing
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.41 2004/11/17 01:47:20 itojun Exp $	*/
d61 1
d275 1
a275 8
		if (fork())
			exit(0);

		close(0);
		close(1);
		close(2);

		if (fork())
d338 2
a400 2
			while (waitpid(-1, NULL, WNOHANG) > 0)
				;
d496 10
@


1.41
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.40 2004/09/16 08:25:05 deraadt Exp $	*/
d80 1
a80 1
	hp = gethostbyaddr((char *) addr, sizeof(struct in_addr), AF_INET);
d99 1
a99 1
	hp = gethostbyaddr((char *)&sin->sin_addr, sizeof(struct in_addr), AF_INET);
d114 1
a114 1
	int error;
d117 1
a117 1
	error = getnameinfo((struct sockaddr *)addr, addr->sin6_len,
d119 2
a120 2
	if (error != 0) {
		syslog(LOG_ERR, "getnameinfo failed (%s)", gai_strerror(error));
@


1.40
log
@i hate macros with 50 , :? and ())()()((()())); otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.39 2004/09/14 22:14:29 deraadt Exp $	*/
a111 3
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a112 1
#endif
@


1.39
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.38 2004/08/08 19:32:45 deraadt Exp $	*/
d25 1
a36 1
#include "error.h"
d171 1
a171 1
			ERROR1("no such user: neither %s nor nobody",
d214 1
a214 1
				ERROR1("no such user (%s) for -u option",
d230 1
a230 1
				ERROR1("no such group (%s) for -g option", optarg);
d290 1
a290 1
			ERROR("main: socket");
d307 1
a307 1
					ERROR1("no such address (%s) for -a switch",
d319 1
a319 1
				ERROR1("main: getservbyname: %s", portno);
d324 1
a324 1
			ERROR("main: bind");
d327 1
a327 1
			ERROR("main: listen");
d331 1
a331 1
			ERROR("main: setgid");
d333 1
a333 1
			ERROR("main: setgid");
d337 1
a337 1
			ERROR("main: setuid");
d339 1
a339 1
			ERROR("main: setuid");
d385 1
a385 1
				ERROR("main: select");
d403 1
a403 1
				ERROR1("main: accept. errno = %d", errno);
d417 1
a417 1
			ERROR("main: dup2: failed fd 0");
d420 1
a420 1
			ERROR("main: dup2: failed fd 1");
d423 1
a423 1
			ERROR("main: dup2: failed fd 2");
d484 22
@


1.38
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.37 2004/04/07 14:09:35 aaron Exp $	*/
d135 1
@


1.37
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.36 2003/07/29 18:39:23 deraadt Exp $	*/
d40 7
a46 7
int     verbose_flag;
int     debug_flag;
int     syslog_flag;
int     multi_flag;
int     unknown_flag;
int     number_flag;
int     noident_flag;
d51 2
a52 2
int     lport;
int     fport;
d155 1
a155 1
	int     background_flag = 0, timeout = 0, ch;
d275 1
a275 1
		int     fd;
d344 1
a344 1
		int     nfds, fd;
@


1.36
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.35 2003/06/28 01:05:21 deraadt Exp $	*/
d179 1
a179 1
	while ((ch = getopt(argc, argv, "hHbwit:p:a:u:g:c:r:loenvdmNU")) != -1) {
@


1.35
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.34 2003/06/07 18:31:17 henning Exp $	*/
d144 1
a144 1
int 
@


1.34
log
@drop privileges to _identd by default and fall back to nobody in case of error
inspired by PR 3294 and a conversation with theo

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.33 2002/09/13 01:31:39 djm Exp $	*/
d59 3
@


1.33
log
@Add -H option to hide nonexistent users (useful on NAT gateways). ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.32 2002/07/17 02:53:36 deraadt Exp $	*/
d161 12
@


1.32
log
@whoops, wrong type
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.31 2002/07/16 10:36:10 deraadt Exp $	*/
d49 1
d164 1
a164 1
	while ((ch = getopt(argc, argv, "hbwit:p:a:u:g:c:r:loenvdmNU")) != -1) {
d168 3
@


1.31
log
@remove more junk
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.30 2002/07/16 10:24:04 deraadt Exp $	*/
d157 1
a157 1
	size_t len;
@


1.30
log
@let BSS work to our advantage
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.29 2002/07/16 10:21:20 deraadt Exp $	*/
a55 2
char   *indirect_host = NULL;
char   *indirect_password = NULL;
a216 3
			break;
		case 'r':
			indirect_host = optarg;
@


1.29
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.28 2002/07/16 10:16:10 deraadt Exp $	*/
d40 9
a48 9
int     verbose_flag = 0;
int     debug_flag = 0;
int     syslog_flag = 0;
int     multi_flag = 0;
int     unknown_flag = 0;
int     number_flag = 0;
int     noident_flag = 0;
int	userident_flag = 0;
int	token_flag = 0;
d50 2
a51 2
int     lport = 0;
int     fport = 0;
@


1.28
log
@minor cleanup, and toast -V
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.27 2002/06/22 20:34:31 deraadt Exp $	*/
d153 1
a153 1
	int     background_flag = 0, timeout = 0, len, ch;
d159 1
a159 1
	extern int optind;
@


1.27
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.26 2002/03/12 19:45:09 millert Exp $	*/
a37 1
extern char *version;
d66 1
a66 1
	    "[-a address] [-c charset] [-noelVvmNUdh]", __progname);
d115 1
a115 1
	static int bb=0; 
d117 1
a117 1
	
d146 1
a146 1
	/* 	struct sockaddr_in sin;*/
d165 1
a165 1
	while ((ch = getopt(argc, argv, "hbwit:p:a:u:g:c:r:loenVvdmNU")) != -1) {
a234 4
		case 'V':	/* Give version of this daemon */
			(void)fprintf(stderr, "[identd version %s]\r\n", version);
			exit(0);
			break;
d344 1
a344 1
			
@


1.26
log
@Fix typo that prevented user's gid in passwd entry from being applied;
Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.25 2002/03/12 18:45:17 millert Exp $	*/
d63 1
a63 1
usage()
d74 2
a75 3
char   *
gethost4_addr(addr)
	struct in_addr *addr;
d85 2
a86 3
char   *
gethost(ss)
	struct sockaddr_storage *ss;
d93 2
a94 3
char   *
gethost4(sin)
	struct sockaddr_in *sin;
d107 2
a108 3
char   *
gethost6(addr)
	struct sockaddr_in6 *addr;
d135 1
a135 1
alarm_handler()
d144 1
a144 3
main(argc, argv)
	int     argc;
	char   *argv[];
a145 1
	int     len;
d148 2
a149 2
	struct sockaddr_in * sin;
	struct sockaddr_in6 * sin6;
d154 1
a154 2
	int     background_flag = 0;
	int     timeout = 0;
a160 1
	int ch;
d432 1
a432 2
	}
	else {
d464 1
a464 2
	}
	else {
@


1.25
log
@1) user and group name may start with a number (though it is a bad idea).
   For the -u/-g flags do passwd/group file lookups first and then try
   as a numeric id.
2) Set the gid based on the uid's passwd file entry if there is one, just
   like we do with names.
Partially based on a patch from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.24 2002/01/07 17:08:28 mpech Exp $	*/
d210 1
a210 1
				if (setgid == 0)
@


1.24
log
@While I'm here (next issue):
o) __progname;
o) remove #define LOG_DAEMON;
o) use openlog() before syslog();
o) write $version to stderr;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.23 2002/01/07 08:13:31 mpech Exp $	*/
d199 2
a200 1
			if (isdigit(optarg[0])) {
d202 2
a203 1
				break;
d205 3
a207 3
			pwd = getpwnam(optarg);
			if (!pwd)
				ERROR1("no such user (%s) for -u option", optarg);
d215 2
a216 1
			if (isdigit(optarg[0])) {
@


1.23
log
@o) int -> {uid,gid}_t; %d -> %u;
o) int -> pid_t;

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.22 2001/11/17 19:54:56 deraadt Exp $	*/
d39 1
a61 4
#ifdef LOG_DAEMON
static int syslog_facility = LOG_DAEMON;
#endif

d66 2
a67 2
	    "identd [-i | -w | -b] [-t seconds] [-u uid] [-g gid] [-p port] "
	    "[-a address] [-c charset] [-noelVvmNUdh]");
a70 1

d171 1
d243 1
a243 1
			printf("[identd version %s]\r\n", version);
d447 1
a447 6
	if (syslog_flag) {
#ifdef LOG_DAEMON
		openlog("identd", LOG_PID, syslog_facility);
#else
		openlog("identd", LOG_PID);
#endif
d449 1
a449 1
	}
@


1.22
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.21 2001/09/19 10:58:07 mpech Exp $	*/
d59 1
a59 1
static int child_pid;
d169 2
a170 2
	int     set_uid = 0;
	int     set_gid = 0;
@


1.21
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.20 2001/08/12 17:53:16 fgsch Exp $	*/
d137 1
a137 1
sig_atomic_t alarm_fired;
@


1.20
log
@Use INFTIM where possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.19 2001/08/08 07:02:42 deraadt Exp $	*/
d381 1
a381 1
			 * An error occured in select? Just die
@


1.19
log
@split up the gethost*() functions a bit more, to make it more obvious what
is going on.  This could be improved further by always passing around
fat sockaddr's I think.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.18 2001/04/15 23:48:15 hugh Exp $	*/
d377 1
a377 1
					nfds = poll(pfd, 1, -1);
@


1.18
log
@Replace a bunch of conditional expressions with global pointers.
Requested and checked by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.17 2001/04/13 20:16:53 millert Exp $	*/
d79 1
a79 1
gethost(addr)
d90 21
d456 1
a456 1
		syslog(LOG_INFO, "Connection from %s", gethost(&faddr));
@


1.17
log
@Add support for user specified tokens to identd.  Based on a patch
from rjmooney@@wall.st w/ minor tweakage by Theo and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.16 2001/03/28 21:48:31 fgsch Exp $	*/
a43 1
int     other_flag = 0;
d53 3
a55 1
char   *charset_name = NULL;
d207 1
d216 1
a216 1
			other_flag = 1;
@


1.16
log
@Don't make poll exit right away; if timeout is 0 use -1 for poll.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.15 2001/01/28 19:34:28 niklas Exp $	*/
d48 1
d69 1
a69 1
	    "[-a address] [-c charset] [-noelVvmNdh]");
d156 1
a156 1
	while ((ch = getopt(argc, argv, "hbwit:p:a:u:g:c:r:loenVvdmN")) != -1) {
d223 1
a223 1
			printf("[in.identd, version %s]\r\n", version);
d237 3
@


1.15
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d347 4
a350 1
				nfds = poll(pfd, 1, timeout * 1000);
@


1.14
log
@avoid fd_set overflow by using poll(); avoid syslog() in signal handler by using flag checked in main loop
@
text
@d1 2
@


1.13
log
@add ipv6 support
@
text
@d21 1
d112 2
d120 1
a120 3
	if (syslog_flag)
		syslog(LOG_DEBUG, "SIGALRM triggered, exiting");
	exit(0);
a137 1
	struct timeval tv;
d316 1
a316 1
		fd_set  read_set;
d329 1
d335 9
a343 2
				FD_ZERO(&read_set);
				FD_SET(0, &read_set);
d345 1
a345 6
				if (timeout) {
					tv.tv_sec = timeout;
					tv.tv_usec = 0;
					nfds = select(1, &read_set, NULL, NULL, &tv);
				} else
					nfds = select(1, &read_set, NULL, NULL, NULL);
@


1.12
log
@bad arguments? usage() should syslog()
@
text
@d82 27
a108 2
	else
		return inet_ntoa(*addr);
d131 4
a134 1
	struct sockaddr_in sin;
d136 1
d392 2
a393 2
	len = sizeof(sin);
	if (getpeername(0, (struct sockaddr *) &sin, &len) == -1) {
d403 8
a410 1
	faddr = sin.sin_addr;
d426 2
a427 2
	len = sizeof(sin);
	if (getsockname(0, (struct sockaddr *) &sin, &len) == -1) {
d435 18
a452 1
	laddr = sin.sin_addr;
a453 4
	/*
	 * Get the local/foreign port pair from the luser
	 */
	parse(STDIN_FILENO, &laddr, &faddr);
@


1.11
log
@change to using getopt() [some inetd.conf files will need repair];
add usage()
and add token support via -h (token information is sysloged)
@
text
@d8 11
d25 1
a28 9

#include <sys/types.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/wait.h>

a31 6
#include <netinet/in.h>

#include <arpa/inet.h>

extern int errno;

d63 4
a66 4
	fprintf(stderr,
	    "identd [-i | -w | -b] [-t seconds] [-u uid] [-g gid] [-p port]\n"
	    "\t[-a address] [-c charset] [-noelVvmNdh]\n");
	exit(1);
@


1.10
log
@Now uses TCPCTL_IDENT sysctl to get uid associated with a connection
instead of kmem. Kmem parsing functions and options removed.
@
text
@d48 1
d63 10
d108 1
a108 1
	int     i, len;
d120 3
a122 1
	int     opt_count = 0;	/* Count of option flags */
d127 5
a131 3
	for (i = 1; i < argc && argv[i][0] == '-'; i++) {
		opt_count++;
		switch (argv[i][1]) {
d142 1
a142 1
			timeout = atoi(argv[i] + 2);
d145 1
a145 1
			portno = argv[i] + 2;
d148 1
a148 1
			bind_address = argv[i] + 2;
d151 2
a152 2
			if (isdigit(argv[i][2])) {
				set_uid = atoi(argv[i] + 2);
d155 1
a155 1
			pwd = getpwnam(argv[i] + 2);
d157 1
a157 1
				ERROR1("no such user (%s) for -u option", argv[i] + 2);
d161 1
a161 1
				  set_gid = pwd->pw_gid;
d165 2
a166 2
			if (isdigit(argv[i][2])) {
				set_gid = atoi(argv[i] + 2);
d169 1
a169 1
			grp = getgrnam(argv[i] + 2);
d171 1
a171 1
				ERROR1("no such group (%s) for -g option", argv[i] + 2);
d176 1
a176 1
			charset_name = argv[i] + 2;
d179 1
a179 1
			indirect_host = argv[i] + 2;
d209 2
d251 4
a254 3
					ERROR1("no such address (%s) for -a switch", bind_address);

				memcpy(&addr.sin_addr, hp->h_addr, sizeof(addr.sin_addr));
@


1.9
log
@Using stdio on sockets is gross so don't do it.  Also some -Wall.
@
text
@a39 3
char   *path_unix = NULL;
char   *path_kmem = NULL;

d105 1
a105 1
	char   *portno = "113";
d145 2
a146 1
				set_gid = pwd->pw_gid;
a195 18

	/*
	 * Path to kernel namelist file specified on command line
	 */
	if (i < argc)
		path_unix = argv[i++];

	/*
	 * Path to kernel memory device specified on command line
	 */
	if (i < argc)
		path_kmem = argv[i++];

	/*
	 * Open the kernel memory device and read the nlist table
	 */
	if (k_open() < 0)
		ERROR("main: k_open");
@


1.8
log
@indent
@
text
@d9 1
d16 1
d269 1
a269 1
		if (bind(0, (struct sockaddr *) & addr, sizeof(addr)) < 0)
d369 1
a369 1
	if (getpeername(0, (struct sockaddr *) & sin, &len) == -1) {
d396 1
a396 1
	if (getsockname(0, (struct sockaddr *) & sin, &len) == -1) {
d409 1
a409 1
	parse(stdin, &laddr, &faddr);
@


1.7
log
@reindent and remove extra crud. a program that is security sensitive must be readable
@
text
@d102 2
a103 1

a120 1

a123 1

a126 1

a129 1

a132 1

a135 1

d137 1
a137 1
			if (isdigit(argv[i][2]))
d139 5
d145 2
a146 9
				struct passwd *pwd;

				pwd = getpwnam(argv[i] + 2);
				if (!pwd)
					ERROR1("no such user (%s) for -u option", argv[i] + 2);
				else {
					set_uid = pwd->pw_uid;
					set_gid = pwd->pw_gid;
				}
a148 1

d150 1
a150 1
			if (isdigit(argv[i][2]))
d152 1
a152 8
			else {
				struct group *grp;

				grp = getgrnam(argv[i] + 2);
				if (!grp)
					ERROR1("no such group (%s) for -g option", argv[i] + 2);
				else
					set_gid = grp->gr_gid;
d154 5
a159 1

a162 1

a165 1

a168 1

a171 1

a174 1

a177 1

a181 1

a184 1

a187 1

a190 1

a222 1

a291 1

a378 1

a387 1

@


1.6
log
@remove config trash
@
text
@d2 5
a6 23
**	$Id: identd.c,v 1.5 1997/07/29 07:49:31 deraadt Exp $
**
** identd.c			  A TCP/IP link identification protocol server
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 22 April 1993
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@@lysator.liu.se>
*/

#if defined(IRIX) || defined(SVR4) || defined(NeXT) || defined(__NetBSD__) || \
	defined(__OpenBSD__)
#  define SIGRETURN_TYPE void
#  define SIGRETURN_TYPE_IS_VOID
#else
#  define SIGRETURN_TYPE int
#endif

#ifdef SVR4
#  define STRNET
#endif
d20 1
a20 3
#ifndef _AUX_SOURCE
#  include <sys/file.h>
#endif
d29 1
a29 3
#ifndef HPUX7
#  include <arpa/inet.h>
#endif
a30 1
#if defined(MIPS) || defined(BSD43)
a31 1
#endif
a35 16
/* Antique unixes do not have these things defined... */
#ifndef FD_SETSIZE
#  define FD_SETSIZE 256
#endif

#ifndef FD_SET
#  ifndef NFDBITS
#    define NFDBITS   	(sizeof(int) * NBBY)  /* bits per mask */
#  endif
#  define FD_SET(n, p)  ((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#endif

#ifndef FD_ZERO
#  define FD_ZERO(p)	    bzero((char *)(p), sizeof(*(p)))
#endif

d38 2
a39 3
extern void *calloc();
extern void *malloc();

d41 15
a55 18
char *path_unix = NULL;
char *path_kmem = NULL;

int verbose_flag = 0;
int debug_flag   = 0;
int syslog_flag  = 0;
int multi_flag   = 0;
int other_flag   = 0;
int unknown_flag = 0;
int number_flag  = 0;
int noident_flag = 0;

int lport = 0;
int fport = 0;

char *charset_name = NULL;
char *indirect_host = NULL;
char *indirect_password = NULL;
d64 5
a68 37
** The structure passing convention for GCC is incompatible with
** Suns own C compiler, so we define our own inet_ntoa() function.
** (This should only affect GCC version 1 I think, a well, this works
** for version 2 also so why bother.. :-)
*/
#if defined(__GNUC__) && defined(__sparc__)

#ifdef inet_ntoa
#undef inet_ntoa
#endif

char *inet_ntoa(ad)
  struct in_addr ad;
{
  unsigned long int s_ad;
  int a, b, c, d;
  static char addr[20];
  
  s_ad = ad.s_addr;
  d = s_ad % 256;
  s_ad /= 256;
  c = s_ad % 256;
  s_ad /= 256;
  b = s_ad % 256;
  a = s_ad / 256;
  sprintf(addr, "%d.%d.%d.%d", a, b, c, d);
  
  return addr;
}
#endif


/*
** Return the name of the connecting host, or the IP number as a string.
*/
char *gethost(addr)
  struct in_addr *addr;
d70 1
a70 1
  struct hostent *hp;
d72 5
a76 6
  
  hp = gethostbyaddr((char *) addr, sizeof(struct in_addr), AF_INET);
  if (hp)
    return hp->h_name;
  else
    return inet_ntoa(*addr);
d80 3
a82 3
** Exit cleanly after our time's up.
*/
static SIGRETURN_TYPE
d85 3
a87 4
  if (syslog_flag)
    syslog(LOG_DEBUG, "SIGALRM triggered, exiting");
  
  exit(0);
a89 1
#if !defined(hpux) && !defined(__hpux) && !defined(SVR4) || defined(_CRAY)
d91 6
a96 5
** This is used to clean up zombie child processes
** if the -w or -b options are used.
*/
static SIGRETURN_TYPE
child_handler()
d98 119
a216 16
#if defined(IRIX) || defined(NeXT)
  union wait status;
#else
  int status;
#endif
  int save_errno = errno;

  while (wait3(&status, WNOHANG, NULL) > 0)
    ;
  
  errno = save_errno;
#ifndef SIGRETURN_TYPE_IS_VOID
  return 0;
#endif
}
#endif
d218 70
d289 2
a290 5
char *clearmem(bp, len)
  char *bp;
  int len;
{
  char *cp;
d292 87
a378 6
  cp = bp;
  while (len-- > 0)
    *cp++ = 0;

  return bp;
}
d380 2
d383 2
a384 70
/*
** Main entry point into this daemon
*/
int main(argc,argv)
  int argc;
  char *argv[];
{
  int i, len;
  struct sockaddr_in sin;
  struct in_addr laddr, faddr;
  struct timeval tv;

  int background_flag = 0;
  int timeout = 0;
  char *portno = "113";
  char *bind_address = NULL;
  int set_uid = 0;
  int set_gid = 0;
  int opt_count = 0;		/* Count of option flags */
  
#ifdef __convex__
  argc--;    /* get rid of extra argument passed by inetd */
#endif

  /*
  ** Parse the command line arguments
  */
  for (i = 1; i < argc && argv[i][0] == '-'; i++) {
    opt_count++;
    switch (argv[i][1])
    {
      case 'b':    /* Start as standalone daemon */
	background_flag = 1;
	break;

      case 'w':    /* Start from Inetd, wait mode */
	background_flag = 2;
	break;

      case 'i':    /* Start from Inetd, nowait mode */
	background_flag = 0;
	break;

      case 't':
	timeout = atoi(argv[i]+2);
	break;

      case 'p':
	portno = argv[i]+2;
	break;

      case 'a':
	bind_address = argv[i]+2;
	break;
	  
      case 'u':
	if (isdigit(argv[i][2]))
	  set_uid = atoi(argv[i]+2);
	else
 	{
	  struct passwd *pwd;

	  pwd = getpwnam(argv[i]+2);
	  if (!pwd)
	    ERROR1("no such user (%s) for -u option", argv[i]+2);
	  else
	  {
	    set_uid = pwd->pw_uid;
	    set_gid = pwd->pw_gid;
	  }
d386 13
a398 14
	break;
	
      case 'g':
	if (isdigit(argv[i][2]))
	  set_gid = atoi(argv[i]+2);
	else
 	{
	  struct group *grp;

	  grp = getgrnam(argv[i]+2);
	  if (!grp)
	    ERROR1("no such group (%s) for -g option", argv[i]+2);
	  else
	    set_gid = grp->gr_gid;
d400 1
a400 1
	break;
a401 28
      case 'c':
	charset_name = argv[i]+2;
	break;

      case 'r':
	indirect_host = argv[i]+2;
	break;

      case 'l':    /* Use the Syslog daemon for logging */
	syslog_flag++;
	break;

      case 'o':
	other_flag = 1;
	break;

      case 'e':
	unknown_flag = 1;
	break;

      case 'n':
	number_flag = 1;
	break;
       
      case 'V':    /* Give version of this daemon */
	printf("[in.identd, version %s]\r\n", version);
	exit(0);
	break;
d403 8
a410 30
      case 'v':    /* Be verbose */
	verbose_flag++;
	break;
	  
      case 'd':    /* Enable debugging */
	debug_flag++;
	break;

      case 'm':    /* Enable multiline queries */
	multi_flag++;
	break;

      case 'N':    /* Enable users ".noident" files */
	noident_flag++;
	break;
    }
  }
  
#if defined(_AUX_SOURCE) || defined (SUNOS35)
  /* A/UX 2.0* & SunOS 3.5 calls us with an argument XXXXXXXX.YYYY
  ** where XXXXXXXXX is the hexadecimal version of the callers
  ** IP number, and YYYY is the port/socket or something.
  ** It seems to be impossible to pass arguments to a daemon started
  ** by inetd.
  **
  ** Just in case it is started from something else, then we only
  ** skip the argument if no option flags have been seen.
  */
  if (opt_count == 0)
    argc--;
d413 13
a425 147
  /*
  ** Path to kernel namelist file specified on command line
  */
  if (i < argc)
    path_unix = argv[i++];

  /*
  ** Path to kernel memory device specified on command line
  */
  if (i < argc)
    path_kmem = argv[i++];


  /*
  ** Open the kernel memory device and read the nlist table
  */
  if (k_open() < 0)
      ERROR("main: k_open");

  /*
  ** Do the special handling needed for the "-b" flag
  */
  if (background_flag == 1)
  {
    struct sockaddr_in addr;
    struct servent *sp;
    int fd;

    
    if (fork())
      exit(0);

    close(0);
    close(1);
    close(2);

    if (fork())
      exit(0);
    
    fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd == -1)
      ERROR("main: socket");
    
    if (fd != 0)
      dup2(fd, 0);

    clearmem(&addr, sizeof(addr));
    
    addr.sin_len = sizeof(struct sockaddr_in);
    addr.sin_family = AF_INET;
    if (bind_address == NULL)
      addr.sin_addr.s_addr = htonl(INADDR_ANY);
    else
    {
      if (inet_aton(bind_address, &addr.sin_addr) == 0)
      {
	struct hostent *hp;

	hp = gethostbyname(bind_address);
	if (!hp)
	  ERROR1("no such address (%s) for -a switch", bind_address);

	memcpy(&addr.sin_addr, hp->h_addr, sizeof(addr.sin_addr));
      }
    }

    if (isdigit(portno[0]))
      addr.sin_port = htons(atoi(portno));
    else
    {
      sp = getservbyname(portno, "tcp");
      if (sp == NULL)
	ERROR1("main: getservbyname: %s", portno);
      addr.sin_port = sp->s_port;
    }
    
    if (bind(0, (struct sockaddr *) &addr, sizeof(addr)) < 0)
      ERROR("main: bind");

    if (listen(0, 3) < 0)
      ERROR("main: listen");
  }
  
  if (set_gid) {
    if (setegid(set_gid) == -1)
      ERROR("main: setgid");
    if (setgid(set_gid) == -1)
      ERROR("main: setgid");
  }
  
  if (set_uid) {
    if (seteuid(set_uid) == -1)
      ERROR("main: setuid");
    if (setuid(set_uid) == -1)
      ERROR("main: setuid");
  }

  /*
  ** Do some special handling if the "-b" or "-w" flags are used
  */
  if (background_flag)
  {
    int nfds, fd;
    fd_set read_set;


    /*
    ** Set up the SIGCHLD signal child termination handler so
    ** that we can avoid zombie processes hanging around and
    ** handle childs terminating before being able to complete the
    ** handshake.
    */
#if (defined(SVR4) || defined(hpux) || defined(__hpux) || \
     defined(_CRAY) || defined(_AUX_SOURCE))
    signal(SIGCHLD, SIG_IGN);
#else
    signal(SIGCHLD, (SIGRETURN_TYPE (*)()) child_handler);
#endif
    
    /*
    ** Loop and dispatch client handling processes
    */
    do
    {
      /*
      ** Terminate if we've been idle for 'timeout' seconds
      */
      if (background_flag == 2 && timeout)
      {
	signal(SIGALRM, alarm_handler);
	alarm(timeout);
      }
      
      /*
      ** Wait for a connection request to occur.
      ** Ignore EINTR (Interrupted System Call).
      */
      do
      {
	FD_ZERO(&read_set);
	FD_SET(0, &read_set);

	if (timeout)
	{
	  tv.tv_sec = timeout;
	  tv.tv_usec = 0;
	  nfds = select(FD_SETSIZE, &read_set, NULL, NULL, &tv);
d427 1
a427 4
	else

	nfds = select(FD_SETSIZE, &read_set, NULL, NULL, NULL);
      } while (nfds < 0  && errno == EINTR);
d429 4
a432 10
      /*
      ** An error occured in select? Just die
      */
      if (nfds < 0)
	ERROR("main: select");

      /*
      ** Timeout limit reached. Exit nicely
      */
      if (nfds == 0)
a433 92
      
      /*
      ** Disable the alarm timeout
      */
      alarm(0);
      
      /*
      ** Accept the new client
      */
      fd = accept(0, NULL, NULL);
      if (fd == -1)
	ERROR1("main: accept. errno = %d", errno);
      
      /*
      ** And fork, then close the fd if we are the parent.
      */
      child_pid = fork();
    } while (child_pid && (close(fd), 1));

    /*
    ** We are now in child, the parent has returned to "do" above.
    */
    if (dup2(fd, 0) == -1)
      ERROR("main: dup2: failed fd 0");
    
    if (dup2(fd, 1) == -1)
      ERROR("main: dup2: failed fd 1");
    
    if (dup2(fd, 2) == -1)
      ERROR("main: dup2: failed fd 2");
  }

  /*
  ** Get foreign internet address
  */
  len = sizeof(sin);
  if (getpeername(0, (struct sockaddr *) &sin, &len) == -1)
  {
    /*
    ** A user has tried to start us from the command line or
    ** the network link died, in which case this message won't
    ** reach to other end anyway, so lets give the poor user some
    ** errors.
    */
    perror("in.identd: getpeername()");
    exit(1);
  }
  
  faddr = sin.sin_addr;


  /*
  ** Open the connection to the Syslog daemon if requested
  */
  if (syslog_flag)
  {
#ifdef LOG_DAEMON
    openlog("identd", LOG_PID, syslog_facility);
#else
    openlog("identd", LOG_PID);
#endif
    
    syslog(LOG_INFO, "Connection from %s", gethost(&faddr));
  }
  

  /*
  ** Get local internet address
  */
  len = sizeof(sin);
#ifdef ATTSVR4
  if (t_getsockname(0, (struct sockaddr *) &sin, &len) == -1)
#else
  if (getsockname(0, (struct sockaddr *) &sin, &len) == -1)
#endif
  {
    /*
    ** We can just die here, because if this fails then the
    ** network has died and we haven't got anyone to return
    ** errors to.
    */
    exit(1);
  }
  laddr = sin.sin_addr;


  /*
  ** Get the local/foreign port pair from the luser
  */
  parse(stdin, &laddr, &faddr);

  exit(0);
@


1.5
log
@wrap wait3 with save_errno
@
text
@d2 1
a2 1
**	$Id: identd.c,v 1.4 1997/07/23 20:36:27 kstailey Exp $
a225 1
  int inhibit_default_config = 0;
a231 14
  /*
  ** Prescan the arguments for "-f<config-file>" switches
  */
  inhibit_default_config = 0;
  for (i = 1; i < argc && argv[i][0] == '-'; i++)
    if (argv[i][1] == 'f')
      inhibit_default_config = 1;

  /*
  ** Parse the default config file - if it exists
  */
  if (!inhibit_default_config)
    parse_config(NULL, 1);
  
@


1.4
log
@tabify
@
text
@d2 1
a2 1
**	$Id: identd.c,v 1.3 1996/12/22 03:41:14 tholo Exp $
d181 1
d186 1
@


1.3
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d2 1
a2 1
**	$Id: identd.c,v 1.2 1996/07/25 09:50:02 deraadt Exp $
d4 1
a4 1
** identd.c                       A TCP/IP link identification protocol server
d73 1
a73 1
#  define FD_ZERO(p)        bzero((char *)(p), sizeof(*(p)))
d253 1
a253 1
        background_flag = 1;
@


1.2
log
@openbsd
@
text
@d2 1
a2 1
**	$Id: identd.c,v 1.1.1.1 1995/10/18 08:43:18 deraadt Exp $
d453 3
a455 1
  if (set_gid)
d458 1
d460 3
a462 1
  if (set_uid)
d465 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
**	$Id: identd.c,v 1.5 1995/06/07 17:14:21 cgd Exp $
d14 2
a15 1
#if defined(IRIX) || defined(SVR4) || defined(NeXT) || defined(__NetBSD__)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
