head	1.48;
access;
symbols
	OPENBSD_5_4:1.46.0.22
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.20
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.18
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.16
	OPENBSD_5_0:1.46.0.14
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.12
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.10
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.6
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.46.0.8
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.43.0.6
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.43.0.4
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2013.12.04.20.46.39;	author deraadt;	state dead;
branches;
next	1.47;

1.47
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.26.02.50.36;	author ray;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.21.03.32.28;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.06.22.05.22;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.04.08.55.36;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.04.18.19.26;	author moritz;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.16.08.25.05;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.28.01.05.21;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.25.11.08.18;	author mpech;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.13.01.31.39;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.24.23.11.14;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.16.10.32.37;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.16.10.21.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.16.10.16.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.22.20.34.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.07.08.13.31;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.01.18.54.43;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.08.07.02.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.08.06.46.09;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.16.00.26.21;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.15.23.48.16;	author hugh;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.14.02.49.19;	author hugh;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.13.20.16.53;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.28.19.34.29;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.10.12.37.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.18.04.43.28;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	99.12.18.08.06.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.08.06.17.35.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.07.04.01.07.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.09.16.20.22.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.07.10.08.06.06;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.06.10.03.49.43;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	97.10.15.00.59.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.10.20.56.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.21.17.38.34;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.11.23.12.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.11.23.09.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.09.22.59.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.06.10.24.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.08.01.19.32.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.20.36.28;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.18.22.15.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@we now use the rewritten usr.sbin/identd
@
text
@/*	$OpenBSD: parse.c,v 1.47 2013/11/27 21:25:25 deraadt Exp $	*/

/*
 * This program is in the public domain and may be used freely by anyone
 * who wants to.
 *
 * Please send bug fixes/bug reports to: Peter Eriksson <pen@@lysator.liu.se>
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <stdio.h>
#include <poll.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <ctype.h>
#include <pwd.h>
#include <unistd.h>

#include "identd.h"

#define IO_TIMEOUT	30	/* Timeout I/O operations after N seconds */

int check_noident(char *);
ssize_t timed_read(int, void *, size_t, time_t);
ssize_t timed_write(int, const void *, size_t, time_t);
int getuserident(char *homedir, char *buf, int len);
void gentoken(char *, int);

/*
 * A small routine to check for the existence of the ".noident"
 * file in a users home directory.
 */
int
check_noident(char *homedir)
{
	char   path[MAXPATHLEN];
	struct stat st;
	int n;

	if (!homedir)
		return 0;
	if ((n = snprintf(path, sizeof(path), "%s/.noident", homedir))
	    >= sizeof(path) || n < 0)
		return 0;
	if (stat(path, &st) == 0)
		return 1;
	return 0;
}

/*
 * A small routine to check for the existence of the ".ident"
 * file in a users home directory, and return its contents.
 */
int
getuserident(char *homedir, char *buf, int len)
{
	char   path[MAXPATHLEN];
	int    fd, nread, n;
	struct stat st;

	if (len == 0)
		return 0;
	if (!homedir)
		return 0;
	if ((n = snprintf(path, sizeof path, "%s/.ident", homedir))
	    >= sizeof(path) || n < 0)
		return 0;
	if ((fd = open(path, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0)) < 0)
		return 0;
	if (fstat(fd, &st) != 0 || !S_ISREG(st.st_mode)) {
		close(fd);
		return 0;
	}

	if ((nread = read(fd, buf, len - 1)) <= 0) {
		close(fd);
		return 0;
	}
	buf[nread] = '\0';

	/* remove illegal characters */
	buf[strcspn(buf, "\r\n")] = '\0';

	close(fd);
	return 1;
}

static char token0cnv[] = "abcdefghijklmnopqrstuvwxyz";
static char tokencnv[] = "abcdefghijklmnopqrstuvwxyz0123456789";

void
gentoken(char *buf, int len)
{
	char *p;

	if (len == 0)
		return;
	for (p = buf; len > 1; p++, len--) {
		if (p == buf)
			*p = token0cnv[arc4random_uniform(sizeof(token0cnv)-1)];
		else
			*p = tokencnv[arc4random_uniform(sizeof(tokencnv)-1)];
	}
	*p = '\0';
}

/*
 * Returns 0 on timeout, -1 on error, #bytes read on success.
 */
ssize_t
timed_read(int fd, void *buf, size_t siz, time_t timeout)
{
	struct timeval tv, start, after, duration, tmp;
	int err, tot = 0, i, r;
	struct pollfd rfd[1];
	char *p = buf;

	tv.tv_sec = timeout;
	tv.tv_usec = 0;

	while (1) {
		rfd[0].fd = fd;
		rfd[0].events = POLLIN;
		rfd[0].revents = 0;

		gettimeofday(&start, NULL);
		if ((err = poll(rfd, 1, tv.tv_sec * 1000 +
		    tv.tv_usec / 1000)) <= 0)
			return err;
		r = read(fd, p, siz - tot);
		if (r == -1 || r == 0)
			return (r);
		for (i = 0; i < r; i++)
			if (p[i] == '\r' || p[i] == '\n') {
				tot += r;
				return (tot);
			}
		gettimeofday(&after, NULL);
		timersub(&start, &after, &duration);
		timersub(&tv, &duration, &tmp);
		tv = tmp;
		if (tv.tv_sec < 0 || !timerisset(&tv))
			return (tot);
		tot += r;
		p += r;
	}
}

/*
 * Returns 0 on timeout, -1 on error, #bytes read on success.
 */
ssize_t
timed_write(int fd, const void *buf, size_t siz, time_t timeout)
{
	struct pollfd wfd[2];
	struct timeval tv;
	int err;

	wfd[0].fd = fd;
	wfd[0].events = POLLOUT;
	wfd[0].revents = 0;

	tv.tv_sec = timeout;
	tv.tv_usec = 0;

	if ((err = poll(wfd, 1, tv.tv_sec * 1000 +
	    tv.tv_usec / 1000)) <= 0)
		return err;
	return (write(fd, buf, siz));
}

int
parse(int fd, struct in_addr *laddr, struct in_addr *faddr)
{
	char	token[21], buf[BUFSIZ], *p;
	struct	in_addr laddr2, faddr2;
	struct	passwd *pw;
	uid_t	uid;
	int	n;

	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "In function parse(), from %s to %s",
		    gethost4_addr(faddr), gethost4_addr(laddr));

	faddr2 = *faddr;
	laddr2 = *laddr;
	lport = fport = 0;

	/* Read query from client */
	if ((n = timed_read(fd, buf, sizeof(buf) - 1, IO_TIMEOUT)) <= 0) {
		if (syslog_flag)
			syslog(LOG_NOTICE,
			    n ? "read from %s: %m" : "read from %s: EOF",
			    gethost4_addr(faddr));
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : UNKNOWN-ERROR\r\n", lport, fport))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}
	buf[n] = '\0';

	/* Pull out local and remote ports */
	p = buf;
	while (isspace((unsigned char)*p))
		p++;
	if ((p = strtok(p, " \t,"))) {
		lport = atoi(p);
		if ((p = strtok(NULL, " \t,")))
			fport = atoi(p);
	}

	if (lport < 1 || lport > 65535 || fport < 1 || fport > 65535) {
		if (syslog_flag)
			syslog(LOG_NOTICE,
			    "scanf: invalid-port(s): %d , %d from %s",
			    lport, fport, gethost4_addr(faddr));
		if ((n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" :
		    "INVALID-PORT")) >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}
	if (syslog_flag && verbose_flag)
		syslog(LOG_NOTICE, "request for (%d,%d) from %s",
		    lport, fport, gethost4_addr(faddr));

	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  After fscanf(), before k_getuid()");

	/*
	 * Next - get the specific TCP connection and return the
	 * uid - user number.
	 */
	if (k_getuid(&faddr2, htons(fport), laddr, htons(lport), &uid) == -1) {
		if (no_user_token_flag) {
			gentoken(token, sizeof token);
			syslog(LOG_NOTICE, "token %s == NO USER", token);
			if ((n = snprintf(buf, sizeof(buf),
			    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
			    opsys_name, charset_sep, charset_name, token))
			    >= sizeof(buf) || n < 0)
				n = strlen(buf);
			if (timed_write(fd, buf, n, IO_TIMEOUT) != n &&
			    syslog_flag) {
				syslog(LOG_NOTICE, "write to %s: %m",
				    gethost4_addr(faddr));
				return 1;
			}
			return 0;
		}
		if (syslog_flag)
			syslog(LOG_DEBUG, "Returning: %d , %d : NO-USER",
			    lport, fport);
		if ((n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "NO-USER"))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}
	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  After k_getuid(), before getpwuid()");

	pw = getpwuid(uid);
	if (!pw) {
		if (syslog_flag)
			syslog(LOG_WARNING,
			    "getpwuid() could not map uid (%u) to name",
			    uid);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%u\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, uid))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}

	if (syslog_flag)
		syslog(LOG_DEBUG, "Successful lookup: %d , %d : %s",
		    lport, fport, pw->pw_name);

	if (noident_flag && check_noident(pw->pw_dir)) {
		if (syslog_flag && verbose_flag)
			syslog(LOG_NOTICE,
			    "user %s requested HIDDEN-USER for host %s: %d, %d",
			    pw->pw_name, gethost4_addr(faddr), lport, fport);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : HIDDEN-USER\r\n", lport, fport))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}

	if (userident_flag && getuserident(pw->pw_dir, token, sizeof token)) {
		syslog(LOG_NOTICE, "token \"%s\" == uid %u (%s)",
		    token, uid, pw->pw_name);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
		    opsys_name, charset_sep, charset_name, token))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}

	if (token_flag) {
		gentoken(token, sizeof token);
		syslog(LOG_NOTICE, "token %s == uid %u (%s)", token, uid,
		    pw->pw_name);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
		    opsys_name, charset_sep, charset_name, token))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}

	if (number_flag) {
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%u\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, uid))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
			return 1;
		}
		return 0;
	}
	if ((n = snprintf(buf, sizeof(buf), "%d , %d : USERID : %s%s%s :%s\r\n",
	    lport, fport, opsys_name, charset_sep, charset_name, pw->pw_name))
	    >= sizeof(buf) || n < 0)
		n = strlen(buf);
	if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
		syslog(LOG_NOTICE, "write to %s: %m", gethost4_addr(faddr));
		return 1;
	}
	return 0;
}


/* Parse, a-la IPv6 */
int
parse6(int fd, struct sockaddr_in6 *laddr, struct sockaddr_in6 *faddr)
{
	char	token[21], buf[BUFSIZ], *p;
	struct	sockaddr_in6 laddr2, faddr2;
	struct	passwd *pw;
	uid_t	uid;
	int	n;

	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "In function parse6(), from %s to %s",
		    gethost6(faddr), gethost6(laddr));

	faddr2 = *faddr;
	laddr2 = *laddr;
	lport = fport = 0;

	/* Read query from client */
	if ((n = timed_read(fd, buf, sizeof(buf) - 1, IO_TIMEOUT)) <= 0) {
		if (syslog_flag)
			syslog(LOG_NOTICE,
			    n ? "read from %s: %m" : "read from %s: EOF",
			    gethost6(faddr));
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : UNKNOWN-ERROR\r\n", lport, fport))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}
	buf[n] = '\0';

	/* Pull out local and remote ports */
	p = buf;
	while (isspace((unsigned char)*p))
		p++;
	if ((p = strtok(p, " \t,"))) {
		lport = atoi(p);
		if ((p = strtok(NULL, " \t,")))
			fport = atoi(p);
	}

	if (lport < 1 || lport > 65535 || fport < 1 || fport > 65535) {
		if (syslog_flag)
			syslog(LOG_NOTICE,
			    "scanf: invalid-port(s): %d , %d from %s",
			    lport, fport, gethost6(faddr));
		if ((n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" :
		    "INVALID-PORT")) >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}
	if (syslog_flag && verbose_flag)
		syslog(LOG_NOTICE, "request for (%d,%d) from %s",
		    lport, fport, gethost6(faddr));

	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  After fscanf(), before k_getuid6()");

	/*
	 * Next - get the specific TCP connection and return the
	 * uid - user number.
	 */
	if (k_getuid6(&faddr2, htons(fport), laddr, htons(lport), &uid) == -1) {
		if (no_user_token_flag) {
			gentoken(token, sizeof token);
			syslog(LOG_NOTICE, "token %s == NO USER", token);
			if ((n = snprintf(buf, sizeof(buf),
			    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
			    opsys_name, charset_sep, charset_name, token))
			    >= sizeof(buf) || n < 0)
				n = strlen(buf);
			if (timed_write(fd, buf, n, IO_TIMEOUT) != n &&
			    syslog_flag) {
				syslog(LOG_NOTICE, "write to %s: %m",
				    gethost6(faddr));
				return 1;
			}
			return 0;
		}
		if (syslog_flag)
			syslog(LOG_DEBUG, "Returning: %d , %d : NO-USER",
			    lport, fport);
		if ((n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "NO-USER"))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}
	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  After k_getuid6(), before getpwuid()");

	pw = getpwuid(uid);
	if (!pw) {
		if (syslog_flag)
			syslog(LOG_WARNING,
			    "getpwuid() could not map uid (%u) to name",
			    uid);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%u\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, uid))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}

	if (syslog_flag)
		syslog(LOG_DEBUG, "Successful lookup: %d , %d : %s",
		    lport, fport, pw->pw_name);

	if (noident_flag && check_noident(pw->pw_dir)) {
		if (syslog_flag && verbose_flag)
			syslog(LOG_NOTICE,
			    "user %s requested HIDDEN-USER for host %s: %d, %d",
			    pw->pw_name, gethost6(faddr), lport, fport);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : HIDDEN-USER\r\n", lport, fport))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}

	if (userident_flag && getuserident(pw->pw_dir, token, sizeof token)) {
		syslog(LOG_NOTICE, "token \"%s\" == uid %u (%s)",
		    token, uid, pw->pw_name);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
		    opsys_name, charset_sep, charset_name, token))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}

	if (token_flag) {
		gentoken(token, sizeof token);
		syslog(LOG_NOTICE, "token %s == uid %u (%s)", token, uid,
		    pw->pw_name);
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport,
		    opsys_name, charset_sep, charset_name, token))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}

	if (number_flag) {
		if ((n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%u\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, uid))
		    >= sizeof(buf) || n < 0)
			n = strlen(buf);
		if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
			syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
			return 1;
		}
		return 0;
	}

	if ((n = snprintf(buf, sizeof(buf), "%d , %d : USERID : %s%s%s :%s\r\n",
	    lport, fport, opsys_name, charset_sep, charset_name, pw->pw_name))
	    >= sizeof(buf) || n < 0)
		n = strlen(buf);
	if (timed_write(fd, buf, n, IO_TIMEOUT) != n && syslog_flag) {
		syslog(LOG_NOTICE, "write to %s: %m", gethost6(faddr));
		return 1;
	}
	return 0;
}
@


1.47
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.46 2008/04/13 00:22:17 djm Exp $	*/
@


1.46
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.45 2007/09/26 02:50:36 ray Exp $	*/
d217 1
a217 1
	while (isspace(*p))
d415 1
a415 1
	while (isspace(*p))
@


1.45
log
@From Tamas TEVESZ:
- Use strcspn to strip \r and \n.

OK chl.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.44 2007/03/21 03:32:28 tedu Exp $	*/
d108 1
a108 1
			*p = token0cnv[arc4random() % (sizeof token0cnv-1)];
d110 1
a110 1
			*p = tokencnv[arc4random() % (sizeof tokencnv-1)];
@


1.44
log
@remove extra *p tests, from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.43 2005/12/06 22:05:22 deraadt Exp $	*/
d65 1
a65 1
	char   path[MAXPATHLEN], *p;
d90 1
a90 2
	if ((p = strpbrk(buf, "\r\n")))
		*p = '\0';
@


1.43
log
@avoid variable aliasing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.42 2005/04/04 08:55:36 deraadt Exp $	*/
d218 1
a218 1
	while (*p != '\0' && isspace(*p))
d416 1
a416 1
	while (*p != '\0' && isspace(*p))
@


1.42
log
@nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.41 2005/01/04 18:19:26 moritz Exp $	*/
d123 1
a123 1
	int error, tot = 0, i, r;
d136 1
a136 1
		if ((error = poll(rfd, 1, tv.tv_sec * 1000 +
d138 1
a138 1
			return error;
d166 1
a166 1
	int error;
d175 1
a175 1
	if ((error = poll(wfd, 1, tv.tv_sec * 1000 +
d177 2
a178 2
		return error;
	return(write(fd, buf, siz));
@


1.41
log
@add some more snprintf sanity checks and fix two previously added checks.

ok millert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.40 2004/09/16 08:25:05 deraadt Exp $	*/
a24 1
#include <nlist.h>
@


1.40
log
@i hate macros with 50 , :? and ())()()((()())); otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.39 2004/08/08 19:32:45 deraadt Exp $	*/
d257 1
a257 1
			n = snprintf(buf, sizeof(buf),
d259 3
a261 1
			    opsys_name, charset_sep, charset_name, token);
d455 1
a455 1
			n = snprintf(buf, sizeof(buf),
d457 3
a459 1
			    opsys_name, charset_sep, charset_name, token);
d494 1
d514 1
@


1.39
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.38 2003/07/29 18:39:23 deraadt Exp $	*/
d21 1
a28 1
#include "error.h"
@


1.38
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.37 2003/06/28 01:05:21 deraadt Exp $	*/
d193 1
a193 1
		       gethost4_addr(faddr), gethost4_addr(laddr));
d389 1
a389 1
		       gethost6(faddr), gethost6(laddr));
@


1.37
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.36 2002/11/25 11:08:18 mpech Exp $	*/
d258 1
a258 1
			    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport, 
d260 1
a260 1
			if (timed_write(fd, buf, n, IO_TIMEOUT) != n && 
d262 1
a262 1
				syslog(LOG_NOTICE, "write to %s: %m", 
d454 1
a454 1
			    "%d , %d : USERID : %s%s%s :%s\r\n", lport, fport, 
d456 1
a456 1
			if (timed_write(fd, buf, n, IO_TIMEOUT) != n && 
d458 1
a458 1
				syslog(LOG_NOTICE, "write to %s: %m", 
@


1.36
log
@Missing check around snprintf().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.35 2002/09/13 01:31:39 djm Exp $	*/
d35 1
@


1.35
log
@Add -H option to hide nonexistent users (useful on NAT gateways). ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.34 2002/07/24 23:11:14 millert Exp $	*/
d537 1
a537 1
		    >= sizeof(buf))
@


1.34
log
@Sanity check snprintf() return values before using them.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.33 2002/07/16 10:32:37 deraadt Exp $	*/
d252 15
a266 2
	if (k_getuid(&faddr2, htons(fport), laddr,
	    htons(lport), &uid) == -1) {
d448 15
a462 2
	if (k_getuid6(&faddr2, htons(fport), laddr,
	    htons(lport), &uid) == -1) {
@


1.33
log
@minor tweaks of no consequence
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.32 2002/07/16 10:21:20 deraadt Exp $	*/
d46 1
d50 2
a51 1
	if (snprintf(path, sizeof path, "%s/.noident", homedir) >= sizeof path)
d66 1
a66 1
	int    fd, nread;
d73 2
a74 1
	if (snprintf(path, sizeof path, "%s/.ident", homedir) >= sizeof(path))
d204 4
a207 2
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : UNKNOWN-ERROR\r\n", lport, fport);
d231 4
a234 2
		n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "INVALID-PORT");
d257 4
a260 2
		n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "NO-USER");
d276 1
a276 1
		n = snprintf(buf, sizeof(buf),
d278 3
a280 1
		    lport, fport, opsys_name, charset_sep, charset_name, uid);
d297 4
a300 2
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : HIDDEN-USER\r\n", lport, fport);
d311 5
a315 3
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, token);
d327 5
a331 3
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, token);
d340 1
a340 1
		n = snprintf(buf, sizeof(buf),
d342 3
a344 1
		    lport, fport, opsys_name, charset_sep, charset_name, uid);
d351 4
a354 2
	n = snprintf(buf, sizeof(buf), "%d , %d : USERID : %s%s%s :%s\r\n",
	    lport, fport, opsys_name, charset_sep, charset_name, pw->pw_name);
d387 4
a390 2
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : UNKNOWN-ERROR\r\n", lport, fport);
d414 4
a417 2
		n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "INVALID-PORT");
d440 4
a443 2
		n = snprintf(buf, sizeof(buf), "%d , %d : ERROR : %s\r\n",
		    lport, fport, unknown_flag ? "UNKNOWN-ERROR" : "NO-USER");
d459 1
a459 1
		n = snprintf(buf, sizeof(buf),
d461 2
a462 1
		    lport, fport, opsys_name, charset_sep, charset_name, uid);
d479 3
a481 2
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : ERROR : HIDDEN-USER\r\n", lport, fport);
d492 5
a496 3
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, token);
d508 5
a512 3
		n = snprintf(buf, sizeof(buf),
		    "%d , %d : USERID : %s%s%s :%s\r\n",
		    lport, fport, opsys_name, charset_sep, charset_name, token);
d521 1
a521 1
		n = snprintf(buf, sizeof(buf),
d523 3
a525 1
		    lport, fport, opsys_name, charset_sep, charset_name, uid);
d533 4
a536 2
	n = snprintf(buf, sizeof(buf), "%d , %d : USERID : %s%s%s :%s\r\n",
	    lport, fport, opsys_name, charset_sep, charset_name, pw->pw_name);
@


1.32
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.31 2002/07/16 10:16:10 deraadt Exp $	*/
d64 1
a65 1
	int    fd, nread;
d119 1
d121 1
a122 2
	struct pollfd rfd[1];
	struct timeval tv, start, after, duration, tmp;
a160 1
	int error;
d163 1
d181 1
a181 2
	char	token[21];
	char	buf[BUFSIZ], *p;
d184 1
a185 1
	uid_t	uid;
a190 2
	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  Before read from remote host");
d346 1
a346 2
	char	token[21];
	char	buf[BUFSIZ], *p;
d349 1
a350 1
	uid_t	uid;
a355 2
	if (debug_flag && syslog_flag)
		syslog(LOG_DEBUG, "  Before read from remote host");
@


1.31
log
@minor cleanup, and toast -V
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.30 2002/06/22 20:34:31 deraadt Exp $	*/
a24 1
#include <kvm.h>
@


1.30
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.29 2002/02/16 21:27:30 millert Exp $	*/
d64 1
a64 1
	char   path[MAXPATHLEN];
a66 1
	char   *p;
d190 1
a190 1
		syslog(LOG_DEBUG, "In function parse(), from %s to %s", 
d252 1
a252 1
			syslog(LOG_DEBUG, "Returning: %d , %d : NO-USER",	
d358 1
a358 1
		syslog(LOG_DEBUG, "In function parse6(), from %s to %s", 
d420 1
a420 1
			syslog(LOG_DEBUG, "Returning: %d , %d : NO-USER",	
@


1.29
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.28 2002/01/07 08:13:31 mpech Exp $	*/
d43 1
a43 2
check_noident(homedir)
	char   *homedir;
d62 1
a62 3
getuserident(homedir, buf, len)
	char *homedir, *buf;
	int len;
d100 1
a100 3
gentoken(buf, len)
	char *buf;
	int len;
d119 1
a119 5
timed_read(fd, buf, siz, timeout)
	int fd;
	void *buf;
	size_t siz;
	time_t timeout;
d161 1
a161 5
timed_write(fd, buf, siz, timeout)
	int fd;
	const void *buf;
	size_t siz;
	time_t timeout;
d181 1
a181 3
parse(fd, laddr, faddr)
	int fd;
	struct in_addr *laddr, *faddr;
d349 1
a349 3
parse6(fd, laddr, faddr)
	int fd;
	struct sockaddr_in6 *laddr, *faddr;
@


1.28
log
@o) int -> {uid,gid}_t; %d -> %u;
o) int -> pid_t;

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.27 2001/12/01 18:54:43 deraadt Exp $	*/
d33 4
a36 4
int check_noident __P((char *));
ssize_t timed_read __P((int, void *, size_t, time_t));
ssize_t timed_write __P((int, const void *, size_t, time_t));
void gentoken __P((char *, int));
@


1.27
log
@fix fd_set overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.26 2001/08/08 07:02:42 deraadt Exp $	*/
d285 1
a285 1
			    "getpwuid() could not map uid (%d) to name",
d288 1
a288 1
		    "%d , %d : USERID : %s%s%s :%d\r\n",
d344 1
a344 1
		    "%d , %d : USERID : %s%s%s :%d\r\n",
d455 1
a455 1
			    "getpwuid() could not map uid (%d) to name",
d458 1
a458 1
		    "%d , %d : USERID : %s%s%s :%d\r\n",
d514 1
a514 1
		    "%d , %d : USERID : %s%s%s :%d\r\n",
@


1.26
log
@split up the gethost*() functions a bit more, to make it more obvious what
is going on.  This could be improved further by always passing around
fat sockaddr's I think.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.25 2001/08/08 06:46:09 deraadt Exp $	*/
d177 1
a177 1
	fd_set writeds;
d180 3
a182 2
	FD_ZERO(&writeds);
	FD_SET(fd, &writeds);
d187 2
a188 1
	if ((error = select(fd + 1, 0, &writeds, 0, &tv)) <= 0)
@


1.25
log
@do not use %m in syslog() when errno is known to be 0
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.24 2001/04/16 00:26:21 fgsch Exp $	*/
d205 1
a205 1
		       gethost(faddr), gethost(laddr));
d218 1
a218 1
			    gethost(faddr));
d222 1
a222 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d243 1
a243 1
			    lport, fport, gethost(faddr));
d247 1
a247 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d254 1
a254 1
		    lport, fport, gethost(faddr));
d271 1
a271 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d289 1
a289 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d303 1
a303 1
			    pw->pw_name, gethost(faddr), lport, fport);
d307 1
a307 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d320 1
a320 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d334 1
a334 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d345 1
a345 1
			syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
d353 1
a353 1
		syslog(LOG_NOTICE, "write to %s: %m", gethost(faddr));
@


1.24
log
@close fd on error; deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.23 2001/04/15 23:48:16 hugh Exp $	*/
d216 3
a218 1
			syslog(LOG_NOTICE, "read from %s: %m", gethost(faddr));
d386 3
a388 1
			syslog(LOG_NOTICE, "read from %s: %m", gethost6(faddr));
@


1.23
log
@Replace a bunch of conditional expressions with global pointers.
Requested and checked by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.22 2001/04/14 02:49:19 hugh Exp $	*/
d80 2
a81 1
	if (fstat(fd, &st) != 0 || !S_ISREG(st.st_mode))
d83 1
@


1.22
log
@Respect (absence of) "other" flag in all cases, and fix some whitespace.
Checked by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.21 2001/04/13 20:16:53 millert Exp $	*/
d283 1
a283 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", uid);
d314 1
a314 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", token);
d328 1
a328 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", token);
d339 1
a339 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", uid);
d347 1
a347 3
	    lport, fport, other_flag ? "OTHER" : "UNIX",
	    charset_name ? " , " : "",
	    charset_name ? charset_name : "", pw->pw_name);
d451 1
a451 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", uid);
d482 1
a482 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", token);
d496 1
a496 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", token);
d507 1
a507 3
		    lport, fport, other_flag ? "OTHER" : "UNIX",
		    charset_name ? " , " : "",
		    charset_name ? charset_name : "", uid);
d516 1
a516 3
	    lport, fport, other_flag ? "OTHER" : "UNIX",
	    charset_name ? " , " : "",
	    charset_name ? charset_name : "", pw->pw_name);
@


1.21
log
@Add support for user specified tokens to identd.  Based on a patch
from rjmooney@@wall.st w/ minor tweakage by Theo and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.20 2001/01/28 19:34:29 niklas Exp $	*/
d194 1
d282 3
a284 2
		    "%d , %d : USERID : OTHER%s%s :%d\r\n",
		    lport, fport, charset_name ? " , " : "",
d311 11
a321 17
	if (userident_flag) {
                char token[21];
                
                if (getuserident(pw->pw_dir, token, sizeof token)) {
	                syslog(LOG_NOTICE, "token \"%s\" == uid %u (%s)",
			    token, uid, pw->pw_name);
	                n = snprintf(buf, sizeof(buf),
        	            "%d , %d : USERID : OTHER%s%s :%s\r\n",
	                    lport, fport, charset_name ? " , " : "",
	                    charset_name ? charset_name : "", token);
	                if (timed_write(fd, buf, n, IO_TIMEOUT) != n &&
			    syslog_flag) {
	                        syslog(LOG_NOTICE, "write to %s: %m",
				    gethost(faddr));
	                        return 1;
	                }
	                return 0;
d323 1
a326 2
		char token[21];

d331 3
a333 2
		    "%d , %d : USERID : OTHER%s%s :%s\r\n",
		    lport, fport, charset_name ? " , " : "",
d341 1
d344 3
a346 2
		    "%d , %d : USERID : OTHER%s%s :%d\r\n",
		    lport, fport, charset_name ? " , " : "",
d372 1
d460 3
a462 2
		    "%d , %d : USERID : OTHER%s%s :%d\r\n",
		    lport, fport, charset_name ? " , " : "",
d489 11
a499 17
	if (userident_flag) {
                char token[21];
                
                if (getuserident(pw->pw_dir, token, sizeof(token))) {
	                syslog(LOG_NOTICE, "token \"%s\" == uid %u (%s)",
			    token, uid, pw->pw_name);
	                n = snprintf(buf, sizeof(buf),
        	            "%d , %d : USERID : OTHER%s%s :%s\r\n",
	                    lport, fport, charset_name ? " , " : "",
	                    charset_name ? charset_name : "", token);
	                if (timed_write(fd, buf, n, IO_TIMEOUT) != n &&
			    syslog_flag) {
	                        syslog(LOG_NOTICE, "write to %s: %m",
				    gethost6(faddr));
	                        return 1;
	                }
	                return 0;
d501 1
a504 2
		char token[21];

d509 3
a511 2
		    "%d , %d : USERID : OTHER%s%s :%s\r\n",
		    lport, fport, charset_name ? " , " : "",
d519 1
d522 3
a524 2
		    "%d , %d : USERID : OTHER%s%s :%d\r\n",
		    lport, fport, charset_name ? " , " : "",
d532 1
@


1.20
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
 * A small routine to check for the existance of the ".noident"
d58 39
a256 1
	 *
d309 20
a436 1
	 *
d487 20
@


1.19
log
@use poll to avoid fd_set overflow
@
text
@d1 2
@


1.18
log
@add ipv6 support
@
text
@d16 1
d89 1
a89 1
	fd_set readfds;
d96 3
a98 2
		FD_ZERO(&readfds);
		FD_SET(fd, &readfds);
d101 2
a102 1
		if ((error = select(fd + 1, &readfds, 0, 0, &tv)) <= 0)
@


1.17
log
@netinet/in.h without sys/socket.h
@
text
@d157 2
a158 1
		syslog(LOG_DEBUG, "In function parse()");
d299 161
@


1.16
log
@Wall
@
text
@d12 1
@


1.15
log
@constrain token character set; worked out with hugh@@openbsd.org
@
text
@d29 1
a29 1
static int check_noident __P((char *));
a31 1
int parse __P((int, struct in_addr *, struct in_addr *));
d38 1
a38 1
static int
@


1.14
log
@change to using getopt() [some inetd.conf files will need repair];
add usage()
and add token support via -h (token information is sysloged)
@
text
@d33 1
d55 2
a56 2
static unsigned char itoa64[] =	 /* 0 ... 63 => ascii - 64 */
	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
d58 6
a63 1
static void to64 __P((char *, u_int32_t, int));
d65 7
a71 9
static void
to64(s, v, n)
	char *s;
	u_int32_t v;
	int n;
{
	while (--n >= 0) {
		*s++ = itoa64[v&0x3f];
		v >>= 6;
d73 1
a266 8
		char *s = token;

		memset(token, 0, sizeof token);
		to64(s, arc4random(), 4);
		to64(s + 4, arc4random(), 4);
		to64(s + 8, arc4random(), 4);
		to64(s + 12, arc4random(), 4);
		to64(s + 16, arc4random(), 4);
d268 1
@


1.13
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d54 17
d260 23
@


1.12
log
@Now uses TCPCTL_IDENT sysctl to get uid associated with a connection
instead of kmem. Kmem parsing functions and options removed.
@
text
@d226 1
a226 1
		syslog(LOG_DEBUG, "Successful lookup: %d , %d : %s\n",
@


1.11
log
@another terminating condition, why did i forget that
@
text
@d131 1
a131 1
	int	try, n;
a190 3
	 * Try to fetch the information 5 times incase the
	 * kernel changed beneath us and we missed or took
	 * a fault.
d192 2
a193 6
	for (try = 0; try < 5; try++)
		if (k_getuid(&faddr2, htons(fport), laddr,
		    htons(lport), &uid) != -1)
			break;

	if (try >= 5) {
d195 1
a195 1
			syslog(LOG_DEBUG, "Returned: %d , %d : NO-USER",	
a204 3
	if (try > 0 && syslog_flag)
		syslog(LOG_NOTICE, "k_getuid retries: %d", try);

@


1.10
log
@do not rely on a single read() to get us sufficient data. Read till newline
@
text
@d80 1
a80 1
		if (r == -1)
@


1.9
log
@.noident not .noindent; fc@@parkone.ci.oakland.ca.us
@
text
@d64 2
a65 1
	int error;
d67 1
a67 4
	struct timeval tv;

	FD_ZERO(&readfds);
	FD_SET(fd, &readfds);
d72 24
a95 3
	if ((error = select(fd + 1, &readfds, 0, 0, &tv)) <= 0)
		return error;
	return(read(fd, buf, siz));
@


1.8
log
@Prototype things.
@
text
@d47 1
a47 1
	if (snprintf(path, sizeof path, "%s/.noindent", homedir) >= sizeof path)
@


1.7
log
@Timeout reads/writes on the socket just to be safe.
@
text
@d29 5
@


1.6
log
@Using stdio on sockets is gross so don't do it.  Also some -Wall.
@
text
@d27 2
d33 1
a33 1
static int 
d49 51
a99 1
int 
d114 1
a114 1
		syslog(LOG_DEBUG, "  Before fscanf()");
d120 1
a120 1
	if ((n = read(fd, buf, sizeof(buf) - 1)) <= 0) {
d125 1
a125 1
		if (write(fd, buf, n) != n && syslog_flag) {
d150 1
a150 1
		if (write(fd, buf, n) != n && syslog_flag) {
d182 1
a182 1
		if (write(fd, buf, n) != n && syslog_flag) {
d204 1
a204 1
		if (write(fd, buf, n) != n && syslog_flag) {
d222 1
a222 1
		if (write(fd, buf, n) != n && syslog_flag) {
d234 1
a234 1
		if (write(fd, buf, n) != n && syslog_flag) {
d244 1
a244 1
	if (write(fd, buf, n) != n && syslog_flag) {
@


1.5
log
@reindent and remove extra crud. a program that is security sensitive must be readable
@
text
@d15 1
d22 1
d48 2
a49 2
parse(fp, laddr, faddr)
	FILE   *fp;
d52 1
a52 1
	char	lhostaddr[16], fhostaddr[16], password[33];
d55 1
a55 1
	int	try, rcode;
a65 1
	lhostaddr[0] = fhostaddr[0] = password[0] = '\0';
d68 22
a89 1
	rcode = fscanf(fp, " %d , %d", &lport, &fport);
d91 2
a92 3
	if (rcode < 2 || lport < 1 || lport > 65535 ||
	    fport < 1 || fport > 65535) {
		if (syslog_flag && rcode > 0)
d96 6
a101 2
		printf("%d , %d : ERROR : %s\r\n", lport, fport,
		    unknown_flag ? "UNKNOWN-ERROR" : "INVALID-PORT");
d128 6
a133 2
		printf("%d , %d : ERROR : %s\r\n", lport, fport,
		    unknown_flag ? "UNKNOWN-ERROR" : "NO-USER");
d148 2
a149 1
		printf("%d , %d : USERID : OTHER%s%s :%d\r\n",
d152 4
d168 6
a173 1
		printf("%d , %d : ERROR : HIDDEN-USER\r\n", lport, fport);
d178 2
a179 1
		printf("%d , %d : USERID : OTHER%s%s :%d\r\n",
d182 4
d188 1
a188 1
	printf("%d , %d : USERID : %s%s%s :%s\r\n",
d192 4
@


1.4
log
@cleanup; everyone please test
@
text
@d4 1
@


1.3
log
@tabify
@
text
@d2 10
a11 11
**	$Id: parse.c,v 1.2 1995/12/18 22:15:08 deraadt Exp $
**
** parse.c			   This file contains the protocol parser
**
** This program is in the public domain and may be used freely by anyone
** who wants to. 
**
** Last update: 6 Dec 1992
**
** Please send bug fixes/bug reports to: Peter Eriksson <pen@@lysator.liu.se>
*/
a17 8

#include <sys/types.h>
#include <netinet/in.h>

#ifndef HPUX7
#  include <arpa/inet.h>
#endif

a20 7
#include <sys/types.h>
#include <sys/stat.h>

#if defined(MIPS) || defined(BSD43)
extern int errno;
#endif

a23 2
extern void *malloc();

d25 6
a30 6
** This function will eat whitespace characters until
** either a non-whitespace character is read, or EOF
** occurs. This function is only used if the "-m" option
** is enabled.
*/
static int eat_whitespace()
d32 2
a33 1
  int c;
d35 7
a41 14
  
  while ((c = getchar()) != EOF &&
	 !(c == '\r' || c == '\n'))
    ;

  if (c != EOF)
    while ((c = getchar()) != EOF &&
	   (c == ' ' || c == '\t' || c == '\n' || c == '\r'))
      ;

  if (c != EOF)
    ungetc(c, stdin);
  
  return (c != EOF);
d44 4
a47 8

#ifdef INCLUDE_EXTENSIONS
/*
** Validate an indirect request
*/
static int valid_fhost(faddr, password)
  struct in_addr *faddr;
  char *password;
d49 15
a63 2
  if (indirect_host == NULL)
    return 0;
d65 2
a66 31
  if (strcmp(indirect_host, "*") != 0)
  {
    if (isdigit(indirect_host[0]))
    {
      if (strcmp(inet_ntoa(*faddr), indirect_host))
      {
	syslog(LOG_NOTICE, "valid_fhost: access denied for: %s",
	       gethost(faddr));
	return 0;
      }
    }
    else
    {
      if (strcmp(gethost(faddr), indirect_host))
      {
	syslog(LOG_NOTICE, "valid_fhost: access denied for: %s",
	       gethost(faddr));
	return 0;
      }
    }
  }
      
  if (indirect_password == NULL)
    return 1;
  
  if (strcmp(password, indirect_password))
  {
    syslog(LOG_NOTICE, "valid_fhost: invalid password from: %s",
	   gethost(faddr));
    return 0;
  }
d68 13
a80 3
  return 1;
}
#endif
d82 2
a83 18
/*
** A small routine to check for the existance of the ".noident"
** file in a users home directory.
*/
static int check_noident(homedir)
  char *homedir;
{
  char *tmp_path;
  struct stat sbuf;
  int rcode;
  

  if (!homedir)
    return 0;
  
  tmp_path = (char *) malloc(strlen(homedir) + sizeof("/.noident") + 1);
  if (!tmp_path)
    return 0;
d85 23
a107 2
  strcpy(tmp_path, homedir);
  strcat(tmp_path, "/.noident");
d109 2
a110 5
  rcode = stat(tmp_path, &sbuf);
  free(tmp_path);

  return (rcode == 0);
}
d112 11
d124 11
a134 82
int parse(fp, laddr, faddr)
  FILE *fp;
  struct in_addr *laddr, *faddr;
{
  int uid, try, rcode;
  struct passwd *pwp;
  char lhostaddr[16];
  char fhostaddr[16];
  char password[33];
#ifdef INCLUDE_EXTENSIONS  
  char arg[33];
  int c;
#endif
  struct in_addr laddr2;
  struct in_addr faddr2;
  
  
  if (debug_flag && syslog_flag)
    syslog(LOG_DEBUG, "In function parse()");
  
  /*
  ** Get the local/foreign port pair from the luser
  */
  do
  {
    if (debug_flag && syslog_flag)
      syslog(LOG_DEBUG, "  Before fscanf()");
    
    faddr2 = *faddr;
    laddr2 = *laddr;
    lport = fport = 0;
    lhostaddr[0] = fhostaddr[0] = password[0] = '\0';

    /* Read query from client */
    rcode = fscanf(fp, " %d , %d", &lport, &fport);

#ifdef INCLUDE_EXTENSIONS
    /*
    ** Do additional parsing in case of extended request
    */
    if (rcode == 0)
    {
      rcode = fscanf(fp, "%32[^ \t\n\r:]", arg);

      /* Skip leading space up to EOF, EOL or non-space char */
      while ((c = getc(fp)) == ' ' || c == '\t')
	;
      
      if (rcode <= 0)
      {
	printf("%d , %d : ERROR : %s\r\n",
	       lport, fport,
	       unknown_flag ? "UNKNOWN-ERROR" : "X-INVALID-REQUEST");
	continue;
      }

      /*
      ** Non-standard extended request, returns with Pidentd
      ** version information
      */
      if (strcmp(arg, "VERSION") == 0)
      {
	printf("%d , %d : ERROR : X-VERSION : %s\r\n", lport, fport,
	       version);
	continue;
      }

      /*
      ** Non-standard extended proxy request
      */
      else if (strcmp(arg, "PROXY") == 0 && c == ':')
      {
	/* We have a colon char, check for port numbers */
	rcode = fscanf(fp, " %d , %d : %15[0-9.] , %15[0-9.]",
		       &lport, &fport, fhostaddr, lhostaddr);

	if (!(rcode == 3 || rcode == 4))
	{
	  printf("%d , %d : ERROR : %s\r\n",
		 lport, fport,
		 unknown_flag ? "UNKNOWN-ERROR" : "X-INVALID-REQUEST");
	  continue;
d137 5
a141 27
	if (rcode == 4)
	  (void) inet_aton(lhostaddr, &laddr2);
	
	(void) inet_aton(fhostaddr, &faddr2);

	proxy(&laddr2, &faddr2, lport, fport, NULL);
	continue;
      }
      
      /*
      ** Non-standard extended remote indirect request
      */
      else if (strcmp(arg, "REMOTE") == 0 && c == ':')
      {
	/* We have a colon char, check for port numbers */
	rcode = fscanf(fp, " %d , %d", &lport, &fport);
	
	/* Skip leading space up to EOF, EOL or non-space char */
	while ((c = getc(fp)) == ' ' || c == '\t')
	  ;

	if (rcode != 2 || c != ':')
	{
	  printf("%d , %d : ERROR : %s\r\n",
		 lport, fport,
		 unknown_flag ? "UNKNOWN-ERROR" : "X-INVALID-REQUEST");
	  continue;
d143 5
a147 146
	    
	/* We have a colon char, check for addr and password */
	rcode = fscanf(fp, " %15[0-9.] , %32[^ \t\r\n]",
		       fhostaddr, password);
	if (rcode > 0)
	  rcode += 2;
	else
	{
	  printf("%d , %d : ERROR : %s\r\n",
		 lport, fport,
		 unknown_flag ? "UNKNOWN-ERROR" : "X-INVALID-REQUEST");
	  continue;
	}
	
	/*
	** Verify that the host originating the indirect request
	** is allowed to do that
	*/
	if (!valid_fhost(faddr, password))
	{
	  printf("%d , %d : ERROR : %s\r\n",
		 lport, fport,
		 unknown_flag ? "UNKNOWN-ERROR" : "X-ACCESS-DENIED");
	  continue;
	}
	
	(void) inet_aton(fhostaddr, &faddr2);
      }
      
      else
      {
	printf("%d , %d : ERROR : %s\r\n",
	       lport, fport,
	       unknown_flag ? "UNKNOWN-ERROR" : "X-INVALID-REQUEST");
	continue;
      }
    }
#endif /* EXTENSIONS */
    
    if (rcode < 2 || lport < 1 || lport > 65535 || fport < 1 || fport > 65535)
    {
      if (syslog_flag && rcode > 0)
	syslog(LOG_NOTICE, "scanf: invalid-port(s): %d , %d from %s",
	       lport, fport, gethost(faddr));
      
      printf("%d , %d : ERROR : %s\r\n",
	     lport, fport,
	     unknown_flag ? "UNKNOWN-ERROR" : "INVALID-PORT");
      continue;
    }

    if (syslog_flag && verbose_flag)
	syslog(LOG_NOTICE, "request for (%d,%d) from %s",
	       lport, fport, gethost(faddr));

    if (debug_flag && syslog_flag)
      syslog(LOG_DEBUG, "  After fscanf(), before k_getuid()");
    
    /*
    ** Next - get the specific TCP connection and return the
    ** uid - user number.
    **
    ** Try to fetch the information 5 times incase the
    ** kernel changed beneath us and we missed or took
    ** a fault.
    */
    for (try = 0;
	 (try < 5 &&
	   k_getuid(&faddr2, htons(fport), laddr, htons(lport), &uid) == -1);
	 try++)
      ;

    if (try >= 5)
    {
      if (syslog_flag)
	syslog(LOG_DEBUG, "Returned: %d , %d : NO-USER", lport, fport);
      
      printf("%d , %d : ERROR : %s\r\n",
	     lport, fport,
	     unknown_flag ? "UNKNOWN-ERROR" : "NO-USER");
      continue;
    }

    if (try > 0 && syslog_flag)
      syslog(LOG_NOTICE, "k_getuid retries: %d", try);
    
    if (debug_flag && syslog_flag)
      syslog(LOG_DEBUG, "  After k_getuid(), before getpwuid()");

    /*
    ** Then we should try to get the username. If that fails we
    ** return it as an OTHER identifier
    */
    pwp = getpwuid(uid);
    
    if (!pwp)
    {
      if (syslog_flag)
	syslog(LOG_WARNING, "getpwuid() could not map uid (%d) to name",
	       uid);

      printf("%d , %d : USERID : OTHER%s%s :%d\r\n",
	     lport, fport,
	     charset_name ? " , " : "",
	     charset_name ? charset_name : "",
	     uid);
      continue;
    }

    /*
    ** Hey! We finally made it!!!
    */
    if (syslog_flag)
      syslog(LOG_DEBUG, "Successful lookup: %d , %d : %s\n",
	     lport, fport, pwp->pw_name);

    if (noident_flag && check_noident(pwp->pw_dir))
    {
      if (syslog_flag && verbose_flag)
	syslog(LOG_NOTICE, "user %s requested HIDDEN-USER for host %s: %d, %d",
	       pwp->pw_name,
	       gethost(faddr),
	       lport, fport);
      
      printf("%d , %d : ERROR : HIDDEN-USER\r\n",
	   lport, fport);
      continue;
    }

    if (number_flag)
      printf("%d , %d : USERID : OTHER%s%s :%d\r\n",
	     lport, fport,
	     charset_name ? " , " : "",
	     charset_name ? charset_name : "",
	     uid);
    else
      printf("%d , %d : USERID : %s%s%s :%s\r\n",
	     lport, fport,
	     other_flag ? "OTHER" : "UNIX",
	     charset_name ? " , " : "",
	     charset_name ? charset_name : "",
	     pwp->pw_name);
    
  } while(fflush(stdout), fflush(stderr), multi_flag && eat_whitespace());

  return 0;
@


1.2
log
@identd incorrectly prefixed a space to the userid/username; from
mouse@@Collatz.McRCIM.McGill.EDU; netbsd pr#1848
@
text
@d2 1
a2 1
**	$Id: parse.c,v 1.1.1.1 1995/10/18 08:43:18 deraadt Exp $
d4 1
a4 1
** parse.c                         This file contains the protocol parser
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
**	$Id: parse.c,v 1.5 1995/05/21 00:39:13 mycroft Exp $
d358 1
a358 1
      printf("%d , %d : USERID : OTHER%s%s : %d\r\n",
d387 1
a387 1
      printf("%d , %d : USERID : OTHER%s%s : %d\r\n",
d393 1
a393 1
      printf("%d , %d : USERID : %s%s%s : %s\r\n",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
