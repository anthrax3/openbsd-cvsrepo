head	1.33;
access;
symbols
	OPENBSD_5_8:1.31.0.10
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.12
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.10
	OPENBSD_5_0:1.29.0.8
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.16
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.12
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.10
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.8
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.8
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.4
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.6
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.4
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.6
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.4
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.33
date	2015.11.26.19.13.14;	author deraadt;	state dead;
branches;
next	1.32;
commitid	fyLCxlWCeyOgaZvC;

1.32
date	2015.10.22.12.52.15;	author tedu;	state Exp;
branches;
next	1.31;
commitid	C5I2Q0xjNWH0Fjhk;

1.31
date	2013.11.27.21.25.40;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.02.01.29.29;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.20.23.21.23;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.21.08.26;	author maja;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.26.18.28.25;	author pvalchev;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.20.03.43.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.17.14.04.36;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.08.21.18.11;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.26.01.29.43;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.08.06.20.41.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.01.28.21.20.37;	author maja;	state Exp;
branches;
next	1.16;

1.16
date	97.11.17.23.56.20;	author gene;	state Exp;
branches;
next	1.15;

1.15
date	97.08.19.07.00.51;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.07.21.19.22.57;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.06.17.10.13.14;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.02.18.23.38.58;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.02.18.22.44.49;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.02.18.14.05.40;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	96.12.06.01.54.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.31.13.54.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.30.15.10.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.30.13.09.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.08.16.14.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.22.11.27;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.36.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.01.17.40.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.23.07.44.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@rpc.yppasswdd goes to the bitbucket.

(The story is that some people do use YP still as a libc -> non-file
lookup mechanism; some of them with standard ypbind/ypserv, but more
of them with ypbind/ypldap.  That however does not justify these cruddy
tools dealing with passwords, which are more likely to contain problems)
@
text
@/*	$OpenBSD: yppasswdd_mkpw.c,v 1.32 2015/10/22 12:52:15 tedu Exp $	*/

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <fcntl.h>
#include <rpc/rpc.h>
#include <rpcsvc/yppasswd.h>
#include <db.h>
#include <pwd.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>
#include <ctype.h>
#include <string.h>
#include <syslog.h>

extern int noshell;
extern int nogecos;
extern int nopw;
extern int make;
extern char make_arg[];
extern char *dir;

char *ok_shell(char *);
int badchars(char *);
int subst(char *, char, char);
int make_passwd(yppasswd *);

char *
ok_shell(char *name)
{
	char *p, *sh;

	setusershell();
	while ((sh = getusershell())) {
		if (!strcmp(name, sh))
			return (name);
		/* allow just shell name, but use "real" path */
		if ((p = strrchr(sh, '/')) && strcmp(name, p + 1) == 0)
			return (sh);
	}
	return (NULL);
}

int
badchars(char *base)
{
	int ampr = 0;
	char *s;

	for (s = base; *s; s++) {
		if (*s == '&')
			ampr++;
		if (!isprint((unsigned char)*s))
			return 1;
		if (strchr(":\n\t\r", *s))
			return 1;
	}
	if (ampr > 10)
		return 1;
	return 0;
}

int
subst(char *s, char from, char to)
{
	int	n = 0;

	while (*s) {
		if (*s == from) {
			*s = to;
			n++;
		}
		s++;
	}
	return (n);
}

int
make_passwd(yppasswd *argp)
{
	struct passwd pw;
	int     pfd = -1, tfd;
	char	buf[11], *bp = NULL, *p, *t;
	int	n;
	ssize_t cnt;
	size_t	resid;
	struct stat st;
	char *master;

	pw_init();
	if (dir)
		pw_setdir(dir);
	master = pw_file(_PATH_MASTERPASSWD);
	if (!master)
		return (1);
	pfd = open(master, O_RDONLY);
	if (pfd < 0)
		goto fail;
	if (fstat(pfd, &st))
		goto fail;
	p = bp = malloc((resid = st.st_size) + 1);
	if (bp == NULL)
		goto fail;
	do {
		cnt = read(pfd, p, resid);
		if (cnt < 0)
			goto fail;
		p += cnt;
		resid -= cnt;
	} while (resid > 0);
	close(pfd);
	pfd = -1;
	*p = '\0';		/* Buf oflow prevention */

	p = bp;
	subst(p, '\n', '\0');
	for (n = 1; p < bp + st.st_size; n++, p = t) {
		t = strchr(p, '\0') + 1;
		cnt = subst(p, ':', '\0');
		if (cnt != 9) {
			syslog(LOG_WARNING, "bad entry at line %d of %s", n,
			    master);
			continue;
		}

		if (strcmp(p, argp->newpw.pw_name) == 0)
			break;
	}
	if (p >= bp + st.st_size)
		goto fail;

#define	EXPAND(e)	e = p; while (*p++);
	EXPAND(pw.pw_name);
	EXPAND(pw.pw_passwd);
	pw.pw_uid = atoi(p); EXPAND(t);
	pw.pw_gid = atoi(p); EXPAND(t);
	EXPAND(pw.pw_class);
	pw.pw_change = (time_t)atol(p); EXPAND(t);
	pw.pw_expire = (time_t)atol(p); EXPAND(t);
	EXPAND(pw.pw_gecos);
	EXPAND(pw.pw_dir);
	EXPAND(pw.pw_shell);

	if (crypt_checkpass(argp->oldpass, pw.pw_passwd) != 0)
		goto fail;

	if (!nopw && badchars(argp->newpw.pw_passwd))
		goto fail;
	if (!nogecos && badchars(argp->newpw.pw_gecos))
		goto fail;
	if (!nogecos && badchars(argp->newpw.pw_shell))
		goto fail;
	if (!ok_shell(argp->newpw.pw_shell) || !ok_shell(pw.pw_shell))
		goto fail;

	/*
	 * Get the new password.  Reset passwd change time to zero; when
	 * classes are implemented, go and get the "offset" value for this
	 * class and reset the timer.
	 */
	if (!nopw) {
		pw.pw_passwd = argp->newpw.pw_passwd;
		pw.pw_change = 0;
	}
	if (!nogecos)
		pw.pw_gecos = argp->newpw.pw_gecos;
	if (!noshell)
		pw.pw_shell = argp->newpw.pw_shell;

	for (n = 0, p = pw.pw_gecos; *p; p++) {
		if (*p == '&')
			n = n + strlen(pw.pw_name) - 1;
	}
	if (strlen(pw.pw_name) + 1 + strlen(pw.pw_passwd) + 1 +
	    strlen((snprintf(buf, sizeof buf, "%u", pw.pw_uid), buf)) + 1 +
	    strlen((snprintf(buf, sizeof buf, "%u", pw.pw_gid), buf)) + 1 +
	    strlen(pw.pw_gecos) + n + 1 + strlen(pw.pw_dir) + 1 +
	    strlen(pw.pw_shell) >= 1023)
		goto fail;

	pfd = open(master, O_RDONLY, 0);
	if (pfd < 0) {
		syslog(LOG_ERR, "cannot open %s", master);
		goto fail;
	}

	tfd = pw_lock(0);
	if (tfd < 0)
		goto fail;

	pw_copy(pfd, tfd, &pw, NULL);
	pw_mkdb(pw.pw_name, 0);
	free(bp);

	if (fork() == 0) {
		chdir("/var/yp");
		(void)umask(022);
		system(make_arg);
		exit(0);
	}
	return (0);

fail:
	if (bp)
		free(bp);
	if (pfd >= 0)
		close(pfd);
	free(master);
	return (1);
}
@


1.32
log
@use crypt_checkpass to check password
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.31 2013/11/27 21:25:40 deraadt Exp $	*/
@


1.31
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.30 2012/12/04 02:24:47 deraadt Exp $	*/
d172 1
a172 1
	if (strcmp(crypt(argp->oldpass, pw.pw_passwd), pw.pw_passwd) != 0)
@


1.30
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.29 2009/10/27 23:59:31 deraadt Exp $	*/
d81 1
a81 1
		if (!isprint(*s))
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.28 2006/04/02 01:29:29 deraadt Exp $	*/
a28 1
#include <sys/param.h>
@


1.28
log
@#ifdef lint not LINT
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.27 2004/04/20 23:21:23 millert Exp $	*/
a27 4

#ifndef lint
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.27 2004/04/20 23:21:23 millert Exp $";
#endif
@


1.27
log
@Adapt to new pw_copy() API, closes PR 3698.
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.26 2003/07/06 21:57:27 deraadt Exp $	*/
d29 2
a30 2
#ifndef LINT
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.26 2003/07/06 21:57:27 deraadt Exp $";
@


1.26
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.25 2003/06/02 21:08:26 maja Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.25 2003/06/02 21:08:26 maja Exp $";
d224 1
a224 1
	pw_copy(pfd, tfd, &pw);
@


1.25
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.24 2003/04/26 18:28:25 pvalchev Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.24 2003/04/26 18:28:25 pvalchev Exp $";
d55 5
@


1.24
log
@%u expands to 11 chars; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.23 2002/06/20 03:43:41 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.23 2002/06/20 03:43:41 deraadt Exp $";
@


1.23
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.22 2002/05/22 06:35:44 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.22 2002/05/22 06:35:44 deraadt Exp $";
d116 1
a116 1
	char	buf[10], *bp = NULL, *p, *t;
@


1.22
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.21 2001/08/17 14:04:36 espie Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.21 2001/08/17 14:04:36 espie Exp $";
d62 1
a62 2
ok_shell(name)
	char *name;
d78 1
a78 2
badchars(base)
	char *base;
d97 1
a97 3
subst(s, from, to)
	char *s;
	char from, to;
d112 1
a112 2
make_passwd(argp)
	yppasswd *argp;
d115 1
a115 1
	int     pfd, tfd;
d135 2
d203 1
a203 1
	for (n = 0, p = pw.pw_gecos; *p; p++)
d206 1
@


1.21
log
@clean up after Todd.
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.20 2001/07/08 21:18:11 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.20 2001/07/08 21:18:11 deraadt Exp $";
d210 2
a211 2
	    strlen((sprintf(buf, "%u", pw.pw_uid), buf)) + 1 +
	    strlen((sprintf(buf, "%u", pw.pw_gid), buf)) + 1 +
@


1.20
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.19 2000/11/26 01:29:43 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.19 2000/11/26 01:29:43 millert Exp $";
d227 1
a227 1
	pw_mkdb(pw.pw_name);
@


1.19
log
@Update for pw_mkdb(3) interface change.  All but vipw and userdel can
specify a username (and thus avoid rebuilding the while database).
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.18 1999/08/06 20:41:05 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.18 1999/08/06 20:41:05 deraadt Exp $";
d68 1
a68 1
	while (sh = getusershell()) {
@


1.18
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.17 1998/01/28 21:20:37 maja Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.17 1998/01/28 21:20:37 maja Exp $";
d227 1
a227 1
	pw_mkdb();
@


1.17
log
@Added futher checks... from theo -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.16 1997/11/17 23:56:20 gene Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.16 1997/11/17 23:56:20 gene Exp $";
d210 2
a211 2
	    strlen((sprintf(buf, "%d", pw.pw_uid), buf)) + 1 +
	    strlen((sprintf(buf, "%d", pw.pw_gid), buf)) + 1 +
@


1.16
log
@Check if we get a valid fd from pw_lock().
@
text
@d1 1
a1 1
/*	$OpenBSD: yppasswdd_mkpw.c,v 1.15 1997/08/19 07:00:51 niklas Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.15 1997/08/19 07:00:51 niklas Exp $";
d61 17
d188 2
@


1.15
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppasswdd_mkpw.c,v 1.14 1997/07/21 19:22:57 deraadt Exp $";
d204 3
@


1.14
log
@Wall
@
text
@d1 2
d35 1
a35 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.13 1997/06/17 10:13:14 niklas Exp $";
@


1.13
log
@Add a -d flag which takes the directory where the YP password files are.
This change makes it possible to separate the host's passwords from the ones
served to YP clients.
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.12 1997/02/18 23:38:58 provos Exp $";
d48 1
@


1.12
log
@open master.passwd before doing pw_copy
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.11 1997/02/18 22:44:49 provos Exp $";
d36 1
d43 1
d48 2
d56 1
d79 17
d99 1
a99 1
	struct passwd *pw;
d101 6
a106 2
	char	buf[10], *p;
	int	alen;
d108 5
a112 2
	pw = getpwnam(argp->newpw.pw_name);
	if (!pw)
d114 45
d160 2
a161 2
	if (strcmp(crypt(argp->oldpass, pw->pw_passwd), pw->pw_passwd) != 0)
		return (1);
d164 1
a164 1
		return (1);
d166 1
a166 1
		return (1);
d168 1
a168 1
		return (1);
d176 2
a177 2
		pw->pw_passwd = argp->newpw.pw_passwd;
		pw->pw_change = 0;
d180 1
a180 1
		pw->pw_gecos = argp->newpw.pw_gecos;
d182 1
a182 1
		pw->pw_shell = argp->newpw.pw_shell;
d184 1
a184 1
	for (alen = 0, p = pw->pw_gecos; *p; p++)
d186 12
a197 7
			alen = alen + strlen(pw->pw_name) - 1;
	if (strlen(pw->pw_name) + 1 + strlen(pw->pw_passwd) + 1 +
	    strlen((sprintf(buf, "%d", pw->pw_uid), buf)) + 1 +
	    strlen((sprintf(buf, "%d", pw->pw_gid), buf)) + 1 +
	    strlen(pw->pw_gecos) + alen + 1 + strlen(pw->pw_dir) + 1 +
	    strlen(pw->pw_shell) >= 1023) {
		return (1);
a199 5
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY, 0);
	if (pfd < 0)
		pw_error(_PATH_MASTERPASSWD, 1, 1);

	pw_init();
d201 1
a201 2

	pw_copy(pfd, tfd, pw);
d203 1
d207 1
a207 1
		(void) umask(022);
a211 8
}

/*
int
do_mkdb()
{
	int pstat;
	pid_t pid;
d213 7
a219 14
	(void)printf("%s: rebuilding the database...\n", progname);
	(void)fflush(stdout);
	if (!(pid = vfork())) {
		execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p", tempname, NULL);
		warn(_PATH_PWD_MKDB);
		warnx("%s: unchanged", _PATH_MASTERPASSWD);
		pw_abort();
		_exit(1);
	}
	pid = waitpid(pid, &pstat, 0);
	if (pid == -1 || !WIFEXITED(pstat) || WEXITSTATUS(pstat) != 0)
		return(0);
	(void)printf("%s: done\n", progname);
	return(1);
a220 1
*/
@


1.11
log
@reversed changes
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.10 1997/02/18 14:05:40 provos Exp $";
d39 1
d120 4
@


1.10
log
@increase max. buffer size to pass checks for crypt output > 10 chars.
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.9 1996/12/06 01:54:58 deraadt Exp $";
d67 1
a67 1
	if (ampr > _PASSWORD_LEN)
d78 1
a78 1
	char	buf[_PASSWORD_LEN], *p;
@


1.9
log
@vfork w/ exit botch
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.8 1996/08/31 13:54:13 deraadt Exp $";
d67 1
a67 1
	if (ampr > 10)
d78 1
a78 1
	char	buf[10], *p;
@


1.8
log
@constrain & expansion to LINE_MAX for safety
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.7 1996/08/30 15:10:02 deraadt Exp $";
d146 4
a149 1
		pw_error(_PATH_PWD_MKDB, 1, 1);
@


1.7
log
@test before commiting, theo
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.6 1996/08/30 13:09:14 deraadt Exp $";
d78 2
a94 3
	pw_init();
	tfd = pw_lock(0);

d108 14
@


1.6
log
@more careful; found by das33@@cornell.edu fixed by me
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.5 1996/08/08 16:14:50 deraadt Exp $";
a55 1
	char *s = match;
d57 1
d59 1
a59 1
	for (s = match; *s; s++) {
@


1.5
log
@check for bad chars
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.4 1996/06/26 22:11:27 maja Exp $";
d53 2
a54 2
badchar(base, match)
	char *base, *match;
d57 1
d59 4
a62 2
	while (*s)
		if (strchr(base, *s++))
d64 5
d86 1
a86 1
	if (!nopw && badchar(argp->newpw.pw_passwd, ":\n\t"))
d88 1
a88 1
	if (!nogecos && badchar(argp->newpw.pw_gecos, ":\n\t"))
d90 1
a90 1
	if (!nogecos && badchar(argp->newpw.pw_shell, ":\n\t"))
@


1.4
log
@Copyright fixes and cleaned up after move to use of libutil. /moj
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.3 1996/05/22 11:36:01 deraadt Exp $";
d53 12
d76 7
@


1.3
log
@libutil
@
text
@d13 5
a17 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d33 1
a33 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.2 1995/11/01 17:40:35 deraadt Exp $";
d44 1
a44 3

#include "pw_util.h"
#include "pw_copy.h"
@


1.2
log
@+ from moj
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.3 1995/06/05 10:15:38 moj Exp $";
d67 1
a67 2
	pfd = pw_lock();
	tfd = pw_tmp();
@


1.1
log
@add ypserv
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: yppasswdd_mkpw.c,v 1.2 1994/05/29 10:20:26 moj Exp root $";
d42 3
a44 1
#include "yplog.h"
d57 5
a61 11
	int pfd, tfd;
	
	yplog_line("enter make_passwd");

	if (!(pw = getpwnam(argp->newpw.pw_name))) {
	  yplog_date("yppasswdd: unknown user");
	  yplog_line(argp->newpw.pw_name);
	  return(TRUE);
	}
	
	yplog_line("get user done");
d63 2
a64 7
	if (strcmp(crypt(argp->oldpass, pw->pw_passwd), pw->pw_passwd) != 0) {
	  yplog_date("yppasswdd: incorrect password");
	  yplog_line(argp->newpw.pw_name);
	  return(TRUE);
	}
	
	yplog_line("password ok");
d75 8
a82 14
	if (!(nopw)) {
	  pw->pw_passwd = argp->newpw.pw_passwd;
	  pw->pw_change = 0;
	}

	if (!(nogecos)) {
	  pw->pw_gecos = argp->newpw.pw_gecos;
	}

	if (!(noshell)) {
	  pw->pw_shell = argp->newpw.pw_shell;
	}

	yplog_line("before pw_copy");
a84 7

	yplog_line("before pw_mkdb");

/*
	if (!pw_mkdb())
		pw_error((char *)NULL, 0, 0);
*/
a86 2
	yplog_line("before fork");

d88 4
a91 4
	  chdir("/var/yp");
	  (void) umask(022);
	  system(make_arg);
	  exit(0);
d93 2
a94 6
	
	yplog_line("exit make_passwd");

	return(FALSE);

};
@
