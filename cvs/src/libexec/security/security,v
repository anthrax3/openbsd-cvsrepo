head	1.38;
access;
symbols
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.19.0.4
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17;
locks; strict;
comment	@# @;


1.38
date	2016.12.27.09.17.52;	author jca;	state Exp;
branches;
next	1.37;
commitid	3qP8ymCdYHblqMMe;

1.37
date	2016.10.22.18.35.12;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	13LXbYfn7lcs6kkW;

1.36
date	2015.07.21.19.07.13;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	O1auMCahbzS25wG1;

1.35
date	2015.04.21.10.24.22;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	jhmhJW94uZQdfIDI;

1.34
date	2015.03.27.13.26.19;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	9z6zyzBveSL4pl3Q;

1.33
date	2015.03.27.12.33.36;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	ngoydny1VIkF38y5;

1.32
date	2014.12.04.00.07.21;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	RRLmQHzVfoGsrMjT;

1.31
date	2014.07.14.08.49.27;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	TnjLmWRiVQrQ7w0g;

1.30
date	2014.06.26.16.00.16;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	PMvVA3iPDJJ4eyMH;

1.29
date	2014.06.24.16.18.30;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	GFDIJCqnkLVLjGdY;

1.28
date	2014.06.24.15.05.49;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	pv59wtG9ZfpfLJm8;

1.27
date	2014.04.29.21.30.20;	author dcoppa;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.21.15.46.03;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.20.22.15.49;	author ajacoutot;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.23.22.08.15;	author sthen;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.21.09.37.37;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.19.22.14.30;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.18.14.36.05;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.18.13.20.39;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.08.21.48.38;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2012.05.17.16.06.03;	author pascal;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.20.21.02.19;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.20.00.39.15;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.20.21.53.53;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.25.21.16.29;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.10.17.53.56;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.23.19.47.06;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.23.13.43.44;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.17.13.26.07;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.17.10.48.01;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.10.23.28.48;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.09.22.54.40;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.09.22.11.11;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.03.30.21.41.28;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.26.22.13.53;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.25.02.30.33;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.03.24.21.54.32;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.03.23.21.13.27;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Remove user uucp and group news from base.
@
text
@#!/usr/bin/perl -T

# $OpenBSD: security,v 1.37 2016/10/22 18:35:12 schwarze Exp $
#
# Copyright (c) 2011, 2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
# Copyright (c) 2011 Andrew Fresh <andrew@@afresh1.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use warnings;
use strict;

use Digest::SHA qw(sha256_hex);
use Errno qw(ENOENT);
use Fcntl qw(O_RDONLY O_NONBLOCK :mode);
use File::Basename qw(basename);
use File::Compare qw(compare);
use File::Copy qw(copy);
require File::Find;

use constant {
	BACKUP_DIR => '/var/backups/',
};

$ENV{PATH} = '/bin:/usr/bin:/sbin:/usr/sbin';
delete $ENV{ENV};
umask 077;

my $check_title;
my $return_code = 0;

sub nag ($$) {
	my ($cond, $msg) = @@_;
	if ($cond) {
		if ($check_title) {
			print "\n$check_title\n";
			undef $check_title;
		}
		print "$msg\n";
		$return_code = 1;
	}
	return $cond;
}

sub close_or_nag {
	my ($fh, $cmd) = @@_;
	my $res = close $fh;
	nag !$res, "$cmd: " .
	    ($! ? "error closing pipe: $!" : "exit code " . ($? >> 8));
	return $res;
}

sub check_access_file {
	my ($filename, $login) = @@_;
	return unless -e $filename;
	my $mode = (stat(_))[2];
	nag $mode & (S_IRUSR | S_IRGRP | S_IROTH) && ! -O $filename,
	    "Login $login is off but still has a valid shell " .
	    "and alternate access files in\n" .
	    "\t home directory are still readable.";
}

sub check_passwd {
	my $filename = '/etc/master.passwd';
	$check_title = "Checking the $filename file:";
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	my (%logins, %uids);
	while (my $line = <$fh>) {
		chomp $line;
		nag $line !~ /\S/,
		    "Line $. is a blank line."
		    and next;
		my @@f = split /:/, $line, -1;
		nag @@f != 10,
		    "Line $. has the wrong number of fields:\n$line";
		my ($name, $pwd, $uid, $gid, $class, $chg, $exp, $gecos,
		    $home, $shell) = @@f;
		next if $name =~ /^[+-]/;  # skip YP lines
		unless (nag $name eq '',
		    "Line $. has an empty login field:\n$line") {
			nag $name !~ /^[A-Za-z0-9_][-.A-Za-z0-9_]*\$?$/,
			    "Login $name has non-alphanumeric characters.";
			nag $logins{$name}++,
			    "Duplicate user name $name.";
		}
		nag length $name > 31,
		    "Login $name has more than 31 characters.";
		nag $pwd eq '' && !($name eq 'anoncvs' &&
				    $shell =~ /\/anoncvssh$/),
		    "Login $name has no password.";
		if ($pwd ne '' &&
		    $pwd ne 'skey' &&
		    length $pwd != 13 &&
		    $pwd !~ /^\$[0-9a-f]+\$/ &&
		    ($shell eq '' || $shell =~ /sh$/)) {
			nag -s "/etc/skey/$name",
			    "Login $name is off but still has a valid " .
			    "shell and an entry in /etc/skey.";
			nag -d $home && ! -r $home,
			    "Login $name is off but still has valid " .
			    "shell and home directory is unreadable\n" .
			    "\t by root; cannot check for existence " .
			    "of alternate access files."
			or check_access_file "$home/.$_", $name
			    foreach qw(ssh rhosts shosts);
		}
		nag $uid == 0 && $name ne 'root',
		    "Login $name has a user ID of 0.";
		nag $uid < 0,
		    "Login $name has a negative user ID.";
		nag $uids{$uid}++,
		    "Login $name has duplicate user ID $uid.";
		nag $gid < 0,
		    "Login $name has a negative group ID.";
		nag $exp != 0 && $exp < time,
		    "Login $name has expired.";
	}
	close $fh;
}

# Backup the master password file; a special case, the normal backup
# mechanisms also print out file differences and we don't want to do
# that because this file has encrypted passwords in it.
sub backup_passwd {
	my $base = 'master.passwd';
	my $orig = "/etc/$base";
	my $curr = BACKUP_DIR . "$base.current";
	if (!-s $curr) {
		# nothing
	} elsif (compare $curr, $orig) {
		copy $curr, BACKUP_DIR . "$base.backup";
	} else {
		return;
	}
	copy $orig, $curr;
	chown 0, 0, $curr;
}

# Check the group file syntax.
sub check_group {
	my $filename = '/etc/group';
	$check_title = "Checking the $filename file:";
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	my (%names, $global_yp);
	while (my $line = <$fh>) {
		chomp $line;
		nag $global_yp,
		    'Global YP inclusion ("+") is not the last line.'
		    and undef $global_yp;
		if ($line eq '+') {
			$global_yp = 1;
			next;
		}
		nag $line !~ /\S/,
		    "Line $. is a blank line."
		    and next;
		my @@f = split /:/, $line, -1;
		nag @@f != 4,
		    "Line $. has the wrong number of fields:\n$line";
		my ($name, $pwd, $gid, $members) = @@f;
		next if $name =~ /^[+-]/;  # skip YP lines
		unless (nag $name eq '',
		    "Line $. has an empty group name field:\n$line") {
			nag $name !~ /^[A-Za-z0-9_][-.A-Za-z0-9_]*$/,
			    "Group $name has non-alphanumeric characters.";
			nag $names{$name}++,
			    "Duplicate group name $name.";
		}
		nag length $name > 31,
		    "Group $name has more than 31 characters.";
		nag $gid =~ /[^\d]/,
		    "Group $name has an invalid group ID.";
	}
	close $fh;
}

sub check_umask {
	my ($filename) = @@_;
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	my $umaskset;
	while (<$fh>) {
		next unless /^\s*umask\s+([0-7]+)/;
		my $umask = "0$1";
		$umaskset = 1;
		my ($other, $group) = reverse split '', $umask;
		nag $group =~ /^[0145]$/,
		    "Root umask is group writable";
		nag $other =~ /^[0145]$/,
		    "Root umask is other writable";
	}
	close $fh;
	return $umaskset;
}

# This type of test by spawning a shell is messy and fragile.
# Instead, consider modifying the shells to warn about '.' in the PATH.
sub check_root_path {
	my ($path, $filename) = @@_;
	nag !(defined $path && $path =~ s/^PATH=[:\s]*//),
	    "Failed to find PATH in $filename."
	    and return;
	foreach my $dir (split /[:\s]+/, $path) {
		nag $dir eq '.', "The root path includes ." and next;
		next unless -d $dir;
		my $mode = (stat(_))[2];
		nag $mode & S_IWGRP,
		    "Root path directory $dir is group writable.";
		nag $mode & S_IWOTH,
		    "Root path directory $dir is other writable.";
	}
}

# Check for umask values and root paths in startup files.
sub check_csh {
	my @@list = qw(/etc/csh.cshrc /etc/csh.login /root/.cshrc /root/.login);
	$check_title = "Checking root csh paths, umask values:\n@@list";

	my $umaskset = 0;
	foreach my $filename (@@list) {
		next unless -s $filename;
		$umaskset = 1 if check_umask $filename;

		nag !(open my $fh, '-|', qw(/bin/csh -f -c),
			"eval 'source $filename' >& /dev/null; " .
			"echo PATH=\$path"),
		    "cannot spawn /bin/csh: $!"
		    and next;
		my @@output = <$fh>;
		close_or_nag $fh, "csh $filename" or next;
		chomp @@output;
		check_root_path pop @@output, $filename;
	}
	nag !$umaskset,
	    "\nRoot csh startup files do not set the umask.";
}

sub check_sh {
	my @@list = qw(/etc/profile /root/.profile);
	$check_title = "Checking root sh paths, umask values:\n@@list";

	my @@env_path;
	my $umaskset = 0;
	foreach my $filename (@@list) {
		next unless -s $filename;
		$umaskset ||= check_umask($filename);

		nag !(open my $fh, '-|', qw(/bin/sh -c),
			". $filename; echo ENV=\$ENV; echo PATH=\$PATH"),
		    "cannot spawn /bin/sh: $!"
		    and next;
		my @@output = <$fh>;
		close_or_nag $fh, "sh $filename" or next;
		chomp @@output;
		check_root_path pop @@output, $filename;

		my $env = pop @@output;
		nag !(defined $env && $env =~ /^ENV=\s*(\S*)/),
		    "Failed to find ENV in $filename."
		    and next;
		push @@env_path, $1 if $1 ne '';
	}
	nag !$umaskset,
	    "\nRoot sh startup files do not set the umask.";
	return @@env_path;
}

sub check_ksh {
	my @@list = ('/etc/ksh.kshrc', @@_);
	$check_title = "Checking root ksh paths, umask values:\n@@list";

	# Usually, we are at HOME anyway, but for the ENV check, this
	# is particularly important, so make sure we are really there.
	chdir '/root';

	# A good .kshrc will not have a umask or path, 
	# that being set in .profile; check anyway.
	foreach my $filename (@@list) {
		next unless -s $filename;
		check_umask($filename);

		nag !(open my $fh, '-|', qw(/bin/ksh -c),
			". $filename; echo PATH=\$PATH"),
		    "cannot spawn /bin/ksh: $!"
		    and next;
		my @@output = <$fh>;
		close_or_nag $fh, "ksh $filename" or next;
		chomp @@output;
		check_root_path pop @@output, $filename;
	}
}

# Uudecode should not be in the /etc/mail/aliases file.
sub check_mail_aliases {
	my $filename = '/etc/mail/aliases';
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	no warnings 'uninitialized';
	nag /^((?:uu)?decode)/,
	    "There is an entry for $1 in the $filename file."
	    while <$fh>;
	close $fh;
}

# hostname.if files may contain secrets and should not be world-readable.
sub check_hostname_if {
	while (my $filename = glob '/etc/hostname.*') {
		next unless -e $filename;
		my $mode = (stat(_))[2];
		nag $mode & S_IRWXO,
		    "$filename is world readable.";
	}
}

# hosts.lpd should not have + signs.
sub check_hosts_lpd {
	my $filename = '/etc/hosts.lpd';
	-s $filename or return;
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	nag /^\+/ && !/^\+@@/,
	    "Plus sign in $filename file."
	    while <$fh>;
	close $fh;
}

sub find_homes {
	my $filename = '/etc/passwd';
	nag !(open my $fh, '<', $filename),
	    "open: $filename: $!"
	    and return [];
	my $homes = [];
	while (<$fh>) {
		my $entry = [ @@{[split /:/]}[0,2,5] ];
		chomp;
		nag !defined $entry->[2],
		    "Incomplete line \"$_\" in $filename."
		    and next;
		chomp $entry->[2];
		push @@$homes, $entry;
	}
	close $fh;
	return $homes;
}

# Check for special users with .rhosts/.shosts files.
# Only root should have .rhosts/.shosts files.
sub check_rhosts_owner {
	my ($name, $uid, $home) = @@_;
	return if $name =~ /^[+-]/;  # skip YP lines
	foreach my $base (qw(rhosts shosts)) {
		my $filename = "$home/.$base";
		next unless -s $filename;
		nag ! -O $filename &&
		    ($name eq 'ftp' || ($uid < 100 && $name ne 'root')),
		    "$filename is not owned by root.";
	}
}

# Also, .rhosts/.shosts files should not have plus signs.
sub check_rhosts_content {
	my ($name, $uid, $home) = @@_;
	foreach my $base (qw(rhosts shosts)) {
		my $filename = "$home/.$base";
		next unless -s $filename;
		nag !sysopen(my $fh, $filename, O_RDONLY | O_NONBLOCK),
		    "open: $filename: $!"
		    and next;
		nag !(-f $fh),
		    "$filename is not a regular file"
		    and next;
		local $_;
		nag /^\+\s*$/,
		    "$filename has + sign in it."
		    while <$fh>;
		close $fh;
	}
}

# Home directories should not be owned by someone else or writeable.
sub check_homedir {
	my ($name, $uid, $home) = @@_;
	return if $name =~ /^[+-]/;  # skip YP lines
	return unless -d $home;
	my ($mode, $fuid) = (stat(_))[2,4];
	nag $fuid && $fuid != $uid,
	    "user $name home directory is owned by " .
	    ((getpwuid $fuid)[0] // $fuid);
	nag $mode & S_IWGRP,
	    "user $name home directory is group writable";
	nag $mode & S_IWOTH,
	    "user $name home directory is other writable";
}

# Files that should not be owned by someone else or readable.
sub check_dot_readable {
	my ($name, $uid, $home) = @@_;
	return if $name =~ /^[+-]/;  # skip YP lines
	foreach my $f (qw(
	    .netrc .rhosts .gnupg/secring.gpg .gnupg/random_seed
	    .pgp/secring.pgp .shosts .ssh/identity .ssh/id_dsa .ssh/id_ecdsa
	    .ssh/id_rsa .ssh/id_ed25519
	)) {
		next unless -e "$home/$f";
		my ($mode, $fuid) = (stat(_))[2,4];
		nag $fuid && $fuid != $uid,
		    "user $name $f file is owned by " .
		    ((getpwuid $fuid)[0] // $fuid);
		nag $mode & S_IRGRP,
		    "user $name $f file is group readable";
		nag $mode & S_IROTH,
		    "user $name $f file is other readable";
		nag $mode & S_IWGRP,
		    "user $name $f file is group writable";
		nag $mode & S_IWOTH,
		    "user $name $f file is other writable";
	}
}

# Files that should not be owned by someone else or writeable.
sub check_dot_writeable {
	my ($name, $uid, $home) = @@_;
	return if $name =~ /^[+-]/;  # skip YP lines
	foreach my $f (qw(
	    .bashrc .bash_profile .bash_login .bash_logout .cshrc
	    .emacs .exrc .forward .fvwmrc .inputrc .kshrc .login
	    .logout .nexrc .profile .screenrc .ssh .ssh/config
	    .ssh/authorized_keys .ssh/authorized_keys2 .ssh/environment
	    .ssh/known_hosts .ssh/rc .tcshrc .twmrc .xsession .xinitrc
	    .Xdefaults .Xauthority
        )) {
		next unless -e "$home/$f";
		my ($mode, $fuid) = (stat(_))[2,4];
		nag $fuid && $fuid != $uid,
		    "user $name $f file is owned by " .
		    ((getpwuid $fuid)[0] // $fuid);
		nag $mode & S_IWGRP,
		    "user $name $f file is group writable";
		nag $mode & S_IWOTH,
		    "user $name $f file is other writable";
	}
}

# Mailboxes should be owned by the user and unreadable.
sub check_mailboxes {
	my $dir = '/var/mail';
	nag !(opendir my $dh, $dir), "opendir: $dir: $!" and return;
	foreach my $name (readdir $dh) {
		next if $name =~ /^\.\.?$/;
		next if $name =~ /.\.lock$/;
		my ($mode, $fuid, $fgid) = (stat "$dir/$name")[2,4,5];
		unless (defined $mode) {
			nag !$!{ENOENT}, "stat: $dir/$name: $!";
			next;
		}
		my $fname = (getpwuid $fuid)[0] // $fuid;
		my $gname = (getgrgid $fgid)[0] // $fgid;
		nag $fname ne $name,
		    "user $name mailbox is owned by $fname";
		nag S_IMODE($mode) != (S_IRUSR | S_IWUSR),
		    sprintf 'user %s mailbox is %s, group %s',
		        $name, strmode($mode), $gname;
	}
	closedir $dh;
}

# File systems should not be globally exported.
sub check_exports {
	my $filename = '/etc/exports';
	return unless -e $filename;
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;

	LINE: while (<$fh>) {
		chomp;
		next if /^(?:#|$)/;

		my @@fs;
		my $readonly = 0;
		foreach (split) {
			if (/^\//)                   { push @@fs, $_; }
			elsif ($_ eq '-ro')          { $readonly = 1; }
			elsif (/^(?:[^-]|-network)/) { next LINE; }
		}

		nag 1, "File system @@fs globally exported, "
		    . ($readonly ? 'read-only.' : 'read-write.');
	}
	close $fh;
}

sub strmode_x {
	my ($mode, $x, $s) = @@_;
	$x &= $mode;
	$s &= $mode;
	return ($x && $s) ? 's' : $x ? 'x' : $s ? 'S' : '-';
}

sub strmode {
	my ($mode) = @@_;

	my %types = (
		S_IFDIR,  'd',    # directory
		S_IFCHR,  'c',    # character special
		S_IFBLK,  'b',    # block special
		S_IFREG,  '-',    # regular
		S_IFLNK,  'l',    # symbolic link
		S_IFSOCK, 's',    # socket
		S_IFIFO,  'p',    # fifo
	);

	return
	      ($types{ $mode & S_IFMT } || '?')
	    . (($mode & S_IRUSR) ? 'r' : '-')
	    . (($mode & S_IWUSR) ? 'w' : '-')
	    . (strmode_x $mode, S_IXUSR, S_ISUID)
	    . (($mode & S_IRGRP) ? 'r' : '-')
	    . (($mode & S_IWGRP) ? 'w' : '-')
	    . (strmode_x $mode, S_IXGRP, S_ISGID)
	    . (($mode & S_IROTH) ? 'r' : '-')
	    . (($mode & S_IWOTH) ? 'w' : '-')
	    . (strmode_x $mode, S_IXOTH, S_ISVTX);
}

sub find_special_files {
	my %skip;

	%skip = map { $_ => 1 } split ' ', $ENV{SUIDSKIP}
	    if $ENV{SUIDSKIP};

	# Add mount points of non-local file systems
	# to the list of directories to skip.
	nag !(open my $fh, '-|', 'mount'),
	    "cannot spawn mount: $!"
	    and return;
	while (<$fh>) {
		my ($path, $type) = /\son\s+(.*?)\s+type\s+(\w+)/;
		$skip{$path} = 1 if $path &&
		    ($type =~ /^(?:a|nnp|proc)fs$/ || !/\(.*local.*\)/);
	}
	close_or_nag $fh, "mount" or return;

	my $setuid_files = {};
	my $device_files = {};
	my $uudecode_is_setuid = 0;

	File::Find::find({no_chdir => 1, wanted => sub {

		if ($skip{$_}) {
			no warnings 'once';
			$File::Find::prune = 1;
			return;
		}

		my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
		    $atime, $mtime, $ctime, $blksize, $blocks) = lstat;
		unless (defined $dev) {
			nag !$!{ENOENT}, "stat: $_: $!";
			return;
		}

		# SUID/SGID files
		my $file = {};
		if (-f _ && $mode & (S_ISUID | S_ISGID)) {
			$setuid_files->{$File::Find::name} = $file;
			$uudecode_is_setuid = 1
			    if basename($_) eq 'uudecode';
		}

		# Special Files
		elsif (!-d _ && !-f _ && !-l _ && !-S _ && !-p _ ) {
			$device_files->{$File::Find::name} = $file;
			$file->{major} = (($rdev >> 8) & 0xff) . ',';
			$file->{minor} = (($rdev >> 8) & 0xffff00) |
			    ($rdev & 0xff);
		} else {
			return;
		}

		$file->{mode}    = $mode;
		$file->{strmode} = strmode $mode;
		$file->{nlink}   = $nlink;
		$file->{user}    = (getpwuid $uid)[0] // $uid;
		$file->{group}   = (getgrgid $gid)[0] // $gid;
		$file->{size}    = $size;
		@@$file{qw(wday mon day time year)} =
		    split ' ', localtime $mtime;
	}}, '/');

	nag $uudecode_is_setuid, 'Uudecode is setuid.';
	return $setuid_files, $device_files;
}

sub adjust_columns {
	my (@@table) = @@_;

	my @@s;
	foreach my $row (@@table) {
		for (0 .. $#$row) {
			$s[$_] = length $row->[$_]
			    if (!$s[$_] || length $row->[$_] > $s[$_]);
		}
	}
	$s[-1] = '0';
	my $fmt = join ' ', map { m/(\d+)/ && "%-$1s"} @@s;

	return map { sprintf $fmt, @@$_ } @@table;
}

# Display any changes in setuid/setgid files and devices.
sub check_filelist {
	my ($files, $mode) = @@_;
	my $current = BACKUP_DIR . "$mode.current";
	my $backup  = BACKUP_DIR . "$mode.backup";
	my @@fields  = (
	    qw(strmode nlink user group),
	    $mode eq 'device' ?  qw(major minor) : 'size',
	    qw(mon day time year)
	);

	my %current;
	if (-s $current) {
		nag !(open my $fh, '<', $current), "open: $current: $!"
		    and return;
		while (<$fh>) {
			chomp;
			my (%f, $file);
			(@@f{@@fields}, $file) = split ' ', $_, @@fields + 1;
			$current{$file} = \%f;
		}
		close $fh;
	}

	my %changed;
	foreach my $f (sort keys %$files) {
		if (my $old = delete $current{$f}) {
			next if $mode eq 'device' &&
			    !S_ISBLK($files->{$f}{mode});
			foreach my $k (@@fields) {
				next if $old->{$k} eq $files->{$f}{$k};
				push @@{$changed{changes}},
				    [ @@$old{@@fields}, $f ],
				    [ @@{$files->{$f}}{@@fields}, $f ];
				last;
			}
			next;
		}
		push @@{$changed{additions}}, [ @@{$files->{$f}}{@@fields}, $f ];
	}
	foreach my $f (sort keys %current) {
		push @@{$changed{deletions}}, [ @@{$current{$f}}{@@fields}, $f ];
	};

	foreach my $k (qw( additions deletions changes )) {
		next unless exists $changed{$k};
		$mode = 'block device' if $mode eq 'device' && $k eq 'changes';
		$check_title = (ucfirst $mode) . " $k:";
		nag 1, $_ for adjust_columns @@{$changed{$k}};
	}

	return if !%changed;
	copy $current, $backup;

	nag !(open my $fh, '>', $current), "open: $current: $!" and return;
	print $fh "@@{$files->{$_}}{@@fields} $_\n" foreach sort keys %$files;
	close $fh;
}

# Check for block and character disk devices that are readable or writeable
# or not owned by root.operator.
sub check_disks {
	my ($files) = @@_;

	my $disk_re = qr/
	    \/
	    (?:ccd|dk|fd|hd|hk|hp|jb|kra|ra|rb|rd|rl|rx|rz|sd|up|vnd|wd|xd)
	    \d+ [B-H]? [a-p] 
	    $
	/x;

	foreach my $file (sort keys %$files) {
		next if $file !~ /$disk_re/;
		my $f = $files->{$file};
		nag $f->{user} ne 'root' || $f->{group} ne 'operator' ||
			S_IMODE($f->{mode}) != (S_IRUSR | S_IWUSR | S_IRGRP),
		    sprintf("Disk %s is user %s, group %s, permissions %s.",
			$file, $f->{user}, $f->{group}, $f->{strmode});
	}
}

# Check special files and system binaries.
#
# Create the mtree tree specifications using:
#
#       mtree -cx -p DIR -K sha256digest,type > /etc/mtree/DIR.secure
#       chown root:wheel /etc/mtree/DIR.secure
#       chmod 600 /etc/mtree/DIR.secure
#
# Note, this is not complete protection against Trojan horsed binaries, as
# the hacker can modify the tree specification to match the replaced binary.
# For details on really protecting yourself against modified binaries, see
# the mtree(8) manual page.
sub check_mtree {
	nag !-d '/etc/mtree', '/etc/mtree is missing' and return;

	if (open my $fh, '-|', qw(mtree -e -l -p / -f /etc/mtree/special)) {
		nag 1, $_ for map { chomp; $_ } <$fh>;
		close_or_nag $fh, "mtree special";
	} else { nag 1, "cannot spawn mtree: $!"; }

	while (my $filename = glob '/etc/mtree/*.secure') {
		nag !(open my $fh, '<', $filename),
		    "open: $filename: $!"
		    and next;

		my $tree;
		while (<$fh>) {
			last unless /^#/;
			($tree) = /^#\s+tree:\s+(.*)/ and last;
		}
		next unless $tree;

		$check_title = "Checking system binaries in $tree:";
		nag !(open $fh, '-|', 'mtree', '-f', $filename, '-p', $tree),
		    "cannot spawn mtree: $!"
		    and next;
		nag 1, $_ for map { chomp; $_ } <$fh>;
		close_or_nag $fh, "mtree $filename";
	}
}

sub diff {
	nag !(open my $fh, '-|', qw(diff -ua), @@_),
	    "cannot spawn diff: $!"
	    and return;
	local $/;
	my $diff = <$fh>;
	{
		close $fh and last;
		nag $!, "diff: error closing pipe: $!" and last;
		nag $? >> 8 > 1, "diff: exit code " . ($? >> 8);
	}
	return nag !!$diff, $diff;
}

sub backup_if_changed {
	my ($orig) = @@_;

	my ($backup) = $orig =~ /(.*)/;
	if (index $backup, BACKUP_DIR) {
		$backup =~ s{^/}{};
		$backup =~ s{/}{_}g;
		$backup = BACKUP_DIR . $backup;
	}
	my $current = "$backup.current";
	$backup .= '.backup';
	my $last = -s $current ? $current : '/dev/null';
	$orig    = '/dev/null' unless -s $orig;

	diff $last, $orig or return;

	if (-s $current) {
		copy $current, $backup;
		chown 0, 0, $backup;
	}
	if ($orig eq '/dev/null') {
		unlink $current;
	} else {
		copy $orig, $current;
		chown 0, 0, $current;
	}
}

sub backup_digest {
	my ($orig) = @@_;

	my ($backup) = $orig =~ m{^/?(.*)};
	$backup =~ s{/}{_}g;
	my $current = BACKUP_DIR . "$backup.current.sha256";
	$backup = BACKUP_DIR . "$backup.backup.sha256";

	my $digest_new = 0;
	if (-s $orig) {
		if (open my $fh, '<', $orig) {
			binmode $fh;
			local $/;
			$digest_new = sha256_hex(<$fh>);
			close $fh;
		} else { nag 1, "open: $orig: $!"; }
	}

	my $digest_old = 0;
	if (-s $current) {
		if (open my $fh, '<', $current) {
			$digest_old = <$fh>;
			close $fh;
			chomp $digest_old;
		} else { nag 1, "open: $current: $!"; }
	}

	return if $digest_old eq $digest_new;

	if ($digest_old && $digest_new) {
		copy $current, $backup;
		chown 0, 0, $backup;
		chmod 0600, $backup;
	} elsif ($digest_old) {
		$check_title = "======\n$orig removed SHA-256 checksum\n======";
		unlink $current;
	} elsif ($digest_new) {
		$check_title = "======\n$orig new SHA-256 checksum\n======";
	}

	if ($digest_new) {
		if (open my $fh, '>', $current) {
			print $fh "$digest_new\n";
			close $fh;
		} else { nag 1, "open: $current: $!\n"; }
		chown 0, 0, $current;
		chmod 0600, $current;
	}

	nag $digest_old, "OLD: $digest_old";
	nag $digest_new, "NEW: $digest_new";
}

# List of files that get backed up and checked for any modifications.  Each
# file is expected to have two backups, /var/backups/file.{current,backup}.
# Any changes cause the files to rotate.
sub check_changelist {
	my $filename = '/etc/changelist';
	-s $filename or return;
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;

	my @@relative;
	while (<$fh>) {
		next if /^(?:#|\s*$)/;
		chomp;
		my $plus = s/^\+//;
		unless (/^\//) {
			push @@relative, $_;
			next;
		}
		my $tilda = /~$/;

		foreach (glob) {
			next if $_ eq '/etc/master.passwd';
			next if /~$/ && !$tilda;
			next if -d $_;

			if ($plus) {
				$check_title =
				    "======\n$_ SHA-256 checksums\n======";
				backup_digest $_;
			} else {
				$check_title =
				    "======\n$_ diffs (-OLD  +NEW)\n======";
				backup_if_changed $_;
			}
		}
	}
	close $fh;

	$check_title = "Skipped relative paths in changelist(5):";
	nag 1, $_ foreach @@relative;
}

# Make backups of the labels for any mounted disks
# and produce diffs when they change.
sub check_disklabels {
	nag !(open my $fh, '-|', qw(df -ln)),
	    "cannot spawn df: $!"
	    and return;
	my @@disks = sort map m{^/dev/(\w*\d*)[a-p]}, <$fh>;
	close_or_nag $fh, "df";

	foreach my $disk (@@disks) {
		$check_title = "======\n$disk diffs (-OLD  +NEW)\n======";
		my $filename = BACKUP_DIR . "disklabel.$disk";
		system "disklabel $disk > $filename";
		backup_if_changed $filename;
		unlink $filename;
	}
}

# Backup the list of installed packages and produce diffs when it changes.
sub check_pkglist {
	$check_title = "======\nPackage list changes (-OLD  +NEW)\n======";
	my $filename = BACKUP_DIR . 'pkglist';
	system "pkg_info > $filename 2>&1";
	backup_if_changed $filename;
	unlink $filename;
}

# main program
check_passwd;
backup_passwd;
check_group;
check_csh;
check_ksh(check_sh);
$check_title = "Checking configuration files:";
check_mail_aliases;
check_hostname_if;
check_hosts_lpd;
$check_title = "Checking for special users with .rhosts/.shosts files.";
my $homes = find_homes;
check_rhosts_owner @@$_ foreach @@$homes;
$check_title = "Checking .rhosts/.shosts files syntax.";
check_rhosts_content @@$_ foreach @@$homes;
$check_title = "Checking home directories.";
check_homedir @@$_ foreach @@$homes;
$check_title = "Checking dot files.";
check_dot_readable @@$_ foreach @@$homes;
check_dot_writeable @@$_ foreach @@$homes;
$check_title = "Checking mailbox ownership.";
check_mailboxes;
$check_title = "Checking for globally exported file systems.";
check_exports;
$check_title = "Setuid/device find errors:";
my ($setuid_files, $device_files) = find_special_files;
$check_title = "Checking setuid/setgid files and devices:";
check_filelist $setuid_files, 'setuid' if $setuid_files;
$check_title = "Checking disk ownership and permissions.";
check_disks $device_files;
check_filelist $device_files, 'device' if $device_files;
$check_title = "Checking special files and directories.\n" .
    "Output format is:\n\tfilename:\n\t\tcriteria (shouldbe, reallyis)";
check_mtree;
$check_title = "Backing up and comparing configuration files.";
check_changelist;
$check_title = "Checking disklabels of mounted disks:";
check_disklabels;
check_pkglist;
exit $return_code;
@


1.37
log
@When checking ownership and modes of files in /var/mail/,
ignore *.lock files, to avoid pointless warning mails
reported by Philippe Meunier <meunier at ccs dot neu dot edu>;
OK florian@@ jca@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.36 2015/07/21 19:07:13 schwarze Exp $
d362 1
a362 2
		    ($name eq 'ftp' || $name eq 'uucp' ||
		    ($uid < 100 && $name ne 'root')),
@


1.36
log
@When reading untrusted user files, don't risk blocking, such that
users can't mount a DOS attack against security(8), and for additional
safety against race attacks, make sure they are regular files after
opening and before actually reading them.

Issue originally hinted at by Sevan Janiyan <venture37 at
geeklan dot com dot uk> based on a NetBSD commit message,
then commented on by tedu@@, problem finally confirmed by guenther@@,
who also provided feedback on the actual patch.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.35 2015/04/21 10:24:22 schwarze Exp $
d458 1
@


1.35
log
@When diff(1) finds differences, it returns an exit status of 1.
In that particular case, refrain from printing "diff: exit code 1"
because that exit status doesn't indicate an error condition.

Issue noticed by and patch OK'ed by ajacoutot@@.
"I agree with the goal, and I suspect the diff actually achieves it" guenther@@.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.34 2015/03/27 13:26:19 schwarze Exp $
d25 1
a25 1
use Fcntl qw(:mode);
d374 1
a374 1
		nag !open(my $fh, '<', $filename),
d376 3
@


1.34
log
@In mount(8) output, do not misparse lines where fs_spec ends with the
two characters "on", which can for example happen for NFS mounts.
Patch from Lauri Tirkkonen <lotheac at iki dot fi> on bugs@@.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.33 2015/03/27 12:33:36 schwarze Exp $
d741 5
a745 1
	close_or_nag $fh, "diff";
@


1.33
log
@If /etc/passwd contains incomplete lines ending before the
home directory field, warn explicitly rather than stumbling
into Perl "uninitialized value" warnings.
Issue reported by Denis Lapshin <deniza at mindall dot org>.
OK afresh1@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.32 2014/12/04 00:07:21 schwarze Exp $
d540 1
a540 1
		my ($path, $type) = /on\s+(.*?)\s+type\s+(\w+)/;
@


1.32
log
@AnonCVS is designed to work with a user account that has no password and a
very special shell, so do not complain about that particular combination.
Idea originally brought up by landry@@ five years ago, repeatedly forgotten.
Using feedback from sthen@@ millert@@ halex@@; OK landry@@ ajacoutot@@.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.31 2014/07/14 08:49:27 schwarze Exp $
d5 1
a5 1
# Copyright (c) 2011, 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d339 10
a348 1
	my $homes = [ map [ @@{[split /:/]}[0,2,5] ], <$fh> ];
@


1.31
log
@The file /etc/exports is now optional and not installed by default,
so do not complain when it is absent.

issue found by and patch ok by ajacoutot@@
"I don't do perl, but seems ok" deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.30 2014/06/26 16:00:16 schwarze Exp $
d98 2
a99 1
		nag $pwd eq '',
@


1.30
log
@Do not redirect STDERR of the main security(8) script to /dev/null,
not even for calling three particular functions, as that carries a risk
of hiding serious errors in the security(8) script itself: otto@@ found
and reported a bug (already fixed by now) where that hurt him.

Instead, only do the redirection where it is really needed, that is,
inside the forked csh(1) child process.  The csh(1) "eval" builtin is
required because the csh(1) "source" builtin apparently ignores
redirections.

No objections came up when showing this diff on tech@@.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.29 2014/06/24 16:18:30 schwarze Exp $
d464 1
@


1.29
log
@The Perl close() function, when called on pipe file descriptors,
provides information from wait(2), which needs careful inspection
in order to not hide errors.

Problem identified by florian@@ after a bug report from otto@@.
Fix based on a patch from florian@@, considerably tweaked by me.
OK florian@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.28 2014/06/24 15:05:49 schwarze Exp $
d233 2
a234 1
			"source $filename; echo PATH=\$path"),
a886 3

open my $olderr, '>&', \*STDERR;
open STDERR, '>', '/dev/null';
a888 2
open STDERR, '>&', $olderr;

@


1.28
log
@Do not try to pass potentially non-existent array elements into
functions since that is going to kill the Perl interpreter.
While here, do not attempt to parse $PATH or $ENV when undefined.

Crash found the hard way with a dubious /root/.login file by otto@@ who
declares himself unable to read perl code even though he can apparently
debug it with ktrace(1) - thanks for the excellent bug report!

Feedback and ok florian@@.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.27 2014/04/29 21:30:20 dcoppa Exp $
d55 8
d237 1
a237 1
		close $fh;
d260 1
a260 1
		close $fh;
d294 1
a294 1
		close $fh;
d532 1
a532 1
	close $fh;
d699 1
a699 1
		close $fh;
d719 1
a719 1
		close $fh;
d729 1
a729 1
	close $fh;
d862 1
a862 1
	close $fh;
@


1.27
log
@
tedu ~/.klogin

ok henning@@ deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.26 2014/04/21 15:46:03 sthen Exp $
d5 1
a5 1
# Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d200 3
a202 2
	nag !($path =~ s/^PATH=[:\s]*//),
	    "Failed to find PATH in $filename.";
d231 1
a231 1
		check_root_path $output[-1], $filename;
d254 1
a254 1
		check_root_path $output[-1], $filename;
d256 2
a257 1
		nag !($output[-2] =~ /^ENV=\s*(\S*)/),
d288 1
a288 1
		check_root_path $output[-1], $filename;
@


1.26
log
@check perms on .ssh/id_ed25519; Fritjof Bornebusch
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.25 2014/04/20 22:15:49 ajacoutot Exp $
d106 1
a106 1
			    foreach qw(ssh rhosts shosts klogin);
d410 1
a410 1
	    .emacs .exrc .forward .fvwmrc .inputrc .klogin .kshrc .login
@


1.25
log
@check_hosts_equiv -> check_hosts_lpd
i.e. don't check for hosts.equiv anymore.

input/ok schwarze@@, ok sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.24 2014/03/23 22:08:15 sthen Exp $
d386 1
a386 1
	    .ssh/id_rsa 
@


1.24
log
@don't check ftpusers in security(8), from gsoares@@, ok afresh1@@ schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.23 2013/03/21 09:37:37 sthen Exp $
d311 9
a319 13
# Files that should not have + signs.
sub check_hosts_equiv {
	foreach my $base (qw(hosts.equiv shosts.equiv hosts.lpd)) {
		my $filename = "/etc/$base";
		next unless -s $filename;
		nag !(open my $fh, '<', $filename),
		    "open: $filename: $!"
		    and next;
		nag /^\+/ && !/^\+@@/,
		    "Plus sign in $filename file."
		    while <$fh>;
		close $fh;
	}
d886 1
a886 1
check_hosts_equiv;
@


1.23
log
@Correct the last change to untaint $fmt; it caused the final parameter of
the format string to be dropped, causing the year to be printed instead of
the filename, as reported by ajacoutot. ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.22 2013/03/19 22:14:30 sthen Exp $
a289 14
# Root and uucp should both be in /etc/ftpusers.
sub check_ftpusers {
	my $filename = '/etc/ftpusers';
	nag !(open my $fh, '<', $filename), "open: $filename: $!" and return;
	my %banned = qw(root 1 uucp 1);
	while (<$fh>) {
		chomp;
		delete $banned{$_};
	}
	nag 1, "\u$_ not listed in $filename file."
	    foreach sort keys %banned;
	close $fh;
}

a887 1
check_ftpusers;
@


1.22
log
@Untaint a variable used in an sprintf format string by using a regex and back-
reference. This diff from espie@@ after we worked through a few alternatives.

(Background: with perl's taint mode, any operation other than RE+backref, even
just taking a length of a tainted [user-supplied/untrusted] string, results in
a tainted variable. Perl 5.14 improves the checks in format strings to sprintf
which triggers with this script).
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.21 2013/03/18 14:36:05 sthen Exp $
d603 2
a604 2
	$s[-1] = '';
	my $fmt = join ' ', map { m/(\d+)/ && "%-$1s"} @@s; 
@


1.21
log
@create an empty %skip even if SUIDSKIP is not set, newer perl complains.
"I don't even see how this could work before" and ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.20 2013/03/18 13:20:39 sthen Exp $
d604 1
a604 1
	my $fmt = join ' ', map "%-${_}s", @@s;
@


1.20
log
@Enclose qw()...) literals in parentheses where required; this was historically
assumed anyway, but recent versions of Perl deprecate this.  ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.19 2012/07/08 21:48:38 schwarze Exp $
d525 3
a527 1
	my %skip = map { $_ => 1 } split ' ', $ENV{SUIDSKIP}
@


1.19
log
@To detect changes of system files, use SHA-256 rather than MD5,
taking advantage of naddy@@'s recent mtree(8) modernization.
While here, do not provide an example protecting a home directory
from file changes; protect some system binaries instead.
ok naddy@@ jmc@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.18 2012/05/17 16:06:03 pascal Exp $
d327 1
a327 1
	foreach my $base qw(hosts.equiv shosts.equiv hosts.lpd) {
d355 1
a355 1
	foreach my $base qw(rhosts shosts) {
d368 1
a368 1
	foreach my $base qw(rhosts shosts) {
d401 1
a401 1
	foreach my $f qw(
d405 1
a405 1
	) {
d426 1
a426 1
	foreach my $f qw(
d433 1
a433 1
        ) {
@


1.18
log
@Also check permissions of .ssh/id_ecdsa.

ok schwarze@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.17 2011/07/20 21:02:19 schwarze Exp $
d5 1
a5 1
# Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d23 1
a23 1
require Digest::MD5;
d692 1
a692 1
#       mtree -cx -p DIR -K md5digest,type >/etc/mtree/DIR.secure
d767 1
a767 1
sub backup_md5 {
d772 2
a773 2
	my $current = BACKUP_DIR . "$backup.current.md5";
	$backup = BACKUP_DIR . "$backup.backup.md5";
d775 1
a775 1
	my $md5_new = 0;
d779 2
a780 1
			$md5_new = Digest::MD5->new->addfile($fh)->hexdigest;
d785 1
a785 1
	my $md5_old = 0;
d788 1
a788 1
			$md5_old = <$fh>;
d790 1
a790 1
			chomp $md5_old;
d794 1
a794 1
	return if $md5_old eq $md5_new;
d796 1
a796 1
	if ($md5_old && $md5_new) {
d800 2
a801 2
	} elsif ($md5_old) {
		$check_title = "======\n$orig removed MD5 checksum\n======";
d803 2
a804 2
	} elsif ($md5_new) {
		$check_title = "======\n$orig new MD5 checksum\n======";
d807 1
a807 1
	if ($md5_new) {
d809 1
a809 1
			print $fh "$md5_new\n";
d816 2
a817 2
	nag $md5_old, "OLD: $md5_old";
	nag $md5_new, "NEW: $md5_new";
d846 2
a847 2
				    "======\n$_ MD5 checksums\n======";
				backup_md5 $_;
@


1.17
log
@During mailbox and special file checks, skip all files that can't
be stat(2)'ed, but do not complain about those that were just removed,
because removing files is not a security risk in itself.

Sorry, i can't remember the original reporter of the issue;
reported again by mk@@; patch looks good to Andrew Fresh.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.16 2011/07/20 00:39:15 schwarze Exp $
d403 2
a404 1
	    .pgp/secring.pgp .shosts .ssh/identity .ssh/id_dsa .ssh/id_rsa
@


1.16
log
@In lists of setuid/setgid files and devices, do not pad the last column
with trailing spaces; ugliness spotted by daniel dot c dot sinclair at
gmail dot com, fix from Andrew Fresh.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.15 2011/06/20 21:53:53 schwarze Exp $
d24 1
d452 4
a455 3
		nag !defined $mode,
		    "stat: $dir/$name: $!"
		    and next;
d553 4
a556 3
		nag !defined $dev,
		    "stat: $_: $!"
		    and return;
@


1.15
log
@Restore changelist(5) wildcard support that we inadvertently killed
by the recent security(8) rewrite.

While here:
1) Skip relative paths in changelist(5), and complain about them.
2) Skip file names ending in a tilde ('~') unless the tilde is
explicitly specified in the changelist(5).  That is, trailing
wildcards will not match trailing tildes, as suggested by matthew@@.

Bug reported by both mk@@ and matthew@@.
OK Andrew Fresh, also tested by and "move forward" mk@@
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.14 2011/05/25 21:16:29 schwarze Exp $
d597 1
@


1.14
log
@Fix two bugs where race conditions might cause stat(2) to fail,
such that security(8) would output garbage on stderr.
One reported by <RD at thrush dot com>, the other found by code audit.
While here, remove dead code in two other places: stat(_) uses cashed
data and cannot fail, not even if the file is removed in between.
ok Andrew Fresh
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.13 2011/05/10 17:53:56 schwarze Exp $
d822 1
d824 1
d826 6
a831 2
		next if /^(?:#|\/etc\/master.passwd|$)/;
		next if -d $_;
d833 14
a846 6
		if (s/^\+//) {
			$check_title = "======\n$_ MD5 checksums\n======";
			backup_md5 $_;
		} else {
			$check_title = "======\n$_ diffs (-OLD  +NEW)\n======";
			backup_if_changed $_;
d850 3
@


1.13
log
@Do not complain about an /etc/group line "+\n" as "wrong number of fields",
that abbreviated syntax is explicitly allowed by group(5).  While here,
warn if it isn't the last line in the group file.
Regression reported, fix tested and ok miod@@, and seems good to ajacoutot@@.

Note: I'm not removing the advice to put "+\n" at the end of the group file
right now because i'm not 100% sure that advice is pointless, even though
guenther@@ looked at the code an came to the conclusion OpenBSD libc ought
to cope.  And i'd rather have the manuals and the syntax checker be
consistent.  In case this really annoys people, it can be carefully tested
and changed later.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.12 2011/04/23 19:47:06 schwarze Exp $
d58 1
a58 3
	nag !defined $mode,
	    "stat: $filename: $!"
	or nag $mode & (S_IRUSR | S_IRGRP | S_IROTH) && ! -O $filename,
d319 1
a319 3
		nag !defined $mode,
		    "stat: $filename: $!"
		or nag $mode & S_IRWXO,
d451 3
d551 3
@


1.12
log
@When a device or setuid file is owned by a nonexistent user or group,
undefined data got used.
Fix this by reporting the UID/GID numerically in that case.
Problem reported and patch provided by rd at thrush dot com.

While here, use // rather than || everywhere to detect get*id failure,
as suggested by RD Thrush.  The edge case where it matters - a username
of "0" - is rather insane, but the // is more precise anyway.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.11 2011/04/23 13:43:44 schwarze Exp $
d146 1
a146 1
	my %names;
d149 7
@


1.11
log
@Very nice bugfix from Andrew Fresh, who writes:
>> "return if !%changed;" in check_filelist would never return
because just above "for @@{$changed{xxx}}" autovivifys $changed{xxx} = []
if it is not set already. <<
I hate autovivification, and it hates me.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.10 2011/04/17 13:26:07 schwarze Exp $
d386 1
a386 1
	    ((getpwuid $fuid)[0] || $fuid);
d405 1
a405 1
		    ((getpwuid $fuid)[0] || $fuid);
d433 1
a433 1
		    ((getpwuid $fuid)[0] || $fuid);
d448 2
a449 2
		my $fname = (getpwuid $fuid)[0] || $fuid;
		my $gname = (getgrgid $fgid)[0] || $fgid;
d567 2
a568 2
		$file->{user}    = (getpwuid $uid)[0];
		$file->{group}   = (getgrgid $gid)[0];
@


1.10
log
@remove a bogus blank line; from Andrew Fresh
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.9 2011/04/17 10:48:01 schwarze Exp $
d624 1
a624 1
				push @@{$changed{change}},
d631 1
a631 1
		push @@{$changed{add}}, [ @@{$files->{$f}}{@@fields}, $f ];
d634 1
a634 1
		push @@{$changed{delete}}, [ @@{$current{$f}}{@@fields}, $f ];
d637 6
a642 7
	$check_title = (ucfirst $mode) . ' additions:';
	nag 1, $_ for adjust_columns @@{$changed{add}};
	$check_title = (ucfirst $mode) . ' deletions:';
	nag 1, $_ for adjust_columns @@{$changed{delete}};
	$mode =~ s/device/block device/;
	$check_title = (ucfirst $mode) . ' changes:';
	nag 1, $_ for adjust_columns @@{$changed{change}};
@


1.9
log
@Keep the exact format of the message:
  user %s mailbox is %s, group %s
This is easy because we now have the strmode() function.
From Andrew Fresh, minimally tweaked myself.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.8 2011/04/10 23:28:48 schwarze Exp $
d63 1
a63 1
	    "\t home directory are still readable.\n";
@


1.8
log
@Reviewing my version of the code, Andrew Fresh found an elegant way to
keep the format of the "Block device changes:" output exactly the same
as it was in the past.  As a bonus, this also avoids lies in variable
names, making it more obvious what is actually being compared here.
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.7 2011/04/09 22:54:40 schwarze Exp $
d447 1
a447 1
		my ($mode, $fuid) = (stat "$dir/$name")[2,4];
d449 1
d453 2
a454 2
		    sprintf 'user %s mailbox permissions are %04o',
			 $name, S_IMODE($mode);
@


1.7
log
@implement one last check that Andrew overlooked
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.6 2011/04/09 22:11:11 schwarze Exp $
d556 3
a558 2
			$file->{size} = (($rdev >> 8) & 0xff) . ',' .
			    (($rdev & 0xff) | (($rdev >> 8) & 0xffff00));
d597 5
a601 1
	my @@fields  = qw(strmode nlink user group size mon day time year);
@


1.6
log
@implementation of the remaining checks;
heavily based on code written by Andrew Fresh,
but with considerable tweaking, mainly for simplicity;
lightly tested - there are probably still bugs, but auditing and
fixing it in the tree will be easier than with floating diffs
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.5 2011/03/30 21:41:28 schwarze Exp $
d348 1
a348 2
# Also, .rhosts/.shosts files should not have plus signs.
sub check_rhosts {
d361 17
d869 3
a871 1
check_rhosts(@@$_) foreach @@$homes;
d873 1
a873 1
check_homedir(@@$_) foreach @@$homes;
d875 2
a876 2
check_dot_readable(@@$_) foreach @@$homes;
check_dot_writeable(@@$_) foreach @@$homes;
d886 1
a886 1
check_disks($device_files);
@


1.5
log
@style cleanup:
* include the colon into $check_title, where needed
* always use the same style for stat calls
* and a few minor points
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.4 2011/03/26 22:13:53 schwarze Exp $
d23 1
d25 1
d27 6
a32 1
use File::Copy qw(cp);
d69 1
a69 1
	nag !open(my $fh, '<', $filename), "open: $filename: $!" and return;
a126 2
	my $bdir = '/var/backups';
	mkdir $bdir, 0700 unless -d $bdir;
d129 1
a129 1
	my $curr = "$bdir/$base.current";
d133 1
a133 1
		cp $curr, "$bdir/$base.backup";
d137 1
a137 1
	cp $orig, $curr;
d145 1
a145 1
	nag !open(my $fh, '<', $filename), "open: $filename: $!" and return;
d174 1
a174 1
	nag !open(my $fh, '<', $filename), "open: $filename: $!" and return;
d217 1
a217 1
		nag !open(my $fh, '-|', qw(/bin/csh -f -c),
d240 1
a240 1
		nag !open(my $fh, '-|', qw(/bin/sh -c),
d273 1
a273 1
		nag !open(my $fh, '-|', qw(/bin/ksh -c),
d287 1
a287 1
	nag !open(my $fh, '<', $filename), "open: $filename: $!" and return;
d301 1
a301 1
	nag !open(my $fh, '<', $filename), "open: $filename: $!" and return;
d326 1
a326 1
		nag !open(my $fh, '<', $filename),
d338 1
a338 1
	nag !open(my $fh, '<', $filename),
d428 1
a428 1
	nag !opendir(my $dh, $dir), "opendir: $dir: $!" and return;
d442 392
d861 17
a877 4

$check_title = "Status:";
nag 'right now', 'not yet ready';

@


1.4
log
@umask and path checks;
heavily based on code written by Andrew Fresh;
tweaked in team-work
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.3 2011/03/25 02:30:33 schwarze Exp $
d38 1
a38 1
			print "\n$check_title:\n";
d50 1
a50 1
	my (undef, undef, $mode) = stat $filename;
d61 1
a61 1
	$check_title = "Checking the $filename file";
d80 1
a80 1
			    "Duplicate login $name.";
d139 1
a139 1
	$check_title = "Checking the $filename file";
d168 1
a168 1
	my $filename = shift;
d308 1
a308 1
		my (undef, undef, $mode) = stat $filename;
d362 1
a362 1
	my (undef, undef, $mode, undef, $fuid) = stat(_);
d381 1
a381 1
		my (undef, undef, $mode, undef, $fuid) = stat(_);
d409 1
a409 1
		my (undef, undef, $mode, undef, $fuid) = stat(_);
d426 1
a426 1
		my (undef, undef, $mode, undef, $fuid) = stat "$dir/$name";
d449 1
a449 1
$check_title = "Checking configuration files";
d465 1
a465 1
$check_title = "Status";
@


1.3
log
@home directory checks;
large parts from a submission by Andrew Fresh <andrew at afresh1 dot com>
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.2 2011/03/24 21:54:32 schwarze Exp $
d27 4
d167 112
d437 1
d442 7
d464 1
@


1.2
log
@fix "german" typo; from <markus dot lude at gmx dot de>
@
text
@d3 1
a3 1
# $OpenBSD: security,v 1.1 2011/03/23 21:13:27 schwarze Exp $
d6 1
d241 80
d333 7
@


1.1
log
@Work in progress to replace /etc/security, not yet linked to the build.

Main design goals:
1. Safely handle untrusted file names and file content.
2. Output compatibility with current security(8) to please people
   parsing the output with scripts (except when improving functionality
   right away saves considerable implementation effort).  Substantial
   functional enhancements are for later.

Prodding to do this in Perl by deraadt@@.
Using some feedback from espie@@.

Agree to put this in now and at this place even though only about
one third of the functionality is ready, to complete it in the tree:
beck@@ espie@@ millert@@ deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD$
d236 1
a236 1
		    "$filename ist not owned by root.";
@

