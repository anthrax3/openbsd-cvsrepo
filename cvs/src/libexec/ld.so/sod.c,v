head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.14
	OPENBSD_5_0:1.23.0.12
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.16
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.14
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.12
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.10
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.8
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	r20000612:1.1.1.1
	dsr:1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.33;
commitid	veGB6uLWx3BTEAfk;

1.33
date	2015.10.29.13.07.41;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	4tAKMJesfO6c2ROc;

1.32
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.31;
commitid	G35ycnLxaVis5TX9;

1.31
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.30;
commitid	ImRWDrCXNlhODvC7;

1.30
date	2014.07.09.12.54.03;	author guenther;	state Exp;
branches;
next	1.29;
commitid	0KayvPMeoDHeGivt;

1.29
date	2014.07.06.17.33.10;	author otto;	state Exp;
branches;
next	1.28;
commitid	Todo1ZT3AnVz3T5r;

1.28
date	2014.06.21.08.00.23;	author otto;	state Exp;
branches;
next	1.27;
commitid	wh9FTpEgwThWVeqE;

1.27
date	2013.12.03.01.47.05;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.20.21.49.59;	author kurt;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.19.20.04.05;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.12.20.32.17;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.17.03.56.49;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.18.16.50.31;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.11.14.51.01;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.26.23.23.12;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.08.16.30.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.07.29.22.43.36;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.27.23.37.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.25.02.46.09;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.25.02.34.45;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.22.04.58.18;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.22.04.29.32;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.08.06.49.20;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.31.10.16.30;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.12.10.39.54;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.11.16.21.11;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.40.14;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.40.14;	author rahnds;	state Exp;
branches;
next	;

1.16.2.1
date	2003.05.31.00.53.01;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.34
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: sod.c,v 1.33 2015/10/29 13:07:41 deraadt Exp $	*/

/*
 * Copyright (c) 1993 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <machine/exec.h>
#include <limits.h>
#include <stdio.h>
#include <fcntl.h>
#include <nlist.h>
#include <link.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "syscall.h"
#include "archdep.h"
#include "path.h"
#include "util.h"
#include "sod.h"

int _dl_hinthash(char *cp, int vmajor, int vminor);
void _dl_maphints(void);

/*
 * Populate sod struct for dlopen's call to map_object
 */
void
_dl_build_sod(const char *name, struct sod *sodp)
{
	unsigned int	tuplet;
	int		major, minor;
	char		*realname, *tok, *etok, *cp;

	/* default is an absolute or relative path */
	sodp->sod_name = (long)_dl_strdup(name);    /* strtok is destructive */
	if (sodp->sod_name == 0)
		_dl_oom();
	sodp->sod_library = 0;
	sodp->sod_major = sodp->sod_minor = 0;

	/* does it look like /^lib/ ? */
	if (_dl_strncmp((char *)sodp->sod_name, "lib", 3) != 0)
		goto backout;

	/* is this a filename? */
	if (_dl_strchr((char *)sodp->sod_name, '/'))
		goto backout;

	/* skip over 'lib' */
	cp = (char *)sodp->sod_name + 3;

	realname = cp;

	/* dot guardian */
	if ((_dl_strchr(cp, '.') == NULL) || (*(cp+_dl_strlen(cp)-1) == '.'))
		goto backout;

	cp = _dl_strstr(cp, ".so");
	if (cp == NULL)
		goto backout;

	/* default */
	major = minor = -1;

	/* loop through name - parse skipping name */
	for (tuplet = 0; (tok = _dl_strsep(&cp, ".")) != NULL; tuplet++) {
		switch (tuplet) {
		case 0:
			/* empty tok, we already skipped to "\.so.*" */
			break;
		case 1:
			/* 'so' extension */
			break;
		case 2:
			/* major version extension */
			major = _dl_strtol(tok, &etok, 10);
			if (*tok == '\0' || *etok != '\0')
				goto backout;
			break;
		case 3:
			/* minor version extension */
			minor = _dl_strtol(tok, &etok, 10);
			if (*tok == '\0' || *etok != '\0')
				goto backout;
			break;
		/* if we get here, it must be weird */
		default:
			goto backout;
		}
	}
	if (realname == NULL)
		goto backout;
	cp = (char *)sodp->sod_name;
	sodp->sod_name = (long)_dl_strdup(realname);
	if (sodp->sod_name == 0)
		_dl_oom();
	_dl_free(cp);
	sodp->sod_library = 1;
	sodp->sod_major = major;
	sodp->sod_minor = minor;
	return;

backout:
	_dl_free((char *)sodp->sod_name);
	sodp->sod_name = (long)_dl_strdup(name);
	if (sodp->sod_name == 0)
		_dl_oom();
}

void
_dl_set_sod(const char *path, struct sod *sod)
{
	char *fname = _dl_strrchr(path, '/');

	if (fname != NULL)
		_dl_build_sod(++fname, sod);
	else
		_dl_build_sod(path, sod);
}

static struct hints_header	*hheader = NULL;
static struct hints_bucket	*hbuckets;
static char			*hstrtab;
char				**_dl_hint_search_path = NULL;

#define HINTS_VALID (hheader != NULL && hheader != (struct hints_header *)-1)

void
_dl_maphints(void)
{
	struct stat	sb;
	caddr_t		addr = MAP_FAILED;
	long		hsize = 0;
	int		hfd;

	if ((hfd = _dl_open(_PATH_LD_HINTS, O_RDONLY | O_CLOEXEC)) < 0)
		goto bad_hints;

	if (_dl_fstat(hfd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX)
		goto bad_hints;

	hsize = (long)sb.st_size;
	addr = (void *)_dl_mmap(0, hsize, PROT_READ, MAP_PRIVATE, hfd, 0);
	if (_dl_mmap_error(addr))
		goto bad_hints;

	hheader = (struct hints_header *)addr;
	if (HH_BADMAG(*hheader) || hheader->hh_ehints > hsize)
		goto bad_hints;

	if (hheader->hh_version != LD_HINTS_VERSION_2)
		goto bad_hints;

	hbuckets = (struct hints_bucket *)(addr + hheader->hh_hashtab);
	hstrtab = (char *)(addr + hheader->hh_strtab);
	if (hheader->hh_version >= LD_HINTS_VERSION_2)
		_dl_hint_search_path = _dl_split_path(hstrtab + hheader->hh_dirlist);

	/* close the file descriptor, leaving the hints mapped */
	_dl_close(hfd);

	return;

bad_hints:
	if (!_dl_mmap_error(addr))
		_dl_munmap(addr, hsize);
	if (hfd != -1)
		_dl_close(hfd);
	hheader = (struct hints_header *)-1;
}

char *
_dl_findhint(char *name, int major, int minor, char *preferred_path)
{
	struct hints_bucket	*bp;

	/*
	 * If not mapped, and we have not tried before, try to map the
	 * hints, if previous attempts failed hheader is -1 and we
	 * do not wish to retry it.
	 */
	if (hheader == NULL)
		_dl_maphints();

	/* if it failed to map, return failure */
	if (!(HINTS_VALID))
		return NULL;

	if (hheader->hh_nbucket == 0)
		return NULL;

	bp = hbuckets + (_dl_hinthash(name, major, minor) % hheader->hh_nbucket);

	while (1) {
		/* Sanity check */
		if (bp->hi_namex >= hheader->hh_strtab_sz)
			_dl_die("bad name index: %#x", bp->hi_namex);
		if (bp->hi_pathx >= hheader->hh_strtab_sz)
			_dl_die("bad path index: %#x", bp->hi_pathx);

		if (_dl_strcmp(name, hstrtab + bp->hi_namex) == 0) {
			/* It's `name', check version numbers */
			if (bp->hi_major == major &&
			    (bp->hi_ndewey < 2 || bp->hi_minor >= minor)) {
				if (preferred_path == NULL) {
					return hstrtab + bp->hi_pathx;
				} else {
					char *path = hstrtab + bp->hi_pathx;
					char *edir = _dl_strrchr(path, '/');

					if ((_dl_strncmp(preferred_path, path,
					    (edir - path)) == 0) &&
					    (preferred_path[edir - path] == '\0'))
						return path;
				}
			}
		}

		if (bp->hi_next == -1)
			break;

		/* Move on to next in bucket */
		bp = &hbuckets[bp->hi_next];
	}

	/* No hints available for name */
	return NULL;
}

int
_dl_hinthash(char *cp, int vmajor, int vminor)
{
	int	k = 0;

	while (*cp)
		k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;

	k = (((k << 1) + (k >> 14)) ^ (vmajor*257)) & 0x3fff;

	return k;
}
@


1.33
log
@remove tests for LD_HINTS_VERSION_1; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.32 2014/11/18 20:51:00 krw Exp $	*/
d68 1
a68 1
		_dl_exit(7);
d127 1
a127 1
		_dl_exit(7);
d138 1
a138 1
		_dl_exit(7);
d228 4
a231 10
		if (bp->hi_namex >= hheader->hh_strtab_sz) {
			_dl_printf("Bad name index: %#x\n", bp->hi_namex);
			_dl_exit(7);
			break;
		}
		if (bp->hi_pathx >= hheader->hh_strtab_sz) {
			_dl_printf("Bad path index: %#x\n", bp->hi_pathx);
			_dl_exit(7);
			break;
		}
@


1.32
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.31 2014/07/10 09:03:01 otto Exp $	*/
d183 1
a183 2
	if (hheader->hh_version != LD_HINTS_VERSION_1 &&
	    hheader->hh_version != LD_HINTS_VERSION_2)
a276 2
	if (hheader->hh_version == LD_HINTS_VERSION_1)
		k = (((k << 1) + (k >> 14)) ^ (vminor*167)) & 0x3fff;
@


1.31
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.30 2014/07/09 12:54:03 guenther Exp $	*/
a41 1
#include <limits.h>
@


1.30
log
@Use O_CLOEXEC to make sure fork+exec in a threaded process can't
see the fds used by dlopen()

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.29 2014/07/06 17:33:10 otto Exp $	*/
a66 1
	/* XXX */
d68 2
a125 1
	/* XXX */
d127 2
a136 1
	/* XXX */
d138 2
@


1.29
log
@enable -Wall, explicitly call _dl_strsep, and zap some redundant includes
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.28 2014/06/21 08:00:23 otto Exp $	*/
d165 1
a165 1
	if ((hfd = _dl_open(_PATH_LD_HINTS, O_RDONLY)) < 0)
@


1.28
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.27 2013/12/03 01:47:05 deraadt Exp $	*/
d97 1
a97 1
	for (tuplet = 0; (tok = strsep(&cp, ".")) != NULL; tuplet++) {
@


1.27
log
@stop using sys/syslimits.h directly, and use limits.h
prodded by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.26 2013/03/20 21:49:59 kurt Exp $	*/
d67 1
d125 1
d135 1
@


1.26
log
@- Parse colon separated paths into NULL terminated arrays of string
pointers to prepare for adding rpath ORIGIN support.
okay matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.25 2013/01/19 20:04:05 miod Exp $	*/
d35 3
a37 1
#include <sys/syslimits.h>
a42 2
#include <machine/exec.h>
#include <sys/mman.h>
@


1.25
log
@Do not divide by zero in _dl_findhint() if there is a valid hints file but
no buckets in it (could happen if the administrator reruns ldconfig with
bogus paths). ok matthew@@ kurt@@ drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.24 2012/06/12 20:32:17 matthew Exp $	*/
d49 1
d150 1
a150 1
char				*_dl_hint_search_path = NULL;
d185 1
a185 1
		_dl_hint_search_path = hstrtab + hheader->hh_dirlist;
@


1.24
log
@Fix loaded object sod matching: when we load libfoo.so.X.Y into
memory, we should be able to match other requests for libfoo.so.X.Z
against that same object.

ok kurt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.23 2008/10/02 20:12:08 kurt Exp $	*/
d214 3
@


1.23
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.22 2004/10/17 03:56:49 drahn Exp $	*/
d133 11
@


1.22
log
@Fix some problems related to LD_LIBRARY_PATH parsing where it would not
correctly deal with current directory searches specified by "::", ":foo" or
"foo:"
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.21 2004/05/18 16:50:31 mickey Exp $	*/
d159 1
a159 1
	if (addr == MAP_FAILED)
d181 1
a181 1
	if (addr != MAP_FAILED)
@


1.21
log
@fix includes scoping; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.20 2003/11/11 14:51:01 drahn Exp $	*/
d189 1
a189 1
_dl_findhint(char *name, int major, int minor, char *prefered_path)
d224 1
a224 4
				if (prefered_path == NULL ||
				    _dl_strncmp(prefered_path,
				    hstrtab + bp->hi_pathx,
				    _dl_strlen(prefered_path)) == 0)
d226 9
@


1.20
log
@Better fix to the library name parsing. now correctly handles
libpython2.2.so.0.0 vs libpython2.1.so.0.0. Clean up a potential
memory leak if the filename is not a valid library.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.19 2003/10/26 23:23:12 drahn Exp $	*/
a45 1
#include <syscall.h>
d47 1
@


1.19
log
@Work around a problem with shared libraries named as libX-A.B.so.X.Y.
Without this patch, the standard major:minor version matching failed.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.18 2003/07/06 20:03:57 deraadt Exp $	*/
d72 1
a72 1
		return;
d76 1
a76 1
		return;
d81 2
d85 5
a89 1
		return;
a93 1
	realname = NULL;
d98 1
a98 2
			/* removed 'lib' and extensions from name */
			realname = tok;
a101 8
			if (_dl_strcmp(tok, "so") != 0) {
				/*
				 * filenames such as libX-A.B.so.X.Y
				 * screw this up, decrement tuplet
				 * and try to continue.
				 */
				 tuplet--;
			}
@


1.18
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.17 2003/05/08 16:30:52 millert Exp $	*/
d98 8
a105 2
			if (_dl_strcmp(tok, "so") != 0)
				goto backout;
@


1.17
log
@Previously, ld.so would use a single page for mapping the hints file
and then, if that was not big enough, map the rest of it contiguously.
However, there is no guarantee that the address space after the
first mmap has not already been used by something else.

Instead, just fstat the file and map up to st_size.  Also reorganized
the code a tad and added some sanity checks for st_size.

Problem tracked down by dhartmei@@ and mickey@@; drahn@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.16 2003/02/02 16:57:58 deraadt Exp $	*/
d53 1
d103 1
a103 1
			major = strtol(tok, &etok, 10);
d109 1
a109 1
			minor = strtol(tok, &etok, 10);
@


1.16
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.15 2002/07/29 22:43:36 art Exp $	*/
d40 1
a51 1
#define PAGSIZ	__LDPGSZ
a131 2
static int			hfd;
static long			hsize;
d142 16
a157 15
	caddr_t		addr;

	if ((hfd = _dl_open(_PATH_LD_HINTS, O_RDONLY)) < 0) {
		hheader = (struct hints_header *)-1;
		return;
	}

	hsize = PAGSIZ;
	addr = (void *) _dl_mmap(0, hsize, PROT_READ, MAP_PRIVATE, hfd, 0);

	if (addr == MAP_FAILED) {
		_dl_close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}
d160 2
a161 6
	if (HH_BADMAG(*hheader)) {
		_dl_munmap(addr, hsize);
		_dl_close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}
d164 2
a165 17
	    hheader->hh_version != LD_HINTS_VERSION_2) {
		_dl_munmap(addr, hsize);
		_dl_close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}

	if (hheader->hh_ehints > hsize) {
		if ((caddr_t)_dl_mmap(addr+hsize, hheader->hh_ehints - hsize,
		    PROT_READ, MAP_PRIVATE|MAP_FIXED,
		    hfd, hsize) != (caddr_t)(addr+hsize)) {
			_dl_munmap((caddr_t)hheader, hsize);
			_dl_close(hfd);
			hheader = (struct hints_header *)-1;
			return;
		}
	}
d174 9
@


1.16.2.1
log
@Pull patch from -current:
Fix by millert@@

Previously, ld.so would use a single page for mapping the hints file
and then, if that was not big enough, map the rest of it contiguously.
However, there is no guarantee that the address space after the
first mmap has not already been used by something else.

Instead, just fstat the file and map up to st_size.  Also reorganized
the code a tad and added some sanity checks for st_size.

Problem tracked down by dhartmei@@ and mickey@@; drahn@@ OK.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.17 2003/05/08 16:30:52 millert Exp $	*/
a39 1
#include <limits.h>
d51 1
d132 2
d144 15
a158 16
	struct stat	sb;
	caddr_t		addr = MAP_FAILED;
	long		hsize = 0;
	int		hfd;

	if ((hfd = _dl_open(_PATH_LD_HINTS, O_RDONLY)) < 0)
		goto bad_hints;

	if (_dl_fstat(hfd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX)
		goto bad_hints;

	hsize = (long)sb.st_size;
	addr = (void *)_dl_mmap(0, hsize, PROT_READ, MAP_PRIVATE, hfd, 0);
	if (addr == MAP_FAILED)
		goto bad_hints;
d161 6
a166 2
	if (HH_BADMAG(*hheader) || hheader->hh_ehints > hsize)
		goto bad_hints;
d169 17
a185 2
	    hheader->hh_version != LD_HINTS_VERSION_2)
		goto bad_hints;
a193 9

	return;

bad_hints:
	if (addr != MAP_FAILED)
		_dl_munmap(addr, hsize);
	if (hfd != -1)
		_dl_close(hfd);
	hheader = (struct hints_header *)-1;
@


1.15
log
@minor formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.14 2002/07/12 20:18:30 drahn Exp $	*/
d58 1
a58 3
_dl_build_sod(name, sodp)
	const char	*name;
	struct sod	*sodp;
d117 1
a117 1
	if (realname == NULL) {
a118 1
	}
d142 1
a142 1
_dl_maphints()
d197 1
a197 4
_dl_findhint(name, major, minor, prefered_path)
	char	*name;
	int	major, minor;
	char	*prefered_path;
d250 1
d252 1
a252 3
_dl_hinthash(cp, vmajor, vminor)
	char	*cp;
	int	vmajor, vminor;
@


1.14
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.13 2002/05/27 23:37:25 deraadt Exp $	*/
d207 2
a208 1
	/* If not mapped, and we have not tried before, try to map the
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.12 2002/05/25 02:46:09 drahn Exp $	*/
d49 1
d89 1
d119 3
d140 1
a140 1
static char			*hint_search_path = "";
d193 1
a193 1
		hint_search_path = hstrtab + hheader->hh_dirlist;
@


1.12
log
@use _dl_strncmp() not strncmp(), _dl version is already present and used.
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.11 2002/05/25 02:34:45 drahn Exp $	*/
d231 6
a236 6
				(bp->hi_ndewey < 2 || bp->hi_minor >= minor)) {
					if (prefered_path == NULL ||
					    _dl_strncmp(prefered_path,
					    hstrtab + bp->hi_pathx,
					    _dl_strlen(prefered_path)) == 0)
						return hstrtab + bp->hi_pathx;
@


1.11
log
@_dl_strcmp() and _dl_strchr() exist, do not pull these routines
from libsa source.
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.10 2002/05/24 04:17:00 deraadt Exp $	*/
d233 1
a233 1
					    strncmp(prefered_path,
@


1.10
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sod.c,v 1.9 2002/05/24 03:44:37 deraadt Exp $	*/
d75 1
a75 1
	if (strchr((char *)sodp->sod_name, '/'))
d82 1
a82 1
	if ((strchr(cp, '.') == NULL) || (*(cp+_dl_strlen(cp)-1) == '.'))
d97 1
a97 1
			if (strcmp(tok, "so") != 0)
d228 1
a228 1
		if (strcmp(name, hstrtab + bp->hi_namex) == 0) {
@


1.9
log
@various KNF
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.8 2002/02/21 23:17:53 drahn Exp $       */
d17 1
a17 1
 *      This product includes software developed by Paul Kranenburg.
@


1.8
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 3
a3 2
/*      $OpenBSD: sod.c,v 1.7 2001/09/22 04:58:18 drahn Exp $       */
/*  
d176 2
a177 3
				PROT_READ, MAP_PRIVATE|MAP_FIXED,
				hfd, hsize) != (caddr_t)(addr+hsize)) {

d206 1
a206 1
	if (hheader == NULL) {
a207 1
	}
d210 1
a210 1
	if (!(HINTS_VALID)) { 
a211 1
	}
d234 2
a235 2
						hstrtab + bp->hi_pathx,
						_dl_strlen(prefered_path)) == 0) {
a236 1
					}
@


1.7
log
@Upon futher contemplation, the notion of unmaphints is just wrong.
First the maphints code is not cleaning up after itself, by leaving
a file descriptor open and trying to clean up after the dynamic linker
is done loading by removing data needed during dlopen() is nonsense.
the _dl_unmaphints() function and it's references have been removed.
_dl_maphints() now cleans up it's file descriptor before returning.
static data used later during dlopen() is left intact.
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.6 2001/09/22 04:29:32 drahn Exp $       */
d47 1
a49 2
char * _dl_strdup(const char *);
void _dl_free(void *);
d70 1
a70 1
	if (strncmp((char *)sodp->sod_name, "lib", 3) != 0)
@


1.6
log
@The unmaphints routine should not destroy the hint mapping.
Otherwise shared modules which depend on libraries cannot find
them because the list of trusted directories has been lost.
However we need to be careful that the unmapping of the hints frees
the file descriptor, but will not free it multiple times.
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.5 2001/06/08 06:49:20 art Exp $       */
a189 5
}

void
_dl_unmaphints()
{
d191 2
a192 5
	if (HINTS_VALID) {
		if (hfd != 0)
			_dl_close(hfd);
		hfd = 0;
	}
@


1.5
log
@Be consistent. If we have inveted our of strlen, use it everywhere.
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.4 2001/05/31 10:16:30 art Exp $       */
d197 3
a199 3
		_dl_munmap((caddr_t)hheader, hsize);
		_dl_close(hfd);
		hheader = (void *)-1;
@


1.4
log
@When opening the hints file, check for error return < 0, not -1.
_dl_open is not necessarily like the regular open(2).
XXX - maybe we should check with _dl_check_error?
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.3 2001/05/12 10:39:54 art Exp $       */
d46 2
d82 1
a82 1
	if ((strchr(cp, '.') == NULL) || (*(cp+strlen(cp)-1) == '.'))
d246 1
a246 1
						strlen(prefered_path)) == 0) {
@


1.3
log
@MAP_COPY -> MAP_PRIVATE
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.2 2001/05/11 16:21:11 art Exp $       */
d142 1
a142 1
	if ((hfd = _dl_open(_PATH_LD_HINTS, O_RDONLY)) == -1) {
@


1.2
log
@-1 -> MAP_FAILED.
@
text
@d1 1
a1 1
/*      $OpenBSD: sod.c,v 1.1.1.1 2000/06/13 03:40:14 rahnds Exp $       */
d148 1
a148 1
	addr = (void *) _dl_mmap(0, hsize, PROT_READ, MAP_COPY, hfd, 0);
d174 1
a174 1
				PROT_READ, MAP_COPY|MAP_FIXED,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $OpenBSD: rtld.c,v 1.16 2000/02/03 17:19:07 millert Exp $       */
d150 1
a150 1
	if (addr == (caddr_t)-1) {
@


1.1.1.1
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems 
such as correctness and security.

@
text
@@
