head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.10
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.23
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	31KwZ9PARAKUg1ob;

1.22
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.21;
commitid	ImRWDrCXNlhODvC7;

1.21
date	2014.07.09.11.19.42;	author guenther;	state Exp;
branches;
next	1.20;
commitid	GhKcBET8qtUpBvPk;

1.20
date	2014.07.06.18.26.58;	author otto;	state Exp;
branches;
next	1.19;
commitid	gUR7Ft4ra5a1D7GA;

1.19
date	2014.07.06.17.33.10;	author otto;	state Exp;
branches;
next	1.18;
commitid	Todo1ZT3AnVz3T5r;

1.18
date	2014.06.21.08.00.22;	author otto;	state Exp;
branches;
next	1.17;
commitid	wh9FTpEgwThWVeqE;

1.17
date	2013.08.13.05.52.17;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.21.04.28.45;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.14.02.16.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.09.14.51.13;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.08.18.47.32;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.24.20.00.35;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.16.14.47.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.18.16.50.31;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.31.22.25.34;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.24.01.05.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.23
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@/*	$OpenBSD: dir.c,v 1.22 2014/07/10 09:03:01 otto Exp $	*/
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <dirent.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#include "syscall.h"
#include "archdep.h"
#include "util.h"
#include "dir.h"

struct _dl_dirdesc {
	long	dd_loc;		/* offset in current buffer */
	long	dd_size;	/* amount of data returned by getdents() */
	char	*dd_buf;	/* data buffer */
	int	dd_len;		/* size of data buffer */
	int	dd_fd;		/* file descriptor associated with directory */
};

/*
 * Open a directory.
 */
_dl_DIR *
_dl_opendir(const char *name)
{
	_dl_DIR *dirp;
	int fd;
	struct stat sb;

	if ((fd = _dl_open(name, O_RDONLY | O_DIRECTORY | O_CLOEXEC)) < 0)
		return (NULL);
	if (_dl_fstat(fd, &sb) || (dirp = _dl_malloc(sizeof(*dirp))) == NULL) {
		_dl_close(fd);
		return (NULL);
	}

	dirp->dd_fd = fd;
	dirp->dd_loc = 0;
	dirp->dd_size = 0;
	dirp->dd_len = _dl_round_page(sb.st_blksize);
	dirp->dd_buf = _dl_malloc(dirp->dd_len);
	if (dirp->dd_buf == NULL) {
		_dl_free(dirp);
		_dl_close (fd);
		return (NULL);
	}

	return (dirp);
}


/*
 * close a directory.
 */
int
_dl_closedir(_dl_DIR *dirp)
{
	int ret;

	ret = _dl_close(dirp->dd_fd);
	_dl_free(dirp->dd_buf);
	_dl_free(dirp);
	return ret;
}


/*
 * get next entry in a directory.
 */
struct dirent *
_dl_readdir(_dl_DIR *dirp)
{
	struct dirent *dp;

	for (;;) {
		if (dirp->dd_loc >= dirp->dd_size) {
			dirp->dd_loc = 0;
		}
		if (dirp->dd_loc == 0) {
			dirp->dd_size = _dl_getdents(dirp->dd_fd,
			    dirp->dd_buf, dirp->dd_len);
			if (dirp->dd_size <= 0)
				return (NULL);
		}
		dp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
		if ((long)dp & 03)	/* bogus pointer check */
			return (NULL);
		if (dp->d_reclen <= 0 ||
		    dp->d_reclen > dirp->dd_len + 1 - dirp->dd_loc)
			return (NULL);
		dirp->dd_loc += dp->d_reclen;
		if (dp->d_ino == 0)
			continue;
		return (dp);
	}
}
@


1.22
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.21 2014/07/09 11:19:42 guenther Exp $	*/
d31 1
a31 2
#include <sys/param.h>
#include <sys/mount.h>
@


1.21
log
@Resync _dl_opendir() with libc: use O_CLOEXEC and O_DIRECTORY instead
of post-open tests and fixups.  Also, reorder _dl_dirdesc to save
8 bytes on LP64.

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.20 2014/07/06 18:26:58 otto Exp $	*/
a90 1
	int fd;
d93 4
a96 7
	fd = dirp->dd_fd;
	dirp->dd_fd = -1;
	dirp->dd_loc = 0;
	_dl_free((void *)dirp->dd_buf);
	_dl_free((void *)dirp);
	ret = _dl_close(fd);
	return (ret);
@


1.20
log
@int all fields, so calloc can become malloc; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.19 2014/07/06 17:33:10 otto Exp $	*/
a45 1
	int	dd_fd;		/* file descriptor associated with directory */
d50 1
d63 1
a63 4
	if ((fd = _dl_open(name, O_RDONLY | O_NONBLOCK)) < 0)
		return (NULL);
	if (_dl_fstat(fd, &sb) || !S_ISDIR(sb.st_mode)) {
		_dl_close(fd);
d65 1
a65 3
	}
	if (_dl_fcntl(fd, F_SETFD, FD_CLOEXEC) < 0 ||
	    (dirp = _dl_malloc(sizeof(*dirp))) == NULL) {
@


1.19
log
@enable -Wall, explicitly call _dl_strsep, and zap some redundant includes
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.18 2014/06/21 08:00:22 otto Exp $	*/
d70 1
a70 1
	    (dirp = _dl_calloc(1, sizeof(*dirp))) == NULL) {
d75 3
a84 2
	dirp->dd_loc = 0;
	dirp->dd_fd = fd;
@


1.18
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.17 2013/08/13 05:52:17 guenther Exp $	*/
a37 1
#include <string.h>
@


1.17
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.16 2012/03/21 04:28:45 matthew Exp $	*/
d71 1
a71 1
	    (dirp = _dl_malloc(sizeof(*dirp))) == NULL) {
@


1.16
log
@Switch ld.so's _dl_opendir functions to use a locally defined
_dl_dirdesc struct (containing just the fields ld.so's implementation
actually needs) instead of reusing libc's _dirdesc struct.

Also, switch ldconfig to use futimens() instead of futimes().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.15 2011/07/14 02:16:00 deraadt Exp $	*/
d49 1
a49 1
	long	dd_size;	/* amount of data returned by getdirentries */
a51 1
	off_t	dd_seek;	/* magic cookie returned by getdirentries */
a82 1
	dirp->dd_seek = 0;
d122 2
a123 2
			dirp->dd_size = _dl_getdirentries(dirp->dd_fd,
			    dirp->dd_buf, dirp->dd_len, &dirp->dd_seek);
@


1.15
log
@__opendir2, DTF_NODUP, and __DTF_READALL can die.  struct dirent
dd_flags is renamed to the placeholder position dd_unused so that
we can spot "broken software" which assumes we have Jan Simon Pendry's
union mounts (we don't have them, and won't have them ever again).
__opendir2 question spotted by matthew
verified to not break ports by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.14 2009/10/27 23:59:31 deraadt Exp $	*/
d46 8
a53 2
long _dl_telldir(const DIR *dirp);
void _dl_seekdir(DIR *dirp, long loc);
d58 1
a58 1
DIR *
d61 1
a61 1
	DIR *dirp;
d72 1
a72 1
	    (dirp = (DIR *)_dl_malloc(sizeof(DIR))) == NULL) {
d96 1
a96 1
_dl_closedir(DIR *dirp)
d115 1
a115 1
_dl_readdir(DIR *dirp)
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.13 2007/02/09 14:51:13 drahn Exp $	*/
a80 1
	dirp->dd_flags = DTF_NODUP;
@


1.13
log
@readdir buffers should not get a fixed buffer size, but should be dependant
on the block size of the filesystem. Rounded up to page size for efficiency.
similar to change in libc yesterday. Should fix PR 5364.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.12 2007/02/08 18:47:32 millert Exp $	*/
a30 4
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = ": opendir.c,v 1.6 1998/08/15 08:10:14 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */

a86 3
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$ closedir.c,v 1.3 1998/11/20 11:18:37 d Exp $";
#endif /* LIBC_SCCS and not lint */
a105 3
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$ readdir.c,v 1.5 2001/05/17 20:20:36 rees Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@Remove __DTF_READALL usage in ld.so's private copy of readdir().
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.11 2006/03/24 20:00:35 otto Exp $	*/
a61 1
	int incr;
d75 1
a75 12
	/*
	 * If the machine's page size is an exact multiple of DIRBLKSIZ,
	 * use a buffer that is cluster boundary aligned.
	 * Hopefully this can be a big win someday by allowing page trades
	 * to user space to be done by getdirentries()
	 * - not done in ld.so.
	 */
	incr = DIRBLKSIZ;

	/* UNION mount support removed */

	dirp->dd_len = incr;
@


1.11
log
@Remove telldir/seekdir support from the internal ld.so lib, it's not
used. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.10 2005/06/16 14:47:09 millert Exp $	*/
a137 2
			if (dirp->dd_flags & __DTF_READALL)
				return (NULL);
d140 1
a140 1
		if (dirp->dd_loc == 0 && !(dirp->dd_flags & __DTF_READALL)) {
@


1.10
log
@remove whiteout stuff from ld.so's private opendir(); OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 2004/05/18 16:50:31 mickey Exp $	*/
a98 5
	/*
	 * Set up seek point for rewinddir.
	 */
	dirp->dd_rewind = _dl_telldir(dirp);

a114 1
	_dl_seekdir(dirp, dirp->dd_rewind);	/* free seekdir storage */
a158 89
}


#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$ telldir.c,v 1.2 1996/08/19 08:26:35 tholo Exp $";
#endif /* LIBC_SCCS and not lint */

/*
 * The option SINGLEUSE may be defined to say that a telldir
 * cookie may be used only once before it is freed. This option
 * is used to avoid having memory usage grow without bound.
 */
#define SINGLEUSE

/*
 * One of these structures is malloced to describe the current directory
 * position each time telldir is called. It records the current magic
 * cookie returned by getdirentries and the offset within the buffer
 * associated with that return value.
 */
struct ddloc {
	struct	ddloc *loc_next;/* next structure in list */
	long	loc_index;	/* key associated with structure */
	long	loc_seek;	/* magic cookie returned by getdirentries */
	long	loc_loc;	/* offset of entry in buffer */
};

#define	NDIRHASH	32	/* Num of hash lists, must be a power of 2 */
#define	LOCHASH(i)	((i)&(NDIRHASH-1))

static long	dd_loccnt;	/* Index of entry for sequential readdir's */
static struct	ddloc *dd_hash[NDIRHASH];   /* Hash list heads for ddlocs */

/*
 * return a pointer into a directory
 */
long
_dl_telldir(const DIR *dirp)
{
	int index;
	struct ddloc *lp;

	if ((lp = (struct ddloc *)_dl_malloc(sizeof(struct ddloc))) == NULL)
		return (-1);
	index = dd_loccnt++;
	lp->loc_index = index;
	lp->loc_seek = dirp->dd_seek;
	lp->loc_loc = dirp->dd_loc;
	lp->loc_next = dd_hash[LOCHASH(index)];
	dd_hash[LOCHASH(index)] = lp;
	return (index);
}

/*
 * seek to an entry in a directory.
 * Only values returned by "telldir" should be passed to seekdir.
 */
void
_dl_seekdir(DIR *dirp, long loc)
{
	struct ddloc *lp;
	struct ddloc **prevlp;
	struct dirent *dp;

	prevlp = &dd_hash[LOCHASH(loc)];
	lp = *prevlp;
	while (lp != NULL) {
		if (lp->loc_index == loc)
			break;
		prevlp = &lp->loc_next;
		lp = lp->loc_next;
	}
	if (lp == NULL)
		return;
	if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
		goto found;
	_dl_lseek(dirp->dd_fd, (off_t)lp->loc_seek, SEEK_SET);
	dirp->dd_seek = lp->loc_seek;
	dirp->dd_loc = 0;
	while (dirp->dd_loc < lp->loc_loc) {
		dp = _dl_readdir(dirp);
		if (dp == NULL)
			break;
	}
found:
#ifdef SINGLEUSE
	*prevlp = lp->loc_next;
	_dl_free((caddr_t)lp);
#endif
@


1.9
log
@fix includes scoping; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 2003/07/06 20:03:57 deraadt Exp $	*/
a63 2
	int flags = DTF_HIDEW|DTF_NODUP;

a94 2
	flags &= ~DTF_REWIND;

d97 1
a97 1
	dirp->dd_flags = flags;
a161 2
			continue;
		if (dp->d_type == DT_WHT && (dirp->dd_flags & DTF_HIDEW))
@


1.8
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.7 2003/06/02 19:38:24 millert Exp $	*/
a34 1
#include <syscall.h>
d44 3
a47 1
#include "archdep.h"
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.6 2003/02/02 16:57:58 deraadt Exp $	*/
d47 1
@


1.6
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.5 2003/01/31 22:25:34 drahn Exp $	*/
d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@The version of open in ld.so, _dl_open(), will return -errno instead of -1.
This is to avoid corrupting 'errno'. Handle this case in _dl_opendir().
This is also the case for _dl_fcntl(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.4 2002/07/24 04:11:10 deraadt Exp $	*/
a54 1

d59 1
a59 2
_dl_opendir(name)
	const char *name;
d121 1
a121 2
_dl_closedir(dirp)
	DIR *dirp;
d144 1
a144 2
_dl_readdir(dirp)
	DIR *dirp;
d210 1
a210 2
_dl_telldir(dirp)
	const DIR *dirp;
d231 1
a231 3
_dl_seekdir(dirp, loc)
	DIR *dirp;
	long loc;
@


1.4
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.2 2002/07/24 01:05:11 deraadt Exp $	*/
d70 1
a70 1
	if ((fd = _dl_open(name, O_RDONLY | O_NONBLOCK)) == -1)
d76 1
a76 1
	if (_dl_fcntl(fd, F_SETFD, FD_CLOEXEC) == -1 ||
@


1.3
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.1 2002/07/12 20:18:30 drahn Exp $	*/
d86 1
a86 1
	 * to user space to be done by getdirentries() 
d193 1
a193 1
 * position each time telldir is called. It records the current magic 
@


1.2
log
@spacing
@
text
@d86 1
a86 1
	 * to user space to be done by getdirentries()
d193 1
a193 1
 * position each time telldir is called. It records the current magic
@


1.1
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
	 * to user space to be done by getdirentries() 
d193 1
a193 1
 * position each time telldir is called. It records the current magic 
@

