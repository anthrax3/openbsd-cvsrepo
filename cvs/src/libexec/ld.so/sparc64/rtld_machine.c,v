head	1.60;
access;
symbols
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.6
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.46.0.6
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.43.0.6
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.8
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.4
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.4
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.34.0.6
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.34.0.4
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.60
date	2017.08.28.14.06.22;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	r8vwp03giVzP3uiZ;

1.59
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.58;
commitid	veGB6uLWx3BTEAfk;

1.58
date	2016.06.21.15.25.38;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	lRIiUPnkIQNjSTol;

1.57
date	2016.05.21.21.58.52;	author kettenis;	state Exp;
branches;
next	1.56;
commitid	a9dEvttP256O9E2v;

1.56
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.55;
commitid	zGFWeGZdYJxUOZli;

1.55
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.54;
commitid	FcRQ6g8MqXiORdFs;

1.54
date	2015.08.23.20.45.14;	author guenther;	state Exp;
branches;
next	1.53;
commitid	bWSDVTHL6DFekj9O;

1.53
date	2014.08.30.21.30.23;	author guenther;	state Exp;
branches;
next	1.52;
commitid	eCoPNHFmr2tYvZ27;

1.52
date	2014.04.16.10.52.59;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.08.20.55.15;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.31.06.26.27;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2012.12.05.23.20.07;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.24.18.12.29;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.16.20.33.42;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.24.10.16.58;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.22.01.33.09;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.21.23.12.11;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.16.23.19.43;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.25.21.42.48;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.25.18.07.21;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.25.15.56.19;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.04.19.37.08;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.04.19.33.50;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.02.15.17.52;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.28.03.11.00;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.16.20.41;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.15.22.39.14;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.01.23.55.01;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.23.23.29.32;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.05.23.13.55;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.19.34.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.03.20.30.50;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.24.04.17.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.24.03.44.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.14.52.39;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.20.05.04.34;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.27.06.58.33;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.26.14.57.56;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.26.10.45.02;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.26.10.19.16;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.26.09.32.32;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.25.14.29.48;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.25.14.12.23;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.23.00.14.56;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.60
log
@whitespace
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.59 2017/01/24 07:48:37 guenther Exp $ */

/*
 * Copyright (c) 1999 Dale Rahn
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 2000 Eduardo Horvath.
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>
#include <machine/trap.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

/*
 * The following table holds for each relocation type:
 *	- the width in bits of the memory location the relocation
 *	  applies to (not currently used)
 *	- the number of bits the relocation value must be shifted to the
 *	  right (i.e. discard least significant bits) to fit into
 *	  the appropriate field in the instruction word.
 *	- flags indicating whether
 *		* the relocation involves a symbol
 *		* the relocation is relative to the current position
 *		* the relocation is for a GOT entry
 *		* the relocation is relative to the load address
 *
 */
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_U		0x04000000		/* Unaligned */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,							/* NONE */
	_RF_S|_RF_A|		_RF_SZ(8)  | _RF_RS(0),		/* RELOC_8 */
	_RF_S|_RF_A|		_RF_SZ(16) | _RF_RS(0),		/* RELOC_16 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* RELOC_32 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(8)  | _RF_RS(0),		/* DISP_8 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(16) | _RF_RS(0),		/* DISP_16 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* DISP_32 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP_30 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP_22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(10),	/* HI22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 13 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* LO10 */
	_RF_G|			_RF_SZ(32) | _RF_RS(0),		/* GOT10 */
	_RF_G|			_RF_SZ(32) | _RF_RS(0),		/* GOT13 */
	_RF_G|			_RF_SZ(32) | _RF_RS(10),	/* GOT22 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* PC10 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(10),	/* PC22 */
	      _RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WPLT30 */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* COPY */
	_RF_S|_RF_A|		_RF_SZ(64) | _RF_RS(0),		/* GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* JMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(64) | _RF_RS(0),		/* RELATIVE */
	_RF_S|_RF_A|	_RF_U|	_RF_SZ(32) | _RF_RS(0),		/* UA_32 */

	      _RF_A|		_RF_SZ(32) | _RF_RS(0),		/* PLT32 */
	      _RF_A|		_RF_SZ(32) | _RF_RS(10),	/* HIPLT22 */
	      _RF_A|		_RF_SZ(32) | _RF_RS(0),		/* LOPLT10 */
	      _RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* PCPLT32 */
	      _RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(10),	/* PCPLT22 */
	      _RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* PCPLT10 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 10 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 11 */
	_RF_S|_RF_A|		_RF_SZ(64) | _RF_RS(0),		/* 64 */
	_RF_S|_RF_A|/*extra*/	_RF_SZ(32) | _RF_RS(0),		/* OLO10 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(42),	/* HH22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(32),	/* HM10 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(10),	/* LM22 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(42),	/* PC_HH22 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(32),	/* PC_HM10 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(10),	/* PC_LM22 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP16 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP19 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* GLOB_JMP */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 7 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 5 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 6 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(64) | _RF_RS(0),		/* DISP64 */
	      _RF_A|		_RF_SZ(64) | _RF_RS(0),		/* PLT64 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(10),	/* HIX22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* LOX10 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(22),	/* H44 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(12),	/* M44 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* L44 */
	_RF_S|_RF_A|		_RF_SZ(64) | _RF_RS(0),		/* REGISTER */
	_RF_S|_RF_A|	_RF_U|	_RF_SZ(64) | _RF_RS(0),		/* UA64 */
	_RF_S|_RF_A|	_RF_U|	_RF_SZ(16) | _RF_RS(0),		/* UA16 */
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
#define RELOC_UNALIGNED(t)		((reloc_target_flags[t] & _RF_U) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)

static long reloc_target_bitmask[] = {
#define _BM(x)	(~(-(1ULL << (x))))
	0,				/* NONE */
	_BM(8), _BM(16), _BM(32),	/* RELOC_8, _16, _32 */
	_BM(8), _BM(16), _BM(32),	/* DISP8, DISP16, DISP32 */
	_BM(30), _BM(22),		/* WDISP30, WDISP22 */
	_BM(22), _BM(22),		/* HI22, _22 */
	_BM(13), _BM(10),		/* RELOC_13, _LO10 */
	_BM(10), _BM(13), _BM(22),	/* GOT10, GOT13, GOT22 */
	_BM(10), _BM(22),		/* _PC10, _PC22 */
	_BM(30), 0,			/* _WPLT30, _COPY */
	-1, _BM(32), -1,		/* _GLOB_DAT, JMP_SLOT, _RELATIVE */
	_BM(32), _BM(32),		/* _UA32, PLT32 */
	_BM(22), _BM(10),		/* _HIPLT22, LOPLT10 */
	_BM(32), _BM(22), _BM(10),	/* _PCPLT32, _PCPLT22, _PCPLT10 */
	_BM(10), _BM(11), -1,		/* _10, _11, _64 */
	_BM(10), _BM(22),		/* _OLO10, _HH22 */
	_BM(10), _BM(22),		/* _HM10, _LM22 */
	_BM(22), _BM(10), _BM(22),	/* _PC_HH22, _PC_HM10, _PC_LM22 */
	_BM(16), _BM(19),		/* _WDISP16, _WDISP19 */
	-1,				/* GLOB_JMP */
	_BM(7), _BM(5), _BM(6)		/* _7, _5, _6 */
	-1, -1,				/* DISP64, PLT64 */
	_BM(22), _BM(13),		/* HIX22, LOX10 */
	_BM(22), _BM(10), _BM(13),	/* H44, M44, L44 */
	-1, -1, _BM(16),		/* REGISTER, UA64, UA16 */
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

int _dl_reloc_plt(Elf_Word *where1, Elf_Word *where2, Elf_Word *pltaddr,
	Elf_Addr value);
void _dl_install_plt(Elf_Word *pltgot, Elf_Addr proc);

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	long	i;
	long	numrela;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_RelA *relas;
	struct load_list *llist;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf64_Rela);
	relrel = rel == DT_RELA ? object->relacount : 0;
	relas = (Elf64_Rela *)(object->Dyn.info[rel]);

	if (relas == NULL)
		return(0);

	if (relrel > numrela)
		_dl_die("relacount > numrel: %ld > %ld", relrel, numrela);

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, relas++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(relas->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELACOUNT wrong");
#endif
		where = (Elf_Addr *)(relas->r_offset + loff);
		*where = relas->r_addend + loff;
	}
	for (; i < numrela; i++, relas++) {
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(relas->r_info);

		if (type == R_TYPE(NONE) || type == R_TYPE(JMP_SLOT))
			continue;

		where = (Elf_Addr *)(relas->r_offset + loff);

		if (RELOC_USE_ADDEND(type))
			value = relas->r_addend;
		else
			value = 0;

		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(relas->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(relas->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JMP_SLOT)) ?
					SYM_PLT : SYM_NOTPLT),
				    sym, NULL);
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			size_t size = dstsym->st_size;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    dstsym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, size);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;
		if (RELOC_BASE_RELATIVE(type))
			value += loff;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		if (RELOC_UNALIGNED(type)) {
			/* Handle unaligned relocations. */
			Elf_Addr tmp = 0;
			char *ptr = (char *)where;
			int i, size = RELOC_TARGET_SIZE(type)/8;

			/* Read it in one byte at a time. */
			for (i=0; i<size; i++)
				tmp = (tmp << 8) | ptr[i];

			tmp &= ~mask;
			tmp |= value;

			/* Write it back out. */
			for (i=0; i<size; i++)
				ptr[i] = ((tmp >> (8*i)) & 0xff);
		} else if (RELOC_TARGET_SIZE(type) > 32) {
			*where &= ~mask;
			*where |= value;
		} else {
			Elf32_Addr *where32 = (Elf32_Addr *)where;

			*where32 &= ~mask;
			*where32 |= value;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

/*
 * Instruction templates:
 */

#define	BAA	0x30680000	/*	ba,a	%xcc, 0 */
#define	SETHI	0x03000000	/*	sethi	%hi(0), %g1 */
#define	JMP	0x81c06000	/*	jmpl	%g1+%lo(0), %g0	  <-- simm13 */
#define	NOP	0x01000000	/*	sethi	%hi(0), %g0 */
#define	OR	0x82106000	/*	or	%g1, 0, %g1 */
#define	ORG5	0x8a116000	/*	or	%g5, 0, %g5 */
#define	XOR	0x82186000	/*	xor	%g1, 0, %g1 */
#define	MOV71	0x8210000f	/*	or	%o7, 0, %g1 */
#define	MOV17	0x9e100001	/*	or	%g1, 0, %o7 */
#define	CALL	0x40000000	/*	call	0	  <-- disp30 */
#define	SLLX	0x83287000	/*	sllx	%g1, 0, %g1 */
#define	SLLXG5	0x8b297000	/*	sllx	%g5, 0, %g5 */
#define	SRAX	0x83387000	/*	srax	%g1, 0, %g1 */
#define	SETHIG5	0x0b000000	/*	sethi	%hi(0), %g5 */
#define	ORG15	0x82804005	/*	or	%g1, %g5, %g1 */


/* %hi(v) with variable shift */
#define	HIVAL(v, s)	(((v) >> (s)) &  0x003fffff)
#define LOVAL(v)	((v) & 0x000003ff)

int
_dl_reloc_plt(Elf_Word *where1, Elf_Word *where2, Elf_Word *pltaddr,
    Elf_Addr value)
{
	Elf_Addr offset;

	/*
	 * At the PLT entry pointed at by `where', we now construct
	 * a direct transfer to the now fully resolved function
	 * address.
	 *
	 * A PLT entry is supposed to start by looking like this:
	 *
	 *	sethi	%hi(. - .PLT0), %g1
	 *	ba,a,pt	%xcc, .PLT1
	 *	nop
	 *	nop
	 *	nop
	 *	nop
	 *	nop
	 *	nop
	 *
	 * When we replace these entries we either (a) only replace
	 * the second word (the ba,a,pt), or (b) replace multiple
	 * words: one or more nops, then finally the ba,a,pt.  By
	 * replacing the ba,a,pt last, we guarantee that the PLT can
	 * be used by other threads even while it's being updated.
	 * This is made slightly more complicated by kbind, for which
	 * we need to pass them to the kernel in the order they get
	 * written.  To that end, we store the word to overwrite the
	 * ba,a,pt at *where1, and the words to overwrite the nops at
	 * where2[0], where2[1], ...
	 *
	 * We now need to find out how far we need to jump.  We
	 * have a choice of several different relocation techniques
	 * which are increasingly expensive.
	 */

	offset = value - ((Elf_Addr)pltaddr);
	if ((int64_t)(offset-4) <= (1L<<20) &&
	    (int64_t)(offset-4) >= -(1L<<20)) {
		/*
		 * We're within 1MB -- we can use a direct branch insn.
		 *
		 * We can generate this pattern:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	ba,a,pt	%xcc, addr
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *
		 */
		*where1 = BAA | (((offset-4) >> 2) &0x7ffff);
		return (0);
	} else if (value < (1UL<<32)) {
		/*
		 * We're within 32-bits of address zero.
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	sethi	%hi(addr), %g1
		 *	jmp	%g1+%lo(addr)
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *
		 */
		*where1 = SETHI | HIVAL(value, 10);
		where2[0] = JMP   | LOVAL(value);
		return (1);
	} else if (value > -(1UL<<32)) {
		/*
		 * We're within 32-bits of address -1.
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	sethi	%hix(~addr), %g1
		 *	xor	%g1, %lox(~addr), %g1
		 *	jmp	%g1
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *
		 */
		*where1 = SETHI | HIVAL(~value, 10);
		where2[0] = XOR | ((~value) & 0x00001fff);
		where2[1] = JMP;
		return (2);
	} else if ((int64_t)(offset-8) <= (1L<<31) &&
	    (int64_t)(offset-8) >= -((1L<<31) - 4)) {
		/*
		 * We're within 32-bits -- we can use a direct call insn
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	mov	%o7, %g1
		 *	call	(.+offset)
		 *	 mov	%g1, %o7
		 *	nop
		 *	nop
		 *	nop
		 *	nop
		 *
		 */
		*where1 = MOV71;
		where2[0] = CALL | (((offset-8) >> 2) & 0x3fffffff);
		where2[1] = MOV17;
		return (2);
	} else if (value < (1L<<42)) {
		/*
		 * Target 42bits or smaller.
		 * We can generate this pattern:
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	sethi	%hi(addr >> 20), %g1
		 *	or	%g1, %lo(addr >> 10), %g1
		 *	sllx	%g1, 10, %g1
		 *	jmp	%g1+%lo(addr)
		 *	nop
		 *	nop
		 *	nop
		 *
		 * this can handle addresses 0 - 0x3fffffffffc
		 */
		*where1 = SETHI | HIVAL(value, 20);
		where2[0] = OR    | LOVAL(value >> 10);
		where2[1] = SLLX  | 10;
		where2[2] = JMP   | LOVAL(value);
		return (3);
	} else if (value > -(1UL<<41)) {
		/*
		 * Large target >= 0xfffffe0000000000UL
		 * We can generate this pattern:
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	sethi	%hi(addr >> 20), %g1
		 *	or	%g1, %lo(addr >> 10), %g1
		 *	sllx	%g1, 32, %g1
		 *	srax	%g1, 22, %g1
		 *	jmp	%g1+%lo(addr)
		 *	nop
		 *	nop
		 *	nop
		 *
		 */
		*where1 = SETHI | HIVAL(value, 20);
		where2[0] = OR   | LOVAL(value >> 10);
		where2[1] = SLLX  | 32;
		where2[2] = SRAX  | 22;
		where2[3] = JMP   | LOVAL(value);
		return (4);
	} else {
		/*
		 * We need to load all 64-bits
		 *
		 * The resulting code in the jump slot is:
		 *
		 *	sethi	%hi(. - .PLT0), %g1
		 *	sethi	%hi(addr >> 42), %g5
		 *	sethi	%hi(addr >> 10), %g1
		 *	or	%g1, %lo(addr >> 32), %g5
		 *	sllx	%g5, 32, %g5
		 *	or	%g1, %g5, %g1
		 *	jmp	%g1+%lo(addr)
		 *	nop
		 *
		 */
		*where1 = SETHIG5 | HIVAL(value, 42);
		where2[0] = SETHI | HIVAL(value, 10);
		where2[1] = ORG5 | LOVAL(value >> 32);
		where2[2] = SLLXG5 | 32;
		where2[3] = ORG15;
		where2[4] = JMP | LOVAL(value);
		return (5);
	}
}

/*
 * Resolve a symbol at run-time.
 */
Elf_Addr
_dl_bind(elf_object_t *object, int index)
{
	Elf_RelA *rela;
	Elf_Word *addr;
	Elf_Addr ooff, newvalue;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param[2];
		Elf_Word newval[6];
	} buf;
	struct __kbind *param;
	size_t psize;
	int i;

	rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);
	if (ELF_R_TYPE(rela->r_info) == R_TYPE(JMP_SLOT)) {
		/*
		 * XXXX
		 *
		 * The first four PLT entries are reserved.  There
		 * is some disagreement whether they should have
		 * associated relocation entries.  Both the SPARC
		 * 32-bit and 64-bit ELF specifications say that
		 * they should have relocation entries, but the
		 * 32-bit SPARC binutils do not generate them,
		 * and now the 64-bit SPARC binutils have stopped
		 * generating them too.
		 *
		 * So, to provide binary compatibility, we will
		 * check the first entry, if it is reserved it
		 * should not be of the type JMP_SLOT.  If it
		 * is JMP_SLOT, then the 4 reserved entries were
		 * not generated and our index is 4 entries too far.
		 */
		rela += index - 4;
	} else
		rela += index;

	sym = object->dyn.symtab;
	sym += ELF64_R_SYM(rela->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	newvalue = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (newvalue);

	/*
	 * While some relocations just need to write one word and
	 * can do that with kbind() with just one block, many
	 * require two blocks to be written: all but first word,
	 * then the first word.  So, if we want to write 5 words
	 * in total, then the layout of the buffer we pass to
	 * kbind() needs to be one of these:
	 *   +------------+
	 *   | kbind.addr |
	 *   |     """    |
	 *   | kbind.size |
	 *   |     """    |		+------------+
	 *   | kbind.addr |		| kbind.addr |
	 *   |     """    |		|     """    |
	 *   | kbind.size |		| kbind.size |
	 *   |     """    |		|     """    |
	 *   |   word 2   |		|    word    |
	 *   |   word 3   |		+------------+
	 *   |   word 4   |
	 *   |   word 5   |
	 *   |   word 1   |
	 *   +------------+
	 *
	 * We first handle the special case of relocations with a
	 * non-zero r_addend, which have one block to update whose
	 * address is the relocation address itself.  This is only
	 * used for PLT entries after the 2^15th, i.e., truly monstrous
	 * programs, thus the __predict_false().
	 */
	addr = (Elf_Word *)(object->obj_base + rela->r_offset);
	_dl_memset(&buf, 0, sizeof(buf));
	if (__predict_false(rela->r_addend)) {
		/*
		 * This entry is >32768.  The relocation points to a
		 * PC-relative pointer to the _dl_bind_start_0 stub at
		 * the top of the PLT section.  Update it to point to
		 * the target function.
		 */
		buf.newval[0] = rela->r_addend + newvalue
		    - object->Dyn.info[DT_PLTGOT];
		buf.param[1].kb_addr = addr;
		buf.param[1].kb_size = sizeof(buf.newval[0]);
		param = &buf.param[1];
		psize = sizeof(struct __kbind) + sizeof(buf.newval[0]);
	} else {
		Elf_Word first;

		/*
		 * For the other relocations, the word at the relocation
		 * address will be left unchanged.  Assume _dl_reloc_plt()
		 * will tell us to update multiple words, so save the first
		 * word to the side.
		 */
		i = _dl_reloc_plt(&first, &buf.newval[0], addr, newvalue);

		/*
		 * _dl_reloc_plt() returns the number of words that must be
		 * written after the first word in location, but before it
		 * in time.  If it returns zero, then only a single block
		 * with one word is needed, so we just put it in place per
		 * the right-hand diagram and just use param[1] and newval[0]
		 */
		if (i == 0) {
			/* fill in the __kbind structure */
			buf.param[1].kb_addr = &addr[1];
			buf.param[1].kb_size = sizeof(Elf_Word);
			buf.newval[0] = first;
			param = &buf.param[1];
			psize = sizeof(struct __kbind) + sizeof(buf.newval[0]);
		} else {
			/*
			 * Two blocks are necessary.  Save the first word
			 * after the other words.
			 */
			buf.param[0].kb_addr = &addr[2];
			buf.param[0].kb_size = i * sizeof(Elf_Word);
			buf.param[1].kb_addr = &addr[1];
			buf.param[1].kb_size = sizeof(Elf_Word);
			buf.newval[i] = first;
			param = &buf.param[0];
			psize = 2 * sizeof(struct __kbind) +
			    (i + 1) * sizeof(buf.newval[0]);
		}
	}

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("g1") = SYS_kbind;
		register void *arg1 __asm("o0") = param;
		register long  arg2 __asm("o1") = psize;
		register long  arg3 __asm("o2") = cookie;

		__asm volatile("t %2" : "+r" (arg1), "+r" (arg2)
		    : "i" (ST_SYSCALL), "r" (syscall_num), "r" (arg3)
		    : "cc", "memory");
	}

	return (newvalue);
}

/*
 * Install rtld function call into this PLT slot.
 */
#define SAVE		0x9de3bf50
#define SETHI_l0	0x21000000
#define SETHI_l1	0x23000000
#define OR_l0_l0	0xa0142000
#define SLLX_l0_32_l0	0xa12c3020
#define OR_l0_l1_l0	0xa0140011
#define JMPL_l0_o1	0x93c42000
#define MOV_g1_o0	0x90100001

void
_dl_install_plt(Elf_Word *pltgot, Elf_Addr proc)
{
	pltgot[0] = SAVE;
	pltgot[1] = SETHI_l0  | HIVAL(proc, 42);
	pltgot[2] = SETHI_l1  | HIVAL(proc, 10);
	pltgot[3] = OR_l0_l0  | LOVAL((proc) >> 32);
	pltgot[4] = SLLX_l0_32_l0;
	pltgot[5] = OR_l0_l1_l0;
	pltgot[6] = JMPL_l0_o1 | LOVAL(proc);
	pltgot[7] = MOV_g1_o0;
}

void _dl_bind_start_0(long, long);
void _dl_bind_start_1(long, long);

static int
_dl_md_reloc_all_plt(elf_object_t *object)
{
	long	i;
	long	numrela;
	int	fails = 0;
	Elf_Addr loff;
	Elf_RelA *relas;

	loff = object->obj_base;
	numrela = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf64_Rela);
	relas = (Elf64_Rela *)(object->Dyn.info[DT_JMPREL]);

	if (relas == NULL)
		return(0);

	for (i = 0; i < numrela; i++, relas++) {
		Elf_Addr value;
		Elf_Word *where;
		const Elf_Sym *sym, *this;

		if (ELF_R_TYPE(relas->r_info) != R_TYPE(JMP_SLOT))
			continue;

		sym = object->dyn.symtab + ELF_R_SYM(relas->r_info);

		this = NULL;
		value = _dl_find_symbol_bysym(object, ELF_R_SYM(relas->r_info),
		    &this, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, NULL);
		if (this == NULL) {
			if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
				fails++;
			continue;
		}

		where = (Elf_Word *)(relas->r_offset + loff);
		value += this->st_value;

		if (__predict_false(relas->r_addend)) {
			/*
			 * This entry is >32768.  The relocation points to a
			 * PC-relative pointer to the _dl_bind_start_0 stub at
			 * the top of the PLT section.  Update it to point to
			 * the target function.
			 */
			*(Elf_Addr *)where = relas->r_addend + value -
			    object->Dyn.info[DT_PLTGOT];
		} else
			_dl_reloc_plt(&where[1], &where[2], where, value);
	}

	return (fails);
}

/*
 *	Relocate the Global Offset Table (GOT).
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	Elf_Word *entry = (Elf_Word *)pltgot;

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	if (object->traced)
		lazy = 1;

	/* temporarily make the PLT writable */
	_dl_protect_segment(object, 0, "__plt_start", "__plt_end",
	    PROT_READ|PROT_WRITE);

	if (!lazy) {
		fails = _dl_md_reloc_all_plt(object);
	} else {
		_dl_install_plt(&entry[0], (Elf_Addr)&_dl_bind_start_0);
		_dl_install_plt(&entry[8], (Elf_Addr)&_dl_bind_start_1);

		pltgot[8] = (Elf_Addr)object;
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	/* mprotect the PLT */
	_dl_protect_segment(object, 0, "__plt_start", "__plt_end",
	    PROT_READ|PROT_EXEC);

	return (fails);
}
@


1.59
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.58 2016/06/21 15:25:38 deraadt Exp $ */
d424 1
a424 1
	 * written.  To that end, we store the word to overwrite the 
d515 1
a515 1
		 * Target 42bits or smaller. 
@


1.58
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.57 2016/05/21 21:58:52 kettenis Exp $ */
d228 2
a229 4
	if (relrel > numrela) {
		_dl_printf("relacount > numrel: %ld > %ld\n", relrel, numrela);
		_dl_exit(20);
	}
d247 2
a248 4
		if (ELF_R_TYPE(relas->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELACOUNT wrong\n");
			_dl_exit(20);
		}
d638 2
a639 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.57
log
@Temporarily make the PLT writable when we're initializing the magic slots
or doing non-lazy relocation processing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.56 2015/11/02 07:02:53 guenther Exp $ */
d240 1
a240 1
				    llist->prot|PROT_WRITE);
@


1.56
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.55 2015/09/19 20:56:47 guenther Exp $ */
d849 4
@


1.55
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.54 2015/08/23 20:45:14 guenther Exp $ */
a842 3
	Elf_Addr ooff;
	Elf_Addr plt_addr;
	const Elf_Sym *this;
a846 47
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	plt_addr = 0;
	object->plt_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		plt_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__plt_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	if (plt_addr == 0)
		object->plt_start = 0;
	else {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
	}

d858 7
a864 6
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
@


1.54
log
@Use kbind for lazy binding GOT/PLT updates on amd64 and sparc64; others
to follow.  While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.53 2014/08/30 21:30:23 guenther Exp $ */
a75 1
#include <signal.h>
@


1.53
log
@Make the handling of PLT entries above the 32k mark thread-safe.
Also, make a comment not lie: use the V9 ISA's relative branch
immediate instruction for short (with in 2^19 words) PLT branches.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.52 2014/04/16 10:52:59 guenther Exp $ */
d70 3
d82 2
d204 2
a205 2
void _dl_reloc_plt(elf_object_t *object, Elf_Word *where, Elf_Addr value,
	Elf_RelA *rela);
d266 1
a266 4
		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JMP_SLOT) && rel != DT_JMPREL)
a308 5
		if (type == R_TYPE(JMP_SLOT)) {
			_dl_reloc_plt(object, (Elf_Word *)where, value, relas);
			continue;
		}

d381 1
a381 1
#define	JMP	0x81c06000	/*	jmpl	%g1+%lo(0), %g0 */
d388 1
a388 1
#define	CALL	0x40000000	/*	call	0 */
d400 3
a402 3
void
_dl_reloc_plt(elf_object_t *object, Elf_Word *where, Elf_Addr value,
    Elf_RelA *rela)
d414 1
a414 1
	 *	ba,a	%xcc, .PLT1
d422 10
a431 4
	 * When we replace these entries we start from the second
	 * entry and do it in reverse order so the last thing we
	 * do is replace the branch.  That allows us to change this
	 * atomically.
d438 2
a439 12
	offset = value - ((Elf_Addr)where);
	if (rela->r_addend) {
		Elf_Addr *ptr = (Elf_Addr *)where;
		/*
		 * This entry is >32768.  The relocation points to a
		 * PC-relative pointer to the _dl_bind_start_0 stub at
		 * the top of the PLT section.  Update it to point to
		 * the target function.
		 */
		ptr[0] = value + rela->r_addend - object->obj_base;

	} else if ((int64_t)(offset-4) <= (1L<<20) &&
d447 1
a447 1
		 *	ba,a	%xcc, addr
d456 2
a457 2
		where[1] = BAA | (((offset-4) >> 2) &0x7ffff);
		__asm volatile("iflush %0+4" : : "r" (where));
d474 3
a476 5
		where[2] = JMP   | LOVAL(value);
		where[1] = SETHI | HIVAL(value, 10);
		__asm volatile("iflush %0+8" : : "r" (where));
		__asm volatile("iflush %0+4" : : "r" (where));

d493 4
a496 7
		where[3] = JMP;
		where[2] = XOR | ((~value) & 0x00001fff);
		where[1] = SETHI | HIVAL(~value, 10);
		__asm volatile("iflush %0+12" : : "r" (where));
		__asm volatile("iflush %0+8" : : "r" (where));
		__asm volatile("iflush %0+4" : : "r" (where));

d514 4
a517 7
		where[3] = MOV17;
		where[2] = CALL	  | (((offset-8) >> 2) & 0x3fffffff);
		__asm volatile("iflush %0+12" : : "r" (where));
		__asm volatile("iflush %0+8" : : "r" (where));
		where[1] = MOV71;
		__asm volatile("iflush %0+4" : : "r" (where));

d536 5
a540 9
		where[4] = JMP   | LOVAL(value);
		where[3] = SLLX  | 10;
		where[2] = OR    | LOVAL(value >> 10);
		where[1] = SETHI | HIVAL(value, 20);
		__asm volatile("iflush %0+16" : : "r" (where));
		__asm volatile("iflush %0+12" : : "r" (where));
		__asm volatile("iflush %0+8" : : "r" (where));
		__asm volatile("iflush %0+4" : : "r" (where));

d559 6
a564 11
		where[5] = JMP   | LOVAL(value);
		where[4] = SRAX  | 22;
		where[3] = SLLX  | 32;
		where[2] = OR   | LOVAL(value >> 10);
		where[1] = SETHI | HIVAL(value, 20);

		__asm volatile("iflush %0+16" : : "r" (where));
		__asm volatile("iflush %0+12" : : "r" (where));
		__asm volatile("iflush %0+8" : : "r" (where));
		__asm volatile("iflush %0+4" : : "r" (where));

d581 7
a587 12
		where[6] = JMP | LOVAL(value);
		where[5] = ORG15;
		where[4] = SLLXG5 | 32;
		where[3] = ORG5 | LOVAL(value >> 32);
		where[2] = SETHI | HIVAL(value, 10);
		where[1] = SETHIG5 | HIVAL(value, 42);
		__asm volatile("iflush %0+24" : : "r" (where));
		__asm volatile("iflush %0+20" : : "r" (where));
		__asm volatile("iflush %0+16" : : "r" (where));
		__asm volatile("iflush %0+12" : : "r" (where));
		__asm volatile("iflush %0+8" : : "r" (where));
		__asm volatile("iflush %0+4" : : "r" (where));
d599 1
a599 1
	Elf_Addr ooff;
d603 8
a610 1
	sigset_t savedmask;
d632 3
a634 4
		index -= 4;
	}

	rela += index;
a639 1
	addr = (Elf_Word *)(object->obj_base + rela->r_offset);
d648 59
a706 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return ooff + this->st_value;
d708 28
a735 5
	/* if PLT is protected, allow the write */
	if (object->plt_size != 0)  {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_WRITE|PROT_EXEC);
d738 10
a747 7
	_dl_reloc_plt(object, addr, ooff + this->st_value, rela);

	/* if PLT is (to be protected), change back to RO/X */
	if (object->plt_size != 0) {
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
		_dl_thread_bind_lock(1, &savedmask);
d750 1
a750 1
	return ooff + this->st_value;
d781 54
d902 1
a902 1
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
@


1.52
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.51 2013/06/13 04:13:47 brad Exp $ */
d381 2
a382 1
#define	BAA	0x10400000	/*	ba,a	%xcc, 0 */
d444 1
a444 1
		ptr[0] += value - object->Dyn.info[DT_PLTGOT];
d463 1
a463 1
		where[1] = BAA | (((offset-4) >> 2) &0x3fffff);
@


1.51
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.50 2013/06/01 09:57:58 miod Exp $ */
d463 1
a463 1
		__asm __volatile("iflush %0+4" : : "r" (where));
d482 2
a483 2
		__asm __volatile("iflush %0+8" : : "r" (where));
		__asm __volatile("iflush %0+4" : : "r" (where));
d504 3
a506 3
		__asm __volatile("iflush %0+12" : : "r" (where));
		__asm __volatile("iflush %0+8" : : "r" (where));
		__asm __volatile("iflush %0+4" : : "r" (where));
d527 2
a528 2
		__asm __volatile("iflush %0+12" : : "r" (where));
		__asm __volatile("iflush %0+8" : : "r" (where));
d530 1
a530 1
		__asm __volatile("iflush %0+4" : : "r" (where));
d554 4
a557 4
		__asm __volatile("iflush %0+16" : : "r" (where));
		__asm __volatile("iflush %0+12" : : "r" (where));
		__asm __volatile("iflush %0+8" : : "r" (where));
		__asm __volatile("iflush %0+4" : : "r" (where));
d583 4
a586 4
		__asm __volatile("iflush %0+16" : : "r" (where));
		__asm __volatile("iflush %0+12" : : "r" (where));
		__asm __volatile("iflush %0+8" : : "r" (where));
		__asm __volatile("iflush %0+4" : : "r" (where));
d610 6
a615 6
		__asm __volatile("iflush %0+24" : : "r" (where));
		__asm __volatile("iflush %0+20" : : "r" (where));
		__asm __volatile("iflush %0+16" : : "r" (where));
		__asm __volatile("iflush %0+12" : : "r" (where));
		__asm __volatile("iflush %0+8" : : "r" (where));
		__asm __volatile("iflush %0+4" : : "r" (where));
@


1.50
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.49 2013/05/08 20:55:15 guenther Exp $ */
d668 1
a668 1
		*((int *)0) = 0;	/* XXX */
@


1.49
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.48 2013/01/31 06:26:27 guenther Exp $ */
d630 1
d665 1
a665 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d671 3
d783 3
@


1.48
log
@The code to use relative jumps in the GOT was completely broken, calculating
the offset in the wrong direction, failing to take into account where in the
relocation the jump would be, and not even using the right instructions in
one case.  Fortunately(?), the test of whether the offset was small enough
had signed-vs-unsigned bugs too, so it was never used.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.47 2012/12/05 23:20:07 deraadt Exp $ */
d208 1
d211 2
d218 1
d224 5
d240 14
a253 1
	for (i = 0; i < numrela; i++, relas++) {
d284 2
d301 3
a303 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.47
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.46 2011/04/06 11:36:25 miod Exp $ */
d362 2
a363 2
#define	MOV71	0x8283a000	/*	or	%o7, 0, %g1 */
#define	MOV17	0x9c806000	/*	or	%g1, 0, %o7 */
d408 1
a408 1
	offset = ((Elf_Addr)where) - value;
d419 2
a420 1
	} else if (offset <= (1L<<20) && offset >= -(1L<<20)) {
d436 1
a436 1
		where[1] = BAA | ((offset >> 2) &0x3fffff);
d466 2
a467 2
		 *	sethi	%hix(addr), %g1
		 *	xor	%g1, %lox(addr), %g1
d482 2
a483 1
	} else if (offset <= (1L<<32) && offset >= -((1L<<32) - 4)) {
d500 1
a500 2
		where[2] = CALL	  | ((offset >> 4) & 0x3fffffff);
		where[1] = MOV71;
d503 1
@


1.46
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.45 2010/05/02 04:57:01 guenther Exp $ */
a68 1
#include <sys/cdefs.h>
@


1.45
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.44 2010/04/24 18:12:29 kettenis Exp $ */
d707 1
a707 1
	object->got_addr = NULL;
d739 2
a740 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d746 2
a747 2
	if (plt_addr == NULL)
		object->plt_start = NULL;
@


1.44
log
@Fix handling of more than 32768 PLT entries.  Mostly from NetBSD.

eyeballed by deraadt@@ and drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.43 2008/07/16 20:33:42 drahn Exp $ */
d603 1
a603 1
	sigset_t omask, nmask;
d646 1
a646 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d657 1
a657 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.43
log
@Fix several of the 'large offset' PLT entries. With help from kurt.
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.42 2008/04/09 21:45:26 kurt Exp $ */
d200 2
a201 1
void _dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_RelA *rela);
d283 1
a283 1
			_dl_reloc_plt((Elf_Word *)where, value, relas);
d378 2
a379 1
_dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_RelA *rela)
d413 4
a416 1
		 * This entry is >32768.  Just replace the pointer.
d418 1
a418 1
		ptr[0] = value;
d653 1
a653 1
	_dl_reloc_plt(addr, ooff + this->st_value, rela);
@


1.42
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.41 2008/02/24 10:16:58 kettenis Exp $ */
d359 3
a361 2
#define	OR	0x82806000	/*	or	%g1, 0, %g1 */
#define	XOR	0x82c06000	/*	xor	%g1, 0, %g1 */
d365 3
a367 1
#define	SLLX	0x8b407000	/*	sllx	%g1, 0, %g1 */
d369 1
a369 1
#define	ORG5	0x82804005	/*	or	%g1, %g5, %g1 */
d433 1
a433 1
	} else if (value >= 0 && value < (1L<<32)) {
d435 1
a435 1
		 * We're withing 32-bits of address zero.
d454 1
a454 1
	} else if (value <= 0 && value > -(1L<<32)) {
d456 1
a456 1
		 * We're withing 32-bits of address -1.
d479 1
a479 1
		 * We're withing 32-bits -- we can use a direct call insn
d500 1
a500 1
	} else if (offset >= 0 && offset < (1L<<44)) {
d502 2
a503 1
		 * We're withing 44 bits.  We can generate this pattern:
d508 4
a511 4
		 *	sethi	%h44(addr), %g1
		 *	or	%g1, %m44(addr), %g1
		 *	sllx	%g1, 12, %g1
		 *	jmp	%g1+%l44(addr)
d516 1
d518 4
a521 4
		where[4] = JMP   | LOVAL(offset);
		where[3] = SLLX  | 12;
		where[2] = OR    | (((offset) >> 12) & 0x00001fff);
		where[1] = SETHI | HIVAL(offset, 22);
d527 1
a527 1
	} else if (offset < 0 && offset > -(1L<<44)) {
d529 2
a530 1
		 * We're withing 44 bits.  We can generate this pattern:
d535 5
a539 4
		 *	sethi	%h44(-addr), %g1
		 *	xor	%g1, %m44(-addr), %g1
		 *	sllx	%g1, 12, %g1
		 *	jmp	%g1+%l44(addr)
d545 6
a550 4
		where[4] = JMP   | LOVAL(offset);
		where[3] = SLLX  | 12;
		where[2] = XOR   | (((~offset) >> 12) & 0x00001fff);
		where[1] = SETHI | HIVAL(~offset, 22);
d563 4
a566 4
		 *	sethi	%hh(addr), %g1
		 *	sethi	%lm(addr), %g5
		 *	or	%g1, %hm(addr), %g1
		 *	sllx	%g1, 32, %g1
d573 5
a577 5
		where[5] = ORG5;
		where[4] = SLLX | 12;
		where[3] = OR | LOVAL((value) >> 32);
		where[2] = SETHIG5 | HIVAL(value, 10);
		where[1] = SETHI | HIVAL(value, 42);
@


1.41
log
@Use rounded down address when changing memory protections on the GOT, such
that we don't accidentally touch the page after the GOT.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.40 2007/11/27 16:42:19 miod Exp $ */
d213 1
a213 1
	loff = object->load_offs;
d620 1
a620 1
	addr = (Elf_Word *)(object->load_offs + rela->r_offset);
@


1.40
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.39 2007/05/05 15:21:21 drahn Exp $ */
d752 1
a752 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.39
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.38 2006/10/28 16:06:05 drahn Exp $ */
d208 1
a208 1
	long	fails = 0;
d683 1
a683 1
void
d686 1
d694 1
a694 1
		return;
d744 1
a744 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d757 2
@


1.38
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.37 2005/09/22 01:33:09 drahn Exp $ */
d634 1
d645 1
@


1.37
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.36 2005/09/21 23:12:11 drahn Exp $ */
d223 1
a223 1
	if ((rel == DT_REL || rel == DT_RELA)) {
d341 1
a341 1
	if ((rel == DT_REL || rel == DT_RELA)) {
@


1.36
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.35 2005/09/16 23:19:43 drahn Exp $ */
d272 3
a274 5
					_dl_printf("%s: %s: can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);
					fails++;
@


1.35
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2004/05/25 21:42:48 mickey Exp $ */
d269 1
a269 1
				    sym->st_size, NULL);
d297 1
a297 1
			    size, object, NULL);
d625 1
a625 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
d699 1
a699 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d706 1
a706 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d715 1
a715 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d722 1
a722 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
@


1.34
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2004/05/25 18:07:21 mickey Exp $ */
d265 1
a265 2
				    ELF_R_SYM(relas->r_info),
				    _dl_objects, &this, NULL,
d269 1
a269 1
				    sym->st_size);
d295 3
a297 3
			soff = _dl_find_symbol(symn, object->next, &srcsym,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    size, object);
d624 3
a626 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d698 3
a700 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d705 3
a707 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d714 3
a716 2
	ooff = _dl_find_symbol("__plt_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d721 3
a723 2
	ooff = _dl_find_symbol("__plt_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
@


1.33
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2004/05/25 15:56:19 deraadt Exp $ */
a78 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	const unsigned char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2003/09/04 19:37:08 drahn Exp $ */
d277 1
a277 1
				    _dl_objects, &this,
d308 1
a308 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
d636 1
a636 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
d709 1
a709 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d715 1
a715 1
	ooff = _dl_find_symbol("__got_end", object, &this,
d723 1
a723 1
	ooff = _dl_find_symbol("__plt_start", object, &this,
d729 1
a729 1
	ooff = _dl_find_symbol("__plt_end", object, &this,
@


1.31
log
@Fix W^X mistake. If the dynamic linker is workin in non-lazy mode, it
should still mprotect the GOT and PLT as appropriate. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2003/09/04 19:33:50 drahn Exp $ */
d577 1
a577 1
		where[6] = JMP     | LOVAL(value);
d579 2
a580 2
		where[4] = SLLX    | 12;
		where[3] = OR      | LOVAL((value) >> 32);
d582 1
a582 1
		where[1] = SETHI   | HIVAL(value, 42);
@


1.30
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2003/09/02 15:17:52 drahn Exp $ */
d751 5
a755 1
		return;
a756 6

	_dl_install_plt(&entry[0], (Elf_Addr)&_dl_bind_start_0);
	_dl_install_plt(&entry[8], (Elf_Addr)&_dl_bind_start_1);

	pltgot[8] = (Elf_Addr)object;

@


1.29
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2003/07/28 03:11:00 drahn Exp $ */
d275 7
a281 5
				ooff = _dl_find_symbol(symn, _dl_objects,
				    &this, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JMP_SLOT))?
					SYM_PLT:SYM_NOTPLT),
				    sym->st_size, object);
@


1.28
log
@The fifth argument to _dl_find_symbol is a 'int size', not a SYM_ define.
Fix several calls which had the incorrect but working define in that position
It happened that SYM_NOTPLT was 0, which was the desired size value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2003/07/06 20:04:00 deraadt Exp $ */
d279 1
a279 1
				    sym->st_size, object->load_name);
d307 1
a307 1
			    size, object->load_name);
d635 1
a635 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0, object->load_name);
d708 1
a708 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d714 1
a714 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d722 1
a722 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d728 1
a728 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
@


1.27
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2003/06/03 16:20:41 art Exp $ */
d708 1
a708 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d714 1
a714 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d722 1
a722 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d728 1
a728 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
@


1.26
log
@three four gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2003/02/15 22:39:14 drahn Exp $ */
d212 1
d593 1
a593 1
void *
d658 1
a658 1
	return (void *)ooff + this->st_value;
@


1.25
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2003/02/02 16:57:58 deraadt Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2002/12/18 19:20:02 drahn Exp $ */
d647 1
a647 1
	if (object->plt_addr != NULL && object->plt_size != 0)  {
d650 1
a650 1
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
d657 2
a658 2
	if (object->plt_addr != NULL && object->plt_size != 0) {
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
d703 1
d709 2
d725 2
d732 1
a732 1
		object->plt_addr = ooff + this->st_value;
d739 16
a754 1
		object->plt_size = ooff + this->st_value  - object->plt_addr;
d766 1
a766 1
	if (object->got_addr != NULL && object->got_size != 0)
d769 2
a770 2
	if (object->plt_addr != NULL && object->plt_size != 0)
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
@


1.23
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2002/11/14 15:15:54 drahn Exp $ */
d651 1
a651 1
		    PROT_READ|PROT_WRITE|PROT_EXEC); 
d659 1
a659 1
		    PROT_READ|PROT_EXEC); 
d728 1
a728 1
	 
d746 1
a746 1
	if (object->got_addr != NULL && object->got_size != 0) 
d748 2
a749 2
		    PROT_READ); 
	if (object->plt_addr != NULL && object->plt_size != 0) 
@


1.22
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2002/09/01 23:55:01 drahn Exp $ */
d80 1
d606 1
d646 8
d656 7
d702 2
d708 28
d745 7
@


1.21
log
@Make sure that the symbol return value is always initialized before
the address of it is passed to dl_find_symbol(). fixes xpdf lazy
binding problem. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2002/08/23 23:29:32 art Exp $ */
d283 1
a283 1
				    sym->st_size);
d311 1
a311 1
			    size);
d638 1
a638 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0);
@


1.20
log
@Fix after recent changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2002/08/23 22:57:03 drahn Exp $ */
d636 1
@


1.19
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2002/08/11 16:51:04 drahn Exp $ */
d310 1
a310 1
			    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_NOTPLT,
@


1.18
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2002/07/12 20:18:30 drahn Exp $ */
d280 4
a283 1
				    &this, 0, 1, type == R_TYPE(JMP_SLOT));
a293 14
#ifdef notyet
/*
 * XXX Hmm, we should change the API of _dl_find_symbol and do this in there,
 * XXX or maybe make a wrapper.
 */
				if (this->st_size != sym->st_size &&
				    sym->st_size != 0) {
					_dl_printf("%s: %s : WARNING: "
					    "symbol(%s) size mismatch ",
					    _dl_progname, object->load_name,
					    symn);
					_dl_printf("relink your program\n");
				}
#endif
d310 2
a311 1
				0, 2, 0);
d636 2
a637 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1, 1);
@


1.17
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2002/06/05 23:13:55 art Exp $ */
d280 1
a280 1
				    &this, 0, 1);
d321 1
a321 1
				0, 2);
d646 1
a646 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
@


1.16
log
@Cleanup/remove duplicate code that checks STAT_RELOC_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2002/06/05 19:34:44 art Exp $ */
d267 2
@


1.15
log
@Get rid of an unnecessary typedef (for future cleanup).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2002/06/03 20:30:50 drahn Exp $ */
d232 1
a232 1
	if ((object->status & STAT_RELOC_DONE) || !relas)
@


1.14
log
@Proper masks for 64 bit relocation types. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2002/05/24 04:17:01 deraadt Exp $ */
d226 1
a226 1
	load_list_t *llist;
@


1.13
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2002/05/24 03:44:38 deraadt Exp $ */
d197 1
a197 1
	_BM(32), _BM(32), _BM(32),	/* _GLOB_DAT, JMP_SLOT, _RELATIVE */
@


1.12
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2002/03/15 14:52:39 drahn Exp $ */
d53 2
a54 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d228 1
a228 1
	loff   = object->load_offs;
@


1.11
log
@Add support for binutils 2.11. Work around change in PLT generation new ld
generates. From NetBSD. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2002/02/21 23:17:53 drahn Exp $ */
d7 1
a7 1
 * 
d88 2
a89 2
	const unsigned char *psrc;
	unsigned char *pdest;
d91 2
a92 3
	psrc = src;
	pdest = dest;
	for (i = 0; i < size; i++) {
a93 1
	}
d117 1
a117 1
#define _RF_RS(s)	( (s) & 0xff)		/* right shift */
d195 1
a195 1
	_BM(10), _BM(22),		/* _PC10, _PC22 */  
d232 1
a232 1
	if ((object->status & STAT_RELOC_DONE) || !relas) {
a233 1
	}
d240 1
a240 1
			if (!(llist->prot & PROT_WRITE)) {
d242 1
a242 2
					llist->prot|PROT_WRITE);
			}
d281 1
a281 1
					_dl_printf("%s: %s :can't resolve "
d328 1
a328 1
		if (RELOC_PC_RELATIVE(type)) {
d330 1
a330 3
		}

		if (RELOC_BASE_RELATIVE(type)) {
a331 1
		}
d342 1
a342 1
		
d367 1
a367 1
			if (!(llist->prot & PROT_WRITE)) {
d369 1
a369 2
					llist->prot);
			}
d437 1
a437 1
		/* 
d455 1
a455 1
		/* 
d476 1
a476 1
		/* 
d499 2
a500 2
		/* 
		 * We're withing 32-bits -- we can use a direct call insn 
d522 1
a522 1
		/* 
d530 2
a531 2
		 *	sllx	%g1, 12, %g1	
		 *	jmp	%g1+%l44(addr)	
d547 1
a547 1
		/* 
d555 2
a556 2
		 *	sllx	%g1, 12, %g1	
		 *	jmp	%g1+%l44(addr)	
d572 1
a572 1
		/* 
a598 1

d649 1
a649 1
	
@


1.10
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2002/02/20 05:04:34 jason Exp $ */
d615 1
a615 1
_dl_bind(elf_object_t *object, Elf_Word reloff)
d623 24
a646 1
	rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);
@


1.9
log
@Fix obvious pasto: when iflush'n flush 24,20,16,... not 20,16,16,...
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2001/09/27 06:58:33 art Exp $ */
d292 1
a307 1
			value += (Elf_Addr)(ooff + this->st_value);
a318 1
			const char *name = symn;
@


1.8
log
@Local symbols don't need to have a name. Don't barf on them.
They are often generated by gcc c++ exceptions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2001/09/26 14:57:56 art Exp $ */
d602 1
a603 1
		__asm __volatile("iflush %0+16" : : "r" (where));
@


1.7
log
@Some juggling to simplify the code and some missing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2001/09/26 10:45:02 art Exp $ */
d276 8
a283 3
			this = NULL;
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
			if (this == NULL) {
d285 21
a305 4
				_dl_printf("%s: %s :can't resolve reference '%s'\n",
					_dl_progname, object->load_name, symn);
				fails++;
				continue;
a306 1

@


1.6
log
@Lazy binding. Parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2001/09/26 10:19:16 art Exp $ */
d226 1
a226 1
	Elf_Addr loff, mask;
d251 2
a252 2
		Elf_Addr *where, value, ooff;
		long type;
a255 2
		where = (Elf64_Addr *)(relas->r_offset + loff);

a256 1
		value = relas->r_addend;
d261 1
a261 2
		if (type == R_TYPE(RELATIVE)) {
			*where = (Elf_Addr)(loff + value);
a262 1
		}
d264 6
a269 2
		if (type == R_TYPE(JMP_SLOT) && rel != DT_JMPREL)
			continue;
a289 2
			if (relas->r_addend)
				value -= relas->r_addend;
d319 4
@


1.5
log
@Implement COPY relocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2001/09/26 09:32:32 art Exp $ */
d597 2
a598 1
	Elf_Addr *addr, ooff;
d608 1
a608 1
	addr = (Elf_Addr *)(object->load_offs + rela->r_offset);
d614 2
a615 1
	*addr = ooff + this->st_value + rela->r_addend;
d617 1
a617 1
	return (void *)*addr;
d621 28
d654 7
a660 1
	if (object->Dyn.info[DT_PLTREL] == DT_RELA)
d662 7
@


1.4
log
@Code for PLT relocations. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2001/09/25 14:29:48 art Exp $ */
d85 13
d140 1
a140 1
				_RF_SZ(32) | _RF_RS(0),		/* COPY */
a263 5
		if (type == R_TYPE(COPY)) {
_dl_printf("COPY relocation\n");
			continue;
		}

d280 1
d293 19
a311 1
			_dl_reloc_plt((Eld_Word *)where, value, relas);
@


1.3
log
@Duh! if we go through the hassle of looking up a symbol it might
be a good idea to actually use the value of the symbol.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2001/09/25 14:12:23 art Exp $ */
d129 1
a129 1
				_RF_SZ(32) | _RF_RS(0),		/* JMP_SLOT */
d205 2
a226 2
	 * XXX - we unprotect waay to much. only the text can have cow
	 *       relocations.
d239 1
a239 1
		Elf_Word type;
a250 5
		if (type == R_TYPE(JMP_SLOT)) {
_dl_printf("JMP_SLOT relocation\n");
			continue;
		}

d261 3
d281 7
a321 4
	/*
	 * flush ??  - XXX
	__asm __volatile("imb" : : : "memory");
	 */
d337 227
d597 1
a597 7
	Elf_Addr *pltgot;
	extern void _dl_bind_start(void);	/* XXX */

	lazy = 0; /* not yet */
	pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];

	if (object->obj_type == OBJTYPE_LDR || !lazy || pltgot == NULL) {
a598 21
		return;
	}

#ifdef SUPPORT_LAZY
	if (object->obj_type != OBJTYPE_EXE) {
		int i, size;
		Elf_Addr *addr;
		Elf_RelA *rela;

		size = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf_RelA);
		rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);

		for (i = 0; i < size; i++) {
			addr = (Elf_Addr *)(object->load_offs + rela[i].r_offset);
			*addr += object->load_offs;
		}
	}

	pltgot[2] = (Elf_Addr)_dl_bind_start;
	pltgot[3] = (Elf_Addr)object;
#endif /* SUPPORT_LAZY */
@


1.2
log
@Borrow a big chunk of code from the NetBSD ld.elf_so to do all the
basic relocations with a table.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2001/09/23 00:14:56 drahn Exp $ */
d279 2
@


1.1
log
@add munmap syscall
change _rtld references to _dl to match C code.
change relocation types in archdep.h to be sparc64 relocs.

rtld_machine.c copied from alpha, with some modes to compile for sparc64

This is in-tree development.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2001/06/26 18:43:06 art Exp $ */
d34 8
d43 27
d85 119
a203 11
void
_dl_bcopy(void *src, void *dest, int size)
{
	unsigned char *psrc, *pdest;
	int i;
	psrc = src;
	pdest = dest;
	for (i = 0; i < size; i++) {
		pdest[i] = psrc[i];
	}
}
d211 2
a212 2
	Elf64_Addr loff;
	Elf64_Rela  *relas;
d238 3
a240 3
		Elf64_Addr *r_addr;
		Elf64_Addr ooff;
		const Elf64_Sym *sym, *this;
d243 4
a246 1
		r_addr = (Elf64_Addr *)(relas->r_offset + loff);
d248 10
a257 1
		if (ELF64_R_SYM(relas->r_info) == 0xffffffff) {
d261 11
a271 7
		sym = object->dyn.symtab;
		sym += ELF64_R_SYM(relas->r_info);
		symn = object->dyn.strtab + sym->st_name;

		this = NULL;
		switch (ELF64_R_TYPE(relas->r_info)) {
		case R_TYPE(64):
d273 5
a277 20
			if (this == NULL)
				goto resolve_failed;
			*r_addr += ooff + this->st_value + relas->r_addend;
			break;
		case R_TYPE(RELATIVE):
			/*
			 * There is a lot of unaligned RELATIVE
			 * relocs generated by gcc in the exception handlers.
			 */
			if ((((Elf_Addr) r_addr) & 0x7) != 0) {
				Elf_Addr tmp;
#if 0
_dl_printf("unaligned RELATIVE: %p type: %d %s 0x%lx -> 0x%lx\n", r_addr,
ELF_R_TYPE(relas->r_info), object->load_name, *r_addr, *r_addr+loff);
#endif
				_dl_bcopy(r_addr, &tmp, sizeof(Elf_Addr));
				tmp += loff;
				_dl_bcopy(&tmp, r_addr, sizeof(Elf_Addr));
			} else {
				*r_addr += loff;
d279 35
a313 27
			break;
		case R_TYPE(JMP_SLOT):
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
			if (this == NULL)
				goto resolve_failed;
			*r_addr = ooff + this->st_value + relas->r_addend;
			break;
		case R_TYPE(GLOB_DAT):
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
			if (this == NULL)
				goto resolve_failed;
			*r_addr = ooff + this->st_value + relas->r_addend;
			break;
		case R_TYPE(NONE):
			break;
		default:
			_dl_printf("%s:"
				" %s: unsupported relocation '%s' %d at %lx\n",
					_dl_progname, object->load_name, symn,
					ELF64_R_TYPE(relas->r_info), r_addr );
			_dl_exit(1);
		}
		continue;
resolve_failed:
		_dl_printf("%s: %s :can't resolve reference '%s'\n",
			_dl_progname, object->load_name, symn);
		fails++;
@

