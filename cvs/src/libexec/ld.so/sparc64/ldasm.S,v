head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.37.0.8
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.14
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.16
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.12
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.10
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7;
locks; strict;
comment	@# @;


1.45
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.44;
commitid	veGB6uLWx3BTEAfk;

1.44
date	2016.08.28.06.15.33;	author guenther;	state Exp;
branches;
next	1.43;
commitid	Y7AbrDd15D7CrGY4;

1.43
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.42;
commitid	d9R7VGw9CHTkwXE1;

1.42
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.41;
commitid	hneUpr7ZOJCeNeHP;

1.41
date	2016.03.21.01.32.49;	author guenther;	state Exp;
branches;
next	1.40;
commitid	7Tp2uEssgeiK9f77;

1.40
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	kmpP8aoRsEOyxUMj;

1.39
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.38;
commitid	FcRQ6g8MqXiORdFs;

1.38
date	2015.09.13.17.08.04;	author guenther;	state Exp;
branches;
next	1.37;
commitid	BssYI6s6zozAyfkk;

1.37
date	2014.07.14.03.54.51;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	fsr4AzfIP3TLhLM2;

1.36
date	2014.07.09.12.51.21;	author guenther;	state Exp;
branches;
next	1.35;
commitid	l16v8zUGQ3906m8T;

1.35
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.34;
commitid	vlK4cqSehsiJVTpr;

1.34
date	2013.12.23.22.24.37;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2013.12.23.17.29.15;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.13.05.52.21;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.24.03.26.56;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.22.17.27.19;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.27.20.44.23;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.09.09.34.42;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.24.18.12.29;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.03.16.10.52;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.25.15.56.19;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.10.22.47.54;	author pvalchev;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.12.18.53.44;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.09.21.01.10;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.20.20.35;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.23.06.19.26;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.21.16.01.55;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.11.18.41.17;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.24.04.17.01;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.03.44.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.17.00.22.04;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.15.14.52.39;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.25.06.57.03;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.25.06.34.31;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.24.23.51.12;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.24.23.40.56;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.24.16.25.00;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.23.00.14.56;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.14.52.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.45
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: ldasm.S,v 1.44 2016/08/28 06:15:33 guenther Exp $	*/
/*	$NetBSD: rtld_start.S,v 1.5 2001/08/14 22:17:48 eeh Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2000 Eduardo Horvath.
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Christos Zoulas and Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/syscall.h>
#include <machine/trap.h>
#include <machine/asm.h>
#define	_LOCORE
#include <machine/frame.h>

/*
 * ELF:
 *	On startup the stack should contain 16 extended word register save
 *	area, followed by the arg count, etc.
 *
 * _rtld() expects the stack pointer to point to two longwords for argument
 *	return followed by argc, etc.  We need to create a pointer to
 *	&argc + 16 and pass that in.  The return args will be in those
 *	locations.
 */

/* Offset of ARGC from bottom of stack */
#define	ARGC	CC64FSZ
/* XXX - DL_DATA_SIZE should be (9*8), but I can't think right now. */
#define DL_DATA_SIZE (16*8)

	.section	".text"
	.align	16
	.register %g2,#scratch

_ENTRY(_dl_start)
	sub	%g0, %g0, %fp		! clear frame
	sub	%sp, 48 + DL_DATA_SIZE, %sp	! make room for dl_data
	add	%sp, BIAS + ARGC, %l3

	add	%l3, DL_DATA_SIZE, %o0
	mov	%o0, %l0

	/*
	 * need to figure out where _DYNAMIC is located, newer binutils
	 * does not fill in GOT to read _DYNAMIC before relocation.
	 */
	call	0f
	 nop
	call	_DYNAMIC+8		! not executed (no delay needed)
0:	ld	[%o7+8], %o2		! load stub call instruction
	sll	%o2, 2, %o2		! extract PC offset
	sra	%o2, 0, %o2		! sign-extend

	add	%o2, %o7, %o2		! real &_DYNAMIC

	call	_dl_boot_bind		! _dl_boot_bind(sp,dl_data,dynamicp)
	 mov	%l3, %o1

	mov	%l3, %o3
	ldx	[%l0], %l3		! argc = *sp
	sllx	%l3, 3, %l3		! argc *= sizeof(long)
	addx	%l0, 8, %o0		! argv = [sp + argc]
	addx	%l0, 16, %o1		! envp = sp + 16 +
	addx	%o1, %l3, %o1		!	+ argc

	addx	%o3, (7*8), %l2
	ldx	[%l2], %o2		! loff = dl_data[AUX_base];

	call	_dl_boot		! _dl_boot(argv,envp,loff,dl_data)
	 nop

	add	%sp, 48 + DL_DATA_SIZE, %sp	! restore stack

1:	call	2f
	 sethi	%hi(_GLOBAL_OFFSET_TABLE_+(.-1b)), %l7
2:	or	%l7, %lo(_GLOBAL_OFFSET_TABLE_+(.-1b)), %l7
	add	%l7, %o7, %l7

	jmp	%o0
	 ldx	[%l7 + _dl_dtors], %g1	! %g1 = cleanup

	/*
	 * We have two separate entry points to the runtime linker.
	 * I'm implementing this following the SPARC v9 ABI spec.
	 *
	 * _dl_bind_start_0(x, y) is called from .PLT0, and is used for
	 * PLT entries above 32768.
	 *
	 * _dl_bind_start_1(x, y) is called from .PLT1, and is used for
	 * PLT entries below 32768.
	 *
	 * The first two entries of PLT2 contain the xword object pointer.
	 *
	 * These routines are called with two longword arguments,
	 * x and y.  To calculate the address of the entry,
	 * _dl_bind_start_1(x, y) does:
	 *
	 *	n = x >> 15;
	 *
	 * and _dl_bind_start_0(x, y) does:
	 *
	 *	i = x - y + 8 - 32768*32;
	 *	n = 32768 + (i/5120)*160 + (i%5120)/24;
	 *
	 * Neither routine needs to issue a save since it's already been
	 * done in the PLT entry.
	 */

	/* NOTE: _dl_bind_start_0 is untested.  Hence the debug stuff */

_ENTRY(_dl_bind_start_0)		# (x, y)
	sethi	%hi(32768*32-8), %l1
	sub	%o0, %o1, %l0		/* x - y */
	or	%l1, %lo(32768*32-8), %l1
	sub	%l0, %l1, %l0		/* x - y + 8 - 32768*32 */

	sethi	%hi(5120), %l1
	sdivx	%l0, %l1, %l1		/* Calculate i/5120 */
	ldx	[%o1 + (10*4)], %o0	/* Load object pointer from PLT2 */
	sllx	%l1, 2, %l2
	add	%l1, %l2, %l2
	sllx	%l2, 10, %l2
	sub	%l0, %l2, %l2		/* And i%5120 */

	/* Let the division churn for a bit. */
	sdivx	%l2, 24, %l4		/* (i%5120)/24 */

	/* 160 is (32 * 5) or (32 * (4 + 1)) */
	sllx	%l1, 2, %l3		/* 4 * (i/5120) */
	add	%l1, %l3, %l3		/* 5 * (i/5120) */
	sllx	%l3, 5, %l3		/* 32 * 5 * (i/5120) */

	sethi	%hi(32768), %l6
	add	%l3, %l4, %l5		/* %l5 = (i/5120)*160 + (i%5120)/24; */
	add	%l5, %l6, %l5

	call	_dl_bind		/* Call _dl_bind(obj, offset) */
	 mov	%l5, %o1

	jmp	%o0			/* return value == function address */
	 restore			/* Dump our stack frame */

_ENTRY(_dl_bind_start_1)		# (x, y)
	srax	%o0, 15, %o2		/* %o0 is the index to our PLT slot */

	ldx	[%o1 + 8], %o0		/* The object pointer is at [%o1 + 8] */

	call	_dl_bind		/* Call _dl_bind(obj, offset) */
	 mov	%o2, %o1

	jmp	%o0			/* return value == function address */
	 restore			/* Dump our stack frame */

_ENTRY(_dl_close)
	mov SYS_close | SYSCALL_G2RFLAG, %g1	! call sys_close
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_exit)
	mov SYS_exit | SYSCALL_G2RFLAG, %g1	! call sys_exit
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_issetugid)
	mov SYS_issetugid | SYSCALL_G2RFLAG, %g1	! call sys_issetugid
	add %o7, 8, %g2					! just return on success
	t ST_SYSCALL					! off to wonderland
	retl
	 sub %g0, %o0, %o0				! error: result = -errno

_ENTRY(_dl_getthrid)
	mov SYS_getthrid | SYSCALL_G2RFLAG, %g1	! call sys_getthrid
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl__syscall)
	mov SYS___syscall | SYSCALL_G2RFLAG, %g1	! call sys___syscall
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_munmap)
	mov SYS_munmap | SYSCALL_G2RFLAG, %g1	! calling sys_munmap
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_mprotect)
	mov SYS_mprotect | SYSCALL_G2RFLAG, %g1	! calling sys_mprotect
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_open)
	mov SYS_open | SYSCALL_G2RFLAG, %g1	! calling sys_open
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_read)
	mov SYS_read | SYSCALL_G2RFLAG, %g1	! calling sys_read
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_write)
	mov SYS_write | SYSCALL_G2RFLAG, %g1	! calling sys_write
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_fstat)
	mov  SYS_fstat | SYSCALL_G2RFLAG, %g1	! call sys_fstat
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_getdents)
	mov  SYS_getdents | SYSCALL_G2RFLAG, %g1	! call sys_getdents
	add %o7, 8, %g2					! just return on success
	t ST_SYSCALL					! off to wonderland
	retl
	 sub %g0, %o0, %o0				! error: result = -errno

_ENTRY(_dl_sysctl)
	mov  SYS_sysctl | SYSCALL_G2RFLAG, %g1		! call sys_sysctl
	add %o7, 8, %g2					! just return on success
	t ST_SYSCALL					! off to wonderland
	retl
	 sub %g0, %o0, %o0				! error: result = -errno

_ENTRY(_dl_readlink)
	mov SYS_readlink | SYSCALL_G2RFLAG, %g1	! calling sys_readlink
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_getcwd)
	mov SYS___getcwd | SYSCALL_G2RFLAG, %g1	! calling sys___getcwd
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_utrace)
	mov SYS_utrace | SYSCALL_G2RFLAG, %g1	! calling sys_utrace
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_getentropy)
	mov SYS_getentropy | SYSCALL_G2RFLAG, %g1	! calling sys_getentropy
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_sendsyslog)
	mov SYS_sendsyslog | SYSCALL_G2RFLAG, %g1	! calling sys_sendsyslog
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_pledge)
	mov SYS_pledge | SYSCALL_G2RFLAG, %g1	! calling sys_pledge
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_thrkill)
	mov SYS_thrkill | SYSCALL_G2RFLAG, %g1	! calling sys_thrkill
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno
@


1.44
log
@ld.so doesn't need gettimeofday or lstat stubs any more

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.43 2016/05/07 19:05:23 guenther Exp $	*/
d340 7
@


1.43
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.42 2016/03/21 22:41:29 bluhm Exp $	*/
a302 7
_ENTRY(_dl_gettimeofday)
	mov SYS_gettimeofday | SYSCALL_G2RFLAG, %g1	! calling sys_gettimeofday
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

a304 7
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_lstat)
	mov SYS_lstat | SYSCALL_G2RFLAG, %g1	! calling sys_lstat
@


1.42
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.41 2016/03/21 01:32:49 guenther Exp $	*/
d232 7
@


1.41
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.40 2015/11/15 03:41:24 deraadt Exp $	*/
d338 2
a339 2
_ENTRY(_dl_sendsyslog2)
	mov SYS_sendsyslog2 | SYSCALL_G2RFLAG, %g1	! calling sys_sendsyslog
@


1.40
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.39 2015/09/19 20:56:47 guenther Exp $	*/
d338 2
a339 2
_ENTRY(_dl_sendsyslog)
	mov SYS_sendsyslog | SYSCALL_G2RFLAG, %g1	! calling sys_sendsyslog
@


1.39
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.38 2015/09/13 17:08:04 guenther Exp $	*/
d340 7
@


1.38
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.37 2014/07/14 03:54:51 deraadt Exp $	*/
a287 13

	/* _dl_sigprocmask does not support NULL new mask */
_ENTRY(_dl_sigprocmask)
	ld	[%o1], %o1			! indirect for new mask
	mov	SYS_sigprocmask, %g1		! call sys_sigprocmask
	t ST_SYSCALL				! off to wonderland
						! what about errors?
	cmp	%o2, 0
	bne,a	1f				! if oset != NULL
	 st	%o0, [%o2]			!   *oset = oldmask
1:
	retl
	 clr %o0
@


1.37
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.36 2014/07/09 12:51:21 guenther Exp $	*/
d303 1
a303 1
	mov  SYS___sysctl | SYSCALL_G2RFLAG, %g1	! call sys___sysctl
@


1.36
log
@_dl_fcntl() is no longer used; kill the stubs

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.35 2014/07/06 07:28:36 otto Exp $	*/
d346 7
@


1.35
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.34 2013/12/23 22:24:37 kettenis Exp $	*/
a276 7
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_fcntl)
	mov  SYS_fcntl | SYSCALL_G2RFLAG, %g1	! call sys_fcntl
@


1.34
log
@Use slightly diffrerent code to get the global offset table address.  This
version will match the (upcoming) 32-bit version (for sparc) and allegedly
is slightly faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.33 2013/12/23 17:29:15 kettenis Exp $	*/
d346 7
@


1.33
log
@Make ld.so pass its cleanup handler in %g1 as required by the SPARC System V
ABI, and stop calling atexit(4) directly from ld.so on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.32 2013/08/13 05:52:21 guenther Exp $	*/
d132 4
a135 4
	sethi	%hi(_GLOBAL_OFFSET_TABLE_ - 4), %l7
	rd	%pc, %g1
	or	%l7, %lo(_GLOBAL_OFFSET_TABLE_ + 4), %l7
	add	%l7, %g1, %l7
@


1.32
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.31 2013/06/01 09:57:58 miod Exp $	*/
d132 5
d138 1
a138 1
	 clr	%g1			! XXX don't register with atexit
@


1.31
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.30 2013/04/05 12:58:03 kurt Exp $	*/
d284 2
a285 2
_ENTRY(_dl_getdirentries)
	mov  SYS_getdirentries | SYSCALL_G2RFLAG, %g1	! call sys_getdirentries
@


1.30
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.29 2012/10/24 03:26:56 guenther Exp $	*/
d339 6
@


1.29
log
@Garbage-collect the _dl_stat() routine, now unused

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.28 2012/10/22 17:27:19 kettenis Exp $	*/
d313 21
@


1.28
log
@Stop passing around PS_STRINGS in %g1.  The ELF ABI reserves this register
for passing around a pointer to a cleanup function and we'd like to use it
for that purpose in the near future.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.27 2010/10/27 20:44:23 millert Exp $	*/
a264 7
	add %o7, 8, %g2				! just return on success
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno

_ENTRY(_dl_stat)
	mov SYS_stat | SYSCALL_G2RFLAG, %g1	! call sys_stat
@


1.27
log
@Fix comment; no binary change.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.26 2010/05/09 09:34:42 kettenis Exp $	*/
a81 3
 *
 * NB:	We are violating the ELF spec by passing a pointer to the ps strings in
 *	%g1 instead of a termination routine.
a94 1
	mov	%g1, %l1		! save ps_strings
a130 1
	mov	%l1, %g1		! restore ps_strings
d133 1
a133 1
	 nop
@


1.26
log
@Reserve space for 6 extended word argument slots required by the ABI.
Apparently gcc4 uses them in cases where gcc3 didn't.  Fixes segmentation
faults with gcc4 because the space for the slots was colliding with
the space for dl_data that we allocated on the stack.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.25 2010/04/24 18:12:29 kettenis Exp $	*/
d317 1
a317 1
	mov  SYS___sysctl | SYSCALL_G2RFLAG, %g1	! call sys_getdirentries
@


1.25
log
@Fix handling of more than 32768 PLT entries.  Mostly from NetBSD.

eyeballed by deraadt@@ and drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.24 2006/05/03 16:10:52 drahn Exp $	*/
d88 1
a88 1
#define	ARGC	(16*8)
d99 1
a99 1
	sub	%sp, DL_DATA_SIZE, %sp	! make room for dl_data
d134 1
a134 1
	add	%sp, DL_DATA_SIZE, %sp		! restore stack
@


1.24
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.23 2004/05/25 15:56:19 deraadt Exp $	*/
d160 1
a160 1
	 *	i = x - y + 1048596;
d170 1
a170 1
	sethi	%hi(1048596), %l1
d172 2
a173 2
	or	%l1, %lo(1048596), %l1
	add	%l0, %l1, %l0		/* x - y + 1048596 */
d175 2
a176 1
	sdivx	%l0, 5120, %l1		/* Calculate i/5120 */
d178 4
a181 1
	sub	%l0, %l1, %l2		/* And i%5120 */
d184 1
a184 1
	sdivx	%l2, 14, %l4		/* (i%5120)/24 */
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.22 2004/01/10 22:47:54 pvalchev Exp $	*/
d318 8
@


1.22
log
@the sparcv9 ABI requires registers %g2, %g3 to be first announced before
it can use them, and gcc3 catches this
ok henric
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.21 2003/08/12 18:53:44 jason Exp $	*/
d116 1
a116 1
	add	%o2, %o7, %o2           ! real &_DYNAMIC
d283 1
a283 1
	 sub %g0, %o0, %o0                      ! error: result = -errno
d290 1
a290 1
	 sub %g0, %o0, %o0                      ! error: result = -errno
d297 1
a297 1
	 sub %g0, %o0, %o0                      ! error: result = -errno
d317 1
a317 1
	 sub %g0, %o0, %o0                      ! error: result = -errno
@


1.21
log
@use _ENTRY consistently, remove some #if 0 code, and clean up some comments; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.20 2003/07/09 21:01:10 drahn Exp $	*/
d94 1
@


1.20
log
@changes to ld.so to be compatible with newer binutils, requires
slight changes in the startup code on most archs. ok art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.19 2003/06/02 20:20:35 jason Exp $	*/
d75 2
a76 2
 *	On startup the stack should contain 16 extended word register save area,
 *	followed by the arg count, etc.
d80 2
a81 1
 *	&argc + 16 and pass that in.  The return args will be in those locations.
d94 2
a95 3
	.global	_dl_start
	.type	_dl_start,@@function
_dl_start:
d168 1
a168 13
	.section	".text"
	.align	4
	.global	_dl_bind_start_0
	.type	_dl_bind_start_0,@@function
_dl_bind_start_0:	# (x, y)
#if 0
	call	_dl_bind_start_0_stub
	 ldx	[%o1 + (10*4)], %l7
	mov	%o0, %o1

	call	_dl_bind
	 mov	%l7, %o0
#else
a194 1
#endif
d196 1
a196 5
	.section	".text"
	.align	4
	.global	_dl_bind_start_1
	.type	_dl_bind_start_1,@@function
_dl_bind_start_1:	# (x, y)
d207 1
a207 5
	.section ".text"
	.align 4
	.global _dl_close
	.type _dl_close,@@function
_dl_close:
d214 1
a214 6

	.section ".text"
	.align 4
	.global _dl_exit
	.type _dl_exit,@@function
_dl_exit:
d221 1
a221 6

	.section ".text"
	.align 4
	.global _dl_issetugid
	.type _dl_issetugid,@@function
_dl_issetugid:
d228 1
a228 6

	.section ".text"
	.align 4
	.global _dl__syscall
	.type _dl__syscall,@@function
_dl__syscall:
d235 1
a235 6

	.section ".text"
	.align 4
	.global _dl_munmap
	.type _dl_munmap,@@function
_dl_munmap:
d242 1
a242 6

	.section ".text"
	.align 4
	.global _dl_mprotect
	.type _dl_mprotect,@@function
_dl_mprotect:
d249 1
a249 6

	.section ".text"
	.align 4
	.global _dl_open
	.type _dl_open,@@function
_dl_open:
d256 1
a256 6

	.section ".text"
	.align 4
	.global _dl_read
	.type _dl_read,@@function
_dl_read:
d263 1
a263 6

	.section ".text"
	.align 4
	.global _dl_write
	.type _dl_write,@@function
_dl_write:
d270 1
a270 6

	.section ".text"
	.align 4
	.global _dl_stat
	.type _dl_stat,@@function
_dl_stat:
d277 1
a277 6

	.section ".text"
	.align 4
	.globl _dl_fstat
	.type _dl_fstat,@@function
_dl_fstat:
d284 1
a284 6

	.section ".text"
	.align 4
	.globl _dl_fcntl
	.type _dl_fcntl,@@function
_dl_fcntl:
d291 1
a291 6

	.section ".text"
	.align 4
	.globl _dl_getdirentries
	.type _dl_getdirentries,@@function
_dl_getdirentries:
a297 1

d299 1
a299 5
	.section ".text"
	.align 4
	.globl _dl_sigprocmask
	.type _dl_sigprocmask,@@function
_dl_sigprocmask:
d311 1
a311 6

	.section ".text"
	.align 4
	.globl _dl_sysctl
	.type _dl_sysctl,@@function
_dl_sysctl:
@


1.19
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.18 2003/05/30 01:13:53 drahn Exp $	*/
d103 15
a117 1
	call	_dl_boot_bind		! _dl_boot_bind(sp,dl_data)
d130 1
a130 1
	call	_dl_boot		! _dl_boot(argv,envp,loff,dynp,dl_data)
@


1.18
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.17 2003/02/02 16:57:58 deraadt Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.17
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.16 2002/12/18 19:20:02 drahn Exp $	*/
d387 12
@


1.16
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.15 2002/11/23 06:19:26 drahn Exp $	*/
d380 1
a380 1
						! what about errors? 
@


1.15
log
@clean up comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.14 2002/10/21 16:01:55 drahn Exp $	*/
d369 18
@


1.14
log
@Simplify the ld.so asm api, the data is available other ways.
tested by naddy@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.13 2002/08/11 18:41:17 drahn Exp $	*/
d244 3
a246 3
	mov SYS_issetugid | SYSCALL_G2RFLAG, %g1
	add %o7, 8, %g2
	t ST_SYSCALL
d248 1
a248 1
	 sub %g0, %o0, %o0
d256 1
a256 1
	mov SYS___syscall | SYSCALL_G2RFLAG, %g1	! call sys_exit
d268 1
a268 1
	mov SYS_munmap | SYSCALL_G2RFLAG, %g1	! calling sys_mmap
d352 1
a352 1
	mov  SYS_fcntl | SYSCALL_G2RFLAG, %g1	! call sys_fstat
d364 1
a364 1
	mov  SYS_getdirentries | SYSCALL_G2RFLAG, %g1	! call sys_fstat
@


1.13
log
@The parameter dynp was never used, rather than pass in a dummy on most
archs and a nasty calcuation on others, remove the parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.12 2002/07/12 20:18:30 drahn Exp $	*/
a106 1
	mov	0, %o2			! dynp = 0
d108 2
a109 2
	call	_dl_boot_bind		! _dl_boot_bind(sp,loff,dynp,dl_data)
	 mov	%l3, %o3
@


1.12
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.11 2002/05/24 04:17:01 deraadt Exp $	*/
d112 1
a112 1
	mov	%l3, %o4
d119 1
a119 1
	addx	%o4, (7*8), %l2
d123 1
a123 1
	 mov	0, %o3			! dynp = 0
@


1.11
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.10 2002/05/24 03:44:38 deraadt Exp $	*/
d222 1
a222 1
	add %o7, 8, %g2				! just return on sucess
d234 1
a234 1
	add %o7, 8, %g2				! just return on sucess
d254 3
a256 3
	.global _dl___syscall
	.type _dl___syscall,@@function
_dl___syscall:
d258 1
a258 1
	add %o7, 8, %g2				! just return on sucess
d270 1
a270 1
	add %o7, 8, %g2				! just return on sucess
d282 1
a282 1
	add %o7, 8, %g2				! just return on sucess
d294 1
a294 1
	add %o7, 8, %g2				! just return on sucess
d306 1
a306 1
	add %o7, 8, %g2				! just return on sucess
d318 1
a318 1
	add %o7, 8, %g2				! just return on sucess
d330 1
a330 1
	add %o7, 8, %g2				! just return on sucess
d334 36
@


1.10
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.9 2002/03/17 00:22:04 art Exp $	*/
d53 2
a54 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d167 1
a167 1
	 ldx     [%o1 + (10*4)], %l7
@


1.9
log
@Clean up the zapping of bad variables. Instead of implementing
_dl_suid_ok, just use the issetugid syscall.
ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.8 2002/03/15 14:52:39 drahn Exp $	*/
d3 1
a3 1
	
d86 1
a86 1
 * 
d88 1
a88 1
 * 	%g1 instead of a termination routine.
d90 1
a90 1
	
d143 1
a143 1
	 * These routines are called with two longword arguments, 
d159 1
a159 1
	
d169 1
a169 1
	
d181 1
a181 1
	
d193 1
a193 1
	
d199 2
a200 2
#endif	
	
d207 1
a207 1
	
d209 1
a209 1
	
a214 1
	
@


1.8
log
@Add support for binutils 2.11. Work around change in PLT generation new ld
generates. From NetBSD. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.7 2001/09/25 06:57:03 art Exp $	*/
d243 6
a248 18
	.global _dl_getegid
	.type _dl_getegid,@@function
_dl_getegid:
	mov SYS_getegid | SYSCALL_G2RFLAG, %g1	! call sys_exit
	add %o7, 8, %g2				! just return on sucess
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno


	.section ".text"
	.align 4
	.global _dl_geteuid
	.type _dl_geteuid,@@function
_dl_geteuid:
	mov SYS_geteuid | SYSCALL_G2RFLAG, %g1	! call sys_exit
	add %o7, 8, %g2				! just return on sucess
	t ST_SYSCALL				! off to wonderland
d250 1
a250 25
	 sub %g0, %o0, %o0			! error: result = -errno


	.section ".text"
	.align 4
	.global _dl_getgid
	.type _dl_getgid,@@function
_dl_getgid:
	mov SYS_getgid | SYSCALL_G2RFLAG, %g1	! call sys_exit
	add %o7, 8, %g2				! just return on sucess
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno


	.section ".text"
	.align 4
	.global _dl_getuid
	.type _dl_getuid,@@function
_dl_getuid:
	mov SYS_getuid | SYSCALL_G2RFLAG, %g1	! call sys_exit
	add %o7, 8, %g2				! just return on sucess
	t ST_SYSCALL				! off to wonderland
	retl
	 sub %g0, %o0, %o0			! error: result = -errno
@


1.7
log
@Do mmap the right way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.6 2001/09/25 06:34:31 art Exp $	*/
d168 1
a168 5
	mov	%o0, %l5
	
	sllx	%l5, 1, %l6		/* Each element is an Elf_Rela which */
	add	%l6, %l5, %l5		/*  is 3 longwords or 24 bytes. */
	sllx	%l5, 3, %o1		/*  So multiply by 24. */
a193 4
	sllx	%l5, 1, %l6		/* Each element is an Elf_Rela which */
	add	%l6, %l5, %l5		/*  is 3 longwords or 24 bytes. */
	sllx	%l5, 3, %l5		/*  So multiply by 24. */
	
a206 4
	
	sllx	%o2, 1, %o3		/* Each element is an Elf_Rela which */
	add	%o3, %o2, %o2		/*  is 3 longwords or 24 bytes. */
	sllx	%o2, 3, %o2		/*  So multiply by 24. */
@


1.6
log
@Another attempt at getting this right. This time, play safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.5 2001/09/24 23:51:12 art Exp $	*/
d303 4
a306 4
	.global _dl_mmap
	.type _dl_mmap,@@function
_dl_mmap:
	mov SYS_mmap | SYSCALL_G2RFLAG, %g1	! calling sys_mmap
d311 1
@


1.5
log
@Some cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.4 2001/09/24 23:40:56 art Exp $	*/
d93 2
a94 1
#define DL_DATA_SIZE (16*9)
d103 2
a104 2
	sub	%sp, DL_DATA_SIZE, %sp	! make room for return args
	add	%sp, BIAS, %o3
d106 1
a106 1
	add	%o3, DL_DATA_SIZE + ARGC, %l0
d108 3
a110 2
	call	_dl_boot_bind		! _dl_boot(argv,envp,loff,dynp,dl_data)
	 mov	%l0, %o0
d112 1
a117 2

	subx	%l0, DL_DATA_SIZE+ARGC, %o4 ! dl_data = sp
@


1.4
log
@Get the bootstrapping right.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.3 2001/09/24 16:25:00 art Exp $	*/
a111 1

a112 1

d116 1
a116 3
	subx	%l0, ARGC, %o4		! dl_data = sp

	mov	0, %o3			! dynp = 0
d122 1
a122 1
	 nop
d124 1
a124 1
	add	%sp, 16, %sp		! restore stack
@


1.3
log
@dl_data is at the start of the stack, not after env. load loff.
Now _dl_boot starts correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.2 2001/09/23 00:14:56 drahn Exp $	*/
d93 1
d102 2
a103 2
	sub	%sp, 16, %sp		! make room for return args
	add	%sp, BIAS+ARGC, %l0	! l0 points to bottom of stack
d105 6
a110 1
	ldx	[%l0], %l3		! argc
d113 1
a113 1
	addx	%l0, 8, %o0		! argv = [%l0 + 8]
d115 1
a115 1
	addx	%l0, 16, %o1		! envp = %l0 + 16 +
@


1.2
log
@add munmap syscall
change _rtld references to _dl to match C code.
change relocation types in archdep.h to be sparc64 relocs.

rtld_machine.c copied from alpha, with some modes to compile for sparc64

This is in-tree development.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.1 2001/09/21 14:52:45 jason Exp $	*/
d112 1
a112 1
	! XXX loff ???
d114 4
a117 6
	mov	%o1, %o4		! %o3 = my_envp
1:
	ldx	[%o4 + 0], %l2		! while ((*my_envp)
	subxcc	%l2, %g0, %g0		!   != NULL)
	bnz	1b			!	my_envp++;
	 addx	%o4, 8, %o4		! %o4 == dynp
@


1.1
log
@first whack at ldasm.S... this will not work yet (partially based on NetBSD,
partially based on alpha)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 1
a134 1
	 * _rtld_bind_start_0(x, y) is called from .PLT0, and is used for
d137 1
a137 1
	 * _rtld_bind_start_1(x, y) is called from .PLT1, and is used for
d144 1
a144 1
	 * _rtld_bind_start_1(x, y) does:
d148 1
a148 1
	 * and _rtld_bind_start_0(x, y) does:
d157 1
a157 1
	/* NOTE: _rtld_bind_start_0 is untested.  Hence the debug stuff */
d161 3
a163 3
	.global	_rtld_bind_start_0
	.type	_rtld_bind_start_0,@@function
_rtld_bind_start_0:	# (x, y)
d165 1
a165 1
	call	_rtld_bind_start_0_stub
d173 1
a173 1
	call	_rtld_bind
d201 1
a201 1
	call	_rtld_bind		/* Call _rtld_bind(obj, offset) */
d210 3
a212 3
	.global	_rtld_bind_start_1
	.type	_rtld_bind_start_1,@@function
_rtld_bind_start_1:	# (x, y)
d221 1
a221 1
	call	_rtld_bind		/* Call _rtld_bind(obj, offset) */
d306 11
@

