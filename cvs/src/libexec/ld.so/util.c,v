head	1.44;
access;
symbols
	OPENBSD_6_2:1.44.0.6
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.38.0.4
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.10
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.44
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.43;
commitid	veGB6uLWx3BTEAfk;

1.43
date	2016.08.12.20.39.01;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	9Gsc7gGSE2YeEbd8;

1.42
date	2016.08.05.15.42.05;	author tedu;	state Exp;
branches;
next	1.41;
commitid	XzRnVKqcyvxykoqx;

1.41
date	2016.03.21.22.41.28;	author bluhm;	state Exp;
branches;
next	1.40;
commitid	hneUpr7ZOJCeNeHP;

1.40
date	2016.03.21.01.32.48;	author guenther;	state Exp;
branches;
next	1.39;
commitid	7Tp2uEssgeiK9f77;

1.39
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.38;
commitid	Kpc3J4Ry51yjfQid;

1.38
date	2015.01.20.19.51.00;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	PgPcBEiUSoQ60N4U;

1.37
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	31KwZ9PARAKUg1ob;

1.36
date	2014.12.09.15.36.36;	author tedu;	state Exp;
branches;
next	1.35;
commitid	WB7lyZ4tm3T0eTL1;

1.35
date	2014.07.14.03.54.50;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	fsr4AzfIP3TLhLM2;

1.34
date	2014.07.06.07.39.07;	author otto;	state Exp;
branches;
next	1.33;
commitid	XT6OUAXF6kkCorMy;

1.33
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.32;
commitid	vlK4cqSehsiJVTpr;

1.32
date	2014.06.21.08.00.23;	author otto;	state Exp;
branches;
next	1.31;
commitid	wh9FTpEgwThWVeqE;

1.31
date	2014.06.14.20.31.17;	author miod;	state Exp;
branches;
next	1.30;
commitid	sK3sx98EPyrixHN0;

1.30
date	2014.06.05.08.39.07;	author otto;	state Exp;
branches;
next	1.29;
commitid	PovK1yhVqujrpswl;

1.29
date	2014.01.23.01.07.45;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.12.28.18.41.48;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.13.05.41.42;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.09.13.10.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.23.19.01.44;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.28.16.39.09;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2012.08.22.17.06.39;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.07.17.47.06;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.30.15.36.32;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.09.14.51.13;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.14.15.07.36;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.25.23.36.11;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.06.20.03.58;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.02.23.17.36;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.02.16.31.53;	author naddy;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.02.09.00.18;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.24.00.13.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.28.00.22.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.24.18.37.38;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.09.19.59.47;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.44
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: util.c,v 1.43 2016/08/12 20:39:01 deraadt Exp $	*/

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <syslog.h>
#include "archdep.h"
#include "resolve.h"

/*
 * Stack protector dummies.
 * Ideally, a scheme to compile these stubs from libc should be used, but
 * this would end up dragging too much code from libc here.
 */
long __guard_local __dso_hidden __attribute__((section(".openbsd.randomdata")));

void __stack_smash_handler(char [], int);

void
__stack_smash_handler(char func[], int damaged)
{
	char message[256];

	/* <10> indicates LOG_CRIT */
	_dl_strlcpy(message, "<10>ld.so:", sizeof message);
	_dl_strlcat(message, __progname, sizeof message);
	if (_dl_strlen(message) > sizeof(message)/2)
		_dl_strlcpy(message + sizeof(message)/2, "...",
		    sizeof(message) - sizeof(message)/2);
	_dl_strlcat(message, "stack overflow in function ", sizeof message);
	_dl_strlcat(message, func, sizeof message);

	_dl_sendsyslog(message, _dl_strlen(message), LOG_CONS);
	_dl_diedie();
}

char *
_dl_strdup(const char *orig)
{
	char *newstr;
	size_t len;

	len = _dl_strlen(orig)+1;
	newstr = _dl_malloc(len);
	if (newstr != NULL)
		_dl_strlcpy(newstr, orig, len);
	return (newstr);
}

void
_dl_arc4randombuf(void *v, size_t buflen)
{
	static char bytes[256];
	static u_int reserve;
	char *buf = v;
	size_t chunk;

	while (buflen != 0) {
		if (reserve == 0) {
			if (_dl_getentropy(bytes, sizeof(bytes)) != 0)
				_dl_die("no entropy");
			reserve = sizeof(bytes);
		}
		if (buflen > reserve)
			chunk = reserve;
		else
			chunk = buflen;
#if 0
		memcpy(buf, bytes + reserve - chunk, chunk);
		memset(bytes + reserve - chunk, 0, chunk);
#else
		{
			char *d = buf;
			char *s = bytes + reserve - chunk;
			u_int l;
			for (l = chunk; l > 0; l--, s++, d++) {
				*d = *s;
				*s = 0;
			}
		}
#endif
		reserve -= chunk;
		buflen -= chunk;
		buf += chunk;
	}
}

u_int32_t
_dl_arc4random(void)
{
	u_int32_t rnd;
	_dl_arc4randombuf(&rnd, sizeof(rnd));
	return (rnd);
}
@


1.43
log
@the slimmed down random functions inside ld.so are strict clones of the
libc arc4random API, so call them _dl_{arc4random,arcrandombuf}
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2016/08/05 15:42:05 tedu Exp $	*/
d58 1
a58 1
	_dl_exit(127);
d85 1
a85 1
				_dl_exit(8);
@


1.42
log
@use a larger chunk for getentropy() and save some for next time.
coalesces some syscalls instead of one per random number.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2016/03/21 22:41:28 bluhm Exp $	*/
d75 1
a75 1
_dl_randombuf(void *v, size_t buflen)
d113 1
a113 1
_dl_random(void)
d116 1
a116 1
	_dl_randombuf(&rnd, sizeof(rnd));
@


1.41
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2016/03/21 01:32:48 guenther Exp $	*/
d77 2
d83 7
a89 2
		if (buflen > 256)
			chunk = 256;
d92 15
a106 2
		if (_dl_getentropy(buf, chunk) != 0)
			_dl_exit(8);
@


1.40
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2016/03/20 02:29:51 guenther Exp $	*/
d57 1
a57 1
	_dl_sendsyslog2(message, _dl_strlen(message), LOG_CONS);
@


1.39
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2015/01/20 19:51:00 deraadt Exp $	*/
d30 1
d57 1
a57 1
	_dl_sendsyslog(message, _dl_strlen(message));
@


1.38
log
@If _dl_progname exceeds half the syslog buffer, truncate it with "...",
so that the remaining information is more visible
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2015/01/16 16:18:07 deraadt Exp $	*/
d31 1
a44 1
	extern const char *_dl_progname;
d49 1
a49 1
	_dl_strlcat(message, _dl_progname, sizeof message);
@


1.37
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2014/12/09 15:36:36 tedu Exp $	*/
d45 1
a45 1
	char message[100];
d50 3
@


1.36
log
@avoid void arithmetic. from david carlier
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2014/07/14 03:54:50 deraadt Exp $	*/
a29 1
#include <sys/param.h>
@


1.35
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2014/07/06 07:39:07 otto Exp $	*/
d72 1
a72 1
_dl_randombuf(void *buf, size_t buflen)
d74 1
@


1.34
log
@rm unneeded includes; prompted (partly) by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2014/07/06 07:28:36 otto Exp $	*/
d45 10
@


1.33
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2014/06/21 08:00:23 otto Exp $	*/
a30 2
#include <sys/sysctl.h>
#include <string.h>
@


1.32
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2014/06/14 20:31:17 miod Exp $	*/
a65 1
	const int mib[2] = { CTL_KERN, KERN_ARND };
d73 2
a74 1
		_dl_sysctl(mib, 2, buf, &chunk, NULL, 0);
@


1.31
log
@Make _dl_randombuf invoke sysctl KERN_ARND in 256-byte chunks, for this is
(currently) the largest output you can get from it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2014/06/05 08:39:07 otto Exp $	*/
d54 1
a54 1
	int len;
d58 2
a59 1
	_dl_strlcpy(newstr, orig, len);
@


1.30
log
@Move to (slightly stripped) version of libc malloc; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2014/01/23 01:07:45 deraadt Exp $	*/
d66 11
a76 1
	_dl_sysctl(mib, 2, buf, &buflen, NULL, 0);
@


1.29
log
@improve some types
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2013/12/28 18:41:48 deraadt Exp $	*/
a30 1
#include <sys/mman.h>
a49 6
/*
 * Static vars usable after bootstrapping.
 */
static char *_dl_malloc_pool;
static long *_dl_malloc_free;

a60 62


/*
 * The following malloc/free code is a very simplified implementation
 * of a malloc function. However, we do not need to be very complex here
 * because we only free memory when 'dlclose()' is called and we can
 * reuse at least the memory allocated for the object descriptor. We have
 * one dynamic string allocated, the library name and it is likely that
 * we can reuse that one too without a lot of complex collapsing code.
 */
void *
_dl_malloc(size_t need)
{
	long *p, *t, *n, have;

	need = (need + 2*DL_MALLOC_ALIGN - 1) & ~(DL_MALLOC_ALIGN - 1);

	if ((t = _dl_malloc_free) != 0) {	/* Try free list first */
		n = (long *)&_dl_malloc_free;
		while (t && t[-1] < need) {
			n = t;
			t = (long *)*t;
		}
		if (t) {
			*n = *t;
			_dl_memset(t, 0, t[-1] - DL_MALLOC_ALIGN);
			return((void *)t);
		}
	}
	have = _dl_round_page((long)_dl_malloc_pool) - (long)_dl_malloc_pool;
	if (need > have) {
		if (have >= 8 + DL_MALLOC_ALIGN) {
			p = (void *)_dl_malloc_pool;
			p = (void *) ((long)p + DL_MALLOC_ALIGN);
			p[-1] = have;
			_dl_free((void *)p);		/* move to freelist */
		}
		_dl_malloc_pool = (void *)_dl_mmap((void *)0,
		    _dl_round_page(need), PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0);
		if (_dl_malloc_pool == 0 || _dl_mmap_error(_dl_malloc_pool)) {
			_dl_printf("Dynamic loader failure: malloc.\n");
			_dl_exit(7);
		}
	}
	p = (void *)_dl_malloc_pool;
	_dl_malloc_pool += need;
	_dl_memset(p, 0, need);
	p = (void *) ((long)p + DL_MALLOC_ALIGN);
	p[-1] = need;
	return (p);
}

void
_dl_free(void *p)
{
	long *t = (long *)p;

	*t = (long)_dl_malloc_free;
	_dl_malloc_free = p;
}

@


1.28
log
@Do not need __guard anymore
Discussion with miod
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2013/11/13 05:41:42 deraadt Exp $	*/
d138 1
a138 1
unsigned int
d141 1
a141 1
	unsigned int rnd;
@


1.27
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2013/06/09 13:10:19 miod Exp $	*/
a40 1
long __guard[8] __dso_public __attribute__((section(".openbsd.randomdata")));
@


1.26
log
@Constify the mib argument of sysctl().
ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2013/01/23 19:01:44 miod Exp $	*/
d55 2
a56 2
static void *_dl_malloc_pool = 0;
static long *_dl_malloc_free = 0;
d101 1
a101 1
			p = _dl_malloc_pool;
d114 1
a114 1
	p = _dl_malloc_pool;
@


1.25
log
@Cache flush .plt after updating its pointers to .got during the initial
object relocation, if loaded at a different address than the one it was
compiled for; unsurprisingly fixes some spurious crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2012/08/28 16:39:09 matthew Exp $	*/
d135 1
a135 1
	int mib[2] = { CTL_KERN, KERN_ARND };
@


1.24
log
@Add __guard_local as a hidden symbol to ld.so, kernel, and every
executable and DSO (via crtbegin.c/crtbeginS.c).  Not used yet, but
needed before GCC can start emitting -fstack-protector code that uses
them instead of __guard.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2012/08/22 17:06:39 matthew Exp $	*/
d77 1
a77 1
 * we can reuse that one to without a lot of complex colapsing code.
@


1.23
log
@Change ld.so and libc to use .openbsd.randomdata on ELF platforms for
initializing their __guard values.  For the time being, we're leaving
libc's constructor method as a backup to make sure __guard actually
gets initialized and to emit syslog warnings when it's not.

Not really an ABI change, so no shlib bump... "hold on to your butts"

ok deraadt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2012/08/07 17:47:06 matthew Exp $	*/
d41 2
a42 1
long __guard[8] __attribute__((section(".openbsd.randomdata")));
@


1.22
log
@Factor out a _dl_randombuf() method from _dl_random().
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2010/10/30 15:36:32 deraadt Exp $	*/
d41 1
a41 1
long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};
@


1.21
log
@fix a 10 year old bug in the memory allocator, which affected only sparc.
sparc has 4 byte long, but needs 8 byte alignment.  recently the DIR
struct was changed to contain some off_t, which needs 8 byte alignment.
turns out the allocator calculated the bias for alignment, and then
subtracted out it's private linkage storage afterwards.  on hppa this
worked because a 8-byte object can be loaded at a 4-byte boundary; on
all other architectures the situation was either 4/4 or 8/8.
thanks for a bit of help from drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2008/10/02 20:12:08 kurt Exp $	*/
d131 7
a140 1
	int mib[2];
d142 1
a142 7
	size_t len;

	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;
	len = sizeof(rnd);
	_dl_sysctl(mib, 2, &rnd, &len, NULL, 0);

a144 2


@


1.20
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2007/02/09 14:51:13 drahn Exp $	*/
d83 1
a83 1
	need = (need + 8 + DL_MALLOC_ALIGN - 1) & ~(DL_MALLOC_ALIGN - 1);
d93 1
a93 1
			_dl_memset(t, 0, t[-1] - sizeof(long));
d101 3
a103 2
			*p = have;
			_dl_free((void *)(p + 1));	/* move to freelist */
d116 3
a118 2
	*p = need;
	return((void *)(p + 1));
@


1.19
log
@readdir buffers should not get a fixed buffer size, but should be dependant
on the block size of the filesystem. Rounded up to page size for efficiency.
similar to change in libc yesterday. Should fix PR 5364.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2004/06/14 15:07:36 millert Exp $	*/
d107 1
a107 1
		if (_dl_malloc_pool == 0 || _dl_malloc_pool == MAP_FAILED ) {
@


1.18
log
@Make _dl_malloc() deal with allocations > 4096 correctly.  Also place
unused memory chunks on the free list when making a large allocation.
OK drahn@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2004/02/25 23:36:11 drahn Exp $	*/
a68 1
#define	_dl_round_page(x)	(((x) + (__LDPGSZ - 1)) & ~(__LDPGSZ - 1))
@


1.17
log
@Fix this assumed sizeof(long) == 4 error. Would very occasionally cause
the code to attempt to zero 4 bytes of the next page.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2003/07/06 20:03:58 deraadt Exp $	*/
a53 1
static void *_dl_malloc_base;
d69 2
d80 1
a80 1
_dl_malloc(size_t size)
d82 1
a82 1
	long *p, *t, *n;
d84 1
a84 1
	size = (size + 8 + DL_MALLOC_ALIGN - 1) & ~(DL_MALLOC_ALIGN - 1);
d88 1
a88 1
		while (t && t[-1] < size) {
d98 10
a107 4
	if (_dl_malloc_pool == 0 ||
	    _dl_malloc_pool + size > _dl_malloc_base + 4096) {
		_dl_malloc_pool = (void *)_dl_mmap((void *)0, 4096,
		    PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
a111 1
		_dl_malloc_base = _dl_malloc_pool;
d114 3
a116 3
	_dl_malloc_pool += size;
	_dl_memset(p, 0, size);
	*p = size;
@


1.16
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2003/06/09 16:10:03 deraadt Exp $	*/
d93 1
a93 1
			_dl_memset(t, 0, t[-1] - 4);
@


1.15
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2003/05/30 01:13:53 drahn Exp $	*/
d43 2
d125 1
a125 1
_dl_random(void)   
@


1.14
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2003/02/02 16:57:58 deraadt Exp $	*/
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2002/12/02 23:17:36 deraadt Exp $	*/
d36 1
d38 1
d126 18
@


1.12
log
@KNF; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2002/12/02 16:31:53 naddy Exp $	*/
d46 1
d73 6
a78 6
 *  The following malloc/free code is a very simplified implementation
 *  of a malloc function. However, we do not need to be very complex here
 *  because we only free memory when 'dlclose()' is called and we can
 *  reuse at least the memory allocated for the object descriptor. We have
 *  one dynamic string allocated, the library name and it is likely that
 *  we can reuse that one to without a lot of complex colapsing code.
a79 1

@


1.11
log
@typo; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2002/12/02 09:00:18 miod Exp $	*/
d45 1
a45 1
long __guard[8] = {0,0,0,0,0,0,0,0};
@


1.10
log
@Import propolice (http://www.trl.ibm.com/projects/security/ssp), a stack
attack protection scheme, into gcc.

This protection is enabled by default. It can be turned off by using the
-fno-stack-protector flag.

Code by Hiroaki Etoh (etoh at jp dot ibm dot com); work on openbsd-specific
integration by fgsch@@, deraadt@@ and myself; tests by fgsch@@, naddy@@ and
myself; beer drinking by myself.

Please note that system upgrades with this new code will require a new
libc and ld.so to be build and installed before the propolice-enabled
compiler can be installed.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2002/07/24 04:11:10 deraadt Exp $	*/
d47 1
a47 1
stack_smash_handler(char func[], int damaged)
@


1.9
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2002/07/24 00:13:55 deraadt Exp $	*/
d39 12
@


1.8
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2002/07/07 08:54:50 jufi Exp $	*/
d69 1
a69 1
_dl_malloc(int size)
@


1.7
log
@make more _dl_*() func params like real ones in libc
@
text
@d69 1
a69 1
_dl_malloc(size_t size)
@


1.6
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2002/05/28 00:22:01 deraadt Exp $	*/
d69 1
a69 1
_dl_malloc(int size)
@


1.5
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2002/05/24 18:37:38 drahn Exp $	*/
d41 1
a41 1
 * Static vars usable after bootsrapping.
@


1.4
log
@Change _dl_strcpy() to _dl_strlcpy(), implementation taken from libc.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2002/05/24 03:44:37 deraadt Exp $	*/
d52 1
d71 1
a71 2
	long *p;
	long *t, *n;
@


1.3
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2002/04/09 19:59:47 drahn Exp $	*/
d51 4
a54 2
	newstr = _dl_malloc(_dl_strlen(orig)+1);
	_dl_strcpy(newstr, orig);
@


1.2
log
@Add the Copyrights from the respective files the code came from. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.1 2002/02/21 23:17:53 drahn Exp $	*/
d5 1
a5 1
 * 
d85 2
a86 2
	if ((_dl_malloc_pool == 0) ||
	    (_dl_malloc_pool + size > _dl_malloc_base + 4096)) {
d88 1
a88 2
						PROT_READ|PROT_WRITE,
						MAP_ANON|MAP_PRIVATE, -1, 0);
@


1.1
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 33
a33 1
/*	$OpenBSD: strdup.c,v 1.4 2001/06/08 06:49:19 art Exp $	*/
@

