head	1.96;
access;
symbols
	OPENBSD_6_1:1.96.0.4
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.95.0.2
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.90.0.6
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.89.0.6
	OPENBSD_5_6_BASE:1.89
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.88.0.2
	OPENBSD_5_4_BASE:1.88
	OPENBSD_5_3:1.87.0.2
	OPENBSD_5_3_BASE:1.87
	OPENBSD_5_2:1.86.0.2
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.2
	OPENBSD_5_0:1.84.0.2
	OPENBSD_5_0_BASE:1.84
	OPENBSD_4_9:1.82.0.4
	OPENBSD_4_9_BASE:1.82
	OPENBSD_4_8:1.82.0.2
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.80.0.6
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.80.0.8
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.4
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.80.0.2
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.77.0.2
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.73.0.4
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.71.0.2
	OPENBSD_3_9_BASE:1.71
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	r20000612:1.1.1.2
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.96
date	2017.01.23.13.00.09;	author guenther;	state Exp;
branches;
next	1.95;
commitid	HAR0DSiIm2Be6qd4;

1.95
date	2016.03.21.01.52.45;	author guenther;	state Exp;
branches;
next	1.94;
commitid	wG7PPtfGd1wknOcX;

1.94
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.93;
commitid	Kpc3J4Ry51yjfQid;

1.93
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.92;
commitid	JEVxsRygqcjPtWTf;

1.92
date	2015.12.22.08.54.16;	author mmcc;	state Exp;
branches;
next	1.91;
commitid	sTDrw9FlbNNwVprE;

1.91
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.90;
commitid	FcRQ6g8MqXiORdFs;

1.90
date	2015.01.22.05.48.17;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	GZoxg3rKKQGZ5hZT;

1.89
date	2013.11.13.05.41.41;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.24.01.37.23;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.31.19.44.03;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2012.06.12.20.32.16;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.27.16.47.50;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2011.05.22.22.43.47;	author drahn;	state Exp;
branches;
next	1.82;

1.82
date	2010.07.01.19.25.44;	author drahn;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.13.23.14.47;	author kurt;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.27.18.56.32;	author kurt;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.29.04.47.17;	author jason;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.03.14.33.07;	author jason;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.08.20.34.36;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.03.15.44.56;	author drahn;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.09.16.32.12;	author kurt;	state Exp;
branches;
next	1.70;

1.70
date	2005.10.18.02.49.17;	author drahn;	state Exp;
branches;
next	1.69;

1.69
date	2005.10.16.04.14.22;	author kurt;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.67;

1.67
date	2005.10.10.16.33.51;	author kurt;	state Exp;
branches;
next	1.66;

1.66
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.65;

1.65
date	2005.10.07.01.26.33;	author kurt;	state Exp;
branches;
next	1.64;

1.64
date	2005.10.06.22.01.58;	author kurt;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.06.21.53.09;	author kurt;	state Exp;
branches;
next	1.62;

1.62
date	2005.10.05.21.50.53;	author kurt;	state Exp;
branches;
next	1.61;

1.61
date	2005.10.03.21.01.37;	author kurt;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.03.20.17.26;	author kurt;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.01.19.32.22;	author drahn;	state Exp;
branches;
next	1.57;

1.57
date	2005.09.28.20.35.23;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.28.15.41.06;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.28.15.24.22;	author kurt;	state Exp;
branches;
next	1.54;

1.54
date	2005.09.22.22.33.40;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2005.09.21.20.32.19;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2005.09.19.03.16.47;	author kurt;	state Exp;
branches;
next	1.51;

1.51
date	2005.09.17.03.02.37;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.13.03.32.15;	author drahn;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.23.19.22.11;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.08.20.01.59;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.07.20.50.11;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.01.22.27.35;	author kurt;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.14.10.02.28;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.13.16.45.41;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.11.19.14.56;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.07.15.18.19;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.07.15.00.38;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.22.19.42.52;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.01.02.55.23;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.25.21.56.20;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.04.19.33.48;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.26.07.53.27;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.28.22.51.25;	author marc;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.23.04.09.34;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.04.03.01.42;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.31.04.58.25;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.28.00.23.57;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.17.04.50.57;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.07.00.54.09;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.15.32.11;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.29.03.18.59;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.15.20.44.52;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.09.02.42.12;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.06.12.45.17;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.06.12.31.52;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.06.12.26.05;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.02.23.11.20;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.17.17.50.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.33.58;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.33.58;	author rahnds;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.06.13.03.39.56;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.96
log
@Mark a bunch of stuff static

ok kettenis@@
@
text
@/*	$OpenBSD: dlfcn.c,v 1.95 2016/03/21 01:52:45 guenther Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <nlist.h>
#include <link.h>
#include <dlfcn.h>
#include <unistd.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"
#include "sod.h"

int _dl_errno;
static int _dl_tracelib;

static int _dl_real_close(void *handle);
static void (*_dl_thread_fnc)(int) = NULL;
static elf_object_t *obj_from_addr(const void *addr);

void *
dlopen(const char *libname, int flags)
{
	elf_object_t *object;
	int failed = 0;
	int obj_flags;

	if (flags & ~(RTLD_TRACE|RTLD_LAZY|RTLD_NOW|RTLD_GLOBAL)) {
		_dl_errno = DL_INVALID_MODE;
		return NULL;
	}

	if (libname == NULL)
		return RTLD_DEFAULT;

	if ((flags & RTLD_TRACE) == RTLD_TRACE) {
		_dl_traceld = "true";
		_dl_tracelib = 1;
	}

	DL_DEB(("dlopen: loading: %s\n", libname));

	_dl_thread_kern_stop();

	if (_dl_debug_map && _dl_debug_map->r_brk) {
		_dl_debug_map->r_state = RT_ADD;
		(*((void (*)(void))_dl_debug_map->r_brk))();
	}

	_dl_loading_object = NULL;

	obj_flags = (flags & RTLD_NOW ? DF_1_NOW : 0)
	    | (flags & RTLD_GLOBAL ? DF_1_GLOBAL : 0);
	object = _dl_load_shlib(libname, _dl_objects, OBJTYPE_DLO, obj_flags);
	if (object == 0) {
		DL_DEB(("dlopen: failed to open %s\n", libname));
		failed = 1;
		goto loaded;
	}

	_dl_link_dlopen(object);

	if (OBJECT_REF_CNT(object) > 1) {
		/* if opened but grpsym_list has not been created */
		if (OBJECT_DLREF_CNT(object) == 1) {
			/* add first object manually */
			_dl_link_grpsym(object, 1);
			_dl_cache_grpsym_list(object);
		}
		goto loaded;
	}

	/* this add_object should not be here, XXX */
	_dl_add_object(object);

	DL_DEB(("head [%s]\n", object->load_name ));

	if ((failed = _dl_load_dep_libs(object, obj_flags, 0)) == 1) {
		_dl_real_close(object);
		object = NULL;
		_dl_errno = DL_CANT_LOAD_OBJ;
	} else {
		int err;
		DL_DEB(("tail %s\n", object->load_name ));
		if (_dl_traceld) {
			_dl_show_objects();
			_dl_unload_shlib(object);
			_dl_exit(0);
		}
		err = _dl_rtld(object);
		if (err != 0) {
			_dl_real_close(object);
			_dl_errno = DL_CANT_LOAD_OBJ;
			object = NULL;
			failed = 1;
		} else {
			_dl_call_init(object);
		}
	}

loaded:
	_dl_loading_object = NULL;

	if (_dl_debug_map && _dl_debug_map->r_brk) {
		_dl_debug_map->r_state = RT_CONSISTENT;
		(*((void (*)(void))_dl_debug_map->r_brk))();
	}

	_dl_thread_kern_go();

	DL_DEB(("dlopen: %s: done (%s).\n", libname,
	    failed ? "failed" : "success"));

	return((void *)object);
}

void *
dlsym(void *handle, const char *name)
{
	elf_object_t	*object;
	elf_object_t	*dynobj;
	const elf_object_t	*pobj;
	char		*retval;
	const Elf_Sym	*sym = NULL;
	int flags;

	if (handle == NULL || handle == RTLD_NEXT ||
	    handle == RTLD_SELF || handle == RTLD_DEFAULT) {
		void *retaddr;

		retaddr = __builtin_return_address(0);	/* __GNUC__ only */

		if ((object = obj_from_addr(retaddr)) == NULL) {
			_dl_errno = DL_CANT_FIND_OBJ;
			return(0);
		}

		if (handle == RTLD_NEXT)
			flags = SYM_SEARCH_NEXT|SYM_PLT;
		else if (handle == RTLD_SELF)
			flags = SYM_SEARCH_SELF|SYM_PLT;
		else if (handle == RTLD_DEFAULT)
			flags = SYM_SEARCH_ALL|SYM_PLT;
		else
			flags = SYM_DLSYM|SYM_PLT;

	} else {
		object = (elf_object_t *)handle;
		flags = SYM_DLSYM|SYM_PLT;

		dynobj = _dl_objects;
		while (dynobj && dynobj != object)
			dynobj = dynobj->next;

		if (!dynobj || object != dynobj) {
			_dl_errno = DL_INVALID_HANDLE;
			return(0);
		}
	}

	retval = (void *)_dl_find_symbol(name, &sym,
	    flags|SYM_NOWARNNOTFOUND, NULL, object, &pobj);

	if (sym != NULL) {
		retval += sym->st_value;
#ifdef __hppa__
		if (ELF_ST_TYPE(sym->st_info) == STT_FUNC)
			retval = (void *)_dl_md_plabel((Elf_Addr)retval,
			    pobj->dyn.pltgot);
#endif
		DL_DEB(("dlsym: %s in %s: %p\n",
		    name, object->load_name, retval));
	} else
		_dl_errno = DL_NO_SYMBOL;
	return (retval);
}

int
dlctl(void *handle, int command, void *data)
{
	int retval;

	switch (command) {
	case DL_SETTHREADLCK:
		DL_DEB(("dlctl: _dl_thread_fnc set to %p\n", data));
		_dl_thread_fnc = data;
		retval = 0;
		break;
	case DL_SETBINDLCK:
		/* made superfluous by kbind */
		retval = 0;
		break;
	case 0x20:
		_dl_show_objects();
		retval = 0;
		break;
	case 0x21:
	{
		struct dep_node *n, *m;
		elf_object_t *obj;
		_dl_printf("Load Groups:\n");

		TAILQ_FOREACH(n, &_dlopened_child_list, next_sib) {
			obj = n->data;
			_dl_printf("%s\n", obj->load_name);

			_dl_printf("  children\n");
			TAILQ_FOREACH(m, &obj->child_list, next_sib)
				_dl_printf("\t[%s]\n", m->data->load_name);

			_dl_printf("  grpref\n");
			TAILQ_FOREACH(m, &obj->grpref_list, next_sib)
				_dl_printf("\t[%s]\n", m->data->load_name);
			_dl_printf("\n");
		}
		retval = 0;
		break;
	}
	default:
		_dl_errno = DL_INVALID_CTL;
		retval = -1;
		break;
	}
	return (retval);
}
__strong_alias(_dlctl,dlctl);

int
dlclose(void *handle)
{
	int retval;

	if (handle == RTLD_DEFAULT)
		return 0;

	_dl_thread_kern_stop();

	if (_dl_debug_map && _dl_debug_map->r_brk) {
		_dl_debug_map->r_state = RT_DELETE;
		(*((void (*)(void))_dl_debug_map->r_brk))();
	}

	retval = _dl_real_close(handle);

	if (_dl_debug_map && _dl_debug_map->r_brk) {
		_dl_debug_map->r_state = RT_CONSISTENT;
		(*((void (*)(void))_dl_debug_map->r_brk))();
	}
	_dl_thread_kern_go();
	return (retval);
}

int
_dl_real_close(void *handle)
{
	elf_object_t	*object;
	elf_object_t	*dynobj;

	object = (elf_object_t *)handle;

	dynobj = _dl_objects;
	while (dynobj && dynobj != object)
		dynobj = dynobj->next;

	if (!dynobj || object != dynobj) {
		_dl_errno = DL_INVALID_HANDLE;
		return (1);
	}

	if (object->opencount == 0) {
		_dl_errno = DL_INVALID_HANDLE;
		return (1);
	}

	object->opencount--;
	_dl_notify_unload_shlib(object);
	_dl_run_all_dtors();
	_dl_unload_shlib(object);
	_dl_cleanup_objects();
	return (0);
}


/*
 * Return a character string describing the last dl... error occurred.
 */
char *
dlerror(void)
{
	char *errmsg;

	switch (_dl_errno) {
	case 0:	/* NO ERROR */
		errmsg = NULL;
		break;
	case DL_NOT_FOUND:
		errmsg = "File not found";
		break;
	case DL_CANT_OPEN:
		errmsg = "Can't open file";
		break;
	case DL_NOT_ELF:
		errmsg = "File not an ELF object";
		break;
	case DL_CANT_OPEN_REF:
		errmsg = "Can't open referenced object";
		break;
	case DL_CANT_MMAP:
		errmsg = "Can't map ELF object";
		break;
	case DL_INVALID_HANDLE:
		errmsg = "Invalid handle";
		break;
	case DL_NO_SYMBOL:
		errmsg = "Unable to resolve symbol";
		break;
	case DL_INVALID_CTL:
		errmsg = "Invalid dlctl() command";
		break;
	case DL_NO_OBJECT:
		errmsg = "No shared object contains address";
		break;
	case DL_CANT_FIND_OBJ:
		errmsg = "Cannot determine caller's shared object";
		break;
	case DL_CANT_LOAD_OBJ:
		errmsg = "Cannot load specified object";
		break;
	case DL_INVALID_MODE:
		errmsg = "Invalid mode";
		break;
	default:
		errmsg = "Unknown error";
	}

	_dl_errno = 0;
	return (errmsg);
}

static void
_dl_tracefmt(int fd, elf_object_t *object, const char *fmt1, const char *fmt2,
    const char *objtypename)
{
	const char *fmt;
	int i;

	fmt = object->sod.sod_library ? fmt1 : fmt2;

	for (i = 0; fmt[i]; i++) {
		if (fmt[i] != '%' && fmt[i] != '\\') {
			_dl_fdprintf(fd, "%c", fmt[i]);
			continue;
		}
		if (fmt[i] == '%') {
			i++;
			switch (fmt[i]) {
			case '\0':
				return;
			case '%':
				_dl_fdprintf(fd, "%c", '%');
				break;
			case 'A':
				_dl_fdprintf(fd, "%s", _dl_traceprog ?
				    _dl_traceprog : "");
				break;
			case 'a':
				_dl_fdprintf(fd, "%s", __progname);
				break;
			case 'e':
				_dl_fdprintf(fd, "%lX",
				    (void *)(object->load_base +
				    object->load_size));
				break;
			case 'g':
				_dl_fdprintf(fd, "%d", object->grprefcount);
				break;
			case 'm':
				_dl_fdprintf(fd, "%d", object->sod.sod_major);
				break;
			case 'n':
				_dl_fdprintf(fd, "%d", object->sod.sod_minor);
				break;
			case 'O':
				_dl_fdprintf(fd, "%d", object->opencount);
				break;
			case 'o':
				_dl_fdprintf(fd, "%s", object->sod.sod_name);
				break;
			case 'p':
				_dl_fdprintf(fd, "%s", object->load_name);
				break;
			case 'r':
				_dl_fdprintf(fd, "%d", object->refcount);
				break;
			case 't':
				_dl_fdprintf(fd, "%s", objtypename);
				break;
			case 'x':
				_dl_fdprintf(fd, "%lX", object->load_base);
				break;
			}
		}
		if (fmt[i] == '\\') {
			i++;
			switch (fmt[i]) {
			case '\0':
				return;
			case 'n':
				_dl_fdprintf(fd, "%c", '\n');
				break;
			case 'r':
				_dl_fdprintf(fd, "%c", '\r');
				break;
			case 't':
				_dl_fdprintf(fd, "%c", '\t');
				break;
			default:
				_dl_fdprintf(fd, "%c", fmt[i]);
				break;
			}
		}
	}
}

void
_dl_show_objects(void)
{
	elf_object_t *object;
	char *objtypename;
	int outputfd;
	char *pad;
	const char *fmt1, *fmt2;

	object = _dl_objects;
	if (_dl_traceld)
		outputfd = STDOUT_FILENO;
	else
		outputfd = STDERR_FILENO;

	if (sizeof(long) == 8)
		pad = "        ";
	else
		pad = "";

	fmt1 = _dl_tracefmt1 ? _dl_tracefmt1 :
	    "\t%x %e %t %O    %r   %g      %p\n";
	fmt2 = _dl_tracefmt2 ? _dl_tracefmt2 :
	    "\t%x %e %t %O    %r   %g      %p\n";

	if (_dl_tracefmt1 == NULL && _dl_tracefmt2 == NULL)
		_dl_fdprintf(outputfd, "\tStart   %s End     %s Type Open Ref GrpRef Name\n",
		    pad, pad);

	if (_dl_tracelib) {
		for (; object != NULL; object = object->next)
			if (object->obj_type == OBJTYPE_LDR) {
				object = object->next;
				break;
			}
	}

	for (; object != NULL; object = object->next) {
		switch (object->obj_type) {
		case OBJTYPE_LDR:
			objtypename = "rtld";
			break;
		case OBJTYPE_EXE:
			objtypename = "exe ";
			break;
		case OBJTYPE_LIB:
			objtypename = "rlib";
			break;
		case OBJTYPE_DLO:
			objtypename = "dlib";
			break;
		default:
			objtypename = "????";
			break;
		}
		_dl_tracefmt(outputfd, object, fmt1, fmt2, objtypename);
	}

	if (_dl_symcachestat_lookups != 0)
		DL_DEB(("symcache lookups %d hits %d ratio %d% hits\n",
		    _dl_symcachestat_lookups, _dl_symcachestat_hits,
		    (_dl_symcachestat_hits * 100) /
		    _dl_symcachestat_lookups));
}

void
_dl_thread_kern_stop(void)
{
	if (_dl_thread_fnc != NULL)
		(*_dl_thread_fnc)(0);
}

void
_dl_thread_kern_go(void)
{
	if (_dl_thread_fnc != NULL)
		(*_dl_thread_fnc)(1);
}

int
dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *data),
	void *data)
{
	elf_object_t *object;
	struct dl_phdr_info info;
	int retval = -1;

	for (object = _dl_objects; object != NULL; object = object->next) {
		if (object->phdrp == NULL)
			continue;

		info.dlpi_addr = object->obj_base;
		info.dlpi_name = object->load_name;
		info.dlpi_phdr = object->phdrp;
		info.dlpi_phnum = object->phdrc;
		retval = callback(&info, sizeof (struct dl_phdr_info), data);
		if (retval)
			break;
	}

	return retval;
}

static elf_object_t *
obj_from_addr(const void *addr)
{
	elf_object_t *dynobj;
	Elf_Phdr *phdrp;
	int phdrc;
	Elf_Addr start;
	int i;

	for (dynobj = _dl_objects; dynobj != NULL; dynobj = dynobj->next) {
		if (dynobj->phdrp == NULL)
			continue;

		phdrp = dynobj->phdrp;
		phdrc = dynobj->phdrc;

		for (i = 0; i < phdrc; i++, phdrp++) {
			if (phdrp->p_type == PT_LOAD) {
				start = dynobj->obj_base + phdrp->p_vaddr;
				if ((Elf_Addr)addr >= start &&
				    (Elf_Addr)addr < start + phdrp->p_memsz)
					return dynobj;
			}
		}
	}

	return NULL;
}

int
dladdr(const void *addr, Dl_info *info)
{
	const elf_object_t *object;
	const Elf_Sym *sym;
	void *symbol_addr;
	u_int32_t symoffset;

	object = obj_from_addr(addr);

	if (object == NULL) {
		_dl_errno = DL_NO_OBJECT;
		return 0;
	}

	info->dli_fname = (char *)object->load_name;
	info->dli_fbase = (void *)object->load_base;
	info->dli_sname = NULL;
	info->dli_saddr = NULL;

	/*
	 * Walk the symbol list looking for the symbol whose address is
	 * closest to the address sent in.
	 */
	for (symoffset = 0; symoffset < object->nchains; symoffset++) {
		sym = object->dyn.symtab + symoffset;

		/*
		 * For skip the symbol if st_shndx is either SHN_UNDEF or
		 * SHN_COMMON.
		 */
		if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)
			continue;

		/*
		 * If the symbol is greater than the specified address, or if
		 * it is further away from addr than the current nearest
		 * symbol, then reject it.
		 */
		symbol_addr = (void *)(object->obj_base + sym->st_value);
		if (symbol_addr > addr || symbol_addr < info->dli_saddr)
			continue;

		/* Update our idea of the nearest symbol. */
		info->dli_sname = object->dyn.strtab + sym->st_name;
		info->dli_saddr = symbol_addr;

		/* Exact match? */
		if (info->dli_saddr == addr)
			break;
	}

	return 1;
}
@


1.95
log
@Provide _dlctl(), an alternate name for dlctl() that's in the reserved
namespace, for use by libpthread

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.94 2016/03/20 02:29:51 guenther Exp $ */
d43 1
a43 1
int _dl_tracelib;
d45 2
a46 2
int _dl_real_close(void *handle);
void (*_dl_thread_fnc)(int) = NULL;
@


1.94
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.93 2016/03/16 15:41:10 krw Exp $ */
d254 1
@


1.93
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.92 2015/12/22 08:54:16 mmcc Exp $ */
d394 1
a394 1
				_dl_fdprintf(fd, "%s", _dl_progname);
@


1.92
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.91 2015/09/19 20:56:47 guenther Exp $ */
d602 1
a602 1
	info->dli_saddr = (void *)0;
@


1.91
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.90 2015/01/22 05:48:17 deraadt Exp $ */
d122 1
a122 1
			object = 0;
@


1.90
log
@delete annoying white space that annoy
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.89 2013/11/13 05:41:41 deraadt Exp $ */
a46 1
void (*_dl_bind_lock_f)(int) = NULL;
d218 1
a218 2
		DL_DEB(("dlctl: _dl_bind_lock_f set to %p\n", data));
		_dl_bind_lock_f = data;
a514 15
}

void
_dl_thread_bind_lock(int what, sigset_t *omask)
{
	if (! what) {
		sigset_t nmask;

		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, omask);
	}
	if (_dl_bind_lock_f != NULL)
		(*_dl_bind_lock_f)(what);
	if (what)
		_dl_sigprocmask(SIG_SETMASK, omask, NULL);
@


1.89
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.88 2013/03/24 01:37:23 deraadt Exp $ */
d152 1
a152 1
	char 		*retval;
d377 1
a377 1
	
@


1.88
log
@dlerror() should not return const char *, as noted by landry
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.87 2012/08/31 19:44:03 kettenis Exp $ */
d152 1
a152 1
	void		*retval;
d369 1
a369 1
void
@


1.87
log
@Since _dl_debug_map is only initialized if we see a DT_DEBUG tag, make sure
it isn't NULL before we dereference it.

Fixes perl PIE on hppa.

ok matthew@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.86 2012/06/12 20:32:16 matthew Exp $ */
d316 1
a316 1
const char *
d319 1
a319 1
	const char *errmsg;
@


1.86
log
@Fix loaded object sod matching: when we load libfoo.so.X.Y into
memory, we should be able to match other requests for libfoo.so.X.Z
against that same object.

ok kurt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.85 2011/11/28 20:59:03 guenther Exp $ */
d74 1
a74 1
	if (_dl_debug_map->r_brk) {
d133 1
a133 1
	if (_dl_debug_map->r_brk) {
d267 1
a267 1
	if (_dl_debug_map->r_brk) {
d274 1
a274 2

	if (_dl_debug_map->r_brk) {
@


1.85
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.84 2011/06/27 16:47:50 sthen Exp $ */
a374 1
	struct sod sd;
a375 1
	char *s;
d377 1
a377 7
	s = _dl_strrchr(object->load_name, '/');
	if (s != NULL)
		s++;
	else
		s = object->load_name;
	_dl_build_sod(s, &sd);
	fmt = sd.sod_library ? fmt1 : fmt2;
d408 1
a408 1
				_dl_fdprintf(fd, "%d", sd.sod_major);
d411 1
a411 1
				_dl_fdprintf(fd, "%d", sd.sod_minor);
d417 1
a417 1
				_dl_fdprintf(fd, "%s", sd.sod_name);
a452 1
	_dl_free((void *)sd.sod_name);
@


1.84
log
@Backout the dynamic linker speed improvement diff for now, it still
has some issues. Discussed with various, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.82 2010/07/01 19:25:44 drahn Exp $ */
d55 6
d81 3
a83 1
	object = _dl_load_shlib(libname, _dl_objects, OBJTYPE_DLO, flags);
d107 1
a107 1
	if ((failed = _dl_load_dep_libs(object, flags, 0)) == 1) {
d358 3
@


1.83
log
@Dynamic linker speed improvement diff. tested by several sinc k2k11.
get it in tree now deraadt@@, ok by several ports folks. Thanks for the testing.
@
text
@a110 1
		_dl_search_list_valid = 0;
a265 1
	_dl_search_list_valid = 0;
@


1.82
log
@When generating grpsym lists, avoid duplicates without searching the
already generated list. Speeds up startup on deeply nested dlopen binaries.
ok guenther@@, tested by ckuethe@@ and ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.81 2010/05/02 04:57:01 guenther Exp $ */
d111 1
d267 1
@


1.81
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.80 2008/06/13 23:14:47 kurt Exp $ */
d88 1
a88 1
			_dl_link_grpsym(object);
@


1.80
log
@Completing the executable elf_object_t data exposed a bug in
dl_iterate_phdr(3) which was returning the load base not the
object base. Problem noted in the misc/exceptions regress by
David Krause. okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.79 2008/05/05 02:29:02 kurt Exp $ */
d519 1
a519 1
_dl_thread_bind_lock(int what)
d521 6
d529 2
@


1.79
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.78 2008/04/09 21:45:26 kurt Exp $ */
d551 1
a551 1
		info.dlpi_addr = object->load_base;
@


1.78
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.77 2007/11/27 18:56:32 kurt Exp $ */
a543 1
	Elf_Ehdr *ehdr;
d548 1
a548 2
		ehdr = (Elf_Ehdr *)object->load_base;
		if (object->phdrp == NULL && ehdr == NULL)
a554 5
		if (info.dlpi_phdr == NULL) {
		    info.dlpi_phdr = (Elf_Phdr *)
			((char *)object->load_base + ehdr->e_phoff);
		    info.dlpi_phnum = ehdr->e_phnum;
		}
d567 1
a567 2
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdr;
d573 1
a573 8
		if (dynobj->load_base != NULL) {
			ehdr = (Elf_Ehdr *)dynobj->load_base;
			phdr = (Elf_Phdr *)((char *)dynobj->load_base + ehdr->e_phoff);
			phdrc = ehdr->e_phnum;
		} else if (dynobj->phdrp != NULL) {
			phdr = dynobj->phdrp;
			phdrc = dynobj->phdrc;
		} else
d576 6
a581 4
		for (i = 0; i < phdrc; i++) {
			switch (phdr[i].p_type) {
			case PT_LOAD:
				start = dynobj->obj_base + phdr[i].p_vaddr;
d583 1
a583 1
				    (Elf_Addr)addr < start + phdr[i].p_memsz)
a584 3
				break;
			default:
				break;
@


1.77
log
@Fix dlsym w/special handles when called from an executable that has been
linked without -E. dlsym issues reported by Pedro Martelletto <pedro at
ambientworks.net>. okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.76 2007/05/29 04:47:17 jason Exp $ */
d398 1
a398 1
				    (void *)(object->load_addr +
d426 1
a426 1
				_dl_fdprintf(fd, "%lX", object->load_addr);
d549 1
a549 1
		ehdr = (Elf_Ehdr *)object->load_addr;
d553 1
a553 1
		info.dlpi_addr = object->load_addr;
d559 1
a559 1
			((char *)object->load_addr + ehdr->e_phoff);
d581 3
a583 3
		if (dynobj->load_addr != NULL) {
			ehdr = (Elf_Ehdr *)dynobj->load_addr;
			phdr = (Elf_Phdr *)((char *)dynobj->load_addr + ehdr->e_phoff);
d594 1
a594 1
				start = phdr[i].p_vaddr + dynobj->load_addr;
d624 1
a624 1
	info->dli_fbase = (void *)object->load_addr;
d647 1
a647 1
		symbol_addr = (void *)(object->load_addr + sym->st_value);
@


1.76
log
@based on a diff from Matt Provost: allow printing of ldd information
on libraries themselves.  Works by setting up the debugging flags then
calling dlopen() to do the heavy lifting.  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.75 2007/05/05 15:21:21 drahn Exp $ */
d576 1
a577 3
	Elf_Addr end;
	u_int32_t symoffset;
	const Elf_Sym *sym;
d581 8
a588 2
		ehdr = (Elf_Ehdr *)dynobj->load_addr;
		if (ehdr == NULL)
d591 1
a591 3
		phdr = (Elf_Phdr *)((char *)dynobj->load_addr + ehdr->e_phoff);

		for (i = 0; i < ehdr->e_phnum; i++) {
d605 1
a605 25
	/* find the lowest & highest symbol address in the main exe */
	start = -1;
	end = 0;

	for (symoffset = 0; symoffset < _dl_objects->nchains; symoffset++) {
		sym = _dl_objects->dyn.symtab + symoffset;

		/*
		 * For skip the symbol if st_shndx is either SHN_UNDEF or
		 * SHN_COMMON.
		 */
		if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)
			continue;

		if (sym->st_value < start)
			start = sym->st_value;

		if (sym->st_value > end)
			end = sym->st_value;
	}

	if (end && (Elf_Addr) addr >= start && (Elf_Addr) addr <= end)
		return _dl_objects;
	else
		return NULL;
@


1.75
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.74 2007/04/03 14:33:07 jason Exp $ */
d43 1
d59 5
d106 5
d481 8
@


1.74
log
@add support for LD_TRACE_LOADED_OBJECTS_{FMT1/FMT2/PROGNAME}.  Functionality
matches and expands on the old a.out ld.so formatting.  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.73 2006/05/08 20:34:36 deraadt Exp $ */
d46 1
d199 5
d497 7
@


1.73
log
@de-space
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.72 2006/05/03 15:44:56 drahn Exp $ */
d40 1
d343 94
d443 1
a454 2
	_dl_fdprintf(outputfd, "\tStart   %s End     %s Type Open Ref GrpRef Name\n",
	    pad, pad);
d456 10
a465 1
	while (object) {
d483 1
a483 6
		_dl_fdprintf(outputfd, "\t%lX %lX %s %d    %d   %d      %s\n",
		    (void *)object->load_addr,
		    (void *)(object->load_addr + object->load_size),
		    objtypename, object->opencount, object->refcount,
		    object->grprefcount, object->load_name);
		object = object->next;
@


1.72
log
@Keep the state of the debugger constistant, let it know a the dynamic
linker is adding or removing a library before it does the act.
Discussed with kurt@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.71 2005/11/09 16:32:12 kurt Exp $ */
d197 1
a197 1
	case 0x20:  
@


1.71
log
@the handle returned by dlopen(0,...) should behave the same as
RTLD_DEFAULT, so return RTLD_DEFAULT for handle. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.70 2005/10/18 02:49:17 drahn Exp $ */
d60 5
a112 2
		_dl_debug_map->r_state = RT_ADD;
		(*((void (*)(void))_dl_debug_map->r_brk))();
d241 5
a247 1
	_dl_thread_kern_go();
a249 2
		_dl_debug_map->r_state = RT_DELETE;
		(*((void (*)(void))_dl_debug_map->r_brk))();
d253 1
@


1.70
log
@This is too useful for debugging to not have in the tree, however
the interface may change at any time, so dont depend on it. (ie regress)
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.69 2005/10/16 04:14:22 kurt Exp $ */
d54 1
a54 1
		return _dl_objects;
d233 1
a233 1
	if (handle == _dl_objects)
@


1.69
log
@Consolidate dl_boot and dlopen dep lib loading into new function
_dl_load_dep_libs. Now both dl_boot and dlopen will randomize dep lib
loading, where previously only dl_boot did.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.68 2005/10/12 20:36:16 kurt Exp $ */
d194 26
@


1.68
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.67 2005/10/10 16:33:51 kurt Exp $ */
d50 1
a50 2
	elf_object_t *object, *dynobj;
	Elf_Dyn	*dynp;
a51 1
	const char *deplibname = NULL;
d86 1
a86 28
	dynobj = object;
	while (dynobj) {
		for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			elf_object_t *depobj;

			if (dynp->d_tag != DT_NEEDED)
				continue;

			deplibname = dynobj->dyn.strtab + dynp->d_un.d_val;
			DL_DEB(("dlopen: loading: %s required by %s\n",
			    deplibname, libname));
			depobj = _dl_load_shlib(deplibname, dynobj, OBJTYPE_LIB,
				flags);
			if (!depobj) {
				failed = 1;
				break;
			}
			/* this add_object should not be here, XXX */
			_dl_add_object(depobj);
			_dl_link_child(depobj, dynobj);
		}
		dynobj = dynobj->next;
	}

	if (failed == 1) {
		if (deplibname != NULL) {
			DL_DEB(("dlopen: failed to open %s\n", deplibname));
		}
a92 2
		_dl_link_grpsym(object);
		_dl_cache_grpsym_list(object);
@


1.67
log
@set _dl_loading_object to NULL upon entering and exiting _dl_boot and
dlopen and cleanup of related redundant code. looks fine drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.66 2005/10/09 04:29:13 kurt Exp $ */
a51 1
	struct dep_node *n;
d73 7
a79 1
	if (OBJECT_REF_CNT(object) > 1)
d81 1
a87 6
	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(5);
	n->data = object;
	TAILQ_INSERT_TAIL(&object->grpsym_list, n, next_sib);

d107 1
a107 1
			_dl_link_sub(depobj, dynobj);
d122 2
@


1.66
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.65 2005/10/07 01:26:33 kurt Exp $ */
d63 2
a71 2
	_dl_loading_object = object;

a80 1
	object->load_object = object;
@


1.65
log
@rename dload_list to grpsym_list which better represents its usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.64 2005/10/06 22:01:58 kurt Exp $ */
d74 1
a74 1
	if (object->refcount + object->opencount + object->grprefcount > 1)
@


1.64
log
@remove dep_next "shadow object" dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.63 2005/10/06 21:53:09 kurt Exp $ */
d87 1
a87 1
	TAILQ_INSERT_TAIL(&object->dload_list, n, next_sib);
@


1.63
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.62 2005/10/05 21:50:53 kurt Exp $ */
a88 8

	/*
	 * Check for 'needed' objects. For each 'needed' object we
	 * create a 'shadow' object and add it to a list attached to
	 * the object so we know our dependencies. This list should
	 * also be used to determine the library search order when
	 * resolving undefined symbols. This is not yet done. XXX
	 */
a90 2
		elf_object_t *tmpobj = dynobj;

a108 4

			tmpobj->dep_next = _dl_malloc(sizeof(elf_object_t));
			tmpobj->dep_next->next = depobj;
			tmpobj = tmpobj->dep_next;
@


1.62
log
@move opencount increment and dups check to _dl_link_dlopen. fixes cleanup
of partially dlopened (but failed) cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.61 2005/10/03 21:01:37 kurt Exp $ */
d74 1
a74 1
	if (++object->refcount > 1)
d291 1
a293 1
	object->opencount--;
d371 1
a371 1
	_dl_fdprintf(outputfd, "\tStart   %s End     %s Type Ref Name\n",
d392 1
a392 1
		_dl_fdprintf(outputfd, "\t%lX %lX %s  %d  %s\n",
d395 2
a396 1
		    objtypename, object->refcount, object->load_name);
@


1.61
log
@check opencount after handle has been verified to avoid a possible use
after free.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.60 2005/10/03 20:17:26 kurt Exp $ */
d72 1
a72 2
	if (object->opencount == 0)
		_dl_link_dlopen(object);
a148 3
	if (failed == 0)
		object->opencount++;

@


1.60
log
@protect against errant programs that attempt to dlclose a handle that is
already closed (but still around due to refs).
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.59 2005/10/03 19:48:24 kurt Exp $ */
a280 5
	if (object->opencount == 0) {
		_dl_errno = DL_INVALID_HANDLE;
		return (1);
	}

d286 5
@


1.59
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.58 2005/10/01 19:32:22 drahn Exp $ */
d280 6
@


1.58
log
@handle references to load groups caused by dlopen()ing of depenant
members of the load group. work by kurt@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.57 2005/09/28 20:35:23 drahn Exp $ */
d75 1
a75 1
	if (object->refcount > 1)
@


1.57
log
@keep a state flag if a library has been unloaded, and then free the list
seperately ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.56 2005/09/28 15:41:06 drahn Exp $ */
d69 6
a82 1
	_dl_loading_object = object;
a127 2
	_dl_loading_object = NULL;

a137 1
		_dl_link_dlopen(object);
d153 2
d291 1
a291 2
	if(--object->opencount == 0)
		_dl_unlink_dlopen(object);
@


1.56
log
@keep track of opencounts for dlopened objects, so that they
get unloaded the right number of times on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.55 2005/09/28 15:24:22 kurt Exp $ */
d290 1
@


1.55
log
@use the calling object's handle for dlsym(RTLD_DEFAULT,...). makes symbols
in the calling object's load group visable.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.54 2005/09/22 22:33:40 drahn Exp $ */
d148 3
a284 1

d287 2
a288 1
	_dl_unlink_dlopen(object);
@


1.54
log
@Track if symbols are searched but missing while resolving GOT, if
any are missing exit instead of later causing an abort, ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.53 2005/09/21 20:32:19 drahn Exp $ */
d174 1
a174 1
	    handle == RTLD_SELF) {
d188 2
a192 3
	} else if (handle == RTLD_DEFAULT) {
		object = _dl_objects;
		flags = SYM_SEARCH_ALL|SYM_PLT;
@


1.53
log
@Fix bug if object search is not the object where dlsym() finds an object.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.52 2005/09/19 03:16:47 kurt Exp $ */
d66 2
a67 2
		_dl_thread_kern_go();
		return((void *)0);
d70 1
a70 1
		return((void *)object);	/* Already loaded */
d133 1
d136 9
a144 2
		_dl_rtld(object);
		_dl_call_init(object);
d147 1
@


1.52
log
@don't promote DT_NEEDED libs to RTLD_GLOBAL by default when dlopening
libs.

okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.51 2005/09/17 03:02:37 drahn Exp $ */
d159 1
d200 1
a200 1
	    flags|SYM_NOWARNNOTFOUND, 0, object, NULL);
d207 1
a207 1
			    object->dyn.pltgot);
@


1.51
log
@Cleanly handle the case where a dynamic object is opened, but one of it's
dependant libraries is missing. return NULL for a handle instead of
causing the program to exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.50 2005/09/16 23:19:41 drahn Exp $ */
d107 1
a107 1
				flags|RTLD_GLOBAL);
@


1.50
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.49 2005/09/13 03:32:15 drahn Exp $ */
d53 2
d65 1
a97 1
			const char *deplibname;
d108 4
a111 2
			if (!depobj)
				_dl_exit(4);
d123 1
a123 3
	_dl_link_dlopen(object);
	_dl_rtld(object);
	_dl_call_init(object);
d125 13
a137 3

	_dl_loading_object = NULL;
	DL_DEB(("tail %s\n", object->load_name ));
d148 2
a149 1
	DL_DEB(("dlopen: %s: done.\n", libname));
d323 3
@


1.49
log
@Only return a _dl_md_plabel() if the object is a function, do not indirect
a data reference. sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.48 2005/05/23 19:22:11 drahn Exp $ */
d52 1
d60 1
d66 3
a70 2
	_dl_link_sub(object, _dl_objects);
	_dl_thread_kern_go();
d72 10
a81 2
	if (object->refcount > 1)
		return((void *)object);	/* Already loaded */
a103 1
			_dl_thread_kern_stop();
a110 1
			_dl_thread_kern_go();
d119 1
a122 1
	_dl_link_dlopen(object);
d124 2
d134 2
d148 1
a148 1
	int		flags;
d161 3
a163 9
		if (handle == RTLD_NEXT) {
			object = object->next;
			if (object == NULL) {
				_dl_errno = DL_NO_SYMBOL;
				return(0);
			}
		}

		if (handle == NULL)
d166 1
a166 1
			flags = SYM_SEARCH_ALL|SYM_PLT;
d173 1
a173 1
		flags = SYM_SEARCH_SELF|SYM_NOTPLT;
d185 2
a186 2
	retval = (void *)_dl_find_symbol(name, object, &sym, NULL,
	    flags|SYM_NOWARNNOTFOUND, 0, object);
d229 2
d233 2
d260 1
a260 1
	_dl_unlink_dlopen(object);
d263 1
a321 2
	extern int _dl_symcachestat_hits;
	extern int _dl_symcachestat_lookups;
@


1.48
log
@fixes for dlclose, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.47 2005/05/10 03:36:07 drahn Exp $ */
d184 3
a186 2
		retval = (void *)_dl_md_plabel((Elf_Addr)retval,
		    object->dyn.pltgot);
@


1.47
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.46 2005/04/06 00:16:53 deraadt Exp $ */
a43 1
void _dl_unload_deps(elf_object_t *object);
d45 1
a45 1
elf_object_t *obj_from_addr(const void *addr);
a247 5
	if (object->refcount == 1) {
		if (dynobj->dep_next)
			_dl_unload_deps(dynobj);
	}

d249 2
a254 19
/*
 * Scan through the shadow dep list and 'unload' every library
 * we depend upon. Shadow objects are removed when removing ourself.
 */
void
_dl_unload_deps(elf_object_t *object)
{
	elf_object_t *depobj;

	depobj = object->dep_next;
	while (depobj) {
		if (depobj->next->refcount == 1) { /* This object will go away */
			if (depobj->next->dep_next)
				_dl_unload_deps(depobj->next);
			_dl_unload_shlib(depobj->next);
		}
		depobj = depobj->dep_next;
	}
}
@


1.46
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.44 2005/03/08 20:01:59 drahn Exp $ */
d43 4
a46 6
static int _dl_real_close(void *handle);
static void _dl_unload_deps(elf_object_t *object);
static void _dl_thread_kern_stop(void);
static void _dl_thread_kern_go(void);
static void (*_dl_thread_fnc)(int) = NULL;
static elf_object_t *obj_from_addr(const void *addr);
d114 3
d233 1
a233 1
static int
d254 1
d263 1
a263 1
static void
d384 1
a384 1
static void
d391 1
a391 1
static void
@


1.45
log
@Do a better job of running destructors in the right order.
@
text
@d43 6
a48 4
int _dl_real_close(void *handle);
void _dl_unload_deps(elf_object_t *object);
void (*_dl_thread_fnc)(int) = NULL;
elf_object_t *obj_from_addr(const void *addr);
a115 3
	_dl_link_dlopen(object);


d232 1
a232 1
int
a252 1
	_dl_unlink_dlopen(object);
d261 1
a261 1
void
d382 1
a382 1
void
d389 1
a389 1
void
@


1.44
log
@Do not shadow a parameter with a local variable. also add a debug statement
to print dependandant libraries loaded by dlopen ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.43 2005/03/07 20:50:11 kettenis Exp $ */
d43 4
a46 6
static int _dl_real_close(void *handle);
static void _dl_unload_deps(elf_object_t *object);
static void _dl_thread_kern_stop(void);
static void _dl_thread_kern_go(void);
static void (*_dl_thread_fnc)(int) = NULL;
static elf_object_t *obj_from_addr(const void *addr);
d114 3
d233 1
a233 1
static int
d254 1
d263 1
a263 1
static void
d384 1
a384 1
static void
d391 1
a391 1
static void
@


1.43
log
@Fix bug not calling callback for the main executable object.
ok drahn@@, espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.42 2004/12/01 22:27:35 kurt Exp $ */
d87 1
a87 1
			const char *libname;
d93 3
a95 1
			libname = dynobj->dyn.strtab + dynp->d_un.d_val;
d97 1
a97 1
			depobj = _dl_load_shlib(libname, dynobj, OBJTYPE_LIB,
@


1.42
log
@fix dlsym(RTLD_NEXT,...) when called from the last shared object
loaded. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.41 2004/10/14 10:02:28 kettenis Exp $ */
d405 1
a405 1
		if (ehdr == NULL)
d410 7
a416 3
		info.dlpi_phdr =
		    (Elf_Phdr *)((char *)object->load_addr + ehdr->e_phoff);
		info.dlpi_phnum = ehdr->e_phnum;
@


1.41
log
@Add dl_iterate_phdr() support.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.40 2004/08/13 16:45:41 drahn Exp $ */
d146 1
a146 1
		if (handle == RTLD_NEXT)
d148 5
@


1.40
log
@Cast to Elf_Addr to remove warnings of ELF types(int)/pointer, ok david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.39 2004/08/11 19:14:56 drahn Exp $ */
d387 27
@


1.39
log
@add dladdr() support and add some 'standard' dlsym() support.
ok millert miod pval, grumble deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.38 2004/06/07 15:18:19 mickey Exp $ */
d443 1
a443 1
	if (end && addr >= start && addr <= end)
@


1.38
log
@fixup the dlsym() return to produce a callable address (plabel) and move one comment closer to the code it talks about earlier; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.37 2004/06/07 15:00:38 mickey Exp $ */
d48 1
d133 1
d135 13
a147 4
	object = (elf_object_t *)handle;
	dynobj = _dl_objects;
	while (dynobj && dynobj != object)
		dynobj = dynobj->next;
d149 20
a168 3
	if (!dynobj || object != dynobj) {
		_dl_errno = DL_INVALID_HANDLE;
		return(0);
d172 2
a173 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_NOTPLT, 0, object);
d306 6
d389 114
@


1.37
log
@debugging notify that dlopen() has finished as it was said when it had started; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.36 2004/05/25 18:07:20 mickey Exp $ */
a61 1
	/* this add_object should not be here, XXX */
d66 1
d145 1
a145 1
	if (sym != NULL)
d147 7
a153 1
	else
@


1.36
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.35 2004/05/25 15:56:18 deraadt Exp $ */
d119 3
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.34 2004/05/22 19:42:52 drahn Exp $ */
d140 1
a140 1
	retval = (void *)_dl_find_symbol(name, object, &sym,
@


1.34
log
@Dont print symcache statistics if no symbol lookups have occurred, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.33 2003/10/01 02:55:23 millert Exp $ */
d279 2
d323 6
a328 9
	{
		extern int _dl_symcachestat_hits;
		extern int _dl_symcachestat_lookups;
		if (_dl_symcachestat_lookups != 0)
			DL_DEB(("symcache lookups %d hits %d ratio %d% hits\n",
			    _dl_symcachestat_lookups, _dl_symcachestat_hits,
			    (_dl_symcachestat_hits * 100) /
			    _dl_symcachestat_lookups));
	}
@


1.33
log
@Add break statements in switch missing from revision 1.32.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.32 2003/09/25 21:56:20 millert Exp $ */
d324 5
a328 3
	DL_DEB(("symcache lookups %d hits %d ratio %d% hits\n",
	    _dl_symcachestat_lookups, _dl_symcachestat_hits,
	    (_dl_symcachestat_hits * 100) / _dl_symcachestat_lookups));
@


1.32
log
@dlerror(3) should clear _dl_errno; based on a patch from Bjorn Sandell.
Closes PR 3441; drahn@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.31 2003/09/04 19:33:48 drahn Exp $ */
d243 1
d246 1
d249 1
d252 1
d255 1
d258 1
d261 1
d264 1
d267 1
@


1.31
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.30 2003/09/02 15:17:51 drahn Exp $ */
d238 2
d242 1
a242 1
		return (NULL);
d244 1
a244 1
		return ("File not found");
d246 1
a246 1
		return ("Can't open file");
d248 1
a248 1
		return ("File not an ELF object");
d250 1
a250 1
		return ("Can't open referenced object");
d252 1
a252 1
		return ("Can't map ELF object");
d254 1
a254 1
		return ("Invalid handle");
d256 1
a256 1
		return ("Unable to resolve symbol");
d258 1
a258 1
		return ("Invalid dlctl() command");
d260 1
a260 1
		return ("Unknown error");
d262 3
@


1.30
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.29 2003/06/26 07:53:27 deraadt Exp $ */
d306 7
@


1.29
log
@simple protos
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.28 2003/06/22 21:39:01 drahn Exp $ */
d50 1
a50 1
dlopen(const char *libname, int how)
d61 1
a61 1
	object = _dl_load_shlib(libname, _dl_objects, OBJTYPE_DLO);
d94 2
a95 1
			depobj = _dl_load_shlib(libname, dynobj, OBJTYPE_LIB);
d141 1
a141 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_NOTPLT, 0, "");
@


1.28
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.27 2003/06/09 16:10:03 deraadt Exp $ */
d114 1
a114 1
		(*((void (*)())_dl_debug_map->r_brk))();
d116 1
a116 1
		(*((void (*)())_dl_debug_map->r_brk))();
d179 1
a179 1
		(*((void (*)())_dl_debug_map->r_brk))();
d181 1
a181 1
		(*((void (*)())_dl_debug_map->r_brk))();
@


1.27
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.26 2003/05/30 01:13:53 drahn Exp $ */
d62 6
a69 2
	if (object == 0)
		return((void *)0);
d95 4
a100 2
			if (!depobj)
				_dl_exit(4);
@


1.26
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.25 2003/04/28 22:51:25 marc Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.25
log
@
thread safe dlxxx func (for elf) part 2.   This requires the latest
ldfcn.h in /usr/include.   "looks nice" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.24 2003/02/02 16:57:58 deraadt Exp $ */
d68 1
d97 1
@


1.24
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.23 2002/11/23 04:09:34 drahn Exp $ */
d51 3
d66 1
d68 1
d94 1
d96 1
d149 2
d152 5
d159 1
d162 1
a162 1
	return(-1);
d305 15
@


1.23
log
@Remove some error messages which were incorrectly printed. Some cleanup.
ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.22 2002/11/14 15:15:54 drahn Exp $ */
d71 5
a75 5
	 *	Check for 'needed' objects. For each 'needed' object we
	 *	create a 'shadow' object and add it to a list attached to
	 *	the object so we know our dependencies. This list should
	 *	also be used to determine the library search order when
	 *	resolving undefined symbols. This is not yet done. XXX
d195 2
a196 2
 *	Scan through the shadow dep list and 'unload' every library
 *	we depend upon. Shadow objects are removed when removing ourself.
d215 1
a215 3
 *	dlerror()
 *
 *	Return a character string describing the last dl... error occurred.
d218 1
a218 1
dlerror()
d245 1
a245 1
_dl_show_objects()
d255 1
a255 1
	else 
@


1.22
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.21 2002/10/04 03:01:42 drahn Exp $ */
d131 1
a131 1
	    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_NOTPLT, 0, object->load_name);
@


1.21
log
@Print full 64 bit address. At least until LD_TRACE_LOADED_OBJECTS_FMT[12]
is supported properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.20 2002/08/31 04:58:25 drahn Exp $ */
d131 1
a131 1
	    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_NOTPLT, 0);
@


1.20
log
@Add the ability to output to file descriptors besides stderr.
This allows ldd outptut go to stdout like it should. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.19 2002/08/23 22:57:03 drahn Exp $ */
d252 1
d260 6
a265 1
	_dl_fdprintf(outputfd, "\tStart    End     Type Ref Name\n");
d285 3
a287 2
		_dl_fdprintf(outputfd, "\t%X %X %s  %d  %s\n",
		    object->load_addr, object->load_addr + object->load_size,
@


1.19
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.18 2002/08/11 16:51:04 drahn Exp $ */
d41 1
d251 1
d254 4
d259 1
a259 1
	_dl_printf("\tStart    Size     Type Ref Name\n");
d279 2
a280 2
		_dl_printf("\t%X %X %s  %d  %s\n", object->load_addr,
		    object->load_addr + object->load_size,
@


1.18
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.17 2002/05/28 00:23:57 deraadt Exp $ */
d129 2
a130 1
	retval = (void *)_dl_find_symbol(name, object, &sym, 1, 1, 0);
@


1.17
log
@proto _dl_show_objects() in one place
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.16 2002/05/24 04:17:00 deraadt Exp $ */
d129 1
a129 1
	retval = (void *)_dl_find_symbol(name, object, &sym, 1, 1);
@


1.16
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.15 2002/05/24 03:44:37 deraadt Exp $ */
a47 2
void _dl_show_objects(void);

d54 1
a54 2
	elf_object_t	*object;
	elf_object_t	*dynobj;
a140 7

#ifdef __mips__
	case DL_DUMP_MAP:
		_dl_show_objects();
		return(0);
#endif /* __mips__ */

@


1.15
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.14 2002/03/17 04:50:57 drahn Exp $ */
d83 1
a83 1
                for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
d87 1
a87 1
                        if (dynp->d_tag != DT_NEEDED)
d98 3
a100 3
                }
                dynobj = dynobj->next;
        }
@


1.14
log
@Remove hackery I added to deal with dlopen(NULL), handle it in a reasonably
sane manner. This and the previous resolve.c change art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.14 2002/03/17 04:42:51 drahn Exp $ */
d5 1
a5 1
 * 
d60 1
a60 1
	if (libname == NULL) {
d62 1
a62 1
	}
d66 1
a66 1
	if (object == 0) {
a67 1
	}
d69 1
a69 1
	if (object->refcount > 1) {
a70 1
	}
d87 1
a87 1
                        if (dynp->d_tag != DT_NEEDED) {
d89 1
a89 1
			}
d92 1
a92 1
			if (!depobj) {
d94 1
a94 1
			}
d105 1
a105 1
	if(_dl_debug_map->r_brk) {
a110 1

d124 1
a124 1
	while (dynobj && dynobj != object) {
d126 1
a126 1
	}
d133 1
a133 1
	if (sym != NULL) {
d135 1
a135 1
	} else {
a136 2
	}

d163 1
a163 1
	if (handle == _dl_objects) {
d165 1
a165 1
	}
a173 1

d185 1
a185 1
	while (dynobj && dynobj != object) {
d187 1
a187 1
	}
d194 1
a194 1
		if (dynobj->dep_next) {
a195 1
		}
d214 1
a214 1
			if (depobj->next->dep_next) {
a215 1
			}
d283 2
a284 3
				object->load_addr + object->load_size,
				objtypename, object->refcount,
				object->load_name);
@


1.13
log
@call the r_brk function in dlopen/dloclose on all archs,
not just mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.12 2002/02/21 23:17:53 drahn Exp $ */
d61 1
a61 1
		return NULL;
a124 10
	if (handle == NULL) {
		object = _dl_objects;
		retval = (void *)_dl_find_symbol(name, object, &sym, 1, 1);
		if (sym != NULL) {
			retval += sym->st_value;
		} else {
			_dl_errno = DL_NO_SYMBOL;
		}
		return retval;
	}
d168 3
@


1.12
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.11 2001/11/06 15:32:11 drahn Exp $ */
d63 1
a63 1
	DL_DEB(("loading: %s\n", libname));
a106 1
#ifdef __mips__
a112 1
#endif /* __mips__ */
a179 1
#ifdef __mips__
a185 1
#endif /* __mips__ */
@


1.11
log
@Since the header of the file map is Start End,
print the end address, not the size.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.11 2001/11/06 15:18:08 drahn Exp $ */
d281 1
a281 1
	_dl_printf("\tStart    End      Type Ref Name\n");
@


1.10
log
@Change method of determining object type, does better bounds checking,
and fixes a bug on sparc64 "ELF" for type.
ok art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.9 2001/09/19 10:58:07 mpech Exp $ */
d302 3
a304 2
				object->load_size, objtypename,
				object->refcount, object->load_name);
@


1.9
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.8 2001/09/15 20:44:52 drahn Exp $ */
d277 1
a277 3
	static char *otyp[] = {
		"none", "rtld", "exe ", "rlib", "dlib"
	};
d284 17
d302 1
a302 1
				object->load_size, otyp[object->obj_type],
@


1.8
log
@Some cleanup in loader.c, initialize the symbol pointer with NULL,
add a missing initialization of the sym pointer.

Add some functionality which allows a program to open itself dlopen(NULL),
so that it can then look up symbols in the executable itself.
Note that the program can only access exported variables, either by
exporting all variables with the ld option -E or externally referrenced.

Fix bug in dlsym() where it would return failure when looking up symbols.
It was testing the offset of the found symbol, not if the symbol was found.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.7 2001/08/09 02:42:12 drahn Exp $ */
d244 1
a244 1
 *	Return a character string describing the last dl... error occured.
@


1.7
log
@It seems bogus to me, but if code call dlerror() when an error has
not occurred, there exists code that expects dlerror to return NULL.
Change the code to match the expected behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.6 2001/06/06 12:45:17 art Exp $ */
d60 3
d93 1
a93 1
			depobj = _dl_load_shlib(libname, dynobj, OBJTYPE_DLO);
d125 1
a125 1
	const Elf_Sym	*sym = 0;
d127 10
d148 1
a148 1
	if (retval) {
@


1.6
log
@more cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.5 2001/06/06 12:31:52 art Exp $ */
d237 2
@


1.5
log
@Replace all 'if (_dl_debug) _dl_printf(...)' with a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.4 2001/06/06 12:26:05 art Exp $ */
d63 1
a63 1
	if(object == 0) {
d67 1
a67 1
	if(object->refcount > 1) {
d79 1
a79 1
	while(dynobj) {
d81 2
a82 1
                for(dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
d86 1
a86 1
                        if(dynp->d_tag != DT_NEEDED) {
d91 1
a91 1
			if(!depobj) {
d126 1
a126 1
	while(dynobj && dynobj != object) {
d129 1
a129 1
	if(!dynobj || object != dynobj) {
d135 1
a135 1
	if(retval) {
d137 1
a137 2
	}
	else {
d140 2
a141 1
	return(retval);
d147 1
a147 1
	switch(command) {
d170 1
a170 1
	if(_dl_debug_map->r_brk) {
d177 2
a178 1
	return(retval);
d189 1
a189 1
	while(dynobj && dynobj != object) {
d192 1
a192 1
	if(!dynobj || object != dynobj) {
d194 1
a194 1
		return(1);
d197 2
a198 2
	if(object->refcount == 1) {
		if(dynobj->dep_next) {
d204 1
a204 1
	return(0);
d217 3
a219 3
	while(depobj) {
		if(depobj->next->refcount == 1) { /* This object will go away */
			if(depobj->next->dep_next) {
d236 1
a236 1
	switch(_dl_errno) {
d238 1
a238 1
		return("File not found");
d240 1
a240 1
		return("Can't open file");
d242 1
a242 1
		return("File not an ELF object");
d244 1
a244 1
		return("Can't open referenced object");
d246 1
a246 1
		return("Can't map ELF object");
d248 1
a248 1
		return("Invalid handle");
d250 1
a250 1
		return("Unable to resolve symbol");
d252 1
a252 1
		return("Invalid dlctl() command");
d254 1
a254 1
		return("Unknown error");
a257 1

d262 3
a264 3
static char *otyp[] = {
	"none", "rtld", "exe ", "rlib", "dlib"
};
d270 1
a270 1
	while(object) {
@


1.4
log
@No need to extern _dl_debug here.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.3 2001/04/02 23:11:20 drahn Exp $ */
d60 2
a61 3
	if (_dl_debug) {
		_dl_printf("loading: %s\n", libname);
	}
@


1.3
log
@Cleanup for 64bit support.
Pieces by art, niklas and me.
Only tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.2 2000/09/17 17:50:57 deraadt Exp $ */
a51 1
extern char *_dl_debug;
@


1.2
log
@activate ldd, and indent some ld.so messages to make it easier to see what is going on
@
text
@d1 1
a1 1
/*	$OpenBSD: dlfcn.c,v 1.1.1.2 2000/06/13 03:39:56 rahnds Exp $ */
d59 1
a59 1
	Elf32_Dyn	*dynp;
d123 1
a123 1
	const Elf32_Sym	*sym = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d38 1
d52 1
d61 3
d105 1
d112 1
d123 1
a123 1
	Elf32_Sym	*sym = 0;
d135 1
a135 1
	retval = (void *)_dl_find_symbol(name, object, &sym, 1);
d149 2
d154 1
d170 1
d177 1
a262 2
	elf_object_t *depobj;
	elf_object_t *tmpobj;
d269 1
a269 2
	_dl_printf("Currently loaded modules:\n");
	_dl_printf("Start    End      Type Ref Name\n");
d272 1
a272 1
		_dl_printf("%X %X %s  %d  %s\n", object->load_addr,
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@


1.1.1.2
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems
such as correctness and security.
@
text
@a37 1
#include <nlist.h>
a50 1
extern char *_dl_debug;
a58 3
	if (_dl_debug) {
		_dl_printf("loading: %s\n", libname);
	}
a99 1
#ifdef __mips__
a105 1
#endif /* __mips__ */
d116 1
a116 1
	const Elf32_Sym	*sym = 0;
d128 1
a128 1
	retval = (void *)_dl_find_symbol(name, object, &sym, 1, 1);
a141 2

#ifdef __mips__
a144 1
#endif /* __mips__ */
a159 1
#ifdef __mips__
a165 1
#endif /* __mips__ */
d251 2
@

