head	1.14;
access;
symbols
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	r20000612:1.1.1.1
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2004.08.11.17.11.45;	author pefo;	state dead;
branches;
next	1.13;

1.13
date	2004.08.06.09.40.44;	author pefo;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.09.16.10.04;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.23.12.38.29;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.23.23.56.31;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.24.03.44.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.34.17;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.34.17;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.14
log
@mips->mips64
@
text
@/*	$OpenBSD: syscall.h,v 1.13 2004/08/06 09:40:44 pefo Exp $ */

/*
 * Copyright (c) 1998-2002 Opsycon AB, Sweden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#ifndef __DL_SYSCALL_H__
#define __DL_SYSCALL_H__

#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/signal.h>

extern long _dl__syscall(quad_t val, ...);

#ifndef _dl_MAX_ERRNO
#define _dl_MAX_ERRNO 4096
#endif
#define _dl_check_error(__res)	\
	((int) __res < 0 && (int) __res >= -_dl_MAX_ERRNO)

/*
 *  Inlined system call functions that can be used before
 *  any dynamic address resolving has been done.
 */

extern inline int
_dl_exit(int status)
{
	register int __status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "syscall"
	    : "=r" (__status)
	    : "0" (SYS_exit), "r" (status)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	while (1)
		;
}

extern inline int
_dl_open(const char* addr, int flags)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_open), "r" (addr), "r" (flags)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline int
_dl_close(int fd)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_close), "r" (fd)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline ssize_t
_dl_write(int fd, const char* buf, size_t len)
{
	register ssize_t status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "move  $6,%4\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_write), "r" (fd), "r" (buf), "r" (len)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline ssize_t
_dl_read(int fd, const char* buf, size_t len)
{
	register ssize_t status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "move  $6,%4\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_read), "r" (fd), "r" (buf), "r" (len)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline void *
_dl_mmap(void *addr, size_t size, int prot, int flags, int fd, off_t f_offset)
{
	register void * malloc_buffer __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "addiu $29,-40\n\t"
	    "move  $6,%2\n\t"
	    "move  $7,%3\n\t"
	    "sw    %4,16($29)\n\t"
	    "sw    %5,20($29)\n\t"
#ifdef __MIPSEL__
	    "li    $4,197\n\t"
	    "li    $5,0\n\t"
	    "sw    %6,24($29)\n\t"
	    "sw    $0,28($29)\n\t"
	    "sw    %7,32($29)\n\t"
	    "sw    $0,36($29)\n\t"
#endif
#ifdef __MIPSEB__
	    "li    $4,0\n\t"
	    "li    $5,197\n\t"
	    "sw    %6,24($29)\n\t"
	    "sw    $0,28($29)\n\t"
	    "sw    $0,32($29)\n\t"
	    "sw    %7,36($29)\n\t"
#endif
	    "syscall\n\t"
	    "addiu $29,40"
	    : "=r" (malloc_buffer)
	    : "0" (SYS___syscall), "r" (addr), "r" (size), "r" (prot),
	    "r" (flags), "r" (fd), "r" ((int)f_offset)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return malloc_buffer;
}

extern inline int
_dl_munmap(const void* addr, size_t len)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_munmap), "r" (addr), "r" (len)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline int
_dl_mprotect(const void *addr, size_t size, int prot)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "move  $6,%4\n\t"
	    "syscall"
	    : "=r" (status)
	    : "0" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline int
_dl_stat(const char *addr, struct stat *sb)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "syscall"
	    : "=r" (status)
	    : "0" (SYS_stat), "r" (addr), "r" (sb)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline int
_dl_fstat(const int fd, struct stat *sb)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "syscall"
	    : "=r" (status)
	    : "0" (SYS_fstat), "r" (fd), "r" (sb)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline ssize_t
_dl_fcntl(int fd, int cmd, int flag)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "move  $6,%4\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_fcntl), "r" (fd), "r" (cmd), "r" (flag)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline ssize_t
_dl_getdirentries(int fd, char *buf, int nbytes, long *basep)
{
	register int status __asm__ ("$2");

	__asm__ volatile ("move  $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
	    "move  $6,%4\n\t"
	    "move  $7,%5\n\t"
	    "syscall\n\t"
	    "beq   $7,$0,1f\n\t"
	    "li    $2,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "0" (SYS_getdirentries), "r" (fd), "r" (buf), "r" (nbytes), "r" (basep)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline int
_dl_issetugid(void)
{
	register int status __asm__ ("$2");

	__asm__ volatile (
	    "move  $2,%1\n\t"
	    "syscall"
	    : "=r" (status)
	    : "0" (SYS_issetugid)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
	return status;
}

extern inline off_t
_dl_lseek(int fd, off_t offset, int whence)
{
	return _dl__syscall((quad_t)SYS_lseek, fd, 0, offset, whence);
}

extern inline int
_dl_sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
        sigset_t sig_store;
        sigset_t sig_store1;

        if (set != NULL) {
                sig_store1 = *set;
        } else {
                sig_store1 = 0;
        }

        __asm__ volatile (
	    "li    $2,%1\n\t"
	    "move  $4,%2\n\t"
	    "move  $5,%3\n\t"
            "syscall\n\t"
            "move    %0, $2"
            : "=r" (sig_store)
            : "I" (SYS_sigprocmask), "r" (how), "r" (sig_store1)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
        if (oset != NULL)
                *oset = sig_store;

        return 0;
}
static inline int
_dl_sysctl(int *name, u_int namelen, void *oldp, size_t *oldplen, void *newp,
    size_t newlen)
{
        register int status __asm__ ("$2");

        __asm__ volatile (
	    "move  $2,%1\n\t"
	    "addiu $29,-40\n\t"
            "move  $4,%2\n\t"
            "move  $5,%3\n\t"
            "move  $6,%4\n\t"
            "move  $7,%5\n\t"
            "sw    %6,16($29)\n\t"
            "sw    %7,20($29)\n\t"
            "syscall\n\t"
	    "addiu $29,40\n\t"
            "beqz   $2,1f\n\t"
            "li    $2,-1\n\t"
            "1:"
            : "=r" (status)
            : "r" (SYS___sysctl), "r" (name), "r" (namelen), "r" (oldp),
            "r" (oldplen), "r" (newp), "r" (newlen)
	    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
	    "$10","$11","$12","$13","$14","$15","$24","$25");
        return status;
}


#endif /*__DL_SYSCALL_H__*/
@


1.13
log
@update for mips
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.12 2003/07/06 20:04:00 deraadt Exp $ */
@


1.12
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.11 2003/06/09 16:10:04 deraadt Exp $ */
a31 1

d33 1
d178 1
a178 1
	    "r" (flags), "r" (fd), "r" (f_offset)
d318 57
@


1.11
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.10 2002/10/23 12:38:29 pefo Exp $ */
d49 1
a49 1
_dl_exit (int status)
d66 1
a66 1
_dl_open (const char* addr, int flags)
d86 1
a86 1
_dl_close (int fd)
d105 1
a105 1
_dl_write (int fd, const char* buf, size_t len)
d126 1
a126 1
_dl_read (int fd, const char* buf, size_t len)
d147 1
a147 1
_dl_mmap (void *addr, size_t size, int prot, int flags, int fd, off_t f_offset)
d185 1
a185 1
_dl_munmap (const void* addr, size_t len)
d205 1
a205 1
_dl_mprotect (const void *addr, size_t size, int prot)
d223 1
a223 1
_dl_stat (const char *addr, struct stat *sb)
d240 1
a240 1
_dl_fstat (const int fd, struct stat *sb)
d257 1
a257 1
_dl_fcntl (int fd, int cmd, int flag)
d278 1
a278 1
_dl_getdirentries (int fd, char *buf, int nbytes, long *basep)
d299 1
a299 1
_dl_issetugid (void)
d314 1
a314 1
_dl_lseek (int fd, off_t offset, int whence)
@


1.10
log
@mips archdep stuff update while waiting for ok on mi
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.9 2002/07/24 04:11:10 deraadt Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.7 2002/07/23 23:56:31 mickey Exp $ */
d4 1
a4 1
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
d16 1
a16 2
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
d40 2
d58 3
a60 1
	__asm__ volatile ("move  $4,%2\n\t"
d75 3
a77 1
	__asm__ volatile ("move  $4,%2\n\t"
d95 3
a97 1
	__asm__ volatile ("move  $4,%2\n\t"
d114 3
a116 1
	__asm__ volatile ("move  $4,%2\n\t"
d135 3
a137 1
	__asm__ volatile ("move  $4,%2\n\t"
d156 3
a158 1
	__asm__ volatile ("addiu $29,-40\n\t"
d163 1
a163 1
#ifdef MIPSEL
d171 1
a171 1
#ifdef MIPSEB
d194 3
a196 1
	__asm__ volatile ("move  $4,%2\n\t"
d214 3
a216 1
	__asm__ volatile ("move  $4,%2\n\t"
d232 3
a234 1
	__asm__ volatile ("move  $4,%2\n\t"
a243 4
/*
 * Not an actual syscall, but we need something in assembly to say
 * whether this is OK or not.
 */
d245 1
a245 1
_dl_suid_ok (void)
d247 1
a247 1
	unsigned int uid, euid, gid, egid;
d249 7
a255 2
	__asm__ volatile ("move $2,%1; syscall; move %0,$2"
	    : "=r" (uid) : "r" (SYS_getuid)
d258 19
a276 2
	__asm__ volatile ("move $2,%1; syscall; move %0,$2"
	    : "=r" (euid) : "r" (SYS_geteuid)
d279 19
a297 2
	__asm__ volatile ("move $2,%1; syscall; move %0,$2"
	    : "=r" (gid) : "r" (SYS_getgid)
d300 13
a312 2
	__asm__ volatile ("move $2,%1; syscall; move %0,$2"
	    : "=r" (egid) : "r" (SYS_getegid)
d315 2
d318 4
a321 1
	return (uid == euid && gid == egid);
@


1.8
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.6 2002/07/12 20:18:30 drahn Exp $ */
d68 1
a68 1
_dl_open (const char* addr, unsigned int flags)
d102 2
a103 2
extern inline int
_dl_write (int fd, const char* buf, int len)
d105 1
a105 1
	register int status __asm__ ("$2");
d121 2
a122 2
extern inline int
_dl_read (int fd, const char* buf, int len)
d124 1
a124 1
	register int status __asm__ ("$2");
d140 2
a141 3
extern inline int
_dl_mmap (void *addr, unsigned int size, unsigned int prot,
    unsigned int flags, int fd, unsigned int f_offset)
d143 1
a143 1
	register int malloc_buffer __asm__ ("$2");
d177 1
a177 1
_dl_munmap (const void* addr, unsigned int len)
d195 1
a195 1
_dl_mprotect (const void *addr, int size, int prot)
@


1.7
log
@match _dl_ syscall prototypes w/ the real syscalls prototypes, including args and return values; art@@ ok
@
text
@d68 1
a68 1
_dl_open (const char* addr, int flags)
d102 2
a103 2
extern inline ssize_t
_dl_write (int fd, const char* buf, size_t len)
d105 1
a105 1
	register ssize_t status __asm__ ("$2");
d121 2
a122 2
extern inline ssize_t
_dl_read (int fd, const char* buf, size_t len)
d124 1
a124 1
	register ssize_t status __asm__ ("$2");
d140 3
a142 2
extern inline void *
_dl_mmap (void *addr, size_t size, int prot, int flags, int fd, off_t f_offset)
d144 1
a144 1
	register void * malloc_buffer __asm__ ("$2");
d178 1
a178 1
_dl_munmap (const void* addr, size_t len)
d196 1
a196 1
_dl_mprotect (const void *addr, size_t size, int prot)
@


1.6
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.5 2002/07/07 08:54:50 jufi Exp $ */
d68 1
a68 1
_dl_open (const char* addr, unsigned int flags)
d102 2
a103 2
extern inline int
_dl_write (int fd, const char* buf, int len)
d105 1
a105 1
	register int status __asm__ ("$2");
d121 2
a122 2
extern inline int
_dl_read (int fd, const char* buf, int len)
d124 1
a124 1
	register int status __asm__ ("$2");
d140 2
a141 3
extern inline int
_dl_mmap (void *addr, unsigned int size, unsigned int prot,
    unsigned int flags, int fd, unsigned int f_offset)
d143 1
a143 1
	register int malloc_buffer __asm__ ("$2");
d177 1
a177 1
_dl_munmap (const void* addr, unsigned int len)
d195 1
a195 1
_dl_mprotect (const void *addr, int size, int prot)
@


1.5
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.4 2002/05/24 04:17:00 deraadt Exp $ */
a36 1
#ifdef USE_CACHE
a37 1
#endif
a210 1
#ifdef USE_CACHE
a224 2

#endif
@


1.4
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.3 2002/05/24 03:44:38 deraadt Exp $ */
d51 1
a51 1
 *  any dynamic address resoving has been done.
@


1.3
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.2 2002/02/21 23:17:53 drahn Exp $ */
d62 1
a62 1
            : "0" (SYS_exit), "r" (status)
d76 1
a76 1
            "syscall\n\t"
d144 1
a144 1
	        unsigned int flags, int fd, unsigned int f_offset)
@


1.2
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.1.1.1 2000/06/13 03:34:17 rahnds Exp $ */
d5 1
a5 1
 * 
d47 1
a47 1
  ((int) __res < 0 && (int) __res >= -_dl_MAX_ERRNO)
d56 12
a67 10
{ 
  register int __status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "syscall"
                    : "=r" (__status)
                    : "0" (SYS_exit), "r" (status)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  while(1);
} 
d71 15
a85 14
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "0" (SYS_open), "r" (addr), "r" (flags)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d89 14
a102 13
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "0" (SYS_close), "r" (fd)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d106 16
a121 15
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "0" (SYS_write), "r" (fd), "r" (buf), "r" (len)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d125 16
a140 15
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "0" (SYS_read), "r" (fd), "r" (buf), "r" (len)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d144 9
a152 8
          unsigned int flags, int fd, unsigned int f_offset)
{ 
  register int malloc_buffer __asm__ ("$2");
  __asm__ volatile ("addiu $29,-40\n\t"
                    "move  $6,%2\n\t"
                    "move  $7,%3\n\t"
		    "sw    %4,16($29)\n\t"
		    "sw    %5,20($29)\n\t"
d154 6
a159 6
		    "li    $4,197\n\t"
                    "li    $5,0\n\t"
		    "sw    %6,24($29)\n\t"
		    "sw    $0,28($29)\n\t"
		    "sw    %7,32($29)\n\t"
		    "sw    $0,36($29)\n\t"
d162 6
a167 6
                    "li    $4,0\n\t"
		    "li    $5,197\n\t"
		    "sw    %6,24($29)\n\t"
		    "sw    $0,28($29)\n\t"
		    "sw    $0,32($29)\n\t"
		    "sw    %7,36($29)\n\t"
d169 9
a177 9
                    "syscall\n\t"
		    "addiu $29,40"
                    : "=r" (malloc_buffer)
                    : "0" (SYS___syscall), "r" (addr), "r" (size), "r" (prot),
		      "r" (flags), "r" (fd), "r" (f_offset)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return malloc_buffer;
} 
d181 15
a195 14
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall\n\t"
		    "beq   $7,$0,1f\n\t"
		    "li    $2,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "0" (SYS_munmap), "r" (addr), "r" (len)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d199 13
a211 12
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "move  $6,%4\n\t"
                    "syscall"
                    : "=r" (status)
                    : "0" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d216 12
a227 11
{ 
  register int status __asm__ ("$2");
  __asm__ volatile ("move  $4,%2\n\t"
                    "move  $5,%3\n\t"
                    "syscall"
                    : "=r" (status)
                    : "0" (SYS_stat), "r" (addr), "r" (sb)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  return status;
} 
d231 4
a234 3
/* Not an actual syscall, but we need something in assembly to say
   whether this is OK or not.  */

d238 1
a238 1
  unsigned int uid, euid, gid, egid;
d240 16
a255 16
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (uid) : "r" (SYS_getuid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (euid) : "r" (SYS_geteuid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (gid) : "r" (SYS_getgid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
  __asm__ volatile ("move $2,%1; syscall; move %0,$2"
                    : "=r" (egid) : "r" (SYS_getegid)
                    : "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9",
		     "$10","$11","$12","$13","$14","$15","$24","$25");
d257 1
a257 1
  	return (uid == euid && gid == egid);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 2
d248 1
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@
