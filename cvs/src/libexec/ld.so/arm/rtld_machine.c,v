head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.12
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.8
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.24;
commitid	veGB6uLWx3BTEAfk;

1.24
date	2017.01.23.10.30.58;	author guenther;	state Exp;
branches;
next	1.23;
commitid	gelJDihLmdyfb63O;

1.23
date	2016.06.21.15.25.37;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	lRIiUPnkIQNjSTol;

1.22
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.21;
commitid	zGFWeGZdYJxUOZli;

1.21
date	2015.11.02.06.06.07;	author guenther;	state Exp;
branches;
next	1.20;
commitid	QI00fp028yyfkXPi;

1.20
date	2015.09.12.16.07.56;	author guenther;	state Exp;
branches;
next	1.19;
commitid	7YyOQ0cGgcty3RLm;

1.19
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.24.15.47.47;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.23.21.22.09;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.21.23.12.10;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.16.23.19.42;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.25.21.42.48;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.09.21.09.31;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.02.33.48;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.07.06.00.49;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.25
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.24 2017/01/23 10:30:58 guenther Exp $ */

/*
 * Copyright (c) 2004 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

void _dl_bind_start(void); /* XXX */
Elf_Addr _dl_bind(elf_object_t *object, int reloff);
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_U		0x04000000		/* Unaligned */
#define _RF_E		0x02000000		/* ERROR */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,						/*  0 NONE */
	_RF_S|_RF_P|_RF_A|	_RF_SZ(32) | _RF_RS(0),	/*  1 PC24 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),	/*  2 ABS32 */
	_RF_S|_RF_P|_RF_A|	_RF_SZ(32) | _RF_RS(0),	/*  3 REL32 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/*  4 REL13 */
	_RF_S|_RF_A|		_RF_E,			/*  5 ABS16 */
	_RF_S|_RF_A|		_RF_E,			/*  6 ABS12 */
	_RF_S|_RF_A|		_RF_E,			/*  7 T_ABS5 */
	_RF_S|_RF_A|		_RF_E,			/*  8 ABS8 */
	_RF_S|_RF_B|_RF_A|	_RF_E,			/*  9 SBREL32 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/* 10 T_PC22 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/* 11 T_PC8 */
	_RF_E,						/* 12 Reserved */
	_RF_S|_RF_A|		_RF_E,			/* 13 SWI24 */
	_RF_S|_RF_A|		_RF_E,			/* 14 T_SWI8 */
	_RF_E,						/* 15 OBSL */
	_RF_E,						/* 16 OBSL */
	_RF_E,						/* 17 UNUSED */
	_RF_E,						/* 18 UNUSED */
	_RF_E,						/* 19 UNUSED */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 20 COPY */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),	/* 21 GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 22 JUMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(32) | _RF_RS(0),	/* 23 RELATIVE */
	_RF_E,						/* 24 GOTOFF */
	_RF_E,						/* 25 GOTPC */
	_RF_E,						/* 26 GOT32 */
	_RF_E,						/* 27 PLT32 */
	_RF_E,						/* 28 UNUSED */
	_RF_E,						/* 29 UNUSED */
	_RF_E,						/* 30 UNUSED */
	_RF_E,						/* 31 UNUSED */
	_RF_E,						/* 32 A_PCR 0 */
	_RF_E,						/* 33 A_PCR 8 */
	_RF_E,						/* 34 A_PCR 16 */
	_RF_E,						/* 35 B_PCR 0 */
	_RF_E,						/* 36 B_PCR 12 */
	_RF_E,						/* 37 B_PCR 20 */
	_RF_E,						/* 38 RELAB32 */
	_RF_E,						/* 39 ROSGREL32 */
	_RF_E,						/* 40 V4BX */
	_RF_E,						/* 41 STKCHK */
	_RF_E						/* 42 TSTKCHK */
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
#define RELOC_UNALIGNED(t)		((reloc_target_flags[t] & _RF_U) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)
static int reloc_target_bitmask[] = {
#define _BM(x)  (x == 32? ~0 : ~(-(1UL << (x))))
	_BM(0),		/*  0 NONE */
	_BM(24),	/*  1 PC24 */
	_BM(32),	/*  2 ABS32 */
	_BM(32),	/*  3 REL32 */
	_BM(0),		/*  4 REL13 */
	_BM(0),		/*  5 ABS16 */
	_BM(0),		/*  6 ABS12 */
	_BM(0),		/*  7 T_ABS5 */
	_BM(0),		/*  8 ABS8 */
	_BM(32),	/*  9 SBREL32 */
	_BM(0),		/* 10 T_PC22 */
	_BM(0),		/* 11 T_PC8 */
	_BM(0),		/* 12 Reserved */
	_BM(0),		/* 13 SWI24 */
	_BM(0),		/* 14 T_SWI8 */
	_BM(0),		/* 15 OBSL */
	_BM(0),		/* 16 OBSL */
	_BM(0),		/* 17 UNUSED */
	_BM(0),		/* 18 UNUSED */
	_BM(0),		/* 19 UNUSED */
	_BM(32),	/* 20 COPY */
	_BM(32),	/* 21 GLOB_DAT */
	_BM(32),	/* 22 JUMP_SLOT */
	_BM(32),	/* 23 RELATIVE */
	_BM(0),		/* 24 GOTOFF */
	_BM(0),		/* 25 GOTPC */
	_BM(0),		/* 26 GOT32 */
	_BM(0),		/* 27 PLT32 */
	_BM(0),		/* 28 UNUSED */
	_BM(0),		/* 29 UNUSED */
	_BM(0),		/* 30 UNUSED */
	_BM(0),		/* 31 UNUSED */
	_BM(0),		/* 32 A_PCR 0 */
	_BM(0),		/* 33 A_PCR 8 */
	_BM(0),		/* 34 A_PCR 16 */
	_BM(0),		/* 35 B_PCR 0 */
	_BM(0),		/* 36 B_PCR 12 */
	_BM(0),		/* 37 B_PCR 20 */
	_BM(0),		/* 38 RELAB32 */
	_BM(0),		/* 39 ROSGREL32 */
	_BM(0),		/* 40 V4BX */
	_BM(0),		/* 41 STKCHK */
	_BM(0)		/* 42 TSTKCHK */
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

#define R_TYPE(x) R_ARM_ ## x

void _dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_Rel *rel);

int
_dl_md_reloc(elf_object_t *object, int rel, int relsz)
{
	long	i;
	long	numrel;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_Rel *rels;
	struct load_list *llist;

	loff = object->obj_base;
	numrel = object->Dyn.info[relsz] / sizeof(Elf_Rel);
	relrel = rel == DT_REL ? object->relcount : 0;
	rels = (Elf_Rel *)(object->Dyn.info[rel]);

	if (rels == NULL)
		return(0);

	if (relrel > numrel)
		_dl_die("relcount > numrel: %ld > %ld", relrel, numrel);

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list;
		    llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, rels++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELCOUNT wrong");
#endif
		where = (Elf_Addr *)(rels->r_offset + loff);
		*where += loff;
	}
	for (; i < numrel; i++, rels++) {
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(rels->r_info);

		if (reloc_target_flags[type] & _RF_E)
			_dl_die("bad relocation %ld %d", i, type);
		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JUMP_SLOT) && rel != DT_JMPREL)
			continue;

		where = (Elf_Addr *)(rels->r_offset + loff);

		if (RELOC_USE_ADDEND(type))
#ifdef LDSO_ARCH_IS_RELA_
			value = rels->r_addend;
#else
			value = *where & RELOC_VALUE_BITMASK(type);
#endif
		else
			value = 0;

		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(rels->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JUMP_SLOT)) ?
					SYM_PLT : SYM_NOTPLT),
				    sym, NULL);
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(JUMP_SLOT)) {
			/*
			_dl_reloc_plt((Elf_Word *)where, value, rels);
			*/
			*where = value;
			continue;
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    dstsym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, dstsym->st_size);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;
		if (RELOC_BASE_RELATIVE(type))
			value += loff;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		if (RELOC_UNALIGNED(type)) {
			/* Handle unaligned relocations. */
			Elf_Addr tmp = 0;
			char *ptr = (char *)where;
			int i, size = RELOC_TARGET_SIZE(type)/8;

			/* Read it in one byte at a time. */
			for (i=0; i<size; i++)
				tmp = (tmp << 8) | ptr[i];

			tmp &= ~mask;
			tmp |= value;

			/* Write it back out. */
			for (i=0; i<size; i++)
				ptr[i] = ((tmp >> (8*i)) & 0xff);
		} else {
			*where &= ~mask;
			*where |= value;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list;
		    llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

/*
 *	Relocate the Global Offset Table (GOT).
 *	This is done by calling _dl_md_reloc on DT_JMPREL for DL_BIND_NOW,
 *	otherwise the lazy binding plt initialization is performed.
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	int i, num;
	Elf_Rel *rel;

	if (object->Dyn.info[DT_PLTREL] != DT_REL)
		return (0);

	if (object->traced)
		lazy = 1;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);
		num = (object->Dyn.info[DT_PLTRELSZ]);

		for (i = 0; i < num/sizeof(Elf_Rel); i++, rel++) {
			Elf_Addr *where;
			where = (Elf_Addr *)(rel->r_offset + object->obj_base);
			*where += object->obj_base;
		}

		pltgot[1] = (Elf_Addr)object;
		pltgot[2] = (Elf_Addr)_dl_bind_start;
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	return (fails);
}

Elf_Addr
_dl_bind(elf_object_t *object, int relidx)
{
	Elf_Rel *rel;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr ooff;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Word newval;
	} buf;

	rel = ((Elf_Rel *)object->Dyn.info[DT_JMPREL]) + (relidx);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rel->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn,  &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
	buf.param.kb_size = sizeof(Elf_Word);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("r12") = SYS_kbind;
		register void *arg1 __asm("r0") = &buf;
		register long  arg2 __asm("r1") = sizeof(buf);
		register long  arg3 __asm("r2") = 0xffffffff &  cookie;
		register long  arg4 __asm("r3") = 0xffffffff & (cookie >> 32);

		__asm volatile("swi 0" : "+r" (arg1), "+r" (arg2)
		    : "r" (syscall_num), "r" (arg3), "r" (arg4)
		    : "cc", "memory");
	}

	return (buf.newval);
}
@


1.24
log
@Fix format string mismatches
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2016/06/21 15:25:37 deraadt Exp $ */
d183 2
a184 4
	if (relrel > numrel) {
		_dl_printf("relcount > numrel: %ld > %ld\n", relrel, numrel);
		_dl_exit(20);
	}
d204 2
a205 4
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELCOUNT wrong\n");
			_dl_exit(20);
		}
d218 2
a219 4
		if (reloc_target_flags[type] & _RF_E) {
			_dl_printf(" bad relocation %ld %d\n", i, type);
			_dl_exit(1);
		}
d404 2
a405 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.23
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2015/11/02 07:02:53 guenther Exp $ */
d223 1
a223 1
			_dl_printf(" bad relocation %d %d\n", i, type);
@


1.22
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2015/11/02 06:06:07 guenther Exp $ */
d197 1
a197 1
				    llist->prot|PROT_WRITE);
@


1.21
log
@Fix typo: s/DT_JUMPREL/DT_JMPREL/
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2015/09/12 16:07:56 guenther Exp $ */
a355 2
	Elf_Addr ooff;
	const Elf_Sym *this;
a361 25
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	object->plt_size = 0;	/* Text PLT on ARM */

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	object->plt_start = 0;

d380 3
a382 6
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
@


1.20
log
@Use kbind for lazy binding GOT/PLT updates on arm.
While here add some gcc __predict hints.

Much testing, discussion, pondering, and flailing from miod and deraadt
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2013/06/13 04:13:47 brad Exp $ */
d348 1
a348 1
 *	This is done by calling _dl_md_reloc on DT_JUMPREL for DL_BIND_NOW,
@


1.19
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2013/06/01 09:57:58 miod Exp $ */
d33 2
a37 1
#include <signal.h>
d43 2
a420 1
	Elf_Word *addr;
d424 6
a429 2
	Elf_Addr ooff, newval;
	sigset_t savedmask;
d445 1
a445 2
	addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
	newval = ooff + this->st_value;
d447 2
a448 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return newval;
d450 14
a463 5
	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ|PROT_WRITE);
d466 1
a466 10
	if (*addr != newval)
		*addr = newval;

	/* put the GOT back to RO */
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
	}
	return newval;
@


1.18
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2013/05/08 20:55:14 guenther Exp $ */
d436 1
a436 1
		*((int *)0) = 0;	/* XXX */
@


1.17
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2011/04/06 11:36:25 miod Exp $ */
d386 3
d421 1
d433 1
a433 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d441 3
@


1.16
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2010/05/02 04:57:01 guenther Exp $ */
d164 1
d167 2
d174 1
d180 5
d198 14
a211 1
	for (i = 0; i < numrel; i++, rels++) {
d250 2
d267 3
a269 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.15
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2008/04/09 21:45:26 kurt Exp $ */
d335 1
a335 1
	object->got_addr = NULL;
d351 2
a352 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d358 1
a358 1
	object->plt_start = NULL;
@


1.14
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2008/02/24 15:47:47 drahn Exp $ */
d393 1
a393 1
	sigset_t omask, nmask;
d415 1
a415 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d427 1
a427 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.13
log
@Use rounded down address when changing memory protections on the GOT, such
that we don't accidentally touch the page after the GOT.

Bug found on sparc64 affected other platforms as well.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2007/11/27 16:42:19 miod Exp $ */
d169 1
a169 1
	loff = object->load_offs;
d368 2
a369 2
			where = (Elf_Addr *)(rel->r_offset + object->load_offs);
			*where += object->load_offs;
d410 1
a410 1
	addr = (Elf_Addr *)(object->load_offs + rel->r_offset);
@


1.12
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2007/05/05 15:21:21 drahn Exp $ */
d376 1
a376 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.11
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2006/08/23 21:22:09 drahn Exp $ */
d164 1
a164 1
	long	fails = 0;
d322 1
a322 1
void
d325 1
d333 1
a333 1
		return;
d361 1
a361 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d381 2
@


1.10
log
@Support arm libraries with DT_TEXTREL, has no affect for other libraries.
ok kettenis, 'in then' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2005/09/22 01:33:08 drahn Exp $ */
d414 1
d426 1
@


1.9
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2005/09/21 23:12:10 drahn Exp $ */
a158 3
/*
#define LD_ALLOW_WRITEABLE_TEXT
*/
a166 1
#ifdef LD_ALLOW_WRITEABLE_TEXT
a167 1
#endif
a175 1
#ifdef LD_ALLOW_WRITEABLE_TEXT
d179 1
a179 1
	if ((rel == DT_REL || rel == DT_RELA)) {
a187 1
#endif
a302 1
#ifdef LD_ALLOW_WRITEABLE_TEXT
d304 1
a304 1
	if ((rel == DT_REL || rel == DT_RELA)) {
a312 1
#endif
@


1.8
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2005/09/16 23:19:42 drahn Exp $ */
d245 3
a247 5
					_dl_printf("%s: %s: can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);
					fails++;
@


1.7
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2004/05/25 21:42:48 mickey Exp $ */
d242 1
a242 1
				    sym->st_size, NULL);
a267 1
			size_t size = dstsym->st_size;
d272 1
a272 1
			    size, object, NULL);
d277 1
a277 1
			_dl_bcopy(srcaddr, dstaddr, size);
d349 1
a349 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d355 1
a355 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d409 1
d411 1
a411 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
@


1.6
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2004/05/25 18:07:20 mickey Exp $ */
d238 1
a238 2
				    ELF_R_SYM(rels->r_info),
				    _dl_objects, &this, NULL,
d242 1
a242 1
				    sym->st_size);
d271 3
a273 3
			soff = _dl_find_symbol(symn, object->next, &srcsym,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    size, object);
d349 3
a351 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d356 3
a358 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d412 3
a414 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
@


1.5
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2004/05/25 15:56:18 deraadt Exp $ */
a153 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	unsigned const char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2004/02/09 21:09:31 drahn Exp $ */
d250 1
a250 1
				    _dl_objects, &this,
d284 1
a284 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
d361 1
a361 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d367 1
a367 1
	ooff = _dl_find_symbol("__got_end", object, &this,
d422 1
a422 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
@


1.3
log
@Enable lazy binding on arm:
  _dl_bind_start inspired by netbsd.
  changed a define to LD_ALLOW_WRITABLE_TEXT, should this be allowed?
  remove plt protect code, arm has a text PLT.
  relocate the got entries associated with the plt.
  perform got protect/unprotect for lazy binding updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2004/02/09 02:33:48 drahn Exp $ */
d66 1
a66 1
	_RF_E,			 			/* 12 Reserved */
d69 5
a73 5
	_RF_E,			 			/* 15 OBSL */
	_RF_E,			 			/* 16 OBSL */
	_RF_E,			 			/* 17 UNUSED */
	_RF_E,			 			/* 18 UNUSED */
	_RF_E,			 			/* 19 UNUSED */
d78 19
a96 19
	_RF_E,			 			/* 24 GOTOFF */
	_RF_E,			 			/* 25 GOTPC */
	_RF_E,			 			/* 26 GOT32 */
	_RF_E,			 			/* 27 PLT32 */
	_RF_E,			 			/* 28 UNUSED */
	_RF_E,			 			/* 29 UNUSED */
	_RF_E,			 			/* 30 UNUSED */
	_RF_E,			 			/* 31 UNUSED */
	_RF_E,			 			/* 32 A_PCR 0 */
	_RF_E,			 			/* 33 A_PCR 8 */
	_RF_E,			 			/* 34 A_PCR 16 */
	_RF_E,			 			/* 35 B_PCR 0 */
	_RF_E,			 			/* 36 B_PCR 12 */
	_RF_E,			 			/* 37 B_PCR 20 */
	_RF_E,			 			/* 38 RELAB32 */
	_RF_E,			 			/* 39 ROSGREL32 */
	_RF_E,			 			/* 40 V4BX */
	_RF_E,			 			/* 41 STKCHK */
	_RF_E			 			/* 42 TSTKCHK */
d215 1
a215 1
		if (reloc_target_flags[type] & _RF_E) { 
d442 1
a442 1
		
@


1.2
log
@Disable lazy binding until that feature is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2004/02/07 06:00:49 drahn Exp $ */
d170 3
a172 1
#define LD_PROTECT_TEXT
d181 1
a181 1
#ifndef LD_PROTECT_TEXT
d192 1
a192 1
#ifndef LD_PROTECT_TEXT
d197 3
a199 1
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
d325 1
a325 1
#ifndef LD_PROTECT_TEXT
d328 3
a330 1
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
d336 1
a336 1
	#endif
a348 2
#define DISABLE_LAZY
#ifndef DISABLE_LAZY
a349 1
#endif
a350 1
	Elf_Addr plt_addr;
d352 2
d372 1
a372 7
	plt_addr = 0;
	object->plt_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", object, &this,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
	if (this != NULL)
		plt_addr = ooff + this->st_value;
a380 1
#if 1
a381 9
#else
	if (plt_addr == NULL)
		object->plt_start = NULL;
	else {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
	}
#endif
a382 2
#define DISABLE_LAZY
#ifndef DISABLE_LAZY
a383 1
#endif
a384 1
#ifndef DISABLE_LAZY
d386 9
a397 1
#endif
d407 1
a407 1
_dl_bind(elf_object_t *object, int reloff)
d409 2
a411 1
	Elf_Addr *r_addr, ooff, newval;
d413 2
a414 1
	Elf_Rel *rels;
d416 1
a416 1
	rels = ((Elf_Rel *)object->Dyn.info[DT_JMPREL]) + (reloff>>2);
d419 1
a419 1
	sym += ELF_R_SYM(rels->r_info);
d429 1
a429 1
	r_addr = (Elf_Addr *)(object->load_offs + rels->r_offset);
d432 10
a441 2
	if (*r_addr != newval)
		*r_addr = newval;
d443 6
a450 1

@


1.1
log
@Dynamic linker support for arm. non-lazy binding works.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2004/01/18 22:02:08 drahn Exp $ */
d343 2
d346 1
d395 2
d398 1
d400 1
d405 1
@

