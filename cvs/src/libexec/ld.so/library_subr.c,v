head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.2
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.4
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.6
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.47
date	2017.01.24.07.48.36;	author guenther;	state Exp;
branches;
next	1.46;
commitid	veGB6uLWx3BTEAfk;

1.46
date	2017.01.22.01.20.36;	author guenther;	state Exp;
branches;
next	1.45;
commitid	uadpoy0GKiB9Exf8;

1.45
date	2016.01.24.03.54.34;	author guenther;	state Exp;
branches;
next	1.44;
commitid	dUhNJfxOdkXUgGnA;

1.44
date	2015.06.10.21.16.41;	author sthen;	state Exp;
branches;
next	1.43;
commitid	MZbEWxiG4hi5GVPO;

1.43
date	2015.06.10.20.50.05;	author miod;	state Exp;
branches;
next	1.42;
commitid	MQR5kHnk6hKSfZ87;

1.42
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	31KwZ9PARAKUg1ob;

1.41
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.40;
commitid	ImRWDrCXNlhODvC7;

1.40
date	2014.07.06.17.33.10;	author otto;	state Exp;
branches;
next	1.39;
commitid	Todo1ZT3AnVz3T5r;

1.39
date	2013.12.03.01.47.05;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.13.05.41.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.20.21.49.59;	author kurt;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.21.04.28.45;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.13.20.49.44;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.16.18.59.00;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.01.19.25.44;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.09.09.53.28;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.01.07.46.30;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.11.15.30.16;	author kurt;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.08.20.37.01;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.08.20.34.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.15.02.14.47;	author kurt;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.02.15.25.00;	author kurt;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.21.15.24.10;	author kurt;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.09.04.37.13;	author kurt;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.07.01.26.34;	author kurt;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.05.21.50.53;	author kurt;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.01.19.32.22;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.28.20.48.00;	author kurt;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.28.18.17.41;	author kurt;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.28.15.41.06;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.22.04.07.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.19.02.31.04;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.17.04.15.23;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.17.02.52.43;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.23.19.22.11;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.23.19.48.05;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.47
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: library_subr.c,v 1.46 2017/01/22 01:20:36 guenther Exp $ */

/*
 * Copyright (c) 2002 Dale Rahn
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/queue.h>
#include <limits.h>
#include <dirent.h>

#include "archdep.h"
#include "resolve.h"
#include "dir.h"
#include "sod.h"

char * _dl_default_path[2] = { "/usr/lib", NULL };


/* STATIC DATA */
struct dlochld _dlopened_child_list;


/*
 * _dl_match_file()
 *
 * This function determines if a given name matches what is specified
 * in a struct sod. The major must match exactly, and the minor must
 * be same or larger.
 *
 * sodp is updated with the minor if this matches.
 */

int
_dl_match_file(struct sod *sodp, const char *name, int namelen)
{
	int match;
	struct sod lsod;
	const char *lname;

	lname = name;
	if (sodp->sod_library) {
		if (_dl_strncmp(name, "lib", 3))
			return 0;
		lname += 3;
	}
	if (_dl_strncmp(lname, (char *)sodp->sod_name,
	    _dl_strlen((char *)sodp->sod_name)))
		return 0;

	_dl_build_sod(name, &lsod);

	match = 0;
	if ((_dl_strcmp((char *)lsod.sod_name, (char *)sodp->sod_name) == 0) &&
	    (lsod.sod_library == sodp->sod_library) &&
	    ((sodp->sod_major == -1) || (sodp->sod_major == lsod.sod_major)) &&
	    ((sodp->sod_minor == -1) ||
	    (lsod.sod_minor >= sodp->sod_minor))) {
		match = 1;

		/* return version matched */
		sodp->sod_major = lsod.sod_major;
		sodp->sod_minor = lsod.sod_minor;
	}
	_dl_free((char *)lsod.sod_name);
	return match;
}

/*
 * _dl_cmp_sod()
 *
 * This function compares sod structs. The major must match exactly,
 * and the minor must be same or larger.
 *
 * sodp is updated with the minor if this matches.
 */

static int
_dl_cmp_sod(struct sod *sodp, const struct sod *lsod)
{
	int match;

	match = 1;
	if ((_dl_strcmp((char *)lsod->sod_name, (char *)sodp->sod_name) == 0) &&
	    (lsod->sod_library == sodp->sod_library) &&
	    ((sodp->sod_major == -1) || (sodp->sod_major == lsod->sod_major)) &&
	    ((sodp->sod_minor == -1) ||
	    (lsod->sod_minor >= sodp->sod_minor))) {
		match = 0;

		/* return version matched */
		sodp->sod_major = lsod->sod_major;
		sodp->sod_minor = lsod->sod_minor;
	}
	return match;
}

char _dl_hint_store[PATH_MAX];

char *
_dl_find_shlib(struct sod *sodp, char **searchpath, int nohints)
{
	char *hint, **pp;
	struct dirent *dp;
	int match, len;
	_dl_DIR *dd;
	struct sod tsod, bsod;		/* transient and best sod */

	/* if we are to search default directories, and hints
	 * are not to be used, search the standard path from ldconfig
	 * (_dl_hint_search_path) or use the default path
	 */
	if (nohints)
		goto nohints;

	if (searchpath == NULL) {
		/* search 'standard' locations, find any match in the hints */
		hint = _dl_findhint((char *)sodp->sod_name, sodp->sod_major,
		    sodp->sod_minor, NULL);
		if (hint)
			return hint;
	} else {
		/* search hints requesting matches for only
		 * the searchpath directories,
		 */
		for (pp = searchpath; *pp != NULL; pp++) {
			hint = _dl_findhint((char *)sodp->sod_name,
			    sodp->sod_major, sodp->sod_minor, *pp);
			if (hint != NULL)
				return hint;
		}
	}

	/*
	 * For each directory in the searchpath, read the directory
	 * entries looking for a match to sod. filename compare is
	 * done by _dl_match_file()
	 */
nohints:
	if (searchpath == NULL) {
		if (_dl_hint_search_path != NULL)
			searchpath = _dl_hint_search_path;
		else
			searchpath = _dl_default_path;
	}
	_dl_memset(&bsod, 0, sizeof(bsod));
	for (pp = searchpath; *pp != NULL; pp++) {
		if ((dd = _dl_opendir(*pp)) != NULL) {
			match = 0;
			while ((dp = _dl_readdir(dd)) != NULL) {
				tsod = *sodp;
				if (_dl_match_file(&tsod, dp->d_name,
				    dp->d_namlen)) {
					/*
					 * When a match is found, tsod is
					 * updated with the major+minor found.
					 * This version is compared with the
					 * largest so far (kept in bsod),
					 * and saved if larger.
					 */
					if (!match ||
					    tsod.sod_major == -1 ||
					    tsod.sod_major > bsod.sod_major ||
					    ((tsod.sod_major ==
					    bsod.sod_major) &&
					    tsod.sod_minor > bsod.sod_minor)) {
						bsod = tsod;
						match = 1;
						len = _dl_strlcpy(
						    _dl_hint_store, *pp,
						    PATH_MAX);
						if (pp[0][len-1] != '/') {
							_dl_hint_store[len] =
							    '/';
							len++;
						}
						_dl_strlcpy(
						    &_dl_hint_store[len],
						    dp->d_name,
						    PATH_MAX-len);
						if (tsod.sod_major == -1)
							break;
					}
				}
			}
			_dl_closedir(dd);
			if (match) {
				*sodp = bsod;
				return (_dl_hint_store);
			}
		}
	}
	return NULL;
}

static elf_object_t *
_dl_lookup_object(const char *req_name, struct sod *req_sod)
{
	elf_object_t *object = _dl_objects;

	while (object) {
		char *soname;

		if (_dl_cmp_sod(req_sod, &object->sod) == 0)
			return(object);

		soname = (char *)object->Dyn.info[DT_SONAME];
		if (soname != NULL) {
			if (_dl_strcmp(req_name, soname) == 0)
				return(object);
		}

		object = object->next;
	}

	return(NULL);
}

static elf_object_t *
_dl_find_loaded_shlib(const char *req_name, struct sod req_sod, int flags)
{
	elf_object_t *object;

	object = _dl_lookup_object(req_name, &req_sod);

	/* if not found retry with any minor */
	if (object == NULL && req_sod.sod_library && req_sod.sod_minor != -1) {
		short orig_minor = req_sod.sod_minor;
		req_sod.sod_minor = -1;
		object = _dl_lookup_object(req_name, &req_sod);

		if (object != NULL && req_sod.sod_minor < orig_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    req_sod.sod_name, req_sod.sod_major,
			    req_sod.sod_minor, orig_minor);
	}

	if (object) {	/* Already loaded */
		object->obj_flags |= flags & DF_1_GLOBAL;
		if (_dl_loading_object == NULL)
			_dl_loading_object = object;
		if (object->load_object != _dl_objects &&
		    object->load_object != _dl_loading_object) {
			_dl_link_grpref(object->load_object, _dl_loading_object);
		}
	}

	return (object);
}

/*
 *  Load a shared object. Search order is:
 *      First check loaded objects for a matching shlib, otherwise:
 *
 *	If the name contains a '/' use only the path preceding the
 *	library name and do not continue on to other methods if not
 *	found.
 *	   search hints for match in path preceding library name
 *	     this will only match specific library version.
 *	   search path preceding library name
 *	     this will find largest minor version in path provided
 *
 *	Otherwise, the name doesn't contain a '/':
 *	search hints for the specific library version, trying in turn
 *	paths from the following:
 *	  - the LD_LIBRARY_PATH environment variable (if set)
 *	  - the library's own DT_RUNPATH
 *	  - if DT_RUNPATH wasn't set, then:
 *	    - the library's own DT_RPATH
 *	    - the executable's own DT_RPATH
 *	  - the default search path set by ldconfig, or /usr/lib if unset
 *
 *	If the hints doesn't have an exact match, then we search
 *	that exact same list of directories again, looking for a
 *	lib with the correct major version.  If we find a match on
 *	the major, then we take the match *in that directory* which
 *	has the largest minor version
 */

elf_object_t *
_dl_load_shlib(const char *libname, elf_object_t *parent, int type, int flags)
{
	int try_any_minor, ignore_hints;
	struct sod sod, req_sod;
	elf_object_t *object = NULL;
	char *hint;

	try_any_minor = 0;
	ignore_hints = 0;

	if (_dl_strchr(libname, '/')) {
		char *paths[2];
		char *lpath, *lname;
		lpath = _dl_strdup(libname);
		if (lpath == NULL)
			_dl_oom();
		lname = _dl_strrchr(lpath, '/');
		if (lname == NULL) {
			_dl_free(lpath);
			_dl_errno = DL_NOT_FOUND;
			return (object);
		}
		*lname = '\0';
		lname++;
		if (*lname  == '\0') {
			_dl_free(lpath);
			_dl_errno = DL_NOT_FOUND;
			return (object);
		}

		_dl_build_sod(lname, &sod);
		req_sod = sod;

		paths[0] = lpath;
		paths[1] = NULL;
fullpathagain:
		hint = _dl_find_shlib(&req_sod, paths, ignore_hints);
		if (hint != NULL)
			goto fullpathdone;

		if (try_any_minor == 0) {
			try_any_minor = 1;
			ignore_hints = 1;
			req_sod.sod_minor = -1;
			goto fullpathagain;
		}
		_dl_errno = DL_NOT_FOUND;
fullpathdone:
		_dl_free(lpath);
		goto done;
	}

	_dl_build_sod(libname, &sod);
	req_sod = sod;

	object = _dl_find_loaded_shlib(libname, req_sod, flags);
	if (object) {
		_dl_free((char *)sod.sod_name);
		return (object);
	}

again:
	/* No '/' in name. Scan the known places, LD_LIBRARY_PATH first.  */
	if (_dl_libpath != NULL) {
		hint = _dl_find_shlib(&req_sod, _dl_libpath, ignore_hints);
		if (hint != NULL)
			goto done;
	}

	/* Check DT_RUNPATH */
	if (parent->runpath != NULL) {
		hint = _dl_find_shlib(&req_sod, parent->runpath, ignore_hints);
		if (hint != NULL)
			goto done;
	} else {
		/* 
		 * If DT_RUNPATH wasn't set then first check DT_RPATH,
		 * followed by the main program's DT_RPATH.
		 */
		if (parent->rpath != NULL) {
			hint = _dl_find_shlib(&req_sod, parent->rpath,
			    ignore_hints);
			if (hint != NULL)
				goto done;
		}
		if (parent != _dl_objects && _dl_objects->rpath != NULL) {
			hint = _dl_find_shlib(&req_sod, _dl_objects->rpath,
			    ignore_hints);
			if (hint != NULL)
				goto done;
		}
	}

	/* check 'standard' locations */
	hint = _dl_find_shlib(&req_sod, NULL, ignore_hints);
	if (hint != NULL)
		goto done;

	if (try_any_minor == 0) {
		try_any_minor = 1;
		ignore_hints = 1;
		req_sod.sod_minor = -1;
		goto again;
	}
	_dl_errno = DL_NOT_FOUND;
done:
	if (hint != NULL) {
		if (req_sod.sod_minor < sod.sod_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    sod.sod_name, sod.sod_major,
			    req_sod.sod_minor, sod.sod_minor);
		object = _dl_tryload_shlib(hint, type, flags);
	}
	_dl_free((char *)sod.sod_name);
	return(object);
}


void
_dl_link_dlopen(elf_object_t *dep)
{
	struct dep_node *n;

	dep->opencount++;

	if (OBJECT_DLREF_CNT(dep) > 1)
		return;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_oom();

	n->data = dep;
	TAILQ_INSERT_TAIL(&_dlopened_child_list, n, next_sib);

	DL_DEB(("linking %s as dlopen()ed\n", dep->load_name));
}

static void
_dl_child_refcnt_decrement(elf_object_t *object)
{
	struct dep_node *n;

	object->refcount--;
	if (OBJECT_REF_CNT(object) == 0)
		TAILQ_FOREACH(n, &object->child_list, next_sib)
			_dl_child_refcnt_decrement(n->data);
}

void
_dl_notify_unload_shlib(elf_object_t *object)
{
	struct dep_node *n;

	if (OBJECT_REF_CNT(object) == 0)
		TAILQ_FOREACH(n, &object->child_list, next_sib)
			_dl_child_refcnt_decrement(n->data);

	if (OBJECT_DLREF_CNT(object) == 0) {
		while ((n = TAILQ_FIRST(&object->grpref_list)) != NULL) {
			TAILQ_REMOVE(&object->grpref_list, n, next_sib);
			n->data->grprefcount--;
			_dl_notify_unload_shlib(n->data);
			_dl_free(n);
		}
	}
}

void
_dl_unload_dlopen(void)
{
	struct dep_node *node;

	TAILQ_FOREACH_REVERSE(node, &_dlopened_child_list, dlochld, next_sib) {
		/* dont dlclose the main program */
		if (node->data == _dl_objects)
			continue;

		while (node->data->opencount > 0) {
			node->data->opencount--;
			_dl_notify_unload_shlib(node->data);
			_dl_run_all_dtors();
		}
	}
}

void
_dl_link_grpref(elf_object_t *load_group, elf_object_t *load_object)
{
	struct dep_node *n;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_oom();
	n->data = load_group;
	TAILQ_INSERT_TAIL(&load_object->grpref_list, n, next_sib);
	load_group->grprefcount++;
}

void
_dl_link_child(elf_object_t *dep, elf_object_t *p)
{
	struct dep_node *n;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_oom();
	n->data = dep;
	TAILQ_INSERT_TAIL(&p->child_list, n, next_sib);

	dep->refcount++;

	DL_DEB(("linking dep %s as child of %s\n", dep->load_name,
	    p->load_name));
}

/* Generation number of the current grpsym insertion/caching */
static unsigned int _dl_grpsym_gen = 0;

void
_dl_link_grpsym(elf_object_t *object, int checklist)
{
	struct dep_node *n;

	if (checklist) {
		TAILQ_FOREACH(n, &_dl_loading_object->grpsym_list, next_sib)
			if (n->data == object)
				return; /* found, dont bother adding */
	} else {
		if (object->grpsym_gen == _dl_grpsym_gen) {
			return; /* found, dont bother adding */
		}
	}
	object->grpsym_gen = _dl_grpsym_gen;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_oom();
	n->data = object;
	TAILQ_INSERT_TAIL(&_dl_loading_object->grpsym_list, n, next_sib);
}

void
_dl_cache_grpsym_list_setup(elf_object_t *object)
{
	_dl_grpsym_gen += 1;

	if (_dl_grpsym_gen == 0) {
		/*
		 * If the count rolls over, reset all counters so
		 * we don't get accidental collision.
		 */
		elf_object_t *walkobj;
		for (walkobj = _dl_objects;
		    walkobj != NULL;
		    walkobj = walkobj->next) {
			walkobj->grpsym_gen = 0;
		}
		_dl_grpsym_gen = 1;
	}
	_dl_cache_grpsym_list(object);
}
void
_dl_cache_grpsym_list(elf_object_t *object)
{
	struct dep_node *n;

	/*
	 * grpsym_list is an ordered list of all child libs of the
	 * _dl_loading_object with no dups. The order is equivalent
	 * to a breadth-first traversal of the child list without dups.
	 */

	TAILQ_FOREACH(n, &object->child_list, next_sib)
		_dl_link_grpsym(n->data, 0);

	TAILQ_FOREACH(n, &object->child_list, next_sib)
		_dl_cache_grpsym_list(n->data);
}
@


1.46
log
@Add support for DT_RUNPATH and DT_FLAGS

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.45 2016/01/24 03:54:34 guenther Exp $ */
d323 1
a323 1
			_dl_exit(5);
d440 1
a440 1
		_dl_exit(5);
d503 1
a503 1
		_dl_exit(7);
d516 1
a516 1
		_dl_exit(7);
d547 1
a547 1
		_dl_exit(8);
@


1.45
log
@Delete remnants of grpsym cache setting during symbol search: it's done at
load time only nwo.  Rename _dl_searchnum and lastlookup to _dl_grpsym_gen
and grpsym_gen as they are generation numbers.  Merge _dl_newsymsearch()
into _dl_cache_grpsym_list_setup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.44 2015/06/10 21:16:41 sthen Exp $ */
d289 16
a304 12
 *	try the LD_LIBRARY_PATH specification (if present)
 *	   search hints for match in LD_LIBRARY_PATH dirs
 *           this will only match specific library version.
 *	   search LD_LIBRARY_PATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	check DT_RPATH paths, (if present)
 *	   search hints for match in DT_RPATH dirs
 *           this will only match specific library version.
 *	   search DT_RPATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	last look in default search directory, either as specified
 *      by ldconfig or default to '/usr/lib'
a306 1

d377 3
a379 10
	/* Check DT_RPATH.  */
	if (parent->rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, parent->rpath, ignore_hints);
		if (hint != NULL)
			goto done;
	}

	/* Check main program's DT_RPATH, if parent != main program */
	if (parent != _dl_objects && _dl_objects->rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, _dl_objects->rpath, ignore_hints);
d382 17
@


1.44
log
@breath->breadth
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.43 2015/06/10 20:50:05 miod Exp $ */
d513 3
d526 1
a526 1
		if (object->lastlookup == _dl_searchnum) {
d530 1
a530 1
	object->lastlookup = _dl_searchnum;
d542 15
a556 1
	_dl_newsymsearch();
@


1.43
log
@Typos: equalivant, fucntion, libary.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.42 2015/01/16 16:18:07 deraadt Exp $ */
d550 1
a550 1
	 * to a breath-first traversal of the child list without dups.
@


1.42
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.41 2014/07/10 09:03:01 otto Exp $ */
d52 1
a52 1
 * This fucntion determines if a given name matches what is specified
d97 1
a97 1
 * This fucntion compares sod structs. The major must match exactly,
d291 1
a291 1
 *           this will only match specific libary version.
d296 1
a296 1
 *           this will only match specific libary version.
d549 1
a549 1
	 * _dl_loading_object with no dups. The order is equalivant
@


1.41
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.40 2014/07/06 17:33:10 otto Exp $ */
a32 1
#include <sys/param.h>
d123 1
a123 1
char _dl_hint_store[MAXPATHLEN];
d196 1
a196 1
						    MAXPATHLEN);
d205 1
a205 1
						    MAXPATHLEN-len);
@


1.40
log
@enable -Wall, explicitly call _dl_strsep, and zap some redundant includes
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.39 2013/12/03 01:47:05 deraadt Exp $ */
d320 2
@


1.39
log
@stop using sys/syslimits.h directly, and use limits.h
prodded by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.38 2013/11/13 05:41:41 deraadt Exp $ */
a36 1
#include <string.h>
@


1.38
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.37 2013/03/20 21:49:59 kurt Exp $ */
a32 1
#include <sys/syslimits.h>
d35 1
@


1.37
log
@- Parse colon separated paths into NULL terminated arrays of string
pointers to prepare for adding rpath ORIGIN support.
okay matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.36 2012/03/21 04:28:45 matthew Exp $ */
d105 1
a105 1
int
d223 1
a223 1
elf_object_t *
d246 1
a246 1
elf_object_t *
d435 1
a435 1
void
@


1.36
log
@Switch ld.so's _dl_opendir functions to use a locally defined
_dl_dirdesc struct (containing just the fields ld.so's implementation
actually needs) instead of reusing libc's _dirdesc struct.

Also, switch ldconfig to use futimens() instead of futimes().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.35 2011/11/28 20:59:03 guenther Exp $ */
d44 1
a44 1
#define DEFAULT_PATH "/usr/lib"
d128 1
a128 1
_dl_find_shlib(struct sod *sodp, const char *searchpath, int nohints)
d130 1
a130 1
	char *hint, lp[PATH_MAX + 10], *path;
a131 1
	const char *pp;
d153 1
a153 14
		pp = searchpath;
		while (pp) {
			path = lp;
			while (path < lp + PATH_MAX &&
			    *pp && *pp != ':' && *pp != ';')
				*path++ = *pp++;
			*path = 0;

			/* interpret "" as curdir "." */
			if (lp[0] == '\0') {
				lp[0] = '.';
				lp[1] = '\0';
			}

d155 1
a155 1
			    sodp->sod_major, sodp->sod_minor, lp);
a157 5

			if (*pp)	/* Try curdir if ':' at end */
				pp++;
			else
				pp = 0;
d171 1
a171 1
			searchpath = DEFAULT_PATH;
d174 2
a175 14
	pp = searchpath;
	while (pp) {
		path = lp;
		while (path < lp + PATH_MAX && *pp && *pp != ':' && *pp != ';')
			*path++ = *pp++;
		*path = 0;

		/* interpret "" as curdir "." */
		if (lp[0] == '\0') {
			lp[0] = '.';
			lp[1] = '\0';
		}

		if ((dd = _dl_opendir(lp)) != NULL) {
d197 1
a197 1
						    _dl_hint_store, lp,
d199 1
a199 1
						if (lp[len-1] != '/') {
a218 5

		if (*pp)	/* Try curdir if ':' at end */
			pp++;
		else
			pp = 0;
d318 1
d338 2
d341 1
a341 1
		hint = _dl_find_shlib(&req_sod, lpath, ignore_hints);
d375 2
a376 2
	if (parent->dyn.rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, parent->dyn.rpath, ignore_hints);
d382 2
a383 2
	if (parent != _dl_objects && _dl_objects->dyn.rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, _dl_objects->dyn.rpath, ignore_hints);
@


1.35
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.34 2011/07/13 20:49:44 drahn Exp $ */
d134 1
a134 1
	DIR *dd;
@


1.34
log
@Delete items on grpreflist when walking them to decrement the count,
otherwise double decrement can occur. ok kurt@@ timeout on other reviewers.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.33 2010/11/16 18:59:00 drahn Exp $ */
d304 1
a304 1
		object->obj_flags |= flags & RTLD_GLOBAL;
@


1.33
log
@Fix error message when ld.so ends up loading a different than expected
library, but other library needs the one loaded. mostly ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.32 2010/10/25 20:34:44 kurt Exp $ */
d489 2
a490 1
		TAILQ_FOREACH(n, &object->grpref_list, next_sib) {
d493 1
@


1.32
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.31 2010/07/01 19:25:44 drahn Exp $ */
a441 7
		if (object) {
			object->sod = req_sod;
		} else {
			_dl_free((char *)sod.sod_name);
		}
	} else {
		_dl_free((char *)sod.sod_name);
d443 1
@


1.31
log
@When generating grpsym lists, avoid duplicates without searching the
already generated list. Speeds up startup on deeply nested dlopen binaries.
ok guenther@@, tested by ckuethe@@ and ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.30 2010/05/09 09:53:28 matthieu Exp $ */
d62 1
a62 1
_dl_match_file(struct sod *sodp, char *name, int namelen)
d66 1
a66 1
	char *lname;
d96 29
d259 57
d318 2
d393 6
d442 7
a449 1
	_dl_free((char *)sod.sod_name);
@


1.30
log
@use _dl_memset() instead of bzero() here. Unbreaks sparc build.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.29 2010/05/01 07:46:30 jsg Exp $ */
d451 1
a451 1
_dl_link_grpsym(elf_object_t *object)
d455 6
a460 2
	TAILQ_FOREACH(n, &_dl_loading_object->grpsym_list, next_sib)
		if (n->data == object)
d462 3
d474 6
d491 1
a491 1
		_dl_link_grpsym(n->data);
@


1.29
log
@bzero a struct to appease gcc4.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.28 2008/04/11 15:30:16 kurt Exp $ */
d163 1
a163 1
	bzero(&bsod, sizeof(bsod));
@


1.28
log
@Correct a bug where _dl_error was set to DL_NOT_FOUND when a shared lib
was found but failed to load. Adjust _dl_load_shlib() to only attempt to
load the first matching shared lib which allows the correct _dl_error to
propagate out upon load failure.

okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.27 2006/12/23 21:08:01 krw Exp $ */
d37 1
d163 1
@


1.27
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.26 2006/05/08 20:37:01 deraadt Exp $ */
a49 4
/* local functions */
elf_object_t * _dl_load_shlib_hint(struct sod *sod, struct sod *req_sod,
    int type, int flags, int use_hints, const char *libpath);

a228 24
 * attempt to locate and load a library based on libpath, sod info and
 * if it needs to respect hints, passing type and flags to perform open
 */
elf_object_t *
_dl_load_shlib_hint(struct sod *sod, struct sod *req_sod, int type,
    int flags, int use_hints, const char *libpath)
{
	elf_object_t *object = NULL;
	char *hint;

	hint = _dl_find_shlib(req_sod, libpath, use_hints);
	if (hint != NULL) {
		if (req_sod->sod_minor < sod->sod_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    sod->sod_name, sod->sod_major,
			    req_sod->sod_minor, sod->sod_minor);
		object = _dl_tryload_shlib(hint, type, flags);
	}
	return object;
}

/*
d258 1
d284 2
a285 3
		object = _dl_load_shlib_hint(&sod, &req_sod, type, flags,
		    ignore_hints,  lpath);
		if (object != NULL)
d297 1
a297 2
		_dl_free((char *)sod.sod_name);
		return (object);
d306 2
a307 3
		object = _dl_load_shlib_hint(&sod, &req_sod, type, flags,
		    ignore_hints,  _dl_libpath);
		if (object != NULL)
d313 2
a314 3
		object = _dl_load_shlib_hint(&sod, &req_sod, type, flags,
		    ignore_hints,  parent->dyn.rpath);
		if (object != NULL)
d320 2
a321 3
		object = _dl_load_shlib_hint(&sod, &req_sod, type, flags,
		    ignore_hints, _dl_objects->dyn.rpath);
		if (object != NULL)
d326 2
a327 3
	object = _dl_load_shlib_hint(&sod, &req_sod, type, flags,
	    ignore_hints, NULL);
	if (object != NULL)
d338 9
@


1.26
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.25 2006/05/08 20:34:36 deraadt Exp $ */
d258 1
a258 1
 *	If the name contains a '/' use only the path preceeding the
d261 1
a261 1
 *	   search hints for match in path preceeding library name
d263 1
a263 1
 *	   search path preceeding library name
@


1.25
log
@de-space
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.24 2005/11/15 02:14:47 kurt Exp $ */
d434 1
a434 1
		while(node->data->opencount > 0) {
@


1.24
log
@correct opencount decrement in _dl_unload_dlopen. was leaving function
with -1 as opencount and interfeering with dtors. problem reported by
espie@@. okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.23 2005/11/02 15:25:00 kurt Exp $ */
d418 1
a418 1
			n->data->grprefcount--; 
@


1.23
log
@allow shlibs with paths to use shlib version matching rules too.
previously shlibs with paths would only open an exact match.
initial diff from dale. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.22 2005/10/21 15:24:10 kurt Exp $ */
d434 2
a435 1
		while(node->data->opencount-- != 0) {
@


1.22
log
@using _dl_link_grpsym to increment refcounts made _dl_notify_unload_shlib
simpler, however it broke ldd refcount output. use _dl_link_child to
increment refcounts and adjust _dl_notify_unload_shlib to match.
work by drahn@@ and myself. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.21 2005/10/12 20:36:16 kurt Exp $ */
d258 7
a264 1
 *	If the name contains a '/' use the name exactly as is. (only)
d291 36
a326 2
		object = _dl_tryload_shlib(libname, type, flags);
		return(object);
@


1.21
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.20 2005/10/09 04:37:13 kurt Exp $ */
d357 11
d372 4
a376 5
		TAILQ_FOREACH(n, &object->grpsym_list, next_sib) {
			if (n->data == object)
				continue;
			n->data->refcount--;
		}
d425 2
a444 4

	/* _dl_loading_object uses opencount & grprefcount */
	if (object != _dl_loading_object)
		object->refcount++;
@


1.20
log
@fix incomplete ref count check in _dl_link_dlopen (use macro now).
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.19 2005/10/09 04:29:13 kurt Exp $ */
d405 1
a405 1
_dl_link_sub(elf_object_t *dep, elf_object_t *p)
d415 9
a423 5
	/*
	 * because two child libraries can refer to the same library
	 * and we only want to deal with each one once, check for dups
	 * before adding new, dup libs will have the same dep pointer.
	 */
d425 1
a425 1
		if (n->data == dep)
d431 1
a431 1
	n->data = dep;
a432 1
	dep->refcount++;
d434 21
a454 2
	DL_DEB(("linking dep %s as child of %s\n", dep->load_name,
	    p->load_name));
@


1.19
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.18 2005/10/07 01:26:34 kurt Exp $ */
d341 3
a343 1
	if (dep->opencount++ > 0)
@


1.18
log
@rename dload_list to grpsym_list which better represents its usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.17 2005/10/06 21:53:10 kurt Exp $ */
d359 1
a359 1
	if (object->opencount + object->grprefcount == 0) {
@


1.17
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.16 2005/10/05 21:50:53 kurt Exp $ */
d360 1
a360 1
		TAILQ_FOREACH(n, &object->dload_list, next_sib) {
d418 1
a418 1
	TAILQ_FOREACH(n, &_dl_loading_object->dload_list, next_sib)
d426 1
a426 1
	TAILQ_INSERT_TAIL(&_dl_loading_object->dload_list, n, next_sib);
@


1.16
log
@move opencount increment and dups check to _dl_link_dlopen. fixes cleanup
of partially dlopened (but failed) cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.15 2005/10/03 19:48:24 kurt Exp $ */
d359 4
a362 7
	/*
	 * if this is the last ref, then decrement refcount
	 * on self and all dloaded deps, otherwise just decrement
	 * self.
         */
	if (object->refcount == 1) {
		TAILQ_FOREACH(n, &object->dload_list, next_sib)
d364 5
a368 2
	} else {
		object->refcount--;
d387 13
@


1.15
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.14 2005/10/01 19:32:22 drahn Exp $ */
d340 3
@


1.14
log
@handle references to load groups caused by dlopen()ing of depenant
members of the load group. work by kurt@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.13 2005/09/28 20:48:00 kurt Exp $ */
d356 11
a366 4
	object->refcount--;

	TAILQ_FOREACH(n, &object->child_list, next_sib)
		n->data->refcount--;
d411 1
@


1.13
log
@fix a use after free and let exit clean up instead. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.12 2005/09/28 18:17:41 kurt Exp $ */
a351 18
_dl_unlink_dlopen(elf_object_t *dep)
{

	struct dep_node *dnode;

	TAILQ_FOREACH(dnode, &_dlopened_child_list, next_sib)
		if (dnode->data == dep)
			break;

	if (dnode == NULL) /* XXX - not found? */
		return;

	TAILQ_REMOVE(&_dlopened_child_list, dnode, next_sib);

	_dl_free(dnode);
}

void
d356 4
a359 3
	if (--object->refcount == 0)
		TAILQ_FOREACH(n, &object->child_list, next_sib)
			_dl_notify_unload_shlib(n->data);
@


1.12
log
@remove _dl_exiting dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.11 2005/09/28 15:41:06 drahn Exp $ */
a392 3

		TAILQ_REMOVE(&_dlopened_child_list, node, next_sib);
		_dl_free(node);
@


1.11
log
@keep track of opencounts for dlopened objects, so that they
get unloaded the right number of times on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.10 2005/09/22 04:07:10 deraadt Exp $ */
a391 2
			if (_dl_exiting == 0)
				_dl_unload_shlib(node->data);
@


1.10
log
@knf; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.9 2005/09/19 02:31:04 drahn Exp $ */
d389 6
a394 4
		_dl_notify_unload_shlib(node->data);
		_dl_run_all_dtors();
		if (_dl_exiting == 0)
			_dl_unload_shlib(node->data);
@


1.9
log
@simplify code by putting executable in misnamed _dlopened_child_list,
also move RTLD_NEXT/RTLD_SELF code into that code, it is a single test.
okay kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.8 2005/09/17 04:15:23 drahn Exp $ */
d234 1
a234 2
 * if it needs to respect hints,
 * passing type and flags to perform open 
@


1.8
log
@refactor this code, much more readable, no operational change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.7 2005/09/17 02:52:43 drahn Exp $ */
d386 4
@


1.7
log
@Respect main program's rpath for dependancies of dynamic libraries.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.6 2005/09/16 23:19:41 drahn Exp $ */
d50 3
d233 25
d274 1
d280 1
a280 2
	elf_object_t *object;
	char *hint;
d294 1
a294 3
	/*
	 *  No '/' in name. Scan the known places, LD_LIBRARY_PATH first.
	 */
d296 4
a299 14
		hint = _dl_find_shlib(&req_sod, _dl_libpath, ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type, flags);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				return (object);
			}
		}
d302 1
a302 3
	/*
	 *  Check DT_RPATH.
	 */
d304 4
a307 15
		hint = _dl_find_shlib(&req_sod, parent->dyn.rpath,
		    ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type, flags);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				return (object);
			}
		}
d309 2
d312 4
a315 15
		hint = _dl_find_shlib(&req_sod, _dl_objects->dyn.rpath,
		    ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type, flags);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				return (object);
			}
		}
d319 4
a322 14
	hint = _dl_find_shlib(&req_sod, NULL, ignore_hints);
	if (hint != NULL) {
		if (req_sod.sod_minor < sod.sod_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    sod.sod_name, sod.sod_major,
			    req_sod.sod_minor, sod.sod_minor);
		object = _dl_tryload_shlib(hint, type, flags);
		if (object != NULL) {
			_dl_free((char *)sod.sod_name);
			return(object);
		}
	}
d330 2
d333 1
a333 2
	_dl_errno = DL_NOT_FOUND;
	return(0);
@


1.6
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.5 2005/05/23 19:22:11 drahn Exp $ */
d291 17
@


1.5
log
@fixes for dlclose, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.4 2005/05/10 03:36:07 drahn Exp $ */
d35 1
a44 1
static void _dl_unload_dlopen_recurse(struct dep_node *node);
d47 3
a49 2
static struct dep_node *_dlopened_first_child;
static struct dep_node *_dlopened_last_child;
d258 1
a258 1
		object = _dl_tryload_shlib(libname, type);
d278 1
a278 1
			object = _dl_tryload_shlib(hint, type);
a280 1
				object->obj_flags = flags;
d299 1
a299 1
			object = _dl_tryload_shlib(hint, type);
a301 1
				object->obj_flags = flags;
d316 1
a316 1
		object = _dl_tryload_shlib(hint, type);
a318 1
			object->obj_flags = flags;
d345 1
a345 6
	n->next_sibling = NULL;
	if (_dlopened_first_child) {
		_dlopened_last_child->next_sibling = n;
		_dlopened_last_child = n;
	} else
		_dlopened_first_child = _dlopened_last_child = n;
a352 3
	struct dep_node **dnode;
	struct dep_node *pnode;
	struct dep_node *next;
d354 5
a358 1
	dnode = &_dlopened_first_child;
d360 1
a360 1
	if (_dlopened_first_child == NULL)
d363 1
a363 7
	if (_dlopened_first_child->data == dep) {
		next = _dlopened_first_child->next_sibling;
		_dl_free(_dlopened_first_child);
		_dlopened_first_child = next;
		return;
	}
	pnode = _dlopened_first_child;
d365 1
a365 11
	while (pnode->next_sibling != NULL) {
		if (pnode->next_sibling->data == dep) {
			next = pnode->next_sibling->next_sibling;
			if (pnode->next_sibling == _dlopened_last_child)
				_dlopened_last_child = pnode;
			_dl_free(pnode->next_sibling);
			pnode->next_sibling = next;
			break;
		}
		pnode = pnode->next_sibling;
	}
d374 1
a374 1
		for (n = object->first_child; n; n = n->next_sibling)
d381 7
a387 3
	if (_dlopened_first_child != NULL)
		_dl_unload_dlopen_recurse(_dlopened_first_child);
}
d389 2
a390 8
/*
 * is recursion here a good thing? 
 */
void
_dl_unload_dlopen_recurse(struct dep_node *node)
{
	if (node->next_sibling != NULL) {
		_dl_unload_dlopen_recurse(node->next_sibling);
a391 5
	_dl_notify_unload_shlib(node->data);
	_dl_run_all_dtors();
	if (_dl_exiting == 0)
		_dl_unload_shlib(node->data);
	_dl_free(node);
a393 1

d401 16
a416 1
		_dl_exit(5);
d418 1
a418 6
	n->next_sibling = NULL;
	if (p->first_child) {
		p->last_child->next_sibling = n;
		p->last_child = n;
	} else
		p->first_child = p->last_child = n;
@


1.4
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.3 2005/04/06 00:16:53 deraadt Exp $ */
d388 10
@


1.3
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: library_subr.c,v 1.1 2005/03/23 19:48:05 drahn Exp $ */
d44 6
d334 77
@


1.2
log
@Do a better job of running destructors in the right order.
@
text
@a43 6
static void _dl_unload_dlopen_recurse(struct dep_node *node);

/* STATIC DATA */
static struct dep_node *_dlopened_first_child;
static struct dep_node *_dlopened_last_child;

a327 77
}


void
_dl_link_dlopen(elf_object_t *dep)
{
	struct dep_node *n;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(5);

	n->data = dep;
	n->next_sibling = NULL;
	if (_dlopened_first_child) {
		_dlopened_last_child->next_sibling = n;
		_dlopened_last_child = n;
	} else
		_dlopened_first_child = _dlopened_last_child = n;

	DL_DEB(("linking %s as dlopen()ed\n", dep->load_name));
}

void
_dl_unlink_dlopen(elf_object_t *dep)
{
	struct dep_node **dnode;
	struct dep_node *pnode;
	struct dep_node *next;

	dnode = &_dlopened_first_child;

	if (_dlopened_first_child == NULL)
		return;

	if (_dlopened_first_child->data == dep) {
		next = _dlopened_first_child->next_sibling;
		_dl_free(_dlopened_first_child);
		_dlopened_first_child = next;
		return;
	}
	pnode = _dlopened_first_child;

	while (pnode->next_sibling != NULL) {
		if (pnode->next_sibling->data == dep) {
			next = pnode->next_sibling->next_sibling;
			if (pnode->next_sibling == _dlopened_last_child)
				_dlopened_last_child = pnode;
			_dl_free(pnode->next_sibling);
			pnode->next_sibling = next;
			break;
		}
		pnode = pnode->next_sibling;
	}
}

void
_dl_unload_dlopen(void)
{
	if (_dlopened_first_child != NULL)
		_dl_unload_dlopen_recurse(_dlopened_first_child);
}

/*
 * is recursion here a good thing? 
 */
void
_dl_unload_dlopen_recurse(struct dep_node *node)
{
	if (node->next_sibling != NULL) {
		_dl_unload_dlopen_recurse(node->next_sibling);
	}
	_dl_notify_unload_shlib(node->data);
	_dl_run_all_dtors();
	if (_dl_exiting == 0)
		_dl_unload_shlib(node->data);
	_dl_free(node);
@


1.1
log
@Code reorganization, move copied code in library.c and library_mquery.c
into its own file. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.35 2004/10/17 03:56:49 drahn Exp $ */
d44 6
d334 77
@

