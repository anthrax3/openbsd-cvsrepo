head	1.45;
access;
symbols
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.6
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.6
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8;
locks; strict;
comment	@ * @;


1.45
date	2016.09.01.09.30.59;	author tedu;	state dead;
branches;
next	1.44;
commitid	W3WhHsm8evLS7ffT;

1.44
date	2016.06.21.15.25.38;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	lRIiUPnkIQNjSTol;

1.43
date	2016.05.21.22.07.34;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	1vHRjVFROVk0WC5R;

1.42
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.41;
commitid	zGFWeGZdYJxUOZli;

1.41
date	2015.09.09.12.16.43;	author miod;	state Exp;
branches;
next	1.40;
commitid	q6qhpOckIvyW7TzE;

1.40
date	2015.09.01.05.10.43;	author guenther;	state Exp;
branches;
next	1.39;
commitid	oxjtfmrKwr0vr4bV;

1.39
date	2015.07.26.03.08.16;	author guenther;	state Exp;
branches;
next	1.38;
commitid	8fZXTItSeA4fJ2hk;

1.38
date	2014.04.16.10.52.59;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2012.12.05.23.20.07;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.24.15.47.47;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.21.23.12.11;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.16.23.19.43;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.25.21.42.48;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.04.19.37.08;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.04.19.33.49;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.02.15.17.52;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.28.03.11.00;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.16.20.41;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.15.22.39.13;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.18.19.21.01;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.23.19.14.25;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.01.23.55.01;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.09.14.38.23;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.08.21.18.30;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.29.15.20.38;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.27.16.56.01;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.27.13.19.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.45
log
@retire sparc
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.44 2016/06/21 15:25:38 deraadt Exp $ */

/*
 * Copyright (c) 1999 Dale Rahn
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define _DYN_LOADER

#include <sys/param.h>
#include <sys/mman.h>
#include <sys/sysctl.h>
#include <sys/syscall.h>
#include <sys/unistd.h>
#include <machine/cpu.h>
#include <machine/trap.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

/*
 * The following table holds for each relocation type:
 *	- the width in bits of the memory location the relocation
 *	  applies to (not currently used)
 *	- the number of bits the relocation value must be shifted to the
 *	  right (i.e. discard least significant bits) to fit into
 *	  the appropriate field in the instruction word.
 *	- flags indicating whether
 *		* the relocation involves a symbol
 *		* the relocation is relative to the current position
 *		* the relocation is for a GOT entry
 *		* the relocation is relative to the load address
 *
 */
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,							/* NONE */
	_RF_S|_RF_A|		_RF_SZ(8)  | _RF_RS(0),		/* RELOC_8 */
	_RF_S|_RF_A|		_RF_SZ(16) | _RF_RS(0),		/* RELOC_16 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* RELOC_32 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(8)  | _RF_RS(0),		/* DISP_8 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(16) | _RF_RS(0),		/* DISP_16 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* DISP_32 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP_30 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WDISP_22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(10),	/* HI22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 22 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 13 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* LO10 */
	_RF_G|			_RF_SZ(32) | _RF_RS(0),		/* GOT10 */
	_RF_G|			_RF_SZ(32) | _RF_RS(0),		/* GOT13 */
	_RF_G|			_RF_SZ(32) | _RF_RS(10),	/* GOT22 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* PC10 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(10),	/* PC22 */
	      _RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(2),		/* WPLT30 */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* COPY */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* JMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(32) | _RF_RS(0),		/* RELATIVE */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* UA_32 */

	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* PLT32 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* HIPLT22 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* LOPLT10 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* LOPLT10 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* PCPLT22 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* PCPLT32 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* 10 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* 11 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* 64 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* OLO10 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* HH22 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* HM10 */
	_RF_S|_RF_A|/*unknown*/	_RF_SZ(32) | _RF_RS(0),		/* LM22 */
	_RF_S|_RF_A|_RF_P|/*unknown*/	_RF_SZ(32) | _RF_RS(0),	/* WDISP16 */
	_RF_S|_RF_A|_RF_P|/*unknown*/	_RF_SZ(32) | _RF_RS(0),	/* WDISP19 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* GLOB_JMP */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* 7 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* 5 */
	/*unknown*/		_RF_SZ(32) | _RF_RS(0),		/* 6 */
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)

static int reloc_target_bitmask[] = {
#define _BM(x)	(~(-(1ULL << (x))))
	0,				/* NONE */
	_BM(8), _BM(16), _BM(32),	/* RELOC_8, _16, _32 */
	_BM(8), _BM(16), _BM(32),	/* DISP8, DISP16, DISP32 */
	_BM(30), _BM(22),		/* WDISP30, WDISP22 */
	_BM(22), _BM(22),		/* HI22, _22 */
	_BM(13), _BM(10),		/* RELOC_13, _LO10 */
	_BM(10), _BM(13), _BM(22),	/* GOT10, GOT13, GOT22 */
	_BM(10), _BM(22),		/* _PC10, _PC22 */
	_BM(30), 0,			/* _WPLT30, _COPY */
	-1, -1, -1,			/* _GLOB_DAT, JMP_SLOT, _RELATIVE */
	_BM(32), _BM(32),		/* _UA32, PLT32 */
	_BM(22), _BM(10),		/* _HIPLT22, LOPLT10 */
	_BM(32), _BM(22), _BM(10),	/* _PCPLT32, _PCPLT22, _PCPLT10 */
	_BM(10), _BM(11), -1,		/* _10, _11, _64 */
	_BM(10), _BM(22),		/* _OLO10, _HH22 */
	_BM(10), _BM(22),		/* _HM10, _LM22 */
	_BM(16), _BM(19),		/* _WDISP16, _WDISP19 */
	-1,				/* GLOB_JMP */
	_BM(7), _BM(5), _BM(6)		/* _7, _5, _6 */
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

static inline void
_dl_reloc_plt(Elf_Addr *where1, Elf_Addr *where2, Elf_Addr value)
{
	/*
	 * At the PLT entry pointed at by `where1' and `where2', we now
	 * construct a direct transfer to the now fully resolved function
	 * address.  The resulting code in the jump slot is:
	 *
	 *		sethi	%hi(roffset), %g1
	 * where1:	sethi	%hi(addr), %g1
	 * where2:	jmp	%g1+%lo(addr)
	 *
	 * If this was being directly applied to the PLT during resolution
	 * of a lazy binding, then to make it thread safe we would need to
	 * update the third instruction first, since that leaves the
	 * previous `b,a' at the second word in place, so that the whole
	 * PLT slot can be atomically change to the new sequence by
	 * writing the `sethi' instruction at word 2.  We would also need
	 * iflush instructions to guarantee that the third instruction
	 * made it to the I-cache before the second instruction.
	 *
	 * HOWEVER, we do lazy binding via the kbind syscall, so we can
	 * write them in order here and reorder by the kbind blocking.
	 */
#define SETHI	0x03000000
#define JMP	0x81c06000
	*where1 = SETHI | ((value >> 10) & 0x003fffff);
	*where2 = JMP   | (value & 0x000003ff);
}

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	long	i;
	long	numrela;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_RelA *relas;
	struct load_list *llist;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf_RelA);
	relrel = rel == DT_RELA ? object->relacount : 0;
	relas = (Elf_RelA *)(object->Dyn.info[rel]);

	if (relas == NULL)
		return(0);

	if (relrel > numrela) {
		_dl_printf("relacount > numrela: %ld > %ld\n", relrel, numrela);
		_dl_exit(20);
	}

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, relas++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(relas->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELACOUNT wrong\n");
			_dl_exit(20);
		}
#endif
		where = (Elf_Addr *)(relas->r_offset + loff);
		*where = relas->r_addend + loff;
	}
	for (; i < numrela; i++, relas++) {
		Elf_Addr *where, ooff;
		Elf_Word type, value, mask;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(relas->r_info);

		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JMP_SLOT) && rel != DT_JMPREL)
			continue;

		where = (Elf_Addr *)(relas->r_offset + loff);

		if (type == R_TYPE(RELATIVE)) {
			*where += (Elf_Addr)(loff + relas->r_addend);
			continue;
		}

		if (RELOC_USE_ADDEND(type))
			value = relas->r_addend;
		else
			value = 0;

		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(relas->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(relas->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JMP_SLOT)) ?
					SYM_PLT : SYM_NOTPLT),
				    sym, NULL);
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			size_t size = dstsym->st_size;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    dstsym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, size);
			continue;
		}

		if (type == R_TYPE(JMP_SLOT)) {
			_dl_reloc_plt(&where[1], &where[2], value);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		/* We ignore alignment restrictions here */
		*where &= ~mask;
		*where |= value;
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

/*
 * Resolve a symbol at run-time.
 */
Elf_Addr
_dl_bind(elf_object_t *object, int reloff)
{
	const Elf_Sym *sym, *this;
	Elf_Addr *addr, ooff;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr value;
	Elf_RelA *rela;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param[2];
		Elf_Word buf[2];
	} buf;

	rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rela->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}

	value = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (value);

	/*
	 * Relocations require two blocks to be written: the second word
	 * then the first word. So the layout of the buffer we pass to
	 * kbind() needs to be this:
	 *   +------------+
	 *   | kbind.addr |
	 *   | kbind.size |
	 *   | kbind.addr |
	 *   | kbind.size |
	 *   |   word 2   |
	 *   |   word 1   |
	 *   +------------+
	 */
	addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
	_dl_reloc_plt(&buf.buf[1], &buf.buf[0], value);
	buf.param[0].kb_addr = &addr[2];
	buf.param[0].kb_size = sizeof(Elf_Word);
	buf.param[1].kb_addr = &addr[1];
	buf.param[1].kb_size = sizeof(Elf_Word);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("g1") = SYS_kbind;
		register void *arg1 __asm("o0") = &buf;
		register long  arg2 __asm("o1") = sizeof(buf);
		register long  arg3 __asm("o2") = 0xffffffff & (cookie >> 32);
		register long  arg4 __asm("o3") = 0xffffffff &  cookie;

		__asm volatile("t %2" : "+r" (arg1), "+r" (arg2)
		    : "i" (ST_SYSCALL), "r" (syscall_num), "r" (arg3),
		    "r" (arg4) : "cc", "memory" );
	}

	/*
	 * iflush requires 5 subsequent cycles to be sure all copies
	 * are flushed from the CPU and the icache.
	 */
	__asm volatile("iflush %0+8; iflush %0+4; nop; nop; nop; nop; nop" :
	    : "r" (addr));

	return (value);
}

int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	fails = 0;
	Elf_Addr *pltgot;
	extern void _dl_bind_start(void);	/* XXX */

	pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];

	if (object->traced)
		lazy = 1;

	if (object->obj_type == OBJTYPE_LDR || !lazy || pltgot == NULL) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		/*
		 * PLTGOT is the PLT on the sparc.
		 * The first entry holds the call the dynamic linker.
		 * We construct a `call' sequence that transfers
		 * to `_dl_bind_start()'.
		 * The second entry holds the object identification.
		 * Note: each PLT entry is three words long.
		 */
#define SAVE	0x9de3bfc0	/* i.e. `save %sp,-64,%sp' */
#define CALL	0x40000000
#define NOP	0x01000000
		pltgot[0] = SAVE;
		pltgot[1] = CALL |
		    ((Elf_Addr)&_dl_bind_start - (Elf_Addr)&pltgot[1]) >> 2;
		pltgot[2] = NOP;
		pltgot[3] = (Elf_Addr) object;
		__asm volatile("iflush %0+8"  : : "r" (pltgot));
		__asm volatile("iflush %0+4"  : : "r" (pltgot));
		__asm volatile("iflush %0+0"  : : "r" (pltgot));
		/*
		 * iflush requires 5 subsequent cycles to be sure all copies
		 * are flushed from the CPU and the icache.
		 */
		__asm volatile("nop;nop;nop;nop;nop");
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	/* mprotect the PLT */
	_dl_protect_segment(object, 0, "__plt_start", "__plt_end",
	    PROT_READ|PROT_EXEC);

	return (fails);
}


void __mul(void);
void _mulreplace_end(void);
void _mulreplace(void);
void __umul(void);
void _umulreplace_end(void);
void _umulreplace(void);

void __div(void);
void _divreplace_end(void);
void _divreplace(void);
void __udiv(void);
void _udivreplace_end(void);
void _udivreplace(void);

void __rem(void);
void _remreplace_end(void);
void _remreplace(void);
void __urem(void);
void _uremreplace_end(void);
void _uremreplace(void);

void
_dl_mul_fixup()
{
	int mib[2], v8mul;
	size_t len;


	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_V8MUL;
	len = sizeof(v8mul);
	_dl_sysctl(mib, 2, &v8mul, &len, NULL, 0);


	if (!v8mul)
		return;

	_dl_mprotect(&__mul, _mulreplace_end-_mulreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_mulreplace, __mul, _mulreplace_end-_mulreplace);
	_dl_mprotect(&__mul, _mulreplace_end-_mulreplace,
	    PROT_READ|PROT_EXEC);

	_dl_mprotect(&__umul, _umulreplace_end-_umulreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_umulreplace, __umul, _umulreplace_end-_umulreplace);
	_dl_mprotect(&__umul, _umulreplace_end-_umulreplace,
	    PROT_READ|PROT_EXEC);


	_dl_mprotect(&__div, _divreplace_end-_divreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_divreplace, __div, _divreplace_end-_divreplace);
	_dl_mprotect(&__div, _divreplace_end-_divreplace,
	    PROT_READ|PROT_EXEC);

	_dl_mprotect(&__udiv, _udivreplace_end-_udivreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_udivreplace, __udiv, _udivreplace_end-_udivreplace);
	_dl_mprotect(&__udiv, _udivreplace_end-_udivreplace,
	    PROT_READ|PROT_EXEC);


	_dl_mprotect(&__rem, _remreplace_end-_remreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_remreplace, __rem, _remreplace_end-_remreplace);
	_dl_mprotect(&__rem, _remreplace_end-_remreplace,
	    PROT_READ|PROT_EXEC);

	_dl_mprotect(&__urem, _uremreplace_end-_uremreplace,
	    PROT_READ|PROT_WRITE);
	_dl_bcopy(_uremreplace, __urem, _uremreplace_end-_uremreplace);
	_dl_mprotect(&__urem, _uremreplace_end-_uremreplace,
	    PROT_READ|PROT_EXEC);
}
@


1.44
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.43 2016/05/21 22:07:34 deraadt Exp $ */
@


1.43
log
@mul/div/rem replacement should happen without PROT_EXEC
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.42 2015/11/02 07:02:53 guenther Exp $ */
d211 1
a211 1
				    llist->prot|PROT_WRITE);
@


1.42
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.41 2015/09/09 12:16:43 miod Exp $ */
d504 1
a504 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
d510 1
a510 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
d517 1
a517 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
d523 1
a523 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
d530 1
a530 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
d536 1
a536 1
	    PROT_READ|PROT_WRITE|PROT_EXEC);
@


1.41
log
@Some explicit iflush instructions after the kbind() call are still needed
for now; misunderstanding between guenther@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.40 2015/09/01 05:10:43 guenther Exp $ */
a419 3
	Elf_Addr ooff;
	const Elf_Sym *this;
	Elf_Addr plt_addr;
d423 6
a428 1
	if (pltgot != NULL) {
d455 2
a456 53
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	plt_addr = 0;
	object->plt_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		plt_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__plt_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	if (plt_addr == 0)
		object->plt_start = 0;
	else {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
	}

	if (object->traced)
		lazy = 1;

	if (object->obj_type == OBJTYPE_LDR || !lazy || pltgot == NULL) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	}
d458 3
a460 6
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
@


1.40
log
@Use kbind for lazy binding GOT/PLT updates on m88k and sparc.

Much discussion with and assistance from miod and deraadt
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.39 2015/07/26 03:08:16 guenther Exp $ */
d152 2
a153 2
	 * At the PLT entry pointed at by `where', we now construct
	 * a direct transfer to the now fully resolved function
d156 3
a158 3
	 *	sethi	%hi(roffset), %g1
	 *	sethi	%hi(addr), %g1
	 *	jmp	%g1+%lo(addr)
a170 2
	 * Non-lazy binding does lots of work before returning, so no
	 * reordering or iflushing is needed.
d403 7
@


1.39
log
@Copy relocations can't be jump-slot relocations, so delete the test for that.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.38 2014/04/16 10:52:59 guenther Exp $ */
d32 1
a32 1
#include <sys/types.h>
a33 1
#include <sys/param.h>
d35 2
d38 1
a41 1
#include <signal.h>
d47 2
d149 1
a149 1
_dl_reloc_plt(Elf_Addr *where, Elf_Addr value)
d160 4
a163 2
	 * We write the third instruction first, since that leaves the
	 * previous `b,a' at the second word in place. Hence the whole
d165 8
a172 1
	 * writing the `sethi' instruction at word 2.
d176 2
a177 10
#define NOP	0x01000000
	where[2] = JMP   | (value & 0x000003ff);
	where[1] = SETHI | ((value >> 10) & 0x003fffff);
	__asm volatile("iflush %0+8" : : "r" (where));
	__asm volatile("iflush %0+4" : : "r" (where));
	/*
	 * iflush requires 5 subsequent cycles to be sure all copies
	 * are flushed from the CPU and the icache.
	 */
	__asm volatile("nop;nop;nop;nop;nop");
d308 1
a308 1
			_dl_reloc_plt(where, value);
d348 5
a352 1
	sigset_t savedmask;
a359 1
	addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
d370 2
a371 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return value;
d373 31
a403 16
	/* if PLT is protected, allow the write */
	if (object->plt_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		/* mprotect the actual modified region, not the whole plt */
		_dl_mprotect((void*)addr, sizeof (Elf_Addr) * 3,
		    PROT_READ|PROT_WRITE|PROT_EXEC);
	}

	_dl_reloc_plt(addr, value);

	/* if PLT is (to be protected, change back to RO/X */
	if (object->plt_size != 0) {
		/* mprotect the actual modified region, not the whole plt */
		_dl_mprotect((void*)addr, sizeof (Elf_Addr) * 3,
		    PROT_READ|PROT_EXEC);
		_dl_thread_bind_lock(1, &savedmask);
@


1.38
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.37 2013/06/13 04:13:47 brad Exp $ */
d293 1
a293 2
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|
			    ((type == R_TYPE(JMP_SLOT)) ? SYM_PLT : SYM_NOTPLT),
@


1.37
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.36 2013/06/01 09:57:58 miod Exp $ */
d167 2
a168 2
	__asm __volatile("iflush %0+8" : : "r" (where));
	__asm __volatile("iflush %0+4" : : "r" (where));
d173 1
a173 1
	__asm __volatile("nop;nop;nop;nop;nop");
d417 3
a419 3
		__asm __volatile("iflush %0+8"  : : "r" (pltgot));
		__asm __volatile("iflush %0+4"  : : "r" (pltgot));
		__asm __volatile("iflush %0+0"  : : "r" (pltgot));
d424 1
a424 1
		__asm __volatile("nop;nop;nop;nop;nop");
@


1.36
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.35 2013/05/08 20:55:14 guenther Exp $ */
d359 1
a359 1
		*((int *)0) = 0;	/* XXX */
@


1.35
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2012/12/05 23:20:07 deraadt Exp $ */
d342 1
d356 1
a356 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d364 3
d473 3
@


1.34
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2011/04/06 11:36:25 miod Exp $ */
d181 1
d184 2
d191 1
d197 5
d213 14
a226 1
	for (i = 0; i < numrela; i++, relas++) {
d262 2
d279 3
a281 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.33
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2010/05/02 04:57:01 guenther Exp $ */
a32 1
#include <sys/cdefs.h>
@


1.32
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2008/04/09 21:45:26 kurt Exp $ */
d399 1
a399 1
	object->got_addr = NULL;
d431 2
a432 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d438 2
a439 2
	if (plt_addr == NULL)
		object->plt_start = NULL;
@


1.31
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2008/02/24 15:47:47 drahn Exp $ */
d319 1
a319 1
	sigset_t omask, nmask;
d341 1
a341 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d354 1
a354 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.30
log
@Use rounded down address when changing memory protections on the GOT, such
that we don't accidentally touch the page after the GOT.

Bug found on sparc64 affected other platforms as well.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2007/11/27 16:42:19 miod Exp $ */
d187 1
a187 1
	loff = object->load_offs;
d327 1
a327 1
	addr = (Elf_Addr *)(object->load_offs + rela->r_offset);
@


1.29
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2007/05/05 15:21:21 drahn Exp $ */
d454 1
a454 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.28
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2006/10/28 16:06:05 drahn Exp $ */
d182 1
a182 1
	long	fails = 0;
d363 1
a363 1
void
d366 1
d450 1
a450 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d459 2
@


1.27
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2005/09/22 01:33:08 drahn Exp $ */
d343 1
d356 1
@


1.26
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2005/09/21 23:12:11 drahn Exp $ */
d197 1
a197 1
	if ((rel == DT_REL || rel == DT_RELA)) {
d297 1
a297 1
	if ((rel == DT_REL || rel == DT_RELA)) {
@


1.25
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2005/09/16 23:19:43 drahn Exp $ */
d251 3
a253 6
					_dl_printf("%s: %s: can't resolve "
					    "reference '%s'\n",
					    _dl_progname,
					    object->load_name,
					    symn);
					fails++;
@


1.24
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2004/05/25 21:42:48 mickey Exp $ */
d248 1
a248 1
				    sym->st_size, NULL);
d273 1
a273 1
			    size, object, NULL);
d333 1
a333 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
d406 1
a406 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d413 1
a413 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d422 1
a422 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
d429 1
a429 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
@


1.23
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2004/05/25 18:07:20 mickey Exp $ */
d244 1
a244 2
				    ELF_R_SYM(relas->r_info),
				    _dl_objects, &this, NULL,
d248 1
a248 1
				    sym->st_size);
d270 2
a271 2
			soff = _dl_find_symbol(symn, object->next, &srcsym,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d273 1
a273 1
			    size, object);
d332 3
a334 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d405 3
a407 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d412 3
a414 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d421 3
a423 2
	ooff = _dl_find_symbol("__plt_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d428 3
a430 2
	ooff = _dl_find_symbol("__plt_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
@


1.22
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2004/05/25 15:56:18 deraadt Exp $ */
a45 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	const unsigned char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2003/09/04 19:37:08 drahn Exp $ */
d256 1
a256 1
				    _dl_objects, &this,
d283 1
a283 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d344 1
a344 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
d416 1
a416 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d422 1
a422 1
	ooff = _dl_find_symbol("__got_end", object, &this,
d430 1
a430 1
	ooff = _dl_find_symbol("__plt_start", object, &this,
d436 1
a436 1
	ooff = _dl_find_symbol("__plt_end", object, &this,
@


1.20
log
@Fix W^X mistake. If the dynamic linker is workin in non-lazy mode, it
should still mprotect the GOT and PLT as appropriate. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2003/09/04 19:33:49 drahn Exp $ */
d395 3
a397 3
#define SAVE    0x9de3bfc0      /* i.e. `save %sp,-64,%sp' */
#define CALL    0x40000000
#define NOP     0x01000000
d497 1
a497 1
        mib[0] = CTL_MACHDEP;
@


1.19
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2003/09/02 15:17:52 drahn Exp $ */
a457 1
		return;
@


1.18
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2003/07/28 03:11:00 drahn Exp $ */
d254 2
a255 1
				ooff = _dl_find_symbol(symn,
d260 1
a260 1
				    sym->st_size, object);
@


1.17
log
@The fifth argument to _dl_find_symbol is a 'int size', not a SYM_ define.
Fix several calls which had the incorrect but working define in that position
It happened that SYM_NOTPLT was 0, which was the desired size value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2003/07/06 20:04:00 deraadt Exp $ */
d259 1
a259 1
				    sym->st_size, object->load_name);
d284 1
a284 1
			    size, object->load_name);
d344 1
a344 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0, object->load_name);
d416 1
a416 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d422 1
a422 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d430 1
a430 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d436 1
a436 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
@


1.16
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2003/06/03 16:20:41 art Exp $ */
d416 1
a416 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d422 1
a422 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d430 1
a430 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d436 1
a436 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
@


1.15
log
@three four gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2003/02/15 22:39:13 drahn Exp $ */
d326 1
a326 1
_dl_bind(elf_object_t *object, Elf_Word reloff)
d357 1
a357 1
		_dl_mprotect((void*)addr,sizeof (Elf_Addr) * 3,
d366 1
a366 1
		_dl_mprotect((void*)addr,sizeof (Elf_Addr) * 3,
@


1.14
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2003/02/02 16:57:58 deraadt Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2002/12/18 19:21:01 drahn Exp $ */
d359 1
a359 1
	if (object->plt_addr != NULL && object->plt_size != 0) {
d370 1
a370 1
	if (object->plt_addr != NULL && object->plt_size != 0) {
d387 1
d418 2
d434 2
d441 1
a441 1
		object->plt_addr = ooff + this->st_value;
d448 16
a463 1
		object->plt_size = ooff + this->st_value  - object->plt_addr;
d470 1
a470 1
	if (object->got_addr != NULL && object->got_size != 0)
d473 2
a474 2
	if (object->plt_addr != NULL && object->plt_size != 0)
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
@


1.12
log
@Remove pointless 'if 0' code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2002/12/18 19:20:02 drahn Exp $ */
d364 1
a364 1
		    PROT_READ|PROT_WRITE|PROT_EXEC); 
d373 1
a373 1
		    PROT_READ|PROT_EXEC); 
d450 1
a450 1
	if (object->got_addr != NULL && object->got_size != 0) 
d452 2
a453 2
		    PROT_READ); 
	if (object->plt_addr != NULL && object->plt_size != 0) 
@


1.11
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2002/11/23 19:14:25 drahn Exp $ */
d362 1
a362 4
#if 0
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
		    PROT_READ|PROT_WRITE|PROT_EXEC); 
#else
a364 1
#endif
d371 1
a371 4
#if 0
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
		    PROT_READ|PROT_EXEC);
#else
a373 1
#endif
@


1.10
log
@Implement [u]mul/[u]div/[u]rem with faster version if available
on machine. Improves speed for dynamic userland processes when active.
Idea from Theo. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2002/11/14 15:15:54 drahn Exp $ */
d47 1
d339 1
d358 13
d373 12
d393 2
d425 28
d458 6
@


1.9
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2002/09/01 23:55:01 drahn Exp $ */
d41 3
d401 77
@


1.8
log
@Make sure that the symbol return value is always initialized before
the address of it is passed to dl_find_symbol(). fixes xpdf lazy
binding problem. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2002/08/23 22:57:03 drahn Exp $ */
d261 1
a261 1
				    sym->st_size);
d286 1
a286 1
			    size);
d345 1
a345 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0);
@


1.7
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2002/08/11 16:51:04 drahn Exp $ */
d343 1
@


1.6
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2002/08/09 14:38:23 art Exp $ */
d257 5
a261 2
				    _dl_objects, &this, 0, 1,
				    type == R_TYPE(JMP_SLOT));
a272 14
#ifdef notyet
/*
 * XXX Hmm, we should change the API of _dl_find_symbol and do this in there,
 * XXX or maybe make a wrapper.
 */
				if (this->st_size != sym->st_size &&
				    sym->st_size != 0) {
					_dl_printf("%s: %s : WARNING: "
					    "symbol(%s) size mismatch ",
					    _dl_progname, object->load_name,
					    symn);
					_dl_printf("relink your program\n");
				}
#endif
d284 3
a286 1
				0, 2, 0);
d343 2
a344 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1, 1);
@


1.5
log
@Various fixes.
 - JMP_SLOT relocations require a symbol lookup (duh).
 - compress the nops to not dominate the code.
 - reorder the installation of the pltgot and always install it when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2002/08/08 21:18:30 jason Exp $ */
d257 2
a258 1
				    _dl_objects, &this, 0, 1);
d295 1
a295 1
				0, 2);
d352 1
a352 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
@


1.4
log
@- Add some missing iflush's
- insert some nop's to make sure all copies are gone from the icache and CPU
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2002/07/29 15:20:38 art Exp $ */
d103 1
a103 1
				_RF_SZ(32) | _RF_RS(0),		/* JMP_SLOT */
d187 1
a187 5
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
a285 5
		if (type == R_TYPE(JMP_SLOT)) {
			_dl_reloc_plt(where, value);
			continue;
		}

d303 5
d372 27
a403 29
	/*
	 * PLTGOT is the PLT on the sparc.
	 * The first entry holds the call the dynamic linker.
	 * We construct a `call' sequence that transfers
	 * to `_dl_bind_start()'.
	 * The second entry holds the object identification.
	 * Note: each PLT entry is three words long.
	 */
#define SAVE    0x9de3bfc0      /* i.e. `save %sp,-64,%sp' */
#define CALL    0x40000000
#define NOP     0x01000000
	pltgot[0] = SAVE;
	pltgot[1] = CALL |
	    ((Elf_Addr)&_dl_bind_start - (Elf_Addr)&pltgot[1]) >> 2;
	pltgot[2] = NOP;
	pltgot[3] = (Elf_Addr) object;
	__asm __volatile("iflush %0+12" : : "r" (pltgot));
	__asm __volatile("iflush %0+8"  : : "r" (pltgot));
	__asm __volatile("iflush %0+4"  : : "r" (pltgot));
	__asm __volatile("iflush %0+0"  : : "r" (pltgot));
	/*
	 * iflush requires 5 subsequent cycles to be sure all copies
	 * are flushed from the CPU and the icache.
	 */
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
	__asm __volatile("nop");
@


1.3
log
@Bunch of cleanups and one last bugfix that seems to make things work.
Mark COPY relocations as needing to resolve the destination symbol.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2002/07/27 16:56:01 art Exp $ */
d183 9
d397 13
@


1.2
log
@Commit work in progress before I get drunk tonight.

Code from sparc64 and NetBSD.

Basically we can link the most, lazy linking works (!), but something else
is screwed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2002/07/27 13:19:26 art Exp $ */
d101 1
a101 1
				_RF_SZ(32) | _RF_RS(0),		/* COPY */
a129 1
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
d159 25
a183 1
void _dl_reloc_plt(Elf_Word *where, Elf_Addr value);
d214 2
a215 2
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
d229 5
d251 2
a252 2
				ooff = _dl_find_symbol(symn, _dl_objects,
				    &this, 0, 1);
d257 2
a258 1
					    _dl_progname, object->load_name,
d282 1
a282 1
			_dl_reloc_plt((Elf_Word *)where, value);
a304 2
		if (RELOC_BASE_RELATIVE(type))
			value += loff + *where;
a312 1

a326 26
void
_dl_reloc_plt(Elf_Word *where, Elf_Addr value)
{
	/*
	 * At the PLT entry pointed at by `where', we now construct
	 * a direct transfer to the now fully resolved function
	 * address.  The resulting code in the jump slot is:
	 *
	 *	sethi	%hi(roffset), %g1
	 *	sethi	%hi(addr), %g1
	 *	jmp	%g1+%lo(addr)
	 *
	 * We write the third instruction first, since that leaves the
	 * previous `b,a' at the second word in place. Hence the whole
	 * PLT slot can be atomically change to the new sequence by
	 * writing the `sethi' instruction at word 2.
	 */
#define SETHI	0x03000000
#define JMP	0x81c06000
#define NOP	0x01000000
	where[2] = JMP   | (value & 0x000003ff);
	where[1] = SETHI | ((value >> 10) & 0x003fffff);
	__asm __volatile("iflush %0+8" : : "r" (where));
	__asm __volatile("iflush %0+4" : : "r" (where));
}

d330 1
a330 1
void *
d333 1
a333 1
	Elf_RelA *rela;
a334 1
	const Elf_Sym *sym, *this;
d336 2
a344 2
DL_DEB(("_dl_bind %s\n", symn));

d352 3
a354 1
	_dl_reloc_plt(addr, ooff + this->st_value);
d356 1
a356 1
	return (void *)ooff + this->st_value;
d376 1
a376 1
	 * to `_rtld_bind_start()'.
d385 1
a385 2
	    ((Elf_Addr)&_dl_bind_start -
	     (Elf_Addr)&pltgot[1]) >> 2;
@


1.1
log
@Just a skeleton for sparc. Builds, but pieces are missing and it doesn't
even get to dl_boot_bind correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2002/07/12 20:18:30 drahn Exp $ */
d60 102
d165 160
a324 1
	return (0);
d326 1
d331 1
a331 1
_dl_bind(elf_object_t *object, int index)
d333 21
a353 2
	return (NULL);
}
d355 1
a355 3
void
_dl_install_plt(Elf_Word *pltgot, Elf_Addr proc)
{
d361 27
@

