head	1.170;
access;
symbols
	OPENBSD_6_1:1.170.0.4
	OPENBSD_6_1_BASE:1.170
	OPENBSD_6_0:1.162.0.2
	OPENBSD_6_0_BASE:1.162
	OPENBSD_5_9:1.156.0.2
	OPENBSD_5_9_BASE:1.156
	OPENBSD_5_8:1.154.0.4
	OPENBSD_5_8_BASE:1.154
	OPENBSD_5_7:1.153.0.2
	OPENBSD_5_7_BASE:1.153
	OPENBSD_5_6:1.150.0.4
	OPENBSD_5_6_BASE:1.150
	OPENBSD_5_5:1.147.0.4
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.133.0.2
	OPENBSD_5_4_BASE:1.133
	OPENBSD_5_3:1.130.0.2
	OPENBSD_5_3_BASE:1.130
	OPENBSD_5_2:1.129.0.2
	OPENBSD_5_2_BASE:1.129
	OPENBSD_5_1_BASE:1.127
	OPENBSD_5_1:1.127.0.2
	OPENBSD_5_0:1.125.0.2
	OPENBSD_5_0_BASE:1.125
	OPENBSD_4_9:1.121.0.2
	OPENBSD_4_9_BASE:1.121
	OPENBSD_4_8:1.119.0.2
	OPENBSD_4_8_BASE:1.119
	OPENBSD_4_7:1.118.0.2
	OPENBSD_4_7_BASE:1.118
	OPENBSD_4_6:1.117.0.6
	OPENBSD_4_6_BASE:1.117
	OPENBSD_4_5:1.117.0.2
	OPENBSD_4_5_BASE:1.117
	OPENBSD_4_4:1.115.0.2
	OPENBSD_4_4_BASE:1.115
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.111.0.2
	OPENBSD_4_2_BASE:1.111
	OPENBSD_4_1:1.109.0.2
	OPENBSD_4_1_BASE:1.109
	OPENBSD_4_0:1.103.0.2
	OPENBSD_4_0_BASE:1.103
	OPENBSD_3_9:1.100.0.2
	OPENBSD_3_9_BASE:1.100
	OPENBSD_3_8:1.86.0.2
	OPENBSD_3_8_BASE:1.86
	OPENBSD_3_7:1.83.0.4
	OPENBSD_3_7_BASE:1.83
	OPENBSD_3_6:1.83.0.2
	OPENBSD_3_6_BASE:1.83
	OPENBSD_3_5:1.73.0.2
	OPENBSD_3_5_BASE:1.73
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	r20000612:1.1.1.2
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.170
date	2017.02.08.04.34.29;	author guenther;	state Exp;
branches;
next	1.169;
commitid	v6BJE4JNZ5jMnrCa;

1.169
date	2017.01.24.07.48.36;	author guenther;	state Exp;
branches;
next	1.168;
commitid	veGB6uLWx3BTEAfk;

1.168
date	2017.01.09.22.51.04;	author kettenis;	state Exp;
branches;
next	1.167;
commitid	8mveS1UjNqlN99uR;

1.167
date	2016.08.28.04.33.17;	author guenther;	state Exp;
branches;
next	1.166;
commitid	kKq3FzyJhu8aeIlP;

1.166
date	2016.08.23.06.46.17;	author kettenis;	state Exp;
branches;
next	1.165;
commitid	77WGwq23vMDU6RQE;

1.165
date	2016.08.14.04.30.39;	author guenther;	state Exp;
branches;
next	1.164;
commitid	QiJxT5aCaZ65iaKY;

1.164
date	2016.08.12.20.39.01;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	9Gsc7gGSE2YeEbd8;

1.163
date	2016.08.08.21.59.20;	author guenther;	state Exp;
branches;
next	1.162;
commitid	PufSD0ERJAhj0Sd1;

1.162
date	2016.07.04.21.15.06;	author guenther;	state Exp;
branches;
next	1.161;
commitid	qHDzpShMNCJZKLBF;

1.161
date	2016.06.08.11.58.59;	author kettenis;	state Exp;
branches;
next	1.160;
commitid	McGYMfmcR7iKjRD2;

1.160
date	2016.06.05.19.43.58;	author kettenis;	state Exp;
branches;
next	1.159;
commitid	CsWZjDjYm9WfJh8U;

1.159
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.158;
commitid	d9R7VGw9CHTkwXE1;

1.158
date	2016.03.24.05.27.19;	author guenther;	state Exp;
branches;
next	1.157;
commitid	cLl4FNtsUqRv0WJn;

1.157
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.156;
commitid	Kpc3J4Ry51yjfQid;

1.156
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.155;
commitid	kmpP8aoRsEOyxUMj;

1.155
date	2015.08.18.17.34.44;	author deraadt;	state Exp;
branches;
next	1.154;
commitid	3c8JS3nIQIl5t1xO;

1.154
date	2015.05.06.01.03.31;	author jsg;	state Exp;
branches;
next	1.153;
commitid	ESuAgEXMJYUpucU5;

1.153
date	2015.01.22.05.48.17;	author deraadt;	state Exp;
branches;
next	1.152;
commitid	GZoxg3rKKQGZ5hZT;

1.152
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.151;
commitid	31KwZ9PARAKUg1ob;

1.151
date	2014.11.03.17.50.56;	author guenther;	state Exp;
branches;
next	1.150;
commitid	FlXbNaFQfyra9gBu;

1.150
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.149;
commitid	ImRWDrCXNlhODvC7;

1.149
date	2014.07.06.19.15.16;	author otto;	state Exp;
branches;
next	1.148;
commitid	qQhpNhZYPVj5gCGG;

1.148
date	2014.06.21.08.00.23;	author otto;	state Exp;
branches;
next	1.147;
commitid	wh9FTpEgwThWVeqE;

1.147
date	2014.02.16.01.16.38;	author martynas;	state Exp;
branches;
next	1.146;

1.146
date	2014.01.23.00.31.34;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2014.01.18.09.08.42;	author kettenis;	state Exp;
branches;
next	1.144;

1.144
date	2013.12.25.15.14.59;	author miod;	state Exp;
branches;
next	1.143;

1.143
date	2013.12.25.15.01.39;	author miod;	state Exp;
branches;
next	1.142;

1.142
date	2013.12.25.13.06.00;	author miod;	state Exp;
branches;
next	1.141;

1.141
date	2013.12.25.11.10.02;	author kettenis;	state Exp;
branches;
next	1.140;

1.140
date	2013.12.23.22.13.03;	author kettenis;	state Exp;
branches;
next	1.139;

1.139
date	2013.12.23.22.03.52;	author kettenis;	state Exp;
branches;
next	1.138;

1.138
date	2013.12.23.21.18.57;	author kettenis;	state Exp;
branches;
next	1.137;

1.137
date	2013.12.23.17.29.15;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2013.12.23.14.13.03;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2013.12.23.13.57.44;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2013.12.23.10.39.10;	author kettenis;	state Exp;
branches;
next	1.133;

1.133
date	2013.06.01.09.57.55;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.131;

1.131
date	2013.03.20.21.49.59;	author kurt;	state Exp;
branches;
next	1.130;

1.130
date	2013.01.11.21.17.07;	author miod;	state Exp;
branches;
next	1.129;

1.129
date	2012.06.12.20.32.17;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	2012.05.08.14.32.01;	author jsing;	state Exp;
branches;
next	1.127;

1.127
date	2012.01.08.19.44.34;	author kettenis;	state Exp;
branches;
next	1.126;

1.126
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.27.16.47.50;	author sthen;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.22.22.43.47;	author drahn;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.09.18.13.34;	author otto;	state Exp;
branches;
next	1.122;

1.122
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.07.18.29.28;	author drahn;	state Exp;
branches;
next	1.120;

1.120
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.119;

1.119
date	2010.07.01.19.25.44;	author drahn;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.02.12.16.35;	author kettenis;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.04.19.44.51;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.115;

1.115
date	2008.06.13.23.52.42;	author kurt;	state Exp;
branches;
next	1.114;

1.114
date	2008.06.12.19.50.04;	author kurt;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.112;

1.112
date	2007.11.27.16.42.15;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.03.14.33.07;	author jason;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.02.15.24.19;	author drahn;	state Exp;
branches;
next	1.109;

1.109
date	2007.01.28.21.28.23;	author drahn;	state Exp;
branches;
next	1.108;

1.108
date	2006.11.21.20.15.55;	author drahn;	state Exp;
branches;
next	1.107;

1.107
date	2006.11.15.19.14.21;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2006.11.10.21.19.54;	author drahn;	state Exp;
branches;
next	1.105;

1.105
date	2006.11.10.07.44.58;	author drahn;	state Exp;
branches;
next	1.104;

1.104
date	2006.09.24.21.52.49;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.08.20.37.01;	author deraadt;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2006.05.08.20.34.36;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.09.16.41.29;	author kurt;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2005.10.21.15.24.10;	author kurt;	state Exp;
branches;
next	1.98;

1.98
date	2005.10.16.04.14.22;	author kurt;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.96;

1.96
date	2005.10.10.16.33.51;	author kurt;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.07.01.26.34;	author kurt;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.28.18.17.42;	author kurt;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.22.22.33.40;	author drahn;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.21.23.12.09;	author drahn;	state Exp;
branches;
next	1.88;

1.88
date	2005.09.19.02.31.04;	author drahn;	state Exp;
branches;
next	1.87;

1.87
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.83;

1.83
date	2004.08.11.17.13.10;	author pefo;	state Exp;
branches;
next	1.82;

1.82
date	2004.08.11.17.11.45;	author pefo;	state Exp;
branches;
next	1.81;

1.81
date	2004.05.27.21.59.07;	author mickey;	state Exp;
branches;
next	1.80;

1.80
date	2004.05.26.19.14.14;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2004.05.25.21.48.00;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.25.20.51.03;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.24.20.24.54;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.24.20.16.12;	author drahn;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.23.20.47.39;	author drahn;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.10.14.12.22;	author drahn;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.07.06.00.48;	author drahn;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.04.16.13.33;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.03.23.03.37;	author drahn;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.04.19.33.48;	author drahn;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.09.21.01.10;	author drahn;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.03.18.04.08;	author drahn;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.30.19.07.34;	author drahn;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.30.16.00.43;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.30.15.58.24;	author drahn;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.30.03.14.12;	author drahn;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.30.01.33.05;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.15.22.43.06;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.30.03.46.46;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.25.10.39.51;	author pefo;	state Exp;
branches;
next	1.50;

1.50
date	2002.10.21.16.01.55;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2002.08.23.23.02.48;	author drahn;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.12.01.05.23;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.11.18.41.17;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.09.14.35.43;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.27.15.40.44;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.27.13.19.26;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.24.01.05.11;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.05.23.13.55;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.28.00.34.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.28.00.31.37;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.28.00.30.50;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.28.00.30.19;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.28.00.23.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.31.21.56.58;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.17.19.02.30;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.17.00.22.04;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.07.00.53.26;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.26.22.58.23;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.25.07.01.39;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.24.23.42.25;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.24.21.35.09;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.22.04.58.18;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.15.20.44.52;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.13.08.40.39;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.06.12.31.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.06.12.23.18;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.06.10.59.15;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.01.09.20.58;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.31.13.58.24;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.31.13.53.56;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.28.21.38.14;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.14.22.18.19;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.12.10.39.54;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.02.23.11.20;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.03.22.11.41;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.23.15.56.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.13.05.21.10;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.17.17.50.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.02.36.37;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.34.06;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.34.06;	author rahnds;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.06.13.03.40.05;	author rahnds;	state Exp;
branches;
next	;

1.100.2.1
date	2006.11.15.23.12.40;	author brad;	state Exp;
branches;
next	;

1.103.2.1
date	2006.11.15.23.04.36;	author brad;	state Exp;
branches;
next	;


desc
@@


1.170
log
@Provide size-generic ELF_NO_ADDR in <sys/exec_elf.h> and use that instead
of ELFDEFNNAME(NO_ADDR)

ok jca@@
@
text
@/*	$OpenBSD: loader.c,v 1.169 2017/01/24 07:48:36 guenther Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define	_DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <nlist.h>
#include <string.h>
#include <link.h>
#include <limits.h>			/* NAME_MAX */
#include <dlfcn.h>

#include "syscall.h"
#include "archdep.h"
#include "path.h"
#include "resolve.h"
#include "sod.h"
#include "stdlib.h"

/*
 * Local decls.
 */
unsigned long _dl_boot(const char **, char **, const long, long *);
void _dl_debug_state(void);
void _dl_setup_env(const char *_argv0, char **_envp);
void _dl_dtors(void);
void _dl_fixup_user_env(void);
void _dl_call_preinit(elf_object_t *);
void _dl_call_init_recurse(elf_object_t *object, int initfirst);

int  _dl_pagesz;

char **_dl_libpath;

char *_dl_preload;
char *_dl_bindnow;
char *_dl_traceld;
char *_dl_debug;
char *_dl_showmap;
char *_dl_tracefmt1, *_dl_tracefmt2, *_dl_traceprog;

int _dl_trust;

struct r_debug *_dl_debug_map;

void _dl_dopreload(char *paths);

/*
 * Run dtors for a single object.
 */
void
_dl_run_dtors(elf_object_t *obj)
{
	if (obj->dyn.fini_array) {
		int num = obj->dyn.fini_arraysz / sizeof(Elf_Addr);
		int i;

		DL_DEB(("doing finiarray obj %p @@%p: [%s]\n",
		    obj, obj->dyn.fini_array, obj->load_name));
		for (i = num; i > 0; i--)
			(*obj->dyn.fini_array[i-1])();
	}

	if (obj->dyn.fini) {
		DL_DEB(("doing dtors obj %p @@%p: [%s]\n",
		    obj, obj->dyn.fini, obj->load_name));
		(*obj->dyn.fini)();
	}
}

/*
 * Run dtors for all objects that are eligible.
 */
void
_dl_run_all_dtors(void)
{
	elf_object_t *node;
	struct dep_node *dnode;
	int fini_complete;
	int skip_initfirst;
	int initfirst_skipped;

	fini_complete = 0;
	skip_initfirst = 1;
	initfirst_skipped = 0;

	while (fini_complete == 0) {
		fini_complete = 1;
		for (node = _dl_objects;
		    node != NULL;
		    node = node->next) {
			if ((node->dyn.fini || node->dyn.fini_array) &&
			    (OBJECT_REF_CNT(node) == 0) &&
			    (node->status & STAT_INIT_DONE) &&
			    ((node->status & STAT_FINI_DONE) == 0)) {
				if (skip_initfirst &&
				    (node->obj_flags & DF_1_INITFIRST))
					initfirst_skipped = 1;
				else
					node->status |= STAT_FINI_READY;
			    }
		}
		for (node = _dl_objects;
		    node != NULL;
		    node = node->next ) {
			if ((node->dyn.fini || node->dyn.fini_array) &&
			    (OBJECT_REF_CNT(node) == 0) &&
			    (node->status & STAT_INIT_DONE) &&
			    ((node->status & STAT_FINI_DONE) == 0) &&
			    (!skip_initfirst ||
			    (node->obj_flags & DF_1_INITFIRST) == 0))
				TAILQ_FOREACH(dnode, &node->child_list,
				    next_sib)
					dnode->data->status &= ~STAT_FINI_READY;
		}


		for (node = _dl_objects;
		    node != NULL;
		    node = node->next ) {
			if (node->status & STAT_FINI_READY) {
				fini_complete = 0;
				node->status |= STAT_FINI_DONE;
				node->status &= ~STAT_FINI_READY;
				_dl_run_dtors(node);
			}
		}

		if (fini_complete && initfirst_skipped)
			fini_complete = initfirst_skipped = skip_initfirst = 0;
	}
}

/*
 * Routine to walk through all of the objects except the first
 * (main executable).
 *
 * Big question, should dlopen()ed objects be unloaded before or after
 * the destructor for the main application runs?
 */
void
_dl_dtors(void)
{
	_dl_thread_kern_stop();

	/* ORDER? */
	_dl_unload_dlopen();

	DL_DEB(("doing dtors\n"));

	_dl_objects->opencount--;
	_dl_notify_unload_shlib(_dl_objects);

	_dl_run_all_dtors();
}

void
_dl_dopreload(char *paths)
{
	char		*cp, *dp;
	elf_object_t	*shlib;

	dp = paths = _dl_strdup(paths);
	if (dp == NULL)
		_dl_oom();

	while ((cp = _dl_strsep(&dp, ":")) != NULL) {
		shlib = _dl_load_shlib(cp, _dl_objects, OBJTYPE_LIB,
		_dl_objects->obj_flags);
		if (shlib == NULL)
			_dl_die("can't preload library '%s'", cp);
		_dl_add_object(shlib);
		_dl_link_child(shlib, _dl_objects);
	}
	_dl_free(paths);
	return;
}

/*
 * grab interesting environment variables, zap bad env vars if
 * issetugid, and set the exported environ and __progname variables
 */
char **environ = NULL;
char *__progname = NULL;
void
_dl_setup_env(const char *argv0, char **envp)
{
	static char progname_storage[NAME_MAX+1] = "";

	/*
	 * Get paths to various things we are going to use.
	 */
	_dl_debug = _dl_getenv("LD_DEBUG", envp);
	_dl_libpath = _dl_split_path(_dl_getenv("LD_LIBRARY_PATH", envp));
	_dl_preload = _dl_getenv("LD_PRELOAD", envp);
	_dl_bindnow = _dl_getenv("LD_BIND_NOW", envp);
	_dl_traceld = _dl_getenv("LD_TRACE_LOADED_OBJECTS", envp);
	_dl_tracefmt1 = _dl_getenv("LD_TRACE_LOADED_OBJECTS_FMT1", envp);
	_dl_tracefmt2 = _dl_getenv("LD_TRACE_LOADED_OBJECTS_FMT2", envp);
	_dl_traceprog = _dl_getenv("LD_TRACE_LOADED_OBJECTS_PROGNAME", envp);

	/*
	 * Don't allow someone to change the search paths if he runs
	 * a suid program without credentials high enough.
	 */
	_dl_trust = !_dl_issetugid();
	if (!_dl_trust) {	/* Zap paths if s[ug]id... */
		if (_dl_libpath) {
			_dl_free_path(_dl_libpath);
			_dl_libpath = NULL;
			_dl_unsetenv("LD_LIBRARY_PATH", envp);
		}
		if (_dl_preload) {
			_dl_preload = NULL;
			_dl_unsetenv("LD_PRELOAD", envp);
		}
		if (_dl_bindnow) {
			_dl_bindnow = NULL;
			_dl_unsetenv("LD_BIND_NOW", envp);
		}
		if (_dl_debug) {
			_dl_debug = NULL;
			_dl_unsetenv("LD_DEBUG", envp);
		}
	}
	environ = envp;

	_dl_trace_setup(envp);

	if (argv0 != NULL) {		/* NULL ptr if argc = 0 */
		const char *p = _dl_strrchr(argv0, '/');

		if (p == NULL)
			p = argv0;
		else
			p++;
		_dl_strlcpy(progname_storage, p, sizeof(progname_storage));
	}
	__progname = progname_storage;
}

int
_dl_load_dep_libs(elf_object_t *object, int flags, int booting)
{
	elf_object_t *dynobj;
	Elf_Dyn *dynp;
	unsigned int loop;
	int libcount;
	int depflags;

	dynobj = object;
	while (dynobj) {
		DL_DEB(("examining: '%s'\n", dynobj->load_name));
		libcount = 0;

		/* propagate DF_1_NOW to deplibs (can be set by dynamic tags) */
		depflags = flags | (dynobj->obj_flags & DF_1_NOW);

		for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			if (dynp->d_tag == DT_NEEDED) {
				libcount++;
			}
		}

		if ( libcount != 0) {
			struct listent {
				Elf_Dyn *dynp;
				elf_object_t *depobj;
			} *liblist;
			int *randomlist;

			liblist = _dl_reallocarray(NULL, libcount,
			    sizeof(struct listent));
			randomlist =  _dl_reallocarray(NULL, libcount,
			    sizeof(int));

			if (liblist == NULL || randomlist == NULL)
				_dl_oom();

			for (dynp = dynobj->load_dyn, loop = 0; dynp->d_tag;
			    dynp++)
				if (dynp->d_tag == DT_NEEDED)
					liblist[loop++].dynp = dynp;

			/* Randomize these */
			for (loop = 0; loop < libcount; loop++)
				randomlist[loop] = loop;

			for (loop = 1; loop < libcount; loop++) {
				unsigned int rnd;
				int cur;
				rnd = _dl_arc4random();
				rnd = rnd % (loop+1);
				cur = randomlist[rnd];
				randomlist[rnd] = randomlist[loop];
				randomlist[loop] = cur;
			}

			for (loop = 0; loop < libcount; loop++) {
				elf_object_t *depobj;
				const char *libname;
				libname = dynobj->dyn.strtab;
				libname +=
				    liblist[randomlist[loop]].dynp->d_un.d_val;
				DL_DEB(("loading: %s required by %s\n", libname,
				    dynobj->load_name));
				depobj = _dl_load_shlib(libname, dynobj,
				    OBJTYPE_LIB, depflags);
				if (depobj == 0) {
					if (booting) {
						_dl_die(
						    "can't load library '%s'",
						    libname);
					}
					DL_DEB(("dlopen: failed to open %s\n",
					    libname));
					_dl_free(liblist);
					_dl_free(randomlist);
					return (1);
				}
				liblist[randomlist[loop]].depobj = depobj;
			}

			for (loop = 0; loop < libcount; loop++) {
				_dl_add_object(liblist[loop].depobj);
				_dl_link_child(liblist[loop].depobj, dynobj);
			}
			_dl_free(liblist);
			_dl_free(randomlist);
		}
		dynobj = dynobj->next;
	}

	/* add first object manually */
	_dl_link_grpsym(object, 1);
	_dl_cache_grpsym_list_setup(object);

	return(0);
}


#define PFLAGS(X) ((((X) & PF_R) ? PROT_READ : 0) | \
		   (((X) & PF_W) ? PROT_WRITE : 0) | \
		   (((X) & PF_X) ? PROT_EXEC : 0))

/*
 * This is the dynamic loader entrypoint. When entering here, depending
 * on architecture type, the stack and registers are set up according
 * to the architectures ABI specification. The first thing required
 * to do is to dig out all information we need to accomplish our task.
 */
unsigned long
_dl_boot(const char **argv, char **envp, const long dyn_loff, long *dl_data)
{
	struct elf_object *exe_obj;	/* Pointer to executable object */
	struct elf_object *dyn_obj;	/* Pointer to ld.so object */
	struct r_debug **map_link;	/* Where to put pointer for gdb */
	struct r_debug *debug_map;
	struct load_list *next_load, *load_list = NULL;
	Elf_Dyn *dynp;
	Elf_Phdr *phdp;
	Elf_Ehdr *ehdr;
	char *us = NULL;
	unsigned int loop;
	int failed;
	struct dep_node *n;
	Elf_Addr minva, maxva, exe_loff;
	Elf_Phdr *ptls = NULL;
	int align;

	if (dl_data[AUX_pagesz] != 0)
		_dl_pagesz = dl_data[AUX_pagesz];
	else
		_dl_pagesz = 4096;

	align = _dl_pagesz - 1;

#define ROUND_PG(x) (((x) + align) & ~(align))
#define TRUNC_PG(x) ((x) & ~(align))

	_dl_setup_env(argv[0], envp);

	DL_DEB(("rtld loading: '%s'\n", __progname));

	/* init this in runtime, not statically */
	TAILQ_INIT(&_dlopened_child_list);

	exe_obj = NULL;
	_dl_loading_object = NULL;

	minva = ELF_NO_ADDR;
	maxva = exe_loff = 0;

	/*
	 * Examine the user application and set up object information.
	 */
	phdp = (Elf_Phdr *)dl_data[AUX_phdr];
	for (loop = 0; loop < dl_data[AUX_phnum]; loop++) {
		switch (phdp->p_type) {
		case PT_PHDR:
			exe_loff = (Elf_Addr)dl_data[AUX_phdr] - phdp->p_vaddr;
			us += exe_loff;
			DL_DEB(("exe load offset:  0x%lx\n", exe_loff));
			break;
		case PT_DYNAMIC:
			minva = TRUNC_PG(minva);
			maxva = ROUND_PG(maxva);
			exe_obj = _dl_finalize_object(argv[0] ? argv[0] : "",
			    (Elf_Dyn *)(phdp->p_vaddr + exe_loff),
			    (Elf_Phdr *)dl_data[AUX_phdr],
			    dl_data[AUX_phnum], OBJTYPE_EXE, minva + exe_loff,
			    exe_loff);
			_dl_add_object(exe_obj);
			break;
		case PT_INTERP:
			us += phdp->p_vaddr;
			break;
		case PT_LOAD:
			if (phdp->p_vaddr < minva)
				minva = phdp->p_vaddr;
			if (phdp->p_vaddr > maxva)
				maxva = phdp->p_vaddr + phdp->p_memsz;

			next_load = _dl_calloc(1, sizeof(struct load_list));
			if (next_load == NULL)
				_dl_oom();
			next_load->next = load_list;
			load_list = next_load;
			next_load->start = (char *)TRUNC_PG(phdp->p_vaddr) + exe_loff;
			next_load->size = (phdp->p_vaddr & align) + phdp->p_filesz;
			next_load->prot = PFLAGS(phdp->p_flags);
			break;
		case PT_TLS:
			if (phdp->p_filesz > phdp->p_memsz)
				_dl_die("invalid tls data");
			ptls = phdp;
			break;
		case PT_GNU_RELRO:
			exe_obj->relro_addr = phdp->p_vaddr + exe_loff;
			exe_obj->relro_size = phdp->p_memsz;
			break;
		}
		phdp++;
	}
	exe_obj->load_list = load_list;
	exe_obj->obj_flags |= DF_1_GLOBAL;
	exe_obj->load_size = maxva - minva;
	_dl_set_sod(exe_obj->load_name, &exe_obj->sod);

	/* TLS bits in the base executable */
	if (ptls != NULL && ptls->p_memsz)
		_dl_set_tls(exe_obj, ptls, exe_loff, NULL);

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_oom();
	n->data = exe_obj;
	TAILQ_INSERT_TAIL(&_dlopened_child_list, n, next_sib);
	exe_obj->opencount++;

	if (_dl_preload != NULL)
		_dl_dopreload(_dl_preload);

	_dl_load_dep_libs(exe_obj, exe_obj->obj_flags, 1);

	/*
	 * Now add the dynamic loader itself last in the object list
	 * so we can use the _dl_ code when serving dl.... calls.
	 * Intentionally left off the exe child_list.
	 */
	dynp = (Elf_Dyn *)((void *)_DYNAMIC);
	ehdr = (Elf_Ehdr *)dl_data[AUX_base];
	dyn_obj = _dl_finalize_object(us, dynp,
	    (Elf_Phdr *)((char *)dl_data[AUX_base] + ehdr->e_phoff),
	    ehdr->e_phnum, OBJTYPE_LDR, dl_data[AUX_base], dyn_loff);
	_dl_add_object(dyn_obj);

	dyn_obj->refcount++;
	_dl_link_grpsym(dyn_obj, 1);

	dyn_obj->status |= STAT_RELOC_DONE;
	_dl_set_sod(dyn_obj->load_name, &dyn_obj->sod);

	/* calculate the offsets for static TLS allocations */
	_dl_allocate_tls_offsets();

	/*
	 * Make something to help gdb when poking around in the code.
	 * Do this poking at the .dynamic section now, before relocation
	 * renders it read-only
	 */
	map_link = NULL;
#ifdef __mips__
	map_link = (struct r_debug **)(exe_obj->Dyn.info[DT_MIPS_RLD_MAP -
	    DT_LOPROC + DT_NUM]);
#endif
	if (map_link == NULL) {
		for (dynp = exe_obj->load_dyn; dynp->d_tag; dynp++) {
			if (dynp->d_tag == DT_DEBUG) {
				map_link = (struct r_debug **)&dynp->d_un.d_ptr;
				break;
			}
		}
		if (dynp->d_tag != DT_DEBUG)
			DL_DEB(("failed to mark DTDEBUG\n"));
	}
	if (map_link) {
		debug_map = _dl_malloc(sizeof(*debug_map));
		if (debug_map == NULL)
			_dl_oom();
		debug_map->r_version = 1;
		debug_map->r_map = (struct link_map *)_dl_objects;
		debug_map->r_brk = (Elf_Addr)_dl_debug_state;
		debug_map->r_state = RT_CONSISTENT;
		debug_map->r_ldbase = dyn_loff;
		_dl_debug_map = debug_map;
#ifdef __mips__
		if (dynp->d_tag == DT_DEBUG)
			_dl_mprotect(map_link, sizeof(*map_link),
			    PROT_READ|PROT_WRITE);
#endif
		*map_link = _dl_debug_map;
#ifdef __mips__
		if (dynp->d_tag == DT_DEBUG)
			_dl_mprotect(map_link, sizeof(*map_link),
			    PROT_READ|PROT_EXEC);
#endif
	}


	/*
	 * Everything should be in place now for doing the relocation
	 * and binding. Call _dl_rtld to do the job. Fingers crossed.
	 */

	failed = 0;
	if (_dl_traceld == NULL)
		failed = _dl_rtld(_dl_objects);

	if (_dl_debug || _dl_traceld) {
		if (_dl_traceld)
			_dl_pledge("stdio rpath", NULL);
		_dl_show_objects();
	}

	DL_DEB(("dynamic loading done, %s.\n",
	    (failed == 0) ? "success":"failed"));

	if (failed != 0)
		_dl_die("relocation failed");

	if (_dl_traceld)
		_dl_exit(0);

	_dl_loading_object = NULL;

	/* set up the TIB for the initial thread */
	_dl_allocate_first_tib();

	_dl_fixup_user_env();

	_dl_debug_state();

	/*
	 * Do not run init code if run from ldd.
	 */
	if (_dl_objects->next != NULL) {
		_dl_call_preinit(_dl_objects);
		_dl_call_init(_dl_objects);
	}

	DL_DEB(("entry point: 0x%lx\n", dl_data[AUX_entry]));

	/*
	 * Return the entry point.
	 */
	return(dl_data[AUX_entry]);
}

#define DL_SM_SYMBUF_CNT 512
sym_cache _dl_sm_symcache_buffer[DL_SM_SYMBUF_CNT];

int
_dl_rtld(elf_object_t *object)
{
	size_t sz;
	struct load_list *llist;
	int fails = 0;

	if (object->next)
		fails += _dl_rtld(object->next);

	if (object->status & STAT_RELOC_DONE)
		return 0;

	sz = 0;
	if (object->nchains < DL_SM_SYMBUF_CNT) {
		_dl_symcache = _dl_sm_symcache_buffer;
//		DL_DEB(("using static buffer for %d entries\n",
//		    object->nchains));
		_dl_memset(_dl_symcache, 0,
		    sizeof (sym_cache) * object->nchains);
	} else {
		sz = ELF_ROUND(sizeof (sym_cache) * object->nchains,
		    _dl_pagesz);
//		DL_DEB(("allocating symcache sz %x with mmap\n", sz));

		_dl_symcache = (void *)_dl_mmap(0, sz, PROT_READ|PROT_WRITE,
		    MAP_PRIVATE|MAP_ANON, -1, 0);
		if (_dl_mmap_error(_dl_symcache)) {
			sz = 0;
			_dl_symcache = NULL;
		}
	}

	/*
	 * Do relocation information first, then GOT.
	 */
	fails =_dl_md_reloc(object, DT_REL, DT_RELSZ);
	fails += _dl_md_reloc(object, DT_RELA, DT_RELASZ);
	fails += _dl_md_reloc_got(object, !(_dl_bindnow ||
	    object->obj_flags & DF_1_NOW));

	/*
	 * Look for W&X segments and make them read-only.
	 */
	for (llist = object->load_list; llist != NULL; llist = llist->next) {
		if ((llist->prot & PROT_WRITE) && (llist->prot & PROT_EXEC)) {
			_dl_mprotect(llist->start, llist->size,
			    llist->prot & ~PROT_WRITE);
		}
	}

	if (_dl_symcache != NULL) {
		if (sz != 0)
			_dl_munmap( _dl_symcache, sz);
		_dl_symcache = NULL;
	}
	if (fails == 0)
		object->status |= STAT_RELOC_DONE;

	return (fails);
}

void
_dl_call_preinit(elf_object_t *object)
{
	if (object->dyn.preinit_array) {
		int num = object->dyn.preinit_arraysz / sizeof(Elf_Addr);
		int i;

		DL_DEB(("doing preinitarray obj %p @@%p: [%s]\n",
		    object, object->dyn.preinit_array, object->load_name));
		for (i = 0; i < num; i++)
			(*object->dyn.preinit_array[i])();
	}
}

void
_dl_call_init(elf_object_t *object)
{
	_dl_call_init_recurse(object, 1);
	_dl_call_init_recurse(object, 0);
}

void
_dl_call_init_recurse(elf_object_t *object, int initfirst)
{
	struct dep_node *n;

	object->status |= STAT_VISITED;

	TAILQ_FOREACH(n, &object->child_list, next_sib) {
		if (n->data->status & STAT_VISITED)
			continue;
		_dl_call_init_recurse(n->data, initfirst);
	}

	object->status &= ~STAT_VISITED;

	if (object->status & STAT_INIT_DONE)
		return;

	if (initfirst && (object->obj_flags & DF_1_INITFIRST) == 0)
		return;

	if (object->dyn.init) {
		DL_DEB(("doing ctors obj %p @@%p: [%s]\n",
		    object, object->dyn.init, object->load_name));
		(*object->dyn.init)();
	}

	if (object->dyn.init_array) {
		int num = object->dyn.init_arraysz / sizeof(Elf_Addr);
		int i;

		DL_DEB(("doing initarray obj %p @@%p: [%s]\n",
		    object, object->dyn.init_array, object->load_name));
		for (i = 0; i < num; i++)
			(*object->dyn.init_array[i])();
	}

	object->status |= STAT_INIT_DONE;
}

char *
_dl_getenv(const char *var, char **env)
{
	const char *ep;

	while ((ep = *env++)) {
		const char *vp = var;

		while (*vp && *vp == *ep) {
			vp++;
			ep++;
		}
		if (*vp == '\0' && *ep++ == '=')
			return((char *)ep);
	}
	return(NULL);
}

void
_dl_unsetenv(const char *var, char **env)
{
	char *ep;

	while ((ep = *env)) {
		const char *vp = var;

		while (*vp && *vp == *ep) {
			vp++;
			ep++;
		}
		if (*vp == '\0' && *ep++ == '=') {
			char **P;

			for (P = env;; ++P)
				if (!(*P = *(P + 1)))
					break;
		} else
			env++;
	}
}

/*
 * _dl_fixup_user_env()
 *
 * Set the user environment so that programs can use the environment
 * while running constructors. Specifically, MALLOC_OPTIONS= for malloc()
 */
void
_dl_fixup_user_env(void)
{
	const struct elf_object *obj;
	const Elf_Sym *sym;
	Elf_Addr ooff;
	struct elf_object dummy_obj;

	dummy_obj.dyn.symbolic = 0;
	dummy_obj.load_name = "ld.so";

	sym = NULL;
	ooff = _dl_find_symbol("environ", &sym,
	    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, &dummy_obj, &obj);
	if (sym != NULL) {
		DL_DEB(("setting environ %p@@%s[%p] from %p\n",
		    (void *)(sym->st_value + ooff), obj->load_name,
		    (void *)obj, (void *)&environ));
		if ((char ***)(sym->st_value + ooff) != &environ)
			*((char ***)(sym->st_value + ooff)) = environ;
	}

	sym = NULL;
	ooff = _dl_find_symbol("__progname", &sym,
	    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, &dummy_obj, &obj);
	if (sym != NULL) {
		DL_DEB(("setting __progname %p@@%s[%p] from %p\n",
		    (void *)(sym->st_value + ooff), obj->load_name,
		    (void *)obj, (void *)&__progname));
		if ((char **)(sym->st_value + ooff) != &__progname)
			*((char **)(sym->st_value + ooff)) = __progname;
	}
}
@


1.169
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.168 2017/01/09 22:51:04 kettenis Exp $ */
d419 1
a419 1
	minva = ELFDEFNNAME(NO_ADDR);
@


1.168
log
@Remove dependency on __got_{start,end} symbols and look at PT_GNU_RELRO
instead.  Result in a few more pages that aren't writable on some platforms
(such as hppa).  Based on an initial diff from guenther@@.

Thanks to deraadt@@ for testing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.167 2016/08/28 04:33:17 guenther Exp $ */
d192 2
a193 4
	if (dp == NULL) {
		_dl_printf("preload: out of memory");
		_dl_exit(1);
	}
d198 2
a199 5
		if (shlib == NULL) {
			_dl_printf("%s: can't preload library '%s'\n",
			    __progname, cp);
			_dl_exit(4);
		}
d306 1
a306 1
				_dl_exit(5);
d339 3
a341 10
						_dl_printf(
						    "%s: can't load library '%s'\n",
						    __progname, libname);
						_dl_exit(4);
					} else  {
						DL_DEB(("dlopen: failed to open %s\n",
						    libname));
						_dl_free(liblist);
						_dl_free(randomlist);
						return (1);
d343 5
d454 1
a454 1
				_dl_exit(5);
d462 2
a463 5
			if (phdp->p_filesz > phdp->p_memsz) {
				_dl_printf("%s: invalid tls data.\n",
				    __progname);
				_dl_exit(5);
			}
d484 1
a484 1
		_dl_exit(5);
d538 1
a538 1
			_dl_exit(5);
d578 1
a578 1
		_dl_exit(1);
@


1.167
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.166 2016/08/23 06:46:17 kettenis Exp $ */
a414 19

	/*
	 * now that GOT and PLT have been relocated, and we know
	 * page size, protect them from modification
	 */
#ifndef  RTLD_NO_WXORX
	{
		extern char *__got_start;
		extern char *__got_end;

		if (&__got_start != &__got_end) {
			_dl_mprotect((void *)ELF_TRUNC((long)&__got_start,
			    _dl_pagesz),
			    ELF_ROUND((long)&__got_end,_dl_pagesz) -
			    ELF_TRUNC((long)&__got_start, _dl_pagesz),
			    GOT_PERMS);
		}
	}
#endif
@


1.166
log
@Implement support for DT_INIT_ARRAY, DT_FINI_ARRAY and DT_PREINIT_ARRAY.
Don't skip DT_INIT and DT_FINI for the main executable.  This matches what
Linux and Solaris do.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.165 2016/08/14 04:30:39 guenther Exp $ */
d682 1
a682 1
	 * Look for W|X segments and make them read-only.
@


1.165
log
@Mark the relro/got section as read-only before setting up the environment
to minimize the amount of code run without it RO.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.164 2016/08/12 20:39:01 deraadt Exp $ */
d56 1
d77 23
a101 1

d117 1
a117 1
		for (node = _dl_objects->next;
d120 1
a120 1
			if ((node->dyn.fini) &&
d131 1
a131 1
		for (node = _dl_objects->next;
d134 1
a134 1
			if ((node->dyn.fini) &&
d146 1
a146 1
		for (node = _dl_objects->next;
a149 4
				DL_DEB(("doing dtors obj %p @@%p: [%s]\n",
				    node, node->dyn.fini,
				    node->load_name));

d153 1
a153 1
				(*node->dyn.fini)();
a178 5
	/* main program runs its dtors itself
	 * but we want to run dtors on all it's children);
	 */
	_dl_objects->status |= STAT_FINI_DONE;

a621 4
	 * The first object is the executable itself,
	 * it is responsible for running it's own ctors/dtors
	 * thus do NOT run the ctors for the executable, all of
	 * the shared libraries which follow.
d625 1
a625 1
		_dl_objects->status |= STAT_INIT_DONE;
d703 14
d748 10
@


1.164
log
@the slimmed down random functions inside ld.so are strict clones of the
libc arc4random API, so call them _dl_{arc4random,arcrandombuf}
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.163 2016/08/08 21:59:20 guenther Exp $ */
a391 2
	_dl_setup_env(argv[0], envp);

d420 2
@


1.163
log
@Look for a PT_GNU_RELRO section per object and, if present, mprotect that
range instead of the [__got_start, __got_end) range.
On many archs this will cover _DYNAMIC too, so move up the DT_DEBUG handling
to before relocations and the mprotect are done.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.162 2016/07/04 21:15:06 guenther Exp $ */
d311 1
a311 1
				rnd = _dl_random();
@


1.162
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.161 2016/06/08 11:58:59 kettenis Exp $ */
d481 4
d531 3
a533 31
	 * Everything should be in place now for doing the relocation
	 * and binding. Call _dl_rtld to do the job. Fingers crossed.
	 */
	failed = 0;
	if (_dl_traceld == NULL)
		failed = _dl_rtld(_dl_objects);

	if (_dl_debug || _dl_traceld) {
		if (_dl_traceld)
			_dl_pledge("stdio rpath", NULL);
		_dl_show_objects();
	}

	DL_DEB(("dynamic loading done, %s.\n",
	    (failed == 0) ? "success":"failed"));

	if (failed != 0)
		_dl_exit(1);

	if (_dl_traceld)
		_dl_exit(0);

	_dl_loading_object = NULL;

	/* set up the TIB for the initial thread */
	_dl_allocate_first_tib();

	_dl_fixup_user_env();

	/*
	 * Finally make something to help gdb when poking around in the code.
d572 32
@


1.161
log
@Some ELF ABIs still require a PLT that is both writable and executable.  To
avoid W^X violations, initially map such segments as writable and
non-executable, and change the mapping to non-writable and executable
after initial relocation processing.  As a side-benefit this means we no
longer depend on the __plt_start and __plt_end to make the PLT read-only
after relocation processing.

This will break binaries linked with ld -Z, most notably emacs, on some
of our architectures.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.160 2016/06/05 19:43:58 kettenis Exp $ */
a46 1
#include "dl_prebind.h"
a66 2
char *_dl_noprebind;
char *_dl_prebind_validate;
a219 2
	_dl_noprebind = _dl_getenv("LD_NOPREBIND", envp);
	_dl_prebind_validate = _dl_getenv("LD_PREBINDVALIDATE", envp);
a471 5

			if (phdp->p_flags & 0x08000000) {
//				dump_prelink(phdp->p_vaddr + exe_loff, phdp->p_memsz);
				prebind_load_exe(phdp, exe_obj);
			}
a529 2

	_dl_prebind_pre_resolve();
a533 2
	_dl_prebind_post_resolve();

a653 1
	prebind_symcache(object, SYM_NOTPLT);
a659 1
	prebind_symcache(object, SYM_PLT);
@


1.160
log
@Avoid W^X violation when setting DT_DEBUG on mips64.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.159 2016/05/07 19:05:23 guenther Exp $ */
d640 1
d678 10
@


1.159
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.158 2016/03/24 05:27:19 guenther Exp $ */
d601 1
a601 1
			    PROT_READ|PROT_WRITE|PROT_EXEC);
@


1.158
log
@Unbreak arm and m88k: COPY relocations for weak symbols that are overloaded
with strong symbols in ld.so don't do what we need, so put definitions back
in crt0 and make ld.so update __progname like it does environ.

report and testing patrick@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.157 2016/03/20 02:29:51 guenther Exp $ */
d394 1
d484 6
a489 3
			_dl_printf("%s: unsupported TLS program header\n",
			    __progname);
			_dl_exit(1);
d499 4
d533 3
d564 3
@


1.157
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.156 2015/11/15 03:41:24 deraadt Exp $ */
d773 1
a773 1
	if (sym != NULL && (char ***)(sym->st_value + ooff) != &environ) {
d777 13
a789 1
		*((char ***)(sym->st_value + ooff)) = environ;
@


1.156
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.155 2015/08/18 17:34:44 deraadt Exp $ */
d38 1
d54 1
a54 1
void _dl_setup_env(char **);
a58 1
const char *_dl_progname;
d191 1
a191 1
			    _dl_progname, cp);
d203 1
a203 1
 * issetugid
d205 2
a206 1
char **_dl_so_envp;
d208 1
a208 1
_dl_setup_env(char **envp)
d210 2
d250 1
a250 1
	_dl_so_envp = envp;
d253 11
d337 1
a337 1
						    _dl_progname, libname);
d382 1
a382 1
	struct elf_object *dyn_obj;	/* Pointer to executable object */
d396 1
a396 1
	_dl_setup_env(envp);
a397 1
	_dl_progname = argv[0];
d427 1
a427 1
	DL_DEB(("rtld loading: '%s'\n", _dl_progname));
d484 1
a484 1
			    _dl_progname);
d762 1
d772 7
a778 3
	    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, &dummy_obj, NULL);
	if (sym != NULL)
		*((char ***)(sym->st_value + ooff)) = _dl_so_envp;
@


1.155
log
@_dl_malloc() proto exists, do not cast result
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.154 2015/05/06 01:03:31 jsg Exp $ */
d524 3
a526 1
	if (_dl_debug || _dl_traceld)
d528 1
@


1.154
log
@Fix a memory leak in _dl_load_dep_libs()
ok otto@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.153 2015/01/22 05:48:17 deraadt Exp $ */
d559 1
a559 1
		debug_map = (struct r_debug *)_dl_malloc(sizeof(*debug_map));
@


1.153
log
@delete annoying white space that annoy
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.152 2015/01/16 16:18:07 deraadt Exp $ */
d329 1
d341 1
@


1.152
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.151 2014/11/03 17:50:56 guenther Exp $ */
d142 1
a142 1
                        fini_complete = initfirst_skipped = skip_initfirst = 0;
d499 1
a499 1
        dyn_obj = _dl_finalize_object(us, dynp,
@


1.151
log
@Eliminate RTLD_PROTECT_PLT: ld.so is built with -Bsymbolic so the
PLT is empty/unused.  On at least macppc and sparc64, ld.so's attempt
to mprotect its PLT could instead hit its own allocated data and
cause a segfault shortly there after.

While here, take a shot at preventing the same issue with the GOT
by checking for __got_start != __got_end.

reproduction *with ktracing* by afresh1@@ provided the key data
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.150 2014/07/10 09:03:01 otto Exp $ */
a33 1
#include <sys/param.h>
@


1.150
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.149 2014/07/06 19:15:16 otto Exp $ */
d402 8
a409 17
#ifdef RTLD_PROTECT_PLT
		extern char *__plt_start;
		extern char *__plt_end;
#endif

		_dl_mprotect((void *)ELF_TRUNC((long)&__got_start, _dl_pagesz),
		    ELF_ROUND((long)&__got_end,_dl_pagesz) -
		    ELF_TRUNC((long)&__got_start, _dl_pagesz),
		    GOT_PERMS);

#ifdef RTLD_PROTECT_PLT
		/* only for DATA_PLT or BSS_PLT */
		_dl_mprotect((void *)ELF_TRUNC((long)&__plt_start, _dl_pagesz),
		    ELF_ROUND((long)&__plt_end,_dl_pagesz) -
		    ELF_TRUNC((long)&__plt_start, _dl_pagesz),
		    PROT_READ|PROT_EXEC);
#endif
@


1.149
log
@allocate two things, test two pointers; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.148 2014/06/21 08:00:23 otto Exp $ */
d464 2
a566 1
		/* XXX */
d568 2
@


1.148
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.147 2014/02/16 01:16:38 martynas Exp $ */
d288 1
a288 1
			if (liblist == NULL)
@


1.147
log
@Unbreak ld.so with ssp-strong/all on sparc64 and powerpc.  With the
new SSP logic it additionally protects functions which have their
local addresses taken of, and _dl_boot_bind() gets selected.

We have to go through GOT to reach __guard_local, however it hasn't
been relocated yet.  So add boot.c and don't protect everything up
to the point until it has been relocated and no longer needs the
loff adjustment.

OK matthew@@.  Full build done & tested by florian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.146 2014/01/23 00:31:34 deraadt Exp $ */
d283 4
a286 2
			liblist = _dl_malloc(libcount * sizeof(struct listent));
			randomlist =  _dl_malloc(libcount * sizeof(int));
d463 1
a463 1
			next_load = _dl_malloc(sizeof(struct load_list));
d565 1
@


1.146
log
@Remove LD_NORANDOM feature.  It serves no usable purpose.  Determinism
in this one specific area is not going to help debugging, because so
many other parts are non-deterministic.
ok guenthre matthew jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.145 2014/01/18 09:08:42 kettenis Exp $ */
a48 2
#include "../../lib/csu/common_elf/os-note-elf.h"

a55 1
void _dl_boot_bind(const long, long *, Elf_Dyn *);
a602 184
}

void
_dl_boot_bind(const long sp, long *dl_data, Elf_Dyn *dynamicp)
{
	struct elf_object  dynld;	/* Resolver data for the loader */
	AuxInfo		*auxstack;
	long		*stack;
	Elf_Dyn		*dynp;
	int		n, argc;
	char **argv, **envp;
	long loff;

	/*
	 * Scan argument and environment vectors. Find dynamic
	 * data vector put after them.
	 */
	stack = (long *)sp;
	argc = *stack++;
	argv = (char **)stack;
	envp = &argv[argc + 1];
	stack = (long *)envp;
	while (*stack++ != 0L)
		;

	/*
	 * Zero out dl_data.
	 */
	for (n = 0; n <= AUX_entry; n++)
		dl_data[n] = 0;

	/*
	 * Dig out auxiliary data set up by exec call. Move all known
	 * tags to an indexed local table for easy access.
	 */
	for (auxstack = (AuxInfo *)stack; auxstack->au_id != AUX_null;
	    auxstack++) {
		if (auxstack->au_id > AUX_entry)
			continue;
		dl_data[auxstack->au_id] = auxstack->au_v;
	}
	loff = dl_data[AUX_base];	/* XXX assumes ld.so is linked at 0x0 */

	/*
	 * We need to do 'selfreloc' in case the code weren't
	 * loaded at the address it was linked to.
	 *
	 * Scan the DYNAMIC section for the loader.
	 * Cache the data for easier access.
	 */

#if defined(__alpha__)
	dynp = (Elf_Dyn *)((long)_DYNAMIC);
#elif defined(__sparc__) || defined(__sparc64__) || defined(__powerpc__) || \
    defined(__hppa__) || defined(__sh__)
	dynp = dynamicp;
#else
	dynp = (Elf_Dyn *)((long)_DYNAMIC + loff);
#endif
	while (dynp != NULL && dynp->d_tag != DT_NULL) {
		if (dynp->d_tag < DT_NUM)
			dynld.Dyn.info[dynp->d_tag] = dynp->d_un.d_val;
		else if (dynp->d_tag >= DT_LOPROC &&
		    dynp->d_tag < DT_LOPROC + DT_PROCNUM)
			dynld.Dyn.info[dynp->d_tag - DT_LOPROC + DT_NUM] =
			    dynp->d_un.d_val;
		if (dynp->d_tag == DT_TEXTREL)
			dynld.dyn.textrel = 1;
		dynp++;
	}

	/*
	 * Do the 'bootstrap relocation'. This is really only needed if
	 * the code was loaded at another location than it was linked to.
	 * We don't do undefined symbols resolving (to difficult..)
	 */

	/* "relocate" dyn.X values if they represent addresses */
	{
		int i, val;
		/* must be code, not pic data */
		int table[20];

		i = 0;
		table[i++] = DT_PLTGOT;
		table[i++] = DT_HASH;
		table[i++] = DT_STRTAB;
		table[i++] = DT_SYMTAB;
		table[i++] = DT_RELA;
		table[i++] = DT_INIT;
		table[i++] = DT_FINI;
		table[i++] = DT_REL;
		table[i++] = DT_JMPREL;
		/* other processors insert their extras here */
		table[i++] = DT_NULL;
		for (i = 0; table[i] != DT_NULL; i++) {
			val = table[i];
			if (val >= DT_LOPROC && val < DT_LOPROC + DT_PROCNUM)
				val = val - DT_LOPROC + DT_NUM;
			else if (val >= DT_NUM)
				continue;
			if (dynld.Dyn.info[val] != 0)
				dynld.Dyn.info[val] += loff;
		}
	}

	{
		u_int32_t rs;
		Elf_Rel *rp;
		int	i;

		rp = (Elf_Rel *)(dynld.Dyn.info[DT_REL]);
		rs = dynld.dyn.relsz;

		for (i = 0; i < rs; i += sizeof (Elf_Rel)) {
			Elf_Addr *ra;
			const Elf_Sym *sp;

			sp = dynld.dyn.symtab;
			sp += ELF_R_SYM(rp->r_info);

			if (ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
/* cannot printf in this function */
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab +
				    sp->st_name);
#endif
				_dl_exit(5);
			}

			ra = (Elf_Addr *)(rp->r_offset + loff);
			RELOC_REL(rp, sp, ra, loff);
			rp++;
		}
	}

	for (n = 0; n < 2; n++) {
		unsigned long rs;
		Elf_RelA *rp;
		int	i;

		switch (n) {
		case 0:
			rp = (Elf_RelA *)(dynld.Dyn.info[DT_JMPREL]);
			rs = dynld.dyn.pltrelsz;
			break;
		case 1:
			rp = (Elf_RelA *)(dynld.Dyn.info[DT_RELA]);
			rs = dynld.dyn.relasz;
			break;
		default:
			rp = NULL;
			rs = 0;
		}
		for (i = 0; i < rs; i += sizeof (Elf_RelA)) {
			Elf_Addr *ra;
			const Elf_Sym *sp;

			sp = dynld.dyn.symtab;
			sp += ELF_R_SYM(rp->r_info);
			if (ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab +
				    sp->st_name);
#endif
				_dl_exit(6);
			}

			ra = (Elf_Addr *)(rp->r_offset + loff);
			RELOC_RELA(rp, sp, ra, loff, dynld.dyn.pltgot);
			rp++;
		}
	}

	RELOC_GOT(&dynld, loff);

	/*
	 * we have been fully relocated here, so most things no longer
	 * need the loff adjustment
	 */
@


1.145
log
@Make ld.so pass its cleanup handler in $2 as required by the MIPS System V
ABI, and completely remove the code that attempts to call atexit(3) directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.144 2013/12/25 15:14:59 miod Exp $ */
a71 1
char *_dl_norandom;
a223 1
	_dl_norandom = _dl_getenv("LD_NORANDOM", envp);
a249 4
		if (_dl_norandom) {
			_dl_norandom = NULL;
			_dl_unsetenv("LD_NORANDOM", envp);
		}
d301 9
a309 10
			if (!_dl_norandom)
				for (loop = 1; loop < libcount; loop++) {
					unsigned int rnd;
					int cur;
					rnd = _dl_random();
					rnd = rnd % (loop+1);
					cur = randomlist[rnd];
					randomlist[rnd] = randomlist[loop];
					randomlist[loop] = cur;
				}
@


1.144
log
@Pass _dl_dtors as the csu cleanup routine on sh
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.143 2013/12/25 15:01:39 miod Exp $ */
a605 23

#if defined(__mips64__)	/* XXX */
	/*
	 * Schedule a routine to be run at shutdown, by using atexit.
	 * Cannot call atexit directly from ld.so?
	 * Do not schedule destructors if run from ldd.
	 */
	{
		const elf_object_t *sobj;
		const Elf_Sym *sym;
		Elf_Addr ooff;

		sym = NULL;
		ooff = _dl_find_symbol("__cxa_atexit", &sym,
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT,
		    NULL, dyn_obj, &sobj);
		if (sym == NULL)
			_dl_printf("cannot find __cxa_atexit, destructors will not be run!\n");
		else
			(*(void (*)(void (*)(void), void *, void *))
			    (sym->st_value + ooff))(_dl_dtors, NULL, NULL);
	}
#endif
@


1.143
log
@Pass _dl_dtors as the csu cleanup routine on arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.142 2013/12/25 13:06:00 miod Exp $ */
d607 1
a607 1
#if defined(__mips64__) || defined(__sh__)	/* XXX */
@


1.142
log
@Pass _dl_dtors as the csu cleanup routine on m68k and m88k; change the
conditional in the MI code to only list the architectures left to adapt.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.141 2013/12/25 11:10:02 kettenis Exp $ */
d607 1
a607 1
#if defined(__arm__) || defined(__mips64__) || defined(__sh__)	/* XXX */
@


1.141
log
@Make ld.so pass its cleanup handler in %g1 as required by the SPARC System V
ABI, and stop calling atexit(4) directly from ld.so on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.140 2013/12/23 22:13:03 kettenis Exp $ */
d607 1
a607 3
#if !defined(__alpha__) && !defined(__amd64__) && !defined(__hppa__) && \
    !defined(__i386__) && !defined(__powerpc__) && !defined(__sparc__) && \
    !defined(__sparc64__)
@


1.140
log
@Make ld.so pass its cleanup handler in %rdx as required by the AMD64 System V
ABI, and stop calling atexit(4) directly from ld.so on amd64.  Note that this
means that binaries built before the middle of november may no longer call
destructors in shared libraries implemented in C++.  Update your packages!

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.139 2013/12/23 22:03:52 kettenis Exp $ */
d608 2
a609 1
    !defined(__i386__) && !defined(__powerpc__) && !defined(__sparc64__)
@


1.139
log
@Make ld.so pass its cleanup handler in r7 as required by the PowerPC System V
ABI, and stop calling atexit(4) directly from ld.so on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.138 2013/12/23 21:18:57 kettenis Exp $ */
d607 2
a608 2
#if !defined(__alpha__) && !defined(__hppa__) && !defined(__i386__) && \
    !defined(__powerpc__) && !defined(__sparc64__)
@


1.138
log
@Make ld.so pass its cleanup handler in v0 and stop calling atexit(4) directly
from ld.so on alpha.  Note that this means that binaries built before early
december may no longer call destructors in shared libraries implemented in
C++.  Update your packages!
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.137 2013/12/23 17:29:15 kettenis Exp $ */
d608 1
a608 1
    !defined(__sparc64__)
@


1.137
log
@Make ld.so pass its cleanup handler in %g1 as required by the SPARC System V
ABI, and stop calling atexit(4) directly from ld.so on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.136 2013/12/23 14:13:03 kettenis Exp $ */
d607 2
a608 1
#if !defined(__hppa__) && !defined(__i386__) && !defined(__sparc64__)
@


1.136
log
@Call __cxa_atexit(3) instead of atexit(3).  Preparation for upcoming changes to
make it possible to call atexit from dynamically loaded shared objects.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.135 2013/12/23 13:57:44 kettenis Exp $ */
d607 1
a607 1
#if !defined(__hppa__) && !defined(__i386__)
@


1.135
log
@Make ld.so pass its cleanup handler in %arg1 and stop calling atiexit(4)
directly from ld.so on hppa.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.134 2013/12/23 10:39:10 kettenis Exp $ */
d619 1
a619 1
		ooff = _dl_find_symbol("atexit", &sym,
d623 1
a623 1
			_dl_printf("cannot find atexit, destructors will not be run!\n");
d625 2
a626 2
			(*(void (*)(Elf_Addr))(sym->st_value + ooff))
			    ((Elf_Addr)_dl_dtors);
@


1.134
log
@Make ld.so pass its cleanup handler in %edx as required by the i386 System V
ABI, and stop calling atexit(4) directly from ld.so on i386.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.133 2013/06/01 09:57:55 miod Exp $ */
d607 1
a607 1
#if !defined(__i386__)
a624 3
#ifdef MD_ATEXIT
			MD_ATEXIT(sobj, sym, (Elf_Addr)&_dl_dtors);
#else
a626 1
#endif
@


1.133
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.132 2013/04/05 12:58:03 kurt Exp $ */
d607 1
d632 1
@


1.132
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.131 2013/03/20 21:49:59 kurt Exp $ */
a53 2
static char *_dl_getenv(const char *, char **);
static void _dl_unsetenv(const char *, char **);
d258 2
d917 1
a917 1
static char *
d935 1
a935 1
static void
@


1.131
log
@- Parse colon separated paths into NULL terminated arrays of string
pointers to prepare for adding rpath ORIGIN support.
okay matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.130 2013/01/11 21:17:07 miod Exp $ */
d79 2
d235 2
a236 1
	if (_dl_issetugid()) {	/* Zap paths if s[ug]id... */
@


1.130
log
@Proper bounds checking for DT_xxx values in _dl_boot_bind(). Turned out to be
harmless because we have full control over the array being processed, and none
of the values we set up may trigger the bug; yet this may change in the future.

ok drahn matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.129 2012/06/12 20:32:17 matthew Exp $ */
d43 1
d67 2
a68 1
char *_dl_libpath;
d217 2
a218 1
	_dl_libpath = _dl_getenv("LD_LIBRARY_PATH", envp);
a224 1
	_dl_debug = _dl_getenv("LD_DEBUG", envp);
d235 1
@


1.129
log
@Fix loaded object sod matching: when we load libfoo.so.X.Y into
memory, we should be able to match other requests for libfoo.so.X.Z
against that same object.

ok kurt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.128 2012/05/08 14:32:01 jsing Exp $ */
d397 2
a398 2
	 * now that GOT and PLT has been relocated, and we know
	 * page size, protect it from modification
d729 3
a731 1
			if (val > DT_HIPROC) /* ??? */
a732 2
			if (val > DT_LOPROC)
				val -= DT_LOPROC + DT_NUM;
@


1.128
log
@Refuse to load ELF objects that contain a PT_TLS program header.
Otherwise the binary assumes that the requested TLS storage has been
allocated and will happily use it, resulting in unwanted memory corruption.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.126 2011/11/28 20:59:03 guenther Exp $ */
a60 1
void _dl_set_sod(const char *, struct sod *);
a79 11

void
_dl_set_sod(const char *path, struct sod *sod)
{
	char *fname = _dl_strrchr(path, '/');

	if (fname != NULL)
		_dl_build_sod(++fname, sod);
	else
		_dl_build_sod(path, sod);
}
@


1.127
log
@Since PIE executables on mips64 don't have DT_MIPS_RLD_MAP, fall back on
using DT_DEBUG if DT_MIPS_RLD_MAP isn't there.  This requires us to make
.dynamic temporarily writable.  Fixes debugging of PIE execuables with gdb(1).

ok miod@@
@
text
@d489 5
@


1.126
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.125 2011/06/27 16:47:50 sthen Exp $ */
d558 1
d562 7
a568 6
#else
	map_link = NULL;
	for (dynp = exe_obj->load_dyn; dynp->d_tag; dynp++) {
		if (dynp->d_tag == DT_DEBUG) {
			map_link = (struct r_debug **)&dynp->d_un.d_ptr;
			break;
d570 2
a572 3
	if (dynp->d_tag != DT_DEBUG)
		DL_DEB(("failed to mark DTDEBUG\n"));
#endif
d581 5
d587 5
@


1.125
log
@Backout the dynamic linker speed improvement diff for now, it still
has some issues. Discussed with various, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.123 2011/05/09 18:13:34 otto Exp $ */
d62 1
d98 1
a98 1
_dl_run_all_dtors()
d101 1
d103 2
a104 1
	struct dep_node *dnode;
d107 2
d119 5
a123 1
				node->status |= STAT_FINI_READY;
d132 3
a134 1
			    ((node->status & STAT_FINI_DONE) == 0))
d155 3
d282 2
a283 2
		/* propagate RTLD_NOW to deplibs (can be set by dynamic tags) */
		depflags = flags | (dynobj->obj_flags & RTLD_NOW);
d493 1
a493 1
	exe_obj->obj_flags |= RTLD_GLOBAL;
d857 1
a857 1
	    object->obj_flags & RTLD_NOW));
d869 1
d873 7
d882 2
d885 1
a885 1
		if (n->data->status & STAT_INIT_DONE)
d887 1
a887 1
		_dl_call_init(n->data);
d890 2
d895 3
a903 1
	/* What about loops? */
@


1.124
log
@Dynamic linker speed improvement diff. tested by several sinc k2k11.
get it in tree now deraadt@@, ok by several ports folks. Thanks for the testing.
@
text
@a425 1
	TAILQ_INIT(&_dlsym_search_list);
a512 1
	_dl_search_list_valid = 0;
@


1.123
log
@Outsmart gcc4 on mips* by moving the declaration of _dl_debug_state
outside the file the call is in. Since the function is empty, gcc
optmizes the call away, breaking the gdb hook needed to resolve symbols in
lazy bound shared libs. Analysis by kettenis@@; ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.122 2011/04/06 11:36:25 miod Exp $ */
d426 1
d514 1
@


1.122
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.121 2010/12/07 18:29:28 drahn Exp $ */
a89 6
}

void
_dl_debug_state(void)
{
	/* Debugger stub */
@


1.121
log
@Make the preload error distinct from the normal error.
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.120 2010/10/25 20:34:44 kurt Exp $ */
d642 1
a642 1
	while (*stack++ != NULL)
@


1.120
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.119 2010/07/01 19:25:44 drahn Exp $ */
d197 1
a197 1
			_dl_printf("%s: can't load library '%s'\n",
@


1.119
log
@When generating grpsym lists, avoid duplicates without searching the
already generated list. Speeds up startup on deeply nested dlopen binaries.
ok guenther@@, tested by ckuethe@@ and ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.118 2010/01/02 12:16:35 kettenis Exp $ */
d61 1
d82 11
d487 1
d517 1
@


1.118
log
@Fix handling of hppa RELOC_IPLT relocations during 'bootstrap relocation'.

ok miod@@, deraadt@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.117 2009/02/04 19:44:51 kettenis Exp $ */
d340 2
a341 2
	_dl_link_grpsym(object);
	_dl_cache_grpsym_list(object);
d501 1
a501 1
	_dl_link_grpsym(dyn_obj);
@


1.117
log
@Tag ld.so as an OpenBSD binary/library.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.116 2008/10/02 20:12:08 kurt Exp $ */
d779 1
a779 1
			RELOC_RELA(rp, sp, ra, loff);
@


1.116
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.115 2008/06/13 23:52:42 kurt Exp $ */
d47 2
@


1.115
log
@Pass relocated Elf_Dyn * to _dl_finalize_object(). Needed for pie
executables.  Debugged and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.114 2008/06/12 19:50:04 kurt Exp $ */
d819 1
a819 1
		if (_dl_symcache == (void *)MAP_FAILED) {
@


1.114
log
@- rename _dl_boot argument loff to dyn_loff to differentiate it from
  exe_loff
- calculate minva, maxva, exe_loff for the executable for passing to
  _dl_finialize_object and completing the executable elf_object_t data.
  this fixes ldd output for the exe object and prepares for PIE support.
- calculate the interpreter path pointer in a way that allows for the
  possibility that PT_INTERP comes before PT_PHDR
- fix an off by one in the init of dl_data

input and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.113 2008/05/05 02:29:02 kurt Exp $ */
d440 4
a443 2
			    (Elf_Dyn *)phdp->p_vaddr, (Elf_Phdr *)dl_data[AUX_phdr],
			    dl_data[AUX_phnum], OBJTYPE_EXE, minva + exe_loff, exe_loff);
@


1.113
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.112 2007/11/27 16:42:15 miod Exp $ */
d356 1
a356 1
_dl_boot(const char **argv, char **envp, const long loff, long *dl_data)
d366 1
a366 1
	char *us = "";
d370 2
d381 5
d421 4
d430 9
a438 1
		if (phdp->p_type == PT_DYNAMIC) {
d441 1
a441 1
			    dl_data[AUX_phnum], OBJTYPE_EXE, 0, 0);
d443 9
a451 7
		} else if (phdp->p_type == PT_INTERP) {
			us = _dl_strdup((char *)phdp->p_vaddr);
		} else if (phdp->p_type == PT_LOAD) {
			int align = _dl_pagesz - 1;
			int size = (phdp->p_vaddr & align) + phdp->p_filesz;

#define TRUNC_PG(x) ((x) & ~(align))
d456 2
a457 2
			next_load->start = (char *)TRUNC_PG(phdp->p_vaddr);
			next_load->size = size;
d461 1
a461 1
//				dump_prelink(phdp->p_vaddr, phdp->p_memsz);
d464 1
d470 1
d493 1
a493 1
	    ehdr->e_phnum, OBJTYPE_LDR, dl_data[AUX_base], loff);
d552 1
a552 1
		debug_map->r_ldbase = loff;
d630 1
a630 1
	for (n = 0; n < AUX_entry; n++)
d643 1
a643 1
	loff = dl_data[AUX_base];	/* XXX assumes linked at 0x0 */
@


1.112
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.111 2007/04/03 14:33:07 jason Exp $ */
d365 1
d421 2
a422 2
			    (Elf_Dyn *)phdp->p_vaddr, dl_data, OBJTYPE_EXE,
			    0, 0);
d467 4
a470 2
	dyn_obj = _dl_finalize_object(us, dynp, 0, OBJTYPE_LDR,
	    dl_data[AUX_base], loff);
@


1.111
log
@add support for LD_TRACE_LOADED_OBJECTS_{FMT1/FMT2/PROGNAME}.  Functionality
matches and expands on the old a.out ld.so formatting.  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.110 2007/04/02 15:24:19 drahn Exp $ */
d804 1
a804 1
	_dl_md_reloc_got(object, !(_dl_bindnow ||
@


1.110
log
@Since the kernel allows argv[0] == NULL, dont core in ld.so
diff from Matthew Dempsky, with reminder from theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.109 2007/01/28 21:28:23 drahn Exp $ */
d72 1
d209 3
@


1.109
log
@revert 1.108, the diff allowed ldd to print the load address of the binary,
however this modified variables used by C++ backtrace code which caused it
to crash. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.108 2006/11/21 20:15:55 drahn Exp $ */
d415 1
a415 1
			exe_obj = _dl_finalize_object(argv[0],
@


1.108
log
@Fill in load/end address for binary.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.107 2006/11/15 19:14:21 deraadt Exp $ */
a364 1
	Elf_Addr start, end;
a408 3

	start = ELFDEFNNAME(NO_ADDR);
	end = 0;
a433 4
			if (phdp->p_vaddr < start)
				start = phdp->p_vaddr;
			if (phdp->p_vaddr > end)
				end = phdp->p_vaddr;
a442 4
	if (start != ELFDEFNNAME(NO_ADDR)) {
		exe_obj->load_addr = start;
		exe_obj->load_size = end - start;
	}
@


1.107
log
@failed to purge doubled up environment variables; found by Mark Dowd
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.106 2006/11/10 21:19:54 drahn Exp $ */
d365 1
d410 3
d438 4
d451 4
@


1.106
log
@Getting much closer.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.105 2006/11/10 07:44:58 drahn Exp $ */
d873 2
a874 2
		}
		env++;
@


1.105
log
@Not quite working ld.so support for sh
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.104 2006/09/24 21:52:49 kettenis Exp $ */
d626 1
a626 1
    defined(__hppa__)
@


1.104
log
@Fill in the list of loaded segments for the main executable such that we can
unprotect them if necessary for binaries that have TEXTREL set.

ok drahn@@, martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.103 2006/05/08 20:37:01 deraadt Exp $ */
d378 1
d400 1
@


1.103
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.102 2006/05/08 20:34:36 deraadt Exp $ */
d341 3
d358 1
d419 17
a435 4
		} else if ((phdp->p_type == PT_LOAD) &&
		    (phdp->p_flags & 0x08000000)) {
//			dump_prelink(phdp->p_vaddr, phdp->p_memsz);
			prebind_load_exe(phdp, exe_obj);
d439 1
@


1.103.2.1
log
@MFC:
Fix by deraadt@@

failed to purge doubled up environment variables; found by Mark Dowd

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.103 2006/05/08 20:37:01 deraadt Exp $ */
d853 2
a854 2
		} else
			env++;
@


1.102
log
@de-space
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.101 2006/05/03 16:10:51 drahn Exp $ */
d252 1
a252 1
	while(dynobj) {
@


1.101
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.100 2005/11/09 16:41:29 kurt Exp $ */
d210 2
a211 2
	_dl_noprebind = _dl_getenv("LD_NOPREBIND", envp); 
	_dl_prebind_validate = _dl_getenv("LD_PREBINDVALIDATE", envp); 
d340 1
a340 1
 
d415 1
a415 1
		} else if ((phdp->p_type == PT_LOAD) && 
@


1.100
log
@add RTLD_NOW support to dlopen and propogate -z now to dep libs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.99 2005/10/21 15:24:10 kurt Exp $ */
d46 1
d70 2
d210 2
d340 2
d415 4
d455 2
d461 2
d756 2
a757 2
		DL_DEB(("using static buffer for %d entries\n",
		    object->nchains));
d763 1
a763 1
		DL_DEB(("allocating symcache sz %x with mmap\n", sz));
d772 2
d779 1
a792 1

@


1.100.2.1
log
@MFC:
Fix by deraadt@@

failed to purge doubled up environment variables; found by Mark Dowd

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.100 2005/11/09 16:41:29 kurt Exp $ */
d836 2
a837 2
		} else
			env++;
@


1.99
log
@using _dl_link_grpsym to increment refcounts made _dl_notify_unload_shlib
simpler, however it broke ldd refcount output. use _dl_link_child to
increment refcounts and adjust _dl_notify_unload_shlib to match.
work by drahn@@ and myself. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.98 2005/10/16 04:14:22 kurt Exp $ */
d177 1
a177 1
		DL_LAZY|RTLD_GLOBAL);
d244 1
d250 4
d302 1
a302 1
				    OBJTYPE_LIB, flags);
d411 1
a411 1
	exe_obj->obj_flags = RTLD_GLOBAL;
d423 1
a423 1
	_dl_load_dep_libs(exe_obj, DL_LAZY|RTLD_GLOBAL, 1);
d762 2
a763 1
	_dl_md_reloc_got(object, !(_dl_bindnow || object->dyn.bind_now));
@


1.98
log
@Consolidate dl_boot and dlopen dep lib loading into new function
_dl_load_dep_libs. Now both dl_boot and dlopen will randomize dep lib
loading, where previously only dl_boot did.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.97 2005/10/12 20:36:16 kurt Exp $ */
d430 1
@


1.97
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.96 2005/10/10 16:33:51 kurt Exp $ */
d237 93
a343 1
	elf_object_t *dynobj;
d347 1
a347 1
	int libcnt_err = 0;
d418 1
a418 79
	/*
	 * Now, pick up and 'load' all libraries required. Start
	 * with the first on the list and then do whatever gets
	 * added along the tour.
	 */
	dynobj = _dl_objects;
	for (dynobj = _dl_objects; dynobj != NULL; dynobj = dynobj->next) {
		DL_DEB(("examining: '%s'\n", dynobj->load_name));
		libcnt_err = 0;
		for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			if (dynp->d_tag == DT_NEEDED) {
				libcnt_err++;
			}
		}
		if ( libcnt_err != 0) {
			struct listent {
				Elf_Dyn *dynp;
				elf_object_t *dynobj;
			} *liblist;
			int *randomlist;

			liblist = _dl_malloc(libcnt_err *
			    sizeof(struct listent));
			randomlist =  _dl_malloc(libcnt_err * sizeof(int));
			if (liblist == NULL)
				_dl_exit(5);

			for (dynp = dynobj->load_dyn, loop = 0;
			    dynp->d_tag;
			    dynp++)
				if (dynp->d_tag == DT_NEEDED)
					liblist[loop++].dynp = dynp;

			/* Randomize these */
			for (loop = 0; loop < libcnt_err; loop++)
				randomlist[loop] = loop;

			if (!_dl_norandom)
				for (loop = 1; loop < libcnt_err; loop++) {
					unsigned int rnd;
					int cur;

					rnd = _dl_random();

					rnd = rnd % (loop+1);

					cur = randomlist[rnd];
					randomlist[rnd] = randomlist[loop];
					randomlist[loop] = cur;
				}

			for (loop = 0; loop < libcnt_err; loop++) {
				elf_object_t *depobj;
				const char *libname;

				libname = dynobj->dyn.strtab;
				libname +=
				    liblist[randomlist[loop]].dynp->d_un.d_val;
				DL_DEB(("needs: '%s'\n", libname));
				depobj = _dl_load_shlib(libname, dynobj,
				    OBJTYPE_LIB, DL_LAZY|RTLD_GLOBAL);
				if (depobj == 0) {
					_dl_printf(
					    "%s: can't load library '%s'\n",
					    _dl_progname, libname);
					_dl_exit(4);
				}
				liblist[randomlist[loop]].dynobj = depobj;
			}
			for (loop = 0; loop < libcnt_err; loop++) {
				_dl_add_object(liblist[loop].dynobj);
				_dl_link_child(liblist[loop].dynobj, dynobj);
			}
			_dl_free(liblist);
		}
	}

	_dl_link_grpsym(exe_obj);
	_dl_cache_grpsym_list(exe_obj);
d438 1
a438 1
	libcnt_err = 0;
d440 1
a440 1
		libcnt_err = _dl_rtld(_dl_objects);
d446 1
a446 1
	    (libcnt_err == 0) ? "success":"failed"));
d448 1
a448 1
	if (libcnt_err != 0)
@


1.96
log
@set _dl_loading_object to NULL upon entering and exiting _dl_boot and
dlopen and cleanup of related redundant code. looks fine drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.95 2005/10/09 04:29:13 kurt Exp $ */
d184 1
a184 1
		_dl_link_sub(shlib, _dl_objects);
a320 6

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(9);
	n->data = exe_obj;
	TAILQ_INSERT_TAIL(&exe_obj->grpsym_list, n, next_sib);
d397 1
a397 1
				_dl_link_sub(liblist[loop].dynobj, dynobj);
d403 3
d409 1
d416 1
a416 6
	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(5);
	n->data = dyn_obj;
	TAILQ_INSERT_TAIL(&exe_obj->grpsym_list, n, next_sib);
	dyn_obj->refcount++;
@


1.95
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.94 2005/10/07 01:26:34 kurt Exp $ */
d298 1
a314 3
	exe_obj->load_object = exe_obj;
	TAILQ_INIT(&exe_obj->grpsym_list);
	TAILQ_INIT(&exe_obj->grpref_list);
d446 2
@


1.94
log
@rename dload_list to grpsym_list which better represents its usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.93 2005/10/06 21:53:10 kurt Exp $ */
d99 1
a99 2
			    (node->refcount + node->opencount +
			     node->grprefcount == 0) &&
d109 1
a109 2
			    (node->refcount + node->opencount +
			     node->grprefcount == 0) &&
@


1.93
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.92 2005/10/03 19:48:24 kurt Exp $ */
d317 1
a317 1
	TAILQ_INIT(&exe_obj->dload_list);
d330 1
a330 1
	TAILQ_INSERT_TAIL(&exe_obj->dload_list, n, next_sib);
d426 1
a426 1
	TAILQ_INSERT_TAIL(&exe_obj->dload_list, n, next_sib);
@


1.92
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.91 2005/09/28 18:17:42 kurt Exp $ */
d81 1
a81 2
 * Run dtors for the current object, then notify all of the DT_NEEDED
 * libraries that it can be unloaded (or ref count lowered).
d99 2
a100 1
			    (node->refcount == 0) &&
d110 2
a111 1
			    (node->refcount == 0) &&
a136 12
void
_dl_run_dtors(elf_object_t *object)
{
	struct dep_node *n;

	TAILQ_FOREACH(n, &object->child_list, next_sib)
		_dl_notify_unload_shlib(n->data);

	_dl_run_all_dtors();

}

d158 5
a162 1
	_dl_run_dtors(_dl_objects);
d318 1
d331 1
a331 1
	exe_obj->refcount++;
@


1.91
log
@remove _dl_exiting dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.90 2005/09/22 22:33:40 drahn Exp $ */
d337 1
a337 1

d433 1
@


1.90
log
@Track if symbols are searched but missing while resolving GOT, if
any are missing exit instead of later causing an abort, ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.89 2005/09/21 23:12:09 drahn Exp $ */
a73 2
int _dl_exiting;

a158 1
	_dl_exiting = 1;
@


1.89
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.88 2005/09/19 02:31:04 drahn Exp $ */
d266 2
a267 2
	unsigned int i;
	int libcnt = 0;
d314 1
a314 1
	for (i = 0; i < dl_data[AUX_phnum]; i++) {
d353 1
a353 1
		libcnt = 0;
d356 1
a356 1
				libcnt++;
d359 1
a359 1
		if ( libcnt != 0) {
d366 3
a368 2
			liblist = _dl_malloc(libcnt * sizeof(struct listent));
			randomlist =  _dl_malloc(libcnt * sizeof(int));
d372 1
a372 1
			for (dynp = dynobj->load_dyn, i = 0;
d376 1
a376 1
					liblist[i++].dynp = dynp;
d379 2
a380 2
			for (i = 0; i < libcnt; i++)
				randomlist[i] = i;
d383 1
a383 1
				for (i = 1; i < libcnt; i++) {
d389 1
a389 1
					rnd = rnd % (i+1);
d392 2
a393 2
					randomlist[rnd] = randomlist[i];
					randomlist[i] = cur;
d396 1
a396 1
			for (i = 0; i < libcnt; i++) {
d402 1
a402 1
				    liblist[randomlist[i]].dynp->d_un.d_val;
d412 1
a412 1
				liblist[randomlist[i]].dynobj = depobj;
d414 3
a416 3
			for (i = 0; i < libcnt; i++) {
				_dl_add_object(liblist[i].dynobj);
				_dl_link_sub(liblist[i].dynobj, dynobj);
d443 1
d445 1
a445 1
		_dl_rtld(_dl_objects);
d450 5
a454 1
	DL_DEB(("dynamic loading done.\n"));
d723 1
a723 1
void
d727 2
d730 1
a730 1
		_dl_rtld(object->next);
d733 1
a733 1
		return;
d757 2
a758 2
	_dl_md_reloc(object, DT_REL, DT_RELSZ);
	_dl_md_reloc(object, DT_RELA, DT_RELASZ);
d766 4
a769 1
	object->status |= STAT_RELOC_DONE;
@


1.88
log
@simplify code by putting executable in misnamed _dlopened_child_list,
also move RTLD_NEXT/RTLD_SELF code into that code, it is a single test.
okay kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.87 2005/09/16 23:19:41 drahn Exp $ */
d510 1
a510 1
		    0, dyn_obj, &sobj);
d844 1
a844 1
	    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, &dummy_obj, NULL);
@


1.87
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.86 2005/05/10 03:36:07 drahn Exp $ */
d325 1
d328 6
@


1.86
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.85 2005/04/06 00:16:53 deraadt Exp $ */
d115 2
a116 3
				for (dnode = node->first_child;
				    dnode != NULL;
				    dnode = dnode->next_sibling)
d143 1
a143 1
	for (n = object->first_child; n; n = n->next_sibling) {
a144 1
	}
a147 4

	if (_dl_exiting == 0)
		for (n = object->first_child; n; n = n->next_sibling)
			_dl_unload_shlib(n->data);
d268 1
d306 3
d325 9
d366 2
a367 2
			    dynp++) {
				if (dynp->d_tag == DT_NEEDED) {
a368 1
				}
a369 1
			}
d422 7
d501 3
a503 2
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, &sobj,
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, dyn_obj);
d759 1
a759 1
	for (n = object->first_child; n; n = n->next_sibling) {
d836 2
a837 2
	ooff = _dl_find_symbol("environ", _dl_objects, &sym, NULL,
	    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, &dummy_obj);
@


1.85
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.83 2004/08/11 17:13:10 pefo Exp $ */
d74 2
d83 2
a84 2
 * Routine to walk through all of the objects except the first
 * (main executable).
d86 53
d142 4
a145 4
	if (object->dyn.fini) {
		DL_DEB(("doing dtors @@%p: [%s]\n",
		    object->dyn.fini, object->load_name));
		(*object->dyn.fini)();
d147 7
a153 2
	if (object->next)
		_dl_run_dtors(object->next);
d156 7
d166 6
d173 6
a178 2
	if (_dl_objects->next)
		_dl_run_dtors(_dl_objects->next);
d756 2
a757 2
		DL_DEB(("doing ctors @@%p: [%s]\n",
		    object->dyn.init, object->load_name));
@


1.84
log
@Do a better job of running destructors in the right order.
@
text
@a73 2
int _dl_exiting;

d81 2
a82 2
 * Run dtors for the current object, then notify all of the DT_NEEDED
 * libraries that it can be unloaded (or ref count lowered).
a83 53

void
_dl_run_all_dtors()
{
	elf_object_t *node;
	int fini_complete;
	struct dep_node *dnode;

	fini_complete = 0;

	while (fini_complete == 0) {
		fini_complete = 1;
		for (node = _dl_objects->next;
		    node != NULL;
		    node = node->next) {
			if ((node->dyn.fini) &&
			    (node->refcount == 0) &&
			    (node->status & STAT_INIT_DONE) &&
			    ((node->status & STAT_FINI_DONE) == 0)) {
				node->status |= STAT_FINI_READY;
			    }
		}
		for (node = _dl_objects->next;
		    node != NULL;
		    node = node->next ) {
			if ((node->dyn.fini) &&
			    (node->refcount == 0) &&
			    (node->status & STAT_INIT_DONE) &&
			    ((node->status & STAT_FINI_DONE) == 0))
				for (dnode = node->first_child;
				    dnode != NULL;
				    dnode = dnode->next_sibling)
					dnode->data->status &= ~STAT_FINI_READY;
		}


		for (node = _dl_objects->next;
		    node != NULL;
		    node = node->next ) {
			if (node->status & STAT_FINI_READY) {
				DL_DEB(("doing dtors obj %p @@%p: [%s]\n",
				    node, node->dyn.fini,
				    node->load_name));

				fini_complete = 0;
				node->status |= STAT_FINI_DONE;
				node->status &= ~STAT_FINI_READY;
				(*node->dyn.fini)();
			}
		}
	}
}

d87 4
a90 4
	struct dep_node *n;

	for (n = object->first_child; n; n = n->next_sibling) {
		_dl_notify_unload_shlib(n->data);
d92 2
a93 7

	_dl_run_all_dtors();


	if (_dl_exiting == 0)
		for (n = object->first_child; n; n = n->next_sibling)
			_dl_unload_shlib(n->data);
a95 7
/*
 * Routine to walk through all of the objects except the first
 * (main executable).
 *
 * Big question, should dlopen()ed objects be unloaded before or after
 * the destructor for the main application runs?
 */
a98 6
	_dl_thread_kern_stop();
	_dl_exiting = 1;

	/* ORDER? */
	_dl_unload_dlopen();

d100 2
a101 6

	/* main program runs its dtors itself
	 * but we want to run dtors on all it's children);
	 */
	_dl_objects->status |= STAT_FINI_DONE;
	_dl_run_dtors(_dl_objects);
d679 2
a680 2
		DL_DEB(("doing ctors obj %p @@%p: [%s]\n",
		    object, object->dyn.init, object->load_name));
@


1.83
log
@revert, should not have gone in
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.82 2004/08/11 17:11:45 pefo Exp $ */
d74 2
d83 2
a84 2
 * Routine to walk through all of the objects except the first
 * (main executable).
d86 53
d142 4
a145 4
	if (object->dyn.fini) {
		DL_DEB(("doing dtors @@%p: [%s]\n",
		    object->dyn.fini, object->load_name));
		(*object->dyn.fini)();
d147 7
a153 2
	if (object->next)
		_dl_run_dtors(object->next);
d156 7
d166 6
d173 6
a178 2
	if (_dl_objects->next)
		_dl_run_dtors(_dl_objects->next);
d756 2
a757 2
		DL_DEB(("doing ctors @@%p: [%s]\n",
		    object->dyn.init, object->load_name));
@


1.82
log
@mips->mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.81 2004/05/27 21:59:07 mickey Exp $ */
a205 1
#ifndef __mips__
a230 1
#endif
@


1.81
log
@fake plabel32 relocs for dyn.init/fini instead of an evil md macro hook
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.80 2004/05/26 19:14:14 mickey Exp $ */
d206 1
d232 1
@


1.80
log
@call ctors after debugging has been setup; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.79 2004/05/25 21:48:00 mickey Exp $ */
a89 3
#ifdef MD_CALL
		MD_CALL(object, object->dyn.fini, NULL);
#else
a90 1
#endif
a680 3
#ifdef MD_CALL
		MD_CALL(object, object->dyn.init, NULL);
#else
a681 1
#endif
@


1.79
log
@md parts for hppa
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.78 2004/05/25 20:51:03 mickey Exp $ */
a363 12
	 * The first object is the executable itself,
	 * it is responsible for running it's own ctors/dtors
	 * thus do NOT run the ctors for the executable, all of
	 * the shared libraries which follow.
	 * Do not run init code if run from ldd.
	 */
	if (_dl_objects->next != NULL) {
		_dl_objects->status |= STAT_INIT_DONE;
		_dl_call_init(_dl_objects);
	}

	/*
d392 12
@


1.78
log
@use md hook for calling init/fini if defined; only say running ctors/dtors if they are there; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.77 2004/05/25 18:07:20 mickey Exp $ */
d488 2
a489 1
#elif defined(__sparc__) || defined(__sparc64__) || defined(__powerpc__)
@


1.77
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.76 2004/05/25 15:56:18 deraadt Exp $ */
d87 6
a92 2
	DL_DEB(("doing dtors: [%s]\n", object->load_name));
	if (object->dyn.fini)
d94 2
d411 1
d416 1
a416 1
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, NULL,
d421 3
d426 1
d681 6
a686 2
	DL_DEB(("doing ctors: [%s]\n", object->load_name));
	if (object->dyn.init)
d688 2
@


1.76
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.75 2004/05/24 20:24:54 mickey Exp $ */
d409 1
a409 1
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym,
d736 1
a736 1
	ooff = _dl_find_symbol("environ", _dl_objects, &sym,
@


1.75
log
@doing ldd exit asap -- move all other tasks towards after it.
call atext(_dl_dtors) at the very end -- allows debuggering it.
drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.74 2004/05/24 20:16:12 drahn Exp $ */
d649 1
a649 1
		if (sz != 0) 
d719 1
a719 1
/* 
d721 1
a721 1
 * 
@


1.74
log
@Change define used to deal with PLT protection, use postive logic not negative.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.73 2004/02/23 20:47:39 drahn Exp $ */
a339 3
	if (_dl_traceld == NULL)
		_dl_fixup_user_env();

d347 10
d364 1
a364 1
	if ((_dl_traceld == NULL) && (_dl_objects->next != NULL)) {
a369 19
	 * Schedule a routine to be run at shutdown, by using atexit.
	 * Cannot call atexit directly from ld.so?
	 * Do not schedule destructors if run from ldd.
	 */
	if (_dl_traceld == NULL) {
		const Elf_Sym *sym;
		Elf_Addr ooff;

		sym = NULL;
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym,
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, dyn_obj);
		if (sym == NULL)
			_dl_printf("cannot find atexit, destructors will not be run!\n");
		else
			(*(void (*)(Elf_Addr))(sym->st_value + ooff))
			    ((Elf_Addr)_dl_dtors);
	}

	/*
d399 17
a415 3
	if (_dl_debug || _dl_traceld) {
		_dl_show_objects();
		DL_DEB(("dynamic loading done.\n"));
a416 2
	if (_dl_traceld)
		_dl_exit(0);
@


1.73
log
@Set the user variable environ early in ld.so so that library constructors can
properly see the environment. Fixes problem with MALLOC_OPTIONS on dynamic
executables. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.72 2004/02/10 14:12:22 drahn Exp $ */
d211 1
a211 1
#ifndef RTLD_TEXT_PLT
d221 1
a221 1
#ifndef RTLD_TEXT_PLT
@


1.72
log
@Check for RTLD_TEXT_PLT define instead of an architecture specific check.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.71 2004/02/07 06:00:48 drahn Exp $ */
d57 1
d133 1
d173 1
d340 3
d717 23
@


1.71
log
@Dynamic linker support for arm. non-lazy binding works.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.70 2003/10/04 16:13:33 deraadt Exp $ */
d208 1
a208 1
#if !defined(__i386__) && !defined(__arm__)
d218 1
a218 1
#if !defined(__i386__) && !defined(__arm__)
@


1.70
log
@breaks on sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.68 2003/09/04 19:33:48 drahn Exp $ */
d208 1
a208 1
#ifndef __i386__
d218 1
a218 1
#ifndef __i386__
@


1.69
log
@Initialize environ before calling constructors or atexit.
Tested by tedu, no real ok.
@
text
@a351 11
		const Elf_Sym *sym;
		Elf_Addr ooff;

		sym = NULL;
		ooff = _dl_find_symbol("environ", _dl_objects, &sym,
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, dyn_obj);
		if (sym == NULL)
			_dl_printf("cannot find environ, env will not be set up for atexit!\n");
		else
			*((char ***)(sym->st_value + ooff)) = envp;

@


1.68
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.67 2003/09/02 15:17:51 drahn Exp $ */
d352 11
@


1.67
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.66 2003/07/09 21:01:10 drahn Exp $ */
d45 1
d603 3
d609 1
d616 19
d641 6
@


1.66
log
@changes to ld.so to be compatible with newer binutils, requires
slight changes in the startup code on most archs. ok art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.65 2003/07/06 20:03:57 deraadt Exp $ */
d39 1
d113 2
a114 1
		shlib = _dl_load_shlib(cp, _dl_objects, OBJTYPE_LIB);
d309 1
a309 1
				    OBJTYPE_LIB);
d366 1
a366 1
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0, "");
d412 1
@


1.65
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.64 2003/06/22 21:39:01 drahn Exp $ */
d54 1
a54 1
void _dl_boot_bind(const long, long *);
d417 1
a417 1
_dl_boot_bind(const long sp, long *dl_data)
d467 2
@


1.64
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.63 2003/06/09 16:10:03 deraadt Exp $ */
d48 7
a54 2
static char *_dl_getenv(const char *var, char **env);
static void _dl_unsetenv(const char *var, char **env);
a128 1

d199 2
a200 2
	 * now that GOT and PLT has been relocated, and we know page size 
	 * protect it from modification 
d212 1
a212 1
		        ELF_TRUNC((long)&__got_start, _dl_pagesz),
d219 1
a219 1
		        ELF_TRUNC((long)&__plt_start, _dl_pagesz),
a222 1
	
@


1.63
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.62 2003/06/03 18:04:08 drahn Exp $ */
d113 1
d230 1
a230 1
			exe_obj = _dl_add_object(argv[0],
d233 1
d244 1
a244 1
	 * Now, pick up and 'load' all libraries requierd. Start
a280 1
#ifdef NO_RANDOM_EXPOSES_BUGS_ELSEWHERE__
a293 1
#endif /* NO_RANDOM_EXPOSES_BUGS_ELSEWHERE__ */
d311 1
a311 1
				liblist[i].dynobj = depobj;
d314 1
d326 3
a328 2
	dyn_obj = _dl_add_object(us, dynp, 0, OBJTYPE_LDR, dl_data[AUX_base],
	    loff);
d626 1
@


1.62
log
@Disable random library ordering, this seems to be exposing bugs in other code.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.61 2003/05/30 19:07:34 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.61
log
@Move env setup to its own function, works around compiler problem on sparc
LD_NORANDOM is now disabled on issetugid().
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.60 2003/05/30 16:00:43 deraadt Exp $ */
d285 1
d299 1
@


1.60
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.59 2003/05/30 15:58:24 drahn Exp $ */
d126 2
a127 4
 * This is the dynamic loader entrypoint. When entering here, depending
 * on architecture type, the stack and registers are set up according
 * to the architectures ABI specification. The first thing required
 * to do is to dig out all information we need to accomplish our task.
d129 3
a131 2
unsigned long
_dl_boot(const char **argv, char **envp, const long loff, long *dl_data)
a132 11
	struct elf_object *exe_obj;	/* Pointer to executable object */
	struct elf_object *dyn_obj;	/* Pointer to executable object */
	struct r_debug **map_link;	/* Where to put pointer for gdb */
	struct r_debug *debug_map;
	Elf_Dyn *dynp;
	elf_object_t *dynobj;
	Elf_Phdr *phdp;
	char *us = "";
	unsigned int i;
	int libcnt = 0;

a163 1
#if 0
a167 1
#endif
d169 23
@


1.59
log
@Unbreak tree for sparc, zapping ld_norandom strangely has a bad affect,
killing ld.so.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.58 2003/05/30 03:14:12 drahn Exp $ */
d153 1
a153 1
	_dl_norandom =  _dl_getenv("LD_NORANDOM", envp);
@


1.58
log
@Fix botch in tag array indexing. deal with 0 - DT_NUM,
DT_LOPROC - DT_LOPROC+DT_PROCNUM, and no other values.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.57 2003/05/30 01:33:05 drahn Exp $ */
d176 1
d181 1
@


1.57
log
@zap LD_NORANDOM on issetugid() binaries.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.56 2003/05/30 01:13:53 drahn Exp $ */
d459 1
a459 1
		if (dynp->d_tag < DT_LOPROC)
d461 3
a463 2
		else if (dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM)
			dynld.Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] =
@


1.56
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.55 2003/02/15 22:43:06 drahn Exp $ */
d175 4
@


1.55
log
@After relocation is completed, remove write protection from GOT/PLT in ld.so.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.54 2003/02/02 16:57:58 deraadt Exp $ */
d40 2
d66 1
d104 1
d113 2
a114 1
		if (_dl_load_shlib(cp, _dl_objects, OBJTYPE_LIB) == 0) {
d119 1
d142 2
a143 1
	int n;
d153 1
d218 1
a218 1
	for (n = 0; n < dl_data[AUX_phnum]; n++) {
d238 1
a238 1
	while (dynobj) {
d240 1
d242 22
a263 1
			const char *libname;
a264 9
			if (dynp->d_tag != DT_NEEDED)
				continue;
			libname = dynobj->dyn.strtab;
			libname += dynp->d_un.d_val;
			DL_DEB(("needs: '%s'\n", libname));
			if (_dl_load_shlib(libname, dynobj, OBJTYPE_LIB) == 0) {
				_dl_printf("%s: can't load library '%s'\n",
				    _dl_progname, libname);
				_dl_exit(4);
d266 40
a306 1
		dynobj = dynobj->next;
d314 2
a315 1
	dyn_obj = _dl_add_object(us, dynp, 0, OBJTYPE_LDR, dl_data[AUX_base], loff);
@


1.54
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.53 2003/01/30 03:46:46 drahn Exp $ */
d175 27
@


1.53
log
@Change the constructor execution order to initialize dependant libraries
first. This mirrors the commit espie put in a.out ld.so recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.52 2002/11/14 15:15:54 drahn Exp $ */
d98 1
a98 2
_dl_dopreload(paths)
	char		*paths;
d188 1
a188 2
		}
		else if (phdp->p_type == PT_INTERP) {
d261 1
a261 1
		if (sym == NULL) {
d263 3
a265 3
		} else {
			(*(void (*)(Elf_Addr))(sym->st_value + ooff))((Elf_Addr)_dl_dtors);
		}
d272 2
a273 1
	map_link = (struct r_debug **)(exe_obj->Dyn.info[DT_MIPS_RLD_MAP - DT_LOPROC + DT_NUM]);
d282 1
a282 1
	if (dynp->d_tag != DT_DEBUG) {
a283 1
	}
d315 1
d319 2
a320 4
	int		n;
	int argc;
	char **argv;
	char **envp;
a321 1
	struct elf_object  dynld;	/* Resolver data for the loader */
a409 1

a441 1

a569 1

@


1.52
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.51 2002/10/25 10:39:51 pefo Exp $ */
d246 4
a249 2
	if ((_dl_traceld == NULL) && (_dl_objects->next != NULL))
		_dl_call_init(_dl_objects->next);
d519 7
a525 2
	if (object->next)
		_dl_call_init(object->next);
d533 1
@


1.51
log
@Some small fixes in MI code for mips backport. A new reloc md function,
RELOC_GOT, was added to handle mips got bootstrap reloc.

Also remove workaround used on previous versions of binutils for mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.50 2002/10/21 16:01:55 drahn Exp $ */
d260 1
a260 1
		    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT, 0);
@


1.50
log
@Simplify the ld.so asm api, the data is available other ways.
tested by naddy@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.49 2002/08/23 23:02:48 drahn Exp $ */
d190 1
a190 1
		if (phdp->p_type == PT_INTERP)
d192 1
d353 1
a353 1
	loff = dl_data[AUX_base];
d487 3
a516 3
	Elf_Addr ooff;
	const Elf_Sym *sym;

a522 1
#ifndef __mips__
a524 20
/*
 * XXX We perform relocation of DTOR/CTOR. This is a ld bug problem
 * XXX that should be fixed.
 */
	sym = NULL;
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym,
	    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_PLT, 0);
	if (sym != NULL) {
		int i = *(int *)(sym->st_value + ooff);
		while (i--)
			*(int *)(sym->st_value + ooff + 4 + 4 * i) += ooff;
	}
	sym = NULL;
	ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym,
	    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_PLT, 0);
	if (sym != NULL) {
		int i = *(int *)(sym->st_value + ooff);
		while (i--)
			*(int *)(sym->st_value + ooff + 4 + 4 * i) += ooff;
	}
a525 17
/*
 * XXX We should really call any code which resides in the .init segment
 * XXX but at the moment this functionality is not provided by the toolchain.
 * XXX Instead we rely on a symbol named '.init' and call it if it exists.
 */
	sym = NULL;
	ooff = _dl_find_symbol(".init", object, &sym,
	    SYM_SEARCH_SELF|SYM_WARNNOTFOUND|SYM_PLT, 0);
	if (sym != NULL) {
		DL_DEB(("calling .init in '%s'\n",object->load_name));
		(*(void(*)(void))(sym->st_value + ooff))();
	}
#if 0 /*XXX*/
	if (object->dyn.init)
		(*object->dyn.init)();
#endif
#endif /* __mips__ */
@


1.49
log
@Support for i386 ELF. Not an indication that the change is going to be made,
just so that these files are maintained in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.48 2002/08/23 22:57:03 drahn Exp $ */
d312 1
a312 1
_dl_boot_bind(const long sp, long loff, Elf_Dyn *dynamicp, long *dl_data)
d321 1
a351 1
#if defined(__sparc64__) || defined(__sparc__) || defined(__i386__)
a352 1
#endif
d362 2
a363 4
#if defined(__sparc64__) || defined(__sparc__)
	dynp = (Elf_Dyn *)((long)_DYNAMIC + loff);
#elif defined(__powerpc__) || defined(__alpha__)
	dynp = dynamicp;
@


1.48
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.47 2002/08/12 01:05:23 drahn Exp $ */
d351 1
a351 1
#if defined(__sparc64__) || defined(__sparc__)
@


1.47
log
@Add support for REL type relocations, all currently supported arch
use only RELA type relocations, but that could change. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.46 2002/08/11 18:41:17 drahn Exp $ */
d258 2
a259 1
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0, 1);
d533 2
a534 1
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1, 1, 1);
d541 2
a542 1
	ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1, 1, 1);
d555 2
a556 1
	ooff = _dl_find_symbol(".init", object, &sym, 1, 1, 1);
d584 1
a584 1
	return(0);
d586 1
@


1.46
log
@The parameter dynp was never used, rather than pass in a dummy on most
archs and a nasty calcuation on others, remove the parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.45 2002/08/11 16:51:04 drahn Exp $ */
a442 1
			/*
a443 1
			*/
@


1.45
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.44 2002/08/09 14:35:43 art Exp $ */
d127 1
a127 2
_dl_boot(const char **argv, char **envp, const long loff,
	Elf_Dyn *dynp, long *dl_data)
d133 1
@


1.44
log
@Simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.43 2002/07/27 15:40:44 art Exp $ */
d258 1
a258 1
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0);
d534 1
a534 1
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1, 1);
d541 1
a541 1
	ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1, 1);
d554 1
a554 1
	ooff = _dl_find_symbol(".init", object, &sym, 1, 1);
@


1.43
log
@I don't see the point of a return at the end of a void function.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.42 2002/07/27 13:19:26 art Exp $ */
d510 1
a510 4
	if (_dl_bindnow || object->dyn.bind_now)	/* XXX Perhaps more checking ? */
		_dl_md_reloc_got(object, 0);
	else
		_dl_md_reloc_got(object, 1);
@


1.42
log
@Just a skeleton for sparc. Builds, but pieces are missing and it doesn't
even get to dl_boot_bind correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.41 2002/07/24 04:11:10 deraadt Exp $ */
a493 1
	return;
@


1.41
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.39 2002/07/24 01:05:11 deraadt Exp $ */
d350 1
a350 1
#ifdef __sparc64__
d362 1
a362 1
#if defined(__sparc64__)
@


1.40
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.38 2002/07/12 20:18:30 drahn Exp $ */
d76 1
a76 1
 * Routine to walk through all of the objects except the first 
d195 1
a195 1
	if (_dl_preload != NULL) 
d235 1
a235 1
	if (_dl_traceld == NULL) 
@


1.39
log
@spacing
@
text
@d76 1
a76 1
 * Routine to walk through all of the objects except the first
d195 1
a195 1
	if (_dl_preload != NULL)
d235 1
a235 1
	if (_dl_traceld == NULL)
@


1.38
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.37 2002/07/07 08:54:50 jufi Exp $ */
d76 1
a76 1
 * Routine to walk through all of the objects except the first 
d195 1
a195 1
	if (_dl_preload != NULL) 
d235 1
a235 1
	if (_dl_traceld == NULL) 
@


1.37
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.36 2002/06/05 23:13:55 art Exp $ */
d41 1
d47 1
d67 2
d97 23
a168 1

d179 1
d195 3
d235 2
a236 1
	_dl_rtld(_dl_objects);
a265 1

d272 1
a279 1
		map_link = NULL;
@


1.36
log
@Cleanup/remove duplicate code that checks STAT_RELOC_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.35 2002/05/28 00:34:53 deraadt Exp $ */
d72 2
a73 1
 * Routine to walk thru all of the objects except the first (main executable).
d97 1
a97 1
 * to do is to dig out all information we need to accomplish out task.
d170 1
a170 1
	 * With the first on the list and then do whatever gets
d219 1
a219 1
	 * cannot call atexit directly from ld.so?
@


1.35
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.34 2002/05/28 00:31:37 deraadt Exp $ */
d471 3
@


1.34
log
@issetugid() test earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.33 2002/05/28 00:30:50 deraadt Exp $ */
d48 1
a48 1
 *  Local decls.
d93 4
a96 4
 *  This is the dynamic loader entrypoint. When entering here, depending
 *  on architecture type, the stack and registers are set up according
 *  to the architectures ABI specification. The first thing required
 *  to do is to dig out all information we need to accomplish out task.
a101 4
	int		n;
	Elf_Phdr	*phdp;
	char		*us = "";
	elf_object_t	*dynobj;
d104 1
d106 4
a109 1
	struct r_debug **map_link;	/* Where to put pointer for gdb */
d112 1
a112 1
	 *  Get paths to various things we are going to use.
d121 2
a122 2
	 *  Don't allow someone to change the search paths if he runs
	 *  a suid program without credentials high enough.
d153 1
a153 1
	 *  Examine the user application and set up object information.
d168 3
a170 3
	 *  Now, pick up and 'load' all libraries requierd. Start
	 *  With the first on the list and then do whatever gets
	 *  added along the tour.
d201 2
a202 2
	 *  Everything should be in place now for doing the relocation
	 *  and binding. Call _dl_rtld to do the job. Fingers crossed.
d324 2
a325 2
	 *  We need to do 'selfreloc' in case the code weren't
	 *  loaded at the address it was linked to.
d327 2
a328 2
	 *  Scan the DYNAMIC section for the loader.
	 *  Cache the data for easier access.
d350 3
a352 3
	 *  Do the 'bootstrap relocation'. This is really only needed if
	 *  the code was loaded at another location than it was linked to.
	 *  We don't do undefined symbols resolving (to difficult..)
a385 1
		int	i;
d388 1
a420 1
		int	i;
d423 1
d448 2
a449 2
				_dl_wrstderr((char *)dynld.dyn.strtab
					+ sp->st_name);
d473 1
a473 1
	 *  Do relocation information first, then GOT.
@


1.33
log
@unused variable in latest commit
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.32 2002/05/28 00:30:19 drahn Exp $ */
a119 8
	_dl_progname = argv[0];
	if (dl_data[AUX_pagesz] != 0)
		_dl_pagesz = dl_data[AUX_pagesz];
	else
		_dl_pagesz = 4096;

	DL_DEB(("rtld loading: '%s'\n", _dl_progname));

d125 4
a132 4
		if (_dl_libpath) {
			_dl_libpath = NULL;
			_dl_unsetenv("LD_LIBRARY_PATH", envp);
		}
d143 8
@


1.32
log
@Remove LD_LIBRARY_PATH completely from environment, as per ldconfig manpage.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.31 2002/05/28 00:23:57 deraadt Exp $ */
a560 1
		char *lep = ep;
@


1.31
log
@proto _dl_show_objects() in one place
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.30 2002/05/24 04:17:00 deraadt Exp $ */
d50 2
a51 1
static char *_dl_getenv(const char *var, const char **env);
d99 1
a99 1
_dl_boot(const char **argv, const char **envp, const long loff,
d133 17
a149 4
		if (_dl_preload)
			*_dl_preload = '\0';
		if (_dl_libpath)
			*_dl_libpath = '\0';
d538 1
a538 1
_dl_getenv(const char *var, const char **env)
d553 24
@


1.30
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.29 2002/05/24 03:44:37 deraadt Exp $ */
a251 1
		void _dl_show_objects(); /* remove -Wall warning */
@


1.29
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.28 2002/03/31 21:56:58 drahn Exp $ */
d117 1
a117 1
	_dl_debug   = _dl_getenv("LD_DEBUG", envp);
d208 1
a208 1
		const Elf_Sym  *sym;
d373 1
a373 1
		int	  i;
d375 1
a375 1
		Elf_Rel  *rp;
d382 1
a382 1
			const Elf_Sym  *sp;
d408 1
a408 1
		int	  i;
d410 1
a410 1
		Elf_RelA  *rp;
d427 1
a427 1
			const Elf_Sym  *sp;
d475 1
a475 1
	const Elf_Sym  *sym;
@


1.28
log
@Do not run static constructors when run from ldd. ok theo, art, espie, pefo
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.27 2002/03/17 19:02:30 art Exp $ */
d5 1
a5 1
 * 
a72 1

d77 1
a77 1
	if (object->dyn.fini) {
d79 1
a79 2
	}
	if (object->next) {
a80 1
	}
d87 1
a87 1
	if (_dl_objects->next) {
a88 1
	}
d120 1
a120 1
	if (dl_data[AUX_pagesz] != 0) {
d122 1
a122 1
	} else {
d124 1
a124 1
	}
d132 1
a132 1
		if (_dl_preload) {
d134 1
a134 2
		}
		if (_dl_libpath) {
a135 1
		}
d148 1
a148 1
		if (phdp->p_type == PT_INTERP) {
a149 1
		}
d171 1
a171 1
					_dl_progname, libname);
a189 1

d193 1
a193 1
	 * The first object is the executable itself, 
d199 1
a199 1
	if ((_dl_traceld == NULL) && (_dl_objects->next != NULL)) {
a200 1
	}
d256 1
a256 1
	if (_dl_traceld) {
a257 1
	}
d287 2
a288 1
	while(*stack++ != NULL) {};
d326 1
a326 1
		if (dynp->d_tag < DT_LOPROC) {
d328 3
a330 3
		} else if (dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM) {
			dynld.Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] = dynp->d_un.d_val;
		}
d346 2
a347 1
		int table[20]; 
d392 2
a393 2
				_dl_wrstderr((char *)dynld.dyn.strtab
					+ sp->st_name);
a441 1

a442 1

d456 1
a456 1
	if (object->next) {
a457 1
	}
d464 1
a464 1
	if (_dl_bindnow || object->dyn.bind_now) {	/* XXX Perhaps more checking ? */
d466 1
a466 1
	} else {
a467 1
	}
d477 1
a477 1
	if (object->next) {
a478 1
	}
d480 1
a480 1
	if (object->status & STAT_INIT_DONE) {
a481 1
	}
d484 1
a484 1
	if(object->dyn.init) {
a485 1
	}
d494 1
a494 1
		while(i--) {
a495 1
		}
d501 1
a501 1
		while(i--) {
a502 1
		}
d517 1
a517 1
	if (object->dyn.init) {
a518 1
	}
d536 1
a536 1
		if (*vp == '\0' && *ep++ == '=') {
a537 1
		}
a538 1

@


1.27
log
@Clean up building of debug_map. mips and non-mips can more
or less share the same code.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.26 2002/03/17 00:22:04 art Exp $ */
d205 1
d207 1
a207 1
	if (_dl_objects->next) {
d214 1
d216 1
a216 1
	{
@


1.26
log
@Clean up the zapping of bad variables. Instead of implementing
_dl_suid_ok, just use the issetugid syscall.
ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.25 2002/03/07 00:53:26 art Exp $ */
d109 4
a112 6
	struct elf_object  *exe_obj;	/* Pointer to executable object */
	struct elf_object  *dyn_obj;	/* Pointer to executable object */
	struct r_debug * debug_map;
#ifdef __mips__
	struct r_debug	   **map_link;	/* Where to put pointer for gdb */
#endif /* __mips__ */
d231 4
a234 13
#if defined(__powerpc__) || defined(__alpha__) || defined(__sparc64__)
	debug_map = (struct r_debug *)_dl_malloc(sizeof(*debug_map));
	debug_map->r_version = 1;
	debug_map->r_map = (struct link_map *)_dl_objects;
	debug_map->r_brk = (Elf_Addr)_dl_debug_state;
	debug_map->r_state = RT_CONSISTENT;
	debug_map->r_ldbase = loff;
	_dl_debug_map = debug_map;

	/* Picks up the first object, the executable itself */
	dynobj = _dl_objects;

	for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
d236 1
a236 1
			dynp->d_un.d_ptr = (Elf_Addr) debug_map;
d241 2
a242 1
		_dl_printf("failed to mark DTDEBUG\n");
a244 3

#ifdef __mips__
	map_link = (struct r_debug **)(exe_obj->Dyn.info[DT_MIPS_RLD_MAP - DT_LOPROC + DT_NUM]);
a254 1
#endif
@


1.25
log
@Add a debug printf for the entry point just before returning to MD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.24 2002/02/21 23:17:53 drahn Exp $ */
a53 1
int  _dl_trusted;
d137 1
a137 1
	if ((_dl_trusted = !_dl_suid_ok())) {	/* Zap paths if s[ug]id... */
@


1.24
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.23 2001/09/26 22:58:23 jason Exp $ */
d282 1
@


1.23
log
@'loff' shouldn't be const (at least not on sparc64)
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.22 2001/09/25 07:01:39 art Exp $ */
a51 7
/*
 * Static vars usable after bootsrapping.
 */
static void *_dl_malloc_base;
static void *_dl_malloc_pool = 0;
static long *_dl_malloc_free = 0;

a106 1
	int		brk_addr;
a151 4
		if (phdp->p_type == PT_LOAD) {				/*XXX*/
			if (phdp->p_vaddr + phdp->p_memsz > brk_addr)	/*XXX*/
				brk_addr = phdp->p_vaddr + phdp->p_memsz;
		}							/*XXX*/
d153 3
a155 2
			exe_obj = _dl_add_object("", (Elf_Dyn *)phdp->p_vaddr,
						   dl_data, OBJTYPE_EXE, 0, 0);
d158 1
a158 2
			us = (char *)_dl_malloc(_dl_strlen((char *)phdp->p_vaddr) + 1);
			_dl_strcpy(us, (char *)phdp->p_vaddr);
a499 1
	static void (*_dl_atexit)(Elf_Addr) = NULL;
a571 57
}


/*
 *  The following malloc/free code is a very simplified implementation
 *  of a malloc function. However, we do not need to be very complex here
 *  because we only free memory when 'dlclose()' is called and we can
 *  reuse at least the memory allocated for the object descriptor. We have
 *  one dynamic string allocated, the library name and it is likely that
 *  we can reuse that one to without a lot of complex colapsing code.
 */

void *
_dl_malloc(int size)
{
	long *p;
	long *t, *n;

	size = (size + 8 + DL_MALLOC_ALIGN - 1) & ~(DL_MALLOC_ALIGN - 1);

	if ((t = _dl_malloc_free) != 0) {	/* Try free list first */
		n = (long *)&_dl_malloc_free;
		while (t && t[-1] < size) {
			n = t;
			t = (long *)*t;
		}
		if (t) {
			*n = *t;
			_dl_memset(t, 0, t[-1] - 4);
			return((void *)t);
		}
	}
	if ((_dl_malloc_pool == 0) ||
	    (_dl_malloc_pool + size > _dl_malloc_base + 4096)) {
		_dl_malloc_pool = (void *)_dl_mmap((void *)0, 4096,
						PROT_READ|PROT_WRITE,
						MAP_ANON|MAP_PRIVATE, -1, 0);
		if (_dl_malloc_pool == 0 || _dl_malloc_pool == MAP_FAILED ) {
			_dl_printf("Dynamic loader failure: malloc.\n");
			_dl_exit(7);
		}
		_dl_malloc_base = _dl_malloc_pool;
	}
	p = _dl_malloc_pool;
	_dl_malloc_pool += size;
	_dl_memset(p, 0, size);
	*p = size;
	return((void *)(p + 1));
}

void
_dl_free(void *p)
{
	long *t = (long *)p;

	*t = (long)_dl_malloc_free;
	_dl_malloc_free = p;
@


1.22
log
@Zero out dl_data before populating it.
Cleaner populating of dl_data.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.21 2001/09/24 23:42:25 art Exp $ */
d301 1
a301 1
_dl_boot_bind(const long sp, const long loff, Elf_Dyn *dynamicp, long *dl_data)
@


1.21
log
@Some voodoo for bootstrapping sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.20 2001/09/24 21:35:09 drahn Exp $ */
a179 1

a203 1

d324 6
d333 5
a337 7

	auxstack = (AuxInfo *)stack;
	while (auxstack->au_id != AUX_null) {
		if (auxstack->au_id <= AUX_entry) {
			dl_data[auxstack->au_id] = auxstack->au_v;
		}
		auxstack++;
@


1.20
log
@API change between asm code and _dl_boot_bind(). Simply and
reduce number of parameters. Alpha changes coming shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.19 2001/09/22 04:58:18 drahn Exp $ */
a127 1

a301 1

a311 1
	
a330 1

d337 3
d349 3
a351 1
#if defined(__powerpc__) || defined(__alpha__) || defined(__sparc64__)
d436 1
a483 1

@


1.19
log
@Upon futher contemplation, the notion of unmaphints is just wrong.
First the maphints code is not cleaning up after itself, by leaving
a file descriptor open and trying to clean up after the dynamic linker
is done loading by removing data needed during dlopen() is nonsense.
the _dl_unmaphints() function and it's references have been removed.
_dl_maphints() now cleans up it's file descriptor before returning.
static data used later during dlopen() is left intact.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.18 2001/09/15 20:44:52 drahn Exp $ */
d249 1
a249 1
#if defined(__powerpc__) || defined(__alpha__)
d305 1
a305 2
_dl_boot_bind(const long sp, const long loff,  int argc, const char **argv,
	const char **envp, Elf_Dyn *dynamicp, long *dl_data)
d311 4
a314 1

a320 1
#ifdef _mips_
d323 1
a323 1
	argv = (const char **)stack;
a324 1
#endif /* _mips_ */
d350 1
a350 1
#if defined(__powerpc__) || defined(__alpha__)
@


1.18
log
@Some cleanup in loader.c, initialize the symbol pointer with NULL,
add a missing initialization of the sym pointer.

Add some functionality which allows a program to open itself dlopen(NULL),
so that it can then look up symbols in the executable itself.
Note that the program can only access exported variables, either by
exporting all variables with the ld option -E or externally referrenced.

Fix bug in dlsym() where it would return failure when looking up symbols.
It was testing the offset of the found symbol, not if the symbol was found.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.17 2001/06/13 08:40:39 art Exp $ */
a70 1
void _dl_unmaphints();
a292 1
	_dl_unmaphints();
@


1.17
log
@Don't do plt relocations here, move that to md code that might choose
to do lazy binding.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.16 2001/06/06 12:31:52 art Exp $ */
d237 1
d529 1
a529 1
	sym = 0;
d531 1
a531 1
	if (sym) {
d537 1
a537 1
	sym = 0;
d539 1
a539 1
	if (sym) {
d551 1
a551 1
	sym = 0;
d553 1
a553 1
	if (sym) {
@


1.16
log
@Replace all 'if (_dl_debug) _dl_printf(...)' with a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.15 2001/06/06 12:23:18 art Exp $ */
d497 3
a499 5
#if defined(__alpha__)
	/* We assume that DT_PTREL is DT_RELA */
	_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
#endif
	if (_dl_bindnow) {	/* XXX Perhaps more checking ? */
a500 2
	} else {
		_dl_md_reloc_got(object, 0);
@


1.15
log
@more cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.14 2001/06/06 10:59:15 art Exp $ */
d86 1
a86 2
	if (_dl_debug)
		_dl_printf("doing dtors: [%s]\n", object->load_name);
d98 1
a98 2
	if(_dl_debug)
		_dl_printf("doing dtors\n");
d142 1
a142 2
	if (_dl_debug)
		_dl_printf("rtld loading: '%s'\n", _dl_progname);
d185 1
a185 2
		if (_dl_debug)
			_dl_printf("examining: '%s'\n", dynobj->load_name);
d193 1
a193 2
			if (_dl_debug) 
				_dl_printf("needs: '%s'\n", libname);
d291 1
a291 2
		if (_dl_debug)
			_dl_printf("dynamic loading done.\n");
d557 1
a557 2
		if (_dl_debug)
			_dl_printf("calling .init in '%s'\n",object->load_name);
@


1.14
log
@Cleanup.
 - remove printfs that are only useful for the person who put them there.
 - Style.
 - dead code.
Needs much more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.13 2001/06/01 09:20:58 art Exp $ */
d209 2
a210 2
	 *  Now add the dynamic loader itself last in the object list
	 *  so we can use the _dl_ code when serving dl.... calls.
d235 2
a236 2
	 * schedule a routine to be run at shutdown, by using atexit.
	 * cannot call atexit directly from ld.so ??
d252 1
a252 1
	 *  Finally make something to help gdb when poking around in the code.
d255 7
a261 10
	{
		int done = 0;
		 
		debug_map = (struct r_debug *)_dl_malloc(sizeof(*debug_map));
		debug_map->r_version = 1;
		debug_map->r_map = (struct link_map *)_dl_objects;
		debug_map->r_brk = (Elf_Addr)_dl_debug_state;
		debug_map->r_state = RT_CONSISTENT;
		debug_map->r_ldbase = loff;
		_dl_debug_map = debug_map;
d263 2
a264 2
		/* picks up the first object, the executable itself */
		dynobj = _dl_objects;
d266 4
a269 9
		for (dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			if (dynp->d_tag == DT_DEBUG) {
				dynp->d_un.d_ptr = (Elf_Addr) debug_map;
				done = 1;
				break;
			}
		}
		if (done == 0) {
			_dl_printf("failed to mark DTDEBUG\n");
d271 3
@


1.13
log
@ - Allocate space for the finishing NUL in the name of ld.so.
 - some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.12 2001/05/31 13:58:24 art Exp $ */
d50 1
a50 1
/* static */ char *_dl_getenv(const char *var, const char **env);
d53 1
a53 1
 *   Static vars usable after bootsrapping.
a78 46

#if 1
static inline void
put_x(unsigned int x)
{
	char string[8];
	char *pchr;
	unsigned int rem;
	int len = 0;
	string[19] = '\0';
	pchr = &string[7];
	do {
		rem = x % 16;
		x =   x / 16;
		if (rem < 10) {
		*pchr = rem + '0';
		} else  {
			*pchr = rem - 10 + 'a';
		}
		pchr--;
		len++;
	} while (len < 8);
	_dl_write(1, string, len);

}

static inline int
putstring(char *string, unsigned int off)
{
	int len = 0;
	char * str1;
	if ((unsigned long) string < 0x10000000) {
		string += off;
	}
	for ( str1 = string; len < 30 && *str1++ != '\0'; len++);
	return _dl_write(1, string, len);
	
}
static inline int
putc(char c)
{
	return _dl_write(1, &c, 1);
	
}
#endif

d86 1
a86 1
	if(_dl_debug)
d88 1
a88 1
	if(object->dyn.fini) {
d95 1
d97 1
a97 1
_dl_dtors()
d105 1
a127 4
#if 0
_dl_printf("%p %p 0x%lx %p %p\n", argv, envp, loff, dynp, dl_data);
#endif

d139 1
a139 1
	if(dl_data[AUX_pagesz] != 0) {
d141 1
a141 2
	}
	else {
d144 1
a144 1
	if(_dl_debug)
d151 2
a152 2
	if((_dl_trusted = !_dl_suid_ok())) {	/* Zap paths if s[ug]id... */
		if(_dl_preload) {
d155 1
a155 1
		if(_dl_libpath) {
d163 4
a166 4
	phdp = (Elf_Phdr *) dl_data[AUX_phdr];
	for(n = 0; n < dl_data[AUX_phnum]; n++) {
		if(phdp->p_type == PT_LOAD) {				/*XXX*/
			if(phdp->p_vaddr + phdp->p_memsz > brk_addr)	/*XXX*/
d169 1
a169 1
		if(phdp->p_type == PT_DYNAMIC) {
d173 1
a173 1
		if(phdp->p_type == PT_INTERP) {
d187 2
a188 2
	while(dynobj) {
		if(_dl_debug)
d190 13
a202 12
		for(dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			if(dynp->d_tag == DT_NEEDED) {
				const char *libname;
				libname = dynobj->dyn.strtab;
				libname += dynp->d_un.d_val;
				if(_dl_debug) 
					_dl_printf("needs: '%s'\n", libname);
				if(_dl_load_shlib(libname, dynobj, OBJTYPE_LIB) == 0) {
					_dl_printf("%s: can't load library '%s'\n",
						_dl_progname, libname);
					_dl_exit(4);
				}
d223 3
a225 1
	/* the first object is the executable itself, 
d234 2
a235 1
	/* schedule a routine to be run at shutdown, by using atexit.
d245 1
a245 1
		} else
d247 1
d269 1
a269 1
		for(dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
d284 1
a284 1
	if(map_link) {
d298 1
a298 1
	if(_dl_debug || _dl_traceld) {
a307 3
#ifdef DL_PRINTF_DEBUG
_dl_printf("Entry point: 0x%lx\n", dl_data[AUX_entry]);
#endif
d309 3
d320 3
a322 1
	Elf_Dyn	*dynp;
a323 2
	long		*stack;
	AuxInfo		*auxstack;
a326 14
#if 0
_dl_printf("0x%lx 0x%lx %d %p %p %p %p\n", sp, loff, argc, argv, envp, dynamicp, dl_data);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[0], ((long *)sp)[0], ((long *)sp)[1], ((long *)sp)[2], ((long *)sp)[3]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[4], ((long *)sp)[4], ((long *)sp)[5], ((long *)sp)[6], ((long *)sp)[7]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[8], ((long *)sp)[8], ((long *)sp)[9], ((long *)sp)[10], ((long *)sp)[11]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[12], ((long *)sp)[12], ((long *)sp)[13], ((long *)sp)[14], ((long *)sp)[15]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[16], ((long *)sp)[16], ((long *)sp)[17], ((long *)sp)[18], ((long *)sp)[19]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[20], ((long *)sp)[20], ((long *)sp)[21], ((long *)sp)[22], ((long *)sp)[23]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[24], ((long *)sp)[24], ((long *)sp)[25], ((long *)sp)[26], ((long *)sp)[27]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[28], ((long *)sp)[28], ((long *)sp)[29], ((long *)sp)[30], ((long *)sp)[31]);
 _dl_printf("%p 0x%lx 0x%lx 0x%lx 0x%lx\n", &((long *)sp)[32], ((long *)sp)[32], ((long *)sp)[33], ((long *)sp)[34], ((long *)sp)[35]);
 _dl_printf("XXX 0x%lx\n", ((long *)sp)[23]);
#endif

d347 2
a348 11
#if 0
 _dl_printf("XXX 0x%lx\n", ((long *)sp)[23]);
_dl_printf("---\n");
#endif
	while(auxstack->au_id != AUX_null) {
#if 0
 _dl_printf("XXX %p 0x%lx\n", &((long *)sp)[23], ((long *)sp)[23]);
 _dl_printf("XXX %p 0x%lx\n", &auxstack->au_v, auxstack->au_v);
_dl_printf("%p 0x%lx 0x%lx %d 0x%lx\n", auxstack, ((long *)auxstack)[0], ((long *)auxstack)[1], auxstack->au_id, auxstack->au_v);
#endif
		if(auxstack->au_id <= AUX_entry) {
a353 7
#if 0
_dl_printf("---\n");
 _dl_printf("0x%lx 0x%lx 0x%lx 0x%lx\n", dl_data[0], dl_data[1], dl_data[2], dl_data[3]);
 _dl_printf("0x%lx 0x%lx 0x%lx 0x%lx\n", dl_data[4], dl_data[5], dl_data[6], dl_data[7]);
 _dl_printf("0x%lx 0x%lx 0x%lx 0x%lx\n", dl_data[8], dl_data[9], dl_data[10], dl_data[11]);
#endif

d355 1
a355 1
	 *  We need to do 'selfreloc' in case the code were'nt
d367 2
a368 2
	while(dynp != NULL && dynp->d_tag != DT_NULL) {
		if(dynp->d_tag < DT_LOPROC) {
d370 1
a370 2
		}
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM) {
d373 1
a373 1
		if(dynp->d_tag == DT_TEXTREL)
d399 1
a399 1
		/* other processors insert there extras here */
d401 1
a401 17
#if 0
		= {
		DT_PLTGOT,
		DT_HASH,
		DT_STRTAB,
		DT_SYMTAB,
		DT_RELA,
		DT_INIT,
		DT_FINI,
		DT_REL,
		DT_JMPREL,
		/* other processors insert there extras here */
		DT_NULL
		};
#endif
		for (i = 0; table[i] != DT_NULL; i++)
		{
d403 1
a403 2
			if ( val > DT_HIPROC) {
				/* ??? */
d405 1
a405 2
			}
			if ( val > DT_LOPROC) {
d407 1
a407 2
			}
			if ( dynld.Dyn.info[val] != 0 ) {
a408 1
			}
d421 1
a421 1
		for(i = 0; i < rs; i += sizeof (Elf_Rel)) {
a426 5
#if 1
			putstring("reloc  ", loff);
			putstring(((char *)dynld.dyn.strtab) + sp->st_name, 0);
			putstring(" ", loff);
#endif
d428 1
a428 1
			if(ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
a439 4
#if 0
			put_x((unsigned int)ra);
			putstring("\n", loff);
#endif
d447 1
a447 1
	for(n = 0; n < 2; n++) {
a459 1

a463 1
			;
d465 1
a465 1
		for(i = 0; i < rs; i += sizeof (Elf_RelA)) {
d471 1
a471 1
			if(ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
a483 2
			/*
			*/
a484 2
			/*
			*/
d488 2
a489 1
	/* we have been fully relocated here, so most things no longer
d499 1
a499 1
	if(object->next) {
d512 1
a512 1
	if(_dl_bindnow) {	/* XXX Perhaps more checking ? */
d527 1
a527 1
	if(object->next) {
d531 1
a531 1
	if(object->status & STAT_INIT_DONE) {
a534 1

d539 2
a540 3
#endif
#ifdef __mips__
/* XXX We perform relocation of DTOR/CTOR. This is a ld bug problem
d545 1
a545 1
	if(sym) {
d553 1
a553 1
	if(sym) {
d560 2
a561 1
/* XXX We should really call any code which resides in the .init segment
d567 2
a568 2
	if(sym) {
		if(_dl_debug)
d573 1
a573 1
	if(object->dyn.init) {
d581 1
a581 1
/* static */ char *
d586 1
a586 1
	while((ep = *env++)) {
d588 2
a589 1
		while(*vp && *vp == *ep) {
d593 1
a593 1
		if(*vp == '\0' && *ep++ == '=') {
d597 1
d619 1
a619 1
	if((t = _dl_malloc_free) != 0) {	/* Try free list first */
d621 1
a621 1
		while(t && t[-1] < size) {
d625 1
a625 1
		if(t) {
d631 2
a632 2
	if((_dl_malloc_pool == 0) ||
	   (_dl_malloc_pool + size > _dl_malloc_base + 4096)) {
d636 1
a636 3
		if(_dl_malloc_pool == 0 ||
			_dl_malloc_pool == MAP_FAILED )
		{
@


1.12
log
@If we can't find atexit (because we linked against libc.a),
print a message instead of dereferencing a NULL pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.11 2001/05/31 13:53:56 art Exp $ */
d223 1
a223 1
			us = (char *)_dl_malloc(_dl_strlen((char *)phdp->p_vaddr));
d298 1
a298 1
#ifdef __powerpc__
d618 1
@


1.11
log
@alpha needs JMPREL relocations.
various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.10 2001/05/28 21:38:14 drahn Exp $ */
d288 4
a291 1
		(*(void (*)(Elf_Addr))(sym->st_value + ooff))((Elf_Addr)_dl_dtors);
@


1.10
log
@Commonize csu code for elf systems, powerpc now no longer has it's own
versions of these files.

Fixed a bug in ld.so in this, instead of scheduling the fini of each of
the shared libraries with atexit. schedule a function of ld.so itself
and it will walk all of the open libraries when the program exits.
otherwise a shared library could be dl_open()ed and then dl_close()d
and then it would not be mapped for the atexit processing.

TODO:
What if atexit is not found (process did not link against libc?)
Do shared libraries that are dl_closed have their global destructors run?
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.10 2001/05/28 21:27:50 drahn Exp $ */
d349 2
a350 2
#if 0
_dl_printf("0x%lx\n", dl_data[AUX_entry]);
d352 1
d550 1
a550 1
		u_int32_t rs;
a593 1

d614 1
a614 1
	/*
d616 1
a616 1
	*/
d619 1
a619 2
	}
	else {
d622 1
@


1.9
log
@Commit initial alpha bits, to facilitate in-tree dev.
This code is not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.8 2001/05/12 10:39:54 art Exp $ */
d126 25
d272 1
a272 1
	 * it is responsible for running it's ctors/dtors
d279 12
@


1.8
log
@MAP_COPY -> MAP_PRIVATE
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.7 2001/04/02 23:11:20 drahn Exp $ */
d57 1
a57 1
static long  *_dl_malloc_free = 0;
d143 7
d312 3
d329 14
a342 4
#ifdef __mips__
	struct r_debug	   *debug_map;	/* Dynamic objects map for gdb */
	struct r_debug	   **map_link;	/* Where to put pointer for gdb */
#endif /* __mips__ */
d364 4
d369 5
d379 7
@


1.7
log
@Cleanup for 64bit support.
Pieces by art, niklas and me.
Only tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.6 2001/02/03 22:11:41 drahn Exp $ */
d666 1
a666 1
						MAP_ANON|MAP_COPY, -1, 0);
@


1.6
log
@Previously only powerpc used the DT_INIT field to find the ctors/init
code, now that will be changed to all arch besides mips will default
to using that. mips probably would be changed to but it has not been
tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.5 2001/01/23 15:56:39 deraadt Exp $ */
d57 1
a57 1
static int  *_dl_malloc_free = 0;
d110 1
a110 1
	if ((unsigned int) string < 0x10000000) {
d128 1
a128 1
 *  to the architectures ABI specification. The first thing requiered
d131 3
a133 3
int
_dl_boot(const char **argv, const char **envp, const int loff,
	Elf32_Dyn *dynp, int *dl_data)
d137 1
a137 1
	Elf32_Phdr	*phdp;
d180 1
a180 1
	phdp = (Elf32_Phdr *) dl_data[AUX_phdr];
d187 1
a187 1
			exe_obj = _dl_add_object("", (Elf32_Dyn *)phdp->p_vaddr,
d229 1
a229 1
	dynp = (Elf32_Dyn *)((int)_DYNAMIC);
d258 1
a258 1
		debug_map->r_brk = (Elf32_Addr)_dl_debug_state;
d268 1
a268 1
				dynp->d_un.d_ptr = (Elf32_Addr) debug_map;
d285 1
a285 1
		debug_map->r_brk = (Elf32_Addr)_dl_debug_state;
d310 2
a311 2
_dl_boot_bind(const int sp, const int loff,  int argc, const char **argv,
	const char **envp, Elf32_Dyn *dynamicp, int *dl_data)
d313 1
a313 1
	Elf32_Dyn	*dynp;
d315 1
a315 1
	int		*stack;
d329 1
a329 1
	stack = (int *)sp;
d334 1
a334 1
	stack = (int *)envp;
d338 1
a338 1
	 * Dig out auxilary data set up by exec call. Move all known
d359 1
a359 1
#ifdef __powerpc__
d362 1
a362 1
	dynp = (Elf32_Dyn *)((int)_DYNAMIC + loff);
d434 1
a434 1
		Elf32_Rel  *rp;
d436 1
a436 1
		rp = (Elf32_Rel *)(dynld.Dyn.info[DT_REL]);
d439 3
a441 3
		for(i = 0; i < rs; i += sizeof (Elf32_Rel)) {
			Elf32_Addr *ra;
			const Elf32_Sym  *sp;
d444 1
a444 1
			sp += ELF32_R_SYM(rp->r_info);
d451 1
a451 1
			if(ELF32_R_SYM(rp->r_info) && sp->st_value == 0) {
d462 1
a462 1
			ra = (Elf32_Addr *)(rp->r_offset + loff);
d477 1
a477 1
		Elf32_Rela  *rp;
d481 1
a481 1
			rp = (Elf32_Rela *)(dynld.Dyn.info[DT_JMPREL]);
d485 1
a485 1
			rp = (Elf32_Rela *)(dynld.Dyn.info[DT_RELA]);
d494 3
a496 3
		for(i = 0; i < rs; i += sizeof (Elf32_Rela)) {
			Elf32_Addr *ra;
			const Elf32_Sym  *sp;
d499 2
a500 2
			sp += ELF32_R_SYM(rp->r_info);
			if(ELF32_R_SYM(rp->r_info) && sp->st_value == 0) {
d510 1
a510 1
			ra = (Elf32_Addr *)(rp->r_offset + loff);
d555 3
a557 3
	Elf32_Addr ooff;
	const Elf32_Sym  *sym;
	static void (*_dl_atexit)(Elf32_Addr) = NULL;
d645 2
a646 2
	int *p;
	int *t, *n;
d651 1
a651 1
		n = (int *)&_dl_malloc_free;
d654 1
a654 1
			t = (int *)*t;
d668 1
a668 1
			_dl_malloc_pool == (void*)0xffffffff )
d685 1
a685 1
	int *t = (int *)p;
d687 1
a687 1
	*t = (int)_dl_malloc_free;
@


1.5
log
@fix includes
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.4 2000/10/13 05:21:10 drahn Exp $ */
d568 1
a568 1
#ifdef __powerpc__
d573 1
a573 1
#ifndef __powerpc__
d610 1
a610 1
#endif /* ! __powerpc__ */
@


1.4
log
@Clean up static constructor/destructor discovery and calling. Instead
of relying on magic variable names, reqire that the library provide the
_init/_fini functions so that the linker will find them and create
the DT_INIT and DT_FINI sections of the .dynamic section of the shared library.
With the shared library providing the DT_INIT function pointer, it is
now possible to just check the init field and call it if defined, if not
defined no constructors are needed. This cleans up the code in ld.so greatly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.3 2000/09/17 17:50:57 deraadt Exp $ */
d39 1
@


1.3
log
@activate ldd, and indent some ld.so messages to make it easier to see what is going on
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.2 2000/09/11 02:36:37 rahnds Exp $ */
d238 8
a245 1
	_dl_call_init(_dl_objects);
a565 16
#if 0
	ooff = _dl_find_symbol("_GLOBAL_.I.__1A", object, &sym, 1, 0);
	if (sym) {
		if(_dl_debug)
			_dl_printf("ctor func %x of %x\n", sym->st_value, ooff);
		(*(void (*)(void))(sym->st_value + ooff))();
	}
	ooff = _dl_find_symbol("_GLOBAL_.D.__1A", object, &sym, 1, 1);
	if (sym) {
		Elf32_Addr dtor_func = sym->st_value + ooff;

		/* cannot call atexit directly from ld.so ?? */
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0);
		(*(void (*)(Elf32_Addr))(sym->st_value + ooff))(dtor_func);
	}
#endif
d568 2
a569 50
/* For powerpc, the ctors/dtors section is a list of function pointers
 * to be called at the appropriate time. These have been relocated
 * by the dynamic relocations before as necessary. At this time,
 * it is just necessary to call all of the ctors functions
 * and set up the dtors functions to be called at exit (using atexit).
 * Is requiring libc for atexit a problem?
 */
	sym = 0;
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1, 1);
	if(sym) {
		int i = 1;
		typedef void *voidfunc(void) ; 
		voidfunc **func;
		func = (voidfunc **)(sym->st_value + ooff);
		for (i=1; func[i] != NULL; i++) {
			if(_dl_debug) {
				_dl_printf("ctor func %x\n", func[i]);
			}
			(func[i])();
		}
	}
	/* Once atexit() is found, do not bother to look it up again.
	 * the same atexit() should be used for all libraries.
	 */
	if (_dl_atexit == NULL) {
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0);
		if (sym) {
			_dl_atexit = (void (*)(Elf32_Addr))
				(sym->st_value + ooff);
			if(_dl_debug) {
				_dl_printf("_dl_atexit at %x\n", _dl_atexit);
			}
		}
	}
	/* if atexit() is not found, dtors cannot be run */
	if (_dl_atexit != NULL) {
		sym = 0;
		ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1, 1);
		if(sym) {
			int i = 1;
			typedef void *voidfunc(void) ; 
			voidfunc **func;
			func = (voidfunc **)(sym->st_value + ooff);
			for (i=1; func[i] != NULL; i++) {
				if(_dl_debug) {
					_dl_printf("dtor func %x\n", func[i]);
				}
				(*_dl_atexit)((Elf32_Addr)func[i]);
			}
		}
@


1.2
log
@ldd compatibility (if we had ldd for this ld.so)
respect the LD_TRACE_LOADED_OBJECTS environment variable,
print loaded libraries and exit, do not execute program.
@
text
@d1 1
a1 1
/*	$OpenBSD: loader.c,v 1.1.1.2 2000/06/13 03:40:05 rahnds Exp $ */
d290 2
a291 1
		_dl_printf("dynamic loading done.\n");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
d49 1
a49 1
static char *_dl_getenv(const char *var, const char **env);
d70 1
d78 46
a129 1

d131 2
a132 1
_dl_boot(const int sp, const int loff)
a133 1
	int		argc;
a135 5
	const char	**argv, **envp;
	int		*stack, execstack = sp;
	AuxInfo		*auxstack;
	int		dl_data[AUX_entry + 1];
	Elf32_Dyn	*dynp;
d137 1
a138 3
	char		*us = "";

	struct elf_object  dynld;	/* Resolver data for the loader */
d141 1
a141 2
	struct r_debug	   *debug_map;	/* Dynamic objects map for gdb */
	struct r_debug	   **map_link;	/* Where to put pointer for gdb */
d144 1
a144 48
	 * Scan argument and environment vectors. Find dynamic
	 * data vector put after them.
	 */
	stack = (int *)execstack;
	argc = *stack++;
	argv = (const char **)stack;
	envp = &argv[argc + 1];
	stack = (int *)envp;
	while(*stack++ != NULL) {};

	/*
	 * Dig out auxilary data set up by exec call. Move all known
	 * tags to an indexed local table for easy access.
	 */

	auxstack = (AuxInfo *)stack;
	while(auxstack->au_id != AUX_null) {
		if(auxstack->au_id <= AUX_entry) {
			dl_data[auxstack->au_id] = auxstack->au_v;
		}
		auxstack++;
	}

	/*
	 *  We need to do 'selfreloc' in case the code were'nt
	 *  loaded at the address it was linked to.
	 *
	 *  Scan the DYNAMIC section for the loader.
	 *  Cache the data for easier access.
	 */

	dynp = (Elf32_Dyn *)((int)_DYNAMIC + loff);
	while(dynp->d_tag != DT_NULL) {
		if(dynp->d_tag < DT_PROCNUM) {
			dynld.Dyn.info[dynp->d_tag] = dynp->d_un.d_val;
		}
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_PROCNUM) {
			dynld.Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] = dynp->d_un.d_val;
		}
		if(dynp->d_tag == DT_TEXTREL)
			dynld.dyn.textrel = 1;
		dynp++;
	}

	/*
	 *  Do the 'bootstrap relocation'. This is really only needed if
	 *  the code was loaded at another location than it was linked to.
	 *  We don't do undefined symbols resolving (to difficult..)
a145 17
	for(n = 0; n < 2; n++) {
		int	  i;
		u_int32_t rs;
		RELTYPE	  *rp;

		if(n == 0) {
			rp = (RELTYPE *)(dynld.Dyn.info[DT_REL] + loff);
			rs = dynld.dyn.relsz;
		}
		else {
			rp = (RELTYPE *)(dynld.Dyn.info[DT_JMPREL] + loff);
			rs = dynld.dyn.pltrelsz;
		}

		for(i = 0; i < rs; i += RELSIZE) {
			Elf32_Addr *ra;
			const Elf32_Sym  *sp;
a146 18
			sp = dynld.dyn.symtab + loff;
			sp += ELF32_R_SYM(rp->r_info);
			if(ELF32_R_SYM(rp->r_info) && sp->st_value == 0) {
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab + loff + sp->st_name);
				_dl_exit(4);
			}

			ra = (Elf32_Addr *)(rp->r_offset + loff);
			SIMPLE_RELOC(rp, sp, ra, loff);
		}

	}

	/*
	 *  Get paths to various things we are going to use.
	 */
d228 1
a228 1
	dynp = (Elf32_Dyn *)((int)_DYNAMIC + loff);
d243 27
d287 2
a288 1
	if(_dl_debug) {
d292 16
d309 208
a516 1
	return(dl_data[AUX_entry]);
d531 2
d534 1
d547 2
a548 1
	Elf32_Sym  *sym;
d558 71
d633 1
a633 1
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1);
d641 1
a641 1
	ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1);
d654 1
a654 1
	ooff = _dl_find_symbol(".init", object, &sym, 1);
d665 1
d669 1
a669 1
static char *
d722 3
a724 1
		if(_dl_malloc_pool == 0) {
d726 1
a726 1
			_dl_exit(4);
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@


1.1.1.2
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems
such as correctness and security.
@
text
@a38 1
#include <nlist.h>
d48 1
a48 1
/* static */ char *_dl_getenv(const char *var, const char **env);
a68 1
void _dl_unmaphints();
a75 46

#if 1
static inline void
put_x(unsigned int x)
{
	char string[8];
	char *pchr;
	unsigned int rem;
	int len = 0;
	string[19] = '\0';
	pchr = &string[7];
	do {
		rem = x % 16;
		x =   x / 16;
		if (rem < 10) {
		*pchr = rem + '0';
		} else  {
			*pchr = rem - 10 + 'a';
		}
		pchr--;
		len++;
	} while (len < 8);
	_dl_write(1, string, len);

}

static inline int
putstring(char *string, unsigned int off)
{
	int len = 0;
	char * str1;
	if ((unsigned int) string < 0x10000000) {
		string += off;
	}
	for ( str1 = string; len < 30 && *str1++ != '\0'; len++);
	return _dl_write(1, string, len);
	
}
static inline int
putc(char c)
{
	return _dl_write(1, &c, 1);
	
}
#endif

d82 1
d84 1
a84 2
_dl_boot(const char **argv, const char **envp, const int loff,
	Elf32_Dyn *dynp, int *dl_data)
d86 1
d89 5
d95 1
d97 2
a98 1
	elf_object_t	*dynobj;
d101 85
a185 1
	struct r_debug * debug_map;
a189 1

d271 1
a271 1
	dynp = (Elf32_Dyn *)((int)_DYNAMIC);
a285 27
#ifdef __powerpc__
	{
		int done = 0;
		 
		debug_map = (struct r_debug *)_dl_malloc(sizeof(*debug_map));
		debug_map->r_version = 1;
		debug_map->r_map = (struct link_map *)_dl_objects;
		debug_map->r_brk = (Elf32_Addr)_dl_debug_state;
		debug_map->r_state = RT_CONSISTENT;
		debug_map->r_ldbase = loff;
		_dl_debug_map = debug_map;

		/* picks up the first object, the executable itself */
		dynobj = _dl_objects;

		for(dynp = dynobj->load_dyn; dynp->d_tag; dynp++) {
			if (dynp->d_tag == DT_DEBUG) {
				dynp->d_un.d_ptr = (Elf32_Addr) debug_map;
				done = 1;
				break;
			}
		}
		if (done == 0) {
			_dl_printf("failed to mark DTDEBUG\n");
		}
	}
#endif
a303 1
		void _dl_show_objects(); /* remove -Wall warning */
d307 1
a307 1
	_dl_unmaphints();
a312 220
_dl_boot_bind(const int sp, const int loff,  int argc, const char **argv,
	const char **envp, Elf32_Dyn *dynamicp, int *dl_data)
{
	Elf32_Dyn	*dynp;
	int		n;
	int		*stack;
	AuxInfo		*auxstack;

	struct elf_object  dynld;	/* Resolver data for the loader */
#ifdef __mips__
	struct r_debug	   *debug_map;	/* Dynamic objects map for gdb */
	struct r_debug	   **map_link;	/* Where to put pointer for gdb */
#endif /* __mips__ */

	/*
	 * Scan argument and environment vectors. Find dynamic
	 * data vector put after them.
	 */
#ifdef _mips_
	stack = (int *)sp;
	argc = *stack++;
	argv = (const char **)stack;
	envp = &argv[argc + 1];
#endif /* _mips_ */
	stack = (int *)envp;
	while(*stack++ != NULL) {};

	/*
	 * Dig out auxilary data set up by exec call. Move all known
	 * tags to an indexed local table for easy access.
	 */

	auxstack = (AuxInfo *)stack;

	while(auxstack->au_id != AUX_null) {
		if(auxstack->au_id <= AUX_entry) {
			dl_data[auxstack->au_id] = auxstack->au_v;
		}
		auxstack++;
	}

	/*
	 *  We need to do 'selfreloc' in case the code were'nt
	 *  loaded at the address it was linked to.
	 *
	 *  Scan the DYNAMIC section for the loader.
	 *  Cache the data for easier access.
	 */

#ifdef __powerpc__
	dynp = dynamicp;
#else
	dynp = (Elf32_Dyn *)((int)_DYNAMIC + loff);
#endif
	while(dynp != NULL && dynp->d_tag != DT_NULL) {
		if(dynp->d_tag < DT_LOPROC) {
			dynld.Dyn.info[dynp->d_tag] = dynp->d_un.d_val;
		}
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM) {
			dynld.Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] = dynp->d_un.d_val;
		}
		if(dynp->d_tag == DT_TEXTREL)
			dynld.dyn.textrel = 1;
		dynp++;
	}

	/*
	 *  Do the 'bootstrap relocation'. This is really only needed if
	 *  the code was loaded at another location than it was linked to.
	 *  We don't do undefined symbols resolving (to difficult..)
	 */

	/* "relocate" dyn.X values if they represent addresses */
	{
		int i, val;
		/* must be code, not pic data */
		int table[20]; 
		i = 0;
		table[i++] = DT_PLTGOT;
		table[i++] = DT_HASH;
		table[i++] = DT_STRTAB;
		table[i++] = DT_SYMTAB;
		table[i++] = DT_RELA;
		table[i++] = DT_INIT;
		table[i++] = DT_FINI;
		table[i++] = DT_REL;
		table[i++] = DT_JMPREL;
		/* other processors insert there extras here */
		table[i++] = DT_NULL;
#if 0
		= {
		DT_PLTGOT,
		DT_HASH,
		DT_STRTAB,
		DT_SYMTAB,
		DT_RELA,
		DT_INIT,
		DT_FINI,
		DT_REL,
		DT_JMPREL,
		/* other processors insert there extras here */
		DT_NULL
		};
#endif
		for (i = 0; table[i] != DT_NULL; i++)
		{
			val = table[i];
			if ( val > DT_HIPROC) {
				/* ??? */
				continue;
			}
			if ( val > DT_LOPROC) {
				val -= DT_LOPROC + DT_NUM;
			}
			if ( dynld.Dyn.info[val] != 0 ) {
				dynld.Dyn.info[val] += loff;
			}
		}

	}

	{
		int	  i;
		u_int32_t rs;
		Elf32_Rel  *rp;

		rp = (Elf32_Rel *)(dynld.Dyn.info[DT_REL]);
		rs = dynld.dyn.relsz;

		for(i = 0; i < rs; i += sizeof (Elf32_Rel)) {
			Elf32_Addr *ra;
			const Elf32_Sym  *sp;

			sp = dynld.dyn.symtab;
			sp += ELF32_R_SYM(rp->r_info);
#if 1
			putstring("reloc  ", loff);
			putstring(((char *)dynld.dyn.strtab) + sp->st_name, 0);
			putstring(" ", loff);
#endif

			if(ELF32_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
/* cannot printf in this function */
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab
					+ sp->st_name);
#endif
				_dl_exit(5);
			}

			ra = (Elf32_Addr *)(rp->r_offset + loff);
#if 0
			put_x((unsigned int)ra);
			putstring("\n", loff);
#endif
			/*
			RELOC_REL(rp, sp, ra, loff);
			*/
			rp++;
		}

	}
	for(n = 0; n < 2; n++) {
		int	  i;
		u_int32_t rs;
		Elf32_Rela  *rp;

		switch (n) {
		case 0:
			rp = (Elf32_Rela *)(dynld.Dyn.info[DT_JMPREL]);
			rs = dynld.dyn.pltrelsz;
			break;
		case 1:
			rp = (Elf32_Rela *)(dynld.Dyn.info[DT_RELA]);
			rs = dynld.dyn.relasz;

			break;
		default:
			rp = NULL;
			rs = 0;
			;
		}
		for(i = 0; i < rs; i += sizeof (Elf32_Rela)) {
			Elf32_Addr *ra;
			const Elf32_Sym  *sp;

			sp = dynld.dyn.symtab;
			sp += ELF32_R_SYM(rp->r_info);
			if(ELF32_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab
					+ sp->st_name);
#endif
				_dl_exit(6);
			}

			ra = (Elf32_Addr *)(rp->r_offset + loff);

			RELOC_RELA(rp, sp, ra, loff);
			/*
			*/

			/*
			*/
			rp++;
		}

	}
	/* we have been fully relocated here, so most things no longer
	 * need the loff adjustment
	 */
	return;
}


void
a322 2
	_dl_md_reloc(object, DT_RELA, DT_RELASZ);
	/*
a323 1
	*/
d336 1
a336 2
	const Elf32_Sym  *sym;
	static void (*_dl_atexit)(Elf32_Addr) = NULL;
a345 71
#if 0
	ooff = _dl_find_symbol("_GLOBAL_.I.__1A", object, &sym, 1, 0);
	if (sym) {
		if(_dl_debug)
			_dl_printf("ctor func %x of %x\n", sym->st_value, ooff);
		(*(void (*)(void))(sym->st_value + ooff))();
	}
	ooff = _dl_find_symbol("_GLOBAL_.D.__1A", object, &sym, 1, 1);
	if (sym) {
		Elf32_Addr dtor_func = sym->st_value + ooff;

		/* cannot call atexit directly from ld.so ?? */
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0);
		(*(void (*)(Elf32_Addr))(sym->st_value + ooff))(dtor_func);
	}
#endif

#ifdef __powerpc__
/* For powerpc, the ctors/dtors section is a list of function pointers
 * to be called at the appropriate time. These have been relocated
 * by the dynamic relocations before as necessary. At this time,
 * it is just necessary to call all of the ctors functions
 * and set up the dtors functions to be called at exit (using atexit).
 * Is requiring libc for atexit a problem?
 */
	sym = 0;
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1, 1);
	if(sym) {
		int i = 1;
		typedef void *voidfunc(void) ; 
		voidfunc **func;
		func = (voidfunc **)(sym->st_value + ooff);
		for (i=1; func[i] != NULL; i++) {
			if(_dl_debug) {
				_dl_printf("ctor func %x\n", func[i]);
			}
			(func[i])();
		}
	}
	/* Once atexit() is found, do not bother to look it up again.
	 * the same atexit() should be used for all libraries.
	 */
	if (_dl_atexit == NULL) {
		ooff = _dl_find_symbol("atexit", _dl_objects, &sym, 0, 0);
		if (sym) {
			_dl_atexit = (void (*)(Elf32_Addr))
				(sym->st_value + ooff);
			if(_dl_debug) {
				_dl_printf("_dl_atexit at %x\n", _dl_atexit);
			}
		}
	}
	/* if atexit() is not found, dtors cannot be run */
	if (_dl_atexit != NULL) {
		sym = 0;
		ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1, 1);
		if(sym) {
			int i = 1;
			typedef void *voidfunc(void) ; 
			voidfunc **func;
			func = (voidfunc **)(sym->st_value + ooff);
			for (i=1; func[i] != NULL; i++) {
				if(_dl_debug) {
					_dl_printf("dtor func %x\n", func[i]);
				}
				(*_dl_atexit)((Elf32_Addr)func[i]);
			}
		}
	}
#endif
#ifndef __powerpc__
d350 1
a350 1
	ooff = _dl_find_symbol("__CTOR_LIST__", object, &sym, 1, 1);
d358 1
a358 1
	ooff = _dl_find_symbol("__DTOR_LIST__", object, &sym, 1, 1);
d371 1
a371 1
	ooff = _dl_find_symbol(".init", object, &sym, 1, 1);
a381 1
#endif /* ! __powerpc__ */
d385 1
a385 1
/* static */ char *
d438 1
a438 3
		if(_dl_malloc_pool == 0 ||
			_dl_malloc_pool == (void*)0xffffffff )
		{
d440 1
a440 1
			_dl_exit(7);
@

