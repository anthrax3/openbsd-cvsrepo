head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.10
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.8
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	r20000612:1.1.1.1
	dsr:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.43;
commitid	veGB6uLWx3BTEAfk;

1.43
date	2016.08.28.06.15.32;	author guenther;	state Exp;
branches;
next	1.42;
commitid	Y7AbrDd15D7CrGY4;

1.42
date	2016.07.04.21.15.07;	author guenther;	state Exp;
branches;
next	1.41;
commitid	qHDzpShMNCJZKLBF;

1.41
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.40;
commitid	d9R7VGw9CHTkwXE1;

1.40
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.39;
commitid	hneUpr7ZOJCeNeHP;

1.39
date	2016.03.21.01.32.49;	author guenther;	state Exp;
branches;
next	1.38;
commitid	7Tp2uEssgeiK9f77;

1.38
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	kmpP8aoRsEOyxUMj;

1.37
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.36;
commitid	FcRQ6g8MqXiORdFs;

1.36
date	2014.09.01.05.09.53;	author doug;	state Exp;
branches;
next	1.35;
commitid	XQe4V1YtkyCx6uWd;

1.35
date	2014.07.14.03.54.51;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	fsr4AzfIP3TLhLM2;

1.34
date	2014.07.09.12.51.21;	author guenther;	state Exp;
branches;
next	1.33;
commitid	l16v8zUGQ3906m8T;

1.33
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.32;
commitid	vlK4cqSehsiJVTpr;

1.32
date	2014.07.05.21.54.51;	author miod;	state Exp;
branches;
next	1.31;
commitid	L2YdBy6SCQ1MEPfW;

1.31
date	2014.07.05.20.41.25;	author miod;	state Exp;
branches;
next	1.30;
commitid	zx3AJZL8OTCTrlVs;

1.30
date	2014.07.05.17.06.18;	author miod;	state Exp;
branches;
next	1.29;
commitid	jSLj33X9mOpIw96Z;

1.29
date	2013.08.13.22.33.04;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.13.05.52.20;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.09.13.10.19;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.24.03.26.56;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.08.17.14.32.46;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.03.16.10.52;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.12.02.21.21;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.03.17.00.15;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.09.16.10.04;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.24.01.05.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.23.23.56.31;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.24.04.17.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.24.03.44.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.17.00.22.04;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.01.00.51.20;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.25.03.36.38;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.40.39;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.40.39;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.44
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: syscall.h,v 1.43 2016/08/28 06:15:32 guenther Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#ifndef __DL_SYSCALL_H__
#define __DL_SYSCALL_H__

#include <sys/stat.h>
#include <sys/syscall.h>

#ifndef _dl_MAX_ERRNO
#define _dl_MAX_ERRNO 512L
#endif
#define _dl_mmap_error(__res) \
    ((long)__res < 0 && (long)__res >= -_dl_MAX_ERRNO)

int	_dl_close(int);
__dead
void	_dl_exit(int);
int	_dl_fstat(int, struct stat *);
int	_dl_getcwd(char *, size_t);
ssize_t	_dl_getdents(int, char *, size_t);
int	_dl_issetugid(void);
int	_dl_getthrid(void);
void *	_dl_mmap(void *, size_t, int, int, int, off_t);
int	_dl_mprotect(const void *, size_t, int);
int	_dl_munmap(const void *, size_t);
int	_dl_open(const char *, int);
ssize_t	_dl_read(int, const char *, size_t);
ssize_t	_dl_readlink(const char *, char *, size_t);
int	_dl_pledge(const char *, const char **);
long	_dl__syscall(quad_t, ...);
int	_dl_sysctl(const int *, u_int, void *, size_t *, void *, size_t);
int	_dl_utrace(const char *, const void *, size_t);
ssize_t	_dl_write(int, const char *, size_t);
int	_dl_getentropy(char *, size_t);
int	_dl_sendsyslog(const char *, size_t, int);
__dead
void	_dl_thrkill(pid_t, int, void *);

#endif /*__DL_SYSCALL_H__*/
@


1.43
log
@ld.so doesn't need gettimeofday or lstat stubs any more

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.42 2016/07/04 21:15:07 guenther Exp $ */
d61 2
@


1.42
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.41 2016/05/07 19:05:23 guenther Exp $ */
a45 1
int	_dl_gettimeofday(struct timeval *, struct timezone *);
a47 1
int	_dl_lstat(const char *, struct stat *);
@


1.41
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.40 2016/03/21 22:41:29 bluhm Exp $ */
a62 6

static inline off_t
_dl_lseek(int fildes, off_t offset, int whence)
{
	return _dl__syscall((quad_t)SYS_lseek, fildes, 0, offset, whence);
}
@


1.40
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.39 2016/03/21 01:32:49 guenther Exp $ */
d48 1
@


1.39
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.38 2015/11/15 03:41:24 deraadt Exp $ */
d61 1
a61 1
int	_dl_sendsyslog2(const char *, size_t, int);
@


1.38
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.37 2015/09/19 20:56:47 guenther Exp $ */
d61 1
a61 1
int	_dl_sendsyslog(const char *, size_t);
@


1.37
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.36 2014/09/01 05:09:53 doug Exp $ */
d55 1
@


1.36
log
@Sync readlink(2) with IEEE Std 1003.1-2008.

discussion, help and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.35 2014/07/14 03:54:51 deraadt Exp $ */
a31 1

a32 2
#include <sys/signal.h>
#include <sys/time.h>
a54 1
int	_dl_sigprocmask(int, const sigset_t *, sigset_t *);
@


1.35
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.34 2014/07/09 12:51:21 guenther Exp $ */
d57 1
a57 1
int	_dl_readlink(const char *, char *, size_t);
@


1.34
log
@_dl_fcntl() is no longer used; kill the stubs

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.33 2014/07/06 07:28:36 otto Exp $ */
a48 1
int	_dl_getentropy(char *, size_t);
d63 2
@


1.33
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.32 2014/07/05 21:54:51 miod Exp $ */
a45 1
int	_dl_fcntl(int, int, int);
@


1.32
log
@Mark _dl_exit __dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.31 2014/07/05 20:41:25 miod Exp $ */
d50 1
@


1.31
log
@Implement _dl_mmap as direct mmap(2) wrapper, without needing to use
__syscall(2) - calling convention will conveniently provide the padding
argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.30 2014/07/05 17:06:18 miod Exp $ */
d44 1
@


1.30
log
@Add more sugar to build syscall stubs, and turn them from inlines to real
entry points; also, make sure syscall failures return -errno rather than -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.29 2013/08/13 22:33:04 miod Exp $ */
a36 2
static off_t	_dl_lseek(int, off_t, int);

d52 1
a67 7
}

static inline void *
_dl_mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
{
	return((void *)_dl__syscall((quad_t)SYS_mmap, addr, len, prot,
	    flags, fd, 0, offset));
@


1.29
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.28 2013/08/13 05:52:20 guenther Exp $ */
a36 1

d45 19
a63 4
/*
 *  Inlined system call functions that can be used before
 *  any dynamic address resolving has been done.
 */
d65 2
a66 2
static inline void
_dl_exit(int status)
d68 1
a68 49
	register int __status;

	__asm__ volatile ("li  0,%1\n\t"
	    "mr  3,%2\n\t"
	    "sc"
	    : "=r" (__status)
	    : "I" (SYS_exit), "r" (status) : "0", "3");

	while (1)
		;
}

static inline int
_dl_open(const char* addr, int flags)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_open), "r" (addr), "r" (flags)
	    : "memory", "0", "3", "4" );
	return status;
}

static inline int
_dl_close(int fd)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_close), "r" (fd)
	    : "0", "3");
	return status;
a70 46
static inline ssize_t
_dl_write(int fd, const char* buf, size_t len)
{
	register ssize_t status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_write), "r" (fd), "r" (buf), "r" (len)
	    : "memory", "0", "3", "4", "5" );
	return status;
}

static inline ssize_t
_dl_read(int fd, const char* buf, size_t len)
{
	register ssize_t status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_read), "r" (fd), "r" (buf), "r" (len)
	    : "memory", "0", "3", "4", "5");
	return status;
}

#define STRINGIFY(x)  #x
#define XSTRINGIFY(x) STRINGIFY(x)
long _dl__syscall(quad_t val, ...);

a77 280
static inline int
_dl_munmap(const void* addr, size_t len)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_munmap), "r" (addr), "r" (len)
	    : "memory", "0", "3", "4");
	return status;
}

static inline int
_dl_mprotect(const void *addr, size_t size, int prot)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
	    : "memory", "0", "3", "4", "5");
	return status;
}

static inline int
_dl_fstat(int fd, struct stat *sb)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_fstat), "r" (fd), "r" (sb)
	    : "memory", "0", "3", "4");
	return status;
}

static inline int
_dl_fcntl(int fd, int cmd, int flag)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    : "=r" (status)
	    : "I" (SYS_fcntl), "r" (fd), "r" (cmd), "r"(flag)
	    : "memory", "0", "3", "4", "5");
	return status;
}

static inline ssize_t
_dl_getdents(int fd, char *buf, size_t nbytes)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_getdents), "r" (fd), "r" (buf), "r" (nbytes)
	    : "memory", "0", "3", "4", "5", "6");
	return status;
}

static inline int
_dl_issetugid(void)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_issetugid)
	    : "0", "3");
	return status;
}

static inline off_t
_dl_lseek(int fildes, off_t offset, int whence)
{
	return _dl__syscall((quad_t)SYS_lseek, fildes, 0, offset, whence);
}

static inline int
_dl_sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
	sigset_t sig_store;
	sigset_t sig_store1;

	if (set != NULL) {
		sig_store1 = *set;
	} else {
		sig_store1 = 0;
	}

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "mr    %0, 3"
	    : "=r" (sig_store)
	    : "I" (SYS_sigprocmask), "r" (how), "r" (sig_store1)
	    : "memory", "0", "3", "4");
	if (oset != NULL)
		*oset = sig_store;

	return 0;
}

static inline int
_dl_sysctl(const int *name, u_int namelen, void *oldp, size_t *oldplen,
    void *newp, size_t newlen)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "mr    6,%5\n\t"
	    "mr    7,%6\n\t"
	    "mr    8,%7\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS___sysctl), "r" (name), "r" (namelen), "r" (oldp),
	    "r" (oldplen), "r" (newp), "r" (newlen)
	    : "memory", "0", "3", "4", "5", "6", "7", "8");
	return status;
}

static inline int
_dl_gettimeofday(struct timeval *tp, struct timezone *tzp)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_gettimeofday), "r" (tp), "r" (tzp)
	    : "memory", "0", "3", "4" );
	return status;
}

static inline int
_dl_readlink(const char *path, char *buf, size_t bufsiz)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_readlink), "r" (path), "r" (buf), "r" (bufsiz)
	    : "memory", "0", "3", "4", "5");
	return status;
}

static inline int
_dl_lstat(const char *path, struct stat *sb)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_lstat), "r" (path), "r" (sb)
	    : "memory", "0", "3", "4" );
	return status;
}

static inline int
_dl_getcwd(char *buf, size_t size)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS___getcwd), "r" (buf), "r" (size)
	    : "0", "3", "4");
	return status;
}

static inline int
_dl_utrace(const char *label, const void *addr, size_t len)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "mr    5,%4\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_utrace), "r" (label), "r" (addr), "r" (len)
	    : "memory", "0", "3", "4", "5");
	return status;
}

a78 1

@


1.28
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.27 2013/06/09 13:10:19 miod Exp $ */
d255 1
a255 1
	    : "I" (SYS_getdents), "r" (fd), "r" (buf), "r" (nbytes),
@


1.27
log
@Constify the mib argument of sysctl().
ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.26 2013/06/01 09:57:58 miod Exp $ */
d239 2
a240 2
static inline int
_dl_getdirentries(int fd, char *buf, int nbytes, off_t *basep)
a247 1
	    "mr    6,%5\n\t"
d255 1
a255 2
	    : "I" (SYS_getdirentries), "r" (fd), "r" (buf), "r"(nbytes),
	    "r" (basep)
@


1.26
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.25 2013/04/05 12:58:03 kurt Exp $ */
d313 2
a314 2
_dl_sysctl(int *name, u_int namelen, void *oldp, size_t *oldplen, void *newp,
    size_t newlen)
@


1.25
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.24 2012/10/24 03:26:56 guenther Exp $ */
d416 21
@


1.24
log
@Garbage-collect the _dl_stat() routine, now unused

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.23 2012/08/17 14:32:46 matthew Exp $ */
d311 1
d337 1
d358 60
@


1.23
log
@Fix mips64 and powerpc's ld.so syscall implementations by adding
"memory" to the list of clobbered registers for all syscalls that
accept a pointer.  This prevents GCC from optimizing away memory loads
and stores that otherwise appear unused in a function.

Issue noted and identified by miod; fix by me.
ok miod, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.22 2010/10/28 15:02:41 millert Exp $ */
a195 20
	return status;
}

static inline int
_dl_stat(const char *addr, struct stat *sb)
{
	register int status;

	__asm__ volatile ("li    0,%1\n\t"
	    "mr    3,%2\n\t"
	    "mr    4,%3\n\t"
	    "sc\n\t"
	    "cmpwi   0, 0\n\t"
	    "beq   1f\n\t"
	    "li    3,-1\n\t"
	    "1:"
	    "mr   %0,3\n\t"
	    : "=r" (status)
	    : "I" (SYS_stat), "r" (addr), "r" (sb)
	    : "memory", "0", "3", "4");
@


1.22
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.21 2008/10/02 20:12:08 kurt Exp $ */
d82 1
a82 1
	    : "0", "3", "4" );
d122 1
a122 1
	    : "0", "3", "4", "5" );
d143 1
a143 1
	    : "0", "3", "4", "5");
d174 1
a174 1
	    : "0", "3", "4");
d195 1
a195 1
	    : "0", "3", "4", "5");
d215 1
a215 1
	    : "0", "3", "4");
d235 1
a235 1
	    : "0", "3", "4");
d255 1
a255 1
	    : "0", "3", "4", "5");
d278 1
a278 1
	    : "0", "3", "4", "5", "6");
d325 1
a325 1
	    : "0", "3", "4");
d353 1
a353 1
	    : "0", "3", "4", "5", "6", "7", "8");
d372 1
a372 1
	    : "0", "3", "4" );
@


1.21
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.20 2006/05/03 16:10:52 drahn Exp $ */
d260 1
a260 1
_dl_getdirentries(int fd, char *buf, int nbytes, long *basep)
@


1.20
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.19 2004/01/12 02:21:21 drahn Exp $ */
d41 1
a41 1
#define _dl_MAX_ERRNO 4096
d43 2
a44 2
#define _dl_check_error(__res) \
	((int) __res < 0 && (int) __res >= -_dl_MAX_ERRNO)
@


1.19
log
@GCC3 compatible asm code. tested on gcc2 myself. ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.18 2003/12/03 17:00:15 drahn Exp $ */
d35 1
d356 20
d378 1
@


1.18
log
@Move the asm definition of _dl__syscall from a header file into a .c file
so that 12 copies of it are not generated.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.17 2003/07/06 20:04:00 deraadt Exp $ */
d50 1
a50 1
static inline int
d53 1
a53 1
	register int __status __asm__ ("3");
d55 1
a55 1
	__asm__ volatile ("mr  0,%1\n\t"
d59 1
a59 1
	    : "r" (SYS_exit), "r" (status) : "0", "3");
d68 1
a68 1
	register int status __asm__ ("3");
d70 1
a70 1
	__asm__ volatile ("mr    0,%1\n\t"
d78 1
d80 1
a80 1
	    : "r" (SYS_open), "r" (addr), "r" (flags)
d88 1
a88 1
	register int status __asm__ ("3");
d90 1
a90 1
	__asm__ volatile ("mr    0,%1\n\t"
d97 1
d99 1
a99 1
	    : "r" (SYS_close), "r" (fd)
d107 1
a107 1
	register ssize_t status __asm__ ("3");
d109 1
a109 1
	__asm__ volatile ("mr    0,%1\n\t"
d118 1
d120 1
a120 1
	    : "r" (SYS_write), "r" (fd), "r" (buf), "r" (len)
d128 1
a128 1
	register ssize_t status __asm__ ("3");
d130 1
a130 1
	__asm__ volatile ("mr    0,%1\n\t"
d139 1
d141 1
a141 1
	    : "r" (SYS_read), "r" (fd), "r" (buf), "r" (len)
d160 1
a160 1
	register int status __asm__ ("3");
d162 1
a162 1
	__asm__ volatile ("mr    0,%1\n\t"
d170 1
d172 1
a172 1
	    : "r" (SYS_munmap), "r" (addr), "r" (len)
d180 1
a180 1
	register int status __asm__ ("3");
d182 1
a182 1
	__asm__ volatile ("mr    0,%1\n\t"
d191 1
d193 1
a193 1
	    : "r" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
d201 1
a201 1
	register int status __asm__ ("3");
d203 1
a203 1
	__asm__ volatile ("mr    0,%1\n\t"
d211 1
d213 1
a213 1
	    : "r" (SYS_stat), "r" (addr), "r" (sb)
d221 1
a221 1
	register int status __asm__ ("3");
d223 1
a223 1
	__asm__ volatile ("mr    0,%1\n\t"
d231 1
d233 1
a233 1
	    : "r" (SYS_fstat), "r" (fd), "r" (sb)
d241 1
a241 1
	register int status __asm__ ("3");
d243 1
a243 1
	__asm__ volatile ("mr    0,%1\n\t"
d253 1
a253 1
	    : "r" (SYS_fcntl), "r" (fd), "r" (cmd), "r"(flag)
d261 1
a261 1
	register int status __asm__ ("3");
d263 1
a263 1
	__asm__ volatile ("mr    0,%1\n\t"
d273 1
d275 1
a275 1
	    : "r" (SYS_getdirentries), "r" (fd), "r" (buf), "r"(nbytes),
d284 1
a284 1
	register int status __asm__ ("3");
d286 1
a286 1
	__asm__ volatile ("mr    0,%1\n\t"
d292 1
d294 1
a294 1
	    : "r" (SYS_issetugid)
d334 1
a334 1
	register int status __asm__ ("3");
d336 1
a336 1
	__asm__ volatile ("mr    0,%1\n\t"
d348 1
d350 1
a350 1
	    : "r" (SYS___sysctl), "r" (name), "r" (namelen), "r" (oldp),
@


1.17
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.16 2003/06/09 16:10:04 deraadt Exp $ */
a144 10
__asm__(".align 2\n\t"
	".type _dl__syscall,@@function\n"
	"_dl__syscall:\n\t"
	"li 0, " XSTRINGIFY(SYS___syscall) "\n\t"
	"sc\n\t"
	"cmpwi	0, 0\n\t"
	"beq	1f\n\t"
	"li	3, -1\n\t"
	"1:\n\t"
	"blr");
@


1.16
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.15 2003/05/30 01:13:53 drahn Exp $ */
d51 1
a51 1
_dl_exit (int status)
d66 1
a66 1
_dl_open (const char* addr, int flags)
d85 1
a85 1
_dl_close (int fd)
d103 1
a103 1
_dl_write (int fd, const char* buf, size_t len)
d123 1
a123 1
_dl_read (int fd, const char* buf, size_t len)
d157 1
a157 1
_dl_mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)
d164 1
a164 1
_dl_munmap (const void* addr, size_t len)
d183 1
a183 1
_dl_mprotect (const void *addr, size_t size, int prot)
d203 1
a203 1
_dl_stat (const char *addr, struct stat *sb)
d222 1
a222 1
_dl_fstat (int fd, struct stat *sb)
d241 1
a241 1
_dl_fcntl (int fd, int cmd, int flag)
d283 1
a283 1
_dl_issetugid()
d306 1
a306 1
_dl_sigprocmask (int how, const sigset_t *set, sigset_t *oset)
d310 1
a352 1
	
@


1.15
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.14 2002/12/18 19:20:02 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.14
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.13 2002/07/24 04:11:10 deraadt Exp $ */
d335 26
@


1.13
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.11 2002/07/24 01:05:11 deraadt Exp $ */
d40 1
d309 25
@


1.12
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.9 2002/07/12 20:18:30 drahn Exp $ */
d71 1
a71 1
_dl_open (const char* addr, unsigned int flags)
d107 2
a108 2
static inline int
_dl_write (int fd, const char* buf, int len)
d110 1
a110 1
	register int status __asm__ ("3");
d127 2
a128 2
static inline int
_dl_read (int fd, const char* buf, int len)
d130 1
a130 1
	register int status __asm__ ("3");
d161 2
a162 3
static inline int
_dl_mmap (void *addr, unsigned int len, unsigned int prot,
    unsigned int flags, int fd, off_t offset)
d164 1
a164 1
	return((int)_dl__syscall((quad_t)SYS_mmap, addr, len, prot,
d169 1
a169 1
_dl_munmap (const void* addr, unsigned int len)
d188 1
a188 1
_dl_mprotect (const void *addr, int size, int prot)
d282 1
a282 1
	        "r" (basep)
d307 1
a307 1
        return _dl__syscall((quad_t)SYS_lseek, fildes, 0, offset, whence);
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.10 2002/07/23 23:56:31 mickey Exp $ */
d71 1
a71 1
_dl_open (const char* addr, int flags)
d107 2
a108 2
static inline ssize_t
_dl_write (int fd, const char* buf, size_t len)
d110 1
a110 1
	register ssize_t status __asm__ ("3");
d127 2
a128 2
static inline ssize_t
_dl_read (int fd, const char* buf, size_t len)
d130 1
a130 1
	register ssize_t status __asm__ ("3");
d161 3
a163 2
static inline void *
_dl_mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)
d165 1
a165 1
	return((void *)_dl__syscall((quad_t)SYS_mmap, addr, len, prot,
d170 1
a170 1
_dl_munmap (const void* addr, size_t len)
d189 1
a189 1
_dl_mprotect (const void *addr, size_t size, int prot)
d283 1
a283 1
	    "r" (basep)
d308 1
a308 1
	return _dl__syscall((quad_t)SYS_lseek, fildes, 0, offset, whence);
@


1.10
log
@match _dl_ syscall prototypes w/ the real syscalls prototypes, including args and return values; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.9 2002/07/12 20:18:30 drahn Exp $ */
d282 1
a282 1
	        "r" (basep)
d307 1
a307 1
        return _dl__syscall((quad_t)SYS_lseek, fildes, 0, offset, whence);
@


1.9
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.8 2002/07/07 08:54:50 jufi Exp $ */
d71 1
a71 1
_dl_open (const char* addr, unsigned int flags)
d107 2
a108 2
static inline int
_dl_write (int fd, const char* buf, int len)
d110 1
a110 1
	register int status __asm__ ("3");
d127 2
a128 2
static inline int
_dl_read (int fd, const char* buf, int len)
d130 1
a130 1
	register int status __asm__ ("3");
d161 2
a162 3
static inline int
_dl_mmap (void *addr, unsigned int len, unsigned int prot,
    unsigned int flags, int fd, off_t offset)
d164 1
a164 1
	return((int)_dl__syscall((quad_t)SYS_mmap, addr, len, prot,
d169 1
a169 1
_dl_munmap (const void* addr, unsigned int len)
d188 1
a188 1
_dl_mprotect (const void *addr, int size, int prot)
@


1.8
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.7 2002/05/24 04:17:01 deraadt Exp $ */
a36 1
#ifdef USE_CACHE
a37 1
#endif
d41 3
d149 1
a149 1
int _dl__syscall(quad_t val, ...);
d161 1
a161 1
static int
a207 1
#ifdef USE_CACHE
d227 60
a286 1
#endif
d304 6
a309 1
#include <elf_abi.h>
@


1.7
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.6 2002/05/24 03:44:38 deraadt Exp $ */
d51 1
a51 1
 *  any dynamic address resoving has been done.
@


1.6
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.5 2002/03/17 00:22:04 art Exp $ */
d46 2
a47 2
#define _dl_check_error(__res)	\
  ((int) __res < 0 && (int) __res >= -_dl_MAX_ERRNO)
d57 10
a66 8
  register int __status __asm__ ("3");
  __asm__ volatile ("mr  0,%1\n\t"
		    "mr  3,%2\n\t"
                    "sc"
                    : "=r" (__status)
                    : "r" (SYS_exit), "r" (status) : "0", "3");
  while (1)
	;
d72 14
a85 13
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_open), "r" (addr), "r" (flags)
                    : "0", "3", "4" );
  return status;
d91 13
a103 12
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_close), "r" (fd)
                    : "0", "3");
  return status;
d109 15
a123 14
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "mr    5,%4\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_write), "r" (fd), "r" (buf), "r" (len)
                    : "0", "3", "4", "5" );
  return status;
d129 15
a143 14
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "mr    5,%4\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_read), "r" (fd), "r" (buf), "r" (len)
                    : "0", "3", "4", "5");
  return status;
d162 1
a162 1
          unsigned int flags, int fd, off_t offset)
d165 1
a165 1
		flags, fd, 0, offset));
d171 14
a184 13
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_munmap), "r" (addr), "r" (len)
                    : "0", "3", "4");
  return status;
d190 15
a204 14
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "mr    5,%4\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_mprotect), "r" (addr), "r" (size), "r" (prot)
                    : "0", "3", "4", "5");
  return status;
d211 14
a224 13
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "mr    3,%2\n\t"
                    "mr    4,%3\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_stat), "r" (addr), "r" (sb)
                    : "0", "3", "4");
  return status;
d232 12
a243 11
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_issetugid)
                    : "0", "3");
  return status;
@


1.5
log
@Clean up the zapping of bad variables. Instead of implementing
_dl_suid_ok, just use the issetugid syscall.
ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.4 2002/02/21 23:17:53 drahn Exp $ */
d5 1
a5 1
 * 
d56 1
a56 1
{ 
d63 3
a65 2
  while(1);
} 
d69 1
a69 1
{ 
d83 1
a83 1
} 
d87 1
a87 1
{ 
d100 1
a100 1
} 
d104 1
a104 1
{ 
d119 1
a119 1
} 
d123 1
a123 1
{ 
d138 1
a138 1
} 
d157 1
a157 1
{ 
d164 1
a164 1
{ 
d178 1
a178 1
} 
d182 1
a182 1
{ 
d197 1
a197 1
} 
d202 1
a202 1
{ 
d216 1
a216 1
} 
d222 1
a222 1
{ 
d234 1
a234 1
} 
@


1.4
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.3 2000/10/01 00:51:20 rahnds Exp $ */
a218 18
/* Not an actual syscall, but we need something in assembly to say
   whether this is OK or not.  */

static inline int
_dl_getuid ()
{ 
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_getuid)
                    : "0", "3");
  return status;
} 
d220 1
a220 1
_dl_geteuid ()
d230 1
a230 1
                    : "r" (SYS_geteuid)
a233 42
static inline int
_dl_getgid ()
{ 
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_getgid)
                    : "0", "3");
  return status;
} 
static inline int
_dl_getegid ()
{ 
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_getgid)
                    : "0", "3");
  return status;
} 
static inline int
_dl_suid_ok (void)
{
  unsigned int uid, euid, gid, egid;

	uid = _dl_getuid();
	euid = _dl_geteuid();
	gid = _dl_getgid();
	egid = _dl_getegid();
  	return (uid == euid && gid == egid);
}

@


1.3
log
@Fix some very serious cut and paste errors in this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.2 2000/08/25 03:36:38 rahnds Exp $ */
d34 2
a53 2
void _dl_printf(const char *, ...);

d295 1
@


1.2
log
@Cleanup of powerpc ld.so files.
instead of #if 0, make them potentially useful -> LD_PRINTF_DEBUG
Deal with _dl_suid_ok correctly, this is not something that should
be hardcoded. - pointed out a few weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.h,v 1.1.1.1 2000/06/13 03:40:39 rahnds Exp $ */
d174 1
a174 1
                    : "r" (SYS_read), "r" (addr), "r" (len)
d193 1
a193 1
                    : "r" (SYS_read), "r" (addr), "r" (size), "r" (prot)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a137 18
#if 0
static inline int
_dl__syscall(quad_t val, ...)
{
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
		    "mr	   3,%2\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS___syscall), "r" (val)
                    : "0");
	
}
#else
d152 1
a152 1
#endif
a196 1
#if 0
d212 1
a212 1
                    : "r" (SYS_read), "r" (addr), "r" (sb)
d223 1
a223 1
_dl_getuid (const void *addr, int size, int prot)
d238 1
a238 1
_dl_geteuid (const void *addr, int size, int prot)
d253 1
a253 1
_dl_getgid (const void *addr, int size, int prot)
d268 1
a268 1
_dl_getuid (const void *addr, int size, int prot)
d278 1
a278 16
                    : "r" (SYS_getegid),
                    : "0", "3");
  return status;
} 
static inline int
_dl_getuid (const void *addr, int size, int prot)
{ 
  register int status __asm__ ("3");
  __asm__ volatile ("mr    0,%1\n\t"
                    "sc\n\t"
		    "cmpwi   0, 0\n\t"
		    "beq   1f\n\t"
		    "li    3,-1\n\t"
		    "1:"
                    : "=r" (status)
                    : "r" (SYS_read), 
a291 6
}
#endif
static inline int
_dl_suid_ok(void)
{
	return 1;
@


1.1.1.1
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems 
such as correctness and security.

@
text
@@
