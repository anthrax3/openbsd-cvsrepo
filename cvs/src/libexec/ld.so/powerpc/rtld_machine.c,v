head	1.62;
access;
symbols
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.59.0.2
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.6
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.48.0.8
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.4
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.45.0.6
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.8
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.4
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.35.0.6
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	r20000612:1.1.1.1
	dsr:1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2017.01.24.10.59.10;	author guenther;	state Exp;
branches;
next	1.61;
commitid	YxIOY4o1CZ7Ajqca;

1.61
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.60;
commitid	veGB6uLWx3BTEAfk;

1.60
date	2017.01.23.10.30.58;	author guenther;	state Exp;
branches;
next	1.59;
commitid	gelJDihLmdyfb63O;

1.59
date	2016.06.21.15.25.37;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	lRIiUPnkIQNjSTol;

1.58
date	2016.06.13.04.59.56;	author guenther;	state Exp;
branches;
next	1.57;
commitid	Wg8GqaAjGMMGLcBt;

1.57
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.56;
commitid	Kpc3J4Ry51yjfQid;

1.56
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.55;
commitid	zGFWeGZdYJxUOZli;

1.55
date	2015.08.25.08.01.12;	author guenther;	state Exp;
branches;
next	1.54;
commitid	M0bGpiGTwjhIbKC7;

1.54
date	2015.08.23.15.28.41;	author kettenis;	state Exp;
branches;
next	1.53;
commitid	tP0VrypBkE7jLg1S;

1.53
date	2014.11.24.05.50.08;	author miod;	state Exp;
branches;
next	1.52;
commitid	x2cF47Kp82GJrgZz;

1.52
date	2014.07.05.17.06.18;	author miod;	state Exp;
branches;
next	1.51;
commitid	jSLj33X9mOpIw96Z;

1.51
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.03.04.03.03;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.08.20.37.01;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.02.20.17.21;	author kurt;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.22.13.59.47;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.21.23.12.11;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.16.23.19.42;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.25.21.42.48;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.03.17.00.15;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.04.19.37.07;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.04.19.33.49;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.02.15.17.52;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.19.04.15.54;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.28.03.11.00;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.09.16.10.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.10.03.57.57;	author david;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.15.22.39.13;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.15.00.30.16;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.30.06.40.38;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.24.00.43.29;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.22.22.21.23;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.05.16.53.19;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.09.19.06.18;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.05.23.13.55;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.05.19.34.44;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.24.04.21.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.24.04.17.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.24.03.44.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.05.15.31.35;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.30.01.35.21;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.06.17.39.30;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.25.03.36.38;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.40.38;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.40.38;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.62
log
@For consistentcy, use 'void *' with %p instead of 'char *'
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.61 2017/01/24 07:48:37 guenther Exp $ */

/*
 * Copyright (c) 1999 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

#define	DT_PROC(n)	((n) - DT_LOPROC + DT_NUM)

void _dl_syncicache(char *from, size_t len);

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

/* relocation bits */
#define HA(x) (((Elf_Addr)(x) >> 16) + (((Elf_Addr)(x) & 0x00008000) >> 15))
#define L(x) (((Elf_Addr)x) & 0x0000ffff)
#define ADDIS_R11_R11	0x3d6b0000
#define ADDIS_R11_R0	0x3d600000
#define ADDI_R11_R11	0x396b0000
#define LWZ_R11_R11	0x816b0000
#define LI_R11		0x39600000

#define ADDIS_R12_R0	0x3d800000
#define ADDI_R12_R12	0x398c0000
#define MCTR_R11	0x7d6903a6
#define MCTR_R12	0x7d8903a6
#define BCTR		0x4e800420
#define BRVAL(from, to)					\
	((((Elf32_Addr)(to) - (Elf32_Addr)(&(from)))	\
	    & ~0xfc000000) | 0x48000000)
#define BR(from, to)	((from) = BRVAL(from, to))


#define SLWI_R12_R11_1	0x556c083c
#define ADD_R11_R12_R11 0x7d6c5a14

/* these are structures/functions offset from PLT region */
#define PLT_CALL_OFFSET		8
#define PLT_INFO_OFFSET		12
#define PLT_1STRELA_OFFSET	18
#define B24_VALID_RANGE(x) \
    ((((x) & 0xfe000000) == 0x00000000) || (((x) &  0xfe000000) == 0xfe000000))

void _dl_bind_start(void); /* XXX */
Elf_Addr _dl_bind(elf_object_t *object, int reloff);

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	int	i;
	int	numrela;
	long	relrel;
	int	fails = 0;
	struct load_list *llist;
	Elf32_Addr loff;
	Elf32_Rela  *relas;
	/* for jmp table relocations */
	Elf32_Addr *pltresolve;
	Elf32_Addr *pltcall;
	Elf32_Addr *plttable;
	Elf32_Addr *pltinfo;
	Elf32_Addr *first_rela;
	Elf32_Addr prev_value = 0, prev_ooff = 0;
	const Elf32_Sym *prev_sym = NULL;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf32_Rela);
	relrel = rel == DT_RELA ? object->relacount : 0;
	relas = (Elf32_Rela *)(object->Dyn.info[rel]);

#ifdef DL_PRINTF_DEBUG
_dl_printf("object relocation size %x, numrela %x\n",
	object->Dyn.info[relasz], numrela);
#endif

	if (relas == NULL)
		return(0);

	if (relrel > numrela)
		_dl_die("relcount > numrel: %ld > %d", relrel, numrela);

	pltresolve = NULL;
	pltcall = NULL;
	plttable = NULL;

	/* for plt relocation usage */
	if (object->Dyn.info[DT_JMPREL] != 0 &&
	    object->Dyn.info[DT_PROC(DT_PPC_GOT)] == 0) {
		/* resolver stub not set up */
		int nplt;

		/* Need to construct table to do jumps */
		pltresolve = (Elf32_Addr *)(object->Dyn.info[DT_PLTGOT]);
		pltcall = (Elf32_Addr *)(pltresolve) + PLT_CALL_OFFSET;
		pltinfo = (Elf32_Addr *)(pltresolve) + PLT_INFO_OFFSET;
		first_rela =  (Elf32_Addr *)(pltresolve) + PLT_1STRELA_OFFSET;

		nplt = object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf32_Rela);

		if (nplt >= (2<<12)) {
			plttable = (Elf32_Addr *) ((Elf32_Addr)first_rela)
			    + (2 * (2<<12)) + (4 * (nplt - (2<<12)));
		} else {
			plttable = (Elf32_Addr *) ((Elf32_Addr)first_rela)
			    + (2 * nplt);
		}

		pltinfo[0] = (Elf32_Addr)plttable;

#ifdef DL_PRINTF_DEBUG
		_dl_printf("md_reloc:  plttbl size %x\n",
		    (object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf32_Rela)));
		_dl_printf("md_reloc: plttable %x\n", plttable);
#endif
		pltresolve[0] = SLWI_R12_R11_1;
		pltresolve[1] = ADD_R11_R12_R11;
		pltresolve[2] = ADDIS_R12_R0 | HA(_dl_bind_start);
		pltresolve[3] = ADDI_R12_R12 | L(_dl_bind_start);
		pltresolve[4] = MCTR_R12;
		pltresolve[5] = ADDIS_R12_R0 | HA(object);
		pltresolve[6] = ADDI_R12_R12 | L(object);
		pltresolve[7] = BCTR;
		_dl_dcbf(&pltresolve[0]);
		_dl_dcbf(&pltresolve[7]);

		/* addis r11,r11,.PLTtable@@ha*/
		pltcall[0] = ADDIS_R11_R11 | HA(plttable);
		/* lwz r11,plttable@@l(r11) */
		pltcall[1] = LWZ_R11_R11 | L(plttable);
		pltcall[2] = MCTR_R11;	/* mtctr r11 */
		pltcall[3] = BCTR;	/* bctr */
		_dl_dcbf(&pltcall[0]);
		_dl_dcbf(&pltcall[3]);
	} else {
		first_rela = NULL;
	}

	/*
	 * Change protection of all write protected segments in the object
	 * so we can do relocations such as REL24, REL16 etc. After
	 * relocation restore protection.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE)) {
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
			}
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, relas++) {
		Elf_Addr *r_addr;
#ifdef DEBUG
		const Elf32_Sym *sym;

		if (ELF32_R_TYPE(relas->r_info) != RELOC_RELATIVE)
			_dl_die("RELCOUNT wrong");
		sym = object->dyn.symtab;
		sym += ELF32_R_SYM(relas->r_info);
		if (ELF32_ST_BIND(sym->st_info) != STB_LOCAL ||
		    (ELF32_ST_TYPE(sym->st_info) != STT_SECTION &&
		    ELF32_ST_TYPE(sym->st_info) != STT_NOTYPE))
			_dl_die("RELATIVE relocation against symbol");
#endif
		r_addr = (Elf_Addr *)(relas->r_offset + loff);
		*r_addr = loff + relas->r_addend;
	}
	for (; i < numrela; i++, relas++) {
		Elf32_Addr *r_addr = (Elf32_Addr *)(relas->r_offset + loff);
		Elf32_Addr ooff;
		const Elf32_Sym *sym, *this;
		const char *symn;
		int type;

		if (ELF32_R_SYM(relas->r_info) == 0xffffff)
			continue;

		type = ELF32_R_TYPE(relas->r_info);

		if (type == RELOC_JMP_SLOT && rel != DT_JMPREL)
			continue;

		sym = object->dyn.symtab;
		sym += ELF32_R_SYM(relas->r_info);
		symn = object->dyn.strtab + sym->st_name;

		ooff = 0;
		this = NULL;
		if (ELF32_R_SYM(relas->r_info) &&
		    !(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
		    ELF32_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
			if (sym == prev_sym) {
				this = sym;	/* XXX any non-NULL */
				ooff = prev_ooff;
			} else {
				ooff = _dl_find_symbol_bysym(object,
				    ELF32_R_SYM(relas->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == RELOC_JMP_SLOT) ?
				    SYM_PLT:SYM_NOTPLT), sym, NULL);

				if (this == NULL) {
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = this->st_value;
				prev_ooff = ooff;
			}
		}

		/*
		 * For Secure-PLT, RELOC_JMP_SLOT simply sets PLT
		 * slots similarly to how RELOC_GLOB_DAT updates GOT
		 * slots.
		 */
		if (type == RELOC_JMP_SLOT &&
		    object->Dyn.info[DT_PROC(DT_PPC_GOT)])
			type = RELOC_GLOB_DAT;

		switch (type) {
		case RELOC_32:
			if (ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
			    (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
				*r_addr = ooff + relas->r_addend;
			} else {
				*r_addr = ooff + prev_value +
				    relas->r_addend;
			}
			break;
		case RELOC_RELATIVE:
			if (ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
			    (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
				*r_addr = loff + relas->r_addend;

#ifdef DL_PRINTF_DEBUG
_dl_printf("rel1 r_addr %x val %x loff %x ooff %x addend %x\n", r_addr,
    loff + relas->r_addend, loff, ooff, relas->r_addend);
#endif

			} else {
				*r_addr = loff + prev_value +
				    relas->r_addend;
			}
			break;
		case RELOC_JMP_SLOT:
		    {
			Elf32_Addr target = ooff + prev_value +
			    relas->r_addend;
			Elf32_Addr val = target - (Elf32_Addr)r_addr;

			if (!B24_VALID_RANGE(val)){
				int index;
#ifdef DL_PRINTF_DEBUG
_dl_printf(" ooff %x, sym val %x, addend %x"
	" r_addr %x symn [%s] -> %x\n",
	ooff, prev_value, relas->r_addend,
	r_addr, symn, val);
#endif
				/* if offset is > RELOC_24 deal with it */
				index = (r_addr - first_rela) >> 1;

				if (index >= (2 << 12)) {
					/* addis r11,r11,.PLTtable@@ha*/
					r_addr[0] = ADDIS_R11_R0 | HA(index*4);
					r_addr[1] = ADDI_R11_R11 | L(index*4);
					BR(r_addr[2], pltcall);
				} else {
					r_addr[0] = LI_R11 | (index * 4);
					BR(r_addr[1], pltcall);

				}
				_dl_dcbf(&r_addr[0]);
				_dl_dcbf(&r_addr[2]);
				val= ooff + prev_value +
				    relas->r_addend;
#ifdef DL_PRINTF_DEBUG
_dl_printf(" symn [%s] val 0x%x\n", symn, val);
#endif
				plttable[index] = val;
			} else {
				/* if the offset is small enough,
				 * branch directly to the dest
				 */
				BR(r_addr[0], target);
				_dl_dcbf(&r_addr[0]);
			}
		    }

			break;
		case RELOC_GLOB_DAT:
			*r_addr = ooff + prev_value + relas->r_addend;
			break;
#if 1
		/* should not be supported ??? */
		case RELOC_REL24:
		    {
			Elf32_Addr val = ooff + prev_value +
			    relas->r_addend - (Elf32_Addr)r_addr;
			if (!B24_VALID_RANGE(val)) {
				/* invalid offset */
				_dl_die("%s: invalid %s offset %x at %p",
				    object->load_name, "REL24", val,
				    (void *)r_addr);
			}
			val &= ~0xfc000003;
			val |= (*r_addr & 0xfc000003);
			*r_addr = val;

			_dl_dcbf(r_addr);
		    }
		break;
#endif
#if 1
		case RELOC_16_LO:
		    {
			Elf32_Addr val;

			val = loff + relas->r_addend;
			*(Elf32_Half *)r_addr = val;

			_dl_dcbf(r_addr);
		    }
		break;
#endif
#if 1
		case RELOC_16_HI:
		    {
			Elf32_Addr val;

			val = loff + relas->r_addend;
			*(Elf32_Half *)r_addr = (val >> 16);

			_dl_dcbf(r_addr);
		    }
		break;
#endif
#if 1
		case RELOC_16_HA:
		    {
			Elf32_Addr val;

			val = loff + relas->r_addend;
			*(Elf32_Half *)r_addr = ((val + 0x8000) >> 16);

			_dl_dcbf(r_addr);
		    }
		break;
#endif
		case RELOC_REL14_TAKEN:
			/* val |= 1 << (31-10) XXX? */
		case RELOC_REL14:
		case RELOC_REL14_NTAKEN:
		    {
			Elf32_Addr val = ooff + prev_value +
			    relas->r_addend - (Elf32_Addr)r_addr;
			if (((val & 0xffff8000) != 0) &&
			    ((val & 0xffff8000) != 0xffff8000)) {
				/* invalid offset */
				_dl_die("%s: invalid %s offset %x at %p",
				    object->load_name, "REL14", val,
				    (void *)r_addr);
			}
			val &= ~0xffff0003;
			val |= (*r_addr & 0xffff0003);
			*r_addr = val;
#ifdef DL_PRINTF_DEBUG
			_dl_printf("rel 14 %x val %x\n", r_addr, val);
#endif

			_dl_dcbf(r_addr);
		    }
			break;
		case RELOC_COPY:
		{
#ifdef DL_PRINTF_DEBUG
			_dl_printf("copy r_addr %x, sym %x [%s] size %d val %x\n",
			    r_addr, sym, symn, sym->st_size,
			    (ooff + prev_value+
			    relas->r_addend));
#endif
			/*
			 * we need to find a symbol, that is not in the current
			 * object, start looking at the beginning of the list,
			 * searching all objects but _not_ the current object,
			 * first one found wins.
			 */
			const Elf32_Sym *cpysrc = NULL;
			Elf32_Addr src_loff;
			int size;

			src_loff = 0;
			src_loff = _dl_find_symbol(symn, &cpysrc,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND| SYM_NOTPLT,
			    sym, object, NULL);
			if (cpysrc != NULL) {
				size = sym->st_size;
				if (sym->st_size != cpysrc->st_size) {
					_dl_printf("symbols size differ [%s] \n",
					    symn);
					size = sym->st_size < cpysrc->st_size ?
					    sym->st_size : cpysrc->st_size;
				}
#ifdef DL_PRINTF_DEBUG
_dl_printf(" found other symbol at %x size %d\n",
    src_loff + cpysrc->st_value,  cpysrc->st_size);
#endif
				_dl_bcopy((void *)(src_loff + cpysrc->st_value),
				    r_addr, size);
			} else
				fails++;
		}
			break;
		case RELOC_NONE:
			break;

		default:
			_dl_die("%s: unsupported relocation '%s' %d at %p\n",
			    object->load_name, symn,
			    ELF32_R_TYPE(relas->r_info), (void *)r_addr );
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}
	return(fails);
}

void
_dl_setup_secure_plt(elf_object_t *object)
{
	Elf32_Addr *got;
	Elf32_Addr *plt;
	int numplt, i;

	/* Relocate processor-specific tags. */
	object->Dyn.info[DT_PROC(DT_PPC_GOT)] += object->obj_base;

	got = (Elf32_Addr *)
	    (Elf32_Rela *)(object->Dyn.info[DT_PROC(DT_PPC_GOT)]);
	got[1] = (Elf32_Addr)_dl_bind_start;
	got[2] = (Elf32_Addr)object;

	plt = (Elf32_Addr *)
	   (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
	numplt = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf32_Rela);
	for (i = 0; i < numplt; i++)
		plt[i] += object->obj_base;
}

void
_dl_setup_bss_plt(elf_object_t *object)
{
	Elf_Addr *pltresolve;
	Elf_Addr *first_rela;
	Elf_RelA *relas;
	Elf32_Addr *r_addr;
	int numrela, i;
	int index;

	first_rela = (Elf32_Addr *)
	    (((Elf32_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset +
	    object->obj_base);
	pltresolve = (Elf32_Addr *)(first_rela) - 18;

	relas = (Elf32_Rela *)(object->Dyn.info[DT_JMPREL]);
	numrela = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf32_Rela);
	r_addr = (Elf32_Addr *)(relas->r_offset + object->obj_base);

	for (i = 0, index = 0; i < numrela; i++, r_addr+=2, index++) {
		if (index >= (2 << 12)) {
			/* addis r11,r0,.PLTtable@@ha*/
			r_addr[0] = ADDIS_R11_R0 | HA(index*4);
			r_addr[1] = ADDI_R11_R11 | L(index*4);
			BR(r_addr[2], pltresolve);
			/* only every other slot is used after
			 * index == 2^14
			 */
			r_addr += 2;
		} else {
			r_addr[0] = LI_R11 | (index * 4);
			BR(r_addr[1], pltresolve);
		}
		_dl_dcbf(&r_addr[0]);
		_dl_dcbf(&r_addr[2]);
	}
}

/*
 *	Relocate the Global Offset Table (GOT).
 *	This is done by calling _dl_md_reloc on DT_JMPREL for DL_BIND_NOW,
 *	otherwise the lazy binding plt initialization is performed.
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	void *got_addr;
	int fails = 0;
	int prot_exec = 0;

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	/*
	 * For BSS-PLT, both the GOT and the PLT need to be
	 * executable.  Yuck!
	 */
	if (object->Dyn.info[DT_PROC(DT_PPC_GOT)] == 0)
		prot_exec = PROT_EXEC;

	if (object->traced)
		lazy = 1;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		if (object->Dyn.info[DT_PROC(DT_PPC_GOT)])
			_dl_setup_secure_plt(object);
		else
			_dl_setup_bss_plt(object);
	}

	/* mprotect the GOT */
	got_addr = _dl_protect_segment(object, 0, "__got_start", "__got_end",
	    PROT_READ|prot_exec);
	if (prot_exec != 0 && got_addr != NULL)
		_dl_syncicache(got_addr, 4);

	/* mprotect the PLT */
	_dl_protect_segment(object, 0, "__plt_start", "__plt_end",
	    PROT_READ|prot_exec);

	return (fails);
}

Elf_Addr
_dl_bind(elf_object_t *object, int reloff)
{
	const Elf_Sym *sym, *this;
	Elf_Addr *r_addr, ooff;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr value;
	Elf_RelA *relas;
	Elf32_Addr val;
	Elf32_Addr *pltresolve;
	Elf32_Addr *pltcall;
	Elf32_Addr *pltinfo;
	Elf32_Addr *plttable;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param[2];
		Elf_Addr newval[2];
	} buf;
	struct __kbind *param;
	size_t psize;

	relas = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(relas->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	value = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (value);

	r_addr = (Elf_Addr *)(object->obj_base + relas->r_offset);
	val = value - (Elf32_Addr)r_addr;

	if (object->Dyn.info[DT_PROC(DT_PPC_GOT)] == 0) {
		if (!B24_VALID_RANGE(val)) {
			int index, addr_off;

			/* if offset is > RELOC_24 deal with it */
			index = reloff / sizeof(Elf32_Rela);

			pltresolve = (Elf32_Addr *)
			    (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
			pltcall = (Elf32_Addr *)(pltresolve) + PLT_CALL_OFFSET;

			/*
			 * Early plt entries can make short jumps; later ones
			 * use a 3 word sequence.  c.f. _dl_md_reloc_got()
			 */
			addr_off = (index >= (2 << 12)) ? 2 : 1;

			/*
			 * Update plttable before pltcall branch, to make
			 * this a safe race for threads
			 */
			pltinfo = (Elf32_Addr *)(pltresolve) + PLT_INFO_OFFSET;
			plttable = (Elf32_Addr *)pltinfo[0];

			buf.param[0].kb_addr = &plttable[index];
			buf.param[0].kb_size = sizeof(Elf_Addr);
			buf.param[1].kb_addr = &r_addr[addr_off];
			buf.param[1].kb_size = sizeof(Elf_Addr);
			buf.newval[0] = value + relas->r_addend;
			buf.newval[1] = BRVAL(r_addr[addr_off], pltcall);
			param = &buf.param[0];
			psize = sizeof(buf);
		} else {
			/*
			 * If the offset is small enough, branch directly to
			 * the dest.  We use the _second_ kbind params only.
			 */
			buf.param[1].kb_addr = &r_addr[0];
			buf.param[1].kb_size = sizeof(Elf_Addr);
			buf.newval[0] = BRVAL(r_addr[0], value);
			param = &buf.param[1];
			psize = sizeof(struct __kbind) + sizeof(Elf_Addr);
		}
	} else {
		int index = reloff / sizeof(Elf32_Rela);

		/*
		 * Secure PLT; only needs one update so use the
		 * second kbind params.
		 */
		plttable = (Elf32_Addr *)
		    (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
		buf.param[1].kb_addr = &plttable[index];
		buf.param[1].kb_size = sizeof(Elf_Addr);
		buf.newval[0] = value;
		param = &buf.param[1];
		psize = sizeof(struct __kbind) + sizeof(Elf_Addr);
	}

	{
		register long syscall_num __asm("r0") = SYS_kbind;
		register void *arg1 __asm("r3") = param;
		register long  arg2 __asm("r4") = psize;
		register long  arg3 __asm("r5") = 0xffffffff & (cookie >> 32);
		register long  arg4 __asm("r6") = 0xffffffff &  cookie;

		__asm volatile("sc" : "+r" (syscall_num), "+r" (arg1),
		    "+r" (arg2) : "r" (arg3), "r" (arg4) : "cc", "memory");
	}

	return (value);
}

/* should not be defined here, but it is 32 for all powerpc 603-G4 */
#define CACHELINESIZE 32
void
_dl_syncicache(char *from, size_t len)
{
	unsigned int off = 0;
	int l = len + ((int)from & (CACHELINESIZE-1));

	while (off < l) {
		asm volatile ("dcbst %1,%0" :: "r"(from), "r"(off));
		asm volatile ("sync");
		asm volatile ("icbi %1, %0" :: "r"(from), "r"(off));
		asm volatile ("sync");
		asm volatile ("isync");

		off += CACHELINESIZE;
	}
}
@


1.61
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.60 2017/01/23 10:30:58 guenther Exp $ */
d345 1
a345 1
				    (char *)r_addr);
d403 1
a403 1
				    (char *)r_addr);
d461 1
a461 1
			    ELF32_R_TYPE(relas->r_info), (char *)r_addr );
@


1.60
log
@Fix format string mismatches
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.59 2016/06/21 15:25:37 deraadt Exp $ */
d114 2
a115 4
	if (relrel > numrela) {
		_dl_printf("relcount > numrel: %ld > %d\n", relrel, numrela);
		_dl_exit(20);
	}
d193 2
a194 4
		if (ELF32_R_TYPE(relas->r_info) != RELOC_RELATIVE) {
			_dl_printf("RELCOUNT wrong\n");
			_dl_exit(20);
		}
d199 2
a200 4
		    ELF32_ST_TYPE(sym->st_info) != STT_NOTYPE)) {
			_dl_printf("RELATIVE relocation against symbol\n");
			_dl_exit(20);
		}
d341 1
a341 1
			if (!B24_VALID_RANGE(val)){
d343 3
a345 1
				_dl_exit(20);
d401 3
a403 1
				_dl_exit(20);
d459 2
a460 3
			_dl_printf("%s:"
			    " %s: unsupported relocation '%s' %d at %p\n",
			    __progname, object->load_name, symn,
a461 1
			_dl_exit(1);
d614 2
a615 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.59
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.58 2016/06/13 04:59:56 guenther Exp $ */
d115 1
a115 1
		_dl_printf("relcount > numrel: %ld > %ld\n", relrel, numrela);
d462 1
a462 1
			    " %s: unsupported relocation '%s' %d at %x\n",
d464 1
a464 1
			    ELF32_R_TYPE(relas->r_info), r_addr );
@


1.58
log
@Only need to sync the icache on the GOT for the old BSS PLT format

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.57 2016/03/20 02:29:51 guenther Exp $ */
d184 1
a184 1
				    llist->prot|PROT_WRITE);
@


1.57
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.56 2015/11/02 07:02:53 guenther Exp $ */
d577 1
a577 1
	if (got_addr != NULL)
@


1.56
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.55 2015/08/25 08:01:12 guenther Exp $ */
d463 1
a463 1
			    _dl_progname, object->load_name, symn,
@


1.55
log
@Use kbind for lazy binding GOT/PLT updates on i386 and powerpc; still others
to follow.  While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.54 2015/08/23 15:28:41 kettenis Exp $ */
d548 1
a548 3
	Elf_Addr plt_addr;
	Elf_Addr ooff;
	const Elf_Sym *this;
a561 47
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	plt_addr = 0;
	object->plt_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		plt_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__plt_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL,
	    object, NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	if (plt_addr == 0)
		object->plt_start = 0;
	else {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
	}

d573 10
a582 8
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ|prot_exec);
		_dl_syncicache((void*)object->got_addr, 4);
	}
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|prot_exec);
@


1.54
log
@Add support for the Secure-PLT ABI variant.  This will give us better W^X
support on powerpc as it uses a non-executable GOT and PLT.

"start slamming stuff in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.53 2014/11/24 05:50:08 miod Exp $ */
d33 2
a37 1
#include <signal.h>
d47 2
d63 5
a67 6
#define BR(from, to)	do { \
	int lval = (Elf32_Addr)(to) - (Elf32_Addr)(&(from)); \
	lval &= ~0xfc000000; \
	lval |= 0x48000000; \
	(from) = lval; \
} while (0)
d648 7
a654 2
	sigset_t savedmask;
	int prot_exec = 0;
a661 1
	r_addr = (Elf_Addr *)(object->obj_base + relas->r_offset);
d672 2
a673 16
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return value;

	/*
	 * For BSS-PLT, both the GOT and the PLT need to be
	 * executable.  Yuck!
	 */
	if (object->Dyn.info[DT_PROC(DT_PPC_GOT)] == 0)
		prot_exec = PROT_EXEC;

	/* if PLT is protected, allow the write */
	if (object->plt_size != 0)  {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_WRITE|prot_exec);
	}
d675 1
d679 2
a680 3
		pltresolve = (Elf32_Addr *)
		    (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
		pltcall = (Elf32_Addr *)(pltresolve) + PLT_CALL_OFFSET;
a681 2
		if (!B24_VALID_RANGE(val)) {
			int index;
d685 12
a696 1
			/* update plttable before pltcall branch, to make
a698 2
			val = ooff + this->st_value + relas->r_addend;

a700 1
			plttable[index] = val;
d702 8
a709 13
			if (index >= (2 << 12)) {
				/* r_addr[0,1] is initialized to correct
				 * value in reloc_got.
				 */
				BR(r_addr[2], pltcall);
				_dl_dcbf(&r_addr[2]);
			} else {
				/* r_addr[0] is initialized to correct
				 * value in reloc_got.
				 */
				BR(r_addr[1], pltcall);
				_dl_dcbf(&r_addr[1]);
			}
d711 3
a713 2
			/* if the offset is small enough,
			 * branch directly to the dest
d715 5
a719 2
			BR(r_addr[0], value);
			_dl_dcbf(&r_addr[0]);
d724 4
d730 16
a745 1
		plttable[index] = value;
a747 6
	/* if PLT is to be protected, change back to RO/X */
	if (object->plt_size != 0) {
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|prot_exec);
		_dl_thread_bind_lock(1, &savedmask);
	}
@


1.53
log
@Make the scope of the symbol caching variables added in 1.49 a bit larger so
that these don't get reset for every relocation being processed (oops).
ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.52 2014/07/05 17:06:18 miod Exp $ */
d42 2
d67 3
d71 2
a72 2
#define PLT_CALL_OFFSET		6
#define PLT_INFO_OFFSET		10
d122 2
a123 1
	if (object->Dyn.info[DT_JMPREL] != 0) {
d150 8
a157 6
		pltresolve[0] = ADDIS_R12_R0 | HA(_dl_bind_start);
		pltresolve[1] = ADDI_R12_R12 | L(_dl_bind_start);
		pltresolve[2] = MCTR_R12;
		pltresolve[3] = ADDIS_R12_R0 | HA(object);
		pltresolve[4] = ADDI_R12_R12 | L(object);
		pltresolve[5] = BCTR;
d159 1
a159 1
		_dl_dcbf(&pltresolve[5]);
d255 9
a264 1
#if 1
a274 1
#endif
d478 60
d546 1
a546 9
	Elf_Addr *pltresolve;
	Elf_Addr *first_rela;
	Elf_RelA *relas;
	Elf_Addr  plt_addr;
	int	i;
	int	numrela;
	int	fails = 0;
	int index;
	Elf32_Addr *r_addr;
d549 2
d555 7
d615 4
a618 26
		first_rela = (Elf32_Addr *)
		    (((Elf32_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset +
		    object->obj_base);
		pltresolve = (Elf32_Addr *)(first_rela) - 18;

		relas = (Elf32_Rela *)(object->Dyn.info[DT_JMPREL]);
		numrela = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf32_Rela);
		r_addr = (Elf32_Addr *)(relas->r_offset + object->obj_base);

		for (i = 0, index = 0; i < numrela; i++, r_addr+=2, index++) {
			if (index >= (2 << 12)) {
				/* addis r11,r0,.PLTtable@@ha*/
				r_addr[0] = ADDIS_R11_R0 | HA(index*4);
				r_addr[1] = ADDI_R11_R11 | L(index*4);
				BR(r_addr[2], pltresolve);
				/* only every other slot is used after
				 * index == 2^14
				 */
				r_addr += 2;
			} else {
				r_addr[0] = LI_R11 | (index * 4);
				BR(r_addr[1], pltresolve);
			}
			_dl_dcbf(&r_addr[0]);
			_dl_dcbf(&r_addr[2]);
		}
a620 1

d622 1
a622 1
		    PROT_READ|PROT_EXEC); /* only PPC is PROT_EXE */
d627 1
a627 1
		    PROT_READ|PROT_EXEC);
d647 1
d649 1
a649 1
	relas = ((Elf_RelA *)object->Dyn.info[DT_JMPREL]) + (reloff>>2);
d669 7
d680 1
a680 1
		    PROT_READ|PROT_WRITE|PROT_EXEC);
d685 9
a693 8
	pltresolve = (Elf32_Addr *)
	    (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
	pltcall = (Elf32_Addr *)(pltresolve) + PLT_CALL_OFFSET;

	if (!B24_VALID_RANGE(val)) {
		int index;
		/* if offset is > RELOC_24 deal with it */
		index = reloff >> 2;
d695 4
a698 4
		/* update plttable before pltcall branch, to make
		 * this a safe race for threads
		 */
		val = ooff + this->st_value + relas->r_addend;
d700 3
a702 3
		pltinfo = (Elf32_Addr *)(pltresolve) + PLT_INFO_OFFSET;
		plttable = (Elf32_Addr *)pltinfo[0];
		plttable[index] = val;
d704 13
a716 6
		if (index >= (2 << 12)) {
			/* r_addr[0,1] is initialized to correct
			 * value in reloc_got.
			 */
			BR(r_addr[2], pltcall);
			_dl_dcbf(&r_addr[2]);
d718 2
a719 2
			/* r_addr[0] is initialized to correct
			 * value in reloc_got.
d721 2
a722 2
			BR(r_addr[1], pltcall);
			_dl_dcbf(&r_addr[1]);
d725 5
a729 5
		/* if the offset is small enough,
		 * branch directly to the dest
		 */
		BR(r_addr[0], value);
		_dl_dcbf(&r_addr[0]);
d735 1
a735 1
		    PROT_READ|PROT_EXEC); /* only PPC is PROT_EXE */
@


1.52
log
@Add more sugar to build syscall stubs, and turn them from inlines to real
entry points; also, make sure syscall failures return -errno rather than -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.51 2013/06/13 04:13:47 brad Exp $ */
d91 2
a206 2
		Elf32_Addr prev_value = 0, prev_ooff = 0;
		const Elf32_Sym *prev_sym = NULL;
@


1.51
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.50 2013/06/01 09:57:58 miod Exp $ */
a689 12
__asm__(".section\t\".text\"\n\t"
	".align 2\n\t"
	".globl _dl__syscall\n\t"
	".type _dl__syscall,@@function\n"
	"_dl__syscall:\n\t"
	"li 0, " XSTRINGIFY(SYS___syscall) "\n\t"
	"sc\n\t"
	"cmpwi	0, 0\n\t"
	"beq	1f\n\t"
	"li	3, -1\n\t"
	"1:\n\t"
	"blr");
@


1.50
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.49 2013/05/08 20:55:14 guenther Exp $ */
d607 1
a607 1
		*((int *)0) = 0;	/* XXX */
@


1.49
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.48 2011/04/06 11:36:25 miod Exp $ */
d533 3
d585 1
d604 1
a604 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d610 5
a620 2

	value = ooff + this->st_value;
@


1.48
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.47 2010/05/03 04:03:03 guenther Exp $ */
d80 1
a89 1

d94 1
d105 5
d177 23
a199 2

	for (i = 0; i < numrela; i++, relas++) {
d205 2
d225 19
a243 10
			ooff = _dl_find_symbol_bysym(object,
			    ELF32_R_SYM(relas->r_info), &this,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
			    ((type == RELOC_JMP_SLOT) ? SYM_PLT:SYM_NOTPLT),
			    sym, NULL);

			if (this == NULL) {
				if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
					fails++;
				continue;
d255 1
a255 1
				*r_addr = ooff + this->st_value +
d272 1
a272 1
				*r_addr = loff + this->st_value +
d278 1
a278 1
			Elf32_Addr target = ooff + this->st_value +
d287 1
a287 1
	ooff, this->st_value, relas->r_addend,
d305 1
a305 1
				val= ooff + this->st_value +
d322 1
a322 1
			*r_addr = ooff + this->st_value + relas->r_addend;
d328 1
a328 1
			Elf32_Addr val = ooff + this->st_value +
d383 1
a383 1
			Elf32_Addr val = ooff + this->st_value +
d405 1
a405 1
			    (ooff + this->st_value+
@


1.47
log
@Make powerpc consistent with the other platforms: SYM_SEARCH_OBJ
overrides SYM_DLSYM, so remove the latter

ok drahn@@, testing krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.46 2010/05/02 04:57:01 guenther Exp $ */
d448 1
a448 1
	object->got_addr = NULL;
d480 2
a481 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d487 2
a488 2
	if (plt_addr == NULL)
		object->plt_start = NULL;
@


1.46
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.45 2008/04/09 21:45:26 kurt Exp $ */
d452 1
a452 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, NULL,
d459 1
a459 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, NULL,
d468 1
a468 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, NULL,
d475 1
a475 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, NULL,
@


1.45
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.44 2007/11/27 16:42:19 miod Exp $ */
d551 1
a551 1
	sigset_t omask, nmask;
d571 1
a571 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d623 1
a623 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.44
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.43 2007/05/05 15:21:21 drahn Exp $ */
d92 1
a92 1
	loff = object->load_offs;
d500 1
a500 1
		    object->load_offs);
d505 1
a505 1
		r_addr = (Elf32_Addr *)(relas->r_offset + object->load_offs);
d559 1
a559 1
	r_addr = (Elf_Addr *)(object->load_offs + relas->r_offset);
@


1.43
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.42 2006/10/28 16:06:05 drahn Exp $ */
d430 1
a430 1
void
d437 1
d439 1
a439 1
	int i;
d446 1
a446 1
		return;
d496 1
a496 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d534 2
@


1.42
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.41 2006/05/08 20:37:01 deraadt Exp $ */
d570 1
d622 1
@


1.41
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.40 2005/12/02 20:17:21 kurt Exp $ */
d81 1
a81 1
	struct load_list *load_list;
d162 7
a168 6
	load_list = object->load_list;
	while (load_list != NULL) {
		if ((load_list->prot & PROT_WRITE) == 0)
			_dl_mprotect(load_list->start, load_list->size,
			    load_list->prot|PROT_WRITE);
		load_list = load_list->next;
d413 8
a420 6
	load_list = object->load_list;
	while (load_list != NULL) {
		if ((load_list->prot & PROT_WRITE) == 0)
			_dl_mprotect(load_list->start, load_list->size,
			    load_list->prot);
		load_list = load_list->next;
@


1.40
log
@fix RELOC_COPY on powerpc when symbol is weak. use relocation address
instead of symbol address. okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.39 2005/09/22 13:59:47 drahn Exp $ */
d383 1
a383 1
			if(cpysrc != NULL) {
@


1.39
log
@missed a NOWARN -> WARN change
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.38 2005/09/22 01:33:08 drahn Exp $ */
d396 1
a396 2
				    (void *)(ooff + this->st_value+ relas->r_addend),
					size);
@


1.38
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.37 2005/09/21 23:12:11 drahn Exp $ */
d197 1
a197 1
			    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
@


1.37
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.36 2005/09/16 23:19:42 drahn Exp $ */
d202 1
a202 6
				if (ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
					_dl_printf("%s: %s :can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);

a203 1
				}
d381 1
a381 1
			    SYM_SEARCH_OTHER|SYM_NOWARNNOTFOUND| SYM_NOTPLT,
d383 1
a383 3
			if (cpysrc == NULL) {
				_dl_printf("symbol not found [%s] \n", symn);
			} else {
d398 2
a399 1
			}
@


1.36
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.35 2004/05/25 21:42:48 mickey Exp $ */
a187 1
		this = sym;
d191 1
a191 1

d199 8
a206 1
			    sym->st_size, NULL);
d208 3
a210 4
			if (!this && ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
				_dl_printf("%s: %s :can't resolve reference '%s'\n",
				    _dl_progname, object->load_name, symn);
				fails++;
d388 1
a388 1
			    sym->st_size, object, NULL);
d456 1
a456 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, 0,
d463 1
a463 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, 0,
d472 1
a472 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, 0,
d479 1
a479 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT|SYM_DLSYM, 0,
d564 1
a564 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
@


1.35
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2004/05/25 18:07:20 mickey Exp $ */
d197 2
a198 2
			    ELF32_R_SYM(relas->r_info), _dl_objects,
			    &this, NULL, SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d200 1
a200 1
			    sym->st_size);
d363 1
a369 1
		    {
a375 1
			elf_object_t *cobj;
d381 3
a383 13
			for (cobj = _dl_objects; cobj != NULL && cpysrc == NULL;
			    cobj = cobj->next) {
				if (object != cobj) {
					/* only look in this object */
					src_loff = _dl_find_symbol_bysym(object,
					    ELF32_R_SYM(relas->r_info),
					    cobj, &cpysrc, NULL,
					    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|
					    ((type == RELOC_JMP_SLOT) ?
					        SYM_PLT : SYM_NOTPLT),
					    sym->st_size);
				}
			}
d450 3
a452 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d457 3
a459 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d466 3
a468 2
	ooff = _dl_find_symbol("__plt_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d473 3
a475 2
	ooff = _dl_find_symbol("__plt_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d558 3
a560 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d617 1
a617 1
	/* if PLT is (to be protected, change back to RO/X */
@


1.34
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2003/12/03 17:00:15 drahn Exp $ */
a73 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	unsigned const char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.33
log
@Move the asm definition of _dl__syscall from a header file into a .c file
so that 12 copies of it are not generated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2003/09/04 19:37:07 drahn Exp $ */
d209 1
a209 1
			    &this, SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d399 1
a399 1
					    cobj, &cpysrc,
d472 1
a472 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d478 1
a478 1
	ooff = _dl_find_symbol("__got_end", object, &this,
d486 1
a486 1
	ooff = _dl_find_symbol("__plt_start", object, &this,
d492 1
a492 1
	ooff = _dl_find_symbol("__plt_end", object, &this,
d576 1
a576 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
@


1.32
log
@Fix W^X mistake. If the dynamic linker is workin in non-lazy mode, it
should still mprotect the GOT and PLT as appropriate. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2003/09/04 19:33:49 drahn Exp $ */
d661 12
@


1.31
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2003/09/02 15:17:52 drahn Exp $ */
d514 26
a539 22
		return;
	}
	first_rela = (Elf32_Addr *)
	    (((Elf32_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset +
	    object->load_offs);
	pltresolve = (Elf32_Addr *)(first_rela) - 18;

	relas = (Elf32_Rela *)(object->Dyn.info[DT_JMPREL]);
	numrela = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf32_Rela);
	r_addr = (Elf32_Addr *)(relas->r_offset + object->load_offs);

	for (i = 0, index = 0; i < numrela; i++, r_addr+=2, index++) {
		if (index >= (2 << 12)) {
			/* addis r11,r11,.PLTtable@@ha*/
			r_addr[0] = ADDIS_R11_R0 | HA(index*4);
			r_addr[1] = ADDI_R11_R11 | L(index*4);
			BR(r_addr[2], pltresolve);
			/* only every other slot is used after index == 2^14 */
			r_addr += 2;
		} else {
			r_addr[0] = LI_R11 | (index * 4);
			BR(r_addr[1], pltresolve);
a540 2
		_dl_dcbf(&r_addr[0]);
		_dl_dcbf(&r_addr[2]);
@


1.30
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2003/08/19 04:15:54 drahn Exp $ */
d207 3
a209 2
			ooff = _dl_find_symbol(symn, _dl_objects, &this,
			    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d211 1
a211 1
			    sym->st_size, object);
d397 3
a399 2
					src_loff = _dl_find_symbol(symn, cobj,
					    &cpysrc,
d403 1
a403 1
					    sym->st_size, object);
@


1.29
log
@Fix PowerPC PLT generation. After 2^12 entries (2^14 offset), only every
other slot in the PLT is used, this is because it takes more than one
instruction to generate a constant > 2^14.

Normal PLT entry < 2^12
li r11, <n>		# where n is PLT index*4 (offset used for plttable).
b .pltresolve | .pltcall | target

PLT entry after 2^12
lis r11, <n>@@ha
addi r11, r11, <n>@@l	# where n is PLT index*4 (offset used for plttable).
b .pltresolve | .pltcall | target
nop 			# unused

This is all specified by the PowerPC SVID.

The PLT table generation code was never tested for entries > 2^12 before
and was broken. This fixes the indexing, the constant checking 12 vs 14, ...

This code has been tested with up to 128000+ functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2003/07/28 03:11:00 drahn Exp $ */
d73 1
d210 1
a210 1
			    sym->st_size, object->load_name);
d401 1
a401 1
					    sym->st_size, object->load_name);
d471 1
a471 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d477 1
a477 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d485 1
a485 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d491 1
a491 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d573 1
a573 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0, object->load_name);
@


1.28
log
@The fifth argument to _dl_find_symbol is a 'int size', not a SYM_ define.
Fix several calls which had the incorrect but working define in that position
It happened that SYM_NOTPLT was 0, which was the desired size value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2003/07/06 20:04:00 deraadt Exp $ */
d121 1
d129 1
a129 3
		plttable = (Elf32_Addr *)
		    ((Elf32_Addr)first_rela) + (2 *
		    (object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf32_Rela)));
d131 7
d264 1
a264 1
				if (index > (2 << 14)) {
d523 1
a523 1
		if (index > (2 << 14)) {
d528 1
a528 1
			/* only every other slot is used after 2^14 entries */
a529 1
			index++;
d608 1
a608 1
		if (index > (2 << 14)) {
@


1.27
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2003/06/09 16:10:04 deraadt Exp $ */
d464 1
a464 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d470 1
a470 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d478 1
a478 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d484 1
a484 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d567 1
a567 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    object->load_name);
@


1.26
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2003/03/10 03:57:57 david Exp $ */
d75 1
a75 1
_dl_bcopy(void *src, void *dest, int size)
d77 2
a78 1
	unsigned char *psrc = src, *pdest = dest;
d506 1
a506 2
		
	
@


1.25
log
@typo
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2003/02/15 22:39:13 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2003/02/15 00:30:16 drahn Exp $ */
d644 1
a644 1
/* should not be defined here, but is is 32 for all powerpc 603-G4 */
@


1.23
log
@Do not call mprotect to enable writing for sections which normally are
writable. Idea taken from alpha version. Saves many mprotect syscalls.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2003/02/02 16:57:58 deraadt Exp $ */
d451 4
a454 3
	Elf32_Addr *pltresolve;
	Elf32_Addr *first_rela;
	Elf32_Rela  *relas;
d465 2
d481 2
d488 1
a488 1
		object->plt_addr = ooff + this->st_value;
d495 1
a495 1
		object->plt_size = ooff + this->st_value  - object->plt_addr;
d497 16
d542 3
a544 2
	if (object->got_addr != NULL && object->got_size != 0) {
		_dl_mprotect((void*)object->got_addr, object->got_size,
d548 2
a549 2
	if (object->plt_addr != NULL && object->plt_size != 0)
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
d585 1
a585 1
	if (object->plt_addr != NULL && object->plt_size != 0)  {
d588 1
a588 1
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
d636 2
a637 2
	if (object->plt_addr != NULL && object->plt_size != 0) {
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
@


1.22
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2003/01/30 06:40:38 drahn Exp $ */
d173 3
a175 2
		_dl_mprotect(load_list->start, load_list->size,
		    load_list->prot|PROT_WRITE);
d435 3
a437 1
		_dl_mprotect(load_list->start, load_list->size, load_list->prot);
@


1.21
log
@Only flush the got address, if there is one. DOH.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2003/01/24 00:43:29 drahn Exp $ */
d69 1
a69 1
}while(0)
d251 1
a251 1
			if(!B24_VALID_RANGE(val)){
d299 1
a299 1
			if(!B24_VALID_RANGE(val)){
d523 1
a523 1
	if (object->plt_addr != NULL && object->plt_size != 0) 
d564 1
a564 1
		    PROT_READ|PROT_WRITE|PROT_EXEC); 
@


1.20
log
@Flush the blrl instruction from the instruction cache if the GOT tag is
present. Fixes illegal instruction problems seen the last few days
tested by myself and matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2002/12/18 19:20:02 drahn Exp $ */
d518 1
a518 1
	if (object->got_addr != NULL && object->got_size != 0) 
d522 1
@


1.19
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2002/11/22 22:21:23 drahn Exp $ */
d48 1
d521 1
@


1.18
log
@Formatting cleanup, no point in extra nesting block. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2002/11/14 15:15:54 drahn Exp $ */
d42 1
d454 2
d460 28
d517 6
d538 1
d556 8
d607 6
@


1.17
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2002/11/05 16:53:19 drahn Exp $ */
d496 5
d520 1
a520 2
	{
		Elf32_Addr val = value - (Elf32_Addr)r_addr;
d522 13
a534 4
		Elf32_Addr *pltresolve;
		Elf32_Addr *pltcall;
		Elf32_Addr *pltinfo;
		Elf32_Addr *plttable;
d536 3
a538 3
		pltresolve = (Elf32_Addr *)
		    (Elf32_Rela *)(object->Dyn.info[DT_PLTGOT]);
		pltcall = (Elf32_Addr *)(pltresolve) + PLT_CALL_OFFSET;
d540 3
a542 7
		if (!B24_VALID_RANGE(val)) {
			int index;
			/* if offset is > RELOC_24 deal with it */
			index = reloff >> 2;

			/* update plttable before pltcall branch, to make
			 * this a safe race for threads
d544 2
a545 19
			val = ooff + this->st_value + relas->r_addend;

			pltinfo = (Elf32_Addr *)(pltresolve) + PLT_INFO_OFFSET;
			plttable = (Elf32_Addr *)pltinfo[0];
			plttable[index] = val;

			if (index > (2 << 14)) {
				/* r_addr[0,1] is initialized to correct
				 * value in reloc_got.
				 */
				BR(r_addr[2], pltcall);
				_dl_dcbf(&r_addr[2]);
			} else {
				/* r_addr[0] is initialized to correct
				 * value in reloc_got.
				 */
				BR(r_addr[1], pltcall);
				_dl_dcbf(&r_addr[1]);
			}
d547 2
a548 2
			/* if the offset is small enough,
			 * branch directly to the dest
d550 2
a551 2
			BR(r_addr[0], value);
			_dl_dcbf(&r_addr[0]);
d553 6
@


1.16
log
@Use define, not number.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2002/09/09 19:06:18 drahn Exp $ */
d205 1
a205 1
			    sym->st_size);
d396 1
a396 1
					    sym->st_size);
d506 2
a507 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, SYM_NOTPLT);
@


1.15
log
@Add lazy binding support for powerpc ld.so. ok pvalchev@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2002/08/23 22:57:03 drahn Exp $ */
d506 1
a506 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0);
@


1.14
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2002/08/11 16:51:04 drahn Exp $ */
d47 31
d98 1
d101 1
d117 1
a123 1
		Elf32_Addr val;
a124 3
		first_rela = (Elf32_Addr *)
		    (((Elf32_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset +
		    loff);
d126 5
a130 5
		pltcall = (Elf32_Addr *)(first_rela) - 12;
#ifdef DL_PRINTF_DEBUG
		_dl_printf("creating pltcall at %x\n", pltcall);
		_dl_printf("md_reloc(jumprel %x\n", first_rela);
#endif
d135 3
d143 16
a158 9
		pltcall[-1]= 0x504c5400; /* PLT tag :-) */
		val = ((Elf32_Addr)plttable >> 16) +
		    (((Elf32_Addr)plttable & 0x00008000) >> 15);
		pltcall[0] = 0x3d6b0000 | val;  /* addis r11,r11,.PLTtable@@ha*/
		val = (Elf32_Addr)plttable & 0x0000ffff;
		pltcall[1] = 0x816b0000 | val;	/* lwz r11,plttable@@l(r11) */
		pltcall[2] = 0x7d6903a6;	/* mtctr r12 */
		pltcall[3] = 0x4e800420;	/* bctr */
		_dl_dcbf(pltcall);
d187 5
a195 1
		type = ELF32_R_TYPE(relas->r_info);
d203 1
a203 1
			SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d205 1
a205 1
			sym->st_size);
d245 5
a249 4
			Elf32_Addr val = ooff + this->st_value +
			    relas->r_addend - (Elf32_Addr)r_addr;
			if (!(((val & 0xfe000000) == 0x00000000) ||
			    ((val &  0xfe000000) == 0xfe000000))) {
d262 3
a264 9
					val = (index*4 >> 16) +
					    ((index*4 & 0x00008000) >> 15);
					r_addr[0] = 0x3d600000 | val;
					val = (Elf32_Addr)pltcall -
					    (Elf32_Addr)&r_addr[2];
					r_addr[1] = 0x396b0000 | val;
					val &= ~0xfc000000;
					val |= 0x48000000;
					r_addr[2] = val;
d266 2
a267 11
#ifdef DL_PRINTF_DEBUG
_dl_printf("  index %d, pltcall %x r_addr %x\n",
    index, pltcall, r_addr);
#endif

					r_addr[0] = 0x39600000 | (index * 4);
					val = (Elf32_Addr)pltcall -
					    (Elf32_Addr)&r_addr[1];
					val &= ~0xfc000000;
					val |= 0x48000000;
					r_addr[1] = val;
d270 1
a270 1
				_dl_dcbf(r_addr);
d280 1
a280 1
				 * branch directy to the dest
d282 2
a283 4
				val &= ~0xfc000000;
				val |= 0x48000000;
				*r_addr = val;
				_dl_dcbf(r_addr);
d297 1
a297 2
			if (((val & 0xfe000000) != 0) &&
			    ((val & 0xfe000000) != 0xfe000000)) {
d305 1
a305 1
_dl_dcbf(r_addr);
d439 3
a441 7
 *	Relocate the Global Offset Table (GOT). Currently we don't
 *	do lazy evaluation here because the GNU linker doesn't
 *	follow the ABI spec which says that if an external symbol
 *	is referenced by other relocations than CALL16 and 26 it
 *	should not be given a stub and have a zero value in the
 *	symbol table. By not doing so, we can't use pointers to
 *	external functions and use them in comparisons...
d446 117
a562 1
	/* relocations all done via rela relocations above */
@


1.13
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2002/07/12 20:18:30 drahn Exp $ */
d142 1
a142 1
		int inplt;
d151 1
d158 5
a162 2
			inplt = (ELF32_R_TYPE(relas->r_info) == RELOC_JMP_SLOT);
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 0, inplt);
d170 1
a170 1
		switch (ELF32_R_TYPE(relas->r_info)) {
d365 5
a369 1
					    &cpysrc, 1, 1, 0);
@


1.12
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2002/07/07 08:54:50 jufi Exp $ */
d142 1
d157 2
a158 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 0);
d361 1
a361 1
					    &cpysrc, 1, 1);
@


1.11
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2002/06/05 23:13:55 art Exp $ */
d84 3
d151 2
d352 2
@


1.10
log
@Cleanup/remove duplicate code that checks STAT_RELOC_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2002/06/05 19:34:44 art Exp $ */
d401 1
a401 1
 *	external functions and use them in comparitions...
@


1.9
log
@Get rid of an unnecessary typedef (for future cleanup).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2002/05/24 04:21:27 deraadt Exp $ */
d81 1
a81 1
	if ((object->status & STAT_RELOC_DONE) || !relas)
a385 1
	object->status |= STAT_RELOC_DONE;
@


1.8
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2002/05/24 04:17:01 deraadt Exp $ */
d63 1
a63 1
	load_list_t *load_list;
@


1.7
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2002/05/24 03:44:38 deraadt Exp $ */
d163 2
a164 2
			   (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
			   ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
d174 2
a175 2
			   (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
			   ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
@


1.6
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2001/08/05 15:31:35 drahn Exp $ */
d72 1
a72 1
	loff   = object->load_offs;
d111 1
a111 1
		val  = (Elf32_Addr)plttable & 0x0000ffff;
d164 1
a164 1
			    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
d175 1
a175 1
			    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
d189 1
a189 1
		   {
d213 1
a213 1
					val |=  0x48000000;
d225 1
a225 1
					val |=  0x48000000;
d242 1
a242 1
				val |=  0x48000000;
d246 1
a246 1
		   }
d264 1
a264 1
			val |=  (*r_addr & 0xfc000003);
d320 1
a320 1
			val |=  (*r_addr & 0xffff0003);
d358 1
a358 1
				size  = sym->st_size;
@


1.5
log
@Do not have dl_find_symbol complain about symbols not found, code immediately
following the call will catch and report any errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2001/03/30 01:35:21 drahn Exp $ */
d5 1
a5 1
 * 
d50 1
a50 1
	unsigned char *psrc, *pdest;
d52 2
a53 3
	psrc = src;
	pdest = dest;
	for (i = 0; i < size; i++) {
a54 1
	}
d70 1
a70 1
	Elf32_Addr * first_rela;
d81 1
a81 1
	if((object->status & STAT_RELOC_DONE) || !relas) {
d83 1
a83 1
	}
d90 2
a91 2
		(((Elf32_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset
			+ loff);
d95 2
a96 2
_dl_printf("creating pltcall at %x\n", pltcall);
_dl_printf("md_reloc( jumprel %x\n", first_rela );
d99 2
a100 3
			((Elf32_Addr)first_rela) + (2 *
			(object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf32_Rela))
			);
d103 3
a105 4
_dl_printf("md_reloc:  plttbl size %x\n", 
			(object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf32_Rela))
);
_dl_printf("md_reloc: plttable %x\n", plttable);
d109 1
a109 1
			(((Elf32_Addr)plttable & 0x00008000) >> 15);
d127 1
a127 1
	while(load_list != NULL) {
d129 1
a129 1
			load_list->prot|PROT_WRITE);
d134 1
a134 1
	for(i = 0; i < numrela; i++, relas++) {
d140 1
a140 1
		if(ELF32_R_SYM(relas->r_info) == 0xffffff) {
a141 1
		}
d148 3
a150 4
		if(ELF32_R_SYM(relas->r_info) &&
		   !(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
		     ELF32_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
			
d152 3
a154 5
			if(!this && ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
				_dl_printf("%s:"
					" %s :can't resolve reference '%s'\n",
					_dl_progname, object->load_name,
					symn);
a156 1

d159 1
a159 1
		switch(ELF32_R_TYPE(relas->r_info)) {
d162 1
a162 1
			if(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
d168 1
a168 1
					relas->r_addend;
d173 1
a173 1
			if(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
d180 1
a180 1
loff + relas->r_addend, loff, ooff, relas->r_addend);
d185 1
a185 1
					relas->r_addend;
d191 3
a193 4
				relas->r_addend - (Elf32_Addr)r_addr;
			if (!(((val & 0xfe000000) == 0x00000000) || 
				((val &  0xfe000000) == 0xfe000000)))
			{
a204 1

d207 1
a207 1
						((index*4 & 0x00008000) >> 15);
d210 2
a211 2
						(Elf32_Addr)&r_addr[2];
					r_addr[1] = 0x396b0000 | val; 
a214 1

d217 2
a218 2
	_dl_printf("  index %d, pltcall %x r_addr %x\n",
		index, pltcall, r_addr);
d223 1
a223 1
						(Elf32_Addr)&r_addr[1];
d232 1
a232 1
					relas->r_addend;
d234 1
a234 1
		_dl_printf(" symn [%s] val 0x%x\n", symn, val);
d238 1
a238 1
				/* if the offset is small enough, 
d243 1
a243 1
				*r_addr = val;	
d255 1
a255 1
		  {
d257 3
a259 3
				relas->r_addend - (Elf32_Addr)r_addr;
			if ((val & 0xfe000000 != 0) &&
				(val & 0xfe000000 != 0xfe000000)) {
d265 1
a265 1
			*r_addr = val;	
d268 1
a268 1
		  }
d273 1
a273 1
		  {
d280 1
a280 1
		  }
d285 1
a285 1
		  {
d292 1
a292 1
		  }
d297 1
a297 1
		  {
d304 1
a304 1
		  }
d306 1
a306 1
#endif                      
d311 1
a311 1
			{
d313 1
a313 1
				relas->r_addend - (Elf32_Addr)r_addr;
d315 1
a315 2
				((val & 0xffff8000) != 0xffff8000))
			{
d321 1
a321 1
			*r_addr = val;	
d323 1
a323 2
			_dl_printf("rel 14 %x val %x\n", 
				r_addr, val);
d325 1
a325 1
				
d327 1
a327 1
			}
d332 36
a367 5
				r_addr, sym, symn, sym->st_size,
				(ooff + this->st_value+
				relas->r_addend)

				);
d369 4
a372 18
{
	/* we need to find a symbol, that is not in the current object,
	 * start looking at the beginning of the list, searching all objects
	 * but _not_ the current object, first one found wins.
	 */
	elf_object_t *cobj;
	const Elf32_Sym *cpysrc = NULL;
	Elf32_Addr src_loff;
	int size;
	for (cobj = _dl_objects;
		cobj != NULL && cpysrc == NULL;
		cobj = cobj->next)
	{
		if (object != cobj) {

			/* only look in this object */
			src_loff = _dl_find_symbol(symn, cobj,
				&cpysrc, 1, 1);
a373 19
	}
	if (cpysrc == NULL) {
		_dl_printf("symbol not found [%s] \n", symn);
	} else {
		size  = sym->st_size;
		if (sym->st_size != cpysrc->st_size) {
			_dl_printf("symbols size differ [%s] \n", symn);
			size = sym->st_size < cpysrc->st_size ?
				sym->st_size : cpysrc->st_size;
		}
#ifdef DL_PRINTF_DEBUG
_dl_printf(" found other symbol at %x size %d\n", 
		src_loff + cpysrc->st_value,  cpysrc->st_size);
#endif
		_dl_bcopy((void *)(src_loff + cpysrc->st_value),
			(void *)(ooff + this->st_value+ relas->r_addend),
			size);
	}
}
d380 3
a382 3
				" %s: unsupported relocation '%s' %d at %x\n",
					_dl_progname, object->load_name, symn,
					ELF32_R_TYPE(relas->r_info), r_addr );
d388 1
a388 1
	while(load_list != NULL) {
@


1.4
log
@Add infrastructure to allow mapping of text sections which are normally
RO, RW while ld.so is working. And then the information to set the
sections back to RO (or appropriate mode).

PowerPC now supports the typical NON-PIC relocations in ld.so.
I do not know how well this will work with large shared libraries.
I seem to recall a possible problem with large data where data is
located in a different shared library.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2000/10/06 17:39:30 rahnds Exp $ */
d157 1
a157 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
@


1.3
log
@Work around a shared library/pmap bug on the powerpc arch. Somehow
it seems that the instruction cache will not get properly initialized
or a problem exists with mmaping code and being able to execute it.
This workaround is excessive in that it flushes the cache for the
entire mmaped library. This slows down program startup, but seems
to eliminate the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2000/10/06 17:33:55 drahn Exp $ */
d38 1
d65 1
d125 13
d264 1
a264 1
#ifdef DL_PRINTF_DEBUG
d267 1
a267 1
			{
d271 1
a271 2
				(val & 0xfe000000 != 0xfe000000))
			{
d278 25
a302 1
				
d304 2
a305 1
			}
d307 12
a318 1
			break;
d403 5
a430 1
        int l = len;
d432 1
d434 2
a435 2
	while (off < len) {
                asm volatile ("dcbst %1,%0" :: "r"(from), "r"(off));
d437 1
a437 1
                asm volatile ("icbi 0,%0" :: "r"(from), "r"(off));
d441 2
a442 2
                off += CACHELINESIZE;
        }
@


1.2
log
@Cleanup of powerpc ld.so files.
instead of #if 0, make them potentially useful -> LD_PRINTF_DEBUG
Deal with _dl_suid_ok correctly, this is not something that should
be hardcoded. - pointed out a few weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1.1.1 2000/06/13 03:40:38 rahnds Exp $ */
d369 19
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d76 1
a76 1
#if 0
d94 1
a94 1
#if 0
d103 1
a103 1
#if 0
d172 1
a172 1
#if 0
d190 1
a190 1
#if 0
d213 1
a213 1
#if 0
d230 1
a230 1
#if 0
d249 1
a249 1
#if 0
d285 1
a285 1
#if 0
d294 1
a294 1
#if 0
d331 1
a331 1
#if 0
@


1.1.1.1
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems 
such as correctness and security.

@
text
@@
