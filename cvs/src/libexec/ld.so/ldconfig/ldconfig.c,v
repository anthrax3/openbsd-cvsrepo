head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.16
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	r20000612:1.1.1.1
	dsr:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.07.04.20.56.50;	author kettenis;	state Exp;
branches;
next	1.35;
commitid	roU3LTBV1W77FE1g;

1.35
date	2015.11.15.02.49.59;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	pYzPwGjmgQiV0uBc;

1.34
date	2015.01.18.04.48.24;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	eRoBhNqhtj9qy8AW;

1.33
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	31KwZ9PARAKUg1ob;

1.32
date	2013.12.30.21.58.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.13.05.41.42;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.18.14.44.39;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.11.21.20.14;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.13.20.51.33;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.30.17.42.50;	author zinovik;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.19.19.38.17;	author bluhm;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.26.23.26.12;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.19.20.44.27;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.15.22.09.32;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.18.17.00.06;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.13.16.33.40;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.12.23.20.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.11.22.03.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.11.15.21.40;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.31.15.08.22;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.14.03.08.24;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.21.08.56.34;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.21.08.50.38;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.30.22.25.27;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.24.19.00.17;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.13.06.35;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.13.31.42;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.13.28.09;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.30.02.39.06;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.40.19;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.40.19;	author rahnds;	state Exp;
branches;
next	;

1.7.2.1
date	2002.05.30.18.13.21;	author jason;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Nuke prebind support; it's unworkable and we're never going to finish it.

ok guenther@@, deraadt@@
@
text
@/*	$OpenBSD: ldconfig.c,v 1.35 2015/11/15 02:49:59 deraadt Exp $	*/

/*
 * Copyright (c) 1993,1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <ar.h>
#include <ranlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ld.h"

#undef major
#undef minor

extern char			*__progname;

int				verbose;
static int			nostd;
static int			justread;
int				merge;
static int			rescan;
static int			unconfig;

struct shlib_list {
	/* Internal list of shared libraries found */
	char			*name;
	char			*path;
	int			dewey[MAXDEWEY];
	int			ndewey;
#define major dewey[0]
#define minor dewey[1]
	struct shlib_list	*next;
};

static struct shlib_list	*shlib_head = NULL, **shlib_tail = &shlib_head;
static char			*dir_list;

static void	enter(char *, char *, char *, int *, int);
static int	dodir(char *, int);
static int	buildhints(void);
static int	readhints(void);
static void	listhints(void);

static void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-mRrsUv] [path ...]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int i, c;
	int rval = 0;

	if (pledge("stdio rpath wpath cpath tmppath fattr", NULL) == -1)
		err(1, "pledge");

	while ((c = getopt(argc, argv, "DmPrRsSUv")) != -1) {
		switch (c) {
		case 'R':
			rescan = 1;
			break;
		case 'U':
			rescan = unconfig = 1;
			break;
		case 'm':
			merge = 1;
			break;
		case 'r':
			justread = 1;
			break;
		case 's':
			nostd = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
			break;
		}
	}

	if (unconfig && merge)
		errx(1, "cannot use -U with -m");

	dir_list = xmalloc(1);
	*dir_list = '\0';

	if (justread || merge || rescan) {
		if ((rval = readhints()) != 0)
			return rval;
		if (justread) {
			listhints();
			return 0;
		}
		add_search_path(dir_list);
		dir_list = xrealloc(dir_list, 1);
		*dir_list = '\0';
	} else if (!nostd)
		std_search_path();

	if (unconfig) {
		if (optind < argc)
			for (i = optind; i < argc; i++)
				remove_search_dir(argv[i]);
		else {
			i = 0;
			while (i < n_search_dirs) {
				if (access(search_dirs[i], R_OK) < 0)
					remove_search_dir(search_dirs[i]);
				else
					i++;
			}
		}
	} else
		for (i = optind; i < argc; i++)
			add_search_dir(argv[i]);

	for (i = 0; i < n_search_dirs; i++) {
		char *cp = concat(dir_list, *dir_list?":":"", search_dirs[i]);

		free(dir_list);
		dir_list = cp;
		rval |= dodir(search_dirs[i], 0);
	}

	rval |= buildhints();

	return rval;
}

int
dodir(char *dir, int silent)
{
	DIR		*dd;
	struct dirent	*dp;
	char		name[PATH_MAX];
	int		dewey[MAXDEWEY], ndewey;

	if ((dd = opendir(dir)) == NULL) {
		if (!silent || errno != ENOENT)
			warn("%s", dir);
		return -1;
	}

	while ((dp = readdir(dd)) != NULL) {
		size_t n;
		char *cp;

		/* Check for `lib' prefix */
		if (dp->d_name[0] != 'l' ||
		    dp->d_name[1] != 'i' ||
		    dp->d_name[2] != 'b')
			continue;

		/* Copy the entry minus prefix */
		(void)strlcpy(name, dp->d_name + 3, sizeof name);
		n = strlen(name);
		if (n < 4)
			continue;

		/* Find ".so." in name */
		for (cp = name + n - 4; cp > name; --cp) {
			if (cp[0] == '.' &&
			    cp[1] == 's' &&
			    cp[2] == 'o' &&
			    cp[3] == '.')
				break;
		}
		if (cp <= name)
			continue;

		*cp = '\0';

		bzero((caddr_t)dewey, sizeof(dewey));
		ndewey = getdewey(dewey, cp + 3);
		if (ndewey > 0)
			enter(dir, dp->d_name, name, dewey, ndewey);
	}
	closedir(dd);
	return 0;
}

static void
enter(char *dir, char *file, char *name, int dewey[], int ndewey)
{
	struct shlib_list	*shp;

	for (shp = shlib_head; shp; shp = shp->next) {
		if (strcmp(name, shp->name) != 0 || major != shp->major)
			continue;

		/* Name matches existing entry */
		if (cmpndewey(dewey, ndewey, shp->dewey, shp->ndewey) > 0) {

			/* Update this entry with higher versioned lib */
			if (verbose)
				printf("Updating lib%s.%d.%d to %s/%s\n",
				    shp->name, shp->major, shp->minor,
				    dir, file);

			free(shp->name);
			shp->name = xstrdup(name);
			free(shp->path);
			shp->path = concat(dir, "/", file);
			bcopy(dewey, shp->dewey, sizeof(shp->dewey));
			shp->ndewey = ndewey;
		}
		break;
	}

	if (shp)
		/* Name exists: older version or just updated */
		return;

	/* Allocate new list element */
	if (verbose)
		printf("Adding %s/%s\n", dir, file);

	shp = (struct shlib_list *)xmalloc(sizeof *shp);
	shp->name = xstrdup(name);
	shp->path = concat(dir, "/", file);
	bcopy(dewey, shp->dewey, sizeof(shp->dewey));
	shp->ndewey = ndewey;
	shp->next = NULL;

	*shlib_tail = shp;
	shlib_tail = &shp->next;
}


#if DEBUG
/* test */
#undef _PATH_LD_HINTS
#define _PATH_LD_HINTS		"./ld.so.hints"
#endif

static int
hinthash(char *cp, int vmajor, int vminor)
{
	int	k = 0;

	while (*cp)
		k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;

	k = (((k << 1) + (k >> 14)) ^ (vmajor*257)) & 0x3fff;
#if 0
	k = (((k << 1) + (k >> 14)) ^ (vminor*167)) & 0x3fff;
#endif

	return k;
}

int
buildhints(void)
{
	int strtab_sz = 0, nhints = 0, fd = -1, i, ret = -1, str_index = 0;
	struct hints_bucket *blist;
	struct hints_header hdr;
	struct shlib_list *shp;
	char *strtab, *tmpfilenam;
	size_t n;

	for (shp = shlib_head; shp; shp = shp->next) {
		strtab_sz += 1 + strlen(shp->name);
		strtab_sz += 1 + strlen(shp->path);
		nhints++;
	}

	/* Fill hints file header */
	hdr.hh_magic = HH_MAGIC;
	hdr.hh_version = LD_HINTS_VERSION_2;
	hdr.hh_nbucket = 1 * nhints;
	n = hdr.hh_nbucket * sizeof(struct hints_bucket);
	hdr.hh_hashtab = sizeof(struct hints_header);
	hdr.hh_strtab = hdr.hh_hashtab + n;
	hdr.hh_dirlist = strtab_sz;
	strtab_sz += 1 + strlen(dir_list);
	hdr.hh_strtab_sz = strtab_sz;
	hdr.hh_ehints = hdr.hh_strtab + hdr.hh_strtab_sz;

	if (verbose)
		printf("Totals: entries %d, buckets %ld, string size %d\n",
		    nhints, hdr.hh_nbucket, strtab_sz);

	/* Allocate buckets and string table */
	blist = (struct hints_bucket *)xmalloc(n);
	bzero(blist, n);
	for (i = 0; i < hdr.hh_nbucket; i++)
		/* Empty all buckets */
		blist[i].hi_next = -1;

	strtab = xmalloc(strtab_sz);

	/* Enter all */
	for (shp = shlib_head; shp; shp = shp->next) {
		struct hints_bucket	*bp;

		bp = blist + (hinthash(shp->name, shp->major, shp->minor) %
		    hdr.hh_nbucket);

		if (bp->hi_pathx) {
			int	j;

			for (j = 0; j < hdr.hh_nbucket; j++) {
				if (blist[j].hi_pathx == 0)
					break;
			}
			if (j == hdr.hh_nbucket) {
				warnx("Bummer!");
				goto out;
			}
			while (bp->hi_next != -1)
				bp = &blist[bp->hi_next];
			bp->hi_next = j;
			bp = blist + j;
		}

		/* Insert strings in string table */
		bp->hi_namex = str_index;
		strlcpy(strtab + str_index, shp->name, strtab_sz - str_index);
		str_index += 1 + strlen(shp->name);

		bp->hi_pathx = str_index;
		strlcpy(strtab + str_index, shp->path, strtab_sz - str_index);
		str_index += 1 + strlen(shp->path);

		/* Copy versions */
		bcopy(shp->dewey, bp->hi_dewey, sizeof(bp->hi_dewey));
		bp->hi_ndewey = shp->ndewey;
	}

	/* Copy search directories */
	strlcpy(strtab + str_index, dir_list, strtab_sz - str_index);
	str_index += 1 + strlen(dir_list);

	/* Sanity check */
	if (str_index != strtab_sz)
		errx(1, "str_index(%d) != strtab_sz(%d)", str_index, strtab_sz);

	tmpfilenam = concat(_PATH_LD_HINTS, ".XXXXXXXXXX", "");
	if ((fd = mkstemp(tmpfilenam)) == -1) {
		warn("%s", tmpfilenam);
		goto out;
	}
	fchmod(fd, 0444);

	if (write(fd, &hdr, sizeof(struct hints_header)) !=
	    sizeof(struct hints_header)) {
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}
	if (write(fd, blist, hdr.hh_nbucket * sizeof(struct hints_bucket)) !=
	    hdr.hh_nbucket * sizeof(struct hints_bucket)) {
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}
	if (write(fd, strtab, strtab_sz) != strtab_sz) {
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}

	if (rename(tmpfilenam, _PATH_LD_HINTS) != 0) {
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}

	ret = 0;
out:
	if (fd != -1)
		close(fd);
	free(blist);
	free(strtab);
	return (ret);
}

static int
readhints(void)
{
	struct stat sb;
	struct hints_bucket *blist;
	struct hints_header *hdr;
	struct shlib_list *shp;
	caddr_t addr;
	char *strtab;
	long msize;
	int fd, i;

	if ((fd = open(_PATH_LD_HINTS, O_RDONLY, 0)) == -1) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}
	if (fstat(fd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	msize = (long)sb.st_size;
	addr = mmap(0, msize, PROT_READ, MAP_PRIVATE, fd, 0);

	if (addr == MAP_FAILED) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	hdr = (struct hints_header *)addr;
	if (HH_BADMAG(*hdr)) {
		warnx("%s: Bad magic: %lo",
		    _PATH_LD_HINTS, hdr->hh_magic);
		return -1;
	}

	if (hdr->hh_ehints > msize) {
		warnx("%s: hintsize greater than filesize: 0x%lx > 0x%lx ",
		    _PATH_LD_HINTS, hdr->hh_ehints, msize);
		    return -1;
	}

	if (hdr->hh_version != LD_HINTS_VERSION_2) {
		warnx("Unsupported version: %ld", hdr->hh_version);
		return -1;
	}

	close(fd);

	blist = (struct hints_bucket *)(addr + hdr->hh_hashtab);
	strtab = (char *)(addr + hdr->hh_strtab);

	dir_list = xstrdup(strtab + hdr->hh_dirlist);

	if (rescan)
		return (0);

	for (i = 0; i < hdr->hh_nbucket; i++) {
		struct hints_bucket	*bp = &blist[i];

		/* Sanity check */
		if (bp->hi_namex >= hdr->hh_strtab_sz) {
			warnx("Bad name index: %#x", bp->hi_namex);
			return -1;
		}
		if (bp->hi_pathx >= hdr->hh_strtab_sz) {
			warnx("Bad path index: %#x", bp->hi_pathx);
			return -1;
		}

		/* Allocate new list element */
		shp = (struct shlib_list *)xmalloc(sizeof *shp);
		shp->name = xstrdup(strtab + bp->hi_namex);
		shp->path = xstrdup(strtab + bp->hi_pathx);
		bcopy(bp->hi_dewey, shp->dewey, sizeof(shp->dewey));
		shp->ndewey = bp->hi_ndewey;
		shp->next = NULL;

		*shlib_tail = shp;
		shlib_tail = &shp->next;
	}
	return 0;
}

static void
listhints(void)
{
	struct shlib_list *shp;
	int i;

	printf("%s:\n", _PATH_LD_HINTS);
	printf("\tsearch directories: %s\n", dir_list);

	for (i = 0, shp = shlib_head; shp; i++, shp = shp->next)
		printf("\t%d:-l%s.%d.%d => %s\n",
		    i, shp->name, shp->major, shp->minor, shp->path);
}
@


1.35
log
@pledge "stdio rpath wpath cpath tmppath fattr"
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.34 2015/01/18 04:48:24 deraadt Exp $	*/
a51 2
#include "prebind.h"

a59 2
static int			delete;
static int			doprebind;
a62 1
int				safe;
d90 1
a90 1
	    "usage: %s [-DmPRrSsUv] [path ...]\n", __progname);
a119 3
		case 'S':
			safe = 1;
			break;
a122 6
		case 'D':
			delete = 1;
			break;
		case 'P':
			doprebind = 1;
			break;
a146 10

	if (delete) {
		if (rescan || unconfig || merge || justread || nostd || doprebind)
			errx(1, "cannot mix -U -R -r -s -P options with -D");
		exit(prebind_delete(&argv[optind]));
	} else if (doprebind) {
		if (rescan || unconfig || justread || nostd)
			errx(1, "cannot mix other options with -P");
		exit(prebind(&argv[optind]));
	}
@


1.34
log
@do not require <a.out.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.33 2015/01/16 16:18:07 deraadt Exp $	*/
d104 3
@


1.33
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.32 2013/12/30 21:58:07 deraadt Exp $	*/
a45 1
#include <a.out.h>
@


1.32
log
@When a function does not obviously terminate itself, it is good practice
to clean up a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.31 2013/11/13 05:41:42 deraadt Exp $	*/
a32 1
#include <sys/param.h>
d51 1
d205 1
a205 1
	char		name[MAXPATHLEN];
@


1.31
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.30 2013/10/18 14:44:39 deraadt Exp $	*/
d325 1
a325 1
	int strtab_sz = 0, nhints = 0, fd, i, ret = -1, str_index = 0;
a429 4
	if (close(fd) != 0) {
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}
d438 2
@


1.30
log
@does not need stab.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.29 2012/09/11 21:20:14 espie Exp $	*/
d92 1
a92 1
void
@


1.29
log
@prevent detection of bogus libraries
problem initially noticed by deraadt@@, exchanged various patches with
kettenis@@

decided to fix the bug now, even though ldconfig could probably use
a larger rewrite.

okay matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.28 2010/12/13 20:51:33 espie Exp $	*/
a47 1
#include <stab.h>
@


1.28
log
@rename() is the atomic operation, unlink() is just there to create
races between ldconfig and ld.so

(simple commit, hours of bug hunt...)

okay kettenis@@, deraad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.27 2010/03/30 17:42:50 zinovik Exp $	*/
a242 2
		if (!isdigit(*(cp+4)))
			continue;
d245 3
a247 2
		ndewey = getdewey(dewey, cp + 4);
		enter(dir, dp->d_name, name, dewey, ndewey);
@


1.27
log
@several missing closedir() calls

regress test run fine with this changes

ok deraadt@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.26 2009/08/19 19:38:17 bluhm Exp $	*/
a432 6
		warn("%s", _PATH_LD_HINTS);
		goto out;
	}

	/* Install it */
	if (unlink(_PATH_LD_HINTS) != 0 && errno != ENOENT) {
@


1.26
log
@In ldconfig the dewey field of shlib_list was only partially filled
as bcopy used the number of elements instead of the array's size.
As a consequence, the wrong version of a library could be selected
if the library had many minor numbers.
from Christian Rusch;  ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.25 2006/06/26 23:26:12 drahn Exp $	*/
d250 1
@


1.25
log
@build cleanly with -Wall -Werror
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.24 2006/06/19 20:44:27 jmc Exp $	*/
d292 1
a292 1
	bcopy(dewey, shp->dewey, MAXDEWEY);
@


1.24
log
@sort usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.23 2006/06/15 22:09:32 drahn Exp $	*/
d54 2
d492 1
a492 1
		warnx("%s: hintsize greater than filesize: 0x%x > 0x%x ",
@


1.23
log
@When writing a TXTBUSY file, make certain to preserve all file metadata,
also add -S flag, like install's -S flag to safely perform operations.
Getting it in so it gets tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.22 2006/05/18 17:00:06 deraadt Exp $	*/
d95 1
a95 1
	    "usage: %s [-DmPrRsSUv] [path ...]\n", __progname);
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.21 2006/05/13 16:33:40 deraadt Exp $	*/
d67 1
d95 1
a95 1
	    "usage: %s [-DmPrRsUv] [path ...]\n", __progname);
d105 1
a105 1
	while ((c = getopt(argc, argv, "DmPrRsUv")) != -1) {
d121 3
@


1.21
log
@some knf and delinting; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.20 2006/05/12 23:20:52 deraadt Exp $	*/
d158 1
a158 1
		exit (prebind_delete(&argv[optind]));
d162 1
a162 1
		exit (prebind(&argv[optind]));
@


1.20
log
@move the prebind code into ldconfig as the -P option.
next we will want to enhance the verbose mode, fix error handling,
and change the prebind delete code to use the same directory handling
code
ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.19 2006/05/11 22:03:22 deraadt Exp $	*/
d210 1
a210 1
		int n;
d320 1
a320 1
	int strtab_sz = 0, nhints = 0, fd, i, n, ret = -1, str_index = 0;
d324 2
a325 1
	char *strtab, *tmpfile;
d351 1
a351 1
	bzero((char *)blist, n);
d356 1
a356 1
	strtab = (char *)xmalloc(strtab_sz);
d366 1
a366 1
			int	i;
d368 2
a369 2
			for (i = 0; i < hdr.hh_nbucket; i++) {
				if (blist[i].hi_pathx == 0)
d372 1
a372 1
			if (i == hdr.hh_nbucket) {
d378 2
a379 2
			bp->hi_next = i;
			bp = blist + i;
d401 1
a401 1
	if (str_index != strtab_sz) {
a402 1
	}
d404 3
a406 3
	tmpfile = concat(_PATH_LD_HINTS, ".XXXXXXXXXX", "");
	if ((fd = mkstemp(tmpfile)) == -1) {
		warn("%s", tmpfile);
d436 1
a436 1
	if (rename(tmpfile, _PATH_LD_HINTS) != 0) {
d470 1
a470 1
	msize =  (long)sb.st_size;
@


1.19
log
@move prebind_strip(8) into ldconfig as the -D option; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.18 2006/04/11 15:21:40 ray Exp $	*/
d61 1
a61 1
static int			verbose;
d66 1
a66 1
static int			merge;
d94 1
a94 1
	    "usage: %s [-DmRrsUv] [path ...]\n", __progname);
d104 1
a104 1
	while ((c = getopt(argc, argv, "DRmrsUv")) != -1) {
d127 2
a128 2
//		case 'P':
//			doprebind = 1;
a141 6
	if (delete) {
		if (rescan || unconfig || merge || justread || nostd || doprebind)
			errx(1, "cannot mix -U -R -r -s -P options with -D");
		exit (prebind_delete(&argv[optind], verbose));
	}

d155 9
a163 5
//	if (doprebind) {
//		if (rescan || unconfig || justread || nostd)
//			errx(1, "cannot mix other options with -P");
//		exit (prebind(&argv[optind], verbose, merge));
//	}
@


1.18
log
@Plug memory leaks.

Spotted by NetBSD Coverity CID 1603, improvements by jaredy@@ and
otto@@.

OK otto@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.17 2005/12/31 15:08:22 jmc Exp $	*/
d62 2
d90 8
d104 1
a104 1
	while ((c = getopt(argc, argv, "RUmrsv")) != -1) {
d124 6
d131 1
a131 3
			fprintf(stderr,
			    "usage: %s [-mRrsUv] [dir ...]\n", __progname);
			exit(1);
d142 6
d158 8
a165 3
	} else
		if (!nostd)
			std_search_path();
@


1.17
log
@sort options and sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.16 2004/08/14 03:08:24 drahn Exp $	*/
d297 1
a297 1
	int strtab_sz = 0, nhints = 0, fd, i, n, str_index = 0;
d350 1
a350 1
				return -1;
d384 1
a384 1
		return -1;
d391 1
a391 1
		return -1;
d396 1
a396 1
		return -1;
d400 1
a400 1
		return -1;
d404 1
a404 1
		return -1;
d410 1
a410 1
		return -1;
d415 1
a415 1
		return -1;
d418 5
a422 1
	return 0;
@


1.16
log
@When reading the ld.so hints file, map the entire file in a single mmap
instead of assuming the region after the first mmap is available. Same
change was made to ELF ld.so previously. ok deraadt miod pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.15 2003/11/21 08:56:34 djm Exp $	*/
d116 1
a116 1
			    "usage: %s [-RUmrsv] [dir ...]\n", __progname);
@


1.15
log
@oops, it wasn't that diff that tedu@@ ok'd - revert for now
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.13 2003/07/06 20:04:00 deraadt Exp $	*/
d424 1
d437 5
d443 1
a443 1
	msize = PAGSIZ;
d458 6
a468 9
	if (hdr->hh_ehints > msize) {
		if (mmap(addr+msize, hdr->hh_ehints - msize,
		    PROT_READ, MAP_PRIVATE|MAP_FIXED,
		    fd, msize) != (caddr_t)(addr+msize)) {

			warn("%s", _PATH_LD_HINTS);
			return -1;
		}
	}
@


1.14
log
@add output file and path stripping options useful for pre-generating
ld.so.hints for dynamic ramdisks. idea from markus@@ manpage nits jmc@@ ok tedu@@
@
text
@a58 6
#if DEBUG
/* test */
#undef _PATH_LD_HINTS
#define _PATH_LD_HINTS		"./ld.so.hints"
#endif

d83 4
a86 4
static int	dodir(char *, const char *, int);
static int	buildhints(const char *);
static int	readhints(const char *);
static void	listhints(const char *);
a92 1
	char path[PATH_MAX], *strip = NULL;
d94 1
a94 2
	strlcpy(path, _PATH_LD_HINTS, sizeof(path));
	while ((c = getopt(argc, argv, "RUmrsvf:S:")) != -1) {
a95 3
		case 'f':
			strlcpy(path, optarg, sizeof(path));
			break;
a98 3
		case 'S':
			strip = optarg;
			break;
d115 2
a116 2
			fprintf(stderr, "usage: %s [-RUmrsv] [-f hints_file] "
			    "[-S strip_path] [dir ...]\n", __progname);
d129 1
a129 1
		if ((rval = readhints(path)) != 0)
d132 1
a132 1
			listhints(path);
d164 1
a164 1
		rval |= dodir(search_dirs[i], strip, 0);
d167 1
a167 1
	rval |= buildhints(path);
d173 1
a173 1
dodir(char *dir, const char *strip, int silent)
d178 1
a178 4
	int		dewey[MAXDEWEY], ndewey, doff = 0;

	if (strip != NULL && strncmp(dir, strip, strlen(strip)) == 0)
		doff = strlen(strip);
d219 1
a219 1
		enter(dir + doff, dp->d_name, name, dewey, ndewey);
d271 7
d295 1
a295 1
buildhints(const char *path)
d381 1
a381 1
	tmpfile = concat(path, ".XXXXXXXXXX", "");
d390 1
a390 1
		warn("%s", path);
d395 1
a395 1
		warn("%s", path);
d399 1
a399 1
		warn("%s", path);
d403 1
a403 1
		warn("%s", path);
d408 2
a409 2
	if (unlink(path) != 0 && errno != ENOENT) {
		warn("%s", path);
d413 2
a414 2
	if (rename(tmpfile, path) != 0) {
		warn("%s", path);
d422 1
a422 1
readhints(const char *path)
d432 2
a433 2
	if ((fd = open(path, O_RDONLY, 0)) == -1) {
		warn("%s", path);
d441 1
a441 1
		warn("%s", path);
d448 1
a448 1
		    path, hdr->hh_magic);
d462 1
a462 1
			warn("%s", path);
d504 1
a504 1
listhints(const char *path)
d509 1
a509 1
	printf("%s:\n", path);
@


1.13
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.12 2002/07/30 22:25:27 deraadt Exp $	*/
d59 6
d89 4
a92 4
static int	dodir(char *, int);
static int	buildhints(void);
static int	readhints(void);
static void	listhints(void);
d99 1
d101 2
a102 1
	while ((c = getopt(argc, argv, "RUmrsv")) != -1) {
d104 3
d110 3
d129 2
a130 2
			fprintf(stderr,
			    "usage: %s [-RUmrsv] [dir ...]\n", __progname);
d143 1
a143 1
		if ((rval = readhints()) != 0)
d146 1
a146 1
			listhints();
d178 1
a178 1
		rval |= dodir(search_dirs[i], 0);
d181 1
a181 1
	rval |= buildhints();
d187 1
a187 1
dodir(char *dir, int silent)
d192 4
a195 1
	int		dewey[MAXDEWEY], ndewey;
d236 1
a236 1
		enter(dir, dp->d_name, name, dewey, ndewey);
a287 7

#if DEBUG
/* test */
#undef _PATH_LD_HINTS
#define _PATH_LD_HINTS		"./ld.so.hints"
#endif

d305 1
a305 1
buildhints(void)
d391 1
a391 1
	tmpfile = concat(_PATH_LD_HINTS, ".XXXXXXXXXX", "");
d400 1
a400 1
		warn("%s", _PATH_LD_HINTS);
d405 1
a405 1
		warn("%s", _PATH_LD_HINTS);
d409 1
a409 1
		warn("%s", _PATH_LD_HINTS);
d413 1
a413 1
		warn("%s", _PATH_LD_HINTS);
d418 2
a419 2
	if (unlink(_PATH_LD_HINTS) != 0 && errno != ENOENT) {
		warn("%s", _PATH_LD_HINTS);
d423 2
a424 2
	if (rename(tmpfile, _PATH_LD_HINTS) != 0) {
		warn("%s", _PATH_LD_HINTS);
d432 1
a432 1
readhints(void)
d442 2
a443 2
	if ((fd = open(_PATH_LD_HINTS, O_RDONLY, 0)) == -1) {
		warn("%s", _PATH_LD_HINTS);
d451 1
a451 1
		warn("%s", _PATH_LD_HINTS);
d458 1
a458 1
		    _PATH_LD_HINTS, hdr->hh_magic);
d472 1
a472 1
			warn("%s", _PATH_LD_HINTS);
d514 1
a514 1
listhints(void)
d519 1
a519 1
	printf("%s:\n", _PATH_LD_HINTS);
@


1.12
log
@knf & ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.11 2002/05/24 19:00:17 drahn Exp $	*/
d278 1
a278 1
int
d297 5
a301 9
	struct hints_header	hdr;
	struct hints_bucket	*blist;
	struct shlib_list	*shp;
	char			*strtab;
	int			i, n, str_index = 0;
	int			strtab_sz = 0;	/* Total length of strings */
	int			nhints = 0;	/* Total number of hints */
	int			fd;
	char			*tmpfile;
d424 7
a430 7
	int			fd, i;
	caddr_t			addr;
	long			msize;
	struct hints_header	*hdr;
	struct hints_bucket	*blist;
	char			*strtab;
	struct shlib_list	*shp;
d506 2
a507 2
	struct shlib_list	*shp;
	int			i;
@


1.11
log
@Replace strcpy() with strlcpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.10 2002/05/24 04:17:00 deraadt Exp $	*/
d89 1
a89 3
main(argc, argv)
int	argc;
char	*argv[];
d91 2
a92 2
	int		i, c;
	int		rval = 0;
d161 1
d173 1
a173 3
dodir(dir, silent)
char	*dir;
int	silent;
d225 1
a225 3
enter(dir, file, name, dewey, ndewey)
char	*dir, *file, *name;
int	dewey[], ndewey;
d279 1
a279 3
hinthash(cp, vmajor, vminor)
char	*cp;
int	vmajor, vminor;
d295 1
a295 1
buildhints()
d398 1
a398 1
		  hdr.hh_nbucket * sizeof(struct hints_bucket)) {
d426 1
a426 1
readhints()
d428 1
a428 1
	int			fd;
a434 1
	int			i;
d452 1
a452 1
			_PATH_LD_HINTS, hdr->hh_magic);
d463 2
a464 2
				PROT_READ, MAP_PRIVATE|MAP_FIXED,
				fd, msize) != (caddr_t)(addr+msize)) {
a503 1

d508 1
a508 1
listhints()
a518 2

	return;
@


1.10
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.9 2002/05/24 03:44:37 deraadt Exp $	*/
d371 1
a371 1
		strcpy(strtab + str_index, shp->name);
d375 1
a375 1
		strcpy(strtab + str_index, shp->path);
d384 1
a384 1
	strcpy(strtab + str_index, dir_list);
@


1.9
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.8 2002/05/22 06:35:44 deraadt Exp $	*/
d17 1
a17 1
 *      This product includes software developed by Paul Kranenburg.
@


1.8
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.7 2002/02/16 21:27:30 millert Exp $	*/
d117 2
a118 2
			(void)fprintf(stderr,
				"usage: %s [-RUmrsv] [dir ...]\n", __progname);
a223 1

d244 2
a245 2
					shp->name, shp->major, shp->minor,
					dir, file);
d334 1
a334 1
					nhints, hdr.hh_nbucket, strtab_sz);
d349 2
a350 2
		bp = blist +
		  (hinthash(shp->name, shp->major, shp->minor) % hdr.hh_nbucket);
d527 1
a527 1
			i, shp->name, shp->major, shp->minor, shp->path);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.6 2001/12/07 18:45:32 mpech Exp $	*/
d200 1
a200 1
		(void)strcpy(name, dp->d_name + 3);
@


1.7.2.1
log
@Pull in patch from current:
Fix (drahn):
Replace strcpy() with strlcpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.7 2002/02/16 21:27:30 millert Exp $	*/
d372 1
a372 1
		strlcpy(strtab + str_index, shp->name, strtab_sz - str_index);
d376 1
a376 1
		strlcpy(strtab + str_index, shp->path, strtab_sz - str_index);
d385 1
a385 1
	strlcpy(strtab + str_index, dir_list, strtab_sz - str_index);
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.5 2001/10/24 13:06:35 mpech Exp $	*/
d82 5
a86 5
static void	enter __P((char *, char *, char *, int *, int));
static int	dodir __P((char *, int));
static int	buildhints __P((void));
static int	readhints __P((void));
static void	listhints __P((void));
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.4 2001/05/11 13:31:42 art Exp $	*/
d190 2
a191 2
		register int n;
		register char *cp;
@


1.4
log
@mmap returns MAP_FAILED when it fails, not -1
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.3 2001/05/11 13:28:09 art Exp $	*/
d96 1
a96 1
	while ((c = getopt(argc, argv, "RUmrsv")) != EOF) {
@


1.3
log
@MAP_COPY -> MAP_PRIVATE
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.2 2001/01/30 02:39:06 brad Exp $	*/
d453 1
a453 1
	if (addr == (caddr_t)-1) {
@


1.2
log
@sync with a.out ldconfig, adds missing -U option. Reviewed by: drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.1.1.1 2000/06/13 03:40:19 rahnds Exp $	*/
d451 1
a451 1
	addr = mmap(0, msize, PROT_READ, MAP_COPY, fd, 0);
d472 1
a472 1
				PROT_READ, MAP_COPY|MAP_FIXED,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.7 2000/01/27 22:14:57 form Exp $	*/
d66 1
d96 1
a96 1
	while ((c = getopt(argc, argv, "Rmrsv")) != EOF) {
d101 3
d117 3
a119 2
			errx(1, "Usage: %s [-mrsv] [dir ...]",
				__progname);
d124 3
a136 5
	}

	if (!nostd && !merge)
		std_search_path();
	if (rescan)
d138 22
d161 2
a162 6
	for (i = 0; i < n_search_dirs; i++)
		rval |= dodir(search_dirs[i], 1);

	for (i = optind; i < argc; i++) {
		/* Check for duplicates? */
		char *cp = concat(dir_list, *dir_list?":":"", argv[i]);
d165 1
a165 1
		rval |= dodir(argv[i], 0);
d249 1
a249 2
			if ((shp->name = strdup(name)) == NULL)
				errx(1, "virtual memory exhausted");
d267 1
a267 2
	if ((shp->name = strdup(name)) == NULL)
		errx(1, "virtual memory exhausted");
d484 4
a487 13
	if (justread || !rescan) {
		for (i = 0; i < hdr->hh_nbucket; i++) {
			struct hints_bucket	*bp = &blist[i];

			/* Sanity check */
			if (bp->hi_namex >= hdr->hh_strtab_sz) {
				warnx("Bad name index: %#x", bp->hi_namex);
				return -1;
			}
			if (bp->hi_pathx >= hdr->hh_strtab_sz) {
				warnx("Bad path index: %#x", bp->hi_pathx);
				return -1;
			}
d489 2
a490 9
			/* Allocate new list element */
			shp = (struct shlib_list *)xmalloc(sizeof *shp);
			if ((shp->name = strdup(strtab + bp->hi_namex)) == NULL)
				errx(1, "virtual memory exhausted");
			if ((shp->path = strdup(strtab + bp->hi_pathx)) == NULL)
				errx(1, "virtual memory exhausted");
			bcopy(bp->hi_dewey, shp->dewey, sizeof(shp->dewey));
			shp->ndewey = bp->hi_ndewey;
			shp->next = NULL;
d492 4
a495 2
			*shlib_tail = shp;
			shlib_tail = &shp->next;
d497 15
a512 3

	if ((dir_list = strdup(strtab + hdr->hh_dirlist)) == NULL)
		errx(1, "virtual memory exhausted");
@


1.1.1.1
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems 
such as correctness and security.

@
text
@@
