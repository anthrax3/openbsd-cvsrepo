head	1.15;
access;
symbols
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.8
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.15
date	2016.07.04.20.56.50;	author kettenis;	state dead;
branches;
next	1.14;
commitid	roU3LTBV1W77FE1g;

1.14
date	2015.12.17.18.37.58;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	ycJi4KhOsGdNlB5W;

1.13
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.12;
commitid	GouatFiJVxwlAVIQ;

1.12
date	2013.05.04.09.23.33;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.21.04.28.45;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.30.17.42.50;	author zinovik;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.08.02.40.49;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.28.21.38.05;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.26.23.26.12;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.15.22.09.32;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.17.02.59.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.13.16.33.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.12.23.20.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.11.22.19.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.11.22.03.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Nuke prebind support; it's unworkable and we're never going to finish it.

ok guenther@@, deraadt@@
@
text
@/* $OpenBSD: prebind_delete.c,v 1.14 2015/12/17 18:37:58 mmcc Exp $ */

/*
 * Copyright (c) 2006 Dale Rahn <drahn@@dalerahn.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/exec_elf.h>
#include <elf_abi.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include "prebind.h"

#define BUFSZ (256 * 1024)

int	strip_prebind(char *file);
int	prebind_remove_load_section(int fd, char *name);
int	prebind_newfile(int fd, char *name, struct stat *st, off_t orig_size);
int	strip_file_or_dir(char *name);
int	strip_dir(char *dir);

extern	int verbose;

int
prebind_delete(char **argv)
{
	while (*argv) {
		if (strip_file_or_dir(*argv) == -1)
			return (1);
		argv++;
	}
	return (0);
}

int
strip_file_or_dir(char *name)
{
	struct stat sb;
	int ret = -1;

	ret = lstat(name, &sb);
	if (ret != 0)
		return 0;
	switch (sb.st_mode & S_IFMT) {
	case S_IFREG:
		ret =  strip_prebind(name);
		break;
	case S_IFDIR:
		if (verbose > 0)
			printf("loading dir %s\n", name);
		ret = strip_dir(name);
		break;
	default:
		; /* links and other files we skip */
		ret = 0;
	}
	return ret;
}

int
strip_dir(char *dir)
{
	struct dirent *dp;
	struct stat sb;
	DIR *dirp;
	char *buf;
	int ret;

	dirp = opendir(dir);

	/* if dir failed to open, skip */
	if (dirp == NULL)
		return 0;

	ret = 0;
	while ((dp = readdir(dirp)) != NULL && ret != -1) {
		ret = -1;
		switch (dp->d_type) {
		case DT_UNKNOWN:
			/*
			 * NFS will return unknown, since load_file
			 * does stat the file, this just
			 */
			if (asprintf(&buf, "%s/%s", dir, dp->d_name) == -1) {
				if (verbose)
					warn("asprintf");
				goto done;
			}
			lstat(buf, &sb);
			if (sb.st_mode == S_IFREG)
				ret = strip_prebind(buf);
			free(buf);
			break;
		case DT_REG:
			if (asprintf(&buf, "%s/%s", dir, dp->d_name) == -1) {
				if (verbose)
					warn("asprintf");
				goto done;
			}
			ret = strip_prebind(buf);
			free(buf);
			break;
		default:
			/* other files symlinks, dirs, ... we ignore */
			ret = 0;
			;
		}
	}
done:
	closedir(dirp);
	return ret;
}

int
strip_prebind(char *file)
{
	struct prebind_footer footer;
	extern char *__progname;
	int fd, rdonly = 0;
	struct stat st;
	ssize_t bytes;

	fd = open(file, O_RDWR);
	if (fd == -1 && errno == ETXTBSY) {
		fd = open(file, O_RDONLY);
		rdonly = 1;
	}
	if (fd == -1) {
		warn("%s", file);
		return (-1);
	}

	if (fstat(fd, &st) == -1)
		return (-1);

	lseek(fd, -((off_t)sizeof(struct prebind_footer)), SEEK_END);
	bytes = read(fd, &footer, sizeof(struct prebind_footer));
	if (bytes != sizeof(struct prebind_footer))
		goto done;

	if (footer.bind_id[0] != BIND_ID0 || footer.bind_id[1] != BIND_ID1 ||
	    footer.bind_id[2] != BIND_ID2 || footer.bind_id[3] != BIND_ID3) {
		if (verbose)
			fprintf(stderr, "%s: no prebind header\n", file);
		goto done;
	}

	if (rdonly) {
		fd = prebind_newfile(fd, file, &st, footer.orig_size);
	} else {
		prebind_remove_load_section(fd, file);
		ftruncate(fd, footer.orig_size);
	}

	if (verbose)
		fprintf(stderr, "%s: stripped %lld bytes from %s\n",
		    __progname, st.st_size - footer.orig_size, file);

done:
	if (fd != -1)
		close(fd);
	return (0);
}

int
prebind_remove_load_section(int fd, char *name)
{
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdr;
	int loadsection;
	char *buf;

	buf = mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_FILE | MAP_SHARED,
	    fd, 0);
	if (buf == MAP_FAILED) {
		if (verbose)
			warn("%s: cannot mmap for for write", name);
		return (-1);
	}

	ehdr = (Elf_Ehdr *)buf;
	phdr = (Elf_Phdr *)(buf + ehdr->e_phoff);
	loadsection = ehdr->e_phnum - 1;

	if (ehdr->e_type != ET_EXEC ||
	    (phdr[loadsection].p_flags & 0x08000000) == 0)
		goto done;

	if (phdr[loadsection].p_type != PT_LOAD ||
	    ((phdr[loadsection].p_flags & 0x08000000) == 0)) {
		/* doesn't look like ours */
		if (verbose)
			fprintf(stderr, "mapped, %s id doesn't match %lx\n", name,
			    (long)(phdr[loadsection].p_vaddr));
		goto done;
	}

	bzero(&phdr[loadsection], sizeof(Elf_Phdr));
	ehdr->e_phnum--;
done:
	munmap(buf, 8192);
	return (0);
}

int
prebind_newfile(int infd, char *name, struct stat *st, off_t orig_size)
{
	struct timespec ts[2];
	char *newname, *buf;
	ssize_t len, wlen;
	int outfd;

	if (asprintf(&newname, "%s.XXXXXXXXXX", name) == -1) {
		if (verbose)
			warn("asprintf");
		return (-1);
	}
	outfd = open(newname, O_CREAT|O_RDWR|O_TRUNC, 0600);
	if (outfd == -1) {
		warn("%s", newname);
		free(newname);
		return (-1);
	}

	buf = malloc(BUFSZ);
	if (buf == NULL) {
		if (verbose)
			warn("malloc");
		goto fail;
	}

	/* copy old file to new file */
	lseek(infd, (off_t)0, SEEK_SET);
	while (1) {
		len = read(infd, buf, BUFSIZ);
		if (len == -1) {
			if (verbose)
				warn("read");
			free(buf);
			goto fail;
		}
		if (len == 0)
			break;
		wlen = write(outfd, buf, len);
		if (wlen != len) {
			free(buf);
			goto fail;
		}
	}
	free(buf);
	close (infd);

	/* now back track, and delete the header */
	if (prebind_remove_load_section(outfd, newname) == -1)
		goto fail;
	if (orig_size != (off_t)-1 &&
	    ftruncate(outfd, orig_size) == -1)
		goto fail;

	/* move new file into place */
	ts[0] = st->st_atimespec;
	ts[1] = st->st_mtimespec;
	if (futimens(outfd, ts) == -1)
		goto fail;
	if (fchown(outfd, st->st_uid, st->st_gid) == -1)
		goto fail;
	if (fchmod(outfd, st->st_mode) == -1)
		goto fail;
	if (fchflags(outfd, st->st_flags) == -1)
		goto fail;
	if (rename(newname, name) == -1)
		goto fail;

	return (outfd);

fail:
	unlink(newname);
	free(newname);
	close(outfd);
	return (-1);
}
@


1.14
log
@s/failes/failed/g
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.13 2015/06/03 02:24:36 millert Exp $ */
@


1.13
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.12 2013/05/04 09:23:33 jsg Exp $ */
d91 1
a91 1
	/* if dir failes to open, skip */
@


1.12
log
@fix use after free in error paths
ok sthen@@ jung@@ fgsch@@
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.11 2012/03/21 04:28:45 matthew Exp $ */
d104 5
a108 1
			asprintf(&buf, "%s/%s", dir, dp->d_name);
d115 5
a119 1
			asprintf(&buf, "%s/%s", dir, dp->d_name);
d129 1
@


1.11
log
@Switch ld.so's _dl_opendir functions to use a locally defined
_dl_dirdesc struct (containing just the fields ld.so's implementation
actually needs) instead of reusing libc's _dirdesc struct.

Also, switch ldconfig to use futimens() instead of futimes().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.10 2010/03/30 17:42:50 zinovik Exp $ */
d288 1
a289 1
	unlink(newname);
@


1.10
log
@several missing closedir() calls

regress test run fine with this changes

ok deraadt@@, drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.9 2008/06/08 02:40:49 drahn Exp $ */
d219 1
a219 1
	struct timeval tv[2];
d272 3
a274 3
	TIMESPEC_TO_TIMEVAL(&tv[0], &st->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &st->st_mtimespec);
	if (futimes(outfd, tv) == -1)
@


1.9
log
@When prebind_newfile() is called the input file is replaced with the new
file, thus leaking the file descriptor, close the input file when it done.
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.8 2006/07/28 21:38:05 drahn Exp $ */
d121 1
@


1.8
log
@Only stop processing prebind deletion if an actual error occurs.
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.7 2006/06/26 23:26:12 drahn Exp $ */
d261 1
@


1.7
log
@build cleanly with -Wall -Werror
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.6 2006/06/15 22:09:32 drahn Exp $ */
d75 1
d77 1
a77 1
	return -1;
@


1.6
log
@When writing a TXTBUSY file, make certain to preserve all file metadata,
also add -S flag, like install's -S flag to safely perform operations.
Getting it in so it gets tested.
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.5 2006/05/17 02:59:08 deraadt Exp $ */
d30 1
d39 2
d63 1
a63 1
		return;
d92 1
a92 1
		return;
d94 1
@


1.5
log
@prep prebind_newfile() for reuse by dale in prebind; ok drahn
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.4 2006/05/13 16:33:40 deraadt Exp $ */
d29 1
d45 1
a45 1
		if (strip_prebind(*argv) == -1)
d50 67
@


1.4
log
@some knf and delinting; ok drahn
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.3 2006/05/12 23:20:52 deraadt Exp $ */
d36 1
a36 2
int	prebind_newfile(int fd, char *name, struct stat *st,
	    struct prebind_footer *footer);
d86 1
a86 1
		fd = prebind_newfile(fd, file, &st, &footer);
d143 1
a143 2
prebind_newfile(int infd, char *name, struct stat *st,
    struct prebind_footer *footer)
d192 2
a193 1
	if (ftruncate(outfd, footer->orig_size) == -1)
@


1.3
log
@move the prebind code into ldconfig as the -P option.
next we will want to enhance the verbose mode, fix error handling,
and change the prebind delete code to use the same directory handling
code
ok drahn
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.2 2006/05/11 22:19:23 deraadt Exp $ */
a43 2
	extern char *__progname;

@


1.2
log
@use CFLAGS with -I to reach for prebind.h
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_delete.c,v 1.1 2006/05/11 22:03:22 deraadt Exp $ */
d22 1
d34 2
a35 2
int	strip_prebind(char *file, int verbose);
int	prebind_remove_load_section(int fd, char *name, int verbose);
d37 3
a39 1
	    struct prebind_footer *footer, int verbose);
d42 1
a42 1
prebind_delete(char **argv, int verbose)
d47 1
a47 1
		if (strip_prebind(*argv, verbose) == -1)
d55 1
a55 1
strip_prebind(char *file, int verbose)
d89 1
a89 1
		fd = prebind_newfile(fd, file, &st, &footer, verbose);
d91 1
a91 1
		prebind_remove_load_section(fd, file, verbose);
d106 1
a106 1
prebind_remove_load_section(int fd, char *name, int verbose)
d147 1
a147 1
    struct prebind_footer *footer, int verbose)
d194 1
a194 1
	if (prebind_remove_load_section(outfd, newname, verbose) == -1)
@


1.1
log
@move prebind_strip(8) into ldconfig as the -D option; ok drahn
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_strip.c,v 1.4 2006/05/08 20:37:01 deraadt Exp $ */
d29 1
a29 1
#include "../prebind.h"
@

