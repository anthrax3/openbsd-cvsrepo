head	1.7;
access;
symbols
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.30
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.7
date	2016.07.04.20.56.50;	author kettenis;	state dead;
branches;
next	1.6;
commitid	roU3LTBV1W77FE1g;

1.6
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	31KwZ9PARAKUg1ob;

1.5
date	2013.12.03.01.47.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.18.17.00.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.14.21.09.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.13.05.58.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.12.23.20.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Nuke prebind support; it's unworkable and we're never going to finish it.

ok guenther@@, deraadt@@
@
text
@/* $OpenBSD: debug.c,v 1.6 2015/01/16 16:18:07 deraadt Exp $ */
/*
 * Copyright (c) 2006 Dale Rahn <drahn@@dalerahn.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <limits.h>
#include <fcntl.h>
#include <nlist.h>
#include <elf_abi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include "resolve.h"
#include "link.h"
#include "sod.h"
#ifndef __mips64__
#include "machine/reloc.h"
#endif
#include "prebind.h"
#include "prebind_struct.h"

#ifdef DEBUG1
void
dump_info(struct elf_object *object)
{
	int numrel, numrela, i;
	const Elf_Sym	*symt;
	const char	*strt;
	Elf_Word *needed_list;

	symt = object->dyn.symtab;
	strt = object->dyn.strtab;

	for (i = 0; i < object->nchains; i++) {
		const Elf_Sym *sym = symt + i;
		char *type;

		switch (ELF_ST_TYPE(sym->st_info)) {
		case STT_FUNC:
			type = "func";
			break;
		case STT_OBJECT:
			type = "object";
			break;
		case STT_NOTYPE:
			type = "notype";
			break;
		default:
			type = "UNKNOWN";
		}
		printf("symbol %d [%s] type %s value %x\n", i,
		    strt + sym->st_name,
		    type, sym->st_value);
	}

	numrel = object->dyn.relsz / sizeof(Elf_Rel);
	numrela = object->dyn.relasz / sizeof(Elf_RelA);
	printf("numrel %d numrela %d\n", numrel, numrela);

	printf("rel relocations:\n");
	for (i = 0; i < numrel ; i++) {
		Elf_Rel *rel = object->dyn.rel;

		printf("%d: %x sym %x type %d\n", i, rel[i].r_offset,
		    ELF_R_SYM(rel[i].r_info), ELF_R_TYPE(rel[i].r_info));
	}
	printf("rela relocations:\n");
	for (i = 0; i < numrela ; i++) {
		Elf_RelA *rela = object->dyn.rela;

		printf("%d: %x sym %x type %d\n", i, rela[i].r_offset,
		    ELF_R_SYM(rela[i].r_info), ELF_R_TYPE(rela[i].r_info));
	}
	needed_list = (Elf_Addr *)object->dyn.needed;
	for (i = 0; needed_list[i] != NULL; i++)
		printf("NEEDED %s\n", needed_list[i] + strt);

}
#endif


void
elf_dump_footer(struct prebind_footer *footer)
{
	printf("\nbase %llx\n", (long long)footer->prebind_base);
	printf("nameidx_idx %d\n", footer->nameidx_idx);
	printf("symcache_idx %d\n", footer->symcache_idx);
	printf("pltsymcache_idx %d\n", footer->pltsymcache_idx);
	printf("fixupcnt_idx %d\n", footer->fixupcnt_idx);
	printf("fixup_cnt %d\n", footer->fixup_cnt);
	printf("nametab_idx %d\n", footer->nametab_idx);
	printf("symcache_cnt %d\n", footer->symcache_cnt);
	printf("pltsymcache_cnt %d\n", footer->pltsymcache_cnt);
	printf("fixup_cnt %d\n", footer->fixup_cnt);
	printf("numlibs %d\n", footer->numlibs);
	printf("id0 %x\n", footer->id0);
	printf("id1 %x\n", footer->id1);
	printf("orig_size %lld\n", (long long)footer->orig_size);
	printf("version %d\n", footer->prebind_version);
	printf("bind_id %c%c%c%c\n", footer->bind_id[0],
	    footer->bind_id[1], footer->bind_id[2], footer->bind_id[3]);
}


void
dump_symcachetab(struct symcachetab *symcachetab, int symcache_cnt,
    struct elf_object *object, int id)
{
	int i;

	printf("symcache for %s\n", object->load_name);
	for (i = 0; i < symcache_cnt; i++) {
		printf("symidx %d: obj %d sym %d\n",
		    symcachetab[i].idx,
		    symcachetab[i].obj_idx,
		    symcachetab[i].sym_idx);
	}
}

void
elf_print_prog_list(prog_list_ty *prog_list)
{
	struct elf_object *object;
	struct proglist *pl;

	TAILQ_FOREACH(pl, prog_list, list) {
		object = TAILQ_FIRST(&(pl->curbin_list))->object;
		printf("bin: %s\n", object->load_name);
		elf_print_curbin_list(pl);
	}
}

void
elf_print_curbin_list(struct proglist *bin)
{
	struct objlist *ol;

	TAILQ_FOREACH(ol, &(bin->curbin_list), list) {
		printf("\t%s\n", ol->object->load_name);
	}
}

@


1.6
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.5 2013/12/03 01:47:06 deraadt Exp $ */
@


1.5
log
@stop using sys/syslimits.h directly, and use limits.h
prodded by millert
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.4 2006/05/18 17:00:06 deraadt Exp $ */
a19 1
#include <sys/param.h>
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.3 2006/05/14 21:09:47 deraadt Exp $ */
a19 1
#include <sys/syslimits.h>
d22 1
@


1.3
log
@use __mips64__
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.2 2006/05/13 05:58:42 deraadt Exp $ */
d139 1
a139 1
elf_print_prog_list (prog_list_ty *prog_list)
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.1 2006/05/12 23:20:52 deraadt Exp $ */
d34 1
a34 1
#ifndef __mips64
@


1.1
log
@move the prebind code into ldconfig as the -P option.
next we will want to enhance the verbose mode, fix error handling,
and change the prebind delete code to use the same directory handling
code
ok drahn
@
text
@d1 1
a1 1
/* $OpenBSD: debug.c,v 1.4 2006/05/08 20:39:44 deraadt Exp $ */
d34 1
d36 1
d45 2
a46 2
	const Elf_Sym   *symt;
        const char      *strt;
d50 1
a50 1
        strt = object->dyn.strtab;
d58 1
a58 1
			type =  "func";
d61 1
a61 1
			type =  "object";
d64 1
a64 1
			type =  "notype";
d74 1
a74 1
        numrel = object->dyn.relsz / sizeof(Elf_Rel);
a75 1

d80 2
a81 1
		Elf_Rel *rel =  object->dyn.rel;
d87 2
a88 1
		Elf_RelA *rela =  object->dyn.rela;
d93 1
a93 1
	for (i = 0; needed_list[i] != NULL; i++) {
a94 1
	}
@

