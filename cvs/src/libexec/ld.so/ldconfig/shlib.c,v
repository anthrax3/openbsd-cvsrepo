head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.10
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.36
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.34
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.30
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.28
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.26
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	r20000612:1.1.1.1
	dsr:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.22.08.15.05;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	ndl5BIvFpTKLuTk1;

1.11
date	2015.01.18.04.48.24;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	eRoBhNqhtj9qy8AW;

1.10
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	31KwZ9PARAKUg1ob;

1.9
date	2006.05.13.16.33.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.22.25.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.30.02.39.06;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.40.21;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.40.21;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove a couple needless allocation casts. No binary change.
@
text
@/*	$OpenBSD: shlib.c,v 1.11 2015/01/18 04:48:24 deraadt Exp $	*/
/*	$NetBSD: shlib.c,v 1.13 1998/04/04 01:00:29 fvdl Exp $	*/

/*
 * Copyright (c) 1993 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <ranlib.h>
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ld.h"

/*
 * Standard directories to search for files specified by -l.
 */
#ifndef STANDARD_SEARCH_DIRS
#define	STANDARD_SEARCH_DIRS	"/usr/lib"
#endif

/*
 * Actual vector of library search directories,
 * including `-L'ed and LD_LIBRARY_PATH spec'd ones.
 */
char	 **search_dirs;
int	n_search_dirs;

char	*standard_search_dirs[] = {
	STANDARD_SEARCH_DIRS
};

void
add_search_dir(char *name)
{
	size_t len;
	int i;

	len = strlen(name);

	while (len > 1 && name[len - 1] == '/')
		--len;

	for (i = 0; i < n_search_dirs; i++)
		if (strlen(search_dirs[i]) == len &&
		    !strncmp(search_dirs[i], name, len))
				return;
	n_search_dirs++;
	search_dirs = xrealloc(search_dirs,
	    n_search_dirs * sizeof search_dirs[0]);
	search_dirs[n_search_dirs - 1] = xmalloc(++len);
	(void)strlcpy(search_dirs[n_search_dirs - 1], name, len);
}

void
remove_search_dir(char *name)
{
	size_t	len;
	int	i;

	len = strlen(name);

	while (len > 1 && name[len - 1] == '/')
		--len;

	for (i = 0; i < n_search_dirs; i++) {
		if (strlen(search_dirs[i]) != len ||
		    strncmp(search_dirs[i], name, len))
			continue;
		free(search_dirs[i]);
		if (i < (n_search_dirs - 1))
			bcopy(&search_dirs[i+1], &search_dirs[i],
			    (n_search_dirs - i - 1) * sizeof search_dirs[0]);
		n_search_dirs--;
		search_dirs = xrealloc(search_dirs,
		    n_search_dirs * sizeof search_dirs[0]);
		break;
	}
}

void
add_search_path(char *path)
{
	char	*cp, *dup;

	if (path == NULL)
		return;

	/* Add search directories from `path' */
	path = dup = strdup(path);
	while ((cp = strsep(&path, ":")) != NULL)
		add_search_dir(cp);
	free(dup);
}

void
std_search_path(void)
{
	int	i, n;

	/* Append standard search directories */
	n = sizeof standard_search_dirs / sizeof standard_search_dirs[0];
	for (i = 0; i < n; i++)
		add_search_dir(standard_search_dirs[i]);
}

/*
 * Return true if CP points to a valid dewey number.
 * Decode and leave the result in the array DEWEY.
 * Return the number of decoded entries in DEWEY.
 */

int
getdewey(int dewey[], char *cp)
{
	int	i, n;

	for (n = 0, i = 0; i < MAXDEWEY; i++) {
		if (*cp == '\0')
			break;

		if (*cp == '.') cp++;
#ifdef SUNOS_LIB_COMPAT
		if (!(isdigit)(*cp))
#else
		if (!isdigit(*cp))
#endif
			return 0;

		dewey[n++] = strtol(cp, &cp, 10);
	}
	return n;
}

/*
 * Compare two dewey arrays.
 * Return -1 if `d1' represents a smaller value than `d2'.
 * Return  1 if `d1' represents a greater value than `d2'.
 * Return  0 if equal.
 */
int
cmpndewey(int d1[], int n1, int d2[], int n2)
{
	int	i;

	for (i = 0; i < n1 && i < n2; i++) {
		if (d1[i] < d2[i])
			return -1;
		if (d1[i] > d2[i])
			return 1;
	}
	if (n1 == n2)
		return 0;
	if (i == n1)
		return -1;
	if (i == n2)
		return 1;
	errx(1, "cmpndewey: cant happen");
	return 0;
}
@


1.11
log
@do not require <a.out.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.10 2015/01/16 16:18:07 deraadt Exp $	*/
d84 1
a84 1
	search_dirs = (char **)xrealloc(search_dirs,
d110 1
a110 1
		search_dirs = (char **)xrealloc(search_dirs,
@


1.10
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.9 2006/05/13 16:33:40 deraadt Exp $	*/
a39 1
#include <a.out.h>
@


1.9
log
@some knf and delinting; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.8 2003/07/06 20:04:00 deraadt Exp $	*/
a34 1
#include <sys/param.h>
@


1.8
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.7 2002/07/30 22:25:27 deraadt Exp $	*/
d73 2
a74 1
	int i, len;
d86 2
a87 2
	search_dirs = (char **)
	    xrealloc(search_dirs, n_search_dirs * sizeof search_dirs[0]);
d95 2
a96 1
	int	i, len;
a132 15
static void
remove_search_path(char *path)
{
	char	*cp, *dup;

	if (path == NULL)
		return;

	/* Remove search directories from `path' */
	path = dup = strdup(path);
	while ((cp = strsep(&path, ":")) != NULL)
		remove_search_dir(cp);
	free(dup);
}

a196 85
}

/*
 * Search directories for a shared library matching the given
 * major and minor version numbers.
 *
 * MAJOR == -1 && MINOR == -1	--> find highest version
 * MAJOR != -1 && MINOR == -1   --> find highest minor version
 * MAJOR == -1 && MINOR != -1   --> invalid
 * MAJOR != -1 && MINOR != -1   --> find highest micro version
 */

/* Not interested in devices right now... */
#undef major
#undef minor

static char *
findshlib(char *name, int *majorp, int *minorp, int do_dot_a)
{
	int major = *majorp, minor = *minorp, ndewey, i, len;
	int dewey[MAXDEWEY], tmp[MAXDEWEY];
	char *lname;

	len = strlen(name) + sizeof("lib");
	lname = (char *)alloca(len);
	snprintf(lname, len, "lib%s", name);

	ndewey = 0;

	for (i = 0; i < n_search_dirs; i++) {
		struct dirent *dp;
		char *path = NULL;
		DIR *dd;

		dd = opendir(search_dirs[i]);
		if (dd == NULL)
			continue;

		while ((dp = readdir(dd)) != NULL) {
			int	n;

			if (do_dot_a && path == NULL &&
			    dp->d_namlen == len + 2 &&
			    strncmp(dp->d_name, lname, len) == 0 &&
			    (dp->d_name+len)[0] == '.' &&
			    (dp->d_name+len)[1] == 'a')
				path = concat(search_dirs[i], "/", dp->d_name);

			if (dp->d_namlen < len + 4)
				continue;
			if (strncmp(dp->d_name, lname, len) != 0)
				continue;
			if (strncmp(dp->d_name+len, ".so.", 4) != 0)
				continue;

			if ((n = getdewey(tmp, dp->d_name+len+4)) == 0)
				continue;

			/* skip inappropriate versions. */
			if (major != -1) {
				if (tmp[0] != major)
					continue;
				if (n != 1 && minor != -1 && tmp[1] < minor)
					continue;
			}

			if (cmpndewey(tmp, n, dewey, ndewey) <= 0)
				continue;

			/* We have a better version */
			if (path)
				free(path);
			path = concat(search_dirs[i], "/", dp->d_name);
			bcopy(tmp, dewey, sizeof(dewey));
			ndewey = n;
			*majorp = dewey[0];
			*minorp = dewey[1];
		}
		closedir(dd);

		/* There's a lib in this dir; take it. */
		if (path != NULL)
			return path;
	}
	return NULL;
@


1.7
log
@knf & ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.6 2002/05/24 04:17:00 deraadt Exp $	*/
d131 1
a131 1
void
d226 1
a226 1
char *
@


1.6
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.5 2002/05/24 03:44:37 deraadt Exp $	*/
a34 5
#ifdef sun
char	*strsep();
int	isdigit();
#endif

a69 1

d71 1
a71 2
add_search_dir(name)
	char	*name;
d82 1
a82 1
			!strncmp(search_dirs[i], name, len))
d86 1
a86 1
		xrealloc(search_dirs, n_search_dirs * sizeof search_dirs[0]);
d92 1
a92 2
remove_search_dir(name)
	char	*name;
d111 1
a111 1
			n_search_dirs * sizeof search_dirs[0]);
d117 1
a117 2
add_search_path(path)
char	*path;
d132 1
a132 2
remove_search_path(path)
char	*path;
d164 1
a164 3
getdewey(dewey, cp)
	int	dewey[];
	char	*cp;
a181 1

d192 1
a192 3
cmpndewey(d1, n1, d2, n2)
int	d1[], d2[];
int	n1, n2;
a201 1

a203 1

a205 1

a207 1

d227 1
a227 4
findshlib(name, majorp, minorp, do_dot_a)
char	*name;
int	*majorp, *minorp;
int	do_dot_a;
d229 7
a235 12
	int		dewey[MAXDEWEY];
	int		ndewey;
	int		tmp[MAXDEWEY];
	int		i;
	int		len;
	char		*lname;
	int		major = *majorp, minor = *minorp;

	len = strlen(name);
	lname = (char *)alloca(len + sizeof("lib"));
	sprintf(lname, "lib%s", name);
	len += 3;
d240 3
a242 3
		DIR		*dd = opendir(search_dirs[i]);
		struct dirent	*dp;
		char		*path = NULL;
d244 1
d290 1
a291 3
			/*
			 * There's a lib in this dir; take it.
			 */
a293 1

@


1.5
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.4 2002/05/22 06:35:44 deraadt Exp $	*/
d18 1
a18 1
 *      This product includes software developed by Paul Kranenburg.
d116 1
a116 1
			      (n_search_dirs - i - 1) * sizeof search_dirs[0]);
@


1.4
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.3 2001/12/07 18:45:32 mpech Exp $	*/
d157 1
a157 1
std_search_path()
d175 2
a176 2
int	dewey[];
char	*cp;
d269 1
a269 1
		char 		*path = NULL;
d300 1
a300 1
			} 
@


1.3
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.2 2001/01/30 02:39:06 brad Exp $	*/
d278 4
a281 5
					dp->d_namlen == len + 2 &&
					strncmp(dp->d_name, lname, len) == 0 &&
					(dp->d_name+len)[0] == '.' &&
					(dp->d_name+len)[1] == 'a') {

a282 1
			}
@


1.2
log
@sync with a.out ldconfig, adds missing -U option. Reviewed by: drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.1.1.1 2000/06/13 03:40:21 rahnds Exp $	*/
d128 1
a128 1
	register char	*cp, *dup;
d144 1
a144 1
	register char	*cp, *dup;
d209 1
a209 1
	register int	i;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: shlib.c,v 1.8 2000/01/16 14:31:26 espie Exp $	*/
d80 11
d94 2
a95 1
	search_dirs[n_search_dirs - 1] = strdup(name);
d102 6
a107 1
	int	n;
d109 3
a111 2
	for (n = 0; n < n_search_dirs; n++) {
		if (strcmp(search_dirs[n], name))
d113 4
a116 4
		free(search_dirs[n]);
		if (n < (n_search_dirs - 1))
			bcopy(&search_dirs[n+1], &search_dirs[n],
			      (n_search_dirs - n - 1) * sizeof search_dirs[0]);
d118 3
@


1.1.1.1
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems 
such as correctness and security.

@
text
@@
