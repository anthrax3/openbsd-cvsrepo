head	1.40;
access;
symbols
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.26
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.24
	OPENBSD_5_0:1.17.0.22
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.20
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.18
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@# @;


1.40
date	2017.08.27.21.59.52;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	VUjW1bPAOMU4NF33;

1.39
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.38;
commitid	veGB6uLWx3BTEAfk;

1.38
date	2016.08.31.13.18.57;	author guenther;	state Exp;
branches;
next	1.37;
commitid	CVAxKVTW0W9k3Y9P;

1.37
date	2016.08.28.06.15.32;	author guenther;	state Exp;
branches;
next	1.36;
commitid	Y7AbrDd15D7CrGY4;

1.36
date	2016.08.07.03.05.23;	author guenther;	state Exp;
branches;
next	1.35;
commitid	XoKaUgklLqr4KORR;

1.35
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.34;
commitid	d9R7VGw9CHTkwXE1;

1.34
date	2016.03.21.22.41.28;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	hneUpr7ZOJCeNeHP;

1.33
date	2016.03.21.01.32.48;	author guenther;	state Exp;
branches;
next	1.32;
commitid	7Tp2uEssgeiK9f77;

1.32
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	kmpP8aoRsEOyxUMj;

1.31
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.30;
commitid	FcRQ6g8MqXiORdFs;

1.30
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.29;
commitid	BssYI6s6zozAyfkk;

1.29
date	2015.05.29.19.12.26;	author miod;	state Exp;
branches;
next	1.28;
commitid	NxuNAiDufiij8H5G;

1.28
date	2014.07.28.04.28.43;	author guenther;	state Exp;
branches;
next	1.27;
commitid	xUQBauwDaqUEsvAg;

1.27
date	2014.07.14.03.54.50;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	fsr4AzfIP3TLhLM2;

1.26
date	2014.07.09.12.51.20;	author guenther;	state Exp;
branches;
next	1.25;
commitid	l16v8zUGQ3906m8T;

1.25
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.24;
commitid	vlK4cqSehsiJVTpr;

1.24
date	2014.07.05.17.03.19;	author miod;	state Exp;
branches;
next	1.23;
commitid	nRbEqUl3nEcX9FFT;

1.23
date	2013.12.23.21.18.57;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.10.19.23.14;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.13.05.52.18;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.09.57.57;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.24.03.26.55;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.09.21.01.10;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.17.20.41.07;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.18.19.20.01;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.21.16.01.55;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.11.18.41.17;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.17.00.22.04;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.24.21.37.06;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.13.08.42.03;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.29.08.52.11;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.14.22.18.20;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Replace heaps of hand-written syscall stubs with a simpler framework
which is largely MI.
ok visa kettenis
@
text
@/*	$OpenBSD: ldasm.S,v 1.39 2017/01/24 07:48:37 guenther Exp $ */

/*
 * Copyright (c) 2001 Niklas Hallqvist
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Copyright 1996 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/asm.h>
#include <machine/pal.h>
#include <sys/syscall.h>

#define AUX_entry 9

	.extern _GLOBAL_OFFSET_TABLE_

/* Not really a leaf... but we are special.  */
LEAF_NOPROFILE(_dl_start, 0)
	.set	noreorder
	br	pv, L1
L1:
	LDGP(pv)

	mov	a0, s0		/* save arg */

	/* relocate ourself. */
	br	s2, L2		/* get our PC */
L2:	ldiq	s3, L2		/* get where the linker thought we were */

	subq	s2, s3, s2
	mov	s2, a1
	lda	t5, _DYNAMIC
	addq	s2, t5, a0
	mov	a0, s6

	bsr	ra, _reloc_alpha_got

	/* allocate stack */
	lda	sp, (-8 - ((AUX_entry) * 8))(sp)

	mov	s0, a0
	mov	s2, s1		/* relocation displacement */
	ldq	a2, 0(a0)	/* argc */
	lda	a3, 8(a0)	/* argv */
	mov	a3, s3
	lda	t3, 1(a2)
	sll	t3, 3, t3
	addq	a3, t3, a4	/* envp */
	mov	a4, s4
	mov	a5, s5
	lda	s2, 0(sp)
	mov	s2, a1
	mov	s6, a2		/* &_DYNAMIC */
	CALL(_dl_boot_bind)
	mov	s3, a0		/* **argv  */
	mov	s4, a1		/* **envp  */
	mov	s1, a2		/* loff    */
	mov	s2, a3		/* dl_data */
	CALL(_dl_boot)
	mov	s0, a0		/* stack */
	lda	a1, _dl_dtors	/* cleanup */
	mov	v0, pv
	jsr	ra, (pv)
END(_dl_start)

/*
 * Lazy binding entry point, called via PLT.
 */
NESTED_NOPROFILE(_dl_bind_start, 0, 168, ra, 0, 0)
	.set	noat
	/* at_reg already used by PLT code. */

	/*
	 * Allocate stack frame and preserve all registers that the caller
	 * would have normally saved themselves.
	 */
	lda	sp, -168(sp)
	stq	ra, 0(sp)
	stq	v0, 8(sp)
	stq	t0, 16(sp)
	stq	t1, 24(sp)
	stq	t2, 32(sp)
	stq	t3, 40(sp)
	stq	t4, 48(sp)
	stq	t5, 56(sp)
	stq	t6, 64(sp)
	stq	t7, 72(sp)
	stq	a0, 80(sp)
	stq	a1, 88(sp)
	stq	a2, 96(sp)
	stq	a3, 104(sp)
	stq	a4, 112(sp)
	stq	a5, 120(sp)
	stq	t8, 128(sp)
	stq	t9, 136(sp)
	stq	t10, 144(sp)
	stq	t11, 152(sp)
	stq	gp, 160(sp)

	/*
	 * Load our global pointer.  Note, can't use pv, since it is
	 * already used by the PLT code.
	 */
	br	t0, 1f
1:	LDGP(t0)

	/* Set up the arguments for _dl_bind. */
	subq	at_reg, t12, a1
	ldq	a0, 8(t12)
	subq	a1, 20, a1
	addq	a1, a1, a1
	CALL(_dl_bind)

	/* Move the destination address into position. */
	mov	v0, pv

	/* Restore program registers. */
	ldq	ra, 0(sp)
	ldq	v0, 8(sp)
	ldq	t0, 16(sp)
	ldq	t1, 24(sp)
	ldq	t2, 32(sp)
	ldq	t3, 40(sp)
	ldq	t4, 48(sp)
	ldq	t5, 56(sp)
	ldq	t6, 64(sp)
	ldq	t7, 72(sp)
	ldq	a0, 80(sp)
	ldq	a1, 88(sp)
	ldq	a2, 96(sp)
	ldq	a3, 104(sp)
	ldq	a4, 112(sp)
	ldq	a5, 120(sp)
	ldq	t8, 128(sp)
	ldq	t9, 136(sp)
	ldq	t10, 144(sp)
	ldq	t11, 152(sp)
	ldq	gp, 160(sp)
	/* XXX LDGP? */

	/*
	 * We've patched the PLT; sync the I-stream.
	 */
	imb

	/* Pop the stack frame and turn control to the destination. */
	lda	sp, 168(sp)
	jmp	zero, (pv)
END(_dl_bind_start)

/*
 * Lazy binding entry point, called via secure (read-only) PLT.
 */
NESTED_NOPROFILE(_dl_bind_secureplt, 0, 168, ra, 0, 0)
	.set	noat
	/* at_reg and t11 already used by PLT code. */

	/*
	 * Allocate stack frame and preserve all registers that the caller
	 * would have normally saved themselves.
	 */
	lda	sp, -160(sp)
	stq	ra, 0(sp)
	stq	v0, 8(sp)
	stq	t0, 16(sp)
	stq	t1, 24(sp)
	stq	t2, 32(sp)
	stq	t3, 40(sp)
	stq	t4, 48(sp)
	stq	t5, 56(sp)
	stq	t6, 64(sp)
	stq	t7, 72(sp)
	stq	a0, 80(sp)
	stq	a1, 88(sp)
	stq	a2, 96(sp)
	stq	a3, 104(sp)
	stq	a4, 112(sp)
	stq	a5, 120(sp)
	stq	t8, 128(sp)
	stq	t9, 136(sp)
	stq	t10, 144(sp)
	stq	gp, 152(sp)

	/*
	 * Load our global pointer.  Note, can't use pv, since it is
	 * already used by the PLT code.
	 */
	br	t0, 1f
1:	LDGP(t0)

	/* Set up the arguments for _dl_bind. */
	mov	at_reg, a0	/* object */
	mov	t11, a1		/* reloff as computed by the plt resolver */
	CALL(_dl_bind)

	/* Move the destination address into position. */
	mov	v0, pv

	/* Restore program registers. */
	ldq	ra, 0(sp)
	ldq	v0, 8(sp)
	ldq	t0, 16(sp)
	ldq	t1, 24(sp)
	ldq	t2, 32(sp)
	ldq	t3, 40(sp)
	ldq	t4, 48(sp)
	ldq	t5, 56(sp)
	ldq	t6, 64(sp)
	ldq	t7, 72(sp)
	ldq	a0, 80(sp)
	ldq	a1, 88(sp)
	ldq	a2, 96(sp)
	ldq	a3, 104(sp)
	ldq	a4, 112(sp)
	ldq	a5, 120(sp)
	ldq	t8, 128(sp)
	ldq	t9, 136(sp)
	ldq	t10, 144(sp)
	ldq	gp, 152(sp)
	/* XXX LDGP? */

	/* Pop the stack frame and turn control to the destination. */
	lda	sp, 160(sp)
	jmp	zero, (pv)
END(_dl_bind_secureplt)
@


1.39
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.38 2016/08/31 13:18:57 guenther Exp $ */
a271 59


/*
 * In reality these are not leaves, but they are stubs which does not need
 * further register saving.
 */

#define	DL_SYSCALL(n)			DL_SYSCALL2(n,n)
#define	DL_SYSCALL_NOERR(n)		DL_SYSCALL2_NOERR(n,n)
#define	DL_SYSCALL2(n,c)						\
LEAF_NOPROFILE(_dl_##n, irrelevant);					\
	CALLSYS_NOERROR(c);						\
	beq	a3, 1f;							\
	jmp	zero, _dl_cerror;					\
1:									\
	RET;								\
END(_dl_##n)
#define	DL_SYSCALL2_NOERR(n,c)						\
LEAF_NOPROFILE(_dl_##n, irrelevant);					\
	CALLSYS_NOERROR(c);						\
	RET;								\
END(_dl_##n)

_dl_cerror:
	subq	zero, v0, v0	/* return -errno */
	RET

/* _dl_mmap() is special, as it needs to insert the syscall padding argument */
LEAF_NOPROFILE(_dl_mmap, 6)
	lda	sp, -8(sp)
	stq	a5, 0(sp)
	CALLSYS_NOERROR(mmap)
	lda	sp, 8(sp)
	beq	a3, 1f
	jmp	zero, _dl_cerror
1:
	RET
END(_dl_mmap)

DL_SYSCALL(close)
DL_SYSCALL_NOERR(exit)
DL_SYSCALL(fstat)
DL_SYSCALL2(getcwd,__getcwd)
DL_SYSCALL(getdents)
DL_SYSCALL(getentropy)
DL_SYSCALL(sendsyslog)
DL_SYSCALL(pledge)
DL_SYSCALL_NOERR(issetugid)
DL_SYSCALL_NOERR(getthrid)
DL_SYSCALL(mprotect)
DL_SYSCALL(munmap)
DL_SYSCALL(open)
DL_SYSCALL(read)
DL_SYSCALL(readlink)
DL_SYSCALL2(_syscall,__syscall)
DL_SYSCALL(sysctl)
DL_SYSCALL(thrkill)
DL_SYSCALL(utrace)
DL_SYSCALL(write)
@


1.38
log
@alpha and sh have TCB_SET() macros so don't need _dl_set_tcb()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.37 2016/08/28 06:15:32 guenther Exp $ */
d328 1
@


1.37
log
@ld.so doesn't need gettimeofday or lstat stubs any more

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.36 2016/08/07 03:05:23 guenther Exp $ */
a326 1
DL_SYSCALL2_NOERR(set_tcb,__set_tcb)
@


1.36
log
@As with csu, alpha passes &_DYNAMIC to _reloc_alpha_got(), so just
save that and pass it to _dl_boot_bind() too
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.35 2016/05/07 19:05:23 guenther Exp $ */
a318 1
DL_SYSCALL(gettimeofday)
a320 1
DL_SYSCALL(lstat)
@


1.35
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.34 2016/03/21 22:41:28 bluhm Exp $ */
d80 1
d99 1
a99 1
	mov	0,  a2		/* dynamicp is unused on alpha */
@


1.34
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.33 2016/03/21 01:32:48 guenther Exp $ */
d320 1
d328 1
@


1.33
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.32 2015/11/15 03:41:24 deraadt Exp $ */
d316 1
a316 1
DL_SYSCALL(sendsyslog2)
@


1.32
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.31 2015/09/19 20:56:47 guenther Exp $ */
d316 1
a316 1
DL_SYSCALL(sendsyslog)
@


1.31
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.30 2015/09/13 17:08:03 guenther Exp $ */
d317 1
@


1.30
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.29 2015/05/29 19:12:26 miod Exp $ */
a308 20

LEAF_NOPROFILE(_dl_sigprocmask, 4)
	/* _dl_sigprocmask does not support NULL new mask */
	mov	a2, a5
#if 0
	cmoveq	a1, 1, a0	/* if set is NULL, set how to SIG_BLOCK */
	beq	a1, 1f
#endif
	ldl	a1, 0(a1)	/* load the set from *set */
1:
	CALLSYS_NOERROR(sigprocmask)
	beq	a3, 1f
	jmp	zero, _dl_cerror
1:
	beq	a5, 1f
	stl	v0, 0(a5)
1:
	mov	zero, v0
	RET
END(_dl_sigprocmask)
@


1.29
log
@Make ld.so on alpha cope with binaries built with secureplt (where secure here
means read-only, which our ld.so already enforced, but a smaller plt section).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.28 2014/07/28 04:28:43 guenther Exp $ */
d346 1
a346 1
DL_SYSCALL2(sysctl,__sysctl)
@


1.28
log
@_dl_sigprocmask() works better when it actually saves the returned sigmask

asm suggestion from kettenis@@
tested by miod@@, suffering under the brain-destroying summer heat
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.27 2014/07/14 03:54:50 deraadt Exp $ */
d149 2
a150 2
	br	t0, L100
L100:	LDGP(t0)
d195 76
@


1.27
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.26 2014/07/09 12:51:20 guenther Exp $ */
d246 1
@


1.26
log
@_dl_fcntl() is no longer used; kill the stubs

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.25 2014/07/06 07:28:36 otto Exp $ */
d259 1
@


1.25
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.24 2014/07/05 17:03:19 miod Exp $ */
a254 1
DL_SYSCALL(fcntl)
@


1.24
log
@Add more sugar to generate syscall stubs; and make sure errors are reported
with a negative value (I'm looking at you, _dl_mmap);
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.23 2013/12/23 21:18:57 kettenis Exp $ */
d259 1
@


1.23
log
@Make ld.so pass its cleanup handler in v0 and stop calling atexit(4) directly
from ld.so on alpha.  Note that this means that binaries built before early
december may no longer call destructors in shared libraries implemented in
C++.  Update your packages!
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.22 2013/11/10 19:23:14 guenther Exp $ */
d202 15
a216 26
LEAF_NOPROFILE(_dl_exit, 1)
	ldiq	v0, SYS_exit
	call_pal PAL_OSF1_callsys
	RET
END(_dl_exit)

LEAF_NOPROFILE(_dl_open, 2)
	ldiq	v0, SYS_open
	call_pal PAL_OSF1_callsys
	beq	a3, _dl_open_no_error
	subq	zero, v0, v0
_dl_open_no_error:
	RET
END(_dl_open)

LEAF_NOPROFILE(_dl_close, 1)
	ldiq	v0, SYS_close
	call_pal PAL_OSF1_callsys
	RET
END(_dl_close)

LEAF_NOPROFILE(_dl_write, 3)
	ldiq	v0, SYS_write
	call_pal PAL_OSF1_callsys
	RET
END(_dl_write)
d218 2
a219 3
LEAF_NOPROFILE(_dl_read, 3)
	ldiq	v0, SYS_read
	call_pal PAL_OSF1_callsys
a220 1
END(_dl_read)
d222 1
d226 1
a226 2
	ldiq	v0, SYS_mmap
	call_pal PAL_OSF1_callsys
d228 3
a233 43
LEAF_NOPROFILE(_dl_munmap, 2)
	ldiq	v0, SYS_munmap
	call_pal PAL_OSF1_callsys
	RET
END(_dl_munmap)

LEAF_NOPROFILE(_dl_mprotect, 3)
	ldiq	v0, SYS_mprotect
	call_pal PAL_OSF1_callsys
	RET
END(_dl_mprotect)

LEAF_NOPROFILE(_dl_issetugid, 0)
	ldiq	v0, SYS_issetugid
	call_pal PAL_OSF1_callsys
	RET
END(_dl_issetugid)

LEAF_NOPROFILE(_dl__syscall, 3)
	ldiq	v0, SYS___syscall
	call_pal PAL_OSF1_callsys
	RET
END(_dl__syscall)

LEAF_NOPROFILE(_dl_fstat, 2)
	ldiq	v0, SYS_fstat
	call_pal PAL_OSF1_callsys
	RET
END(_dl_fstat)

LEAF_NOPROFILE(_dl_fcntl, 3)
	ldiq	v0, SYS_fcntl
	call_pal PAL_OSF1_callsys
	RET
END(_dl_fcntl)

LEAF_NOPROFILE(_dl_getdents, 3)
	ldiq	v0, SYS_getdents
	call_pal PAL_OSF1_callsys
	RET
END(_dl_getdents)

/* _dl_sigprocmask does not support NULL new mask */
d235 1
d237 9
a245 4
	ldl	a1, 0(a1)		/* load the set from *set */
	ldiq	v0, SYS_sigprocmask
	call_pal PAL_OSF1_callsys
	/* What about syscalls failing? */
d248 2
a249 1
1:	mov	zero, v0
d253 18
a270 35
LEAF_NOPROFILE(_dl_sysctl, 4)
	ldiq	v0, SYS___sysctl
	call_pal PAL_OSF1_callsys
	RET
END(_dl_sysctl)

LEAF_NOPROFILE(_dl_gettimeofday, 2)
	ldiq	v0, SYS_gettimeofday
	call_pal PAL_OSF1_callsys
	RET
END(_dl_gettimeofday)

LEAF_NOPROFILE(_dl_readlink, 3)
	ldiq	v0, SYS_readlink
	call_pal PAL_OSF1_callsys
	RET
END(_dl_readlink)

LEAF_NOPROFILE(_dl_lstat, 2)
	ldiq	v0, SYS_lstat
	call_pal PAL_OSF1_callsys
	RET
END(_dl_lstat)

LEAF_NOPROFILE(_dl_getcwd, 2)
	ldiq	v0, SYS___getcwd
	call_pal PAL_OSF1_callsys
	RET
END(_dl_getcwd)

LEAF_NOPROFILE(_dl_utrace, 2)
	ldiq	v0, SYS_utrace
	call_pal PAL_OSF1_callsys
	RET
END(_dl_utrace)
@


1.22
log
@Make sure we pass a NULL cleanup argument to __start() by initializing
a2 to zero in the kernel and ld.so.  This will let us add the
conditional atexit() call to crt0

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.21 2013/08/13 05:52:18 guenther Exp $ */
d106 1
a106 1
	mov	zero, a1	/* cleanup */
@


1.21
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.20 2013/06/01 09:57:57 miod Exp $ */
d105 2
a106 1
	mov	s0, a0
@


1.20
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.19 2013/04/05 12:58:03 kurt Exp $ */
d279 2
a280 2
LEAF_NOPROFILE(_dl_getdirentries, 4)
	ldiq	v0, SYS_getdirentries
d283 1
a283 1
END(_dl_getdirentries)
@


1.19
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.18 2012/10/24 03:26:55 guenther Exp $ */
d328 5
@


1.18
log
@Garbage-collect the _dl_stat() routine, now unused

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.17 2006/05/03 16:10:51 drahn Exp $ */
d309 18
@


1.17
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.16 2004/05/25 15:56:18 deraadt Exp $ */
a259 6

LEAF_NOPROFILE(_dl_stat, 2)
	ldiq	v0, SYS_stat
	call_pal PAL_OSF1_callsys
	RET
END(_dl_stat)
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.15 2003/07/09 21:01:10 drahn Exp $ */
d309 7
@


1.15
log
@changes to ld.so to be compatible with newer binutils, requires
slight changes in the startup code on most archs. ok art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.14 2003/06/09 16:10:03 deraadt Exp $ */
d294 1
a294 1
	ldl     a1, 0(a1)               /* load the set from *set */
@


1.14
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.13 2003/05/30 01:13:53 drahn Exp $ */
d98 1
@


1.13
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.12 2003/01/17 20:41:07 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@Change the GOT initialization so that it is done in a function which
initialized just the correct addresses instead of assuming that the GOT
extends from _GLOBAL_OFFSET_TABLE_ to _DYNAMIC. Mostly from NetBSD.
ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.11 2002/12/18 19:20:01 drahn Exp $ */
d308 6
@


1.11
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.10 2002/10/21 16:01:55 drahn Exp $ */
a71 1
	lda	sp, (-8 - ((AUX_entry) * 8))(sp)
d75 19
a93 16
	ldiq	t2, L1
	subq	pv, t2, t2
	lda	t0, _GLOBAL_OFFSET_TABLE_
	addq	t0, t2, t0
	lda	t1, _DYNAMIC
	addq	t1, t2, t1
L2:	cmpult	t0, t1, t3
	beq	t3, L3
	ldq	t3, 0(t0)
	addq	t3, t2, t3
	stq	t3, 0(t0)
	lda	t0, 8(t0)
	br	L2
L3:
	mov	a0, s0
	mov	t2, s1		/* relocation displacement */
@


1.10
log
@Simplify the ld.so asm api, the data is available other ways.
tested by naddy@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.9 2002/08/11 18:41:17 drahn Exp $ */
d293 13
@


1.9
log
@The parameter dynp was never used, rather than pass in a dummy on most
archs and a nasty calcuation on others, remove the parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.8 2002/07/12 20:18:30 drahn Exp $ */
d91 1
a91 2
	mov	t2, a1		/* relocation displacement */
	mov	a1, s1
a98 1
	mov	t1, a2		/* dynamic */
d101 1
a101 1
	mov	s2, a3
@


1.8
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.7 2002/05/24 04:17:00 deraadt Exp $ */
d105 4
a108 5
	mov	s3, a0
	mov	s4, a1
	mov	s1, a2
	mov	s5, a3
	mov	s2, a4
@


1.7
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.6 2002/05/24 03:44:37 deraadt Exp $ */
a266 1
#ifdef USE_CACHE
d272 24
a295 1
#endif
@


1.6
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.5 2002/03/17 00:22:04 art Exp $ */
d197 1
a197 1
	lda     sp, 168(sp)
@


1.5
log
@Clean up the zapping of bad variables. Instead of implementing
_dl_suid_ok, just use the issetugid syscall.
ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.4 2001/09/24 21:37:06 art Exp $ */
d5 1
a5 1
 * 
d81 2
a82 2
	addq	t1, t2, t1	
L2:	cmpult	t0, t1, t3	
d206 1
a206 1
	
d238 1
a238 1
END(_dl_exit)
@


1.4
log
@Adapt to _dl_boot_bind change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.3 2001/06/13 08:42:03 art Exp $ */
d261 2
a262 2
LEAF_NOPROFILE(_dl_getuid, 0)
	ldiq	v0, SYS_getuid
d265 1
a265 19
END(_dl_getuid)

LEAF_NOPROFILE(_dl_geteuid, 0)
	ldiq	v0, SYS_geteuid
	call_pal PAL_OSF1_callsys
	RET
END(_dl_geteuid)

LEAF_NOPROFILE(_dl_getgid, 0)
	ldiq	v0, SYS_getgid
	call_pal PAL_OSF1_callsys
	RET
END(_dl_getgid)

LEAF_NOPROFILE(_dl_getegid, 0)
	ldiq	v0, SYS_getegid
	call_pal PAL_OSF1_callsys
	RET
END(_dl_getegid)
@


1.3
log
@Lazy binding entry point. From NetBSD with some help from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.2 2001/05/29 08:52:11 art Exp $ */
d72 1
a72 1
	lda	sp, (-8 - ((AUX_entry + 1) * 8))(sp)
d100 1
a100 1
	mov	t1, a5		/* dynamic */
d102 2
a103 2
	lda	s2, 8(sp)
	stq	s2, 0(sp)	/* dl_link */
@


1.2
log
@Check for error on open.
ENOENT happens to be the same as stderr. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.1 2001/05/14 22:18:20 niklas Exp $ */
d34 26
d115 86
@


1.1
log
@Commit initial alpha bits, to facilitate in-tree dev.
This code is not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.1.1.1 2000/06/13 03:40:35 rahnds Exp $ */
d104 3
@

