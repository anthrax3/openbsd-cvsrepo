head	1.61;
access;
symbols
	OPENBSD_6_2_BASE:1.61
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.59.0.2
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.50.0.6
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.47.0.2
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.46.0.6
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.44.0.4
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.43.0.6
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.8
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.4
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.31.0.6
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.4
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.61
date	2017.02.16.13.31.10;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	qhSZlvkB3BmfCwmg;

1.60
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.59;
commitid	veGB6uLWx3BTEAfk;

1.59
date	2016.06.21.15.25.36;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	lRIiUPnkIQNjSTol;

1.58
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.57;
commitid	Kpc3J4Ry51yjfQid;

1.57
date	2015.12.22.08.54.16;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	sTDrw9FlbNNwVprE;

1.56
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.55;
commitid	zGFWeGZdYJxUOZli;

1.55
date	2015.09.23.22.52.12;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	eTl5brMgebSiEJQr;

1.54
date	2015.08.26.02.04.41;	author guenther;	state Exp;
branches;
next	1.53;
commitid	gf5adcYyT8xVSb14;

1.53
date	2015.05.29.19.12.26;	author miod;	state Exp;
branches;
next	1.52;
commitid	NxuNAiDufiij8H5G;

1.52
date	2014.12.27.13.13.25;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	a1FfQ1Gq2ABF0Pqw;

1.51
date	2014.04.16.10.52.58;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.01.09.57.57;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2012.12.05.23.20.06;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.08.02.43.28;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.28.22.11.00;	author kurt;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.24.15.47.47;	author drahn;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.27.16.42.17;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.06.21.45.46;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.06.16.38.10;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.22.19.50.21;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.22.01.33.07;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.21.23.12.09;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.25.21.42.47;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.05.03.56.58;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.04.19.37.07;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.04.19.33.49;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.28.03.11.00;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.06.20.04.00;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.03.16.20.40;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.07.02.06.44;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.15.22.39.13;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.17.20.41.07;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.16.19.56.37;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.18.19.20.01;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.01.23.55.01;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.05.23.13.55;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.05.19.34.44;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.26.18.43.06;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.13.08.45.34;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.05.14.52.26;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.31.23.49.08;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.31.22.10.49;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.31.13.49.27;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.31.13.26.51;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.14.22.18.21;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.61
log
@correct format strings, ok guenther
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.60 2017/01/24 07:48:37 guenther Exp $ */

/*
 * Copyright (c) 1999 Dale Rahn
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/exec.h>
#include <sys/syscall.h>
#include <sys/unistd.h>
#include <machine/pal.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

#define	DT_PROC(n)	((n) - DT_LOPROC + DT_NUM)

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	long	i;
	long	numrela;
	long	relrel;
	int	fails = 0;
	Elf64_Addr loff;
	Elf64_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf64_Rela  *relas;
	struct load_list *llist;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf64_Rela);
	relrel = rel == DT_RELA ? object->relacount : 0;
	relas = (Elf64_Rela *)(object->Dyn.info[rel]);

	if (relas == NULL)
		return(0);

	if (relrel > numrela)
		_dl_die("relacount > numrel: %ld > %ld", relrel, numrela);

	/*
	 * unprotect some segments if we need it.
	 * XXX - we unprotect way to much. only the text can have cow
	 * relocations.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE)) {
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
			}
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, relas++) {
		Elf_Addr *r_addr;

#ifdef DEBUG
		if (ELF64_R_TYPE(relas->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELACOUNT wrong");
#endif

		r_addr = (Elf64_Addr *)(relas->r_offset + loff);

		/* Handle unaligned RELATIVE relocs */
		if ((((Elf_Addr)r_addr) & 0x7) != 0) {
			Elf_Addr tmp;
			_dl_bcopy(r_addr, &tmp, sizeof(Elf_Addr));
			tmp += loff;
			_dl_bcopy(&tmp, r_addr, sizeof(Elf_Addr));
		} else
			*r_addr += loff;
	}
	for (; i < numrela; i++, relas++) {
		Elf64_Addr *r_addr;
		Elf64_Addr ooff;
		const Elf64_Sym *sym, *this;
		const char *symn;

		r_addr = (Elf64_Addr *)(relas->r_offset + loff);

		if (ELF64_R_SYM(relas->r_info) == 0xffffffff)
			continue;


		sym = object->dyn.symtab;
		sym += ELF64_R_SYM(relas->r_info);
		symn = object->dyn.strtab + sym->st_name;

		this = NULL;
		switch (ELF64_R_TYPE(relas->r_info)) {
		case R_TYPE(REFQUAD):
			ooff =  _dl_find_symbol_bysym(object,
			    ELF64_R_SYM(relas->r_info), &this,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym, NULL);
			if (this == NULL)
				goto resolve_failed;
			*r_addr += ooff + this->st_value + relas->r_addend;
			break;
		case R_TYPE(RELATIVE):
			/*
			 * There is a lot of unaligned RELATIVE
			 * relocs generated by gcc in the exception handlers.
			 */
			if ((((Elf_Addr) r_addr) & 0x7) != 0) {
				Elf_Addr tmp;
#if 0
_dl_printf("unaligned RELATIVE: %p type: %d %s 0x%lx -> 0x%lx\n", r_addr,
    ELF_R_TYPE(relas->r_info), object->load_name, *r_addr, *r_addr+loff);
#endif
				_dl_bcopy(r_addr, &tmp, sizeof(Elf_Addr));
				tmp += loff;
				_dl_bcopy(&tmp, r_addr, sizeof(Elf_Addr));
			} else
				*r_addr += loff;
			break;
		case R_TYPE(JMP_SLOT):
			ooff = _dl_find_symbol(symn, &this,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT,
			    sym, object, NULL);
			if (this == NULL)
				goto resolve_failed;
			*r_addr = ooff + this->st_value + relas->r_addend;
			break;
		case R_TYPE(GLOB_DAT):
			if (sym == prev_sym) {
				*r_addr = prev_value + relas->r_addend;
				break;
			}
			ooff =  _dl_find_symbol_bysym(object,
			    ELF64_R_SYM(relas->r_info), &this,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym, NULL);
			if (this == NULL)
				goto resolve_failed;
			prev_sym = sym;
			prev_value = ooff + this->st_value;
			*r_addr = prev_value + relas->r_addend;
			break;
		case R_TYPE(NONE):
			break;
		default:
			_dl_die("%s: unsupported relocation '%s' %lld at %p",
			    object->load_name, symn,
			    ELF64_R_TYPE(relas->r_info), (void *)r_addr);
		}
		continue;
resolve_failed:
		if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
			fails++;
	}
	__asm volatile("imb" : : : "memory");

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}
	return (fails);
}

/*
 * Resolve a symbol at run-time.
 */
Elf_Addr
_dl_bind(elf_object_t *object, int reloff)
{
	Elf_RelA *rela;
	Elf_Addr ooff;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	uint64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;

	rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);

	sym = object->dyn.symtab;
	sym += ELF64_R_SYM(rela->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value + rela->r_addend;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("$0") /* v0 */ = SYS_kbind;
		register void *arg1 __asm("$16") /* a0 */ = &buf;
		register long  arg2 __asm("$17") /* a1 */ = sizeof(buf);
		register long  arg3 __asm("$18") /* a2 */ = cookie;

		__asm volatile( "call_pal %1" : "+r" (syscall_num)
		    : "i" (PAL_OSF1_callsys), "r" (arg1), "r" (arg2),
		    "r" (arg3) : "$19", "$20", "memory");
	}

	return (buf.newval);
}

/*
 *	Relocate the Global Offset Table (GOT).
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	fails = 0;
	Elf_Addr *pltgot;
	extern void _dl_bind_start(void);	/* XXX */
	extern void _dl_bind_secureplt(void);	/* XXX */
	Elf_Addr seg_start;
	u_long pltro;

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	pltro = object->Dyn.info[DT_PROC(DT_ALPHA_PLTRO)];
	pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];

	if (object->traced)
		lazy = 1;

	if (object->obj_type == OBJTYPE_LDR || !lazy || pltgot == NULL) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		if (object->obj_base != 0) {
			int i, size;
			Elf_Addr *addr;
			Elf_RelA *rela;

			size = object->Dyn.info[DT_PLTRELSZ] /
			    sizeof(Elf_RelA);
			rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);

			for (i = 0; i < size; i++) {
				addr = (Elf_Addr *)(object->obj_base +
				    rela[i].r_offset);
				*addr += object->obj_base;
			}
		}
		if (pltro == 0) {
			pltgot[2] = (Elf_Addr)_dl_bind_start;
			pltgot[3] = (Elf_Addr)object;
		} else {
			pltgot[0] = (Elf_Addr)_dl_bind_secureplt;
			pltgot[1] = (Elf_Addr)object;
		}
	}

	/* mprotect the GOT */
	seg_start = 0;
	if (pltro != 0)
		seg_start = (Elf_Addr)pltgot;
	_dl_protect_segment(object, seg_start, "__got_start", "__got_end",
	    PROT_READ);

	/* mprotect the PLT, if it isn't already read-only */
	if (pltro == 0)
		_dl_protect_segment(object, (Elf_Addr)pltgot, "__plt_start",
		    "__plt_end", PROT_READ|PROT_EXEC);

	return (fails);
}

/* relocate the GOT early */

void	_reloc_alpha_got(Elf_Dyn *dynp, Elf_Addr relocbase);

void
_reloc_alpha_got(Elf_Dyn *dynp, Elf_Addr relocbase)
{
	const Elf_RelA *rela = NULL, *relalim;
	Elf_Addr relasz = 0;
	Elf_Addr *where;

	for (; dynp->d_tag != DT_NULL; dynp++) {
		switch (dynp->d_tag) {
		case DT_RELA:
			rela = (const Elf_RelA *)(relocbase + dynp->d_un.d_ptr);
			break;
		case DT_RELASZ:
			relasz = dynp->d_un.d_val;
			break;
		}
	}
	relalim = (const Elf_RelA *)((caddr_t)rela + relasz);
	for (; rela < relalim; rela++) {
		if (ELF64_R_TYPE(rela->r_info) != RELOC_RELATIVE)
			continue;
		where = (Elf_Addr *)(relocbase + rela->r_offset);
		*where += (Elf_Addr)relocbase;
	}
}
@


1.60
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.59 2016/06/21 15:25:36 deraadt Exp $ */
d179 1
a179 1
			_dl_die("%s: unsupported relocation '%s' %d at %lx",
d181 1
a181 1
			    ELF64_R_TYPE(relas->r_info), r_addr );
@


1.59
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.58 2016/03/20 02:29:51 guenther Exp $ */
d72 2
a73 4
	if (relrel > numrela) {
		_dl_printf("relacount > numrel: %ld > %ld\n", relrel, numrela);
		_dl_exit(20);
	}
d94 2
a95 4
		if (ELF64_R_TYPE(relas->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELACOUNT wrong\n");
			_dl_exit(20);
		}
d179 2
a180 3
			_dl_printf("%s:"
			    " %s: unsupported relocation '%s' %d at %lx\n",
			    __progname, object->load_name, symn,
a181 1
			_dl_exit(1);
d227 2
a228 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.58
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.57 2015/12/22 08:54:16 mmcc Exp $ */
d86 1
a86 1
				    llist->prot|PROT_WRITE);
@


1.57
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.56 2015/11/02 07:02:53 guenther Exp $ */
d185 1
a185 1
			    _dl_progname, object->load_name, symn,
@


1.56
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.55 2015/09/23 22:52:12 kettenis Exp $ */
d332 1
a332 1
	const Elf_RelA *rela = 0, *relalim;
@


1.55
log
@Don't be too agressive write-protecting the GOT and PLT.  If we have no clue
where they end, there is a good chance they are sharing a page with .data,
which obviously needs to remain writable.  So only attempt to make them
read-only if we know they have a non-zero size.  Original diff from guenther@@
based on an earlier diff from me.  Fixes ld -Z on alpha.

ok miod@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.54 2015/08/26 02:04:41 guenther Exp $ */
d271 1
a271 3
	Elf_Addr ooff;
	Elf_Addr plt_addr;
	const Elf_Sym *this;
d274 3
a279 63
	object->got_addr = 0;
	object->got_size = 0;
	if (pltro != 0 && pltgot != NULL)
		object->got_addr = (Elf_Addr)pltgot;
	else {
		this = NULL;
		ooff = _dl_find_symbol("__got_start", &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this != NULL)
			object->got_addr = ooff + this->st_value;
	}

	if (object->got_addr != 0) {
		this = NULL;
		ooff = _dl_find_symbol("__got_end", &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this != NULL)
			object->got_size = ooff + this->st_value
			    - object->got_addr;
	}

	plt_addr = 0;
	object->plt_size = 0;
	/*
	 * Do not even attempt to locate the .plt section if we will not
	 * have to write into it.
	 */
	if (pltro == 0) {
		if (pltgot != NULL)
			plt_addr = (Elf_Addr)pltgot;
		else {
			this = NULL;
			ooff = _dl_find_symbol("__plt_start", &this,
			    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
			    object, NULL);
			if (this != NULL)
				plt_addr = ooff + this->st_value;
		}

		if (plt_addr != 0) {
			this = NULL;
			ooff = _dl_find_symbol("__plt_end", &this,
			    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT,
			    NULL, object, NULL);
			if (this != NULL)
				object->plt_size = ooff + this->st_value
				    - plt_addr;
		}
	}

	if (object->got_size != 0) {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	if (object->plt_size != 0) {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
	}

a300 2
	}
	if (pltgot != NULL) {
d309 12
a320 6
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
@


1.54
log
@Kbind 3: The Legend Continues!
Use kbind for lazy binding GOT/PLT updates on alpha and mips64.
While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.53 2015/05/29 19:12:26 miod Exp $ */
d292 9
a300 5
	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;
d320 9
a328 6
		this = NULL;
		ooff = _dl_find_symbol("__plt_end", &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this != NULL)
			object->plt_size = ooff + this->st_value  - plt_addr;
d331 1
a331 3
	if (object->got_addr == 0)
		object->got_start = 0;
	else {
d336 1
a336 3
	if (plt_addr == 0)
		object->plt_start = 0;
	else {
@


1.53
log
@Make ld.so on alpha cope with binaries built with secureplt (where secure here
means read-only, which our ld.so already enforced, but a smaller plt section).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.52 2014/12/27 13:13:25 kettenis Exp $ */
d36 3
a41 1
#include <signal.h>
d49 2
d214 1
a214 1
	Elf_Addr *addr, ooff;
d218 5
a222 1
	sigset_t savedmask;
a224 1
	addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
d238 1
a238 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return ooff + this->st_value + rela->r_addend;
d240 2
a241 5
	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect(addr, sizeof(Elf_Addr), PROT_READ | PROT_WRITE);
	}
d243 2
a244 1
	*addr = ooff + this->st_value + rela->r_addend;
d246 10
a255 4
	/* if GOT is to be protected, change back to RO */
	if (object->got_size != 0) {
		_dl_mprotect(addr, sizeof(Elf_Addr), PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
d258 1
a258 1
	return *addr;
@


1.52
log
@Make ld.so process only R_ALPHA_RELATIVE relocations during early GOT
relocation in _reloc_alpha_got(), and teach RELOC_RELA() to skip R_ALPHA_NONE
relocations (which are just nops used to fill out the relocation table).
Handling R_ALPHA_NONE relocations will be necessary for static PIE support
and it is not inconceivable that ld.so will end up with such relocations
at some point.

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.51 2014/04/16 10:52:58 guenther Exp $ */
d45 2
a216 1

a217 9
	if (object->plt_size != 0 && !(*addr >=  object->plt_start &&
	    *addr < (object->plt_start + object->plt_size ))) {
		/* something is broken, relocation has already occurred */
#if 0
		DL_DEB(("*addr doesn't point into plt %p obj %s\n", 
		    *addr, object->load_name));
#endif
		return *addr;
	}
d234 2
a235 2
	/* if PLT is protected, allow the write */
	if (object->plt_size != 0) {
d237 1
a237 2
		_dl_mprotect(addr, sizeof(Elf_Addr),
		    PROT_READ|PROT_WRITE);
d242 3
a244 4
	/* if PLT is (to be protected, change back to RO/X  */
	if (object->plt_size != 0) {
		_dl_mprotect(addr, sizeof(Elf_Addr),
		    PROT_READ);
d260 1
d264 1
d266 1
d271 10
a280 5
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;
d290 15
a304 5
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		plt_addr = ooff + this->st_value;
d306 7
a312 5
	this = NULL;
	ooff = _dl_find_symbol("__plt_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;
d352 7
a358 2
		pltgot[2] = (Elf_Addr)_dl_bind_start;
		pltgot[3] = (Elf_Addr)object;
@


1.51
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.50 2013/06/13 04:13:47 brad Exp $ */
d378 2
a380 1
		/* XXX For some reason I see a few GLOB_DAT relocs here. */
@


1.50
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.49 2013/06/01 09:57:57 miod Exp $ */
d188 1
a188 1
	__asm __volatile("imb" : : : "memory");
@


1.49
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.48 2013/05/08 20:55:14 guenther Exp $ */
d236 1
a236 1
		*((int *)0) = 0;	/* XXX */
@


1.48
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.47 2012/12/05 23:20:06 deraadt Exp $ */
d211 1
d233 1
a233 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d239 3
a273 1

d318 3
@


1.47
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.46 2011/04/08 02:43:28 deraadt Exp $ */
d50 1
d53 2
d60 1
d66 5
d85 23
a107 1
	for (i = 0; i < numrela; i++, relas++) {
d160 4
d170 3
a172 1
			*r_addr = ooff + this->st_value + relas->r_addend;
@


1.46
log
@Do not use NULL in integer comparison.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.45 2011/04/06 11:36:25 miod Exp $ */
a33 1
#include <sys/cdefs.h>
@


1.45
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.44 2010/05/02 04:57:01 guenther Exp $ */
d273 1
a273 1
	if (plt_addr == NULL)
@


1.44
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.43 2008/07/28 22:11:00 kurt Exp $ */
d238 1
a238 1
	object->got_addr = NULL;
d252 1
a252 1
	plt_addr = NULL;
d266 2
a267 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d274 1
a274 1
		object->plt_start = NULL;
@


1.43
log
@Only optimize away plt relocation when obj_base == 0. Corrects
pie relocation. Assembly debugging help from kettenis@@.

okay kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.42 2008/04/09 21:45:26 kurt Exp $ */
d175 1
a175 1
	sigset_t omask, nmask;
d205 1
a205 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d216 1
a216 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.42
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.41 2008/02/24 15:47:47 drahn Exp $ */
d287 1
a287 1
		if (object->obj_type != OBJTYPE_EXE) {
@


1.41
log
@Use rounded down address when changing memory protections on the GOT, such
that we don't accidentally touch the page after the GOT.

Bug found on sparc64 affected other platforms as well.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.40 2007/11/27 16:42:17 miod Exp $ */
d56 1
a56 1
	loff = object->load_offs;
d179 1
a179 1
	addr = (Elf_Addr *)(object->load_offs + rela->r_offset);
d297 1
a297 1
				addr = (Elf_Addr *)(object->load_offs +
d299 1
a299 1
				*addr += object->load_offs;
@


1.40
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.39 2007/05/05 15:21:21 drahn Exp $ */
d308 1
a308 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.39
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.38 2006/10/28 16:06:05 drahn Exp $ */
d51 1
a51 1
	long	fails = 0;
d228 1
a228 1
void
d231 1
d285 1
a285 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d313 2
@


1.38
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.37 2006/08/06 21:45:46 kettenis Exp $ */
d207 1
d218 1
@


1.37
log
@Do not take shortcuts when the PLT size is 0; makes emacs work again on alpha.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.36 2006/08/06 16:38:10 drahn Exp $ */
d68 1
a68 1
	if ((rel == DT_REL || rel == DT_RELA)) {
d155 1
a155 1
	if ((rel == DT_REL || rel == DT_RELA)) {
@


1.36
log
@Work around an issue found when working with gcc3 on alpha,
gcc2 nomally calls functions thru the gp (basically a function pointer), but
gcc3 frequently calls directly to the plt. gcc2 does occasionally directly
call to the plt. Currently how the plt/pltgot is fixed up on lazy
binding, this will cause the dl_bind code to be called on each plt call
causing a symbol resolution and plt fixup. This diff works around the
problem partially by recognizing that a pltgot entry is already fixed
and skips the symbol resolution. Since the pltgot is what is modified
do not add PROT_EXEC permission to the mapping.
While this is not an ideal fix, kettenis and I think it is better than before.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.35 2006/02/22 19:50:21 miod Exp $ */
d180 1
a180 1
	if (!(*addr >=  object->plt_start &&
@


1.35
log
@No need to include <machine/elf_machdep.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2005/09/22 01:33:07 drahn Exp $ */
d179 11
a193 1
	addr = (Elf_Addr *)(object->load_offs + rela->r_offset);
d202 1
d208 1
a208 1
		    PROT_READ|PROT_WRITE|PROT_EXEC);
d216 1
a216 1
		    PROT_READ|PROT_EXEC);
@


1.34
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2005/09/21 23:12:09 drahn Exp $ */
a36 2

#include <machine/elf_machdep.h>
@


1.33
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2005/09/16 23:19:41 drahn Exp $ */
d151 2
a152 3
		_dl_printf("%s: %s :can't resolve reference '%s'\n",
		    _dl_progname, object->load_name, symn);
		fails++;
@


1.32
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2004/05/25 21:42:47 mickey Exp $ */
d101 1
a101 1
			    sym->st_size, NULL);
d126 1
a126 1
			    sym->st_size, object, NULL);
d135 1
a135 1
			    sym->st_size, NULL);
d189 1
a189 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
d234 1
a234 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
d240 1
a240 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
d248 1
a248 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
d254 1
a254 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
@


1.31
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2004/05/25 18:07:20 mickey Exp $ */
d99 3
a101 3
			    ELF64_R_SYM(relas->r_info), _dl_objects, &this,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym->st_size);
d124 3
a126 3
			ooff = _dl_find_symbol(symn, _dl_objects, &this,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT,
			    sym->st_size, object);
d133 3
a135 3
			    ELF64_R_SYM(relas->r_info), _dl_objects, &this,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym->st_size);
d188 3
a190 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d233 2
a234 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d239 2
a240 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d247 2
a248 2
	ooff = _dl_find_symbol("__plt_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d253 2
a254 2
	ooff = _dl_find_symbol("__plt_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
@


1.30
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2003/09/05 03:56:58 drahn Exp $ */
a46 12

void
_dl_bcopy(const void *src, void *dest, int size)
{
	unsigned const char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++) {
		pdest[i] = psrc[i];
	}
}
@


1.29
log
@Put in workaround for alpha so that non-lazy binding seems to work,
however it is using some of the lazy binding values. With this patch
LD_BIND_NOW=yes make does not core. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2003/09/04 19:37:07 drahn Exp $ */
d112 1
a112 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
d137 1
a137 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT,
d146 1
a146 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
d200 1
a200 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
d244 1
a244 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d250 1
a250 1
	ooff = _dl_find_symbol("__got_end", object, &this,
d258 1
a258 1
	ooff = _dl_find_symbol("__plt_start", object, &this,
d264 1
a264 1
	ooff = _dl_find_symbol("__plt_end", object, &this,
@


1.28
log
@Fix W^X mistake. If the dynamic linker is workin in non-lazy mode, it
should still mprotect the GOT and PLT as appropriate. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2003/09/04 19:33:49 drahn Exp $ */
d302 2
a303 1

@


1.27
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2003/09/02 15:17:51 drahn Exp $ */
d286 16
a301 2
		return;
	}
d303 2
a304 12
	if (object->obj_type != OBJTYPE_EXE) {
		int i, size;
		Elf_Addr *addr;
		Elf_RelA *rela;

		size = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf_RelA);
		rela = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);

		for (i = 0; i < size; i++) {
			addr = (Elf_Addr *)(object->load_offs + rela[i].r_offset);
			*addr += object->load_offs;
		}
a305 3

	pltgot[2] = (Elf_Addr)_dl_bind_start;
	pltgot[3] = (Elf_Addr)object;
@


1.26
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2003/07/28 03:11:00 drahn Exp $ */
d110 2
a111 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this,
d113 1
a113 1
			    sym->st_size, object);
d144 2
a145 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this,
d147 1
a147 1
			    sym->st_size, object);
@


1.25
log
@The fifth argument to _dl_find_symbol is a 'int size', not a SYM_ define.
Fix several calls which had the incorrect but working define in that position
It happened that SYM_NOTPLT was 0, which was the desired size value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2003/07/06 20:04:00 deraadt Exp $ */
d112 1
a112 1
			    sym->st_size, object->load_name);
d137 1
a137 1
			    sym->st_size, object->load_name);
d145 1
a145 1
			    sym->st_size, object->load_name);
d199 1
a199 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
	    object->load_name);
d243 1
a243 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d249 1
a249 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d257 1
a257 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d263 1
a263 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
@


1.24
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2003/06/03 16:20:40 art Exp $ */
d244 1
a244 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d250 1
a250 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d258 1
a258 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d264 1
a264 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
@


1.23
log
@three four gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2003/03/07 02:06:44 drahn Exp $ */
d36 1
d49 1
a49 1
_dl_bcopy(void *src, void *dest, int size)
d51 2
a52 1
	unsigned char *psrc, *pdest;
d54 1
a54 2
	psrc = src;
	pdest = dest;
d181 2
a182 2
void *
_dl_bind(elf_object_t *object, Elf_Word reloff)
d222 1
a222 1
	return (void *)*addr;
a285 2
	 

d318 2
d321 1
a321 3
_reloc_alpha_got(dynp, relocbase)
	Elf_Dyn *dynp;
	Elf_Addr relocbase;
@


1.22
log
@Fix cut and paste on wrong line bugs, now like other versions. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2003/02/15 22:39:13 drahn Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.21
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2003/01/17 20:41:07 drahn Exp $ */
d315 1
a315 1
	if (object->got_addr != NULL && object->got_size != 0)
d317 2
a318 2
		    PROT_READ|PROT_EXEC);
	if (object->got_size != 0)
@


1.20
log
@Change the GOT initialization so that it is done in a function which
initialized just the correct addresses instead of assuming that the GOT
extends from _GLOBAL_OFFSET_TABLE_ to _DYNAMIC. Mostly from NetBSD.
ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2003/01/16 19:56:37 drahn Exp $ */
d211 1
a211 1
	if (object->plt_addr != NULL && object->plt_size != 0) {
d221 1
a221 1
	if (object->plt_addr != NULL && object->plt_size != 0) {
d239 1
d245 2
d261 2
d268 1
a268 1
		object->plt_addr = ooff + this->st_value;
d275 18
a292 1
		object->plt_size = ooff + this->st_value  - object->plt_addr;
d318 2
a319 2
	if (object->plt_addr != NULL && object->got_size != 0)
		_dl_mprotect((void*)object->plt_addr, object->plt_size,
@


1.19
log
@whitespace removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2002/12/18 19:20:01 drahn Exp $ */
d299 29
@


1.18
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2002/11/14 15:15:54 drahn Exp $ */
d215 1
a215 1
		    PROT_READ|PROT_WRITE|PROT_EXEC); 
d250 1
a250 1
 
d257 1
a257 1
 
d264 1
a264 1
	 
d293 1
a293 1
	if (object->got_addr != NULL && object->got_size != 0) 
d296 1
a296 1
	if (object->plt_addr != NULL && object->got_size != 0) 
@


1.17
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2002/09/01 23:55:01 drahn Exp $ */
d47 1
d193 1
d210 8
d219 8
d238 3
d244 28
d293 6
@


1.16
log
@Make sure that the symbol return value is always initialized before
the address of it is passed to dl_find_symbol(). fixes xpdf lazy
binding problem. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2002/08/23 22:57:03 drahn Exp $ */
d116 1
a116 1
			    sym->st_size);
d141 1
a141 1
			    sym->st_size);
d149 1
a149 1
			    sym->st_size);
d202 2
a203 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size);
@


1.15
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2002/08/11 16:51:04 drahn Exp $ */
d200 1
@


1.14
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2002/07/07 08:54:50 jufi Exp $ */
d114 3
a116 2
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1,
			    0);
d139 3
a141 2
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1,
			    1);
d147 3
a149 2
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1,
			    0);
d200 2
a201 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1, 1);
@


1.13
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2002/06/05 23:13:55 art Exp $ */
d114 2
a115 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
d138 2
a139 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
d145 2
a146 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
d197 1
a197 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
@


1.12
log
@Cleanup/remove duplicate code that checks STAT_RELOC_DONE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2002/06/05 19:34:44 art Exp $ */
d83 1
a83 1
	 * XXX - we unprotect waay to much. only the text can have cow
@


1.11
log
@Get rid of an unnecessary typedef (for future cleanup).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2002/05/24 04:17:00 deraadt Exp $ */
d78 1
a78 1
	if ((object->status & STAT_RELOC_DONE) || !relas)
@


1.10
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2002/05/24 03:44:37 deraadt Exp $ */
d72 1
a72 1
	load_list_t *llist;
@


1.9
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2001/06/26 18:43:06 art Exp $ */
d74 1
a74 1
	loff   = object->load_offs;
d84 1
a84 1
	 *       relocations.
@


1.8
log
@Lazy binding for shared libraries.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2001/06/13 08:45:34 art Exp $ */
d7 1
a7 1
 * 
d78 1
a78 1
	if ((object->status & STAT_RELOC_DONE) || !relas) {
a79 1
	}
d90 1
a90 1
					llist->prot|PROT_WRITE);
d103 1
a103 1
		if (ELF64_R_SYM(relas->r_info) == 0xffffffff) {
d105 1
a105 1
		}
d128 1
a128 1
ELF_R_TYPE(relas->r_info), object->load_name, *r_addr, *r_addr+loff);
d133 1
a133 1
			} else {
a134 1
			}
d152 3
a154 3
				" %s: unsupported relocation '%s' %d at %lx\n",
					_dl_progname, object->load_name, symn,
					ELF64_R_TYPE(relas->r_info), r_addr );
d160 1
a160 1
			_dl_progname, object->load_name, symn);
d168 1
a168 1
			if (!(llist->prot & PROT_WRITE)) {
d170 1
a170 2
					llist->prot);
			}
a172 1

a199 1

@


1.7
log
@Add support for lazy binding.
For now we only do it for the main executable, some code cleanup is
necessary to support it for libraries.

This fixes the problem I had in cc1plus and I'm able to finish a make build
with shared libraries enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2001/06/05 14:52:26 art Exp $ */
d219 1
a219 1
	if (object->obj_type != OBJTYPE_EXE || !lazy || pltgot == NULL) {
d222 14
@


1.6
log
@gcc generates a lot of unaligned RELATIVE relocations for c++ exception handlers.
Workaround that.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2001/05/31 23:49:08 art Exp $ */
d128 2
a129 3
_dl_printf("unaligned RELATIVE: %p type: %d %s:%s 0x%lx -> 0x%lx\n", r_addr,
ELF_R_TYPE(relas->r_info), object->load_name, symn, *r_addr,
*r_addr+loff);
d142 1
a142 1
			*r_addr = ooff + this->st_value;
a151 1

d181 28
d214 12
a225 1
	/* no got relocations until lazy binding */
@


1.5
log
@Apparently GLOB_DAT needs r_addend.
"Hello, world!\n" now works with libc.so
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2001/05/31 22:10:49 art Exp $ */
d121 17
a137 1
			*r_addr += loff;
@


1.4
log
@Some cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2001/05/31 13:49:27 art Exp $ */
d133 1
a133 1
			*r_addr = ooff + this->st_value;
@


1.3
log
@Remove write protection from some memory segments when
doing rel and rela relocations.
XXX - we have to find out when and why we actually need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2001/05/31 13:26:51 art Exp $ */
d6 1
a109 1
		this = sym;
d112 1
d121 1
a121 5
#if 0
			if ((caddr_t)r_addr < (caddr_t)_GLOBAL_OFFSET_TABLE_ ||
			    (caddr_t)r_addr >= (caddr_t)&_DYNAMIC)
#endif
				*r_addr += loff;
a134 52
		case R_TYPE(COPY):
_dl_printf("copy relocation, not tested\n");
			ooff = _dl_find_symbol(symn, _dl_objects, &this, 0, 1);
			if (this == NULL)
				goto resolve_failed;
#ifdef DL_PRINTF_DEBUG
			_dl_printf("copy r_addr %lx, sym %x [%s] size %d val %lx\n",
				r_addr, sym, symn, sym->st_size,
				(ooff + this->st_value+
				relas->r_addend)

				);
#endif
{
	/* we need to find a symbol, that is not in the current object,
	 * start looking at the beginning of the list, searching all objects
	 * but _not_ the current object, first one found wins.
	 */
	elf_object_t *cobj;
	const Elf64_Sym *cpysrc = NULL;
	Elf64_Addr src_loff = 0;
	int size;
	for (cobj = _dl_objects;
		cobj != NULL && cpysrc == NULL;
		cobj = cobj->next)
	{
		if (object != cobj) {

			/* only look in this object */
			src_loff = _dl_find_symbol(symn, cobj,
				&cpysrc, 1, 1);
		}
	}
	if (cpysrc == NULL) {
		_dl_printf("symbol not found [%s] \n", symn);
	} else {
		size  = sym->st_size;
		if (sym->st_size != cpysrc->st_size) {
			_dl_printf("symbols size differ [%s] \n", symn);
			size = sym->st_size < cpysrc->st_size ?
				sym->st_size : cpysrc->st_size;
		}
#ifdef DL_PRINTF_DEBUG
_dl_printf(" found other symbol at %x size %d\n", 
		src_loff + cpysrc->st_value,  cpysrc->st_size);
#endif
		_dl_bcopy((void *)(src_loff + cpysrc->st_value),
			(void *)(ooff + this->st_value+ relas->r_addend),
			size);
	}
}
			break;
d167 1
a167 7
 *	Relocate the Global Offset Table (GOT). Currently we don't
 *	do lazy evaluation here because the GNU linker doesn't
 *	follow the ABI spec which says that if an external symbol
 *	is referenced by other relocations than CALL16 and 26 it
 *	should not be given a stub and have a zero value in the
 *	symbol table. By not doing so, we can't use pointers to
 *	external functions and use them in comparitions...
d172 1
a172 1
	/* relocations all done via rela relocations above */
@


1.2
log
@Correctly implement most linking for alpha.
Remove a lot of code copied from powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2001/05/14 22:18:21 niklas Exp $ */
d40 1
d71 1
d81 14
d207 12
a218 1
	return(fails);
@


1.1
log
@Commit initial alpha bits, to facilitate in-tree dev.
This code is not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2000/10/06 17:39:30 rahnds Exp $ */
d65 3
a67 3
	int	i;
	int	numrela;
	int	fails = 0;
a69 5
	/* for jmp table relocations */
	Elf64_Addr *pltcall;
	Elf64_Addr *plttable;

	Elf64_Addr * first_rela;
d75 1
a75 6
#ifdef DL_PRINTF_DEBUG
_dl_printf("loff 0x%lx object relocation size %x, numrela %x\n", loff,
	object->Dyn.info[relasz], numrela);
#endif

	if((object->status & STAT_RELOC_DONE) || !relas) {
a77 18
	/* for plt relocation usage */
	if (object->Dyn.info[DT_JMPREL] != 0) {
		/* resolver stub not set up */
		Elf64_Addr val;

		first_rela = (Elf64_Addr *)
		(((Elf64_Rela *)(object->Dyn.info[DT_JMPREL]))->r_offset
			+ loff);
		/* Need to construct table to do jumps */
		pltcall = (Elf64_Addr *)(first_rela) - 12;
#ifdef DL_PRINTF_DEBUG
_dl_printf("creating pltcall at %p\n", pltcall);
_dl_printf("md_reloc( jumprel %p\n", first_rela );
#endif
		plttable = (Elf64_Addr *)
			((Elf64_Addr)first_rela) + (2 *
			(object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf64_Rela))
			);
d79 2
a80 12
#ifdef DL_PRINTF_DEBUG
_dl_printf("md_reloc:  plttbl size %x\n", 
			(object->Dyn.info[DT_PLTRELSZ]/sizeof(Elf64_Rela))
);
_dl_printf("md_reloc: plttable %p\n", plttable);
#endif
	} else {
		first_rela = NULL;
	}

	for(i = 0; i < numrela; i++, relas++) {
		Elf64_Addr *r_addr = (Elf64_Addr *)(relas->r_offset + loff);
d85 1
a85 3
#if 0
_dl_printf("%d offset 0x%lx info 0x%lx addend 0x%lx\n", i, relas->r_offset, relas->r_info, relas->r_addend);
#endif
d87 1
a87 1
		if(ELF64_R_SYM(relas->r_info) == 0xffffff) {
d96 2
a97 4
		if(ELF64_R_SYM(relas->r_info) &&
		   !(ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
		     ELF64_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
			
d99 3
a101 24
			if(!this && ELF64_ST_BIND(sym->st_info) == STB_GLOBAL) {
				_dl_printf("%s:"
					" %s :can't resolve reference '%s'\n",
					_dl_progname, object->load_name,
					symn);
				fails++;
			}

		}

#if 0
_dl_printf("reloc %d\n", ELF64_R_TYPE(relas->r_info));
#endif
		switch(ELF64_R_TYPE(relas->r_info)) {
#if 1
		case R_TYPE(REFQUAD):
			if(ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
			   (ELF64_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF64_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
				*r_addr = ooff + relas->r_addend;
			} else {
				*r_addr = ooff + this->st_value +
					relas->r_addend;
			}
a102 1
#endif
d105 2
a106 22
_dl_printf("sym info %d r_addr %p relas %p\n", sym->st_info, r_addr, relas);
#endif
			if(ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
			   (ELF64_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF64_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
#if 0
_dl_printf("addend 0x%lx\n", relas->r_addend);
_dl_printf("*r_addr 0x%lx\n", *r_addr);
#endif
				*r_addr = loff + relas->r_addend;
#if 0
_dl_printf("*r_addr 0x%lx\n", *r_addr);
#endif

#ifdef DL_PRINTF_DEBUG
_dl_printf("rel1 r_addr %p val %lx loff %lx ooff %lx addend %lx\n", r_addr,
loff + relas->r_addend, loff, ooff, relas->r_addend);
#endif

			} else {
#if 0
_dl_printf("this %p\n", this);
d108 1
a108 3
				*r_addr = loff + this->st_value +
					relas->r_addend;
			}
d111 4
a114 62
		   {
			Elf64_Addr val = ooff + this->st_value +
				relas->r_addend - (Elf64_Addr)r_addr;
			if (!(((val & 0xfe000000) == 0x00000000) || 
				((val &  0xfe000000) == 0xfe000000)))
			{
				int index;
#ifdef DL_PRINTF_DEBUG
_dl_printf(" ooff %lx, sym val %lx, addend %lx"
	" r_addr %lx symn [%s] -> %x\n",
	ooff, this->st_value, relas->r_addend,
	r_addr, symn, val);
#endif
				/* if offset is > RELOC_24 deal with it */
				index = (r_addr - first_rela) >> 1;

				if (index > (2 << 14)) {

					/* addis r11,r11,.PLTtable@@ha*/
					val = (index*4 >> 16) +
						((index*4 & 0x00008000) >> 15);
					r_addr[0] = 0x3d600000 | val;
					val = (Elf64_Addr)pltcall -
						(Elf64_Addr)&r_addr[2];
					r_addr[1] = 0x396b0000 | val; 
					val &= ~0xfc000000;
					val |=  0x48000000;
					r_addr[2] = val;

				} else {
#ifdef DL_PRINTF_DEBUG
	_dl_printf("  index %d, pltcall %x r_addr %lx\n",
		index, pltcall, r_addr);
#endif

					r_addr[0] = 0x39600000 | (index * 4);
					val = (Elf64_Addr)pltcall -
						(Elf64_Addr)&r_addr[1];
					val &= ~0xfc000000;
					val |=  0x48000000;
					r_addr[1] = val;

				}
				_dl_dcbf(r_addr);
				_dl_dcbf(&r_addr[2]);
				val= ooff + this->st_value +
					relas->r_addend;
#ifdef DL_PRINTF_DEBUG
		_dl_printf(" symn [%s] val 0x%x\n", symn, val);
#endif
				plttable[index] = val;
			} else {
				/* if the offset is small enough, 
				 * branch directy to the dest
				 */
				val &= ~0xfc000000;
				val |=  0x48000000;
				*r_addr = val;	
				_dl_dcbf(r_addr);
			}
		   }

d117 4
a120 46
			*r_addr = ooff + this->st_value + relas->r_addend;
			break;
#if 0
#ifdef DL_PRINTF_DEBUG
		/* should not be supported ??? */
		case RELOC_REL24:
			{
			Elf64_Addr val = ooff + this->st_value +
				relas->r_addend - (Elf64_Addr)r_addr;
			if ((val & 0xfe000000 != 0) &&
				(val & 0xfe000000 != 0xfe000000))
			{
				/* invalid offset */
				_dl_exit(20);
			}
			val &= ~0xfc000003;
			val |=  (*r_addr & 0xfc000003);
			*r_addr = val;	
				
			_dl_dcbf(r_addr);
			}
#endif
			break;
		case RELOC_REL14_TAKEN:
			/* val |= 1 << (31-10) XXX? */
		case RELOC_REL14:
		case RELOC_REL14_NTAKEN:
			{
			Elf64_Addr val = ooff + this->st_value +
				relas->r_addend - (Elf64_Addr)r_addr;
			if (((val & 0xffff8000) != 0) &&
				((val & 0xffff8000) != 0xffff8000))
			{
				/* invalid offset */
				_dl_exit(20);
			}
			val &= ~0xffff0003;
			val |=  (*r_addr & 0xffff0003);
			*r_addr = val;	
#ifdef DL_PRINTF_DEBUG
			_dl_printf("rel 14 %lx val %lx\n", 
				r_addr, val);
#endif
				
			_dl_dcbf(r_addr);
			}
a121 1
#endif
d123 4
d142 1
a142 1
	Elf64_Addr src_loff;
d184 5
d190 1
a190 4
	object->status |= STAT_RELOC_DONE;
#if 0
_dl_printf("<\n");
#endif
a206 13
}

/* should not be defined here, but is is 32 for all powerpc 603-G4 */
#define CACHELINESIZE 32
void
_dl_syncicache(char *from, size_t len)
{
        int l = len;
	unsigned int off = 0;

	while (off < len) {
                off += CACHELINESIZE;
        }
@

