head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.6
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.54.0.2
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.49.0.6
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.44.0.8
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.4
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.36.0.8
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.8
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.6
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.4
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13;
locks; strict;
comment	@ * @;


1.57
date	2017.01.24.07.48.36;	author guenther;	state Exp;
branches;
next	1.56;
commitid	veGB6uLWx3BTEAfk;

1.56
date	2016.08.12.20.39.01;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	9Gsc7gGSE2YeEbd8;

1.55
date	2016.08.08.21.59.20;	author guenther;	state Exp;
branches;
next	1.54;
commitid	PufSD0ERJAhj0Sd1;

1.54
date	2016.07.04.21.15.06;	author guenther;	state Exp;
branches;
next	1.53;
commitid	qHDzpShMNCJZKLBF;

1.53
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.52;
commitid	d9R7VGw9CHTkwXE1;

1.52
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.51;
commitid	Kpc3J4Ry51yjfQid;

1.51
date	2015.12.22.08.54.16;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	sTDrw9FlbNNwVprE;

1.50
date	2015.11.06.05.12.30;	author guenther;	state Exp;
branches;
next	1.49;
commitid	QyXWPc6ZNUAPw1ll;

1.49
date	2015.01.22.05.48.17;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	GZoxg3rKKQGZ5hZT;

1.48
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	31KwZ9PARAKUg1ob;

1.47
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.46;
commitid	ImRWDrCXNlhODvC7;

1.46
date	2014.07.09.12.54.03;	author guenther;	state Exp;
branches;
next	1.45;
commitid	0KayvPMeoDHeGivt;

1.45
date	2014.06.21.08.00.23;	author otto;	state Exp;
branches;
next	1.44;
commitid	wh9FTpEgwThWVeqE;

1.44
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.21.06.46.58;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2012.06.12.20.32.17;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	2012.05.08.14.32.01;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.09.17.01.22;	author ariane;	state Exp;
branches;
next	1.39;

1.39
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.16.18.59.00;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.10.03.26.50;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.09.16.41.29;	author kurt;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.01.19.32.22;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.28.21.56.24;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.27.14.47.00;	author kurt;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.26.14.51.05;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.31.14.31.36;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.30.23.31.16;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.23.19.22.11;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.23.19.48.05;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.22.18.03.39;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.05.00.47.40;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.14.09.02;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.02.08.18.03;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.28.21.32.08;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.25.20.32.07;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.25.18.30.18;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.21.14.35.50;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.18.12.38.39;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.17.03.40.45;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.57
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: library_mquery.c,v 1.56 2016/08/12 20:39:01 deraadt Exp $ */

/*
 * Copyright (c) 2002 Dale Rahn
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"
#include "sod.h"

#define PFLAGS(X) ((((X) & PF_R) ? PROT_READ : 0) | \
		   (((X) & PF_W) ? PROT_WRITE : 0) | \
		   (((X) & PF_X) ? PROT_EXEC : 0))

void
_dl_load_list_free(struct load_list *load_list)
{
	struct load_list *next;
	Elf_Addr align = _dl_pagesz - 1;

	while (load_list != NULL) {
		if (load_list->start != NULL)
			_dl_munmap(load_list->start,
			    ((load_list->size) + align) & ~align);
		next = load_list->next;
		_dl_free(load_list);
		load_list = next;
	}
}


void
_dl_unload_shlib(elf_object_t *object)
{
	struct dep_node *n;
	elf_object_t *load_object = object->load_object;

	/*
	 * If our load object has become unreferenced then we lost the
	 * last group reference to it, so the entire group should be taken
	 * down.  The current object is somewhere below load_object in
	 * the child_list tree, so it'll get cleaned up by the recursion.
	 * That means we can just switch here to the load object.
	 */
	if (load_object != object && OBJECT_REF_CNT(load_object) == 0 &&
	    (load_object->status & STAT_UNLOADED) == 0) {
		DL_DEB(("unload_shlib switched from %s to %s\n",
		    object->load_name, load_object->load_name));
		object = load_object;
		goto unload;
	}

	DL_DEB(("unload_shlib called on %s\n", object->load_name));
	if (OBJECT_REF_CNT(object) == 0 &&
	    (object->status & STAT_UNLOADED) == 0) {
unload:
		object->status |= STAT_UNLOADED;
		TAILQ_FOREACH(n, &object->child_list, next_sib)
			_dl_unload_shlib(n->data);
		TAILQ_FOREACH(n, &object->grpref_list, next_sib)
			_dl_unload_shlib(n->data);
		DL_DEB(("unload_shlib unloading on %s\n", object->load_name));
		_dl_load_list_free(object->load_list);
		_dl_remove_object(object);
	}
}


elf_object_t *
_dl_tryload_shlib(const char *libname, int type, int flags)
{
	int libfile, i;
	struct load_list *ld, *lowld = NULL;
	elf_object_t *object;
	Elf_Dyn *dynp = NULL;
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdp;
	Elf_Addr load_end = 0;
	Elf_Addr align = _dl_pagesz - 1, off, size;
	Elf_Phdr *ptls = NULL;
	Elf_Addr relro_addr = 0, relro_size = 0;
	struct stat sb;
	char hbuf[4096];

#define ROUND_PG(x) (((x) + align) & ~(align))
#define TRUNC_PG(x) ((x) & ~(align))

	libfile = _dl_open(libname, O_RDONLY | O_CLOEXEC);
	if (libfile < 0) {
		_dl_errno = DL_CANT_OPEN;
		return(0);
	}

	if ( _dl_fstat(libfile, &sb) < 0) {
		_dl_errno = DL_CANT_OPEN;
		return(0);
	}

	for (object = _dl_objects; object != NULL; object = object->next) {
		if (object->dev == sb.st_dev &&
		    object->inode == sb.st_ino) {
			object->obj_flags |= flags & DF_1_GLOBAL;
			_dl_close(libfile);
			if (_dl_loading_object == NULL)
				_dl_loading_object = object;
			if (object->load_object != _dl_objects &&
			    object->load_object != _dl_loading_object) {
				_dl_link_grpref(object->load_object,
				    _dl_loading_object);
			}
			return(object);
		}
	}

	_dl_read(libfile, hbuf, sizeof(hbuf));
	ehdr = (Elf_Ehdr *)hbuf;
	if (ehdr->e_ident[0] != ELFMAG0  || ehdr->e_ident[1] != ELFMAG1 ||
	    ehdr->e_ident[2] != ELFMAG2 || ehdr->e_ident[3] != ELFMAG3 ||
	    ehdr->e_type != ET_DYN || ehdr->e_machine != MACHID) {
		_dl_close(libfile);
		_dl_errno = DL_NOT_ELF;
		return(0);
	}

	/* Insertion sort */
#define LDLIST_INSERT(ld) do { \
	struct load_list **_ld; \
	for (_ld = &lowld; *_ld != NULL; _ld = &(*_ld)->next) \
		if ((*_ld)->moff > ld->moff) \
			break; \
	ld->next = *_ld; \
	*_ld = ld; \
} while (0)
	/*
	 *  Alright, we might have a winner!
	 *  Figure out how much VM space we need and set up the load
	 *  list that we'll use to find free VM space.
	 */
	phdp = (Elf_Phdr *)(hbuf + ehdr->e_phoff);
	for (i = 0; i < ehdr->e_phnum; i++, phdp++) {
		switch (phdp->p_type) {
		case PT_LOAD:
			off = (phdp->p_vaddr & align);
			size = off + phdp->p_filesz;

			if (size != 0) {
				ld = _dl_malloc(sizeof(struct load_list));
				if (ld == NULL)
					_dl_oom();
				ld->start = NULL;
				ld->size = size;
				ld->moff = TRUNC_PG(phdp->p_vaddr);
				ld->foff = TRUNC_PG(phdp->p_offset);
				ld->prot = PFLAGS(phdp->p_flags);
				LDLIST_INSERT(ld);
			}

			if ((PFLAGS(phdp->p_flags) & PROT_WRITE) == 0 ||
			    ROUND_PG(size) == ROUND_PG(off + phdp->p_memsz))
				break;
			/* This phdr has a zfod section */
			ld = _dl_calloc(1, sizeof(struct load_list));
			if (ld == NULL)
				_dl_oom();
			ld->start = NULL;
			ld->size = ROUND_PG(off + phdp->p_memsz) -
			    ROUND_PG(size);
			ld->moff = TRUNC_PG(phdp->p_vaddr) +
			    ROUND_PG(size);
			ld->foff = -1;
			ld->prot = PFLAGS(phdp->p_flags);
			LDLIST_INSERT(ld);
			break;
		case PT_DYNAMIC:
			dynp = (Elf_Dyn *)phdp->p_vaddr;
			break;
		case PT_TLS:
			if (phdp->p_filesz > phdp->p_memsz) {
				_dl_printf("%s: invalid tls data in %s.\n",
				    __progname, libname);
				_dl_close(libfile);
				_dl_errno = DL_CANT_LOAD_OBJ;
				return(0);
			}
			if (!_dl_tib_static_done) {
				ptls = phdp;
				break;
			}
			_dl_printf("%s: unsupported TLS program header in %s\n",
			    __progname, libname);
			_dl_close(libfile);
			_dl_errno = DL_CANT_LOAD_OBJ;
			return(0);
		default:
			break;
		}
	}

#define LOFF ((Elf_Addr)lowld->start - lowld->moff)

retry:
	for (ld = lowld; ld != NULL; ld = ld->next) {
		off_t foff;
		int fd, flags;
		void *res;

		flags = MAP_PRIVATE;
		if (LOFF + ld->moff != 0)
			flags |= MAP_FIXED | __MAP_NOREPLACE;

		if (ld->foff < 0) {
			fd = -1;
			foff = 0;
			flags |= MAP_ANON;
		} else {
			fd = libfile;
			foff = ld->foff;
		}

		res = _dl_mmap((void *)(LOFF + ld->moff), ROUND_PG(ld->size),
		    ld->prot, flags, fd, foff);
		if (_dl_mmap_error(res)) {
			/*
			 * The mapping we wanted isn't free, so we do an
			 * mquery without MAP_FIXED to get the next free
			 * mapping, adjust the base mapping address to match
			 * this free mapping and restart the process again.
			 *
			 * XXX - we need some kind of boundary condition
			 * here, or fix mquery to not run into the stack
			 */
			res = _dl_mquery((void *)(LOFF + ld->moff),
			    ROUND_PG(ld->size), ld->prot,
			    flags & ~(MAP_FIXED | __MAP_NOREPLACE), fd, foff);

			/*
			 * If ld == lowld, then ld->start is just a hint and
			 * thus shouldn't be unmapped.
			 */
			ld->start = NULL;

			/* Unmap any mappings that we did get in. */
			for (ld = lowld; ld != NULL; ld = ld->next) {
				if (ld->start == NULL)
					break;
				_dl_munmap(ld->start, ROUND_PG(ld->size));
				ld->start = NULL;
			}

			/* if the mquery failed, give up */
			if (_dl_mmap_error(res))
				goto fail;

			/* otherwise, reset the start of the base mapping */
			lowld->start = res - ld->moff + lowld->moff;
			goto retry;
		}

		ld->start = res;
	}

	for (ld = lowld; ld != NULL; ld = ld->next) {
		/* Zero out everything past the EOF */
		if ((ld->prot & PROT_WRITE) != 0 && (ld->size & align) != 0)
			_dl_memset((char *)ld->start + ld->size, 0,
			    _dl_pagesz - (ld->size & align));
		load_end = (Elf_Addr)ld->start + ROUND_PG(ld->size);
	}

	phdp = (Elf_Phdr *)(hbuf + ehdr->e_phoff);
	for (i = 0; i < ehdr->e_phnum; i++, phdp++) {
		if (phdp->p_type == PT_OPENBSD_RANDOMIZE)
			_dl_arc4randombuf((char *)(phdp->p_vaddr + LOFF),
			    phdp->p_memsz);
		else if (phdp->p_type == PT_GNU_RELRO) {
			relro_addr = phdp->p_vaddr + LOFF;
			relro_size = phdp->p_memsz;
		}
	}

	_dl_close(libfile);

	dynp = (Elf_Dyn *)((unsigned long)dynp + LOFF);
	object = _dl_finalize_object(libname, dynp,
	    (Elf_Phdr *)((char *)lowld->start + ehdr->e_phoff), ehdr->e_phnum,
	    type, (Elf_Addr)lowld->start, LOFF);
	if (object) {
		object->load_size = (Elf_Addr)load_end - (Elf_Addr)lowld->start;
		object->load_list = lowld;
		/* set inode, dev from stat info */
		object->dev = sb.st_dev;
		object->inode = sb.st_ino;
		object->obj_flags |= flags;
		object->relro_addr = relro_addr;
		object->relro_size = relro_size;
		_dl_set_sod(object->load_name, &object->sod);
		if (ptls != NULL && ptls->p_memsz)
			_dl_set_tls(object, ptls, (Elf_Addr)lowld->start,
			    libname);
	} else {
		_dl_load_list_free(lowld);
	}
	return(object);
fail:
	_dl_printf("%s: rtld mmap failed mapping %s.\n", __progname, libname);
	_dl_close(libfile);
	_dl_errno = DL_CANT_MMAP;
	_dl_load_list_free(lowld);
	return(0);
}
@


1.56
log
@the slimmed down random functions inside ld.so are strict clones of the
libc arc4random API, so call them _dl_{arc4random,arcrandombuf}
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.55 2016/08/08 21:59:20 guenther Exp $ */
d179 1
a179 1
					_dl_exit(7);
d194 1
a194 1
				_dl_exit(7);
@


1.55
log
@Look for a PT_GNU_RELRO section per object and, if present, mprotect that
range instead of the [__got_start, __got_end) range.
On many archs this will cover _DYNAMIC too, so move up the DT_DEBUG handling
to before relocations and the mprotect are done.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.54 2016/07/04 21:15:06 guenther Exp $ */
d303 1
a303 1
			_dl_randombuf((char *)(phdp->p_vaddr + LOFF),
@


1.54
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.53 2016/05/07 19:05:23 guenther Exp $ */
d111 1
d301 1
a301 1
	for (i = 0; i < ehdr->e_phnum; i++, phdp++)
d305 5
d324 2
@


1.53
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.52 2016/03/20 02:29:51 guenther Exp $ */
a34 1
#include "dl_prebind.h"
a111 1
	void *prebind_data;
a304 2
	prebind_data = prebind_load_fd(libfile, libname);

a311 1
		object->prebind_data = prebind_data;
@


1.52
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.51 2015/12/22 08:54:16 mmcc Exp $ */
d111 1
d209 11
d324 3
@


1.51
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.50 2015/11/06 05:12:30 guenther Exp $ */
d209 1
a209 1
			    _dl_progname, libname);
d317 1
a317 2
	_dl_printf("%s: rtld mmap failed mapping %s.\n",
	    _dl_progname, libname);
@


1.50
log
@Fix unloading of load groups when the last reference wasn't on the
load_object but rather some descendent.  Detect that case in
_dl_unload_shlib() and switch to unloading the entire group.

Based on partial analyses by Henri Kemppainen (duclare (at) guu.fi)
and Peter Hajdu (peter.ferenc.hajdu (at) gmail.com)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.49 2015/01/22 05:48:17 deraadt Exp $ */
d106 1
a106 1
	Elf_Dyn *dynp = 0;
@


1.49
log
@delete annoying white space that annoy
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.48 2015/01/16 16:18:07 deraadt Exp $ */
d67 16
d87 1
@


1.48
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.47 2014/07/10 09:03:01 otto Exp $ */
d283 1
a283 1
	object = _dl_finalize_object(libname, dynp, 
@


1.47
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.46 2014/07/09 12:54:03 guenther Exp $ */
a32 1
#include <sys/param.h>
@


1.46
log
@Use O_CLOEXEC to make sure fork+exec in a threaded process can't
see the fds used by dlopen()

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.45 2014/06/21 08:00:23 otto Exp $ */
a160 1
				/* XXX */
d162 2
d177 2
@


1.45
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.44 2012/08/20 23:25:07 matthew Exp $ */
d102 1
a102 1
	libfile = _dl_open(libname, O_RDONLY);
@


1.44
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.43 2012/07/21 06:46:58 matthew Exp $ */
d161 1
d175 1
a175 1
			ld = _dl_malloc(sizeof(struct load_list));
@


1.43
log
@Add a new mmap(2) flag __MAP_NOREMAP for use with MAP_FIXED to
indicate that the kernel should fail with MAP_FAILED if the specified
address is not currently available instead of unmapping it.

Change ld.so on i386 to make use of __MAP_NOREMAP to improve
reliability.

__MAP_NOREMAP diff by guenther based on an earlier diff by Ariane;
ld.so bits by guenther and me
bulk build stress testing of earlier diffs by sthen
ok deraadt; committing now for further testing
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.42 2012/06/12 20:32:17 matthew Exp $ */
d268 6
@


1.42
log
@Fix loaded object sod matching: when we load libfoo.so.X.Y into
memory, we should be able to match other requests for libfoo.so.X.Z
against that same object.

ok kurt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.41 2012/05/08 14:32:01 jsing Exp $ */
d204 5
d210 5
a214 7
		/*
		 * We don't want to provide the fd/off hint for anything
		 * but the first mapping, all other might have
		 * cache-incoherent aliases and will cause this code to
		 * loop forever.
		 */
		if (ld == lowld) {
a216 5
			flags = 0;
		} else {
			fd = -1;
			foff = 0;
			flags = MAP_FIXED;
d219 29
a247 1
		ld->start = (void *)(LOFF + ld->moff);
d249 2
a250 15
		/*
		 * Magic here.
		 * The first mquery is done with MAP_FIXED to see if
		 * the mapping we want is free. If it's not, we redo the
		 * mquery without MAP_FIXED to get the next free mapping,
		 * adjust the base mapping address to match this free mapping
		 * and restart the process again.
		 */
		ld->start = _dl_mquery(ld->start, ROUND_PG(ld->size), ld->prot,
		    flags, fd, foff);
		if (_dl_mmap_error(ld->start)) {
			ld->start = (void *)(LOFF + ld->moff);
			ld->start = _dl_mquery(ld->start, ROUND_PG(ld->size),
			    ld->prot, flags & ~MAP_FIXED, fd, foff);
			if (_dl_mmap_error(ld->start))
a251 1
		}
d253 2
a254 2
		if (ld->start != (void *)(LOFF + ld->moff)) {
			lowld->start = ld->start - ld->moff + lowld->moff;
d257 2
a258 4
		/*
		 * XXX - we need some kind of boundary condition here,
		 * or fix mquery to not run into the stack
		 */
a261 17
		int fd, flags;
		off_t foff;
		void *res;

		if (ld->foff < 0) {
			fd = -1;
			foff = 0;
			flags = MAP_FIXED|MAP_PRIVATE|MAP_ANON;
		} else {
			fd = libfile;
			foff = ld->foff;
			flags = MAP_FIXED|MAP_PRIVATE;
		}
		res = _dl_mmap(ld->start, ROUND_PG(ld->size), ld->prot, flags,
		    fd, foff);
		if (_dl_mmap_error(res))
			goto fail;
@


1.41
log
@Refuse to load ELF objects that contain a PT_TLS program header.
Otherwise the binary assumes that the requested TLS storage has been
allocated and will happily use it, resulting in unwanted memory corruption.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.39 2011/11/28 20:59:03 guenther Exp $ */
d292 1
a292 1
		_dl_build_sod(object->load_name, &object->sod);
a293 1
		/* XXX no point. object is never returned NULL */
@


1.40
log
@Don't mmap 0 byte areas, treat them as a noop instead.

ok miod@@
@
text
@d187 6
@


1.39
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.38 2010/11/16 18:59:00 drahn Exp $ */
d160 9
a168 7
			ld = _dl_malloc(sizeof(struct load_list));
			ld->start = NULL;
			ld->size = size;
			ld->moff = TRUNC_PG(phdp->p_vaddr);
			ld->foff = TRUNC_PG(phdp->p_offset);
			ld->prot = PFLAGS(phdp->p_flags);
			LDLIST_INSERT(ld);
d170 1
a170 1
			if ((ld->prot & PROT_WRITE) == 0 ||
@


1.38
log
@Fix error message when ld.so ends up loading a different than expected
library, but other library needs the one loaded. mostly ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.37 2010/10/25 20:34:44 kurt Exp $ */
d116 1
a116 1
			object->obj_flags |= flags & RTLD_GLOBAL;
@


1.37
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.36 2008/10/02 20:12:08 kurt Exp $ */
d41 1
d284 1
a284 1

@


1.36
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.35 2008/05/05 02:29:02 kurt Exp $ */
a99 12

	object = _dl_lookup_object(libname);
	if (object) {
		object->obj_flags |= flags & RTLD_GLOBAL;
		if (_dl_loading_object == NULL)
			_dl_loading_object = object;
		if (object->load_object != _dl_objects &&
		    object->load_object != _dl_loading_object) {
			_dl_link_grpref(object->load_object, _dl_loading_object);
		}
		return(object);		/* Already loaded */
	}
@


1.35
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.34 2006/05/10 03:26:50 deraadt Exp $ */
d50 1
a50 1
	int align = _dl_pagesz - 1;
d86 1
a86 1
	int libfile, i, align = _dl_pagesz - 1, off, size;
d93 1
d236 1
a236 1
		if (_dl_check_error(ld->start)) {
d240 1
a240 1
			if (_dl_check_error(ld->start))
d270 1
a270 1
		if (_dl_check_error((long)res))
@


1.34
log
@pretty this up; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.33 2006/05/03 16:10:51 drahn Exp $ */
d283 3
a285 2
	object = _dl_finalize_object(libname, dynp, 0, type,
	    (Elf_Addr)lowld->start, LOFF);
@


1.33
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.32 2005/11/09 16:41:29 kurt Exp $ */
d67 1
d86 1
a86 1
	int	libfile, i, align = _dl_pagesz - 1;
a88 1
	char	hbuf[4096];
a91 2
	int off;
	int size;
d95 1
d254 1
a255 1
		int fd, flags;
@


1.32
log
@add RTLD_NOW support to dlopen and propogate -z now to dep libs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.31 2005/10/12 20:36:16 kurt Exp $ */
d36 1
d96 1
d278 3
d287 1
@


1.31
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.30 2005/10/09 04:29:13 kurt Exp $ */
d287 1
a287 1
		object->obj_flags = flags;
@


1.30
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.29 2005/10/06 21:53:10 kurt Exp $ */
d101 1
a101 1
		object->load_object->obj_flags |= flags & RTLD_GLOBAL;
d125 1
a125 1
			object->load_object->obj_flags |= flags & RTLD_GLOBAL;
@


1.29
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.28 2005/10/03 19:48:24 kurt Exp $ */
d67 1
a67 1
	if (object->refcount + object->opencount + object->grprefcount == 0 &&
@


1.28
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.27 2005/10/01 19:32:22 drahn Exp $ */
d67 2
a68 1
	if (object->refcount == 0 && (object->status & STAT_UNLOADED) == 0) {
d72 2
d102 3
a104 2
		if (object->load_object != object &&
		    object->load_object != _dl_objects &&
d106 1
a106 3
			if (_dl_loading_object == NULL)
				_dl_loading_object = object;
			_dl_link_sub(object->load_object, _dl_loading_object);
d127 3
a129 2
			if (object->load_object != object &&
			    object->load_object != _dl_objects &&
d131 1
a131 3
				if (_dl_loading_object == NULL)
					_dl_loading_object = object;
				_dl_link_sub(object->load_object,
@


1.27
log
@handle references to load groups caused by dlopen()ing of depenant
members of the load group. work by kurt@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.26 2005/09/28 21:56:24 drahn Exp $ */
a97 1
		object->refcount++;
a101 1
			object->load_object->refcount++;
a122 1
			object->refcount++;
a127 1
				object->load_object->refcount++;
@


1.26
log
@correct last commit, in both files.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.25 2005/09/27 14:47:00 kurt Exp $ */
d100 8
d128 9
@


1.25
log
@increment refcount when opening a lib that is already open (dev/inode
case) ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.24 2005/09/26 14:51:05 drahn Exp $ */
d67 2
a68 1
	if (object->refcount == 0) {
@


1.24
log
@Fully unload dependant libraries, fixes gphoto2 bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.23 2005/09/16 23:19:41 drahn Exp $ */
d116 1
@


1.23
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.22 2005/05/31 14:31:36 drahn Exp $ */
d65 2
d68 3
@


1.22
log
@removed unused var, pointed out by wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.21 2005/05/30 23:31:16 drahn Exp $ */
d73 1
a73 1
_dl_tryload_shlib(const char *libname, int type)
d93 1
d111 1
d266 2
@


1.21
log
@unload is not to be recursive anymore, previous diff change method but
this code was missed, fixes issue seen by tedu and millert hopefully php too.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.20 2005/05/23 19:22:11 drahn Exp $ */
a64 2
	struct dep_node *n;

@


1.20
log
@fixes for dlclose, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.19 2005/05/10 03:36:07 drahn Exp $ */
a69 4

		for (n = object->first_child; n; n = n->next_sibling) {
			_dl_unload_shlib(n->data);
		}
@


1.19
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.18 2005/04/06 00:16:53 deraadt Exp $ */
a60 9
void
_dl_notify_unload_shlib(elf_object_t *object)
{
	struct dep_node *n;

	if (--object->refcount == 0)
		for (n = object->first_child; n; n = n->next_sibling)
			_dl_notify_unload_shlib(n->data);
}
@


1.18
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.16 2005/03/23 19:48:05 drahn Exp $ */
d62 10
d74 3
a76 2
	if (--object->refcount == 0) {
		_dl_run_dtors(object);
d79 4
@


1.17
log
@Do a better job of running destructors in the right order.
@
text
@a61 10
_dl_notify_unload_shlib(elf_object_t *object)
{
	struct dep_node *n;

	if (--object->refcount == 0)
		for (n = object->first_child; n; n = n->next_sibling)
			_dl_notify_unload_shlib(n->data);
}

void
d64 2
a65 3
	struct dep_node *n;

	if (object->refcount == 0) {
a67 4

		for (n = object->first_child; n; n = n->next_sibling) {
			_dl_unload_shlib(n->data);
		}
@


1.16
log
@Code reorganization, move copied code in library.c and library_mquery.c
into its own file. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.15 2005/03/22 18:03:39 drahn Exp $ */
d62 10
d74 3
a76 2
	if (--object->refcount == 0) {
		_dl_run_dtors(object);
d79 4
@


1.15
log
@fix PR3944 on i386 (ugh), from library.c
--
Fix some problems related to LD_LIBRARY_PATH parsing where it would not
correctly deal with current directory searches specified by "::", ":foo" or
"foo:"
--
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.14 2004/07/05 00:47:40 kjell Exp $ */
a32 1
#include <sys/syslimits.h>
a34 2
#include <nlist.h>
#include <link.h>
a35 1
#include <dirent.h>
a39 4
#include "dir.h"
#include "sod.h"

#define DEFAULT_PATH "/usr/lib"
a44 288
elf_object_t *_dl_tryload_shlib(const char *libname, int type);

/*
 * _dl_match_file()
 *
 * This fucntion determines if a given name matches what is specified
 * in a struct sod. The major must match exactly, and the minor must
 * be same or larger.
 *
 * sodp is updated with the minor if this matches.
 */

int
_dl_match_file(struct sod *sodp, char *name, int namelen)
{
	int match;
	struct sod lsod;
	char *lname;

	lname = name;
	if (sodp->sod_library) {
		if (_dl_strncmp(name, "lib", 3))
			return 0;
		lname += 3;
	}
	if (_dl_strncmp(lname, (char *)sodp->sod_name,
	    _dl_strlen((char *)sodp->sod_name)))
		return 0;

	_dl_build_sod(name, &lsod);

	match = 0;
	if ((_dl_strcmp((char *)lsod.sod_name, (char *)sodp->sod_name) == 0) &&
	    (lsod.sod_library == sodp->sod_library) &&
	    ((sodp->sod_major == -1) || (sodp->sod_major == lsod.sod_major)) &&
	    ((sodp->sod_minor == -1) ||
	    (lsod.sod_minor >= sodp->sod_minor))) {
		match = 1;

		/* return version matched */
		sodp->sod_major = lsod.sod_major;
		sodp->sod_minor = lsod.sod_minor;
	}
	_dl_free((char *)lsod.sod_name);
	return match;
}

char _dl_hint_store[MAXPATHLEN];

char *
_dl_find_shlib(struct sod *sodp, const char *searchpath, int nohints)
{
	char *hint, lp[PATH_MAX + 10], *path;
	struct dirent *dp;
	const char *pp;
	int match, len;
	DIR *dd;
	struct sod tsod, bsod;		/* transient and best sod */

	/* if we are to search default directories, and hints
	 * are not to be used, search the standard path from ldconfig
	 * (_dl_hint_search_path) or use the default path
	 */
	if (nohints)
		goto nohints;

	if (searchpath == NULL) {
		/* search 'standard' locations, find any match in the hints */
		hint = _dl_findhint((char *)sodp->sod_name, sodp->sod_major,
		    sodp->sod_minor, NULL);
		if (hint)
			return hint;
	} else {
		/* search hints requesting matches for only
		 * the searchpath directories,
		 */
		pp = searchpath;
		while (pp) {
			path = lp;
			while (path < lp + PATH_MAX &&
			    *pp && *pp != ':' && *pp != ';')
				*path++ = *pp++;
			*path = 0;

			/* interpret "" as curdir "." */
			if (lp[0] == '\0') {
				lp[0] = '.';
				lp[1] = '\0';
			}

			hint = _dl_findhint((char *)sodp->sod_name,
			    sodp->sod_major, sodp->sod_minor, lp);
			if (hint != NULL)
				return hint;

			if (*pp)	/* Try curdir if ':' at end */
				pp++;
			else
				pp = 0;
		}
	}

	/*
	 * For each directory in the searchpath, read the directory
	 * entries looking for a match to sod. filename compare is
	 * done by _dl_match_file()
	 */
nohints:
	if (searchpath == NULL) {
		if (_dl_hint_search_path != NULL)
			searchpath = _dl_hint_search_path;
		else
			searchpath = DEFAULT_PATH;
	}
	pp = searchpath;
	while (pp) {
		path = lp;
		while (path < lp + PATH_MAX && *pp && *pp != ':' && *pp != ';')
			*path++ = *pp++;
		*path = 0;

		/* interpret "" as curdir "." */
		if (lp[0] == '\0') {
			lp[0] = '.';
			lp[1] = '\0';
		}

		if ((dd = _dl_opendir(lp)) != NULL) {
			match = 0;
			while ((dp = _dl_readdir(dd)) != NULL) {
				tsod = *sodp;
				if (_dl_match_file(&tsod, dp->d_name,
				    dp->d_namlen)) {
					/*
					 * When a match is found, tsod is
					 * updated with the major+minor found.
					 * This version is compared with the
					 * largest so far (kept in bsod),
					 * and saved if larger.
					 */
					if (!match ||
					    tsod.sod_major == -1 ||
					    tsod.sod_major > bsod.sod_major ||
					    ((tsod.sod_major ==
					    bsod.sod_major) &&
					    tsod.sod_minor > bsod.sod_minor)) {
						bsod = tsod;
						match = 1;
						len = _dl_strlcpy(
						    _dl_hint_store, lp,
						    MAXPATHLEN);
						if (lp[len-1] != '/') {
							_dl_hint_store[len] =
							    '/';
							len++;
						}
						_dl_strlcpy(
						    &_dl_hint_store[len],
						    dp->d_name,
						    MAXPATHLEN-len);
						if (tsod.sod_major == -1)
							break;
					}
				}
			}
			_dl_closedir(dd);
			if (match) {
				*sodp = bsod;
				return (_dl_hint_store);
			}
		}

		if (*pp)	/* Try curdir if ':' at end */
			pp++;
		else
			pp = 0;
	}
	return NULL;
}

/*
 *  Load a shared object. Search order is:
 *	If the name contains a '/' use the name exactly as is. (only)
 *	try the LD_LIBRARY_PATH specification (if present)
 *	   search hints for match in LD_LIBRARY_PATH dirs
 *           this will only match specific libary version.
 *	   search LD_LIBRARY_PATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	check DT_RPATH paths, (if present)
 *	   search hints for match in DT_RPATH dirs
 *           this will only match specific libary version.
 *	   search DT_RPATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	last look in default search directory, either as specified
 *      by ldconfig or default to '/usr/lib'
 */

elf_object_t *
_dl_load_shlib(const char *libname, elf_object_t *parent, int type, int flags)
{
	int try_any_minor, ignore_hints;
	struct sod sod, req_sod;
	elf_object_t *object;
	char *hint;

	try_any_minor = 0;
	ignore_hints = 0;

	if (_dl_strchr(libname, '/')) {
		object = _dl_tryload_shlib(libname, type);
		return(object);
	}

	_dl_build_sod(libname, &sod);
	req_sod = sod;

again:
	/*
	 *  No '/' in name. Scan the known places, LD_LIBRARY_PATH first.
	 */
	if (_dl_libpath != NULL) {
		hint = _dl_find_shlib(&req_sod, _dl_libpath, ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				object->obj_flags = flags;
				return (object);
			}
		}
	}

	/*
	 *  Check DT_RPATH.
	 */
	if (parent->dyn.rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, parent->dyn.rpath,
		    ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				object->obj_flags = flags;
				return (object);
			}
		}
	}

	/* check 'standard' locations */
	hint = _dl_find_shlib(&req_sod, NULL, ignore_hints);
	if (hint != NULL) {
		if (req_sod.sod_minor < sod.sod_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    sod.sod_name, sod.sod_major,
			    req_sod.sod_minor, sod.sod_minor);
		object = _dl_tryload_shlib(hint, type);
		if (object != NULL) {
			_dl_free((char *)sod.sod_name);
			object->obj_flags = flags;
			return(object);
		}
	}

	if (try_any_minor == 0) {
		try_any_minor = 1;
		ignore_hints = 1;
		req_sod.sod_minor = -1;
		goto again;
	}
	_dl_free((char *)sod.sod_name);
	_dl_errno = DL_NOT_FOUND;
	return(0);
}

a60 2
void _dl_run_dtors(elf_object_t *object);

d86 1
a86 1
	
d114 1
a114 1
	
a276 22

void
_dl_link_sub(elf_object_t *dep, elf_object_t *p)
{
	struct dep_node *n;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(5);
	n->data = dep;
	n->next_sibling = NULL;
	if (p->first_child) {
		p->last_child->next_sibling = n;
		p->last_child = n;
	} else
		p->first_child = p->last_child = n;

	DL_DEB(("linking dep %s as child of %s\n", dep->load_name,
	    p->load_name));
}


@


1.14
log
@Fix an issue where a shared library could be loaded at two different
locations by resolving all dlopens back to a dev/inode.

i.e. Don't load a library if the dev/inode it stats back to matches one
already in our list.

fix started (and ok'ed) drahn@@. ok deraadt@@.
"doesn't break anything yet" pval@@ art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.13 2003/09/02 15:17:51 drahn Exp $ */
d137 6
d173 6
@


1.13
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.12 2003/07/18 14:09:02 drahn Exp $ */
d371 2
a372 1

d388 13
d547 3
d551 1
@


1.12
log
@Fix print if minor of library used is is less than requested. ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.11 2003/07/06 20:03:57 deraadt Exp $ */
d239 1
a239 1
_dl_load_shlib(const char *libname, elf_object_t *parent, int type)
d273 1
d295 1
d313 1
@


1.11
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.10 2003/07/02 08:18:03 niklas Exp $ */
d269 1
a269 1
				    sod.sod_minor, req_sod.sod_minor);
d290 1
a290 1
				    sod.sod_minor, req_sod.sod_minor);
d307 1
a307 1
			    sod.sod_minor, req_sod.sod_minor);
@


1.10
log
@Correct library search algorithm, wrt versioned objects
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.9 2003/06/22 21:39:01 drahn Exp $ */
d191 1
a191 1
						     MAXPATHLEN);
@


1.9
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.8 2003/06/09 16:10:03 deraadt Exp $ */
d87 1
a87 1
	    (sodp->sod_major == lsod.sod_major) &&
d93 1
a96 1

d110 1
d171 2
a172 1
				if (_dl_match_file(sodp, dp->d_name,
d175 5
a179 9
					 * When a match is found, sodp is
					 * updated with the minor found.
					 * We continue looking at this
					 * directory, thus this will find
					 * the largest matching library
					 * in this directory.
					 * we save off the d_name now
					 * so that it doesn't have to be
					 * recreated from the hint.
d181 22
a202 6
					match = 1;
					len = _dl_strlcpy(_dl_hint_store, lp,
					    MAXPATHLEN);
					if (lp[len-1] != '/') {
						_dl_hint_store[len] = '/';
						len++;
a203 2
					_dl_strlcpy(&_dl_hint_store[len],
					    dp->d_name, MAXPATHLEN-len);
d207 2
a208 1
			if (match)
d210 1
@


1.8
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.7 2003/05/30 01:13:53 drahn Exp $ */
d511 1
a511 1
	object = _dl_add_object(libname, dynp, 0, type,
@


1.7
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.6 2003/04/28 21:32:08 drahn Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.6
log
@Change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built, booted, and 'make includes' before building
ld.so with this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.5 2003/04/25 20:32:07 drahn Exp $ */
a59 1
static void _dl_link_sub(elf_object_t *dep, elf_object_t *p);
a242 1
		_dl_link_sub(object, parent);
a263 1
				_dl_link_sub(object, parent);
a284 1
				_dl_link_sub(object, parent);
a301 1
			_dl_link_sub(object, parent);
d535 1
a535 1
static void
@


1.5
log
@backout mquery change, something broke when not combined with a different diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.3 2003/04/21 14:35:50 drahn Exp $ */
a447 1
		int error;
d475 3
a477 3
		error = _dl_mquery(flags, &ld->start, ROUND_PG(ld->size), fd,
		    foff);
		if (_dl_check_error(error)) {
d479 3
a481 3
			error = _dl_mquery(0, &ld->start, ROUND_PG(ld->size),
			    fd, foff);
			if (_dl_check_error(error))
@


1.4
log
@change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built and installed before building ld.so with this change.
ok millert@@ tedu@@
@
text
@d448 1
d476 3
a478 3
		ld->start = _dl_mquery(ld->start, ROUND_PG(ld->size), ld->prot,
		    flags, fd, foff);
		if (_dl_check_error(ld->start)) {
d480 3
a482 3
			ld->start = _dl_mquery(ld->start, ROUND_PG(ld->size),
			    ld->prot, flags & ~MAP_FIXED, fd, foff);
			if (_dl_check_error(ld->start))
@


1.3
log
@Fix the load_size which is used by ldd to print end address.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.2 2003/04/18 12:38:39 drahn Exp $ */
a447 1
		int error;
d475 3
a477 3
		error = _dl_mquery(flags, &ld->start, ROUND_PG(ld->size), fd,
		    foff);
		if (_dl_check_error(error)) {
d479 3
a481 3
			error = _dl_mquery(0, &ld->start, ROUND_PG(ld->size),
			    fd, foff);
			if (_dl_check_error(error))
@


1.2
log
@Adjusting the start is wrong. The value returned by mquery() should be used
here. Fixes a bug with emacs21. tested by marc@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: library_mquery.c,v 1.1 2003/04/17 03:40:45 drahn Exp $ */
d526 1
a526 1
		object->load_size = (Elf_Addr)lowld->start - (Elf_Addr)load_end;
@


1.1
log
@mquery support, currently for i386 only.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.26 2003/02/02 16:57:58 deraadt Exp $ */
a466 8
		if (ld->start == 0) {
			/* we dont want the first > MAXDSIZ address
			 * we want the first available address 
			 * skip the first 16 pages for page 0, 
			 * possible sigtramp and some exe.
			 */
			ld->start = (void *)(long)(_dl_pagesz * 16);
		}
@

