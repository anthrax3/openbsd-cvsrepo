head	1.81;
access;
symbols
	OPENBSD_6_2:1.81.0.6
	OPENBSD_6_2_BASE:1.81
	OPENBSD_6_1:1.81.0.4
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.77.0.2
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.67.0.8
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.67.0.4
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.66.0.2
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.2
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.58.0.8
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.4
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.58.0.6
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.54.0.8
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.54.0.6
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.54.0.4
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	r20000612:1.1.1.2
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2017.02.08.04.34.29;	author guenther;	state Exp;
branches;
next	1.80;
commitid	v6BJE4JNZ5jMnrCa;

1.80
date	2017.01.24.07.48.36;	author guenther;	state Exp;
branches;
next	1.79;
commitid	veGB6uLWx3BTEAfk;

1.79
date	2016.08.12.20.39.01;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	9Gsc7gGSE2YeEbd8;

1.78
date	2016.08.08.21.59.20;	author guenther;	state Exp;
branches;
next	1.77;
commitid	PufSD0ERJAhj0Sd1;

1.77
date	2016.07.04.21.15.06;	author guenther;	state Exp;
branches;
next	1.76;
commitid	qHDzpShMNCJZKLBF;

1.76
date	2016.06.08.11.58.59;	author kettenis;	state Exp;
branches;
next	1.75;
commitid	McGYMfmcR7iKjRD2;

1.75
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.74;
commitid	d9R7VGw9CHTkwXE1;

1.74
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.73;
commitid	Kpc3J4Ry51yjfQid;

1.73
date	2015.12.22.08.54.16;	author mmcc;	state Exp;
branches;
next	1.72;
commitid	sTDrw9FlbNNwVprE;

1.72
date	2015.11.06.05.12.30;	author guenther;	state Exp;
branches;
next	1.71;
commitid	QyXWPc6ZNUAPw1ll;

1.71
date	2015.01.16.16.18.07;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	31KwZ9PARAKUg1ob;

1.70
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.69;
commitid	ImRWDrCXNlhODvC7;

1.69
date	2014.07.09.12.54.03;	author guenther;	state Exp;
branches;
next	1.68;
commitid	0KayvPMeoDHeGivt;

1.68
date	2014.06.21.08.00.22;	author otto;	state Exp;
branches;
next	1.67;
commitid	wh9FTpEgwThWVeqE;

1.67
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	2012.06.12.20.32.17;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.08.14.32.01;	author jsing;	state Exp;
branches;
next	1.64;

1.64
date	2012.01.09.17.01.22;	author ariane;	state Exp;
branches;
next	1.63;

1.63
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.10.04.50.35;	author otto;	state Exp;
branches;
next	1.61;

1.61
date	2011.05.09.18.13.34;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2010.11.16.18.59.00;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.58;

1.58
date	2008.10.02.20.12.08;	author kurt;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.02.02.27.36;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.08.20.34.36;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.09.16.41.29;	author kurt;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.12.20.48.15;	author kurt;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.01.19.32.22;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.28.21.56.24;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.28.20.35.23;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.27.14.47.00;	author kurt;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.26.14.51.05;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.23.19.22.11;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.23.19.48.05;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.17.03.56.49;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.05.00.47.40;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.18.14.09.02;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.02.08.18.03;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.30.03.46.46;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.13.20.45.54;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.17.20.27.20;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.08.17.17.12;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.24.01.05.11;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.24.00.13.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.23.23.56.31;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.12.20.18.30;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.19.34.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.28.00.22.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.24.18.37.38;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.22.04.33.36;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.21.01.19.35;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.06.15.09.58;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.31.13.47.20;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.16.19.37;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.02.23.11.20;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.30.01.35.20;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.16.05.28.17;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.06.17.40.17;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.34.00;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.34.00;	author rahnds;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.06.13.03.40.02;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Provide size-generic ELF_NO_ADDR in <sys/exec_elf.h> and use that instead
of ELFDEFNNAME(NO_ADDR)

ok jca@@
@
text
@/*	$OpenBSD: library.c,v 1.80 2017/01/24 07:48:36 guenther Exp $ */

/*
 * Copyright (c) 2002 Dale Rahn
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"
#include "sod.h"

#define PFLAGS(X) ((((X) & PF_R) ? PROT_READ : 0) | \
		   (((X) & PF_W) ? PROT_WRITE : 0) | \
		   (((X) & PF_X) ? PROT_EXEC : 0))

void
_dl_load_list_free(struct load_list *load_list)
{
	struct load_list *next;

	while (load_list != NULL) {
		next = load_list->next;
		_dl_free(load_list);
		load_list = next;
	}
}

void
_dl_unload_shlib(elf_object_t *object)
{
	struct dep_node *n;
	elf_object_t *load_object = object->load_object;

	/*
	 * If our load object has become unreferenced then we lost the
	 * last group reference to it, so the entire group should be taken
	 * down.  The current object is somewhere below load_object in
	 * the child_list tree, so it'll get cleaned up by the recursion.
	 * That means we can just switch here to the load object.
	 */
	if (load_object != object && OBJECT_REF_CNT(load_object) == 0 &&
	    (load_object->status & STAT_UNLOADED) == 0) {
		DL_DEB(("unload_shlib switched from %s to %s\n",
		    object->load_name, load_object->load_name));
		object = load_object;
		goto unload;
	}

	DL_DEB(("unload_shlib called on %s\n", object->load_name));
	if (OBJECT_REF_CNT(object) == 0 &&
	    (object->status & STAT_UNLOADED) == 0) {
unload:
		object->status |= STAT_UNLOADED;
		TAILQ_FOREACH(n, &object->child_list, next_sib)
			_dl_unload_shlib(n->data);
		TAILQ_FOREACH(n, &object->grpref_list, next_sib)
			_dl_unload_shlib(n->data);
		DL_DEB(("unload_shlib unloading on %s\n", object->load_name));
		_dl_load_list_free(object->load_list);
		_dl_munmap((void *)object->load_base, object->load_size);
		_dl_remove_object(object);
	}
}

elf_object_t *
_dl_tryload_shlib(const char *libname, int type, int flags)
{
	int	libfile, i;
	struct load_list *next_load, *load_list = NULL;
	Elf_Addr maxva = 0, minva = ELF_NO_ADDR;
	Elf_Addr libaddr, loff, align = _dl_pagesz - 1;
	Elf_Addr relro_addr = 0, relro_size = 0;
	elf_object_t *object;
	char	hbuf[4096];
	Elf_Dyn *dynp = NULL;
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdp;
	Elf_Phdr *ptls = NULL;
	struct stat sb;

#define ROUND_PG(x) (((x) + align) & ~(align))
#define TRUNC_PG(x) ((x) & ~(align))

	libfile = _dl_open(libname, O_RDONLY | O_CLOEXEC);
	if (libfile < 0) {
		_dl_errno = DL_CANT_OPEN;
		return(0);
	}

	if ( _dl_fstat(libfile, &sb) < 0) {
		_dl_errno = DL_CANT_OPEN;
		return(0);
	}

	for (object = _dl_objects; object != NULL; object = object->next) {
		if (object->dev == sb.st_dev &&
		    object->inode == sb.st_ino) {
			object->obj_flags |= flags & DF_1_GLOBAL;
			_dl_close(libfile);
			if (_dl_loading_object == NULL)
				_dl_loading_object = object;
			if (object->load_object != _dl_objects &&
			    object->load_object != _dl_loading_object) {
				_dl_link_grpref(object->load_object,
				    _dl_loading_object);
			}
			return(object);
		}
	}

	_dl_read(libfile, hbuf, sizeof(hbuf));
	ehdr = (Elf_Ehdr *)hbuf;
	if (ehdr->e_ident[0] != ELFMAG0  || ehdr->e_ident[1] != ELFMAG1 ||
	    ehdr->e_ident[2] != ELFMAG2 || ehdr->e_ident[3] != ELFMAG3 ||
	    ehdr->e_type != ET_DYN || ehdr->e_machine != MACHID) {
		_dl_close(libfile);
		_dl_errno = DL_NOT_ELF;
		return(0);
	}

	/*
	 *  Alright, we might have a winner!
	 *  Figure out how much VM space we need.
	 */
	phdp = (Elf_Phdr *)(hbuf + ehdr->e_phoff);
	for (i = 0; i < ehdr->e_phnum; i++, phdp++) {
		switch (phdp->p_type) {
		case PT_LOAD:
			if (phdp->p_vaddr < minva)
				minva = phdp->p_vaddr;
			if (phdp->p_vaddr + phdp->p_memsz > maxva)
				maxva = phdp->p_vaddr + phdp->p_memsz;
			break;
		case PT_DYNAMIC:
			dynp = (Elf_Dyn *)phdp->p_vaddr;
			break;
		case PT_TLS:
			if (phdp->p_filesz > phdp->p_memsz) {
				_dl_printf("%s: invalid tls data in %s.\n",
				    __progname, libname);
				_dl_close(libfile);
				_dl_errno = DL_CANT_LOAD_OBJ;
				return(0);
			}
			if (!_dl_tib_static_done) {
				ptls = phdp;
				break;
			}
			_dl_printf("%s: unsupported TLS program header in %s\n",
			    __progname, libname);
			_dl_close(libfile);
			_dl_errno = DL_CANT_LOAD_OBJ;
			return(0);
		default:
			break;
		}
	}
	minva = TRUNC_PG(minva);
	maxva = ROUND_PG(maxva);

	/*
	 * We map the entire area to see that we can get the VM
	 * space required. Map it unaccessible to start with.
	 *
	 * We must map the file we'll map later otherwise the VM
	 * system won't be able to align the mapping properly
	 * on VAC architectures.
	 */
	libaddr = (Elf_Addr)_dl_mmap(0, maxva - minva, PROT_NONE,
	    MAP_PRIVATE|MAP_FILE, libfile, 0);
	if (_dl_mmap_error(libaddr)) {
		_dl_printf("%s: rtld mmap failed mapping %s.\n",
		    __progname, libname);
		_dl_close(libfile);
		_dl_errno = DL_CANT_MMAP;
		return(0);
	}

	loff = libaddr - minva;
	phdp = (Elf_Phdr *)(hbuf + ehdr->e_phoff);

	for (i = 0; i < ehdr->e_phnum; i++, phdp++) {
		switch (phdp->p_type) {
		case PT_LOAD: {
			char *start = (char *)(TRUNC_PG(phdp->p_vaddr)) + loff;
			Elf_Addr off = (phdp->p_vaddr & align);
			Elf_Addr size = off + phdp->p_filesz;
			int flags = PFLAGS(phdp->p_flags);
			void *res;

			/*
			 * Initially map W|X segments without X
			 * permission.  After we're done with the
			 * initial relocation processing, we will make
			 * these segments read-only and add back the X
			 * permission.  This way we maintain W^X at
			 * all times.
			 */
			if ((flags & PROT_WRITE) && (flags & PROT_EXEC))
				flags &= ~PROT_EXEC;

			if (size != 0) {
				res = _dl_mmap(start, ROUND_PG(size), flags,
				    MAP_FIXED|MAP_PRIVATE, libfile,
				    TRUNC_PG(phdp->p_offset));
			} else
				res = NULL;	/* silence gcc */
			next_load = _dl_calloc(1, sizeof(struct load_list));
			if (next_load == NULL)
				_dl_oom();
			next_load->next = load_list;
			load_list = next_load;
			next_load->start = start;
			next_load->size = size;
			next_load->prot = PFLAGS(phdp->p_flags);
			if (size != 0 && _dl_mmap_error(res)) {
				_dl_printf("%s: rtld mmap failed mapping %s.\n",
				    __progname, libname);
				_dl_close(libfile);
				_dl_errno = DL_CANT_MMAP;
				_dl_munmap((void *)libaddr, maxva - minva);
				_dl_load_list_free(load_list);
				return(0);
			}
			if (phdp->p_flags & PF_W) {
				/* Zero out everything past the EOF */
				if ((size & align) != 0)
					_dl_memset(start + size, 0,
					    _dl_pagesz - (size & align));
				if (ROUND_PG(size) ==
				    ROUND_PG(off + phdp->p_memsz))
					continue;
				start = start + ROUND_PG(size);
				size = ROUND_PG(off + phdp->p_memsz) -
				    ROUND_PG(size);
				res = _dl_mmap(start, size, flags,
				    MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
				if (_dl_mmap_error(res)) {
					_dl_printf("%s: rtld mmap failed mapping %s.\n",
					    __progname, libname);
					_dl_close(libfile);
					_dl_errno = DL_CANT_MMAP;
					_dl_munmap((void *)libaddr, maxva - minva);
					_dl_load_list_free(load_list);
					return(0);
				}
			}
			break;
		}

		case PT_OPENBSD_RANDOMIZE:
			_dl_arc4randombuf((char *)(phdp->p_vaddr + loff),
			    phdp->p_memsz);
			break;

		case PT_GNU_RELRO:
			relro_addr = phdp->p_vaddr + loff;
			relro_size = phdp->p_memsz;
			break;

		default:
			break;
		}
	}

	_dl_close(libfile);

	dynp = (Elf_Dyn *)((unsigned long)dynp + loff);
	object = _dl_finalize_object(libname, dynp,
	    (Elf_Phdr *)((char *)libaddr + ehdr->e_phoff), ehdr->e_phnum,type,
	    libaddr, loff);
	if (object) {
		object->load_size = maxva - minva;	/*XXX*/
		object->load_list = load_list;
		/* set inode, dev from stat info */
		object->dev = sb.st_dev;
		object->inode = sb.st_ino;
		object->obj_flags |= flags;
		object->relro_addr = relro_addr;
		object->relro_size = relro_size;
		_dl_set_sod(object->load_name, &object->sod);
		if (ptls != NULL && ptls->p_memsz)
			_dl_set_tls(object, ptls, libaddr, libname);
	} else {
		_dl_munmap((void *)libaddr, maxva - minva);
		_dl_load_list_free(load_list);
	}
	return(object);
}
@


1.80
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.79 2016/08/12 20:39:01 deraadt Exp $ */
d99 1
a99 1
	Elf_Addr maxva = 0, minva = ELFDEFNNAME(NO_ADDR);
@


1.79
log
@the slimmed down random functions inside ld.so are strict clones of the
libc arc4random API, so call them _dl_{arc4random,arcrandombuf}
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.78 2016/08/08 21:59:20 guenther Exp $ */
d239 1
a239 1
				_dl_exit(7);
@


1.78
log
@Look for a PT_GNU_RELRO section per object and, if present, mprotect that
range instead of the [__got_start, __got_end) range.
On many archs this will cover _DYNAMIC too, so move up the DT_DEBUG handling
to before relocations and the mprotect are done.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.77 2016/07/04 21:15:06 guenther Exp $ */
d281 1
a281 1
			_dl_randombuf((char *)(phdp->p_vaddr + loff),
@


1.77
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.76 2016/06/08 11:58:59 kettenis Exp $ */
d101 1
d285 5
d308 2
@


1.76
log
@Some ELF ABIs still require a PLT that is both writable and executable.  To
avoid W^X violations, initially map such segments as writable and
non-executable, and change the mapping to non-writable and executable
after initial relocation processing.  As a side-benefit this means we no
longer depend on the __plt_start and __plt_end to make the PLT read-only
after relocation processing.

This will break binaries linked with ld -Z, most notably emacs, on some
of our architectures.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.75 2016/05/07 19:05:23 guenther Exp $ */
a34 1
#include "dl_prebind.h"
a107 1
	void *prebind_data;
a288 2
	prebind_data = prebind_load_fd(libfile, libname);

a295 1
		object->prebind_data = prebind_data;
@


1.75
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.74 2016/03/20 02:29:51 guenther Exp $ */
d218 1
d221 11
d233 1
a233 2
				res = _dl_mmap(start, ROUND_PG(size),
				    PFLAGS(phdp->p_flags),
d266 1
a266 2
				res = _dl_mmap(start, size,
				    PFLAGS(phdp->p_flags),
@


1.74
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.73 2015/12/22 08:54:16 mmcc Exp $ */
d107 1
d168 11
d298 2
@


1.73
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.72 2015/11/06 05:12:30 guenther Exp $ */
d168 1
a168 1
			    _dl_progname, libname);
d191 1
a191 1
		    _dl_progname, libname);
d225 1
a225 1
				    _dl_progname, libname);
d248 1
a248 1
					    _dl_progname, libname);
@


1.72
log
@Fix unloading of load groups when the last reference wasn't on the
load_object but rather some descendent.  Detect that case in
_dl_unload_shlib() and switch to unloading the entire group.

Based on partial analyses by Henri Kemppainen (duclare (at) guu.fi)
and Peter Hajdu (peter.ferenc.hajdu (at) gmail.com)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.71 2015/01/16 16:18:07 deraadt Exp $ */
d104 1
a104 1
	Elf_Dyn *dynp = 0;
@


1.71
log
@<sys/param.h> to <limits.h> conversion.  Verified binaries
ok millert, thanks to doug for process advice
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.70 2014/07/10 09:03:01 otto Exp $ */
d62 17
d82 1
@


1.70
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.69 2014/07/09 12:54:03 guenther Exp $ */
a32 1
#include <sys/param.h>
@


1.69
log
@Use O_CLOEXEC to make sure fork+exec in a threaded process can't
see the fds used by dlopen()

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.68 2014/06/21 08:00:22 otto Exp $ */
d199 2
@


1.68
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.67 2012/08/20 23:25:07 matthew Exp $ */
d96 1
a96 1
	libfile = _dl_open(libname, O_RDONLY);
@


1.67
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.66 2012/06/12 20:32:17 matthew Exp $ */
d198 1
a198 1
			next_load = _dl_malloc(sizeof(struct load_list));
@


1.66
log
@Fix loaded object sod matching: when we load libfoo.so.X.Y into
memory, we should be able to match other requests for libfoo.so.X.Z
against that same object.

ok kurt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.65 2012/05/08 14:32:01 jsing Exp $ */
d184 2
a185 1
		if (phdp->p_type == PT_LOAD) {
d237 10
@


1.65
log
@Refuse to load ELF objects that contain a PT_TLS program header.
Otherwise the binary assumes that the requested TLS storage has been
allocated and will happily use it, resulting in unwanted memory corruption.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.63 2011/11/28 20:59:03 guenther Exp $ */
d255 1
a255 1
		_dl_build_sod(object->load_name, &object->sod);
a256 1
		/* XXX not possible. object cannot come back NULL */
@


1.64
log
@Don't mmap 0 byte areas, treat them as a noop instead.

ok miod@@
@
text
@d149 6
@


1.63
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.62 2011/05/10 04:50:35 otto Exp $ */
d184 7
a190 4
			res = _dl_mmap(start, ROUND_PG(size),
			    PFLAGS(phdp->p_flags),
			    MAP_FIXED|MAP_PRIVATE, libfile,
			    TRUNC_PG(phdp->p_offset));
d197 1
a197 1
			if (_dl_mmap_error(res)) {
@


1.62
log
@Fix previous. On i386, library.c isn't compiled
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.61 2011/05/09 18:13:34 otto Exp $ */
d110 1
a110 1
			object->obj_flags |= flags & RTLD_GLOBAL;
@


1.61
log
@Outsmart gcc4 on mips* by moving the declaration of _dl_debug_state
outside the file the call is in. Since the function is empty, gcc
optmizes the call away, breaking the gdb hook needed to resolve symbols in
lazy bound shared libs. Analysis by kettenis@@; ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.60 2010/11/16 18:59:00 drahn Exp $ */
a253 7

void
_dl_debug_state(void)
{
        /* Debugger stub */
}

@


1.60
log
@Fix error message when ld.so ends up loading a different than expected
library, but other library needs the one loaded. mostly ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.59 2010/10/25 20:34:44 kurt Exp $ */
d254 7
@


1.59
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.58 2008/10/02 20:12:08 kurt Exp $ */
d41 1
d246 1
@


1.58
log
@Fix mmap() error checking to be correct 64-bit addresses. Consistently
use _dl_mmap_error() to check for mmap() errors. Adjust datatypes of
some local vars for 64-bit safety.

okay millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.57 2008/05/05 02:29:02 kurt Exp $ */
a93 12

	object = _dl_lookup_object(libname);
	if (object) {
		object->obj_flags |= flags & RTLD_GLOBAL;
		if (_dl_loading_object == NULL)
			_dl_loading_object = object;
		if (object->load_object != _dl_objects &&
		    object->load_object != _dl_loading_object) {
			_dl_link_grpref(object->load_object, _dl_loading_object);
		}
		return(object);		/* Already loaded */
	}
@


1.57
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.56 2008/04/09 21:45:26 kurt Exp $ */
d80 1
a80 1
	int	libfile, i, align = _dl_pagesz - 1;
d83 1
a83 1
	Elf_Addr libaddr, loff;
d177 1
a177 1
	if (_dl_check_error(libaddr)) {
d191 2
a192 2
			int off = (phdp->p_vaddr & align);
			int size = off + phdp->p_filesz;
d205 1
a205 1
			if (_dl_check_error((long)res)) {
d228 1
a228 1
				if (_dl_check_error((long)res)) {
@


1.56
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.55 2008/04/02 02:27:36 drahn Exp $ */
d246 3
a248 1
	object = _dl_finalize_object(libname, dynp, 0, type, libaddr, loff);
@


1.55
log
@Use the proper define for this address, not a incorrect (on 64bit) define.
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.54 2006/05/08 20:34:36 deraadt Exp $ */
d72 1
a72 1
		_dl_munmap((void *)object->load_addr, object->load_size);
@


1.54
log
@de-space
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.53 2006/05/03 16:10:51 drahn Exp $ */
d82 1
a82 1
	Elf_Addr maxva = 0, minva = 0x7fffffff;	/* XXX Correct for 64bit? */
@


1.53
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.52 2005/11/09 16:41:29 kurt Exp $ */
d242 1
a242 1
	
@


1.52
log
@add RTLD_NOW support to dlopen and propogate -z now to dep libs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.51 2005/10/12 20:48:15 kurt Exp $ */
d36 1
a76 1

d90 1
d240 3
d248 1
@


1.51
log
@add missing grpref unload propogation (sync with library_mquery)
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.50 2005/10/12 20:36:16 kurt Exp $ */
d249 1
a249 1
		object->obj_flags = flags;
@


1.50
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.49 2005/10/09 04:29:13 kurt Exp $ */
d66 2
@


1.49
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.48 2005/10/06 21:53:10 kurt Exp $ */
d94 1
a94 1
		object->load_object->obj_flags |= flags & RTLD_GLOBAL;
d118 1
a118 1
			object->load_object->obj_flags |= flags & RTLD_GLOBAL;
@


1.48
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.47 2005/10/03 19:48:24 kurt Exp $ */
d62 1
a62 1
	if (object->refcount + object->opencount + object->grprefcount == 0 &&
@


1.47
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.46 2005/10/01 19:32:22 drahn Exp $ */
d62 2
a63 1
	if (object->refcount == 0 && (object->status & STAT_UNLOADED) == 0) {
d95 3
a97 2
		if (object->load_object != object &&
		    object->load_object != _dl_objects &&
d99 1
a99 3
			if (_dl_loading_object == NULL)
				_dl_loading_object = object;
			_dl_link_sub(object->load_object, _dl_loading_object);
d120 3
a122 2
			if (object->load_object != object &&
			    object->load_object != _dl_objects &&
d124 1
a124 4
				if (_dl_loading_object == NULL)
					_dl_loading_object = object;

				_dl_link_sub(object->load_object,
@


1.46
log
@handle references to load groups caused by dlopen()ing of depenant
members of the load group. work by kurt@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.45 2005/09/28 21:56:24 drahn Exp $ */
a92 1
		object->refcount++;
a96 1
			object->load_object->refcount++;
a117 1
			object->refcount++;
a122 1
				object->load_object->refcount++;
@


1.45
log
@correct last commit, in both files.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.44 2005/09/28 20:35:23 drahn Exp $ */
d95 8
d123 10
@


1.44
log
@keep a state flag if a library has been unloaded, and then free the list
seperately ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.43 2005/09/27 14:47:00 kurt Exp $ */
d62 2
a63 2
	if (object->refcount == 0 && (object->status & STATUS_UNLOADED) == 0) {
		object->status |= STATUS_UNLOADED;
@


1.43
log
@increment refcount when opening a lib that is already open (dev/inode
case) ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.42 2005/09/26 14:51:05 drahn Exp $ */
d62 2
a63 1
	if (object->refcount == 0) {
@


1.42
log
@Fully unload dependant libraries, fixes gphoto2 bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.41 2005/09/16 23:19:41 drahn Exp $ */
d111 1
@


1.41
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.40 2005/05/23 19:22:11 drahn Exp $ */
d60 2
d63 3
@


1.40
log
@fixes for dlclose, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.39 2005/05/10 03:36:07 drahn Exp $ */
d69 1
a69 1
_dl_tryload_shlib(const char *libname, int type)
d88 1
d106 1
d228 1
@


1.39
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.38 2005/04/06 00:16:53 deraadt Exp $ */
a56 7
void
_dl_notify_unload_shlib(elf_object_t *object)
{
	if (--object->refcount == 0) {
		_dl_run_dtors(object);
	}
}
@


1.38
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.36 2005/03/23 19:48:05 drahn Exp $ */
d58 1
a58 1
_dl_unload_shlib(elf_object_t *object)
d62 6
@


1.37
log
@Do a better job of running destructors in the right order.
@
text
@d58 1
a58 1
_dl_notify_unload_shlib(elf_object_t *object)
a61 6
	}
}
void
_dl_unload_shlib(elf_object_t *object)
{
	if (object->refcount == 0) {
@


1.36
log
@Code reorganization, move copied code in library.c and library_mquery.c
into its own file. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.35 2004/10/17 03:56:49 drahn Exp $ */
d58 1
a58 1
_dl_unload_shlib(elf_object_t *object)
d62 6
@


1.35
log
@Fix some problems related to LD_LIBRARY_PATH parsing where it would not
correctly deal with current directory searches specified by "::", ":foo" or
"foo:"
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.34 2004/07/05 00:47:40 kjell Exp $ */
a32 1
#include <sys/syslimits.h>
a34 2
#include <nlist.h>
#include <link.h>
a35 1
#include <dirent.h>
a39 4
#include "dir.h"
#include "sod.h"

#define DEFAULT_PATH "/usr/lib"
a44 288
static elf_object_t *_dl_tryload_shlib(const char *libname, int type);

/*
 * _dl_match_file()
 *
 * This fucntion determines if a given name matches what is specified
 * in a struct sod. The major must match exactly, and the minor must
 * be same or larger.
 *
 * sodp is updated with the minor if this matches.
 */

int
_dl_match_file(struct sod *sodp, char *name, int namelen)
{
	int match;
	struct sod lsod;
	char *lname;

	lname = name;
	if (sodp->sod_library) {
		if (_dl_strncmp(name, "lib", 3))
			return 0;
		lname += 3;
	}
	if (_dl_strncmp(lname, (char *)sodp->sod_name,
	    _dl_strlen((char *)sodp->sod_name)))
		return 0;

	_dl_build_sod(name, &lsod);

	match = 0;
	if ((_dl_strcmp((char *)lsod.sod_name, (char *)sodp->sod_name) == 0) &&
	    (lsod.sod_library == sodp->sod_library) &&
	    ((sodp->sod_major == -1) || (sodp->sod_major == lsod.sod_major)) &&
	    ((sodp->sod_minor == -1) ||
	    (lsod.sod_minor >= sodp->sod_minor))) {
		match = 1;

		/* return version matched */
		sodp->sod_major = lsod.sod_major;
		sodp->sod_minor = lsod.sod_minor;
	}
	_dl_free((char *)lsod.sod_name);
	return match;
}

char _dl_hint_store[MAXPATHLEN];

char *
_dl_find_shlib(struct sod *sodp, const char *searchpath, int nohints)
{
	char *hint, lp[PATH_MAX + 10], *path;
	struct dirent *dp;
	const char *pp;
	int match, len;
	DIR *dd;
	struct sod tsod, bsod;		/* transient and best sod */

	/* if we are to search default directories, and hints
	 * are not to be used, search the standard path from ldconfig
	 * (_dl_hint_search_path) or use the default path
	 */
	if (nohints)
		goto nohints;

	if (searchpath == NULL) {
		/* search 'standard' locations, find any match in the hints */
		hint = _dl_findhint((char *)sodp->sod_name, sodp->sod_major,
		    sodp->sod_minor, NULL);
		if (hint)
			return hint;
	} else {
		/* search hints requesting matches for only
		 * the searchpath directories,
		 */
		pp = searchpath;
		while (pp) {
			path = lp;
			while (path < lp + PATH_MAX &&
			    *pp && *pp != ':' && *pp != ';')
				*path++ = *pp++;
			*path = 0;

			/* interpret "" as curdir "." */
			if (lp[0] == '\0') {
				lp[0] = '.';
				lp[1] = '\0';
			}

			hint = _dl_findhint((char *)sodp->sod_name,
			    sodp->sod_major, sodp->sod_minor, lp);
			if (hint != NULL)
				return hint;

			if (*pp)	/* Try curdir if ':' at end */
				pp++;
			else
				pp = 0;
		}
	}

	/*
	 * For each directory in the searchpath, read the directory
	 * entries looking for a match to sod. filename compare is
	 * done by _dl_match_file()
	 */
nohints:
	if (searchpath == NULL) {
		if (_dl_hint_search_path != NULL)
			searchpath = _dl_hint_search_path;
		else
			searchpath = DEFAULT_PATH;
	}
	pp = searchpath;
	while (pp) {
		path = lp;
		while (path < lp + PATH_MAX && *pp && *pp != ':' && *pp != ';')
			*path++ = *pp++;
		*path = 0;

		/* interpret "" as curdir "." */
		if (lp[0] == '\0') {
			lp[0] = '.';
			lp[1] = '\0';
		}

		if ((dd = _dl_opendir(lp)) != NULL) {
			match = 0;
			while ((dp = _dl_readdir(dd)) != NULL) {
				tsod = *sodp;
				if (_dl_match_file(&tsod, dp->d_name,
				    dp->d_namlen)) {
					/*
					 * When a match is found, tsod is
					 * updated with the major+minor found.
					 * This version is compared with the
					 * largest so far (kept in bsod),
					 * and saved if larger.
					 */
					if (!match ||
					    tsod.sod_major == -1 ||
					    tsod.sod_major > bsod.sod_major ||
					    ((tsod.sod_major ==
					    bsod.sod_major) &&
					    tsod.sod_minor > bsod.sod_minor)) {
						bsod = tsod;
						match = 1;
						len = _dl_strlcpy(
						    _dl_hint_store, lp,
						    MAXPATHLEN);
						if (lp[len-1] != '/') {
							_dl_hint_store[len] =
							    '/';
							len++;
						}
						_dl_strlcpy(
						    &_dl_hint_store[len],
						    dp->d_name,
						    MAXPATHLEN-len);
						if (tsod.sod_major == -1)
							break;
					}
				}
			}
			_dl_closedir(dd);
			if (match) {
				*sodp = bsod;
				return (_dl_hint_store);
			}
		}

		if (*pp)	/* Try curdir if ':' at end */
			pp++;
		else
			pp = 0;
	}
	return NULL;
}

/*
 *  Load a shared object. Search order is:
 *	If the name contains a '/' use the name exactly as is. (only)
 *	try the LD_LIBRARY_PATH specification (if present)
 *	   search hints for match in LD_LIBRARY_PATH dirs
 *           this will only match specific libary version.
 *	   search LD_LIBRARY_PATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	check DT_RPATH paths, (if present)
 *	   search hints for match in DT_RPATH dirs
 *           this will only match specific libary version.
 *	   search DT_RPATH dirs for match.
 *           this will find largest minor version in first dir found.
 *	last look in default search directory, either as specified
 *      by ldconfig or default to '/usr/lib'
 */

elf_object_t *
_dl_load_shlib(const char *libname, elf_object_t *parent, int type, int flags)
{
	int try_any_minor, ignore_hints;
	struct sod sod, req_sod;
	elf_object_t *object;
	char *hint;

	try_any_minor = 0;
	ignore_hints = 0;

	if (_dl_strchr(libname, '/')) {
		object = _dl_tryload_shlib(libname, type);
		return(object);
	}

	_dl_build_sod(libname, &sod);
	req_sod = sod;

again:
	/*
	 *  No '/' in name. Scan the known places, LD_LIBRARY_PATH first.
	 */
	if (_dl_libpath != NULL) {
		hint = _dl_find_shlib(&req_sod, _dl_libpath, ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				object->obj_flags = flags;
				return (object);
			}
		}
	}

	/*
	 *  Check DT_RPATH.
	 */
	if (parent->dyn.rpath != NULL) {
		hint = _dl_find_shlib(&req_sod, parent->dyn.rpath,
		    ignore_hints);
		if (hint != NULL) {
			if (req_sod.sod_minor < sod.sod_minor)
				_dl_printf("warning: lib%s.so.%d.%d: "
				    "minor version >= %d expected, "
				    "using it anyway\n",
				    sod.sod_name, sod.sod_major,
				    req_sod.sod_minor, sod.sod_minor);
			object = _dl_tryload_shlib(hint, type);
			if (object != NULL) {
				_dl_free((char *)sod.sod_name);
				object->obj_flags = flags;
				return (object);
			}
		}
	}

	/* check 'standard' locations */
	hint = _dl_find_shlib(&req_sod, NULL, ignore_hints);
	if (hint != NULL) {
		if (req_sod.sod_minor < sod.sod_minor)
			_dl_printf("warning: lib%s.so.%d.%d: "
			    "minor version >= %d expected, "
			    "using it anyway\n",
			    sod.sod_name, sod.sod_major,
			    req_sod.sod_minor, sod.sod_minor);
		object = _dl_tryload_shlib(hint, type);
		if (object != NULL) {
			_dl_free((char *)sod.sod_name);
			object->obj_flags = flags;
			return(object);
		}
	}

	if (try_any_minor == 0) {
		try_any_minor = 1;
		ignore_hints = 1;
		req_sod.sod_minor = -1;
		goto again;
	}
	_dl_free((char *)sod.sod_name);
	_dl_errno = DL_NOT_FOUND;
	return(0);
}

d69 1
a69 1
static elf_object_t *
a233 22

void
_dl_link_sub(elf_object_t *dep, elf_object_t *p)
{
	struct dep_node *n;

	n = _dl_malloc(sizeof *n);
	if (n == NULL)
		_dl_exit(5);
	n->data = dep;
	n->next_sibling = NULL;
	if (p->first_child) {
		p->last_child->next_sibling = n;
		p->last_child = n;
	} else
		p->first_child = p->last_child = n;

	DL_DEB(("linking dep %s as child of %s\n", dep->load_name,
	    p->load_name));
}


@


1.34
log
@Fix an issue where a shared library could be loaded at two different
locations by resolving all dlopens back to a dev/inode.

i.e. Don't load a library if the dev/inode it stats back to matches one
already in our list.

fix started (and ok'ed) drahn@@. ok deraadt@@.
"doesn't break anything yet" pval@@ art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.33 2003/09/02 15:17:51 drahn Exp $ */
d137 6
d173 6
@


1.33
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.32 2003/07/18 14:09:02 drahn Exp $ */
d365 1
d382 13
d508 3
d512 1
@


1.32
log
@Fix print if minor of library used is is less than requested. ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.31 2003/07/06 20:03:57 deraadt Exp $ */
d239 1
a239 1
_dl_load_shlib(const char *libname, elf_object_t *parent, int type)
d273 1
d295 1
d313 1
@


1.31
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.30 2003/07/02 08:18:03 niklas Exp $ */
d269 1
a269 1
				    sod.sod_minor, req_sod.sod_minor);
d290 1
a290 1
				    sod.sod_minor, req_sod.sod_minor);
d307 1
a307 1
			    sod.sod_minor, req_sod.sod_minor);
@


1.30
log
@Correct library search algorithm, wrt versioned objects
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.29 2003/06/22 21:39:01 drahn Exp $ */
d191 1
a191 1
						     MAXPATHLEN);
a336 2

void _dl_run_dtors(elf_object_t *object);
@


1.29
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.28 2003/06/09 16:10:03 deraadt Exp $ */
d87 1
a87 1
	    (sodp->sod_major == lsod.sod_major) &&
d93 1
a96 1

d110 1
d171 2
a172 1
				if (_dl_match_file(sodp, dp->d_name,
d175 5
a179 9
					 * When a match is found, sodp is
					 * updated with the minor found.
					 * We continue looking at this
					 * directory, thus this will find
					 * the largest matching library
					 * in this directory.
					 * we save off the d_name now
					 * so that it doesn't have to be
					 * recreated from the hint.
d181 22
a202 6
					match = 1;
					len = _dl_strlcpy(_dl_hint_store, lp,
					    MAXPATHLEN);
					if (lp[len-1] != '/') {
						_dl_hint_store[len] = '/';
						len++;
a203 2
					_dl_strlcpy(&_dl_hint_store[len],
					    dp->d_name, MAXPATHLEN-len);
d207 2
a208 1
			if (match)
d210 1
@


1.28
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.27 2003/05/30 01:13:53 drahn Exp $ */
d475 1
a475 1
	object = _dl_add_object(libname, dynp, 0, type, libaddr, loff);
@


1.27
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.26 2003/02/02 16:57:58 deraadt Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.25 2003/01/30 03:46:46 drahn Exp $ */
a59 1
static void _dl_link_sub(elf_object_t *dep, elf_object_t *p);
a242 1
		_dl_link_sub(object, parent);
a263 1
				_dl_link_sub(object, parent);
a284 1
				_dl_link_sub(object, parent);
a301 1
			_dl_link_sub(object, parent);
d492 1
a492 1
static void
@


1.25
log
@Change the constructor execution order to initialize dependant libraries
first. This mirrors the commit espie put in a.out ld.so recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.24 2002/12/13 20:45:54 drahn Exp $ */
d81 1
a81 1
		if (_dl_strncmp(name, "lib", 3)) {
a82 1
		}
d86 1
a86 1
	    _dl_strlen((char *)sodp->sod_name))) {
a87 1
	}
d112 2
a113 4
	int len;
	char *hint;
	char lp[PATH_MAX + 10];
	char *path;
d115 1
a116 2
	struct dirent *dp;
	int match;
d154 1
d179 2
a180 1
					/* When a match is found, sodp is
a189 1

d198 1
a198 1
						dp->d_name, MAXPATHLEN-len);
d234 2
a236 2
	struct sod sod;
	struct sod req_sod;
a237 2
	int try_any_minor;
	int ignore_hints;
a247 1

d510 1
a510 1
	} else {
d512 1
a512 1
	}
@


1.24
log
@Compare to ELFMAG byte by byte rather than using full fledged function.
Also avoids a gas problem for the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.23 2002/11/17 20:27:20 drahn Exp $ */
d60 1
d250 1
d273 1
d295 1
d313 1
d503 22
@


1.23
log
@Terminate printed strings with newlines.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.22 2002/08/08 17:17:12 art Exp $ */
d381 2
a382 1
	if (_dl_strncmp(ehdr->e_ident, ELFMAG, SELFMAG) ||
@


1.22
log
@There was a possible off-by-one in ld.so when loading shared libraries.
In some (rare?) cases, where the bss was too small and fit entirely into the
leftovers of the data segment we could map one extra page. This is slightly
dangerous on PMAP_PREFER machines where mmaps allocations do not happen
linearly in the virtual space and we could end up overwriting mappings
that are already in use.

This also changes the initial allocation from being a MAP_ANON to a
MAP_FILE so that we can pass the fd as a PMAP_PREFER hint.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.21 2002/07/24 04:11:10 deraadt Exp $ */
d266 1
a266 1
				    "using it anyway",
d287 1
a287 1
				    "using it anyway",
d304 1
a304 1
			    "using it anyway",
@


1.21
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.19 2002/07/24 01:05:11 deraadt Exp $ */
d364 3
d408 2
a409 2
	minva &= ~align;
	maxva = (maxva + align) & ~(align);
d412 6
a417 2
	 *  We map the entire area to see that we can get the VM
	 *  space required. Map it unaccessible to start with.
d420 1
a420 1
	    MAP_PRIVATE|MAP_ANON, -1, 0);
d434 3
a436 2
			char *start = (char *)(phdp->p_vaddr & ~align) + loff;
			int size = (phdp->p_vaddr & align) + phdp->p_filesz;
d439 2
a440 1
			res = _dl_mmap(start, size, PFLAGS(phdp->p_flags),
d442 1
a442 1
			    phdp->p_offset & ~align);
d459 2
a460 1
				if (size & align)
d463 6
a468 3
				start = start + ((size + align) & ~align);
				size = size - (phdp->p_vaddr & align);
				size = phdp->p_memsz - size;
@


1.20
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.16 2002/07/12 20:18:30 drahn Exp $ */
d67 1
a67 1
 * 
d101 1
a101 1
		sodp->sod_minor = lsod.sod_minor; 
d122 1
a122 1
	/* if we are to search default directories, and hints 
d137 1
a137 1
		 * the searchpath directories, 
d167 1
a167 1
		else 
d429 1
a429 1
			int res;
d440 1
a440 1
			if (_dl_check_error(res)) {
d459 1
a459 1
				if (_dl_check_error(res)) {
@


1.19
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.18 2002/07/24 00:13:25 deraadt Exp $ */
d67 1
a67 1
 *
d101 1
a101 1
		sodp->sod_minor = lsod.sod_minor;
d122 1
a122 1
	/* if we are to search default directories, and hints
d137 1
a137 1
		 * the searchpath directories,
d167 1
a167 1
		else
d429 1
a429 1
			void *res;
d440 1
a440 1
			if (_dl_check_error((long)res)) {
d459 1
a459 1
				if (_dl_check_error((long)res)) {
@


1.18
log
@cope with _dl_mmap() returning void *
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.17 2002/07/23 23:56:31 mickey Exp $ */
d67 1
a67 1
 * 
d101 1
a101 1
		sodp->sod_minor = lsod.sod_minor; 
d122 1
a122 1
	/* if we are to search default directories, and hints 
d137 1
a137 1
		 * the searchpath directories, 
d167 1
a167 1
		else 
@


1.17
log
@match _dl_ syscall prototypes w/ the real syscalls prototypes, including args and return values; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.16 2002/07/12 20:18:30 drahn Exp $ */
d440 1
a440 1
			if (_dl_check_error(res)) {
d459 1
a459 1
				if (_dl_check_error(res)) {
@


1.16
log
@Change ld.so search order/method to match the a.out ld.so.

run destructors on dlclose()

Move more symbols into _dl_ private space, so that the proper (libc)
version of the function will be used.

Add readdir() functionality to perform the proper library searching.

Support DL_PRELOAD

Do not relocate symbols if ld.so is being traced (and will exit).

Misc lint cleanup.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.15 2002/06/05 19:34:44 art Exp $ */
d429 1
a429 1
			int res;
@


1.15
log
@Get rid of an unnecessary typedef (for future cleanup).
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.14 2002/05/28 00:22:01 deraadt Exp $ */
d4 1
d40 1
d45 1
d50 4
d59 157
a215 3
elf_object_t *_dl_tryload_shlib(const char *libname, int type);
void	_dl_build_sod(const char *name, struct sod *sodp);
char	*_dl_findhint(char *name, int major, int minor, char *prefered_path);
d221 4
d226 6
a231 2
 *	check /var/run/ld.so.hints cache
 *	last look in /usr/lib.
a236 1
	char lp[PATH_MAX + 10], *hint, *path = lp;
d238 8
a245 2
	const char *pp;
	struct sod sodp;
d252 5
d260 14
a273 17
	pp = _dl_libpath;
	while (pp) {
		const char *ln = libname;

		path = lp;
		while (path < lp + PATH_MAX && *pp && *pp != ':' && *pp != ';')
			*path++ = *pp++;
		/* Insert '/' */
		if (path != lp && *(path - 1) != '/')
			*path++ = '/';

		while (path < lp + PATH_MAX && (*path++ = *ln++))
			;
		if (path < lp + PATH_MAX) {
			object = _dl_tryload_shlib(lp, type);
			if (object)
				return(object);
a274 4
		if (*pp)	/* Try curdir if ':' at end */
			pp++;
		else
			pp = 0;
d280 15
a294 18
	pp = parent->dyn.rpath;
	while (pp) {
		const char *ln = libname;

		path = lp;
		while (path < lp + PATH_MAX && *pp && *pp != ':')
			*path++ = *pp++;

		/* Make sure '/' after dir path */
		if (*(path - 1) != '/')
			*path++ = '/';

		while (path < lp + PATH_MAX && (*path++ = *ln++))
			;
		if (path < lp + PATH_MAX) {
			object = _dl_tryload_shlib(lp, type);
			if (object)
				return(object);
a295 4
		if (*pp)	/* Try curdir if ':' at end */
			pp++;
		else
			pp = 0;
d298 9
a306 3
	_dl_build_sod(libname, &sodp);
	if ((hint = _dl_findhint((char *)sodp.sod_name, sodp.sod_major,
	    sodp.sod_minor, NULL)) != NULL) {
d308 4
a311 1
		return(object);
d314 5
a318 11
	/*
	 *  Check '/usr/lib'
	 */
	_dl_strlcpy(lp, "/usr/lib/", sizeof(lp));
	path = lp + sizeof("/usr/lib/") - 1;
	while (path < lp + PATH_MAX && (*path++ = *libname++))
		;
	if (path < lp + PATH_MAX) {
		object = _dl_tryload_shlib(lp, type);
		if (object)
			return(object);
d320 1
d337 2
d343 1
d351 1
a351 1
elf_object_t *
@


1.14
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.13 2002/05/24 18:37:38 drahn Exp $ */
d157 1
a157 1
_dl_load_list_free(load_list_t *load_list)
d159 1
a159 1
	load_list_t *next;
d183 1
a183 1
	load_list_t *next_load, *load_list = NULL;
d262 1
a262 2
			next_load = (load_list_t *)_dl_malloc(
			    sizeof(load_list_t));
@


1.13
log
@Change _dl_strcpy() to _dl_strlcpy(), implementation taken from libc.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.12 2002/05/24 04:17:00 deraadt Exp $ */
d68 2
a69 2
	char	lp[PATH_MAX + 10];
	char	*path = lp;
a70 1
	elf_object_t *object;
a71 1
	char *hint;
d99 1
a99 1
		if (*pp) {	/* Try curdir if ':' at end */
d101 1
a101 1
		} else {
a102 1
		}
d115 1
d127 1
a127 1
		if (*pp) {	/* Try curdir if ':' at end */
d129 1
a129 1
		} else {
a130 1
		}
a139 1

a142 1

d149 1
a149 1
		if (object) {
a150 1
		}
d182 5
a186 2
	int	libfile;
	int	i;
d188 1
a190 8
	Elf_Dyn *dynp = 0;
	Elf_Addr maxva = 0;
	Elf_Addr minva = 0x7fffffff;	/* XXX Correct for 64bit? */
	Elf_Addr libaddr;
	Elf_Addr loff;
	int	align = _dl_pagesz - 1;
	elf_object_t *object;
	load_list_t *next_load, *load_list = NULL;
d207 1
a207 1
	   ehdr->e_type != ET_DYN || ehdr->e_machine != MACHID) {
a216 1

d221 1
a221 1
			if (phdp->p_vaddr < minva) {
d223 1
a223 2
			}
			if (phdp->p_vaddr + phdp->p_memsz > maxva) {
a224 1
			}
a225 1

a228 1

d241 1
a241 1
					MAP_PRIVATE|MAP_ANON, -1, 0);
a254 1
			int res;
d257 1
d287 1
a287 2
				    MAP_FIXED|MAP_PRIVATE|MAP_ANON,
				    -1, 0);
@


1.12
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.11 2002/05/24 03:44:37 deraadt Exp $ */
d148 1
a148 1
	_dl_strcpy(lp, "/usr/lib/");
@


1.11
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.10 2001/09/22 04:33:36 drahn Exp $ */
d193 1
a193 1
	Elf_Dyn  *dynp = 0;
d272 2
a273 1
			int size  = (phdp->p_vaddr & align) + phdp->p_filesz;
d298 2
a299 2
				size  = size - (phdp->p_vaddr & align);
				size  = phdp->p_memsz - size;
@


1.10
log
@Do not check for ':' twice, otherwise the rpath loses the first character
after the : in the list of paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.9 2001/08/21 01:19:35 drahn Exp $ */
d5 1
a5 1
 * 
d52 3
a54 3
elf_object_t * _dl_tryload_shlib(const char *libname, int type);
void _dl_build_sod(const char *name, struct sod *sodp);
char * _dl_findhint(char *name, int major, int minor, char *prefered_path);
d75 1
a75 1
	if(_dl_strchr(libname, '/')) {
d84 1
a84 1
	while(pp) {
d88 1
a88 1
		while(path < lp + PATH_MAX && *pp && *pp != ':' && *pp != ';') {
d90 2
a91 2
		}
		if(path != lp && *(path - 1) != '/') {	/* Insert '/' */
d93 4
a96 3
		}
		while(path < lp + PATH_MAX && (*path++ = *ln++)) {};
		if(path < lp + PATH_MAX) {
d98 1
a98 1
			if(object) {
a99 1
			}
d101 1
a101 1
		if(*pp) {	/* Try curdir if ':' at end */
d103 1
a103 2
		}
		else {
d112 1
a112 1
	while(pp) {
d116 1
a116 1
		while(path < lp + PATH_MAX && *pp && *pp != ':') {
d118 2
a119 2
		}
		if(*(path - 1) != '/') {/* Make sure '/' after dir path */
d121 4
a124 3
		}
		while(path < lp + PATH_MAX && (*path++ = *ln++)) {};
		if(path < lp + PATH_MAX) {
d126 1
a126 1
			if(object) {
a127 1
			}
d129 1
a129 1
		if(*pp) {	/* Try curdir if ':' at end */
d131 1
a131 2
		}
		else {
d138 1
a138 2
		sodp.sod_minor, NULL)) != NULL)
	{
a140 1
		
d150 3
a152 2
	while(path < lp + PATH_MAX && (*path++ = *libname++)) {};
	if(path < lp + PATH_MAX) {
d154 1
a154 1
		if(object) {
d167 1
a167 1
	while(load_list != NULL) {
d177 1
a177 1
	if(--object->refcount == 0) {
d190 1
a190 1
	char 	hbuf[4096];
d203 1
a203 1
	if(object) {
d209 1
a209 1
	if(libfile < 0) {
d216 1
a216 1
	if(_dl_strncmp(ehdr->e_ident, ELFMAG, SELFMAG) ||
d229 2
a230 2
	for(i = 0; i < ehdr->e_phnum; i++, phdp++) {
		switch(phdp->p_type) {
d232 1
a232 1
			if(phdp->p_vaddr < minva) {
d235 1
a235 1
			if(phdp->p_vaddr + phdp->p_memsz > maxva) {
d257 1
a257 1
	if(_dl_check_error(libaddr)) {
d259 1
a259 1
				_dl_progname, libname);
d268 2
a269 2
	for(i = 0; i < ehdr->e_phnum; i++, phdp++) {
		if(phdp->p_type == PT_LOAD) {
d274 2
a275 2
					MAP_FIXED|MAP_PRIVATE, libfile,
					phdp->p_offset & ~align);
d277 1
a277 1
					sizeof(load_list_t));
d283 1
a283 1
			if(_dl_check_error(res)) {
d285 1
a285 1
						_dl_progname, libname);
d293 1
a293 1
				if(size & align) {
d295 1
a295 2
						_dl_pagesz - (size & align));
				}
d300 4
a303 4
					       PFLAGS(phdp->p_flags),
					       MAP_FIXED|MAP_PRIVATE|MAP_ANON,
						-1, 0);
				if(_dl_check_error(res)) {
d305 1
a305 1
							_dl_progname, libname);
d319 1
a319 1
	if(object) {
@


1.9
log
@Fix up comment to indicate order that libraries in which the
libraries are actually searched.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.8 2001/08/06 15:09:58 drahn Exp $ */
a121 3
		}
		if(*pp) {		/* ':' if not end. skip over. */
			pp++;
@


1.8
log
@Change the priority of LD_LIBRARY_PATH, -rpath, and ldconfig path
in ELF ld.so to match the behavior in a.out ld.so. The given order
is the new order, previously ldconfig had highest priority, which
made it impossible to override.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.7 2001/05/31 13:47:20 art Exp $ */
d58 4
a61 3
 *	If the name contains a '/' use the name exactly as is.
 *	Otherwise first check DT_RPATH paths,
 *	then try the LD_LIBRARY_PATH specification and
@


1.7
log
@random indentation fixes (needs much more work).
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.6 2001/05/11 16:19:37 art Exp $ */
a73 9
	_dl_build_sod(libname, &sodp);
	if ((hint = _dl_findhint((char *)sodp.sod_name, sodp.sod_major,
		sodp.sod_minor, NULL)) != NULL)
	{
		object = _dl_tryload_shlib(hint, type);
		return(object);
		
	}

d139 10
@


1.6
log
@MAP_COPY -> MAP_PRIVATE
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.5 2001/04/02 23:11:20 drahn Exp $ */
d296 1
a296 1
			if(phdp->p_flags & PF_W) {
d327 1
a327 2
	}
	else {
@


1.5
log
@Cleanup for 64bit support.
Pieces by art, niklas and me.
Only tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.4 2001/03/30 01:35:20 drahn Exp $ */
d260 1
a260 1
					MAP_COPY|MAP_ANON, -1, 0);
d278 1
a278 1
					MAP_FIXED|MAP_COPY, libfile,
d306 1
a306 1
					       MAP_FIXED|MAP_COPY|MAP_ANON,
@


1.4
log
@Add infrastructure to allow mapping of text sections which are normally
RO, RW while ld.so is working. And then the information to set the
sections back to RO (or appropriate mode).

PowerPC now supports the typical NON-PIC relocations in ld.so.
I do not know how well this will work with large shared libraries.
I seem to recall a possible problem with large data where data is
located in a different shared library.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.3 2001/02/16 05:28:17 drahn Exp $ */
d195 7
a201 7
	Elf32_Ehdr *ehdr;
	Elf32_Phdr *phdp;
	Elf32_Dyn  *dynp = 0;
	Elf32_Addr maxva = 0;
	Elf32_Addr minva = 0x7fffffff;
	Elf32_Addr libaddr;
	Elf32_Addr loff;
d219 1
a219 1
	ehdr = (Elf32_Ehdr *)hbuf;
d232 1
a232 1
	phdp = (Elf32_Phdr *)(hbuf + ehdr->e_phoff);
d245 1
a245 1
			dynp = (Elf32_Dyn *)phdp->p_vaddr;
d259 1
a259 1
	libaddr = (Elf32_Addr)_dl_mmap(0, maxva - minva, PROT_NONE,
d270 1
a270 1
	phdp = (Elf32_Phdr *)(hbuf + ehdr->e_phoff);
d322 1
a322 1
	dynp = (Elf32_Dyn *)((int)dynp + loff);
@


1.3
log
@Now that powerpc is using UVM, this shared library hack is no longer necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.2 2000/10/06 17:40:17 rahnds Exp $ */
d167 12
d182 1
d204 1
d271 1
d280 7
d293 1
d297 4
a300 2
				_dl_memset(start + size, 0,
					_dl_pagesz - (size & align));
d314 1
d326 1
d330 1
@


1.2
log
@Work around a shared library/pmap bug on the powerpc arch. Somehow
it seems that the instruction cache will not get properly initialized
or a problem exists with mmaping code and being able to execute it.
This workaround is excessive in that it flushes the cache for the
entire mmaped library. This slows down program startup, but seems
to eliminate the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: library.c,v 1.2 2000/10/06 17:33:51 drahn Exp $ */
d243 1
a243 1
	 *  space requiered. Map it unaccessible to start with.
a264 3
#ifdef __powerpc__
			_dl_syncicache(start, size);
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 1
a43 1
#include "resolve.h"
d46 1
d53 2
d71 11
d265 3
d280 1
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@


1.1.1.2
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems
such as correctness and security.
@
text
@a39 1
#include <nlist.h>
d43 1
a45 1
#include "resolve.h"
a51 2
void _dl_build_sod(const char *name, struct sod *sodp);
char * _dl_findhint(char *name, int major, int minor, char *prefered_path);
a67 11
	struct sod sodp;
	char *hint;

	_dl_build_sod(libname, &sodp);
	if ((hint = _dl_findhint((char *)sodp.sod_name, sodp.sod_major,
		sodp.sod_minor, NULL)) != NULL)
	{
		object = _dl_tryload_shlib(hint, type);
		return(object);
		
	}
a262 1
				size  = size - (phdp->p_vaddr & align);
@

