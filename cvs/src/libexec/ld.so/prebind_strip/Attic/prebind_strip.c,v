head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2006.05.11.22.03.22;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2006.05.08.20.37.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.08.20.34.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.05.02.51.16;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.03.16.10.52;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@move prebind_strip(8) into ldconfig as the -D option; ok drahn
@
text
@/* $OpenBSD: prebind_strip.c,v 1.4 2006/05/08 20:37:01 deraadt Exp $ */
/*
 * Copyright (c) 2006 Dale Rahn <drahn@@dalerahn.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/exec_elf.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "prebind.h"

void strip_prebind(char *file, char *output);
void prebind_remove_load_section(int fd, char *name);
int prebind_cat(int fd, struct prebind_footer *footer, char *name);

extern char *__progname;

void __dead
usage(void)
{
	fprintf(stderr, "Usage:%s [-o <outfile>] <filelist>\n", __progname);
	exit(1);
}


int
main(int argc, char **argv)
{
	char *outputfile = NULL;
	int i;
	int ch;
	while ((ch = getopt(argc, argv, "o:")) != -1) {
		switch (ch) {
		case 'o':
			outputfile = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (outputfile != NULL && argc > 1) {
		fprintf(stderr, "%s:-o will not work with multiple files\n",
		    __progname);
		usage();
	}
	for (i = 0; i < argc; i++) {
		strip_prebind(argv[i], outputfile);
	}

	return 0;
}

void
strip_prebind(char *file, char *outfile)
{
	struct prebind_footer footer;
	int fd;
	ssize_t bytes;
	int mode;

	if (outfile == NULL)
		mode = O_RDWR;
	else
		mode = O_RDONLY;

	fd = open(file, mode);
	if (fd == -1) {
		perror(file);
		return;
	}
	lseek(fd, -((off_t)sizeof(struct prebind_footer)), SEEK_END);
	bytes = read(fd, &footer, sizeof(struct prebind_footer));
	if (bytes != sizeof(struct prebind_footer)) {
		perror("short read\n");
		goto done;
	}

	if (footer.bind_id[0] == BIND_ID0 &&
	    footer.bind_id[1] == BIND_ID1 &&
	    footer.bind_id[2] == BIND_ID2 &&
	    footer.bind_id[3] == BIND_ID3) {

	} else {
		fprintf(stderr, "%s: no prebind header\n", file);
		goto done;
	}

	if (outfile == NULL) {
		prebind_remove_load_section(fd, file);

		ftruncate(fd, footer.orig_size);
	} else {
		prebind_cat(fd, &footer, outfile);
	}
done:
	close(fd);
}

void
prebind_remove_load_section(int fd, char *name)
{
	void *buf;
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdr;
	int loadsection;

	buf = mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_FILE | MAP_SHARED,
	    fd, 0);
	if (buf == MAP_FAILED) {
		perror(name);
		fprintf(stderr, "%s: cannot mmap for write\n", name);
		return;
	}

	ehdr = (Elf_Ehdr *) buf;
	phdr = (Elf_Phdr *)((char *)buf + ehdr->e_phoff);

	loadsection = ehdr->e_phnum - 1;

	if (ehdr->e_type != ET_EXEC ||
	    (phdr[loadsection].p_flags & 0x08000000) == 0) {
		goto done;
	}

	if ((phdr[loadsection].p_type != PT_LOAD) ||
	    ((phdr[loadsection].p_flags & 0x08000000) == 0)) {
		/* doesn't look like ours */
		fprintf(stderr, "mapped, %s id doesn't match %lx\n", name,
		    (long)(phdr[loadsection].p_vaddr));
		goto done;
	}

	bzero(&phdr[loadsection], sizeof(Elf_Phdr));

	ehdr->e_phnum--;
done:
	munmap(buf, 8192);
}

int
prebind_cat(int fd, struct prebind_footer *footer, char *name)
{
	int outfd;
	void *buf;
	Elf_Ehdr *ehdr;
	Elf_Phdr *phdr;
	size_t len, wlen, rlen, remlen;
	int header_done = 0;
	int err = 0;
	int loadsection;

	if (strcmp(name, "-") == 0)
		outfd = 1;
	else
		outfd = open(name, O_RDWR|O_CREAT|O_TRUNC, 0644);

	if (outfd == -1) {
		fprintf(stderr, "unable to open file %s\n", name);
		return 1;
	}
#define BUFSZ (256 * 1024)
	buf = malloc(BUFSZ);

	if (buf == NULL) {
		fprintf(stderr, "failed to allocate copy buffer\n");
		return 1;
	}

	lseek(fd, 0, SEEK_SET);
	remlen = footer->orig_size;
	while (remlen > 0) {
		if (remlen > BUFSZ)
			rlen = BUFSZ;
		else
			rlen = remlen;
		len = read(fd, buf, rlen);
		if (len <= 0) {
			break; /* read failure */
			err=1;
		}
		remlen -= len;
		if (header_done == 0) {
			header_done = 1;
			ehdr = (Elf_Ehdr *) buf;
			phdr = (Elf_Phdr *)((char *)buf + ehdr->e_phoff);

			loadsection = ehdr->e_phnum - 1;

			if ((len >= ehdr->e_phoff +
			    sizeof(Elf_Phdr) * ehdr->e_phnum) &&
			    ehdr->e_type == ET_EXEC &&
			    (phdr[loadsection].p_flags & 0x08000000) != 0 &&
			    (phdr[loadsection].p_type == PT_LOAD)) {
				bzero(&phdr[loadsection], sizeof(Elf_Phdr));
				ehdr->e_phnum--;
			}
		}
		wlen = write(outfd, buf, len);
		if (wlen != len) {
			/* write failed */
			err=1;
			break;
		}
	}

	return err;
}
@


1.4
log
@more spacing
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_strip.c,v 1.3 2006/05/08 20:34:36 deraadt Exp $ */
@


1.3
log
@de-space
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_strip.c,v 1.2 2006/05/05 02:51:16 drahn Exp $ */
d140 1
a140 1
	if(ehdr->e_type != ET_EXEC ||
@


1.2
log
@Add -o <output> mode in addition to strip in place, '-' is stdout.
@
text
@d1 1
a1 1
/* $OpenBSD: prebind_strip.c,v 1.1 2006/05/03 16:10:52 drahn Exp $ */
d172 1
a172 1
	if (strcmp(name, "-") == 0) 
d174 1
a174 1
	else 
d194 1
a194 1
		else 
d225 1
a225 1
		
@


1.1
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 12
a39 7
void dump_prebind(char *file);
void prebind_dump_footer(struct prebind_footer *footer, char *file);
void prebind_dump_symcache(struct symcachetab *symcachetab, u_int32_t cnt);
void prebind_dump_nameidx(struct nameidx *nameidx, u_int32_t numblibs,
    char *nametab);
void prebind_dump_fixup(struct fixup *fixup, u_int32_t numfixups);
void prebind_dump_libmap(u_int32_t *libmap, u_int32_t numlibs, void *a);
a40 1
void prebind_remove_load_section(int fd, char *name);
d45 1
d47 21
a67 3
	for (i = 1; i < argc; i++) {
		printf("stripping %s\n", argv[i]);
		dump_prebind(argv[i]);
d74 1
a74 1
dump_prebind(char *file)
d79 6
d86 1
a86 1
	fd = open(file, O_RDWR);
d104 1
a104 1
		printf("%s: no prebind header\n", file);
d108 2
a109 1
	prebind_remove_load_section(fd, file);
d111 4
a114 1
	ftruncate(fd, footer.orig_size);
d131 1
a131 1
		printf("%s: cannot mmap for write\n", name);
d148 1
a148 1
		printf("mapped, %s id doesn't match %lx\n", name,
d158 69
@

