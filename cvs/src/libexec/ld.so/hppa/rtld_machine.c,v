head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.36
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.35;
commitid	veGB6uLWx3BTEAfk;

1.35
date	2017.01.09.22.51.04;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	8mveS1UjNqlN99uR;

1.34
date	2016.08.27.22.52.21;	author guenther;	state Exp;
branches;
next	1.33;
commitid	Mv44aUnxdb4Sup0h;

1.33
date	2016.06.21.15.21.42;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	lL1eKVpNKR6kIDJW;

1.32
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.31;
commitid	zGFWeGZdYJxUOZli;

1.31
date	2015.08.27.20.55.34;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	mgN9IJuqxtm8ShTw;

1.30
date	2015.08.27.04.10.35;	author guenther;	state Exp;
branches;
next	1.29;
commitid	NJR1ZEUifTt0ofeH;

1.29
date	2014.04.16.10.52.59;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.26.18.50.48;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.05.23.20.06;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.20.13.47.20;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.05.21.40.58;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.05.17.04.44;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.27.08.26.49;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.02.12.03.24;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.03.22.18.04;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.09.12.34.47;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.03.16.10.52;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.22.04.07.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.21.23.12.10;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.16.23.19.42;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.09.17.57.40;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.07.15.19.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.07.07.13.35;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.01.21.07.46;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.27.21.59.07;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.25.21.56.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.25.21.48.00;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.36
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.35 2017/01/09 22:51:04 kettenis Exp $	*/

/*
 * Copyright (c) 2004 Michael Shalayeff
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 * Copyright (c) 1999 Dale Rahn
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/tree.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <machine/vmparam.h>	/* SYSCALLGATE */

#include <nlist.h>
#include <link.h>
#include <string.h>

#include "syscall.h"
#include "archdep.h"
#define	_dl_bind XXX_dl_bind
#include "resolve.h"
#undef	_dl_bind
uint64_t _dl_bind(elf_object_t *object, int reloff);

typedef
struct hppa_plabel {
	Elf_Addr	pc;
	Elf_Addr	*sl;
	SPLAY_ENTRY(hppa_plabel) node;
} hppa_plabel_t;
SPLAY_HEAD(_dl_md_plabels, hppa_plabel) _dl_md_plabel_root;

void	_hppa_dl_set_dp(Elf_Addr *dp);	/* from ldasm.S */

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

static __inline int
_dl_md_plcmp(hppa_plabel_t *a, hppa_plabel_t *b)
{
	if (a->sl < b->sl)
		return (-1);
	else if (a->sl > b->sl)
		return (1);
	else if (a->pc < b->pc)
		return (-1);
	else if (a->pc > b->pc)
		return (1);
	else
		return (0);
}

SPLAY_PROTOTYPE(_dl_md_plabels, hppa_plabel, node, _dl_md_plcmp);
SPLAY_GENERATE(_dl_md_plabels, hppa_plabel, node, _dl_md_plcmp);

Elf_Addr
_dl_md_plabel(Elf_Addr pc, Elf_Addr *sl)
{
	hppa_plabel_t key, *p;

	key.pc = pc;
	key.sl = sl;
	p = SPLAY_FIND(_dl_md_plabels, &_dl_md_plabel_root, &key);
	if (p == NULL) {
		p = _dl_malloc(sizeof(*p));
		if (p == NULL)
			_dl_oom();
		p->pc = pc;
		p->sl = sl;
		SPLAY_INSERT(_dl_md_plabels, &_dl_md_plabel_root, p);
	}

	return (Elf_Addr)p | 2;
}

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	Elf_RelA	*rela;
	Elf_Addr	loff;
	int	i, numrela, fails = 0;
	size_t	size;
	struct load_list *llist;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf_RelA);
	rela = (Elf_RelA *)(object->Dyn.info[rel]);

#ifdef DEBUG
	DL_DEB(("object %s relasz %x, numrela %x loff %x\n",
	    object->load_name, object->Dyn.info[relasz], numrela, loff));
#endif

	if (rela == NULL)
		return (0);

	/* either it's an ld bug or a wacky hpux abi */
	if (!object->dyn.pltgot)
		object->Dyn.info[DT_PLTGOT] += loff;

	if (object->dyn.init && !((Elf_Addr)object->dyn.init & 2)) {
		Elf_Addr addr = _dl_md_plabel((Elf_Addr)object->dyn.init,
		    object->dyn.pltgot);
#ifdef DEBUG
		DL_DEB(("PLABEL32: %p:%p(_init) -> 0x%x in %s\n",
		    object->dyn.init, object->dyn.pltgot,
		    addr, object->load_name));
#endif
		object->dyn.init = (void *)addr;
	}

	if (object->dyn.fini && !((Elf_Addr)object->dyn.fini & 2)) {
		Elf_Addr addr = _dl_md_plabel((Elf_Addr)object->dyn.fini,
		    object->dyn.pltgot);
#ifdef DEBUG
		DL_DEB(("PLABEL32: %p:%p(_fini) -> 0x%x in %s\n",
		    object->dyn.fini, object->dyn.pltgot,
		    addr, object->load_name));
#endif
		object->dyn.fini = (void *)addr;
	}

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ|PROT_WRITE);
		}
	}

	/*
	 * this is normally done by the crt0 code but we have to make
	 * sure it's set here to allow constructors to call functions
	 * that are overridden in the user binary (that are un-pic)
	 */
	if (object->obj_type == OBJTYPE_EXE)
		_hppa_dl_set_dp(object->dyn.pltgot);

	for (i = 0; i < numrela; i++, rela++) {
		const elf_object_t *sobj;
		const Elf_Sym *sym, *this;
		Elf_Addr *pt, ooff;
		const char *symn;
		int type;

		type = ELF_R_TYPE(rela->r_info);
		if (type == RELOC_NONE)
			continue;

		sym = object->dyn.symtab + ELF_R_SYM(rela->r_info);
		sobj = object;
		symn = object->dyn.strtab + sym->st_name;
		pt = (Elf_Addr *)(rela->r_offset + loff);

		ooff = 0;
		this = NULL;
		if (ELF_R_SYM(rela->r_info) && sym->st_name) {
			ooff = _dl_find_symbol_bysym(object,
			    ELF_R_SYM(rela->r_info), &this,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
			    ((type == RELOC_IPLT) ? SYM_PLT: SYM_NOTPLT),
			    sym, &sobj);
			if (this == NULL) {
				if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
					fails++;
				continue;
			}
		}

#ifdef DEBUG
		DL_DEB(("*pt=%x r_addend=%x r_sym=%x\n",
		    *pt, rela->r_addend, ELF_R_SYM(rela->r_info)));
#endif

		switch (type) {
		case RELOC_DIR32:
			if (ELF_R_SYM(rela->r_info) && sym->st_name) {
				*pt = ooff + this->st_value + rela->r_addend;
#ifdef DEBUG
				DL_DEB(("[%x]DIR32: %s:%s -> 0x%x in %s\n",
				    i, symn, object->load_name,
				    *pt, sobj->load_name));
#endif
			} else {
				/*
				 * XXX should objects ever get their
				 * sections loaded insequential this
				 * would have to get a section number
				 * (ELF_R_SYM(rela->r_info))-1 and then:
				 *    *pt = sect->addr + rela->r_addend;
				 */
				if (ELF_R_SYM(rela->r_info))
					*pt += loff;
				else
					*pt += loff + rela->r_addend;
#ifdef DEBUG
				DL_DEB(("[%x]DIR32: %s @@ 0x%x\n", i,
				    object->load_name, *pt));
#endif
			}
			break;

		case RELOC_PLABEL32:
			if (ELF_R_SYM(rela->r_info)) {
				if (ELF_ST_TYPE(this->st_info) != STT_FUNC) {
					DL_DEB(("[%x]PLABEL32: bad\n", i));
					break;
				}
				*pt = _dl_md_plabel(sobj->obj_base +
				    this->st_value + rela->r_addend,
				    sobj->dyn.pltgot);
#ifdef DEBUG
				DL_DEB(("[%x]PLABEL32: %s:%s -> 0x%x in %s\n",
				    i, symn, object->load_name,
				    *pt, sobj->load_name));
#endif
			} else {
				*pt = loff + rela->r_addend;
#ifdef DEBUG
				DL_DEB(("[%x]PLABEL32: %s @@ 0x%x\n", i,
				    object->load_name, *pt));
#endif
			}
			break;

		case RELOC_IPLT:
			if (ELF_R_SYM(rela->r_info)) {
				pt[0] = ooff + this->st_value + rela->r_addend;
				pt[1] = (Elf_Addr)sobj->dyn.pltgot;
#ifdef DEBUG
				DL_DEB(("[%x]IPLT: %s:%s -> 0x%x:0x%x in %s\n",
				    i, symn, object->load_name,
				    pt[0], pt[1], sobj->load_name));
#endif
			} else {
				pt[0] = loff + rela->r_addend;
				pt[1] = (Elf_Addr)object->dyn.pltgot;
#ifdef DEBUG
				DL_DEB(("[%x]IPLT: %s @@ 0x%x:0x%x\n", i,
				    object->load_name, pt[0], pt[1]));
#endif
			}
			break;

		case RELOC_COPY:
		{
			const Elf32_Sym *cpysrc = NULL;
			size = sym->st_size;
			ooff = _dl_find_symbol(symn, &cpysrc,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym, object, NULL);
			if (cpysrc) {
				_dl_bcopy((void *)(ooff + cpysrc->st_value),
				    pt, sym->st_size);
#ifdef DEBUG
				DL_DEB(("[%x]COPY: %s[%x]:%s -> %p[%x] in %s\n",
				    i, symn, ooff + cpysrc->st_value,
				    object->load_name, pt, sym->st_size,
				    sobj->load_name));
#endif
			} else
				DL_DEB(("[%x]COPY: no sym\n", i));
			break;
		}
		default:
			DL_DEB(("[%x]UNKNOWN(%d): type=%d off=0x%lx "
			    "addend=0x%lx rel=0x%x\n", i, type,
			    ELF_R_TYPE(rela->r_info), rela->r_offset,
			    rela->r_addend, *pt));
			break;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

extern void _dl_bind_start(void);

#define PLT_STUB_SIZE	(7 * 4)
#define PLT_ENTRY_SIZE	(2 * 4)
#define PLT_STUB_GOTOFF	(4 * 4)

#define PLT_STUB_MAGIC1	0x00c0ffee
#define PLT_STUB_MAGIC2	0xdeadbeef

#define PLT_STUB_INSN1	0x0e801081	/* ldw	0(%r20), %r1 */
#define PLT_STUB_INSN2	0xe820c000	/* bv	%r0(%r1) */

int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	Elf_RelA *rela;
	Elf_Addr  ooff;
	int	i, numrela, fails = 0;

	if (object->dyn.pltrel != DT_RELA)
		return (0);

	if (object->traced)
		lazy = 1;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		register Elf_Addr ltp __asm ("%r19");
		Elf_Addr *got = NULL;

		rela = (Elf_RelA *)(object->dyn.jmprel);
		numrela = object->dyn.pltrelsz / sizeof(Elf_RelA);
		ooff = object->obj_base;

		/*
		 * Find the PLT stub by looking at all the
		 * relocations.  The PLT stub should be at the end of
		 * the .plt section so we start with the last
		 * relocation, since the linker should have emitted
		 * them in order.
		 */
		for (i = numrela - 1; i >= 0; i--) {
			got = (Elf_Addr *)(ooff + rela[i].r_offset +
			    PLT_ENTRY_SIZE + PLT_STUB_SIZE);
			if (got[-2] == PLT_STUB_MAGIC1 ||
			    got[-1] == PLT_STUB_MAGIC2)
				break;
			got = NULL;
		}
		if (got == NULL)
			return (1);

		/*
		 * Patch up the PLT stub such that it doesn't clobber
		 * %r22, which is used to pass on the errno values
		 * from failed system calls to __cerrno() in libc.
		 */
		got[-7] = PLT_STUB_INSN1;
		got[-6] = PLT_STUB_INSN2;
		__asm volatile("fdc 0(%0)" :: "r" (&got[-7]));
		__asm volatile("fdc 0(%0)" :: "r" (&got[-6]));
		__asm volatile("sync");
		__asm volatile("fic 0(%%sr0,%0)" :: "r" (&got[-7]));
		__asm volatile("fic 0(%%sr0,%0)" :: "r" (&got[-6]));
		__asm volatile("sync");

		/*
		 * Fill in the PLT stub such that it invokes the
		 * _dl_bind_start() trampoline to fix up the
		 * relocation.
		 */
		got[1] = (Elf_Addr)object;
		got[-2] = (Elf_Addr)&_dl_bind_start;
		got[-1] = ltp;
		/*
		 * We need the real address of the trampoline.  Get it
		 * from the function descriptor if that's what we got.
		 */
		if (got[-2] & 2) {
			hppa_plabel_t *p = (hppa_plabel_t *)(got[-2] & ~2);
			got[-2] = p->pc;
		}
		/*
		 * Even though we didn't modify any instructions it
		 * seems we still need to synchronize the caches.
		 * There may be instructions in the same cache line
		 * and they end up being corrupted otherwise.
		 */
		__asm volatile("fdc 0(%0)" :: "r" (&got[-2]));
		__asm volatile("fdc 0(%0)" :: "r" (&got[-1]));
		__asm volatile("sync");
		__asm volatile("fic 0(%%sr0,%0)" :: "r" (&got[-2]));
		__asm volatile("fic 0(%%sr0,%0)" :: "r" (&got[-1]));
		__asm volatile("sync");
		for (i = 0; i < numrela; i++, rela++) {
			Elf_Addr *r_addr = (Elf_Addr *)(ooff + rela->r_offset);

			if (ELF_R_TYPE(rela->r_info) != RELOC_IPLT) {
				_dl_printf("unexpected reloc 0x%x\n",
				    ELF_R_TYPE(rela->r_info));
				return (1);
			}

			if (ELF_R_SYM(rela->r_info)) {
				r_addr[0] = (Elf_Addr)got - PLT_STUB_GOTOFF;
				r_addr[1] = (Elf_Addr) (rela -
				    (Elf_RelA *)object->dyn.jmprel);
			} else {
				r_addr[0] = ooff + rela->r_addend;
				r_addr[1] = (Elf_Addr)object->dyn.pltgot;
			}
		}
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end",
	    PROT_READ|PROT_EXEC);

	return (fails);
}

/*
 * Resolve a symbol at run-time.
 */
uint64_t
_dl_bind(elf_object_t *object, int reloff)
{
	const elf_object_t *sobj;
	const Elf_Sym *sym, *this;
	Elf_Addr ooff;
	const char *symn;
	Elf_Addr value;
	Elf_RelA *rela;
	uint64_t cookie = pcookie;
	struct {
		struct __kbind param;
		uint64_t newval;
	} buf;

	rela = (Elf_RelA *)object->dyn.jmprel + reloff;

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rela->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	value = ooff + this->st_value + rela->r_addend;

	buf.newval = ((uint64_t)value << 32) | (Elf_Addr)sobj->dyn.pltgot;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
	buf.param.kb_size = sizeof(uint64_t);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long r1 __asm__("r1") = SYSCALLGATE;
		register void *arg0 __asm__("r26") = &buf;
		register long arg1 __asm__("r25") = sizeof(buf);
		register long arg2 __asm__("r24") = 0xffffffff & (cookie >> 32);
		register long arg3 __asm__("r23") = 0xffffffff & cookie;
		__asm__ __volatile__ ("ble 4(%%sr7, %%r1) ! ldi %0, %%r22"
		    :
		    : "i" (SYS_kbind), "r" (r1), "r"(arg0), "r"(arg1),
		      "r"(arg2), "r"(arg3)
		    : "r22", "r28", "r29", "cc", "memory");
	}

	return (buf.newval);
}
@


1.35
log
@Remove dependency on __got_{start,end} symbols and look at PT_GNU_RELRO
instead.  Result in a few more pages that aren't writable on some platforms
(such as hppa).  Based on an initial diff from guenther@@.

Thanks to deraadt@@ for testing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2016/08/27 22:52:21 guenther Exp $	*/
d94 1
a94 1
			_dl_exit(5);
d465 2
a466 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.34
log
@Delete debugging from when lazy binding was being implemented

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2016/06/21 15:21:42 deraadt Exp $	*/
d433 1
a433 1
	    GOT_PERMS|PROT_EXEC);
@


1.33
log
@Handle textrels like other architectures do.
ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2015/11/02 07:02:53 guenther Exp $	*/
a468 1
	DL_DEB(("%s: %s\n", symn, sobj->load_name));
@


1.32
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2015/08/27 20:55:34 kettenis Exp $	*/
d110 1
d151 11
d301 9
@


1.31
log
@If we take the address of a function pointer, we might get a pointer to
a plabel instead of the entry-point address.  In that case, get the
entry-point address from the plabel.  Makes ld.so work on hppa when
_dl_bind_start gets hidden by the version script.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2015/08/27 04:10:35 guenther Exp $	*/
a312 1
	const Elf_Sym *this;
a316 22
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL );
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}

d409 4
a412 3
	if (object->got_size != 0)
		_dl_mprotect((void *)object->got_start, object->got_size,
		    GOT_PERMS|PROT_EXEC);
@


1.30
log
@Use kbind for lazy binding GOT/PLT updates on hppa.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2014/04/16 10:52:59 guenther Exp $	*/
d394 8
d403 1
a403 1
		 * seems we still need to syncronize the caches.
@


1.29
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2013/06/13 04:13:47 brad Exp $	*/
d37 4
a43 1
#include <signal.h>
d63 2
d439 1
a439 1
	Elf_Addr *addr, ooff;
d443 5
a447 1
	sigset_t savedmask;
a454 1
	addr = (Elf_Addr *)(object->obj_base + rela->r_offset);
d466 1
a466 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return ((uint64_t)value << 32) | (Elf_Addr)sobj->dyn.pltgot;
d468 2
a469 7
	/* if PLT+GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		/* mprotect the actual modified region, not the whole plt */
		_dl_mprotect((void*)addr, sizeof (Elf_Addr) * 2,
		    PROT_READ|PROT_WRITE|PROT_EXEC);
	}
d471 2
a472 2
	addr[0] = value;
	addr[1] = (Elf_Addr)sobj->dyn.pltgot;
d474 12
a485 6
	/* if PLT is (to be protected, change back to RO */
	if (object->got_size != 0) {
		/* mprotect the actual modified region, not the whole plt */
		_dl_mprotect((void*)addr, sizeof (Elf_Addr) * 3,
		    PROT_READ|PROT_EXEC);
		_dl_thread_bind_lock(1, &savedmask);
d488 1
a488 1
	return ((uint64_t)addr[0] << 32) | addr[1];
@


1.28
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2013/06/01 09:57:58 miod Exp $	*/
d373 6
a378 6
		__asm __volatile("fdc 0(%0)" :: "r" (&got[-7]));
		__asm __volatile("fdc 0(%0)" :: "r" (&got[-6]));
		__asm __volatile("sync");
		__asm __volatile("fic 0(%%sr0,%0)" :: "r" (&got[-7]));
		__asm __volatile("fic 0(%%sr0,%0)" :: "r" (&got[-6]));
		__asm __volatile("sync");
d394 6
a399 6
		__asm __volatile("fdc 0(%0)" :: "r" (&got[-2]));
		__asm __volatile("fdc 0(%0)" :: "r" (&got[-1]));
		__asm __volatile("sync");
		__asm __volatile("fic 0(%%sr0,%0)" :: "r" (&got[-2]));
		__asm __volatile("fic 0(%%sr0,%0)" :: "r" (&got[-1]));
		__asm __volatile("sync");
@


1.27
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2013/03/26 18:50:48 kettenis Exp $	*/
d452 1
a452 1
		*((int *)0) = 0;	/* XXX */
@


1.26
log
@Recommit the change that explicitly passes %sr0 to fic instructions.  miod@@ is
still puzzled why this didn't work back in 2010, but it does work now and
paves the way for binutils 2.17 on hppa.  Obviously based on miod@@'s earlier
diff.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2012/12/05 23:20:06 deraadt Exp $	*/
d45 1
d47 2
d335 3
d429 1
a429 1
Elf_Addr
d458 3
d480 1
a480 1
	return ((Elf_Addr)addr);
@


1.25
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2012/06/20 13:47:20 deraadt Exp $	*/
a369 1
#if 0
a371 4
#else
		__asm __volatile("fic 0(%0)" :: "r" (&got[-7]));
		__asm __volatile("fic 0(%0)" :: "r" (&got[-6]));
#endif
d391 2
a392 2
		__asm __volatile("fic 0(%0)" :: "r" (&got[-2]));
		__asm __volatile("fic 0(%0)" :: "r" (&got[-1]));
@


1.24
log
@With MP rthread setups, we cannot remove the X permission from the GOT
entry momentarily, because another thread might attempt lazy resolve.
ok matthew guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2011/04/06 11:36:25 miod Exp $	*/
a34 1
#include <sys/cdefs.h>
@


1.23
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2010/06/05 21:40:58 miod Exp $	*/
d463 1
a463 1
		    PROT_READ|PROT_WRITE);
@


1.22
log
@Argh, revert previous change, for older binutils do not grok the fic() change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2010/06/05 17:04:44 miod Exp $	*/
d311 1
a311 1
	object->got_addr = NULL;
d325 2
a326 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
@


1.21
log
@Explicitely pass a %sr register to fic instructions, instead of realying on
the assembler to pass %sr0 by default. No binary change.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2010/05/27 08:26:49 kettenis Exp $	*/
d371 1
d374 4
@


1.20
log
@Synchronize caches after modifying the data words in the PLT stub to prevent
instructions in the same cache line from being corrupted.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2010/05/02 12:03:24 kettenis Exp $	*/
d371 2
a372 2
		__asm __volatile("fic 0(%0)" :: "r" (&got[-7]));
		__asm __volatile("fic 0(%0)" :: "r" (&got[-6]));
@


1.19
log
@Fix breakage from last commit.  Bad guenther@@, no cookie!
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2010/05/02 04:57:01 guenther Exp $	*/
d383 12
@


1.18
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2010/01/03 22:18:04 kettenis Exp $	*/
d457 1
a457 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.17
log
@Make lazy binding work on hppa.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2008/11/09 12:34:47 tobias Exp $	*/
d421 1
a421 1
	sigset_t omask, nmask;
d443 1
a443 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
@


1.16
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2008/04/09 21:45:26 kurt Exp $	*/
d288 12
a310 2
	lazy = 0;	/* force busy binding */

d336 3
d343 40
d386 6
d393 3
a395 3
				r_addr[0] = 0;	/* TODO */
				r_addr[1] = (Elf_Addr) ((void *)rela -
				    (void *)object->dyn.jmprel);
d404 1
a404 1
		    GOT_PERMS);
d423 1
a423 1
	rela = (Elf_RelA *)(object->dyn.jmprel + reloff);
d437 1
d439 1
a439 1
	value = ooff + this->st_value;
d458 1
a458 1
		    PROT_READ);
d463 1
a463 1
	return (value);
@


1.15
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2007/11/27 16:42:19 miod Exp $	*/
d145 1
a145 1
	 * that are overriden in the user binary (that are un-pic)
@


1.14
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2007/05/05 15:21:21 drahn Exp $	*/
d104 1
a104 1
	loff = object->load_offs;
d220 1
a220 1
				*pt = _dl_md_plabel(sobj->load_offs +
d328 1
a328 1
		ooff = object->load_offs;
d370 1
a370 1
	addr = (Elf_Addr *)(object->load_offs + rela->r_offset);
@


1.13
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2006/05/03 16:10:52 drahn Exp $	*/
d288 1
a288 1
void
d293 1
a293 1
	int	i, numrela;
d297 1
a297 1
		return;
d324 1
a324 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d346 2
@


1.12
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2005/09/22 04:07:11 deraadt Exp $	*/
d383 1
d397 1
@


1.11
log
@knf; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2005/09/22 01:33:08 drahn Exp $	*/
d108 1
d111 1
d123 1
d127 1
d134 1
d138 1
d172 1
a172 1
			    ((type == RELOC_DIR32) ? SYM_NOTPLT : SYM_PLT),
d181 1
d184 1
d190 1
d194 1
d207 1
d210 1
d223 1
d227 1
d230 1
d233 1
d241 1
d245 1
d249 1
d252 1
d266 1
d271 1
@


1.10
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2005/09/21 23:12:10 drahn Exp $	*/
d161 1
a161 1
		this = 	NULL;
@


1.9
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2005/09/16 23:19:42 drahn Exp $	*/
d165 1
a165 1
			    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d168 3
a170 4
			if (!this) {
				_dl_printf("%s: %s: can't resolve reference '%s'\n",
				    _dl_progname, object->load_name, symn);
				fails++;
@


1.8
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2005/01/09 17:57:40 mickey Exp $	*/
d155 1
a155 1
		this = sym = object->dyn.symtab + ELF_R_SYM(rela->r_info);
d161 1
d167 1
a167 1
			    sym->st_size, &sobj);
d238 2
d241 1
a241 1
			ooff = _dl_find_symbol(symn, &sym,
d243 3
a245 3
			    size, object, NULL);
			if (sym) {
				_dl_bcopy((void *)(ooff + sym->st_value),
d248 1
a248 1
				    i, symn, ooff + sym->st_value,
d254 1
a254 1

d284 1
a284 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL );
d290 1
a290 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
d350 1
a350 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
	    object, &sobj);
@


1.7
log
@set %dp before any constructors get to run; found and debugged w/ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2004/06/07 15:19:59 mickey Exp $	*/
d163 2
a164 2
			    ELF_R_SYM(rela->r_info), _dl_objects,
			    &this, &sobj, SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|
d166 1
a166 1
			    sym->st_size);
d238 3
a240 3
			ooff = _dl_find_symbol(symn, object->next, &sym, NULL,
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    size, object);
d280 2
a281 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d286 2
a287 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d346 3
a348 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, &sobj,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
@


1.6
log
@use the func args and not the key material to init a new plabel
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2004/06/07 07:13:35 mickey Exp $	*/
d56 2
d135 8
@


1.5
log
@better debugging printfs for init/fini fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2004/06/01 21:07:46 mickey Exp $	*/
d86 2
a87 2
		p->pc = key.pc;
		p->sl = key.sl;
@


1.4
log
@need to fixup for empty pltgot (weak regress is a test for it)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2004/05/27 21:59:07 mickey Exp $	*/
d119 3
a121 2
		DL_DEB(("PLABEL32: %x(_init) -> 0x%x in %s\n",
		    object->dyn.init, addr, object->load_name));
d128 3
a130 2
		DL_DEB(("PLABEL32: %x(_fini) -> 0x%x in %s\n",
		    object->dyn.fini, addr, object->load_name));
@


1.3
log
@fake plabel32 relocs for dyn.init/fini instead of an evil md macro hook
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2004/05/25 21:56:49 deraadt Exp $	*/
d111 4
@


1.2
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2004/05/25 21:48:00 mickey Exp $	*/
d51 1
a51 1
	Elf_Addr	sl;
d75 1
a75 1
_dl_md_plabel(const elf_object_t *obj, const Elf_Sym *sym, const Elf_RelA *rela)
d79 2
a80 5
	if (ELF_ST_TYPE(sym->st_info) != STT_FUNC)
		return (0);

	key.pc = obj->load_offs + sym->st_value + rela->r_addend;
	key.sl = (Elf_Addr)obj->dyn.pltgot;
d112 16
d188 7
a194 1
				*pt = _dl_md_plabel(sobj, this, rela);
@


1.1
log
@md parts for hppa
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d293 1
a293 1
_dl_bind(elf_object_t *object, int reloff) 
@

