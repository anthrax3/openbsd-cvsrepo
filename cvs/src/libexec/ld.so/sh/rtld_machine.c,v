head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.20.0.12
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.8
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.25
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.24;
commitid	veGB6uLWx3BTEAfk;

1.24
date	2016.06.21.15.25.38;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	lRIiUPnkIQNjSTol;

1.23
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.22;
commitid	zGFWeGZdYJxUOZli;

1.22
date	2015.11.02.06.06.07;	author guenther;	state Exp;
branches;
next	1.21;
commitid	QI00fp028yyfkXPi;

1.21
date	2015.08.28.23.14.51;	author guenther;	state Exp;
branches;
next	1.20;
commitid	ZuUVMhkDkwe4LgRW;

1.20
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.29.22.57.07;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.26.18.53.47;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.24.23.42.26;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.27.17.27.58;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.24.15.47.47;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.07.18.50.02;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.06.21.39.58;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.03.00.55.34;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.11.23.04.50;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.10.22.02.33;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.10.21.19.54;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.10.07.44.58;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.25
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.24 2016/06/21 15:25:38 deraadt Exp $ */

/*
 * Copyright (c) 2004 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER
#define LDSO_ARCH_IS_RELA_

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

void _dl_bind_start(void); /* XXX */
Elf_Addr _dl_bind(elf_object_t *object, int reloff);
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_U		0x04000000		/* Unaligned */
#define _RF_E		0x02000000		/* ERROR */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,						/* 0	R_SH_NONE */
	_RF_S|_RF_A|            _RF_SZ(32) | _RF_RS(0), /* 1	R_SH_DIR32 */
	_RF_S|_RF_P|_RF_A|      _RF_SZ(32) | _RF_RS(0), /* 2  REL32 */
	_RF_E,						/* 3	R_SH_DIR8WPN */
	_RF_E,						/* 4	R_SH_IND12W */
	_RF_E,						/* 5	R_SH_DIR8WPL */
	_RF_E,						/* 6	R_SH_DIR8WPZ */
	_RF_E,						/* 7	R_SH_DIR8BP */
	_RF_E,						/* 8	R_SH_DIR8W */
	_RF_E,						/* 9	R_SH_DIR8L */
	_RF_E,						/* 10	R_SH_LOOP_START */
	_RF_E,						/* 11	R_SH_LOOP_END */
	_RF_E,						/* 12	Unused */
	_RF_E,						/* 13	Unused */
	_RF_E,						/* 14	Unused */
	_RF_E,						/* 15	Unused */
	_RF_E,						/* 16	Unused */
	_RF_E,						/* 17	Unused */
	_RF_E,						/* 18	Unused */
	_RF_E,						/* 19	Unused */
	_RF_E,						/* 20	Unused */
	_RF_E,						/* 21	Unused */
	_RF_E,						/* 22	R_SH_GNU_VTINHERIT */
	_RF_E,						/* 23	R_SH_GNU_VTENTRY */
	_RF_E,						/* 24	R_SH_SWITCH8 */
	_RF_E,						/* 25	R_SH_SWITCH16 */
	_RF_E,						/* 26	R_SH_SWITCH32 */
	_RF_E,						/* 27	R_SH_USES */
	_RF_E,						/* 28	R_SH_COUNT */
	_RF_E,						/* 29	R_SH_ALIGN */
	_RF_E,						/* 30	R_SH_CODE */
	_RF_E,						/* 31	R_SH_DATA */
	_RF_E,						/* 32	R_SH_LABEL */
	_RF_E,						/* 33	R_SH_DIR16 */
	_RF_E,						/* 34	R_SH_DIR8 */
	_RF_E,						/* 35	R_SH_DIR8UL */
	_RF_E,						/* 36	R_SH_DIR8UW */
	_RF_E,						/* 37	R_SH_DIR8U */
	_RF_E,						/* 38	R_SH_DIR8SW */
	_RF_E,						/* 39	R_SH_DIR8S */
	_RF_E,						/* 40	R_SH_DIR4UL */
	_RF_E,						/* 41	R_SH_DIR4UW */
	_RF_E,						/* 42	R_SH_DIR4U */
	_RF_E,						/* 43	R_SH_PSHA */
	_RF_E,						/* 44	R_SH_PSHL */
	_RF_E,						/* 45	R_SH_DIR5U */
	_RF_E,						/* 46	R_SH_DIR6U */
	_RF_E,						/* 47	R_SH_DIR6S */
	_RF_E,						/* 48	R_SH_DIR10S */
	_RF_E,						/* 49	R_SH_DIR10SW */
	_RF_E,						/* 50	R_SH_DIR10SL */
	_RF_E,						/* 51	R_SH_DIR10SQ */
	_RF_E,						/* 52	XXXX */
	_RF_E,						/* 53	R_SH_DIR16S */
	_RF_E,						/* 54	Unused */
	_RF_E,						/* 55	Unused */
	_RF_E,						/* 56	Unused */
	_RF_E,						/* 57	Unused */
	_RF_E,						/* 58	Unused */
	_RF_E,						/* 59	Unused */
	_RF_E,						/* 60	Unused */
	_RF_E,						/* 61	Unused */
	_RF_E,						/* 62	Unused */
	_RF_E,						/* 63	Unused */
	_RF_E,						/* 64	Unused */
	_RF_E,						/* 65	Unused */
	_RF_E,						/* 66	Unused */
	_RF_E,						/* 67	Unused */
	_RF_E,						/* 68	Unused */
	_RF_E,						/* 69	Unused */
	_RF_E,						/* 70	Unused */
	_RF_E,						/* 71	Unused */
	_RF_E,						/* 72	Unused */
	_RF_E,						/* 73	Unused */
	_RF_E,						/* 74	Unused */
	_RF_E,						/* 75	Unused */
	_RF_E,						/* 76	Unused */
	_RF_E,						/* 77	Unused */
	_RF_E,						/* 78	Unused */
	_RF_E,						/* 79	Unused */
	_RF_E,						/* 80	Unused */
	_RF_E,						/* 81	Unused */
	_RF_E,						/* 82	Unused */
	_RF_E,						/* 83	Unused */
	_RF_E,						/* 84	Unused */
	_RF_E,						/* 85	Unused */
	_RF_E,						/* 86	Unused */
	_RF_E,						/* 87	Unused */
	_RF_E,						/* 88	Unused */
	_RF_E,						/* 89	Unused */
	_RF_E,						/* 90	Unused */
	_RF_E,						/* 91	Unused */
	_RF_E,						/* 92	Unused */
	_RF_E,						/* 93	Unused */
	_RF_E,						/* 94	Unused */
	_RF_E,						/* 95	Unused */
	_RF_E,						/* 96	Unused */
	_RF_E,						/* 97	Unused */
	_RF_E,						/* 98	Unused */
	_RF_E,						/* 99	Unused */
	_RF_E,						/* 100	Unused */
	_RF_E,						/* 101	Unused */
	_RF_E,						/* 102	Unused */
	_RF_E,						/* 103	Unused */
	_RF_E,						/* 104	Unused */
	_RF_E,						/* 105	Unused */
	_RF_E,						/* 106	Unused */
	_RF_E,						/* 107	Unused */
	_RF_E,						/* 108	Unused */
	_RF_E,						/* 109	Unused */
	_RF_E,						/* 110	Unused */
	_RF_E,						/* 111	Unused */
	_RF_E,						/* 112	Unused */
	_RF_E,						/* 113	Unused */
	_RF_E,						/* 114	Unused */
	_RF_E,						/* 115	Unused */
	_RF_E,						/* 116	Unused */
	_RF_E,						/* 117	Unused */
	_RF_E,						/* 118	Unused */
	_RF_E,						/* 119	Unused */
	_RF_E,						/* 120	Unused */
	_RF_E,						/* 121	Unused */
	_RF_E,						/* 122	Unused */
	_RF_E,						/* 123	Unused */
	_RF_E,						/* 124	Unused */
	_RF_E,						/* 125	Unused */
	_RF_E,						/* 126	Unused */
	_RF_E,						/* 127	Unused */
	_RF_E,						/* 128	Unused */
	_RF_E,						/* 129	Unused */
	_RF_E,						/* 130	Unused */
	_RF_E,						/* 131	Unused */
	_RF_E,						/* 132	Unused */
	_RF_E,						/* 133	Unused */
	_RF_E,						/* 134	Unused */
	_RF_E,						/* 135	Unused */
	_RF_E,						/* 136	Unused */
	_RF_E,						/* 137	Unused */
	_RF_E,						/* 138	Unused */
	_RF_E,						/* 139	Unused */
	_RF_E,						/* 140	Unused */
	_RF_E,						/* 141	Unused */
	_RF_E,						/* 142	Unused */
	_RF_E,						/* 143	Unused */
	_RF_E,						/* 144	R_SH_TLS_GD_32 */
	_RF_E,						/* 145	R_SH_TLS_LD_32 */
	_RF_E,						/* 146	R_SH_TLS_LDO_32 */
	_RF_E,						/* 147	R_SH_TLS_IE_32 */
	_RF_E,						/* 148	R_SH_TLS_LE_32 */
	_RF_E,						/* 149	R_SH_TLS_DTPMOD32 */
	_RF_E,						/* 150	R_SH_TLS_DTPOFF32 */
	_RF_E,						/* 151	R_SH_TLS_TPOFF32 */
	_RF_E,						/* 152 Unused */
	_RF_E,						/* 153 Unused */
	_RF_E,						/* 154 Unused */
	_RF_E,						/* 155 Unused */
	_RF_E,						/* 156 Unused */
	_RF_E,						/* 157 Unused */
	_RF_E,						/* 158 Unused */
	_RF_E,						/* 159 Unused */
	_RF_E,						/* 160	R_SH_GOT32 */
	_RF_E,						/* 161	R_SH_PLT32 */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 162	COPY */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),	/* 163	GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 164	JMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(32) | _RF_RS(0),	/* 165 RELATIVE */
	_RF_E,						/* 166	R_SH_GOTOFF */
	_RF_E,						/* 167	R_SH_GOTPC */
	_RF_E,						/* 168	R_SH_GOTPLT32 */
	_RF_E,						/* 169	R_SH_GOT_LOW16 */
	_RF_E,						/* 170	R_SH_GOT_MEDLOW16 */
	_RF_E,						/* 171	R_SH_GOT_MEDHI16 */
	_RF_E,						/* 172	R_SH_GOT_HI16 */
	_RF_E,						/* 173	R_SH_GOTPLT_LOW16 */
	_RF_E,						/* 174	R_SH_GOTPLT_MEDLOW16 */
	_RF_E,						/* 175	R_SH_GOTPLT_MEDHI16 */
	_RF_E,						/* 176	R_SH_GOTPLT_HI16 */
	_RF_E,						/* 177	R_SH_PLT_LOW16 */
	_RF_E,						/* 178	R_SH_PLT_MEDLOW16 */
	_RF_E,						/* 179	R_SH_PLT_MEDHI16 */
	_RF_E,						/* 180	R_SH_PLT_HI16 */
	_RF_E,						/* 181	R_SH_GOTOFF_LOW16 */
	_RF_E,						/* 182	R_SH_GOTOFF_MEDLOW16 */
	_RF_E,						/* 183	R_SH_GOTOFF_MEDHI16 */
	_RF_E,						/* 184	R_SH_GOTOFF_HI16 */
	_RF_E,						/* 185	R_SH_GOTPC_LOW16 */
	_RF_E,						/* 186	R_SH_GOTPC_MEDLOW16 */
	_RF_E,						/* 187	R_SH_GOTPC_MEDHI16 */
	_RF_E,						/* 188	R_SH_GOTPC_HI16 */
	_RF_E,						/* 189	R_SH_GOT10BY4 */
	_RF_E,						/* 190	R_SH_GOTPLT10BY4 */
	_RF_E,						/* 191	R_SH_GOT10BY8 */
	_RF_E,						/* 192	R_SH_GOTPLT10BY8 */
#ifdef SH_SUPPORT_64_BIT
	_RF_E,						/* 193	R_SH_COPY64 */
	_RF_E,						/* 194	R_SH_GLOB_DAT64 */
	_RF_E,						/* 195	R_SH_JMP_SLOT64 */
	_RF_E,						/* 196	R_SH_RELATIVE64 */
	_RF_E,						/* 197	Unused */
	_RF_E,						/* 198	Unused */
	_RF_E,						/* 199	Unused */
	_RF_E,						/* 200	Unused */
	_RF_E,						/* 201	Unused */
	_RF_E,						/* 202	Unused */
	_RF_E,						/* 203	Unused */
	_RF_E,						/* 204	Unused */
	_RF_E,						/* 205	Unused */
	_RF_E,						/* 206	Unused */
	_RF_E,						/* 207	Unused */
	_RF_E,						/* 208	Unused */
	_RF_E,						/* 209	Unused */
	_RF_E,						/* 210	Unused */
	_RF_E,						/* 211	Unused */
	_RF_E,						/* 212	Unused */
	_RF_E,						/* 213	Unused */
	_RF_E,						/* 214	Unused */
	_RF_E,						/* 215	Unused */
	_RF_E,						/* 216	Unused */
	_RF_E,						/* 217	Unused */
	_RF_E,						/* 218	Unused */
	_RF_E,						/* 219	Unused */
	_RF_E,						/* 220	Unused */
	_RF_E,						/* 221	Unused */
	_RF_E,						/* 222	Unused */
	_RF_E,						/* 223	Unused */
	_RF_E,						/* 224	Unused */
	_RF_E,						/* 225	Unused */
	_RF_E,						/* 226	Unused */
	_RF_E,						/* 227	Unused */
	_RF_E,						/* 228	Unused */
	_RF_E,						/* 229	Unused */
	_RF_E,						/* 230	Unused */
	_RF_E,						/* 231	Unused */
	_RF_E,						/* 232	Unused */
	_RF_E,						/* 233	Unused */
	_RF_E,						/* 234	Unused */
	_RF_E,						/* 235	Unused */
	_RF_E,						/* 236	Unused */
	_RF_E,						/* 237	Unused */
	_RF_E,						/* 238	Unused */
	_RF_E,						/* 239	Unused */
	_RF_E,						/* 240	Unused */
	_RF_E,						/* 241	Unused */
	_RF_E,						/* 242	R_SH_SHMEDIA_CODE */
	_RF_E,						/* 243	R_SH_PT_16 */
	_RF_E,						/* 244	R_SH_IMMS16 */
	_RF_E,						/* 245	R_SH_IMMU16 */
	_RF_E,						/* 246	R_SH_IMM_LOW16 */
	_RF_E,						/* 247	R_SH_IMM_LOW16_PCREL */
	_RF_E,						/* 248	R_SH_IMM_MEDLOW16 */
	_RF_E,						/* 249	R_SH_IMM_MEDLOW16_PCREL */
	_RF_E,						/* 250	R_SH_IMM_MEDHI16 */
	_RF_E,						/* 251	R_SH_IMM_MEDHI16_PCREL */
	_RF_E,						/* 252	R_SH_IMM_HI16 */
	_RF_E,						/* 253	R_SH_IMM_HI16_PCREL */
	_RF_E,						/* 254	R_SH_64 */
	_RF_E,						/* 255	R_SH_64_PCREL */
	0
#endif
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
#define RELOC_UNALIGNED(t)		((reloc_target_flags[t] & _RF_U) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)
static int reloc_target_bitmask[] = {
#define _BM(x)  (x == 32? ~0 : ~(-(1UL << (x))))
	_BM(0),		/* 0	R_SH_NONE */
	_BM(32),	/* 1	R_SH_DIR32 */
	_BM(32),	/* 2	R_SH_REL32 */
	_BM(8),		/* 3	R_SH_DIR8WPN */
	_BM(12),	/* 4	R_SH_IND12W */
	_BM(8),		/* 5	R_SH_DIR8WPL */
	_BM(8),		/* 6	R_SH_DIR8WPZ */
	_BM(8),		/* 7	R_SH_DIR8BP */
	_BM(8),		/* 8	R_SH_DIR8W */
	_BM(8),		/* 9	R_SH_DIR8L */
	_BM(0),		/* 10	R_SH_LOOP_START */
	_BM(0),		/* 11	R_SH_LOOP_END */
	_BM(0),		/* 12	Unused */
	_BM(0),		/* 13	Unused */
	_BM(0),		/* 14	Unused */
	_BM(0),		/* 15	Unused */
	_BM(0),		/* 16	Unused */
	_BM(0),		/* 17	Unused */
	_BM(0),		/* 18	Unused */
	_BM(0),		/* 19	Unused */
	_BM(0),		/* 20	Unused */
	_BM(0),		/* 21	Unused */
	_BM(0),		/* 22	R_SH_GNU_VTINHERIT */
	_BM(0),		/* 23	R_SH_GNU_VTENTRY */
	_BM(0),		/* 24	R_SH_SWITCH8 */
	_BM(0),		/* 25	R_SH_SWITCH16 */
	_BM(0),		/* 26	R_SH_SWITCH32 */
	_BM(0),		/* 27	R_SH_USES */
	_BM(0),		/* 28	R_SH_COUNT */
	_BM(0),		/* 29	R_SH_ALIGN */
	_BM(0),		/* 30	R_SH_CODE */
	_BM(0),		/* 31	R_SH_DATA */
	_BM(0),		/* 32	R_SH_LABEL */
	_BM(0),		/* 33	R_SH_DIR16 */
	_BM(0),		/* 34	R_SH_DIR8 */
	_BM(0),		/* 35	R_SH_DIR8UL */
	_BM(0),		/* 36	R_SH_DIR8UW */
	_BM(0),		/* 37	R_SH_DIR8U */
	_BM(0),		/* 38	R_SH_DIR8SW */
	_BM(0),		/* 39	R_SH_DIR8S */
	_BM(0),		/* 40	R_SH_DIR4UL */
	_BM(0),		/* 41	R_SH_DIR4UW */
	_BM(0),		/* 42	R_SH_DIR4U */
	_BM(0),		/* 43	R_SH_PSHA */
	_BM(0),		/* 44	R_SH_PSHL */
	_BM(0),		/* 45	R_SH_DIR5U */
	_BM(0),		/* 46	R_SH_DIR6U */
	_BM(0),		/* 47	R_SH_DIR6S */
	_BM(0),		/* 48	R_SH_DIR10S */
	_BM(0),		/* 49	R_SH_DIR10SW */
	_BM(0),		/* 50	R_SH_DIR10SL */
	_BM(0),		/* 51	R_SH_DIR10SQ */
	_BM(0),		/* 52	xxx */
	_BM(0),		/* 53	R_SH_DIR16S */
	_BM(0),		/* 54	Unused */
	_BM(0),		/* 55	Unused */
	_BM(0),		/* 56	Unused */
	_BM(0),		/* 57	Unused */
	_BM(0),		/* 58	Unused */
	_BM(0),		/* 59	Unused */
	_BM(0),		/* 60	Unused */
	_BM(0),		/* 61	Unused */
	_BM(0),		/* 62	Unused */
	_BM(0),		/* 63	Unused */
	_BM(0),		/* 64	Unused */
	_BM(0),		/* 65	Unused */
	_BM(0),		/* 66	Unused */
	_BM(0),		/* 67	Unused */
	_BM(0),		/* 68	Unused */
	_BM(0),		/* 69	Unused */
	_BM(0),		/* 70	Unused */
	_BM(0),		/* 71	Unused */
	_BM(0),		/* 72	Unused */
	_BM(0),		/* 73	Unused */
	_BM(0),		/* 74	Unused */
	_BM(0),		/* 75	Unused */
	_BM(0),		/* 76	Unused */
	_BM(0),		/* 77	Unused */
	_BM(0),		/* 78	Unused */
	_BM(0),		/* 79	Unused */
	_BM(0),		/* 80	Unused */
	_BM(0),		/* 81	Unused */
	_BM(0),		/* 82	Unused */
	_BM(0),		/* 83	Unused */
	_BM(0),		/* 84	Unused */
	_BM(0),		/* 85	Unused */
	_BM(0),		/* 86	Unused */
	_BM(0),		/* 87	Unused */
	_BM(0),		/* 88	Unused */
	_BM(0),		/* 89	Unused */
	_BM(0),		/* 90	Unused */
	_BM(0),		/* 91	Unused */
	_BM(0),		/* 92	Unused */
	_BM(0),		/* 93	Unused */
	_BM(0),		/* 94	Unused */
	_BM(0),		/* 95	Unused */
	_BM(0),		/* 96	Unused */
	_BM(0),		/* 97	Unused */
	_BM(0),		/* 98	Unused */
	_BM(0),		/* 99	Unused */
	_BM(0),		/* 100	Unused */
	_BM(0),		/* 101	Unused */
	_BM(0),		/* 102	Unused */
	_BM(0),		/* 103	Unused */
	_BM(0),		/* 104	Unused */
	_BM(0),		/* 105	Unused */
	_BM(0),		/* 106	Unused */
	_BM(0),		/* 107	Unused */
	_BM(0),		/* 108	Unused */
	_BM(0),		/* 109	Unused */
	_BM(0),		/* 110	Unused */
	_BM(0),		/* 111	Unused */
	_BM(0),		/* 112	Unused */
	_BM(0),		/* 113	Unused */
	_BM(0),		/* 114	Unused */
	_BM(0),		/* 115	Unused */
	_BM(0),		/* 116	Unused */
	_BM(0),		/* 117	Unused */
	_BM(0),		/* 118	Unused */
	_BM(0),		/* 119	Unused */
	_BM(0),		/* 120	Unused */
	_BM(0),		/* 121	Unused */
	_BM(0),		/* 122	Unused */
	_BM(0),		/* 123	Unused */
	_BM(0),		/* 124	Unused */
	_BM(0),		/* 125	Unused */
	_BM(0),		/* 126	Unused */
	_BM(0),		/* 127	Unused */
	_BM(0),		/* 128	Unused */
	_BM(0),		/* 129	Unused */
	_BM(0),		/* 130	Unused */
	_BM(0),		/* 131	Unused */
	_BM(0),		/* 132	Unused */
	_BM(0),		/* 133	Unused */
	_BM(0),		/* 134	Unused */
	_BM(0),		/* 135	Unused */
	_BM(0),		/* 136	Unused */
	_BM(0),		/* 137	Unused */
	_BM(0),		/* 138	Unused */
	_BM(0),		/* 139	Unused */
	_BM(0),		/* 140	Unused */
	_BM(0),		/* 141	Unused */
	_BM(0),		/* 142	Unused */
	_BM(0),		/* 143	Unused */
	_BM(0),		/* 144	R_SH_TLS_GD_32 */
	_BM(0),		/* 145	R_SH_TLS_LD_32 */
	_BM(0),		/* 146	R_SH_TLS_LDO_32 */
	_BM(0),		/* 147	R_SH_TLS_IE_32 */
	_BM(0),		/* 148	R_SH_TLS_LE_32 */
	_BM(0),		/* 149	R_SH_TLS_DTPMOD32 */
	_BM(0),		/* 150	R_SH_TLS_DTPOFF32 */
	_BM(0),		/* 151	R_SH_TLS_TPOFF32 */
	_BM(0),		/* 152  xxx */
	_BM(0),		/* 153  xxx */
	_BM(0),		/* 154  xxx */
	_BM(0),		/* 155  xxx */
	_BM(0),		/* 156  xxx */
	_BM(0),		/* 157  xxx */
	_BM(0),		/* 158  xxx */
	_BM(0),		/* 159  xxx */
	_BM(0),		/* 160	R_SH_GOT32 */
	_BM(0),		/* 161	R_SH_PLT32 */
	_BM(0),		/* 162	R_SH_COPY */
	_BM(32),	/* 163	R_SH_GLOB_DAT */
	_BM(0),		/* 164	R_SH_JMP_SLOT */
	_BM(32),	/* 165	R_SH_RELATIVE */
	_BM(0),		/* 166	R_SH_GOTOFF */
	_BM(0),		/* 167	R_SH_GOTPC */
	_BM(0),		/* 168	R_SH_GOTPLT32 */
	_BM(0),		/* 169	R_SH_GOT_LOW16 */
	_BM(0),		/* 170	R_SH_GOT_MEDLOW16 */
	_BM(0),		/* 171	R_SH_GOT_MEDHI16 */
	_BM(0),		/* 172	R_SH_GOT_HI16 */
	_BM(0),		/* 173	R_SH_GOTPLT_LOW16 */
	_BM(0),		/* 174	R_SH_GOTPLT_MEDLOW16 */
	_BM(0),		/* 175	R_SH_GOTPLT_MEDHI16 */
	_BM(0),		/* 176	R_SH_GOTPLT_HI16 */
	_BM(0),		/* 177	R_SH_PLT_LOW16 */
	_BM(0),		/* 178	R_SH_PLT_MEDLOW16 */
	_BM(0),		/* 179	R_SH_PLT_MEDHI16 */
	_BM(0),		/* 180	R_SH_PLT_HI16 */
	_BM(0),		/* 181	R_SH_GOTOFF_LOW16 */
	_BM(0),		/* 182	R_SH_GOTOFF_MEDLOW16 */
	_BM(0),		/* 183	R_SH_GOTOFF_MEDHI16 */
	_BM(0),		/* 184	R_SH_GOTOFF_HI16 */
	_BM(0),		/* 185	R_SH_GOTPC_LOW16 */
	_BM(0),		/* 186	R_SH_GOTPC_MEDLOW16 */
	_BM(0),		/* 187	R_SH_GOTPC_MEDHI16 */
	_BM(0),		/* 188	R_SH_GOTPC_HI16 */
	_BM(0),		/* 189	R_SH_GOT10BY4 */
	_BM(0),		/* 190	R_SH_GOTPLT10BY4 */
	_BM(0),		/* 191	R_SH_GOT10BY8 */
	_BM(0),		/* 192	R_SH_GOTPLT10BY8 */
#ifdef SH_SUPPORT_64_BIT
	_BM(0),		/* 193	R_SH_COPY64 */
	_BM(0),		/* 194	R_SH_GLOB_DAT64 */
	_BM(0),		/* 195	R_SH_JMP_SLOT64 */
	_BM(0),		/* 196	R_SH_RELATIVE64 */
	_BM(0),		/* 197 xxx */
	_BM(0),		/* 198 xxx */
	_BM(0),		/* 199 xxx */
	_BM(0),		/* 200 xxx */
	_BM(0),		/* 201 xxx */
	_BM(0),		/* 202 xxx */
	_BM(0),		/* 203 xxx */
	_BM(0),		/* 204 xxx */
	_BM(0),		/* 205 xxx */
	_BM(0),		/* 206 xxx */
	_BM(0),		/* 207 xxx */
	_BM(0),		/* 208 xxx */
	_BM(0),		/* 209 xxx */
	_BM(0),		/* 210 xxx */
	_BM(0),		/* 211 xxx */
	_BM(0),		/* 212 xxx */
	_BM(0),		/* 213 xxx */
	_BM(0),		/* 214 xxx */
	_BM(0),		/* 215 xxx */
	_BM(0),		/* 216 xxx */
	_BM(0),		/* 217 xxx */
	_BM(0),		/* 218 xxx */
	_BM(0),		/* 219 xxx */
	_BM(0),		/* 220 xxx */
	_BM(0),		/* 221 xxx */
	_BM(0),		/* 222 xxx */
	_BM(0),		/* 223 xxx */
	_BM(0),		/* 224 xxx */
	_BM(0),		/* 225 xxx */
	_BM(0),		/* 226 xxx */
	_BM(0),		/* 227 xxx */
	_BM(0),		/* 228 xxx */
	_BM(0),		/* 229  xxx */
	_BM(0),		/* 230 xxx */
	_BM(0),		/* 231 xxx */
	_BM(0),		/* 232 xxx */
	_BM(0),		/* 233 xxx */
	_BM(0),		/* 234 xxx */
	_BM(0),		/* 235 xxx */
	_BM(0),		/* 236 xxx */
	_BM(0),		/* 237 xxx */
	_BM(0),		/* 238 xxx */
	_BM(0),		/* 239 xxx */
	_BM(0),		/* 240 xxx */
	_BM(0),		/* 241 xxx */
	_BM(0),		/* 242	R_SH_SHMEDIA_CODE */
	_BM(0),		/* 243	R_SH_PT_16 */
	_BM(0),		/* 244	R_SH_IMMS16 */
	_BM(0),		/* 245	R_SH_IMMU16 */
	_BM(0),		/* 246	R_SH_IMM_LOW16 */
	_BM(0),		/* 247	R_SH_IMM_LOW16_PCREL */
	_BM(0),		/* 248	R_SH_IMM_MEDLOW16 */
	_BM(0),		/* 249	R_SH_IMM_MEDLOW16_PCREL */
	_BM(0),		/* 250	R_SH_IMM_MEDHI16 */
	_BM(0),		/* 251	R_SH_IMM_MEDHI16_PCREL */
	_BM(0),		/* 252	R_SH_IMM_HI16 */
	_BM(0),		/* 253	R_SH_IMM_HI16_PCREL */
	_BM(0),		/* 254	R_SH_64 */
	_BM(0),		/* 255	R_SH_64_PCREL */
#endif
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

#define R_TYPE(x) R_SH_ ## x

void _dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_RelA *rel);

void
_dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_RelA *rel)
{
	*where = value + rel->r_addend;
}

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	long	i;
	long	numrela;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_RelA *rels;
	struct load_list *llist;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf_RelA);
	relrel = rel == DT_RELA ? object->relacount : 0;
	rels = (Elf_RelA *)(object->Dyn.info[rel]);

	if (rels == NULL)
		return(0);

	if (relrel > numrela)
		_dl_die("relacount > numrel: %ld > %ld", relrel, numrela);

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list;
		    llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, rels++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELACOUNT wrong");
#endif
		where = (Elf_Addr *)(rels->r_offset + loff);
		*where = rels->r_addend + loff;
	}
	for (; i < numrela; i++, rels++) {
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(rels->r_info);

		if (reloc_target_flags[type] & _RF_E)
			_dl_die("bad relocation obj %s %ld %d",
			    object->load_name, i, type);

		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JMP_SLOT) && rel != DT_JMPREL)
			continue;

		where = (Elf_Addr *)(rels->r_offset + loff);

		if (RELOC_USE_ADDEND(type))
#ifdef LDSO_ARCH_IS_RELA_
			value = rels->r_addend;
#else
			value = *where & RELOC_VALUE_BITMASK(type);
#endif
		else
			value = 0;


		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(rels->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
#if 1
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JMP_SLOT)) ?
					SYM_PLT : SYM_NOTPLT),
				    sym, NULL);
#else
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    SYM_PLT,
				    sym, NULL);
#endif
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(JMP_SLOT)) {
			_dl_reloc_plt((Elf_Word *)where, value, rels);
			continue;
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    dstsym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, dstsym->st_size);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;
		if (RELOC_BASE_RELATIVE(type))
			value += loff;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		if (RELOC_UNALIGNED(type)) {
			/* Handle unaligned relocations. */
			Elf_Addr tmp = 0;
			char *ptr = (char *)where;
			int i, size = RELOC_TARGET_SIZE(type)/8;

			/* Read it in one byte at a time. */
			for (i=0; i<size; i++)
				tmp = (tmp << 8) | ptr[i];

			tmp &= ~mask;
			tmp |= value;

			/* Write it back out. */
			for (i=0; i<size; i++)
				ptr[i] = ((tmp >> (8*i)) & 0xff);
		} else {
			*where &= ~mask;
			*where |= value;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list;
		    llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

/*
 *	Relocate the Global Offset Table (GOT).
 *	This is done by calling _dl_md_reloc on DT_JMPREL for DL_BIND_NOW,
 *	otherwise the lazy binding plt initialization is performed.
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	int i, num;
	Elf_RelA *rel;

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	if (object->traced)
		lazy = 1;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);
		num = (object->Dyn.info[DT_PLTRELSZ]) / sizeof(Elf_RelA);

		for (i = 0; i < num; i++, rel++) {
			Elf_Addr *where, value;
			Elf_Word type;

			where = (Elf_Addr *)(rel->r_offset + object->obj_base);
			type = ELF_R_TYPE(rel->r_info);
			if (RELOC_USE_ADDEND(type))
				value = rel->r_addend;
			else
				value = 0;
			*where += object->obj_base + value;
		}

		pltgot[1] = (Elf_Addr)object;
		pltgot[2] = (Elf_Addr)_dl_bind_start;
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	return (fails);
}

Elf_Addr
_dl_bind(elf_object_t *object, int reloff)
{
	Elf_RelA *rel;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr ooff;
	uint64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;

	rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rel->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn,  &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("r0") = SYS_kbind;
		register void *arg1 __asm("r4") = &buf;
		register long  arg2 __asm("r5") = sizeof(buf);
		register long  arg3 __asm("r6") = 0xffffffff &  cookie;
		register long  arg4 __asm("r7") = 0xffffffff & (cookie >> 32);

                __asm volatile("trapa #0x80" : "+r" (syscall_num)
		    : "r" (arg1), "r" (arg2), "r" (arg3), "r" (arg4)
		    : "r1", "cc", "memory");
	}

	return (buf.newval);
}
@


1.24
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2015/11/02 07:02:53 guenther Exp $ */
d621 2
a622 4
	if (relrel > numrela) {
		_dl_printf("relacount > numrel: %ld > %ld\n", relrel, numrela);
		_dl_exit(20);
	}
d642 2
a643 4
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELACOUNT wrong\n");
			_dl_exit(20);
		}
d656 4
a659 4
		if (reloc_target_flags[type] & _RF_E) {
			_dl_printf(" bad relocation obj %s %d %d\n", object->load_name, i, type);
			_dl_exit(1);
		}
d857 2
a858 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.23
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2015/11/02 06:06:07 guenther Exp $ */
d635 1
a635 1
				    llist->prot|PROT_WRITE);
@


1.22
log
@Fix typo: s/DT_JUMPREL/DT_JMPREL/
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2015/08/28 23:14:51 guenther Exp $ */
a799 2
	Elf_Addr ooff;
	const Elf_Sym *this;
a805 24
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}
	object->plt_start = 0;
	object->plt_size = 0;

d831 3
a833 3
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
@


1.21
log
@Use kbind for lazy binding GOT/PLT updates on sh (i.e. landisk)

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2013/06/13 04:13:47 brad Exp $ */
d792 1
a792 1
 *	This is done by calling _dl_md_reloc on DT_JUMPREL for DL_BIND_NOW,
@


1.20
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2013/06/01 09:57:58 miod Exp $ */
d34 2
a38 1
#include <signal.h>
d44 2
a867 1
	Elf_Word *addr;
d871 6
a876 2
	Elf_Addr ooff, newval;
	sigset_t savedmask;
d892 1
a892 1
	newval = ooff + this->st_value;
d894 2
a895 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return newval;
d897 2
a898 1
	addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
d900 11
a910 5
	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ|PROT_WRITE);
d913 1
a913 10
	if (*addr != newval)
		*addr = newval;

	/* put the GOT back to RO */
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
	}
	return newval;
@


1.19
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2013/05/08 20:55:14 guenther Exp $ */
d883 1
a883 1
		*((int *)0) = 0;	/* XXX */
@


1.18
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2013/03/29 22:57:07 miod Exp $ */
d829 3
d868 1
d880 1
a880 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d886 5
a891 1
	newval = ooff + this->st_value;
@


1.17
log
@Enable lazy binding by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2013/03/26 18:53:47 miod Exp $ */
d602 1
d605 2
d612 1
d618 5
d636 14
a649 1
	for (i = 0; i < numrela; i++, rels++) {
d689 2
d714 3
a716 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.16
log
@SH is a RelA architecture, not a Rel one. Fix _dl_bind() and lazy gotplt
relocation to correctly process RelA entries.
This allows lazy binding to work so far; not enabled yet, must survive some
serious churning first.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2011/04/06 11:36:25 miod Exp $ */
a774 3

	/* XXX - lazy binding not supported yet */
	lazy = 0;
@


1.15
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2010/05/02 04:57:01 guenther Exp $ */
d774 1
a774 1
	Elf_Rel *rel;
a795 2
	object->plt_size = 0;	/* Text PLT on ARM */

d804 1
d809 6
a814 2
		rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);
		num = (object->Dyn.info[DT_PLTRELSZ]);
a815 2
		for (i = 0; i < num/sizeof(Elf_Rel); i++, rel++) {
			Elf_Addr *where;
d817 6
a822 1
			*where += object->obj_base;
a830 3
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
d836 1
a836 1
_dl_bind(elf_object_t *object, int relidx)
d838 1
a838 1
	Elf_Rel *rel;
d845 1
a845 1
	rel = ((Elf_Rel *)object->Dyn.info[DT_JMPREL]) + (relidx);
@


1.14
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2008/07/24 23:42:26 guenther Exp $ */
d782 1
a782 1
	object->got_addr = NULL;
d798 2
a799 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
d805 1
a805 1
	object->plt_start = NULL;
@


1.13
log
@release the bind lock before resetting the signal mask

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2008/06/27 17:27:58 miod Exp $ */
d840 1
a840 1
	sigset_t omask, nmask;
d862 1
a862 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d874 1
a874 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.12
log
@Remove again the old _dl_md_reloc() calls-through-plt workaround: it is
no longer necessary now that libgcc is built correctly, and it caused
the elfbug regress test to fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2008/04/09 21:45:26 kurt Exp $ */
d876 1
a877 1
		_dl_thread_bind_lock(1);
@


1.11
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2008/02/24 15:47:47 drahn Exp $ */
d669 1
a669 1
#if 0
@


1.10
log
@Use rounded down address when changing memory protections on the GOT, such
that we don't accidentally touch the page after the GOT.

Bug found on sparc64 affected other platforms as well.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2007/11/27 16:42:19 miod Exp $ */
d607 1
a607 1
	loff = object->load_offs;
d815 2
a816 2
			where = (Elf_Addr *)(rel->r_offset + object->load_offs);
			*where += object->load_offs;
d857 1
a857 1
	addr = (Elf_Addr *)(object->load_offs + rel->r_offset);
@


1.9
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2007/05/05 15:21:21 drahn Exp $ */
d823 1
a823 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.8
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2007/03/07 18:50:02 drahn Exp $ */
d602 1
a602 1
	long	fails = 0;
d766 1
a766 1
void
d769 1
d780 1
a780 1
		return;
d808 1
a808 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d828 2
@


1.7
log
@Put the workaround back in because gcc fails to build otherwise. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2007/02/03 00:55:34 drahn Exp $ */
d861 1
d874 1
@


1.6
log
@Revert a workaround that was put in for softfpu ABI violations, hardfp doesnt.
ok miod.
@
text
@d669 1
d676 7
@


1.5
log
@Kludge around a horrible problem where gcc 'knows' that __udivsi3 will
only clobber r0 and r4, and will not modify any other registers. Unfortunately
calling thru the PLT clobbers other registers eg, r1, which then
breaks because gcc doesn't reload the proper value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2006/11/11 23:04:50 drahn Exp $ */
a668 1
#if 0
a674 7
#else
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    SYM_PLT,
				    sym, NULL);
#endif
@


1.4
log
@remove '#if 0' block.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2006/11/10 22:02:33 drahn Exp $ */
d669 1
d676 7
@


1.3
log
@better...
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2006/11/10 21:19:54 drahn Exp $ */
a54 46
#if 0
	0,						/*  0 NONE */
	_RF_S|_RF_P|_RF_A|	_RF_SZ(32) | _RF_RS(0),	/*  1 PC24 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),	/*  2 ABS32 */
	_RF_S|_RF_P|_RF_A|	_RF_SZ(32) | _RF_RS(0),	/*  3 REL32 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/*  4 REL13 */
	_RF_S|_RF_A|		_RF_E,			/*  5 ABS16 */
	_RF_S|_RF_A|		_RF_E,			/*  6 ABS12 */
	_RF_S|_RF_A|		_RF_E,			/*  7 T_ABS5 */
	_RF_S|_RF_A|		_RF_E,			/*  8 ABS8 */
	_RF_S|_RF_B|_RF_A|	_RF_E,			/*  9 SBREL32 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/* 10 T_PC22 */
	_RF_S|_RF_P|_RF_A|	_RF_E,			/* 11 T_PC8 */
	_RF_E,						/* 12 Reserved */
	_RF_S|_RF_A|		_RF_E,			/* 13 SWI24 */
	_RF_S|_RF_A|		_RF_E,			/* 14 T_SWI8 */
	_RF_E,						/* 15 OBSL */
	_RF_E,						/* 16 OBSL */
	_RF_E,						/* 17 UNUSED */
	_RF_E,						/* 18 UNUSED */
	_RF_E,						/* 19 UNUSED */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 20 COPY */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),	/* 21 GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),	/* 22 JMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(32) | _RF_RS(0),	/* 23 RELATIVE */
	_RF_E,						/* 24 GOTOFF */
	_RF_E,						/* 25 GOTPC */
	_RF_E,						/* 26 GOT32 */
	_RF_E,						/* 27 PLT32 */
	_RF_E,						/* 28 UNUSED */
	_RF_E,						/* 29 UNUSED */
	_RF_E,						/* 30 UNUSED */
	_RF_E,						/* 31 UNUSED */
	_RF_E,						/* 32 A_PCR 0 */
	_RF_E,						/* 33 A_PCR 8 */
	_RF_E,						/* 34 A_PCR 16 */
	_RF_E,						/* 35 B_PCR 0 */
	_RF_E,						/* 36 B_PCR 12 */
	_RF_E,						/* 37 B_PCR 20 */
	_RF_E,						/* 38 RELAB32 */
	_RF_E,						/* 39 ROSGREL32 */
	_RF_E,						/* 40 V4BX */
	_RF_E,						/* 41 STKCHK */
	_RF_E						/* 42 TSTKCHK */

#endif
@


1.2
log
@Getting much closer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2006/11/10 07:44:58 drahn Exp $ */
d266 1
a266 1
	_RF_P|_RF_A|      _RF_SZ(32) | _RF_RS(0), 	/* 165  REL32 */
d386 1
a386 1
	_BM(0),		/* 14	Unused */
d423 1
d523 8
d569 45
d640 1
a640 1
			*where = value + rel->r_addend;
a667 1
	_dl_printf("protecting %x %x\n", llist->start, llist->size);
d701 1
@


1.1
log
@Not quite working ld.so support for sh
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2006/08/23 21:22:09 drahn Exp $ */
d30 1
d55 1
d99 261
d371 204
a574 43
	_BM(0),		/*  0 NONE */
	_BM(24),	/*  1 PC24 */
	_BM(32),	/*  2 ABS32 */
	_BM(32),	/*  3 REL32 */
	_BM(0),		/*  4 REL13 */
	_BM(0),		/*  5 ABS16 */
	_BM(0),		/*  6 ABS12 */
	_BM(0),		/*  7 T_ABS5 */
	_BM(0),		/*  8 ABS8 */
	_BM(32),	/*  9 SBREL32 */
	_BM(0),		/* 10 T_PC22 */
	_BM(0),		/* 11 T_PC8 */
	_BM(0),		/* 12 Reserved */
	_BM(0),		/* 13 SWI24 */
	_BM(0),		/* 14 T_SWI8 */
	_BM(0),		/* 15 OBSL */
	_BM(0),		/* 16 OBSL */
	_BM(0),		/* 17 UNUSED */
	_BM(0),		/* 18 UNUSED */
	_BM(0),		/* 19 UNUSED */
	_BM(32),	/* 20 COPY */
	_BM(32),	/* 21 GLOB_DAT */
	_BM(32),	/* 22 JMP_SLOT */
	_BM(32),	/* 23 RELATIVE */
	_BM(0),		/* 24 GOTOFF */
	_BM(0),		/* 25 GOTPC */
	_BM(0),		/* 26 GOT32 */
	_BM(0),		/* 27 PLT32 */
	_BM(0),		/* 28 UNUSED */
	_BM(0),		/* 29 UNUSED */
	_BM(0),		/* 30 UNUSED */
	_BM(0),		/* 31 UNUSED */
	_BM(0),		/* 32 A_PCR 0 */
	_BM(0),		/* 33 A_PCR 8 */
	_BM(0),		/* 34 A_PCR 16 */
	_BM(0),		/* 35 B_PCR 0 */
	_BM(0),		/* 36 B_PCR 12 */
	_BM(0),		/* 37 B_PCR 20 */
	_BM(0),		/* 38 RELAB32 */
	_BM(0),		/* 39 ROSGREL32 */
	_BM(0),		/* 40 V4BX */
	_BM(0),		/* 41 STKCHK */
	_BM(0)		/* 42 TSTKCHK */
d581 7
a587 1
void _dl_reloc_plt(Elf_Word *where, Elf_Addr value, Elf_Rel *rel);
d590 1
a590 1
_dl_md_reloc(elf_object_t *object, int rel, int relsz)
d593 1
a593 1
	long	numrel;
d596 1
a596 1
	Elf_Rel *rels;
d600 2
a601 2
	numrel = object->Dyn.info[relsz] / sizeof(Elf_Rel);
	rels = (Elf_Rel *)(object->Dyn.info[rel]);
d614 1
d620 1
a620 1
	for (i = 0; i < numrel; i++, rels++) {
d629 1
a629 1
			_dl_printf(" bad relocation %d %d\n", i, type);
a678 1
			/*
a679 2
			*/
			*where = value;
d759 4
a762 1
	if (object->Dyn.info[DT_PLTREL] != DT_REL)
@

