head	1.12;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2017.01.20.10.40.30;	author guenther;	state Exp;
branches;
next	1.11;
commitid	uAlj3GUarQrChIDM;

1.11
date	2017.01.09.22.51.04;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	8mveS1UjNqlN99uR;

1.10
date	2015.12.06.23.36.12;	author guenther;	state Exp;
branches;
next	1.9;
commitid	g8Z7pgqt28AVPEBX;

1.9
date	2014.12.30.11.26.48;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	aGv0kae1o5wkFqKZ;

1.8
date	2014.12.27.20.33.47;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	kSUtX42r21XCN4L2;

1.7
date	2014.07.04.18.07.54;	author miod;	state Exp;
branches;
next	1.6;
commitid	1U8LHeAt2mkJKduB;

1.6
date	2010.01.02.12.16.35;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.08.20.37.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.23.12.42.05;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.21.08.40.45;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.09.17.47.43;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.11.17.11.45;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Delete ancient macros and unnecessary #includes

ok deraadt@@
@
text
@/*	$OpenBSD: archdep.h,v 1.11 2017/01/09 22:51:04 kettenis Exp $ */

/*
 * Copyright (c) 1998-2002 Opsycon AB, Sweden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _MIPS_ARCHDEP_H_
#define _MIPS_ARCHDEP_H_

#include <link.h>

#include "syscall.h"
#include "resolve.h"
#include "util.h"

#define	RELOC_TAG	DT_REL
#define	MACHID	EM_MIPS		/* ELF e_machine ID value checked */


#define RELOC_DYN(relp, symp, adrp, val)				\
do {									\
	if (ELF64_R_TYPE(relp->r_info) == R_MIPS_REL32_64) {		\
		if (ELF64_R_SYM(relp->r_info) != 0)			\
			*adrp += symp->st_value + val;			\
		else							\
			*adrp += val;					\
	} else if (ELF64_R_TYPE(relp->r_info) != R_MIPS_NONE) {		\
		_dl_exit(ELF64_R_TYPE(relp->r_info)+100);		\
	}								\
} while (0)

#define RELOC_GOT(obj, off)						\
do {									\
	struct boot_dyn *__dynld = obj;					\
	long __loff = off;						\
	Elf64_Addr *gotp;						\
	int i, n;							\
	const Elf_Sym *sp;						\
									\
	/* Do all local gots */						\
	gotp = __dynld->dt_pltgot;					\
	n = __dynld->dt_proc[DT_MIPS_LOCAL_GOTNO - DT_LOPROC];		\
									\
	for (i = ((gotp[1] & 0x0000000080000000) ? 2 : 1); i < n; i++) {\
		gotp[i] += __loff;					\
	}								\
	gotp += n;							\
									\
	/* Do symbol referencing gots. There should be no global... */	\
	n =  __dynld->dt_proc[DT_MIPS_SYMTABNO - DT_LOPROC] -		\
	  __dynld->dt_proc[DT_MIPS_GOTSYM - DT_LOPROC];			\
	sp = __dynld->dt_symtab;					\
	sp += __dynld->dt_proc[DT_MIPS_GOTSYM - DT_LOPROC];		\
									\
	while (n--) {							\
		if (sp->st_shndx == SHN_UNDEF ||			\
		    sp->st_shndx == SHN_COMMON) {			\
			if (ELF64_ST_BIND(sp->st_info) != STB_WEAK)	\
				_dl_exit(7);				\
		} else if (ELF64_ST_TYPE(sp->st_info) == STT_FUNC) {	\
			*gotp += __loff;				\
		} else {						\
			*gotp = sp->st_value + __loff;			\
		}							\
		gotp++;							\
		sp++;							\
	}								\
} while (0)

#endif /* _MIPS_ARCHDEP_H_ */
@


1.11
log
@Remove dependency on __got_{start,end} symbols and look at PT_GNU_RELRO
instead.  Result in a few more pages that aren't writable on some platforms
(such as hppa).  Based on an initial diff from guenther@@.

Thanks to deraadt@@ for testing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.10 2015/12/06 23:36:12 guenther Exp $ */
a38 1
#define	DL_MALLOC_ALIGN	8	/* Arch constraint or otherwise */
@


1.10
log
@Simplify the relocation code for the ld.so bootstrap and static pie: track
just the dynamic tags are needed instead of reusing the generic elf_object_t
structure.

testing and feedback from miod@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.9 2014/12/30 11:26:48 kettenis Exp $ */
a91 2

#define GOT_PERMS PROT_READ
@


1.9
log
@Fix handling of R_MIPS_REL32_64 relocations that reference a symbol.
Fixes remaining problems with static PIE on mips64.
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.8 2014/12/27 20:33:47 kettenis Exp $ */
d38 1
d43 1
a43 1
#define RELOC_REL(relp, symp, adrp, val)				\
a54 7
#define RELOC_RELA(rela, sym, ptr, val, pltgot)				\
do {									\
	_dl_exit(20);	/* We don't do RELA now */			\
} while (0)

struct elf_object;

d57 1
a57 1
	struct elf_object *__dynld = obj;				\
d64 2
a65 2
	gotp = __dynld->dyn.pltgot;					\
	n = __dynld->Dyn.info[DT_MIPS_LOCAL_GOTNO - DT_LOPROC + DT_NUM];\
d73 4
a76 4
	n =  __dynld->Dyn.info[DT_MIPS_SYMTABNO - DT_LOPROC + DT_NUM] -	\
	  __dynld->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];	\
	sp = __dynld->dyn.symtab;					\
	sp += __dynld->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];	\
d82 1
a82 1
				_dl_exit(6);				\
a90 1
	__dynld->status |= STAT_GOT_DONE;				\
@


1.8
log
@Static PIE for mips64.  Still something not quite right as a full make build
fails.

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.7 2014/07/04 18:07:54 miod Exp $ */
d45 2
a46 2
		if (ELF64_R_SYM(rp->r_info) != 0)			\
			*adrp = symp->st_value + val;			\
@


1.7
log
@Remove bogus mprotect call from RELOC_REL() - this macro is used to relocate
ld.so itself only, and ld.so on mips only has relocations in the .data section,
which is writable.
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.6 2010/01/02 12:16:35 kettenis Exp $ */
d87 2
a88 1
			_dl_exit(6);					\
@


1.6
log
@Fix handling of hppa RELOC_IPLT relocations during 'bootstrap relocation'.

ok miod@@, deraadt@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.5 2006/05/08 20:37:01 deraadt Exp $ */
a43 1
	_dl_mprotect(adrp, 8, PROT_EXEC|PROT_READ|PROT_WRITE);		\
@


1.5
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.4 2004/09/23 12:42:05 pefo Exp $ */
d55 1
a55 1
#define RELOC_RELA(rela, sym, ptr, val)					\
@


1.4
log
@When doing relocs to .rodata this section must be RW protected.
It would be nice to fix this so it does not do a mprotect call
for each and every reloc but it will need a change in MI code
so we just fix it like this for now. There are not so many
relocs in ld.so itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.3 2004/09/21 08:40:45 pefo Exp $ */
d58 1
a58 1
} while(0)
d98 1
a98 1
} while(0)
@


1.3
log
@ELF64 and got ro prot
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.2 2004/09/09 17:47:43 pefo Exp $ */
d39 1
a40 1
#define	MACHID	EM_MIPS		/* ELF e_machine ID value checked */
d44 1
@


1.2
log
@ABI64 shared libs now handled.
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.1 2004/08/11 17:11:45 pefo Exp $ */
d38 1
a38 3
#define RTLD_PROTECT_PLT

#define	DL_MALLOC_ALIGN	16	/* Arch constraint or otherwise */
a41 4
//static inline void
//RELOC_REL(Elf_Rel *r, const Elf_Sym *s, Elf_Addr *p, unsigned long v)
//{
//}
d44 1
a44 1
	if (ELF64_R_TYPE(relp->r_info) == R_MIPS_REL32_64)	{		\
d54 4
a57 5
static inline void
RELOC_RELA(Elf64_Rela *r, const Elf64_Sym *s, Elf64_Addr *p, unsigned long v)
{
	_dl_exit(20);
}
@


1.1
log
@mips->mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: archdep.h,v 1.8 2004/08/09 13:44:19 pefo Exp $ */
d40 1
a40 1
#define	DL_MALLOC_ALIGN	4	/* Arch constraint or otherwise */
d44 15
a58 2
#define	RELTYPE	Elf32_Rel
#define	RELSIZE	sizeof(Elf32_Rel)
d61 1
a61 6
RELOC_REL(Elf_Rel *r, const Elf_Sym *s, Elf_Addr *p, unsigned long v)
{
}

static inline void
RELOC_RELA(Elf32_Rela *r, const Elf32_Sym *s, Elf32_Addr *p, unsigned long v)
d68 37
a104 36
static inline void
RELOC_GOT(struct elf_object *dynld, long loff)
{
	Elf32_Addr *gotp;
	int i, n;
	const Elf_Sym *sp;

	/* Do all local gots */
	gotp = dynld->dyn.pltgot;
	n = dynld->Dyn.info[DT_MIPS_LOCAL_GOTNO - DT_LOPROC + DT_NUM];

	for (i = ((gotp[1] & 0x80000000) ? 2 : 1); i < n; i++) {
		gotp[i] += loff;
	}
	gotp += n;

	/* Do symbol referencing gots. There should be no global... */
	n =  dynld->Dyn.info[DT_MIPS_SYMTABNO - DT_LOPROC + DT_NUM] -
	  dynld->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];
	sp = dynld->dyn.symtab;
	sp += dynld->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];

	while (n--) {
		if (sp->st_shndx == SHN_UNDEF ||
		    sp->st_shndx == SHN_COMMON) {
			_dl_exit(6);
		} else if (ELF32_ST_TYPE(sp->st_info) == STT_FUNC) {
			*gotp += loff;
		} else {
			*gotp = sp->st_value + loff;
		}
		gotp++;
		sp++;
	}
	dynld->status |= STAT_GOT_DONE;
}
@

