head	1.22;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@# @;


1.22
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.21;
commitid	veGB6uLWx3BTEAfk;

1.21
date	2016.08.28.06.15.32;	author guenther;	state Exp;
branches;
next	1.20;
commitid	Y7AbrDd15D7CrGY4;

1.20
date	2016.08.07.03.01.53;	author guenther;	state Exp;
branches;
next	1.19;
commitid	2iYIwn4jtIofjDNj;

1.19
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.18;
commitid	d9R7VGw9CHTkwXE1;

1.18
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	hneUpr7ZOJCeNeHP;

1.17
date	2016.03.21.01.32.49;	author guenther;	state Exp;
branches;
next	1.16;
commitid	7Tp2uEssgeiK9f77;

1.16
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	kmpP8aoRsEOyxUMj;

1.15
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.14;
commitid	FcRQ6g8MqXiORdFs;

1.14
date	2015.09.13.17.08.04;	author guenther;	state Exp;
branches;
next	1.13;
commitid	BssYI6s6zozAyfkk;

1.13
date	2014.07.14.03.54.51;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	fsr4AzfIP3TLhLM2;

1.12
date	2014.07.09.12.51.21;	author guenther;	state Exp;
branches;
next	1.11;
commitid	l16v8zUGQ3906m8T;

1.11
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.10;
commitid	vlK4cqSehsiJVTpr;

1.10
date	2014.07.05.17.05.08;	author miod;	state Exp;
branches;
next	1.9;
commitid	qI33qwjpMQlsifaE;

1.9
date	2014.01.18.09.08.42;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.14.05.24.07;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.01.19.37.50;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.27.20.45.09;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.27.20.16.15;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.21.09.54.08;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.21.08.40.45;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.09.17.47.43;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.11.17.11.45;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.22
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: ldasm.S,v 1.21 2016/08/28 06:15:32 guenther Exp $ */

/*
 * Copyright (c) 1998-2002 Opsycon AB, Sweden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <machine/asm.h>
#include <sys/syscall.h>
#define __cerror	_dl_cerror
#include <SYS.h>

/* Stack at this stage is:
 * struct stack {
 *	int	kargc;
 *	char	*kargv[1];	size depends on kargc
 *	char	kargstr[1];	size varies
 *	char	kenvstr[1];	size varies
 * };
 */

FRAMESZ= MKFSIZ(4,16)
GPOFF= FRAMESZ-2*REGSZ
RAOFF= FRAMESZ-1*REGSZ

LEAF(_dl_start, FRAMESZ)		/* Not really LEAF, but we simplify */
	PTR_SUBU sp, FRAMESZ		# Some space.
	SETUP_GP64(GPOFF, _dl_start)

	LA	s1, 1f
	bgezal	zero, 1f
1:
	PTR_SUBU s0, ra, s1		# This is the load offset

	PTR_ADDU a0, sp, FRAMESZ	# Where stack info is.
	PTR_ADDU a1, sp, 0		# Where fast AUX info will be.
	LA	a2, _DYNAMIC
	PTR_ADDU a2, s0			# Where _DYNAMIC is
	LA	t9, _dl_boot_bind
	PTR_ADDU t9, s0
	jalr	t9			# Relocate ourself.

	REG_L	a3, FRAMESZ(sp)		# argc
	PTR_ADDU a0, sp, FRAMESZ+REGSZ	# argv
	PTR_ADDU a1, a0, REGSZ
	PTR_SLL  a3, a3, LOGREGSZ
	PTR_ADDU a1, a3
	PTR_ADDU a3, sp, 0		# Where fast AUX info will be.
	move	a2, s0			# Load offset
	jal	_dl_boot		# Go do the linking.

	move	t9, v0			# Entry address from _dl_boot.
	LA	v0, _dl_dtors		# cleanup

	RESTORE_GP64
	PTR_ADDU sp, FRAMESZ		# Restore stack pointer.
	move	ra, zero		# Mark last stack frame.
	j	t9			# Go execute the 'real' program.
END(_dl_start)

FRAMESZ= MKFSIZ(4,16)
GPOFF= FRAMESZ-2*REGSZ
RAOFF= FRAMESZ-1*REGSZ
A0OFF= FRAMESZ-3*REGSZ
A1OFF= FRAMESZ-4*REGSZ
A2OFF= FRAMESZ-5*REGSZ
A3OFF= FRAMESZ-6*REGSZ
A4OFF= FRAMESZ-7*REGSZ
A5OFF= FRAMESZ-8*REGSZ
A6OFF= FRAMESZ-9*REGSZ
A7OFF= FRAMESZ-10*REGSZ
S0OFF= FRAMESZ-11*REGSZ

	.globl	_dl_bind_start
	.ent	_dl_bind_start, 0
_dl_bind_start:
	ld	v1, -32744(gp)
	PTR_SUBU sp, FRAMESZ
	SETUP_GP64(GPOFF, _dl_bind_start)
	REG_S	a0, A0OFF(sp)
	REG_S	a1, A1OFF(sp)
	REG_S	a2, A2OFF(sp)
	REG_S	a3, A3OFF(sp)
	REG_S	a4, A4OFF(sp)
	REG_S	a5, A5OFF(sp)
	REG_S	a6, A6OFF(sp)
	REG_S	a7, A7OFF(sp)
	REG_S	$15, RAOFF(sp)
	REG_S	s0, S0OFF(sp)
	move	s0, sp
	move	a0, v1
	move	a1, t8
	jal	_dl_bind

	move	sp, s0
	REG_L	ra, RAOFF(sp)
	REG_L	s0, S0OFF(sp)
	REG_L	a0, A0OFF(sp)
	REG_L	a1, A1OFF(sp)
	REG_L	a2, A2OFF(sp)
	REG_L	a3, A3OFF(sp)
	REG_L	a4, A4OFF(sp)
	REG_L	a5, A5OFF(sp)
	REG_L	a6, A6OFF(sp)
	REG_L	a7, A7OFF(sp)
	RESTORE_GP64
	PTR_ADDU sp, FRAMESZ
	move	t9, v0
	jr	t9
	.end	_dl_bind_start

#define	DL_SYSCALL(n)		DL_SYSCALL2(n,n)
#define	DL_SYSCALL_NOERR(n)	DL_SYSCALL2_NOERR(n,n)
#define	DL_SYSCALL2(n,c)						\
NLEAF(_dl_##n,0)							\
	__DO_SYSCALL(c);						\
	bnez	a3, _dl_cerror;						\
	j	ra;							\
END(_dl_##n)
#define	DL_SYSCALL2_NOERR(n,c)						\
NLEAF(_dl_##n,0)							\
	__DO_SYSCALL(c);						\
	j	ra;							\
END(_dl_##n)

_dl_cerror:
	subu	v0, zero, v0
	j	ra

DL_SYSCALL(close)
DL_SYSCALL_NOERR(exit)
DL_SYSCALL(fstat)
DL_SYSCALL2(getcwd,__getcwd)
DL_SYSCALL(getdents)
DL_SYSCALL(getentropy)
DL_SYSCALL(sendsyslog)
DL_SYSCALL(pledge)
DL_SYSCALL_NOERR(issetugid)
DL_SYSCALL_NOERR(getthrid)
DL_SYSCALL(mprotect)
DL_SYSCALL(munmap)
DL_SYSCALL(open)
DL_SYSCALL(read)
DL_SYSCALL(readlink)
DL_SYSCALL2(_syscall,__syscall)
DL_SYSCALL2_NOERR(set_tcb,__set_tcb)
DL_SYSCALL(sysctl)
DL_SYSCALL(utrace)
DL_SYSCALL(write)
DL_SYSCALL(thrkill)
@


1.21
log
@ld.so doesn't need gettimeofday or lstat stubs any more

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.20 2016/08/07 03:01:53 guenther Exp $ */
d171 1
@


1.20
log
@Teach mips64 to pass &_DYNAMIC to _dl_boot_bind()

mips64be testing by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.19 2016/05/07 19:05:23 guenther Exp $ */
a158 1
DL_SYSCALL(gettimeofday)
a160 1
DL_SYSCALL(lstat)
@


1.19
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.18 2016/03/21 22:41:29 bluhm Exp $ */
d58 2
@


1.18
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.17 2016/03/21 01:32:49 guenther Exp $ */
d31 1
d159 1
d167 1
@


1.17
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.16 2015/11/15 03:41:24 deraadt Exp $ */
d154 1
a154 1
DL_SYSCALL(sendsyslog2)
@


1.16
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.15 2015/09/19 20:56:47 guenther Exp $ */
d154 1
a154 1
DL_SYSCALL(sendsyslog)
@


1.15
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.14 2015/09/13 17:08:04 guenther Exp $ */
d155 1
@


1.14
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.13 2014/07/14 03:54:51 deraadt Exp $ */
a146 19

NLEAF(_dl_sigprocmask,0)
	/* _dl_sigprocmask does not support NULL as the new mask */
#if 0
	bnez	a1, 1f
	li	a0, 1	/* SIG_BLOCK */
	b	2f
1:
#endif
	lw	a1, 0(a1)
2:
	__DO_SYSCALL(sigprocmask)
	bnez	a3, _dl_cerror
	beqz	a2, 1f
	sw	v0, 0(a2)
1:
	li	v0, 0
	j	ra
END(_dl_sigprocmask)
@


1.13
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.12 2014/07/09 12:51:21 guenther Exp $ */
d183 1
a183 1
DL_SYSCALL2(sysctl,__sysctl)
@


1.12
log
@_dl_fcntl() is no longer used; kill the stubs

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.11 2014/07/06 07:28:36 otto Exp $ */
d173 1
@


1.11
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.10 2014/07/05 17:05:08 miod Exp $ */
a168 1
DL_SYSCALL(fcntl)
@


1.10
log
@Add more sugar to build syscall stubs, and turn them from inlines to real
entry points, now that we no longer need _dl_mprotect to be inline; also,
make sure syscall failures return -errno rather than -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.9 2014/01/18 09:08:42 kettenis Exp $ */
d173 1
@


1.9
log
@Make ld.so pass its cleanup handler in $2 as required by the MIPS System V
ABI, and completely remove the code that attempts to call atexit(3) directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.8 2013/01/14 05:24:07 miod Exp $ */
d31 1
a78 10
LEAF(_dl__syscall, 0)
	li	v0, SYS___syscall	# Indirect syscall.
	syscall
	bne	a3, zero, 1f
	j	ra
1:
	li	v0, -1
	j	ra
END(_dl__syscall)

d129 56
@


1.8
log
@Do not bogusly attempt to mprotect ld.so's .rodata area RW at bootstrap
time: the logic is wrong, and there are no relocations to apply to .rodata
anyway.
ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.7 2012/11/01 19:37:50 kettenis Exp $ */
d69 3
a73 1
	move	t9, v0			# Entry address from _dl_boot.
a74 1
	move	v0, zero		# cleanup
@


1.7
log
@Zero v0 before transferring control to the main program to indicate that
the main program should not reguster a cleanup handler with atexit(3).
This will allow us to add the cleanup handler registration code to crt0.c
and have ld.so pass its cleanup handler to the main program in the future.

While there, also zero ra to mark the last stack frame as demanded by the ELF
ABI.

ok kurt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.6 2010/03/27 20:45:09 kettenis Exp $ */
a52 20
	LA	t0, _fdata
	PTR_SRL	t0, 20			# check if distance is > 2**16.
	beqz	t0, 2f
	li	t0, 0x10000

	li	t0, 0x100000
2:

	# This is a hack to change protection of .rodata so it
	# can be relocated. A better way to find the location
	# of .rodata should probably be used.
	# We know that .rodata is aligned on 0x100000 or 0x10000
	# and is at most 64 k in size.
	li	v0, SYS_mprotect
	or	a0, ra, 0xfff
	xor	a0, 0xfff
	PTR_ADDU a0, t0
	li	a1, 0x10000
	li	a2, 7 /* (PROT_READ|PROT_WRITE|PROT_EXEC) */
	syscall
@


1.6
log
@Remove explicit nop's in delay slots introduced in the previous commit.  They
are already inserted as part of jal/jr expansion by gas, and we don't need
another one.

suggested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.5 2010/03/27 20:16:15 kettenis Exp $ */
d92 2
@


1.5
log
@Implement lazy binding on mips64.  This implementation relies on having two
reserved entries in the GOT, which is a GNU extension to the 64-bit MIPS
SVR4 ABI.  That's fine; all existing OpenBSD/mips64 binaries have the extra
slot.

ok miod@@, jsing@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.4 2004/09/21 09:54:08 pefo Exp $ */
d138 1
a138 1
	 nop
a153 1
	 nop
@


1.4
log
@Automatically adapt to actual text/data alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.3 2004/09/21 08:40:45 pefo Exp $ */
d105 51
a155 6
	.globl	_dl_rt_resolve
	.ent	_dl_rt_resolve, 0
_dl_rt_resolve:

/* XXX Fix when lazy binding works */
	.end	_dl_rt_resolve
@


1.3
log
@ELF64 and got ro prot
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.2 2004/09/09 17:47:43 pefo Exp $ */
d52 8
d64 2
a65 2
	# We know that .rodata is aligned on 0x100000 and is at
	# most 64 k in size.
d69 1
a69 1
	PTR_ADDU a0, 0x10000
a73 1
	PTR_SUBU s0, ra, s1		# This is the load offset
@


1.2
log
@ABI64 shared libs now handled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.1 2004/08/11 17:11:45 pefo Exp $ */
d56 2
d61 2
a62 1
	li	a1, 0x8000
@


1.1
log
@mips->mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.5 2003/06/09 16:10:04 deraadt Exp $ */
d30 1
d41 7
a47 3
LEAF(_dl_start)		/* Not really LEAF, but we simplify */
	addu	sp, -64		# Some space.
	.cprestore 12
d49 1
a49 1
	la	a1, 1f
d52 31
a82 19
	subu	s0, ra, a1	# This is the load offset
	addu	a0, sp, 64	# Where stack info is.
	addu	a1, sp, 16	# Where fast AUX info will be.
	la	t9, _dl_boot_bind
	addu	t9, s0
	jalr	t9		# Relocate ourself.

	lw	a3, 64(sp)	# argc
	addu	a0, sp, 68	# argv
	addi	a1, a0, 4
	sll	a3, a3, 2
	addu	a1, a3
	addu	a3, sp, 16	# Where fast AUX info will be.
	move	a2, s0		# Load offset
	jal	_dl_boot	# Go do the linking.

	addu	sp, 64		# Restore stack pointer.
	move	t9, v0		# Entry address from _dl_boot.
	j	t9		# Go execute the 'real' program.
d85 3
a87 2
LEAF(_dl__syscall)
	li	v0, 0		# Indirect syscall.
@

