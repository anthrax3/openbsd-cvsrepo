head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.6
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2017.01.30.05.00.31;	author guenther;	state Exp;
branches;
next	1.26;
commitid	bD3NPg0DBP1oKFRZ;

1.26
date	2017.01.29.16.29.52;	author visa;	state Exp;
branches;
next	1.25;
commitid	RPjm1nOkPJKXwrzE;

1.25
date	2017.01.25.15.22.57;	author visa;	state Exp;
branches;
next	1.24;
commitid	D2or2c7DstM1Pbrj;

1.24
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.23;
commitid	veGB6uLWx3BTEAfk;

1.23
date	2017.01.23.10.30.58;	author guenther;	state Exp;
branches;
next	1.22;
commitid	gelJDihLmdyfb63O;

1.22
date	2016.06.18.02.40.46;	author guenther;	state Exp;
branches;
next	1.21;
commitid	2GreS8iCAh3xtkgf;

1.21
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.20;
commitid	Kpc3J4Ry51yjfQid;

1.20
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.19;
commitid	zGFWeGZdYJxUOZli;

1.19
date	2015.08.26.02.04.41;	author guenther;	state Exp;
branches;
next	1.18;
commitid	gf5adcYyT8xVSb14;

1.18
date	2014.05.02.04.55.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.11.11.13.20;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.03.04.19.42;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.27.20.16.15;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.21.02.44.55;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.21.23.12.10;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.16.23.19.42;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.01.22.10.37;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.30.17.56.18;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.21.08.40.45;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.09.17.47.43;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.11.17.11.45;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Fix ELF64_R_TYPE(reloc->r_info) to have the same type on mips64le
as on other LP64 archs, __uint64_t, so that printf-like functions
don't require extra casting...then eliminate the extra cast in
ld.so/mips64/rtld_machine.c

discussed with miod
ok visa@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.26 2017/01/29 16:29:52 visa Exp $ */

/*
 * Copyright (c) 1998-2004 Opsycon AB, Sweden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <link.h>

#include "resolve.h"
#include "syscall.h"
#include "archdep.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;


int
_dl_md_reloc(elf_object_t *object, int rel, int relsz)
{
	int	i;
	int	numrel;
	int	fails = 0;
	struct load_list *load_list;
	Elf64_Addr loff;
	Elf64_Addr ooff;
	Elf64_Rel  *relocs;
	const Elf64_Sym *sym, *this;
	Elf64_Addr prev_value = 0;
	const Elf64_Sym *prev_sym = NULL;

	loff = object->obj_base;
	numrel = object->Dyn.info[relsz] / sizeof(Elf64_Rel);
	relocs = (Elf64_Rel *)(object->Dyn.info[rel]);

	if (relocs == NULL)
		return(0);

	/*
	 * Change protection of all write protected segments in the
	 * object so we can do relocations in the .rodata section.
	 * After relocation restore protection.
	 */
	if (object->dyn.textrel) {
		for (load_list = object->load_list; load_list != NULL; load_list = load_list->next) {
			if ((load_list->prot & PROT_WRITE) == 0)
				_dl_mprotect(load_list->start, load_list->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	DL_DEB(("relocating %d\n", numrel));
	for (i = 0; i < numrel; i++, relocs++) {
		Elf64_Addr r_addr = relocs->r_offset + loff;
		const char *symn;
		int type;

		if (ELF64_R_SYM(relocs->r_info) == 0xffffff)
			continue;

		ooff = 0;
		sym = object->dyn.symtab;
		sym += ELF64_R_SYM(relocs->r_info);
		symn = object->dyn.strtab + sym->st_name;
		type = ELF64_R_TYPE(relocs->r_info);

		this = NULL;
		if (ELF64_R_SYM(relocs->r_info)) {
			if (sym == prev_sym)
				this = sym;	/* XXX non-NULL */
			else if (!(ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
			    ELF64_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
				ooff = _dl_find_symbol(symn, &this,
				SYM_SEARCH_ALL | SYM_WARNNOTFOUND | SYM_PLT,
				sym, object, NULL);

				if (this == NULL) {
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = this->st_value + ooff;
			}
		}

		switch (ELF64_R_TYPE(relocs->r_info)) {
			/* XXX Handle non aligned relocs. .eh_frame
			 * XXX in libstdc++ seems to have them... */
			u_int64_t robj;

		case R_MIPS_REL32_64:
			if (ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
			    (ELF64_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF64_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
				if ((long)r_addr & 7) {
					_dl_bcopy((char *)r_addr, &robj, sizeof(robj));
					robj += loff + sym->st_value;
					_dl_bcopy(&robj, (char *)r_addr, sizeof(robj));
				} else {
					*(u_int64_t *)r_addr += loff + sym->st_value;
				}
			} else if (this && ((long)r_addr & 7)) {
				_dl_bcopy((char *)r_addr, &robj, sizeof(robj));
				robj += prev_value;
				_dl_bcopy(&robj, (char *)r_addr, sizeof(robj));
			} else if (this) {
				*(u_int64_t *)r_addr += prev_value;
			}
			break;

		case R_MIPS_NONE:
			break;

		default:
			_dl_die("unsupported relocation '%llu'",
			    ELF64_R_TYPE(relocs->r_info));
		}
	}
	DL_DEB(("done %d fails\n", fails));
	if (object->dyn.textrel) {
		for (load_list = object->load_list; load_list != NULL; load_list = load_list->next) {
			if ((load_list->prot & PROT_WRITE) == 0)
				_dl_mprotect(load_list->start, load_list->size,
				    load_list->prot);
		}
	}
	return(fails);
}

extern void _dl_bind_start(void);

/*
 *	Relocate the Global Offset Table (GOT). Currently we don't
 *	do lazy evaluation here because the GNU linker doesn't
 *	follow the ABI spec which says that if an external symbol
 *	is referenced by other relocations than CALL16 and 26 it
 *	should not be given a stub and have a zero value in the
 *	symbol table. By not doing so, we can't use pointers to
 *	external functions and use them in comparisons...
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	int	i, n;
	Elf64_Addr loff;
	Elf64_Addr ooff;
	Elf64_Addr *gotp;
	const Elf64_Sym  *symp;
	const Elf64_Sym  *this;
	const char *strt;

	if (object->status & STAT_GOT_DONE)
		return (0);

	loff = object->obj_base;
	strt = object->dyn.strtab;
	gotp = object->dyn.pltgot;
	n = object->Dyn.info[DT_MIPS_LOCAL_GOTNO - DT_LOPROC + DT_NUM];

	DL_DEB(("loff: 0x%lx\n", (unsigned long)loff));
	/*
	 *  Set up pointers for run time (lazy) resolving.
	 */
	gotp[0] = (long)_dl_bind_start;
	gotp[1] = (long)object;

	/*  First do all local references. */
	for (i = 2; i < n; i++) {
		gotp[i] += loff;
	}

	gotp += n;

	symp =  object->dyn.symtab;
	symp += object->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];
	n =  object->Dyn.info[DT_MIPS_SYMTABNO - DT_LOPROC + DT_NUM] -
	    object->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];

	this = NULL;

	if (object->traced)
		lazy = 1;

	/*
	 *  Then do all global references according to the ABI.
	 *  Quickstart is not yet implemented.
	 */
	while (n--) {
		if (symp->st_shndx == SHN_UNDEF &&
		    ELF64_ST_TYPE(symp->st_info) == STT_FUNC) {
			if (symp->st_value == 0 || !lazy) {
				this = NULL;
				ooff = _dl_find_symbol(strt + symp->st_name,
				    &this,
				    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT,
				    symp, object, NULL);
				if (this)
					*gotp = this->st_value + ooff;
			} else
				*gotp = symp->st_value + loff;
		} else if (symp->st_shndx == SHN_COMMON ||
			symp->st_shndx == SHN_UNDEF) {
			this = NULL;
			ooff = _dl_find_symbol(strt + symp->st_name, &this,
			    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT,
			    symp, object, NULL);
			if (this)
				*gotp = this->st_value + ooff;
		} else if (ELF64_ST_TYPE(symp->st_info) == STT_FUNC &&
			symp->st_value != *gotp) {
			*gotp += loff;
		} else {	/* Resolve all others immediately */
			this = NULL;
			ooff = _dl_find_symbol(strt + symp->st_name, &this,
			    SYM_SEARCH_ALL|SYM_NOWARNNOTFOUND|SYM_PLT,
			    symp, object, NULL);
			if (this)
				*gotp = this->st_value + ooff;
			else
				*gotp = symp->st_value + loff;
		}
		gotp++;
		symp++;
	}
	object->status |= STAT_GOT_DONE;

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	return (0);
}

Elf_Addr
_dl_bind(elf_object_t *object, int symidx)
{
	Elf_Addr *gotp = object->dyn.pltgot;
	Elf_Addr ooff;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;
	int n;

	sym = object->dyn.symtab;
	sym += symidx;
	symn = object->dyn.strtab + sym->st_name;
	n = object->Dyn.info[DT_MIPS_LOCAL_GOTNO - DT_LOPROC + DT_NUM] -
	    object->Dyn.info[DT_MIPS_GOTSYM - DT_LOPROC + DT_NUM];

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = &gotp[n + symidx];
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("v0") = SYS_kbind;
		register void *arg1 __asm("a0") = &buf;
		register long  arg2 __asm("a1") = sizeof(buf);
		register long  arg3 __asm("a2") = cookie;

		__asm volatile("syscall" : "+r" (syscall_num)
		    : "r" (arg1), "r" (arg2), "r" (arg3)
		    : "v1", "a3", "memory");
	}

	return (buf.newval);
}
@


1.26
log
@Previous commit broke build on loongson. Refix by adding
an explicit type cast.

Reported and tested by matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2017/01/25 15:22:57 visa Exp $ */
d144 2
a145 2
			_dl_die("unsupported relocation '%u'",
			    (unsigned int)ELF64_R_TYPE(relocs->r_info));
@


1.25
log
@Fix build on mips64.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2017/01/24 07:48:37 guenther Exp $ */
d144 2
a145 2
			_dl_die("unsupported relocation '%lld'",
			    ELF64_R_TYPE(relocs->r_info));
@


1.24
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2017/01/23 10:30:58 guenther Exp $ */
d144 1
a144 1
			_dl_die("unsupported relocation '%d'",
@


1.23
log
@Fix format string mismatches
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2016/06/18 02:40:46 guenther Exp $ */
d144 2
a145 3
			_dl_printf("%s: unsupported relocation '%d'\n",
			    __progname, ELF64_R_TYPE(relocs->r_info));
			_dl_exit(1);
d286 2
a287 4
	if (this == NULL) {
		_dl_printf("lazy binding failed\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.22
log
@Make mips64 like all the others: only make mappings writable during relocation
if DT_TEXTREL was set on the object.  If that's needed, only set the mapping
to READ+WRITE to avoid W^X violation.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2016/03/20 02:29:51 guenther Exp $ */
d190 1
a190 1
	DL_DEB(("loff: '%p'\n", loff));
@


1.21
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2015/11/02 07:02:53 guenther Exp $ */
d71 6
a76 6
	load_list = object->load_list;
	while (load_list != NULL) {
		if ((load_list->prot & PROT_WRITE) == 0)
			_dl_mprotect(load_list->start, load_list->size,
			    load_list->prot|PROT_WRITE);
		load_list = load_list->next;
d150 6
a155 6
	load_list = object->load_list;
	while (load_list != NULL) {
		if ((load_list->prot & PROT_WRITE) == 0)
			_dl_mprotect(load_list->start, load_list->size,
			    load_list->prot);
		load_list = load_list->next;
@


1.20
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2015/08/26 02:04:41 guenther Exp $ */
d145 1
a145 1
			    _dl_progname, ELF64_R_TYPE(relocs->r_info));
@


1.19
log
@Kbind 3: The Legend Continues!
Use kbind for lazy binding GOT/PLT updates on alpha and mips64.
While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2014/05/02 04:55:48 miod Exp $ */
a209 12
	object->plt_size = 0;
	object->got_size = 0;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_start = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_start;
d257 2
a258 4
	DL_DEB(("got: %x, %x\n", object->got_start, object->got_size));
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
@


1.18
log
@No need to figure out the area spanned by .got in _dl_md_reloc(); only
_dl_md_reloc_boot() needs to compute this.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2013/06/13 04:13:47 brad Exp $ */
d33 2
a36 1
#include <signal.h>
d42 3
d281 1
a281 1
	Elf_Addr *addr, ooff;
d285 5
a289 1
	sigset_t savedmask;
d306 1
a306 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return ooff + this->st_value;
d308 2
a309 7
	addr = &gotp[n + symidx];

	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect(addr, sizeof(Elf_Addr), PROT_READ|PROT_WRITE);
	}
d311 2
a312 1
	*addr = ooff + this->st_value;
d314 10
a323 4
	/* if GOT is (to be protected, change back to RO */
	if (object->got_size != 0) {
		_dl_mprotect(addr, sizeof (Elf_Addr), PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
d326 1
a326 1
	return *addr;
@


1.17
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2013/06/01 09:57:58 miod Exp $ */
a49 1
	Elf64_Addr got_start, got_end;
a73 15

	/* XXX We need the got limits to know if reloc is in got. */
	/* XXX Relocs against the got should not include the STUB address! */
	this = NULL;
	got_start = 0;
	got_end = 0;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		got_start = ooff + this->st_value;
	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		got_end = ooff + this->st_value;
@


1.16
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2013/05/08 20:55:14 guenther Exp $ */
d311 1
a311 1
		*((int *)0) = 0;	/* XXX */
@


1.15
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2010/09/11 11:13:20 kettenis Exp $ */
d235 3
d296 1
d308 1
a308 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, NULL);
d313 3
@


1.14
log
@Fix lazy binding issue by making sure the second argument to _dl_find_symbol()
always points to a pointer that is initialized to NULL.  Consistently use
NULL instead of mixing NULL and 0 to make the pattern more obvious.
Fixes nm(1) crashes that happen when you pass it multiple object files on
the command line.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2010/05/03 04:19:42 miod Exp $ */
d53 2
d107 17
a123 11
		if (ELF64_R_SYM(relocs->r_info) &&
		    !(ELF64_ST_BIND(sym->st_info) == STB_LOCAL &&
		    ELF64_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
			ooff = _dl_find_symbol(symn, &this,
			SYM_SEARCH_ALL | SYM_WARNNOTFOUND | SYM_PLT,
			sym, object, NULL);

			if (this == NULL) {
				if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
					fails++;
				continue;
d145 1
a145 1
				robj += this->st_value + ooff;
d148 1
a148 1
				*(u_int64_t *)r_addr += this->st_value + ooff;
@


1.13
log
@Fix breakage from last commit.  Bad guenther@@, no cookie!
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2010/03/27 20:16:15 kettenis Exp $ */
d235 1
a235 1
				this = 0;
d246 1
a246 1
			this = 0;
d256 1
a256 1
			this = 0;
d294 1
@


1.12
log
@Implement lazy binding on mips64.  This implementation relies on having two
reserved entries in the GOT, which is a GNU extension to the 64-bit MIPS
SVR4 ABI.  That's fine; all existing OpenBSD/mips64 binaries have the extra
slot.

ok miod@@, jsing@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2008/04/09 21:45:26 kurt Exp $ */
d285 1
a285 1
	sigset_t omask, nmask;
d305 1
a305 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d314 1
a314 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.11
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2007/11/27 16:42:19 miod Exp $ */
d35 2
d164 2
a188 1
	lazy = 0;	/* XXX Fix ld before enabling lazy */
d198 2
a199 4
	gotp[0] = (long)_dl_rt_resolve;
	if (gotp[1] & 0x0000000080000000) {
		gotp[1] = (long)object | 0x0000000080000000;
	}
d202 1
a202 1
	for (i = ((gotp[1] & 0x0000000080000000) ? 2 : 1); i < n; i++) {
d243 1
a243 1
				*gotp = symp->st_value + ooff;
d276 45
@


1.10
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2006/12/21 02:44:55 krw Exp $ */
d52 1
a52 1
	loff = object->load_offs;
d186 1
a186 1
	loff = object->load_offs;
@


1.9
log
@'immediatly' -> 'immediately' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2005/09/22 01:33:08 drahn Exp $ */
d171 1
a171 1
void
d183 1
a183 1
		return;
d273 2
@


1.8
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2005/09/21 23:12:10 drahn Exp $ */
d254 1
a254 1
		} else {	/* Resolve all others immediatly */
@


1.7
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2005/09/16 23:19:42 drahn Exp $ */
d107 1
a107 1
			SYM_SEARCH_ALL | SYM_NOWARNNOTFOUND | SYM_PLT,
d111 1
a111 6
				if (ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
					_dl_printf("%s: %s :can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);

a112 1
				}
@


1.6
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2004/10/01 22:10:37 pefo Exp $ */
d78 1
a78 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d83 1
a83 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
a98 1
		this = sym;
d102 1
d108 12
a119 5
			sym->st_size, object, NULL);
			if (!this && ELF64_ST_BIND(sym->st_info) == STB_GLOBAL) {
				_dl_printf("%s: can't resolve reference '%s'\n",
				    _dl_progname, symn);
				fails++;
a120 1

d222 1
a222 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d228 1
a228 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d244 1
a244 1
				    symp->st_size, object, NULL);
d254 1
a254 1
			    symp->st_size, object, NULL);
d264 1
a264 1
			    symp->st_size, object, NULL);
@


1.5
log
@Fix GOT reloc which had flaws in reloc processing.
Big thanks to Mark Kettenis for finding the problem!
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2004/09/30 17:56:18 pefo Exp $ */
d77 3
a79 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
a81 1

d83 3
a85 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d108 1
a108 1
			ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
d110 1
a110 1
			sym->st_size, object);
d217 3
a219 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d224 3
a226 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d240 1
a240 1
				    _dl_objects, &this, NULL,
d242 1
a242 1
				    symp->st_size, object);
d250 1
a250 2
			ooff = _dl_find_symbol(strt + symp->st_name,
			    _dl_objects, &this, NULL,
d252 1
a252 1
			    symp->st_size, object);
d260 1
a260 2
			ooff = _dl_find_symbol(strt + symp->st_name,
			    _dl_objects, &this, NULL,
d262 1
a262 1
			    symp->st_size, object);
@


1.4
log
@handle unaligned in local relocs as well (c++)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2004/09/21 08:40:45 pefo Exp $ */
d253 2
a254 1
		} else if (ELF64_ST_TYPE(symp->st_info) == STT_FUNC) {
d256 10
a265 2
		} else {	/* XXX ??? */	/* Resolve all others immediatly */
			*gotp = symp->st_value + loff;
@


1.3
log
@ELF64 and got ro prot
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2004/09/09 17:47:43 pefo Exp $ */
d119 4
d127 7
a133 1
				*(u_int64_t *)r_addr += loff + sym->st_value;
a134 3
				/* XXX Handle non aligned relocs. .eh_frame
				 * XXX in libstdc++ seems to have them... */
				u_int64_t robj;
@


1.2
log
@ABI64 shared libs now handled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2004/08/11 17:11:45 pefo Exp $ */
d47 2
d50 1
d72 15
a90 2
		Elf64_Addr ooff = 0;
		const Elf64_Sym *sym, *this;
d97 1
d124 1
a124 1
			} else if (this) {
d127 6
a132 7
				if (((long)r_addr & 7)) {
					u_int64_t robj;
					_dl_bcopy((char *)r_addr, &robj, sizeof(robj));
					robj += this->st_value + ooff;
					_dl_bcopy(&robj, (char *)r_addr, sizeof(robj));
				} else
					*(u_int64_t *)r_addr += this->st_value + ooff;
a171 1
	Elf64_Addr plt_addr;
a196 1
	DL_DEB(("got: '%p' = %x\n", &gotp[i], gotp[i]));
a205 1
	plt_addr = 0;
d218 1
a218 13
		object->got_size = ooff + this->st_value  - object->got_addr;

	this = NULL;
	ooff = _dl_find_symbol("__plt_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
	if (this != NULL)
		object->plt_start = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__plt_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;
a226 1
	DL_DEB(("got: '%s' = %x\n", strt + symp->st_name, symp->st_value));
d256 1
a259 3
	if (object->plt_size != 0)
		_dl_mprotect((void*)object->plt_start, object->plt_size,
		    PROT_READ|PROT_EXEC);
@


1.1
log
@mips->mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2004/08/06 09:38:29 pefo Exp $ */
d45 3
a47 2
	Elf32_Addr loff;
	Elf32_Rel  *relocs;
d50 2
a51 2
	numrel = object->Dyn.info[relsz] / sizeof(Elf32_Rel);
	relocs = (Elf32_Rel *)(object->Dyn.info[rel]);
d56 15
d72 3
a74 3
		Elf32_Addr r_addr = relocs->r_offset + loff;
		Elf32_Addr ooff = 0;
		const Elf32_Sym *sym, *this;
d78 1
a78 1
		if (ELF32_R_SYM(relocs->r_info) == 0xffffff)
d82 1
a82 1
		sym += ELF32_R_SYM(relocs->r_info);
d85 1
a85 1
		type = ELF32_R_TYPE(relocs->r_info);
d87 3
a89 3
		if (ELF32_R_SYM(relocs->r_info) &&
		    !(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
		    ELF32_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
d93 1
a93 1
			if (!this && ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
d101 6
a106 6
		switch (ELF32_R_TYPE(relocs->r_info)) {
		case R_MIPS_REL32:
			if (ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
			    (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
			    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE) ) {
				*(u_int32_t *)r_addr += loff + sym->st_value;
d108 9
a116 1
				*(u_int32_t *)r_addr += this->st_value + ooff;
d124 2
a125 2
			_dl_printf("%s: unsupported relocation '%s'\n",
			    _dl_progname, symn);
d129 8
a136 1

d153 6
a158 6
	Elf32_Addr loff;
	Elf32_Addr ooff;
	Elf32_Addr *gotp;
	Elf32_Addr plt_addr;
	const Elf32_Sym  *symp;
	const Elf32_Sym  *this;
d174 3
a176 3
	gotp[0] = (int)_dl_rt_resolve;
	if (gotp[1] & 0x80000000) {
		gotp[1] = (int)object | 0x80000000;
d180 1
a180 1
	for (i = ((gotp[1] & 0x80000000) ? 2 : 1); i < n; i++) {
d225 1
a225 1
		    ELF32_ST_TYPE(symp->st_info) == STT_FUNC) {
d246 1
a246 1
		} else if (ELF32_ST_TYPE(symp->st_info) == STT_FUNC) {
@

