head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.28
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.27;
commitid	veGB6uLWx3BTEAfk;

1.27
date	2017.01.23.10.30.58;	author guenther;	state Exp;
branches;
next	1.26;
commitid	gelJDihLmdyfb63O;

1.26
date	2016.06.21.15.25.37;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	lRIiUPnkIQNjSTol;

1.25
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.24;
commitid	zGFWeGZdYJxUOZli;

1.24
date	2015.08.23.20.45.14;	author guenther;	state Exp;
branches;
next	1.23;
commitid	bWSDVTHL6DFekj9O;

1.23
date	2015.07.26.03.08.16;	author guenther;	state Exp;
branches;
next	1.22;
commitid	8fZXTItSeA4fJ2hk;

1.22
date	2014.05.25.21.27.07;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.18.04.22.31;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.05.23.20.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.21.23.12.09;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.25.21.42.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.23.20.52.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.10.16.14.11;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.10.14.47.07;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.10.14.30.43;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.10.14.18.14;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.28
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.27 2017/01/23 10:30:58 guenther Exp $ */

/*
 * Copyright (c) 2002,2004 Dale Rahn
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 2000 Eduardo Horvath.
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

/*
 * The following table holds for each relocation type:
 *	- the width in bits of the memory location the relocation
 *	  applies to
 *	- the number of bits the relocation value must be shifted to the
 *	  right (i.e. discard least significant bits) to fit into
 *	  the appropriate field in the instruction word.
 *	- flags indicating whether
 *		* the relocation involves a symbol
 *		* the relocation is relative to the current position
 *		* the relocation is for a GOT entry
 *		* the relocation is relative to the load address
 *
 */
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_E		0x02000000		/* ERROR */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,							/*  0 NONE */
	_RF_S|_RF_A|		_RF_SZ(64) | _RF_RS(0),		/*  1 _64*/
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/*  2 PC32 */
	_RF_G|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/*  3 GOT32 */
	_RF_E|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/*  4 PLT32 */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/*  5 COPY */
	_RF_S|			_RF_SZ(64) | _RF_RS(0),		/*  6 GLOB_DAT*/
	_RF_S|			_RF_SZ(64) | _RF_RS(0),		/* 7 JUMP_SLOT*/
	      _RF_A|	_RF_B|	_RF_SZ(64) | _RF_RS(0),		/*  8 RELATIVE*/
	_RF_E,							/*  9 GOTPCREL*/
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 10 32 */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* 11 32S */
	_RF_S|_RF_A|		_RF_SZ(16) | _RF_RS(0),		/* 12 16 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(16) | _RF_RS(0),		/* 13 PC16 */
	_RF_S|_RF_A|		_RF_SZ(8) | _RF_RS(0),		/* 14 8 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(8) | _RF_RS(0),		/* 15 PC8 */
	_RF_E,							/* 16 DTPMOD64*/
	_RF_E,							/* 17 DTPOFF64*/
	_RF_E,							/* 18 TPOFF64 */
	_RF_E,							/* 19 TLSGD */
	_RF_E,							/* 20 TLSLD */
	_RF_E,							/* 21 DTPOFF32*/
	_RF_E,							/* 22 GOTTPOFF*/
	_RF_E							/* 23 TPOFF32*/
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)
#define RELOC_ERROR(t)			(reloc_target_flags[t] & _RF_E)

static Elf_Addr reloc_target_bitmask[] = {
#define _BM(x)  (~(Elf_Addr)0 >> ((8*sizeof(reloc_target_bitmask[0])) - (x)))
	0,			/*  0 NONE */
	_BM(64),		/*  1 _64*/
	_BM(32),		/*  2 PC32 */
	_BM(32),		/*  3 GOT32 */
	_BM(32),		/*  4 PLT32 */
	0,			/*  5 COPY */
	_BM(64),		/*  6 GLOB_DAT*/
	_BM(64),		/*  7 JUMP_SLOT*/
	_BM(64),		/*  8 RELATIVE*/
	_BM(32),		/*  9 GOTPCREL*/
	_BM(32),		/* 10 32 */
	_BM(32),		/* 11 32S */
	_BM(16),		/* 12 16 */
	_BM(16),		/* 13 PC16 */
	_BM(8),			/* 14 8 */
	_BM(8),			/* 15 PC8 */
	0,			/* 16 DTPMOD64*/
	0,			/* 17 DTPOFF64*/
	0,			/* 18 TPOFF64 */
	0,			/* 19 TLSGD */
	0,			/* 20 TLSLD */
	0,			/* 21 DTPOFF32*/
	0,			/* 22 GOTTPOFF*/
	0			/* 23 TPOFF32*/
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

void _dl_reloc_plt(Elf_Addr *where, Elf_Addr value);

int
_dl_md_reloc(elf_object_t *object, int rel, int relsz)
{
	long	i;
	long	numrel;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_RelA *rels;
	struct load_list *llist;

	loff = object->obj_base;
	numrel = object->Dyn.info[relsz] / sizeof(Elf_RelA);
	relrel = rel == DT_RELA ? object->relacount : 0;
	rels = (Elf_RelA *)(object->Dyn.info[rel]);
	if (rels == NULL)
		return(0);

	if (relrel > numrel)
		_dl_die("relacount > numrel: %ld > %ld", relrel, numrel);

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, rels++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELACOUNT wrong");
#endif
		where = (Elf_Addr *)(rels->r_offset + loff);
		*where = rels->r_addend + loff;
	}
	for (; i < numrel; i++, rels++) {
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(rels->r_info);

		if (RELOC_ERROR(type))
			_dl_die("relocation error %d idx %ld", type, i);

		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JUMP_SLOT) && rel != DT_JMPREL)
			continue;

		where = (Elf_Addr *)(rels->r_offset + loff);

		if (RELOC_USE_ADDEND(type))
			value = rels->r_addend;
		else
			value = 0;

		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(rels->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JUMP_SLOT))?
					SYM_PLT:SYM_NOTPLT),
				    sym, NULL);
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(JUMP_SLOT)) {
			_dl_reloc_plt(where, value);
			continue;
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    dstsym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, dstsym->st_size);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;
		if (RELOC_BASE_RELATIVE(type))
			value += loff;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		if (RELOC_TARGET_SIZE(type) > 32) {
			*where &= ~mask;
			*where |= value;
		} else {
			Elf32_Addr *where32 = (Elf32_Addr *)where;

			*where32 &= ~mask;
			*where32 |= value;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

void
_dl_reloc_plt(Elf_Addr *where, Elf_Addr value)
{
	*where = value;
}

/*
 * Resolve a symbol at run-time.
 */
Elf_Addr
_dl_bind(elf_object_t *object, int index)
{
	Elf_RelA *rel;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr ooff;
	int64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;

	rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]) + index;

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rel->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value + rel->r_addend;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Word *)(object->obj_base + rel->r_offset);
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("rax") = SYS_kbind;
		register void *arg1 __asm("rdi") = &buf;
		register long  arg2 __asm("rsi") = sizeof(buf);
		register long  arg3 __asm("rdx") = cookie;

		__asm volatile("syscall" : "+r" (syscall_num), "+r" (arg3) :
		    "r" (arg1), "r" (arg2) : "cc", "rcx", "r11", "memory");
	}
	return (buf.newval);
}

int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	extern void _dl_bind_start(void);	/* XXX */
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	int i, num;
	Elf_RelA *rel;

	if (pltgot == NULL)
		return (0); /* it is possible to have no PLT/GOT relocations */

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	if (object->traced)
		lazy = 1;

	if (__predict_false(!lazy)) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		pltgot[1] = (Elf_Addr)object;
		pltgot[2] = (Elf_Addr)&_dl_bind_start;

		rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);
		num = (object->Dyn.info[DT_PLTRELSZ]);
		for (i = 0; i < num/sizeof(Elf_RelA); i++, rel++) {
			Elf_Addr *where;
			where = (Elf_Addr *)(rel->r_offset + object->obj_base);
			*where += object->obj_base;
		}
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	return (fails);
}
@


1.27
log
@Fix format string mismatches
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2016/06/21 15:25:37 deraadt Exp $ */
d191 2
a192 4
	if (relrel > numrel) {
		_dl_printf("relacount > numrel: %ld > %ld\n", relrel, numrel);
		_dl_exit(20);
	}
d210 2
a211 4
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELACOUNT wrong\n");
			_dl_exit(20);
		}
d224 2
a225 4
		if (RELOC_ERROR(type)) {
			_dl_printf("relocation error %d idx %ld\n", type, i);
			_dl_exit(20);
		}
d359 2
a360 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.26
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2015/11/02 07:02:53 guenther Exp $ */
d229 1
a229 1
			_dl_printf("relocation error %d idx %d\n", type, i);
@


1.25
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2015/08/23 20:45:14 guenther Exp $ */
d203 1
a203 1
				    llist->prot|PROT_WRITE);
@


1.24
log
@Use kbind for lazy binding GOT/PLT updates on amd64 and sparc64; others
to follow.  While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2015/07/26 03:08:16 guenther Exp $ */
a398 2
	Elf_Addr ooff;
	const Elf_Sym *this;
a402 3
	pltgot[1] = (Elf_Addr)object;
	pltgot[2] = (Elf_Addr)&_dl_bind_start;

a405 22
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}

d412 3
a421 1

d424 2
a425 4
	/* PLT is already RO on amd64, no point in mprotecting it, just GOT */
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
@


1.23
log
@Copy relocations can't be jump-slot relocations, so delete the test for that.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2014/05/25 21:27:07 brad Exp $ */
d70 2
a74 1
#include <signal.h>
d80 2
d85 1
a85 1
 *	  applies to (not currently used)
a100 1
#define _RF_U		0x04000000		/* Unaligned */
a133 1
#define RELOC_UNALIGNED(t)		((reloc_target_flags[t] & _RF_U) != 0)
d310 1
a310 17
		if (RELOC_UNALIGNED(type)) {
			/* Handle unaligned relocations. */
			Elf_Addr tmp = 0;
			char *ptr = (char *)where;
			int i, size = RELOC_TARGET_SIZE(type)/8;

			/* Read it in one byte at a time. */
			for (i=0; i<size; i++)
				tmp = (tmp << 8) | ptr[i];

			tmp &= ~mask;
			tmp |= value;

			/* Write it back out. */
			for (i=0; i<size; i++)
				ptr[i] = ((tmp >> (8*i)) & 0xff);
		} else if (RELOC_TARGET_SIZE(type) > 32) {
a345 1
	Elf_Word *addr;
d349 6
a354 4
	Elf_Addr ooff, newval;
	sigset_t savedmask;

	rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL]);
d356 1
a356 1
	rel += index;
a361 1
	addr = (Elf_Word *)(object->obj_base + rel->r_offset);
d370 1
a370 1
	newval = ooff + this->st_value + rel->r_addend;
d372 2
a373 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return newval;
d375 2
a376 6
	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ|PROT_WRITE);
	}
d378 6
a383 1
	_dl_reloc_plt((Elf_Addr *)addr, newval);
d385 2
a386 5
	/* put the GOT back to RO */
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
d388 1
a388 2

	return(newval);
d436 1
a436 1
	if (!lazy) {
@


1.22
log
@Appease LLVM warnings..

error: shift count >= width of type [-Werror,-Wshift-count-overflow]

Rework the ld.so relocation mask initialization.

Clang complained about the shift code in the old versions
of these, so improve the code.

From drahn Bitrig

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2013/06/13 04:13:47 brad Exp $ */
d290 1
a290 2
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|
			    ((type == R_TYPE(JUMP_SLOT)) ? SYM_PLT:SYM_NOTPLT),
d467 1
a467 1
	/* PLT is already RO on i386, no point in mprotecting it, just GOT */
@


1.21
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2013/06/01 09:57:58 miod Exp $ */
d138 2
a139 2
static long reloc_target_bitmask[] = {
#define _BM(x)  (x == 64? ~0 : ~(-(1UL << (x))))
d145 1
a145 1
	_BM(0),			/*  5 COPY */
@


1.20
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2013/05/08 20:55:14 guenther Exp $ */
d383 1
a383 1
		*((int *)0) = 0;		/* XXX */
@


1.19
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2013/03/18 04:22:31 guenther Exp $ */
d365 1
d380 1
a380 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym,
	    object, NULL);
d388 3
d451 3
@


1.18
log
@Fix comment tpyos
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2012/12/05 23:20:06 deraadt Exp $ */
d175 1
d178 2
d185 1
d190 5
d206 14
a219 1
	for (i = 0; i < numrel; i++, rels++) {
d255 2
d272 3
a274 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.17
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2011/04/06 11:36:25 miod Exp $ */
d119 1
a119 1
	_RF_E,							/* 16 DPTMOD64*/
d156 1
a156 1
	0,			/* 16 DPTMOD64*/
@


1.16
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2010/05/02 04:57:01 guenther Exp $ */
a68 1
#include <sys/cdefs.h>
@


1.15
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2008/04/09 21:45:26 kurt Exp $ */
d402 1
a402 1
	object->got_addr = NULL;
d416 2
a417 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
@


1.14
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2007/11/27 16:42:19 miod Exp $ */
d341 1
a341 1
	sigset_t omask, nmask;
d365 1
a365 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d376 1
a376 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.13
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2007/05/05 15:21:21 drahn Exp $ */
d181 1
a181 1
	loff = object->load_offs;
d351 1
a351 1
	addr = (Elf_Word *)(object->load_offs + rel->r_offset);
d434 2
a435 2
			where = (Elf_Addr *)(rel->r_offset + object->load_offs);
			*where += object->load_offs;
@


1.12
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2006/10/28 16:06:05 drahn Exp $ */
d176 1
a176 1
	long	fails = 0;
d385 1
a385 1
void
d389 1
d397 1
a397 1
		return; /* it is possible to have no PLT/GOT relocations */
d403 1
a403 1
		return;
d428 1
a428 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d444 2
@


1.11
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2005/09/22 01:33:08 drahn Exp $ */
d367 1
d378 1
@


1.10
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2005/09/21 23:12:09 drahn Exp $ */
d190 1
a190 1
	if ((rel == DT_REL || rel == DT_RELA)) {
d313 1
a313 1
	if ((rel == DT_REL || rel == DT_RELA)) {
@


1.9
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2005/09/16 23:19:41 drahn Exp $ */
d244 3
a246 5
					_dl_printf("%s: %s: can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);
					fails++;
@


1.8
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2004/05/25 21:42:47 mickey Exp $ */
d241 1
a241 1
				    sym->st_size, NULL);
a263 1
			size_t size = dstsym->st_size;
d269 1
a269 1
			    size, object, NULL);
d274 1
a274 1
			_dl_bcopy(srcaddr, dstaddr, size);
d356 1
a356 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
d408 1
a408 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
d414 1
a414 1
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object, NULL);
@


1.7
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2004/05/25 18:07:20 mickey Exp $ */
d237 2
a238 2
				    ELF_R_SYM(rels->r_info), _dl_objects,
				    &this,NULL,SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d241 1
a241 1
				    sym->st_size);
d267 2
a268 2
			soff = _dl_find_symbol(symn, object->next, &srcsym,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d270 1
a270 1
			    size, object);
d356 3
a358 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d408 2
a409 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d414 2
a415 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
@


1.6
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2004/02/23 20:52:04 deraadt Exp $ */
a78 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	const unsigned char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.5
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2004/02/10 16:14:11 drahn Exp $ */
d249 1
a249 1
				    &this, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d279 1
a279 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d367 1
a367 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
d418 1
a418 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d424 1
a424 1
	ooff = _dl_find_symbol("__got_end", object, &this,
@


1.4
log
@Fix/enable lazy binding on amd64 ld.so
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2004/02/10 14:47:07 drahn Exp $ */
d221 1
a221 1
			
d371 1
a371 1
		*((int *)0) = 0;        /* XXX */
d399 1
a399 1
	extern void _dl_bind_start(void);       /* XXX */
@


1.3
log
@Disable lazy binding for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2004/02/10 14:30:43 drahn Exp $ */
a230 1
#if 1
a231 3
#else
			value = *where & RELOC_VALUE_BITMASK(type);
#endif
a337 10
#if 0
struct jmpslot {
	u_short opcode;
	u_short addr[2];
	u_short reloc_index;
#define JMPSLOT_RELOC_MASK              0xffff
};
#define JUMP    0xe990          /* NOP + JMP opcode */
#endif

d350 1
a350 1
	Elf_Rel *rel;
d354 1
a354 1
	Elf_Addr ooff;
d357 1
a357 1
	rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);
d359 1
a359 1
	rel += index/sizeof(Elf_Rel);
d374 2
d384 1
a384 1
	_dl_reloc_plt((Elf_Addr *)addr, ooff + this->st_value);
d393 1
a393 1
	return((Elf_Addr)ooff + this->st_value);
a395 3
/*/
#define LAZY_BINDING_WORKS
 */
a400 1
#ifdef LAZY_BINDING_WORKS
a402 1
#endif
a436 1
#ifdef LAZY_BINDING_WORKS
a437 1
#endif
a438 1
#ifdef LAZY_BINDING_WORKS
d445 1
a445 1
			*where = object->load_offs + rel->r_addend;
d449 1
a449 1
#endif
@


1.2
log
@sync with reloc.h change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2004/02/10 14:18:14 drahn Exp $ */
d408 3
d416 1
d419 1
d454 1
d456 1
d458 1
d469 1
@


1.1
log
@AMD64 dynamic linker. initial work by mickey finished up by myself.
lazy binding not working yet. problem exists with gcc and -fpic jump tables.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2003/09/04 19:37:07 drahn Exp $ */
a180 2

#define R_TYPE(x) R_X86_64_ ## x
@

