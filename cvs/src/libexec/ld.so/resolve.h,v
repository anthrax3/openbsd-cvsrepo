head	1.82;
access;
symbols
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.70.0.6
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.69.0.2
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.65.0.6
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.4
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.2
	OPENBSD_5_0:1.64.0.2
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.60.0.2
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.57.0.6
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.57.0.8
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.4
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.52.0.4
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	r20000612:1.1.1.2
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2017.01.22.01.20.36;	author guenther;	state Exp;
branches;
next	1.81;
commitid	uadpoy0GKiB9Exf8;

1.81
date	2016.08.30.12.47.19;	author kettenis;	state Exp;
branches;
next	1.80;
commitid	D3G7AWKOOzp9QFfJ;

1.80
date	2016.08.23.06.46.17;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	77WGwq23vMDU6RQE;

1.79
date	2016.08.08.21.59.20;	author guenther;	state Exp;
branches;
next	1.78;
commitid	PufSD0ERJAhj0Sd1;

1.78
date	2016.07.04.21.15.06;	author guenther;	state Exp;
branches;
next	1.77;
commitid	qHDzpShMNCJZKLBF;

1.77
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.76;
commitid	d9R7VGw9CHTkwXE1;

1.76
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.75;
commitid	Kpc3J4Ry51yjfQid;

1.75
date	2016.01.24.03.54.34;	author guenther;	state Exp;
branches;
next	1.74;
commitid	dUhNJfxOdkXUgGnA;

1.74
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.73;
commitid	zGFWeGZdYJxUOZli;

1.73
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.72;
commitid	FcRQ6g8MqXiORdFs;

1.72
date	2015.08.17.20.04.56;	author guenther;	state Exp;
branches;
next	1.71;
commitid	0ICQ0HNJ87JYgWIz;

1.71
date	2015.01.22.05.48.17;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	GZoxg3rKKQGZ5hZT;

1.70
date	2013.11.13.05.41.42;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2013.06.01.09.57.55;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.20.21.49.59;	author kurt;	state Exp;
branches;
next	1.65;

1.65
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.27.16.47.50;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2011.05.22.22.43.47;	author drahn;	state Exp;
branches;
next	1.62;

1.62
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.11.01.14.27;	author drahn;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.01.19.25.44;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2010.03.27.20.16.15;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.27.16.42.15;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.03.14.33.07;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.16.21.34.53;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.09.16.41.29;	author kurt;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.16.04.14.22;	author kurt;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.07.01.26.34;	author kurt;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.06.22.01.58;	author kurt;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.28.20.35.23;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.28.18.17.42;	author kurt;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.28.15.41.06;	author drahn;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.22.22.33.40;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.21.23.12.09;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.17.03.02.37;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.23.19.48.05;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.11.19.14.56;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.05.00.47.40;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.04.19.33.48;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.06.20.03.57;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.30.01.13.53;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.17.03.40.45;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.15.22.39.13;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.30.03.46.46;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.18.19.20.01;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.24.04.11.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.24.04.00.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.24.00.13.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.07.03.00.56;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.05.19.34.44;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.17.00.22.04;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.26.09.16.42;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.06.12.31.52;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.16.03.21.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.02.23.11.21;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.30.01.35.21;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.34.09;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.34.09;	author rahnds;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.06.13.03.40.10;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Add support for DT_RUNPATH and DT_FLAGS

ok kettenis@@
@
text
@/*	$OpenBSD: resolve.h,v 1.81 2016/08/30 12:47:19 kettenis Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _RESOLVE_H_
#define _RESOLVE_H_

#include <sys/queue.h>
#include <link.h>
#include <dlfcn.h>

/* Number of low tags that are used saved internally (0 .. DT_NUM-1) */
#define DT_NUM	(DT_PREINIT_ARRAYSZ + 1)

struct load_list {
	struct load_list *next;
	void		*start;
	size_t		size;
	int		prot;
	Elf_Addr	moff;
	long		foff;
};

/*
 *  Structure describing a loaded object.
 *  The head of this struct must be compatible
 *  with struct link_map in sys/link.h
 */
typedef struct elf_object elf_object_t;
struct elf_object {
	Elf_Addr obj_base;		/* object's address '0' base */
	char	*load_name;		/* Pointer to object name */
	Elf_Dyn *load_dyn;		/* Pointer to object dynamic data */
	struct elf_object *next;
	struct elf_object *prev;
/* End struct link_map compatible */
	Elf_Addr load_base;		/* Base address of loadable segments */

	struct load_list *load_list;

	u_int32_t  load_size;

	union {
		u_long		info[DT_NUM + DT_PROCNUM];
		struct {
			Elf_Addr	null;		/* Not used */
			Elf_Addr	needed;		/* Not used */
			Elf_Addr	pltrelsz;
			Elf_Addr	*pltgot;
			Elf_Addr	*hash;
			const char	*strtab;
			const Elf_Sym	*symtab;
			Elf_RelA	*rela;
			Elf_Addr	relasz;
			Elf_Addr	relaent;
			Elf_Addr	strsz;
			Elf_Addr	syment;
			void		(*init)(void);
			void		(*fini)(void);
			const char	*soname;
			const char	*rpath;
			Elf_Addr	symbolic;
			Elf_Rel		*rel;
			Elf_Addr	relsz;
			Elf_Addr	relent;
			Elf_Addr	pltrel;
			Elf_Addr	debug;
			Elf_Addr	textrel;
			Elf_Addr	jmprel;
			Elf_Addr	bind_now;
			void		(**init_array)(void);
			void		(**fini_array)(void);
			Elf_Addr	init_arraysz;
			Elf_Addr	fini_arraysz;
			const char	*runpath;
			Elf_Addr	flags;
			Elf_Addr	encoding;
			void		(**preinit_array)(void);
			Elf_Addr	preinit_arraysz;
		} u;
	} Dyn;
#define dyn Dyn.u

	Elf_Addr	relacount;	/* DT_RELACOUNT */
	Elf_Addr	relcount;	/* DT_RELCOUNT */

	int		status;
#define	STAT_RELOC_DONE	0x01
#define	STAT_GOT_DONE	0x02
#define	STAT_INIT_DONE	0x04
#define	STAT_FINI_DONE	0x08
#define	STAT_FINI_READY	0x10
#define	STAT_UNLOADED	0x20
#define	STAT_NODELETE	0x40
#define	STAT_VISITED	0x80

	Elf_Phdr	*phdrp;
	int		phdrc;

	int		obj_type;
#define	OBJTYPE_LDR	1
#define	OBJTYPE_EXE	2
#define	OBJTYPE_LIB	3
#define	OBJTYPE_DLO	4
	int		obj_flags;	/* c.f. <sys/exec_elf.h> DF_1_* */

	Elf_Word	*buckets;
	u_int32_t	nbuckets;
	Elf_Word	*chains;
	u_int32_t	nchains;
	Elf_Dyn		*dynamic;

	TAILQ_HEAD(,dep_node)	child_list;	/* direct dep libs of object */
	TAILQ_HEAD(,dep_node)	grpsym_list;	/* ordered complete dep list */
	TAILQ_HEAD(,dep_node)	grpref_list;	/* refs to other load groups */

	int		refcount;	/* dep libs only */
	int		opencount;	/* # dlopen() & exe */
	int		grprefcount;	/* load group refs */
#define OBJECT_REF_CNT(object) \
    ((object->refcount + object->opencount + object->grprefcount))
#define OBJECT_DLREF_CNT(object) \
    ((object->opencount + object->grprefcount))

	/* object that caused this module to be loaded, used in symbol lookup */
	elf_object_t	*load_object;
	struct sod	sod;

	/* for object confirmation */
	dev_t	dev;
	ino_t inode;

	/* thread local storage info */
	Elf_Addr	tls_fsize;
	Elf_Addr	tls_msize;
	Elf_Addr	tls_align;
	const void	*tls_static_data;
	int		tls_offset;

	/* relro bits */
	Elf_Addr	relro_addr;
	Elf_Addr	relro_size;

	/* generation number of last grpsym insert on this object */
	unsigned int grpsym_gen;

	char **rpath;
	char **runpath;

	/* nonzero if trace enabled for this object */
	int traced;
};

struct dep_node {
	TAILQ_ENTRY(dep_node) next_sib;
	elf_object_t *data;
};


/* Please don't rename or make hidden; gdb(1) knows about these. */
Elf_Addr _dl_bind(elf_object_t *object, int index);
void	_dl_debug_state(void);

/* exported to the application */
extern char *__progname;

__BEGIN_HIDDEN_DECLS
void _dl_add_object(elf_object_t *object);
elf_object_t *_dl_finalize_object(const char *objname, Elf_Dyn *dynp,
    Elf_Phdr *phdrp, int phdrc, const int objtype, const long lbase,
    const long obase);
void	_dl_remove_object(elf_object_t *object);
void	_dl_cleanup_objects(void);
void	*_dl_protect_segment(elf_object_t *_object, Elf_Addr _addr,
	    const char *_start_sym, const char *_end_sym, int _prot);

elf_object_t *_dl_load_shlib(const char *, elf_object_t *, int, int);
elf_object_t *_dl_tryload_shlib(const char *libname, int type, int flags);

int _dl_md_reloc(elf_object_t *object, int rel, int relsz);
int _dl_md_reloc_got(elf_object_t *object, int lazy);

Elf_Addr _dl_find_symbol(const char *name, const Elf_Sym **this,
    int flags, const Elf_Sym *ref_sym, elf_object_t *object,
    const elf_object_t **pobj);
Elf_Addr _dl_find_symbol_bysym(elf_object_t *req_obj, unsigned int symidx,
    const Elf_Sym **ref, int flags, const Elf_Sym *ref_sym,
    const elf_object_t **pobj);
/*
 * defines for _dl_find_symbol() flag field, three bits of meaning
 * myself	- clear: search all objects,	set: search only this object
 * warnnotfound - clear: no warning,		set: warn if not found
 * inplt	- clear: possible plt ref	set: real matching function.
 *
 * inplt - due to how ELF handles function addresses in shared libraries
 * &func may actually refer to the plt entry in the main program
 * rather than the actual function address in the .so file.
 * This rather bizarre behavior is documented in the SVR4 ABI.
 * when getting the function address to relocate a PLT entry
 * the 'real' function address is necessary, not the possible PLT address.
 */
/* myself */
#define SYM_SEARCH_ALL		0x00
#define SYM_SEARCH_SELF		0x01
#define SYM_SEARCH_OTHER	0x02
#define SYM_SEARCH_NEXT		0x04
#define SYM_SEARCH_OBJ		0x08
/* warnnotfound */
#define SYM_NOWARNNOTFOUND	0x00
#define SYM_WARNNOTFOUND	0x10
/* inplt */
#define SYM_NOTPLT		0x00
#define SYM_PLT			0x20

#define SYM_DLSYM		0x40

int _dl_load_dep_libs(elf_object_t *object, int flags, int booting);
int _dl_rtld(elf_object_t *object);
void _dl_call_init(elf_object_t *object);
void _dl_link_child(elf_object_t *dep, elf_object_t *p);
void _dl_link_grpsym(elf_object_t *object, int checklist);
void _dl_cache_grpsym_list(elf_object_t *object);
void _dl_cache_grpsym_list_setup(elf_object_t *object);
void _dl_link_grpref(elf_object_t *load_group, elf_object_t *load_object);
void _dl_link_dlopen(elf_object_t *dep);
void _dl_unlink_dlopen(elf_object_t *dep);
void _dl_notify_unload_shlib(elf_object_t *object);
void _dl_unload_shlib(elf_object_t *object);
void _dl_unload_dlopen(void);

void _dl_run_all_dtors(void);

int	_dl_match_file(struct sod *sodp, const char *name, int namelen);
char	*_dl_find_shlib(struct sod *sodp, char **searchpath, int nohints);
void	_dl_load_list_free(struct load_list *load_list);

void	_dl_thread_kern_go(void);
void	_dl_thread_kern_stop(void);

char	*_dl_getenv(const char *, char **);
void	_dl_unsetenv(const char *, char **);

void	_dl_trace_setup(char **);
void	_dl_trace_object_setup(elf_object_t *);
int	_dl_trace_plt(const elf_object_t *, const char *);

/* tib.c */
void	_dl_allocate_tls_offsets(void);
void	_dl_allocate_first_tib(void);
void	_dl_set_tls(elf_object_t *_object, Elf_Phdr *_ptls, Elf_Addr _libaddr,
	    const char *_libname);
extern int _dl_tib_static_done;

extern elf_object_t *_dl_objects;
extern elf_object_t *_dl_last_object;

extern elf_object_t *_dl_loading_object;

extern struct r_debug *_dl_debug_map;

extern int  _dl_pagesz;
extern int  _dl_errno;

extern char **_dl_libpath;

extern char *_dl_preload;
extern char *_dl_bindnow;
extern char *_dl_traceld;
extern char *_dl_tracefmt1;
extern char *_dl_tracefmt2;
extern char *_dl_traceprog;
extern char *_dl_debug;

extern int _dl_trust;

#define DL_DEB(P) do { if (_dl_debug) _dl_printf P ; } while (0)

#define	DL_NOT_FOUND		1
#define	DL_CANT_OPEN		2
#define	DL_NOT_ELF		3
#define	DL_CANT_OPEN_REF	4
#define	DL_CANT_MMAP		5
#define	DL_NO_SYMBOL		6
#define	DL_INVALID_HANDLE	7
#define	DL_INVALID_CTL		8
#define	DL_NO_OBJECT		9
#define	DL_CANT_FIND_OBJ	10
#define	DL_CANT_LOAD_OBJ	11
#define	DL_INVALID_MODE		12

#define ELF_ROUND(x,malign) (((x) + (malign)-1) & ~((malign)-1))
#define ELF_TRUNC(x,malign) ((x) & ~((malign)-1))

/* symbol lookup cache */
typedef struct sym_cache {
	const elf_object_t *obj;
	const Elf_Sym	*sym;
	int flags;
} sym_cache;

extern sym_cache *_dl_symcache;
extern int _dl_symcachestat_hits;
extern int _dl_symcachestat_lookups;
TAILQ_HEAD(dlochld, dep_node);
extern struct dlochld _dlopened_child_list;
__END_HIDDEN_DECLS

#endif /* _RESOLVE_H_ */
@


1.81
log
@Move DT_NUM from <sys/exec_elf.h> to resolv.h in ld.so where it belongs.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.80 2016/08/23 06:46:17 kettenis Exp $ */
d172 1
@


1.80
log
@Implement support for DT_INIT_ARRAY, DT_FINI_ARRAY and DT_PREINIT_ARRAY.
Don't skip DT_INIT and DT_FINI for the main executable.  This matches what
Linux and Solaris do.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.79 2016/08/08 21:59:20 guenther Exp $ */
d35 3
@


1.79
log
@Look for a PT_GNU_RELRO section per object and, if present, mprotect that
range instead of the [__got_start, __got_end) range.
On many archs this will cover _DYNAMIC too, so move up the DT_DEBUG handling
to before relocations and the mprotect are done.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.78 2016/07/04 21:15:06 guenther Exp $ */
d84 1
a84 1
			Elf_Rel	*rel;
d91 10
@


1.78
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.77 2016/05/07 19:05:23 guenther Exp $ */
d150 4
@


1.77
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.76 2016/03/20 02:29:51 guenther Exp $ */
a138 2

	void *prebind_data;
@


1.76
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.75 2016/01/24 03:54:34 guenther Exp $ */
d146 7
d254 7
@


1.75
log
@Delete remnants of grpsym cache setting during symbol search: it's done at
load time only nwo.  Rename _dl_searchnum and lastlookup to _dl_grpsym_gen
and grpsym_gen as they are generation numbers.  Merge _dl_newsymsearch()
into _dl_cache_grpsym_list_setup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.74 2015/11/02 07:02:53 guenther Exp $ */
d160 9
a233 3
/* Please don't rename; gdb(1) knows about this. */
Elf_Addr _dl_bind(elf_object_t *object, int index);

a236 1
void	_dl_debug_state(void);
a252 1
extern const char *_dl_progname;
d300 1
@


1.74
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.73 2015/09/19 20:56:47 guenther Exp $ */
d146 2
a147 3
	/* last symbol lookup on this object, to avoid mutiple searches */
	int lastlookup_head;
	int lastlookup;
a295 5

/* variables used to avoid duplicate node checking */
extern int _dl_searchnum;
extern uint32_t _dl_skipnum;
void _dl_newsymsearch(void);
@


1.73
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.72 2015/08/17 20:04:56 guenther Exp $ */
a62 5
	Elf_Addr	got_addr;
	Elf_Addr	got_start;
	size_t		got_size;
	Elf_Addr	plt_start;
	size_t		plt_size;
d167 2
@


1.72
log
@Add missing 'extern's to avoid introducing commons into *crt0.o

ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.71 2015/01/22 05:48:17 deraadt Exp $ */
a34 1
#include <signal.h>
a238 2

void	_dl_thread_bind_lock(int, sigset_t *);
@


1.71
log
@delete annoying white space that annoy
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.70 2013/11/13 05:41:42 deraadt Exp $ */
d305 2
a306 2
int _dl_searchnum;
uint32_t _dl_skipnum;
@


1.70
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.69 2013/06/01 09:57:55 miod Exp $ */
d144 1
a144 1
	struct sod      sod;
@


1.69
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.68 2013/05/08 20:55:14 guenther Exp $ */
d236 1
@


1.68
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.67 2013/04/05 12:58:03 kurt Exp $ */
d157 3
d241 7
@


1.67
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.66 2013/03/20 21:49:59 kurt Exp $ */
d100 3
@


1.66
log
@- Parse colon separated paths into NULL terminated arrays of string
pointers to prepare for adding rpath ORIGIN support.
okay matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.65 2011/11/28 20:59:03 guenther Exp $ */
d256 2
@


1.65
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.64 2011/06/27 16:47:50 sthen Exp $ */
d152 2
d228 1
a228 1
char	*_dl_find_shlib(struct sod *sodp, const char *searchpath, int nohints);
d247 2
a248 1
extern char *_dl_libpath;
@


1.64
log
@Backout the dynamic linker speed improvement diff for now, it still
has some issues. Discussed with various, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.62 2010/10/25 20:34:44 kurt Exp $ */
d108 2
d119 1
a119 1
	int		obj_flags;
d267 1
@


1.63
log
@Dynamic linker speed improvement diff. tested by several sinc k2k11.
get it in tree now deraadt@@, ok by several ports folks. Thanks for the testing.
@
text
@a45 3
TAILQ_HEAD(dep_node_head, dep_node);
extern struct dep_node_head _dlsym_search_list;

a117 1
	int		obj_global;
d125 3
a127 3
	struct dep_node_head	child_list;	/* direct dep libs of object */
	struct dep_node_head	grpsym_list;	/* ordered complete dep list */
	struct dep_node_head	grpref_list;	/* refs to other load groups */
a235 1
void _dl_append_search(elf_object_t *object);
a280 1
extern int _dl_search_list_valid;
@


1.62
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.61 2010/08/11 01:14:27 drahn Exp $ */
d46 3
d121 1
d129 3
a131 3
	TAILQ_HEAD(,dep_node)	child_list;	/* direct dep libs of object */
	TAILQ_HEAD(,dep_node)	grpsym_list;	/* ordered complete dep list */
	TAILQ_HEAD(,dep_node)	grpref_list;	/* refs to other load groups */
d240 1
d286 1
@


1.61
log
@Make _dl_searchnum signed as originally intended.
Pointed out by patrick keshish.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.60 2010/07/01 19:25:44 drahn Exp $ */
d139 1
a163 1
elf_object_t *_dl_lookup_object(const char *objname);
d223 1
a223 1
int	_dl_match_file(struct sod *sodp, char *name, int namelen);
@


1.60
log
@When generating grpsym lists, avoid duplicates without searching the
already generated list. Speeds up startup on deeply nested dlopen binaries.
ok guenther@@, tested by ckuethe@@ and ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.59 2010/05/02 04:57:01 guenther Exp $ */
d283 1
a283 1
uint32_t _dl_searchnum;
@


1.59
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.58 2010/03/27 20:16:15 kettenis Exp $ */
d145 4
d208 1
a208 1
void _dl_link_grpsym(elf_object_t *object);
d210 1
d282 4
@


1.58
log
@Implement lazy binding on mips64.  This implementation relies on having two
reserved entries in the GOT, which is a GNU extension to the 64-bit MIPS
SVR4 ABI.  That's fine; all existing OpenBSD/mips64 binaries have the extra
slot.

ok miod@@, jsing@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.57 2008/05/05 02:29:02 kurt Exp $ */
d35 1
d225 1
a225 1
void	_dl_thread_bind_lock(int);
@


1.57
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.56 2008/04/09 21:45:26 kurt Exp $ */
a149 2

void _dl_rt_resolve(void);
@


1.56
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.55 2007/11/27 16:42:15 miod Exp $ */
d155 2
a156 1
    const long *, const int objtype, const long lbase, const long obase);
@


1.55
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.54 2007/05/05 15:21:21 drahn Exp $ */
d52 1
a52 1
	Elf_Addr load_addr;		/* Real load address */
d58 1
a58 1
	Elf_Addr load_offs;		/* Load offset from link address */
d155 1
a155 1
    const long *, const int objtype, const long laddr, const long loff);
@


1.54
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.53 2007/04/03 14:33:07 jason Exp $ */
d163 2
a164 2
int  _dl_md_reloc(elf_object_t *object, int rel, int relsz);
void _dl_md_reloc_got(elf_object_t *object, int lazy);
@


1.53
log
@add support for LD_TRACE_LOADED_OBJECTS_{FMT1/FMT2/PROGNAME}.  Functionality
matches and expands on the old a.out ld.so formatting.  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.52 2006/06/16 21:34:53 kettenis Exp $ */
d224 2
@


1.52
log
@Add comment warning not to rename _dl_bind, since gdb(1) knows about it.
ok (quite a while ago) drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.51 2006/05/03 16:10:51 drahn Exp $ */
d240 3
@


1.51
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.50 2005/11/09 16:41:29 kurt Exp $ */
d215 1
@


1.50
log
@add RTLD_NOW support to dlopen and propogate -z now to dep libs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.49 2005/10/16 04:14:22 kurt Exp $ */
d138 2
@


1.49
log
@Consolidate dl_boot and dlopen dep lib loading into new function
_dl_load_dep_libs. Now both dl_boot and dlopen will randomize dep lib
loading, where previously only dl_boot did.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.48 2005/10/12 20:36:16 kurt Exp $ */
a95 1
			Elf_Addr	bind_now;
@


1.48
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.47 2005/10/09 04:29:13 kurt Exp $ */
d199 1
@


1.47
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.46 2005/10/07 01:26:34 kurt Exp $ */
d201 3
a203 1
void _dl_link_sub(elf_object_t *dep, elf_object_t *p);
@


1.46
log
@rename dload_list to grpsym_list which better represents its usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.45 2005/10/06 22:01:58 kurt Exp $ */
d132 4
@


1.45
log
@remove dep_next "shadow object" dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.44 2005/10/06 21:53:10 kurt Exp $ */
d125 2
a126 2
	TAILQ_HEAD(,dep_node)	child_list;
	TAILQ_HEAD(,dep_node)	dload_list;
@


1.44
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.43 2005/09/28 20:35:23 drahn Exp $ */
a99 2

	struct elf_object *dep_next;	/* Shadow objects for resolve search */
@


1.43
log
@keep a state flag if a library has been unloaded, and then free the list
seperately ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.42 2005/09/28 18:17:42 kurt Exp $ */
a113 1
	int		refcount;
d129 1
d131 3
a133 1
	int opencount;			/* # dlopen() */
d200 1
a206 1
void _dl_run_dtors(elf_object_t *object);
@


1.42
log
@remove _dl_exiting dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.41 2005/09/28 15:41:06 drahn Exp $ */
d109 1
d152 1
@


1.41
log
@keep track of opencounts for dlopened objects, so that they
get unloaded the right number of times on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.40 2005/09/22 22:33:40 drahn Exp $ */
a223 1
extern int  _dl_exiting;
@


1.40
log
@Track if symbols are searched but missing while resolving GOT, if
any are missing exit instead of later causing an abort, ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.39 2005/09/21 23:12:09 drahn Exp $ */
d129 2
@


1.39
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.38 2005/09/17 03:02:37 drahn Exp $ */
d191 1
a191 1
void _dl_rtld(elf_object_t *object);
@


1.38
log
@Cleanly handle the case where a dynamic object is opened, but one of it's
dependant libraries is missing. return NULL for a handle instead of
causing the program to exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.37 2005/09/16 23:19:41 drahn Exp $ */
d157 3
a159 2
Elf_Addr _dl_find_symbol(const char *name, const Elf_Sym **ref,
    int flags, int sym_size, elf_object_t *object, const elf_object_t **pobj);
d161 2
a162 1
    const Elf_Sym **ref, int flags, int req_size, const elf_object_t **pobj);
@


1.37
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.36 2005/05/10 03:36:07 drahn Exp $ */
d240 1
@


1.36
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.35 2005/04/06 00:16:53 deraadt Exp $ */
d32 1
d50 2
a51 1
typedef struct elf_object {
d127 5
a131 2
	struct dep_node *first_child;
	struct dep_node *last_child;
d136 1
a136 1
} elf_object_t;
d139 1
a139 1
	struct dep_node *next_sibling;
d143 1
a143 1
extern void _dl_rt_resolve(void);
d146 13
a158 15
extern elf_object_t *_dl_finalize_object(const char *objname, Elf_Dyn *dynp,
    const u_long *, const int objtype, const long laddr, const long loff);
extern void	_dl_remove_object(elf_object_t *object);

extern elf_object_t *_dl_lookup_object(const char *objname);
extern elf_object_t *_dl_load_shlib(const char *, elf_object_t *, int, int);
extern void	_dl_unload_shlib(elf_object_t *object);
elf_object_t *_dl_tryload_shlib(const char *libname, int type);

extern int  _dl_md_reloc(elf_object_t *object, int rel, int relsz);
extern void _dl_md_reloc_got(elf_object_t *object, int lazy);

Elf_Addr _dl_find_symbol(const char *name, elf_object_t *startlook,
    const Elf_Sym **ref, const elf_object_t **pobj,
    int flags, int sym_size, elf_object_t *object);
d160 1
a160 2
    elf_object_t *startlook, const Elf_Sym **ref, const elf_object_t **pobj,
    int flags, int req_size);
d175 5
a179 2
#define SYM_SEARCH_ALL		0
#define SYM_SEARCH_SELF		1
d181 2
a182 2
#define SYM_NOWARNNOTFOUND	0
#define SYM_WARNNOTFOUND	2
d184 4
a187 2
#define SYM_NOTPLT		0
#define SYM_PLT			4
d195 1
d213 2
d252 5
@


1.35
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.33 2005/03/23 19:48:05 drahn Exp $ */
d102 5
a106 3
#define	STAT_RELOC_DONE	1
#define	STAT_GOT_DONE	2
#define	STAT_INIT_DONE	4
d123 1
a123 1
	Elf_Dyn	*dynamic;
d185 4
d191 1
d199 3
d210 1
@


1.34
log
@Do a better job of running destructors in the right order.
@
text
@d102 3
a104 5
#define	STAT_RELOC_DONE	0x01
#define	STAT_GOT_DONE	0x02
#define	STAT_INIT_DONE	0x04
#define	STAT_FINI_DONE	0x08
#define	STAT_FINI_READY	0x10
d121 1
a121 1
	Elf_Dyn		*dynamic;
a182 4
void _dl_link_dlopen(elf_object_t *dep);
void _dl_unlink_dlopen(elf_object_t *dep);
void _dl_notify_unload_shlib(elf_object_t *object);
void _dl_unload_dlopen(void);
a184 1
void _dl_run_all_dtors(void);
a191 3
void	_dl_thread_kern_go(void);
void	_dl_thread_kern_stop(void);

a199 1
extern int  _dl_exiting;
@


1.33
log
@Code reorganization, move copied code in library.c and library_mquery.c
into its own file. no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.32 2004/08/11 19:14:56 drahn Exp $ */
d102 5
a106 3
#define	STAT_RELOC_DONE	1
#define	STAT_GOT_DONE	2
#define	STAT_INIT_DONE	4
d123 1
a123 1
	Elf_Dyn	*dynamic;
d185 4
d191 1
d199 3
d210 1
@


1.32
log
@add dladdr() support and add some 'standard' dlsym() support.
ok millert miod pval, grumble deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.31 2004/07/05 00:47:40 kjell Exp $ */
d146 1
@


1.31
log
@Fix an issue where a shared library could be loaded at two different
locations by resolving all dlopens back to a dev/inode.

i.e. Don't load a library if the dev/inode it stats back to matches one
already in our list.

fix started (and ok'ed) drahn@@. ok deraadt@@.
"doesn't break anything yet" pval@@ art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.30 2004/05/25 18:07:20 mickey Exp $ */
d216 2
@


1.30
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.29 2003/09/04 19:33:48 drahn Exp $ */
d125 4
@


1.29
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.28 2003/09/02 15:17:51 drahn Exp $ */
d147 2
a148 1
    const Elf_Sym **ref, int flags, int sym_size, elf_object_t *object);
d150 2
a151 1
    elf_object_t *startlook, const Elf_Sym **ref, int flags, int req_size);
d218 1
a219 1
	Elf_Addr	offset;
@


1.28
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.27 2003/07/06 20:03:57 deraadt Exp $ */
d148 2
d213 9
@


1.27
log
@various proto, ansi, and knf repair.  tested on all architectures that
use it. (build may require make cleandir because of .depend balony)
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.26 2003/06/22 21:39:01 drahn Exp $ */
d33 1
d115 1
d140 1
a140 1
extern elf_object_t *_dl_load_shlib(const char *, elf_object_t *, int);
d147 1
a147 1
    const Elf_Sym **ref, int flags, int sym_size, const char *module_name);
@


1.26
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.25 2003/06/09 16:10:03 deraadt Exp $ */
d172 8
@


1.25
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.24 2003/05/30 01:13:53 drahn Exp $ */
d132 3
a134 3
extern elf_object_t *_dl_add_object(const char *objname, Elf_Dyn *dynp,
	    const u_long *, const int objtype,
	    const long laddr, const long loff);
@


1.24
log
@When loading a shared object or libraries dependant object, load them
in random order. This will reduce the possiblity of a buffer overflow
being able to predict the addresss of useful code. Can be disabled
with the LD_NORANDOM environment variable for debugging purposes.
ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.23 2003/04/17 03:40:45 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@mquery support, currently for i386 only.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.22 2003/02/15 22:39:13 drahn Exp $ */
d177 1
@


1.22
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.21 2003/02/02 16:57:58 deraadt Exp $ */
d42 5
a46 3
	char	*start;
	size_t	size;
	int	prot;
@


1.21
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.20 2003/01/30 03:46:46 drahn Exp $ */
d65 1
d67 1
a67 1
	Elf_Addr	plt_addr;
d201 3
@


1.20
log
@Change the constructor execution order to initialize dependant libraries
first. This mirrors the commit espie put in a.out ld.so recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.19 2002/12/18 19:20:01 drahn Exp $ */
d151 2
a152 2
 * myself 	- clear: search all objects,	set: search only this object
 * warnnotfound - clear: no warning, 		set: warn if not found
@


1.19
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.18 2002/11/14 15:15:54 drahn Exp $ */
d124 2
d127 5
@


1.18
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.17 2002/08/23 22:57:03 drahn Exp $ */
d64 4
@


1.17
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.16 2002/08/11 16:51:04 drahn Exp $ */
d137 1
a137 1
    const Elf_Sym **ref, int flags, int sym_size);
@


1.16
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.15 2002/07/24 04:11:10 deraadt Exp $ */
d137 23
a159 1
	    const Elf_Sym **ref, int myself, int warnnotfound, int inplt);
@


1.15
log
@ok i found it
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.13 2002/07/24 00:13:55 deraadt Exp $ */
d137 1
a137 1
	    const Elf_Sym **ref, int myself, int warnnotfound);
@


1.14
log
@back out broken stuff until it is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.12 2002/06/07 03:00:56 art Exp $ */
d125 2
a126 2
				    const u_long *, const int objtype,
				    const long laddr, const long loff);
d137 1
a137 1
			const Elf_Sym **ref, int myself, int warnnotfound);
@


1.13
log
@make more _dl_*() func params like real ones in libc
@
text
@d125 2
a126 2
	    const u_long *, const int objtype,
	    const long laddr, const long loff);
d137 1
a137 1
	    const Elf_Sym **ref, int myself, int warnnotfound);
@


1.12
log
@move load_offs out of the link_map area.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.11 2002/06/05 19:34:44 art Exp $ */
d125 2
a126 2
				    const u_long *, const int objtype,
				    const long laddr, const long loff);
d137 1
a137 1
			const Elf_Sym **ref, int myself, int warnnotfound);
@


1.11
log
@Get rid of an unnecessary typedef (for future cleanup).
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.10 2002/05/24 04:17:00 deraadt Exp $ */
a53 1
	Elf_Addr load_offs;		/* Load offset from link address */
d59 1
@


1.10
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.9 2002/05/24 03:44:37 deraadt Exp $ */
d40 1
a40 1
typedef struct load_list {
d45 1
a45 1
} load_list_t;
d61 1
a61 1
	load_list_t *load_list;
@


1.9
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.8 2002/03/17 00:22:04 art Exp $ */
d42 3
a44 3
	char       *start;
	size_t     size;
	int        prot;
d55 2
a56 2
	char	   *load_name;		/* Pointer to object name */
	Elf_Dyn  *load_dyn;		/* Pointer to object dynamic data */
d127 1
a127 1
extern void         _dl_remove_object(elf_object_t *object);
d131 1
a131 1
extern void         _dl_unload_shlib(elf_object_t *object);
@


1.8
log
@Clean up the zapping of bad variables. Instead of implementing
_dl_suid_ok, just use the issetugid syscall.
ok drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.7 2002/02/21 23:17:53 drahn Exp $ */
d5 1
a5 1
 * 
@


1.7
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.6 2001/09/26 09:16:42 art Exp $ */
a148 1
extern int  _dl_trusted;
@


1.6
log
@Adapt to Elf_Word change.
XXX - Dyn.u should just go away.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.5 2001/06/06 12:31:52 art Exp $ */
a137 3

void * _dl_malloc(const int size);
void  _dl_free(void *);
@


1.5
log
@Replace all 'if (_dl_debug) _dl_printf(...)' with a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.4 2001/05/16 03:21:23 deraadt Exp $ */
d68 5
a72 5
			Elf_Word	null;		/* Not used */
			Elf_Word	needed;		/* Not used */
			Elf_Word	pltrelsz;
			Elf_Word	*pltgot;
			Elf_Word	*hash;
d76 4
a79 4
			Elf_Word	relasz;
			Elf_Word	relaent;
			Elf_Word	strsz;
			Elf_Word	syment;
d84 1
a84 1
			Elf_Word	symbolic;
d86 7
a92 7
			Elf_Word	relsz;
			Elf_Word	relent;
			Elf_Word	pltrel;
			Elf_Word	debug;
			Elf_Word	textrel;
			Elf_Word	jmprel;
			Elf_Word	bind_now;
@


1.4
log
@proper typing of two variables
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.3 2001/04/02 23:11:21 drahn Exp $ */
d160 2
@


1.3
log
@Cleanup for 64bit support.
Pieces by art, niklas and me.
Only tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.2 2001/03/30 01:35:21 drahn Exp $ */
d114 1
a114 1
	u_long		*buckets;
d116 1
a116 1
	u_long		*chains;
@


1.2
log
@Add infrastructure to allow mapping of text sections which are normally
RO, RW while ld.so is working. And then the information to set the
sections back to RO (or appropriate mode).

PowerPC now supports the typical NON-PIC relocations in ld.so.
I do not know how well this will work with large shared libraries.
I seem to recall a possible problem with large data where data is
located in a different shared library.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.h,v 1.1.1.2 2000/06/13 03:40:10 rahnds Exp $ */
d53 2
a54 2
	Elf32_Addr load_addr;		/* Real load address */
	Elf32_Addr load_offs;		/* Load offset from link address */
d56 1
a56 1
	Elf32_Dyn  *load_dyn;		/* Pointer to object dynamic data */
d66 1
a66 1
		u_int32_t	info[DT_NUM + DT_PROCNUM];
d68 5
a72 5
			Elf32_Word	null;		/* Not used */
			Elf32_Word	needed;		/* Not used */
			Elf32_Word	pltrelsz;
			Elf32_Word	*pltgot;
			Elf32_Word	*hash;
d74 6
a79 6
			const Elf32_Sym	*symtab;
			Elf32_Rela	*rela;
			Elf32_Word	relasz;
			Elf32_Word	relaent;
			Elf32_Word	strsz;
			Elf32_Word	syment;
d84 9
a92 9
			Elf32_Word	symbolic;
			Elf32_Rel	*rel;
			Elf32_Word	relsz;
			Elf32_Word	relent;
			Elf32_Word	pltrel;
			Elf32_Word	debug;
			Elf32_Word	textrel;
			Elf32_Word	jmprel;
			Elf32_Word	bind_now;
d104 1
a104 1
	Elf32_Phdr	*phdrp;
d114 1
a114 1
	u_int32_t	*buckets;
d116 1
a116 1
	u_int32_t	*chains;
d118 1
a118 1
	Elf32_Dyn	*dynamic;
d124 3
a126 3
extern elf_object_t *_dl_add_object(const char *objname, Elf32_Dyn *dynp,
				    const u_int32_t *, const int objtype,
				    const int laddr, const int loff);
d136 2
a137 2
Elf32_Addr _dl_find_symbol(const char *name, elf_object_t *startlook,
			const Elf32_Sym **ref, int myself, int warnnotfound);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 6
d61 2
d136 3
d140 1
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@


1.1.1.2
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems
such as correctness and security.
@
text
@a127 3
Elf32_Addr _dl_find_symbol(const char *name, elf_object_t *startlook,
			const Elf32_Sym **ref, int myself, int warnnotfound);

a128 1
void  _dl_free(void *);
@

