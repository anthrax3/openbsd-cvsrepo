head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.2
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.35;
commitid	veGB6uLWx3BTEAfk;

1.35
date	2016.07.04.04.33.35;	author guenther;	state Exp;
branches;
next	1.34;
commitid	40EbbFb7q8saaaNb;

1.34
date	2016.05.26.17.23.39;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	XCYeBHoOOTNcHbQ7;

1.33
date	2016.05.22.01.40.57;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	66Q1V3VfYIhhNVBo;

1.32
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.31;
commitid	zGFWeGZdYJxUOZli;

1.31
date	2015.08.25.08.01.12;	author guenther;	state Exp;
branches;
next	1.30;
commitid	M0bGpiGTwjhIbKC7;

1.30
date	2015.07.26.03.08.16;	author guenther;	state Exp;
branches;
next	1.29;
commitid	8fZXTItSeA4fJ2hk;

1.29
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.05.23.20.06;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.02.04.57.01;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.27.16.42.19;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.05.15.21.21;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.28.16.06.05;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.22.01.33.08;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.21.23.12.10;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.16.23.19.42;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.25.21.42.48;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.04.19.37.07;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.04.19.33.49;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.28.03.11.00;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.16.20.41;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.15.22.39.13;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.18.19.20.02;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.23.06.04.13;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.13.21.19.06;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.01.23.55.01;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.23.23.02.48;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.36
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.35 2016/07/04 04:33:35 guenther Exp $ */

/*
 * Copyright (c) 2002 Dale Rahn
 * Copyright (c) 2001 Niklas Hallqvist
 * Copyright (c) 2001 Artur Grabowski
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 2000 Eduardo Horvath.
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

/*
 * The following table holds for each relocation type:
 *	- the width in bits of the memory location the relocation
 *	  applies to (not currently used)
 *	- the number of bits the relocation value must be shifted to the
 *	  right (i.e. discard least significant bits) to fit into
 *	  the appropriate field in the instruction word.
 *	- flags indicating whether
 *		* the relocation involves a symbol
 *		* the relocation is relative to the current position
 *		* the relocation is for a GOT entry
 *		* the relocation is relative to the load address
 *
 */
#define _RF_S		0x80000000		/* Resolve symbol */
#define _RF_A		0x40000000		/* Use addend */
#define _RF_P		0x20000000		/* Location relative */
#define _RF_G		0x10000000		/* GOT offset */
#define _RF_B		0x08000000		/* Load address relative */
#define _RF_U		0x04000000		/* Unaligned */
#define _RF_SZ(s)	(((s) & 0xff) << 8)	/* memory target size */
#define _RF_RS(s)	((s) & 0xff)		/* right shift */
static int reloc_target_flags[] = {
	0,							/* NONE */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* RELOC_32*/
	_RF_S|_RF_A|_RF_P|	_RF_SZ(32) | _RF_RS(0),		/* PC32 */
	_RF_G|			_RF_SZ(32) | _RF_RS(00),	/* GOT32 */
	      _RF_A|		_RF_SZ(32) | _RF_RS(0),		/* PLT32 */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* COPY */
	_RF_S|_RF_A|		_RF_SZ(32) | _RF_RS(0),		/* GLOB_DAT */
	_RF_S|			_RF_SZ(32) | _RF_RS(0),		/* JUMP_SLOT */
	      _RF_A|	_RF_B|	_RF_SZ(32) | _RF_RS(0),		/* RELATIVE */
	0,							/* GOTOFF XXX */
	0,							/* GOTPC XXX */
	0,							/* DUMMY 11 */
	0,							/* DUMMY 12 */
	0,							/* DUMMY 13 */
	0,							/* DUMMY 14 */
	0,							/* DUMMY 15 */
	0,							/* DUMMY 16 */
	0,							/* DUMMY 17 */
	0,							/* DUMMY 18 */
	0,							/* DUMMY 19 */
	_RF_S|_RF_A|		_RF_SZ(16) | _RF_RS(0),		/* RELOC_16 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(16) | _RF_RS(0),		/* PC_16 */
	_RF_S|_RF_A|		_RF_SZ(8) | _RF_RS(0),		/* RELOC_8 */
	_RF_S|_RF_A|_RF_P|	_RF_SZ(8) | _RF_RS(0),		/* RELOC_PC8 */
};

#define RELOC_RESOLVE_SYMBOL(t)		((reloc_target_flags[t] & _RF_S) != 0)
#define RELOC_PC_RELATIVE(t)		((reloc_target_flags[t] & _RF_P) != 0)
#define RELOC_BASE_RELATIVE(t)		((reloc_target_flags[t] & _RF_B) != 0)
#define RELOC_UNALIGNED(t)		((reloc_target_flags[t] & _RF_U) != 0)
#define RELOC_USE_ADDEND(t)		((reloc_target_flags[t] & _RF_A) != 0)
#define RELOC_TARGET_SIZE(t)		((reloc_target_flags[t] >> 8) & 0xff)
#define RELOC_VALUE_RIGHTSHIFT(t)	(reloc_target_flags[t] & 0xff)

static long reloc_target_bitmask[] = {
#define _BM(x)	(~(-(1ULL << (x))))
	0,		/* NONE */
	_BM(32),	/* RELOC_32*/
	_BM(32),	/* PC32 */
	_BM(32),	/* GOT32 */
	_BM(32),	/* PLT32 */
	0,		/* COPY */
	_BM(32),	/* GLOB_DAT */
	_BM(32),	/* JUMP_SLOT */
	_BM(32),	/* RELATIVE */
	0,		/* GOTOFF XXX */
	0,		/* GOTPC XXX */
	0,		/* DUMMY 11 */
	0,		/* DUMMY 12 */
	0,		/* DUMMY 13 */
	0,		/* DUMMY 14 */
	0,		/* DUMMY 15 */
	0,		/* DUMMY 16 */
	0,		/* DUMMY 17 */
	0,		/* DUMMY 18 */
	0,		/* DUMMY 19 */
	_BM(16),	/* RELOC_16 */
	_BM(8),		/* PC_16 */
	_BM(8),		/* RELOC_8 */
	_BM(8),		/* RELOC_PC8 */
#undef _BM
};
#define RELOC_VALUE_BITMASK(t)	(reloc_target_bitmask[t])

void _dl_reloc_plt(Elf_Addr *where, Elf_Addr value);

int
_dl_md_reloc(elf_object_t *object, int rel, int relsz)
{
	long	i;
	long	numrel;
	long	relrel;
	int	fails = 0;
	Elf_Addr loff;
	Elf_Addr prev_value = 0;
	const Elf_Sym *prev_sym = NULL;
	Elf_Rel *rels;
	struct load_list *llist;

	loff = object->obj_base;
	numrel = object->Dyn.info[relsz] / sizeof(Elf32_Rel);
	relrel = rel == DT_REL ? object->relcount : 0;
	rels = (Elf32_Rel *)(object->Dyn.info[rel]);
	if (rels == NULL)
		return(0);

	if (relrel > numrel)
		_dl_die("relcount > numrel: %ld > %ld", relrel, numrel);

	/*
	 * unprotect some segments if we need it.
	 */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrel; i++, rels++) {
		Elf_Addr *where;

#ifdef DEBUG
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE))
			_dl_die("RELCOUNT wrong");
#endif
		where = (Elf_Addr *)(rels->r_offset + loff);
		*where += loff;
	}
	for (; i < numrel; i++, rels++) {
		Elf_Addr *where, value, ooff, mask;
		Elf_Word type;
		const Elf_Sym *sym, *this;
		const char *symn;

		type = ELF_R_TYPE(rels->r_info);

		if (type == R_TYPE(NONE))
			continue;

		if (type == R_TYPE(JUMP_SLOT) && rel != DT_JMPREL)
			continue;

		where = (Elf_Addr *)(rels->r_offset + loff);

		if (RELOC_USE_ADDEND(type))
			value = *where & RELOC_VALUE_BITMASK(type);
		else
			value = 0;

		sym = NULL;
		symn = NULL;
		if (RELOC_RESOLVE_SYMBOL(type)) {
			sym = object->dyn.symtab;
			sym += ELF_R_SYM(rels->r_info);
			symn = object->dyn.strtab + sym->st_name;

			if (sym->st_shndx != SHN_UNDEF &&
			    ELF_ST_BIND(sym->st_info) == STB_LOCAL) {
				value += loff;
			} else if (sym == prev_sym) {
				value += prev_value;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF_R_SYM(rels->r_info), &this,
				    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
				    ((type == R_TYPE(JUMP_SLOT))?
					SYM_PLT:SYM_NOTPLT),
				    sym, NULL);
				if (this == NULL) {
resolve_failed:
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = (Elf_Addr)(ooff + this->st_value);
				value += prev_value;
			}
		}

		if (type == R_TYPE(JUMP_SLOT)) {
			_dl_reloc_plt((Elf_Word *)where, value);
			continue;
		}

		if (type == R_TYPE(COPY)) {
			void *dstaddr = where;
			const void *srcaddr;
			const Elf_Sym *dstsym = sym, *srcsym = NULL;
			size_t size = dstsym->st_size;
			Elf_Addr soff;

			soff = _dl_find_symbol(symn, &srcsym,
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|SYM_NOTPLT,
			    sym, object, NULL);
			if (srcsym == NULL)
				goto resolve_failed;

			srcaddr = (void *)(soff + srcsym->st_value);
			_dl_bcopy(srcaddr, dstaddr, size);
			continue;
		}

		if (RELOC_PC_RELATIVE(type))
			value -= (Elf_Addr)where;
		if (RELOC_BASE_RELATIVE(type))
			value += loff;

		mask = RELOC_VALUE_BITMASK(type);
		value >>= RELOC_VALUE_RIGHTSHIFT(type);
		value &= mask;

		if (RELOC_UNALIGNED(type)) {
			/* Handle unaligned relocations. */
			Elf_Addr tmp = 0;
			char *ptr = (char *)where;
			int i, size = RELOC_TARGET_SIZE(type)/8;

			/* Read it in one byte at a time. */
			for (i=0; i<size; i++)
				tmp = (tmp << 8) | ptr[i];

			tmp &= ~mask;
			tmp |= value;

			/* Write it back out. */
			for (i=0; i<size; i++)
				ptr[i] = ((tmp >> (8*i)) & 0xff);
		} else if (RELOC_TARGET_SIZE(type) > 32) {
			*where &= ~mask;
			*where |= value;
		} else {
			Elf32_Addr *where32 = (Elf32_Addr *)where;

			*where32 &= ~mask;
			*where32 |= value;
		}
	}

	/* reprotect the unprotected segments */
	if ((object->dyn.textrel == 1) && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL; llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return (fails);
}

#if 0
struct jmpslot {
	u_short opcode;
	u_short addr[2];
	u_short reloc_index;
#define JMPSLOT_RELOC_MASK	0xffff
};
#define JUMP			0xe990	/* NOP + JMP opcode */
#endif

void
_dl_reloc_plt(Elf_Addr *where, Elf_Addr value)
{
	*where = value;
}

/*
 * Resolve a symbol at run-time.
 */
Elf_Addr
_dl_bind(elf_object_t *object, int index)
{
	Elf_Rel *rel;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	Elf_Addr ooff;
	uint64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;

	rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);

	rel += index/sizeof(Elf_Rel);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rel->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Word *)(object->obj_base + rel->r_offset);
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("eax") = SYS_kbind;

		__asm volatile("pushl 4 %3; pushl %3; pushl %2; pushl %1;"
		    " push %%eax; int $0x80; addl $20, %%esp" :
		    "+a" (syscall_num) : "r" (&buf), "i" (sizeof(buf)),
		    "m" (cookie) : "edx", "cc", "memory");
	}

	return (buf.newval);
}

int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	extern void _dl_bind_start(void);	/* XXX */
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	int i, num;
	Elf_Rel *rel;

	if (pltgot == NULL)
		return (0); /* it is possible to have no PLT/GOT relocations */

	if (object->Dyn.info[DT_PLTREL] != DT_REL)
		return (0);

	if (object->traced)
		lazy = 1;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		pltgot[1] = (Elf_Addr)object;
		pltgot[2] = (Elf_Addr)&_dl_bind_start;

		rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);
		num = (object->Dyn.info[DT_PLTRELSZ]);
		for (i = 0; i < num/sizeof(Elf_Rel); i++, rel++) {
			Elf_Addr *where;
			where = (Elf_Addr *)(rel->r_offset + object->obj_base);
			*where += object->obj_base;
		}
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	return (fails);
}
@


1.35
log
@The GOT has been initally mapped RW for *years*; ld.so doesn't need to
mprotect it to RW when filling in the references from the PLT

in snaps for a week, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.34 2016/05/26 17:23:39 deraadt Exp $ */
d191 2
a192 4
	if (relrel > numrel) {
		_dl_printf("relcount > numrel: %ld > %ld\n", relrel, numrel);
		_dl_exit(20);
	}
d210 2
a211 4
		if (ELF_R_TYPE(rels->r_info) != R_TYPE(RELATIVE)) {
			_dl_printf("RELCOUNT wrong\n");
			_dl_exit(20);
		}
d385 2
a386 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.34
log
@for textrels (sthen ran into one...):
Ignore the listed protection (which may contain X) when making page
writeable temporary.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.33 2016/05/22 01:40:57 deraadt Exp $ */
a422 1
	struct load_list *llist;
a440 6
		for (llist = object->load_list; llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
		}
a445 7
		for (llist = object->load_list; llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}

@


1.33
log
@Ignore the listed protection (which may contain X) when making page
writeable temporary.
As pointed out by kettenis, discussed with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.32 2015/11/02 07:02:53 guenther Exp $ */
d203 1
a203 1
				    llist->prot|PROT_WRITE);
@


1.32
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.31 2015/08/25 08:01:12 guenther Exp $ */
d446 1
a446 1
				    llist->prot|PROT_WRITE);
@


1.31
log
@Use kbind for lazy binding GOT/PLT updates on i386 and powerpc; still others
to follow.  While here add some gcc __predict hints.

Much discussion with and assistance from miod and deraadt
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.30 2015/07/26 03:08:16 guenther Exp $ */
a423 2
	Elf_Addr ooff;
	const Elf_Sym *this;
a427 3
	pltgot[1] = (Elf_Addr)object;
	pltgot[2] = (Elf_Addr)&_dl_bind_start;

a430 22
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}

d437 3
d461 3
a463 4
	/* PLT is already RO on i386, no point in mprotecting it, just GOT */
	if (object->got_size != 0)
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
@


1.30
log
@Copy relocations can't be jump-slot relocations, so delete the test for that.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.29 2013/06/13 04:13:47 brad Exp $ */
d70 2
a74 1
#include <signal.h>
d80 2
a367 1
	Elf_Word *addr;
d372 5
a376 1
	sigset_t savedmask;
a385 1
	addr = (Elf_Word *)(object->obj_base + rel->r_offset);
d394 1
a394 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return ooff + this->st_value;
d396 2
a397 6
	/* if GOT is protected, allow the write */
	if (object->got_size != 0) {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ|PROT_WRITE);
	}
d399 2
a400 1
	_dl_reloc_plt(addr, ooff + this->st_value);
d402 8
a409 5
	/* put the GOT back to RO */
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
d412 1
a412 1
	return((Elf_Addr)ooff + this->st_value);
@


1.29
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.28 2013/06/01 09:57:58 miod Exp $ */
d284 1
a284 2
			    SYM_SEARCH_OTHER|SYM_WARNNOTFOUND|
			    ((type == R_TYPE(JUMP_SLOT)) ? SYM_PLT:SYM_NOTPLT),
@


1.28
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.27 2013/05/08 20:55:14 guenther Exp $ */
d387 1
a387 1
		*((int *)0) = 0;	/* XXX */
@


1.27
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.26 2012/12/05 23:20:06 deraadt Exp $ */
d369 1
d384 1
a384 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym, object, NULL);
d390 3
d454 3
@


1.26
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.25 2011/04/06 11:36:25 miod Exp $ */
d173 1
d176 2
d183 1
d188 5
d204 14
a217 1
	for (i = 0; i < numrel; i++, rels++) {
d248 2
d265 3
a267 1
				value += (Elf_Addr)(ooff + this->st_value);
@


1.25
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.24 2010/05/02 04:57:01 guenther Exp $ */
a68 1
#include <sys/cdefs.h>
@


1.24
log
@Combine the signal mask handling into _dl_thread_bind_lock(), as it's MI.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.23 2008/04/09 21:45:26 kurt Exp $ */
d404 1
a404 1
	object->got_addr = NULL;
d418 2
a419 2
	if (object->got_addr == NULL)
		object->got_start = NULL;
@


1.23
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2007/11/27 16:42:19 miod Exp $ */
d345 1
a345 1
	sigset_t omask, nmask;
d366 1
a366 3
		sigfillset(&nmask);
		_dl_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_dl_thread_bind_lock(0);
d377 1
a377 2
		_dl_thread_bind_lock(1);
		_dl_sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.22
log
@Make _dl_md_reloc_got() report errors, and take them into account.
Fixes PR #5579.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.21 2007/05/05 15:21:21 drahn Exp $ */
d179 1
a179 1
	loff = object->load_offs;
d355 1
a355 1
	addr = (Elf_Word *)(object->load_offs + rel->r_offset);
d442 2
a443 2
			where = (Elf_Addr *)(rel->r_offset + object->load_offs);
			*where += object->load_offs;
@


1.21
log
@Provide hook so that rthreads can provide a spinlock to protect from races
in lazy binding. ok art@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.20 2006/10/28 16:06:05 drahn Exp $ */
d174 1
a174 1
	long	fails = 0;
d386 1
a386 1
void
d390 1
d399 1
a399 1
		return; /* it is possible to have no PLT/GOT relocations */
d405 1
a405 1
		return;
d430 1
a430 1
		_dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
d457 2
@


1.20
log
@Only mprotect pages during relocation if the library is marked TEXTREL
mips64 version still needs testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.19 2005/09/22 01:33:08 drahn Exp $ */
d368 1
d379 1
@


1.19
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2005/09/21 23:12:10 drahn Exp $ */
d188 1
a188 1
	if ((rel == DT_REL || rel == DT_RELA)) {
d307 1
a307 1
	if ((rel == DT_REL || rel == DT_RELA)) {
@


1.18
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2005/09/16 23:19:42 drahn Exp $ */
d237 3
a239 5
					_dl_printf("%s: %s: can't resolve "
					    "reference '%s'\n",
					    _dl_progname, object->load_name,
					    symn);
					fails++;
@


1.17
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2004/05/25 21:42:48 mickey Exp $ */
d234 1
a234 1
				    sym->st_size, NULL);
d263 1
a263 1
			    size, object, NULL);
d360 1
a360 2
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size,
	    object, NULL);
d410 1
a410 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
d416 1
a416 2
	    SYM_SEARCH_OBJ|SYM_NOWARNNOTFOUND|SYM_PLT, 0,
	    object, NULL);
@


1.16
log
@provide one version of _dl_bcopy instead of copy in every arch; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2004/05/25 18:07:20 mickey Exp $ */
d230 2
a231 2
				    ELF_R_SYM(rels->r_info), _dl_objects,
				    &this,NULL,SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d234 1
a234 1
				    sym->st_size);
d260 2
a261 2
			soff = _dl_find_symbol(symn, object->next, &srcsym,
			    NULL, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d263 1
a263 1
			    size, object);
d359 3
a361 2
	ooff = _dl_find_symbol(symn, _dl_objects, &this, NULL,
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, sym->st_size, object);
d410 3
a412 2
	ooff = _dl_find_symbol("__got_start", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
d417 3
a419 2
	ooff = _dl_find_symbol("__got_end", object, &this, NULL,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, object);
@


1.15
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2004/05/25 15:56:18 deraadt Exp $ */
a78 11

void
_dl_bcopy(const void *src, void *dest, int size)
{
	const unsigned char *psrc = src;
	unsigned char *pdest = dest;
	int i;

	for (i = 0; i < size; i++)
		pdest[i] = psrc[i];
}
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2003/09/04 19:37:07 drahn Exp $ */
d242 1
a242 1
				    &this, SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d272 1
a272 1
			    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|
d370 1
a370 1
	ooff = _dl_find_symbol(symn, _dl_objects, &this,
d420 1
a420 1
	ooff = _dl_find_symbol("__got_start", object, &this,
d426 1
a426 1
	ooff = _dl_find_symbol("__got_end", object, &this,
@


1.13
log
@Fix W^X mistake. If the dynamic linker is workin in non-lazy mode, it
should still mprotect the GOT and PLT as appropriate. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2003/09/04 19:33:49 drahn Exp $ */
d336 1
a336 1
#define JMPSLOT_RELOC_MASK              0xffff
d338 1
a338 1
#define JUMP    0xe990          /* NOP + JMP opcode */
d374 1
a374 1
		*((int *)0) = 0;        /* XXX */
d400 1
a400 1
	extern void _dl_bind_start(void);       /* XXX */
@


1.12
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2003/09/02 15:17:51 drahn Exp $ */
d441 20
a460 2
		return;
	}
a461 6
	rel = (Elf_Rel *)(object->Dyn.info[DT_JMPREL]);
	num = (object->Dyn.info[DT_PLTRELSZ]);
	for (llist = object->load_list; llist != NULL; llist = llist->next) {
		if (!(llist->prot & PROT_WRITE))
			_dl_mprotect(llist->start, llist->size,
			    llist->prot|PROT_WRITE);
a462 11
	for (i = 0; i < num/sizeof(Elf_Rel); i++, rel++) {
		Elf_Addr *where;
		where = (Elf_Addr *)(rel->r_offset + object->load_offs);
		*where += object->load_offs;
	}
	for (llist = object->load_list; llist != NULL; llist = llist->next) {
		if (!(llist->prot & PROT_WRITE))
			_dl_mprotect(llist->start, llist->size,
			    llist->prot);
	}

@


1.11
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2003/07/28 03:11:00 drahn Exp $ */
d240 2
a241 1
				ooff = _dl_find_symbol(symn, _dl_objects,
d245 1
a245 1
				    sym->st_size, object);
@


1.10
log
@The fifth argument to _dl_find_symbol is a 'int size', not a SYM_ define.
Fix several calls which had the incorrect but working define in that position
It happened that SYM_NOTPLT was 0, which was the desired size value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2003/06/03 16:20:41 art Exp $ */
d244 1
a244 1
				    sym->st_size, object->load_name);
d273 1
a273 1
			    size, object->load_name);
d370 1
a370 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0, object->load_name);
d420 1
a420 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
d426 1
a426 1
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, 0, NULL);
@


1.9
log
@three four gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2003/02/15 22:39:13 drahn Exp $ */
d420 1
a420 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
d426 1
a426 2
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
@


1.8
log
@Paranoia about mprotect, mprotect page aligned regions for got and plt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2003/02/02 16:57:58 deraadt Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2002/12/18 19:20:02 drahn Exp $ */
d383 1
a383 1
	if (object->got_addr != NULL && object->got_size != 0) {
d386 1
a386 1
		_dl_mprotect((void*)object->got_addr, object->got_size,
d393 2
a394 2
	if (object->got_addr != NULL && object->got_size != 0) {
		_dl_mprotect((void*)object->got_addr, object->got_size,
d422 2
d438 7
a444 13
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", object, &this,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
	if (this != NULL)
		object->plt_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__plt_end", object, &this,
	    SYM_SEARCH_SELF|SYM_NOWARNNOTFOUND|SYM_PLT, SYM_NOTPLT,
	    NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - object->plt_addr;
d470 2
a471 2
	if (object->got_addr != NULL && object->got_size != 0)
		_dl_mprotect((void*)object->got_addr, object->got_size,
@


1.6
log
@Prepare for an upcoming ELF executable change. This will allow ld.so to
protect the GOT and PLT sections of the executable from being overwritten.
This behavior is enabled by changes in the executable/shared object layout,
and does not occur without the ld changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2002/11/23 06:04:13 drahn Exp $ */
d387 1
a387 1
		    PROT_READ|PROT_WRITE); 
d474 1
a474 1
	if (object->got_addr != NULL && object->got_size != 0) 
d476 1
a476 1
		    PROT_READ); 
@


1.5
log
@Put in a required item. Should not have been deleted to start with.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.22 2002/11/14 15:15:54 drahn Exp $ */
d80 1
d336 1
d344 1
d363 1
d382 8
d392 7
d410 2
d422 28
d472 5
@


1.4
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 71
a423 2


@


1.3
log
@Check for NULL on pltgot, appearently libraries with no external references
will not create a PLT on i386.
@
text
@d178 1
a178 1
				    sym->st_size);
d207 1
a207 1
			    size);
d301 1
a301 1
	    SYM_SEARCH_ALL|SYM_WARNNOTFOUND|SYM_PLT, 0);
@


1.2
log
@Make sure that the symbol return value is always initialized before
the address of it is passed to dl_find_symbol(). fixes xpdf lazy
binding problem. ok art@@
@
text
@d321 3
@


1.1
log
@Support for i386 ELF. Not an indication that the change is going to be made,
just so that these files are maintained in the tree.
@
text
@d299 1
@

