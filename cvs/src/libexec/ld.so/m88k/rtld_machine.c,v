head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2017.02.15.21.18.52;	author miod;	state Exp;
branches;
next	1.19;
commitid	nNXOCNUaiRx2qGBa;

1.19
date	2017.01.24.10.52.33;	author guenther;	state Exp;
branches;
next	1.18;
commitid	P0Z21QA9ighuehLw;

1.18
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.17;
commitid	veGB6uLWx3BTEAfk;

1.17
date	2016.09.16.02.20.08;	author guenther;	state Exp;
branches;
next	1.16;
commitid	W86i7ggpB36YjZB1;

1.16
date	2016.09.16.02.17.57;	author guenther;	state Exp;
branches;
next	1.15;
commitid	0SKpTT3upQ2YfX7S;

1.15
date	2016.06.21.15.25.37;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	lRIiUPnkIQNjSTol;

1.14
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.13;
commitid	Kpc3J4Ry51yjfQid;

1.13
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.12;
commitid	zGFWeGZdYJxUOZli;

1.12
date	2015.09.01.05.10.43;	author guenther;	state Exp;
branches;
next	1.11;
commitid	oxjtfmrKwr0vr4bV;

1.11
date	2014.12.14.19.55.12;	author miod;	state Exp;
branches;
next	1.10;
commitid	RUiLWoO8fZ72YQC0;

1.10
date	2014.11.25.20.26.13;	author miod;	state Exp;
branches;
next	1.9;
commitid	NJmn0AtrO9ClRQE3;

1.9
date	2013.06.13.04.13.47;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.17.23.27.40;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.20.18.40.42;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.26.20.41.39;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.23.19.01.44;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.21.17.52.27;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.20.23.01.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Make this build (and run) with gcc 4.
@
text
@/*	$OpenBSD: rtld_machine.c,v 1.19 2017/01/24 10:52:33 guenther Exp $	*/

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1999 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/unistd.h>

#include <nlist.h>
#include <link.h>

#include "syscall.h"
#include "archdep.h"
#include "resolve.h"

Elf_Addr _dl_bind(elf_object_t *object, int reloff);
void	_dl_md_reloc_gotp_ent(Elf_Addr, Elf_Addr, Elf_Addr);

int64_t pcookie __attribute__((section(".openbsd.randomdata"))) __dso_hidden;

int
_dl_md_reloc(elf_object_t *object, int rel, int relasz)
{
	int	i;
	int	numrela;
	int	relrela;
	int	fails = 0;
	struct load_list *llist;
	Elf32_Addr loff;
	Elf32_Rela  *relas;
	Elf32_Addr prev_value = 0, prev_ooff = 0;
	const Elf32_Sym *prev_sym = NULL;

	loff = object->obj_base;
	numrela = object->Dyn.info[relasz] / sizeof(Elf32_Rela);
	relrela = rel == DT_RELA ? object->relacount : 0;

	relas = (Elf32_Rela *)(object->Dyn.info[rel]);

#ifdef DL_PRINTF_DEBUG
	_dl_printf("object relocation size %x, numrela %x\n",
	    object->Dyn.info[relasz], numrela);
#endif

	if (relas == NULL)
		return(0);

	if (relrela > numrela)
		_dl_die("relacount > numrel: %d > %d", relrela, numrela);

	/*
	 * Change protection of all write protected segments in the object
	 * so we can do relocations such as DISP26. After relocation,
	 * restore protection.
	 */
	if (object->dyn.textrel == 1 && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE)) {
				_dl_mprotect(llist->start, llist->size,
				    PROT_READ | PROT_WRITE);
			}
		}
	}

	/* tight loop for leading RELATIVE relocs */
	for (i = 0; i < relrela; i++, relas++) {
		Elf32_Addr *r_addr;

		r_addr = (Elf32_Addr *)(relas->r_offset + loff);
		*r_addr = relas->r_addend + loff;
	}
	for (; i < numrela; i++, relas++) {
		Elf32_Addr *r_addr = (Elf32_Addr *)(relas->r_offset + loff);
		Elf32_Addr ooff, addend, newval;
		const Elf32_Sym *sym, *this;
		const char *symn;
		int type;

		type = ELF32_R_TYPE(relas->r_info);

		if (type == RELOC_GOTP_ENT && rel != DT_JMPREL)
			continue;

		if (type == RELOC_NONE)
			continue;

		sym = object->dyn.symtab;
		sym += ELF32_R_SYM(relas->r_info);
		symn = object->dyn.strtab + sym->st_name;

		if (type == RELOC_COPY) {
			/*
			 * we need to find a symbol, that is not in the current
			 * object, start looking at the beginning of the list,
			 * searching all objects but _not_ the current object,
			 * first one found wins.
			 */
			const Elf32_Sym *cpysrc = NULL;
			Elf32_Addr src_loff;
			int size;

			src_loff = 0;
			src_loff = _dl_find_symbol(symn, &cpysrc,
			    SYM_SEARCH_OTHER | SYM_WARNNOTFOUND | SYM_NOTPLT,
			    sym, object, NULL);
			if (cpysrc != NULL) {
				size = sym->st_size;
				if (sym->st_size != cpysrc->st_size) {
					/* _dl_find_symbol() has warned
					   about this already */
					size = sym->st_size < cpysrc->st_size ?
					    sym->st_size : cpysrc->st_size;
				}
				_dl_bcopy((void *)(src_loff + cpysrc->st_value),
				    r_addr, size);
			} else
				fails++;

			continue;
		}

		if (ELF32_R_SYM(relas->r_info) &&
		    !(ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
		    ELF32_ST_TYPE (sym->st_info) == STT_NOTYPE) &&
		    sym != prev_sym) {
			if (ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
			    ELF32_ST_TYPE(sym->st_info) == STT_SECTION) {
				prev_sym = sym;
				prev_value = 0;
				prev_ooff = object->obj_base;
			} else {
				this = NULL;
				ooff = _dl_find_symbol_bysym(object,
				    ELF32_R_SYM(relas->r_info), &this,
				    SYM_SEARCH_ALL | SYM_WARNNOTFOUND |
				    ((type == RELOC_GOTP_ENT) ?
				    SYM_PLT : SYM_NOTPLT), sym, NULL);

				if (this == NULL) {
					if (ELF_ST_BIND(sym->st_info) !=
					    STB_WEAK)
						fails++;
					continue;
				}
				prev_sym = sym;
				prev_value = this->st_value;
				prev_ooff = ooff;
			}
		}

		if (type == RELOC_GOTP_ENT) {
			_dl_md_reloc_gotp_ent((Elf_Addr)r_addr,
			    relas->r_addend + loff,
			    prev_ooff + prev_value);
			continue;
		}

		if (ELF32_ST_BIND(sym->st_info) == STB_LOCAL &&
		    (ELF32_ST_TYPE(sym->st_info) == STT_SECTION ||
		    ELF32_ST_TYPE(sym->st_info) == STT_NOTYPE))
			addend = relas->r_addend;
		else
			addend = prev_value + relas->r_addend;

		switch (type) {
		case RELOC_16L:
			newval = prev_ooff + addend;
			*(unsigned short *)r_addr = newval & 0xffff;
			_dl_cacheflush((unsigned long)r_addr, 2);
			break;
		case RELOC_16H:
			newval = prev_ooff + addend;
			*(unsigned short *)r_addr = newval >> 16;
			_dl_cacheflush((unsigned long)r_addr, 2);
			break;
		case RELOC_DISP26:
			newval = prev_ooff + addend;
			newval -= (Elf_Addr)r_addr;
			if ((newval >> 28) != 0 && (newval >> 28) != 0x0f)
				_dl_die("%s: out of range DISP26"
				    " relocation to '%s' at %p\n",
				    object->load_name, symn, (void *)r_addr);
			*r_addr = (*r_addr & 0xfc000000) |
			    (((int32_t)newval >> 2) & 0x03ffffff);
			_dl_cacheflush((unsigned long)r_addr, 4);
			break;
		case RELOC_32:
			newval = prev_ooff + addend;
			*r_addr = newval;
			break;
		case RELOC_BBASED_32:
			newval = loff + addend;
			*r_addr = newval;
			break;
		default:
			_dl_die("%s: unsupported relocation '%s' %d at %p\n",
			    object->load_name, symn, type, (void *)r_addr);
		}
	}

	/* reprotect the unprotected segments */
	if (object->dyn.textrel == 1 && (rel == DT_REL || rel == DT_RELA)) {
		for (llist = object->load_list; llist != NULL;
		    llist = llist->next) {
			if (!(llist->prot & PROT_WRITE))
				_dl_mprotect(llist->start, llist->size,
				    llist->prot);
		}
	}

	return(fails);
}

/*
 * GOTP_ENT relocations are special in that they define both a .got and a
 * .plt relocation.
 */
void
_dl_md_reloc_gotp_ent(Elf_Addr got_addr, Elf_Addr plt_addr, Elf_Addr val)
{
	uint16_t *plt_entry = (uint16_t *)plt_addr;

	/* .got update */
	*(Elf_Addr *)got_addr = val;
	/* .plt update */
	plt_entry[1] = got_addr >> 16;
	plt_entry[3] = got_addr & 0xffff;
}

/*
 *	Relocate the Global Offset Table (GOT).
 *	This is done by calling _dl_md_reloc on DT_JMPREL for DL_BIND_NOW,
 *	otherwise the lazy binding plt operation is preserved.
 */
int
_dl_md_reloc_got(elf_object_t *object, int lazy)
{
	extern void _dl_bind_start(void);	/* XXX */
	int	fails = 0;
	Elf_Addr *pltgot = (Elf_Addr *)object->Dyn.info[DT_PLTGOT];
	Elf_Addr plt_start, plt_end;
	size_t plt_size;

	if (pltgot == NULL)
		return (0);

	pltgot[1] = (Elf_Addr)object;
	pltgot[2] = (Elf_Addr)_dl_bind_start;

	if (object->Dyn.info[DT_PLTREL] != DT_RELA)
		return (0);

	if (object->traced)
		lazy = 1;

	plt_start = object->Dyn.info[DT_88K_PLTSTART - DT_LOPROC + DT_NUM];
	plt_end = object->Dyn.info[DT_88K_PLTEND - DT_LOPROC + DT_NUM];

	/*
	 * GOT relocation will require PLT to be writeable.
	 */
	if ((!lazy || object->obj_base != 0) && plt_start != 0 &&
	    plt_end != 0) {
		plt_start += object->obj_base;
		plt_end += object->obj_base;
		plt_start = ELF_TRUNC(plt_start, _dl_pagesz);
		plt_size = ELF_ROUND(plt_end, _dl_pagesz) - plt_start;

		_dl_mprotect((void *)plt_start, plt_size,
		    PROT_READ | PROT_WRITE);
	} else
		plt_size = 0;

	if (!lazy) {
		fails = _dl_md_reloc(object, DT_JMPREL, DT_PLTRELSZ);
	} else {
		if (object->obj_base != 0) {
			int cnt;
			Elf_Addr *addr;
			Elf_RelA *rela;

			cnt = object->Dyn.info[DT_PLTRELSZ] / sizeof(Elf_RelA);
			rela = (Elf_RelA *)object->Dyn.info[DT_JMPREL];

			for (; cnt != 0; cnt--, rela++) {
				addr = (Elf_Addr *)(object->obj_base +
				    rela->r_offset);
				_dl_md_reloc_gotp_ent((Elf_Addr)addr,
				    object->obj_base + rela->r_addend,
				    *addr + object->obj_base);
			}
		}
	}

	/* mprotect the GOT */
	_dl_protect_segment(object, 0, "__got_start", "__got_end", PROT_READ);

	if (plt_size != 0) {
		/*
		 * Force a cache sync on the whole plt here,
		 * otherwise I$ might have stale information.
		 */
		_dl_cacheflush(plt_start, plt_size);
		_dl_mprotect((void *)plt_start, plt_size,
		    PROT_READ | PROT_EXEC);
	}

	return (fails);
}

Elf_Addr
_dl_bind(elf_object_t *object, int reloff)
{
	Elf_RelA *rel;
	Elf_Addr ooff;
	const Elf_Sym *sym, *this;
	const char *symn;
	const elf_object_t *sobj;
	uint64_t cookie = pcookie;
	struct {
		struct __kbind param;
		Elf_Addr newval;
	} buf;

	rel = (Elf_RelA *)(object->Dyn.info[DT_JMPREL] + reloff);

	sym = object->dyn.symtab;
	sym += ELF_R_SYM(rel->r_info);
	symn = object->dyn.strtab + sym->st_name;

	this = NULL;
	ooff = _dl_find_symbol(symn, &this,
	    SYM_SEARCH_ALL | SYM_WARNNOTFOUND | SYM_PLT, sym, object, &sobj);
	if (this == NULL)
		_dl_die("lazy binding failed!");

	buf.newval = ooff + this->st_value;

	if (__predict_false(sobj->traced) && _dl_trace_plt(sobj, symn))
		return (buf.newval);

	buf.param.kb_addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
	buf.param.kb_size = sizeof(Elf_Addr);

	/* directly code the syscall, so that it's actually inline here */
	{
		register long syscall_num __asm("r13") = SYS_kbind;
		register void *arg1 __asm("r2") = &buf;
		register long  arg2 __asm("r3") = sizeof(buf);
		register long  arg3 __asm("r4") = 0xffffffff & (cookie >> 32);
		register long  arg4 __asm("r5") = 0xffffffff &  cookie;

		__asm volatile("tb0 0, %%r0, 450; or %%r0, %%r0, %%r0"
		    : "+r" (arg1), "+r" (arg2) : "r" (syscall_num),
		    "r" (arg3), "r" (arg4) : "memory");
	}

	return (buf.newval);
}
@


1.19
log
@To format r_addr, use %p and cast to 'void *'.  From comparison with
other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.18 2017/01/24 07:48:37 guenther Exp $	*/
d398 1
a398 1
		    "r" (arg3), "r" (arg4) : "cc", "memory");
@


1.18
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.17 2016/09/16 02:20:08 guenther Exp $	*/
d224 2
a225 2
				    " relocation to '%s' at %x\n",
				    object->load_name, symn, r_addr);
d239 2
a240 2
			_dl_die("%s: unsupported relocation '%s' %d at %x\n",
			    object->load_name, symn, type, r_addr);
@


1.17
log
@Implement the DT_RELACOUNT optimization.  Missed previously because I
didn't recognize that RELOC_BBASED_32 was the m88k name for a pure-relative
relocation

testing by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.16 2016/09/16 02:17:57 guenther Exp $	*/
d90 2
a91 4
	if (relrela > numrela) {
		_dl_printf("relacount > numrel: %d > %d\n", relrela, numrela);
		_dl_exit(20);
	}
d222 2
a223 2
			if ((newval >> 28) != 0 && (newval >> 28) != 0x0f) {
				_dl_printf("%s: %s: out of range DISP26"
d225 1
a225 4
				    __progname, object->load_name, symn,
				    r_addr);
				_dl_exit(1);
			}
d239 2
a240 4
			_dl_printf("%s:"
			    " %s: unsupported relocation '%s' %d at %x\n",
			    __progname, object->load_name, symn, type, r_addr);
			_dl_exit(1);
d377 2
a378 4
	if (this == NULL) {
		_dl_printf("lazy binding failed!\n");
		*(volatile int *)0 = 0;		/* XXX */
	}
@


1.16
log
@Remove the fallback to the __plt_{start,end} symbols, as the dynamic tags
with the same info (DT_88K_PLT{START,END} have been around since 5.4

testing by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.15 2016/06/21 15:25:37 deraadt Exp $	*/
d68 1
d78 2
d90 5
d110 8
a117 1
	for (i = 0; i < numrela; i++, relas++) {
@


1.15
log
@When handling DT_TEXTREL only set the mapping to READ+WRITE, ignore
possible EXEC permission for the section, because the proper permission
is set late, and there are no thread concerns here.  Avoids W^X issues
in oddball cases.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.14 2016/03/20 02:29:51 guenther Exp $	*/
a275 1
	Elf_Addr ooff;
a277 1
	const Elf_Sym *this;
a290 4
	/*
	 * Post-5.3 binaries use dynamic tags to provide the .plt boundaries.
	 * If the tags are missing, fall back to the special symbol search.
	 */
a292 9
	if (plt_start == 0 || plt_end == 0) {
		this = NULL;
		ooff = _dl_find_symbol("__plt_start", &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this != NULL)
			plt_start = ooff + this->st_value;
		else
			plt_start = 0;
d294 5
a298 9
		this = NULL;
		ooff = _dl_find_symbol("__plt_end", &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this != NULL)
			plt_end = ooff + this->st_value;
		else
			plt_start = 0;		/* not enough to go on */
	} else {
a300 5
	}

	if (plt_start == 0)
		plt_size = 0;
	else {
d304 4
a307 7
		/*
		 * GOT relocation will require PLT to be writeable.
		 */
		if (!lazy || object->obj_base != 0)
			_dl_mprotect((void *)plt_start, plt_size,
			    PROT_READ | PROT_WRITE);
	}
d334 7
a340 9
		if (!lazy || object->obj_base != 0) {
			/*
			 * Force a cache sync on the whole plt here,
			 * otherwise I$ might have stale information.
			 */
			_dl_cacheflush(plt_start, plt_size);
			_dl_mprotect((void *)plt_start, plt_size,
			    PROT_READ | PROT_EXEC);
		}
@


1.14
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.13 2015/11/02 07:02:53 guenther Exp $	*/
d97 1
a97 1
				    llist->prot|PROT_WRITE);
@


1.13
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.12 2015/09/01 05:10:43 guenther Exp $	*/
d212 1
a212 1
				    _dl_progname, object->load_name, symn,
d231 1
a231 2
			    _dl_progname, object->load_name, symn, type,
			    r_addr);
@


1.12
log
@Use kbind for lazy binding GOT/PLT updates on m88k and sparc.

Much discussion with and assistance from miod and deraadt
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.11 2014/12/14 19:55:12 miod Exp $	*/
d279 1
a293 22
	object->got_addr = 0;
	object->got_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__got_start", &this,
	    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_addr = ooff + this->st_value;

	this = NULL;
	ooff = _dl_find_symbol("__got_end", &this,
	    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->got_size = ooff + this->st_value  - object->got_addr;

	if (object->got_addr == 0)
		object->got_start = 0;
	else {
		object->got_start = ELF_TRUNC(object->got_addr, _dl_pagesz);
		object->got_size += object->got_addr - object->got_start;
		object->got_size = ELF_ROUND(object->got_size, _dl_pagesz);
	}

d317 1
a317 1
			plt_end = 0;
d323 5
a327 7
	if (plt_start == 0) {
		object->plt_start = 0;
		object->plt_size = 0;
	} else {
		object->plt_start = ELF_TRUNC(plt_start, _dl_pagesz);
		object->plt_size =
		    ELF_ROUND(plt_end, _dl_pagesz) - object->plt_start;
d333 1
a333 1
			_dl_mprotect((void*)object->plt_start, object->plt_size,
d358 4
a361 5
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
	}
	if (object->plt_size != 0) {
d367 2
a368 2
			_dl_cacheflush(object->plt_start, object->plt_size);
			_dl_mprotect((void*)object->plt_start, object->plt_size,
@


1.11
log
@Revert r1.10: properly built shared libraries will never have any DISP26
relocations, but will always call public symbols through the library's PLT.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.10 2014/11/25 20:26:13 miod Exp $	*/
d48 2
a52 1
#include <signal.h>
d61 2
d404 1
a404 1
	Elf_Addr *r_addr, ooff, value;
d408 5
a412 1
	sigset_t savedmask;
a419 1
	r_addr = (Elf_Addr *)(object->obj_base + rel->r_offset);
d428 1
a428 1
	value = ooff + this->st_value;
d430 2
a431 2
	if (sobj->traced && _dl_trace_plt(sobj, symn))
		return value;
d433 2
a434 6
	/* if GOT is protected, allow the write */
	if (object->got_size != 0)  {
		_dl_thread_bind_lock(0, &savedmask);
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ | PROT_WRITE);
	}
d436 7
a442 1
	*r_addr = value;
d444 3
a446 5
	/* put the GOT back to RO */
	if (object->got_size != 0) {
		_dl_mprotect((void*)object->got_start, object->got_size,
		    PROT_READ);
		_dl_thread_bind_lock(1, &savedmask);
d449 1
a449 1
	return (value);
@


1.10
log
@When a public symbol in a library is referenced by the main program's plt,
the address of the symbol must always resolve to the entry in the main
program's plt, regardless of which object the address resolution is performed
for, so that addresses (pointers) can be compared reliably.

However, depending on how far away library load address randomization places
the library, the main program's plt address might be too far away from the
library itself for its DISP26 relocations to fit in the required relative
displacement range.

Since DISP26 relocations can only be used in code for branches, it is safe
to resolve them to the actual address within the library, and avoid producing
out of bounds displacements.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.9 2013/06/13 04:13:47 brad Exp $	*/
a70 1
	int prev_type = RELOC_NONE;
d152 1
a152 1
		    (sym != prev_sym || type != prev_type)) {
a157 1
				prev_type = type;
d160 5
a164 36

				/*
				 * Resolving a symbol in a library which is
				 * also referenced by the main program will
				 * return the address of the plt trampoline
				 * in the main program, so that the address
				 * of the symbol (&sym) always has the same
				 * value.
				 *
				 * However, in the relative branch case
				 * (DISP26), this could create an out-of-reach
				 * branch, depending where the library happens
				 * to get loaded in the 4GB address space.
				 *
				 * Since DISP26 relocations are only used for
				 * code (branches) and will never appear when
				 * attempting to take the address of a symbol,
				 * it is safe to try and search for the
				 * actual address in the current object
				 * first.
				 */
				if (type == RELOC_DISP26) {
					ooff = _dl_find_symbol_bysym(object,
					    ELF32_R_SYM(relas->r_info), &this,
					    SYM_SEARCH_SELF |
					    SYM_NOWARNNOTFOUND |
					    SYM_NOTPLT, sym, NULL);
				} else
					ooff = 0;	/* XXX gcc -Wall */

				if (this == NULL)
					ooff = _dl_find_symbol_bysym(object,
					    ELF32_R_SYM(relas->r_info), &this,
					    SYM_SEARCH_ALL | SYM_WARNNOTFOUND |
					    ((type == RELOC_GOTP_ENT) ?
					    SYM_PLT : SYM_NOTPLT), sym, NULL);
a174 1
				prev_type = type;
@


1.9
log
@Appease LLVM warning..

error: indirection of non-volatile null pointer will be deleted, not trap [-Werror,-Wnull-dereference]

Suggestion from matthew@@
Ok matthew@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.8 2013/06/01 09:57:58 miod Exp $	*/
d69 3
a105 2
		Elf32_Addr prev_value = 0, prev_ooff = 0;
		const Elf32_Sym *prev_sym = NULL;
d153 1
a153 1
		    sym != prev_sym) {
d159 1
d162 36
a197 5
				ooff = _dl_find_symbol_bysym(object,
				    ELF32_R_SYM(relas->r_info), &this,
				    SYM_SEARCH_ALL | SYM_WARNNOTFOUND |
				    ((type == RELOC_GOTP_ENT) ?
				    SYM_PLT : SYM_NOTPLT), sym, NULL);
d208 1
@


1.8
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.7 2013/05/17 23:27:40 miod Exp $	*/
d419 1
a419 1
		*((int *)0) = 0;	/* XXX */
@


1.7
log
@Try and support the non-PIC TEXTREL relocations which may creep in binaries
when linked against non-pic material (such as linking against libgcc without
passing -fpic or -fPIC on the commandline).

Given the large userland address space (4GB) and random library placement, it
is unlikely that these relocations can ever suceed anyway (DISP26 only allows
for a 256MB offset); _dl_exit() in that case, after printing a warning message.
That's better than dumping core.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.6 2013/05/08 20:55:14 guenther Exp $	*/
d287 3
d404 1
d416 1
a416 1
	    SYM_SEARCH_ALL | SYM_WARNNOTFOUND | SYM_PLT, sym, object, NULL);
d423 3
@


1.6
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.5 2013/04/20 18:40:42 miod Exp $	*/
d84 1
a84 1
	 * so we can do relocations such as PC32. After relocation,
d153 22
a174 11
			this = NULL;
			ooff = _dl_find_symbol_bysym(object,
			    ELF32_R_SYM(relas->r_info), &this,
			    SYM_SEARCH_ALL | SYM_WARNNOTFOUND |
			    ((type == RELOC_GOTP_ENT) ? SYM_PLT : SYM_NOTPLT),
			    sym, NULL);

			if (this == NULL) {
				if (ELF_ST_BIND(sym->st_info) != STB_WEAK)
					fails++;
				continue;
a175 3
			prev_sym = sym;
			prev_value = this->st_value;
			prev_ooff = ooff;
d193 24
@


1.5
log
@Prefer the processor-specific _DYNAMIC[] tags value to find out the boundaries
of the .plt whenever possible, and fallback to the old behaviour of searching
for special symbols pointing to its boundaries. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.4 2013/01/26 20:41:39 miod Exp $	*/
d103 2
a148 2
		ooff = 0;
		this = NULL;
d151 3
a153 1
		    ELF32_ST_TYPE (sym->st_info) == STT_NOTYPE)) {
d165 3
d173 1
a173 1
			    ooff + this->st_value);
d182 1
a182 1
			addend = this->st_value + relas->r_addend;
d186 1
a186 1
			newval = ooff + addend;
@


1.4
log
@Make sure to flush I$ over the plt in case of non-lazy relocation as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.3 2013/01/23 19:01:44 miod Exp $	*/
d238 1
a238 1
	Elf_Addr plt_addr;
d272 15
a286 7
	plt_addr = 0;
	object->plt_size = 0;
	this = NULL;
	ooff = _dl_find_symbol("__plt_start", &this,
	    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		plt_addr = ooff + this->st_value;
d288 12
a299 5
	this = NULL;
	ooff = _dl_find_symbol("__plt_end", &this,
	    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL, object, NULL);
	if (this != NULL)
		object->plt_size = ooff + this->st_value  - plt_addr;
d301 1
a301 1
	if (plt_addr == 0)
d303 5
a307 4
	else {
		object->plt_start = ELF_TRUNC(plt_addr, _dl_pagesz);
		object->plt_size += plt_addr - object->plt_start;
		object->plt_size = ELF_ROUND(object->plt_size, _dl_pagesz);
@


1.3
log
@Cache flush .plt after updating its pointers to .got during the initial
object relocation, if loaded at a different address than the one it was
compiled for; unsurprisingly fixes some spurious crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.2 2013/01/21 17:52:27 miod Exp $	*/
a318 5
			/*
			 * Force a cache sync on the whole plt here,
			 * otherwise I$ might have stale information.
			 */
			_dl_cacheflush(object->plt_start, object->plt_size);
d327 6
a332 1
		if (!lazy || object->obj_base != 0)
d335 1
@


1.2
log
@Use jmp, not jsr, to jump through registers. Doh!
This makes lazy binding work, so don't disable it anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld_machine.c,v 1.1 2013/01/20 23:01:44 miod Exp $	*/
d320 2
a321 2
			 * XXX We ought to invalidate I$ on the whole
			 * XXX plt here.
d323 1
@


1.1
log
@A first cut at ld.so bits for m88k. Lazy binding is currently disabled as it
does not work beyond the first few lazy resolver calls. But that's already
enough to run simple binaries.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a239 5

#if 1
	/* XXX force non-lazy binding for now, until it gets fixed... */
	lazy = 0;
#endif
@

