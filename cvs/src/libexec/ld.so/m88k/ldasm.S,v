head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.4
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4;
locks; strict;
comment	@# @;


1.27
date	2017.09.03.00.14.07;	author aoyama;	state Exp;
branches;
next	1.26;
commitid	ihuFHgGaMihiDXfX;

1.26
date	2017.08.28.14.06.22;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	r8vwp03giVzP3uiZ;

1.25
date	2017.08.27.21.59.52;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	VUjW1bPAOMU4NF33;

1.24
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.23;
commitid	veGB6uLWx3BTEAfk;

1.23
date	2016.08.28.06.15.32;	author guenther;	state Exp;
branches;
next	1.22;
commitid	Y7AbrDd15D7CrGY4;

1.22
date	2016.07.18.08.43.16;	author guenther;	state Exp;
branches;
next	1.21;
commitid	1iW5c5xKqbiBTNXw;

1.21
date	2016.07.18.04.35.57;	author guenther;	state Exp;
branches;
next	1.20;
commitid	h4bwEe9LzSSSIo0M;

1.20
date	2016.07.15.09.25.47;	author guenther;	state Exp;
branches;
next	1.19;
commitid	JjWTrDicGb2HTi6M;

1.19
date	2016.05.07.19.05.23;	author guenther;	state Exp;
branches;
next	1.18;
commitid	d9R7VGw9CHTkwXE1;

1.18
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	hneUpr7ZOJCeNeHP;

1.17
date	2016.03.21.01.32.48;	author guenther;	state Exp;
branches;
next	1.16;
commitid	7Tp2uEssgeiK9f77;

1.16
date	2015.11.15.03.41.24;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	kmpP8aoRsEOyxUMj;

1.15
date	2015.09.19.20.56.47;	author guenther;	state Exp;
branches;
next	1.14;
commitid	FcRQ6g8MqXiORdFs;

1.14
date	2015.09.13.17.08.04;	author guenther;	state Exp;
branches;
next	1.13;
commitid	BssYI6s6zozAyfkk;

1.13
date	2014.07.14.03.54.51;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	fsr4AzfIP3TLhLM2;

1.12
date	2014.07.10.07.41.26;	author miod;	state Exp;
branches;
next	1.11;
commitid	OhyZkhrb35EC9qui;

1.11
date	2014.07.09.12.51.20;	author guenther;	state Exp;
branches;
next	1.10;
commitid	l16v8zUGQ3906m8T;

1.10
date	2014.07.06.07.28.36;	author otto;	state Exp;
branches;
next	1.9;
commitid	vlK4cqSehsiJVTpr;

1.9
date	2014.07.05.16.59.36;	author miod;	state Exp;
branches;
next	1.8;
commitid	pXrmuPqTP2udNBuA;

1.8
date	2013.12.25.13.06.02;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.13.05.52.20;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.01.09.57.58;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.26.20.40.42;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.23.19.01.44;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.21.17.52.27;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.20.23.01.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Fix m88k problem in recent ld.so changes.

- move _dl_cerror function from SYS.h to ldasm.S to avoid duplicate
  definition when linking
- [SYS.h] pull some macros from lib/libc/arch/m88k/DEFS.h
- [ldasm.S] add "'never hit' but needed" br again in _dl_cacheflush
  (thanks to Miod Vallat)
- [ldasm.S] change ld.hu into ld.h in order to get a correctly signed
  and sign-extended value (also thanks to Miod Vallat)

ok deraadt@@
@
text
@/*	$OpenBSD: ldasm.S,v 1.26 2017/08/28 14:06:22 deraadt Exp $	*/

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2006 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <machine/asm.h>
#include <sys/syscall.h>

/*
 * ld.so entry point.
 * On entry: r31 points to the kernel argument struct (argv, argv, environ).
 * The environment pointers list is followed by an array of AuxInfo
 * structs filled by the kernel.
 */
#define DL_DATA_SIZE	(4 * 16)	 /* 16 * sizeof(ELF_Addr) */
ENTRY(_dl_start)
	/*
	 * Two nop because execution may skip up to two instructions.
	 * See setregs() in the kernel for details.
	 *
	 * Note that I have been hacking m88k for years and still fall
	 * into this trap, every time. -- miod
	 */
	or	%r0,  %r0,  %r0
	or	%r0,  %r0,  %r0

	/*
	 * Get some room for the contiguous AUX pointers array.
	  */
	or	%r30, %r31, 0
	subu	%r31, %r31, DL_DATA_SIZE

	/*
	 * Invoke _dl_boot_bind
	 */
	or	%r2,  %r30, 0		| kernel args
	or	%r3,  %r31, 0		| array base
	bsr	1f			| the following instruction is skipped
	bsr	_DYNAMIC		| but gives us the pc-relative offset
1:	ld	%r6, %r1, 0		| fetch branch instruction
	mak	%r5, %r6, 26<2>		| pick branch offset and shift left by 2
	addu	%r4, %r5, %r1
	bsr	_dl_boot_bind

	ld	%r2,  %r30, 0		| argc
	addu	%r6,  %r30, 4 + 4
	lda	%r3,  %r6[%r2]		| envp
	ld	%r4,  %r31, 4 * 7	| ldoff
	or	%r5,  %r31, 0		| array base
	bsr.n	_dl_boot
	 addu	%r2,  %r30, 4		| argv

	addu	%r31, %r31, DL_DATA_SIZE
	bsr	1f			| the following instruction is skipped
	bcnd	eq0, %r0, _dl_dtors	| but gives us the pc-relative offset
1:	ld.h	%r5, %r1, 2		| fetch branch offset (low 16 bits)
	jmp.n	%r2
	 lda	%r5, %r1[%r5]		| cleanup
END(_dl_start)

/*
 * PLT resolver entry point.
 * Invoked with the following stack frame:
 *	r31(0x00)	zero
 *	r31(0x04)	ELF object
 *	r31(0x08)	saved r11
 *	r31(0x0c)	saved r1
 * All registers but r1 and r11 must be preserved. The resolver must return
 * to the resolved address with r1 restored.
 */
#define	OBJECT_OFFSET	(4 * 1)
#define	R11_OFFSET	(4 * 2)
#define	R1_OFFSET	(4 * 3)
#define	PLT_FRAME_SIZE	(4 * 4)
#define REG_SIZE	(4 * 12)
ENTRY(_dl_bind_start)
	/*
	 * Preserve caller-saved registers.
	 */
	subu	%r31, %r31, REG_SIZE
	st.d	%r2,  %r31, 4 * 0
	st.d	%r4,  %r31, 4 * 2
	st.d	%r6,  %r31, 4 * 4
	st.d	%r8,  %r31, 4 * 6
	st	%r10, %r31, 4 * 8
	st.d	%r12, %r31, 4 * 10

	/*
	 * Invoke resolver entry point.
	 */
	ld	%r2,  %r31, REG_SIZE + OBJECT_OFFSET
	bsr.n	_dl_bind
	 ld	%r3,  %r31, REG_SIZE + R11_OFFSET	| reloff

	/*
	 * Preserve return address.
	 */
	or	%r11, %r2,  %r0

	/*
	 * Restore caller-saved registers.
	 */
	ld.d	%r12, %r31, 4 * 10
	ld	%r10, %r31, 4 * 8
	ld.d	%r8,  %r31, 4 * 6
	ld.d	%r6,  %r31, 4 * 4
	ld.d	%r4,  %r31, 4 * 2
	ld.d	%r2,  %r31, 4 * 0
	ld	%r1,  %r31, REG_SIZE + R1_OFFSET

	jmp.n	%r11
	 addu	%r31, %r31, REG_SIZE + PLT_FRAME_SIZE
END(_dl_bind_start)

ENTRY(_dl_cerror)
	jmp.n	%r1
	 subu	%r2, %r0, %r2
END(_dl_cerror)

ENTRY(_dl_cacheflush)
	tb0	0, %r0, 451
	br	_dl_cerror		| never hit
	jmp	%r1
END(_dl_cacheflush)
@


1.26
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.25 2017/08/27 21:59:52 deraadt Exp $	*/
d94 1
a94 1
1:	ld.hu	%r5, %r1, 2		| fetch branch offset (low 16 bits)
d153 5
d160 1
@


1.25
log
@Replace heaps of hand-written syscall stubs with a simpler framework
which is largely MI.
ok visa kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.24 2017/01/24 07:48:37 guenther Exp $	*/
d148 1
a148 1
	
@


1.24
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.23 2016/08/28 06:15:32 guenther Exp $	*/
a45 2
#define __cerror	_dl_cerror
#include <SYS.h>
a152 45
/* ld.so SYSCALLS */

/*
 * m88k syscall return ABI requires the same amount of ASM
 * whether or not the syscall can possibly fail, so there's
 * no benefit to a DL_SYSCALL_NOERR() macro.
 */
#define DL_SYSCALL(n)	DL_SYSCALL2(n,n)
#define DL_SYSCALL2(n,c)				\
	__ENTRY(_dl_,n);				\
	__DO_SYSCALL(c);				\
	br	_dl_cerror;				\
	jmp	%r1;					\
	END(_dl_##n)

ENTRY(_dl_exit)
	__DO_SYSCALL(exit)
1:	br	1b
END(_dl_exit)

DL_SYSCALL(close)
DL_SYSCALL(issetugid)
DL_SYSCALL(getthrid)
DL_SYSCALL2(_syscall,__syscall)
DL_SYSCALL(munmap)
DL_SYSCALL(mprotect)
DL_SYSCALL(open)
DL_SYSCALL(read)
DL_SYSCALL(write)
DL_SYSCALL(fstat)
DL_SYSCALL(readlink)
DL_SYSCALL(utrace)
DL_SYSCALL(getentropy)
DL_SYSCALL(sendsyslog)
DL_SYSCALL(pledge)
DL_SYSCALL2(getcwd,__getcwd)
DL_SYSCALL(sysctl)
DL_SYSCALL(getdents)
DL_SYSCALL(thrkill)

ENTRY(_dl_cerror)
	jmp.n	%r1
	 subu	%r2, %r0, %r2
END(_dl_cerror)

a154 1
	br	_dl_cerror		| never hit
@


1.23
log
@ld.so doesn't need gettimeofday or lstat stubs any more

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.22 2016/07/18 08:43:16 guenther Exp $	*/
d193 1
@


1.22
log
@Polish:
 - copy #define workaround from mips64 to avoid dangling __CERROR symbol
 - remove trap DL_SYSCALL2_NOERR() macro with comment explanation
 - make DL_SYSCALL2() self-contained
 - add END() and ENTRY() macros to make the symbol table shine

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.21 2016/07/18 04:35:57 guenther Exp $	*/
a184 1
DL_SYSCALL(gettimeofday)
a185 1
DL_SYSCALL(lstat)
@


1.21
log
@Updated advice^Wcode from miod@@ for passing &_DYNAMIC to _dl_boot_bind

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.20 2016/07/15 09:25:47 guenther Exp $	*/
d46 1
d153 1
d157 5
d166 3
a168 8
	br	_dl_cerror

#define DL_SYSCALL2_NOERR(n,c)				\
	__ENTRY(_dl_,n);				\
	__DO_SYSCALL(c)

DL_SYSCALL(close)
	jmp	%r1
d173 1
d175 1
a176 2
	jmp	%r1

a177 2
	jmp	%r1

a178 2
	jmp	%r1

a179 2
	jmp	%r1

a180 2
	jmp	%r1

a181 2
	jmp	%r1

a182 2
	jmp	%r1

a183 2
	jmp	%r1

a184 2
	jmp	%r1

a185 2
	jmp	%r1

a186 2
	jmp	%r1

a187 2
	jmp	%r1

a188 2
	jmp	%r1

a189 2
	jmp	%r1

a190 2
	jmp	%r1

a191 2
	jmp	%r1

a192 2
	jmp	%r1

a193 2
	jmp	%r1

a194 1
	jmp	%r1
d196 1
a196 1
_dl_cerror:
d199 1
@


1.20
log
@Switch m88k to pass &_DYNAMIC to _dl_boot_bind()

probably works: this ASM pattern is already used for _dl_dtors
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.19 2016/05/07 19:05:23 guenther Exp $	*/
d78 4
a81 3
	bcnd	eq0, %r0, _DYNAMIC	| but gives us the pc-relative offset
1:	ld.hu	%r5, %r1, 2		| fetch branch offset (low 16 bits)
	lda	%r4, %r1[%r5]		|
@


1.19
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.18 2016/03/21 22:41:29 bluhm Exp $	*/
a76 1
#if 0 /* _dl_boot_bind() can compute this itself */
a80 1
#endif
@


1.18
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.17 2016/03/21 01:32:48 guenther Exp $	*/
d174 3
@


1.17
log
@Switch ld.so's stack smash handler from sendsyslog to sendsyslog2
and pass the LOG_CONS flag like libc's handler.

ok deraadt@@ bluhm@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.16 2015/11/15 03:41:24 deraadt Exp $	*/
d212 1
a212 1
DL_SYSCALL(sendsyslog2)
@


1.16
log
@ldd(1) sets environment variable LD_TRACE_LOADED_OBJECTS to tell ld.so
that it should show information about the program it loads, rather than
run it.  In that specific case, ld.so can pledge to "stdio rpath" to
ensure that code path in ld.so has no bugs.
Yes, a pledge in ld.so.... who'd have thought!
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.15 2015/09/19 20:56:47 guenther Exp $	*/
d212 1
a212 1
DL_SYSCALL(sendsyslog)
@


1.15
log
@kbind has eliminated the need for and use of the bind lock.  Delete it, the
the callback, and the sigprocmask stub.
Keep around the DL_SETBINDLCK case until libpthread stops using it.

discussed with miod@@ at l2k15
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.14 2015/09/13 17:08:04 guenther Exp $	*/
d213 3
@


1.14
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.13 2014/07/14 03:54:51 deraadt Exp $	*/
a222 17

ENTRY(_dl_sigprocmask)
	bcnd	ne0, %r3, 1f
	or	%r2, %r0, 1		/* SIG_BLOCK */
	br	2f
1:
	ld	%r3, %r3, 0
2:
	or	%r13, %r0, SYS_sigprocmask
	tb0	0, %r0, 450
	br	_dl_cerror
	bcnd	eq0, %r4, 3f
	st	%r2, %r4, 0
3:
	jmp.n	%r1
	 or	%r2, %r0, 0
END(_dl_sigprocmask)
@


1.13
log
@Now that we have sendsyslog(2), we can directly use it in the
(previously completely retarded) stack_smash_handler of ld.so
ok beck miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.12 2014/07/10 07:41:26 miod Exp $	*/
d218 1
a218 1
DL_SYSCALL2(sysctl,__sysctl)
@


1.12
log
@typo in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.11 2014/07/09 12:51:20 guenther Exp $	*/
d210 3
@


1.11
log
@_dl_fcntl() is no longer used; kill the stubs

ok otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.10 2014/07/06 07:28:36 otto Exp $	*/
d240 1
a240 1
	 subu	%r2, %r0, r2
@


1.10
log
@move from sysclt(KERN_ARND) to getentropy(2); ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.9 2014/07/05 16:59:36 miod Exp $	*/
a194 3
	jmp	%r1

DL_SYSCALL(fcntl)
@


1.9
log
@Unlike libc syscall stubs, ld.so syscall stubs are expected to return -errno,
rather than -1, upon failure.

Even though nothing in ld.so currently needs to explicitely check for specific
error values, consistency doesn't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.8 2013/12/25 13:06:02 miod Exp $	*/
d210 3
@


1.8
log
@Pass _dl_dtors as the csu cleanup routine on m68k and m88k; change the
conditional in the MI code to only list the architectures left to adapt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.7 2013/08/13 05:52:20 guenther Exp $	*/
d240 1
a240 1
	 subu	%r2, %r0, 1
@


1.7
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.6 2013/06/01 09:57:58 miod Exp $	*/
d94 3
d98 1
a98 1
	 or	%r5,  %r0,  %r0		| cleanup as expected by CSU
@


1.6
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.5 2013/04/05 12:58:03 kurt Exp $	*/
d215 1
a215 1
DL_SYSCALL(getdirentries)
@


1.5
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.4 2013/01/26 20:40:42 miod Exp $	*/
d204 3
@


1.4
log
@Forgot to remove one line in 1.2, in turn caused div() from libc to fail if
invoked with lazy binding.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.3 2013/01/23 19:01:44 miod Exp $	*/
d198 9
@


1.3
log
@Cache flush .plt after updating its pointers to .got during the initial
object relocation, if loaded at a different address than the one it was
compiled for; unsurprisingly fixes some spurious crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldasm.S,v 1.2 2013/01/21 17:52:27 miod Exp $	*/
a123 1
	st	%r13, %r31, 4 * 10
@


1.2
log
@Use jmp, not jsr, to jump through registers. Doh!
This makes lazy binding work, so don't disable it anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a188 4
_dl_cerror:
	jmp.n	%r1
	 subu	%r2, %r0, 1

d215 1
a215 1
	tb0	0, %r0, 128
d222 11
a232 1
END(sigprocmask)
@


1.1
log
@A first cut at ld.so bits for m88k. Lazy binding is currently disabled as it
does not work beyond the first few lazy resolver calls. But that's already
enough to run simple binaries.
@
text
@a88 1
/* DEBUG */ or %r29, %r4, %r0
d94 1
a94 1
	jsr.n	%r2
d118 4
a121 8
	st	%r2,  %r31, 4 * 0
	st	%r3,  %r31, 4 * 1
	st	%r4,  %r31, 4 * 2
	st	%r5,  %r31, 4 * 3
	st	%r6,  %r31, 4 * 4
	st	%r7,  %r31, 4 * 5
	st	%r8,  %r31, 4 * 6
	st	%r9,  %r31, 4 * 7
d123 1
a123 1
	st	%r12, %r31, 4 * 9
d141 1
a141 2
	ld	%r13, %r31, 4 * 10
	ld	%r12, %r31, 4 * 9
d143 4
a146 8
	ld	%r9,  %r31, 4 * 7
	ld	%r8,  %r31, 4 * 6
	ld	%r7,  %r31, 4 * 5
	ld	%r6,  %r31, 4 * 4
	ld	%r5,  %r31, 4 * 3
	ld	%r4,  %r31, 4 * 2
	ld	%r3,  %r31, 4 * 1
	ld	%r2,  %r31, 4 * 0
d149 1
a149 1
	jsr.n	%r11
@

