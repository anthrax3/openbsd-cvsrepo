head	1.81;
access;
symbols
	OPENBSD_6_2_BASE:1.81
	OPENBSD_6_1:1.81.0.4
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.73.0.2
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.68.0.6
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.59.0.4
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.2
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.2
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.49.0.6
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.8
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.4
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.47.0.8
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.47.0.6
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.4
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	r20000612:1.1.1.2
	dsr:1.1.1
	r19990103:1.1.1.1
	per:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2017.01.24.07.48.37;	author guenther;	state Exp;
branches;
next	1.80;
commitid	veGB6uLWx3BTEAfk;

1.80
date	2017.01.24.02.37.10;	author guenther;	state Exp;
branches;
next	1.79;
commitid	rwqQb9pBubSpRTwo;

1.79
date	2017.01.23.16.20.35;	author naddy;	state Exp;
branches;
next	1.78;
commitid	JfJ968Jbe9dZhiz0;

1.78
date	2017.01.23.13.13.12;	author guenther;	state Exp;
branches;
next	1.77;
commitid	kVH43iEQJrng5Y2u;

1.77
date	2017.01.23.13.00.09;	author guenther;	state Exp;
branches;
next	1.76;
commitid	HAR0DSiIm2Be6qd4;

1.76
date	2017.01.22.01.20.36;	author guenther;	state Exp;
branches;
next	1.75;
commitid	uadpoy0GKiB9Exf8;

1.75
date	2016.08.23.06.46.17;	author kettenis;	state Exp;
branches;
next	1.74;
commitid	77WGwq23vMDU6RQE;

1.74
date	2016.08.08.21.59.20;	author guenther;	state Exp;
branches;
next	1.73;
commitid	PufSD0ERJAhj0Sd1;

1.73
date	2016.07.04.21.15.06;	author guenther;	state Exp;
branches;
next	1.72;
commitid	qHDzpShMNCJZKLBF;

1.72
date	2016.03.20.02.29.51;	author guenther;	state Exp;
branches;
next	1.71;
commitid	Kpc3J4Ry51yjfQid;

1.71
date	2016.01.24.03.54.34;	author guenther;	state Exp;
branches;
next	1.70;
commitid	dUhNJfxOdkXUgGnA;

1.70
date	2016.01.24.03.45.54;	author guenther;	state Exp;
branches;
next	1.69;
commitid	sKhEAVRwUQ7K3V4Y;

1.69
date	2015.11.02.07.02.53;	author guenther;	state Exp;
branches;
next	1.68;
commitid	zGFWeGZdYJxUOZli;

1.68
date	2015.01.22.05.48.17;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	GZoxg3rKKQGZ5hZT;

1.67
date	2014.07.10.09.03.01;	author otto;	state Exp;
branches;
next	1.66;
commitid	ImRWDrCXNlhODvC7;

1.66
date	2014.06.21.08.00.23;	author otto;	state Exp;
branches;
next	1.65;
commitid	wh9FTpEgwThWVeqE;

1.65
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2013.11.13.05.41.42;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.01.09.57.55;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.05.12.58.03;	author kurt;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.20.21.49.59;	author kurt;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.06.23.15.50;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2012.06.14.21.30.50;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2011.11.28.20.59.03;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.27.16.47.50;	author sthen;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.26.05.10.49;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.22.22.43.47;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.10.04.50.35;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.25.20.34.44;	author kurt;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.11.01.14.27;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.01.19.25.44;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.05.02.29.02;	author kurt;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.09.21.45.26;	author kurt;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.03.16.10.51;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2005.11.09.16.41.29;	author kurt;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.21.15.24.10;	author kurt;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.17.22.14.18;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.12.20.36.16;	author kurt;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.09.04.29.13;	author kurt;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.07.01.26.34;	author kurt;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.06.22.01.58;	author kurt;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.06.21.53.10;	author kurt;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.03.19.48.24;	author kurt;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.01.19.32.22;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.28.20.35.23;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.28.15.41.06;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.22.04.07.11;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.22.01.33.07;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.21.23.12.09;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.19.21.08.43;	author kurt;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.19.02.31.04;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.16.23.41.05;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.16.23.19.41;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.10.03.36.07;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.06.00.16.53;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.05.19.29.09;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.05.00.47.40;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.25.18.07.20;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.25.15.56.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.04.19.33.48;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.02.15.17.51;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.22.21.39.01;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.09.16.10.03;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.02.16.57.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.30.03.46.46;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.23.04.09.34;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.14.15.15.54;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.23.22.57.03;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.11.16.51.04;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.28.00.22.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.04.17.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.24.03.44.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.17.04.46.53;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.21.23.17.53;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.25.14.06.48;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.08.06.46.59;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.31.22.10.06;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.02.23.11.21;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.13.03.34.07;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.13.03.34.07;	author rahnds;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.06.13.03.40.07;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.81
log
@On fatal errors, kill ourselves with thrkill(0,9,NULL) instead of
simply exiting, via helper functions _dl_die(), _dl_diedie(), and
_dl_oom().

prompted by a complaint from jsing@@
ok jsing@@ deraadt@@
@
text
@/*	$OpenBSD: resolve.c,v 1.80 2017/01/24 02:37:10 guenther Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define _DYN_LOADER

#include <sys/types.h>

#include <limits.h>
#include <nlist.h>
#include <link.h>
#include "syscall.h"
#include "archdep.h"
#include "path.h"
#include "resolve.h"

/* substitution types */
typedef enum {
	SUBST_UNKNOWN, SUBST_ORIGIN, SUBST_OSNAME, SUBST_OSREL, SUBST_PLATFORM
} SUBST_TYPES;

elf_object_t *_dl_objects;
elf_object_t *_dl_last_object;
elf_object_t *_dl_loading_object;

/*
 * Add a new dynamic object to the object list.
 */
void
_dl_add_object(elf_object_t *object)
{
	/*
	 * If a .so is marked nodelete, then the entire load group that it's
	 * in needs to be kept around forever, so add a reference there.
	 * XXX It would be better if we tracked inter-object dependencies
	 * from relocations and didn't leave dangling pointers when a load
	 * group was partially unloaded.  That would render this unnecessary.
	 */
	if (object->obj_flags & DF_1_NODELETE &&
	    (object->load_object->status & STAT_NODELETE) == 0) {
		DL_DEB(("objname %s is nodelete\n", object->load_name));
		object->load_object->opencount++;
		object->load_object->status |= STAT_NODELETE;
	}

	/*
	 * if this is a new object, prev will be NULL
	 * != NULL if an object already in the list
	 * prev == NULL for the first item in the list, but that will
	 * be the executable.
	 */
	if (object->prev != NULL)
		return;

	if (_dl_objects == NULL) {			/* First object ? */
		_dl_last_object = _dl_objects = object;
	} else {
		_dl_last_object->next = object;
		object->prev = _dl_last_object;
		_dl_last_object = object;
	}
}

/*
 * Identify substitution sequence name.
 */
static int
_dl_subst_name(const char *name, size_t siz) {
	switch (siz) {
	case 5:
		if (_dl_strncmp(name, "OSREL", 5) == 0)
			return SUBST_OSREL;
		break;
	case 6:
		if (_dl_strncmp(name, "ORIGIN", 6) == 0)
			return SUBST_ORIGIN;
		if (_dl_strncmp(name, "OSNAME", 6) == 0)
			return SUBST_OSNAME;
		break;
	case 8:
		if (_dl_strncmp(name, "PLATFORM", 8) == 0)
			return SUBST_PLATFORM;
		break;
	}

	return (SUBST_UNKNOWN);
}

/*
 * Perform $ORIGIN substitutions on path
 */
static void
_dl_origin_subst_path(elf_object_t *object, const char *origin_path,
    char **path)
{
	char tmp_path[PATH_MAX];
	char *new_path, *tp;
	const char *pp, *name, *value;
	static struct utsname uts;
	size_t value_len;
	int skip_brace;

	if (uts.sysname[0] == '\0') {
		if (_dl_uname(&uts) != 0)
			return;
	}

	tp = tmp_path;
	pp = *path;

	while (*pp != '\0' && (tp - tmp_path) < sizeof(tmp_path)) {

		/* copy over chars up to but not including $ */
		while (*pp != '\0' && *pp != '$' &&
		    (tp - tmp_path) < sizeof(tmp_path))
			*tp++ = *pp++;

		/* substitution sequence detected */
		if (*pp == '$' && (tp - tmp_path) < sizeof(tmp_path)) {
			pp++;

			if ((skip_brace = (*pp == '{')))
				pp++;

			/* skip over name */
			name = pp;
			while (_dl_isalnum((unsigned char)*pp) || *pp == '_')
				pp++;

			switch (_dl_subst_name(name, pp - name)) {
			case SUBST_ORIGIN:
				value = origin_path;
				break;
			case SUBST_OSNAME:
				value = uts.sysname;
				break;
			case SUBST_OSREL:
				value = uts.release;
				break;
			case SUBST_PLATFORM:
				value = uts.machine;
				break;
			default:
				value = "";
			}

			value_len = _dl_strlen(value);
			if (value_len >= sizeof(tmp_path) - (tp - tmp_path))
				return;

			_dl_bcopy(value, tp, value_len);
			tp += value_len;

			if (skip_brace && *pp == '}')
				pp++;
		}
	}

	/* no substitution made if result exceeds sizeof(tmp_path) */
	if (tp - tmp_path >= sizeof(tmp_path))
		return;

	/* NULL terminate tmp_path */
	*tp = '\0';

	if (_dl_strcmp(tmp_path, *path) == 0)
		return;

	new_path = _dl_strdup(tmp_path);
	if (new_path == NULL)
		return;

	DL_DEB(("orig_path %s\n", *path));
	DL_DEB(("new_path  %s\n", new_path));

	_dl_free(*path);
	*path = new_path;
}

/*
 * Determine origin_path from object load_name. The origin_path argument
 * must refer to a buffer capable of storing at least PATH_MAX characters.
 * Returns 0 on success.
 */
static int
_dl_origin_path(elf_object_t *object, char *origin_path)
{
	const char *dirname_path = _dl_dirname(object->load_name);

	if (dirname_path == NULL)
		return -1;

	if (_dl_realpath(dirname_path, origin_path) == NULL)
		return -1;

	return 0;
}

/*
 * Perform $ORIGIN substitutions on runpath and rpath
 */
static void
_dl_origin_subst(elf_object_t *object)
{
	char origin_path[PATH_MAX];
	char **pp;

	if (_dl_origin_path(object, origin_path) != 0)
		return;

	/* perform path substitutions on each segment of runpath and rpath */
	if (object->runpath != NULL) {
		for (pp = object->runpath; *pp != NULL; pp++)
			_dl_origin_subst_path(object, origin_path, pp);
	}
	if (object->rpath != NULL) {
		for (pp = object->rpath; *pp != NULL; pp++)
			_dl_origin_subst_path(object, origin_path, pp);
	}
}

/*
 * Initialize a new dynamic object.
 */
elf_object_t *
_dl_finalize_object(const char *objname, Elf_Dyn *dynp, Elf_Phdr *phdrp,
    int phdrc, const int objtype, const long lbase, const long obase)
{
	elf_object_t *object;

#if 0
	_dl_printf("objname [%s], dynp %p, objtype %x lbase %lx, obase %lx\n",
	    objname, dynp, objtype, lbase, obase);
#endif
	object = _dl_calloc(1, sizeof(elf_object_t));
	if (object == NULL)
		_dl_oom();
	object->prev = object->next = NULL;

	object->load_dyn = dynp;
	while (dynp->d_tag != DT_NULL) {
		if (dynp->d_tag < DT_NUM)
			object->Dyn.info[dynp->d_tag] = dynp->d_un.d_val;
		else if (dynp->d_tag >= DT_LOPROC &&
		    dynp->d_tag < DT_LOPROC + DT_PROCNUM)
			object->Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] =
			    dynp->d_un.d_val;
		if (dynp->d_tag == DT_TEXTREL)
			object->dyn.textrel = 1;
		if (dynp->d_tag == DT_SYMBOLIC)
			object->dyn.symbolic = 1;
		if (dynp->d_tag == DT_BIND_NOW)
			object->obj_flags |= DF_1_NOW;
		if (dynp->d_tag == DT_FLAGS_1)
			object->obj_flags |= dynp->d_un.d_val;
		if (dynp->d_tag == DT_FLAGS) {
			object->dyn.flags |= dynp->d_un.d_val;
			if (dynp->d_un.d_val & DF_SYMBOLIC)
				object->dyn.symbolic = 1;
			if (dynp->d_un.d_val & DF_ORIGIN)
				object->obj_flags |= DF_1_ORIGIN;
			if (dynp->d_un.d_val & DF_BIND_NOW)
				object->obj_flags |= DF_1_NOW;
		}
		if (dynp->d_tag == DT_RELACOUNT)
			object->relacount = dynp->d_un.d_val;
		if (dynp->d_tag == DT_RELCOUNT)
			object->relcount = dynp->d_un.d_val;
		dynp++;
	}
	DL_DEB((" flags %s = 0x%x\n", objname, object->obj_flags ));
	object->obj_type = objtype;

	if (_dl_loading_object == NULL) {
		/*
		 * no loading object, object is the loading object,
		 * as it is either executable, or dlopened()
		 */
		_dl_loading_object = object;
	}

	if ((object->obj_flags & DF_1_NOOPEN) != 0 &&
	    _dl_loading_object->obj_type == OBJTYPE_DLO &&
	    _dl_traceld == NULL) {
		_dl_free(object);
		_dl_errno = DL_CANT_LOAD_OBJ;
		return(NULL);
	}

	/*
	 *  Now relocate all pointer to dynamic info, but only
	 *  the ones which have pointer values.
	 */
	if (object->Dyn.info[DT_PLTGOT])
		object->Dyn.info[DT_PLTGOT] += obase;
	if (object->Dyn.info[DT_HASH])
		object->Dyn.info[DT_HASH] += obase;
	if (object->Dyn.info[DT_STRTAB])
		object->Dyn.info[DT_STRTAB] += obase;
	if (object->Dyn.info[DT_SYMTAB])
		object->Dyn.info[DT_SYMTAB] += obase;
	if (object->Dyn.info[DT_RELA])
		object->Dyn.info[DT_RELA] += obase;
	if (object->Dyn.info[DT_SONAME])
		object->Dyn.info[DT_SONAME] += object->Dyn.info[DT_STRTAB];
	if (object->Dyn.info[DT_RPATH])
		object->Dyn.info[DT_RPATH] += object->Dyn.info[DT_STRTAB];
	if (object->Dyn.info[DT_RUNPATH])
		object->Dyn.info[DT_RUNPATH] += object->Dyn.info[DT_STRTAB];
	if (object->Dyn.info[DT_REL])
		object->Dyn.info[DT_REL] += obase;
	if (object->Dyn.info[DT_INIT])
		object->Dyn.info[DT_INIT] += obase;
	if (object->Dyn.info[DT_FINI])
		object->Dyn.info[DT_FINI] += obase;
	if (object->Dyn.info[DT_JMPREL])
		object->Dyn.info[DT_JMPREL] += obase;
	if (object->Dyn.info[DT_INIT_ARRAY])
		object->Dyn.info[DT_INIT_ARRAY] += obase;
	if (object->Dyn.info[DT_FINI_ARRAY])
		object->Dyn.info[DT_FINI_ARRAY] += obase;
	if (object->Dyn.info[DT_PREINIT_ARRAY])
		object->Dyn.info[DT_PREINIT_ARRAY] += obase;

	if (object->Dyn.info[DT_HASH] != 0) {
		Elf_Word *hashtab = (Elf_Word *)object->Dyn.info[DT_HASH];

		object->nbuckets = hashtab[0];
		object->nchains = hashtab[1];
		object->buckets = hashtab + 2;
		object->chains = object->buckets + object->nbuckets;
	}

	object->phdrp = phdrp;
	object->phdrc = phdrc;
	object->load_base = lbase;
	object->obj_base = obase;
	object->load_name = _dl_strdup(objname);
	if (object->load_name == NULL)
		_dl_oom();
	object->load_object = _dl_loading_object;
	if (object->load_object == object)
		DL_DEB(("head %s\n", object->load_name));
	DL_DEB(("obj %s has %s as head\n", object->load_name,
	    _dl_loading_object->load_name ));
	object->refcount = 0;
	TAILQ_INIT(&object->child_list);
	object->opencount = 0;	/* # dlopen() & exe */
	object->grprefcount = 0;
	/* default dev, inode for dlopen-able objects. */
	object->dev = 0;
	object->inode = 0;
	object->grpsym_gen = 0;
	TAILQ_INIT(&object->grpsym_list);
	TAILQ_INIT(&object->grpref_list);

	if (object->dyn.runpath)
		object->runpath = _dl_split_path(object->dyn.runpath);
	/*
	 * DT_RPATH is ignored if DT_RUNPATH is present...except in
	 * the exe, whose DT_RPATH is a fallback for libs that don't
	 * use DT_RUNPATH
	 */
	if (object->dyn.rpath && (object->runpath == NULL ||
	    objtype == OBJTYPE_EXE))
		object->rpath = _dl_split_path(object->dyn.rpath);
	if ((object->obj_flags & DF_1_ORIGIN) && _dl_trust)
		_dl_origin_subst(object);

	_dl_trace_object_setup(object);

	return (object);
}

static void
_dl_tailq_free(struct dep_node *n)
{
	struct dep_node *next;

	while (n != NULL) {
		next = TAILQ_NEXT(n, next_sib);
		_dl_free(n);
		n = next;
	}
}

static elf_object_t *free_objects;

void
_dl_cleanup_objects()
{
	elf_object_t *nobj, *head;
	struct dep_node *n, *next;

	n = TAILQ_FIRST(&_dlopened_child_list);
	while (n != NULL) {
		next = TAILQ_NEXT(n, next_sib);
		if (OBJECT_DLREF_CNT(n->data) == 0) {
			TAILQ_REMOVE(&_dlopened_child_list, n, next_sib);
			_dl_free(n);
		}
		n = next;
	}

	head = free_objects;
	free_objects = NULL;
	while (head != NULL) {
		_dl_free(head->load_name);
		_dl_free((char *)head->sod.sod_name);
		_dl_free_path(head->runpath);
		_dl_free_path(head->rpath);
		_dl_tailq_free(TAILQ_FIRST(&head->grpsym_list));
		_dl_tailq_free(TAILQ_FIRST(&head->child_list));
		_dl_tailq_free(TAILQ_FIRST(&head->grpref_list));
		nobj = head->next;
		_dl_free(head);
		head = nobj;
	}
}

void
_dl_remove_object(elf_object_t *object)
{
	object->prev->next = object->next;
	if (object->next)
		object->next->prev = object->prev;

	if (_dl_last_object == object)
		_dl_last_object = object->prev;

	object->next = free_objects;
	free_objects = object;
}

/*
 * mprotect a segment to the indicated protection.  If 'addr' is non-zero,
 * then it's the start address, else the value of 'start_sym' is the start.
 * The value of 'end_sym' is the end address.  The start is rounded down
 * and the end is rounded up to page boundaries.  Returns 'addr' or the
 * address of the start symbol.
 */
void *
_dl_protect_segment(elf_object_t *object, Elf_Addr addr,
    const char *start_sym, const char *end_sym, int prot)
{
	const Elf_Sym *this;
	Elf_Addr ooff, start, end;

	if (addr == 0 && start_sym[2] == 'g' &&
	    (addr = object->relro_addr) != 0) {
		DL_DEB(("protect start RELRO = 0x%lx in %s\n",
		    addr, object->load_name));
	}
	else if (addr == 0) {
		this = NULL;
		ooff = _dl_find_symbol(start_sym, &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		/* If not found, nothing to do */
		if (this == NULL) {
			DL_DEB(("protect start \"%s\" not found in %s\n",
			    start_sym, object->load_name));
			return (NULL);
		}
		addr = ooff + this->st_value;
		DL_DEB(("protect start \"%s\" to %x = 0x%lx in %s\n",
		    start_sym, prot, addr, object->load_name));
	}

	if (object->relro_addr != 0 && start_sym[2] == 'g') {
		end = object->relro_addr + object->relro_size;
		DL_DEB(("protect end RELRO = 0x%lx in %s\n",
		    end, object->load_name));
	} else {
		this = NULL;
		ooff = _dl_find_symbol(end_sym, &this,
		    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL,
		    object, NULL);
		if (this == NULL) {
			DL_DEB(("protect end \"%s\" not found in %s\n",
			    end_sym, object->load_name));
			addr = 0;
		} else {
			end = ooff + this->st_value;
			DL_DEB(("protect end \"%s\" = 0x%lx in %s\n",
			    end_sym, end, object->load_name));
		}
	}

	if (addr != 0 && addr < end) {
		start = ELF_TRUNC(addr, _dl_pagesz);
		end = ELF_ROUND(end, _dl_pagesz);
		_dl_mprotect((void *)start, end - start, prot);
	}

	return ((void *)addr);
}


sym_cache *_dl_symcache;
int _dl_symcachestat_hits;
int _dl_symcachestat_lookups;


Elf_Addr
_dl_find_symbol_bysym(elf_object_t *req_obj, unsigned int symidx,
    const Elf_Sym **this, int flags, const Elf_Sym *ref_sym, const elf_object_t **pobj)
{
	Elf_Addr ret;
	const Elf_Sym *sym;
	const char *symn;
	const elf_object_t *sobj;

	_dl_symcachestat_lookups ++;
	if (_dl_symcache != NULL &&
	    symidx < req_obj->nchains &&
	    _dl_symcache[symidx].obj != NULL &&
	    _dl_symcache[symidx].sym != NULL &&
	    _dl_symcache[symidx].flags == flags) {

		_dl_symcachestat_hits++;
		sobj = _dl_symcache[symidx].obj;
		*this = _dl_symcache[symidx].sym;
		if (pobj)
			*pobj = sobj;
		return sobj->obj_base;
	}

	sym = req_obj->dyn.symtab;
	sym += symidx;
	symn = req_obj->dyn.strtab + sym->st_name;

	ret = _dl_find_symbol(symn, this, flags, ref_sym, req_obj, &sobj);

	if (pobj)
		*pobj = sobj;

	if (_dl_symcache != NULL && symidx < req_obj->nchains) {
#if 0
		DL_DEB(("cache miss %d %p %p, %p %p %s %s %d %d %s\n",
		    symidx,
		    _dl_symcache[symidx].sym, *this,
		    _dl_symcache[symidx].obj, sobj, sobj->load_name,
		    sobj->dyn.strtab + (*this)->st_name,
		    _dl_symcache[symidx].flags, flags, req_obj->load_name));
#endif

		_dl_symcache[symidx].sym = *this;
		_dl_symcache[symidx].obj = sobj;
		_dl_symcache[symidx].flags = flags;
	}

	return ret;
}

static int
_dl_find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
    int flags, const Elf_Sym **this, const Elf_Sym **weak_sym,
    elf_object_t **weak_object)
{
	const Elf_Sym	*symt = object->dyn.symtab;
	const char	*strt = object->dyn.strtab;
	long	si;
	const char *symn;

	for (si = object->buckets[hash % object->nbuckets];
	    si != STN_UNDEF; si = object->chains[si]) {
		const Elf_Sym *sym = symt + si;

		if (sym->st_value == 0)
			continue;

		if (ELF_ST_TYPE(sym->st_info) != STT_NOTYPE &&
		    ELF_ST_TYPE(sym->st_info) != STT_OBJECT &&
		    ELF_ST_TYPE(sym->st_info) != STT_FUNC)
			continue;

		symn = strt + sym->st_name;
		if (sym != *this && _dl_strcmp(symn, name))
			continue;

		/* allow this symbol if we are referring to a function
		 * which has a value, even if section is UNDEF.
		 * this allows &func to refer to PLT as per the
		 * ELF spec. st_value is checked above.
		 * if flags has SYM_PLT set, we must have actual
		 * symbol, so this symbol is skipped.
		 */
		if (sym->st_shndx == SHN_UNDEF) {
			if ((flags & SYM_PLT) || sym->st_value == 0 ||
			    ELF_ST_TYPE(sym->st_info) != STT_FUNC)
				continue;
		}

		if (ELF_ST_BIND(sym->st_info) == STB_GLOBAL) {
			*this = sym;
			return 1;
		} else if (ELF_ST_BIND(sym->st_info) == STB_WEAK) {
			if (!*weak_sym) {
				*weak_sym = sym;
				*weak_object = object;
			}
		}
	}
	return 0;
}

Elf_Addr
_dl_find_symbol(const char *name, const Elf_Sym **this,
    int flags, const Elf_Sym *ref_sym, elf_object_t *req_obj,
    const elf_object_t **pobj)
{
	const Elf_Sym *weak_sym = NULL;
	unsigned long h = 0;
	const char *p = name;
	elf_object_t *object = NULL, *weak_object = NULL;
	int found = 0;
	struct dep_node *n, *m;


	while (*p) {
		unsigned long g;
		h = (h << 4) + *p++;
		if ((g = h & 0xf0000000))
			h ^= g >> 24;
		h &= ~g;
	}

	if (req_obj->dyn.symbolic)
		if (_dl_find_symbol_obj(req_obj, name, h, flags, this, &weak_sym,
		    &weak_object)) {
			object = req_obj;
			found = 1;
			goto found;
		}

	if (flags & SYM_SEARCH_OBJ) {
		if (_dl_find_symbol_obj(req_obj, name, h, flags, this,
		    &weak_sym, &weak_object)) {
			object = req_obj;
			found = 1;
		}
	} else if (flags & SYM_DLSYM) {
		if (_dl_find_symbol_obj(req_obj, name, h, flags, this,
		    &weak_sym, &weak_object)) {
			object = req_obj;
			found = 1;
		}
		if (weak_object != NULL && found == 0) {
			object=weak_object;
			*this = weak_sym;
			found = 1;
		}
		/* search dlopened obj and all children */

		if (found == 0) {
			TAILQ_FOREACH(n, &req_obj->load_object->grpsym_list,
			    next_sib) {
				if (_dl_find_symbol_obj(n->data, name, h,
				    flags, this,
				    &weak_sym, &weak_object)) {
					object = n->data;
					found = 1;
					break;
				}
			}
		}
	} else {
		int skip = 0;

		if ((flags & SYM_SEARCH_SELF) || (flags & SYM_SEARCH_NEXT))
			skip = 1;

		/*
		 * search dlopened objects: global or req_obj == dlopened_obj
		 * and and it's children
		 */
		TAILQ_FOREACH(n, &_dlopened_child_list, next_sib) {
			if (((n->data->obj_flags & DF_1_GLOBAL) == 0) &&
			    (n->data != req_obj->load_object))
				continue;

			TAILQ_FOREACH(m, &n->data->grpsym_list, next_sib) {
				if (skip == 1) {
					if (m->data == req_obj) {
						skip = 0;
						if (flags & SYM_SEARCH_NEXT)
							continue;
					} else
						continue;
				}
				if ((flags & SYM_SEARCH_OTHER) &&
				    (m->data == req_obj))
					continue;
				if (_dl_find_symbol_obj(m->data, name, h, flags,
				    this, &weak_sym, &weak_object)) {
					object = m->data;
					found = 1;
					goto found;
				}
			}
		}
	}

found:
	if (weak_object != NULL && found == 0) {
		object=weak_object;
		*this = weak_sym;
		found = 1;
	}


	if (found == 0) {
		if ((ref_sym == NULL ||
		    (ELF_ST_BIND(ref_sym->st_info) != STB_WEAK)) &&
		    (flags & SYM_WARNNOTFOUND))
			_dl_printf("%s:%s: undefined symbol '%s'\n",
			    __progname, req_obj->load_name, name);
		return (0);
	}

	if (ref_sym != NULL && ref_sym->st_size != 0 &&
	    (ref_sym->st_size != (*this)->st_size)  &&
	    (ELF_ST_TYPE((*this)->st_info) != STT_FUNC) ) {
		_dl_printf("%s:%s: %s : WARNING: "
		    "symbol(%s) size mismatch, relink your program\n",
		    __progname, req_obj->load_name, object->load_name, name);
	}

	if (pobj)
		*pobj = object;

	return (object->obj_base);
}

void
_dl_debug_state(void)
{
	/* Debugger stub */
}
@


1.80
log
@Unbreak $ORIGIN support when only one of DT_RUNPATH and DT_RPATH is used
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.79 2017/01/23 16:20:35 naddy Exp $ */
d261 1
a261 1
		_dl_exit(7);
d364 1
a364 1
		_dl_exit(7);
@


1.79
log
@remove line that slipped in with rev 1.77 but doesn't belong there; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.78 2017/01/23 13:13:12 guenther Exp $ */
d236 7
a242 5
	for (pp = object->runpath; *pp != NULL; pp++) {
		_dl_origin_subst_path(object, origin_path, pp);
	}
	for (pp = object->rpath; *pp != NULL; pp++) {
		_dl_origin_subst_path(object, origin_path, pp);
@


1.78
log
@Whoops, lost the adjustment of DT_RUNPATH value as a DT_STRTAB value.

problem reported by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.77 2017/01/23 13:00:09 guenther Exp $ */
a762 1
DEF(_dl_debug_state);
@


1.77
log
@Mark a bunch of stuff static

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.76 2017/01/22 01:20:36 guenther Exp $ */
d330 2
@


1.76
log
@Add support for DT_RUNPATH and DT_FLAGS

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.75 2016/08/23 06:46:17 kettenis Exp $ */
d407 1
a407 1
elf_object_t *free_objects;
d761 1
@


1.75
log
@Implement support for DT_INIT_ARRAY, DT_FINI_ARRAY and DT_PREINIT_ARRAY.
Don't skip DT_INIT and DT_FINI for the main executable.  This matches what
Linux and Solaris do.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.74 2016/08/08 21:59:20 guenther Exp $ */
d224 1
a224 1
 * Perform $ORIGIN substitutions on rpath
d235 4
a238 1
	/* perform path substitutions on each segment of rpath */
d278 9
d377 9
a385 1
	if (object->dyn.rpath) {
d387 2
a388 3
		if ((object->obj_flags & DF_1_ORIGIN) && _dl_trust)
			_dl_origin_subst(object);
	}
d428 4
a431 6
		if (head->load_name)
			_dl_free(head->load_name);
		if (head->sod.sod_name)
			_dl_free((char *)head->sod.sod_name);
		if (head->rpath)
			_dl_free_path(head->rpath);
@


1.74
log
@Look for a PT_GNU_RELRO section per object and, if present, mprotect that
range instead of the [__got_start, __got_end) range.
On many archs this will cover _DYNAMIC too, so move up the DT_DEBUG handling
to before relocations and the mprotect are done.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.73 2016/07/04 21:15:06 guenther Exp $ */
d249 1
d326 6
@


1.73
log
@Remove prebind support: binding to symbol table indices is too fragile
for our development process.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.72 2016/03/20 02:29:51 guenther Exp $ */
d445 6
a450 1
	if (addr == 0) {
d456 3
a458 1
		if (this == NULL)
d460 1
d462 2
d466 17
a482 11
	this = NULL;
	ooff = _dl_find_symbol(end_sym, &this,
	    SYM_SEARCH_OBJ | SYM_NOWARNNOTFOUND | SYM_PLT, NULL, object, NULL);
	if (this == NULL)
		addr = 0;
	else {
		end = ooff + this->st_value;
		if (addr < end) {
			start = ELF_TRUNC(addr, _dl_pagesz);
			end = ELF_ROUND(end, _dl_pagesz);
			_dl_mprotect((void *)start, end - start, prot);
d484 6
@


1.72
log
@Export environ and __progname, making the latter a copy of just the filename
portion like crt0 does.  This is prep for eliminating _dl_fixup_user_env()
Mark almost everything in resolve.h as hidden, to improve code generation.

ok kettenis@@ mpi@@  "good time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.71 2016/01/24 03:54:34 guenther Exp $ */
a39 1
#include "dl_prebind.h"
a499 2
		if (_dl_prebind_validate) /* XXX */
			prebind_validate(req_obj, symidx, flags, ref_sym);
@


1.71
log
@Delete remnants of grpsym cache setting during symbol search: it's done at
load time only nwo.  Rename _dl_searchnum and lastlookup to _dl_grpsym_gen
and grpsym_gen as they are generation numbers.  Merge _dl_newsymsearch()
into _dl_cache_grpsym_list_setup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.70 2016/01/24 03:45:54 guenther Exp $ */
d695 1
a695 1
			    _dl_progname, req_obj->load_name, name);
d704 1
a704 2
		    _dl_progname, req_obj->load_name,
		    object->load_name, name);
@


1.70
log
@Lacking precise dependency-from-relocation tracking, a nodelete object
needs to lock down the entire load group, not just the specific object.

problem report and ok sthen@@
been in snaps for a week
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.69 2015/11/02 07:02:53 guenther Exp $ */
d355 1
a355 1
	object->lastlookup = 0;
a532 21
int _dl_searchnum = 0;
void
_dl_newsymsearch(void)
{
	_dl_searchnum += 1;

	if (_dl_searchnum < 0) {
		/*
		 * If the signed number rolls over, reset all counters so
		 * we dont get accidental collision.
		 */
		elf_object_t *walkobj;
		for (walkobj = _dl_objects;
		    walkobj != NULL;
		    walkobj = walkobj->next) {
			walkobj->lastlookup = 0;
		}
		_dl_searchnum = 1;
	}
}

a650 2
		_dl_newsymsearch();

a659 1
			n->data->lastlookup_head = _dl_searchnum;
a671 1
				m->data->lastlookup = _dl_searchnum;
@


1.69
log
@Factor out the logic for mprotecting the memory between two symbols into
a new MI routine _dl_protect_segment(), and use that for protecting the
GOT and--on some archs--the PLT.

Amazing testing turnaround by miod@@, who apparently violated relativity
to get back results on some archs as fast as he did
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.68 2015/01/22 05:48:17 deraadt Exp $ */
d57 7
a63 1
	/* if a .so is marked nodelete, then add a reference */
d65 1
a65 1
	    (object->status & STAT_NODELETE) == 0) {
d67 2
a68 2
		object->refcount++;
		object->status |= STAT_NODELETE;
@


1.68
log
@delete annoying white space that annoy
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.67 2014/07/10 09:03:01 otto Exp $ */
d424 42
@


1.67
log
@check all memory allocations; ok miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.66 2014/06/21 08:00:23 otto Exp $ */
d44 1
a44 1
        SUBST_UNKNOWN, SUBST_ORIGIN, SUBST_OSNAME, SUBST_OSREL, SUBST_PLATFORM
d183 1
a183 1
        *tp = '\0';
d694 1
a694 1
        /* Debugger stub */
@


1.66
log
@Move to a non-zeroing _dl_malloc, a _dl_calloc and _dl_reallocarry and
fix _dl_strdup to return NULL instead of crash; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.65 2013/11/27 21:25:25 deraadt Exp $ */
d249 2
a333 1
	/* XXX */
d335 2
@


1.65
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.64 2013/11/13 05:41:42 deraadt Exp $ */
d248 1
a248 1
	object = _dl_malloc(sizeof(elf_object_t));
d332 1
@


1.64
log
@prototype & void * math cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.63 2013/06/01 09:57:55 miod Exp $ */
d146 1
a146 1
			while (_dl_isalnum(*pp) || *pp == '_')
@


1.63
log
@Introduce ltrace(1). This tool works with ld.so to inject utrace record for
each plt call, allowing to trace a binary linked against shared library at the
public function call level.

To do so, ltrace(1) sets up some environment variables to enable plt tracing
in ld.so, and invokes ktrace(2) for utrace events. ld.so will force lazy
binding and will send an utrace record in the plt resolver, without updating
the plt.

Minimal filtering capabilities are provided, inspired by Solaris' truss -u,
to limit tracing to libraries and/or symbol names. Non-traced libraries and
symbols will have the regular resolver processing, with the expected plt
update.

"Get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.62 2013/05/08 20:55:14 guenther Exp $ */
d360 1
a360 1
void
a373 1
void _dl_cleanup_objects(void);
a422 5
int _dl_find_symbol_obj(elf_object_t *object, const char *name,
    unsigned long hash, int flags, const Elf_Sym **ref,
    const Elf_Sym **weak_sym,
    elf_object_t **weak_object);

d502 52
a684 52
}

int
_dl_find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
    int flags, const Elf_Sym **this, const Elf_Sym **weak_sym,
    elf_object_t **weak_object)
{
	const Elf_Sym	*symt = object->dyn.symtab;
	const char	*strt = object->dyn.strtab;
	long	si;
	const char *symn;

	for (si = object->buckets[hash % object->nbuckets];
	    si != STN_UNDEF; si = object->chains[si]) {
		const Elf_Sym *sym = symt + si;

		if (sym->st_value == 0)
			continue;

		if (ELF_ST_TYPE(sym->st_info) != STT_NOTYPE &&
		    ELF_ST_TYPE(sym->st_info) != STT_OBJECT &&
		    ELF_ST_TYPE(sym->st_info) != STT_FUNC)
			continue;

		symn = strt + sym->st_name;
		if (sym != *this && _dl_strcmp(symn, name))
			continue;

		/* allow this symbol if we are referring to a function
		 * which has a value, even if section is UNDEF.
		 * this allows &func to refer to PLT as per the
		 * ELF spec. st_value is checked above.
		 * if flags has SYM_PLT set, we must have actual
		 * symbol, so this symbol is skipped.
		 */
		if (sym->st_shndx == SHN_UNDEF) {
			if ((flags & SYM_PLT) || sym->st_value == 0 ||
			    ELF_ST_TYPE(sym->st_info) != STT_FUNC)
				continue;
		}

		if (ELF_ST_BIND(sym->st_info) == STB_GLOBAL) {
			*this = sym;
			return 1;
		} else if (ELF_ST_BIND(sym->st_info) == STB_WEAK) {
			if (!*weak_sym) {
				*weak_sym = sym;
				*weak_object = object;
			}
		}
	}
	return 0;
@


1.62
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.61 2013/04/05 12:58:03 kurt Exp $ */
d354 2
@


1.61
log
@- Add ORIGIN, OSNAME, OSREL and PLATFORM substitution support for rpaths.
Improvements and okay matthew@@, millert@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.60 2013/03/20 21:49:59 kurt Exp $ */
d267 4
@


1.60
log
@- Parse colon separated paths into NULL terminated arrays of string
pointers to prepare for adding rpath ORIGIN support.
okay matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.59 2012/07/06 23:15:50 matthew Exp $ */
d33 1
d42 5
d84 153
d345 1
a345 1
	if (object->dyn.rpath)
d347 3
d351 1
a351 1
	return(object);
@


1.59
log
@Fix LD_DEBUG=1 regression introduced by previous commit.

ok kurt
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.58 2012/06/14 21:30:50 kettenis Exp $ */
d37 1
d186 3
d230 2
@


1.58
log
@Add support for DF_1_NOOPEN.  Based on an origional diff from matthew@@.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.57 2011/11/28 20:59:03 guenther Exp $ */
a117 1
		DL_DEB(("head %s\n", object->load_name));
d170 2
@


1.57
log
@Add support for getting some flags from DT_FLAGS_1: new flags
DF_1_NODELETE and DF_1_INITFIRST, as well as DF_1_NOW and DF_1_GLOBAL.

Committing for kurt@@ who worked out the final version; ok guenther@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.56 2011/06/27 16:47:50 sthen Exp $ */
d110 18
a166 1
	object->obj_type = objtype;
d170 1
a170 10
	if (_dl_loading_object == NULL) {
		/*
		 * no loading object, object is the loading object,
		 * as it is either executable, or dlopened()
		 */
		_dl_loading_object = object->load_object = object;
		DL_DEB(("head %s\n", object->load_name ));
	} else {
		object->load_object = _dl_loading_object;
	}
@


1.56
log
@Backout the dynamic linker speed improvement diff for now, it still
has some issues. Discussed with various, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.53 2011/05/10 04:50:35 otto Exp $ */
d50 7
d104 3
a106 1
			object->obj_flags = RTLD_NOW;
d109 1
d398 1
a398 1
			if (((n->data->obj_flags & RTLD_GLOBAL) == 0) &&
@


1.55
log
@No need to call _dl_newsymsearch() twice; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.54 2011/05/22 22:43:47 drahn Exp $ */
a215 82
struct dep_node_head _dlsym_search_list;
int _dl_search_list_valid = 0;

void
_dl_rebuild_allobj_grouplist()
{
	struct dep_node *n, *m;
	int global;
	static int maxgrouplist = 0;
	static int maxchildlist = 0;
	int childlistlen = 0, grouplistlen = 0;

	DL_DEB(("rebuil\n"));

	/* get rid of old list */
	while( (n = TAILQ_FIRST(&_dlsym_search_list)) != NULL) {
		TAILQ_REMOVE(&_dlsym_search_list, n, next_sib);
		n->data->obj_global = 0; /* clear the cached global flag */
		_dl_free(n);
	}

	/* rebuild list */
	_dl_newsymsearch();

	/*
	 * search dlopened objects: global or req_obj == dlopened_obj
	 * and and it's children
	 */
	TAILQ_FOREACH(n, &_dlopened_child_list, next_sib) {
		childlistlen++;
#if 0
		DL_DEB(("opened list: %s\n", n->data->load_name)); 
#endif
		global = n->data->obj_flags & RTLD_GLOBAL;

		if (n->data->lastlookup == _dl_searchnum)
			continue;

		grouplistlen = 0;
		TAILQ_FOREACH(m, &n->data->grpsym_list, next_sib) {
			grouplistlen++;
			if (m->data->lastlookup == _dl_searchnum)
				continue;
			if (!global && m->data != n->data) {
				continue;
			}
			m->data->obj_global |= global & RTLD_GLOBAL;

			_dl_append_search(m->data);
		}
	}
	if (grouplistlen > maxgrouplist) {
		maxgrouplist = grouplistlen ;
		DL_DEB(("maxgrouplist = %d\n", maxgrouplist));
	}
	if (childlistlen > maxchildlist) {
		maxchildlist = childlistlen;
		DL_DEB(("maxchildlist = %d\n", maxchildlist));
	}

#if 0
	TAILQ_FOREACH(n, &_dlsym_search_list, next_sib) {
		DL_DEB(("objects: %s global %d\n",
		    n->data->load_name,
		    n->data->obj_global));
	}
#endif

	_dl_search_list_valid = 1;
}

void
_dl_append_search(elf_object_t *object)
{
	struct dep_node *n;
	n = _dl_malloc(sizeof *n);
	n->data = object;

	object->lastlookup = _dl_searchnum;
	TAILQ_INSERT_TAIL(&_dlsym_search_list, n, next_sib);
}

a324 2
	int visit = 0;
	static int maxvisit = 0;
d375 1
a375 1
	} else if ((flags & (SYM_SEARCH_NEXT|SYM_SEARCH_SELF|SYM_SEARCH_OTHER))) {
d381 2
d392 1
d405 1
a413 33
	} else {
		if (_dl_search_list_valid == 0) {
			_dl_rebuild_allobj_grouplist();
		}

		TAILQ_FOREACH(n, &_dlsym_search_list, next_sib) {
			if (n->data == req_obj->load_object) {
				TAILQ_FOREACH(m, &n->data->grpsym_list,
				    next_sib) {
					visit++;
					if (_dl_find_symbol_obj(m->data, name,
					    h, flags, this, &weak_sym,
					    &weak_object)) {
						object = m->data;
						found = 1;
						goto found;
					}
				}
			}
			if (((n->data->obj_global & RTLD_GLOBAL) == 0) &&
			    (n->data != req_obj->load_object))
				continue;

			//DL_DEB(("searching for %s in %s\n", name, n->data->load_name));
			visit++;
			if (_dl_find_symbol_obj(n->data, name, h, flags,
			    this, &weak_sym, &weak_object)) {
				object = n->data;
				found = 1;
				DL_DEB(("sym %s is in %s\n", name, object->load_name));
				goto found;
			}
		}
a416 4
	if (visit > maxvisit) {
		maxvisit = visit;
		DL_DEB(("maxvisit is %d\n", maxvisit));
	}
@


1.54
log
@Dynamic linker speed improvement diff. tested by several sinc k2k11.
get it in tree now deraadt@@, ok by several ports folks. Thanks for the testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.53 2011/05/10 04:50:35 otto Exp $ */
d239 1
a243 3
	
	 _dl_newsymsearch();

@


1.53
log
@Fix previous. On i386, library.c isn't compiled
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.52 2010/10/25 20:34:44 kurt Exp $ */
d216 84
d409 2
d461 1
a461 1
	} else {
a466 2
		_dl_newsymsearch();

a475 1
			n->data->lastlookup_head = _dl_searchnum;
a487 1
				m->data->lastlookup = _dl_searchnum;
d496 33
d532 4
@


1.52
log
@Search loaded libs first and add support for SONAME matching. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.51 2010/08/11 01:14:27 drahn Exp $ */
d498 6
@


1.51
log
@Make _dl_searchnum signed as originally intended.
Pointed out by patrick keshish.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.50 2010/07/01 19:25:44 drahn Exp $ */
d116 1
a116 1
		object->Dyn.info[DT_SONAME] += obase;
d205 2
a229 14

elf_object_t *
_dl_lookup_object(const char *name)
{
	elf_object_t *object;

	object = _dl_objects;
	while (object) {
		if (_dl_strcmp(name, object->load_name) == 0)
			return(object);
		object = object->next;
	}
	return(0);
}
@


1.50
log
@When generating grpsym lists, avoid duplicates without searching the
already generated list. Speeds up startup on deeply nested dlopen binaries.
ok guenther@@, tested by ckuethe@@ and ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.49 2008/05/05 02:29:02 kurt Exp $ */
d306 1
a306 1
uint32_t _dl_searchnum = 0;
d313 3
a315 2
		/* if the signed number roll over, reset
		 * all counters so we dont get accidental collision
@


1.49
log
@Constantly fill in the program header pointer and count in elf_object_t
for all objects which simplifies phdr usage in a few places.
"go for it" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.48 2008/04/09 21:45:26 kurt Exp $ */
d162 1
d306 20
d392 2
d403 1
d416 1
@


1.48
log
@Improve support for shared libs linked at non-zero addreses:
- rename private values in struct elf_object to better
  describe their meaning:
    s/load_offs/obj_base/ "object's address '0' base"
    s/load_addr/load_base/ "The base address of the loadable
    segments"
- gdb needs the obj_base value so swap positions with load_base in
  struct elf_object
- fix a few occurrences of where load_base was used instead of
  obj_base.

With help and okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.47 2006/05/03 16:10:51 drahn Exp $ */
d73 2
a74 2
_dl_finalize_object(const char *objname, Elf_Dyn *dynp, const long *dl_data,
    const int objtype, const long lbase, const long obase)
d78 2
a79 2
	_dl_printf("objname [%s], dynp %p, dl_data %p, objtype %x lbase %lx, obase %lx\n",
	    objname, dynp, dl_data, objtype, lbase, obase);
d137 2
a138 4
	if (dl_data) {
		object->phdrp = (Elf_Phdr *) dl_data[AUX_phdr];
		object->phdrc = dl_data[AUX_phnum];
	}
@


1.47
log
@prebind - how to prelink a binary without throwing security out the window

Prelink fixes the address of libraries making 'return to libc' attacks trival,
prebind uses a different method to achieve most of the same gains, however
without adding any security conerns.

Still under development, now in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.46 2005/11/09 16:41:29 kurt Exp $ */
d74 1
a74 1
    const int objtype, const long laddr, const long loff)
d78 2
a79 2
	_dl_printf("objname [%s], dynp %p, dl_data %p, objtype %x laddr %lx, loff %lx\n",
	    objname, dynp, dl_data, objtype, laddr, loff);
d106 1
a106 1
		object->Dyn.info[DT_PLTGOT] += loff;
d108 1
a108 1
		object->Dyn.info[DT_HASH] += loff;
d110 1
a110 1
		object->Dyn.info[DT_STRTAB] += loff;
d112 1
a112 1
		object->Dyn.info[DT_SYMTAB] += loff;
d114 1
a114 1
		object->Dyn.info[DT_RELA] += loff;
d116 1
a116 1
		object->Dyn.info[DT_SONAME] += loff;
d120 1
a120 1
		object->Dyn.info[DT_REL] += loff;
d122 1
a122 1
		object->Dyn.info[DT_INIT] += loff;
d124 1
a124 1
		object->Dyn.info[DT_FINI] += loff;
d126 1
a126 1
		object->Dyn.info[DT_JMPREL] += loff;
d142 2
a143 2
	object->load_addr = laddr;
	object->load_offs = loff;
d277 1
a277 1
		return sobj->load_offs;
d433 1
a433 1
	return (object->load_offs);
@


1.46
log
@add RTLD_NOW support to dlopen and propogate -z now to dep libs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.45 2005/10/21 15:24:10 kurt Exp $ */
d38 1
d253 1
d275 2
d290 9
@


1.45
log
@using _dl_link_grpsym to increment refcounts made _dl_notify_unload_shlib
simpler, however it broke ldd refcount output. use _dl_link_child to
increment refcounts and adjust _dl_notify_unload_shlib to match.
work by drahn@@ and myself. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.44 2005/10/17 22:14:18 kettenis Exp $ */
d96 1
a96 1
			object->dyn.bind_now = 1;
@


1.44
log
@Fix possible buffer overflow caused by unknown tags in the range
[DT_LOPROC, DT_HIPROC].
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.43 2005/10/12 20:36:16 kurt Exp $ */
a155 1
	/* refcount handled in _dl_link_grpsym_list */
@


1.43
log
@Split grpsym_list creation away from child_list creation and change
grpsym_list order to match Sun's docs. Also corrects bugs where
grpsym_list was either not created or partially created.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.42 2005/10/09 04:29:13 kurt Exp $ */
d88 1
a88 1
		    dynp->d_tag < DT_LOPROC + DT_NUM)
@


1.42
log
@introduce object ref count macros (suggested by dale). no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.41 2005/10/07 01:26:34 kurt Exp $ */
d156 1
a156 1
	/* refcount handled in _dl_link_sub & _dl_boot */
@


1.41
log
@rename dload_list to grpsym_list which better represents its usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.40 2005/10/06 22:01:58 kurt Exp $ */
d194 1
a194 1
		if (n->data->opencount + n->data->grprefcount == 0) {
@


1.40
log
@remove dep_next "shadow object" dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.39 2005/10/06 21:53:10 kurt Exp $ */
d164 1
a164 1
	TAILQ_INIT(&object->dload_list);
d206 1
a206 1
		_dl_tailq_free(TAILQ_FIRST(&head->dload_list));
d344 1
a344 1
			TAILQ_FOREACH(n, &req_obj->load_object->dload_list,
d370 1
a370 1
			TAILQ_FOREACH(m, &n->data->dload_list, next_sib) {
@


1.39
log
@separate load group references from dep lib child/dload lists. move load
group refs to own per object ref counter (grprefcount) and list
(grpref_list). corrects more complex load group ref cases and side effects
from initial implementation. design ideas and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.38 2005/10/03 19:48:24 kurt Exp $ */
a217 2
	elf_object_t *depobj;

a223 5

	while ((depobj = object->dep_next)) {
		object->dep_next = object->dep_next->dep_next;
		_dl_free(depobj);
	}
@


1.38
log
@refcount corrections: count common dep libs once and centralize dep lib
refcount increments to _dl_link_sub. adjust _dl_notify_unload_shlib to
match new refcount method. ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.37 2005/10/01 19:32:22 drahn Exp $ */
d156 1
a156 1
	/* refcount handled in _dl_link_sub, _dl_boot & dlopen */
d159 2
a160 1
	object->opencount = 0;	/* # dlopen() */
d165 1
d170 12
d189 1
a189 1
	struct dep_node *n;
d191 4
a194 3
retry:
	TAILQ_FOREACH(n, &_dlopened_child_list, next_sib) {
		if (n->data->refcount == 0) {
a196 1
			goto retry;
d198 1
d204 5
a226 3
	if (object->load_name)
		_dl_free(object->load_name);

d231 1
d233 1
a233 1
	free_objects = object->next;
@


1.37
log
@handle references to load groups caused by dlopen()ing of depenant
members of the load group. work by kurt@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.36 2005/09/28 20:35:23 drahn Exp $ */
d156 2
a157 1
	object->refcount = 1;
@


1.36
log
@keep a state flag if a library has been unloaded, and then free the list
seperately ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.35 2005/09/28 15:41:06 drahn Exp $ */
d174 11
@


1.35
log
@keep track of opencounts for dlopened objects, so that they
get unloaded the right number of times on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.34 2005/09/22 04:07:11 deraadt Exp $ */
d167 16
d202 2
a203 1
	_dl_free(object);
@


1.34
log
@knf; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.33 2005/09/22 01:33:07 drahn Exp $ */
d158 1
@


1.33
log
@Use std missing symbol print instead of MD custom, do not warn on weak
undefined symbols, or count them as failures. inspired kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.32 2005/09/21 23:12:09 drahn Exp $ */
d222 5
a226 5
	if ((_dl_symcache != NULL) &&
	     (symidx < req_obj->nchains) &&
	     (_dl_symcache[symidx].obj != NULL) &&
	     (_dl_symcache[symidx].sym != NULL) &&
	     (_dl_symcache[symidx].flags == flags)) {
d245 1
a245 2
	if ((_dl_symcache != NULL) &&
	     (symidx < req_obj->nchains)) {
d319 1
a319 1
		
@


1.32
log
@Simplify the internal symbol finding API, with some cleanup, prep for
next step. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.31 2005/09/19 21:08:43 kurt Exp $ */
d361 3
a363 1
		if (flags & SYM_WARNNOTFOUND)
@


1.31
log
@stop searching after first matching symbol is found. okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.30 2005/09/19 02:31:04 drahn Exp $ */
d214 1
a214 1
    const Elf_Sym **ref, int flags, int req_size, const elf_object_t **pobj)
d230 1
a230 1
		*ref = _dl_symcache[symidx].sym;
d240 1
a240 1
	ret = _dl_find_symbol(symn, ref, flags, req_size, req_obj, &sobj);
d247 1
a247 1
		_dl_symcache[symidx].sym = *ref;
d256 3
a258 2
_dl_find_symbol(const char *name, const Elf_Sym **ref,
    int flags, int req_size, elf_object_t *req_obj, const elf_object_t **pobj)
d277 1
a277 1
		if (_dl_find_symbol_obj(req_obj, name, h, flags, ref, &weak_sym,
d285 1
a285 1
		if (_dl_find_symbol_obj(req_obj, name, h, flags, ref,
d291 1
a291 1
		if (_dl_find_symbol_obj(req_obj, name, h, flags, ref,
d298 1
a298 1
			*ref = weak_sym;
d307 1
a307 1
				    flags, ref,
d343 1
a343 1
				    ref, &weak_sym, &weak_object)) {
d355 1
a355 1
		*ref = weak_sym;
d367 3
a369 2
	if (req_size != (*ref)->st_size && req_size != 0 &&
	    (ELF_ST_TYPE((*ref)->st_info) != STT_FUNC)) {
d384 1
a384 1
    int flags, const Elf_Sym **ref, const Elf_Sym **weak_sym,
d405 1
a405 1
		if (sym != *ref && _dl_strcmp(symn, name))
d422 1
a422 1
			*ref = sym;
@


1.30
log
@simplify code by putting executable in misnamed _dlopened_child_list,
also move RTLD_NEXT/RTLD_SELF code into that code, it is a single test.
okay kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.29 2005/09/16 23:41:05 drahn Exp $ */
d345 1
a345 1
					break;
@


1.29
log
@Now that the bug requiring it has been fixed, remove the lastchance kludge
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.28 2005/09/16 23:19:41 drahn Exp $ */
a288 20
	} else if ((flags & SYM_SEARCH_SELF) || (flags & SYM_SEARCH_NEXT)) {
		/* search after req_obj in the objects's load group */
		int skip = 1;

		TAILQ_FOREACH(n, &req_obj->load_object->dload_list, next_sib) {

			if (n->data == req_obj && skip == 1) {
				skip = 0;
				if (flags & SYM_SEARCH_NEXT)
					continue;
			}
			if (skip == 1)
				continue;
			if (_dl_find_symbol_obj(n->data, name, h, flags, ref,
			    &weak_sym, &weak_object)) {
				object = n->data;
				found = 1;
				break;
			}
		}
d315 1
a315 14
		/* search main program and it's libs */
		TAILQ_FOREACH(n, &_dl_objects->dload_list, next_sib) {
			if ((flags & SYM_SEARCH_OTHER) &&
			    (n->data == req_obj)) {
				continue;
			}

			if (_dl_find_symbol_obj(n->data, name, h, flags,
			    ref, &weak_sym, &weak_object)) {
				object = n->data;
				found = 1;
				goto found;
			}
		}
d317 3
d330 8
@


1.28
log
@Rework symbol lookup to more closely match sun's documentation, now
treats dlopens as load groups. ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.27 2005/05/10 03:36:07 drahn Exp $ */
d263 1
a263 1
	int found = 0, lastchance = 0;
a282 2

retry_nonglobal_dlo:
d355 1
a355 2
			if ((lastchance == 0) &&
			    ((n->data->obj_flags & RTLD_GLOBAL) == 0) &&
a381 6
#if 1
		if (lastchance == 0) {
			lastchance = 1;
			goto retry_nonglobal_dlo;
		}
#endif
@


1.27
log
@Recommit the destructor order fix, now that the amd64 bug was fixed.
'no problem' pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.26 2005/04/06 00:16:53 deraadt Exp $ */
d41 1
d72 1
a72 1
_dl_finalize_object(const char *objname, Elf_Dyn *dynp, const u_long *dl_data,
d144 12
d157 1
a157 2
	object->first_child = NULL;
	object->last_child = NULL;
d161 1
d214 1
a214 2
    elf_object_t *startlook, const Elf_Sym **ref, const elf_object_t **pobj,
    int flags, int req_size)
d240 1
a240 2
	ret = _dl_find_symbol(symn, startlook, ref, &sobj,
	    flags, req_size, req_obj);
d256 2
a257 3
_dl_find_symbol(const char *name, elf_object_t *startlook,
    const Elf_Sym **ref, const elf_object_t **pobj,
    int flags, int req_size, elf_object_t *req_obj)
d262 4
a265 3
	elf_object_t *object, *weak_object = NULL;
	int found = 0;
	int lastchance = 0;
d283 1
d285 38
a322 2
	for (object = startlook; object;
	    object = ((flags & SYM_SEARCH_SELF) ? 0 : object->next)) {
d324 27
a350 5
		if ((lastchance == 0) &&
		    ((object->obj_flags & RTLD_GLOBAL) == 0) &&
		    (object->obj_type == OBJTYPE_DLO) &&
		    (object != req_obj))
			continue;
d352 21
a372 4
		if (_dl_find_symbol_obj(object, name, h, flags, ref, &weak_sym,
		    &weak_object)) {
			found = 1;
			break;
d383 1
d385 1
d390 1
@


1.26
log
@backout -- breaks at least amd64; spotted by marc
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.24 2004/07/05 00:47:40 kjell Exp $ */
d190 3
a192 2
int find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
    int flags, const Elf_Sym **ref, const Elf_Sym **weak_sym,
d265 1
a265 1
		if (find_symbol_obj(req_obj, name, h, flags, ref, &weak_sym,
d282 1
a282 1
		if (find_symbol_obj(object, name, h, flags, ref, &weak_sym,
d322 1
a322 1
find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
@


1.25
log
@Do a better job of running destructors in the right order.
@
text
@d190 2
a191 3
int _dl_find_symbol_obj(elf_object_t *object, const char *name,
    unsigned long hash, int flags, const Elf_Sym **ref,
    const Elf_Sym **weak_sym,
d264 1
a264 1
		if (_dl_find_symbol_obj(req_obj, name, h, flags, ref, &weak_sym,
d281 1
a281 1
		if (_dl_find_symbol_obj(object, name, h, flags, ref, &weak_sym,
d321 1
a321 1
_dl_find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
@


1.24
log
@Fix an issue where a shared library could be loaded at two different
locations by resolving all dlopens back to a dev/inode.

i.e. Don't load a library if the dev/inode it stats back to matches one
already in our list.

fix started (and ok'ed) drahn@@. ok deraadt@@.
"doesn't break anything yet" pval@@ art@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.23 2004/05/25 18:07:20 mickey Exp $ */
d190 3
a192 2
int find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
    int flags, const Elf_Sym **ref, const Elf_Sym **weak_sym,
d265 1
a265 1
		if (find_symbol_obj(req_obj, name, h, flags, ref, &weak_sym,
d282 1
a282 1
		if (find_symbol_obj(object, name, h, flags, ref, &weak_sym,
d322 1
a322 1
find_symbol_obj(elf_object_t *object, const char *name, unsigned long hash,
@


1.23
log
@return object* the symbol is in for _dl_find_symbol*; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.22 2004/05/25 15:56:18 deraadt Exp $ */
a78 1

d146 4
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.21 2003/09/04 19:33:48 drahn Exp $ */
d197 2
a198 1
    elf_object_t *startlook, const Elf_Sym **ref, int flags, int req_size)
d203 1
d208 1
d213 1
d215 3
a217 1
		return _dl_symcache[symidx].offset;
d224 5
a228 1
	ret = _dl_find_symbol(symn, startlook, ref, flags, req_size, req_obj);
d233 1
a233 1
		_dl_symcache[symidx].offset = ret;
d242 2
a243 1
    const Elf_Sym **ref, int flags, int req_size, elf_object_t *req_obj)
d310 3
@


1.21
log
@Symbol cache for GOT lookup. When a symbol is found it is saved in a cache
for future lookups in the same GOT relocation table. Uses static buffer
for small symbol tables, mmap for larger ones. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.20 2003/09/02 15:17:51 drahn Exp $ */
d256 1
a256 1
		    
d264 1
a264 1
		    (object != req_obj)) 
@


1.20
log
@Fix PR 3371, symbol lookup in dlopen()ed objects is not correct. Correct
behavior for RTLD_GLOBAL/RTLD_LOCAL is now supported. ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.19 2003/06/22 21:39:01 drahn Exp $ */
d190 39
@


1.19
log
@Dynamic linking random order fixes. This enables random library ordering.
Tested by naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.18 2003/06/09 16:10:03 deraadt Exp $ */
d187 3
d193 1
a193 1
    const Elf_Sym **ref, int flags, int req_size, const char *module_name)
a195 2
	const char *weak_symn = NULL; /* remove warning */
	Elf_Addr weak_offs = 0;
d199 2
d210 9
a220 8
		const Elf_Sym	*symt = object->dyn.symtab;
		const char	*strt = object->dyn.strtab;
		long	si;
		const char *symn;

		for (si = object->buckets[h % object->nbuckets];
		    si != STN_UNDEF; si = object->chains[si]) {
			const Elf_Sym *sym = symt + si;
d222 41
a262 2
			if (sym->st_value == 0)
				continue;
d264 35
a298 2
			if (ELF_ST_TYPE(sym->st_info) != STT_NOTYPE &&
			    ELF_ST_TYPE(sym->st_info) != STT_OBJECT &&
d301 1
d303 7
a309 36
			symn = strt + sym->st_name;
			if (sym != *ref && _dl_strcmp(symn, name))
				continue;

			/* allow this symbol if we are referring to a function
			 * which has a value, even if section is UNDEF.
			 * this allows &func to refer to PLT as per the
			 * ELF spec. st_value is checked above.
			 * if flags has SYM_PLT set, we must have actual
			 * symbol, so this symbol is skipped.
			 */
			if (sym->st_shndx == SHN_UNDEF) {
				if ((flags & SYM_PLT) || sym->st_value == 0 ||
				    ELF_ST_TYPE(sym->st_info) != STT_FUNC)
					continue;
			}

			if (ELF_ST_BIND(sym->st_info) == STB_GLOBAL) {
				*ref = sym;
				if (req_size != sym->st_size &&
				    req_size != 0 &&
				    (ELF_ST_TYPE(sym->st_info) != STT_FUNC)) {
					_dl_printf("%s: %s : WARNING: "
					    "symbol(%s) size mismatch ",
					    _dl_progname, object->load_name,
					    symn);
					_dl_printf("relink your program\n");
				}
				return(object->load_offs);
			} else if (ELF_ST_BIND(sym->st_info) == STB_WEAK) {
				if (!weak_sym) {
					weak_sym = sym;
					weak_symn = symn;
					weak_offs = object->load_offs;
					weak_object = object;
				}
d313 1
a313 14
	if (flags & SYM_WARNNOTFOUND && weak_sym == NULL) {
		_dl_printf("%s:%s: undefined symbol '%s'\n",
		    _dl_progname, module_name, name);
	}
	*ref = weak_sym;
	if (weak_sym != NULL && req_size != weak_sym->st_size &&
	    req_size != 0 && (ELF_ST_TYPE(weak_sym->st_info) != STT_FUNC)) {
		_dl_printf("%s:%s: %s : WARNING: "
		    "symbol(%s) size mismatch ",
		    _dl_progname, module_name, weak_object->load_name,
		    weak_symn);
		_dl_printf("relink your program\n");
	}
	return (weak_offs);
@


1.18
log
@pefo 3/4 licence cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.17 2003/02/02 16:57:58 deraadt Exp $ */
d43 26
a68 2
 * Initialize and add a new dynamic object to the object list.
 * Perform necessary relocations of pointers.
d71 1
a71 1
_dl_add_object(const char *objname, Elf_Dyn *dynp, const u_long *dl_data,
d81 1
a81 9

	object->next = NULL;
	if (_dl_objects == 0) {			/* First object ? */
		_dl_last_object = _dl_objects = object;
	} else {
		_dl_last_object->next = object;
		object->prev = _dl_last_object;
		_dl_last_object = object;
	}
@


1.17
log
@knf & ansi; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.16 2003/01/30 03:46:46 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@Change the constructor execution order to initialize dependant libraries
first. This mirrors the commit espie put in a.out ld.so recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.15 2002/11/23 04:09:34 drahn Exp $ */
d49 2
a50 2
 *	Initialize and add a new dynamic object to the object list.
 *	Perform necessary relocations of pointers.
d54 1
a54 1
	const int objtype, const long laddr, const long loff)
d197 1
a197 2
	for (object = startlook;
	    object;
d217 1
a217 2
			if (sym != *ref &&
			    _dl_strcmp(symn, name))
d227 1
a227 1
			if (sym->st_shndx == SHN_UNDEF)  {
d229 1
a229 1
				    ELF_ST_TYPE(sym->st_info) != STT_FUNC) {
a230 1
				}
d268 1
a268 1
	return(weak_offs);
@


1.15
log
@Remove some error messages which were incorrectly printed. Some cleanup.
ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.14 2002/11/14 15:15:54 drahn Exp $ */
d135 2
@


1.14
log
@Make error messages on symbol lookup failures more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.13 2002/08/23 22:57:03 drahn Exp $ */
d180 1
a180 1
	const Elf_Sym *weak_sym = 0;
d185 1
a185 1
	elf_object_t *object;
d251 1
d256 3
a258 6
	if (flags & SYM_WARNNOTFOUND) {
		if (!weak_sym && ((*ref == NULL) ||
		    ELF_ST_BIND((*ref)->st_info) != STB_WEAK)) {
			_dl_printf("%s:%s: undefined symbol '%s'\n",
			    _dl_progname, module_name, name);
		}
d261 1
a261 1
	if (weak_sym && req_size != weak_sym->st_size &&
d265 1
a265 1
		    _dl_progname, module_name, object->load_name,
@


1.13
log
@Change arguments to _dl_find_symbol() myself, warnnotfound, and inplt into
a single flags field with bits representing each. Use defines to create
the appropriate masks.

Add a new argument sym_size to warn about symbols which have
the incorrect size. This replaces 'ifdef notyet' code which
was in several of the md files with a single version.
sym_size == 0 means do not check, and symbols of type FUNC are
not checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.12 2002/08/11 16:51:04 drahn Exp $ */
d178 1
a178 1
    const Elf_Sym **ref, int flags, int req_size)
d181 1
a181 1
	const char *weak_symn = ""; /* remove warning */
d256 4
a259 4
		if (!weak_sym && *ref &&
		    ELF_ST_BIND((*ref)->st_info) != STB_WEAK) {
			_dl_printf("%s: undefined symbol '%s'\n",
			    _dl_progname, name);
d265 1
a265 1
		_dl_printf("%s: %s : WARNING: "
d267 1
a267 1
		    _dl_progname, object->load_name,
@


1.12
log
@Fix for Elfbug, the Xtiherit problem which has been seen on most OpenBSD
ELF dynamic systems. This was due to an oddity in ELF where the address of
fuctions refer to the PLT address in the program, rather than the actual
function address.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.11 2002/07/07 08:54:50 jufi Exp $ */
d178 1
a178 1
    const Elf_Sym **ref, int myself, int warnnotfound, int inplt)
d181 1
d195 3
a197 1
	for (object = startlook; object; object = (myself ? 0 : object->next)) {
d201 1
d215 1
d217 1
a217 1
			    _dl_strcmp(strt + sym->st_name, name))
d220 7
d228 2
a229 2
				if ((inplt || sym->st_value == 0 ||
				    ELF_ST_TYPE(sym->st_info) != STT_FUNC)) {
d236 9
d249 1
d255 1
a255 1
	if (warnnotfound) {
d263 8
@


1.11
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.10 2002/05/28 00:22:01 deraadt Exp $ */
d178 1
a178 1
    const Elf_Sym **ref, int myself, int warnnotfound)
d203 1
a203 2
			if (sym->st_value == 0 ||
			    sym->st_shndx == SHN_UNDEF)
d214 7
@


1.10
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.9 2002/05/24 04:17:00 deraadt Exp $ */
d92 1
a92 1
	 *  the ones which has pointer values.
@


1.9
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.8 2002/05/24 03:44:37 deraadt Exp $ */
a51 1

d75 1
a75 1
		if (dynp->d_tag < DT_NUM) {
d77 4
a80 5
		} else if (dynp->d_tag >= DT_LOPROC &&
			    dynp->d_tag < DT_LOPROC + DT_NUM) {
			object->Dyn.info[dynp->d_tag + DT_NUM - DT_LOPROC] = dynp->
d_un.d_val;
		}
d178 1
a178 1
			const Elf_Sym **ref, int myself, int warnnotfound)
d180 2
a184 2
	const Elf_Sym *weak_sym = 0;
	Elf_Addr weak_offs = 0;
d189 1
a189 1
		if ((g = h & 0xf0000000)) {
a190 1
		}
@


1.8
log
@various KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.7 2002/03/17 04:46:53 drahn Exp $ */
d123 1
a123 1
		object->nchains  = hashtab[1];
d125 1
a125 1
		object->chains   = object->buckets + object->nbuckets;
d231 1
a231 2
		if (!weak_sym &&
		    *ref &&
@


1.7
log
@Keep _dl_last_object in sync with reality if last element in list is deleted.
allocated memory is not necessarily 0ed, make sure next pointer is inited.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.6 2002/02/21 23:17:53 drahn Exp $ */
d5 1
a5 1
 * 
d60 1
a60 1
		objname, dynp, dl_data, objtype, laddr, loff);
d96 1
a96 1
	if(object->Dyn.info[DT_PLTGOT])
d98 1
a98 1
	if(object->Dyn.info[DT_HASH])
d100 1
a100 1
	if(object->Dyn.info[DT_STRTAB])
d102 1
a102 1
	if(object->Dyn.info[DT_SYMTAB])
d104 1
a104 1
	if(object->Dyn.info[DT_RELA])
d106 1
a106 1
	if(object->Dyn.info[DT_SONAME])
d108 1
a108 1
	if(object->Dyn.info[DT_RPATH])
d110 1
a110 1
	if(object->Dyn.info[DT_REL])
d112 1
a112 1
	if(object->Dyn.info[DT_INIT])
d114 1
a114 1
	if(object->Dyn.info[DT_FINI])
d116 1
a116 1
	if(object->Dyn.info[DT_JMPREL])
a136 1

a139 1

d146 1
a146 1
	if(object->next) {
d148 2
a149 2
	}
	if (_dl_last_object == object) {
d151 2
a152 2
	}
	if(object->load_name) {
d154 2
a155 2
	}
	while((depobj = object->dep_next)) {
d169 2
a170 2
	while(object) {
		if(_dl_strcmp(name, object->load_name) == 0) {
a171 1
		}
d191 1
a191 1
		if((g = h & 0xf0000000)) {
d198 2
a199 2
		const Elf_Sym *symt;
		const char	*strt;
a201 4
		symt = object->dyn.symtab;
		strt = object->dyn.strtab;


d207 1
a207 1
			    sym->st_shndx == SHN_UNDEF) {
a208 1
			}
d212 1
a212 1
			    ELF_ST_TYPE(sym->st_info) != STT_FUNC) {
a213 2
			}

d216 1
a216 1
			    _dl_strcmp(strt + sym->st_name, name)) {
a217 1
			}
d235 1
a235 1
				_dl_progname, name);
a240 1

@


1.6
log
@cleanup of MD/MI ld.so (elf), most changes by art@@ cleanup by me.
tested on alpha sparc64 powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.5 2001/09/25 14:06:48 art Exp $ */
d65 1
d150 3
@


1.5
log
@Cleaner hash bucket init and some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.4 2001/06/08 06:46:59 art Exp $ */
a47 2
void * _dl_malloc(int);

d134 1
a134 2
	object->load_name = (char *)_dl_malloc(_dl_strlen(objname) + 1);
	_dl_strcpy(object->load_name, objname);
@


1.4
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.3 2001/05/31 22:10:06 art Exp $ */
d120 6
a125 4
	object->buckets = object->dyn.hash;
	if(object->buckets != 0) {
		object->nbuckets = *object->buckets++;
		object->nchains  = *object->buckets++;
d129 1
a129 1
	if(dl_data) {
d190 1
a190 1
	while(*p) {
d199 1
a199 1
	for(object = startlook; object; object = (myself ? 0 : object->next)) {
d202 1
a202 1
		u_int32_t	si;
d207 3
a209 2
		for(si = object->buckets[h % object->nbuckets];
			si != STN_UNDEF; si = object->chains[si]) {
d212 2
a213 2
			if(sym->st_value == 0 ||
			   sym->st_shndx == SHN_UNDEF) {
d217 3
a219 3
			if(ELF_ST_TYPE(sym->st_info) != STT_NOTYPE &&
			   ELF_ST_TYPE(sym->st_info) != STT_OBJECT &&
			   ELF_ST_TYPE(sym->st_info) != STT_FUNC) {
d223 3
a225 1
			if(sym != *ref && _dl_strcmp(strt+sym->st_name, name)) {
d229 1
a229 1
			if(ELF_ST_BIND(sym->st_info) == STB_GLOBAL) {
d232 2
a233 3
			}
			else if(ELF_ST_BIND(sym->st_info) == STB_WEAK) {
				if(!weak_sym) {
d241 3
a243 3
		if(!weak_sym &&
			*ref && ELF_ST_BIND((*ref)->st_info) != STB_WEAK)
		{
@


1.3
log
@unsigned long, not u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.2 2001/04/02 23:11:21 drahn Exp $ */
d56 2
a57 3
_dl_add_object(const char *objname, Elf_Dyn *dynp,
			     const u_long *dl_data, const int objtype,
			     const long laddr, const long loff)
d65 1
a65 1
	object = (elf_object_t *)_dl_malloc(sizeof(elf_object_t));
d67 1
a67 1
	if(_dl_objects == 0) {	/* First object ? */
d69 1
a69 2
	}
	else {
d76 2
a77 2
	while(dynp->d_tag != DT_NULL) {
		if(dynp->d_tag < DT_NUM) {
d79 2
a80 2
		}
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM) {
d84 1
a84 1
		if(dynp->d_tag == DT_TEXTREL)
d86 1
a86 1
		if(dynp->d_tag == DT_SYMBOLIC)
d88 1
a88 1
		if(dynp->d_tag == DT_BIND_NOW)
@


1.2
log
@Cleanup for 64bit support.
Pieces by art, niklas and me.
Only tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: resolve.c,v 1.1.1.2 2000/06/13 03:40:07 rahnds Exp $ */
d184 1
a184 1
	u_int32_t h = 0;
d191 1
a191 1
		u_int32_t g;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
a40 1
#include "resolve.h"
d43 1
d48 1
d56 3
a58 3
_dl_add_object(const char *objname, Elf32_Dyn *dynp,
			     const u_int32_t *dl_data, const int objtype,
			     const int laddr, const int loff)
d61 4
d79 1
a79 1
		if(dynp->d_tag < DT_PROCNUM) {
d82 1
a82 1
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_PROCNUM) {
d112 1
a112 1
		object->Dyn.info[DT_RPATH] += loff;
d119 2
d130 1
a130 1
		object->phdrp = (Elf32_Phdr *) dl_data[AUX_phdr];
d180 1
a180 1
Elf32_Addr
d182 1
a182 1
			const Elf32_Sym **ref, int myself)
d187 2
a188 2
	const Elf32_Sym *weak_sym = 0;
	Elf32_Addr weak_offs = 0;
d200 1
a200 1
		const Elf32_Sym *symt;
d209 1
a209 1
			const Elf32_Sym *sym = symt + si;
d216 3
a218 3
			if(ELF32_ST_TYPE(sym->st_info) != STT_NOTYPE &&
			   ELF32_ST_TYPE(sym->st_info) != STT_OBJECT &&
			   ELF32_ST_TYPE(sym->st_info) != STT_FUNC) {
d226 1
a226 1
			if(ELF32_ST_BIND(sym->st_info) == STB_GLOBAL) {
d230 1
a230 1
			else if(ELF32_ST_BIND(sym->st_info) == STB_WEAK) {
d238 7
a244 2
	if(!weak_sym && *ref && ELF32_ST_BIND((*ref)->st_info) != STB_WEAK) {
		_dl_printf("%s: undefined symbol '%s'\n", _dl_progname, name);
@


1.1.1.1
log
@Initial import of ELF ld.so. This was written indepently of the gnu rtld
code and is fully BSD copyrighted.
This initial import contains a mostly working mips and partially working
powerpc version. No support for ld.so.hints or system run path exists.

@
text
@@


1.1.1.2
log
@Updated version of ld.so, contains additional functionality and fixes/
design changes required by egcs.

added support for ldconfig/ld.so.hints

changes to low level relocation code, required by egcs pic
code generation that moved global variable loads to before the
self relocation was performed. Only powerpc supported, mips code not updated.

Code cleaned up somewhat reasonably.

This code needs to be reviewed closely for significant problems
such as correctness and security.
@
text
@a38 1
#include <nlist.h>
d40 1
a42 1
#include "resolve.h"
a46 1
void * _dl_malloc(int);
a58 4
#if 0
	_dl_printf("objname [%s], dynp %x, dl_data %x, objtype %x laddr %x, loff %x\n",
		objname, dynp, dl_data, objtype, laddr, loff);
#endif
d73 1
a73 1
		if(dynp->d_tag < DT_NUM) {
d76 1
a76 1
		else if(dynp->d_tag >= DT_LOPROC && dynp->d_tag < DT_LOPROC + DT_NUM) {
d106 1
a106 1
		object->Dyn.info[DT_RPATH] += object->Dyn.info[DT_STRTAB];
a112 2
	if(object->Dyn.info[DT_JMPREL])
		object->Dyn.info[DT_JMPREL] += loff;
d174 1
a174 1
			const Elf32_Sym **ref, int myself, int warnnotfound)
d230 2
a231 7
	if (warnnotfound) {
		if(!weak_sym &&
			*ref && ELF32_ST_BIND((*ref)->st_info) != STB_WEAK)
		{
			_dl_printf("%s: undefined symbol '%s'\n",
				_dl_progname, name);
		}
@

