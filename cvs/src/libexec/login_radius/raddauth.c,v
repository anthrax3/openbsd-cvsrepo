head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.20
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.18
	OPENBSD_5_0:1.23.0.16
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.14
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.12
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.29
date	2016.09.03.11.04.23;	author gsoares;	state Exp;
branches;
next	1.28;
commitid	SybyyJTSqmUlLCHl;

1.28
date	2015.10.05.17.31.17;	author millert;	state Exp;
branches;
next	1.27;
commitid	TEnCycDCWPhCYHBk;

1.27
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2014.08.10.05.06.38;	author guenther;	state Exp;
branches;
next	1.25;
commitid	lVirdXjpTpLaWfCP;

1.25
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.14.14.23.25;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.20.21.28.09;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.14.13.53.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.19.23.02.25;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.12.13.28.00;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.02.21.51.17;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.11.03.19.08;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.10.21.30.27;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2004.03.03.22.05.15;	author jcs;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.06.21.54.38;	author deraadt;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.09.29.03.23.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.29.00.54.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.26.22.48.33;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2002.09.06.18.45.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.28.01.14.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.07.23.29.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.18.18.56.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.18.18.31.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.26.20.47.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.09.18.59.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.08.20.26.51;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.08.17.56.33;	author millert;	state Exp;
branches;
next	;

1.14.2.1
date	2004.09.12.03.46.55;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2004.09.11.21.06.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.29
log
@convert to use readpassphrase() instead of DEPRECATED/getpass()
OK millert@@
@
text
@/*	$OpenBSD: raddauth.c,v 1.28 2015/10/05 17:31:17 millert Exp $	*/

/*-
 * Copyright (c) 1996, 1997 Berkeley Software Design, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: raddauth.c,v 1.6 1998/04/14 00:39:04 prb Exp $
 */
/*
 * Copyright(c) 1996 by tfm associates.
 * All rights reserved.
 *
 * tfm associates
 * P.O. Box 2086
 * Eugene OR 97402-0031
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of tfm associates may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TFM ASSOC``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TFM ASSOCIATES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdint.h>
#include <limits.h>
#include <login_cap.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <md5.h>
#include <readpassphrase.h>
#include "login_radius.h"


#define	MAXPWNETNAM		64	/* longest username */
#define MAXSECRETLEN		128	/* maximum length of secret */

#define AUTH_VECTOR_LEN			16
#define AUTH_HDR_LEN			20
#define	AUTH_PASS_LEN			(256 - 16)
#define	PW_AUTHENTICATION_REQUEST	1
#define	PW_AUTHENTICATION_ACK		2
#define	PW_AUTHENTICATION_REJECT	3
#define PW_ACCESS_CHALLENGE		11
#define	PW_USER_NAME			1
#define	PW_PASSWORD			2
#define	PW_CLIENT_ID			4
#define	PW_CLIENT_PORT_ID		5
#define PW_PORT_MESSAGE			18
#define PW_STATE			24

#ifndef	RADIUS_DIR
#define RADIUS_DIR		"/etc/raddb"
#endif
#define RADIUS_SERVERS		"servers"

char *radius_dir = RADIUS_DIR;
char auth_secret[MAXSECRETLEN+1];
volatile sig_atomic_t timedout;
int alt_retries;
int retries;
int sockfd;
int timeout;
in_addr_t alt_server;
in_addr_t auth_server;
in_port_t radius_port;

typedef struct {
	u_char	code;
	u_char	id;
	u_short	length;
	u_char	vector[AUTH_VECTOR_LEN];
	u_char	data[4096 - AUTH_HDR_LEN];
} auth_hdr_t;

void servtimeout(int);
in_addr_t get_ipaddr(char *);
in_addr_t gethost(void);
int rad_recv(char *, char *, u_char *);
void parse_challenge(auth_hdr_t *, char *, char *);
void rad_request(u_char, char *, char *, int, char *, char *);
void getsecret(void);

/*
 * challenge -- NULL for interactive service
 * password -- NULL for interactive service and when requesting a challenge
 */
int
raddauth(char *username, char *class, char *style, char *challenge,
    char *password, char **emsg)
{
	static char _pwstate[1024];
	u_char req_id;
	char *userstyle, *passwd, *pwstate, *rad_service;
	char pbuf[AUTH_PASS_LEN+1];
	int auth_port;
	char vector[AUTH_VECTOR_LEN+1], *p, *v;
	int i;
	login_cap_t *lc;
	u_int32_t r;
	struct servent *svp;
	struct sockaddr_in sin;
	struct sigaction sa;
	const char *errstr;

	memset(_pwstate, 0, sizeof(_pwstate));
	pwstate = password ? challenge : _pwstate;

	if ((lc = login_getclass(class)) == NULL) {
		snprintf(_pwstate, sizeof(_pwstate),
		    "%s: no such class", class);
		*emsg = _pwstate;
		return (1);
	}

	rad_service = login_getcapstr(lc, "radius-port", "radius", "radius");
	timeout = login_getcapnum(lc, "radius-timeout", 2, 2);
	retries = login_getcapnum(lc, "radius-retries", 6, 6);

	if (timeout < 1)
		timeout = 1;
	if (retries < 2)
		retries = 2;

	if (challenge == NULL) {
		passwd = NULL;
		v = login_getcapstr(lc, "radius-challenge-styles",
		    NULL, NULL);
		i = strlen(style);
		while (v && (p = strstr(v, style)) != NULL) {
			if ((p == v || p[-1] == ',') &&
			    (p[i] == ',' || p[i] == '\0')) {
				passwd = "";
				break;
			}
			v = p+1;
		}
		if (passwd == NULL)
			passwd = readpassphrase("Password:", pbuf, sizeof(pbuf),
			    RPP_ECHO_OFF);
	} else
		passwd = password;
	if (passwd == NULL)
		passwd = "";

	if ((v = login_getcapstr(lc, "radius-server", NULL, NULL)) == NULL){
		*emsg = "radius-server not configured";
		return (1);
	}

	auth_server = get_ipaddr(v);

	if ((v = login_getcapstr(lc, "radius-server-alt", NULL, NULL)) == NULL)
		alt_server = 0;
	else {
		alt_server = get_ipaddr(v);
		alt_retries = retries/2;
		retries >>= 1;
	}

	/* get port number */
	radius_port = strtonum(rad_service, 1, UINT16_MAX, &errstr);
	if (errstr) {
		svp = getservbyname(rad_service, "udp");
		if (svp == NULL) {
			snprintf(_pwstate, sizeof(_pwstate),
			    "No such service: %s/udp", rad_service);
			*emsg = _pwstate;
			return (1);
		}
		radius_port = svp->s_port;
	} else
		radius_port = htons(radius_port);

	/* get the secret from the servers file */
	getsecret();

	/* set up socket */
	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		snprintf(_pwstate, sizeof(_pwstate), "%s", strerror(errno));
		*emsg = _pwstate;
		return (1);
	}

	/* set up client structure */
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = radius_port;

	req_id = (u_char) arc4random();
	auth_port = ttyslot();
	if (auth_port == 0)
		auth_port = (int)getppid();
	if (strcmp(style, "radius") != 0) {
		if (asprintf(&userstyle, "%s:%s", username, style) == -1)
			err(1, NULL);
	} else
		userstyle = username;

	/* generate random vector */
	for (i = 0; i < AUTH_VECTOR_LEN;) {
		r = arc4random();
		memcpy(&vector[i], &r, sizeof(r));
		i += sizeof(r);
	}
	vector[AUTH_VECTOR_LEN] = '\0';

	sigemptyset(&sa.sa_mask);
	sa.sa_handler = servtimeout;
	sa.sa_flags = 0;		/* don't restart system calls */
	(void)sigaction(SIGALRM, &sa, NULL);
retry:
	if (timedout) {
		timedout = 0;
		if (--retries <= 0) {
			/*
			 * If we ran out of tries but there is an alternate
			 * server, switch to it and try again.
			 */
			if (alt_retries) {
				auth_server = alt_server;
				retries = alt_retries;
				alt_retries = 0;
				getsecret();
			} else
				warnx("no response from authentication server");
		}
	}

	if (retries > 0) {
		rad_request(req_id, userstyle, passwd, auth_port, vector,
		    pwstate);

		switch (i = rad_recv(_pwstate, challenge, vector)) {
		case PW_AUTHENTICATION_ACK:
			/*
			 * Make sure we don't think a challenge was issued.
			 */
			if (challenge)
				*challenge = '\0';
			return (0);

		case PW_AUTHENTICATION_REJECT:
			return (1);

		case PW_ACCESS_CHALLENGE:
			/*
			 * If this is a response then reject them if
			 * we got a challenge.
			 */
			if (password)
				return (1);
			/*
			 * If we wanted a challenge, just return
			 */
			if (challenge) {
				if (strcmp(challenge, _pwstate) != 0)
					syslog(LOG_WARNING,
				    "challenge for %s does not match state",
				    userstyle);
				return (0);
			}
			req_id++;
			if ((passwd = readpassphrase("", pbuf, sizeof(pbuf),
				    RPP_ECHO_OFF)) == NULL)
				passwd = "";
			break;

		default:
			if (timedout)
				goto retry;
			snprintf(_pwstate, sizeof(_pwstate),
			    "invalid response type %d\n", i);
			*emsg = _pwstate;
			return (1);
		}
	}
	return (1);
}

/*
 * Build a radius authentication digest and submit it to the radius server
 */
void
rad_request(u_char id, char *name, char *password, int port, char *vector,
    char *state)
{
	auth_hdr_t auth;
	int i, len, secretlen, total_length, p;
	struct sockaddr_in sin;
	u_char md5buf[MAXSECRETLEN+AUTH_VECTOR_LEN], digest[AUTH_VECTOR_LEN],
	    pass_buf[AUTH_PASS_LEN], *pw, *ptr;
	u_int length;
	in_addr_t ipaddr;
	MD5_CTX context;

	memset(&auth, 0, sizeof(auth));
	auth.code = PW_AUTHENTICATION_REQUEST;
	auth.id = id;
	memcpy(auth.vector, vector, AUTH_VECTOR_LEN);
	total_length = AUTH_HDR_LEN;
	ptr = auth.data;

	/* User name */
	*ptr++ = PW_USER_NAME;
	length = strlen(name);
	if (length > MAXPWNETNAM)
		length = MAXPWNETNAM;
	*ptr++ = length + 2;
	memcpy(ptr, name, length);
	ptr += length;
	total_length += length + 2;

	/* Password */
	length = strlen(password);
	if (length > AUTH_PASS_LEN)
		length = AUTH_PASS_LEN;

	p = (length + AUTH_VECTOR_LEN - 1) / AUTH_VECTOR_LEN;
	*ptr++ = PW_PASSWORD;
	*ptr++ = p * AUTH_VECTOR_LEN + 2;

	memset(pass_buf, 0, sizeof(pass_buf));		/* must zero fill */
	strlcpy((char *)pass_buf, password, sizeof(pass_buf));

	/* Calculate the md5 digest */
	secretlen = strlen(auth_secret);
	memcpy(md5buf, auth_secret, secretlen);
	memcpy(md5buf + secretlen, auth.vector, AUTH_VECTOR_LEN);

	total_length += 2;

	/* XOR the password into the md5 digest */
	pw = pass_buf;
	while (p-- > 0) {
		MD5Init(&context);
		MD5Update(&context, md5buf, secretlen + AUTH_VECTOR_LEN);
		MD5Final(digest, &context);
		for (i = 0; i < AUTH_VECTOR_LEN; ++i) {
			*ptr = digest[i] ^ *pw;
			md5buf[secretlen+i] = *ptr++;
			*pw++ = '\0';
		}
		total_length += AUTH_VECTOR_LEN;
	}
	explicit_bzero(pass_buf, strlen(pass_buf));

	/* Client id */
	*ptr++ = PW_CLIENT_ID;
	*ptr++ = sizeof(in_addr_t) + 2;
	ipaddr = gethost();
	memcpy(ptr, &ipaddr, sizeof(in_addr_t));
	ptr += sizeof(in_addr_t);
	total_length += sizeof(in_addr_t) + 2;

	/* client port */
	*ptr++ = PW_CLIENT_PORT_ID;
	*ptr++ = sizeof(in_addr_t) + 2;
	port = htonl(port);
	memcpy(ptr, &port, sizeof(int));
	ptr += sizeof(int);
	total_length += sizeof(int) + 2;

	/* Append the state info */
	if ((state != NULL) && (strlen(state) > 0)) {
		len = strlen(state);
		*ptr++ = PW_STATE;
		*ptr++ = len + 2;
		memcpy(ptr, state, len);
		ptr += len;
		total_length += len + 2;
	}

	auth.length = htons(total_length);

	memset(&sin, 0, sizeof (sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = auth_server;
	sin.sin_port = radius_port;
	if (sendto(sockfd, &auth, total_length, 0, (struct sockaddr *)&sin,
	    sizeof(sin)) == -1)
		err(1, NULL);
}

/*
 * Receive UDP responses from the radius server
 */
int
rad_recv(char *state, char *challenge, u_char *req_vector)
{
	auth_hdr_t auth;
	socklen_t salen;
	struct sockaddr_in sin;
	u_char recv_vector[AUTH_VECTOR_LEN], test_vector[AUTH_VECTOR_LEN];
	MD5_CTX context;

	salen = sizeof(sin);

	alarm(timeout);
	if ((recvfrom(sockfd, &auth, sizeof(auth), 0,
	    (struct sockaddr *)&sin, &salen)) < AUTH_HDR_LEN) {
		if (timedout)
			return(-1);
		errx(1, "bogus auth packet from server");
	}
	alarm(0);

	if (sin.sin_addr.s_addr != auth_server)
		errx(1, "bogus authentication server");

	/* verify server's shared secret */
	memcpy(recv_vector, auth.vector, AUTH_VECTOR_LEN);
	memcpy(auth.vector, req_vector, AUTH_VECTOR_LEN);
	MD5Init(&context);
	MD5Update(&context, (u_char *)&auth, ntohs(auth.length));
	MD5Update(&context, auth_secret, strlen(auth_secret));
	MD5Final(test_vector, &context);
	if (memcmp(recv_vector, test_vector, AUTH_VECTOR_LEN) != 0)
		errx(1, "shared secret incorrect");

	if (auth.code == PW_ACCESS_CHALLENGE)
		parse_challenge(&auth, state, challenge);

	return (auth.code);
}

/*
 * Get IP address of local hostname
 */
in_addr_t
gethost(void)
{
	char hostname[HOST_NAME_MAX+1];

	if (gethostname(hostname, sizeof(hostname)))
		err(1, "gethost");
	return (get_ipaddr(hostname));
}

/*
 * Get an IP address in host in_addr_t notation from a hostname or dotted quad.
 */
in_addr_t
get_ipaddr(char *host)
{
	struct hostent *hp;

	if ((hp = gethostbyname(host)) == NULL)
		return (0);

	return (((struct in_addr *)hp->h_addr)->s_addr);
}

/*
 * Get the secret from the servers file
 */
void
getsecret(void)
{
	FILE *servfd;
	char *host, *secret, buffer[PATH_MAX];
	size_t len;

	snprintf(buffer, sizeof(buffer), "%s/%s",
	    radius_dir, RADIUS_SERVERS);

	if ((servfd = fopen(buffer, "r")) == NULL) {
		syslog(LOG_ERR, "%s: %m", buffer);
		return;
	}

	secret = NULL;			/* Keeps gcc happy */
	while ((host = fgetln(servfd, &len)) != NULL) {
		if (*host == '#') {
			memset(host, 0, len);
			continue;
		}
		if (host[len-1] == '\n')
			--len;
		else {
			/* No trailing newline, must allocate len+1 for NUL */
			if ((secret = malloc(len + 1)) == NULL) {
				memset(host, 0, len);
				continue;
			}
			memcpy(secret, host, len);
			memset(host, 0, len);
			host = secret;
		}
		while (len > 0 && isspace((unsigned char)host[--len]))
			;
		host[++len] = '\0';
		while (isspace((unsigned char)*host)) {
			++host;
			--len;
		}
		if (*host == '\0')
			continue;
		secret = host;
		while (*secret && !isspace((unsigned char)*secret))
			++secret;
		if (*secret)
			*secret++ = '\0';
		if (get_ipaddr(host) != auth_server) {
			memset(host, 0, len);
			continue;
		}
		while (isspace((unsigned char)*secret))
			++secret;
		if (*secret)
			break;
	}
	if (host) {
		strlcpy(auth_secret, secret, sizeof(auth_secret));
		memset(host, 0, len);
	}
	fclose(servfd);
}

void
servtimeout(int signo)
{

	timedout = 1;
}

/*
 * Parse a challenge received from the server
 */
void
parse_challenge(auth_hdr_t *authhdr, char *state, char *challenge)
{
	int length;
	int attribute, attribute_len;
	u_char *ptr;

	ptr = authhdr->data;
	length = ntohs(authhdr->length) - AUTH_HDR_LEN;

	*state = 0;

	while (length > 0) {
		attribute = *ptr++;
		attribute_len = *ptr++;
		length -= attribute_len;
		attribute_len -= 2;

		switch (attribute) {
		case PW_PORT_MESSAGE:
			if (challenge) {
				memcpy(challenge, ptr, attribute_len);
				challenge[attribute_len] = '\0';
			} else
				printf("%.*s", attribute_len, ptr);
			break;
		case PW_STATE:
			memcpy(state, ptr, attribute_len);
			state[attribute_len] = '\0';
			break;
		}
		ptr += attribute_len;
	}
}
@


1.28
log
@Use explicit_bzero() instead of memset() for zeroing out secrets.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.27 2015/01/16 06:39:50 deraadt Exp $	*/
d88 1
d152 1
d196 2
a197 1
			passwd = getpass("Password:");
d322 2
a323 1
			if ((passwd = getpass("")) == NULL)
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.26 2014/08/10 05:06:38 guenther Exp $	*/
d400 1
@


1.26
log
@Only need <stdint.h> and not all of <inttypes.h> here
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.25 2013/11/27 21:25:25 deraadt Exp $	*/
d486 1
a486 1
	char hostname[MAXHOSTNAMELEN];
d514 1
a514 1
	char *host, *secret, buffer[MAXPATHLEN];
@


1.25
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.24 2012/12/04 02:24:47 deraadt Exp $	*/
d76 1
a76 1
#include <inttypes.h>
@


1.24
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.23 2007/12/14 14:23:25 millert Exp $	*/
d543 1
a543 1
		while (len > 0 && isspace(host[--len]))
d546 1
a546 1
		while (isspace(*host)) {
d553 1
a553 1
		while (*secret && !isspace(*secret))
d561 1
a561 1
		while (isspace(*secret))
@


1.23
log
@Add radius-port login.conf variable to allow people to configure a
non-standard port name or number for use when connecting to radiusd.
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.22 2006/09/20 21:28:09 ray Exp $	*/
a68 1
#include <sys/param.h>
@


1.22
log
@Recommit non-static array fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.21 2006/08/14 13:53:34 millert Exp $	*/
d77 1
d123 1
d151 1
a151 1
	char *userstyle, *passwd, *pwstate;
d160 1
d172 1
d175 1
d217 12
a228 5
	svp = getservbyname ("radius", "udp");
	if (svp == NULL) {
		*emsg = "No such service: radius/udp";
		return (1);
	}
d244 1
a244 1
	sin.sin_port = svp->s_port;
a344 1
	struct servent *rad_port;
a429 5
	/* get radius port number */
	rad_port = getservbyname("radius", "udp");
	if (rad_port == NULL)
		errx(1, "no such service: radius/udp");

d433 1
a433 1
	sin.sin_port = rad_port->s_port;
@


1.21
log
@Fix typo introduced in rev 1.16; fixes "login" authentication style.
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.20 2005/11/19 23:02:25 millert Exp $	*/
d147 1
d151 1
a151 1
	char vector[AUTH_VECTOR_LEN+1], _pwstate[1024], *p, *v;
@


1.20
log
@No longer need volatile since longjmp has been removed.
Ironically silences a gcc warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.19 2005/11/12 13:28:00 deraadt Exp $	*/
d192 1
a192 1
	if (password == NULL)
@


1.19
log
@use snprintf; ok cloder dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.18 2005/03/02 21:51:17 cloder Exp $	*/
d147 3
a149 3
	volatile u_char req_id;
	char * volatile userstyle, * volatile passwd, * volatile pwstate;
	volatile int auth_port;
@


1.18
log
@More network randomness.  PIDs on my machine are none of anyone else's
business.  Submitted by Bruno Rohee.  OK cloder@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.17 2004/09/11 03:19:08 millert Exp $	*/
d238 1
a238 4
		int len = strlen(username) + strlen(style) + 2;

		userstyle = malloc(len);
		if (userstyle == NULL)
a239 1
		snprintf(userstyle, len, "%s:%s", username, style);
@


1.17
log
@Verify packets from the server were md5'd with the same shared
secret we used in the request.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.16 2004/03/10 21:30:27 millert Exp $	*/
d136 1
a136 1
void rad_request(pid_t, char *, char *, int, char *, char *);
d147 1
a147 1
	volatile pid_t req_id;
d233 1
a233 1
	req_id = getpid();
d331 1
a331 1
rad_request(pid_t id, char *name, char *password, int port, char *vector,
@


1.16
log
@More checking for a NULL return value from getpass().  otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.15 2004/03/03 22:05:15 jcs Exp $	*/
d134 1
a134 1
int rad_recv(char *, char *);
d281 1
a281 1
		switch (i = rad_recv(_pwstate, challenge)) {
d440 1
a440 1
rad_recv(char *state, char *challenge)
d445 2
d461 10
@


1.16.2.1
log
@MFC:
Fix by millert@@

Verify packets from the server were md5'd with the same shared
secret we used in the request.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.16 2004/03/10 21:30:27 millert Exp $	*/
d134 1
a134 1
int rad_recv(char *, char *, u_char *);
d281 1
a281 1
		switch (i = rad_recv(_pwstate, challenge, vector)) {
d440 1
a440 1
rad_recv(char *state, char *challenge, u_char *req_vector)
a444 2
	u_char recv_vector[AUTH_VECTOR_LEN], test_vector[AUTH_VECTOR_LEN];
	MD5_CTX context;
a458 10

	/* verify server's shared secret */
	memcpy(recv_vector, auth.vector, AUTH_VECTOR_LEN);
	memcpy(auth.vector, req_vector, AUTH_VECTOR_LEN);
	MD5Init(&context);
	MD5Update(&context, (u_char *)&auth, ntohs(auth.length));
	MD5Update(&context, auth_secret, strlen(auth_secret));
	MD5Final(test_vector, &context);
	if (memcmp(recv_vector, test_vector, AUTH_VECTOR_LEN) != 0)
		errx(1, "shared secret incorrect");
@


1.15
log
@assign servtimeout to sa.sa_handler to actually use the alternate
radius server

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.14 2003/07/06 21:54:38 deraadt Exp $	*/
d190 3
a192 3
	} else if (password != NULL)
		passwd =  password;
	else
d311 2
a312 1
			passwd = getpass("");
@


1.14
log
@proto in scope
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.13 2002/09/29 03:23:01 millert Exp $	*/
d256 1
@


1.14.2.1
log
@MFC:
Fix by millert@@

Verify packets from the server were md5'd with the same shared
secret we used in the request.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.14 2003/07/06 21:54:38 deraadt Exp $	*/
d134 1
a134 1
int rad_recv(char *, char *, u_char *);
d280 1
a280 1
		switch (i = rad_recv(_pwstate, challenge, vector)) {
d438 1
a438 1
rad_recv(char *state, char *challenge, u_char *req_vector)
a442 2
	u_char recv_vector[AUTH_VECTOR_LEN], test_vector[AUTH_VECTOR_LEN];
	MD5_CTX context;
a456 10

	/* verify server's shared secret */
	memcpy(recv_vector, auth.vector, AUTH_VECTOR_LEN);
	memcpy(auth.vector, req_vector, AUTH_VECTOR_LEN);
	MD5Init(&context);
	MD5Update(&context, (u_char *)&auth, ntohs(auth.length));
	MD5Update(&context, auth_secret, strlen(auth_secret));
	MD5Final(test_vector, &context);
	if (memcmp(recv_vector, test_vector, AUTH_VECTOR_LEN) != 0)
		errx(1, "shared secret incorrect");
@


1.13
log
@BSD-licensed as per Stephen Diercouff of tfm associates
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.12 2002/09/29 00:54:49 deraadt Exp $	*/
d88 1
@


1.12
log
@re-add; license will be fixed by millert sometime tonight
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.10 2002/09/06 18:45:06 deraadt Exp $	*/
d41 2
a42 2
 * P.O. Box 1244
 * Eugene OR 97440-1244 USA
d44 22
a65 9
 * This contains unpublished proprietary source code of tfm associates.
 * The copyright notice above does not evidence any
 * actual or intended publication of such source code.
 *
 * A license is granted to Berkeley Software Design, Inc. by
 * tfm associates to modify and/or redistribute this software under the
 * terms and conditions of the software License Agreement provided with this
 * distribution. The Berkeley Software Design Inc. software License
 * Agreement specifies the terms and conditions for redistribution.
@


1.11
log
@Makefile
@
text
@@


1.10
log
@ansi; ok millert pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.9 2002/06/28 01:14:37 deraadt Exp $	*/
@


1.9
log
@minor indent cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.8 2002/05/22 06:35:44 deraadt Exp $	*/
d355 1
a355 1
	strlcpy(pass_buf, password, sizeof(pass_buf));
@


1.8
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.7 2001/12/07 23:29:06 millert Exp $	*/
d45 1
a45 1
 * The copyright notice above does not evidence any 
d47 1
a47 1
 * 
d355 1
a355 1
	strlcpy(pass_buf, password, sizeof(pass_buf));	
d472 1
a472 1
        	return (0);
d483 1
a483 1
    	FILE *servfd;
@


1.7
log
@Kill longjmp by not restarting system calls on receipt of SIGALRM.
We can then just check the flag to see that the alarm ran out.
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.6 2001/08/18 18:56:39 deraadt Exp $	*/
d224 3
a226 1
		userstyle = malloc(strlen(username) + strlen(style) + 2);
d229 1
a229 1
		sprintf(userstyle, "%s:%s", username, style);
d488 1
a488 1
		radius_dir, RADIUS_SERVERS);
@


1.6
log
@better handle things; spotted by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.5 2001/08/18 18:31:21 deraadt Exp $	*/
a66 1
#include <setjmp.h>
a105 1
jmp_buf timerfail;
d142 1
d239 4
a242 3
	signal(SIGALRM, servtimeout);
	setjmp(timerfail);

d260 1
a260 1
	while (retries > 0) {
d298 2
a430 1

d432 3
a434 1
	    (struct sockaddr *)&sin, &salen)) < AUTH_HDR_LEN)
d436 1
a545 1
	longjmp(timerfail, 1);
@


1.5
log
@strlcpy invades the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.4 2001/07/26 20:47:44 millert Exp $	*/
d350 2
a351 1
	strlcpy(pass_buf, password, AUTH_PASS_LEN);	/* must zero fill */
@


1.4
log
@Typo: radius-timout -> radius-timeout; noted by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.3 2001/07/09 18:59:25 millert Exp $	*/
d350 1
a350 1
	strncpy(pass_buf, password, AUTH_PASS_LEN);	/* must zero fill */
@


1.3
log
@Use socklen_t, not size_t for type of length arg to recvfrom()
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.2 2001/07/08 20:26:51 millert Exp $	*/
d155 1
a155 1
	timeout = login_getcapnum(lc, "radius-timout", 2, 2);
@


1.2
log
@o make signal handler safe
o add some missing args to prototypes
o some KNF
o use memcpy() to copy random bytes into the vector instead of hand copying
o if servers files ends w/o a newline, alloc space and copy the line
o remove unused function argument "length" from parse_challenge()
@
text
@d1 1
a1 1
/*	$OpenBSD: raddauth.c,v 1.1 2001/07/08 17:56:33 millert Exp $	*/
d422 1
a422 1
	size_t salen;
@


1.1
log
@BSD auth module for radius authentication, from BSDi.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a80 1

d102 1
d120 2
a121 2
in_addr_t get_ipaddr();
in_addr_t gethost();
d123 1
a123 1
void parse_challenge(auth_hdr_t *, int, char *, char *);
d125 1
a125 1
void getsecret();
d152 1
a152 1
		return(1);
d211 1
a211 1
		return(1);
d233 1
a233 1
	for (i = 0; i < AUTH_VECTOR_LEN; i++) {
d235 2
a236 4
		vector[i]   = r & 0xff;
		vector[++i] = (r >> 8)  & 0xff;
		vector[++i] = (r >> 16) & 0xff;
		vector[++i] = (r >> 24) & 0xff;
d243 17
d301 1
a301 1
			return(1);
a306 1

d308 1
a308 4
 *
 *	rad_request() -- build a radius authentication digest and
 *	submit it to the radius server
 *
d331 1
a335 1

d341 1
a341 4
	/* password */

	/* encrypt the password */

d352 1
a352 1
	/* calculate the md5 digest */
d359 1
a359 1
	/* xor the password into the md5 digest */
d373 1
a373 2

	/* client id */
d416 1
a416 3
 *
 * rad_recv() -- receive udp responses from the radius server
 *
d422 1
a422 1
	int nread, salen;
d429 3
a431 2
	nread = recvfrom(sockfd, &auth, sizeof(auth), 0,
				(struct sockaddr *)&sin, &salen);
d438 1
a438 1
		parse_challenge(&auth, nread, state, challenge);
d440 1
a440 1
	return(auth.code);
a442 1

d444 1
a444 1
 * gethost() -- get local hostname
d447 1
a447 1
gethost()
d453 1
a453 1
	return(get_ipaddr(hostname));
d457 1
a457 2
 * get_ipaddr -- get an ip address in host long notation from a
 * hostname or dotted quad.
d465 1
a465 1
        	return(0);
d471 1
a471 1
 * get the secret from the servers file
d474 1
a474 1
getsecret()
a488 1

a493 1
		/* XXX - in no newline we could oflow */
d496 10
d508 1
a508 1
		host[len+1] = '\0';
d540 1
a540 13
	if (--retries <= 0) {
		/*
		 * If we ran out of tries but there is an alternate
		 * server, switch to it and try again.
		 */
		if (alt_retries) {
			auth_server = alt_server;
			retries = alt_retries;
			alt_retries = 0;
			getsecret();
		} else
			warnx("no response from authentication server");
	}
d544 3
d548 1
a548 1
parse_challenge(auth_hdr_t *authhdr, int length, char *state, char *challenge)
d550 1
@

