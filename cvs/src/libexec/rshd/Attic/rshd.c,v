head	1.57;
access;
symbols
	OPENBSD_5_5:1.54.0.8
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.4
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.53.0.12
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.10
	OPENBSD_5_0:1.53.0.8
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.6
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.52.0.8
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.52.0.4
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.51.0.14
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.51.0.12
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.51.0.10
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.51.0.8
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.51.0.6
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.51.0.4
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.50.0.6
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.50.0.4
	OPENBSD_3_5_BASE:1.50
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	OPENBSD_3_3:1.48.0.4
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.28.0.6
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.28.0.4
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.28.0.2
	OPENBSD_2_4_BASE:1.28
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2014.04.18.15.59.36;	author tedu;	state dead;
branches;
next	1.56;

1.56
date	2014.04.16.19.14.57;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2014.04.16.19.03.14;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.08.19.16.05;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.12.21.21.45;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.03.23.27.19;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.26.09.32.08;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.16.18.38.19;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.16.18.00.44;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.05.22.32.36;	author deraadt;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.07.09.07.04.44;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.11.15.18.51;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.29.21.37.16;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.04.17.51.30;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.28.19.34.32;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.10.17.45.43;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.15.07.13.47;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.20.18.42.38;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.09.14.59.12;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.27.05.21.12;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	99.11.15.01.03.28;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.07.12.08.46.52;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.07.10.18.22.54;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.07.10.08.06.12;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.07.09.23.38.15;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.06.22.19.44.46;	author art;	state Exp;
branches;
next	1.23;

1.23
date	98.06.03.02.35.20;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	98.05.15.04.28.26;	author art;	state Exp;
branches;
next	1.21;

1.21
date	98.02.03.23.39.32;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.07.25.19.41.20;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.07.23.20.36.34;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	97.06.29.11.10.30;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	97.06.15.05.10.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.02.13.22.32.46;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.02.13.22.29.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.13.22.21.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.05.21.09.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.05.14.26.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.05.04.18.30;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.41.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.22.03.41.20;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.11.01.11.30.33;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.26.04.37.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.07.23.19.27.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.22.01.59.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.07.20.01;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.16.22.20.23;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.11.20.09.38.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.22;	author deraadt;	state Exp;
branches;
next	;

1.40.2.1
date	2002.03.19.04.28.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Malak: I think we made the merchant angry.
Conan: Are you surprised?
Malak: But we didn't steal everything he had!
Conan: We didn't have time.
@
text
@/*	$OpenBSD: rshd.c,v 1.56 2014/04/16 19:14:57 okan Exp $	*/

/*-
 * Copyright (c) 1988, 1989, 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * remote shell server:
 *	[port]\0
 *	remuser\0
 *	locuser\0
 *	command\0
 *	data
 */
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <stdarg.h>
#include <login_cap.h>
#include <bsd_auth.h>

int	keepalive = 1;
int	check_all;
int	log_success;		/* If TRUE, log all successful accesses */
int	sent_null;
login_cap_t *lc;

void	 doit(struct sockaddr *);
void	 error(const char *, ...);
void	 getstr(char *, int, char *);
int	 local_domain(char *);
char	*topdomain(char *);
void	 usage(void);

#define	P_SOCKREAD	0
#define	P_PIPEREAD	1

int
main(int argc, char *argv[])
{
	extern int __check_rhosts_file;
	struct linger linger;
	int ch, on = 1;
	socklen_t fromlen;
	struct sockaddr_storage from;

	openlog("rshd", LOG_PID | LOG_ODELAY, LOG_DAEMON);

	opterr = 0;
	while ((ch = getopt(argc, argv, "aLln")) != -1)
		switch (ch) {
		case 'a':
			check_all = 1;
			break;
		case 'L':
			log_success = 1;
			break;
		case 'l':
			__check_rhosts_file = 0;
			break;
		case 'n':
			keepalive = 0;
			break;
		case '?':
		default:
			usage();
			break;
		}

	argc -= optind;
	argv += optind;

	fromlen = sizeof (from);
	if (getpeername(STDIN_FILENO, (struct sockaddr *)&from, &fromlen) < 0) {
		/* syslog(LOG_ERR, "getpeername: %m"); */
		exit(1);
	}
	if (keepalive &&
	    setsockopt(STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
	    sizeof(on)) < 0)
		syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");
	linger.l_onoff = 1;
	linger.l_linger = 60;			/* XXX */
	if (setsockopt(STDIN_FILENO, SOL_SOCKET, SO_LINGER, (char *)&linger,
	    sizeof (linger)) < 0)
		syslog(LOG_WARNING, "setsockopt (SO_LINGER): %m");
	doit((struct sockaddr *)&from);
	/* NOTREACHED */
	exit(0);
}

char	*envinit[1] = { 0 };
extern char **environ;

void
doit(struct sockaddr *fromp)
{
	extern char *__rcmd_errstr;	/* syslog hook from libc/net/rcmd.c. */
	struct addrinfo hints, *res, *res0;
	int gaierror;
	struct passwd *pwd;
	u_short port;
	in_port_t *portp;
	struct pollfd pfd[2];
	int cc, nfd, pv[2], s = 0, one = 1;
	pid_t pid;
	char *hostname, *errorstr, *errorhost = (char *) NULL;
	char *cp, sig, buf[BUFSIZ];
	char cmdbuf[NCARGS+1], locuser[_PW_NAME_LEN+1], remuser[_PW_NAME_LEN+1];
	char remotehost[2 * MAXHOSTNAMELEN + 1];
	char hostnamebuf[2 * MAXHOSTNAMELEN + 1];
	char naddr[NI_MAXHOST];
	char saddr[NI_MAXHOST];
	char raddr[NI_MAXHOST];
	char pbuf[NI_MAXSERV];
	auth_session_t *as;
	const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;

	(void) signal(SIGINT, SIG_DFL);
	(void) signal(SIGQUIT, SIG_DFL);
	(void) signal(SIGTERM, SIG_DFL);
#ifdef DEBUG
	{ int t = open(_PATH_TTY, 2);
	  if (t >= 0) {
		ioctl(t, TIOCNOTTY, (char *)0);
		(void) close(t);
	  }
	}
#endif
	switch (fromp->sa_family) {
	case AF_INET:
		portp = &((struct sockaddr_in *)fromp)->sin_port;
		break;
	case AF_INET6:
		portp = &((struct sockaddr_in6 *)fromp)->sin6_port;
		break;
	default:
		syslog(LOG_ERR, "malformed \"from\" address (af %d)",
		    fromp->sa_family);
		exit(1);
	}
	if (getnameinfo(fromp, fromp->sa_len, naddr, sizeof(naddr),
	    pbuf, sizeof(pbuf), niflags) != 0) {
		syslog(LOG_ERR, "malformed \"from\" address (af %d)",
		    fromp->sa_family);
		exit(1);
	}

#ifdef IP_OPTIONS
	if (fromp->sa_family == AF_INET) {
		struct ipoption opts;
		socklen_t optsize = sizeof(opts);
		int ipproto, i;
		struct protoent *ip;

		if ((ip = getprotobyname("ip")) != NULL)
			ipproto = ip->p_proto;
		else
			ipproto = IPPROTO_IP;
		if (!getsockopt(STDIN_FILENO, ipproto, IP_OPTIONS,
		    (char *)&opts, &optsize) && optsize != 0) {
			for (i = 0; (void *)&opts.ipopt_list[i] - (void *)&opts <
			    optsize; ) {
				u_char c = (u_char)opts.ipopt_list[i];
				if (c == IPOPT_LSRR || c == IPOPT_SSRR)
					exit(1);
				if (c == IPOPT_EOL)
					break;
				i += (c == IPOPT_NOP) ? 1 :
				    (u_char)opts.ipopt_list[i+1];
			}
		}
	}
#endif

	if (ntohs(*portp) >= IPPORT_RESERVED ||
	    ntohs(*portp) < IPPORT_RESERVED/2) {
		syslog(LOG_NOTICE|LOG_AUTH,
		    "Connection from %s on illegal port %u",
		    naddr, ntohs(*portp));
		exit(1);
	}

	(void) alarm(60);
	port = 0;
	for (;;) {
		char c;
		if ((cc = read(STDIN_FILENO, &c, 1)) != 1) {
			if (cc < 0)
				syslog(LOG_NOTICE, "read: %m");
			shutdown(STDIN_FILENO, SHUT_RDWR);
			exit(1);
		}
		if (c == 0)
			break;
		port = port * 10 + c - '0';
	}

	(void) alarm(0);
	if (port != 0) {
		int lport;
		if (port >= IPPORT_RESERVED ||
		    port < IPPORT_RESERVED/2) {
			syslog(LOG_ERR, "2nd port not reserved");
			exit(1);
		}
		*portp = htons(port);
		lport = IPPORT_RESERVED - 1;
		s = rresvport_af(&lport, fromp->sa_family);
		if (s < 0) {
			syslog(LOG_ERR, "can't get stderr port: %m");
			exit(1);
		}
		if (connect(s, (struct sockaddr *)fromp, fromp->sa_len) < 0) {
			syslog(LOG_INFO, "connect second port %d: %m", port);
			exit(1);
		}
	}

#ifdef notdef
	/* from inetd, socket is already on 0, 1, 2 */
	dup2(f, 0);
	dup2(f, 1);
	dup2(f, 2);
#endif
	errorstr = NULL;
	if (getnameinfo(fromp, fromp->sa_len, saddr, sizeof(saddr),
			NULL, 0, NI_NAMEREQD)== 0) {
		/*
		 * If name returned by getnameinfo is in our domain,
		 * attempt to verify that we haven't been fooled by someone
		 * in a remote net; look up the name and check that this
		 * address corresponds to the name.
		 */
		hostname = saddr;
		res0 = NULL;
		if (check_all || local_domain(saddr)) {
			strlcpy(remotehost, saddr, sizeof(remotehost));
			errorhost = remotehost;
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = fromp->sa_family;
			hints.ai_socktype = SOCK_STREAM;
			hints.ai_flags = AI_CANONNAME;
			gaierror = getaddrinfo(remotehost, pbuf, &hints, &res0);
			if (gaierror) {
				syslog(LOG_INFO,
				    "Couldn't look up address for %s: %s",
				    remotehost, gai_strerror(gaierror));
				errorstr =
				"Couldn't look up address for your host (%s)\n";
				hostname = naddr;
			} else {
				for (res = res0; res; res = res->ai_next) {
					if (res->ai_family != fromp->sa_family)
						continue;
					if (res->ai_addrlen != fromp->sa_len)
						continue;
					if (getnameinfo(res->ai_addr,
						res->ai_addrlen,
						raddr, sizeof(raddr), NULL, 0,
						niflags) == 0
					 && strcmp(naddr, raddr) == 0) {
						hostname = res->ai_canonname
							? res->ai_canonname
							: saddr;
						break;
					}
				}
				if (res == NULL) {
					syslog(LOG_NOTICE,
					  "Host addr %s not listed for host %s",
					    naddr, res0->ai_canonname
							? res0->ai_canonname
							: saddr);
					errorstr =
					    "Host address mismatch for %s\n";
					hostname = naddr;
				}
			}
		}
		strlcpy(hostnamebuf, hostname, sizeof(hostnamebuf));
		hostname = hostnamebuf;
		if (res0)
			freeaddrinfo(res0);
	} else {
		strlcpy(hostnamebuf, naddr, sizeof(hostnamebuf));
		errorhost = hostname = hostnamebuf;
	}

	getstr(remuser, sizeof(remuser), "remuser");
	getstr(locuser, sizeof(locuser), "locuser");
	getstr(cmdbuf, sizeof(cmdbuf), "command");
	pwd = getpwnam(locuser);
	if (pwd == NULL) {
		syslog(LOG_INFO|LOG_AUTH,
		    "%s@@%s as %s: unknown login. cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
		if (errorstr == NULL)
			errorstr = "Permission denied.\n";
		goto fail;
	}
	lc = login_getclass(pwd->pw_class);
	if (lc == NULL) {
		syslog(LOG_INFO|LOG_AUTH,
		    "%s@@%s as %s: unknown class. cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
		if (errorstr == NULL)
			errorstr = "Login incorrect.\n";
		goto fail;
	}
	as = auth_open();
	if (as == NULL || auth_setpwd(as, pwd) != 0) {
		syslog(LOG_INFO|LOG_AUTH,
		    "%s@@%s as %s: unable to allocate memory. cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
		if (errorstr == NULL)
			errorstr = "Cannot allocate memory.\n";
		goto fail;
	}

	setegid(pwd->pw_gid);
	seteuid(pwd->pw_uid);
	if (chdir(pwd->pw_dir) < 0) {
		(void) chdir("/");
#ifdef notdef
		syslog(LOG_INFO|LOG_AUTH,
		    "%s@@%s as %s: no home directory. cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
		error("No remote directory.\n");
		exit(1);
#endif
	}
	seteuid(0);
	setegid(0);	/* XXX use a saved gid instead? */

	if (errorstr ||
	    (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\0' &&
	    iruserok_sa(fromp, fromp->sa_len, pwd->pw_uid == 0,
	    remuser, locuser) < 0)) {
		if (__rcmd_errstr)
			syslog(LOG_INFO|LOG_AUTH,
			    "%s@@%s as %s: permission denied (%s). cmd='%.80s'",
			    remuser, hostname, locuser, __rcmd_errstr,
			    cmdbuf);
		else
			syslog(LOG_INFO|LOG_AUTH,
			    "%s@@%s as %s: permission denied. cmd='%.80s'",
			    remuser, hostname, locuser, cmdbuf);
fail:
		if (errorstr == NULL)
			errorstr = "Permission denied.\n";
		error(errorstr, errorhost);
		exit(1);
	}

	if (pwd->pw_uid)
		auth_checknologin(lc);

	(void) write(STDERR_FILENO, "\0", 1);
	sent_null = 1;

	if (port) {
		if (pipe(pv) < 0) {
			error("Can't make pipe.\n");
			exit(1);
		}
		pid = fork();
		if (pid == -1)  {
			error("Can't fork; try again.\n");
			exit(1);
		}
		if (pid) {
			(void) close(STDIN_FILENO);
			(void) close(STDOUT_FILENO);
			(void) close(STDERR_FILENO);
			(void) close(pv[1]);

			pfd[P_SOCKREAD].fd = s;
			pfd[P_SOCKREAD].events = POLLIN;
			pfd[P_PIPEREAD].fd = pv[0];
			pfd[P_PIPEREAD].events = POLLIN;
			nfd = 2;
			ioctl(pv[0], FIONBIO, (char *)&one);

			/* should set s nbio! */
			do {
				if (poll(pfd, nfd, INFTIM) < 0)
					break;
				if (pfd[P_SOCKREAD].revents & POLLIN) {
					int	ret;
					ret = read(s, &sig, 1);
					if (ret <= 0)
						pfd[P_SOCKREAD].revents = 0;
					else
						killpg(pid, sig);
				}
				if (pfd[P_PIPEREAD].revents & POLLIN) {
					errno = 0;
					cc = read(pv[0], buf, sizeof(buf));
					if (cc <= 0) {
						shutdown(s, SHUT_RDWR);
						pfd[P_PIPEREAD].revents = 0;
					} else {
						(void) write(s, buf, cc);
					}
				}
			} while ((pfd[P_SOCKREAD].revents & POLLIN) ||
			    (pfd[P_PIPEREAD].revents & POLLIN));
			exit(0);
		}
		setsid();
		(void) close(s);
		(void) close(pv[0]);
		dup2(pv[1], 2);
		close(pv[1]);
	} else
		setsid();
	if (*pwd->pw_shell == '\0')
		pwd->pw_shell = _PATH_BSHELL;

	environ = envinit;
	if (setenv("HOME", pwd->pw_dir, 1) == -1 ||
	    setenv("SHELL", pwd->pw_shell, 1) == -1 ||
	    setenv("USER", pwd->pw_name, 1) == -1 ||
	    setenv("LOGNAME", pwd->pw_name, 1) == -1)
		errx(1, "cannot setup environment");

	if (setusercontext(lc, pwd, pwd->pw_uid, LOGIN_SETALL))
		errx(1, "cannot set user context");
	if (auth_approval(as, lc, pwd->pw_name, "rsh") <= 0)
		errx(1, "approval failure");
	auth_close(as);
	login_close(lc);

	cp = strrchr(pwd->pw_shell, '/');
	if (cp)
		cp++;
	else
		cp = pwd->pw_shell;
	endpwent();
	if (log_success || pwd->pw_uid == 0) {
		syslog(LOG_INFO|LOG_AUTH, "%s@@%s as %s: cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
	}
	execl(pwd->pw_shell, cp, "-c", cmdbuf, (char *)NULL);
	perror(pwd->pw_shell);
	exit(1);
}

/*
 * Report error to client.  Note: can't be used until second socket has
 * connected to client, or older clients will hang waiting for that
 * connection first.
 */
void
error(const char *fmt, ...)
{
	va_list ap;
	int len;
	char *bp, buf[BUFSIZ];

	va_start(ap, fmt);
	bp = buf;
	if (sent_null == 0) {
		*bp++ = 1;
		len = 1;
	} else
		len = 0;
	(void)vsnprintf(bp, sizeof(buf) - len, fmt, ap);
	(void)write(STDERR_FILENO, buf, len + strlen(bp));
	va_end(ap);
}

void
getstr(char *buf, int cnt, char *err)
{
	char c;

	do {
		if (read(STDIN_FILENO, &c, 1) != 1)
			exit(1);
		*buf++ = c;
		if (--cnt == 0) {
			error("%s too long\n", err);
			exit(1);
		}
	} while (c != 0);
}

/*
 * Check whether host h is in our local domain,
 * defined as sharing the last two components of the domain part,
 * or the entire domain part if the local domain has only one component.
 * If either name is unqualified (contains no '.'),
 * assume that the host is local, as it will be
 * interpreted as such.
 */
int
local_domain(char *h)
{
	char localhost[MAXHOSTNAMELEN];
	char *p1, *p2;

	localhost[0] = 0;
	(void) gethostname(localhost, sizeof(localhost));
	p1 = topdomain(localhost);
	p2 = topdomain(h);
	if (p1 == NULL || p2 == NULL || !strcasecmp(p1, p2))
		return (1);
	return (0);
}

char *
topdomain(char *h)
{
	char *p, *maybe = NULL;
	int dots = 0;

	for (p = h + strlen(h); p >= h; p--) {
		if (*p == '.') {
			if (++dots == 2)
				return (p);
			maybe = p;
		}
	}
	return (maybe);
}

void
usage(void)
{
	syslog(LOG_ERR, "usage: rshd [-aLln]");
	exit(2);
}
@


1.56
log
@Remove ifdef'd out KerberosIV and stream encryption support.  While
here, sort arguments.

ok tedu miod (who had the same diff with an additional bit of clean-up)
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.54 2012/12/04 02:24:47 deraadt Exp $	*/
@


1.55
log
@add missing parens so that errorhost gets properly initialized.

ok tedu miod (who had the same diff)
@
text
@a79 26
#ifdef	KERBEROS
#include <des.h>
#include <kerberosIV/krb.h>
#define	VERSION_SIZE	9
#define SECURE_MESSAGE  "This rsh session is using DES encryption for all transmissions.\r\n"

#ifdef CRYPT
#define OPTIONS		"alnkvxL"
#else
#define	OPTIONS		"alnkvL"
#endif

char	authbuf[sizeof(AUTH_DAT)];
char	tickbuf[sizeof(KTEXT_ST)];
int	doencrypt, use_kerberos, vacuous;
des_key_schedule schedule;
#ifdef CRYPT
int des_read(int, char *, int);
int des_write(int, char *, int);
void desrw_clear_key();
void desrw_set_key(des_cblock *, des_key_schedule *);
#endif
#else
#define	OPTIONS	"alnL"
#endif

a81 2
#define	P_CRYPTREAD	2
#define	P_CRYPTWRITE	3
d95 1
a95 1
	while ((ch = getopt(argc, argv, OPTIONS)) != -1)
d100 3
a108 18
#ifdef	KERBEROS
		case 'k':
			use_kerberos = 1;
			break;

		case 'v':
			vacuous = 1;
			break;

#ifdef CRYPT
		case 'x':
			doencrypt = 1;
			break;
#endif
#endif
		case 'L':
			log_success = 1;
			break;
a117 13
#ifdef	KERBEROS
	if (use_kerberos && vacuous) {
		syslog(LOG_ERR, "only one of -k and -v allowed");
		exit(2);
	}
#ifdef CRYPT
	if (doencrypt && !use_kerberos) {
		syslog(LOG_ERR, "-k is required for -x");
		exit(2);
	}
#endif
#endif

d149 1
a149 1
	struct pollfd pfd[4];
a163 19
#ifdef	KERBEROS
	AUTH_DAT	*kdata = (AUTH_DAT *) NULL;
	KTEXT		ticket = (KTEXT) NULL;
	char		instance[INST_SZ], version[VERSION_SIZE];
	struct		sockaddr_storage fromaddr;
	int		rc;
	long		authopts;
#ifdef CRYPT
	int		pv1[2], pv2[2];
#endif

	if (sizeof(fromaddr) < fromp->sa_len) {
		syslog(LOG_ERR, "malformed \"from\" address (af %d)",
		    fromp->sa_family);
		exit(1);
	}
	memcpy(&fromaddr, fromp, fromp->sa_len);
#endif

d221 7
a227 10
#ifdef	KERBEROS
	if (!use_kerberos)
#endif
		if (ntohs(*portp) >= IPPORT_RESERVED ||
		    ntohs(*portp) < IPPORT_RESERVED/2) {
			syslog(LOG_NOTICE|LOG_AUTH,
			    "Connection from %s on illegal port %u",
			    naddr, ntohs(*portp));
			exit(1);
		}
d247 5
a251 8
#ifdef	KERBEROS
		if (!use_kerberos)
#endif
			if (port >= IPPORT_RESERVED ||
			    port < IPPORT_RESERVED/2) {
				syslog(LOG_ERR, "2nd port not reserved");
				exit(1);
			}
a264 7
#ifdef	KERBEROS
	if (vacuous) {
		error("rshd: remote host requires Kerberos authentication\n");
		exit(1);
	}
#endif

a281 3
#ifdef	KERBEROS
		if (!use_kerberos)
#endif
a333 35
#ifdef	KERBEROS
	if (use_kerberos) {
		kdata = (AUTH_DAT *) authbuf;
		ticket = (KTEXT) tickbuf;
		authopts = 0L;
		strlcpy(instance, "*", sizeof instance);
		version[VERSION_SIZE - 1] = '\0';
#ifdef CRYPT
		if (doencrypt) {
			struct sockaddr_in local_addr;

			rc = sizeof(local_addr);
			if (getsockname(STDIN_FILENO,
			    (struct sockaddr *)&local_addr, &rc) < 0) {
				syslog(LOG_ERR, "getsockname: %m");
				error("rshd: getsockname: %m");
				exit(1);
			}
			authopts = KOPT_DO_MUTUAL;
			rc = krb_recvauth(authopts, 0, ticket,
			    "rcmd", instance, (struct sockaddr_in *)&fromaddr,
			    &local_addr, kdata, "", schedule, version);
			desrw_set_key(&kdata->session, &schedule);
		} else
#endif
			rc = krb_recvauth(authopts, 0, ticket, "rcmd",
			    instance, (struct sockaddr_in *)&fromaddr,
			    NULL, kdata, "", NULL, version);
		if (rc != KSUCCESS) {
			error("Kerberos authentication failure: %s\n",
				  krb_get_err_text(rc));
			exit(1);
		}
	} else
#endif
a380 13
#ifdef	KERBEROS
	if (use_kerberos) {
		if (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\0') {
			if (kuserok(kdata, locuser) != 0) {
				syslog(LOG_INFO|LOG_AUTH,
				    "Kerberos rsh denied to %s.%s@@%s",
				    kdata->pname, kdata->pinst, kdata->prealm);
				error("Permission denied.\n");
				exit(1);
			}
		}
	} else
#endif
a411 14
#ifdef CRYPT
#ifdef KERBEROS
		if (doencrypt) {
			if (pipe(pv1) < 0) {
				error("Can't make 2nd pipe.\n");
				exit(1);
			}
			if (pipe(pv2) < 0) {
				error("Can't make 3rd pipe.\n");
				exit(1);
			}
		}
#endif
#endif
d418 2
a419 15
#ifdef CRYPT
#ifdef KERBEROS
			if (doencrypt) {
				static char msg[] = SECURE_MESSAGE;
				(void) close(pv1[1]);
				(void) close(pv2[1]);
				des_write(s, msg, sizeof(msg) - 1);

			} else
#endif
#endif
			{
				(void) close(STDIN_FILENO);
				(void) close(STDOUT_FILENO);
			}
d428 1
a428 12
#ifdef CRYPT
#ifdef KERBEROS
			if (doencrypt) {
				pfd[P_CRYPTREAD].fd = pv1[0];
				pfd[P_CRYPTREAD].events = POLLIN;
				pfd[P_CRYPTWRITE].fd = pv2[0];
				pfd[P_CRYPTWRITE].events = POLLOUT;
				nfd += 2;
			} else
#endif
#endif
				ioctl(pv[0], FIONBIO, (char *)&one);
d436 1
a436 8
#ifdef CRYPT
#ifdef KERBEROS
					if (doencrypt)
						ret = des_read(s, &sig, 1);
					else
#endif
#endif
						ret = read(s, &sig, 1);
d449 1
a449 11

#ifdef CRYPT
#ifdef KERBEROS
						if (doencrypt)
							(void)
							  des_write(s, buf, cc);
						else
#endif
#endif
							(void)
							  write(s, buf, cc);
a451 28
#ifdef CRYPT
#ifdef KERBEROS
				if (doencrypt &&
				    (pfd[P_CRYPTREAD].revents & POLLIN)) {
					errno = 0;
					cc = read(pv1[0], buf, sizeof(buf));
					if (cc <= 0) {
						shutdown(pv1[0], SHUT_RDWR);
						pfd[P_CRYPTREAD].revents = 0;
					} else
						(void) des_write(STDOUT_FILENO,
						    buf, cc);
				}

				if (doencrypt &&
				    (pfd[P_CRYPTWRITE].revents & POLLIN)) {
					errno = 0;
					cc = des_read(STDIN_FILENO,
					    buf, sizeof(buf));
					if (cc <= 0) {
						shutdown(pv2[0], SHUT_RDWR);
						pfd[P_CRYPTWRITE].revents = 0;
					} else
						(void) write(pv2[0], buf, cc);
				}
#endif
#endif

a452 5
#ifdef CRYPT
#ifdef KERBEROS
			    (doencrypt && (pfd[P_CRYPTREAD].revents & POLLIN)) ||
#endif
#endif
a458 11
#ifdef CRYPT
#ifdef KERBEROS
		if (doencrypt) {
			close(pv1[0]); close(pv2[0]);
			dup2(pv1[1], 1);
			dup2(pv2[1], 0);
			close(pv1[1]);
			close(pv2[1]);
		}
#endif
#endif
d487 2
a488 10
#ifdef	KERBEROS
		if (use_kerberos)
		    syslog(LOG_INFO|LOG_AUTH,
			"Kerberos shell from %s.%s@@%s on %s as %s, cmd='%.80s'",
			kdata->pname, kdata->pinst, kdata->prealm,
			hostname, locuser, cmdbuf);
		else
#endif
		    syslog(LOG_INFO|LOG_AUTH, "%s@@%s as %s: cmd='%.80s'",
			remuser, hostname, locuser, cmdbuf);
d577 1
a577 2

	syslog(LOG_ERR, "usage: rshd [-%s]", OPTIONS);
@


1.54
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.53 2009/10/27 23:59:31 deraadt Exp $	*/
d421 1
a421 1
	} else
d424 1
a424 1

@


1.53
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.52 2008/04/08 19:16:05 deraadt Exp $	*/
a39 1
#include <sys/param.h>
@


1.52
log
@should not call setpwent(); millert agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.51 2004/11/17 01:47:20 itojun Exp $	*/
a30 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1989, 1992, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/* from: static char sccsid[] = "@@(#)rshd.c	8.2 (Berkeley) 4/6/94"; */
static char *rcsid = "$OpenBSD: rshd.c,v 1.51 2004/11/17 01:47:20 itojun Exp $";
#endif /* not lint */
@


1.51
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.50 2003/08/12 21:21:45 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.50 2003/08/12 21:21:45 millert Exp $";
a475 1
	setpwent();
@


1.50
log
@Convert to use poll(2) instead of static select; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.49 2003/06/02 19:38:24 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.49 2003/06/02 19:38:24 millert Exp $";
a229 3
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
#else
a230 1
#endif
@


1.49
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.48 2002/09/06 19:43:54 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.48 2002/09/06 19:43:54 deraadt Exp $";
a60 1
#include <netdb.h>
d65 1
d67 1
d118 5
d187 1
a187 1
	if (getpeername(0, (struct sockaddr *)&from, &fromlen) < 0) {
d192 1
a192 1
	    setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *)&on,
d197 1
a197 1
	if (setsockopt(0, SOL_SOCKET, SO_LINGER, (char *)&linger,
d217 1
a217 1
	fd_set ready, readfrom;
a244 1
	fd_set		wready, writeto;
d296 2
a297 2
		if (!getsockopt(0, ipproto, IP_OPTIONS, (char *)&opts,
		    &optsize) && optsize != 0) {
d330 1
a330 1
			shutdown(0, 1+1);
d453 2
a454 2
			if (getsockname(0, (struct sockaddr *)&local_addr,
			    &rc) < 0) {
d600 2
a601 2
				(void) close(0);
				(void) close(1);
d603 1
a603 1
			(void) close(2);
d606 5
a610 7
			FD_ZERO(&readfrom);
			FD_SET(s, &readfrom);
			FD_SET(pv[0], &readfrom);
			if (pv[0] > s)
				nfd = pv[0];
			else
				nfd = s;
d614 5
a618 6
				FD_ZERO(&writeto);
				FD_SET(pv2[0], &writeto);
				FD_SET(pv1[0], &readfrom);

				nfd = MAX(nfd, pv2[0]);
				nfd = MAX(nfd, pv1[0]);
a624 1
			nfd++;
d626 3
a628 16
				ready = readfrom;
#ifdef CRYPT
#ifdef KERBEROS
				if (doencrypt) {
					wready = writeto;
					if (select(nfd, &ready,
					    &wready, (fd_set *) 0,
					    (struct timeval *) 0) < 0)
						break;
				} else
#endif
#endif
					if (select(nfd, &ready, (fd_set *)0,
					  (fd_set *)0, (struct timeval *)0) < 0)
						break;
				if (FD_ISSET(s, &ready)) {
d639 1
a639 1
						FD_CLR(s, &readfrom);
d643 1
a643 1
				if (FD_ISSET(pv[0], &ready)) {
d647 2
a648 2
						shutdown(s, 1+1);
						FD_CLR(pv[0], &readfrom);
d650 1
d665 2
a666 1
				if (doencrypt && FD_ISSET(pv1[0], &ready)) {
d670 2
a671 2
						shutdown(pv1[0], 1+1);
						FD_CLR(pv1[0], &readfrom);
d677 2
a678 1
				if (doencrypt && FD_ISSET(pv2[0], &wready)) {
d683 2
a684 2
						shutdown(pv2[0], 1+1);
						FD_CLR(pv2[0], &writeto);
d691 1
a691 1
			} while (FD_ISSET(s, &readfrom) ||
d694 1
a694 1
			    (doencrypt && FD_ISSET(pv1[0], &readfrom)) ||
d697 1
a697 1
			    FD_ISSET(pv[0], &readfrom));
@


1.48
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.47 2002/07/03 23:27:19 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.47 2002/07/03 23:27:19 deraadt Exp $";
@


1.47
log
@ansi on a file which idiots believe is not here anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.46 2002/05/26 09:32:08 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.46 2002/05/26 09:32:08 deraadt Exp $";
d126 2
a127 1
	int ch, on = 1, fromlen;
d287 2
a288 1
		int optsize = sizeof(opts), ipproto, i;
@


1.46
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.45 2002/05/22 06:35:44 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.45 2002/05/22 06:35:44 deraadt Exp $";
d122 1
a122 3
main(argc, argv)
	int argc;
	char *argv[];
d206 1
a206 2
doit(fromp)
	struct sockaddr *fromp;
d284 4
a287 5
	if (fromp->sa_family == AF_INET)
      {
	struct ipoption opts;
	int optsize = sizeof(opts), ipproto, i;
	struct protoent *ip;
d289 16
a304 14
	if ((ip = getprotobyname("ip")) != NULL)
		ipproto = ip->p_proto;
	else
		ipproto = IPPROTO_IP;
	if (!getsockopt(0, ipproto, IP_OPTIONS, (char *)&opts, &optsize) &&
	    optsize != 0) {
		for (i = 0; (void *)&opts.ipopt_list[i] - (void *)&opts <
		    optsize; ) {	
			u_char c = (u_char)opts.ipopt_list[i];
			if (c == IPOPT_LSRR || c == IPOPT_SSRR)
				exit(1);
			if (c == IPOPT_EOL)
				break;
			i += (c == IPOPT_NOP) ? 1 : (u_char)opts.ipopt_list[i+1];
a306 1
      }
d794 1
a794 3
getstr(buf, cnt, err)
	char *buf, *err;
	int cnt;
d818 1
a818 2
local_domain(h)
	char *h;
d833 1
a833 2
topdomain(h)
	char *h;
d849 1
a849 1
usage()
@


1.45
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.44 2002/03/16 18:38:19 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.44 2002/03/16 18:38:19 millert Exp $";
d218 2
a219 2
	int cc, nfd, pv[2], pid, s = 0;
	int one = 1;
@


1.44
log
@Add missing login_close() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.43 2002/03/16 18:00:44 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.43 2002/03/16 18:00:44 millert Exp $";
d446 1
a446 1
		strcpy(instance, "*");
@


1.43
log
@auth_approval() calls getpwnam() which can modify the stashed passwd
struct.  Use auth_setpwd() to stash a copy of the struct so
auth_approval() doesn't need to use getpwnam().  Closes PR 2470.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.42 2002/02/19 19:39:38 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.42 2002/02/19 19:39:38 millert Exp $";
d747 1
@


1.42
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.41 2002/02/16 21:27:31 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.41 2002/02/16 21:27:31 millert Exp $";
d229 1
d499 9
d744 1
a744 1
	if (auth_approval(NULL, lc, pwd->pw_name, "rsh") <= 0)
d746 1
@


1.41
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.40 2001/09/05 22:32:36 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.40 2001/09/05 22:32:36 deraadt Exp $";
d78 1
a764 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a765 1
#ifdef __STDC__
a766 5
#else
error(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d771 1
a771 1
#ifdef __STDC__
a772 3
#else
	va_start(ap);
#endif
@


1.40
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.39 2001/07/09 07:04:44 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.39 2001/07/09 07:04:44 deraadt Exp $";
d87 6
a92 6
void	 doit __P((struct sockaddr *));
void	 error __P((const char *, ...));
void	 getstr __P((char *, int, char *));
int	 local_domain __P((char *));
char	*topdomain __P((char *));
void	 usage __P((void));
d111 4
a114 4
int des_read __P((int, char *, int));
int des_write __P((int, char *, int));
void desrw_clear_key __P(());
void desrw_set_key __P((des_cblock *, des_key_schedule *));
@


1.40.2.1
log
@Pull in patch from current:
Fix (millert):
Avoid potential corruption of passwd pointer by auth_approval().
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.40 2001/09/05 22:32:36 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.40 2001/09/05 22:32:36 deraadt Exp $";
a227 1
	auth_session_t *as;
a496 9
	as = auth_open();
	if (as == NULL || auth_setpwd(as, pwd) != 0) {
		syslog(LOG_INFO|LOG_AUTH,
		    "%s@@%s as %s: unable to allocate memory. cmd='%.80s'",
		    remuser, hostname, locuser, cmdbuf);
		if (errorstr == NULL)
			errorstr = "Cannot allocate memory.\n";
		goto fail;
	}
d733 1
a733 1
	if (auth_approval(as, lc, pwd->pw_name, "rsh") <= 0)
a734 2
	auth_close(as);
	login_close(lc);
@


1.39
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.38 2001/06/11 15:18:51 mickey Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.38 2001/06/11 15:18:51 mickey Exp $";
d795 1
@


1.38
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.37 2001/05/29 21:37:16 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.37 2001/05/29 21:37:16 millert Exp $";
d754 1
a754 1
	execl(pwd->pw_shell, cp, "-c", cmdbuf, 0);
@


1.37
log
@Call auth_checknologin() and auth_approval() as appropriate for BSD
authentication.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.36 2001/02/04 17:51:30 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.36 2001/02/04 17:51:30 millert Exp $";
d388 1
a388 2
			strncpy(remotehost, saddr, sizeof(remotehost) - 1);
			remotehost[sizeof(remotehost) - 1] = 0;
d431 2
a432 2
		hostname = strncpy(hostnamebuf, hostname,
		    sizeof(hostnamebuf) - 1);
d436 2
a437 2
		errorhost = hostname = strncpy(hostnamebuf,
		    naddr, sizeof(hostnamebuf) - 1);
a438 1
	hostnamebuf[sizeof(hostnamebuf) - 1] = '\0';
@


1.36
log
@Use _PW_NAME_LEN+1, not 16 for size of remote/local usernames variables
since rcmd(3) sends strlen(pw_name)+1 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rshd.c,v 1.35 2001/01/28 19:34:32 niklas Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.35 2001/01/28 19:34:32 niklas Exp $";
d79 1
d200 1
a200 1
	return 0;
d331 1
a331 1
		if (c== 0)
d377 1
a377 1
		 * If name returned by gethostbyaddr is in our domain,
d548 2
a549 4
	if (pwd->pw_uid && !access(_PATH_NOLOGIN, F_OK)) {
		error("Logins currently disabled.\n");
		exit(1);
	}
d732 1
a732 1
	
d735 2
d795 1
a795 1
	(void)vsnprintf(bp, sizeof(buf) - 1, fmt, ap);
@


1.35
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: rshd.c,v 1.34 2000/11/10 17:45:43 itojun Exp $";
d220 1
a220 1
	char cmdbuf[NCARGS+1], locuser[16], remuser[16];
@


1.34
log
@correct call to freeaddrinfo.   do not free region before referenced.
reported by ryo@@iij.ad.jp for kame/netbsd, and aaron.
@
text
@d1 2
d44 1
a44 1
static char *rcsid = "$Id: rshd.c,v 1.33 2000/09/15 07:13:47 deraadt Exp $";
@


1.33
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.32 2000/08/20 18:42:38 millert Exp $";
d380 1
a426 1
				freeaddrinfo(res);
d431 2
@


1.32
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.31 2000/03/09 14:59:12 deraadt Exp $";
d724 6
a729 4
	setenv("HOME", pwd->pw_dir, 1);
	setenv("SHELL", pwd->pw_shell, 1);
	setenv("USER", pwd->pw_name, 1);
	setenv("LOGNAME", pwd->pw_name, 1);
@


1.31
log
@-Wall type correctness
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.30 2000/01/27 05:21:12 itojun Exp $";
d65 1
d76 1
d82 1
d200 2
a201 8
char	username[20] = "USER=";
char	logname[23] = "LOGNAME=";
char	homedir[64] = "HOME=";
char	shell[64] = "SHELL=";
char	path[100] = "PATH=";
char	*envinit[] =
	    {homedir, shell, path, logname, username, 0};
char	**environ;
d485 9
d702 1
a702 1
		setpgrp(0, getpid());
d718 2
a719 1
	}
d722 1
a722 9
#if	BSD > 43
	if (setlogin(pwd->pw_name) < 0)
		syslog(LOG_ERR, "setlogin() failed: %m");
#endif
	(void) setegid((gid_t)pwd->pw_gid);
	(void) setgid((gid_t)pwd->pw_gid);
	initgroups(pwd->pw_name, pwd->pw_gid);
	(void) seteuid((uid_t)pwd->pw_uid);
	(void) setuid((uid_t)pwd->pw_uid);
d724 7
a730 5
	strncat(homedir, pwd->pw_dir, sizeof(homedir)-6);
	strcat(path, _PATH_DEFPATH);
	strncat(shell, pwd->pw_shell, sizeof(shell)-7);
	strncat(logname, pwd->pw_name, sizeof(logname)-9);
	strncat(username, pwd->pw_name, sizeof(username)-6);
@


1.30
log
@make rshd and rlogind IPv6-ready.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.29 1999/11/15 01:03:28 deraadt Exp $";
d449 1
d459 2
a460 3
				"rcmd", instance, &fromaddr,
				&local_addr, kdata, "", schedule,
				version);
d465 2
a466 4
				instance, &fromaddr,
				(struct sockaddr_in *) 0,
				kdata, "", (struct des_ks_struct *) 0,
				version);
@


1.29
log
@logging getpeername() failures is a waste of time
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.28 1998/07/12 08:46:52 deraadt Exp $";
d81 1
a81 1
void	 doit __P((struct sockaddr_in *));
d122 1
a122 1
	struct sockaddr_in from;
d192 1
a192 1
	doit(&from);
d208 1
a208 1
	struct sockaddr_in *fromp;
d211 2
a212 1
	struct hostent *hp;
d215 1
d224 9
d238 1
a238 1
	struct		sockaddr_in	fromaddr;
d246 6
a251 1
	fromaddr = *fromp;
d265 8
a272 2
	fromp->sin_port = ntohs((u_short)fromp->sin_port);
	if (fromp->sin_family != AF_INET) {
d274 1
a274 1
		    fromp->sin_family);
d277 7
d285 1
d313 2
a314 2
		if (fromp->sin_port >= IPPORT_RESERVED ||
		    fromp->sin_port < IPPORT_RESERVED/2) {
d317 1
a317 2
			    inet_ntoa(fromp->sin_addr),
			    fromp->sin_port);
d347 1
a347 1
		fromp->sin_port = htons(port);
d349 1
a349 1
		s = rresvport(&lport);
d354 1
a354 1
		if (connect(s, (struct sockaddr *)fromp, sizeof (*fromp)) < 0) {
d374 2
a375 3
	hp = gethostbyaddr((char *)&fromp->sin_addr, sizeof (struct in_addr),
		fromp->sin_family);
	if (hp) {
d382 1
a382 1
		hostname = hp->h_name;
d386 2
a387 2
		if (check_all || local_domain(hp->h_name)) {
			strncpy(remotehost, hp->h_name, sizeof(remotehost) - 1);
d390 6
a395 2
			hp = gethostbyname(remotehost);
			if (hp == NULL) {
d397 2
a398 2
				    "Couldn't look up address for %s",
				    remotehost);
d401 19
a419 3
				hostname = inet_ntoa(fromp->sin_addr);
			} else for (; ; hp->h_addr_list++) {
				if (hp->h_addr_list[0] == NULL) {
d422 3
a424 2
					    inet_ntoa(fromp->sin_addr),
					    hp->h_name);
d427 1
a427 8
					hostname = inet_ntoa(fromp->sin_addr);
					break;
				}
				if (!bcmp(hp->h_addr_list[0],
				    (caddr_t)&fromp->sin_addr,
				    sizeof(fromp->sin_addr))) {
					hostname = hp->h_name;
					break;
d429 1
d436 1
a436 1
		    inet_ntoa(fromp->sin_addr), sizeof(hostnamebuf) - 1);
d521 1
a521 1
	    iruserok(fromp->sin_addr.s_addr, pwd->pw_uid == 0,
@


1.28
log
@indent
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.27 1998/07/10 18:22:54 millert Exp $";
d180 1
a180 1
		syslog(LOG_ERR, "getpeername: %m");
@


1.27
log
@Make sure port is in allowed range before trying to get a reserved port.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.26 1998/07/10 08:06:12 deraadt Exp $";
d390 1
a390 1
				   sizeof(hostnamebuf) - 1);
d393 1
a393 2
					       inet_ntoa(fromp->sin_addr),
					       sizeof(hostnamebuf) - 1);
@


1.26
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.25 1998/07/09 23:38:15 millert Exp $";
d309 1
a309 6
		int lport = IPPORT_RESERVED - 1;
		s = rresvport(&lport);
		if (s < 0) {
			syslog(LOG_ERR, "can't get stderr port: %m");
			exit(1);
		}
d319 6
@


1.25
log
@this is rshd, not rlogind
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.24 1998/06/22 19:44:46 art Exp $";
d251 1
a251 1
		syslog(LOG_ERR, "malformed \"from\" address (af %d)\n",
d320 1
a320 1
				syslog(LOG_ERR, "2nd port not reserved\n");
@


1.24
log
@The x option is not used if CRYPT is turned off.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.23 1998/06/03 02:35:20 angelos Exp $";
d410 1
a410 1
				error("rlogind: getsockname: %m");
@


1.23
log
@Make warnings disappear.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.22 1998/05/15 04:28:26 art Exp $";
d93 7
a99 1
#define	OPTIONS		"alnkvxL"
@


1.22
log
@cleanup and build with -Wall
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.21 1998/02/03 23:39:32 deraadt Exp $";
d209 1
a209 1
	int cc, nfd, pv[2], pid, s;
d211 1
a211 1
	char *hostname, *errorstr, *errorhost;
@


1.21
log
@whack _exit(); gnat@@prometheus.frii.com
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.20 1997/07/25 19:41:20 mickey Exp $";
d97 7
a103 1
Key_schedule	schedule;
d188 1
d224 1
d227 1
d412 1
a412 1
			desrw_set_key(kdata->session, schedule);
d422 1
a422 1
				  krb_err_txt[rc]);
d471 1
a471 1
	    pwd->pw_passwd != 0 && *pwd->pw_passwd != '\0' &&
d473 1
a473 1
	    remuser, locuser) < 0) {
@


1.20
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.19 1997/07/23 20:36:34 kstailey Exp $";
d169 1
a169 1
		_exit(1);
@


1.19
log
@tabify
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.18 1997/06/29 11:10:30 provos Exp $";
d702 1
a702 1
#if __STDC__
d709 1
a709 1
#if __STDC__
d720 1
a720 1
#if __STDC__
@


1.18
log
@new location of des.h
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.17 1997/06/15 05:10:39 millert Exp $";
d714 1
a714 1
        va_dcl
@


1.17
log
@rshd should give the same error message when the user doesn't exist
as for when there is no .rhosts/hosts.equiv.  With a different
error message an information gathering attack can be done.
Noted by David Holland <dholland@@eecs.harvard.edu>.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.16 1997/02/13 22:32:46 deraadt Exp $";
d89 1
a89 1
#include <kerberosIV/des.h>
@


1.16
log
@if i find one more little problem, and have to make one more little
tweak to this ip option handling code I am going to absolutely scream
in rage, following which I will rip the bloody innards out of netinet
and build my own new incompatible option checking/processing interface
that does not make it so hidiously difficult to check if a session has
source routes active!
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.15 1997/02/13 22:29:07 deraadt Exp $";
d429 1
a429 1
			errorstr = "Login incorrect.\n";
@


1.15
log
@option handling is a bitch
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.14 1997/02/13 22:21:08 deraadt Exp $";
d253 1
a253 1
		    sizeof opts; ) {	
@


1.14
log
@ok, i finally learned about struct ipoption
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.13 1997/02/05 21:09:29 deraadt Exp $";
d252 2
a253 1
		for (i = 0; i < optsize; ) {
@


1.13
log
@do not warn about valid options; invalid options correctly quit
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.12 1997/02/05 14:26:49 deraadt Exp $";
d61 1
d242 2
a243 2
	u_char optbuf[BUFSIZ/3];
	int optsize = sizeof(optbuf), ipproto, i;
d250 1
a250 1
	if (!getsockopt(0, ipproto, IP_OPTIONS, (char *)optbuf, &optsize) &&
d253 1
a253 1
			u_char c = optbuf[i];
d258 1
a258 1
			i += (c == IPOPT_NOP) ? 1 : optbuf[i+1];
@


1.12
log
@need not clear options since bad ones cause exit; provos@@ws1.physnet.uni-hamburg.de
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.11 1997/02/05 04:18:30 deraadt Exp $";
d241 1
a241 2
	u_char optbuf[BUFSIZ/3], *cp;
	char lbuf[sizeof(optbuf)*3+1], *lp;
a250 5
		for (lp = lbuf, i = 0; i < optsize; i++, lp += 3)
			sprintf(lp, " %2.2x", optbuf[i]);
		syslog(LOG_NOTICE,
		    "Connection received from %s using IP options (ignored):%s",
		    inet_ntoa(fromp->sin_addr), lbuf);
@


1.11
log
@IPOPT_LSRR/IPOPT_SSRR must exit() due to tcp sequencing; pointed out by
provos@@wserver.physnet.uni-hamburg.de. also another 1-char buffer overflow.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.10 1997/01/15 23:41:03 millert Exp $";
a263 5
		}
		if (setsockopt(0, ipproto, IP_OPTIONS,
		    (char *)NULL, optsize) != 0) {
			syslog(LOG_ERR, "setsockopt IP_OPTIONS NULL: %m");
			exit(1);
@


1.10
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.9 1996/12/22 03:41:20 tholo Exp $";
d58 1
d60 1
d242 2
a243 2
	char lbuf[BUFSIZ], *lp;
	int optsize = sizeof(optbuf), ipproto;
d252 2
a253 3
		lp = lbuf;
		for (cp = optbuf; optsize > 0; cp++, optsize--, lp += 3)
			sprintf(lp, " %2.2x", *cp);
d257 8
@


1.9
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.8 1996/11/01 11:30:33 niklas Exp $";
d112 1
a112 1
	while ((ch = getopt(argc, argv, OPTIONS)) != EOF)
@


1.8
log
@argument type nit
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.7 1996/10/26 04:37:29 millert Exp $";
d663 1
d666 1
@


1.7
log
@set $LOGNAME fore POSIX
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.6 1996/07/23 19:27:42 deraadt Exp $";
d409 2
a410 1
				kdata, "", (bit_64 *) 0, version);
@


1.6
log
@require stderr to be > IPPORT_RESERVED/2 (hope this does not break anything...)
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.5 1996/07/22 01:59:10 deraadt Exp $";
d182 1
d187 1
a187 1
	    {homedir, shell, path, username, 0};
d669 1
@


1.5
log
@seteuid for chdir
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.4 1996/04/17 07:20:01 tholo Exp $";
d302 2
a303 1
			if (port >= IPPORT_RESERVED) {
@


1.4
log
@Make encrypted kerberos remote shell work again.  Note that this is not
a supported configuration, and no port number is defined for it.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.3 1995/12/16 22:20:23 tholo Exp $";
d429 3
d442 2
@


1.3
log
@Make it possible to build without SKEY support
Add support for building with kerberosIV
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.2 1995/11/20 09:38:09 deraadt Exp $";
d401 1
a401 1
			des_set_key(kdata->session, schedule);
@


1.2
log
@indentation botch
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.1.1.1 1995/10/18 08:43:22 deraadt Exp $";
d85 11
d97 1
d123 15
d150 12
d206 12
d264 3
d299 3
d313 6
d337 3
d379 36
d440 13
d486 14
d506 11
d531 12
d549 11
d565 7
d585 8
d597 25
d624 5
d635 11
d670 8
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char *rcsid = "$Id: rshd.c,v 1.9 1995/01/20 18:48:50 christos Exp $";
d338 6
a343 7

		if (errorstr ||
		    pwd->pw_passwd != 0 && *pwd->pw_passwd != '\0' &&
		    iruserok(fromp->sin_addr.s_addr, pwd->pw_uid == 0,
		    remuser, locuser) < 0) {
			if (__rcmd_errstr)
				syslog(LOG_INFO|LOG_AUTH,
d345 4
a348 4
				    remuser, hostname, locuser, __rcmd_errstr,
				    cmdbuf);
			else
				syslog(LOG_INFO|LOG_AUTH,
d350 1
a350 1
				    remuser, hostname, locuser, cmdbuf);
d352 5
a356 5
			if (errorstr == NULL)
				errorstr = "Permission denied.\n";
			error(errorstr, errorhost);
			exit(1);
		}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
