head	1.43;
access;
symbols
	OPENBSD_3_7:1.42.0.8
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.6
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.42.0.4
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.33.0.4
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2005.05.25.05.35.22;	author deraadt;	state dead;
branches;
next	1.42;

1.42
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.14.01.46.51;	author hin;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.08.12.17.36;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.14.17.41.55;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.28.01.26.00;	author vincent;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.07.23.08.24;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.07.23.01.44;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.28.00.52.26;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.29.06.26.50;	author pvalchev;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.02.14.16.02;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.29.21.30.55;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.26.04.57.44;	author hin;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.23.19.44.33;	author hin;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.11.15.18.52;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.25.10.25.22;	author hin;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.16.19.00.19;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.24.21.52.37;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.10.15.14.55;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.06.10.55.00;	author hin;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.15.07.13.48;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.18.03.26.10;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	99.12.20.15.51.52;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	99.12.11.01.59.43;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	99.12.10.20.06.48;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.08.17.09.13.13;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.07.20.22.40.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.12.19.01.27.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.07.28.20.18.22;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	98.07.27.18.28.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.07.23.17.55.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.05.08.19.37.50;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.05.08.19.34.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.04.25.04.43.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.03.25.18.43.49;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.03.12.04.53.15;	author art;	state Exp;
branches;
next	1.7;

1.7
date	97.07.14.01.40.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.41.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.23.13.31.40;	author robin;	state Exp;
branches;
next	1.4;

1.4
date	96.08.27.10.25.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.23.03.03.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.28.23.22.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.43
log
@bye bye
@
text
@/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnetd.h"
#include <sys/socket.h>
#include <netdb.h>
#include <fcntl.h>
#include <syslog.h>
#include <unistd.h>
#include <sys/ioctl.h>

/* RCSID("$KTH: telnetd.c,v 1.64 2001/02/08 16:06:27 assar Exp $"); */

#ifdef _SC_CRAY_SECURE_SYS
#include <sys/sysv.h>
#include <sys/secdev.h>
#include <sys/secparm.h>
#include <sys/usrv.h>
int	secflag;
char	tty_dev[16];
struct	secdev dv;
struct	sysv sysv;
struct	socksec ss;
#endif	/* _SC_CRAY_SECURE_SYS */

#ifndef ENCRYPTION
#define	encrypt_delay()	0
#endif

#ifdef AUTHENTICATION
int	auth_level = 0;
#endif

extern	int utmp_len;
int	registerd_host_only = 0;

#ifdef	STREAMSPTY
# include <stropts.h>
# include <termios.h>
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif /* HAVE_SYS_UIO_H */
#ifdef HAVE_SYS_STREAM_H
#include <sys/stream.h>
#endif
#ifdef _AIX
#include <sys/termio.h>
#endif
# ifdef HAVE_SYS_STRTTY_H
# include <sys/strtty.h>
# endif
# ifdef HAVE_SYS_STR_TTY_H
# include <sys/str_tty.h>
# endif
/* make sure we don't get the bsd version */
/* what is this here for? solaris? /joda */
# ifdef HAVE_SYS_TTY_H
# include "/usr/include/sys/tty.h"
# endif
# ifdef HAVE_SYS_PTYVAR_H
# include <sys/ptyvar.h>
# endif

/*
 * Because of the way ptyibuf is used with streams messages, we need
 * ptyibuf+1 to be on a full-word boundary.  The following weirdness
 * is simply to make that happen.
 */
long	ptyibufbuf[BUFSIZ/sizeof(long)+1];
char	*ptyibuf = ((char *)&ptyibufbuf[1])-1;
char	*ptyip = ((char *)&ptyibufbuf[1])-1;
char	ptyibuf2[BUFSIZ];
unsigned char ctlbuf[BUFSIZ];
struct	strbuf strbufc, strbufd;

int readstream(int, char*, int);

#else	/* ! STREAMPTY */

/*
 * I/O data buffers,
 * pointers, and counters.
 */
char	ptyibuf[BUFSIZ], *ptyip = ptyibuf;
char	ptyibuf2[BUFSIZ];

#endif /* ! STREAMPTY */

int	hostinfo = 1;			/* do we print login banner? */

#ifdef	_CRAY
extern int      newmap; /* nonzero if \n maps to ^M^J */
int	lowpty = 0, highpty;	/* low, high pty numbers */
#endif /* CRAY */

int debug = 0;
int keepalive = 1;
char *progname;
char *gettyent = "default";
char *gettytab[2] = { "/etc/gettytab", NULL };

static void usage (void);

/*
 * The string to pass to getopt().  We do it this way so
 * that only the actual options that we support will be
 * passed off to getopt().
 */
char valid_opts[] = "Bd:g:hklnS:u:UL:y"
#ifdef AUTHENTICATION
		    "a:X:z"
#endif
#ifdef DIAGNOSTICS
		    "D:"
#endif
#ifdef _CRAY
		    "r:"
#endif
		    ;

static void doit(struct sockaddr*, int);

int
main(int argc, char **argv)
{
    struct sockaddr_storage __ss;
    struct sockaddr *sa = (struct sockaddr *)&__ss;
    int on = 1;
    socklen_t sa_size;
    int ch;
#if	defined(IPPROTO_IP) && defined(IP_TOS)
    int tos = -1;
#endif
#ifdef ENCRYPTION
    extern int des_check_key;
    des_check_key = 1;	/* Kludge for Mac NCSA telnet 2.6 /bg */
#endif
    pfrontp = pbackp = ptyobuf;
    netip = netibuf;
    nfrontp = nbackp = netobuf;

    progname = *argv;
#ifdef ENCRYPTION
    nclearto = 0;
#endif

#ifdef _CRAY
    /*
     * Get number of pty's before trying to process options,
     * which may include changing pty range.
     */
    highpty = getnpty();
#endif /* CRAY */

    while ((ch = getopt(argc, argv, valid_opts)) != -1) {
	switch(ch) {

#ifdef	AUTHENTICATION
	case 'a':
	    /*
	     * Check for required authentication level
	     */
	    if (strcmp(optarg, "debug") == 0) {
		auth_debug_mode = 1;
	    } else if (strcasecmp(optarg, "none") == 0) {
		auth_level = 0;
	    } else if (strcasecmp(optarg, "other") == 0) {
		auth_level = AUTH_OTHER;
	    } else if (strcasecmp(optarg, "user") == 0) {
		auth_level = AUTH_USER;
	    } else if (strcasecmp(optarg, "valid") == 0) {
		auth_level = AUTH_VALID;
	    } else if (strcasecmp(optarg, "off") == 0) {
		/*
		 * This hack turns off authentication
		 */
		auth_level = -1;
	    } else {
		fprintf(stderr,
			"telnetd: unknown authorization level for -a\n");
	    }
	    break;
#endif	/* AUTHENTICATION */

	case 'B': /* BFTP mode is not supported any more */
	    break;
	case 'd':
	    if (strcmp(optarg, "ebug") == 0) {
		debug++;
		break;
	    }
	    usage();
	    /* NOTREACHED */
	    break;

#ifdef DIAGNOSTICS
	case 'D':
	    /*
	     * Check for desired diagnostics capabilities.
	     */
	    if (!strcmp(optarg, "report")) {
		diagnostic |= TD_REPORT|TD_OPTIONS;
	    } else if (!strcmp(optarg, "exercise")) {
		diagnostic |= TD_EXERCISE;
	    } else if (!strcmp(optarg, "netdata")) {
		diagnostic |= TD_NETDATA;
	    } else if (!strcmp(optarg, "ptydata")) {
		diagnostic |= TD_PTYDATA;
	    } else if (!strcmp(optarg, "options")) {
		diagnostic |= TD_OPTIONS;
	    } else {
		usage();
		/* NOT REACHED */
	    }
	    break;
#endif /* DIAGNOSTICS */


	case 'g':
	    gettyent = optarg;
	    break;

	case 'h':
	    hostinfo = 0;
	    break;

	case 'k': /* Linemode is not supported any more */
	case 'l':
	    break;

	case 'n':
	    keepalive = 0;
	    break;

#ifdef _CRAY
	case 'r':
	    {
		char *strchr();
		char *c;

		/*
		 * Allow the specification of alterations
		 * to the pty search range.  It is legal to
		 * specify only one, and not change the
		 * other from its default.
		 */
		c = strchr(optarg, '-');
		if (c) {
		    *c++ = '\0';
		    highpty = atoi(c);
		}
		if (*optarg != '\0')
		    lowpty = atoi(optarg);
		if ((lowpty > highpty) || (lowpty < 0) ||
		    (highpty > 32767)) {
		    usage();
		    /* NOT REACHED */
		}
		break;
	    }
#endif	/* CRAY */

	case 'S':
#ifdef	HAVE_PARSETOS
	    if ((tos = parsetos(optarg, "tcp")) < 0)
		fprintf(stderr, "%s%s%s\n",
			"telnetd: Bad TOS argument '", optarg,
			"'; will try to use default TOS");
#else
	    fprintf(stderr, "%s%s\n", "TOS option unavailable; ",
		    "-S flag not supported\n");
#endif
	    break;

	case 'u': {
	    char *eptr;

	    utmp_len = strtol(optarg, &eptr, 0);
	    if (optarg == eptr)
		fprintf(stderr, "telnetd: unknown utmp len (%s)\n", optarg);
	    break;
	}

	case 'U':
	    registerd_host_only = 1;
	    break;

#ifdef	AUTHENTICATION
	case 'X':
	    /*
	     * Check for invalid authentication types
	     */
	    auth_disable_name(optarg);
	    break;
#endif
	case 'y':
	    no_warn = 1;
	    break;
#ifdef AUTHENTICATION
	case 'z':
	    log_unauth = 1;
	    break;

#endif	/* AUTHENTICATION */

	case 'L':
	    new_login = optarg;
	    break;
			
	default:
	    fprintf(stderr, "telnetd: %c: unknown option\n", ch);
	    /* FALLTHROUGH */
	case '?':
	    usage();
	    /* NOTREACHED */
	}
    }

    argc -= optind;
    argv += optind;

    if (debug) {
	int port = 0;
	struct servent *sp;

	if (argc > 1) {
	    usage ();
	} else if (argc == 1) {
	    sp = getservbyname (*argv, "tcp");
	    if (sp)
		port = sp->s_port;
	    else
		port = htons(atoi(*argv));
	} else {
	    sp = getservbyname ("telnet", "tcp");
	    port = sp ? sp->s_port : htons(23);
	}
	mini_inetd (port);
    } else if (argc > 0) {
	usage();
	/* NOT REACHED */
    }

#ifdef _SC_CRAY_SECURE_SYS
    secflag = sysconf(_SC_CRAY_SECURE_SYS);

    /*
     *	Get socket's security label
     */
    if (secflag)  {
	socklen_t szss = sizeof(ss);
	int sock_multi;
	socklen_t szi = sizeof(int);

	memset(&dv, 0, sizeof(dv));

	if (getsysv(&sysv, sizeof(struct sysv)) != 0) 
	    fatalperror(net, "getsysv");

	/*
	 *	Get socket security label and set device values
	 *	   {security label to be set on ttyp device}
	 */
#ifdef SO_SEC_MULTI			/* 8.0 code */
	if ((getsockopt(0, SOL_SOCKET, SO_SECURITY,
			(void *)&ss, &szss) < 0) ||
	    (getsockopt(0, SOL_SOCKET, SO_SEC_MULTI,
			(void *)&sock_multi, &szi) < 0)) 
	    fatalperror(net, "getsockopt");
	else {
	    dv.dv_actlvl = ss.ss_actlabel.lt_level;
	    dv.dv_actcmp = ss.ss_actlabel.lt_compart;
	    if (!sock_multi) {
		dv.dv_minlvl = dv.dv_maxlvl = dv.dv_actlvl;
		dv.dv_valcmp = dv.dv_actcmp;
	    } else {
		dv.dv_minlvl = ss.ss_minlabel.lt_level;
		dv.dv_maxlvl = ss.ss_maxlabel.lt_level;
		dv.dv_valcmp = ss.ss_maxlabel.lt_compart;
	    }
	    dv.dv_devflg = 0;
	}
#else /* SO_SEC_MULTI */		/* 7.0 code */
	if (getsockopt(0, SOL_SOCKET, SO_SECURITY,
		       (void *)&ss, &szss) >= 0) {
	    dv.dv_actlvl = ss.ss_slevel;
	    dv.dv_actcmp = ss.ss_compart;
	    dv.dv_minlvl = ss.ss_minlvl;
	    dv.dv_maxlvl = ss.ss_maxlvl;
	    dv.dv_valcmp = ss.ss_maxcmp;
	}
#endif /* SO_SEC_MULTI */
    }
#endif	/* _SC_CRAY_SECURE_SYS */

    openlog("telnetd", LOG_PID | LOG_ODELAY, LOG_DAEMON);
    sa_size = sizeof (__ss);
    if (getpeername(STDIN_FILENO, sa, &sa_size) < 0) {
	fprintf(stderr, "%s: ", progname);
	perror("getpeername");
	_exit(1);
    }
    if (keepalive &&
	setsockopt(STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
		   (void *)&on, sizeof (on)) < 0) {
	syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");
    }

#if	defined(IPPROTO_IP) && defined(IP_TOS) && defined(HAVE_SETSOCKOPT)
    {
# ifdef HAVE_GETTOSBYNAME
	struct tosent *tp;
	if (tos < 0 && (tp = gettosbyname("telnet", "tcp")))
	    tos = tp->t_tos;
# endif
	if (tos < 0)
	    tos = 020;	/* Low Delay bit */
	if (tos
	    && sa->sa_family == AF_INET
	    && (setsockopt(STDIN_FILENO, IPPROTO_IP, IP_TOS,
			   (void *)&tos, sizeof(tos)) < 0)
	    && (errno != ENOPROTOOPT) )
	    syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
    }
#endif	/* defined(IPPROTO_IP) && defined(IP_TOS) */
    net = STDIN_FILENO;
    doit(sa, sa_size);
    /* NOTREACHED */
    return 0;
}  /* end of main */

static void
usage(void)
{
    fprintf(stderr, "Usage: telnetd");
#ifdef	AUTHENTICATION
    fprintf(stderr, " [-a (debug|other|user|valid|off|none)]\n\t");
#endif
    fprintf(stderr, " [-debug]");
#ifdef DIAGNOSTICS
    fprintf(stderr, " [-D (options|report|exercise|netdata|ptydata)]\n\t");
#endif
#ifdef	AUTHENTICATION
    fprintf(stderr, " [-edebug]");
#endif
    fprintf(stderr, " [-h]");
    fprintf(stderr, " [-L login]");
    fprintf(stderr, " [-n]");
#ifdef	_CRAY
    fprintf(stderr, " [-r[lowpty]-[highpty]]");
#endif
    fprintf(stderr, "\n\t");
#ifdef	HAVE_GETTOSBYNAME
    fprintf(stderr, " [-S tos]");
#endif
#ifdef	AUTHENTICATION
    fprintf(stderr, " [-X auth-type] [-y] [-z]");
#endif
    fprintf(stderr, " [-u utmp_hostname_length] [-U]");
    fprintf(stderr, " [port]\n");
    exit(1);
}

/*
 * getterminaltype
 *
 *	Ask the other end to send along its terminal type and speed.
 * Output is the variable terminaltype filled in.
 */
static unsigned char ttytype_sbbuf[] = {
    IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE
};

int
getterminaltype(char *name, size_t name_sz)
{
    int retval = -1;

    settimer(baseline);
#ifdef AUTHENTICATION
    /*
     * Handle the Authentication option before we do anything else.
     */
    send_do(TELOPT_AUTHENTICATION, 1);
    while (his_will_wont_is_changing(TELOPT_AUTHENTICATION))
	ttloop();
    if (his_state_is_will(TELOPT_AUTHENTICATION)) {
	retval = auth_wait(name, name_sz);
    }
#endif

#ifdef ENCRYPTION
    send_will(TELOPT_ENCRYPT, 1);
    send_do(TELOPT_ENCRYPT, 1);	/* esc@@magic.fi */
#endif
    send_do(TELOPT_TTYPE, 1);
    send_do(TELOPT_TSPEED, 1);
    send_do(TELOPT_XDISPLOC, 1);
    send_do(TELOPT_NEW_ENVIRON, 1);
    send_do(TELOPT_OLD_ENVIRON, 1);
    while (
#ifdef ENCRYPTION
	   his_do_dont_is_changing(TELOPT_ENCRYPT) ||
#endif
	   his_will_wont_is_changing(TELOPT_TTYPE) ||
	   his_will_wont_is_changing(TELOPT_TSPEED) ||
	   his_will_wont_is_changing(TELOPT_XDISPLOC) ||
	   his_will_wont_is_changing(TELOPT_NEW_ENVIRON) ||
	   his_will_wont_is_changing(TELOPT_OLD_ENVIRON)) {
	ttloop();
    }
#ifdef ENCRYPTION
    /*
     * Wait for the negotiation of what type of encryption we can
     * send with.  If autoencrypt is not set, this will just return.
     */
    if (his_state_is_will(TELOPT_ENCRYPT)) {
	encrypt_wait();
    }
#endif
    if (his_state_is_will(TELOPT_TSPEED)) {
	static unsigned char sb[] =
	{ IAC, SB, TELOPT_TSPEED, TELQUAL_SEND, IAC, SE };

	telnet_net_write (sb, sizeof sb);
	DIAG(TD_OPTIONS, printsub('>', sb + 2, sizeof sb - 2););
    }
    if (his_state_is_will(TELOPT_XDISPLOC)) {
	static unsigned char sb[] =
	{ IAC, SB, TELOPT_XDISPLOC, TELQUAL_SEND, IAC, SE };

	telnet_net_write (sb, sizeof sb);
	DIAG(TD_OPTIONS, printsub('>', sb + 2, sizeof sb - 2););
    }
    if (his_state_is_will(TELOPT_NEW_ENVIRON)) {
	static unsigned char sb[] =
	{ IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_SEND, IAC, SE };

	telnet_net_write (sb, sizeof sb);
	DIAG(TD_OPTIONS, printsub('>', sb + 2, sizeof sb - 2););
    }
    else if (his_state_is_will(TELOPT_OLD_ENVIRON)) {
	static unsigned char sb[] =
	{ IAC, SB, TELOPT_OLD_ENVIRON, TELQUAL_SEND, IAC, SE };

	telnet_net_write (sb, sizeof sb);
	DIAG(TD_OPTIONS, printsub('>', sb + 2, sizeof sb - 2););
    }
    if (his_state_is_will(TELOPT_TTYPE)) {

	telnet_net_write (ttytype_sbbuf, sizeof ttytype_sbbuf);
	DIAG(TD_OPTIONS, printsub('>', ttytype_sbbuf + 2,
				  sizeof ttytype_sbbuf - 2););
    }
    if (his_state_is_will(TELOPT_TSPEED)) {
	while (sequenceIs(tspeedsubopt, baseline))
	    ttloop();
    }
    if (his_state_is_will(TELOPT_XDISPLOC)) {
	while (sequenceIs(xdisplocsubopt, baseline))
	    ttloop();
    }
    if (his_state_is_will(TELOPT_NEW_ENVIRON)) {
	while (sequenceIs(environsubopt, baseline))
	    ttloop();
    }
    if (his_state_is_will(TELOPT_OLD_ENVIRON)) {
	while (sequenceIs(oenvironsubopt, baseline))
	    ttloop();
    }
    if (his_state_is_will(TELOPT_TTYPE)) {
	char first[256], last[256];

	while (sequenceIs(ttypesubopt, baseline))
	    ttloop();

	/*
	 * If the other side has already disabled the option, then
	 * we have to just go with what we (might) have already gotten.
	 */
	if (his_state_is_will(TELOPT_TTYPE) && !terminaltypeok(terminaltype)) {
	    strlcpy(first, terminaltype, sizeof(first));
	    for(;;) {
		/*
		 * Save the unknown name, and request the next name.
		 */
		strlcpy(last, terminaltype, sizeof(last));
		_gettermname();
		if (terminaltypeok(terminaltype))
		    break;
		if ((strncmp(last, terminaltype, sizeof(last)) == 0) ||
		    his_state_is_wont(TELOPT_TTYPE)) {
		    /*
		     * We've hit the end.  If this is the same as
		     * the first name, just go with it.
		     */
		    if (strncmp(first, terminaltype, sizeof(first)) == 0)
			break;
		    /*
		     * Get the terminal name one more time, so that
		     * RFC1091 compliant telnets will cycle back to
		     * the start of the list.
		     */
		    _gettermname();
		    if (strncmp(first, terminaltype, sizeof(first)) != 0)
			strlcpy(terminaltype, first, sizeof(terminaltype));
		    break;
		}
	    }
	}
    }
    return(retval);
}  /* end of getterminaltype */

void
_gettermname(void)
{
    /*
     * If the client turned off the option,
     * we can't send another request, so we
     * just return.
     */
    if (his_state_is_wont(TELOPT_TTYPE))
	return;
    settimer(baseline);
    telnet_net_write (ttytype_sbbuf, sizeof ttytype_sbbuf);
    DIAG(TD_OPTIONS, printsub('>', ttytype_sbbuf + 2,
			      sizeof ttytype_sbbuf - 2););
    while (sequenceIs(ttypesubopt, baseline))
	ttloop();
}

int
terminaltypeok(char *s)
{
    return 1;
}


char host_name[MAXHOSTNAMELEN];
char remote_host_name[MAXHOSTNAMELEN];
char remote_utmp_name[MAXHOSTNAMELEN];

/*
 * Get a pty, scan input lines.
 */
static void
doit(struct sockaddr *who, int who_len)
{
    int level;
    int ptynum;
    char user_name[256];
    int error;

    /*
     * Find an available pty to use.
     */
    ourpty = getpty(&ptynum);
    if (ourpty < 0)
	fatal(net, "All network ports in use");

#ifdef _SC_CRAY_SECURE_SYS
    /*
     *	set ttyp line security label
     */
    if (secflag) {
	char slave_dev[16];

	snprintf(tty_dev, sizeof(tty_dev), "/dev/pty/%03d", ptynum);
	if (setdevs(tty_dev, &dv) < 0)
	    fatal(net, "cannot set pty security");
	snprintf(slave_dev, sizeof(slave_dev), "/dev/ttyp%03d", ptynum);
	if (setdevs(slave_dev, &dv) < 0)
	    fatal(net, "cannot set tty security");
    }
#endif	/* _SC_CRAY_SECURE_SYS */

    error = getnameinfo (who, who_len,
				  remote_host_name,
				  sizeof(remote_host_name),
				  NULL, 0, 
				  registerd_host_only ? NI_NAMEREQD : 0);
    if (error)
	fatal(net, "Couldn't resolve your address into a host name.\r\n\
Please contact your net administrator");

    gethostname(host_name, sizeof (host_name));

    strlcpy (remote_utmp_name, remote_host_name, sizeof(remote_utmp_name));

    /* Only trim if too long (and possible) */
    if (strlen(remote_utmp_name) > utmp_len) {
	char *domain = strchr(host_name, '.');
	char *p = strchr(remote_utmp_name, '.');
	if (domain != NULL && p != NULL && (strcmp(p, domain) == 0))
	    *p = '\0'; /* remove domain part */
    }

    /*
     * If hostname still doesn't fit utmp, use ipaddr.
     */
    if (strlen(remote_utmp_name) > utmp_len) {
	error = getnameinfo (who, who_len,
			     remote_utmp_name,
			     sizeof(remote_utmp_name),
			     NULL, 0,
			     NI_NUMERICHOST);
	if (error)
	    fatal(net, "Couldn't get numeric address\r\n");
    }

#ifdef AUTHENTICATION
    auth_encrypt_init(host_name, remote_host_name, "TELNETD", 1);
#endif

    init_env();
    /*
     * get terminal type.
     */
    *user_name = 0;
    level = getterminaltype(user_name, sizeof(user_name));
    esetenv("TERM", terminaltype ? terminaltype : "network", 1);

#ifdef _SC_CRAY_SECURE_SYS
    if (secflag) {
	if (setulvl(dv.dv_actlvl) < 0)
	    fatal(net,"cannot setulvl()");
	if (setucmp(dv.dv_actcmp) < 0)
	    fatal(net, "cannot setucmp()");
    }
#endif	/* _SC_CRAY_SECURE_SYS */

    /* begin server processing */
    my_telnet(net, ourpty, remote_host_name, remote_utmp_name,
	      level, user_name);
    /*NOTREACHED*/
}  /* end of doit */

/* output contents of /etc/issue.net, or /etc/issue */
static void
show_issue(void)
{
    FILE *f;
    char buf[128];
    f = fopen("/etc/issue.net", "r");
    if(f == NULL)
	f = fopen("/etc/issue", "r");
    if(f){
	while(fgets(buf, sizeof(buf)-2, f)){
	    size_t off = strcspn(buf, "\r\n");  	
	    strlcpy(buf + off, "\r\n", sizeof(buf) - off);
	    writenet((unsigned char*)buf, strlen(buf));
	}
	fclose(f);
    }
}

/*
 * Main loop.  Select from pty and network, and
 * hand data to telnet receiver finite state machine.
 */
void
my_telnet(int f, int p, const char *host, const char *utmp_host,
	  int level, char *autoname)
{
    int on = 1;
    char *he;
    char *IM;
    char *buf;
    int nfd;
    int startslave_called = 0;
    time_t timeout;
    fd_set *ibits = NULL;
    fd_set *obits = NULL;
    fd_set *xbits = NULL;
    int setsize;

    /*
     * Initialize the slc mapping table.
     */
    get_slc_defaults();

    /*
     * Do some tests where it is desireable to wait for a response.
     * Rather than doing them slowly, one at a time, do them all
     * at once.
     */
    if (my_state_is_wont(TELOPT_SGA))
	send_will(TELOPT_SGA, 1);
    /*
     * Is the client side a 4.2 (NOT 4.3) system?  We need to know this
     * because 4.2 clients are unable to deal with TCP urgent data.
     *
     * To find out, we send out a "DO ECHO".  If the remote system
     * answers "WILL ECHO" it is probably a 4.2 client, and we note
     * that fact ("WILL ECHO" ==> that the client will echo what
     * WE, the server, sends it; it does NOT mean that the client will
     * echo the terminal input).
     */
    send_do(TELOPT_ECHO, 1);

    /*
     * Send along a couple of other options that we wish to negotiate.
     */
    send_do(TELOPT_NAWS, 1);
    send_will(TELOPT_STATUS, 1);
    flowmode = 1;		/* default flow control state */
    restartany = -1;	/* uninitialized... */
    send_do(TELOPT_LFLOW, 1);

    /*
     * Spin, waiting for a response from the DO ECHO.  However,
     * some REALLY DUMB telnets out there might not respond
     * to the DO ECHO.  So, we spin looking for NAWS, (most dumb
     * telnets so far seem to respond with WONT for a DO that
     * they don't understand...) because by the time we get the
     * response, it will already have processed the DO ECHO.
     * Kludge upon kludge.
     */
    while (his_will_wont_is_changing(TELOPT_NAWS))
	ttloop();

    /*
     * But...
     * The client might have sent a WILL NAWS as part of its
     * startup code; if so, we'll be here before we get the
     * response to the DO ECHO.  We'll make the assumption
     * that any implementation that understands about NAWS
     * is a modern enough implementation that it will respond
     * to our DO ECHO request; hence we'll do another spin
     * waiting for the ECHO option to settle down, which is
     * what we wanted to do in the first place...
     */
    if (his_want_state_is_will(TELOPT_ECHO) &&
	his_state_is_will(TELOPT_NAWS)) {
	while (his_will_wont_is_changing(TELOPT_ECHO))
	    ttloop();
    }
    /*
     * On the off chance that the telnet client is broken and does not
     * respond to the DO ECHO we sent, (after all, we did send the
     * DO NAWS negotiation after the DO ECHO, and we won't get here
     * until a response to the DO NAWS comes back) simulate the
     * receipt of a will echo.  This will also send a WONT ECHO
     * to the client, since we assume that the client failed to
     * respond because it believes that it is already in DO ECHO
     * mode, which we do not want.
     */
    if (his_want_state_is_will(TELOPT_ECHO)) {
	DIAG(TD_OPTIONS,
	     {output_data("td: simulating recv\r\n");
	     });
	willoption(TELOPT_ECHO);
    }

    /*
     * Finally, to clean things up, we turn on our echo.  This
     * will break stupid 4.2 telnets out of local terminal echo.
     */

    if (my_state_is_wont(TELOPT_ECHO))
	send_will(TELOPT_ECHO, 1);

#ifdef TIOCPKT
#ifdef	STREAMSPTY
    if (!really_stream)
#endif
	/*
	 * Turn on packet mode
	 */
	ioctl(p, TIOCPKT, (char *)&on);
#endif


    /*
     * Call telrcv() once to pick up anything received during
     * terminal type negotiation, 4.2/4.3 determination, and
     * linemode negotiation.
     */
    telrcv();

    ioctl(f, FIONBIO, (char *)&on);
    ioctl(p, FIONBIO, (char *)&on);

#if	defined(SO_OOBINLINE) && defined(HAVE_SETSOCKOPT)
    setsockopt(net, SOL_SOCKET, SO_OOBINLINE,
	       (void *)&on, sizeof on);
#endif	/* defined(SO_OOBINLINE) */

#ifdef	SIGTSTP
    signal(SIGTSTP, SIG_IGN);
#endif
#ifdef	SIGTTOU
    /*
     * Ignoring SIGTTOU keeps the kernel from blocking us
     * in ttioct() in /sys/tty.c.
     */
    signal(SIGTTOU, SIG_IGN);
#endif

    signal(SIGCHLD, cleanup);

#ifdef  TIOCNOTTY
    {
	int t;
	t = open(_PATH_TTY, O_RDWR);
	if (t >= 0) {
	    ioctl(t, TIOCNOTTY, (char *)0);
	    close(t);
	}
    }
#endif

    show_issue();
    /*
     * Show banner that getty never gave.
     *
     * We put the banner in the pty input buffer.  This way, it
     * gets carriage return null processing, etc., just like all
     * other pty --> client data.
     */

    if (getenv("USER"))
	hostinfo = 0;

    if (cgetent(&buf, gettytab, gettyent) >= 0) {
	char *HN;

	if (cgetstr(buf, "he", &he) <= 0)
	    he = NULL;
	if (cgetstr(buf, "im", &IM) <= 0)
	    IM = "";
	if (cgetstr(buf, "hn", &HN) > 0) {
	    strlcpy(host_name, HN, sizeof host_name);
	    free(HN);
	}
	cgetclose();
    } else {
	IM = DEFAULT_IM;
	he = NULL;
    }
    edithost(he, host_name);
    if (he)
	free(he);
    if (hostinfo && *IM)
	putf(IM, ptyibuf2);
    if (IM != DEFAULT_IM && *IM)
	free(IM);

    if (pcc)
	strncat(ptyibuf2, ptyip, pcc+1);
    ptyip = ptyibuf2;
    pcc = strlen(ptyip);

    DIAG(TD_REPORT, {
	output_data("td: Entering processing loop\r\n");
    });


    nfd = ((f > p) ? f : p) + 1;
    setsize = howmany(nfd, NFDBITS) * sizeof(fd_mask);
    ibits = malloc(setsize);
    obits = malloc(setsize);
    xbits = malloc(setsize);
    if (ibits == NULL || obits == NULL || xbits == NULL) {
	syslog(LOG_ERR, "Out of memory");
	exit(1);
    }
    timeout = time(NULL) + 5;
    for (;;) {
	int c;

	/* wait for encryption to be turned on, but don't wait
           indefinitely */
	if(!startslave_called && (!encrypt_delay() || timeout > time(NULL))){
	    startslave_called = 1;
	    startslave(host, utmp_host, level, autoname);
	}

	if (ncc < 0 && pcc < 0)
	    break;

	memset(obits, 0, setsize);
	memset(ibits, 0, setsize);
	memset(xbits, 0, setsize);

	/*
	 * Never look for input if there's still
	 * stuff in the corresponding output buffer
	 */
	if (nfrontp - nbackp || pcc > 0) {
	    FD_SET(f, obits);
	} else {
	    FD_SET(p, ibits);
	}
	if (pfrontp - pbackp || ncc > 0) {
	    FD_SET(p, obits);
	} else {
	    FD_SET(f, ibits);
	}
	if (!SYNCHing) {
	    FD_SET(f, xbits);
	}
	if ((c = select(nfd, ibits, obits, xbits,
			(struct timeval *)0)) < 1) {
	    if (c == -1) {
		if (errno == EINTR) {
		    continue;
		}
	    }
	    sleep(5);
	    continue;
	}

	/*
	 * Any urgent data?
	 */
	if (FD_ISSET(f, xbits)) {
	    SYNCHing = 1;
	}

	/*
	 * Something to read from the network...
	 */
	if (FD_ISSET(f, ibits)) {
#ifndef SO_OOBINLINE
	    /*
	     * In 4.2 (and 4.3 beta) systems, the
	     * OOB indication and data handling in the kernel
	     * is such that if two separate TCP Urgent requests
	     * come in, one byte of TCP data will be overlaid.
	     * This is fatal for Telnet, but we try to live
	     * with it.
	     *
	     * In addition, in 4.2 (and...), a special protocol
	     * is needed to pick up the TCP Urgent data in
	     * the correct sequence.
	     *
	     * What we do is:  if we think we are in urgent
	     * mode, we look to see if we are "at the mark".
	     * If we are, we do an OOB receive.  If we run
	     * this twice, we will do the OOB receive twice,
	     * but the second will fail, since the second
	     * time we were "at the mark", but there wasn't
	     * any data there (the kernel doesn't reset
	     * "at the mark" until we do a normal read).
	     * Once we've read the OOB data, we go ahead
	     * and do normal reads.
	     *
	     * There is also another problem, which is that
	     * since the OOB byte we read doesn't put us
	     * out of OOB state, and since that byte is most
	     * likely the TELNET DM (data mark), we would
	     * stay in the TELNET SYNCH (SYNCHing) state.
	     * So, clocks to the rescue.  If we've "just"
	     * received a DM, then we test for the
	     * presence of OOB data when the receive OOB
	     * fails (and AFTER we did the normal mode read
	     * to clear "at the mark").
	     */
	    if (SYNCHing) {
		int atmark;

		ioctl(f, SIOCATMARK, (char *)&atmark);
		if (atmark) {
		    ncc = recv(f, netibuf, sizeof (netibuf), MSG_OOB);
		    if ((ncc == -1) && (errno == EINVAL)) {
			ncc = read(f, netibuf, sizeof (netibuf));
			if (sequenceIs(didnetreceive, gotDM)) {
			    SYNCHing = stilloob(f);
			}
		    }
		} else {
		    ncc = read(f, netibuf, sizeof (netibuf));
		}
	    } else {
		ncc = read(f, netibuf, sizeof (netibuf));
	    }
	    settimer(didnetreceive);
#else	/* !defined(SO_OOBINLINE)) */
	    ncc = read(net, netibuf, sizeof (netibuf));
#endif	/* !defined(SO_OOBINLINE)) */
	    if (ncc < 0 && errno == EWOULDBLOCK)
		ncc = 0;
	    else {
		if (ncc <= 0) {
		    break;
		}
		netip = netibuf;
	    }
	    DIAG((TD_REPORT | TD_NETDATA), {
		output_data("td: netread %d chars\r\n", ncc);
		});
	    DIAG(TD_NETDATA, printdata("nd", netip, ncc));
	}

	/*
	 * Something to read from the pty...
	 */
	if (FD_ISSET(p, ibits)) {
#ifdef STREAMSPTY
	    if (really_stream)
		pcc = readstream(p, ptyibuf, BUFSIZ);
	    else
#endif
		pcc = read(p, ptyibuf, BUFSIZ);

	    /*
	     * On some systems, if we try to read something
	     * off the master side before the slave side is
	     * opened, we get EIO.
	     */
	    if (pcc < 0 && (errno == EWOULDBLOCK ||
#ifdef	EAGAIN
			    errno == EAGAIN ||
#endif
			    errno == EIO)) {
		pcc = 0;
	    } else {
		if (pcc <= 0)
		    break;
		if (ptyibuf[0] & TIOCPKT_FLUSHWRITE) {
		    netclear();	/* clear buffer back */
#ifndef	NO_URGENT
		    /*
		     * There are client telnets on some
		     * operating systems get screwed up
		     * royally if we send them urgent
		     * mode data.
		     */
		    output_data ("%c%c", IAC, DM);

		    neturg = nfrontp-1; /* off by one XXX */
		    DIAG(TD_OPTIONS,
			 printoption("td: send IAC", DM));

#endif
		}
		if (his_state_is_will(TELOPT_LFLOW) &&
		    (ptyibuf[0] &
		     (TIOCPKT_NOSTOP|TIOCPKT_DOSTOP))) {
		    int newflow =
			ptyibuf[0] & TIOCPKT_DOSTOP ? 1 : 0;
		    if (newflow != flowmode) {
			flowmode = newflow;
			output_data("%c%c%c%c%c%c",
				    IAC, SB, TELOPT_LFLOW,
				    flowmode ? LFLOW_ON
				    : LFLOW_OFF,
				    IAC, SE);
			DIAG(TD_OPTIONS, printsub('>',
						  (unsigned char *)nfrontp-4,
						  4););
		    }
		}
		pcc--;
		ptyip = ptyibuf+1;
	    }
	}

	while (pcc > 0) {
	    if ((&netobuf[BUFSIZ] - nfrontp) < 3)
		break;
	    c = *ptyip++ & 0377, pcc--;
	    if (c == IAC)
		*nfrontp++ = c;
	    *nfrontp++ = c;
	    if ((c == '\r') && (my_state_is_wont(TELOPT_BINARY))) {
		if (pcc > 0 && ((*ptyip & 0377) == '\n')) {
		    *nfrontp++ = *ptyip++ & 0377;
		    pcc--;
		} else
		    *nfrontp++ = '\0';
	    }
	}

	if (FD_ISSET(f, obits) && (nfrontp - nbackp) > 0)
	    netflush();
	if (ncc > 0)
	    telrcv();
	if (FD_ISSET(p, obits) && (pfrontp - pbackp) > 0)
	    ptyflush();
    }
    cleanup(0);
}

#ifndef	TCSIG
# ifdef	TIOCSIG
#  define TCSIG TIOCSIG
# endif
#endif

#ifdef	STREAMSPTY

    int flowison = -1;  /* current state of flow: -1 is unknown */

int
readstream(int p, char *ibuf, int bufsize)
{
    int flags = 0;
    int ret = 0;
    struct termios *tsp;
#if 0
    struct termio *tp;
#endif
    struct iocblk *ip;
    char vstop, vstart;
    int ixon;
    int newflow;

    strbufc.maxlen = BUFSIZ;
    strbufc.buf = (char *)ctlbuf;
    strbufd.maxlen = bufsize-1;
    strbufd.len = 0;
    strbufd.buf = ibuf+1;
    ibuf[0] = 0;

    ret = getmsg(p, &strbufc, &strbufd, &flags);
    if (ret < 0)  /* error of some sort -- probably EAGAIN */
	return(-1);

    if (strbufc.len <= 0 || ctlbuf[0] == M_DATA) {
	/* data message */
	if (strbufd.len > 0) {			/* real data */
	    return(strbufd.len + 1);	/* count header char */
	} else {
	    /* nothing there */
	    errno = EAGAIN;
	    return(-1);
	}
    }

    /*
     * It's a control message.  Return 1, to look at the flag we set
     */

    switch (ctlbuf[0]) {
    case M_FLUSH:
	if (ibuf[1] & FLUSHW)
	    ibuf[0] = TIOCPKT_FLUSHWRITE;
	return(1);

    case M_IOCTL:
	ip = (struct iocblk *) (ibuf+1);

	switch (ip->ioc_cmd) {
#ifdef TCSETS
	case TCSETS:
	case TCSETSW:
	case TCSETSF:
	    tsp = (struct termios *)
		(ibuf+1 + sizeof(struct iocblk));
	    vstop = tsp->c_cc[VSTOP];
	    vstart = tsp->c_cc[VSTART];
	    ixon = tsp->c_iflag & IXON;
	    break;
#endif
#if 0
	case TCSETA:
	case TCSETAW:
	case TCSETAF:
	    tp = (struct termio *) (ibuf+1 + sizeof(struct iocblk));
	    vstop = tp->c_cc[VSTOP];
	    vstart = tp->c_cc[VSTART];
	    ixon = tp->c_iflag & IXON;
	    break;
#endif
	default:
	    errno = EAGAIN;
	    return(-1);
	}

	newflow =  (ixon && (vstart == 021) && (vstop == 023)) ? 1 : 0;
	if (newflow != flowison) {  /* it's a change */
	    flowison = newflow;
	    ibuf[0] = newflow ? TIOCPKT_DOSTOP : TIOCPKT_NOSTOP;
	    return(1);
	}
    }

    /* nothing worth doing anything about */
    errno = EAGAIN;
    return(-1);
}
#endif /* STREAMSPTY */

/*
 * Send interrupt to process on other side of pty.
 * If it is in raw mode, just write NULL;
 * otherwise, write intr char.
 */
void
interrupt()
{
    ptyflush();	/* half-hearted */

#if defined(STREAMSPTY) && defined(TIOCSIGNAL)
    /* Streams PTY style ioctl to post a signal */
    if (really_stream)
	{
	    int sig = SIGINT;
	    ioctl(ourpty, TIOCSIGNAL, &sig);
	    ioctl(ourpty, I_FLUSH, FLUSHR);
	}
#else
#ifdef	TCSIG
    ioctl(ourpty, TCSIG, (char *)SIGINT);
#else	/* TCSIG */
    init_termbuf();
    *pfrontp++ = slctab[SLC_IP].sptr ?
	(unsigned char)*slctab[SLC_IP].sptr : '\177';
#endif	/* TCSIG */
#endif
}

/*
 * Send quit to process on other side of pty.
 * If it is in raw mode, just write NULL;
 * otherwise, write quit char.
 */
void
sendbrk()
{
    ptyflush();	/* half-hearted */
#ifdef	TCSIG
    ioctl(ourpty, TCSIG, (char *)SIGQUIT);
#else	/* TCSIG */
    init_termbuf();
    *pfrontp++ = slctab[SLC_ABORT].sptr ?
	(unsigned char)*slctab[SLC_ABORT].sptr : '\034';
#endif	/* TCSIG */
}

void
sendsusp()
{
#ifdef	SIGTSTP
    ptyflush();	/* half-hearted */
# ifdef	TCSIG
    ioctl(ourpty, TCSIG, (char *)SIGTSTP);
# else	/* TCSIG */
    *pfrontp++ = slctab[SLC_SUSP].sptr ?
	(unsigned char)*slctab[SLC_SUSP].sptr : '\032';
# endif	/* TCSIG */
#endif	/* SIGTSTP */
}

/*
 * When we get an AYT, if ^T is enabled, use that.  Otherwise,
 * just send back "[Yes]".
 */
void
recv_ayt()
{
#if	defined(SIGINFO) && defined(TCSIG)
    if (slctab[SLC_AYT].sptr && *slctab[SLC_AYT].sptr != _POSIX_VDISABLE) {
	ioctl(ourpty, TCSIG, (char *)SIGINFO);
	return;
    }
#endif
    output_data("\r\n[Yes]\r\n");
}

void
doeof()
{
    init_termbuf();

    *pfrontp++ = slctab[SLC_EOF].sptr ?
	(unsigned char)*slctab[SLC_EOF].sptr : '\004';
}

@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@@


1.41
log
@Get rid of libtelnet, it is compiled into the tree programs
(telnetd, telnet and tn3270) that use them instead.
This gets rid of a really hairy dependency between telnet and libtelnet.

ok millert@@
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@squish a strcopy, ok krw@@
@
text
@a364 5
#ifdef KRB5
	    port = krb5_getportbyname (NULL, "telnet", "tcp", 23);
#elif defined(KRB4)
	    port = k_getportbyname("telnet", "tcp", htons(23));
#else
a366 1
#endif
@


1.39
log
@Change terminalname from a pointer to an array.  Why people hide
the actual storage array as a static inside a function is beyond
me.  By exposing the real array we can use sizeof on it for strlcpy.
deraadt@@ OK
@
text
@d786 2
a787 1
	    strcpy(buf + strcspn(buf, "\r\n"), "\r\n");
@


1.38
log
@fix fd_set overflow

ok hin@@
@
text
@d642 1
a642 1
			strcpy(terminaltype, first);
@


1.37
log
@Backout unrelated changes in last commit
@
text
@d808 4
d996 8
a1005 1
	fd_set ibits, obits, xbits;
d1018 3
a1020 7
	FD_ZERO(&ibits);
	FD_ZERO(&obits);
	FD_ZERO(&xbits);

	if (f >= FD_SETSIZE
	    || p >= FD_SETSIZE)
	    fatal(net, "fd too large");
d1027 1
a1027 1
	    FD_SET(f, &obits);
d1029 1
a1029 1
	    FD_SET(p, &ibits);
d1032 1
a1032 1
	    FD_SET(p, &obits);
d1034 1
a1034 1
	    FD_SET(f, &ibits);
d1037 1
a1037 1
	    FD_SET(f, &xbits);
d1039 1
a1039 1
	if ((c = select(nfd, &ibits, &obits, &xbits,
d1053 1
a1053 1
	if (FD_ISSET(net, &xbits)) {
d1060 1
a1060 1
	if (FD_ISSET(net, &ibits)) {
d1099 1
a1099 1
		ioctl(net, SIOCATMARK, (char *)&atmark);
d1101 1
a1101 1
		    ncc = recv(net, netibuf, sizeof (netibuf), MSG_OOB);
d1103 1
a1103 1
			ncc = read(net, netibuf, sizeof (netibuf));
d1105 1
a1105 1
			    SYNCHing = stilloob(net);
d1109 1
a1109 1
		    ncc = read(net, netibuf, sizeof (netibuf));
d1112 1
a1112 1
		ncc = read(net, netibuf, sizeof (netibuf));
d1135 1
a1135 1
	if (FD_ISSET(p, &ibits)) {
d1212 1
a1212 1
	if (FD_ISSET(f, &obits) && (nfrontp - nbackp) > 0)
d1216 1
a1216 1
	if (FD_ISSET(p, &obits) && (pfrontp - pbackp) > 0)
@


1.36
log
@Kill '-a otp' flag.  Our login(5) doesn't support this option and on OpenBSD
you should use login.conf(5) for this kind of thing.  Closes PR 2967.
@
text
@a39 2
#include <pwd.h>
#include <grp.h>
d130 1
a130 3
char *gettytab[2] = { "./etc/gettytab", NULL };

static int issue_fd;
d432 1
a432 2
    tzset();
    openlog("telnetd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
a679 26
static void
drop_root(void)
{
    struct passwd *pw;

    pw = getpwnam(TELNETD_USER);
    if (!pw)
	fatal(-1, "getpwnam: telnetd: No such user");

    /*
     * Note: we will do another chdir to / later on, after we have
     * finished accessing files outside the jail.
     */
    if (chdir("/"))
	fatalperror(-1, "chdir");
    if (chroot(TELNETD_CHROOT))
	fatalperror(-1, "chroot");

    if (setgroups(0, NULL))
	fatalperror(-1, "setgroups");
    if (setgid(pw->pw_gid))
	fatalperror(-1, "setgid");
    if (setuid(pw->pw_uid))
	fatalperror(-1, "setuid");
}

d688 1
a688 1
    char user_name[256], *buf;
a689 2
    int channel[2];
    FILE *slavef;
a752 24

    if (pipe(channel))
	fatalperror(-1, "pipe");

    startslave(remote_host_name, channel);
    close(channel[0]);

    issue_fd = open("/etc/issue.net", O_RDONLY);
    if (issue_fd < 0)
	issue_fd = open("/etc/issue", O_RDONLY);

    drop_root();

    if (cgetent(&buf, gettytab, gettyent) < 0)
	buf = NULL;

    /* make the chroot really take effect */
    if (chdir("/"))
	fatalperror(-1, "chdir");

    slavef = fdopen(channel[1], "w");
    if (!slavef)
	fatalperror(-1, "fdopen");

d771 1
a771 1
	      level, user_name, buf, slavef);
d781 3
a783 5

    if (issue_fd < 0)
	return;

    f = fdopen(issue_fd, "r");
a789 15
    } else
	close(issue_fd);
}

extern char *goodenv_table[];

static void
fputenv(FILE *f)
{
    char **name, *value;

    for (name = goodenv_table; *name; name++) {
	value = getenv(*name) ?: "";
	if (fwrite(value, strlen(value) + 1, 1, f) != 1)
	    fatalperror(-1, "fwrite");
d799 1
a799 1
	  int level, char *autoname, char *gettybuf, FILE *slavef)
d804 1
d806 2
d957 1
a957 1
    if (gettybuf) {
d960 1
a960 1
	if (cgetstr(gettybuf, "he", &he) <= 0)
d962 1
a962 1
	if (cgetstr(gettybuf, "im", &IM) <= 0)
d964 1
a964 1
	if (cgetstr(gettybuf, "hn", &HN) > 0) {
d968 1
a968 1
	free(gettybuf);
a989 8
#ifdef AUTHENTICATION
    if (fwrite(&level, sizeof(level), 1, slavef) != 1 ||
	fwrite(autoname, strlen(autoname) + 1, 1, slavef) != 1)
	fatalperror(-1, "fwrite");
#endif

    fputenv(slavef);
    fclose(slavef);
d992 1
d996 7
@


1.35
log
@When gettytab doesn't exist, IM contains a #defined string so don't
try to free() it in that case.
@
text
@d40 2
d132 3
a134 1
char *gettytab[2] = { "/etc/gettytab", NULL };
a200 3
	    } else if (strcasecmp(optarg, "otp") == 0) {
		auth_level = 0;
		require_otp = 1;
d436 2
a437 1
    openlog("telnetd", LOG_PID | LOG_ODELAY, LOG_DAEMON);
d478 1
a478 1
    fprintf(stderr, " [-a (debug|other|otp|user|valid|off|none)]\n\t");
d685 26
d719 1
a719 1
    char user_name[256];
d721 2
d786 24
d828 1
a828 1
	      level, user_name);
d838 5
a842 3
    f = fopen("/etc/issue.net", "r");
    if(f == NULL)
	f = fopen("/etc/issue", "r");
d849 15
d873 1
a873 1
	  int level, char *autoname)
a877 1
    char *buf;
a878 2
    int startslave_called = 0;
    time_t timeout;
d1028 1
a1028 1
    if (cgetent(&buf, gettytab, gettyent) >= 0) {
d1031 1
a1031 1
	if (cgetstr(buf, "he", &he) <= 0)
d1033 1
a1033 1
	if (cgetstr(buf, "im", &IM) <= 0)
d1035 1
a1035 1
	if (cgetstr(buf, "hn", &HN) > 0) {
d1039 1
a1039 1
	cgetclose();
d1061 8
a1070 1
    timeout = time(NULL) + 5;
a1073 7

	/* wait for encryption to be turned on, but don't wait
           indefinitely */
	if(!startslave_called && (!encrypt_delay() || timeout > time(NULL))){
	    startslave_called = 1;
	    startslave(host, utmp_host, level, autoname);
	}
@


1.34
log
@wierd -> weird
@
text
@d981 1
a981 1
    if (*IM)
@


1.33
log
@Allows building w/o kerb support
@
text
@d96 1
a96 1
 * ptyibuf+1 to be on a full-word boundary.  The following wierdness
@


1.32
log
@Add back gettytab reading but use cget* instead of the obsolescent gtget*
@
text
@d56 4
d370 2
d373 2
a374 1
	    port = k_getportbyname("telnet", "tcp", htons(23));
@


1.31
log
@-Wall -Werror cleanup
@
text
@d125 2
d135 1
a135 1
char valid_opts[] = "Bd:hklnS:u:UL:y"
d248 4
d800 1
d953 16
a968 2
    IM = DEFAULT_IM;
    he = 0;
d970 2
d974 2
@


1.30
log
@Replace our telnetd with the one from heimdal-0.3f, with the following changes:
- obvious buildsystem tweakes
- our way to filter out bad environment variables
@
text
@d1371 1
@


1.29
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@a0 3
/*	$OpenBSD: telnetd.c,v 1.28 2001/05/25 10:25:22 hin Exp $	*/
/*	$NetBSD: telnetd.c,v 1.6 1996/03/20 04:25:57 tls Exp $	*/

a33 17
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)telnetd.c	8.4 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: telnetd.c,v 1.5 1996/02/28 20:38:23 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.28 2001/05/25 10:25:22 hin Exp $";
#endif
#endif /* not lint */

#include <curses.h>
#include <term.h>
d35 6
a40 1
#include "pathnames.h"
d42 1
a42 16
#include <sys/cdefs.h>
#define P __P

void doit P((struct sockaddr *));
void startslave P((char *, int, char *));
int terminaltypeok P((char *));


#if	defined(_SC_CRAY_SECURE_SYS) && !defined(SCM_SECURITY)
/*
 * UNICOS 6.0/6.1 do not have SCM_SECURITY defined, so we can
 * use it to tell us to turn off all the socket security code,
 * since that is only used in UNICOS 7.0 and later.
 */
# undef _SC_CRAY_SECURE_SYS
#endif
d44 1
a44 1
#if	defined(_SC_CRAY_SECURE_SYS)
a46 1
# ifdef SO_SEC_MULTI		/* 8.0 code */
a48 1
# endif /* SO_SEC_MULTI */
a52 1
# ifdef SO_SEC_MULTI		/* 8.0 code */
a53 3
# else /* SO_SEC_MULTI */	/* 7.0 code */
struct	socket_security ss;
# endif /* SO_SEC_MULTI */
d56 1
a56 2
#if	defined(AUTHENTICATION)
#include <libtelnet/auth.h>
a58 4
#if	defined(ENCRYPTION)
#include <libtelnet/encrypt.h>
#include <libtelnet/misc-proto.h>
#endif
d65 16
a80 1
# include <termio.h>
d82 2
d85 2
d88 1
d102 1
a102 1
int readstream();
d117 1
a117 1
#ifdef	CRAY
a123 1
char *gettyname = "default";
d126 1
a126 1
extern void usage P((void));
d133 3
a135 8
char valid_opts[] = {
	'd', ':', 'g', ':', 'h', 'k', 'n', 'S', ':', 'u', ':', 'U',
	'4', '6',
#ifdef	AUTHENTICATION
	'a', ':', 'X', ':',
#endif
#ifdef BFTPDAEMON
	'B',
d138 1
a138 7
	'D', ':',
#endif
#if	defined(CRAY) && defined(NEWINIT)
	'I', ':',
#endif
#ifdef	LINEMODE
	'l',
d140 2
a141 2
#ifdef CRAY
	'r', ':',
d143 1
a143 2
	'\0'
};
d145 1
a145 1
int family = AF_INET;
d147 2
a148 3
	int
main(argc, argv)
	char *argv[];
d150 5
a154 5
	struct sockaddr_storage from;
	int on = 1, fromlen;
	register int ch;
	extern char *optarg;
	extern int optind;
d156 1
a156 1
	int tos = -1;
a157 1

d159 2
a160 2
	extern int des_check_key;
	des_check_key = 1; /* Kludge for Mac NCSA telnet 2.6 /bg */
d162 3
d166 1
a166 5
	pfrontp = pbackp = ptyobuf;
	netip = netibuf;
	nfrontp = nbackp = netobuf;

	progname = *argv;
d168 1
a168 1
	nclearto = 0;
d171 6
a176 6
#ifdef CRAY
	/*
	 * Get number of pty's before trying to process options,
	 * which may include changing pty range.
	 */
	highpty = getnpty();
d179 2
a180 2
	while ((ch = getopt(argc, argv, valid_opts)) != -1) {
		switch(ch) {
d183 27
a209 24
		case 'a':
			/*
			 * Check for required authentication level
			 */
			if (strcmp(optarg, "debug") == 0) {
				auth_debug_mode = 1;
			} else if (strcasecmp(optarg, "none") == 0) {
				auth_level = 0;
			} else if (strcasecmp(optarg, "other") == 0) {
				auth_level = AUTH_OTHER;
			} else if (strcasecmp(optarg, "user") == 0) {
				auth_level = AUTH_USER;
			} else if (strcasecmp(optarg, "valid") == 0) {
				auth_level = AUTH_VALID;
			} else if (strcasecmp(optarg, "off") == 0) {
				/*
				 * This hack turns off authentication
				 */
				auth_level = -1;
			} else {
				fprintf(stderr,
			    "telnetd: unknown authorization level for -a\n");
			}
			break;
d212 10
a221 14
#ifdef BFTPDAEMON
		case 'B':
			bftpd++;
			break;
#endif /* BFTPDAEMON */

		case 'd':
			if (strcmp(optarg, "ebug") == 0) {
				debug++;
				break;
			}
			usage();
			/* NOTREACHED */
			break;
d224 19
a242 19
		case 'D':
			/*
			 * Check for desired diagnostics capabilities.
			 */
			if (!strcmp(optarg, "report")) {
				diagnostic |= TD_REPORT|TD_OPTIONS;
			} else if (!strcmp(optarg, "exercise")) {
				diagnostic |= TD_EXERCISE;
			} else if (!strcmp(optarg, "netdata")) {
				diagnostic |= TD_NETDATA;
			} else if (!strcmp(optarg, "ptydata")) {
				diagnostic |= TD_PTYDATA;
			} else if (!strcmp(optarg, "options")) {
				diagnostic |= TD_OPTIONS;
			} else {
				usage();
				/* NOT REACHED */
			}
			break;
a244 3
		case 'g':
			gettyname = optarg;
			break;
d246 17
a262 3
		case 'h':
			hostinfo = 0;
			break;
d264 20
a283 53
#if	defined(CRAY) && defined(NEWINIT)
		case 'I':
		    {
			extern char *gen_id;
			gen_id = optarg;
			break;
		    }
#endif	/* defined(CRAY) && defined(NEWINIT) */

#ifdef	LINEMODE
		case 'l':
			alwayslinemode = 1;
			break;
#endif	/* LINEMODE */

		case 'k':
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
			lmodetype = NO_AUTOKLUDGE;
#else
			/* ignore -k option if built without kludge linemode */
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
			break;

		case 'n':
			keepalive = 0;
			break;

#ifdef CRAY
		case 'r':
		    {
			char *strchr();
			char *c;

			/*
			 * Allow the specification of alterations
			 * to the pty search range.  It is legal to
			 * specify only one, and not change the
			 * other from its default.
			 */
			c = strchr(optarg, '-');
			if (c) {
				*c++ = '\0';
				highpty = atoi(c);
			}
			if (*optarg != '\0')
				lowpty = atoi(optarg);
			if ((lowpty > highpty) || (lowpty < 0) ||
							(highpty > 32767)) {
				usage();
				/* NOT REACHED */
			}
			break;
		    }
d286 6
a291 6
		case 'S':
#ifdef	HAS_GETTOS
			if ((tos = parsetos(optarg, "tcp")) < 0)
				fprintf(stderr, "%s%s%s\n",
					"telnetd: Bad TOS argument '", optarg,
					"'; will try to use default TOS");
d293 2
a294 2
			fprintf(stderr, "%s%s\n", "TOS option unavailable; ",
						"-S flag not supported\n");
d296 4
a299 1
			break;
d301 5
a305 3
		case 'u':
			utmp_len = atoi(optarg);
			break;
d307 3
a309 3
		case 'U':
			registerd_host_only = 1;
			break;
d312 15
a326 6
		case 'X':
			/*
			 * Check for invalid authentication types
			 */
			auth_disable_name(optarg);
			break;
d329 3
a331 3
		case '4':
			family = AF_INET;
			break;
d333 6
a338 11
		case '6':
			family = AF_INET6;
			break;
			
		default:
			fprintf(stderr, "telnetd: %c: unknown option\n", ch);
			/* FALLTHROUGH */
		case '?':
			usage();
			/* NOTREACHED */
		}
d340 1
d342 2
a343 2
	argc -= optind;
	argv += optind;
d345 3
a347 10
	if (debug) {
	    int s, ns, foo, error;
	    char *service = "telnet";
	    struct addrinfo hints, *res;

	    if (argc > 1) {
		usage();
		/* NOT REACHED */
	    } else if (argc == 1)
		service = *argv;
d349 2
a350 37
	    memset(&hints, 0, sizeof(hints));
	    hints.ai_flags = AI_PASSIVE;
	    hints.ai_family = family;
	    hints.ai_socktype = SOCK_STREAM;
	    hints.ai_protocol = 0;
	    error = getaddrinfo(NULL, service, &hints, &res);

	    if (error) {
		fprintf(stderr, "tcp/%s: %s\n", service, gai_strerror(error));
		exit(1);
	    }

	    s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	    if (s < 0) {
		perror("telnetd: socket");
		exit(1);
	    }
	    (void) setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
				(char *)&on, sizeof(on));
	    if (bind(s, res->ai_addr, res->ai_addrlen) < 0) {
		perror("bind");
		exit(1);
	    }
	    if (listen(s, 1) < 0) {
		perror("listen");
		exit(1);
	    }
	    foo = res->ai_addrlen;
	    ns = accept(s, res->ai_addr, &foo);
	    if (ns < 0) {
		perror("accept");
		exit(1);
	    }
	    (void) dup2(ns, 0);
	    (void) close(ns);
	    (void) close(s);
#ifdef convex
d352 10
a361 1
		; /* VOID*/		/* Just ignore the host/port name */
a362 3
	} else if (argc > 0) {
		usage();
		/* NOT REACHED */
d364 5
d370 2
a371 2
#if	defined(_SC_CRAY_SECURE_SYS)
	secflag = sysconf(_SC_CRAY_SECURE_SYS);
d373 7
a379 9
	/*
	 *	Get socket's security label
	 */
	if (secflag)  {
		int szss = sizeof(ss);
#ifdef SO_SEC_MULTI			/* 8.0 code */
		int sock_multi;
		int szi = sizeof(int);
#endif /* SO_SEC_MULTI */
d381 1
a381 1
		memset((void *)&dv, 0, sizeof(dv));
d383 2
a384 4
		if (getsysv(&sysv, sizeof(struct sysv)) != 0) {
			perror("getsysv");
			exit(1);
		}
d386 4
a389 4
		/*
		 *	Get socket security label and set device values
		 *	   {security label to be set on ttyp device}
		 */
d391 18
a408 19
		if ((getsockopt(0, SOL_SOCKET, SO_SECURITY,
			       (char *)&ss, &szss) < 0) ||
		    (getsockopt(0, SOL_SOCKET, SO_SEC_MULTI,
				(char *)&sock_multi, &szi) < 0)) {
			perror("getsockopt");
			exit(1);
		} else {
			dv.dv_actlvl = ss.ss_actlabel.lt_level;
			dv.dv_actcmp = ss.ss_actlabel.lt_compart;
			if (!sock_multi) {
				dv.dv_minlvl = dv.dv_maxlvl = dv.dv_actlvl;
				dv.dv_valcmp = dv.dv_actcmp;
			} else {
				dv.dv_minlvl = ss.ss_minlabel.lt_level;
				dv.dv_maxlvl = ss.ss_maxlabel.lt_level;
				dv.dv_valcmp = ss.ss_maxlabel.lt_compart;
			}
			dv.dv_devflg = 0;
		}
d410 8
a417 8
		if (getsockopt(0, SOL_SOCKET, SO_SECURITY,
				(char *)&ss, &szss) >= 0) {
			dv.dv_actlvl = ss.ss_slevel;
			dv.dv_actcmp = ss.ss_compart;
			dv.dv_minlvl = ss.ss_minlvl;
			dv.dv_maxlvl = ss.ss_maxlvl;
			dv.dv_valcmp = ss.ss_maxcmp;
		}
d419 1
a419 1
	}
d422 12
a433 12
	openlog("telnetd", LOG_PID | LOG_ODELAY, LOG_DAEMON);
	fromlen = sizeof (from);
	if (getpeername(0, (struct sockaddr *)&from, &fromlen) < 0) {
		fprintf(stderr, "%s: ", progname);
		perror("getpeername");
		_exit(1);
	}
	if (keepalive &&
	    setsockopt(0, SOL_SOCKET, SO_KEEPALIVE,
			(char *)&on, sizeof (on)) < 0) {
		syslog(LOG_WARNING, "setsockopt (SO_KEEPALIVE): %m");
	}
d435 6
a440 6
#if	defined(IPPROTO_IP) && defined(IP_TOS)
	if (from.ss_family == AF_INET) {
# if	defined(HAS_GETTOS)
		struct tosent *tp;
		if (tos < 0 && (tp = gettosbyname("telnet", "tcp")))
			tos = tp->t_tos;
d442 9
a450 8
		if (tos < 0)
			tos = 020;	/* Low Delay bit */
		if (tos
		   && (setsockopt(0, IPPROTO_IP, IP_TOS,
				  (char *)&tos, sizeof(tos)) < 0)
		   && (errno != ENOPROTOOPT) )
			syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
	}
d452 4
a455 4
	net = 0;
	doit((struct sockaddr *)&from);
	/* NOTREACHED */
	return (0);
d458 2
a459 2
	void
usage()
d461 1
a461 1
	syslog(LOG_ERR, "usage: telnetd"
d463 1
a463 1
	" [-a (debug|other|user|valid|off|none)]"
d465 1
a465 4
#ifdef BFTPDAEMON
	" [-B]"
#endif
	" [-debug]"
d467 1
a467 1
	" [-D (options|report|exercise|netdata|ptydata)]\n\t"
d469 2
a470 3
	" [-h]"
#if	defined(CRAY) && defined(NEWINIT)
	" [-Iinitid]"
d472 9
a480 12
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
	" [-k]"
#endif
#ifdef LINEMODE
	" [-l]"
#endif
	" [-n]"
#ifdef	CRAY
	" [-r[lowpty]-[highpty]]"
#endif
#ifdef	HAS_GETTOS
	" [-S tos]"
d483 1
a483 1
	" [-X auth-type]"
d485 3
a487 3
	" [-u utmp_hostname_length] [-U]"
	" [port]");
	exit(2);
d497 1
a497 1
	IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE
d500 2
a501 4
    int
getterminaltype(name, name_sz)
    char *name;
    size_t name_sz;
a503 1
    void _gettermname();
d506 1
a506 1
#if	defined(AUTHENTICATION)
d520 1
a520 1
    send_do(TELOPT_ENCRYPT, 1);        /* esc@@magic.fi */
d549 1
a549 1
			{ IAC, SB, TELOPT_TSPEED, TELQUAL_SEND, IAC, SE };
d551 1
a551 2
	memmove((void *)nfrontp, (void *)sb, sizeof sb);
	nfrontp += sizeof sb;
d556 1
a556 1
			{ IAC, SB, TELOPT_XDISPLOC, TELQUAL_SEND, IAC, SE };
d558 1
a558 2
	memmove((void *)nfrontp, (void *)sb, sizeof sb);
	nfrontp += sizeof sb;
d563 1
a563 1
			{ IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_SEND, IAC, SE };
d565 1
a565 2
	memmove((void *)nfrontp, (void *)sb, sizeof sb);
	nfrontp += sizeof sb;
d570 1
a570 1
			{ IAC, SB, TELOPT_OLD_ENVIRON, TELQUAL_SEND, IAC, SE };
d572 1
a572 2
	memmove((void *)nfrontp, (void *)sb, sizeof sb);
	nfrontp += sizeof sb;
d577 1
a577 2
	memmove((void *)nfrontp, (void *)ttytype_sbbuf, sizeof ttytype_sbbuf);
	nfrontp += sizeof ttytype_sbbuf;
d579 1
a579 1
					sizeof ttytype_sbbuf - 2););
d630 1
a630 1
		     _gettermname();
d632 1
a632 1
			strlcpy(terminaltype, first, sizeof(terminaltype));
d641 2
a642 2
    void
_gettermname()
d652 1
a652 2
    memmove((void *)nfrontp, (void *)ttytype_sbbuf, sizeof ttytype_sbbuf);
    nfrontp += sizeof ttytype_sbbuf;
d654 1
a654 1
					sizeof ttytype_sbbuf - 2););
d659 2
a660 3
    int
terminaltypeok(s)
    char *s;
d662 1
a662 11
    int errret;

    if (terminaltype == NULL)
	return(1);

    /*
     * setupterm() will return OK if the type is known, and
     * ERR if it is not known.
     * We return 1 on success and 0 on failure.
     */
    return(setupterm(s, STDOUT_FILENO, &errret) != ERR);
a664 3
#ifndef	MAXHOSTNAMELEN
#define	MAXHOSTNAMELEN 64
#endif	/* MAXHOSTNAMELEN */
a665 1
char *hostname;
d668 1
a668 6

#ifndef	convex
extern void telnet P((int, int));
#else
extern void telnet P((int, int, char *));
#endif
d673 2
a674 3
	void
doit(who)
	struct sockaddr *who;
d676 4
a679 8
	char *host = NULL, *inet_ntoa();
	struct hostent *hp;
	int level;
	int ptynum;
	char user_name[256];
	char *ap;
	size_t alen;
	char hbuf[NI_MAXHOST];
d681 6
a686 10
	/*
	 * Find an available pty to use.
	 */
#ifndef	convex
	pty = getpty(&ptynum);
	if (pty < 0)
		fatal(net, "No free pseudo-tty devices.");
#else
	for (;;) {
		char *lp;
d688 6
a693 2
		if ((lp = getpty()) == NULL)
			fatal(net, "Out of ptys");
d695 7
a701 22
		if ((pty = open(lp, O_RDWR)) >= 0) {
			strlcpy(line, lp, sizeof line);
			line[5] = 't';
			break;
		}
	}
#endif

#if	defined(_SC_CRAY_SECURE_SYS)
	/*
	 *	set ttyp line security label
	 */
	if (secflag) {
		char slave_dev[16];

		sprintf(tty_dev, "/dev/pty/%03d", ptynum);
		if (setdevs(tty_dev, &dv) < 0)
		 	fatal(net, "cannot set pty security");
		sprintf(slave_dev, "/dev/ttyp%03d", ptynum);
		if (setdevs(slave_dev, &dv) < 0)
		 	fatal(net, "cannot set tty security");
	}
d704 20
a723 32
	/* get name of connected client */
	switch (who->sa_family) {
	case AF_INET:
		ap = (char *)&((struct sockaddr_in *)who)->sin_addr;
		alen = sizeof(struct in_addr);
		break;
	case AF_INET6:
		ap = (char *)&((struct sockaddr_in6 *)who)->sin6_addr;
		alen = sizeof(struct in6_addr);
		break;
	default:
		ap = NULL;
		alen = 0;
		break;
	}
	if (ap)
		hp = gethostbyaddr(ap, alen, who->sa_family);
	else
		hp = NULL;

	if (hp == NULL && registerd_host_only) {
		fatal(net, "Couldn't resolve your address into a host name.\r\n\
	 Please contact your net administrator");
	} else if (hp && (strlen(hp->h_name) <=
	    (u_int)((utmp_len < 0) ? -utmp_len : utmp_len))) {
		host = hp->h_name;
	} else if (getnameinfo(who, who->sa_len, hbuf, sizeof(hbuf), NULL, 0,
	    NI_NUMERICHOST) == 0) {
		host = hbuf;
	} else {
		fatal(net, "getnameinfo");
	}
d725 12
a736 9
	/*
	 * We must make a copy because Kerberos is probably going
	 * to also do a gethost* and overwrite the static data...
	 */
	strlcpy(remote_host_name, host, sizeof(remote_host_name));
	host = remote_host_name;

	(void) gethostname(host_name, sizeof (host_name));
	hostname = host_name;
d738 2
a739 2
#if	defined(AUTHENTICATION)
	auth_encrypt_init(hostname, host, "TELNETD", 1);
d742 15
a756 21
	init_env();
	/*
	 * get terminal type.
	 */
	*user_name = 0;
	level = getterminaltype(user_name, sizeof(user_name));
	setenv("TERM", terminaltype ? terminaltype : "network", 1);	/* XXX mem */

	/*
	 * Start up the login process on the slave side of the terminal
	 */
#ifndef	convex
	startslave(host, level, user_name);

#if	defined(_SC_CRAY_SECURE_SYS)
	if (secflag) {
		if (setulvl(dv.dv_actlvl) < 0)
			fatal(net,"cannot setulvl()");
		if (setucmp(dv.dv_actcmp) < 0)
			fatal(net, "cannot setucmp()");
	}
d759 4
a762 5
	telnet(net, pty);  /* begin server processing */
#else
	telnet(net, pty, host);
#endif
	/*NOTREACHED*/
d765 3
a767 5
#if	defined(CRAY2) && defined(UNICOS5) && defined(UNICOS50)
	int
Xterm_output(ibufp, obuf, icountp, ocount)
	char **ibufp, *obuf;
	int *icountp, ocount;
d769 12
a780 5
	int ret;
	ret = term_output(*ibufp, obuf, *icountp, ocount);
	*ibufp += *icountp;
	*icountp = 0;
	return(ret);
a781 2
#define	term_output	Xterm_output
#endif	/* defined(CRAY2) && defined(UNICOS5) && defined(UNICOS50) */
d787 3
a789 10
	void
#ifndef	convex
telnet(f, p)
#else
telnet(f, p, host)
#endif
	int f, p;
#ifdef convex
	char *host;
#endif
d791 6
a796 10
	int on = 1;
#define	TABBUFSIZ	512
	char	defent[TABBUFSIZ];
	char	defstrs[TABBUFSIZ];
#undef	TABBUFSIZ
	char *HE;
	char *HN;
	char *IM;
	void netflush();
	int nfd;
d798 4
a801 4
	/*
	 * Initialize the slc mapping table.
	 */
	get_slc_defaults();
d803 18
a820 18
	/*
	 * Do some tests where it is desireable to wait for a response.
	 * Rather than doing them slowly, one at a time, do them all
	 * at once.
	 */
	if (my_state_is_wont(TELOPT_SGA))
		send_will(TELOPT_SGA, 1);
	/*
	 * Is the client side a 4.2 (NOT 4.3) system?  We need to know this
	 * because 4.2 clients are unable to deal with TCP urgent data.
	 *
	 * To find out, we send out a "DO ECHO".  If the remote system
	 * answers "WILL ECHO" it is probably a 4.2 client, and we note
	 * that fact ("WILL ECHO" ==> that the client will echo what
	 * WE, the server, sends it; it does NOT mean that the client will
	 * echo the terminal input).
	 */
	send_do(TELOPT_ECHO, 1);
d822 8
a829 10
#ifdef	LINEMODE
	if (his_state_is_wont(TELOPT_LINEMODE)) {
		/* Query the peer for linemode support by trying to negotiate
		 * the linemode option.
		 */
		linemode = 0;
		editmode = 0;
		send_do(TELOPT_LINEMODE, 1);  /* send do linemode */
	}
#endif	/* LINEMODE */
d831 11
a841 8
	/*
	 * Send along a couple of other options that we wish to negotiate.
	 */
	send_do(TELOPT_NAWS, 1);
	send_will(TELOPT_STATUS, 1);
	flowmode = 1;		/* default flow control state */
	restartany = -1;	/* uninitialized... */
	send_do(TELOPT_LFLOW, 1);
d843 32
a874 11
	/*
	 * Spin, waiting for a response from the DO ECHO.  However,
	 * some REALLY DUMB telnets out there might not respond
	 * to the DO ECHO.  So, we spin looking for NAWS, (most dumb
	 * telnets so far seem to respond with WONT for a DO that
	 * they don't understand...) because by the time we get the
	 * response, it will already have processed the DO ECHO.
	 * Kludge upon kludge.
	 */
	while (his_will_wont_is_changing(TELOPT_NAWS))
		ttloop();
d876 4
a879 32
	/*
	 * But...
	 * The client might have sent a WILL NAWS as part of its
	 * startup code; if so, we'll be here before we get the
	 * response to the DO ECHO.  We'll make the assumption
	 * that any implementation that understands about NAWS
	 * is a modern enough implementation that it will respond
	 * to our DO ECHO request; hence we'll do another spin
	 * waiting for the ECHO option to settle down, which is
	 * what we wanted to do in the first place...
	 */
	if (his_want_state_is_will(TELOPT_ECHO) &&
	    his_state_is_will(TELOPT_NAWS)) {
		while (his_will_wont_is_changing(TELOPT_ECHO))
			ttloop();
	}
	/*
	 * On the off chance that the telnet client is broken and does not
	 * respond to the DO ECHO we sent, (after all, we did send the
	 * DO NAWS negotiation after the DO ECHO, and we won't get here
	 * until a response to the DO NAWS comes back) simulate the
	 * receipt of a will echo.  This will also send a WONT ECHO
	 * to the client, since we assume that the client failed to
	 * respond because it believes that it is already in DO ECHO
	 * mode, which we do not want.
	 */
	if (his_want_state_is_will(TELOPT_ECHO)) {
		DIAG(TD_OPTIONS,
			{sprintf(nfrontp, "td: simulating recv\r\n");
			 nfrontp += strlen(nfrontp);});
		willoption(TELOPT_ECHO);
	}
d881 2
a882 4
	/*
	 * Finally, to clean things up, we turn on our echo.  This
	 * will break stupid 4.2 telnets out of local terminal echo.
	 */
d884 4
a887 4
	if (my_state_is_wont(TELOPT_ECHO))
		send_will(TELOPT_ECHO, 1);

#ifndef	STREAMSPTY
d891 1
a891 1
	(void) ioctl(p, TIOCPKT, (char *)&on);
a893 9
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
	/*
	 * Continuing line mode support.  If client does not support
	 * real linemode, attempt to negotiate kludge linemode by sending
	 * the do timing mark sequence.
	 */
	if (lmodetype < REAL_LINEMODE)
		send_do(TELOPT_TM, 1);
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
d895 6
a900 6
	/*
	 * Call telrcv() once to pick up anything received during
	 * terminal type negotiation, 4.2/4.3 determination, and
	 * linemode negotiation.
	 */
	telrcv();
d902 2
a903 5
	(void) ioctl(f, FIONBIO, (char *)&on);
	(void) ioctl(p, FIONBIO, (char *)&on);
#if	defined(CRAY2) && defined(UNICOS5)
	init_termdriver(f, p, interrupt, sendbrk);
#endif
d905 3
a907 3
#if	defined(SO_OOBINLINE)
	(void) setsockopt(net, SOL_SOCKET, SO_OOBINLINE,
				(char *)&on, sizeof on);
d911 1
a911 1
	(void) signal(SIGTSTP, SIG_IGN);
d914 5
a918 5
	/*
	 * Ignoring SIGTTOU keeps the kernel from blocking us
	 * in ttioct() in /sys/tty.c.
	 */
	(void) signal(SIGTTOU, SIG_IGN);
d921 1
a921 16
	(void) signal(SIGCHLD, cleanup);

#if	defined(CRAY2) && defined(UNICOS5)
	/*
	 * Cray-2 will send a signal when pty modes are changed by slave
	 * side.  Set up signal handler now.
	 */
	if ((int)signal(SIGUSR1, termstat) < 0)
		perror("signal");
	else if (ioctl(p, TCSIGME, (char *)SIGUSR1) < 0)
		perror("ioctl:TCSIGME");
	/*
	 * Make processing loop check terminal characteristics early on.
	 */
	termstat();
#endif
d924 6
a929 7
	{
		register int t;
		t = open(_PATH_TTY, O_RDWR);
		if (t >= 0) {
			(void) ioctl(t, TIOCNOTTY, (char *)0);
			(void) close(t);
		}
d931 1
d934 26
a959 4
#if	defined(CRAY) && defined(NEWINIT) && defined(TIOCSCTTY)
	(void) setsid();
	ioctl(p, TIOCSCTTY, 0);
#endif
a960 7
	/*
	 * Show banner that getty never gave.
	 *
	 * We put the banner in the pty input buffer.  This way, it
	 * gets carriage return null processing, etc., just like all
	 * other pty --> client data.
	 */
d962 5
a966 4
#if	!defined(CRAY) || !defined(NEWINIT)
	if (getenv("USER"))
		hostinfo = 0;
#endif
d968 5
a972 13
	if (gtgetent(defent, gettyname) == 1) {
		char *cp=defstrs;

		HE = gtgetstr("he", &cp);
		HN = gtgetstr("hn", &cp);
		IM = gtgetstr("im", &cp);
		if (HN && *HN)
			strlcpy(host_name, HN, sizeof host_name);
		if (IM == 0)
			IM = "";
	} else {
		IM = DEFAULT_IM;
		HE = 0;
a973 15
	edithost(HE, host_name);
	if (hostinfo && *IM)
		putf(IM, ptyibuf2);

	if (pcc)
		(void) strncat(ptyibuf2, ptyip, pcc+1);
	ptyip = ptyibuf2;
	pcc = strlen(ptyip);
#ifdef	LINEMODE
	/*
	 * Last check to make sure all our states are correct.
	 */
	init_termbuf();
	localstat();
#endif	/* LINEMODE */
d975 2
a976 3
	DIAG(TD_REPORT,
		{sprintf(nfrontp, "td: Entering processing loop\r\n");
		 nfrontp += strlen(nfrontp);});
d978 3
a980 3
#ifdef	convex
	startslave(host);
#endif
d982 3
a984 4
	nfd = ((f > p) ? f : p) + 1;
	for (;;) {
		fd_set ibits, obits, xbits;
		register int c;
d986 22
a1007 36
		if (ncc < 0 && pcc < 0)
			break;

#if	defined(CRAY2) && defined(UNICOS5)
		if (needtermstat)
			_termstat();
#endif	/* defined(CRAY2) && defined(UNICOS5) */
		FD_ZERO(&ibits);
		FD_ZERO(&obits);
		FD_ZERO(&xbits);
		/*
		 * Never look for input if there's still
		 * stuff in the corresponding output buffer
		 */
		if (nfrontp - nbackp || pcc > 0) {
			FD_SET(f, &obits);
		} else {
			FD_SET(p, &ibits);
		}
		if (pfrontp - pbackp || ncc > 0) {
			FD_SET(p, &obits);
		} else {
			FD_SET(f, &ibits);
		}
		if (!SYNCHing) {
			FD_SET(f, &xbits);
		}
		if ((c = select(nfd, &ibits, &obits, &xbits,
						(struct timeval *)0)) < 1) {
			if (c == -1) {
				if (errno == EINTR) {
					continue;
				}
			}
			sleep(5);
			continue;
d1009 4
d1014 6
a1019 6
		/*
		 * Any urgent data?
		 */
		if (FD_ISSET(net, &xbits)) {
		    SYNCHing = 1;
		}
d1021 49
a1069 53
		/*
		 * Something to read from the network...
		 */
		if (FD_ISSET(net, &ibits)) {
#if	!defined(SO_OOBINLINE)
			/*
			 * In 4.2 (and 4.3 beta) systems, the
			 * OOB indication and data handling in the kernel
			 * is such that if two separate TCP Urgent requests
			 * come in, one byte of TCP data will be overlaid.
			 * This is fatal for Telnet, but we try to live
			 * with it.
			 *
			 * In addition, in 4.2 (and...), a special protocol
			 * is needed to pick up the TCP Urgent data in
			 * the correct sequence.
			 *
			 * What we do is:  if we think we are in urgent
			 * mode, we look to see if we are "at the mark".
			 * If we are, we do an OOB receive.  If we run
			 * this twice, we will do the OOB receive twice,
			 * but the second will fail, since the second
			 * time we were "at the mark", but there wasn't
			 * any data there (the kernel doesn't reset
			 * "at the mark" until we do a normal read).
			 * Once we've read the OOB data, we go ahead
			 * and do normal reads.
			 *
			 * There is also another problem, which is that
			 * since the OOB byte we read doesn't put us
			 * out of OOB state, and since that byte is most
			 * likely the TELNET DM (data mark), we would
			 * stay in the TELNET SYNCH (SYNCHing) state.
			 * So, clocks to the rescue.  If we've "just"
			 * received a DM, then we test for the
			 * presence of OOB data when the receive OOB
			 * fails (and AFTER we did the normal mode read
			 * to clear "at the mark").
			 */
		    if (SYNCHing) {
			int atmark;

			(void) ioctl(net, SIOCATMARK, (char *)&atmark);
			if (atmark) {
			    ncc = recv(net, netibuf, sizeof (netibuf), MSG_OOB);
			    if ((ncc == -1) && (errno == EINVAL)) {
				ncc = read(net, netibuf, sizeof (netibuf));
				if (sequenceIs(didnetreceive, gotDM)) {
				    SYNCHing = stilloob(net);
				}
			    }
			} else {
			    ncc = read(net, netibuf, sizeof (netibuf));
a1070 2
		    } else {
			ncc = read(net, netibuf, sizeof (netibuf));
d1072 7
a1078 1
		    settimer(didnetreceive);
d1080 1
a1080 1
		    ncc = read(net, netibuf, sizeof (netibuf));
d1082 5
a1086 12
		    if (ncc < 0 && errno == EWOULDBLOCK)
			ncc = 0;
		    else {
			if (ncc <= 0) {
			    break;
			}
			netip = netibuf;
		    }
		    DIAG((TD_REPORT | TD_NETDATA),
			    {sprintf(nfrontp, "td: netread %d chars\r\n", ncc);
			     nfrontp += strlen(nfrontp);});
		    DIAG(TD_NETDATA, printdata("nd", netip, ncc));
d1088 7
d1096 8
a1103 8
		/*
		 * Something to read from the pty...
		 */
		if (FD_ISSET(p, &ibits)) {
#ifndef	STREAMSPTY
			pcc = read(p, ptyibuf, BUFSIZ);
#else
			pcc = readstream(p, ptyibuf, BUFSIZ);
d1105 8
a1112 6
			/*
			 * On some systems, if we try to read something
			 * off the master side before the slave side is
			 * opened, we get EIO.
			 */
			if (pcc < 0 && (errno == EWOULDBLOCK ||
d1114 1
a1114 1
					errno == EAGAIN ||
d1116 7
a1122 18
					errno == EIO)) {
				pcc = 0;
			} else {
				if (pcc <= 0)
					break;
#if	!defined(CRAY2) || !defined(UNICOS5)
#ifdef	LINEMODE
				/*
				 * If ioctl from pty, pass it through net
				 */
				if (ptyibuf[0] & TIOCPKT_IOCTL) {
					copy_termbuf(ptyibuf+1, pcc-1);
					localstat();
					pcc = 1;
				}
#endif	/* LINEMODE */
				if (ptyibuf[0] & TIOCPKT_FLUSHWRITE) {
					netclear();	/* clear buffer back */
d1124 11
a1134 47
					/*
					 * There are client telnets on some
					 * operating systems get screwed up
					 * royally if we send them urgent
					 * mode data.
					 */
					*nfrontp++ = IAC;
					*nfrontp++ = DM;
					neturg = nfrontp-1; /* off by one XXX */
					DIAG(TD_OPTIONS,
					    printoption("td: send IAC", DM));

#endif
				}
				if (his_state_is_will(TELOPT_LFLOW) &&
				    (ptyibuf[0] &
				     (TIOCPKT_NOSTOP|TIOCPKT_DOSTOP))) {
					int newflow =
					    ptyibuf[0] & TIOCPKT_DOSTOP ? 1 : 0;
					if (newflow != flowmode) {
						flowmode = newflow;
						(void) sprintf(nfrontp,
							"%c%c%c%c%c%c",
							IAC, SB, TELOPT_LFLOW,
							flowmode ? LFLOW_ON
								 : LFLOW_OFF,
							IAC, SE);
						nfrontp += 6;
						DIAG(TD_OPTIONS, printsub('>',
						    (unsigned char *)nfrontp-4,
						    4););
					}
				}
				pcc--;
				ptyip = ptyibuf+1;
#else	/* defined(CRAY2) && defined(UNICOS5) */
				if (!uselinemode) {
					unpcc = pcc;
					unptyip = ptyibuf;
					pcc = term_output(&unptyip, ptyibuf2,
								&unpcc, BUFSIZ);
					ptyip = ptyibuf2;
				} else
					ptyip = ptyibuf;
#endif	/* defined(CRAY2) && defined(UNICOS5) */
			}
		}
d1136 1
a1136 19
		while (pcc > 0) {
			if ((&netobuf[BUFSIZ] - nfrontp) < 2)
				break;
			c = *ptyip++ & 0377, pcc--;
			if (c == IAC)
				*nfrontp++ = c;
#if	defined(CRAY2) && defined(UNICOS5)
			else if (c == '\n' &&
				     my_state_is_wont(TELOPT_BINARY) && newmap)
				*nfrontp++ = '\r';
#endif	/* defined(CRAY2) && defined(UNICOS5) */
			*nfrontp++ = c;
			if ((c == '\r') && (my_state_is_wont(TELOPT_BINARY))) {
				if (pcc > 0 && ((*ptyip & 0377) == '\n')) {
					*nfrontp++ = *ptyip++ & 0377;
					pcc--;
				} else
					*nfrontp++ = '\0';
			}
d1138 16
a1153 9
#if	defined(CRAY2) && defined(UNICOS5)
		/*
		 * If chars were left over from the terminal driver,
		 * note their existence.
		 */
		if (!uselinemode && unpcc) {
			pcc = unpcc;
			unpcc = 0;
			ptyip = unptyip;
d1155 4
a1158 1
#endif	/* defined(CRAY2) && defined(UNICOS5) */
d1160 14
a1173 6
		if (FD_ISSET(f, &obits) && (nfrontp - nbackp) > 0)
			netflush();
		if (ncc > 0)
			telrcv();
		if (FD_ISSET(p, &obits) && (pfrontp - pbackp) > 0)
			ptyflush();
d1175 10
a1184 2
	cleanup(0);
}  /* end of telnet */
d1194 1
a1194 1
int flowison = -1;  /* current state of flow: -1 is unknown */
d1196 2
a1197 4
int readstream(p, ibuf, bufsize)
	int p;
	char *ibuf;
	int bufsize;
d1199 30
a1228 29
	int flags = 0;
	int ret = 0;
	struct termios *tsp;
	struct termio *tp;
	struct iocblk *ip;
	char vstop, vstart;
	int ixon;
	int newflow;

	strbufc.maxlen = BUFSIZ;
	strbufc.buf = (char *)ctlbuf;
	strbufd.maxlen = bufsize-1;
	strbufd.len = 0;
	strbufd.buf = ibuf+1;
	ibuf[0] = 0;

	ret = getmsg(p, &strbufc, &strbufd, &flags);
	if (ret < 0)  /* error of some sort -- probably EAGAIN */
		return(-1);

	if (strbufc.len <= 0 || ctlbuf[0] == M_DATA) {
		/* data message */
		if (strbufd.len > 0) {			/* real data */
			return(strbufd.len + 1);	/* count header char */
		} else {
			/* nothing there */
			errno = EAGAIN;
			return(-1);
		}
d1230 11
d1242 2
a1243 3
	/*
	 * It's a control message.  Return 1, to look at the flag we set
	 */
d1245 26
a1270 31
	switch (ctlbuf[0]) {
	case M_FLUSH:
		if (ibuf[1] & FLUSHW)
			ibuf[0] = TIOCPKT_FLUSHWRITE;
		return(1);

	case M_IOCTL:
		ip = (struct iocblk *) (ibuf+1);

		switch (ip->ioc_cmd) {
		case TCSETS:
		case TCSETSW:
		case TCSETSF:
			tsp = (struct termios *)
					(ibuf+1 + sizeof(struct iocblk));
			vstop = tsp->c_cc[VSTOP];
			vstart = tsp->c_cc[VSTART];
			ixon = tsp->c_iflag & IXON;
			break;
		case TCSETA:
		case TCSETAW:
		case TCSETAF:
			tp = (struct termio *) (ibuf+1 + sizeof(struct iocblk));
			vstop = tp->c_cc[VSTOP];
			vstart = tp->c_cc[VSTART];
			ixon = tp->c_iflag & IXON;
			break;
		default:
			errno = EAGAIN;
			return(-1);
		}
d1272 5
a1276 6
		newflow =  (ixon && (vstart == 021) && (vstop == 023)) ? 1 : 0;
		if (newflow != flowison) {  /* it's a change */
			flowison = newflow;
			ibuf[0] = newflow ? TIOCPKT_DOSTOP : TIOCPKT_NOSTOP;
			return(1);
		}
d1278 1
d1280 3
a1282 3
	/* nothing worth doing anything about */
	errno = EAGAIN;
	return(-1);
d1291 1
a1291 1
	void
d1294 1
a1294 1
	ptyflush();	/* half-hearted */
d1297 2
a1298 1
	/* Streams PTY style ioctl to post a signal */
d1300 3
a1302 3
		int sig = SIGINT;
		(void) ioctl(pty, TIOCSIGNAL, &sig);
		(void) ioctl(pty, I_FLUSH, FLUSHR);
d1306 1
a1306 1
	(void) ioctl(pty, TCSIG, (char *)SIGINT);
d1308 3
a1310 3
	init_termbuf();
	*pfrontp++ = slctab[SLC_IP].sptr ?
			(unsigned char)*slctab[SLC_IP].sptr : '\177';
d1320 1
a1320 1
	void
d1323 1
a1323 1
	ptyflush();	/* half-hearted */
d1325 1
a1325 1
	(void) ioctl(pty, TCSIG, (char *)SIGQUIT);
d1327 3
a1329 3
	init_termbuf();
	*pfrontp++ = slctab[SLC_ABORT].sptr ?
			(unsigned char)*slctab[SLC_ABORT].sptr : '\034';
d1333 1
a1333 1
	void
d1337 1
a1337 1
	ptyflush();	/* half-hearted */
d1339 1
a1339 1
	(void) ioctl(pty, TCSIG, (char *)SIGTSTP);
d1341 2
a1342 2
	*pfrontp++ = slctab[SLC_SUSP].sptr ?
			(unsigned char)*slctab[SLC_SUSP].sptr : '\032';
d1351 1
a1351 1
	void
d1355 4
a1358 4
	if (slctab[SLC_AYT].sptr && *slctab[SLC_AYT].sptr != _POSIX_VDISABLE) {
		(void) ioctl(pty, TCSIG, (char *)SIGINFO);
		return;
	}
d1360 1
a1360 2
	(void) strcpy(nfrontp, "\r\n[Yes]\r\n");
	nfrontp += 9;
d1363 1
a1363 1
	void
d1366 1
a1366 1
	init_termbuf();
d1368 2
a1369 9
#if	defined(LINEMODE) && defined(USE_TERMIO) && (VEOF == VMIN)
	if (!tty_isediting()) {
		extern char oldeofc;
		*pfrontp++ = oldeofc;
		return;
	}
#endif
	*pfrontp++ = slctab[SLC_EOF].sptr ?
			(unsigned char)*slctab[SLC_EOF].sptr : '\004';
@


1.28
log
@KerberosV support from Heimdal.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.27 2000/11/16 19:00:19 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.27 2000/11/16 19:00:19 millert Exp $";
d708 1
a708 2
	    (void) strncpy(first, terminaltype, sizeof(first)-1);
	    first[sizeof(first)-1] = '\0';
d713 1
a713 2
		(void) strncpy(last, terminaltype, sizeof(last)-1);
		last[sizeof(last)-1] = '\0';
d731 2
a732 4
		    if (strncmp(first, terminaltype, sizeof(first)) != 0) {
			(void) strncpy(terminaltype, first, sizeof(terminaltype)-1);
			terminaltype[sizeof(terminaltype)-1] = '\0';
		    }
d822 1
a822 2
			strncpy(line, lp, sizeof line -1);
			line[sizeof line -1] = '\0';
d882 1
a882 2
	strncpy(remote_host_name, host, sizeof(remote_host_name)-1);
	remote_host_name[sizeof(remote_host_name)-1] = 0;
d1158 2
a1159 4
		if (HN && *HN) {
			strncpy(host_name, HN, sizeof host_name - 1);
			host_name[sizeof host_name -1] = '\0';
		}
@


1.27
log
@Don't use sizeof() a pointer as a length parameter.  This change makes
'line' from sys_term.c from a char * into a char array.  There's no
need to explicitly initialize the contents to 0 since that happens
for globals anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.26 2000/10/24 21:52:37 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.26 2000/10/24 21:52:37 millert Exp $";
d593 1
a593 1
getterminaltype(name)
d595 1
d609 1
a609 1
	retval = auth_wait(name);
d903 1
a903 1
	level = getterminaltype(user_name);
@


1.26
log
@When calling setupterm() pass in an int* for the error code so
it doesn't spew to stderr if the terminal type can't be found.

Fix a logic thinko wrt terminaltypeok() -- it should return 0 on failure,
not success.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.25 2000/10/10 15:14:55 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.25 2000/10/10 15:14:55 millert Exp $";
a819 1
		extern char *line, *getpty();
@


1.25
log
@Link with curses, not ocurses and use setupterm().  For now, telnet(1)
still needs ocurses but that will change.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.24 2000/10/06 10:55:00 hin Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.24 2000/10/06 10:55:00 hin Exp $";
d767 1
d775 1
a775 1
     * We return 0 on success and 1 on failure.
d777 1
a777 1
    return(setupterm(s, STDOUT_FILENO, NULL) == ERR);
@


1.24
log
@Remove the unimplemented -edebug flag from usage and manpage.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.23 2000/09/15 07:13:48 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.23 2000/09/15 07:13:48 deraadt Exp $";
d52 2
a53 1
#include "curses.h"
a766 1
    char buf[1024];
d772 3
a774 5
     * tgetent() will return 1 if the type is known, and
     * 0 if it is not known.  If it returns -1, it couldn't
     * open the database.  But if we can't open the database,
     * it won't help to say we failed, because we won't be
     * able to verify anything else.  So, we treat -1 like 1.
d776 1
a776 3
    if (tgetent(buf, s) == 0)
	return(0);
    return(1);
@


1.23
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.22 2000/08/18 03:26:10 itojun Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.22 2000/08/18 03:26:10 itojun Exp $";
a554 3
#endif
#ifdef	AUTHENTICATION
	" [-edebug]"
@


1.22
log
@add support to telnetd -debug -6 (listens to AF_INET6).
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.21 1999/12/20 15:51:52 itojun Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.21 1999/12/20 15:51:52 itojun Exp $";
d910 1
a910 1
	setenv("TERM", terminaltype ? terminaltype : "network", 1);
@


1.21
log
@perform setsockopt(IP_TOS) only when IPv4 connection comes.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.20 1999/12/11 01:59:43 itojun Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.20 1999/12/11 01:59:43 itojun Exp $";
d156 1
d178 2
d374 8
d395 3
a397 3
	    int s, ns, foo;
	    struct servent *sp;
	    static struct sockaddr_in sin = { AF_INET };
d402 13
a414 19
	    } else if (argc == 1) {
		    if ((sp = getservbyname(*argv, "tcp"))) {
			sin.sin_port = sp->s_port;
		    } else {
			sin.sin_port = atoi(*argv);
			if ((int)sin.sin_port <= 0) {
			    fprintf(stderr, "telnetd: %s: bad port #\n", *argv);
			    usage();
			    /* NOT REACHED */
			}
			sin.sin_port = htons((u_short)sin.sin_port);
		   }
	    } else {
		sp = getservbyname("telnet", "tcp");
		if (sp == 0) {
		    fprintf(stderr, "telnetd: tcp/telnet: unknown service\n");
		    exit(1);
		}
		sin.sin_port = sp->s_port;
d417 1
a417 1
	    s = socket(AF_INET, SOCK_STREAM, 0);
d419 2
a420 2
		    perror("telnetd: socket");;
		    exit(1);
d424 1
a424 1
	    if (bind(s, (struct sockaddr *)&sin, sizeof sin) < 0) {
d432 2
a433 2
	    foo = sizeof sin;
	    ns = accept(s, (struct sockaddr *)&sin, &foo);
@


1.20
log
@set "host" properly when getnameinfo() is successful.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.19 1999/12/10 20:06:48 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.19 1999/12/10 20:06:48 deraadt Exp $";
d516 1
a516 1
	{
@


1.19
log
@v6 friendly; KAME
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.18 1999/08/17 09:13:13 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.18 1999/08/17 09:13:13 millert Exp $";
d878 3
a880 1
	    NI_NUMERICHOST) != 0) {
@


1.18
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.17 1999/07/20 22:40:42 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.17 1999/07/20 22:40:42 deraadt Exp $";
d59 1
a59 1
void doit P((struct sockaddr_in *));
d181 1
a181 1
	struct sockaddr_in from;
d532 1
a532 1
	doit(&from);
d800 1
a800 1
	struct sockaddr_in *who;
d807 3
d852 18
a869 2
	hp = gethostbyaddr((char *)&who->sin_addr, sizeof (struct in_addr),
		who->sin_family);
d874 2
a875 3
	} else if (hp &&
	    (strlen(hp->h_name) <= (unsigned int)((utmp_len < 0) ? -utmp_len
								 : utmp_len))) {
d877 3
a879 2
	} else {
		host = inet_ntoa(who->sin_addr);
d881 1
@


1.17
log
@bad arguments? usage() should syslog()
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.16 1998/12/19 01:27:07 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.16 1998/12/19 01:27:07 deraadt Exp $";
d823 1
a823 1
		if ((pty = open(lp, 2)) >= 0) {
@


1.16
log
@less cryptic message on pty allocation failure
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.15 1998/07/28 20:18:22 marc Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.15 1998/07/28 20:18:22 marc Exp $";
d540 1
a540 1
	fprintf(stderr, "Usage: telnetd");
d542 1
a542 1
	fprintf(stderr, " [-a (debug|other|user|valid|off|none)]\n\t");
d545 1
a545 1
	fprintf(stderr, " [-B]");
d547 1
a547 1
	fprintf(stderr, " [-debug]");
d549 1
a549 1
	fprintf(stderr, " [-D (options|report|exercise|netdata|ptydata)]\n\t");
d552 1
a552 1
	fprintf(stderr, " [-edebug]");
d554 1
a554 1
	fprintf(stderr, " [-h]");
d556 1
a556 1
	fprintf(stderr, " [-Iinitid]");
d559 1
a559 1
	fprintf(stderr, " [-k]");
d562 1
a562 1
	fprintf(stderr, " [-l]");
d564 1
a564 1
	fprintf(stderr, " [-n]");
d566 1
a566 1
	fprintf(stderr, " [-r[lowpty]-[highpty]]");
a567 1
	fprintf(stderr, "\n\t");
d569 1
a569 1
	fprintf(stderr, " [-S tos]");
d572 1
a572 1
	fprintf(stderr, " [-X auth-type]");
d574 3
a576 3
	fprintf(stderr, " [-u utmp_hostname_length] [-U]");
	fprintf(stderr, " [port]\n");
	exit(1);
@


1.15
log
@change getent/getstr to gtgettent/gtgetstr, the names now used

in libtelnet; add prototypes for both functions to ext.h
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.14 1998/07/27 18:28:20 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.14 1998/07/27 18:28:20 millert Exp $";
d815 1
a815 1
		fatal(net, "All network ports in use");
@


1.14
log
@use old curses to avoid duplicate symbol in libtelnet
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.13 1998/07/23 17:55:54 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.13 1998/07/23 17:55:54 deraadt Exp $";
d1138 1
a1138 2
	if (getent(defent, gettyname) == 1) {
		char *getstr();
d1141 3
a1143 3
		HE = getstr("he", &cp);
		HN = getstr("hn", &cp);
		IM = getstr("im", &cp);
@


1.13
log
@delete SecurID hacks
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.12 1998/05/08 19:37:50 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.12 1998/05/08 19:37:50 deraadt Exp $";
d52 1
a52 1
#include <term.h>
@


1.12
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.11 1998/05/08 19:34:39 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.11 1998/05/08 19:34:39 deraadt Exp $";
a98 3
#if	defined(SecurID)
int	require_SecurID = 0;
#endif
a173 3
#ifdef	SecurID
	's',
#endif
a341 6
#ifdef	SecurID
		case 's':
			/* SecurID required */
			require_SecurID = 1;
			break;
#endif	/* SecurID */
a568 3
#ifdef	SecurID
	fprintf(stderr, " [-s]");
#endif
@


1.11
log
@tighter buf handling
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.10 1998/04/25 04:43:03 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.10 1998/04/25 04:43:03 millert Exp $";
d1161 1
a1161 1
			strcpy(host_name, HN, sizeof host_name - 1);
@


1.10
log
@Fix casts in args to mem*.  Boy am I anal.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.9 1998/03/25 18:43:49 art Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.9 1998/03/25 18:43:49 art Exp $";
d840 2
a841 1
			strcpy(line,lp);
d1160 4
a1163 2
		if (HN && *HN)
			(void) strcpy(host_name, HN);
@


1.9
log
@cleanup and please -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.8 1998/03/12 04:53:15 art Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.8 1998/03/12 04:53:15 art Exp $";
d470 1
a470 1
		memset((char *)&dv, 0, sizeof(dv));
d658 1
a658 1
	memmove(nfrontp, sb, sizeof sb);
d666 1
a666 1
	memmove(nfrontp, sb, sizeof sb);
d674 1
a674 1
	memmove(nfrontp, sb, sizeof sb);
d682 1
a682 1
	memmove(nfrontp, sb, sizeof sb);
d688 1
a688 1
	memmove(nfrontp, ttytype_sbbuf, sizeof ttytype_sbbuf);
d768 1
a768 1
    memmove(nfrontp, ttytype_sbbuf, sizeof ttytype_sbbuf);
@


1.8
log
@Encryption from kth-krb 0.9.8 (only for those with kerberos)
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.7 1997/07/14 01:40:39 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.7 1997/07/14 01:40:39 millert Exp $";
d95 4
d546 1
d818 1
a818 1
	char *host, *inet_ntoa();
@


1.7
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.6 1997/01/15 23:41:05 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.6 1997/01/15 23:41:05 millert Exp $";
d192 5
d202 3
a222 1
				extern int auth_debug_mode;
d620 4
d630 3
d640 9
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.5 1996/12/23 13:31:40 robin Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.5 1996/12/23 13:31:40 robin Exp $";
d52 1
d59 5
d179 1
d786 1
a790 1
	int t;
@


1.5
log
@Eliminate assignment/truth-value compiler warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.4 1996/08/27 10:25:28 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.4 1996/08/27 10:25:28 deraadt Exp $";
d199 1
a199 1
	while ((ch = getopt(argc, argv, valid_opts)) != EOF) {
@


1.4
log
@strncpy correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: telnetd.c,v 1.2 1996/03/28 23:22:03 niklas Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: telnetd.c,v 1.2 1996/03/28 23:22:03 niklas Exp $";
d386 1
a386 1
		    if (sp = getservbyname(*argv, "tcp")) {
@


1.3
log
@sync with netbsd 960418
@
text
@d685 2
a686 1
	    (void) strncpy(first, terminaltype, sizeof(first));
d691 2
a692 1
		(void) strncpy(last, terminaltype, sizeof(last));
d710 4
a713 2
		    if (strncmp(first, terminaltype, sizeof(first)) != 0)
			(void) strncpy(terminaltype, first, sizeof(first));
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: telnetd.c,v 1.5 1996/02/28 20:38:23 thorpej Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD$";
d137 1
d148 1
a148 1
	'd', ':', 'h', 'k', 'n', 'S', ':', 'u', ':', 'U',
d267 3
d1113 1
a1113 1
	if (getent(defent, "default") == 1) {
@


1.1
log
@Initial revision
@
text
@d1 3
d44 6
a49 2
/* from: static char sccsid[] = "@@(#)telnetd.c	8.1 (Berkeley) 6/4/93"; */
static char *rcsid = "$Id: telnetd.c,v 1.3 1994/02/25 03:20:59 cgd Exp $";
d55 3
d448 1
a448 1
		bzero((char *)&dv, sizeof(dv));
d619 1
a619 1
	bcopy(sb, nfrontp, sizeof sb);
d621 1
d627 1
a627 1
	bcopy(sb, nfrontp, sizeof sb);
d629 1
d635 1
a635 1
	bcopy(sb, nfrontp, sizeof sb);
d637 1
d643 1
a643 1
	bcopy(sb, nfrontp, sizeof sb);
d645 1
d649 1
a649 1
	bcopy(ttytype_sbbuf, nfrontp, sizeof ttytype_sbbuf);
d651 2
d725 1
a725 1
    bcopy(ttytype_sbbuf, nfrontp, sizeof ttytype_sbbuf);
d727 2
d806 1
a806 1
	 *	set ttyp line security label 
d826 1
a826 1
         Please contact your net administrator");
d828 2
a829 1
	    (strlen(hp->h_name) <= ((utmp_len < 0) ? -utmp_len : utmp_len))) {
d918 1
d1148 1
d1180 1
a1180 1
		if ((c = select(16, &ibits, &obits, &xbits,
d1319 3
d1338 3
d1399 1
a1399 1
	
d1475 1
a1475 1
			ixon = tp->c_iflag & IXON;      
d1506 8
d1521 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

