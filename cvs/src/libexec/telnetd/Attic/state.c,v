head	1.22;
access;
symbols
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2005.05.25.05.35.22;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2003.06.26.07.53.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.14.17.41.55;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.07.23.08.23;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.07.23.01.44;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.00.46.35;	author hin;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.02.14.16.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.19.44.32;	author hin;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.08.10.11.42;	author hin;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.08.09.06.32;	author hin;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.06.16.50.15;	author hin;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.15.07.13.47;	author deraadt;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	98.08.21.17.12.22;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.07.10.08.06.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.03.25.18.43.46;	author art;	state Exp;
branches;
next	1.6;

1.6
date	98.03.12.04.53.12;	author art;	state Exp;
branches;
next	1.5;

1.5
date	96.08.24.09.03.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.23.32.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.28.23.21.59;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.10.28.02.33.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.12.08.10.14.16;	author hin;	state Exp;
branches;
next	;


desc
@@


1.22
log
@bye bye
@
text
@/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnetd.h"
#include <syslog.h>

/* RCSID("$KTH: state.c,v 1.14 2000/10/02 05:06:02 assar Exp $"); */

unsigned char	doopt[] = { IAC, DO, '%', 'c', 0 };
unsigned char	dont[] = { IAC, DONT, '%', 'c', 0 };
unsigned char	will[] = { IAC, WILL, '%', 'c', 0 };
unsigned char	wont[] = { IAC, WONT, '%', 'c', 0 };
int	not42 = 1;

/*
 * Buffer for sub-options, and macros
 * for suboptions buffer manipulations
 */
unsigned char subbuffer[2048], *subpointer= subbuffer, *subend= subbuffer;

#define	SB_CLEAR()	subpointer = subbuffer
#define	SB_TERM()	{ subend = subpointer; SB_CLEAR(); }
#define	SB_ACCUM(c)	if (subpointer < (subbuffer+sizeof subbuffer)) { \
    *subpointer++ = (c); \
			     }
#define	SB_GET()	((*subpointer++)&0xff)
#define	SB_EOF()	(subpointer >= subend)
#define	SB_LEN()	(subend - subpointer)

#ifdef	ENV_HACK
unsigned char *subsave;
#define SB_SAVE()	subsave = subpointer;
#define	SB_RESTORE()	subpointer = subsave;
#endif


/*
 * State for recv fsm
 */
#define	TS_DATA		0	/* base state */
#define	TS_IAC		1	/* look for double IAC's */
#define	TS_CR		2	/* CR-LF ->'s CR */
#define	TS_SB		3	/* throw away begin's... */
#define	TS_SE		4	/* ...end's (suboption negotiation) */
#define	TS_WILL		5	/* will option negotiation */
#define	TS_WONT		6	/* wont -''- */
#define	TS_DO		7	/* do -''- */
#define	TS_DONT		8	/* dont -''- */

void
telrcv(void)
{
    int c;
    static int state = TS_DATA;

    while (ncc > 0) {
	if ((&ptyobuf[BUFSIZ] - pfrontp) < 2)
	    break;
	c = *netip++ & 0377, ncc--;
#ifdef ENCRYPTION
	if (decrypt_input)
	    c = (*decrypt_input)(c);
#endif
	switch (state) {

	case TS_CR:
	    state = TS_DATA;
	    /* Strip off \n or \0 after a \r */
	    if ((c == 0) || (c == '\n')) {
		break;
	    }
	    /* FALL THROUGH */

	case TS_DATA:
	    if (c == IAC) {
		state = TS_IAC;
		break;
	    }
	    /*
	     * We now map \r\n ==> \r for pragmatic reasons.
	     * Many client implementations send \r\n when
	     * the user hits the CarriageReturn key.
	     *
	     * We USED to map \r\n ==> \n, since \r\n says
	     * that we want to be in column 1 of the next
	     * printable line, and \n is the standard
	     * unix way of saying that (\r is only good
	     * if CRMOD is set, which it normally is).
	     */
	    if ((c == '\r') && his_state_is_wont(TELOPT_BINARY)) {
#ifdef ENCRYPTION
		int nc = *netip;

		if (decrypt_input)
		    nc = (*decrypt_input)(nc & 0xff);
#endif
		{
#ifdef ENCRYPTION
		    if (decrypt_input)
			(void)(*decrypt_input)(-1);
#endif
		    state = TS_CR;
		}
	    }
	    *pfrontp++ = c;
	    break;

	case TS_IAC:
	gotiac:			switch (c) {

	    /*
	     * Send the process on the pty side an
	     * interrupt.  Do this with a NULL or
	     * interrupt char; depending on the tty mode.
	     */
	case IP:
	    DIAG(TD_OPTIONS,
		 printoption("td: recv IAC", c));
	    interrupt();
	    break;

	case BREAK:
	    DIAG(TD_OPTIONS,
		 printoption("td: recv IAC", c));
	    sendbrk();
	    break;

	    /*
	     * Are You There?
	     */
	case AYT:
	    DIAG(TD_OPTIONS,
		 printoption("td: recv IAC", c));
	    recv_ayt();
	    break;

	    /*
	     * Abort Output
	     */
	case AO:
	    {
		DIAG(TD_OPTIONS,
		     printoption("td: recv IAC", c));
		ptyflush();	/* half-hearted */
		init_termbuf();

		if (slctab[SLC_AO].sptr &&
		    *slctab[SLC_AO].sptr != (cc_t)(_POSIX_VDISABLE)) {
		    *pfrontp++ =
			(unsigned char)*slctab[SLC_AO].sptr;
		}

		netclear();	/* clear buffer back */
		output_data ("%c%c", IAC, DM);
		neturg = nfrontp-1; /* off by one XXX */
		DIAG(TD_OPTIONS,
		     printoption("td: send IAC", DM));
		break;
	    }

	/*
	 * Erase Character and
	 * Erase Line
	 */
	case EC:
	case EL:
	    {
		cc_t ch;

		DIAG(TD_OPTIONS,
		     printoption("td: recv IAC", c));
		ptyflush();	/* half-hearted */
		init_termbuf();
		if (c == EC)
		    ch = *slctab[SLC_EC].sptr;
		else
		    ch = *slctab[SLC_EL].sptr;
		if (ch != (cc_t)(_POSIX_VDISABLE))
		    *pfrontp++ = (unsigned char)ch;
		break;
	    }

	/*
	 * Check for urgent data...
	 */
	case DM:
	    DIAG(TD_OPTIONS,
		 printoption("td: recv IAC", c));
	    SYNCHing = stilloob(net);
	    settimer(gotDM);
	    break;


	    /*
	     * Begin option subnegotiation...
	     */
	case SB:
	    state = TS_SB;
	    SB_CLEAR();
	    continue;

	case WILL:
	    state = TS_WILL;
	    continue;

	case WONT:
	    state = TS_WONT;
	    continue;

	case DO:
	    state = TS_DO;
	    continue;

	case DONT:
	    state = TS_DONT;
	    continue;
	case EOR:
	    if (his_state_is_will(TELOPT_EOR))
		doeof();
	    break;

	    /*
	     * Handle RFC 10xx Telnet linemode option additions
	     * to command stream (EOF, SUSP, ABORT).
	     */
	case xEOF:
	    doeof();
	    break;

	case SUSP:
	    sendsusp();
	    break;

	case ABORT:
	    sendbrk();
	    break;

	case IAC:
	    *pfrontp++ = c;
	    break;
	}
	state = TS_DATA;
	break;

	case TS_SB:
	    if (c == IAC) {
		state = TS_SE;
	    } else {
		SB_ACCUM(c);
	    }
	    break;

	case TS_SE:
	    if (c != SE) {
		if (c != IAC) {
		    /*
		     * bad form of suboption negotiation.
		     * handle it in such a way as to avoid
		     * damage to local state.  Parse
		     * suboption buffer found so far,
		     * then treat remaining stream as
		     * another command sequence.
		     */

		    /* for DIAGNOSTICS */
		    SB_ACCUM(IAC);
		    SB_ACCUM(c);
		    subpointer -= 2;

		    SB_TERM();
		    suboption();
		    state = TS_IAC;
		    goto gotiac;
		}
		SB_ACCUM(c);
		state = TS_SB;
	    } else {
		/* for DIAGNOSTICS */
		SB_ACCUM(IAC);
		SB_ACCUM(SE);
		subpointer -= 2;

		SB_TERM();
		suboption();	/* handle sub-option */
		state = TS_DATA;
	    }
	    break;

	case TS_WILL:
	    willoption(c);
	    state = TS_DATA;
	    continue;

	case TS_WONT:
	    wontoption(c);
	    if (c==TELOPT_ENCRYPT && his_do_dont_is_changing(TELOPT_ENCRYPT) )
                dontoption(c);
	    state = TS_DATA;
	    continue;

	case TS_DO:
	    dooption(c);
	    state = TS_DATA;
	    continue;

	case TS_DONT:
	    dontoption(c);
	    state = TS_DATA;
	    continue;

	default:
	    syslog(LOG_ERR, "telnetd: panic state=%d", state);
	    printf("telnetd: panic state=%d\n", state);
	    exit(1);
	}
    }
}  /* end of telrcv */

/*
 * The will/wont/do/dont state machines are based on Dave Borman's
 * Telnet option processing state machine.
 *
 * These correspond to the following states:
 *	my_state = the last negotiated state
 *	want_state = what I want the state to go to
 *	want_resp = how many requests I have sent
 * All state defaults are negative, and resp defaults to 0.
 *
 * When initiating a request to change state to new_state:
 *
 * if ((want_resp == 0 && new_state == my_state) || want_state == new_state) {
 *	do nothing;
 * } else {
 *	want_state = new_state;
 *	send new_state;
 *	want_resp++;
 * }
 *
 * When receiving new_state:
 *
 * if (want_resp) {
 *	want_resp--;
 *	if (want_resp && (new_state == my_state))
 *		want_resp--;
 * }
 * if ((want_resp == 0) && (new_state != want_state)) {
 *	if (ok_to_switch_to new_state)
 *		want_state = new_state;
 *	else
 *		want_resp++;
 *	send want_state;
 * }
 * my_state = new_state;
 *
 * Note that new_state is implied in these functions by the function itself.
 * will and do imply positive new_state, wont and dont imply negative.
 *
 * Finally, there is one catch.  If we send a negative response to a
 * positive request, my_state will be the positive while want_state will
 * remain negative.  my_state will revert to negative when the negative
 * acknowlegment arrives from the peer.  Thus, my_state generally tells
 * us not only the last negotiated state, but also tells us what the peer
 * wants to be doing as well.  It is important to understand this difference
 * as we may wish to be processing data streams based on our desired state
 * (want_state) or based on what the peer thinks the state is (my_state).
 *
 * This all works fine because if the peer sends a positive request, the data
 * that we receive prior to negative acknowlegment will probably be affected
 * by the positive state, and we can process it as such (if we can; if we
 * can't then it really doesn't matter).  If it is that important, then the
 * peer probably should be buffering until this option state negotiation
 * is complete.
 *
 */
void
send_do(int option, int init)
{
    if (init) {
	if ((do_dont_resp[option] == 0 && his_state_is_will(option)) ||
	    his_want_state_is_will(option))
	    return;
	/*
	 * Special case for TELOPT_TM:  We send a DO, but pretend
	 * that we sent a DONT, so that we can send more DOs if
	 * we want to.
	 */
	if (option == TELOPT_TM)
	    set_his_want_state_wont(option);
	else
	    set_his_want_state_will(option);
	do_dont_resp[option]++;
    }
    output_data((const char *)doopt, option);

    DIAG(TD_OPTIONS, printoption("td: send do", option));
}

#ifdef	AUTHENTICATION
extern void auth_request(void);
#endif
#ifdef	ENCRYPTION
extern void encrypt_send_support(void);
#endif

void
willoption(int option)
{
    int changeok = 0;
    void (*func)(void) = 0;

    /*
     * process input from peer.
     */

    DIAG(TD_OPTIONS, printoption("td: recv will", option));

    if (do_dont_resp[option]) {
	do_dont_resp[option]--;
	if (do_dont_resp[option] && his_state_is_will(option))
	    do_dont_resp[option]--;
    }
    if (do_dont_resp[option] == 0) {
	if (his_want_state_is_wont(option)) {
	    switch (option) {

	    case TELOPT_BINARY:
		init_termbuf();
		tty_binaryin(1);
		set_termbuf();
		changeok++;
		break;

	    case TELOPT_ECHO:
		/*
		 * See comments below for more info.
		 */
		not42 = 0;	/* looks like a 4.2 system */
		break;

	    case TELOPT_TM:
		/*
		 * We never respond to a WILL TM, and
		 * we leave the state WONT.
		 */
		return;

	    case TELOPT_LFLOW:
		/*
		 * If we are going to support flow control
		 * option, then don't worry peer that we can't
		 * change the flow control characters.
		 */
		slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;
		slctab[SLC_XON].defset.flag |= SLC_DEFAULT;
		slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;
		slctab[SLC_XOFF].defset.flag |= SLC_DEFAULT;
	    case TELOPT_TTYPE:
	    case TELOPT_SGA:
	    case TELOPT_NAWS:
	    case TELOPT_TSPEED:
	    case TELOPT_XDISPLOC:
	    case TELOPT_NEW_ENVIRON:
	    case TELOPT_OLD_ENVIRON:
		changeok++;
		break;


#ifdef	AUTHENTICATION
	    case TELOPT_AUTHENTICATION:
		func = auth_request;
		changeok++;
		break;
#endif

#ifdef	ENCRYPTION
	    case TELOPT_ENCRYPT:
		func = encrypt_send_support;
		changeok++;
		break;
#endif
			
	    default:
		break;
	    }
	    if (changeok) {
		set_his_want_state_will(option);
		send_do(option, 0);
	    } else {
		do_dont_resp[option]++;
		send_dont(option, 0);
	    }
	} else {
	    /*
	     * Option processing that should happen when
	     * we receive conformation of a change in
	     * state that we had requested.
	     */
	    switch (option) {
	    case TELOPT_ECHO:
		not42 = 0;	/* looks like a 4.2 system */
		/*
		 * Egads, he responded "WILL ECHO".  Turn
		 * it off right now!
		 */
		send_dont(option, 1);
		/*
		 * "WILL ECHO".  Kludge upon kludge!
		 * A 4.2 client is now echoing user input at
		 * the tty.  This is probably undesireable and
		 * it should be stopped.  The client will
		 * respond WONT TM to the DO TM that we send to
		 * check for kludge linemode.  When the WONT TM
		 * arrives, linemode will be turned off and a
		 * change propogated to the pty.  This change
		 * will cause us to process the new pty state
		 * in localstat(), which will notice that
		 * linemode is off and send a WILL ECHO
		 * so that we are properly in character mode and
		 * all is well.
		 */
		break;

#ifdef	AUTHENTICATION
	    case TELOPT_AUTHENTICATION:
		func = auth_request;
		break;
#endif

#ifdef	ENCRYPTION
	    case TELOPT_ENCRYPT:
		func = encrypt_send_support;
		break;
#endif

	    case TELOPT_LFLOW:
		func = flowstat;
		break;
	    }
	}
    }
    set_his_state_will(option);
    if (func)
	(*func)();
}  /* end of willoption */

void
send_dont(int option, int init)
{
    if (init) {
	if ((do_dont_resp[option] == 0 && his_state_is_wont(option)) ||
	    his_want_state_is_wont(option))
	    return;
	set_his_want_state_wont(option);
	do_dont_resp[option]++;
    }
    output_data((const char *)dont, option);

    DIAG(TD_OPTIONS, printoption("td: send dont", option));
}

void
wontoption(int option)
{
    /*
     * Process client input.
	 */

    DIAG(TD_OPTIONS, printoption("td: recv wont", option));

    if (do_dont_resp[option]) {
	do_dont_resp[option]--;
	if (do_dont_resp[option] && his_state_is_wont(option))
	    do_dont_resp[option]--;
    }
    if (do_dont_resp[option] == 0) {
	if (his_want_state_is_will(option)) {
	    /* it is always ok to change to negative state */
	    switch (option) {
	    case TELOPT_ECHO:
		not42 = 1; /* doesn't seem to be a 4.2 system */
		break;

	    case TELOPT_BINARY:
		init_termbuf();
		tty_binaryin(0);
		set_termbuf();
		break;

	    case TELOPT_TM:
		/*
		 * If we get a WONT TM, and had sent a DO TM,
		 * don't respond with a DONT TM, just leave it
		 * as is.  Short circut the state machine to
		 * achive this.
		 */
		set_his_want_state_wont(TELOPT_TM);
		return;

	    case TELOPT_LFLOW:
		/*
		 * If we are not going to support flow control
		 * option, then let peer know that we can't
		 * change the flow control characters.
		 */
		slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;
		slctab[SLC_XON].defset.flag |= SLC_CANTCHANGE;
		slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;
		slctab[SLC_XOFF].defset.flag |= SLC_CANTCHANGE;
		break;

#ifdef AUTHENTICATION
	    case TELOPT_AUTHENTICATION:
		auth_finished(0, AUTH_REJECT);
		break;
#endif

		/*
		 * For options that we might spin waiting for
		 * sub-negotiation, if the client turns off the
		 * option rather than responding to the request,
		 * we have to treat it here as if we got a response
		 * to the sub-negotiation, (by updating the timers)
		 * so that we'll break out of the loop.
		 */
	    case TELOPT_TTYPE:
		settimer(ttypesubopt);
		break;

	    case TELOPT_TSPEED:
		settimer(tspeedsubopt);
		break;

	    case TELOPT_XDISPLOC:
		settimer(xdisplocsubopt);
		break;

	    case TELOPT_OLD_ENVIRON:
		settimer(oenvironsubopt);
		break;

	    case TELOPT_NEW_ENVIRON:
		settimer(environsubopt);
		break;

	    default:
		break;
	    }
	    set_his_want_state_wont(option);
	    if (his_state_is_will(option))
		send_dont(option, 0);
	} else {
	    switch (option) {
	    case TELOPT_TM:
		break;

#ifdef AUTHENTICATION
	    case TELOPT_AUTHENTICATION:
		auth_finished(0, AUTH_REJECT);
		break;
#endif
	    default:
		break;
	    }
	}
    }
    set_his_state_wont(option);

}  /* end of wontoption */

void
send_will(int option, int init)
{
    if (init) {
	if ((will_wont_resp[option] == 0 && my_state_is_will(option))||
	    my_want_state_is_will(option))
	    return;
	set_my_want_state_will(option);
	will_wont_resp[option]++;
    }
    output_data ((const char *)will, option);

    DIAG(TD_OPTIONS, printoption("td: send will", option));
}

/*
 * When we get a DONT SGA, we will try once to turn it
 * back on.  If the other side responds DONT SGA, we
 * leave it at that.  This is so that when we talk to
 * clients that understand KLUDGELINEMODE but not LINEMODE,
 * we'll keep them in char-at-a-time mode.
 */
int turn_on_sga = 0;

void
dooption(int option)
{
    int changeok = 0;

    /*
     * Process client input.
     */

    DIAG(TD_OPTIONS, printoption("td: recv do", option));

    if (will_wont_resp[option]) {
	will_wont_resp[option]--;
	if (will_wont_resp[option] && my_state_is_will(option))
	    will_wont_resp[option]--;
    }
    if ((will_wont_resp[option] == 0) && (my_want_state_is_wont(option))) {
	switch (option) {
	case TELOPT_ECHO:
	    {
		init_termbuf();
		tty_setecho(1);
		set_termbuf();
	    }
	changeok++;
	break;

	case TELOPT_BINARY:
	    init_termbuf();
	    tty_binaryout(1);
	    set_termbuf();
	    changeok++;
	    break;

	case TELOPT_SGA:
	    turn_on_sga = 0;
	    changeok++;
	    break;

	case TELOPT_STATUS:
	    changeok++;
	    break;

	case TELOPT_TM:
	    /*
	     * Special case for TM.  We send a WILL, but
	     * pretend we sent a WONT.
	     */
	    send_will(option, 0);
	    set_my_want_state_wont(option);
	    set_my_state_wont(option);
	    return;

	case TELOPT_LOGOUT:
	    /*
	     * When we get a LOGOUT option, respond
	     * with a WILL LOGOUT, make sure that
	     * it gets written out to the network,
	     * and then just go away...
	     */
	    set_my_want_state_will(TELOPT_LOGOUT);
	    send_will(TELOPT_LOGOUT, 0);
	    set_my_state_will(TELOPT_LOGOUT);
	    netflush();
	    cleanup(0);
	    /* NOT REACHED */
	    break;

#ifdef ENCRYPTION
	case TELOPT_ENCRYPT:
	    changeok++;
	    break;
#endif
	case TELOPT_LINEMODE:
	case TELOPT_TTYPE:
	case TELOPT_NAWS:
	case TELOPT_TSPEED:
	case TELOPT_LFLOW:
	case TELOPT_XDISPLOC:
#ifdef	TELOPT_ENVIRON
	case TELOPT_NEW_ENVIRON:
#endif
	case TELOPT_OLD_ENVIRON:
	default:
	    break;
	}
	if (changeok) {
	    set_my_want_state_will(option);
	    send_will(option, 0);
	} else {
	    will_wont_resp[option]++;
	    send_wont(option, 0);
	}
    }
    set_my_state_will(option);

}  /* end of dooption */

void
send_wont(int option, int init)
{
    if (init) {
	if ((will_wont_resp[option] == 0 && my_state_is_wont(option)) ||
	    my_want_state_is_wont(option))
	    return;
	set_my_want_state_wont(option);
	will_wont_resp[option]++;
    }
    output_data ((const char *)wont, option);

    DIAG(TD_OPTIONS, printoption("td: send wont", option));
}

void
dontoption(int option)
{
    /*
     * Process client input.
	 */


    DIAG(TD_OPTIONS, printoption("td: recv dont", option));

    if (will_wont_resp[option]) {
	will_wont_resp[option]--;
	if (will_wont_resp[option] && my_state_is_wont(option))
	    will_wont_resp[option]--;
    }
    if ((will_wont_resp[option] == 0) && (my_want_state_is_will(option))) {
	switch (option) {
	case TELOPT_BINARY:
	    init_termbuf();
	    tty_binaryout(0);
	    set_termbuf();
	    break;

	case TELOPT_ECHO:	/* we should stop echoing */
	    {
		init_termbuf();
		tty_setecho(0);
		set_termbuf();
	    }
	break;

	case TELOPT_SGA:
	    set_my_want_state_wont(option);
	    if (my_state_is_will(option))
		send_wont(option, 0);
	    set_my_state_wont(option);
	    if (turn_on_sga ^= 1)
		send_will(option, 1);
	    return;

	default:
	    break;
	}

	set_my_want_state_wont(option);
	if (my_state_is_will(option))
	    send_wont(option, 0);
    }
    set_my_state_wont(option);

}  /* end of dontoption */

#ifdef	ENV_HACK
int env_ovar = -1;
int env_ovalue = -1;
#else	/* ENV_HACK */
# define env_ovar OLD_ENV_VAR
# define env_ovalue OLD_ENV_VALUE
#endif	/* ENV_HACK */

/*
 * variables not to let through.
 * if name ends in =, it is complete variable name
 * if it does not end in =, all variables starting with this name
 * should be dropped.
 */
char *badenv_table[] = {
        "IFS=",
        "LD_",
        "_RLD_",
        "SHLIB_PATH=",
        "LIBPATH=",
        "KRB",
        "ENV=",
        "BASH_ENV=",
        NULL,
};

static int envvarok(char *);

/* envvarok(char*) */
/* check that variable is safe to pass to login or shell */
static int
envvarok(varp)
        char *varp;
{
        int i;
        int len;

        if (strchr(varp, '='))
                return (0);
        for (i = 0; badenv_table[i]; i++) {
                len = strlen(badenv_table[i]);
                if (badenv_table[i][len-1] == '=' &&
                    !strncmp(badenv_table[i], varp, len-1) &&
                    varp[len-2] == '\0')
                        return (0);
                if (!strncmp(badenv_table[i], varp, len-1))
                        return (0);
        }
        return (1);
}

/*
 * suboption()
 *
 *	Look at the sub-option buffer, and try to be helpful to the other
 * side.
 *
 *	Currently we recognize:
 *
 *	Terminal type is
 *	Linemode
 *	Window size
 *	Terminal speed
 */
void
suboption(void)
{
    int subchar;

    DIAG(TD_OPTIONS, {netflush(); printsub('<', subpointer, SB_LEN()+2);});

    subchar = SB_GET();
    switch (subchar) {
    case TELOPT_TSPEED: {
	int xspeed, rspeed;

	if (his_state_is_wont(TELOPT_TSPEED))	/* Ignore if option disabled */
	    break;

	settimer(tspeedsubopt);

	if (SB_EOF() || SB_GET() != TELQUAL_IS)
	    return;

	xspeed = atoi((char *)subpointer);

	while (SB_GET() != ',' && !SB_EOF());
	if (SB_EOF())
	    return;

	rspeed = atoi((char *)subpointer);
	clientstat(TELOPT_TSPEED, xspeed, rspeed);

	break;

    }  /* end of case TELOPT_TSPEED */

    case TELOPT_TTYPE: {		/* Yaaaay! */
	char *tt;

	if (his_state_is_wont(TELOPT_TTYPE))	/* Ignore if option disabled */
	    break;
	settimer(ttypesubopt);

	if (SB_EOF() || SB_GET() != TELQUAL_IS) {
	    return;		/* ??? XXX but, this is the most robust */
	}

	tt = terminaltype;

	while ((tt < (terminaltype + sizeof terminaltype-1)) &&
	       !SB_EOF()) {
	    int c;

	    c = SB_GET();
	    if (isupper(c)) {
		c = tolower(c);
	    }
	    *tt++ = c;    /* accumulate name */
	}
	*tt = 0;
	break;
    }  /* end of case TELOPT_TTYPE */

    case TELOPT_NAWS: {
	int xwinsize, ywinsize;

	if (his_state_is_wont(TELOPT_NAWS))	/* Ignore if option disabled */
	    break;

	if (SB_EOF())
	    return;
	xwinsize = SB_GET() << 8;
	if (SB_EOF())
	    return;
	xwinsize |= SB_GET();
	if (SB_EOF())
	    return;
	ywinsize = SB_GET() << 8;
	if (SB_EOF())
	    return;
	ywinsize |= SB_GET();
	clientstat(TELOPT_NAWS, xwinsize, ywinsize);

	break;

    }  /* end of case TELOPT_NAWS */

    case TELOPT_STATUS: {
	int mode;

	if (SB_EOF())
	    break;
	mode = SB_GET();
	switch (mode) {
	case TELQUAL_SEND:
	    if (my_state_is_will(TELOPT_STATUS))
		send_status();
	    break;

	case TELQUAL_IS:
	    break;

	default:
	    break;
	}
	break;
    }  /* end of case TELOPT_STATUS */

    case TELOPT_XDISPLOC: {
	if (SB_EOF() || SB_GET() != TELQUAL_IS)
	    return;
	settimer(xdisplocsubopt);
	subpointer[SB_LEN()] = '\0';
	esetenv("DISPLAY", (char *)subpointer, 1);
	break;
    }  /* end of case TELOPT_XDISPLOC */

#ifdef	TELOPT_NEW_ENVIRON
    case TELOPT_NEW_ENVIRON:
#endif
    case TELOPT_OLD_ENVIRON: {
	int c;
	char *cp, *varp, *valp;

	if (SB_EOF())
	    return;
	c = SB_GET();
	if (c == TELQUAL_IS) {
	    if (subchar == TELOPT_OLD_ENVIRON)
		settimer(oenvironsubopt);
	    else
		settimer(environsubopt);
	} else if (c != TELQUAL_INFO) {
	    return;
	}

#ifdef	TELOPT_NEW_ENVIRON
	if (subchar == TELOPT_NEW_ENVIRON) {
	    while (!SB_EOF()) {
		c = SB_GET();
		if ((c == NEW_ENV_VAR) || (c == ENV_USERVAR))
		    break;
	    }
	} else
#endif
	    {
#ifdef	ENV_HACK
		/*
		 * We only want to do this if we haven't already decided
		 * whether or not the other side has its VALUE and VAR
		 * reversed.
		 */
		if (env_ovar < 0) {
		    int last = -1;		/* invalid value */
		    int empty = 0;
		    int got_var = 0, got_value = 0, got_uservar = 0;

		    /*
		     * The other side might have its VALUE and VAR values
		     * reversed.  To be interoperable, we need to determine
		     * which way it is.  If the first recognized character
		     * is a VAR or VALUE, then that will tell us what
		     * type of client it is.  If the fist recognized
		     * character is a USERVAR, then we continue scanning
		     * the suboption looking for two consecutive
		     * VAR or VALUE fields.  We should not get two
		     * consecutive VALUE fields, so finding two
		     * consecutive VALUE or VAR fields will tell us
		     * what the client is.
		     */
		    SB_SAVE();
		    while (!SB_EOF()) {
			c = SB_GET();
			switch(c) {
			case OLD_ENV_VAR:
			    if (last < 0 || last == OLD_ENV_VAR
				|| (empty && (last == OLD_ENV_VALUE)))
				goto env_ovar_ok;
			    got_var++;
			    last = OLD_ENV_VAR;
			    break;
			case OLD_ENV_VALUE:
			    if (last < 0 || last == OLD_ENV_VALUE
				|| (empty && (last == OLD_ENV_VAR)))
				goto env_ovar_wrong;
			    got_value++;
			    last = OLD_ENV_VALUE;
			    break;
			case ENV_USERVAR:
			    /* count strings of USERVAR as one */
			    if (last != ENV_USERVAR)
				got_uservar++;
			    if (empty) {
				if (last == OLD_ENV_VALUE)
				    goto env_ovar_ok;
				if (last == OLD_ENV_VAR)
				    goto env_ovar_wrong;
			    }
			    last = ENV_USERVAR;
			    break;
			case ENV_ESC:
			    if (!SB_EOF())
				c = SB_GET();
			    /* FALL THROUGH */
			default:
			    empty = 0;
			    continue;
			}
			empty = 1;
		    }
		    if (empty) {
			if (last == OLD_ENV_VALUE)
			    goto env_ovar_ok;
			if (last == OLD_ENV_VAR)
			    goto env_ovar_wrong;
		    }
		    /*
		     * Ok, the first thing was a USERVAR, and there
		     * are not two consecutive VAR or VALUE commands,
		     * and none of the VAR or VALUE commands are empty.
		     * If the client has sent us a well-formed option,
		     * then the number of VALUEs received should always
		     * be less than or equal to the number of VARs and
		     * USERVARs received.
		     *
		     * If we got exactly as many VALUEs as VARs and
		     * USERVARs, the client has the same definitions.
		     *
		     * If we got exactly as many VARs as VALUEs and
		     * USERVARS, the client has reversed definitions.
		     */
		    if (got_uservar + got_var == got_value) {
		    env_ovar_ok:
			env_ovar = OLD_ENV_VAR;
			env_ovalue = OLD_ENV_VALUE;
		    } else if (got_uservar + got_value == got_var) {
		    env_ovar_wrong:
			env_ovar = OLD_ENV_VALUE;
			env_ovalue = OLD_ENV_VAR;
			DIAG(TD_OPTIONS, {
			    output_data("ENVIRON VALUE and VAR are reversed!\r\n");
			});

		    }
		}
		SB_RESTORE();
#endif

		while (!SB_EOF()) {
		    c = SB_GET();
		    if ((c == env_ovar) || (c == ENV_USERVAR))
			break;
		}
	    }

	if (SB_EOF())
	    return;

	cp = varp = (char *)subpointer;
	valp = 0;

	while (!SB_EOF()) {
	    c = SB_GET();
	    if (subchar == TELOPT_OLD_ENVIRON) {
		if (c == env_ovar)
		    c = NEW_ENV_VAR;
		else if (c == env_ovalue)
		    c = NEW_ENV_VALUE;
	    }
	    switch (c) {

	    case NEW_ENV_VALUE:
		*cp = '\0';
		cp = valp = (char *)subpointer;
		break;

	    case NEW_ENV_VAR:
	    case ENV_USERVAR:
		*cp = '\0';
		if(envvarok(varp)) {
		    if (valp)
			esetenv(varp, valp, 1);
		    else
			unsetenv(varp);
		}
		cp = varp = (char *)subpointer;
		valp = 0;
		break;

	    case ENV_ESC:
		if (SB_EOF())
		    break;
		c = SB_GET();
		/* FALL THROUGH */
	    default:
		*cp++ = c;
		break;
	    }
	}
	*cp = '\0';
	if(envvarok(varp)) {
	    if (valp)
		esetenv(varp, valp, 1);
	    else
		unsetenv(varp);
	}
	break;
    }  /* end of case TELOPT_NEW_ENVIRON */
#ifdef AUTHENTICATION
    case TELOPT_AUTHENTICATION:
	if (SB_EOF())
	    break;
	switch(SB_GET()) {
	case TELQUAL_SEND:
	case TELQUAL_REPLY:
	    /*
	     * These are sent by us and cannot be sent by
	     * the client.
	     */
	    break;
	case TELQUAL_IS:
	    auth_is(subpointer, SB_LEN());
	    break;
	case TELQUAL_NAME:
	    auth_name(subpointer, SB_LEN());
	    break;
	}
	break;
#endif
#ifdef ENCRYPTION
    case TELOPT_ENCRYPT:
	if (SB_EOF())
	    break;
	switch(SB_GET()) {
	case ENCRYPT_SUPPORT:
	    encrypt_support(subpointer, SB_LEN());
	    break;
	case ENCRYPT_IS:
	    encrypt_is(subpointer, SB_LEN());
	    break;
	case ENCRYPT_REPLY:
	    encrypt_reply(subpointer, SB_LEN());
	    break;
	case ENCRYPT_START:
	    encrypt_start(subpointer, SB_LEN());
	    break;
	case ENCRYPT_END:
	    encrypt_end();
	    break;
	case ENCRYPT_REQSTART:
	    encrypt_request_start(subpointer, SB_LEN());
	    break;
	case ENCRYPT_REQEND:
	    /*
	     * We can always send an REQEND so that we cannot
	     * get stuck encrypting.  We should only get this
	     * if we have been able to get in the correct mode
	     * anyhow.
	     */
	    encrypt_request_end();
	    break;
	case ENCRYPT_ENC_KEYID:
	    encrypt_enc_keyid(subpointer, SB_LEN());
	    break;
	case ENCRYPT_DEC_KEYID:
	    encrypt_dec_keyid(subpointer, SB_LEN());
	    break;
	default:
	    break;
	}
	break;
#endif

    default:
	break;
    }  /* end of switch */

}  /* end of suboption */

void
doclientstat(void)
{
    clientstat(TELOPT_LINEMODE, WILL, 0);
}

#define	ADD(c)	 *ncp++ = c
#define	ADD_DATA(c) { *ncp++ = c; if (c == SE || c == IAC) *ncp++ = c; }

void
send_status(void)
{
    unsigned char statusbuf[256];
    unsigned char *ncp;
    unsigned char i;

    ncp = statusbuf;

    netflush();	/* get rid of anything waiting to go out */

    ADD(IAC);
    ADD(SB);
    ADD(TELOPT_STATUS);
    ADD(TELQUAL_IS);

    /*
     * We check the want_state rather than the current state,
     * because if we received a DO/WILL for an option that we
     * don't support, and the other side didn't send a DONT/WONT
     * in response to our WONT/DONT, then the "state" will be
     * WILL/DO, and the "want_state" will be WONT/DONT.  We
     * need to go by the latter.
     */
    for (i = 0; i < (unsigned char)NTELOPTS; i++) {
	if (my_want_state_is_will(i)) {
	    ADD(WILL);
	    ADD_DATA(i);
	}
	if (his_want_state_is_will(i)) {
	    ADD(DO);
	    ADD_DATA(i);
	}
    }

    if (his_want_state_is_will(TELOPT_LFLOW)) {
	ADD(SB);
	ADD(TELOPT_LFLOW);
	if (flowmode) {
	    ADD(LFLOW_ON);
	} else {
	    ADD(LFLOW_OFF);
	}
	ADD(SE);

	if (restartany >= 0) {
	    ADD(SB);
	    ADD(TELOPT_LFLOW);
	    if (restartany) {
		ADD(LFLOW_RESTART_ANY);
	    } else {
		ADD(LFLOW_RESTART_XON);
	    }
	    ADD(SE);
	}
    }


    ADD(IAC);
    ADD(SE);

    writenet(statusbuf, ncp - statusbuf);
    netflush();	/* Send it on its way */

    DIAG(TD_OPTIONS,
	 {printsub('>', statusbuf, ncp - statusbuf); netflush();});
}
@


1.21
log
@simple protos
@
text
@@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d428 1
a428 1
extern void encrypt_send_support();
d435 1
a435 1
    void (*func)() = 0;
d910 2
@


1.19
log
@Change terminalname from a pointer to an array.  Why people hide
the actual storage array as a static inside a function is beyond
me.  By exposing the real array we can use sizeof on it for strlcpy.
deraadt@@ OK
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Backout unrelated changes in last commit
@
text
@d985 1
a985 1
	static char terminalname[41];
d995 1
a995 1
	terminaltype = terminalname;
d997 1
a997 1
	while ((terminaltype < (terminalname + sizeof terminalname-1)) &&
d1005 1
a1005 1
	    *terminaltype++ = c;    /* accumulate name */
d1007 1
a1007 2
	*terminaltype = 0;
	terminaltype = terminalname;
@


1.17
log
@Kill '-a otp' flag.  Our login(5) doesn't support this option and on OpenBSD
you should use login.conf(5) for this kind of thing.  Closes PR 2967.
@
text
@d898 4
a901 2
 * Environment variables that are safe to let through.
 * Anything else will simply be dropped.
d903 10
a912 7
char *goodenv_table[] = {
	"TERM",
	"DISPLAY",
	"USER",
	"LOGNAME",
	"POSIXLY_CORRECT",
	NULL
d915 1
d917 2
a918 2
int
envvarok(varp, valp)
a919 1
        char *valp;
d922 1
d926 10
a935 10

	for (i = 0; goodenv_table[i]; i++) {
		if (strcmp(goodenv_table[i], varp) != 0)
			continue;
		/* disallow variables with slashes or ones that are too long */
		if (strchr(valp, '/') || strlen(valp) >= 0x100)
			return (0);
		return (1);
	}
	return (0);
d1228 1
a1228 1
		if (envvarok(varp, valp)) {
d1249 1
a1249 1
	if (envvarok(varp, valp)) {
@


1.16
log
@no more \n to syslog()
@
text
@d898 2
a899 4
 * variables not to let through.
 * if name ends in =, it is complete variable name
 * if it does not end in =, all variables starting with this name
 * should be dropped.
d901 7
a907 10
char *badenv_table[] = {
        "IFS=",
        "LD_",
        "_RLD_",
        "SHLIB_PATH=",
        "LIBPATH=",
        "KRB",
        "ENV=",
        "BASH_ENV=",
        NULL,
a909 1
/* envvarok(char*) */
d911 2
a912 2
static int
envvarok(varp)
d914 1
a916 1
        int len;
d920 10
a929 10
        for (i = 0; badenv_table[i]; i++) {
                len = strlen(badenv_table[i]);
                if (badenv_table[i][len-1] == '=' &&
                    !strncmp(badenv_table[i], varp, len-1) &&
                    varp[len-2] == '\0')
                        return (0);
                if (!strncmp(badenv_table[i], varp, len-1))
                        return (0);
        }
        return (1);
d1222 1
a1222 1
		if(envvarok(varp)) {
d1243 1
a1243 1
	if(envvarok(varp)) {
@


1.15
log
@Allows building w/o kerb support
@
text
@d342 1
a342 1
	    syslog(LOG_ERR, "telnetd: panic state=%d\n", state);
@


1.14
log
@Replace our telnetd with the one from heimdal-0.3f, with the following changes:
- obvious buildsystem tweakes
- our way to filter out bad environment variables
@
text
@d121 1
d123 1
a123 1
#ifdef ENCRYPTION
@


1.13
log
@Oops.
@
text
@a0 3
/*	$OpenBSD: state.c,v 1.11 2000/12/06 16:50:15 hin Exp $	*/
/*	$NetBSD: state.c,v 1.9 1996/02/28 20:38:19 thorpej Exp $	*/

d34 2
a35 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)state.c	8.5 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: state.c,v 1.9 1996/02/28 20:38:19 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD: state.c,v 1.11 2000/12/06 16:50:15 hin Exp $";
#endif
#endif /* not lint */
d37 1
a37 7
#include "telnetd.h"
#if	defined(AUTHENTICATION)
#include <libtelnet/auth.h>
#endif
#if	defined(ENCRYPTION)
#include <libtelnet/encrypt.h>
#endif
d49 1
a49 1
unsigned char subbuffer[512], *subpointer= subbuffer, *subend= subbuffer;
d54 2
a55 2
				*subpointer++ = (c); \
			}
d76 3
a78 3
#define	TS_WONT		6	/* wont " */
#define	TS_DO		7	/* do " */
#define	TS_DONT		8	/* dont " */
d80 2
a81 2
	void
telrcv()
d83 2
a84 2
	register int c;
	static int state = TS_DATA;
d86 4
a89 4
	while (ncc > 0) {
		if ((&ptyobuf[BUFSIZ] - pfrontp) < 2)
			break;
		c = *netip++ & 0377, ncc--;
d91 2
a92 2
       if (decrypt_input)
           c = (*decrypt_input)(c);
d94 1
a94 1
		switch (state) {
d96 7
a102 7
		case TS_CR:
			state = TS_DATA;
			/* Strip off \n or \0 after a \r */
			if ((c == 0) || (c == '\n')) {
				break;
			}
			/* FALL THROUGH */
d104 18
a121 18
		case TS_DATA:
			if (c == IAC) {
				state = TS_IAC;
				break;
			}
			/*
			 * We now map \r\n ==> \r for pragmatic reasons.
			 * Many client implementations send \r\n when
			 * the user hits the CarriageReturn key.
			 *
			 * We USED to map \r\n ==> \n, since \r\n says
			 * that we want to be in column 1 of the next
			 * printable line, and \n is the standard
			 * unix way of saying that (\r is only good
			 * if CRMOD is set, which it normally is).
			 */
			if ((c == '\r') && his_state_is_wont(TELOPT_BINARY)) {
				int nc = *netip;
d123 2
a124 13
				if (decrypt_input)
					nc = (*decrypt_input)(nc & 0xff);
#endif
#ifdef	LINEMODE
				/*
				 * If we are operating in linemode,
				 * convert to local end-of-line.
				 */
				if (linemode && (ncc > 0) && (('\n' == nc) ||
					 ((0 == nc) && tty_iscrnl())) ) {
					netip++; ncc--;
					c = '\n';
				} else
d126 1
a126 1
				{
d128 2
a129 2
				if (decrypt_input)
					(void)(*decrypt_input)(-1);
d131 91
a221 5
					state = TS_CR;
				}
			}
			*pfrontp++ = c;
			break;
d223 27
a249 2
		case TS_IAC:
gotiac:			switch (c) {
d251 7
a257 50
			/*
			 * Send the process on the pty side an
			 * interrupt.  Do this with a NULL or
			 * interrupt char; depending on the tty mode.
			 */
			case IP:
				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				interrupt();
				break;

			case BREAK:
				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				sendbrk();
				break;

			/*
			 * Are You There?
			 */
			case AYT:
				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				recv_ayt();
				break;

			/*
			 * Abort Output
			 */
			case AO:
			    {
				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				ptyflush();	/* half-hearted */
				init_termbuf();

				if (slctab[SLC_AO].sptr &&
				    *slctab[SLC_AO].sptr != (cc_t)(_POSIX_VDISABLE)) {
				    *pfrontp++ =
					(unsigned char)*slctab[SLC_AO].sptr;
				}

				netclear();	/* clear buffer back */
				*nfrontp++ = IAC;
				*nfrontp++ = DM;
				neturg = nfrontp-1; /* off by one XXX */
				DIAG(TD_OPTIONS,
					printoption("td: send IAC", DM));
				break;
			    }
d259 3
a261 21
			/*
			 * Erase Character and
			 * Erase Line
			 */
			case EC:
			case EL:
			    {
				cc_t ch;

				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				ptyflush();	/* half-hearted */
				init_termbuf();
				if (c == EC)
					ch = *slctab[SLC_EC].sptr;
				else
					ch = *slctab[SLC_EL].sptr;
				if (ch != (cc_t)(_POSIX_VDISABLE))
					*pfrontp++ = (unsigned char)ch;
				break;
			    }
d263 3
a265 61
			/*
			 * Check for urgent data...
			 */
			case DM:
				DIAG(TD_OPTIONS,
					printoption("td: recv IAC", c));
				SYNCHing = stilloob(net);
				settimer(gotDM);
				break;


			/*
			 * Begin option subnegotiation...
			 */
			case SB:
				state = TS_SB;
				SB_CLEAR();
				continue;

			case WILL:
				state = TS_WILL;
				continue;

			case WONT:
				state = TS_WONT;
				continue;

			case DO:
				state = TS_DO;
				continue;

			case DONT:
				state = TS_DONT;
				continue;
			case EOR:
				if (his_state_is_will(TELOPT_EOR))
					doeof();
				break;

			/*
			 * Handle RFC 10xx Telnet linemode option additions
			 * to command stream (EOF, SUSP, ABORT).
			 */
			case xEOF:
				doeof();
				break;

			case SUSP:
				sendsusp();
				break;

			case ABORT:
				sendbrk();
				break;

			case IAC:
				*pfrontp++ = c;
				break;
			}
			state = TS_DATA;
			break;
d267 6
a272 7
		case TS_SB:
			if (c == IAC) {
				state = TS_SE;
			} else {
				SB_ACCUM(c);
			}
			break;
d274 7
a280 35
		case TS_SE:
			if (c != SE) {
				if (c != IAC) {
					/*
					 * bad form of suboption negotiation.
					 * handle it in such a way as to avoid
					 * damage to local state.  Parse
					 * suboption buffer found so far,
					 * then treat remaining stream as
					 * another command sequence.
					 */

					/* for DIAGNOSTICS */
					SB_ACCUM(IAC);
					SB_ACCUM(c);
					subpointer -= 2;

					SB_TERM();
					suboption();
					state = TS_IAC;
					goto gotiac;
				}
				SB_ACCUM(c);
				state = TS_SB;
			} else {
				/* for DIAGNOSTICS */
				SB_ACCUM(IAC);
				SB_ACCUM(SE);
				subpointer -= 2;

				SB_TERM();
				suboption();	/* handle sub-option */
				state = TS_DATA;
			}
			break;
d282 21
a302 24
		case TS_WILL:
			willoption(c);
			state = TS_DATA;
			continue;

		case TS_WONT:
			wontoption(c);
			state = TS_DATA;
			continue;

		case TS_DO:
			dooption(c);
			state = TS_DATA;
			continue;

		case TS_DONT:
			dontoption(c);
			state = TS_DATA;
			continue;

		default:
			syslog(LOG_ERR, "telnetd: panic state=%d", state);
			printf("telnetd: panic state=%d\n", state);
			exit(1);
d304 40
d345 1
d404 2
a405 3
	void
send_do(option, init)
	int option, init;
d407 16
a422 17
	if (init) {
		if ((do_dont_resp[option] == 0 && his_state_is_will(option)) ||
		    his_want_state_is_will(option))
			return;
		/*
		 * Special case for TELOPT_TM:  We send a DO, but pretend
		 * that we sent a DONT, so that we can send more DOs if
		 * we want to.
		 */
		if (option == TELOPT_TM)
			set_his_want_state_wont(option);
		else
			set_his_want_state_will(option);
		do_dont_resp[option]++;
	}
	(void) sprintf(nfrontp, (char *)doopt, option);
	nfrontp += sizeof (dont) - 2;
d424 1
a424 1
	DIAG(TD_OPTIONS, printoption("td: send do", option));
d430 1
a430 4
#ifdef	LINEMODE
extern void doclientstat();
#endif
#ifdef ENCRYPTION
d434 2
a435 4

	void
willoption(option)
	int option;
d437 2
a438 2
	int changeok = 0;
	void (*func)() = 0;
d440 21
a460 3
	/*
	 * process input from peer.
	 */
d462 6
a467 1
	DIAG(TD_OPTIONS, printoption("td: recv will", option));
d469 6
a474 15
	if (do_dont_resp[option]) {
		do_dont_resp[option]--;
		if (do_dont_resp[option] && his_state_is_will(option))
			do_dont_resp[option]--;
	}
	if (do_dont_resp[option] == 0) {
	    if (his_want_state_is_wont(option)) {
		switch (option) {

		case TELOPT_BINARY:
			init_termbuf();
			tty_binaryin(1);
			set_termbuf();
			changeok++;
			break;
d476 19
a494 6
		case TELOPT_ECHO:
			/*
			 * See comments below for more info.
			 */
			not42 = 0;	/* looks like a 4.2 system */
			break;
a495 68
		case TELOPT_TM:
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
			/*
			 * This telnetd implementation does not really
			 * support timing marks, it just uses them to
			 * support the kludge linemode stuff.  If we
			 * receive a will or wont TM in response to our
			 * do TM request that may have been sent to
			 * determine kludge linemode support, process
			 * it, otherwise TM should get a negative
			 * response back.
			 */
			/*
			 * Handle the linemode kludge stuff.
			 * If we are not currently supporting any
			 * linemode at all, then we assume that this
			 * is the client telling us to use kludge
			 * linemode in response to our query.  Set the
			 * linemode type that is to be supported, note
			 * that the client wishes to use linemode, and
			 * eat the will TM as though it never arrived.
			 */
			if (lmodetype < KLUDGE_LINEMODE) {
				lmodetype = KLUDGE_LINEMODE;
				clientstat(TELOPT_LINEMODE, WILL, 0);
				send_wont(TELOPT_SGA, 1);
			} else if (lmodetype == NO_AUTOKLUDGE) {
				lmodetype = KLUDGE_OK;
			}
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
			/*
			 * We never respond to a WILL TM, and
			 * we leave the state WONT.
			 */
			return;

		case TELOPT_LFLOW:
			/*
			 * If we are going to support flow control
			 * option, then don't worry peer that we can't
			 * change the flow control characters.
			 */
			slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;
			slctab[SLC_XON].defset.flag |= SLC_DEFAULT;
			slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;
			slctab[SLC_XOFF].defset.flag |= SLC_DEFAULT;
		case TELOPT_TTYPE:
		case TELOPT_SGA:
		case TELOPT_NAWS:
		case TELOPT_TSPEED:
		case TELOPT_XDISPLOC:
		case TELOPT_NEW_ENVIRON:
		case TELOPT_OLD_ENVIRON:
			changeok++;
			break;

#ifdef	LINEMODE
		case TELOPT_LINEMODE:
# ifdef	KLUDGELINEMODE
			/*
			 * Note client's desire to use linemode.
			 */
			lmodetype = REAL_LINEMODE;
# endif	/* KLUDGELINEMODE */
			func = doclientstat;
			changeok++;
			break;
#endif	/* LINEMODE */
d498 4
a501 4
		case TELOPT_AUTHENTICATION:
			func = auth_request;
			changeok++;
			break;
d504 5
a508 5
#ifdef ENCRYPTION
		case TELOPT_ENCRYPT:
			func = encrypt_send_support;
			changeok++;
			break;
d510 7
a516 11

		default:
			break;
		}
		if (changeok) {
			set_his_want_state_will(option);
			send_do(option, 0);
		} else {
			do_dont_resp[option]++;
			send_dont(option, 0);
		}
d518 17
d536 13
a548 3
		 * Option processing that should happen when
		 * we receive conformation of a change in
		 * state that we had requested.
d550 1
a550 35
		switch (option) {
		case TELOPT_ECHO:
			not42 = 0;	/* looks like a 4.2 system */
			/*
			 * Egads, he responded "WILL ECHO".  Turn
			 * it off right now!
			 */
			send_dont(option, 1);
			/*
			 * "WILL ECHO".  Kludge upon kludge!
			 * A 4.2 client is now echoing user input at
			 * the tty.  This is probably undesireable and
			 * it should be stopped.  The client will
			 * respond WONT TM to the DO TM that we send to
			 * check for kludge linemode.  When the WONT TM
			 * arrives, linemode will be turned off and a
			 * change propogated to the pty.  This change
			 * will cause us to process the new pty state
			 * in localstat(), which will notice that
			 * linemode is off and send a WILL ECHO
			 * so that we are properly in character mode and
			 * all is well.
			 */
			break;
#ifdef	LINEMODE
		case TELOPT_LINEMODE:
# ifdef	KLUDGELINEMODE
			/*
			 * Note client's desire to use linemode.
			 */
			lmodetype = REAL_LINEMODE;
# endif	/* KLUDGELINEMODE */
			func = doclientstat;
			break;
#endif	/* LINEMODE */
d553 3
a555 3
		case TELOPT_AUTHENTICATION:
			func = auth_request;
			break;
d558 4
a561 4
#ifdef ENCRYPTION
		case TELOPT_ENCRYPT:
			func = encrypt_send_support;
			break;
d564 3
a566 4
		case TELOPT_LFLOW:
			func = flowstat;
			break;
		}
d569 4
a572 3
	set_his_state_will(option);
	if (func)
		(*func)();
d575 2
a576 3
	void
send_dont(option, init)
	int option, init;
d578 8
a585 9
	if (init) {
		if ((do_dont_resp[option] == 0 && his_state_is_wont(option)) ||
		    his_want_state_is_wont(option))
			return;
		set_his_want_state_wont(option);
		do_dont_resp[option]++;
	}
	(void) sprintf(nfrontp, (char *)dont, option);
	nfrontp += sizeof (doopt) - 2;
d587 1
a587 1
	DIAG(TD_OPTIONS, printoption("td: send dont", option));
d590 2
a591 3
	void
wontoption(option)
	int option;
d593 2
a594 2
	/*
	 * Process client input.
d597 1
a597 1
	DIAG(TD_OPTIONS, printoption("td: recv wont", option));
d599 18
a616 12
	if (do_dont_resp[option]) {
		do_dont_resp[option]--;
		if (do_dont_resp[option] && his_state_is_wont(option))
			do_dont_resp[option]--;
	}
	if (do_dont_resp[option] == 0) {
	    if (his_want_state_is_will(option)) {
		/* it is always ok to change to negative state */
		switch (option) {
		case TELOPT_ECHO:
			not42 = 1; /* doesn't seem to be a 4.2 system */
			break;
d618 9
a626 5
		case TELOPT_BINARY:
			init_termbuf();
			tty_binaryin(0);
			set_termbuf();
			break;
d628 11
a638 13
#ifdef	LINEMODE
		case TELOPT_LINEMODE:
# ifdef	KLUDGELINEMODE
			/*
			 * If real linemode is supported, then client is
			 * asking to turn linemode off.
			 */
			if (lmodetype != REAL_LINEMODE)
				break;
# endif	/* KLUDGELINEMODE */
			clientstat(TELOPT_LINEMODE, WONT, 0);
			break;
#endif	/* LINEMODE */
d640 4
a643 26
		case TELOPT_TM:
			/*
			 * If we get a WONT TM, and had sent a DO TM,
			 * don't respond with a DONT TM, just leave it
			 * as is.  Short circut the state machine to
			 * achive this.
			 */
			set_his_want_state_wont(TELOPT_TM);
			return;

		case TELOPT_LFLOW:
			/*
			 * If we are not going to support flow control
			 * option, then let peer know that we can't
			 * change the flow control characters.
			 */
			slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;
			slctab[SLC_XON].defset.flag |= SLC_CANTCHANGE;
			slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;
			slctab[SLC_XOFF].defset.flag |= SLC_CANTCHANGE;
			break;

#if	defined(AUTHENTICATION)
		case TELOPT_AUTHENTICATION:
			auth_finished(0, AUTH_REJECT);
			break;
d654 3
a656 3
		case TELOPT_TTYPE:
			settimer(ttypesubopt);
			break;
d658 3
a660 3
		case TELOPT_TSPEED:
			settimer(tspeedsubopt);
			break;
d662 3
a664 3
		case TELOPT_XDISPLOC:
			settimer(xdisplocsubopt);
			break;
d666 3
a668 3
		case TELOPT_OLD_ENVIRON:
			settimer(oenvironsubopt);
			break;
d670 3
a672 3
		case TELOPT_NEW_ENVIRON:
			settimer(environsubopt);
			break;
d674 10
a683 18
		default:
			break;
		}
		set_his_want_state_wont(option);
		if (his_state_is_will(option))
			send_dont(option, 0);
	    } else {
		switch (option) {
		case TELOPT_TM:
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
			if (lmodetype < NO_AUTOKLUDGE) {
				lmodetype = NO_LINEMODE;
				clientstat(TELOPT_LINEMODE, WONT, 0);
				send_will(TELOPT_SGA, 1);
				send_will(TELOPT_ECHO, 1);
			}
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
			break;
d685 4
a688 4
#if	defined(AUTHENTICATION)
		case TELOPT_AUTHENTICATION:
			auth_finished(0, AUTH_REJECT);
			break;
d690 2
a691 3
		default:
			break;
		}
d694 2
a695 1
	set_his_state_wont(option);
d699 2
a700 3
	void
send_will(option, init)
	int option, init;
d702 8
a709 9
	if (init) {
		if ((will_wont_resp[option] == 0 && my_state_is_will(option))||
		    my_want_state_is_will(option))
			return;
		set_my_want_state_will(option);
		will_wont_resp[option]++;
	}
	(void) sprintf(nfrontp, (char *)will, option);
	nfrontp += sizeof (doopt) - 2;
d711 1
a711 1
	DIAG(TD_OPTIONS, printoption("td: send will", option));
a713 1
#if	!defined(LINEMODE) || !defined(KLUDGELINEMODE)
a721 1
#endif
d723 2
a724 3
	void
dooption(option)
	int option;
d726 1
a726 1
	int changeok = 0;
d728 21
a748 3
	/*
	 * Process client input.
	 */
d750 6
a755 1
	DIAG(TD_OPTIONS, printoption("td: recv do", option));
d757 4
a760 22
	if (will_wont_resp[option]) {
		will_wont_resp[option]--;
		if (will_wont_resp[option] && my_state_is_will(option))
			will_wont_resp[option]--;
	}
	if ((will_wont_resp[option] == 0) && (my_want_state_is_wont(option))) {
		switch (option) {
		case TELOPT_ECHO:
#ifdef	LINEMODE
# ifdef	KLUDGELINEMODE
			if (lmodetype == NO_LINEMODE)
# else
			if (his_state_is_wont(TELOPT_LINEMODE))
# endif
#endif
			{
				init_termbuf();
				tty_setecho(1);
				set_termbuf();
			}
			changeok++;
			break;
d762 3
a764 6
		case TELOPT_BINARY:
			init_termbuf();
			tty_binaryout(1);
			set_termbuf();
			changeok++;
			break;
d766 9
a774 29
		case TELOPT_SGA:
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
			/*
			 * If kludge linemode is in use, then we must
			 * process an incoming do SGA for linemode
			 * purposes.
			 */
			if (lmodetype == KLUDGE_LINEMODE) {
				/*
				 * Receipt of "do SGA" in kludge
				 * linemode is the peer asking us to
				 * turn off linemode.  Make note of
				 * the request.
				 */
				clientstat(TELOPT_LINEMODE, WONT, 0);
				/*
				 * If linemode did not get turned off
				 * then don't tell peer that we did.
				 * Breaking here forces a wont SGA to
				 * be returned.
				 */
				if (linemode)
					break;
			}
#else
			turn_on_sga = 0;
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
			changeok++;
			break;
d776 14
a789 3
		case TELOPT_STATUS:
			changeok++;
			break;
a790 24
		case TELOPT_TM:
			/*
			 * Special case for TM.  We send a WILL, but
			 * pretend we sent a WONT.
			 */
			send_will(option, 0);
			set_my_want_state_wont(option);
			set_my_state_wont(option);
			return;

		case TELOPT_LOGOUT:
			/*
			 * When we get a LOGOUT option, respond
			 * with a WILL LOGOUT, make sure that
			 * it gets written out to the network,
			 * and then just go away...
			 */
			set_my_want_state_will(TELOPT_LOGOUT);
			send_will(TELOPT_LOGOUT, 0);
			set_my_state_will(TELOPT_LOGOUT);
			(void)netflush();
			cleanup(0);
			/* NOT REACHED */
			break;
d792 3
a794 3
		case TELOPT_ENCRYPT:
			changeok++;
			break;
d796 6
a801 7

		case TELOPT_LINEMODE:
		case TELOPT_TTYPE:
		case TELOPT_NAWS:
		case TELOPT_TSPEED:
		case TELOPT_LFLOW:
		case TELOPT_XDISPLOC:
d803 1
a803 1
		case TELOPT_NEW_ENVIRON:
d805 10
a814 11
		case TELOPT_OLD_ENVIRON:
		default:
			break;
		}
		if (changeok) {
			set_my_want_state_will(option);
			send_will(option, 0);
		} else {
			will_wont_resp[option]++;
			send_wont(option, 0);
		}
d816 2
a817 1
	set_my_state_will(option);
d821 2
a822 3
	void
send_wont(option, init)
	int option, init;
d824 8
a831 9
	if (init) {
		if ((will_wont_resp[option] == 0 && my_state_is_wont(option)) ||
		    my_want_state_is_wont(option))
			return;
		set_my_want_state_wont(option);
		will_wont_resp[option]++;
	}
	(void) sprintf(nfrontp, (char *)wont, option);
	nfrontp += sizeof (wont) - 2;
d833 1
a833 1
	DIAG(TD_OPTIONS, printoption("td: send wont", option));
d836 2
a837 3
	void
dontoption(option)
	int option;
d839 2
a840 2
	/*
	 * Process client input.
d844 1
a844 1
	DIAG(TD_OPTIONS, printoption("td: recv dont", option));
d846 12
a857 12
	if (will_wont_resp[option]) {
		will_wont_resp[option]--;
		if (will_wont_resp[option] && my_state_is_wont(option))
			will_wont_resp[option]--;
	}
	if ((will_wont_resp[option] == 0) && (my_want_state_is_will(option))) {
		switch (option) {
		case TELOPT_BINARY:
			init_termbuf();
			tty_binaryout(0);
			set_termbuf();
			break;
d859 7
a865 15
		case TELOPT_ECHO:	/* we should stop echoing */
#ifdef	LINEMODE
# ifdef	KLUDGELINEMODE
			if ((lmodetype != REAL_LINEMODE) &&
			    (lmodetype != KLUDGE_LINEMODE))
# else
			if (his_state_is_wont(TELOPT_LINEMODE))
# endif
#endif
			{
				init_termbuf();
				tty_setecho(0);
				set_termbuf();
			}
			break;
d867 8
a874 32
		case TELOPT_SGA:
#if	defined(LINEMODE) && defined(KLUDGELINEMODE)
			/*
			 * If kludge linemode is in use, then we
			 * must process an incoming do SGA for
			 * linemode purposes.
			 */
			if ((lmodetype == KLUDGE_LINEMODE) ||
			    (lmodetype == KLUDGE_OK)) {
				/*
				 * The client is asking us to turn
				 * linemode on.
				 */
				lmodetype = KLUDGE_LINEMODE;
				clientstat(TELOPT_LINEMODE, WILL, 0);
				/*
				 * If we did not turn line mode on,
				 * then what do we say?  Will SGA?
				 * This violates design of telnet.
				 * Gross.  Very Gross.
				 */
			}
			break;
#else
			set_my_want_state_wont(option);
			if (my_state_is_will(option))
				send_wont(option, 0);
			set_my_state_wont(option);
			if (turn_on_sga ^= 1)
				send_will(option, 1);
			return;
#endif	/* defined(LINEMODE) && defined(KLUDGELINEMODE) */
d876 3
a878 3
		default:
			break;
		}
d880 5
a884 5
		set_my_want_state_wont(option);
		if (my_state_is_will(option))
			send_wont(option, 0);
	}
	set_my_state_wont(option);
d903 9
a911 9
	"IFS=",
	"LD_",
	"_RLD_",
	"SHLIB_PATH=",
	"LIBPATH=",
	"KRB",
	"ENV=",
	"BASH_ENV=",
	NULL,
d918 1
a918 1
	char *varp;
d920 2
a921 2
	int i;
	int len;
d923 12
a934 12
	if (strchr(varp, '='))
		return (0);
	for (i = 0; badenv_table[i]; i++) {
		len = strlen(badenv_table[i]);
		if (badenv_table[i][len-1] == '=' &&
		    !strncmp(badenv_table[i], varp, len-1) &&
		    varp[len-2] == '\0')
			return (0);
		if (!strncmp(badenv_table[i], varp, len-1))
			return (0);
	}
	return (1);
d950 2
a951 2
	void
suboption()
d953 1
a953 1
    register int subchar;
d960 1
a960 1
	register int xspeed, rspeed;
d963 1
a963 1
		break;
d968 1
a968 1
		return;
d974 1
a974 1
		return;
d987 1
a987 1
		break;
d997 2
a998 2
								    !SB_EOF()) {
	    register int c;
d1012 1
a1012 1
	register int xwinsize, ywinsize;
d1015 1
a1015 1
		break;
d1018 1
a1018 1
		return;
d1021 1
a1021 1
		return;
d1024 1
a1024 1
		return;
d1027 1
a1027 1
		return;
a1034 48
#ifdef	LINEMODE
    case TELOPT_LINEMODE: {
	register int request;

	if (his_state_is_wont(TELOPT_LINEMODE))	/* Ignore if option disabled */
		break;
	/*
	 * Process linemode suboptions.
	 */
	if (SB_EOF())
	    break;		/* garbage was sent */
	request = SB_GET();	/* get will/wont */

	if (SB_EOF())
	    break;		/* another garbage check */

	if (request == LM_SLC) {  /* SLC is not preceeded by WILL or WONT */
		/*
		 * Process suboption buffer of slc's
		 */
		start_slc(1);
		do_opt_slc(subpointer, subend - subpointer);
		(void) end_slc(0);
		break;
	} else if (request == LM_MODE) {
		if (SB_EOF())
		    return;
		useeditmode = SB_GET();  /* get mode flag */
		clientstat(LM_MODE, 0, 0);
		break;
	}

	if (SB_EOF())
	    break;
	switch (SB_GET()) {  /* what suboption? */
	case LM_FORWARDMASK:
		/*
		 * According to spec, only server can send request for
		 * forwardmask, and client can only return a positive response.
		 * So don't worry about it.
		 */

	default:
		break;
	}
	break;
    }  /* end of case TELOPT_LINEMODE */
#endif
d1058 1
a1058 1
		return;
d1061 1
a1061 2
	/* XXX allocation failure? */
	(void)setenv("DISPLAY", (char *)subpointer, 1);
d1069 2
a1070 2
	register int c;
	register char *cp, *varp, *valp;
d1073 1
a1073 1
		return;
d1076 4
a1079 4
		if (subchar == TELOPT_OLD_ENVIRON)
			settimer(oenvironsubopt);
		else
			settimer(environsubopt);
d1081 1
a1081 1
		return;
d1089 1
a1089 1
			break;
d1093 1
a1093 1
	{
a1094 10
	    /*
	     * We only want to do this if we haven't already decided
	     * whether or not the other side has its VALUE and VAR
	     * reversed.
	     */
	    if (env_ovar < 0) {
		register int last = -1;		/* invalid value */
		int empty = 0;
		int got_var = 0, got_value = 0, got_uservar = 0;

d1096 3
a1098 11
		 * The other side might have its VALUE and VAR values
		 * reversed.  To be interoperable, we need to determine
		 * which way it is.  If the first recognized character
		 * is a VAR or VALUE, then that will tell us what
		 * type of client it is.  If the fist recognized
		 * character is a USERVAR, then we continue scanning
		 * the suboption looking for two consecutive
		 * VAR or VALUE fields.  We should not get two
		 * consecutive VALUE fields, so finding two
		 * consecutive VALUE or VAR fields will tell us
		 * what the client is.
d1100 20
a1119 2
		SB_SAVE();
		while (!SB_EOF()) {
d1123 6
a1128 6
				if (last < 0 || last == OLD_ENV_VAR
				    || (empty && (last == OLD_ENV_VALUE)))
					goto env_ovar_ok;
				got_var++;
				last = OLD_ENV_VAR;
				break;
d1130 6
a1135 6
				if (last < 0 || last == OLD_ENV_VALUE
				    || (empty && (last == OLD_ENV_VAR)))
					goto env_ovar_wrong;
				got_value++;
				last = OLD_ENV_VALUE;
				break;
d1137 11
a1147 11
				/* count strings of USERVAR as one */
				if (last != ENV_USERVAR)
					got_uservar++;
				if (empty) {
					if (last == OLD_ENV_VALUE)
						goto env_ovar_ok;
					if (last == OLD_ENV_VAR)
						goto env_ovar_wrong;
				}
				last = ENV_USERVAR;
				break;
d1149 3
a1151 3
				if (!SB_EOF())
					c = SB_GET();
				/* FALL THROUGH */
d1153 2
a1154 2
				empty = 0;
				continue;
d1157 2
a1158 2
		}
		if (empty) {
d1160 1
a1160 1
				goto env_ovar_ok;
d1162 19
a1180 19
				goto env_ovar_wrong;
		}
		/*
		 * Ok, the first thing was a USERVAR, and there
		 * are not two consecutive VAR or VALUE commands,
		 * and none of the VAR or VALUE commands are empty.
		 * If the client has sent us a well-formed option,
		 * then the number of VALUEs received should always
		 * be less than or equal to the number of VARs and
		 * USERVARs received.
		 *
		 * If we got exactly as many VALUEs as VARs and
		 * USERVARs, the client has the same definitions.
		 *
		 * If we got exactly as many VARs as VALUEs and
		 * USERVARS, the client has reversed definitions.
		 */
		if (got_uservar + got_var == got_value) {
	    env_ovar_ok:
d1183 2
a1184 2
		} else if (got_uservar + got_value == got_var) {
	    env_ovar_wrong:
d1187 3
a1189 3
			DIAG(TD_OPTIONS, {sprintf(nfrontp,
				"ENVIRON VALUE and VAR are reversed!\r\n");
				nfrontp += strlen(nfrontp);});
d1191 1
d1193 1
a1193 2
	    }
	    SB_RESTORE();
d1196 3
a1198 3
	    while (!SB_EOF()) {
		c = SB_GET();
		if ((c == env_ovar) || (c == ENV_USERVAR))
d1200 1
a1201 1
	}
d1204 1
a1204 1
		return;
d1210 8
a1217 8
		c = SB_GET();
		if (subchar == TELOPT_OLD_ENVIRON) {
			if (c == env_ovar)
				c = NEW_ENV_VAR;
			else if (c == env_ovalue)
				c = NEW_ENV_VALUE;
		}
		switch (c) {
d1219 4
a1222 4
		case NEW_ENV_VALUE:
			*cp = '\0';
			cp = valp = (char *)subpointer;
			break;
d1224 12
a1235 13
		case NEW_ENV_VAR:
		case ENV_USERVAR:
			*cp = '\0';
			if (envvarok(varp)) {
				if (valp)
					/* XXX allocation failure? */
					(void)setenv(varp, valp, 1);
				else
					unsetenv(varp);
			}
			cp = varp = (char *)subpointer;
			valp = 0;
			break;
d1237 9
a1245 9
		case ENV_ESC:
			if (SB_EOF())
				break;
			c = SB_GET();
			/* FALL THROUGH */
		default:
			*cp++ = c;
			break;
		}
d1248 5
a1252 6
	if (envvarok(varp)) {
		if (valp)
			/* XXX allocation failure? */
			(void)setenv(varp, valp, 1);
		else
			unsetenv(varp);
d1256 1
a1256 1
#if	defined(AUTHENTICATION)
d1259 1
a1259 1
		break;
d1263 5
a1267 5
		/*
		 * These are sent by us and cannot be sent by
		 * the client.
		 */
		break;
d1269 2
a1270 2
		auth_is(subpointer, SB_LEN());
		break;
d1272 2
a1273 2
		auth_name(subpointer, SB_LEN());
		break;
d1278 3
a1280 3
	case TELOPT_ENCRYPT:
		if (SB_EOF())
		break;
d1283 2
a1284 2
		encrypt_support(subpointer, SB_LEN());
		break;
d1286 2
a1287 2
		encrypt_is(subpointer, SB_LEN());
		break;
d1289 2
a1290 2
		encrypt_reply(subpointer, SB_LEN());
		break;
d1292 2
a1293 2
		encrypt_start(subpointer, SB_LEN());
		break;
d1295 2
a1296 2
		encrypt_end();
		break;
d1298 2
a1299 2
		encrypt_request_start(subpointer, SB_LEN());
		break;
d1301 8
a1308 8
		/*
		 * We can always send an REQEND so that we cannot
		 * get stuck encrypting.  We should only get this
		 * if we have been able to get in the correct mode
		 * anyhow.
		 */
		encrypt_request_end();
		break;
d1310 2
a1311 2
		encrypt_enc_keyid(subpointer, SB_LEN());
		break;
d1313 2
a1314 2
		encrypt_dec_keyid(subpointer, SB_LEN());
		break;
d1316 1
a1316 1
		break;
d1327 2
a1328 2
	void
doclientstat()
d1330 1
a1330 1
	clientstat(TELOPT_LINEMODE, WILL, 0);
d1335 3
a1337 2
	void
send_status()
d1339 31
a1369 7
	unsigned char statusbuf[256];
	register unsigned char *ncp;
	register unsigned char i;

	ncp = statusbuf;

	netflush();	/* get rid of anything waiting to go out */
d1371 1
a1371 1
	ADD(IAC);
d1373 5
a1377 20
	ADD(TELOPT_STATUS);
	ADD(TELQUAL_IS);

	/*
	 * We check the want_state rather than the current state,
	 * because if we received a DO/WILL for an option that we
	 * don't support, and the other side didn't send a DONT/WONT
	 * in response to our WONT/DONT, then the "state" will be
	 * WILL/DO, and the "want_state" will be WONT/DONT.  We
	 * need to go by the latter.
	 */
	for (i = 0; i < (unsigned char)NTELOPTS; i++) {
		if (my_want_state_is_will(i)) {
			ADD(WILL);
			ADD_DATA(i);
		}
		if (his_want_state_is_will(i)) {
			ADD(DO);
			ADD_DATA(i);
		}
d1379 1
d1381 9
a1389 20
	if (his_want_state_is_will(TELOPT_LFLOW)) {
		ADD(SB);
		ADD(TELOPT_LFLOW);
		if (flowmode) {
			ADD(LFLOW_ON);
		} else {
			ADD(LFLOW_OFF);
		}
		ADD(SE);

		if (restartany >= 0) {
			ADD(SB);
			ADD(TELOPT_LFLOW);
			if (restartany) {
				ADD(LFLOW_RESTART_ANY);
			} else {
				ADD(LFLOW_RESTART_XON);
			}
			ADD(SE);
		}
d1391 1
a1392 22
#ifdef	LINEMODE
	if (his_want_state_is_will(TELOPT_LINEMODE)) {
		unsigned char *cp, *cpe;
		int len;

		ADD(SB);
		ADD(TELOPT_LINEMODE);
		ADD(LM_MODE);
		ADD_DATA(editmode);
		ADD(SE);

		ADD(SB);
		ADD(TELOPT_LINEMODE);
		ADD(LM_SLC);
		start_slc(0);
		send_slc();
		len = end_slc(&cp);
		for (cpe = cp + len; cp < cpe; cp++)
			ADD_DATA(*cp);
		ADD(SE);
	}
#endif	/* LINEMODE */
d1394 2
a1395 2
	ADD(IAC);
	ADD(SE);
d1397 2
a1398 2
	writenet(statusbuf, ncp - statusbuf);
	netflush();	/* Send it on its way */
d1400 2
a1401 2
	DIAG(TD_OPTIONS,
		{printsub('>', statusbuf, ncp - statusbuf); netflush();});
@


1.12
log
@Bring recent kerberos fix into -stable.
@
text
@a1459 2
					syslog(LOG_DEBUG, "Setting %=%", 
					       varp, valp);
a1481 1
			syslog 
@


1.11
log
@Be more paranoid about passed KRB environment variables.
(ok art)
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.10 2000/09/15 07:13:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.10 2000/09/15 07:13:47 deraadt Exp $";
d1460 2
d1484 1
@


1.10
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.9 1998/08/21 17:12:22 art Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.9 1998/08/21 17:12:22 art Exp $";
d1089 1
a1089 1
	"KRB_CONF",
@


1.10.2.1
log
@Actually commit kerberos fix. This time done right (hopefully).
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.11 2000/12/06 16:50:15 hin Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.11 2000/12/06 16:50:15 hin Exp $";
d1089 1
a1089 1
	"KRB",
@


1.9
log
@decrypt the input _before_ checking if it is \n, not _after_.
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.8 1998/07/10 08:06:21 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.8 1998/07/10 08:06:21 deraadt Exp $";
d1290 1
d1459 1
d1481 1
@


1.8
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.7 1998/03/25 18:43:46 art Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.7 1998/03/25 18:43:46 art Exp $";
d137 4
a150 4
#endif
#ifdef ENCRYPTION
				if (decrypt_input)
					nc = (*decrypt_input)(nc & 0xff);
@


1.7
log
@cleanup and please -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.6 1998/03/12 04:53:12 art Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.6 1998/03/12 04:53:12 art Exp $";
d366 1
a366 1
			syslog(LOG_ERR, "telnetd: panic state=%d\n", state);
@


1.6
log
@Encryption from kth-krb 0.9.8 (only for those with kerberos)
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.5 1996/08/24 09:03:42 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.5 1996/08/24 09:03:42 deraadt Exp $";
d49 3
@


1.5
log
@more complete list of bad env variables, and a fancy scanner; thanks to
millert and dholland@@hcs.harvard.edu for suggestions.
@
text
@d1 1
a1 1
/*	$OpenBSD: state.c,v 1.4 1996/08/16 23:32:44 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: state.c,v 1.4 1996/08/16 23:32:44 deraadt Exp $";
a96 3
#if	defined(CRAY2) && defined(UNICOS5)
	char *opfrontp = pfrontp;
#endif
d102 4
d145 4
d150 4
a367 15
#if	defined(CRAY2) && defined(UNICOS5)
	if (!linemode) {
		char	xptyobuf[BUFSIZ+NETSLOP];
		char	xbuf2[BUFSIZ];
		register char *cp;
		int n = pfrontp - opfrontp, oc;
		memmove(xptyobuf, opfrontp, n);
		pfrontp = opfrontp;
		pfrontp += term_input(xptyobuf, pfrontp, n, BUFSIZ+NETSLOP,
					xbuf2, &oc, BUFSIZ);
		for (cp = xbuf2; oc > 0; --oc)
			if ((*nfrontp++ = *cp++) == IAC)
				*nfrontp++ = IAC;
	}
#endif	/* defined(CRAY2) && defined(UNICOS5) */
d452 1
a452 1
extern void auth_request();
d457 4
d574 6
d639 6
d933 5
d1499 43
@


1.4
log
@ENV is unsafe to pass; from dholland@@hcs.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d1059 18
d1083 15
a1097 5
	return (strncmp(varp, "LD_", strlen("LD_")) &&
		strncmp(varp, "_RLD_", strlen("_RLD_")) &&
		strcmp(varp, "LIBPATH") &&
		strcmp(varp, "ENV") &&
		strcmp(varp, "IFS"));
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1068 1
@


1.2
log
@security fix from NetBSD
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)state.c	8.1 (Berkeley) 6/4/93"; */
static char *rcsid = "$Id: state.c,v 1.5.4.2 1995/10/19 12:48:54 ghudson Exp $";
d365 1
a365 1
		bcopy(opfrontp, xptyobuf, n);
d387 1
a387 1
 * 
a700 1
			lmodetype = KLUDGE_LINEMODE;
d1472 2
a1473 2
#define	ADD(c)	 *ncp++ = c;
#define	ADD_DATA(c) { *ncp++ = c; if (c == SE) *ncp++ = c; }
a1501 2
			if (i == IAC)
				ADD(IAC);
a1505 2
			if (i == IAC)
				ADD(IAC);
d1520 1
a1520 1
			ADD(SB)
d1527 1
a1527 2
			ADD(SE)
			ADD(SB);
a1539 2
		if (editmode == IAC)
			ADD(IAC);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: state.c,v 1.5 1994/02/25 03:20:54 cgd Exp $";
d1053 12
d1403 6
a1408 4
			if (valp)
				(void)setenv(varp, valp, 1);
			else
				unsetenv(varp);
d1424 6
a1429 4
	if (valp)
		(void)setenv(varp, valp, 1);
	else
		unsetenv(varp);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

