head	1.38;
access;
symbols
	OPENBSD_3_7:1.37.0.4
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.4
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.4
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2005.05.25.05.35.22;	author deraadt;	state dead;
branches;
next	1.37;

1.37
date	2004.09.08.14.23.49;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.24.21.37.45;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.25.07.15.40;	author pvalchev;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.07.23.08.23;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.07.23.01.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.22.02.37.47;	author cloder;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.09.00.40.56;	author hin;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.21.07.32.55;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.02.16.20.13;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.09.07.04.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.29.21.30.55;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.04.57.44;	author hin;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.19.44.32;	author hin;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.11.15.18.52;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.17.23.51.54;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.16.19.00.19;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.10.12.59.46;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.15.07.13.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.08.17.09.13.13;	author millert;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	98.07.28.20.18.20;	author marc;	state Exp;
branches;
next	1.16;

1.16
date	98.07.23.17.55.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.07.13.02.11.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.07.10.08.06.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.05.08.19.32.33;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.04.25.04.43.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.04.01.08.28.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.03.25.18.43.48;	author art;	state Exp;
branches;
next	1.9;

1.9
date	98.03.12.04.53.14;	author art;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.20.36.35;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.14.01.40.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.05.59.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.23.14.29.46;	author robin;	state Exp;
branches;
next	1.4;

1.4
date	96.04.23.03.03.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.28.23.22.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.22.10.39.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.24;	author deraadt;	state Exp;
branches;
next	;

1.18.4.1
date	2000.10.10.19.49.07;	author jason;	state Exp;
branches;
next	;


desc
@@


1.38
log
@bye bye
@
text
@/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnetd.h"

/* RCSID("$KTH: sys_term.c,v 1.100 2001/04/24 23:11:43 assar Exp $"); */

#if defined(_CRAY) || (defined(__hpux) && !defined(HAVE_UTMPX_H))
# define PARENT_DOES_UTMP
#endif

#ifdef HAVE_UTMP_H
#include <utmp.h>
#endif

#ifdef HAVE_UTMPX_H
#include <utmpx.h>
#endif

#ifdef HAVE_UTMPX_H
struct	utmpx wtmp;
#elif defined(HAVE_UTMP_H)
struct	utmp wtmp;
#endif /* HAVE_UTMPX_H */

#ifdef HAVE_STRUCT_UTMP_UT_HOST
int	utmp_len = sizeof(wtmp.ut_host);
#else
int	utmp_len = MAXHOSTNAMELEN;
#endif

#ifndef UTMP_FILE
#ifdef _PATH_UTMP
#define UTMP_FILE _PATH_UTMP
#else
#define UTMP_FILE "/etc/utmp"
#endif
#endif

#if !defined(WTMP_FILE) && defined(_PATH_WTMP)
#define WTMP_FILE _PATH_WTMP
#endif

#ifndef PARENT_DOES_UTMP
#ifdef WTMP_FILE
char	wtmpf[] = WTMP_FILE;
#else
char	wtmpf[]	= "/usr/adm/wtmp";
#endif
char	utmpf[] = UTMP_FILE;
#else /* PARENT_DOES_UTMP */
#ifdef WTMP_FILE
char	wtmpf[] = WTMP_FILE;
#else
char	wtmpf[]	= "/etc/wtmp";
#endif
#endif /* PARENT_DOES_UTMP */

#ifdef HAVE_TMPDIR_H
#include <tmpdir.h>
#endif	/* CRAY */

#ifdef	STREAMSPTY

#ifdef HAVE_SAC_H
#include <sac.h>
#endif

#ifdef HAVE_SYS_STROPTS_H
#include <sys/stropts.h>
#endif

#endif /* STREAMSPTY */

#ifdef	HAVE_SYS_STREAM_H
#ifdef  HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif
#ifdef __hpux
#undef SE
#endif
#include <sys/stream.h>
#endif
#if !(defined(__sgi) || defined(__linux) || defined(_AIX)) && defined(HAVE_SYS_TTY)
#include <sys/tty.h>
#endif
#ifdef	t_erase
#undef	t_erase
#undef	t_kill
#undef	t_intrc
#undef	t_quitc
#undef	t_startc
#undef	t_stopc
#undef	t_eofc
#undef	t_brkc
#undef	t_suspc
#undef	t_dsuspc
#undef	t_rprntc
#undef	t_flushc
#undef	t_werasc
#undef	t_lnextc
#endif

#ifdef HAVE_TERMIOS_H
#include <termios.h>
#else
#ifdef HAVE_TERMIO_H
#include <termio.h>
#endif
#endif

#ifdef HAVE_UTIL_H
#include <util.h>
#endif

# ifndef	TCSANOW
#  ifdef TCSETS
#   define	TCSANOW		TCSETS
#   define	TCSADRAIN	TCSETSW
#   define	tcgetattr(f, t)	ioctl(f, TCGETS, (char *)t)
#  else
#   ifdef TCSETA
#    define	TCSANOW		TCSETA
#    define	TCSADRAIN	TCSETAW
#    define	tcgetattr(f, t)	ioctl(f, TCGETA, (char *)t)
#   else
#    define	TCSANOW		TIOCSETA
#    define	TCSADRAIN	TIOCSETAW
#    define	tcgetattr(f, t)	ioctl(f, TIOCGETA, (char *)t)
#   endif
#  endif
#  define	tcsetattr(f, a, t)	ioctl(f, a, t)
#  define	cfsetospeed(tp, val)	(tp)->c_cflag &= ~CBAUD; \
(tp)->c_cflag |= (val)
#  define	cfgetospeed(tp)		((tp)->c_cflag & CBAUD)
#  ifdef CIBAUD
#   define	cfsetispeed(tp, val)	(tp)->c_cflag &= ~CIBAUD; \
     (tp)->c_cflag |= ((val)<<IBSHIFT)
#   define	cfgetispeed(tp)		(((tp)->c_cflag & CIBAUD)>>IBSHIFT)
#  else
#   define	cfsetispeed(tp, val)	(tp)->c_cflag &= ~CBAUD; \
     (tp)->c_cflag |= (val)
#   define	cfgetispeed(tp)		((tp)->c_cflag & CBAUD)
#  endif
# endif /* TCSANOW */
     struct termios termbuf, termbuf2;	/* pty control structure */
# ifdef  STREAMSPTY
     static int ttyfd = -1;
     int really_stream = 0;
# endif

     char *new_login = NULL;

/*
 * init_termbuf()
 * copy_termbuf(cp)
 * set_termbuf()
 *
 * These three routines are used to get and set the "termbuf" structure
 * to and from the kernel.  init_termbuf() gets the current settings.
 * copy_termbuf() hands in a new "termbuf" to write to the kernel, and
 * set_termbuf() writes the structure into the kernel.
 */

     void
     init_termbuf(void)
{
# ifdef  STREAMSPTY
    if (really_stream)
	tcgetattr(ttyfd, &termbuf);
    else
# endif
	tcgetattr(ourpty, &termbuf);
    termbuf2 = termbuf;
}

void
set_termbuf(void)
{
    /*
     * Only make the necessary changes.
	 */
    if (memcmp(&termbuf, &termbuf2, sizeof(termbuf)))
# ifdef  STREAMSPTY
	if (really_stream)
	    tcsetattr(ttyfd, TCSANOW, &termbuf);
	else
# endif
	    tcsetattr(ourpty, TCSANOW, &termbuf);
}


/*
 * spcset(func, valp, valpp)
 *
 * This function takes various special characters (func), and
 * sets *valp to the current value of that character, and
 * *valpp to point to where in the "termbuf" structure that
 * value is kept.
 *
 * It returns the SLC_ level of support for this function.
 */


int
spcset(int func, cc_t *valp, cc_t **valpp)
{

#define	setval(a, b)	*valp = termbuf.c_cc[a]; \
    *valpp = &termbuf.c_cc[a]; \
				   return(b);
#define	defval(a) *valp = ((cc_t)a); *valpp = (cc_t *)0; return(SLC_DEFAULT);

    switch(func) {
    case SLC_EOF:
	setval(VEOF, SLC_VARIABLE);
    case SLC_EC:
	setval(VERASE, SLC_VARIABLE);
    case SLC_EL:
	setval(VKILL, SLC_VARIABLE);
    case SLC_IP:
	setval(VINTR, SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
    case SLC_ABORT:
	setval(VQUIT, SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
    case SLC_XON:
#ifdef	VSTART
	setval(VSTART, SLC_VARIABLE);
#else
	defval(0x13);
#endif
    case SLC_XOFF:
#ifdef	VSTOP
	setval(VSTOP, SLC_VARIABLE);
#else
	defval(0x11);
#endif
    case SLC_EW:
#ifdef	VWERASE
	setval(VWERASE, SLC_VARIABLE);
#else
	defval(0);
#endif
    case SLC_RP:
#ifdef	VREPRINT
	setval(VREPRINT, SLC_VARIABLE);
#else
	defval(0);
#endif
    case SLC_LNEXT:
#ifdef	VLNEXT
	setval(VLNEXT, SLC_VARIABLE);
#else
	defval(0);
#endif
    case SLC_AO:
#if	!defined(VDISCARD) && defined(VFLUSHO)
# define VDISCARD VFLUSHO
#endif
#ifdef	VDISCARD
	setval(VDISCARD, SLC_VARIABLE|SLC_FLUSHOUT);
#else
	defval(0);
#endif
    case SLC_SUSP:
#ifdef	VSUSP
	setval(VSUSP, SLC_VARIABLE|SLC_FLUSHIN);
#else
	defval(0);
#endif
#ifdef	VEOL
    case SLC_FORW1:
	setval(VEOL, SLC_VARIABLE);
#endif
#ifdef	VEOL2
    case SLC_FORW2:
	setval(VEOL2, SLC_VARIABLE);
#endif
    case SLC_AYT:
#ifdef	VSTATUS
	setval(VSTATUS, SLC_VARIABLE);
#else
	defval(0);
#endif

    case SLC_BRK:
    case SLC_SYNCH:
    case SLC_EOR:
	defval(0);

    default:
	*valp = 0;
	*valpp = 0;
	return(SLC_NOSUPPORT);
    }
}

#ifdef _CRAY
/*
 * getnpty()
 *
 * Return the number of pty's configured into the system.
 */
int
getnpty()
{
#ifdef _SC_CRAY_NPTY
    int numptys;

    if ((numptys = sysconf(_SC_CRAY_NPTY)) != -1)
	return numptys;
    else
#endif /* _SC_CRAY_NPTY */
	return 128;
}
#endif /* CRAY */

/*
 * getpty()
 *
 * Allocate a pty.  As a side effect, the external character
 * array "line" contains the name of the slave side.
 *
 * Returns the file descriptor of the opened pty.
 */

static char Xline[] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
char *line = Xline;

int	slavefd = -1;

#ifdef	_CRAY
char myline[] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
#endif	/* CRAY */

#if !defined(HAVE_PTSNAME) && defined(STREAMSPTY)
static char *ptsname(int fd)
{
#ifdef HAVE_TTYNAME
    return ttyname(fd);
#else
    return NULL;
#endif
}
#endif

int getpty(int *ptynum)
{
#if defined(__osf__) || defined(HAVE_OPENPTY)
    int master;
    int slave;
    if(openpty(&master, &slave, line, 0, 0) == 0){
	slavefd = slave;
	return master;
    }
    return -1;
#else
#ifdef HAVE__GETPTY
    int master, slave;
    char *p;
    p = _getpty(&master, O_RDWR, 0600, 1);
    if(p == NULL)
	return -1;
    strlcpy(line, p, sizeof(Xline));
    return master;
#else

    int p;
    char *cp, *p1, *p2;
    int i;
#if SunOS == 40
    int dummy;
#endif
#if 0 /* && defined(HAVE_OPENPTY) */
    int master;
    int slave;
    if(openpty(&master, &slave, line, 0, 0) == 0){
	close(slave);
	return master;
    }
#else
#ifdef	STREAMSPTY
    char *clone[] = { "/dev/ptc", "/dev/ptmx", "/dev/ptm", 
		      "/dev/ptym/clone", 0 };

    char **q;
    for(q=clone; *q; q++){
	p=open(*q, O_RDWR);
	if(p >= 0){
#ifdef HAVE_GRANTPT
	    grantpt(p);
#endif
#ifdef HAVE_UNLOCKPT
	    unlockpt(p);
#endif
	    strlcpy(line, ptsname(p), sizeof(Xline));
	    really_stream = 1;
	    return p;
	}
    }
#endif /* STREAMSPTY */
#ifndef _CRAY

#ifndef	__hpux
    snprintf(line, sizeof(Xline), "/dev/ptyXX");
    p1 = &line[8];
    p2 = &line[9];
#else
    snprintf(line, sizeof(Xline), "/dev/ptym/ptyXX");
    p1 = &line[13];
    p2 = &line[14];
#endif

	
    for (cp = "pqrstuvwxyzPQRST"; *cp; cp++) {
	struct stat stb;

	*p1 = *cp;
	*p2 = '0';
	/*
	 * This stat() check is just to keep us from
	 * looping through all 256 combinations if there
	 * aren't that many ptys available.
	 */
	if (stat(line, &stb) < 0)
	    break;
	for (i = 0; i < 16; i++) {
	    *p2 = "0123456789abcdef"[i];
	    p = open(line, O_RDWR);
	    if (p > 0) {
#ifndef	__hpux
		line[5] = 't';
#else
		for (p1 = &line[8]; *p1; p1++)
		    *p1 = *(p1+1);
		line[9] = 't';
#endif
		chown(line, 0, 0);
		chmod(line, 0600);
#if SunOS == 40
		if (ioctl(p, TIOCGPGRP, &dummy) == 0
		    || errno != EIO) {
		    chmod(line, 0666);
		    close(p);
		    line[5] = 'p';
		} else
#endif /* SunOS == 40 */
		    return(p);
	    }
	}
    }
#else	/* CRAY */
    extern lowpty, highpty;
    struct stat sb;

    for (*ptynum = lowpty; *ptynum <= highpty; (*ptynum)++) {
	snprintf(myline, sizeof(myline), "/dev/pty/%03d", *ptynum);
	p = open(myline, 2);
	if (p < 0)
	    continue;
	snprintf(line, sizeof(Xline), "/dev/ttyp%03d", *ptynum);
	/*
	 * Here are some shenanigans to make sure that there
	 * are no listeners lurking on the line.
	 */
	if(stat(line, &sb) < 0) {
	    close(p);
	    continue;
	}
	if(sb.st_uid || sb.st_gid || sb.st_mode != 0600) {
	    chown(line, 0, 0);
	    chmod(line, 0600);
	    close(p);
	    p = open(myline, 2);
	    if (p < 0)
		continue;
	}
	/*
	 * Now it should be safe...check for accessability.
	 */
	if (access(line, 6) == 0)
	    return(p);
	else {
	    /* no tty side to pty so skip it */
	    close(p);
	}
    }
#endif	/* CRAY */
#endif	/* STREAMSPTY */
#endif /* OPENPTY */
    return(-1);
#endif
}


int
tty_isecho(void)
{
    return (termbuf.c_lflag & ECHO);
}

int
tty_flowmode(void)
{
    return((termbuf.c_iflag & IXON) ? 1 : 0);
}

int
tty_restartany(void)
{
    return((termbuf.c_iflag & IXANY) ? 1 : 0);
}

void
tty_setecho(int on)
{
    if (on)
	termbuf.c_lflag |= ECHO;
    else
	termbuf.c_lflag &= ~ECHO;
}

int
tty_israw(void)
{
    return(!(termbuf.c_lflag & ICANON));
}

void
tty_binaryin(int on)
{
    if (on) {
	termbuf.c_iflag &= ~ISTRIP;
    } else {
	termbuf.c_iflag |= ISTRIP;
    }
}

void
tty_binaryout(int on)
{
    if (on) {
	termbuf.c_cflag &= ~(CSIZE|PARENB);
	termbuf.c_cflag |= CS8;
	termbuf.c_oflag &= ~OPOST;
    } else {
	termbuf.c_cflag &= ~CSIZE;
	termbuf.c_cflag |= CS7|PARENB;
	termbuf.c_oflag |= OPOST;
    }
}

int
tty_isbinaryin(void)
{
    return(!(termbuf.c_iflag & ISTRIP));
}

int
tty_isbinaryout(void)
{
    return(!(termbuf.c_oflag&OPOST));
}


int
tty_issofttab(void)
{
# ifdef	OXTABS
    return (termbuf.c_oflag & OXTABS);
# endif
# ifdef	TABDLY
    return ((termbuf.c_oflag & TABDLY) == TAB3);
# endif
}

void
tty_setsofttab(int on)
{
    if (on) {
# ifdef	OXTABS
	termbuf.c_oflag |= OXTABS;
# endif
# ifdef	TABDLY
	termbuf.c_oflag &= ~TABDLY;
	termbuf.c_oflag |= TAB3;
# endif
    } else {
# ifdef	OXTABS
	termbuf.c_oflag &= ~OXTABS;
# endif
# ifdef	TABDLY
	termbuf.c_oflag &= ~TABDLY;
	termbuf.c_oflag |= TAB0;
# endif
    }
}

int
tty_islitecho(void)
{
# ifdef	ECHOCTL
    return (!(termbuf.c_lflag & ECHOCTL));
# endif
# ifdef	TCTLECH
    return (!(termbuf.c_lflag & TCTLECH));
# endif
# if	!defined(ECHOCTL) && !defined(TCTLECH)
    return (0);	/* assumes ctl chars are echoed '^x' */
# endif
}

void
tty_setlitecho(int on)
{
# ifdef	ECHOCTL
    if (on)
	termbuf.c_lflag &= ~ECHOCTL;
    else
	termbuf.c_lflag |= ECHOCTL;
# endif
# ifdef	TCTLECH
    if (on)
	termbuf.c_lflag &= ~TCTLECH;
    else
	termbuf.c_lflag |= TCTLECH;
# endif
}

int
tty_iscrnl(void)
{
    return (termbuf.c_iflag & ICRNL);
}

/*
 * Try to guess whether speeds are "encoded" (4.2BSD) or just numeric (4.4BSD).
 */
#if B4800 != 4800
#define	DECODE_BAUD
#endif

#ifdef	DECODE_BAUD

/*
 * A table of available terminal speeds
 */
struct termspeeds {
    int	speed;
    int	value;
} termspeeds[] = {
    { 0,      B0 },      { 50,    B50 },    { 75,     B75 },
    { 110,    B110 },    { 134,   B134 },   { 150,    B150 },
    { 200,    B200 },    { 300,   B300 },   { 600,    B600 },
    { 1200,   B1200 },   { 1800,  B1800 },  { 2400,   B2400 },
    { 4800,   B4800 },
#ifdef	B7200
    { 7200,  B7200 },
#endif
    { 9600,   B9600 },
#ifdef	B14400
    { 14400,  B14400 },
#endif
#ifdef	B19200
    { 19200,  B19200 },
#endif
#ifdef	B28800
    { 28800,  B28800 },
#endif
#ifdef	B38400
    { 38400,  B38400 },
#endif
#ifdef	B57600
    { 57600,  B57600 },
#endif
#ifdef	B115200
    { 115200, B115200 },
#endif
#ifdef	B230400
    { 230400, B230400 },
#endif
    { -1,     0 }
};
#endif	/* DECODE_BUAD */

void
tty_tspeed(int val)
{
#ifdef	DECODE_BAUD
    struct termspeeds *tp;

    for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
	;
    if (tp->speed == -1)	/* back up to last valid value */
	--tp;
    cfsetospeed(&termbuf, tp->value);
#else	/* DECODE_BUAD */
    cfsetospeed(&termbuf, val);
#endif	/* DECODE_BUAD */
}

void
tty_rspeed(int val)
{
#ifdef	DECODE_BAUD
    struct termspeeds *tp;

    for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
	;
    if (tp->speed == -1)	/* back up to last valid value */
	--tp;
    cfsetispeed(&termbuf, tp->value);
#else	/* DECODE_BAUD */
    cfsetispeed(&termbuf, val);
#endif	/* DECODE_BAUD */
}

#ifdef PARENT_DOES_UTMP
extern	struct utmp wtmp;
extern char wtmpf[];

extern void utmp_sig_init (void);
extern void utmp_sig_reset (void);
extern void utmp_sig_wait (void);
extern void utmp_sig_notify (int);
# endif /* PARENT_DOES_UTMP */

#ifdef STREAMSPTY

/* I_FIND seems to live a life of its own */
static int my_find(int fd, char *module)
{
#if defined(I_FIND) && defined(I_LIST)
    static int flag;
    static struct str_list sl;
    int n;
    int i;
  
    if(!flag){
	n = ioctl(fd, I_LIST, 0);
	if(n < 0){
	    perror("ioctl(fd, I_LIST, 0)");
	    return -1;
	}
	sl.sl_modlist=(struct str_mlist*)malloc(n * sizeof(struct str_mlist));
	sl.sl_nmods = n;
	n = ioctl(fd, I_LIST, &sl);
	if(n < 0){
	    perror("ioctl(fd, I_LIST, n)");
	    return -1;
	}
	flag = 1;
    }
  
    for(i=0; i<sl.sl_nmods; i++)
	if(!strcmp(sl.sl_modlist[i].l_name, module))
	    return 1;
#endif
    return 0;
}

static void maybe_push_modules(int fd, char **modules)
{
    char **p;
    int err;

    for(p=modules; *p; p++){
	err = my_find(fd, *p);
	if(err == 1)
	    break;
	if(err < 0 && errno != EINVAL)
	    fatalperror(net, "my_find()");
	/* module not pushed or does not exist */
    }
    /* p points to null or to an already pushed module, now push all
       modules before this one */
  
    for(p--; p >= modules; p--){
	err = ioctl(fd, I_PUSH, *p);
	if(err < 0 && errno != EINVAL)
	    fatalperror(net, "I_PUSH");
    }
}
#endif

/*
 * getptyslave()
 *
 * Open the slave side of the pty, and do any initialization
 * that is necessary.  The return value is a file descriptor
 * for the slave side.
 */
void getptyslave(void)
{
    int t = -1;

    struct winsize ws;
    extern int def_row, def_col;
    extern int def_tspeed, def_rspeed;
    /*
     * Opening the slave side may cause initilization of the
     * kernel tty structure.  We need remember the state of
     * 	if linemode was turned on
     *	terminal window size
     *	terminal speed
     * so that we can re-set them if we need to.
     */

    if (slavefd != -1) {
	t = slavefd;
	goto gottty;
    }

    /*
     * Make sure that we don't have a controlling tty, and
     * that we are the session (process group) leader.
     */

#ifdef HAVE_SETSID
    if(setsid()<0)
	fatalperror(net, "setsid()");
#else
# ifdef	TIOCNOTTY
    t = open(_PATH_TTY, O_RDWR);
    if (t >= 0) {
	ioctl(t, TIOCNOTTY, (char *)0);
	close(t);
    }
# endif
#endif

# ifdef PARENT_DOES_UTMP
    /*
     * Wait for our parent to get the utmp stuff to get done.
     */
    utmp_sig_wait();
# endif

    t = cleanopen(line);
gottty:
    if (t < 0)
	fatalperror(net, line);

#ifdef  STREAMSPTY
    ttyfd = t;
	  

    /*
     * Not all systems have (or need) modules ttcompat and pckt so
     * don't flag it as a fatal error if they don't exist.
     */

    if (really_stream)
	{
	    /* these are the streams modules that we want pushed. note
	       that they are in reverse order, ptem will be pushed
	       first. maybe_push_modules() will try to push all modules
	       before the first one that isn't already pushed. i.e if
	       ldterm is pushed, only ttcompat will be attempted.

	       all this is because we don't know which modules are
	       available, and we don't know which modules are already
	       pushed (via autopush, for instance).

	       */
	     
	    char *ttymodules[] = { "ttcompat", "ldterm", "ptem", NULL };
	    char *ptymodules[] = { "pckt", NULL };

	    maybe_push_modules(t, ttymodules);
	    maybe_push_modules(ourpty, ptymodules);
	}
#endif
    /*
     * set up the tty modes as we like them to be.
     */
    init_termbuf();
# ifdef	TIOCSWINSZ
    if (def_row || def_col) {
	memset(&ws, 0, sizeof(ws));
	ws.ws_col = def_col;
	ws.ws_row = def_row;
	ioctl(t, TIOCSWINSZ, (char *)&ws);
    }
# endif

    /*
     * Settings for sgtty based systems
     */

    /*
     * Settings for UNICOS (and HPUX)
     */
# if defined(_CRAY) || defined(__hpux)
    termbuf.c_oflag = OPOST|ONLCR|TAB3;
    termbuf.c_iflag = IGNPAR|ISTRIP|ICRNL|IXON;
    termbuf.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
    termbuf.c_cflag = EXTB|HUPCL|CS8;
# endif

    /*
     * Settings for all other termios/termio based
     * systems, other than 4.4BSD.  In 4.4BSD the
     * kernel does the initial terminal setup.
     */
# if !(defined(_CRAY) || defined(__hpux)) && (BSD <= 43)
#  ifndef	OXTABS
#   define OXTABS	0
#  endif
    termbuf.c_lflag |= ECHO;
    termbuf.c_oflag |= ONLCR|OXTABS;
    termbuf.c_iflag |= ICRNL;
    termbuf.c_iflag &= ~IXOFF;
# endif
    tty_rspeed((def_rspeed > 0) ? def_rspeed : 9600);
    tty_tspeed((def_tspeed > 0) ? def_tspeed : 9600);

    /*
     * Set the tty modes, and make this our controlling tty.
     */
    set_termbuf();
    if (login_tty(t) == -1)
	fatalperror(net, "login_tty");
    if (net > 2)
	close(net);
    if (ourpty > 2) {
	close(ourpty);
	ourpty = -1;
    }
}

#ifndef	O_NOCTTY
#define	O_NOCTTY	0
#endif
/*
 * Open the specified slave side of the pty,
 * making sure that we have a clean tty.
 */

int cleanopen(char *line)
{
    int t;

#ifdef STREAMSPTY
    if (!really_stream)
#endif
	{
	    /*
	     * Make sure that other people can't open the
	     * slave side of the connection.
	     */
	    chown(line, 0, 0);
	    chmod(line, 0600);
	}

#ifdef HAVE_REVOKE
    revoke(line);
#endif

    t = open(line, O_RDWR|O_NOCTTY);

    if (t < 0)
	return(-1);

    /*
     * Hangup anybody else using this ttyp, then reopen it for
     * ourselves.
     */
# if !(defined(_CRAY) || defined(__hpux)) && (BSD <= 43) && !defined(STREAMSPTY)
    signal(SIGHUP, SIG_IGN);
#ifdef HAVE_VHANGUP
    vhangup();
#else
#endif
    signal(SIGHUP, SIG_DFL);
    t = open(line, O_RDWR|O_NOCTTY);
    if (t < 0)
	return(-1);
# endif
# if	defined(_CRAY) && defined(TCVHUP)
    {
	int i;
	signal(SIGHUP, SIG_IGN);
	ioctl(t, TCVHUP, (char *)0);
	signal(SIGHUP, SIG_DFL);

	i = open(line, O_RDWR);

	if (i < 0)
	    return(-1);
	close(t);
	t = i;
    }
# endif	/* defined(CRAY) && defined(TCVHUP) */
    return(t);
}

#if !defined(BSD4_4)

int login_tty(int t)
{
# if defined(TIOCSCTTY) && !defined(__hpux)
    if (ioctl(t, TIOCSCTTY, (char *)0) < 0)
	fatalperror(net, "ioctl(sctty)");
#  ifdef _CRAY
    /*
     * Close the hard fd to /dev/ttypXXX, and re-open through
     * the indirect /dev/tty interface.
     */
    close(t);
    if ((t = open("/dev/tty", O_RDWR)) < 0)
	fatalperror(net, "open(/dev/tty)");
#  endif
# else
    /*
     * We get our controlling tty assigned as a side-effect
     * of opening up a tty device.  But on BSD based systems,
     * this only happens if our process group is zero.  The
     * setsid() call above may have set our pgrp, so clear
     * it out before opening the tty...
     */
#ifdef HAVE_SETPGID
    setpgid(0, 0);
#else
    setpgrp(0, 0); /* if setpgid isn't available, setpgrp
		      probably takes arguments */
#endif
    close(open(line, O_RDWR));
# endif
    if (t != 0)
	dup2(t, 0);
    if (t != 1)
	dup2(t, 1);
    if (t != 2)
	dup2(t, 2);
    if (t > 2)
	close(t);
    return(0);
}
#endif	/* BSD <= 43 */

/*
 * This comes from ../../bsd/tty.c and should not really be here.
 */

/*
 * Clean the tty name.  Return a pointer to the cleaned version.
 */

static char *
clean_ttyname (char *tty)
{
  char *res = tty;

  if (strncmp (res, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
    res += sizeof(_PATH_DEV) - 1;
  if (strncmp (res, "pty/", 4) == 0)
    res += 4;
  if (strncmp (res, "ptym/", 5) == 0)
    res += 5;
  return res;
}

/*
 * Generate a name usable as an `ut_id', typically without `tty'.
 */

#ifdef HAVE_STRUCT_UTMP_UT_ID
static char *
make_id (char *tty)
{
  char *res = tty;
  
  if (strncmp (res, "pts/", 4) == 0)
    res += 4;
  if (strncmp (res, "tty", 3) == 0)
    res += 3;
  return res;
}
#endif

/*
 * startslave(host)
 *
 * Given a hostname, do whatever
 * is necessary to startup the login process on the slave side of the pty.
 */

/* ARGSUSED */
void
startslave(const char *host, const char *utmp_host,
	   int autologin, char *autoname)
{
    int i;

#ifdef AUTHENTICATION
    if (!autoname || !autoname[0])
	autologin = 0;

    if (autologin < auth_level) {
	fatal(net, "Authorization failed");
	exit(1);
    }
#endif

# ifdef	PARENT_DOES_UTMP
    utmp_sig_init();
# endif	/* PARENT_DOES_UTMP */

    if ((i = fork()) < 0)
	fatalperror(net, "fork");
    if (i) {
# ifdef PARENT_DOES_UTMP
	/*
	 * Cray parent will create utmp entry for child and send
	 * signal to child to tell when done.  Child waits for signal
	 * before doing anything important.
	 */
	int pid = i;
	void sigjob (int);

	setpgrp();
	utmp_sig_reset();		/* reset handler to default */
	/*
	 * Create utmp entry for child
	 */
	wtmp.ut_time = time(NULL);
	wtmp.ut_type = LOGIN_PROCESS;
	wtmp.ut_pid = pid;
	strncpy(wtmp.ut_user,  "LOGIN", sizeof(wtmp.ut_user));
	strncpy(wtmp.ut_host,  utmp_host, sizeof(wtmp.ut_host));
	strncpy(wtmp.ut_line,  clean_ttyname(line), sizeof(wtmp.ut_line));
#ifdef HAVE_STRUCT_UTMP_UT_ID
	strncpy(wtmp.ut_id, wtmp.ut_line + 3, sizeof(wtmp.ut_id));
#endif

	pututline(&wtmp);
	endutent();
	if ((i = open(wtmpf, O_WRONLY|O_APPEND)) >= 0) {
	    write(i, &wtmp, sizeof(struct utmp));
	    close(i);
	}
#ifdef	_CRAY
	signal(WJSIGNAL, sigjob);
#endif
	utmp_sig_notify(pid);
# endif	/* PARENT_DOES_UTMP */
    } else {
	getptyslave();
#if defined(DCE)
	/* if we authenticated via K5, try and join the PAG */
	kerberos5_dfspag();
#endif
	start_login(host, autologin, autoname);
	/*NOTREACHED*/
    }
}

char	*envinit[3];
extern char **environ;

void
init_env(void)
{
    char **envp;

    envp = envinit;
    if ((*envp = getenv("TZ")))
	*envp++ -= 3;
#if defined(_CRAY) || defined(__hpux)
    else
	*envp++ = "TZ=GMT0";
#endif
    *envp = 0;
    environ = envinit;
}

/* We won't agree with the Heimdal people about the right way to check for
 * bad environment variables, so we don't use this code.
 * See envvarok() in state.c instead.
 */
#if 0
/*
 * scrub_env()
 *
 * We only accept the environment variables listed below.
 */

static void
scrub_env(void)
{
    static const char *reject[] = {
	"TERMCAP=/",
	NULL
    };

    static const char *accept[] = {
	"XAUTH=", "XAUTHORITY=", "DISPLAY=",
	"TERM=",
	"EDITOR=",
	"PAGER=",
	"PRINTER=",
	"LOGNAME=",
	"POSIXLY_CORRECT=",
	"TERMCAP=",
	NULL
    };

    char **cpp, **cpp2;
    const char **p;
  
    for (cpp2 = cpp = environ; *cpp; cpp++) {
	int reject_it = 0;

	for(p = reject; *p; p++)
	    if(strncmp(*cpp, *p, strlen(*p)) == 0) {
		reject_it = 1;
		break;
	    }
	if (reject_it)
	    continue;

	for(p = accept; *p; p++)
	    if(strncmp(*cpp, *p, strlen(*p)) == 0)
		break;
	if(*p != NULL)
	    *cpp2++ = *cpp;
    }
    *cpp2 = NULL;
}
#endif

struct arg_val {
    int size;
    int argc;
    const char **argv;
};

static void addarg(struct arg_val*, const char*);

/*
 * start_login(host)
 *
 * Assuming that we are now running as a child processes, this
 * function will turn us into the login process.
 */

void
start_login(const char *host, int autologin, char *name)
{
    struct arg_val argv;
    char *user;
    int save_errno;
    char *buf;
    extern char *gettytab[2], *gettyent;

#ifdef HAVE_UTMPX_H
    int pid = getpid();
    struct utmpx utmpx;
    char *clean_tty;

    /*
     * Create utmp entry for child
     */

    clean_tty = clean_ttyname(line);
    memset(&utmpx, 0, sizeof(utmpx));
    strncpy(utmpx.ut_user,  ".telnet", sizeof(utmpx.ut_user));
    strncpy(utmpx.ut_line,  clean_tty, sizeof(utmpx.ut_line));
#ifdef HAVE_STRUCT_UTMP_UT_ID
    strncpy(utmpx.ut_id, make_id(clean_tty), sizeof(utmpx.ut_id));
#endif
    utmpx.ut_pid = pid;
	
    utmpx.ut_type = LOGIN_PROCESS;

    gettimeofday (&utmpx.ut_tv, NULL);
    if (pututxline(&utmpx) == NULL)
	fatal(net, "pututxline failed");
#endif

#if 0
    scrub_env();
#endif
    /*
     * -h : pass on name of host.
     *		WARNING:  -h is accepted by login if and only if
     *			getuid() == 0.
     * -p : don't clobber the environment (so terminal type stays set).
     *
     * -f : force this login, he has already been authenticated
     */

    /* init argv structure */ 
    argv.size=0;
    argv.argc=0;
    argv.argv=malloc(0); /*so we can call realloc later */
    addarg(&argv, "login");
    addarg(&argv, "-h");
    addarg(&argv, host);
    addarg(&argv, "-p");
    if(name[0])
	user = name;
    else
	user = getenv("USER");
#ifdef AUTHENTICATION
    if (auth_level < 0 || autologin != AUTH_VALID) {
	if(!no_warn) {
	    printf("User not authenticated. "
		"Using plaintext username and password\r\n");
	}
	if(log_unauth) 
	    syslog(LOG_INFO, "unauthenticated access from %s (%s)", 
		   host, user ? user : "unknown user");
    }
    if (auth_level >= 0 && autologin == AUTH_VALID)
	addarg(&argv, "-f");
#endif
    if(user){
	addarg(&argv, "--");
	addarg(&argv, strdup(user));
    }
    if (new_login == NULL && cgetent(&buf, gettytab, gettyent) >= 0) {
	cgetstr(buf, "lo", &new_login);
	cgetclose();
    }
    if (new_login == NULL)
	new_login = _PATH_LOGIN;

    if (getenv("USER")) {
	/*
	 * Assume that login will set the USER variable
	 * correctly.  For SysV systems, this means that
	 * USER will no longer be set, just LOGNAME by
	 * login.  (The problem is that if the auto-login
	 * fails, and the user then specifies a different
	 * account name, he can get logged in with both
	 * LOGNAME and USER in his environment, but the
	 * USER value will be wrong.
	 */
	unsetenv("USER");
    }
    closelog();
    /*
     * This sleep(1) is in here so that telnetd can
     * finish up with the tty.  There's a race condition
     * the login banner message gets lost...
     */
    sleep(1);

    execv(new_login, (char *const*)argv.argv);
    save_errno = errno;
    syslog(LOG_ERR, "%s: %m", new_login);
    fatalperror_errno(net, new_login, save_errno);
    /*NOTREACHED*/
}

static void
addarg(struct arg_val *argv, const char *val)
{
    const char **tmp;

    if (argv->size <= argv->argc+1) {
	tmp = realloc(argv->argv, sizeof(char*) * (argv->size + 10));
	if (tmp == NULL) {
	    if (argv->argv)
		    free(argv->argv);
	    argv->argv = NULL;
	    argv->size = 0;
	    fatal (net, "realloc: out of memory");
	}
	argv->argv = tmp;
	argv->size+=10;
    }
    argv->argv[argv->argc++] = val;
    argv->argv[argv->argc]   = NULL;
}


/*
 * rmut()
 *
 * This is the function called by cleanup() to
 * remove the utmp entry for this person.
 */

#ifdef HAVE_UTMPX_H
static void
rmut(void)
{
    struct utmpx utmpx, *non_save_utxp;
    char *clean_tty = clean_ttyname(line);

    /*
     * This updates the utmpx and utmp entries and make a wtmp/x entry
     */

    setutxent();
    memset(&utmpx, 0, sizeof(utmpx));
    strncpy(utmpx.ut_line, clean_tty, sizeof(utmpx.ut_line));
    utmpx.ut_type = LOGIN_PROCESS;
    non_save_utxp = getutxline(&utmpx);
    if (non_save_utxp) {
	struct utmpx *utxp;
	char user0;

	utxp = malloc(sizeof(struct utmpx));
	*utxp = *non_save_utxp;
	user0 = utxp->ut_user[0];
	utxp->ut_user[0] = '\0';
	utxp->ut_type = DEAD_PROCESS;
#ifdef HAVE_STRUCT_UTMPX_UT_EXIT
#ifdef _STRUCT___EXIT_STATUS
	utxp->ut_exit.__e_termination = 0;
	utxp->ut_exit.__e_exit = 0;
#elif defined(__osf__) /* XXX */
	utxp->ut_exit.ut_termination = 0;
	utxp->ut_exit.ut_exit = 0;
#else	
	utxp->ut_exit.e_termination = 0;
	utxp->ut_exit.e_exit = 0;
#endif
#endif
	gettimeofday(&utxp->ut_tv, NULL);
	pututxline(utxp);
#ifdef WTMPX_FILE
	utxp->ut_user[0] = user0;
	updwtmpx(WTMPX_FILE, utxp);
#elif defined(WTMP_FILE)
	/* This is a strange system with a utmpx and a wtmp! */
	{
	  int f = open(wtmpf, O_WRONLY|O_APPEND);
	  struct utmp wtmp;
	  if (f >= 0) {
	    strncpy(wtmp.ut_line,  clean_tty, sizeof(wtmp.ut_line));
	    strncpy(wtmp.ut_name,  "", sizeof(wtmp.ut_name));
#ifdef HAVE_STRUCT_UTMP_UT_HOST
	    strncpy(wtmp.ut_host,  "", sizeof(wtmp.ut_host));
#endif
	    wtmp.ut_time = time(NULL);
	    write(f, &wtmp, sizeof(wtmp));
	    close(f);
	  }
	}
#endif
	free (utxp);
    }
    endutxent();
}  /* end of rmut */
#endif

#if !defined(HAVE_UTMPX_H) && !(defined(_CRAY) || defined(__hpux))
static void
rmut(void)
{
    int f;
    int found = 0;
    struct utmp *u, *utmp;
    int nutmp;
    struct stat statbf;
    char *clean_tty = clean_ttyname(line);

    f = open(utmpf, O_RDWR);
    if (f >= 0) {
	fstat(f, &statbf);
	utmp = (struct utmp *)malloc((unsigned)statbf.st_size);
	if (!utmp)
	    syslog(LOG_ERR, "utmp malloc failed");
	if (statbf.st_size && utmp) {
	    nutmp = read(f, utmp, (int)statbf.st_size);
	    nutmp /= sizeof(struct utmp);

	    for (u = utmp ; u < &utmp[nutmp] ; u++) {
		if (strncmp(u->ut_line,
			    clean_tty,
			    sizeof(u->ut_line)) ||
		    u->ut_name[0]==0)
		    continue;
		lseek(f, ((long)u)-((long)utmp), L_SET);
		strncpy(u->ut_name,  "", sizeof(u->ut_name));
#ifdef HAVE_STRUCT_UTMP_UT_HOST
		strncpy(u->ut_host,  "", sizeof(u->ut_host));
#endif
		u->ut_time = time(NULL);
		write(f, u, sizeof(wtmp));
		found++;
	    }
	}
	close(f);
    }
    if (found) {
	f = open(wtmpf, O_WRONLY|O_APPEND);
	if (f >= 0) {
	    strncpy(wtmp.ut_line,  clean_tty, sizeof(wtmp.ut_line));
	    strncpy(wtmp.ut_name,  "", sizeof(wtmp.ut_name));
#ifdef HAVE_STRUCT_UTMP_UT_HOST
	    strncpy(wtmp.ut_host,  "", sizeof(wtmp.ut_host));
#endif
	    wtmp.ut_time = time(NULL);
	    write(f, &wtmp, sizeof(wtmp));
	    close(f);
	}
    }
    chmod(line, 0666);
    chown(line, 0, 0);
    line[strlen("/dev/")] = 'p';
    chmod(line, 0666);
    chown(line, 0, 0);
}  /* end of rmut */
#endif	/* CRAY */

#if defined(__hpux) && !defined(HAVE_UTMPX_H)
static void
rmut (char *line)
{
    struct utmp utmp;
    struct utmp *utptr;
    int fd;			/* for /etc/wtmp */

    utmp.ut_type = USER_PROCESS;
    strncpy(utmp.ut_line, clean_ttyname(line), sizeof(utmp.ut_line));
    setutent();
    utptr = getutline(&utmp);
    /* write it out only if it exists */
    if (utptr) {
	utptr->ut_type = DEAD_PROCESS;
	utptr->ut_time = time(NULL);
	pututline(utptr);
	/* set wtmp entry if wtmp file exists */
	if ((fd = open(wtmpf, O_WRONLY | O_APPEND)) >= 0) {
	    write(fd, utptr, sizeof(utmp));
	    close(fd);
	}
    }
    endutent();

    chmod(line, 0666);
    chown(line, 0, 0);
    line[14] = line[13];
    line[13] = line[12];
    line[8] = 'm';
    line[9] = '/';
    line[10] = 'p';
    line[11] = 't';
    line[12] = 'y';
    chmod(line, 0666);
    chown(line, 0, 0);
}
#endif

/*
 * cleanup()
 *
 * This is the routine to call when we are all through, to
 * clean up anything that needs to be cleaned up.
 */

#ifdef PARENT_DOES_UTMP

void
cleanup(int sig)
{
#ifdef _CRAY
    static int incleanup = 0;
    int t;
    int child_status; /* status of child process as returned by waitpid */
    int flags = WNOHANG|WUNTRACED;
    
    /*
     * 1: Pick up the zombie, if we are being called
     *    as the signal handler.
     * 2: If we are a nested cleanup(), return.
     * 3: Try to clean up TMPDIR.
     * 4: Fill in utmp with shutdown of process.
     * 5: Close down the network and pty connections.
     * 6: Finish up the TMPDIR cleanup, if needed.
     */
    if (sig == SIGCHLD) {
	while (waitpid(-1, &child_status, flags) > 0)
	    ;	/* VOID */
	/* Check if the child process was stopped
	 * rather than exited.  We want cleanup only if
	 * the child has died.
	 */
	if (WIFSTOPPED(child_status)) {
	    return;
	}
    }
    t = sigblock(sigmask(SIGCHLD));
    if (incleanup) {
	sigsetmask(t);
	return;
    }
    incleanup = 1;
    sigsetmask(t);
    
    t = cleantmp(&wtmp);
    setutent();	/* just to make sure */
#endif /* CRAY */
    rmut(line);
    close(ourpty);
    shutdown(net, 2);
#ifdef _CRAY
    if (t == 0)
	cleantmp(&wtmp);
#endif /* CRAY */
    exit(1);
}

#else /* PARENT_DOES_UTMP */

void
cleanup(int sig)
{
#if defined(HAVE_UTMPX_H) || !defined(HAVE_LOGWTMP)
    rmut();
#ifdef HAVE_VHANGUP
#ifndef __sgi
    vhangup(); /* XXX */
#endif
#endif
#else
    char *p;
    
    p = line + sizeof("/dev/") - 1;
    if (logout(p))
	logwtmp(p, "", "");
    chmod(line, 0666);
    chown(line, 0, 0);
    *p = 'p';
    chmod(line, 0666);
    chown(line, 0, 0);
#endif
    shutdown(net, 2);
    _exit(1);
}

#endif /* PARENT_DOES_UTMP */

#ifdef PARENT_DOES_UTMP
/*
 * _utmp_sig_rcv
 * utmp_sig_init
 * utmp_sig_wait
 *	These three functions are used to coordinate the handling of
 *	the utmp file between the server and the soon-to-be-login shell.
 *	The server actually creates the utmp structure, the child calls
 *	utmp_sig_wait(), until the server calls utmp_sig_notify() and
 *	signals the future-login shell to proceed.
 */
static int caught=0;		/* NZ when signal intercepted */
static void (*func)();		/* address of previous handler */

void
_utmp_sig_rcv(sig)
     int sig;
{
    caught = 1;
    signal(SIGUSR1, func);
}

void
utmp_sig_init()
{
    /*
     * register signal handler for UTMP creation
     */
    if ((int)(func = signal(SIGUSR1, _utmp_sig_rcv)) == -1)
	fatalperror(net, "telnetd/signal");
}

void
utmp_sig_reset()
{
    signal(SIGUSR1, func);	/* reset handler to default */
}

# ifdef __hpux
# define sigoff() /* do nothing */
# define sigon() /* do nothing */
# endif

void
utmp_sig_wait()
{
    /*
     * Wait for parent to write our utmp entry.
	 */
    sigoff();
    while (caught == 0) {
	pause();	/* wait until we get a signal (sigon) */
	sigoff();	/* turn off signals while we check caught */
    }
    sigon();		/* turn on signals again */
}

void
utmp_sig_notify(pid)
{
    kill(pid, SIGUSR1);
}

#ifdef _CRAY
static int gotsigjob = 0;

	/*ARGSUSED*/
void
sigjob(sig)
     int sig;
{
    int jid;
    struct jobtemp *jp;

    while ((jid = waitjob(NULL)) != -1) {
	if (jid == 0) {
	    return;
	}
	gotsigjob++;
	jobend(jid, NULL, NULL);
    }
}

/*
 *	jid_getutid:
 *		called by jobend() before calling cleantmp()
 *		to find the correct $TMPDIR to cleanup.
 */

struct utmp *
jid_getutid(jid)
     int jid;
{
    struct utmp *cur = NULL;

    setutent();	/* just to make sure */
    while (cur = getutent()) {
	if ( (cur->ut_type != NULL) && (jid == cur->ut_jid) ) {
	    return(cur);
	}
    }

    return(0);
}

/*
 * Clean up the TMPDIR that login created.
 * The first time this is called we pick up the info
 * from the utmp.  If the job has already gone away,
 * then we'll clean up and be done.  If not, then
 * when this is called the second time it will wait
 * for the signal that the job is done.
 */
int
cleantmp(wtp)
     struct utmp *wtp;
{
    struct utmp *utp;
    static int first = 1;
    int mask, omask, ret;
    extern struct utmp *getutid (const struct utmp *_Id);


    mask = sigmask(WJSIGNAL);

    if (first == 0) {
	omask = sigblock(mask);
	while (gotsigjob == 0)
	    sigpause(omask);
	return(1);
    }
    first = 0;
    setutent();	/* just to make sure */

    utp = getutid(wtp);
    if (utp == 0) {
	syslog(LOG_ERR, "Can't get /etc/utmp entry to clean TMPDIR");
	return(-1);
    }
    /*
     * Nothing to clean up if the user shell was never started.
     */
    if (utp->ut_type != USER_PROCESS || utp->ut_jid == 0)
	return(1);

    /*
     * Block the WJSIGNAL while we are in jobend().
     */
    omask = sigblock(mask);
    ret = jobend(utp->ut_jid, utp->ut_tpath, utp->ut_user);
    sigsetmask(omask);
    return(ret);
}

/*
 *	jobend
 *		Assumes that if path is not NULL, then user is also
 * 		not NULL.
 */
int
jobend(jid, path, user)
     int jid;
     char *path;
     char *user;
{
    static int saved_jid = 0;
    static int pty_saved_jid = 0;
    static char saved_path[sizeof(wtmp.ut_tpath)+1];
    static char saved_user[sizeof(wtmp.ut_user)+1];

    /*
     * this little piece of code comes into play
     * only when ptyreconnect is used to reconnect
     * to an previous session.
     *
     * this is the only time when the
     * "saved_jid != jid" code is executed.
     */

    if ( saved_jid && saved_jid != jid ) {
	if (!path) {	/* called from signal handler */
	    pty_saved_jid = jid;
	} else {
	    pty_saved_jid = saved_jid;
	}
    }

    if (path) {
	strncpy(saved_path, path, sizeof(saved_path) - 1);
	strncpy(saved_user, path, sizeof(saved_user) - 1);
	saved_path[sizeof(saved_path) - 1] = '\0';
	saved_user[sizeof(saved_user) - 1] = '\0';
    }
    if (saved_jid == 0) {
	saved_jid = jid;
	return(0);
    }

    /* if the jid has changed, get the correct entry from the utmp file */

    if ( saved_jid != jid ) {
	struct utmp *utp = NULL;
	struct utmp *jid_getutid();

	utp = jid_getutid(pty_saved_jid);

	if (utp == 0) {
	    syslog(LOG_ERR, "Can't get /etc/utmp entry to clean TMPDIR");
	    return(-1);
	}

	cleantmpdir(jid, utp->ut_tpath, utp->ut_user);
	return(1);
    }

    cleantmpdir(jid, saved_path, saved_user);
    return(1);
}

/*
 * Fork a child process to clean up the TMPDIR
 */
cleantmpdir(jid, tpath, user)
     int jid;
     char *tpath;
     char *user;
{
    switch(fork()) {
    case -1:
	syslog(LOG_ERR, "TMPDIR cleanup(%s): fork() failed: %m",
	       tpath);
	break;
    case 0:
	execl(CLEANTMPCMD, CLEANTMPCMD, user, tpath, (char *)NULL);
	syslog(LOG_ERR, "TMPDIR cleanup(%s): execl(%s) failed: %m",
	       tpath, CLEANTMPCMD);
	exit(1);
    default:
	/*
	 * Forget about child.  We will exit, and
	 * /etc/init will pick it up.
	 */
	break;
    }
}
#endif /* CRAY */
#endif	/* defined(PARENT_DOES_UTMP) */
@


1.37
log
@after openpty() do not close() slave and reopen it.  that is just crazy
talk.  instead, save the descriptor and reuse it. millert ok
@
text
@@


1.36
log
@Use openpty; OK deraadt@@
@
text
@d355 2
d378 1
a378 1
	close(slave);
d834 4
d865 1
@


1.35
log
@correct realloc (no ptr = realloc(ptr, ...)); comment & ok deraadt
@
text
@d372 1
a372 1
#ifdef __osf__ /* XXX */
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1379 9
a1387 3
    if(argv->size <= argv->argc+1) {
	argv->argv = realloc(argv->argv, sizeof(char*) * (argv->size + 10));
	if (argv->argv == NULL)
d1389 2
@


1.33
log
@Backout unrelated changes in last commit
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@Kill '-a otp' flag.  Our login(5) doesn't support this option and on OpenBSD
you should use login.conf(5) for this kind of thing.  Closes PR 2967.
@
text
@a1103 36
static int
fgets0(char *s, int size, FILE *f)
{
    int i, c, trunc;

    i = 0;
    trunc = 0;
    while ((c = getc(f)) != EOF && c)
	if (i < size - 1)
	    s[i++] = c;
	else
	    trunc = 1;
    s[i] = 0;

    if (c == EOF)
	fatal(-1, "fgets0: Unexpected EOF");

    return trunc;
}

extern char *goodenv_table[];
extern int envvarok(char *varp, char *valp);

static void
fgetenv(FILE *f)
{
    char **name, value[0x100];

    for (name = goodenv_table; *name; name++) {
	if (fgets0(value, sizeof(value), f) || !value[0])
	    continue;
	if (envvarok(*name, value))
	    setenv(*name, value, 1);
    }
}

d1113 2
a1114 1
startslave(const char *host, int channel[2])
a1116 6
    int autologin;
    char autoname[9];
    FILE *masterf;

    autologin = -1; /* shouldn't be used */
    autoname[0] = '\0';
a1118 2
    autologin = AUTH_REJECT;

a1170 21
	close(channel[1]);

	masterf = fdopen(channel[0], "r");
	if (!masterf)
	    fatalperror(-1, "fdopen");

#ifdef AUTHENTICATION
	if (fread(&autologin, sizeof(autologin), 1, masterf) != 1)
	    fatalperror(-1, "fread");

	if (fgets0(autoname, sizeof(autoname), masterf)) {
	    /* Truncation of a username isn't safe */
	    autologin = AUTH_REJECT;
	    autoname[0] = 0;
	}
#endif

	fgetenv(masterf);

	fclose(masterf);

@


1.31
log
@Correct string termination in jobend() for saved_path and saved_user.
OK millert@@
@
text
@d1104 36
d1149 1
a1149 2
startslave(const char *host, const char *utmp_host,
	   int autologin, char *autoname)
d1152 6
d1160 2
d1214 21
d1395 2
a1396 9
	    printf("User not authenticated. ");
	    if (require_otp)
		printf("Using one-time password\r\n");
	    else
		printf("Using plaintext username and password\r\n");
	}
	if (require_otp) {
	    addarg(&argv, "-a");
	    addarg(&argv, "otp");
@


1.30
log
@no \n for syslog()
@
text
@d1815 5
d1849 4
a1852 4
	strncpy(saved_path, path, sizeof(wtmp.ut_tpath));
	strncpy(saved_user, user, sizeof(wtmp.ut_user));
	saved_path[sizeof(saved_path)] = '\0';
	saved_user[sizeof(saved_user)] = '\0';
@


1.29
log
@use sizeof w/ defines; niklas@@ millert@@ ok.
@
text
@d1382 1
a1382 1
    syslog(LOG_ERR, "%s: %m\n", new_login);
d1885 1
a1885 1
	syslog(LOG_ERR, "TMPDIR cleanup(%s): fork() failed: %m\n",
d1890 1
a1890 1
	syslog(LOG_ERR, "TMPDIR cleanup(%s): execl(%s) failed: %m\n",
@


1.28
log
@_exit() in signal handler
@
text
@d1077 2
a1078 2
  if (strncmp (res, _PATH_DEV, strlen(_PATH_DEV)) == 0)
    res += strlen(_PATH_DEV);
@


1.27
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1656 1
a1656 1
    exit(1);
@


1.26
log
@Add back gettytab reading but use cget* instead of the obsolescent gtget*
@
text
@d1889 1
a1889 1
	execl(CLEANTMPCMD, CLEANTMPCMD, user, tpath, 0);
@


1.25
log
@-Wall -Werror cleanup
@
text
@d182 1
a182 1
     const char *new_login = _PATH_LOGIN;
d1276 2
d1352 7
@


1.24
log
@Replace our telnetd with the one from heimdal-0.3f, with the following changes:
- obvious buildsystem tweakes
- our way to filter out bad environment variables
@
text
@d1371 1
a1371 1
    execv(new_login, argv.argv);
@


1.23
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@a0 3
/*	$OpenBSD: sys_term.c,v 1.22 2001/01/17 23:51:54 deraadt Exp $	*/
/*	$NetBSD: sys_term.c,v 1.9 1996/03/20 04:25:53 tls Exp $	*/

d34 1
a34 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)sys_term.c	8.4+1 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: sys_term.c,v 1.8 1996/02/28 20:38:21 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.22 2001/01/17 23:51:54 deraadt Exp $";
#endif
#endif /* not lint */
d36 1
a36 2
#include "telnetd.h"
#include "pathnames.h"
d38 3
a40 3
#include <util.h>
#include <sys/cdefs.h>
#define P __P
d42 2
a43 2
#if	defined(AUTHENTICATION)
#include <libtelnet/auth.h>
d46 2
a47 2
#if defined(CRAY) || defined(__hpux)
# define PARENT_DOES_UTMP
d50 1
a50 6
#ifdef	NEWINIT
#include <initreq.h>
int	utmp_len = MAXHOSTNAMELEN;	/* sizeof(init_request.host) */
#else	/* NEWINIT*/
# ifdef	UTMPX
# include <utmpx.h>
d52 1
a52 2
# else
# include <utmp.h>
d54 1
a54 1
# endif /* UTMPX */
d56 1
d58 20
a77 1
# ifndef PARENT_DOES_UTMP
d79 6
a84 2
char	utmpf[] = "/etc/utmp";
# else /* PARENT_DOES_UTMP */
d86 2
a87 1
# endif /* PARENT_DOES_UTMP */
d89 1
a89 1
# ifdef CRAY
d91 1
a91 4
#include <sys/wait.h>
#  if (UNICOS_LVL == '7.0') || (UNICOS_LVL == '7.1')
#   define UNICOS7x
#  endif
d93 1
a93 8
#  ifdef UNICOS7x
#include <sys/sysv.h>
#include <sys/secstat.h>
extern int secflag;
extern struct sysv sysv;
#  endif /* UNICOS7x */
# endif	/* CRAY */
#endif	/* NEWINIT */
d95 1
a95 1
#ifdef	STREAMSPTY
d97 3
d103 1
a103 2
#define SCPYN(a, b)	(void) strncpy(a, b, sizeof(a))
#define SCMPN(a, b)	strncmp(a, b, sizeof(a))
d105 3
a107 2
#ifdef	STREAMS
#include <sys/stream.h>
d110 3
a112 2
#include <sys/resource.h>
#include <sys/proc.h>
d114 1
d116 1
d134 10
a143 2
#if defined(UNICOS5) && defined(CRAY2) && !defined(EXTPROC)
# define EXTPROC 0400
a145 16
#ifndef	USE_TERMIO
struct termbuf {
	struct sgttyb sg;
	struct tchars tc;
	struct ltchars ltc;
	int state;
	int lflags;
} termbuf, termbuf2;
# define	cfsetospeed(tp, val)	(tp)->sg.sg_ospeed = (val)
# define	cfsetispeed(tp, val)	(tp)->sg.sg_ispeed = (val)
# define	cfgetospeed(tp)		(tp)->sg.sg_ospeed
# define	cfgetispeed(tp)		(tp)->sg.sg_ispeed
#else	/* USE_TERMIO */
# ifdef	SYSV_TERMIO
#	define termios termio
# endif
d164 1
a164 1
					(tp)->c_cflag |= (val)
d168 1
a168 1
					(tp)->c_cflag |= ((val)<<IBSHIFT)
d172 1
a172 1
					(tp)->c_cflag |= (val)
d176 1
a176 1
struct termios termbuf, termbuf2;	/* pty control structure */
d178 2
a179 1
int ttyfd = -1;
a180 1
#endif	/* USE_TERMIO */
d182 1
a182 2
int cleanopen P((char *));
void scrub_env P((void));
d195 2
a196 2
	void
init_termbuf()
a197 8
#ifndef	USE_TERMIO
	(void) ioctl(pty, TIOCGETP, (char *)&termbuf.sg);
	(void) ioctl(pty, TIOCGETC, (char *)&termbuf.tc);
	(void) ioctl(pty, TIOCGLTC, (char *)&termbuf.ltc);
# ifdef	TIOCGSTATE
	(void) ioctl(pty, TIOCGSTATE, (char *)&termbuf.state);
# endif
#else
d199 3
a201 3
	(void) tcgetattr(ttyfd, &termbuf);
# else
	(void) tcgetattr(pty, &termbuf);
d203 2
a204 2
#endif
	termbuf2 = termbuf;
d207 2
a208 5
#if	defined(LINEMODE) && defined(TIOCPKT_IOCTL)
	void
copy_termbuf(cp, len)
	char *cp;
	int len;
d210 2
a211 12
	if (len > sizeof(termbuf))
		len = sizeof(termbuf);
	memmove((void *)&termbuf, cp, len);
	termbuf2 = termbuf;
}
#endif	/* defined(LINEMODE) && defined(TIOCPKT_IOCTL) */

	void
set_termbuf()
{
	/*
	 * Only make the necessary changes.
d213 1
a213 14
#ifndef	USE_TERMIO
	if (memcmp((void *)&termbuf.sg, (void *)&termbuf2.sg,
							sizeof(termbuf.sg)))
		(void) ioctl(pty, TIOCSETN, (char *)&termbuf.sg);
	if (memcmp((void *)&termbuf.tc, (void *)&termbuf2.tc,
							sizeof(termbuf.tc)))
		(void) ioctl(pty, TIOCSETC, (char *)&termbuf.tc);
	if (memcmp((void *)&termbuf.ltc, (void *)&termbuf2.ltc,
							sizeof(termbuf.ltc)))
		(void) ioctl(pty, TIOCSLTC, (char *)&termbuf.ltc);
	if (termbuf.lflags != termbuf2.lflags)
		(void) ioctl(pty, TIOCLSET, (char *)&termbuf.lflags);
#else	/* USE_TERMIO */
	if (memcmp((void *)&termbuf, (void *)&termbuf2, sizeof(termbuf)))
d215 3
a217 6
		(void) tcsetattr(ttyfd, TCSANOW, &termbuf);
# else
		(void) tcsetattr(pty, TCSANOW, &termbuf);
# endif
# if	defined(CRAY2) && defined(UNICOS5)
	needtermstat = 1;
d219 1
a219 1
#endif	/* USE_TERMIO */
d234 3
a236 81
#ifndef	USE_TERMIO
	int
spcset(func, valp, valpp)
	int func;
	cc_t *valp;
	cc_t **valpp;
{
	switch(func) {
	case SLC_EOF:
		*valp = termbuf.tc.t_eofc;
		*valpp = (cc_t *)&termbuf.tc.t_eofc;
		return(SLC_VARIABLE);
	case SLC_EC:
		*valp = termbuf.sg.sg_erase;
		*valpp = (cc_t *)&termbuf.sg.sg_erase;
		return(SLC_VARIABLE);
	case SLC_EL:
		*valp = termbuf.sg.sg_kill;
		*valpp = (cc_t *)&termbuf.sg.sg_kill;
		return(SLC_VARIABLE);
	case SLC_IP:
		*valp = termbuf.tc.t_intrc;
		*valpp = (cc_t *)&termbuf.tc.t_intrc;
		return(SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
	case SLC_ABORT:
		*valp = termbuf.tc.t_quitc;
		*valpp = (cc_t *)&termbuf.tc.t_quitc;
		return(SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
	case SLC_XON:
		*valp = termbuf.tc.t_startc;
		*valpp = (cc_t *)&termbuf.tc.t_startc;
		return(SLC_VARIABLE);
	case SLC_XOFF:
		*valp = termbuf.tc.t_stopc;
		*valpp = (cc_t *)&termbuf.tc.t_stopc;
		return(SLC_VARIABLE);
	case SLC_AO:
		*valp = termbuf.ltc.t_flushc;
		*valpp = (cc_t *)&termbuf.ltc.t_flushc;
		return(SLC_VARIABLE);
	case SLC_SUSP:
		*valp = termbuf.ltc.t_suspc;
		*valpp = (cc_t *)&termbuf.ltc.t_suspc;
		return(SLC_VARIABLE);
	case SLC_EW:
		*valp = termbuf.ltc.t_werasc;
		*valpp = (cc_t *)&termbuf.ltc.t_werasc;
		return(SLC_VARIABLE);
	case SLC_RP:
		*valp = termbuf.ltc.t_rprntc;
		*valpp = (cc_t *)&termbuf.ltc.t_rprntc;
		return(SLC_VARIABLE);
	case SLC_LNEXT:
		*valp = termbuf.ltc.t_lnextc;
		*valpp = (cc_t *)&termbuf.ltc.t_lnextc;
		return(SLC_VARIABLE);
	case SLC_FORW1:
		*valp = termbuf.tc.t_brkc;
		*valpp = (cc_t *)&termbuf.ltc.t_lnextc;
		return(SLC_VARIABLE);
	case SLC_BRK:
	case SLC_SYNCH:
	case SLC_AYT:
	case SLC_EOR:
		*valp = (cc_t)0;
		*valpp = (cc_t *)0;
		return(SLC_DEFAULT);
	default:
		*valp = (cc_t)0;
		*valpp = (cc_t *)0;
		return(SLC_NOSUPPORT);
	}
}

#else	/* USE_TERMIO */

	int
spcset(func, valp, valpp)
	int func;
	cc_t *valp;
	cc_t **valpp;
d240 2
a241 2
			*valpp = &termbuf.c_cc[a]; \
			return(b);
d244 12
a255 12
	switch(func) {
	case SLC_EOF:
		setval(VEOF, SLC_VARIABLE);
	case SLC_EC:
		setval(VERASE, SLC_VARIABLE);
	case SLC_EL:
		setval(VKILL, SLC_VARIABLE);
	case SLC_IP:
		setval(VINTR, SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
	case SLC_ABORT:
		setval(VQUIT, SLC_VARIABLE|SLC_FLUSHIN|SLC_FLUSHOUT);
	case SLC_XON:
d257 1
a257 1
		setval(VSTART, SLC_VARIABLE);
d259 1
a259 1
		defval(0x13);
d261 1
a261 1
	case SLC_XOFF:
d263 1
a263 1
		setval(VSTOP, SLC_VARIABLE);
d265 1
a265 1
		defval(0x11);
d267 1
a267 1
	case SLC_EW:
d269 1
a269 1
		setval(VWERASE, SLC_VARIABLE);
d271 1
a271 1
		defval(0);
d273 1
a273 1
	case SLC_RP:
d275 1
a275 1
		setval(VREPRINT, SLC_VARIABLE);
d277 1
a277 1
		defval(0);
d279 1
a279 1
	case SLC_LNEXT:
d281 1
a281 1
		setval(VLNEXT, SLC_VARIABLE);
d283 1
a283 1
		defval(0);
d285 1
a285 1
	case SLC_AO:
d290 1
a290 1
		setval(VDISCARD, SLC_VARIABLE|SLC_FLUSHOUT);
d292 1
a292 1
		defval(0);
d294 1
a294 1
	case SLC_SUSP:
d296 1
a296 1
		setval(VSUSP, SLC_VARIABLE|SLC_FLUSHIN);
d298 1
a298 1
		defval(0);
d301 2
a302 2
	case SLC_FORW1:
		setval(VEOL, SLC_VARIABLE);
d305 2
a306 2
	case SLC_FORW2:
		setval(VEOL2, SLC_VARIABLE);
d308 1
a308 1
	case SLC_AYT:
d310 1
a310 1
		setval(VSTATUS, SLC_VARIABLE);
d312 1
a312 1
		defval(0);
d315 4
a318 4
	case SLC_BRK:
	case SLC_SYNCH:
	case SLC_EOR:
		defval(0);
d320 5
a324 5
	default:
		*valp = 0;
		*valpp = 0;
		return(SLC_NOSUPPORT);
	}
a325 1
#endif	/* USE_TERMIO */
d327 1
a327 1
#ifdef CRAY
d333 1
a333 1
	int
d337 1
a337 1
	int numptys;
d339 3
a341 3
	if ((numptys = sysconf(_SC_CRAY_NPTY)) != -1)
		return numptys;
	else
d343 1
a343 1
		return 128;
a346 1
#ifndef	convex
d355 6
a360 4
#ifdef	CRAY
char myline[16];
#else
char line[16];
d363 2
a364 3
	int
getpty(ptynum)
int *ptynum;
d366 43
a408 1
	register int p;
d410 2
a411 2
	int t;
	char *ptsname();
d413 17
a429 15
	p = open("/dev/ptmx", O_RDWR);
	if (p > 0) {
		grantpt(p);
		unlockpt(p);
		strcpy(line, ptsname(p));
		return(p);
	}

#else	/* ! STREAMSPTY */
#ifndef CRAY
	register char *cp, *p1, *p2;
	register int i;
#if defined(sun) && defined(TIOCGPGRP) && BSD < 199207
	int dummy;
#endif
d432 26
a457 25
	(void) sprintf(line, "/dev/ptyXX");
	p1 = &line[8];
	p2 = &line[9];
#else
	(void) sprintf(line, "/dev/ptym/ptyXX");
	p1 = &line[13];
	p2 = &line[14];
#endif

	for (cp = "pqrstuvwxyzPQRST"; *cp; cp++) {
		struct stat stb;

		*p1 = *cp;
		*p2 = '0';
		/*
		 * This stat() check is just to keep us from
		 * looping through all 256 combinations if there
		 * aren't that many ptys available.
		 */
		if (stat(line, &stb) < 0)
			break;
		for (i = 0; i < 16; i++) {
			*p2 = "0123456789abcdef"[i];
			p = open(line, O_RDWR);
			if (p > 0) {
d459 1
a459 1
				line[5] = 't';
d461 16
a476 17
				for (p1 = &line[8]; *p1; p1++)
					*p1 = *(p1+1);
				line[9] = 't';
#endif
				chown(line, 0, 0);
				chmod(line, 0600);
#if defined(sun) && defined(TIOCGPGRP) && BSD < 199207
				if (ioctl(p, TIOCGPGRP, &dummy) == 0
				    || errno != EIO) {
					chmod(line, 0666);
					close(p);
					line[5] = 'p';
				} else
#endif /* defined(sun) && defined(TIOCGPGRP) && BSD < 199207 */
					return(p);
			}
		}
d478 1
d480 2
a481 2
	extern lowpty, highpty;
	struct stat sb;
d483 21
a503 31
	for (*ptynum = lowpty; *ptynum <= highpty; (*ptynum)++) {
		(void) sprintf(myline, "/dev/pty/%03d", *ptynum);
		p = open(myline, O_RDWR);
		if (p < 0)
			continue;
		(void) sprintf(line, "/dev/ttyp%03d", *ptynum);
		/*
		 * Here are some shenanigans to make sure that there
		 * are no listeners lurking on the line.
		 */
		if(stat(line, &sb) < 0) {
			(void) close(p);
			continue;
		}
		if(sb.st_uid || sb.st_gid || sb.st_mode != 0600) {
			chown(line, 0, 0);
			chmod(line, 0600);
			(void)close(p);
			p = open(myline, O_RDWR);
			if (p < 0)
				continue;
		}
		/*
		 * Now it should be safe...check for accessability.
		 */
		if (access(line, 6) == 0)
			return(p);
		else {
			/* no tty side to pty so skip it */
			(void) close(p);
		}
d505 10
d517 2
a518 41
	return(-1);
}
#endif	/* convex */

#ifdef	LINEMODE
/*
 * tty_flowmode()	Find out if flow control is enabled or disabled.
 * tty_linemode()	Find out if linemode (external processing) is enabled.
 * tty_setlinemod(on)	Turn on/off linemode.
 * tty_isecho()		Find out if echoing is turned on.
 * tty_setecho(on)	Enable/disable character echoing.
 * tty_israw()		Find out if terminal is in RAW mode.
 * tty_binaryin(on)	Turn on/off BINARY on input.
 * tty_binaryout(on)	Turn on/off BINARY on output.
 * tty_isediting()	Find out if line editing is enabled.
 * tty_istrapsig()	Find out if signal trapping is enabled.
 * tty_setedit(on)	Turn on/off line editing.
 * tty_setsig(on)	Turn on/off signal trapping.
 * tty_issofttab()	Find out if tab expansion is enabled.
 * tty_setsofttab(on)	Turn on/off soft tab expansion.
 * tty_islitecho()	Find out if typed control chars are echoed literally
 * tty_setlitecho()	Turn on/off literal echo of control chars
 * tty_tspeed(val)	Set transmit speed to val.
 * tty_rspeed(val)	Set receive speed to val.
 */

#ifdef convex
static int linestate;
#endif

	int
tty_linemode()
{
#ifndef convex
#ifndef	USE_TERMIO
	return(termbuf.state & TS_EXTPROC);
#else
	return(termbuf.c_lflag & EXTPROC);
#endif
#else
	return(linestate);
a521 24
	void
tty_setlinemode(on)
	int on;
{
#ifdef	TIOCEXT
# ifndef convex
	set_termbuf();
# else
	linestate = on;
# endif
	(void) ioctl(pty, TIOCEXT, (char *)&on);
# ifndef convex
	init_termbuf();
# endif
#else	/* !TIOCEXT */
# ifdef	EXTPROC
	if (on)
		termbuf.c_lflag |= EXTPROC;
	else
		termbuf.c_lflag &= ~EXTPROC;
# endif
#endif	/* TIOCEXT */
}
#endif	/* LINEMODE */
d523 2
a524 2
	int
tty_isecho()
d526 1
a526 15
#ifndef USE_TERMIO
	return (termbuf.sg.sg_flags & ECHO);
#else
	return (termbuf.c_lflag & ECHO);
#endif
}

	int
tty_flowmode()
{
#ifndef USE_TERMIO
	return(((termbuf.tc.t_startc) > 0 && (termbuf.tc.t_stopc) > 0) ? 1 : 0);
#else
	return((termbuf.c_iflag & IXON) ? 1 : 0);
#endif
d529 2
a530 2
	int
tty_restartany()
d532 1
a532 9
#ifndef USE_TERMIO
# ifdef	DECCTQ
	return((termbuf.lflags & DECCTQ) ? 0 : 1);
# else
	return(-1);
# endif
#else
	return((termbuf.c_iflag & IXANY) ? 1 : 0);
#endif
d535 2
a536 3
	void
tty_setecho(on)
	int on;
d538 1
a538 11
#ifndef	USE_TERMIO
	if (on)
		termbuf.sg.sg_flags |= ECHO|CRMOD;
	else
		termbuf.sg.sg_flags &= ~(ECHO|CRMOD);
#else
	if (on)
		termbuf.c_lflag |= ECHO;
	else
		termbuf.c_lflag &= ~ECHO;
#endif
d541 2
a542 2
	int
tty_israw()
d544 4
a547 5
#ifndef USE_TERMIO
	return(termbuf.sg.sg_flags & RAW);
#else
	return(!(termbuf.c_lflag & ICANON));
#endif
d550 2
a551 3
#if	defined (AUTHENTICATION) && defined(NO_LOGIN_F) && defined(LOGIN_R)
	int
tty_setraw(on)
d553 1
a553 30
#  ifndef USE_TERMIO
	if (on)
		termbuf.sg.sg_flags |= RAW;
	else
		termbuf.sg.sg_flags &= ~RAW;
#  else
	if (on)
		termbuf.c_lflag &= ~ICANON;
	else
		termbuf.c_lflag |= ICANON;
#  endif
}
#endif

	void
tty_binaryin(on)
	int on;
{
#ifndef	USE_TERMIO
	if (on)
		termbuf.lflags |= LPASS8;
	else
		termbuf.lflags &= ~LPASS8;
#else
	if (on) {
		termbuf.c_iflag &= ~ISTRIP;
	} else {
		termbuf.c_iflag |= ISTRIP;
	}
#endif
d556 2
a557 3
	void
tty_binaryout(on)
	int on;
d559 5
a563 36
#ifndef	USE_TERMIO
	if (on)
		termbuf.lflags |= LLITOUT;
	else
		termbuf.lflags &= ~LLITOUT;
#else
	if (on) {
		termbuf.c_cflag &= ~(CSIZE|PARENB);
		termbuf.c_cflag |= CS8;
		termbuf.c_oflag &= ~OPOST;
	} else {
		termbuf.c_cflag &= ~CSIZE;
		termbuf.c_cflag |= CS7|PARENB;
		termbuf.c_oflag |= OPOST;
	}
#endif
}

	int
tty_isbinaryin()
{
#ifndef	USE_TERMIO
	return(termbuf.lflags & LPASS8);
#else
	return(!(termbuf.c_iflag & ISTRIP));
#endif
}

	int
tty_isbinaryout()
{
#ifndef	USE_TERMIO
	return(termbuf.lflags & LLITOUT);
#else
	return(!(termbuf.c_oflag&OPOST));
#endif
d566 2
a567 3
#ifdef	LINEMODE
	int
tty_isediting()
d569 9
a577 5
#ifndef USE_TERMIO
	return(!(termbuf.sg.sg_flags & (CBREAK|RAW)));
#else
	return(termbuf.c_lflag & ICANON);
#endif
d580 2
a581 2
	int
tty_istrapsig()
d583 1
a583 5
#ifndef USE_TERMIO
	return(!(termbuf.sg.sg_flags&RAW));
#else
	return(termbuf.c_lflag & ISIG);
#endif
d586 2
a587 3
	void
tty_setedit(on)
	int on;
d589 1
a589 11
#ifndef USE_TERMIO
	if (on)
		termbuf.sg.sg_flags &= ~CBREAK;
	else
		termbuf.sg.sg_flags |= CBREAK;
#else
	if (on)
		termbuf.c_lflag |= ICANON;
	else
		termbuf.c_lflag &= ~ICANON;
#endif
a591 15
	void
tty_setsig(on)
	int on;
{
#ifndef	USE_TERMIO
	if (on)
		;
#else
	if (on)
		termbuf.c_lflag |= ISIG;
	else
		termbuf.c_lflag &= ~ISIG;
#endif
}
#endif	/* LINEMODE */
d593 2
a594 2
	int
tty_issofttab()
a595 3
#ifndef	USE_TERMIO
	return (termbuf.sg.sg_flags & XTABS);
#else
d597 1
a597 1
	return (termbuf.c_oflag & OXTABS);
d600 1
a600 1
	return ((termbuf.c_oflag & TABDLY) == TAB3);
a601 1
#endif
d604 2
a605 3
	void
tty_setsofttab(on)
	int on;
d607 1
a607 7
#ifndef	USE_TERMIO
	if (on)
		termbuf.sg.sg_flags |= XTABS;
	else
		termbuf.sg.sg_flags &= ~XTABS;
#else
	if (on) {
d609 1
a609 1
		termbuf.c_oflag |= OXTABS;
d612 2
a613 2
		termbuf.c_oflag &= ~TABDLY;
		termbuf.c_oflag |= TAB3;
d615 1
a615 1
	} else {
d617 1
a617 1
		termbuf.c_oflag &= ~OXTABS;
d620 2
a621 2
		termbuf.c_oflag &= ~TABDLY;
		termbuf.c_oflag |= TAB0;
d623 1
a623 2
	}
#endif
d626 2
a627 2
	int
tty_islitecho()
a628 3
#ifndef	USE_TERMIO
	return (!(termbuf.lflags & LCTLECH));
#else
d630 1
a630 1
	return (!(termbuf.c_lflag & ECHOCTL));
d633 1
a633 1
	return (!(termbuf.c_lflag & TCTLECH));
d636 1
a636 1
	return (0);	/* assumes ctl chars are echoed '^x' */
a637 1
#endif
d640 2
a641 3
	void
tty_setlitecho(on)
	int on;
a642 6
#ifndef	USE_TERMIO
	if (on)
		termbuf.lflags &= ~LCTLECH;
	else
		termbuf.lflags |= LCTLECH;
#else
d644 4
a647 4
	if (on)
		termbuf.c_lflag &= ~ECHOCTL;
	else
		termbuf.c_lflag |= ECHOCTL;
d650 4
a653 4
	if (on)
		termbuf.c_lflag &= ~TCTLECH;
	else
		termbuf.c_lflag |= TCTLECH;
a654 1
#endif
d657 2
a658 2
	int
tty_iscrnl()
d660 1
a660 5
#ifndef	USE_TERMIO
	return (termbuf.sg.sg_flags & CRMOD);
#else
	return (termbuf.c_iflag & ICRNL);
#endif
d676 2
a677 2
	int	speed;
	int	value;
d679 5
a683 5
	{ 0,      B0 },      { 50,    B50 },    { 75,     B75 },
	{ 110,    B110 },    { 134,   B134 },   { 150,    B150 },
	{ 200,    B200 },    { 300,   B300 },   { 600,    B600 },
	{ 1200,   B1200 },   { 1800,  B1800 },  { 2400,   B2400 },
	{ 4800,   B4800 },
d685 1
a685 1
	{ 7200,  B7200 },
d687 1
a687 1
	{ 9600,   B9600 },
d689 1
a689 1
	{ 14400,  B14400 },
d692 1
a692 1
	{ 19200,  B19200 },
d695 1
a695 1
	{ 28800,  B28800 },
d698 1
a698 1
	{ 38400,  B38400 },
d701 1
a701 1
	{ 57600,  B57600 },
d704 1
a704 1
	{ 115200, B115200 },
d707 1
a707 1
	{ 230400, B230400 },
d709 1
a709 1
	{ -1,     0 }
d713 2
a714 3
	void
tty_tspeed(val)
	int val;
d717 1
a717 1
	register struct termspeeds *tp;
d719 5
a723 5
	for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
		;
	if (tp->speed == -1)	/* back up to last valid value */
		--tp;
	cfsetospeed(&termbuf, tp->value);
d725 1
a725 1
	cfsetospeed(&termbuf, val);
d729 2
a730 3
	void
tty_rspeed(val)
	int val;
d733 1
a733 1
	register struct termspeeds *tp;
d735 5
a739 5
	for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
		;
	if (tp->speed == -1)	/* back up to last valid value */
		--tp;
	cfsetispeed(&termbuf, tp->value);
d741 1
a741 1
	cfsetispeed(&termbuf, val);
a744 9
#if	defined(CRAY2) && defined(UNICOS5)
	int
tty_isnewmap()
{
	return((termbuf.c_oflag & OPOST) && (termbuf.c_oflag & ONLCR) &&
			!(termbuf.c_oflag & ONLRET));
}
#endif

a745 1
# ifndef NEWINIT
a747 2
# else	/* NEWINIT */
int	gotalarm;
d749 10
a758 4
	/* ARGSUSED */
	void
nologinproc(sig)
	int sig;
d760 50
a809 1
	gotalarm++;
a810 10
# endif	/* NEWINIT */
#endif /* PARENT_DOES_UTMP */

#ifndef	NEWINIT
# ifdef PARENT_DOES_UTMP
extern void utmp_sig_init P((void));
extern void utmp_sig_reset P((void));
extern void utmp_sig_wait P((void));
extern void utmp_sig_notify P((int));
# endif /* PARENT_DOES_UTMP */
d817 2
a818 1
 * that is necessary.
d820 1
a820 2
	void
getptyslave()
d822 1
a822 1
	register int t = -1;
d824 22
a845 26
#if	!defined(CRAY) || !defined(NEWINIT)
# ifdef	LINEMODE
	int waslm;
# endif
# ifdef	TIOCGWINSZ
	struct winsize ws;
	extern int def_row, def_col;
# endif
	extern int def_tspeed, def_rspeed;
	/*
	 * Opening the slave side may cause initilization of the
	 * kernel tty structure.  We need remember the state of
	 * 	if linemode was turned on
	 *	terminal window size
	 *	terminal speed
	 * so that we can re-set them if we need to.
	 */
# ifdef	LINEMODE
	waslm = tty_linemode();
# endif


	/*
	 * Make sure that we don't have a controlling tty, and
	 * that we are the session (process group) leader.
	 */
d847 5
a851 5
	t = open(_PATH_TTY, O_RDWR);
	if (t >= 0) {
		(void) ioctl(t, TIOCNOTTY, (char *)0);
		(void) close(t);
	}
d853 1
a853 1

d856 4
a859 4
	/*
	 * Wait for our parent to get the utmp stuff to get done.
	 */
	utmp_sig_wait();
d862 3
a864 3
	t = cleanopen(line);
	if (t < 0)
		fatalperror(net, line);
d867 2
a868 12
#ifdef	USE_TERMIO
	ttyfd = t;
#endif
	if (ioctl(t, I_PUSH, "ptem") < 0)
		fatal(net, "I_PUSH ptem");
	if (ioctl(t, I_PUSH, "ldterm") < 0)
		fatal(net, "I_PUSH ldterm");
	if (ioctl(t, I_PUSH, "ttcompat") < 0)
		fatal(net, "I_PUSH ttcompat");
	if (ioctl(pty, I_PUSH, "pckt") < 0)
		fatal(net, "I_PUSH pckt");
#endif
d870 4
a873 12
	/*
	 * set up the tty modes as we like them to be.
	 */
	init_termbuf();
# ifdef	TIOCGWINSZ
	if (def_row || def_col) {
		memset((void *)&ws, 0, sizeof(ws));
		ws.ws_col = def_col;
		ws.ws_row = def_row;
		(void)ioctl(t, TIOCSWINSZ, (char *)&ws);
	}
# endif
d875 54
a928 23
	/*
	 * Settings for sgtty based systems
	 */
# ifndef	USE_TERMIO
	termbuf.sg.sg_flags |= CRMOD|ANYP|ECHO|XTABS;
# endif	/* USE_TERMIO */

	/*
	 * Settings for UNICOS (and HPUX)
	 */
# if defined(CRAY) || defined(__hpux)
	termbuf.c_oflag = OPOST|ONLCR|TAB3;
	termbuf.c_iflag = IGNPAR|ISTRIP|ICRNL|IXON;
	termbuf.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
	termbuf.c_cflag = EXTB|HUPCL|CS8;
# endif

	/*
	 * Settings for all other termios/termio based
	 * systems, other than 4.4BSD.  In 4.4BSD the
	 * kernel does the initial terminal setup.
	 */
# if defined(USE_TERMIO) && !(defined(CRAY) || defined(__hpux)) && (BSD <= 43)
d932 20
a951 32
	termbuf.c_lflag |= ECHO;
	termbuf.c_oflag |= ONLCR|OXTABS;
	termbuf.c_iflag |= ICRNL;
	termbuf.c_iflag &= ~IXOFF;
# endif /* defined(USE_TERMIO) && !defined(CRAY) && (BSD <= 43) */
	tty_rspeed((def_rspeed > 0) ? def_rspeed : 9600);
	tty_tspeed((def_tspeed > 0) ? def_tspeed : 9600);
# ifdef	LINEMODE
	if (waslm)
		tty_setlinemode(1);
# endif	/* LINEMODE */

	/*
	 * Set the tty modes, and make this our controlling tty.
	 */
	set_termbuf();
	if (login_tty(t) == -1)
		fatalperror(net, "login_tty");
#endif	/* !defined(CRAY) || !defined(NEWINIT) */
	if (net > 2)
		(void) close(net);
#if	defined(AUTHENTICATION) && defined(NO_LOGIN_F) && defined(LOGIN_R)
	/*
	 * Leave the pty open so that we can write out the rlogin
	 * protocol for /bin/login, if the authentication works.
	 */
#else
	if (pty > 2) {
		(void) close(pty);
		pty = -1;
	}
#endif
a953 1
#if	!defined(CRAY) || !defined(NEWINIT)
a960 8
	int
cleanopen(line)
	char *line;
{
	register int t;
#ifdef	UNICOS7x
	struct secstat secbuf;
#endif	/* UNICOS7x */
d962 6
a967 7
#ifndef STREAMSPTY
	/*
	 * Make sure that other people can't open the
	 * slave side of the connection.
	 */
	(void) chown(line, 0, 0);
	(void) chmod(line, 0600);
d969 7
a975 12

# if !defined(CRAY) && (BSD > 43)
	(void) revoke(line);
# endif
#ifdef	UNICOS7x
	if (secflag) {
		if (secstat(line, &secbuf) < 0)
			return(-1);
		if (setulvl(secbuf.st_slevel) < 0)
			return(-1);
		if (setucmp(secbuf.st_compart) < 0)
			return(-1);
a976 1
#endif	/* UNICOS7x */
d978 3
a980 1
	t = open(line, O_RDWR|O_NOCTTY);
d982 1
a982 8
#ifdef	UNICOS7x
	if (secflag) {
		if (setulvl(sysv.sy_minlvl) < 0)
			return(-1);
		if (setucmp(0) < 0)
			return(-1);
	}
#endif	/* UNICOS7x */
d984 2
a985 2
	if (t < 0)
		return(-1);
d987 14
a1000 11
	/*
	 * Hangup anybody else using this ttyp, then reopen it for
	 * ourselves.
	 */
# if !(defined(CRAY) || defined(__hpux)) && (BSD <= 43) && !defined(STREAMSPTY)
	(void) signal(SIGHUP, SIG_IGN);
	vhangup();
	(void) signal(SIGHUP, SIG_DFL);
	t = open(line, O_RDWR|O_NOCTTY);
	if (t < 0)
		return(-1);
d1002 14
a1015 34
# if	defined(CRAY) && defined(TCVHUP)
	{
		register int i;
		(void) signal(SIGHUP, SIG_IGN);
		(void) ioctl(t, TCVHUP, (char *)0);
		(void) signal(SIGHUP, SIG_DFL);

#ifdef	UNICOS7x
		if (secflag) {
			if (secstat(line, &secbuf) < 0)
				return(-1);
			if (setulvl(secbuf.st_slevel) < 0)
				return(-1);
			if (setucmp(secbuf.st_compart) < 0)
				return(-1);
		}
#endif	/* UNICOS7x */

		i = open(line, O_RDWR);

#ifdef	UNICOS7x
		if (secflag) {
			if (setulvl(sysv.sy_minlvl) < 0)
				return(-1);
			if (setucmp(0) < 0)
				return(-1);
		}
#endif	/* UNICOS7x */

		if (i < 0)
			return(-1);
		(void) close(t);
		t = i;
	}
d1017 1
a1017 1
	return(t);
a1018 1
#endif	/* !defined(CRAY) || !defined(NEWINIT) */
d1020 1
a1020 1
#if BSD <= 43
d1022 13
a1034 26
	int
login_tty(t)
	int t;
{
	if (setsid() < 0) {
#ifdef ultrix
		/*
		 * The setsid() may have failed because we
		 * already have a pgrp == pid.  Zero out
		 * our pgrp and try again...
		 */
		if ((setpgrp(0, 0) < 0) || (setsid() < 0))
#endif
			fatalperror(net, "setsid()");
	}
# ifdef	TIOCSCTTY
	if (ioctl(t, TIOCSCTTY, (char *)0) < 0)
		fatalperror(net, "ioctl(sctty)");
#  if defined(CRAY)
	/*
	 * Close the hard fd to /dev/ttypXXX, and re-open through
	 * the indirect /dev/tty interface.
	 */
	close(t);
	if ((t = open("/dev/tty", O_RDWR)) < 0)
		fatalperror(net, "open(/dev/tty)");
d1037 24
a1060 23
	/*
	 * We get our controlling tty assigned as a side-effect
	 * of opening up a tty device.  But on BSD based systems,
	 * this only happens if our process group is zero.  The
	 * setsid() call above may have set our pgrp, so clear
	 * it out before opening the tty...
	 */
#  ifndef SOLARIS
	(void) setpgrp(0, 0);
#  else
	(void) setpgrp();
#  endif
	close(open(line, O_RDWR));
# endif
	if (t != 0)
		(void) dup2(t, 0);
	if (t != 1)
		(void) dup2(t, 1);
	if (t != 2)
		(void) dup2(t, 2);
	if (t > 2)
		close(t);
	return(0);
d1064 38
a1101 2
#ifdef	NEWINIT
char *gen_id = "fe";
d1112 14
a1125 22
	void
startslave(host, autologin, autoname)
	char *host;
	int autologin;
	char *autoname;
{
	register int i;
#ifdef	NEWINIT
	extern char *ptyip;
	struct init_request request;
	void nologinproc();
	register int n;
#endif	/* NEWINIT */

#if	defined(AUTHENTICATION)
	if (!autoname || !autoname[0])
		autologin = 0;

	if (autologin < auth_level) {
		fatal(net, "Authorization failed");
		exit(1);
	}
a1127 2
#ifndef	NEWINIT

d1129 1
a1129 1
	utmp_sig_init();
d1132 3
a1134 3
	if ((i = fork()) < 0)
		fatalperror(net, "fork");
	if (i) {
a1135 42
		/*
		 * Cray parent will create utmp entry for child and send
		 * signal to child to tell when done.  Child waits for signal
		 * before doing anything important.
		 */
		register int pid = i;
		void sigjob P((int));

		setpgrp();
		utmp_sig_reset();		/* reset handler to default */
		/*
		 * Create utmp entry for child
		 */
		(void) time(&wtmp.ut_time);
		wtmp.ut_type = LOGIN_PROCESS;
		wtmp.ut_pid = pid;
		SCPYN(wtmp.ut_user, "LOGIN");
		SCPYN(wtmp.ut_host, host);
		SCPYN(wtmp.ut_line, line + sizeof("/dev/") - 1);
#ifndef	__hpux
		SCPYN(wtmp.ut_id, wtmp.ut_line+3);
#else
		SCPYN(wtmp.ut_id, wtmp.ut_line+7);
#endif
		pututline(&wtmp);
		endutent();
		if ((i = open(wtmpf, O_WRONLY|O_APPEND)) >= 0) {
			(void) write(i, (char *)&wtmp, sizeof(struct utmp));
			(void) close(i);
		}
#ifdef	CRAY
		(void) signal(WJSIGNAL, sigjob);
#endif
		utmp_sig_notify(pid);
# endif	/* PARENT_DOES_UTMP */
	} else {
		getptyslave(autologin);
		start_login(host, autologin, autoname);
		/*NOTREACHED*/
	}
#else	/* NEWINIT */

d1137 3
a1139 2
	 * Init will start up login process if we ask nicely.  We only wait
	 * for it to start up and begin normal telnet operation.
d1141 5
a1145 16
	if ((i = open(INIT_FIFO, O_WRONLY)) < 0) {
		char tbuf[128];
		(void) snprintf(tbuf, sizeof tbuf, "Can't open %s\n", INIT_FIFO);
		fatalperror(net, tbuf);
	}
	memset((void *)&request, 0, sizeof(request));
	request.magic = INIT_MAGIC;
	SCPYN(request.gen_id, gen_id);
	SCPYN(request.tty_id, &line[8]);
	SCPYN(request.host, host);
	SCPYN(request.term_type, terminaltype ? terminaltype : "network");
#if	!defined(UNICOS5)
	request.signal = SIGCLD;
	request.pid = getpid();
#endif
#ifdef BFTPDAEMON
d1147 1
a1147 1
	 * Are we working as the bftp daemon?
d1149 15
a1163 2
	if (bftpd) {
		SCPYN(request.exec_name, BFTPPATH);
d1165 14
a1178 28
#endif /* BFTPDAEMON */
	if (write(i, (char *)&request, sizeof(request)) < 0) {
		char tbuf[128];
		(void) snprintf(tbuf, sizeof tbuf, "Can't write to %s\n", INIT_FIFO);
		fatalperror(net, tbuf);
	}
	(void) close(i);
	(void) signal(SIGALRM, nologinproc);
	for (i = 0; ; i++) {
		char tbuf[128];
		alarm(15);
		n = read(pty, ptyip, BUFSIZ);
		if (i == 3 || n >= 0 || !gotalarm)
			break;
		gotalarm = 0;
		snprintf(tbuf, sizeof tbuf,
		    "telnetd: waiting for /etc/init to start login process on %s\r\n",
		    line);
		(void) write(net, tbuf, strlen(tbuf));
	}
	if (n < 0 && gotalarm)
		fatal(net, "/etc/init didn't start login process");
	pcc += n;
	alarm(0);
	(void) signal(SIGALRM, SIG_DFL);

	return;
#endif	/* NEWINIT */
d1184 2
a1185 2
	void
init_env()
d1187 1
a1187 2
	extern char *getenv();
	char **envp;
d1189 6
a1194 6
	envp = envinit;
	if ((*envp = getenv("TZ")))
		*envp++ -= 3;
#if	defined(CRAY) || defined(__hpux)
	else
		*envp++ = "TZ=GMT0";
d1196 2
a1197 2
	*envp = 0;
	environ = envinit;
d1200 5
a1204 2
#ifndef	NEWINIT

d1206 1
a1206 1
 * start_login(host)
d1208 1
a1208 2
 * Assuming that we are now running as a child processes, this
 * function will turn us into the login process.
d1211 33
a1243 23
	void
start_login(host, autologin, name)
	char *host;
	int autologin;
	char *name;
{
	register char **argv;
	char **addarg();
	extern char *getenv();
	extern char *gettyname;
#define	TABBUFSIZ	512
	char	defent[TABBUFSIZ];
	char	defstrs[TABBUFSIZ];
#undef	TABBUFSIZ
	char *loginprog = NULL;
#ifdef	UTMPX
	register int pid = getpid();
	struct utmpx utmpx;
#endif
#ifdef SOLARIS
	char *term;
	char termbuf[64];
#endif
d1245 8
a1252 17
#ifdef	UTMPX
	/*
	 * Create utmp entry for child
	 */

	memset((void *)&utmpx, 0, sizeof(utmpx));
	SCPYN(utmpx.ut_user, ".telnet");
	SCPYN(utmpx.ut_line, line + sizeof("/dev/") - 1);
	utmpx.ut_pid = pid;
	utmpx.ut_id[0] = 't';
	utmpx.ut_id[1] = 'n';
	utmpx.ut_id[2] = SC_WILDC;
	utmpx.ut_id[3] = SC_WILDC;
	utmpx.ut_type = LOGIN_PROCESS;
	(void) time(&utmpx.ut_tv.tv_sec);
	if (makeutx(&utmpx) == NULL)
		fatal(net, "makeutx failed");
d1255 5
a1259 1
	scrub_env();
d1261 1
a1261 9
	/*
	 * -h : pass on name of host.
	 *		WARNING:  -h is accepted by login if and only if
	 *			getuid() == 0.
	 * -p : don't clobber the environment (so terminal type stays set).
	 *
	 * -f : force this login, he has already been authenticated
	 */
	argv = addarg(0, "login");
d1263 6
a1268 1
#if	!defined(NO_LOGIN_H)
d1270 30
a1299 25
# if	defined (AUTHENTICATION) && defined(NO_LOGIN_F) && defined(LOGIN_R)
	/*
	 * Don't add the "-h host" option if we are going
	 * to be adding the "-r host" option down below...
	 */
	if ((auth_level < 0) || (autologin != AUTH_VALID))
# endif
	{
		argv = addarg(argv, "-h");
		argv = addarg(argv, host);
#ifdef	SOLARIS
		/*
		 * SVR4 version of -h takes TERM= as second arg, or -
		 */
		term = getenv("TERM");
		if (term == NULL || term[0] == 0) {
			term = "-";
		} else {
			strcpy(termbuf, "TERM=");
			strncat(termbuf, term, sizeof(termbuf) - 6);
			term = termbuf;
		}
		argv = addarg(argv, term);
#endif
	}
a1300 63
#if	!defined(NO_LOGIN_P)
	argv = addarg(argv, "-p");
#endif
#ifdef	LINEMODE
	/*
	 * Set the environment variable "LINEMODE" to either
	 * "real" or "kludge" if we are operating in either
	 * real or kludge linemode.
	 */
	if (lmodetype == REAL_LINEMODE)
		setenv("LINEMODE", "real", 1);		/* XXX mem */
# ifdef KLUDGELINEMODE
	else if (lmodetype == KLUDGE_LINEMODE || lmodetype == KLUDGE_OK)
		setenv("LINEMODE", "kludge", 1);	/* XXX mem */
# endif
#endif
#ifdef	BFTPDAEMON
	/*
	 * Are we working as the bftp daemon?  If so, then ask login
	 * to start bftp instead of shell.
	 */
	if (bftpd) {
		argv = addarg(argv, "-e");
		argv = addarg(argv, BFTPPATH);
	} else
#endif
#if	defined (AUTHENTICATION)
	if (auth_level >= 0 && autologin == AUTH_VALID) {
# if	!defined(NO_LOGIN_F)
		argv = addarg(argv, "-f");
		argv = addarg(argv, "--");
		argv = addarg(argv, name);
# else
#  if defined(LOGIN_R)
		/*
		 * We don't have support for "login -f", but we
		 * can fool /bin/login into thinking that we are
		 * rlogind, and allow us to log in without a
		 * password.  The rlogin protocol expects
		 *	local-user\0remote-user\0term/speed\0
		 */

		if (pty > 2) {
			register char *cp;
			char speed[128];
			int isecho, israw, xpty, len;
			extern int def_rspeed;
#  ifndef LOGIN_HOST
			/*
			 * Tell login that we are coming from "localhost".
			 * If we passed in the real host name, then the
			 * user would have to allow .rhost access from
			 * every machine that they want authenticated
			 * access to work from, which sort of defeats
			 * the purpose of an authenticated login...
			 * So, we tell login that the session is coming
			 * from "localhost", and the user will only have
			 * to have "localhost" in their .rhost file.
			 */
#			define LOGIN_HOST "localhost"
#  endif
			argv = addarg(argv, "-r");
			argv = addarg(argv, LOGIN_HOST);
d1302 2
a1303 45
			xpty = pty;
# ifndef  STREAMSPTY
			pty = 0;
# else
			ttyfd = 0;
# endif
			init_termbuf();
			isecho = tty_isecho();
			israw = tty_israw();
			if (isecho || !israw) {
				tty_setecho(0);		/* Turn off echo */
				tty_setraw(1);		/* Turn on raw */
				set_termbuf();
			}
			len = strlen(name)+1;
			write(xpty, name, len);
			write(xpty, name, len);
			snprintf(speed, sizeof speed,
			    "%s/%d", (cp = getenv("TERM")) ? cp : "",
			    (def_rspeed > 0) ? def_rspeed : 9600);
			len = strlen(speed)+1;
			write(xpty, speed, len);

			if (isecho || !israw) {
				init_termbuf();
				tty_setecho(isecho);
				tty_setraw(israw);
				set_termbuf();
				if (!israw) {
					/*
					 * Write a newline to ensure
					 * that login will be able to
					 * read the line...
					 */
					write(xpty, "\n", 1);
				}
			}
			pty = xpty;
		}
#  else
		argv = addarg(argv, "--");
		argv = addarg(argv, name);
#  endif
# endif
	} else
d1305 84
a1388 55
	if (getenv("USER")) {
		argv = addarg(argv, "--");
		argv = addarg(argv, getenv("USER"));
#if	defined(LOGIN_ARGS) && defined(NO_LOGIN_P)
		{
			register char **cpp;
			for (cpp = environ; *cpp; cpp++)
				argv = addarg(argv, *cpp);
		}
#endif
		/*
		 * Assume that login will set the USER variable
		 * correctly.  For SysV systems, this means that
		 * USER will no longer be set, just LOGNAME by
		 * login.  (The problem is that if the auto-login
		 * fails, and the user then specifies a different
		 * account name, he can get logged in with both
		 * LOGNAME and USER in his environment, but the
		 * USER value will be wrong.
		 */
		unsetenv("USER");
	}
#ifdef	SOLARIS
	else {
		char **p;

		argv = addarg(argv, "");	/* no login name */
		for (p = environ; *p; p++) {
			argv = addarg(argv, *p);
		}
	}
#endif	/* SOLARIS */
#if	defined(AUTHENTICATION) && defined(NO_LOGIN_F) && defined(LOGIN_R)
	if (pty > 2)
		close(pty);
#endif
	if (gtgetent(defent, gettyname) == 1) {
		char *cp = defstrs;

		loginprog = gtgetstr("lo", &cp);
	}
	if (loginprog == NULL)
		loginprog = _PATH_LOGIN;
	closelog();
	/*
	 * This sleep(1) is in here so that telnetd can
	 * finish up with the tty.  There's a race condition
	 * the login banner message gets lost...
	 */
	sleep(1);
	execv(loginprog, argv);

	syslog(LOG_ERR, "%s: %m", loginprog);
	fatalperror(net, loginprog);
	/*NOTREACHED*/
a1390 33
	char **
addarg(argv, val)
	register char **argv;
	register char *val;
{
	register char **cpp;

	if (argv == NULL) {
		/*
		 * 10 entries, a leading length, and a null
		 */
		argv = (char **)malloc(sizeof(*argv) * 12);
		if (argv == NULL)
			return(NULL);
		*argv++ = (char *)10;
		*argv = (char *)0;
	}
	for (cpp = argv; *cpp; cpp++)
		;
	if (cpp == &argv[(long)argv[-1]]) {
		--argv;
		*argv = (char *)((long)(*argv) + 10);
		argv = (char **)realloc(argv, sizeof(*argv)*((long)(*argv) + 2));
		if (argv == NULL)
			return(NULL);
		argv++;
		cpp = &argv[(long)argv[-1] - 10];
	}
	*cpp++ = val;
	*cpp = 0;
	return(argv);
}
#endif	/* NEWINIT */
d1393 1
a1393 1
 * scrub_env()
d1395 2
a1396 2
 * Remove a few things from the environment that
 * don't need to be there.
a1397 4
	void
scrub_env()
{
	register char **cpp, **cpp2;
d1399 161
a1559 13
	for (cpp2 = cpp = environ; *cpp; cpp++) {
		if (strncmp(*cpp, "LD_", 3) &&
		    strncmp(*cpp, "_RLD_", 5) &&
		    strncmp(*cpp, "LIBPATH=", 8) &&
		    strncmp(*cpp, "TERMINFO=", 9) &&
		    strncmp(*cpp, "TERMINFO_DIRS=", 14) &&
		    strncmp(*cpp, "TERMPATH=", 9) &&
		    strncmp(*cpp, "TERMCAP=/", 9) &&
		    strncmp(*cpp, "ENV=", 4) &&
		    strncmp(*cpp, "IFS=", 4))
			*cpp2++ = *cpp;
	}
	*cpp2 = 0;
d1561 1
a1568 21
	/* ARGSUSED */
	void
cleanup(sig)
	int sig;
{
#ifndef	PARENT_DOES_UTMP
# if (BSD > 43) || defined(convex)
	char *p;

	p = line + sizeof("/dev/") - 1;
	if (logout(p))
		logwtmp(p, "", "");
	(void)chmod(line, 0666);
	(void)chown(line, 0, 0);
	*p = 'p';
	(void)chmod(line, 0666);
	(void)chown(line, 0, 0);
	(void) shutdown(net, 2);
	_exit(1);
# else
	void rmut();
d1570 1
a1570 15
	rmut();
	vhangup();	/* XXX */
	(void) shutdown(net, 2);
	_exit(1);
# endif
#else	/* PARENT_DOES_UTMP */
# ifdef	NEWINIT
	(void) shutdown(net, 2);
	_exit(1);
# else	/* NEWINIT */
#  ifdef CRAY
	static int incleanup = 0;
	register int t;
	int child_status; /* status of child process as returned by waitpid */
	int flags = WNOHANG|WUNTRACED;
d1572 31
a1602 26
	/*
	 * 1: Pick up the zombie, if we are being called
	 *    as the signal handler.
	 * 2: If we are a nested cleanup(), return.
	 * 3: Try to clean up TMPDIR.
	 * 4: Fill in utmp with shutdown of process.
	 * 5: Close down the network and pty connections.
	 * 6: Finish up the TMPDIR cleanup, if needed.
	 */
	if (sig == SIGCHLD) {
		while (waitpid(-1, &child_status, flags) > 0)
			;	/* VOID */
		/* Check if the child process was stopped
		 * rather than exited.  We want cleanup only if
		 * the child has died.
		 */
		if (WIFSTOPPED(child_status)) {
			return;
		}
	}
	t = sigblock(sigmask(SIGCHLD));
	if (incleanup) {
		sigsetmask(t);
		return;
	}
	incleanup = 1;
d1604 16
a1619 25
#ifdef	UNICOS7x
	if (secflag) {
		/*
		 *	We need to set ourselves back to a null
		 *	label to clean up.
		 */

		setulvl(sysv.sy_minlvl);
		setucmp((long)0);
	}
#endif	/* UNICOS7x */

	t = cleantmp(&wtmp);
	setutent();	/* just to make sure */
#  endif /* CRAY */
	rmut(line);
	close(pty);
	(void) shutdown(net, 2);
#  ifdef CRAY
	if (t == 0)
		cleantmp(&wtmp);
#  endif /* CRAY */
	_exit(1);
# endif	/* NEWINT */
#endif	/* PARENT_DOES_UTMP */
d1622 31
a1652 1
#if defined(PARENT_DOES_UTMP) && !defined(NEWINIT)
d1666 1
a1666 1
	void
d1668 1
a1668 1
	int sig;
d1670 2
a1671 2
	caught = 1;
	(void) signal(SIGUSR1, func);
d1674 1
a1674 1
	void
d1677 5
a1681 5
	/*
	 * register signal handler for UTMP creation
	 */
	if ((int)(func = signal(SIGUSR1, _utmp_sig_rcv)) == -1)
		fatalperror(net, "telnetd/signal");
d1684 1
a1684 1
	void
d1687 1
a1687 1
	(void) signal(SIGUSR1, func);	/* reset handler to default */
d1695 1
a1695 1
	void
d1698 2
a1699 2
	/*
	 * Wait for parent to write our utmp entry.
d1701 6
a1706 6
	sigoff();
	while (caught == 0) {
		pause();	/* wait until we get a signal (sigon) */
		sigoff();	/* turn off signals while we check caught */
	}
	sigon();		/* turn on signals again */
d1709 1
a1709 1
	void
d1712 1
a1712 1
	kill(pid, SIGUSR1);
d1715 1
a1715 1
# ifdef CRAY
d1719 1
a1719 1
	void
d1721 1
a1721 1
	int sig;
d1723 2
a1724 2
	register int jid;
	register struct jobtemp *jp;
d1726 7
a1732 7
	while ((jid = waitjob(NULL)) != -1) {
		if (jid == 0) {
			return;
		}
		gotsigjob++;
		jobend(jid, NULL, NULL);
	}
d1741 1
a1741 1
	struct utmp *
d1743 1
a1743 1
	int jid;
d1745 1
a1745 1
	struct utmp *cur = NULL;
d1747 4
a1750 5
	setutent();	/* just to make sure */
	while (cur = getutent()) {
		if ( (cur->ut_type != NULL) && (jid == cur->ut_jid) ) {
			return(cur);
		}
d1752 1
d1754 1
a1754 1
	return(0);
d1765 1
a1765 1
	int
d1767 1
a1767 1
	register struct utmp *wtp;
d1769 4
a1772 4
	struct utmp *utp;
	static int first = 1;
	register int mask, omask, ret;
	extern struct utmp *getutid P((const struct utmp *_Id));
d1775 1
a1775 1
	mask = sigmask(WJSIGNAL);
d1777 19
a1795 19
	if (first == 0) {
		omask = sigblock(mask);
		while (gotsigjob == 0)
			sigpause(omask);
		return(1);
	}
	first = 0;
	setutent();	/* just to make sure */

	utp = getutid(wtp);
	if (utp == 0) {
		syslog(LOG_ERR, "Can't get /etc/utmp entry to clean TMPDIR");
		return(-1);
	}
	/*
	 * Nothing to clean up if the user shell was never started.
	 */
	if (utp->ut_type != USER_PROCESS || utp->ut_jid == 0)
		return(1);
d1797 7
a1803 7
	/*
	 * Block the WJSIGNAL while we are in jobend().
	 */
	omask = sigblock(mask);
	ret = jobend(utp->ut_jid, utp->ut_tpath, utp->ut_user);
	sigsetmask(omask);
	return(ret);
d1806 1
a1806 1
	int
d1808 23
a1830 24
	register int jid;
	register char *path;
	register char *user;
{
	static int saved_jid = 0;
	static int pty_saved_jid = 0;
	static char saved_path[sizeof(wtmp.ut_tpath)+1];
	static char saved_user[sizeof(wtmp.ut_user)+1];

	/*
	 * this little piece of code comes into play
	 * only when ptyreconnect is used to reconnect
	 * to an previous session.
	 *
	 * this is the only time when the
	 * "saved_jid != jid" code is executed.
	 */

	if ( saved_jid && saved_jid != jid ) {
		if (!path) {	/* called from signal handler */
			pty_saved_jid = jid;
		} else {
			pty_saved_jid = saved_jid;
		}
d1832 1
d1834 10
a1843 8
	if (path) {
		strlcpy(saved_path, path, sizeof(saved_path));
		strlcpy(saved_user, user, sizeof(saved_user));
	}
	if (saved_jid == 0) {
		saved_jid = jid;
		return(0);
	}
d1845 1
a1845 1
	/* if the jid has changed, get the correct entry from the utmp file */
d1847 3
a1849 3
	if ( saved_jid != jid ) {
		struct utmp *utp = NULL;
		struct utmp *jid_getutid();
d1851 1
a1851 1
		utp = jid_getutid(pty_saved_jid);
d1853 3
a1855 7
		if (utp == 0) {
			syslog(LOG_ERR, "Can't get /etc/utmp entry to clean TMPDIR");
			return(-1);
		}

		cleantmpdir(jid, utp->ut_tpath, utp->ut_user);
		return(1);
d1858 1
a1858 1
	cleantmpdir(jid, saved_path, saved_user);
d1860 4
d1870 15
a1884 44
	register int jid;
	register char *tpath;
	register char *user;
{
	switch(fork()) {
	case -1:
		syslog(LOG_ERR, "TMPDIR cleanup(%s): fork() failed: %m",
							tpath);
		break;
	case 0:
		execl(CLEANTMPCMD, CLEANTMPCMD, user, tpath, 0);
		syslog(LOG_ERR, "TMPDIR cleanup(%s): execl(%s) failed: %m",
							tpath, CLEANTMPCMD);
		exit(1);
	default:
		/*
		 * Forget about child.  We will exit, and
		 * /etc/init will pick it up.
		 */
		break;
	}
}
# endif /* CRAY */
#endif	/* defined(PARENT_DOES_UTMP) && !defined(NEWINIT) */

/*
 * rmut()
 *
 * This is the function called by cleanup() to
 * remove the utmp entry for this person.
 */

#ifdef	UTMPX
	void
rmut()
{
	register f;
	int found = 0;
	struct utmp *u, *utmp;
	int nutmp;
	struct stat statbf;

	struct utmpx *utxp, utmpx;

d1886 2
a1887 1
	 * This updates the utmpx and utmp entries and make a wtmp/x entry
d1889 2
a1890 105

	SCPYN(utmpx.ut_line, line + sizeof("/dev/") - 1);
	utxp = getutxline(&utmpx);
	if (utxp) {
		utxp->ut_type = DEAD_PROCESS;
		utxp->ut_exit.e_termination = 0;
		utxp->ut_exit.e_exit = 0;
		(void) time(&utmpx.ut_tv.tv_sec);
		utmpx.ut_tv.tv_usec = 0;
		modutx(utxp);
	}
	endutxent();
}  /* end of rmut */
#endif

#if	!defined(UTMPX) && !(defined(CRAY) || defined(__hpux)) && BSD <= 43
	void
rmut()
{
	register f;
	int found = 0;
	struct utmp *u, *utmp;
	int nutmp;
	struct stat statbf;

	f = open(utmpf, O_RDWR);
	if (f >= 0) {
		(void) fstat(f, &statbf);
		utmp = (struct utmp *)malloc((unsigned)statbf.st_size);
		if (!utmp)
			syslog(LOG_ERR, "utmp malloc failed");
		if (statbf.st_size && utmp) {
			nutmp = read(f, (char *)utmp, (int)statbf.st_size);
			nutmp /= sizeof(struct utmp);

			for (u = utmp ; u < &utmp[nutmp] ; u++) {
				if (SCMPN(u->ut_line, line+5) ||
				    u->ut_name[0]==0)
					continue;
				(void) lseek(f, ((off_t)u)-((off_t)utmp),
				    SEEK_SET);
				SCPYN(u->ut_name, "");
				SCPYN(u->ut_host, "");
				(void) time(&u->ut_time);
				(void) write(f, (char *)u, sizeof(wtmp));
				found++;
			}
		}
		(void) close(f);
	}
	if (found) {
		f = open(wtmpf, O_WRONLY|O_APPEND);
		if (f >= 0) {
			SCPYN(wtmp.ut_line, line+5);
			SCPYN(wtmp.ut_name, "");
			SCPYN(wtmp.ut_host, "");
			(void) time(&wtmp.ut_time);
			(void) write(f, (char *)&wtmp, sizeof(wtmp));
			(void) close(f);
		}
	}
	(void) chmod(line, 0666);
	(void) chown(line, 0, 0);
	line[strlen("/dev/")] = 'p';
	(void) chmod(line, 0666);
	(void) chown(line, 0, 0);
}  /* end of rmut */
#endif	/* CRAY */

#ifdef __hpux
rmut (line)
char *line;
{
	struct utmp utmp;
	struct utmp *utptr;
	int fd;			/* for /etc/wtmp */

	utmp.ut_type = USER_PROCESS;
	(void) strncpy(utmp.ut_id, line+12, sizeof(utmp.ut_id));
	(void) setutent();
	utptr = getutid(&utmp);
	/* write it out only if it exists */
	if (utptr) {
		utptr->ut_type = DEAD_PROCESS;
		utptr->ut_time = time((time_t *) 0);
		(void) pututline(utptr);
		/* set wtmp entry if wtmp file exists */
		if ((fd = open(wtmpf, O_WRONLY | O_APPEND)) >= 0) {
			(void) write(fd, utptr, sizeof(utmp));
			(void) close(fd);
		}
	}
	(void) endutent();

	(void) chmod(line, 0666);
	(void) chown(line, 0, 0);
	line[14] = line[13];
	line[13] = line[12];
	line[8] = 'm';
	line[9] = '/';
	line[10] = 'p';
	line[11] = 't';
	line[12] = 'y';
	(void) chmod(line, 0666);
	(void) chown(line, 0, 0);
d1892 2
a1893 1
#endif
@


1.22
log
@signal handler should finish using _exit()
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.21 2000/11/16 19:00:19 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.21 2000/11/16 19:00:19 millert Exp $";
d2141 2
a2142 4
		strncpy(saved_path, path, sizeof(wtmp.ut_tpath));
		strncpy(saved_user, user, sizeof(wtmp.ut_user));
		saved_path[sizeof(saved_path)] = '\0';
		saved_user[sizeof(saved_user)] = '\0';
@


1.21
log
@Don't use sizeof() a pointer as a length parameter.  This change makes
'line' from sys_term.c from a char * into a char array.  There's no
need to explicitly initialize the contents to 0 since that happens
for globals anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.20 2000/10/10 12:59:46 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.20 2000/10/10 12:59:46 millert Exp $";
d1884 1
a1884 1
	exit(1);
d1891 1
a1891 1
	exit(1);
d1896 1
a1896 1
	exit(1);
d1953 1
a1953 1
	exit(1);
@


1.20
log
@Prune the following environment variables:
    TERMINFO
    TERMINFO_DIRS
    TERMPATH
    TERMCAP (only if it starts with a '/')
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.19 2000/09/15 07:13:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.19 2000/09/15 07:13:47 deraadt Exp $";
d477 2
a478 2
#ifndef	__GNUC__
char *line = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
d480 1
a480 5
static char Xline[] = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
char *line = Xline;
#endif
#ifdef	CRAY
char *myline = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
@


1.19
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.18 1999/08/17 09:13:13 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.18 1999/08/17 09:13:13 millert Exp $";
d1853 4
@


1.18
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.17 1998/07/28 20:18:20 marc Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.17 1998/07/28 20:18:20 marc Exp $";
d1647 1
a1647 1
		setenv("LINEMODE", "real", 1);
d1650 1
a1650 1
		setenv("LINEMODE", "kludge", 1);
@


1.18.4.1
log
@Pull in patch from current:
Errata (029):
The telnet daemon does not strip out the TERMINFO, TERMINFO_DIRS, TERMPATH
and TERMCAP (when it starts with a '/') environment variables.
Fix (millert):
Prune the following environment variables:
    TERMINFO
    TERMINFO_DIRS
    TERMPATH
    TERMCAP (only if it starts with a '/')
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.18 1999/08/17 09:13:13 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.18 1999/08/17 09:13:13 millert Exp $";
a1852 4
		    strncmp(*cpp, "TERMINFO=", 9) &&
		    strncmp(*cpp, "TERMINFO_DIRS=", 14) &&
		    strncmp(*cpp, "TERMPATH=", 9) &&
		    strncmp(*cpp, "TERMCAP=/", 9) &&
@


1.17
log
@change getent/getstr to gtgettent/gtgetstr, the names now used

in libtelnet; add prototypes for both functions to ext.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.16 1998/07/23 17:55:51 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.16 1998/07/23 17:55:51 deraadt Exp $";
d496 1
a496 1
	p = open("/dev/ptmx", 2);
d536 1
a536 1
			p = open(line, 2);
d565 1
a565 1
		p = open(myline, 2);
d581 1
a581 1
			p = open(myline, 2);
@


1.16
log
@delete SecurID hacks
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.15 1998/07/13 02:11:20 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.15 1998/07/13 02:11:20 millert Exp $";
a1562 1
	extern char *getstr();
d1783 1
a1783 1
	if (getent(defent, gettyname) == 1) {
d1786 1
a1786 1
		loginprog = getstr("lo", &cp);
@


1.15
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.14 1998/07/10 08:06:23 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.14 1998/07/10 08:06:23 deraadt Exp $";
a1662 8
#endif
#if	defined (SecurID)
	/*
	 * don't worry about the -f that might get sent.
	 * A -s is supposed to override it anyhow.
	 */
	if (require_SecurID)
		argv = addarg(argv, "-s");
@


1.14
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.13 1998/05/08 19:32:33 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.13 1998/05/08 19:32:33 deraadt Exp $";
d2271 2
a2272 1
				(void) lseek(f, ((off_t)u)-((off_t)utmp), L_SET);
@


1.13
log
@sprintf removals
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.12 1998/04/25 04:43:02 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.12 1998/04/25 04:43:02 millert Exp $";
d1808 1
a1808 1
	syslog(LOG_ERR, "%s: %m\n", loginprog);
d2191 1
a2191 1
		syslog(LOG_ERR, "TMPDIR cleanup(%s): fork() failed: %m\n",
d2196 1
a2196 1
		syslog(LOG_ERR, "TMPDIR cleanup(%s): execl(%s) failed: %m\n",
@


1.12
log
@Fix casts in args to mem*.  Boy am I anal.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.11 1998/04/01 08:28:19 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.11 1998/04/01 08:28:19 deraadt Exp $";
d1475 1
a1475 1
		(void) sprintf(tbuf, "Can't open %s\n", INIT_FIFO);
d1498 1
a1498 1
		(void) sprintf(tbuf, "Can't write to %s\n", INIT_FIFO);
d1510 3
a1512 1
		sprintf(tbuf, "telnetd: waiting for /etc/init to start login process on %s\r\n", line);
d1727 3
a1729 2
			sprintf(speed, "%s/%d", (cp = getenv("TERM")) ? cp : "",
				(def_rspeed > 0) ? def_rspeed : 9600);
@


1.11
log
@remove eavesdropping warning. Sorry, this is a no-way
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.10 1998/03/25 18:43:48 art Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.10 1998/03/25 18:43:48 art Exp $";
d228 1
a228 1
	memmove((char *)&termbuf, cp, len);
d240 1
a240 1
	if (memcmp((char *)&termbuf.sg, (char *)&termbuf2.sg,
d243 1
a243 1
	if (memcmp((char *)&termbuf.tc, (char *)&termbuf2.tc,
d246 1
a246 1
	if (memcmp((char *)&termbuf.ltc, (char *)&termbuf2.ltc,
d252 1
a252 1
	if (memcmp((char *)&termbuf, (char *)&termbuf2, sizeof(termbuf)))
d1153 1
a1153 1
		memset((char *)&ws, 0, sizeof(ws));
d1478 1
a1478 1
	memset((char *)&request, 0, sizeof(request));
d1582 1
a1582 1
	memset(&utmpx, 0, sizeof(utmpx));
@


1.10
log
@cleanup and please -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.9 1998/03/12 04:53:14 art Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.9 1998/03/12 04:53:14 art Exp $";
a1417 9
	{
		char *tbuf =
		"\r\n*** Connection not encrypted! "
		"Communication may be eavesdropped. ***\r\n";
#ifdef ENCRYPTION
		if (encrypt_output == 0 || decrypt_input == 0)
#endif
			writenet((unsigned char*)tbuf, strlen(tbuf));
	}
@


1.9
log
@Encryption from kth-krb 0.9.8 (only for those with kerberos)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.8 1997/07/23 20:36:35 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.8 1997/07/23 20:36:35 kstailey Exp $";
d1576 1
a1576 1
	char *loginprog;
@


1.8
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.7 1997/07/14 01:40:38 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.7 1997/07/14 01:40:38 millert Exp $";
d1418 10
@


1.7
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.6 1997/02/16 05:59:43 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.6 1997/02/16 05:59:43 deraadt Exp $";
d1788 2
a1789 2
        if (getent(defent, gettyname) == 1) {
                char *cp = defstrs;
d1791 4
a1794 4
                loginprog = getstr("lo", &cp);
        }
        if (loginprog == NULL)
                loginprog = _PATH_LOGIN;
d1802 1
a1802 1
        execv(loginprog, argv);
d1804 2
a1805 2
        syslog(LOG_ERR, "%s: %m\n", loginprog);
        fatalperror(net, loginprog);
@


1.6
log
@block $ENV too, sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.5 1996/12/23 14:29:46 robin Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.5 1996/12/23 14:29:46 robin Exp $";
d49 1
d186 3
d1080 1
a1080 2
 * that is necessary.  The return value is a file descriptor
 * for the slave side.
d1082 1
a1082 1
	int
a1399 1
	char name[256];
a1556 1
	register char *cp;
d1849 1
d2267 1
a2267 1
				(void) lseek(f, ((long)u)-((long)utmp), L_SET);
d2311 1
a2311 1
		utptr->ut_time = time((long *) 0);
@


1.5
log
@Fix assignment/truth-value compiler warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.4 1996/04/23 03:03:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.4 1996/04/23 03:03:47 deraadt Exp $";
d1856 1
@


1.4
log
@sync with netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_term.c,v 1.3 1996/03/28 23:22:00 niklas Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: sys_term.c,v 1.3 1996/03/28 23:22:00 niklas Exp $";
d1530 1
a1530 1
	if (*envp = getenv("TZ"))
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sys_term.c,v 1.8 1996/02/28 20:38:21 thorpej Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d1559 7
d1787 7
d1801 1
a1801 1
	execv(_PATH_LOGIN, argv);
d1803 2
a1804 2
	syslog(LOG_ERR, "%s: %m\n", _PATH_LOGIN);
	fatalperror(net, _PATH_LOGIN);
@


1.2
log
@From NetBSD:
Make sure that the user name cannot ever be interpreted as an option to
login(8).  Note: This does *not* fix any security holes.
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)sys_term.c	8.1 (Berkeley) 6/4/93"; */
static char *rcsid = "$Id: sys_term.c,v 1.1.1.1 1995/10/18 08:43:24 deraadt Exp $";
d49 3
d83 2
a84 7
#  if defined(_SC_CRAY_SECURE_SYS) && !defined(SCM_SECURITY)
   /*
    * UNICOS 6.0/6.1 do not have SCM_SECURITY defined, so we can
    * use it to tell us to turn off all the socket security code,
    * since that is only used in UNICOS 7.0 and later.
    */
#   undef _SC_CRAY_SECURE_SYS
d87 1
a87 1
#  if defined(_SC_CRAY_SECURE_SYS)
d92 1
a92 1
#  endif /* _SC_CRAY_SECURE_SYS */
d224 1
a224 1
	bcopy(cp, (char *)&termbuf, len);
d236 2
a237 1
	if (bcmp((char *)&termbuf.sg, (char *)&termbuf2.sg, sizeof(termbuf.sg)))
d239 2
a240 1
	if (bcmp((char *)&termbuf.tc, (char *)&termbuf2.tc, sizeof(termbuf.tc)))
d242 1
a242 1
	if (bcmp((char *)&termbuf.ltc, (char *)&termbuf2.ltc,
d248 1
a248 1
	if (bcmp((char *)&termbuf, (char *)&termbuf2, sizeof(termbuf)))
d954 9
d969 31
a999 6
	{ 0,     B0 },    { 50,    B50 },   { 75,    B75 },
	{ 110,   B110 },  { 134,   B134 },  { 150,   B150 },
	{ 200,   B200 },  { 300,   B300 },  { 600,   B600 },
	{ 1200,  B1200 }, { 1800,  B1800 }, { 2400,  B2400 },
	{ 4800,  B4800 }, { 9600,  B9600 }, { 19200, B9600 },
	{ 38400, B9600 }, { -1,    B9600 }
d1001 1
d1007 1
d1012 2
d1015 3
d1024 1
d1029 2
d1032 3
d1134 1
a1134 1
	if (ioctl(t, I_PUSH, "ptem") < 0) 
d1150 1
a1150 1
		bzero((char *)&ws, sizeof(ws));
d1230 1
a1230 1
#if	defined(_SC_CRAY_SECURE_SYS)
d1232 1
a1232 1
#endif	/* _SC_CRAY_SECURE_SYS */
d1246 1
a1246 1
#if	defined(_SC_CRAY_SECURE_SYS)
d1255 1
a1255 1
#endif	/* _SC_CRAY_SECURE_SYS */
d1259 1
a1259 1
#if	defined(_SC_CRAY_SECURE_SYS)
d1266 1
a1266 1
#endif	/* _SC_CRAY_SECURE_SYS */
a1288 1
		setpgrp();
d1290 1
a1290 1
#if		defined(_SC_CRAY_SECURE_SYS)
d1299 1
a1299 1
#endif		/* _SC_CRAY_SECURE_SYS */
d1303 1
a1303 1
#if		defined(_SC_CRAY_SECURE_SYS)
d1310 1
a1310 1
#endif		/* _SC_CRAY_SECURE_SYS */
d1359 1
d1361 3
d1573 1
a1573 1
	bzero(&utmpx, sizeof(utmpx));
d1587 2
d1630 13
d1651 1
a1651 1
	} else 
d1766 10
d1781 6
d1816 1
a1816 1
		argv = (char **)realloc(argv, (long)(*argv) + 2);
d1829 20
d1889 2
d1901 2
a1902 2
	if (sig == SIGCHLD)
		while (waitpid(-1, 0, WNOHANG) > 0)
d1904 8
d1919 1
d1929 1
d2030 22
d2107 1
d2111 17
d2138 18
d2245 1
a2245 1
		
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: sys_term.c,v 1.4 1994/12/23 14:29:46 cgd Exp $";
d1593 1
d1666 1
d1673 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

