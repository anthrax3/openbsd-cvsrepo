head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.8
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.10
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.18.0.30
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.28
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.24
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.22
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.20
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.18
	OPENBSD_5_0:1.18.0.16
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.14
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.12
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.22
date	2015.05.18.16.04.21;	author reyk;	state Exp;
branches;
next	1.21;
commitid	BUauTTbpwkWg0A95;

1.21
date	2015.01.13.21.42.59;	author millert;	state Exp;
branches;
next	1.20;
commitid	FcrTmS5RaNh0dgrr;

1.20
date	2015.01.08.22.10.08;	author millert;	state Exp;
branches;
next	1.19;
commitid	YsfBV9Rw2AVnH1rZ;

1.19
date	2014.10.11.03.25.16;	author doug;	state Exp;
branches;
next	1.18;
commitid	M502KacAFZHswlVa;

1.18
date	2007.11.03.19.16.07;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.02.15.19.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.26.16.36.18;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.05.02.10.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.23.19.36.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.04.09.48.27;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.26.07.28.55;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.26.16.07.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.20.00.43.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.22.22.23;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.03.20.17.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.03.14.47.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.02.20.40.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.02.20.32.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.02.19.22.00;	author beck;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Change spamd to use divert-to instead of rdr-to.

divert-to has many advantages over rdr-to for proxies.  For example,
it is much easier to use, requires less code, does not depend on
/dev/pf, works in-band without the asynchronous lookup (DIOCNATLOOK
ioctl), saves us from additional port allocations by the rdr/NAT code,
and even avoids potential collisions and race conditions that could
theoretically happen with the lookup.

Heads up: users will have to update their spamd PF rules from rdr-to
to divert-to.  spamd now also listens to 127.0.0.1 instead of "any"
(0.0.0.0) by default which should be fine with most setups but has to
be considered for some special configurations.

Based on a diff is almost two years old but got delayed several times
... beck@@: "now is the time to get it in" :)

Tested by many
With help from okan@@
OK okan@@ beck@@ millert@@
@
text
@/*	$OpenBSD: sdl.c,v 1.21 2015/01/13 21:42:59 millert Exp $ */

/*
 * Copyright (c) 2003-2007 Bob Beck.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * sdl.c - Implement spamd source lists
 *
 * This consists of everything we need to do to determine which lists
 * someone is on. Spamd gets the connecting address, and looks it up
 * against all lists to determine what deferral messages to feed back
 * to the connecting machine. - The redirection to spamd will happen
 * from pf in the kernel, first match will divert to us. Spamd (along with
 * setup) must keep track of *all* matches, so as to tell someone all the
 * lists that they are on.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sdl.h"

static void sdl_free(struct sdlist *);
static void sdl_clear(struct sdlist *);

extern int debug;
struct sdlist *blacklists = NULL;
int blc = 0, blu = 0;

int
sdl_add(char *sdname, char *sdstring, char **v4, u_int nv4, char **v6, u_int nv6)
{
	int i, idx = -1;
	char astring[40];
	char *addr = NULL;
	unsigned int maskbits;

	/*
	 * if a blacklist of same tag name is already there, replace it,
	 * otherwise append.
	 */
	for (i = 0; i < blu; i++) {
		if (strcmp(blacklists[i].tag, sdname) == 0) {
			idx = i;
			break;
		}
	}
	if (idx != -1) {
		if (debug > 0)
			printf("replacing list %s; %u new entries\n",
			    blacklists[idx].tag, nv4 + nv6);
		sdl_free(&blacklists[idx]);
	} else {
		if (debug > 0)
			printf("adding list %s; %u entries\n", sdname, nv4 + nv6);
		if (blu == blc) {
			struct sdlist *tmp;

			tmp = reallocarray(blacklists, blc + 128,
			    sizeof(struct sdlist));
			if (tmp == NULL)
				return (-1);
			blacklists = tmp;
			blc += 128;
			sdl_clear(&blacklists[blu]);
		}
		idx = blu;
	}

	if ((blacklists[idx].tag = strdup(sdname)) == NULL)
		goto misc_error;
	if ((blacklists[idx].string = strdup(sdstring)) == NULL)
		goto misc_error;

	/*
	 * Cycle through addrs by family, converting. We assume they are
	 * correctly formatted v4 and v6 addrs, if they don't all convert
	 * correctly, the add fails. Each address should be address/maskbits.
	 */
	if (nv4 != 0) {
		blacklists[idx].v4.naddrs = nv4;
		blacklists[idx].v4.addrs = reallocarray(NULL, nv4,
		    sizeof(struct sdentry_v4));
		if (blacklists[idx].v4.addrs == NULL)
			goto misc_error;
		for (i = 0; i < nv4; i++) {
			struct in_addr *m, *n;
			int j;

			n = &blacklists[idx].v4.addrs[i].sda;
			m = &blacklists[idx].v4.addrs[i].sdm;

			addr = v4[i];
			j = sscanf(addr, "%15[^/]/%u", astring, &maskbits);
			if (j != 2)
				goto parse_error;
			/*
			 * sanity check! we don't allow a 0 mask -
			 * don't blacklist the entire net.
			 */
			if (maskbits == 0 || maskbits > 32)
				goto parse_error;
			j = inet_pton(AF_INET, astring, n);
			if (j != 1)
				goto parse_error;
			if (debug > 0)
				printf("added %s/%u\n", astring, maskbits);

			/* set mask. */
			m->s_addr = 0xffffffffU << (32 - maskbits);
			m->s_addr = htonl(m->s_addr);

			/* mask off address bits that won't ever be used */
			n->s_addr = n->s_addr & m->s_addr;
		}
	}
	if (nv6 != 0) {
		blacklists[idx].v6.naddrs = nv6;
		blacklists[idx].v6.addrs = reallocarray(NULL, nv6,
		    sizeof(struct sdentry_v6));
		if (blacklists[idx].v6.addrs == NULL)
			goto misc_error;

		for (i = 0; i < nv6; i++) {
			int j, k;
			struct sdaddr_v6 *m, *n;

			n = &blacklists[idx].v6.addrs[i].sda;
			m = &blacklists[idx].v6.addrs[i].sdm;

			addr = v6[i];
			j = sscanf(addr, "%39[^/]/%u", astring, &maskbits);
			if (j != 2)
				goto parse_error;
			/*
			 * sanity check! we don't allow a 0 mask -
			 * don't blacklist the entire net.
			 */
			if (maskbits == 0 || maskbits > 128)
				goto parse_error;
			j = inet_pton(AF_INET6, astring, n);
			if (j != 1)
				goto parse_error;
			if (debug > 0)
				printf("added %s/%u\n", astring, maskbits);

			/* set mask, borrowed from pf */
			k = 0;
			for (j = 0; j < 4; j++)
				m->addr32[j] = 0;
			while (maskbits >= 32) {
				m->addr32[k++] = 0xffffffffU;
				maskbits -= 32;
			}
			for (j = 31; j > 31 - maskbits; --j)
				m->addr32[k] |= (1 << j);
			if (maskbits)
				m->addr32[k] = htonl(m->addr32[k]);

			/* mask off address bits that won't ever be used */
			for (j = 0; j < 4; j++)
				n->addr32[j] = n->addr32[j] & m->addr32[j];
		}
	}
	if (idx == blu) {
		blu++;
		sdl_clear(&blacklists[blu]);
	}
	return (0);
 parse_error:
	if (debug > 0)
		printf("sdl_add: parse error, \"%s\"\n", addr);
 misc_error:
	sdl_free(&blacklists[idx]);
	if (idx != blu) {
		memmove(&blacklists[idx], &blacklists[idx + 1],
		    (blu - idx) * sizeof(*blacklists));
		blu--;
	}
	return (-1);
}

void
sdl_del(char *sdname)
{
	int i, idx = -1;

	for (i = 0; i < blu; i++) {
		if (strcmp(blacklists[i].tag, sdname) == 0) {
			idx = i;
			break;
		}
	}
	if (idx != -1) {
		if (debug > 0)
			printf("clearing list %s\n", sdname);
		/* Must preserve tag. */
		free(blacklists[idx].string);
		free(blacklists[idx].v4.addrs);
		free(blacklists[idx].v6.addrs);
		blacklists[idx].string = NULL;
		blacklists[idx].v4.addrs = NULL;
		blacklists[idx].v6.addrs = NULL;
		blacklists[idx].v4.naddrs = 0;
		blacklists[idx].v6.naddrs = 0;
	}
}

/*
 * Return 1 if the addresses a (with mask m) matches address b
 * otherwise return 0. It is assumed that address a has been
 * pre-masked out, we only need to mask b.
 */
static int
match_addr_v4(struct in_addr *a, struct in_addr *m, struct in_addr *b)
{
	if (a->s_addr == (b->s_addr & m->s_addr))
		return (1);
	return (0);
}

/*
 * Return 1 if the addresses a (with mask m) matches address b
 * otherwise return 0. It is assumed that address a has been
 * pre-masked out, we only need to mask b.
 */
static int
match_addr_v6(struct sdaddr_v6 *a, struct sdaddr_v6 *m, struct sdaddr_v6 *b)
{
	if (((a->addr32[0]) == (b->addr32[0] & m->addr32[0])) &&
	    ((a->addr32[1]) == (b->addr32[1] & m->addr32[1])) &&
	    ((a->addr32[2]) == (b->addr32[2] & m->addr32[2])) &&
	    ((a->addr32[3]) == (b->addr32[3] & m->addr32[3])))
		return (1);
	return (0);
}

#define grow_sdlist(sd, c, l) do {					       \
	if (c == l) {							       \
		struct sdlist **tmp;					       \
									       \
		tmp = reallocarray(sd, l + 128, sizeof(struct sdlist *));      \
		if (tmp == NULL) {					       \
			/*						       \
			 * XXX out of memory - return what we have	       \
			 */						       \
			return (sdnew);					       \
		}							       \
		sd = tmp;						       \
		l += 128;						       \
	}								       \
} while (0)

static struct sdlist **
sdl_lookup_v4(struct sdlist *sdl, struct in_addr *src)
{
	struct sdentry_v4 *entry;
	int i, matches = 0;
	int sdnewlen = 0;
	struct sdlist **sdnew = NULL;

	while (sdl->tag != NULL) {
		for (i = 0; i < sdl->v4.naddrs; i++) {
			entry = &sdl->v4.addrs[i];
			if (match_addr_v4(&entry->sda, &entry->sdm, src)) {
				grow_sdlist(sdnew, matches, sdnewlen);
				sdnew[matches] = sdl;
				matches++;
				sdnew[matches] = NULL;
				break;
			}
		}
		sdl++;
	}
	return (sdnew);
}

static struct sdlist **
sdl_lookup_v6(struct sdlist *sdl, struct sdaddr_v6 *src)
{
	struct sdentry_v6 *entry;
	int i, matches = 0;
	int sdnewlen = 0;
	struct sdlist **sdnew = NULL;

	while (sdl->tag != NULL) {
		for (i = 0; i < sdl->v6.naddrs; i++) {
			entry = &sdl->v6.addrs[i];
			if (match_addr_v6(&entry->sda, &entry->sdm, src)) {
				grow_sdlist(sdnew, matches, sdnewlen);
				sdnew[matches] = sdl;
				matches++;
				sdnew[matches] = NULL;
				break;
			}
		}
		sdl++;
	}
	return (sdnew);
}

/*
 * Given an address and address family
 * return list of pointers to matching nodes. or NULL if none.
 */
struct sdlist **
sdl_lookup(struct sdlist *head, int af, void *src)
{
	if (head == NULL)
		return (NULL);

	switch (af) {
	case AF_INET:
		return (sdl_lookup_v4(head, src));
	case AF_INET6:
		return (sdl_lookup_v6(head, src));
	default:
		return (NULL);
	}
}

static void
sdl_free(struct sdlist *sdl)
{
	free(sdl->tag);
	free(sdl->string);
	free(sdl->v4.addrs);
	free(sdl->v6.addrs);
	sdl_clear(sdl);
}

static void
sdl_clear(struct sdlist *sdl)
{
	sdl->tag = NULL;
	sdl->string = NULL;
	sdl->v4.addrs = NULL;
	sdl->v4.naddrs = 0;
	sdl->v6.addrs = NULL;
	sdl->v6.naddrs = 0;
}
@


1.21
log
@Use address-family specific lists of addr/mask entries instead of
a union that can store either ipv4 or ipv6.  The old method used
4x as much memory as was really needed for ipv4.  The spamd-setup
protocol has changed from: tag;message;a/m;a/m;a/m...\n
to :tag;message;af;count;a/m;a/m;a/m...[af;count;a/m;a/m;a/m]\n
OK phessler@@ "nice" beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.20 2015/01/08 22:10:08 millert Exp $ */
d26 1
a26 1
 * from pf in the kernel, first macth will rdr to us. Spamd (along with
@


1.20
log
@Avoid a crash (free of bogus pointer) when there is a syntax error
reading the config socket by clearing the entire blacklist struct
instead of just the tag string.  Also avoid holes in the blacklist
array on error since the code can't cope with them.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.19 2014/10/11 03:25:16 doug Exp $ */
a42 2
int match_addr(struct sdaddr *a, struct sdaddr *m, struct sdaddr *b,
    sa_family_t af);
d49 1
a49 1
sdl_add(char *sdname, char *sdstring, char ** addrs, int addrc)
d53 1
a54 1
	struct sdaddr *m, *n;
d68 2
a69 2
			printf("replacing list %s; %d new entries\n",
			    blacklists[idx].tag, addrc);
d73 1
a73 1
			printf("adding list %s; %d entries\n", sdname, addrc);
a92 2
	blacklists[idx].naddrs = addrc;

d94 3
a96 3
	 * Cycle through addrs, converting. We assume they are correctly
	 * formatted v4 and v6 addrs, if they don't all convert correctly, the
	 * add fails. Each address should be address/maskbits
d98 32
a129 3
	blacklists[idx].addrs = calloc(addrc, sizeof(struct sdentry));
	if (blacklists[idx].addrs == NULL)
		goto misc_error;
d131 50
a180 36
	for (i = 0; i < addrc; i++) {
		int j, k, af;

		n = &blacklists[idx].addrs[i].sda;
		m = &blacklists[idx].addrs[i].sdm;

		j = sscanf(addrs[i], "%39[^/]/%u", astring, &maskbits);
		if (j != 2)
			goto parse_error;
		if (maskbits > 128)
			goto parse_error;
		/*
		 * sanity check! we don't allow a 0 mask -
		 * don't blacklist the entire net.
		 */
		if (maskbits == 0)
			goto parse_error;
		if (strchr(astring, ':') != NULL)
			af = AF_INET6;
		else
			af = AF_INET;
		if (af == AF_INET && maskbits > 32)
			goto parse_error;
		j = inet_pton(af, astring, n);
		if (j != 1)
			goto parse_error;
		if (debug > 0)
			printf("added %s/%u\n", astring, maskbits);

		/* set mask, borrowed from pf */
		k = 0;
		for (j = 0; j < 4; j++)
			m->addr32[j] = 0;
		while (maskbits >= 32) {
			m->addr32[k++] = 0xffffffff;
			maskbits -= 32;
a181 8
		for (j = 31; j > 31 - maskbits; --j)
			m->addr32[k] |= (1 << j);
		if (maskbits)
			m->addr32[k] = htonl(m->addr32[k]);

		/* mask off address bits that won't ever be used */
		for (j = 0; j < 4; j++)
			n->addr32[j] = n->addr32[j] & m->addr32[j];
d190 1
a190 1
		printf("sdl_add: parse error, \"%s\"\n", addrs[i]);
d215 1
d217 2
a218 1
		free(blacklists[idx].addrs);
d220 4
a223 2
		blacklists[idx].addrs = NULL;
		blacklists[idx].naddrs = 0;
d232 15
a246 3
int
match_addr(struct sdaddr *a, struct sdaddr *m, struct sdaddr *b,
    sa_family_t af)
d248 23
a270 1
	int	match = 0;
d272 20
a291 17
	switch (af) {
	case AF_INET:
		if ((a->addr32[0]) ==
		    (b->addr32[0] & m->addr32[0]))
			match++;
		break;
	case AF_INET6:
		if (((a->addr32[0]) ==
		    (b->addr32[0] & m->addr32[0])) &&
		    ((a->addr32[1]) ==
		    (b->addr32[1] & m->addr32[1])) &&
		    ((a->addr32[2]) ==
		    (b->addr32[2] & m->addr32[2])) &&
		    ((a->addr32[3]) ==
		    (b->addr32[3] & m->addr32[3])))
			match++;
		break;
d293 1
a293 1
	return (match);
d296 2
a297 7

/*
 * Given an address and address family
 * return list of pointers to matching nodes. or NULL if none.
 */
struct sdlist **
sdl_lookup(struct sdlist *head, int af, void * src)
d299 1
a300 3
	struct sdlist *sdl;
	struct sdentry *sda;
	struct sdaddr *source = (struct sdaddr *) src;
a303 4
	if (head == NULL)
		return (NULL);
	else
		sdl = head;
d305 5
a309 19
		for (i = 0; i < sdl->naddrs; i++) {
			sda = sdl->addrs + i;
			if (match_addr(&sda->sda, &sda->sdm, source, af)) {
				if (matches == sdnewlen) {
					struct sdlist **tmp;

					tmp = reallocarray(sdnew,
					    sdnewlen + 128,
					    sizeof(struct sdlist *));
					if (tmp == NULL)
						/*
						 * XXX out of memory -
						 * return what we have
						 */
						return (sdnew);
					sdnew = tmp;
					sdnewlen += 128;
				}
				sdnew[matches]= sdl;
d311 1
a311 1
				sdnew[matches]=NULL;
d320 20
d345 2
a346 1
	free(sdl->addrs);
d355 4
a358 2
	sdl->addrs = NULL;
	sdl->naddrs = 0;
a359 1

@


1.19
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.18 2007/11/03 19:16:07 beck Exp $ */
d76 11
a88 11
	if (idx == blu && blu == blc) {
		struct sdlist *tmp;

		tmp = reallocarray(blacklists, blc + 128,
		    sizeof(struct sdlist));
		if (tmp == NULL)
			return (-1);
		blacklists = tmp;
		blc += 128;
		sdl_clear(&blacklists[idx]);
	}
d154 1
a154 1
		blacklists[blu].tag = NULL;
d162 5
@


1.18
log
@

PR 5621 - spamd doesn't clear the last entry from an empty TRAP list,
noticed and patch from Piotr Sikora <piotr@@sikora.nu>
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.17 2007/09/02 15:19:20 deraadt Exp $ */
d81 1
a81 1
		tmp = realloc(blacklists, (blc + 128) *
d245 2
a246 2
					tmp = realloc(sdnew,
					    (sdnewlen + 128) *
@


1.17
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.16 2007/03/26 16:36:18 beck Exp $ */
d165 21
@


1.16
log
@use new license.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.15 2007/03/05 02:10:46 deraadt Exp $ */
d102 1
a102 1
	blacklists[idx].addrs = malloc(addrc * sizeof(struct sdentry));
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.14 2007/02/23 19:36:23 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Bob Beck.  All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.14
log
@continue collecting lint to be sold as a parsley substitute; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.13 2005/08/04 09:48:27 otto Exp $ */
d114 1
a114 1
	for(i = 0; i < addrc; i++) {
@


1.13
log
@Fix handling of empty entries at the end of an address list; avoids
always skipping the last address.  ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.12 2004/02/26 08:18:56 deraadt Exp $ */
d61 1
a61 1
	int i, index = -1;
d72 1
a72 1
			index = i;
d76 1
a76 1
	if (index != -1) {
d79 2
a80 2
			    blacklists[index].tag, addrc);
		sdl_free(&blacklists[index]);
d84 1
a84 1
		index = blu;
d86 1
a86 1
	if (index == blu && blu == blc) {
d95 1
a95 1
		sdl_clear(&blacklists[index]);
d98 1
a98 1
	if ((blacklists[index].tag = strdup(sdname)) == NULL)
d100 1
a100 1
	if ((blacklists[index].string = strdup(sdstring)) == NULL)
d103 1
a103 1
	blacklists[index].naddrs = addrc;
d110 2
a111 2
	blacklists[index].addrs = malloc(addrc * sizeof(struct sdentry));
	if (blacklists[index].addrs == NULL)
d117 2
a118 2
		n = &blacklists[index].addrs[i].sda;
		m = &blacklists[index].addrs[i].sdm;
d160 1
a160 1
	if (index == blu) {
d169 1
a169 1
	sdl_free(&blacklists[index]);
@


1.12
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.11 2004/02/26 07:28:55 beck Exp $ */
d78 2
a79 1
			printf("replacing list %s\n", blacklists[index].tag);
d83 1
a83 1
			printf("adding list %s\n", sdname);
@


1.11
log
@Add -g option for greylisting support for spamd. The greylisting techinque
originates from a paper by Evan Harris which can be found at
http://projects.puremagic.com/greylisting/. This implementation makes
spamd allow for non-blacklisted addresses to be treated as "greylisted".
where they are tracked in a db file, and whitelisted by addition to a
pf table when the same envelope from and to are retried from the same
source IP address. Testing by many, ok deraadt@@
@
text
@d1 2
a2 1
/*	$OpenBSD: sdl.c,v 1.10 2003/09/26 16:07:29 deraadt Exp $ */
@


1.10
log
@can free(NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.9 2003/09/20 00:43:10 deraadt Exp $ */
d191 1
a191 1
		     (b->addr32[0] & m->addr32[0])) &&
d193 1
a193 1
		     (b->addr32[1] & m->addr32[1])) &&
d195 1
a195 1
		     (b->addr32[2] & m->addr32[2])) &&
d197 1
a197 1
		     (b->addr32[3] & m->addr32[3])))
d216 2
a217 2
	static int sdnewlen = 0;
	static struct sdlist **sdnew = NULL;
d232 1
a232 1
					     sizeof(struct sdlist *));
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.8 2003/08/22 21:50:34 david Exp $ */
d256 3
a258 9
	if (sdl->tag != NULL)
		free(sdl->tag);

	if (sdl->string != NULL)
		free(sdl->string);

	if (sdl->addrs != NULL)
		free(sdl->addrs);

@


1.8
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.7 2003/07/06 21:57:27 deraadt Exp $ */
d71 2
a72 2
				index = i;
				break;
d86 2
a87 1
		tmp = realloc (blacklists, (blc + 128) *
@


1.7
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.6 2003/03/03 22:22:23 cloder Exp $ */
d104 1
a104 1
	 * formatted v4 and v6 addrs, if they don't all convert correcly, the
@


1.6
log
@Better handling of parse errors and/or allocation
failures.  Add two functions, sdl_free() and
sdl_clear(), use them where needed.  Misc. other
cleanup and optimization.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.5 2003/03/03 20:17:50 deraadt Exp $ */
d50 2
@


1.5
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.4 2003/03/03 14:47:37 deraadt Exp $ */
d48 3
d67 6
a72 4

	for (i = 0; i < blu; i++)
		if (strcmp(blacklists[i].tag, sdname) == 0)
			index = i;
d76 1
a76 6
		free(blacklists[index].tag);
		blacklists[index].tag = NULL;
		free(blacklists[index].string);
		blacklists[index].string = NULL;
		free(blacklists[index].addrs);
		blacklists[index].addrs = NULL;
d90 1
d92 6
a97 2
	blacklists[index].tag = strdup(sdname);
	blacklists[index].string = strdup(sdstring);
d107 1
a107 1
		return (-1);
d162 3
a164 1
		printf("sdl_add: parse error, \"%s\"\n", astring);
d249 25
@


1.4
log
@always set ptr to NULL after free; from cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.3 2003/03/02 20:40:15 deraadt Exp $ */
d67 1
a67 1
				index = i;
d95 2
a96 1
	/* cycle through addrs, converting. We assume they are correctly
a99 1

d102 1
a102 1
		return(-1);
d106 1
d115 2
a116 1
		/* sanity check! we don't allow a 0 mask -
d158 1
a158 1
	return(-1);
d219 1
d228 1
a228 1
						return(sdnew);
d240 1
a240 1
	return(sdnew);
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.2 2003/03/02 20:32:05 deraadt Exp $ */
d72 1
d74 1
d76 1
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sdl.c,v 1.1 2003/03/02 19:22:00 beck Exp $ */
d53 1
a53 1
sdl_add (char *sdname, char *sdstring, char ** addrs, int addrc)
d79 1
a79 1
	if (index == blu &&  blu == blc) {
d200 1
a200 1
	struct sdaddr *source = (struct sdaddr *) src ;
d216 1
a216 1
					     sizeof(struct sdlist *) );
d218 4
a221 2
						/* XXX out of memory - return
						   what we have */
@


1.1
log
@Spamd changes to add blacklist awareness to spamd, new spamd-setup.pl
which configures individual blacklists sources and deals with whitelists.
Perl still needs some stylistic changes as suggested by bmc which will go
in shortly.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 1
a107 1
		if (j != 2) 
d135 1
a135 1
 		}
@

