head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.63.0.2
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.55.0.6
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.52.0.4
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.51.0.6
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.22.0.6
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.64
date	2016.10.20.21.09.46;	author mestre;	state Exp;
branches;
next	1.63;
commitid	ujt9KK3kLsMhYozP;

1.63
date	2016.03.25.16.31.32;	author mestre;	state Exp;
branches;
next	1.62;
commitid	TRi0dGNwWyh3bSyk;

1.62
date	2015.12.10.16.06.29;	author beck;	state Exp;
branches;
next	1.61;
commitid	7YcXEB5v1t3ncjnB;

1.61
date	2015.12.08.03.21.09;	author beck;	state Exp;
branches;
next	1.60;
commitid	rBXxy5NrAMI2Ytcs;

1.60
date	2015.11.29.06.51.20;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	EchUCAhJGddy1V2l;

1.59
date	2015.05.18.16.04.21;	author reyk;	state Exp;
branches;
next	1.58;
commitid	BUauTTbpwkWg0A95;

1.58
date	2015.01.13.21.42.59;	author millert;	state Exp;
branches;
next	1.57;
commitid	FcrTmS5RaNh0dgrr;

1.57
date	2014.11.23.21.19.47;	author guenther;	state Exp;
branches;
next	1.56;
commitid	pQM9z0R0Rd8tOlkz;

1.56
date	2014.10.09.02.43.43;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	sXea7sxYyxWPNIGe;

1.55
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.19.18.33.57;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2013.08.21.16.13.29;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.02.15.26.17;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.03.21.58.58;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.06.09.38.02;	author stephan;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.11.10.00.22;	author beck;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.12.04.08.46;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.20.17.42.21;	author beck;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.25.19.00.36;	author beck;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.07.21.12.52;	author cloder;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.26.22.49.09;	author jsg;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.11.14.53.32;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.11.01.40.50;	author phessler;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.03.19.16.07;	author beck;	state Exp;
branches;
next	1.40;

1.40
date	2007.08.16.04.42.16;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.18.18.38.57;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.16.01.03.04;	author beck;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.14.19.39.55;	author beck;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.14.19.13.35;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.12.03.14.44;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.06.23.38.36;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.05.15.09.01;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.05.02.10.46;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.04.03.24.47;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.04.03.19.41;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.23.22.40.50;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.23.19.45.08;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.23.19.36.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.23.19.28.39;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.23.19.22.07;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.04.21.41.37;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.07.21.10.41;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.15.17.11.14;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.12.00.02.07;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.11.23.09.52;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.04.00.24.42;	author moritz;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.15.00.46.46;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.15.21.49.45;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.04.22.46.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.21.17.07.01;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.21.17.05.43;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.13.17.46.15;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.11.17.48.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.11.17.29.50;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.10.00.33.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.05.00.31.05;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.01.17.03.10;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.28.00.03.59;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.26.08.52.58;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.26.08.50.40;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.26.07.38.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.26.07.28.55;	author beck;	state Exp;
branches;
next	;


desc
@@


1.64
log
@- Remove useless var assignment
- Use memset(*b, 0, len) instead of bzero(*b, len)
- Use memcpy(*dst, *src, len) instead of bcopy(*src, *dst, len)
- Use explicit_bzero(3) instead of bzero(3) to clean temporary HMAC

Remarks from deraadt@@ (duly noted!!), reviewed and OK by henning@@ and tb@@
@
text
@/*	$OpenBSD: grey.c,v 1.63 2016/03/25 16:31:32 mestre Exp $	*/

/*
 * Copyright (c) 2004-2006 Bob Beck.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include <ctype.h>
#include <db.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <netdb.h>

#include "grey.h"
#include "sync.h"

extern time_t passtime, greyexp, whiteexp, trapexp;
extern struct syslog_data sdata;
extern struct passwd *pw;
extern u_short cfg_port;
extern pid_t jail_pid;
extern FILE *trapcfg;
extern FILE *grey;
extern int debug;
extern int syncsend;

/* From netinet/in.h, but only _KERNEL_ gets them. */
#define satosin(sa)	((struct sockaddr_in *)(sa))
#define satosin6(sa)	((struct sockaddr_in6 *)(sa))

void	configure_spamd(char **, u_int, FILE *);
int	configure_pf(char **, int);
char	*dequotetolower(const char *);
void	readsuffixlists(void);
void	freeaddrlists(void);
int	addwhiteaddr(char *);
int	addtrapaddr(char *);
int	db_addrstate(DB *, char *);
int	greyscan(char *);
int	trapcheck(DB *, char *);
int	twupdate(char *, char *, char *, char *, char *);
int	twread(char *);
int	greyreader(void);
void	greyscanner(void);


u_int whitecount, whitealloc;
u_int trapcount, trapalloc;
char **whitelist;
char **traplist;

char *traplist_name = "spamd-greytrap";
char *traplist_msg = "\"Your address %A has mailed to spamtraps here\\n\"";

pid_t db_pid = -1;
int pfdev;

struct db_change {
	SLIST_ENTRY(db_change)	entry;
	char *			key;
	void *			data;
	size_t			dsiz;
	int			act;
};

#define DBC_ADD 1
#define DBC_DEL 2

/* db pending changes list */
SLIST_HEAD(, db_change) db_changes = SLIST_HEAD_INITIALIZER(db_changes);

struct mail_addr {
	SLIST_ENTRY(mail_addr)	entry;
	char			addr[MAX_MAIL];
};

/* list of suffixes that must match TO: */
SLIST_HEAD(, mail_addr) match_suffix = SLIST_HEAD_INITIALIZER(match_suffix);
char *alloweddomains_file = PATH_SPAMD_ALLOWEDDOMAINS;

char *low_prio_mx_ip;
time_t startup;

static char *pargv[11]= {
	"pfctl", "-p", "/dev/pf", "-q", "-t",
	"spamd-white", "-T", "replace", "-f", "-", NULL
};

/* If the parent gets a signal, kill off the children and exit */
/* ARGSUSED */
static void
sig_term_chld(int sig)
{
	if (db_pid != -1)
		kill(db_pid, SIGTERM);
	if (jail_pid != -1)
		kill(jail_pid, SIGTERM);
	_exit(1);
}

/*
 * Greatly simplified version from spamd_setup.c  - only
 * sends one blacklist to an already open stream. Has no need
 * to collapse cidr ranges since these are only ever single
 * host hits.
 */
void
configure_spamd(char **addrs, u_int count, FILE *sdc)
{
	u_int i;

	/* XXX - doesn't support IPV6 yet */
	fprintf(sdc, "%s;", traplist_name);
	if (count != 0) {
		fprintf(sdc, "%s;inet;%u", traplist_msg, count);
		for (i = 0; i < count; i++)
			fprintf(sdc, ";%s/32", addrs[i]);
	}
	fputc('\n', sdc);
	if (fflush(sdc) == EOF)
		syslog_r(LOG_DEBUG, &sdata, "configure_spamd: fflush failed (%m)");
}

int
configure_pf(char **addrs, int count)
{
	FILE *pf = NULL;
	int i, pdes[2], status;
	pid_t pid;
	char *fdpath;
	struct sigaction sa;

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sig_term_chld;

	if (debug)
		fprintf(stderr, "configure_pf - device on fd %d\n", pfdev);

	/* Because /dev/fd/ only contains device nodes for 0-63 */
	if (pfdev < 1 || pfdev > 63)
		return(-1);

	if (asprintf(&fdpath, "/dev/fd/%d", pfdev) == -1)
		return(-1);
	pargv[2] = fdpath;
	if (pipe(pdes) != 0) {
		syslog_r(LOG_INFO, &sdata, "pipe failed (%m)");
		free(fdpath);
		fdpath = NULL;
		return(-1);
	}
	signal(SIGCHLD, SIG_DFL);
	switch (pid = fork()) {
	case -1:
		syslog_r(LOG_INFO, &sdata, "fork failed (%m)");
		free(fdpath);
		fdpath = NULL;
		close(pdes[0]);
		close(pdes[1]);
		sigaction(SIGCHLD, &sa, NULL);
		return(-1);
	case 0:
		/* child */
		close(pdes[1]);
		if (pdes[0] != STDIN_FILENO) {
			dup2(pdes[0], STDIN_FILENO);
			close(pdes[0]);
		}
		execvp(PATH_PFCTL, pargv);
		syslog_r(LOG_ERR, &sdata, "can't exec %s:%m", PATH_PFCTL);
		_exit(1);
	}

	/* parent */
	free(fdpath);
	fdpath = NULL;
	close(pdes[0]);
	pf = fdopen(pdes[1], "w");
	if (pf == NULL) {
		syslog_r(LOG_INFO, &sdata, "fdopen failed (%m)");
		close(pdes[1]);
		sigaction(SIGCHLD, &sa, NULL);
		return(-1);
	}
	for (i = 0; i < count; i++)
		if (addrs[i] != NULL)
			fprintf(pf, "%s/32\n", addrs[i]);
	fclose(pf);

	waitpid(pid, &status, 0);
	if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
		syslog_r(LOG_ERR, &sdata, "%s returned status %d", PATH_PFCTL,
		    WEXITSTATUS(status));
	else if (WIFSIGNALED(status))
		syslog_r(LOG_ERR, &sdata, "%s died on signal %d", PATH_PFCTL,
		    WTERMSIG(status));

	sigaction(SIGCHLD, &sa, NULL);
	return(0);
}

char *
dequotetolower(const char *addr)
{
	static char buf[MAX_MAIL];
	char *cp;

	if (*addr == '<')
		addr++;
	(void) strlcpy(buf, addr, sizeof(buf));
	cp = strrchr(buf, '>');
	if (cp != NULL && cp[1] == '\0')
		*cp = '\0';
	cp = buf;
	while (*cp != '\0') {
		*cp = tolower((unsigned char)*cp);
		cp++;
	}
	return(buf);
}

void
readsuffixlists(void)
{
	FILE *fp;
	char *buf;
	size_t len;
	struct mail_addr *m;

	while (!SLIST_EMPTY(&match_suffix)) {
		m = SLIST_FIRST(&match_suffix);
		SLIST_REMOVE_HEAD(&match_suffix, entry);
		free(m);
	}
	if ((fp = fopen(alloweddomains_file, "r")) != NULL) {
		while ((buf = fgetln(fp, &len))) {
			/* strip white space-characters */
			while (len > 0 && isspace((unsigned char)buf[len-1]))
				len--;
			while (len > 0 && isspace((unsigned char)*buf)) {
				buf++;
				len--;
			}
			if (len == 0)
				continue;
			/* jump over comments and blank lines */
			if (*buf == '#' || *buf == '\n')
				continue;
			if (buf[len-1] == '\n')
				len--;
			if ((len + 1) > sizeof(m->addr)) {
				syslog_r(LOG_ERR, &sdata,
				    "line too long in %s - file ignored",
				    alloweddomains_file);
				goto bad;
			}
			if ((m = malloc(sizeof(struct mail_addr))) == NULL)
				goto bad;
			memcpy(m->addr, buf, len);
			m->addr[len]='\0';
			syslog_r(LOG_ERR, &sdata, "got suffix %s", m->addr);
			SLIST_INSERT_HEAD(&match_suffix, m, entry);
		}
	}
	return;
bad:
	while (!SLIST_EMPTY(&match_suffix)) {
	  	m = SLIST_FIRST(&match_suffix);
		SLIST_REMOVE_HEAD(&match_suffix, entry);
		free(m);
	}
}

void
freeaddrlists(void)
{
	int i;

	if (whitelist != NULL)
		for (i = 0; i < whitecount; i++) {
			free(whitelist[i]);
			whitelist[i] = NULL;
		}
	whitecount = 0;
	if (traplist != NULL) {
		for (i = 0; i < trapcount; i++) {
			free(traplist[i]);
			traplist[i] = NULL;
		}
	}
	trapcount = 0;
}

/* validate, then add to list of addrs to whitelist */
int
addwhiteaddr(char *addr)
{
	struct addrinfo hints, *res;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;		/*for now*/
	hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
	hints.ai_protocol = IPPROTO_UDP;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(addr, NULL, &hints, &res) == 0) {
		if (whitecount == whitealloc) {
			char **tmp;

			tmp = reallocarray(whitelist,
			    whitealloc + 1024, sizeof(char *));
			if (tmp == NULL) {
				freeaddrinfo(res);
				return(-1);
			}
			whitelist = tmp;
			whitealloc += 1024;
		}
		whitelist[whitecount] = strdup(addr);
		if (whitelist[whitecount] == NULL) {
			freeaddrinfo(res);
			return(-1);
		}
		whitecount++;
		freeaddrinfo(res);
	} else
		return(-1);
	return(0);
}

/* validate, then add to list of addrs to traplist */
int
addtrapaddr(char *addr)
{
	struct addrinfo hints, *res;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;		/*for now*/
	hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
	hints.ai_protocol = IPPROTO_UDP;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(addr, NULL, &hints, &res) == 0) {
		if (trapcount == trapalloc) {
			char **tmp;

			tmp = reallocarray(traplist,
			    trapalloc + 1024, sizeof(char *));
			if (tmp == NULL) {
				freeaddrinfo(res);
				return(-1);
			}
			traplist = tmp;
			trapalloc += 1024;
		}
		traplist[trapcount] = strdup(addr);
		if (traplist[trapcount] == NULL) {
			freeaddrinfo(res);
			return(-1);
		}
		trapcount++;
		freeaddrinfo(res);
	} else
		return(-1);
	return(0);
}

static int
queue_change(char *key, char *data, size_t dsiz, int act)
{
	struct db_change *dbc;

	if ((dbc = malloc(sizeof(*dbc))) == NULL) {
		syslog_r(LOG_DEBUG, &sdata, "malloc failed (queue change)");
		return(-1);
	}
	if ((dbc->key = strdup(key)) == NULL) {
		syslog_r(LOG_DEBUG, &sdata, "malloc failed (queue change)");
		free(dbc);
		return(-1);
	}
	if ((dbc->data = malloc(dsiz)) == NULL) {
		syslog_r(LOG_DEBUG, &sdata, "malloc failed (queue change)");
		free(dbc->key);
		free(dbc);
		return(-1);
	}
	memcpy(dbc->data, data, dsiz);
	dbc->dsiz = dsiz;
	dbc->act = act;
	syslog_r(LOG_DEBUG, &sdata,
	    "queueing %s of %s", ((act == DBC_ADD) ? "add" : "deletion"),
	    dbc->key);
	SLIST_INSERT_HEAD(&db_changes, dbc, entry);
	return(0);
}

static int
do_changes(DB *db)
{
	DBT			dbk, dbd;
	struct db_change	*dbc;
	int ret = 0;

	while (!SLIST_EMPTY(&db_changes)) {
		dbc = SLIST_FIRST(&db_changes);
		switch (dbc->act) {
		case DBC_ADD:
			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(dbc->key);
			dbk.data = dbc->key;
			memset(&dbd, 0, sizeof(dbd));
			dbd.size = dbc->dsiz;
			dbd.data = dbc->data;
			if (db->put(db, &dbk, &dbd, 0)) {
				db->sync(db, 0);
				syslog_r(LOG_ERR, &sdata,
				    "can't add %s to spamd db (%m)", dbc->key);
				ret = -1;
			}
			db->sync(db, 0);
			break;
		case DBC_DEL:
			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(dbc->key);
			dbk.data = dbc->key;
			if (db->del(db, &dbk, 0)) {
				syslog_r(LOG_ERR, &sdata,
				    "can't delete %s from spamd db (%m)",
				    dbc->key);
				ret = -1;
			}
			break;
		default:
			syslog_r(LOG_ERR, &sdata, "Unrecognized db change");
			ret = -1;
		}
		free(dbc->key);
		dbc->key = NULL;
		free(dbc->data);
		dbc->data = NULL;
		dbc->act = 0;
		dbc->dsiz = 0;
		SLIST_REMOVE_HEAD(&db_changes, entry);
		free(dbc);

	}
	return(ret);
}

/* -1=error, 0=notfound, 1=TRAPPED, 2=WHITE */
int
db_addrstate(DB *db, char *key)
{
	DBT			dbk, dbd;
	struct gdata		gd;

	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(key);
	dbk.data = key;
	memset(&dbd, 0, sizeof(dbd));
	switch (db->get(db, &dbk, &dbd, 0)) {
	case 1:
		/* not found */
		return (0);
	case 0:
		if (gdcopyin(&dbd, &gd) != -1)
			return (gd.pcount == -1 ? 1 : 2);
		/* FALLTHROUGH */
	default:
		/* error */
		return (-1);
	}
}


int
greyscan(char *dbname)
{
	HASHINFO	hashinfo;
	DBT		dbk, dbd;
	DB		*db;
	struct gdata	gd;
	int		r;
	char		*a = NULL;
	size_t		asiz = 0;
	time_t now = time(NULL);

	/* walk db, expire, and whitelist */
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);
	if (db == NULL) {
		syslog_r(LOG_INFO, &sdata, "dbopen failed (%m)");
		return(-1);
	}
	memset(&dbk, 0, sizeof(dbk));
	memset(&dbd, 0, sizeof(dbd));
	for (r = db->seq(db, &dbk, &dbd, R_FIRST); !r;
	    r = db->seq(db, &dbk, &dbd, R_NEXT)) {
		if ((dbk.size < 1) || gdcopyin(&dbd, &gd) == -1) {
			syslog_r(LOG_ERR, &sdata, "bogus entry in spamd database");
			goto bad;
		}
		if (asiz < dbk.size + 1) {
			char *tmp;

			tmp = reallocarray(a, dbk.size, 2);
			if (tmp == NULL)
				goto bad;
			a = tmp;
			asiz = dbk.size * 2;
		}
		memset(a, 0, asiz);
		memcpy(a, dbk.data, dbk.size);
		if (gd.expire <= now && gd.pcount != -2) {
			/* get rid of entry */
			if (queue_change(a, NULL, 0, DBC_DEL) == -1)
				goto bad;
		} else if (gd.pcount == -1)  {
			/* this is a greytrap hit */
			if ((addtrapaddr(a) == -1) &&
			    (queue_change(a, NULL, 0, DBC_DEL) == -1))
				goto bad;
		} else if (gd.pcount >= 0 && gd.pass <= now) {
			int tuple = 0;
			char *cp;
			int state;

			/*
			 * if not already TRAPPED,
			 * add address to whitelist
			 * add an address-keyed entry to db
			 */
			cp = strchr(a, '\n');
			if (cp != NULL) {
				tuple = 1;
				*cp = '\0';
			}

			state = db_addrstate(db, a);
			if (state != 1 && addwhiteaddr(a) == -1) {
				if (cp != NULL)
					*cp = '\n';
				if (queue_change(a, NULL, 0, DBC_DEL) == -1)
					goto bad;
			}

			if (tuple && state <= 0) {
				if (cp != NULL)
					*cp = '\0';
				/* re-add entry, keyed only by ip */
				gd.expire = now + whiteexp;
				dbd.size = sizeof(gd);
				dbd.data = &gd;
				if (queue_change(a, (void *) &gd, sizeof(gd),
				    DBC_ADD) == -1)
					goto bad;
				syslog_r(LOG_DEBUG, &sdata,
				    "whitelisting %s in %s", a, dbname);
			}
			if (debug)
				fprintf(stderr, "whitelisted %s\n", a);
		}
	}
	(void) do_changes(db);
	db->close(db);
	db = NULL;
	configure_pf(whitelist, whitecount);
	configure_spamd(traplist, trapcount, trapcfg);

	freeaddrlists();
	free(a);
	a = NULL;
	return(0);
 bad:
	(void) do_changes(db);
	db->close(db);
	db = NULL;
	freeaddrlists();
	free(a);
	a = NULL;
	return(-1);
}

int
trapcheck(DB *db, char *to)
{
	int			i, j, smatch = 0;
	DBT			dbk, dbd;
	struct mail_addr	*m;
	char *			trap;
	size_t			s;

	trap = dequotetolower(to);
	if (!SLIST_EMPTY(&match_suffix)) {
		s = strlen(trap);
		SLIST_FOREACH(m, &match_suffix, entry) {
			j = s - strlen(m->addr);
			if ((j >= 0) && (strcasecmp(trap+j, m->addr) == 0))
				smatch = 1;
		}
		if (!smatch)
			/* no suffixes match, so trap it */
			return (0);
	}
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(trap);
	dbk.data = trap;
	memset(&dbd, 0, sizeof(dbd));
	i = db->get(db, &dbk, &dbd, 0);
	if (i == -1)
		return (-1);
	if (i)
		/* didn't exist - so this doesn't match a known spamtrap  */
		return (1);
	else
		/* To: address is a spamtrap, so add as a greytrap entry */
		return (0);
}

int
twupdate(char *dbname, char *what, char *ip, char *source, char *expires)
{
	/* we got a TRAP or WHITE update from someone else */
	HASHINFO	hashinfo;
	DBT		dbk, dbd;
	DB		*db;
	struct gdata	gd;
	time_t		now, expire;
	int		r, spamtrap;

	now = time(NULL);
	/* expiry times have to be in the future */
	expire = strtonum(expires, now,
	    sizeof(time_t) == sizeof(int) ? INT_MAX : LLONG_MAX, NULL);
	if (expire == 0)
		return(-1);

	if (strcmp(what, "TRAP") == 0)
		spamtrap = 1;
	else if (strcmp(what, "WHITE") == 0)
		spamtrap = 0;
	else
		return(-1);

	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);
	if (db == NULL)
		return(-1);

	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(ip);
	dbk.data = ip;
	memset(&dbd, 0, sizeof(dbd));
	r = db->get(db, &dbk, &dbd, 0);
	if (r == -1)
		goto bad;
	if (r) {
		/* new entry */
		memset(&gd, 0, sizeof(gd));
		gd.first = now;
		gd.pcount = spamtrap ? -1 : 0;
		gd.expire = expire;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(ip);
		dbk.data = ip;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		db->sync(db, 0);
		if (r)
			goto bad;
		if (debug)
			fprintf(stderr, "added %s %s\n",
			    spamtrap ? "trap entry for" : "", ip);
		syslog_r(LOG_DEBUG, &sdata,
		    "new %s from %s for %s, expires %s", what, source, ip,
		    expires);
	} else {
		/* existing entry */
		if (gdcopyin(&dbd, &gd) == -1) {
			/* whatever this is, it doesn't belong */
			db->del(db, &dbk, 0);
			db->sync(db, 0);
			goto bad;
		}
		if (spamtrap) {
			gd.pcount = -1;
			gd.bcount++;
		} else
			gd.pcount++;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(ip);
		dbk.data = ip;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		db->sync(db, 0);
		if (r)
			goto bad;
		if (debug)
			fprintf(stderr, "updated %s\n", ip);
	}
	db->close(db);
	return(0);
 bad:
	db->close(db);
	return(-1);

}

int
greyupdate(char *dbname, char *helo, char *ip, char *from, char *to, int sync,
    char *cip)
{
	HASHINFO	hashinfo;
	DBT		dbk, dbd;
	DB		*db;
	char		*key = NULL;
	char		*lookup;
	struct gdata	gd;
	time_t		now, expire;
	int		r, spamtrap;

	now = time(NULL);

	/* open with lock, find record, update, close, unlock */
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);
	if (db == NULL)
		return(-1);
	if (asprintf(&key, "%s\n%s\n%s\n%s", ip, helo, from, to) == -1)
		goto bad;
	r = trapcheck(db, to);
	switch (r) {
	case 1:
		/* do not trap */
		spamtrap = 0;
		lookup = key;
		expire = greyexp;
		break;
	case 0:
		/* trap */
		spamtrap = 1;
		lookup = ip;
		expire = trapexp;
		syslog_r(LOG_DEBUG, &sdata, "Trapping %s for tuple %s", ip,
		    key);
		break;
	default:
		goto bad;
		break;
	}
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(lookup);
	dbk.data = lookup;
	memset(&dbd, 0, sizeof(dbd));
	r = db->get(db, &dbk, &dbd, 0);
	if (r == -1)
		goto bad;
	if (r) {
		/* new entry */
		if (sync &&  low_prio_mx_ip &&
		    (strcmp(cip, low_prio_mx_ip) == 0) &&
		    ((startup + 60)  < now)) {
			/* we haven't seen a greylist entry for this tuple,
			 * and yet the connection was to a low priority MX
			 * which we know can't be hit first if the client
			 * is adhering to the RFC's - soo.. kill it!
			 */
			spamtrap = 1;
			lookup = ip;
			expire = trapexp;
			syslog_r(LOG_DEBUG, &sdata,
			    "Trapping %s for trying %s first for tuple %s",
			    ip, low_prio_mx_ip, key);
		}
		memset(&gd, 0, sizeof(gd));
		gd.first = now;
		gd.bcount = 1;
		gd.pcount = spamtrap ? -1 : 0;
		gd.pass = now + expire;
		gd.expire = now + expire;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(lookup);
		dbk.data = lookup;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		db->sync(db, 0);
		if (r)
			goto bad;
		if (debug)
			fprintf(stderr, "added %s %s\n",
			    spamtrap ? "greytrap entry for" : "", lookup);
		syslog_r(LOG_DEBUG, &sdata,
		    "new %sentry %s from %s to %s, helo %s",
		    spamtrap ? "greytrap " : "", ip, from, to, helo);
	} else {
		/* existing entry */
		if (gdcopyin(&dbd, &gd) == -1) {
			/* whatever this is, it doesn't belong */
			db->del(db, &dbk, 0);
			db->sync(db, 0);
			goto bad;
		}
		gd.bcount++;
		gd.pcount = spamtrap ? -1 : 0;
		if (gd.first + passtime < now)
			gd.pass = now;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(lookup);
		dbk.data = lookup;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		db->sync(db, 0);
		if (r)
			goto bad;
		if (debug)
			fprintf(stderr, "updated %s\n", lookup);
	}
	free(key);
	key = NULL;
	db->close(db);
	db = NULL;

	/* Entry successfully update, sent out sync message */
	if (syncsend && sync) {
		if (spamtrap) {
			syslog_r(LOG_DEBUG, &sdata,
			    "sync_trap %s", ip);
			sync_trapped(now, now + expire, ip);
		}
		else
			sync_update(now, helo, ip, from, to);
	}
	return(0);
 bad:
	free(key);
	key = NULL;
	db->close(db);
	db = NULL;
	return(-1);
}

int
twread(char *buf)
{
	if ((strncmp(buf, "WHITE:", 6) == 0) ||
	    (strncmp(buf, "TRAP:", 5) == 0)) {
		char **ap, *argv[5];
		int argc = 0;

		for (ap = argv;
		    ap < &argv[4] && (*ap = strsep(&buf, ":")) != NULL;) {
			if (**ap != '\0')
				ap++;
			argc++;
		}
		*ap = NULL;
		if (argc != 4)
			return (-1);
		twupdate(PATH_SPAMD_DB, argv[0], argv[1], argv[2], argv[3]);
		return (0);
	} else
		return (-1);
}

int
greyreader(void)
{
	char cip[32], ip[32], helo[MAX_MAIL], from[MAX_MAIL], to[MAX_MAIL];
	char *buf;
	size_t len;
	int state, sync;
	struct addrinfo hints, *res;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;		/*for now*/
	hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
	hints.ai_protocol = IPPROTO_UDP;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;

	state = 0;
	sync = 1;
	if (grey == NULL) {
		syslog_r(LOG_ERR, &sdata, "No greylist pipe stream!\n");
		return (-1);
	}

	/* grab trap suffixes */
	readsuffixlists();

	while ((buf = fgetln(grey, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else
			/* all valid lines end in \n */
			continue;
		if (strlen(buf) < 4)
			continue;

		if (strcmp(buf, "SYNC") == 0) {
			sync = 0;
			continue;
		}

		switch (state) {
		case 0:
			if (twread(buf) == 0) {
				state = 0;
				break;
			}
			if (strncmp(buf, "HE:", 3) != 0) {
				if (strncmp(buf, "CO:", 3) == 0)
					strlcpy(cip, buf+3, sizeof(cip));
				state = 0;
				break;
			}
			strlcpy(helo, buf+3, sizeof(helo));
			state = 1;
			break;
		case 1:
			if (strncmp(buf, "IP:", 3) != 0)
				break;
			strlcpy(ip, buf+3, sizeof(ip));
			if (getaddrinfo(ip, NULL, &hints, &res) == 0) {
				freeaddrinfo(res);
				state = 2;
			} else
				state = 0;
			break;
		case 2:
			if (strncmp(buf, "FR:", 3) != 0) {
				state = 0;
				break;
			}
			strlcpy(from, buf+3, sizeof(from));
			state = 3;
			break;
		case 3:
			if (strncmp(buf, "TO:", 3) != 0) {
				state = 0;
				break;
			}
			strlcpy(to, buf+3, sizeof(to));
			if (debug)
				fprintf(stderr,
				    "Got Grey HELO %s, IP %s from %s to %s\n",
				    helo, ip, from, to);
			greyupdate(PATH_SPAMD_DB, helo, ip, from, to, sync, cip);
			sync = 1;
			state = 0;
			break;
		}
	}
	return (0);
}

void
greyscanner(void)
{
	for (;;) {
		if (greyscan(PATH_SPAMD_DB) == -1)
			syslog_r(LOG_NOTICE, &sdata, "scan of %s failed",
			    PATH_SPAMD_DB);
		sleep(DB_SCAN_INTERVAL);
	}
}

static void
drop_privs(void)
{
	/*
	 * lose root, continue as non-root user
	 */
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid)) {
		syslog_r(LOG_ERR, &sdata, "failed to drop privs (%m)");
		exit(1);
	}
}

void
check_spamd_db(void)
{
	HASHINFO hashinfo;
	int i = -1;
	DB *db;

	/* check to see if /var/db/spamd exists, if not, create it */
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);

	if (db == NULL) {
		switch (errno) {
		case ENOENT:
			i = open(PATH_SPAMD_DB, O_RDWR|O_CREAT, 0644);
			if (i == -1) {
				syslog_r(LOG_ERR, &sdata,
				    "create %s failed (%m)", PATH_SPAMD_DB);
				exit(1);
			}
			/* if we are dropping privs, chown to that user */
			if (pw && (fchown(i, pw->pw_uid, pw->pw_gid) == -1)) {
				syslog_r(LOG_ERR, &sdata,
				    "chown %s failed (%m)", PATH_SPAMD_DB);
				exit(1);
			}
			close(i);
			return;
			break;
		default:
			syslog_r(LOG_ERR, &sdata, "open of %s failed (%m)",
			    PATH_SPAMD_DB);
			exit(1);
		}
	}
	db->sync(db, 0);
	db->close(db);
}


int
greywatcher(void)
{
	struct sigaction sa;

	drop_privs();

	if (pledge("stdio rpath wpath inet flock proc exec", NULL) == -1) {
		syslog_r(LOG_ERR, &sdata, "pledge failed (%m)");
		exit(1);
	}
		
	startup = time(NULL);
	db_pid = fork();
	switch (db_pid) {
	case -1:
		syslog_r(LOG_ERR, &sdata, "fork failed (%m)");
		exit(1);
	case 0:
		/*
		 * child, talks to jailed spamd over greypipe,
		 * updates db. has no access to pf.
		 */
		close(pfdev);
		setproctitle("(%s update)", PATH_SPAMD_DB);
		if (greyreader() == -1) {
		    syslog_r(LOG_ERR, &sdata, "greyreader failed (%m)");
		    _exit(1);
		}
		_exit(0);
	}


	fclose(grey);
	/*
	 * parent, scans db periodically for changes and updates
	 * pf whitelist table accordingly.
	 */

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sig_term_chld;
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGCHLD, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);

	setproctitle("(pf <spamd-white> update)");
	greyscanner();
	exit(1);
}
@


1.63
log
@- Both checks for pw are not needed since it was already done at the start of
the program
- Add error message to syslog if privdrop didn't succeed and then exit
- Remove lint comments

OK beck@@ after his suggestion and also looks good to jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.62 2015/12/10 16:06:29 beck Exp $	*/
a600 1
	asiz = 0;
a608 1
	asiz = 0;
@


1.62
log
@tighten the pledge for spamd, from Ricardo Mestre <serial@@helheim.mooo.com>
this loads the tls certificate files pre-pledge then does the bulk of the tls
setup goo pledged.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.61 2015/12/08 03:21:09 beck Exp $	*/
a1002 1
	/* NOTREACHED */
d1011 5
a1015 6
	if (pw) {
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
a1107 1
	/* NOTREACHED */
@


1.61
log
@Initially pledge spamd
All the work done by Ricardo Mestre <serial@@helheim.mooo.com> - Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.60 2015/11/29 06:51:20 deraadt Exp $	*/
d1068 5
@


1.60
log
@Document that the pfdev check for 63 is /dev/fd/ only contains those nodes
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.59 2015/05/18 16:04:21 reyk Exp $	*/
d1021 1
a1021 1
static void
a1047 1
			drop_privs();
a1057 1
	drop_privs();
d1066 1
a1066 1
	check_spamd_db();
@


1.59
log
@Change spamd to use divert-to instead of rdr-to.

divert-to has many advantages over rdr-to for proxies.  For example,
it is much easier to use, requires less code, does not depend on
/dev/pf, works in-band without the asynchronous lookup (DIOCNATLOOK
ioctl), saves us from additional port allocations by the rdr/NAT code,
and even avoids potential collisions and race conditions that could
theoretically happen with the lookup.

Heads up: users will have to update their spamd PF rules from rdr-to
to divert-to.  spamd now also listens to 127.0.0.1 instead of "any"
(0.0.0.0) by default which should be fine with most setups but has to
be considered for some special configurations.

Based on a diff is almost two years old but got delayed several times
... beck@@: "now is the time to get it in" :)

Tested by many
With help from okan@@
OK okan@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.58 2015/01/13 21:42:59 millert Exp $	*/
d165 2
d169 1
@


1.58
log
@Use address-family specific lists of addr/mask entries instead of
a union that can store either ipv4 or ipv6.  The old method used
4x as much memory as was really needed for ipv4.  The spamd-setup
protocol has changed from: tag;message;a/m;a/m;a/m...\n
to :tag;message;af;count;a/m;a/m;a/m...[af;count;a/m;a/m;a/m]\n
OK phessler@@ "nice" beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.57 2014/11/23 21:19:47 guenther Exp $	*/
a55 4
int server_lookup4(struct sockaddr_in *, struct sockaddr_in *,
    struct sockaddr_in *);
int server_lookup6(struct sockaddr_in6 *, struct sockaddr_in6 *,
    struct sockaddr_in6 *);
a57 2
int	server_lookup(struct sockaddr *, struct sockaddr *,
	    struct sockaddr *);
a147 74
}


/* Stolen from ftp-proxy */
int
server_lookup(struct sockaddr *client, struct sockaddr *proxy,
    struct sockaddr *server)
{
	if (client->sa_family == AF_INET)
		return (server_lookup4(satosin(client), satosin(proxy),
		    satosin(server)));

	if (client->sa_family == AF_INET6)
		return (server_lookup6(satosin6(client), satosin6(proxy),
		    satosin6(server)));

	errno = EPROTONOSUPPORT;
	return (-1);
}

int
server_lookup4(struct sockaddr_in *client, struct sockaddr_in *proxy,
    struct sockaddr_in *server)
{
	struct pfioc_natlook pnl;

	memset(&pnl, 0, sizeof pnl);
	pnl.direction = PF_OUT;
	pnl.af = AF_INET;
	pnl.proto = IPPROTO_TCP;
	memcpy(&pnl.saddr.v4, &client->sin_addr.s_addr, sizeof pnl.saddr.v4);
	memcpy(&pnl.daddr.v4, &proxy->sin_addr.s_addr, sizeof pnl.daddr.v4);
	pnl.sport = client->sin_port;
	pnl.dport = proxy->sin_port;

	if (ioctl(pfdev, DIOCNATLOOK, &pnl) == -1)
		return (-1);

	memset(server, 0, sizeof(struct sockaddr_in));
	server->sin_len = sizeof(struct sockaddr_in);
	server->sin_family = AF_INET;
	memcpy(&server->sin_addr.s_addr, &pnl.rdaddr.v4,
	    sizeof server->sin_addr.s_addr);
	server->sin_port = pnl.rdport;

	return (0);
}

int
server_lookup6(struct sockaddr_in6 *client, struct sockaddr_in6 *proxy,
    struct sockaddr_in6 *server)
{
	struct pfioc_natlook pnl;

	memset(&pnl, 0, sizeof pnl);
	pnl.direction = PF_OUT;
	pnl.af = AF_INET6;
	pnl.proto = IPPROTO_TCP;
	memcpy(&pnl.saddr.v6, &client->sin6_addr.s6_addr, sizeof pnl.saddr.v6);
	memcpy(&pnl.daddr.v6, &proxy->sin6_addr.s6_addr, sizeof pnl.daddr.v6);
	pnl.sport = client->sin6_port;
	pnl.dport = proxy->sin6_port;

	if (ioctl(pfdev, DIOCNATLOOK, &pnl) == -1)
		return (-1);

	memset(server, 0, sizeof(struct sockaddr_in6));
	server->sin6_len = sizeof(struct sockaddr_in6);
	server->sin6_family = AF_INET6;
	memcpy(&server->sin6_addr.s6_addr, &pnl.rdaddr.v6,
	    sizeof server->sin6_addr);
	server->sin6_port = pnl.rdport;

	return (0);
@


1.57
log
@Delete a bunch of unnecessary #includes
Use <fcntl.h> instead of <sys/{file,fcntl}.h>

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.56 2014/10/09 02:43:43 deraadt Exp $	*/
d61 1
a61 1
void	configure_spamd(char **, size_t, FILE *);
d79 2
a80 2
size_t whitecount, whitealloc;
size_t trapcount, trapalloc;
d140 1
a140 1
configure_spamd(char **addrs, size_t count, FILE *sdc)
d142 1
a142 1
	size_t i;
d144 1
d147 1
a147 1
		fprintf(sdc, "%s;", traplist_msg);
d149 1
a149 1
			fprintf(sdc, "%s/32;", addrs[i]);
d151 1
a151 1
	fprintf(sdc, "\n");
@


1.56
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.55 2013/11/27 21:25:25 deraadt Exp $	*/
a21 1
#include <sys/fcntl.h>
a25 1
#include <arpa/inet.h>
a27 1
#include <err.h>
@


1.55
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.54 2013/11/19 18:33:57 deraadt Exp $	*/
d416 2
a417 2
			tmp = realloc(whitelist,
			    (whitealloc + 1024) * sizeof(char *));
d453 2
a454 2
			tmp = realloc(traplist,
			    (trapalloc + 1024) * sizeof(char *));
d613 1
a613 1
			tmp = realloc(a, dbk.size * 2);
@


1.54
log
@add a bunch of missing prototypes
ok beck phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.53 2013/08/21 16:13:29 millert Exp $	*/
d322 1
a322 1
		*cp = tolower(*cp);
d344 1
a344 1
			while (len > 0 && isspace(buf[len-1]))
d346 1
a346 1
			while (len > 0 && isspace(*buf)) {
@


1.53
log
@Remove the use of time_t in the greylist db file and use int64_t instead
with backwards compatibility for records with 32-bit times.
OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.52 2012/10/02 15:26:17 okan Exp $	*/
d64 18
d742 2
a743 1
	expire = strtonum(expires, now, sizeof(time_t) == sizeof(int) ? INT_MAX : LLONG_MAX, NULL);
@


1.52
log
@while it's of little harm, it's also been 5.5 years (and 8 releases),
remove the db conversion from BTREE to HASH.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.51 2011/03/03 21:58:58 deraadt Exp $	*/
a542 1
	int			i;
d550 10
a559 2
	i = db->get(db, &dbk, &dbd, 0);
	if (i == -1)
d561 1
a561 5
	if (i)
		/* not in the database */
		return (0);
	memcpy(&gd, dbd.data, sizeof(gd));
	return gd.pcount == -1 ? 1 : 2;
d588 1
a588 1
		if ((dbk.size < 1) || dbd.size != sizeof(struct gdata)) {
a602 1
		memcpy(&gd, dbd.data, sizeof(gd));
d724 1
a724 1
	expire = strtonum(expires, now, INT_MAX, NULL);
d771 1
a771 1
		if (dbd.size != sizeof(gd)) {
a776 1
		memcpy(&gd, dbd.data, sizeof(gd));
d893 1
a893 1
		if (dbd.size != sizeof(gd)) {
a898 1
		memcpy(&gd, dbd.data, sizeof(gd));
d982 1
a982 1
		exit(1);
d1143 5
a1147 4
		greyreader();
		syslog_r(LOG_ERR, &sdata, "greyreader failed (%m)");
		/* NOTREACHED */
		_exit(1);
@


1.51
log
@repair arguments passed to pfctl; PR 6142, ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.50 2010/10/06 09:38:02 stephan Exp $	*/
a1081 65
convert_spamd_db(void)
{
	char		sfn[] = "/var/db/spamd.XXXXXXXXX";
	int		r, fd = -1;
	DB		*db1, *db2;
	BTREEINFO	btreeinfo;
	HASHINFO	hashinfo;
	DBT		dbk, dbd;

	/* try to open the db as a BTREE */
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db1 = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_BTREE,
	    &btreeinfo);
	if (db1 == NULL) {
		syslog_r(LOG_ERR, &sdata,
		    "corrupt db in %s, remove and restart", PATH_SPAMD_DB);
		exit(1);
	}

	if ((fd = mkstemp(sfn)) == -1) {
		syslog_r(LOG_ERR, &sdata,
		    "can't convert %s: mkstemp failed (%m)", PATH_SPAMD_DB);
		exit(1);
	}
	memset(&hashinfo, 0, sizeof(hashinfo));
	db2 = dbopen(sfn, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);
	if (db2 == NULL) {
		unlink(sfn);
		syslog_r(LOG_ERR, &sdata,
		    "can't convert %s:  can't dbopen %s (%m)", PATH_SPAMD_DB,
		sfn);
		db1->close(db1);
		exit(1);
	}

	memset(&dbk, 0, sizeof(dbk));
	memset(&dbd, 0, sizeof(dbd));
		for (r = db1->seq(db1, &dbk, &dbd, R_FIRST); !r;
		    r = db1->seq(db1, &dbk, &dbd, R_NEXT)) {
			if (db2->put(db2, &dbk, &dbd, 0)) {
				db2->sync(db2, 0);
				db2->close(db2);
				db1->close(db1);
				unlink(sfn);
				syslog_r(LOG_ERR, &sdata,
				    "can't convert %s - remove and restart",
				    PATH_SPAMD_DB);
				exit(1);
			}
		}
	db2->sync(db2, 0);
	db2->close(db2);
	db1->sync(db1, 0);
	db1->close(db1);
	rename(sfn, PATH_SPAMD_DB);
	close(fd);
	/* if we are dropping privs, chown to that user */
	if (pw && (chown(PATH_SPAMD_DB, pw->pw_uid, pw->pw_gid) == -1)) {
		syslog_r(LOG_ERR, &sdata,
		    "chown %s failed (%m)", PATH_SPAMD_DB);
		exit(1);
	}
}

static void
a1107 9
			drop_privs();
			return;
			break;
		case EFTYPE:
			/*
			 * db may be old BTREE instead of HASH, attempt to
			 * convert.
			 */
			convert_spamd_db();
@


1.50
log
@do not pass GREY entries to pf's spamd-white table if already TRAPPED.
Fixes pr/6467. (from boudewijn at indes dot com) - ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.49 2010/01/11 10:00:22 beck Exp $	*/
d103 1
a103 1
	"spamd-white", "-T", "replace", "-f" "-", NULL
@


1.49
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.48 2009/11/12 04:08:46 deraadt Exp $	*/
d539 1
d541 1
a541 1
db_notin(DB *db, char *key)
d545 1
a555 3
		return (1);
	else
		/* it is in the database */
d557 2
d613 1
d616 1
d626 2
a627 1
			if (addwhiteaddr(a) == -1) {
d634 1
a634 1
			if (tuple && db_notin(db, a)) {
@


1.48
log
@malloc() after line length check, to avoid memory leak; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.47 2009/04/20 17:42:21 beck Exp $	*/
d149 1
a149 1
	
d172 1
a172 1
	
d182 1
a182 1
		
d200 1
a200 1
	
@


1.47
log
@
PR 6090 - from Olli Hauer <ohauer@@gmx.de>

A number of small improvements:

- patch for empty lines and comments in alloweddomains_file
- remove some whitespaces at end of line.
- document comment and empty line handling
- Remove unused parameter 'r' from getopt in spamd.c, it is removed in the 'switch statement'
  but not in getopt.
  http://www.openbsd.org/cgi-bin/cvsweb/src/libexec/spamd/spamd.c.diff?r1=1.94;r2=1.95;f=h
- replace atoi with strtonum
- make debug output more usefull, display only what will be synced and not a second
  message which prints always "sync trapped %s"

- some cosemtic and whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.46 2009/02/25 19:00:36 beck Exp $	*/
a338 2
			if ((m = malloc(sizeof(struct mail_addr))) == NULL)
				goto bad;
d345 2
@


1.46
log
@fix slow memory leak, spotted by Max Laier and Artis Caune
ok deraadt@@, oga@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.45 2008/12/07 21:12:52 cloder Exp $	*/
d319 1
a319 1
		m = SLIST_FIRST(&match_suffix);	  
d325 12
d548 1
a548 2
	memset(&dbd, 0,
 sizeof(dbd));
d852 1
a852 1
			/* we haven't seen a greylist entry for this tuple, 
@


1.45
log
@time_t is signed, so use INT_MAX rather than UINT_MAX when parsing a time_t
with strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.44 2008/08/26 22:49:09 jsg Exp $	*/
d318 2
a319 1
	while (!SLIST_EMPTY(&match_suffix))
d321 2
d343 2
a344 1
	while (!SLIST_EMPTY(&match_suffix))
d346 2
d521 1
@


1.44
log
@Fix an if (); typo. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.43 2008/07/11 14:53:32 reyk Exp $	*/
d700 1
a700 1
	expire = strtonum(expires, now, UINT_MAX, NULL);
@


1.43
log
@write a syslog debug message when a new GREY or TRAPPED entry is added
to the database.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.42 2008/07/11 01:40:50 phessler Exp $	*/
d296 1
a296 1
	if (*addr == '<');
@


1.42
log
@greyreader() shouldn't return, so tell us if it does

ok beck@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.41 2007/11/03 19:16:07 beck Exp $	*/
d743 1
a743 1
		    "New %s from %s for %s, expires %s", what, source, ip,
d865 3
@


1.41
log
@

PR 5621 - spamd doesn't clear the last entry from an empty TRAP list,
noticed and patch from Piotr Sikora <piotr@@sikora.nu>
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.40 2007/08/16 04:42:16 ray Exp $	*/
d1193 1
@


1.40
log
@- Don't fill spamd debug with bogus config errors if there are no
  traps.
- Change count to size_t to avoid a size_t -> int conversion.
- Since configure_spamd always returns 0, change to void.
- Since configure_spamd now returns void, remove unreachable logging
  statement.

OK ckuethe and deraadt, initial diff from fgsch@@ and OKed by beck.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.39 2007/03/18 18:38:57 beck Exp $	*/
d129 6
a134 5
	if (count == 0)
		return;
	fprintf(sdc, "%s;%s;", traplist_name, traplist_msg);
	for (i = 0; i < count; i++)
		fprintf(sdc, "%s/32;", addrs[i]);
@


1.39
log
@Be sure to exit if the db_open of the second db for conversion fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.38 2007/03/16 01:03:04 beck Exp $	*/
d124 2
a125 2
int
configure_spamd(char **addrs, int count, FILE *sdc)
d127 1
a127 1
	int i;
d129 2
a136 1
	return(0);
d632 1
a632 2
	if (configure_spamd(traplist, trapcount, trapcfg) == -1)
		syslog_r(LOG_DEBUG, &sdata, "configure_spamd failed");
@


1.38
log
@now that we leave the grey, avoid annoying re-adds of white entries
by checking for them being in the db first.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.37 2007/03/14 19:39:55 beck Exp $	*/
d1087 2
@


1.37
log
@when using low prio MX trapping, ignore hosts connecting to the low prio
mx for the first minute, to avoid problems if hosts legitimately try it
after we are down.
suggested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.36 2007/03/14 19:13:35 beck Exp $	*/
d519 23
d610 1
a610 1
			if (tuple) {
a621 1

@


1.36
log
@Don't delete grey entries when whitelisting. They expire anyway
and this hides the evidence. Avoids a potential race when
using -M traps where a retry comes in between deletion and
whitelisting.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.35 2007/03/12 03:14:44 beck Exp $	*/
d99 1
d808 3
a810 1
		if (sync && low_prio_mx_ip && (strcmp(cip, low_prio_mx_ip) == 0)) {
d1154 1
@


1.35
log
@log when we trap a host.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.34 2007/03/06 23:38:36 beck Exp $	*/
a569 1
			 * remove this tuple-keyed  entry from db
a586 4
				if (cp != NULL)
					*cp = '\n';
				if (queue_change(a, NULL, 0, DBC_DEL) == -1)
					goto bad;
@


1.34
log
@Add -M option to specify a local address that is a lower priority MX
address than the primary one. spamd will trap hosts that contact this
address first without first contacting the primary.
- get it in, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.33 2007/03/05 15:09:01 beck Exp $	*/
d796 2
@


1.33
log
@don't make everything a sync once we see one, reset this once
we save the entry.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.32 2007/03/05 02:10:46 deraadt Exp $	*/
d56 8
d98 2
d137 74
d723 3
a753 2
	syslog_r(LOG_DEBUG, &sdata, "Update from %s for %s %s, expires %s",
	    source, what, ip, expires);
d762 2
a763 1
greyupdate(char *dbname, char *helo, char *ip, char *from, char *to, int sync)
d810 13
d875 3
a877 1
		if (spamtrap)
d879 1
d918 2
a919 1
	char ip[32], helo[MAX_MAIL], from[MAX_MAIL], to[MAX_MAIL], *buf;
d961 2
d997 1
a997 1
			greyupdate(PATH_SPAMD_DB, helo, ip, from, to, sync);
a1151 6
	pfdev = open("/dev/pf", O_RDWR);
	if (pfdev == -1) {
		syslog_r(LOG_ERR, &sdata, "open of /dev/pf failed (%m)");
		exit(1);
	}

d1171 2
d1177 1
a1177 1
	fclose(grey);
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.31 2007/03/04 03:24:47 deraadt Exp $	*/
d893 1
@


1.31
log
@bob writes some of the most horrid space and tab riddled messy code around
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.30 2007/03/04 03:19:41 beck Exp $	*/
d79 1
a79 1
SLIST_HEAD(,  db_change) db_changes = SLIST_HEAD_INITIALIZER(db_changes);
d216 1
a216 1
	while(*cp != '\0') {
d1080 1
a1080 1
	sigaction(SIGHUP,  &sa, NULL);
@


1.30
log
@
Database synchronizaton for spamd/spamlogd

This adds an HMAC protected synchronization protocol for use by spamd and
spamlogd.

- spamd can receive updates from other hosts for GREY, WHITE, and TRAPPED db
entries, and will update the local /var/db/spamd accordingly.

- spamd can send updates when it makes changes to the GREY or TRAPPED
entries in the db to other hosts running spamd. (Note it does not send
WHITE entries because the other spamd will see the GREY changes and have
complete information to make appropritate decisions)

- spamlogd can send updates for WHITE db entries that it performs on the local
db to other hosts running spamd, which will then apply them on remote hosts.

note that while this diff provides synchronization for changes made to the
spamd db by the daemons, it does *not* provide for sychonizing changes
to the spamd db made manually with the spamdb command.

Synchronization protocol and most of the work by reyk@@,
with a bunch of the spamd, and spamlogd stuff by me.

testing mostly at the U of A, running happily there under big load.

ok reyk@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.29 2007/02/23 22:40:50 beck Exp $	*/
d51 2
a52 2
extern FILE * trapcfg;
extern FILE * grey;
d227 1
a227 1
	char * buf;
d352 2
a353 1
queue_change(char *key, char *data, size_t dsiz, int act) {
d382 2
a383 1
do_changes(DB *db) {
a432 1

a489 1

d585 2
a586 1
twupdate(char *dbname, char *what, char *ip, char *source, char *expires) {
d594 1
a594 1
	
d626 1
a626 1
 		memset(&dbk, 0, sizeof(dbk));
d791 3
a793 2
twread(char * buf) {
	if ((strncmp(buf, "WHITE:", 6) == 0) || 
d795 1
a795 1
	  	char **ap, *argv[5];
d797 5
a801 4
	        for (ap = argv; ap < &argv[4] &&
        	(*ap = strsep(&buf, ":")) != NULL;) {
                	if (**ap != '\0')
                        ap++;
d803 2
a804 2
	  	}
	        *ap = NULL;
d806 1
a806 1
			return(-1);
d808 1
a808 1
		return 0;
d810 2
a811 2
		return -1;
}	
d1022 2
a1023 2
			 *  db may be old BTREE instead of HASH, attempt to
			 *  convert.
@


1.29
log
@Make spamd include the HELO/EHLO identification string sent by
the connecting hosts in the tuple key when greylisting. catches
a few more bogus hosts and will let us trap based on HELO later.

Changes spamdb(8) output to include the new field.

ok deraadt@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.28 2007/02/23 19:45:08 beck Exp $	*/
d44 1
d54 1
d585 92
a676 1
greyupdate(char *dbname, char *helo, char *ip, char *from, char *to)
d772 8
d790 21
d815 1
a815 1
	int state;
d825 1
d843 5
d850 4
d889 1
a889 1
			greyupdate(PATH_SPAMD_DB, helo, ip, from, to);
@


1.28
log
@make dequotetolower use regular string functions instead of the manual
walk with mutiple conditions in the loop.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.27 2007/02/23 19:36:23 deraadt Exp $	*/
d583 1
a583 1
greyupdate(char *dbname, char *ip, char *from, char *to)
d601 1
a601 1
	if (asprintf(&key, "%s\n%s\n%s", ip, from, to) == -1)
d691 1
a691 1
	char ip[32], from[MAX_MAIL], to[MAX_MAIL], *buf;
d722 8
d735 1
a735 1
				state = 1;
d739 1
a739 1
		case 1:
d745 1
a745 1
			state = 2;
d747 1
a747 1
		case 2:
d755 3
a757 3
				    "Got Grey IP %s from %s to %s\n",
				    ip, from, to);
			greyupdate(PATH_SPAMD_DB, ip, from, to);
@


1.27
log
@continue collecting lint to be sold as a parsley substitute; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.26 2007/02/23 19:28:39 deraadt Exp $	*/
d205 1
a205 1
	int i;
d209 10
a218 6
	for (i = 0; addr[i] != '\0' && i < sizeof(buf); i++)
		buf[i] = tolower(addr[i]);
	buf[i]='\0';
	if (i > 0 && buf[i-1] == '>')
		buf[i-1] = '\0';
	return (buf);
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.25 2007/02/23 19:22:07 beck Exp $	*/
a63 1
int spamdconf;
@


1.25
log
@greytrapping improvements
	1) remove requirement for <> around spamtrap addresses
	2) add support for /etc/spamd/alloweddomains to specify
	   suffixes for which any destinations that don't match
	   get trapped

	various knf's by theo, feedback from jmc, millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.24 2007/01/04 21:41:37 beck Exp $	*/
d370 1
a370 1
	     dbc->key);
d383 1
a383 1
		switch(dbc->act) {
d855 1
a855 1
        if (db == NULL) {
d870 1
a870 1
	                close(i);
d909 1
a909 1
	switch(db_pid) {
@


1.24
log
@        Using DB_BTREE for spamd is wrong, order is never required
and the rebalancing really slags big databases. Make spamd use DB_HASH
instead, and convert if the old type is noticed on startup.

Testing by me, djm, ian, others
ok deraadt@@, millert@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.23 2006/12/07 21:10:41 otto Exp $	*/
d80 9
d202 50
d373 1
a373 1
}	
d377 1
a377 1
	DBT			dbk, dbd;	 		
d424 1
a424 1
}	
d507 1
a507 1
 				dbd.size = sizeof(gd);
d544 36
a585 1
	char		*trap = NULL;
d589 1
a589 1
	int		i, r, spamtrap;
d600 4
a603 14
	if ((trap = strdup(to)) == NULL)
		goto bad;
	for (i = 0; trap[i] != '\0'; i++)
		if (isupper(trap[i]))
			trap[i] = tolower(trap[i]);
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(trap);
	dbk.data = trap;
	memset(&dbd, 0, sizeof(dbd));
	r = db->get(db, &dbk, &dbd, 0);
	if (r == -1)
		goto bad;
	if (r) {
		/* didn't exist - so this doesn't match a known spamtrap  */
d607 3
a609 2
	} else {
		/* To: address is a spamtrap, so add as a greytrap entry */
d613 4
a673 2
	free(trap);
	trap = NULL;
a679 2
	free(trap);
	trap = NULL;
d704 4
d784 1
a784 1
	char 		sfn[] = "/var/db/spamd.XXXXXXXXX";
d786 1
a786 1
	DB 		*db1, *db2;
d800 1
a800 1
	
d805 1
a805 2
		
	}	
d813 1
a813 1
	}		
d857 1
a857 1
		case ENOENT: 
@


1.23
log
@check exit status of the pfctl command executed. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.22 2005/05/15 17:11:14 beck Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004,2005 Bob Beck.  All rights reserved.
d66 14
d112 2
a113 1
	fflush(sdc);
d287 80
d371 1
a371 1
	BTREEINFO	btreeinfo;
d381 2
a382 3

	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
d392 1
d409 1
a409 3
			if (debug)
				fprintf(stderr, "deleting %s\n", a);
			if (db->del(db, &dbk, 0)) {
d411 1
a411 3
			}
			db->sync(db, 0);
		} else if (gd.pcount == -1) {
d414 1
a414 2
			    db->del(db, &dbk, 0)) {
				db->sync(db, 0);
a415 3
			}
			if (debug)
				fprintf(stderr, "trapped %s\n", a);
d425 1
d431 6
a436 3
			if ((addwhiteaddr(a) == -1) && db->del(db, &dbk, 0)) {
				db->sync(db, 0);
				goto bad;
d438 1
d440 3
a442 2
				if (db->del(db, &dbk, 0)) {
					db->sync(db, 0);
d444 2
a445 1
				}
a446 4
				memset(&dbk, 0, sizeof(dbk));
				dbk.size = strlen(a);
				dbk.data = a;
				memset(&dbd, 0, sizeof(dbd));
d448 1
a448 1
				dbd.size = sizeof(gd);
d450 2
a451 2
				if (db->put(db, &dbk, &dbd, 0)) {
					db->sync(db, 0);
a452 2
				}
				db->sync(db, 0);
d461 1
d474 1
d487 1
a487 1
	BTREEINFO	btreeinfo;
d500 2
a501 2
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
a667 2
	int i;

d669 1
a669 3
		sleep(DB_SCAN_INTERVAL);
		i = greyscan(PATH_SPAMD_DB);
		if (i == -1)
d672 1
d677 17
a693 2
int
greywatcher(void)
d695 31
a725 2
	int i;
	struct sigaction sa;
d727 25
a751 3
	pfdev = open("/dev/pf", O_RDWR);
	if (pfdev == -1) {
		syslog_r(LOG_ERR, &sdata, "open of /dev/pf failed (%m)");
d754 8
d764 33
a796 10
	if ((i = open(PATH_SPAMD_DB, O_RDWR, 0)) == -1 && errno == ENOENT) {
		i = open(PATH_SPAMD_DB, O_RDWR|O_CREAT, 0644);
		if (i == -1) {
			syslog_r(LOG_ERR, &sdata, "create %s failed (%m)",
			    PATH_SPAMD_DB);
			exit(1);
		}
		/* if we are dropping privs, chown to that user */
		if (pw && (fchown(i, pw->pw_uid, pw->pw_gid) == -1)) {
			syslog_r(LOG_ERR, &sdata, "chown %s failed (%m)",
d801 4
a804 2
	if (i != -1)
		close(i);
d806 10
a815 10
	/*
	 * lose root, continue as non-root user
	 * XXX Should not be _spamd - as it currently is.
	 */
	if (pw) {
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
d818 2
d836 1
@


1.22
log
@move db->close to not hold this lock unnecssarily during long protracted
operations. ok millert@@ ages ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.21 2005/03/12 00:02:07 beck Exp $	*/
d106 1
a106 1
	int i, pdes[2];
d165 9
a173 1
	waitpid(pid, NULL, 0);
@


1.21
log
@asprintf in place of strdup really is kind of lame
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.20 2005/03/11 23:09:52 beck Exp $	*/
d365 2
a370 2
	db->close(db);
	db = NULL;
@


1.20
log
@"Greytrapping" for spamd - allow for spamd greylisting to maintain
a list of spamtrap destination addresses in the spamd database. When
a spamtrap address gets an attempted greylist delivery, blacklist the
offending host for a day. Does not affect hosts already whitelisted.

ok deraadt@@, jmc@@, dhartmei@@ to get it in so it can be whacked on
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.19 2004/12/04 00:24:42 moritz Exp $	*/
d408 1
a408 1
	if (asprintf(&trap, "%s",to) == -1)
@


1.19
log
@fix a signal race which could kill unrelated processes.
signal handler could be interrupted by another instance
of itself because it was used for multiple signals and
only one signal was blocked.
ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.18 2004/09/15 00:46:46 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Bob Beck.  All rights reserved.
d28 1
d45 1
a45 1
extern time_t passtime, greyexp, whiteexp;
d48 1
d50 1
d55 1
d57 5
d64 1
a70 1

d83 19
d171 1
a171 1
freewhiteaddr(void)
d181 7
d227 38
d273 2
d289 5
a293 1
		char a[128];
d295 5
a299 4
		if ((dbk.size < 1) || dbd.size != sizeof(struct gdata)) {
			db->close(db);
			db = NULL;
			return(-1);
d301 2
d304 1
a304 1
		if (gd.expire <= now) {
d306 2
a307 7
			if (debug) {
				memset(a, 0, sizeof(a));
				memcpy(a, dbk.data, MIN(sizeof(a),
				    dbk.size));
				syslog_r(LOG_DEBUG, &sdata,
				    "deleting %s from %s", a, dbname);
			}
d309 1
a309 3
				db->close(db);
				db = NULL;
				return(-1);
d312 10
a321 1
		} else if (gd.pass  <= now) {
a329 2
			memset(a, 0, sizeof(a));
			memcpy(a, dbk.data, MIN(sizeof(a) - 1, dbk.size));
d366 3
d371 4
a374 1
	freewhiteaddr();
d379 4
a382 1
	freewhiteaddr();
d393 2
d396 2
a397 2
	time_t		now;
	int		r;
d408 23
d432 2
a433 2
	dbk.size = strlen(key);
	dbk.data = key;
d443 3
a445 2
		gd.pass = now + greyexp;
		gd.expire = now + greyexp;
d447 2
a448 2
		dbk.size = strlen(key);
		dbk.data = key;
d457 2
a458 1
			fprintf(stderr, "added %s\n", key);
d469 1
d473 2
a474 2
		dbk.size = strlen(key);
		dbk.data = key;
d483 1
a483 1
			fprintf(stderr, "updated %s\n", key);
d487 2
d495 2
@


1.18
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.17 2004/08/15 21:49:45 millert Exp $	*/
d81 5
d108 1
a108 1
		signal(SIGCHLD, sig_term_chld);
d130 1
a130 1
		signal(SIGCHLD, sig_term_chld);
d138 1
a138 1
	signal(SIGCHLD, sig_term_chld);
d463 1
d522 7
a528 4
	signal(SIGTERM, sig_term_chld);
	signal(SIGHUP,  sig_term_chld);
	signal(SIGCHLD, sig_term_chld);
	signal(SIGINT, sig_term_chld);
@


1.17
log
@Expire entries that exactly match the time now in addition to ones
with an expire time in the past.  From beck@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.16 2004/08/08 19:32:45 deraadt Exp $	*/
d63 1
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.15 2004/07/04 22:46:47 deraadt Exp $	*/
d216 1
a216 1
		if (gd.expire < now) {
@


1.15
log
@two missing freeaddrinfo() -- leak; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.14 2004/06/21 17:07:01 itojun Exp $	*/
d468 1
a468 1
			syslog_r(LOG_ERR, &sdata, "create %s failed (%m)", 
d474 1
a474 1
			syslog_r(LOG_ERR, &sdata, "chown %s failed (%m)", 
d497 1
a497 1
		syslog_r(LOG_ERR, &sdata, "fork failed (%m)"); 
@


1.14
log
@restrict address resolution to AF_INET for now
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.13 2004/06/21 17:05:43 itojun Exp $	*/
d167 2
a168 1
			if (tmp == NULL)
d170 1
d175 2
a176 1
		if (whitelist[whitecount] == NULL)
d178 1
@


1.13
log
@use getaddr/nameinfo for address resolution.  beck, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.12 2004/03/13 17:46:15 beck Exp $	*/
d156 1
d378 1
@


1.12
log
@Add signal handler to parent, so that when greylisting we don't need to
kill all three processes to make it go away. Adjust daemon() call and
logging appropriately.
ok henning@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.11 2004/03/11 17:48:59 millert Exp $	*/
d40 1
d153 1
a153 2
	struct in_addr	ia;
	struct in6_addr	ia6;
d155 6
a160 1
	if (inet_pton(AF_INET, addr, &ia) == 1) {
d175 1
a175 3
	} else if (inet_pton(AF_INET6, addr, &ia6) == 1) {
		/* XXX deal with v6 later */
		return(-1);
d374 6
a379 1
	struct in_addr ia;
d400 2
a401 1
			if (inet_pton(AF_INET, ip, &ia) == 1)
d403 1
a403 1
			else
@


1.11
log
@Remove sync() calls that immediately precede databse close().  Since
close() calls sync() itself the standalone sync() is a no-op.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.10 2004/03/11 17:29:50 beck Exp $	*/
d33 1
d46 1
d52 1
d60 12
d93 1
d101 1
d123 1
d131 1
d374 4
a377 2
	if (grey == NULL)
		errx(-1, "No greylist pipe stream!\n");
a440 1
	pid_t pid;
d444 4
a447 2
	if (pfdev == -1)
		err(1, "open of /dev/pf failed");
d452 5
a456 2
		if (i == -1)
			err(1, "can't create %s", PATH_SPAMD_DB);
d458 5
a462 2
		if (pw && (fchown(i, pw->pw_uid, pw->pw_gid) == -1))
			err(1, "can't chown %s", PATH_SPAMD_DB);
d479 2
a480 7
	if (!debug) {
		if (daemon(1, 1) == -1)
			err(1, "daemon");
	}

	pid = fork();
	switch(pid) {
d482 2
a483 1
		err(1, "fork");
d500 5
@


1.10
log
@Call db-sync() after each db modification since they aren't all that
frequent in the scheme of things and this avoids the possibility
of database corruption. Run here for a week.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.9 2004/03/10 00:33:56 deraadt Exp $	*/
a250 1
	db->sync(db, 0);
a255 1
	db->sync(db, 0);
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.8 2004/03/05 00:31:05 beck Exp $	*/
a198 1
				db->sync(db, 0);
d203 1
d220 2
a221 1
			if ((addwhiteaddr(a) == -1) && db->del(db, &dbk, 0))
d223 1
d225 2
a226 1
				if (db->del(db, &dbk, 0))
d228 1
d237 2
a238 1
				if (db->put(db, &dbk, &dbd, 0))
d240 2
d244 1
d305 1
d315 1
d329 1
@


1.8
log
@Fix really dumb memory leak that would have long runnign large whitelist
servers having their pf update process growing massive as it leaked
huge tracks of whitelist.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.7 2004/03/01 17:03:10 otto Exp $	*/
d116 1
a116 1
void 
d426 1
a426 1
	} 
@


1.7
log
@uset inet_pton(3) instead of home grown address validator; some other cleanup
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.6 2004/02/28 00:03:59 beck Exp $	*/
d109 1
a109 1
		if (addrs[i] != NULL) {
a110 3
			free(addrs[i]);
			addrs[i] = NULL;
		}
d116 13
d246 1
d252 1
@


1.6
log
@- ensure greylist entry expiry is not updated until actually whitelisted
  to avoid keeping multiple grey entries around from a single host for
  extra time.
- make -G work
- paranoia and cleanup suggestions from deraadt@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.5 2004/02/26 08:52:58 beck Exp $	*/
a51 30
/* borrowed from dhartmei.. */
int
address_valid_v4(const char *a)
{
	if (!*a)
		return (0);
	while (*a)
		if ((*a >= '0' && *a <= '9') || *a == '.')
			a++;
		else
			return (0);
	return (1);
}

int
address_valid_v6(const char *a)
{
	if (!*a)
		return (0);
	while (*a)
		if ((*a >= '0' && *a <= '9') ||
		    (*a >= 'a' && *a <= 'f') ||
		    (*a >= 'A' && *a <= 'F') ||
		    *a == ':')
			a++;
		else
			return (0);
	return (1);
}

d123 2
a124 1
	struct in_addr ia;
d126 7
a132 14
	if (address_valid_v4(addr)) {
		if (inet_aton(addr, &ia) == 1) {
			if (whitecount == whitealloc) {
				char **tmp;

				tmp = realloc(whitelist,
				    (whitealloc + 1024) * sizeof(char **));
				if (tmp == NULL)
					return(-1);
				whitelist = tmp;
				whitealloc += 1024;
			}
			whitelist[whitecount] = strdup(addr);
			if (whitelist[whitecount] == NULL)
d134 2
a135 1
			whitecount++;
d137 5
a141 1
	} else if (address_valid_v6(addr)) {
d331 1
d350 1
a350 1
			if (address_valid_v4(ip))
@


1.5
log
@don't leak one here either.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.4 2004/02/26 08:50:40 beck Exp $	*/
d42 1
a51 4
DB		*db;
DBT		dbk, dbd;
BTREEINFO	btreeinfo;

d105 1
d112 1
d130 1
d135 1
d183 5
a188 2
	struct gdata gd;
	int r;
d206 1
d222 1
d225 1
a225 1
		} else if (gd.pass < now) {
d251 1
d278 7
a284 4
	char *key = NULL;
	struct gdata gd;
	time_t now;
	int r;
d307 2
a308 2
		gd.pass = now + GREYEXP;
		gd.expire = now + GREYEXP;
d329 1
a329 1
		if (gd.first + PASSTIME < now) {
a330 2
			gd.expire = now + WHITEEXP;
		}
d344 1
d350 1
d414 2
d418 4
a421 1
		greyscan(PATH_SPAMD_DB);
d462 1
a462 1
			err(1, "fork");
d466 2
a467 1
	if (pid == -1)
d469 1
a469 1
	if (pid == 0) {
d477 2
a478 8
	} else {
		/*
		 * parent, scans db periodically for changes and updates
		 * pf whitelist table accordingly.
		 */
		fclose(grey);
		setproctitle("(pf <spamd-white> update)");
		greyscanner();
d480 9
a488 1
	return(0);
@


1.4
log
@don't leak an fd here.
@
text
@d1 1
a1 1
/*	$OpenBSD: grey.c,v 1.3 2004/02/26 08:18:56 deraadt Exp $	*/
d429 2
a430 1
	} else if (i != -1)
@


1.3
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d415 1
d422 1
a422 2
	if (open(PATH_SPAMD_DB, O_RDWR, 0) == -1 && errno == ENOENT) {
		int i;
d429 2
a430 1
	}
@


1.2
log
@spaces
@
text
@d1 2
d85 5
a92 2
	static char *argv[11]= {"pfctl", "-p", "/dev/pf", "-q", "-t",
	    "spamd-white", "-T", "replace", "-f" "-", NULL};
d104 1
a104 1
	argv[2] = fdpath;
d114 2
d124 1
a124 1
		execvp(PATH_PFCTL, argv);
d137 1
a137 1
	for (i = 0; i  < count; i++)
d259 1
d264 1
d273 1
a273 1
	time_t now = time(NULL);
d276 2
d335 1
d337 1
a337 1
	free(key);
d342 1
d365 1
a365 1
		switch(state) {
@


1.1
log
@Add -g option for greylisting support for spamd. The greylisting techinque
originates from a paper by Evan Harris which can be found at
http://projects.puremagic.com/greylisting/. This implementation makes
spamd allow for non-blacklisted addresses to be treated as "greylisted".
where they are tracked in a db file, and whitelisted by addition to a
pf table when the same envelope from and to are retried from the same
source IP address. Testing by many, ok deraadt@@
@
text
@d86 1
a86 1
	static char *argv[11]= {"pfctl", "-p", "/dev/pf", "-q", "-t", 
d118 1
a118 1
		syslog_r(LOG_ERR, &sdata, "can't exec %s:%m", PATH_PFCTL); 
d444 1
a444 1
		setproctitle("(%s update)", PATH_SPAMD_DB); 
d452 1
a452 1
		setproctitle("(pf <spamd-white> update)"); 
@

