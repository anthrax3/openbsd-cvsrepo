head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.14
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.12
	OPENBSD_5_0:1.8.0.10
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.10.20.21.09.46;	author mestre;	state Exp;
branches;
next	1.11;
commitid	ujt9KK3kLsMhYozP;

1.11
date	2014.11.23.21.19.47;	author guenther;	state Exp;
branches;
next	1.10;
commitid	pQM9z0R0Rd8tOlkz;

1.10
date	2013.11.19.18.33.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.04.02.36.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.20.17.42.21;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.22.19.54.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.09.07.09.17;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.07.08.50.15;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.27.10.50.06;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.13.05.55.03;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.16.23.08.06;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.04.03.19.41;	author beck;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2007.04.28.02.25.52;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.12
log
@- Remove useless var assignment
- Use memset(*b, 0, len) instead of bzero(*b, len)
- Use memcpy(*dst, *src, len) instead of bcopy(*src, *dst, len)
- Use explicit_bzero(3) instead of bzero(3) to clean temporary HMAC

Remarks from deraadt@@ (duly noted!!), reviewed and OK by henning@@ and tb@@
@
text
@/*	$OpenBSD: sync.c,v 1.11 2014/11/23 21:19:47 guenther Exp $	*/

/*
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <sys/queue.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sha1.h>
#include <syslog.h>
#include <stdint.h>

#include <netdb.h>

#include <openssl/hmac.h>

#include "sdl.h"
#include "grey.h"
#include "sync.h"

extern struct syslog_data sdata;
extern int debug;
extern FILE *grey;
extern int greylist;

u_int32_t sync_counter;
int syncfd;
int sendmcast;
struct sockaddr_in sync_in;
struct sockaddr_in sync_out;
static char *sync_key;

struct sync_host {
	LIST_ENTRY(sync_host)	h_entry;

	char			*h_name;
	struct sockaddr_in	sh_addr;
};
LIST_HEAD(synchosts, sync_host) sync_hosts = LIST_HEAD_INITIALIZER(sync_hosts);

void	 sync_send(struct iovec *, int);
void	 sync_addr(time_t, time_t, char *, u_int16_t);

int
sync_addhost(const char *name, u_short port)
{
	struct addrinfo hints, *res, *res0;
	struct sync_host *shost;
	struct sockaddr_in *addr = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &res0) != 0)
		return (EINVAL);
	for (res = res0; res != NULL; res = res->ai_next) {
		if (addr == NULL && res->ai_family == AF_INET) {
			addr = (struct sockaddr_in *)res->ai_addr;
			break;
		}
	}
	if (addr == NULL) {
		freeaddrinfo(res0);
		return (EINVAL);
	}
	if ((shost = (struct sync_host *)
	    calloc(1, sizeof(struct sync_host))) == NULL) {
		freeaddrinfo(res0);
		return (ENOMEM);
	}
	if ((shost->h_name = strdup(name)) == NULL) {
		free(shost);
		freeaddrinfo(res0);
		return (ENOMEM);
	}

	shost->sh_addr.sin_family = AF_INET;
	shost->sh_addr.sin_port = htons(port);
	shost->sh_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
	freeaddrinfo(res0);

	LIST_INSERT_HEAD(&sync_hosts, shost, h_entry);

	if (debug)
		fprintf(stderr, "added spam sync host %s "
		    "(address %s, port %d)\n", shost->h_name,
		    inet_ntoa(shost->sh_addr.sin_addr), port);

	return (0);
}

int
sync_init(const char *iface, const char *baddr, u_short port)
{
	int one = 1;
	u_int8_t ttl;
	struct ifreq ifr;
	struct ip_mreq mreq;
	struct sockaddr_in *addr;
	char ifnam[IFNAMSIZ], *ttlstr;
	const char *errstr;
	struct in_addr ina;

	if (iface != NULL)
		sendmcast++;

	memset(&ina, 0, sizeof(ina));
	if (baddr != NULL) {
		if (inet_pton(AF_INET, baddr, &ina) != 1) {
			ina.s_addr = htonl(INADDR_ANY);
			if (iface == NULL)
				iface = baddr;
			else if (iface != NULL && strcmp(baddr, iface) != 0) {
				fprintf(stderr, "multicast interface does "
				    "not match");
				return (-1);
			}
		}
	}

	sync_key = SHA1File(SPAM_SYNC_KEY, NULL);
	if (sync_key == NULL) {
		if (errno != ENOENT) {
			fprintf(stderr, "failed to open sync key: %s\n",
			    strerror(errno));
			return (-1);
		}
		/* Use empty key by default */
		sync_key = "";
	}

	syncfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (syncfd == -1)
		return (-1);

	if (setsockopt(syncfd, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		goto fail;

	memset(&sync_out, 0, sizeof(sync_out));
	sync_out.sin_family = AF_INET;
	sync_out.sin_len = sizeof(sync_out);
	sync_out.sin_addr.s_addr = ina.s_addr;
	if (baddr == NULL && iface == NULL)
		sync_out.sin_port = 0;
	else
		sync_out.sin_port = htons(port);

	if (bind(syncfd, (struct sockaddr *)&sync_out, sizeof(sync_out)) == -1)
		goto fail;

	/* Don't use multicast messages */
	if (iface == NULL)
		return (syncfd);

	strlcpy(ifnam, iface, sizeof(ifnam));
	ttl = SPAM_SYNC_MCASTTTL;
	if ((ttlstr = strchr(ifnam, ':')) != NULL) {
		*ttlstr++ = '\0';
		ttl = (u_int8_t)strtonum(ttlstr, 1, UINT8_MAX, &errstr);
		if (errstr) {
			fprintf(stderr, "invalid multicast ttl %s: %s",
			    ttlstr, errstr);
			goto fail;
		}
	}

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifnam, sizeof(ifr.ifr_name));
	if (ioctl(syncfd, SIOCGIFADDR, &ifr) == -1)
		goto fail;

	memset(&sync_in, 0, sizeof(sync_in));
	addr = (struct sockaddr_in *)&ifr.ifr_addr;
	sync_in.sin_family = AF_INET;
	sync_in.sin_len = sizeof(sync_in);
	sync_in.sin_addr.s_addr = addr->sin_addr.s_addr;
	sync_in.sin_port = htons(port);

	memset(&mreq, 0, sizeof(mreq));
	sync_out.sin_addr.s_addr = inet_addr(SPAM_SYNC_MCASTADDR);
	mreq.imr_multiaddr.s_addr = inet_addr(SPAM_SYNC_MCASTADDR);
	mreq.imr_interface.s_addr = sync_in.sin_addr.s_addr;

	if (setsockopt(syncfd, IPPROTO_IP,
	    IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1) {
		fprintf(stderr, "failed to add multicast membership to %s: %s",
		    SPAM_SYNC_MCASTADDR, strerror(errno));
		goto fail;
	}
	if (setsockopt(syncfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
	    sizeof(ttl)) < 0) {
		fprintf(stderr, "failed to set multicast ttl to "
		    "%u: %s\n", ttl, strerror(errno));
		setsockopt(syncfd, IPPROTO_IP,
		    IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
		goto fail;
	}

	if (debug)
		printf("using multicast spam sync %smode "
		    "(ttl %u, group %s, port %d)\n",
		    sendmcast ? "" : "receive ",
		    ttl, inet_ntoa(sync_out.sin_addr), port);

	return (syncfd);

 fail:
	close(syncfd);
	return (-1);
}

void
sync_recv(void)
{
	struct spam_synchdr *hdr;
	struct sockaddr_in addr;
	struct spam_synctlv_hdr *tlv;
	struct spam_synctlv_grey *sg;
	struct spam_synctlv_addr *sd;
	u_int8_t buf[SPAM_SYNC_MAXSIZE];
	u_int8_t hmac[2][SPAM_SYNC_HMAC_LEN];
	struct in_addr ip;
	char *from, *to, *helo;
	u_int8_t *p;
	socklen_t addr_len;
	ssize_t len;
	u_int hmac_len;
	u_int32_t expire;

	memset(&addr, 0, sizeof(addr));
	memset(buf, 0, sizeof(buf));

	addr_len = sizeof(addr);
	if ((len = recvfrom(syncfd, buf, sizeof(buf), 0,
	    (struct sockaddr *)&addr, &addr_len)) < 1)
		return;
	if (addr.sin_addr.s_addr != htonl(INADDR_ANY) &&
	    bcmp(&sync_in.sin_addr, &addr.sin_addr,
	    sizeof(addr.sin_addr)) == 0)
		return;

	/* Ignore invalid or truncated packets */
	hdr = (struct spam_synchdr *)buf;
	if (len < sizeof(struct spam_synchdr) ||
	    hdr->sh_version != SPAM_SYNC_VERSION ||
	    hdr->sh_af != AF_INET ||
	    len < ntohs(hdr->sh_length))
		goto trunc;
	len = ntohs(hdr->sh_length);

	/* Compute and validate HMAC */
	memcpy(hmac[0], hdr->sh_hmac, SPAM_SYNC_HMAC_LEN);
	explicit_bzero(hdr->sh_hmac, SPAM_SYNC_HMAC_LEN);
	HMAC(EVP_sha1(), sync_key, strlen(sync_key), buf, len,
	    hmac[1], &hmac_len);
	if (bcmp(hmac[0], hmac[1], SPAM_SYNC_HMAC_LEN) != 0)
		goto trunc;

	if (debug)
		fprintf(stderr,
		    "%s(sync): received packet of %d bytes\n",
		    inet_ntoa(addr.sin_addr), (int)len);

	p = (u_int8_t *)(hdr + 1);
	while (len) {
		tlv = (struct spam_synctlv_hdr *)p;

		if (len < sizeof(struct spam_synctlv_hdr) ||
		    len < ntohs(tlv->st_length))
			goto trunc;

		switch (ntohs(tlv->st_type)) {
		case SPAM_SYNC_GREY:
			sg = (struct spam_synctlv_grey *)tlv;
			if ((sizeof(*sg) +
			    ntohs(sg->sg_from_length) +
			    ntohs(sg->sg_to_length) +
			    ntohs(sg->sg_helo_length)) >
			    ntohs(tlv->st_length))
				goto trunc;

			ip.s_addr = sg->sg_ip;
			from = (char *)(sg + 1);
			to = from + ntohs(sg->sg_from_length);
			helo = to + ntohs(sg->sg_to_length);
			if (debug) {
				fprintf(stderr, "%s(sync): "
				    "received grey entry ",
				    inet_ntoa(addr.sin_addr));
				fprintf(stderr, "helo %s ip %s "
				    "from %s to %s\n",
				    helo, inet_ntoa(ip), from, to);
			}
			if (greylist) {
				/* send this info to the greylister */
				fprintf(grey,
				    "SYNC\nHE:%s\nIP:%s\nFR:%s\nTO:%s\n",
				    helo, inet_ntoa(ip), from, to);
				fflush(grey);
			}
			break;
		case SPAM_SYNC_WHITE:
			sd = (struct spam_synctlv_addr *)tlv;
			if (sizeof(*sd) != ntohs(tlv->st_length))
				goto trunc;

			ip.s_addr = sd->sd_ip;
			expire = ntohl(sd->sd_expire);
			if (debug) {
				fprintf(stderr, "%s(sync): "
				    "received white entry ",
				    inet_ntoa(addr.sin_addr));
				fprintf(stderr, "ip %s ", inet_ntoa(ip));
			}
			if (greylist) {
				/* send this info to the greylister */
				fprintf(grey, "WHITE:%s:", inet_ntoa(ip));
				fprintf(grey, "%s:%u\n",
				    inet_ntoa(addr.sin_addr), expire);
				fflush(grey);
			}
			break;
		case SPAM_SYNC_TRAPPED:
			sd = (struct spam_synctlv_addr *)tlv;
			if (sizeof(*sd) != ntohs(tlv->st_length))
				goto trunc;

			ip.s_addr = sd->sd_ip;
			expire = ntohl(sd->sd_expire);
			if (debug) {
				fprintf(stderr, "%s(sync): "
				    "received trapped entry ",
				    inet_ntoa(addr.sin_addr));
				fprintf(stderr, "ip %s ", inet_ntoa(ip));
			}
			if (greylist) {
				/* send this info to the greylister */
				fprintf(grey, "TRAP:%s:", inet_ntoa(ip));
				fprintf(grey, "%s:%u\n",
				    inet_ntoa(addr.sin_addr), expire);
				fflush(grey);
			}
			break;
		case SPAM_SYNC_END:
			goto done;
		default:
			printf("invalid type: %d\n", ntohs(tlv->st_type));
			goto trunc;
		}
		len -= ntohs(tlv->st_length);
		p = ((u_int8_t *)tlv) + ntohs(tlv->st_length);
	}

 done:
	return;

 trunc:
	if (debug)
		fprintf(stderr, "%s(sync): truncated or invalid packet\n",
		    inet_ntoa(addr.sin_addr));
}

void
sync_send(struct iovec *iov, int iovlen)
{
	struct sync_host *shost;
	struct msghdr msg;

	/* setup buffer */
	memset(&msg, 0, sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = iovlen;

	if (sendmcast) {
		if (debug)
			fprintf(stderr, "sending multicast sync message\n");
		msg.msg_name = &sync_out;
		msg.msg_namelen = sizeof(sync_out);
		sendmsg(syncfd, &msg, 0);
	}

	LIST_FOREACH(shost, &sync_hosts, h_entry) {
		if (debug)
			fprintf(stderr, "sending sync message to %s (%s)\n",
			    shost->h_name, inet_ntoa(shost->sh_addr.sin_addr));
		msg.msg_name = &shost->sh_addr;
		msg.msg_namelen = sizeof(shost->sh_addr);
		sendmsg(syncfd, &msg, 0);
	}
}

void
sync_update(time_t now, char *helo, char *ip, char *from, char *to)
{
	struct iovec iov[7];
	struct spam_synchdr hdr;
	struct spam_synctlv_grey sg;
	struct spam_synctlv_hdr end;
	u_int16_t sglen, fromlen, tolen, helolen, padlen;
	char pad[SPAM_ALIGNBYTES];
	int i = 0;
	HMAC_CTX ctx;
	u_int hmac_len;

	if (debug)
		fprintf(stderr,
		    "sync grey update helo %s ip %s from %s to %s\n",
		    helo, ip, from, to);

	memset(&hdr, 0, sizeof(hdr));
	memset(&sg, 0, sizeof(sg));
	memset(&pad, 0, sizeof(pad));

	fromlen = strlen(from) + 1;
	tolen = strlen(to) + 1;
	helolen = strlen(helo) + 1;

	HMAC_CTX_init(&ctx);
	HMAC_Init(&ctx, sync_key, strlen(sync_key), EVP_sha1());

	sglen = sizeof(sg) + fromlen + tolen + helolen;
	padlen = SPAM_ALIGN(sglen) - sglen;

	/* Add SPAM sync packet header */
	hdr.sh_version = SPAM_SYNC_VERSION;
	hdr.sh_af = AF_INET;
	hdr.sh_counter = htonl(sync_counter++);
	hdr.sh_length = htons(sizeof(hdr) + sglen + padlen + sizeof(end));
	iov[i].iov_base = &hdr;
	iov[i].iov_len = sizeof(hdr);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add single SPAM sync greylisting entry */
	sg.sg_type = htons(SPAM_SYNC_GREY);
	sg.sg_length = htons(sglen + padlen);
	sg.sg_timestamp = htonl(now);
	sg.sg_ip = inet_addr(ip);
	sg.sg_from_length = htons(fromlen);
	sg.sg_to_length = htons(tolen);
	sg.sg_helo_length = htons(helolen);
	iov[i].iov_base = &sg;
	iov[i].iov_len = sizeof(sg);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	iov[i].iov_base = from;
	iov[i].iov_len = fromlen;
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	iov[i].iov_base = to;
	iov[i].iov_len = tolen;
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	iov[i].iov_base = helo;
	iov[i].iov_len = helolen;
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	iov[i].iov_base = pad;
	iov[i].iov_len = padlen;
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add end marker */
	end.st_type = htons(SPAM_SYNC_END);
	end.st_length = htons(sizeof(end));
	iov[i].iov_base = &end;
	iov[i].iov_len = sizeof(end);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	HMAC_Final(&ctx, hdr.sh_hmac, &hmac_len);

	/* Send message to the target hosts */
	sync_send(iov, i);
	HMAC_CTX_cleanup(&ctx);
}

void
sync_addr(time_t now, time_t expire, char *ip, u_int16_t type)
{
	struct iovec iov[3];
	struct spam_synchdr hdr;
	struct spam_synctlv_addr sd;
	struct spam_synctlv_hdr end;
	int i = 0;
	HMAC_CTX ctx;
	u_int hmac_len;

	if (debug)
		fprintf(stderr, "sync %s %s\n",
			type == SPAM_SYNC_WHITE ? "white" : "trapped", ip);

	memset(&hdr, 0, sizeof(hdr));
	memset(&sd, 0, sizeof(sd));

	HMAC_CTX_init(&ctx);
	HMAC_Init(&ctx, sync_key, strlen(sync_key), EVP_sha1());

	/* Add SPAM sync packet header */
	hdr.sh_version = SPAM_SYNC_VERSION;
	hdr.sh_af = AF_INET;
	hdr.sh_counter = htonl(sync_counter++);
	hdr.sh_length = htons(sizeof(hdr) + sizeof(sd) + sizeof(end));
	iov[i].iov_base = &hdr;
	iov[i].iov_len = sizeof(hdr);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add single SPAM sync address entry */
	sd.sd_type = htons(type);
	sd.sd_length = htons(sizeof(sd));
	sd.sd_timestamp = htonl(now);
	sd.sd_expire = htonl(expire);
	sd.sd_ip = inet_addr(ip);
	iov[i].iov_base = &sd;
	iov[i].iov_len = sizeof(sd);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add end marker */
	end.st_type = htons(SPAM_SYNC_END);
	end.st_length = htons(sizeof(end));
	iov[i].iov_base = &end;
	iov[i].iov_len = sizeof(end);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	HMAC_Final(&ctx, hdr.sh_hmac, &hmac_len);

	/* Send message to the target hosts */
	sync_send(iov, i);
	HMAC_CTX_cleanup(&ctx);
}

void
sync_white(time_t now, time_t expire, char *ip)
{
	sync_addr(now, expire, ip, SPAM_SYNC_WHITE);
}

void
sync_trapped(time_t now, time_t expire, char *ip)
{
	sync_addr(now, expire, ip, SPAM_SYNC_TRAPPED);
}
@


1.11
log
@Delete a bunch of unnecessary #includes
Use <fcntl.h> instead of <sys/{file,fcntl}.h>

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.10 2013/11/19 18:33:07 deraadt Exp $	*/
d75 1
a75 1
	bzero(&hints, sizeof(hints));
d131 1
a131 1
	bzero(&ina, sizeof(ina));
d164 1
a164 1
	bzero(&sync_out, sizeof(sync_out));
d192 1
a192 1
	bzero(&ifr, sizeof(ifr));
d197 1
a197 1
	bzero(&sync_in, sizeof(sync_in));
d204 1
a204 1
	bzero(&mreq, sizeof(mreq));
d255 2
a256 2
	bzero(&addr, sizeof(addr));
	bzero(buf, sizeof(buf));
d277 2
a278 2
	bcopy(hdr->sh_hmac, hmac[0], SPAM_SYNC_HMAC_LEN);
	bzero(hdr->sh_hmac, SPAM_SYNC_HMAC_LEN);
d395 1
a395 1
	bzero(&msg, sizeof(msg));
d435 3
a437 3
	bzero(&hdr, sizeof(hdr));
	bzero(&sg, sizeof(sg));
	bzero(&pad, sizeof(pad));
d522 2
a523 2
	bzero(&hdr, sizeof(hdr));
	bzero(&sd, sizeof(sd));
@


1.10
log
@the time being handled here is strictly unsigned 32 bit
ok beck phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.9 2012/12/04 02:36:38 deraadt Exp $	*/
a18 2
#include <sys/file.h>
#include <sys/wait.h>
a19 1
#include <sys/resource.h>
a27 1
#include <err.h>
a28 2
#include <getopt.h>
#include <pwd.h>
@


1.9
log
@rather than a mishmash of headers, this only needs <stdint.h>
with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.8 2009/04/20 17:42:21 beck Exp $	*/
d259 1
a259 1
	time_t expire;
@


1.8
log
@
PR 6090 - from Olli Hauer <ohauer@@gmx.de>

A number of small improvements:

- patch for empty lines and comments in alloweddomains_file
- remove some whitespaces at end of line.
- document comment and empty line handling
- Remove unused parameter 'r' from getopt in spamd.c, it is removed in the 'switch statement'
  but not in getopt.
  http://www.openbsd.org/cgi-bin/cvsweb/src/libexec/spamd/spamd.c.diff?r1=1.94;r2=1.95;f=h
- replace atoi with strtonum
- make debug output more usefull, display only what will be synced and not a second
  message which prints always "sync trapped %s"

- some cosemtic and whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.7 2008/05/22 19:54:11 deraadt Exp $	*/
a18 2
#include <sys/param.h>
#include <sys/stdint.h>
d41 1
@


1.7
log
@version 2 of spamd sync protocol for two reasons:
1) ip addresses were accidentally being sent in host-byte order, which
   caused compatibility problems (spotted by jbg)
2) the sub-headers in the frame were not natively aligned, thus timeout
   values were incorrectly sent by 64-bit machines
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.6 2008/05/09 07:09:17 deraadt Exp $	*/
d526 2
a527 1
		fprintf(stderr, "sync trapped %s\n", ip);
a573 2
	if (debug)
		fprintf(stderr, "sync white address %s\n", ip);
a579 2
	if (debug)
		fprintf(stderr, "sync trapped address %s\n", ip);
@


1.6
log
@As was done in dhcpd, insert pad blocks after sub-messages to keep the
structures aligned to 16 byte boundaries for maximum portability
(somewhat similar to CMSG's).  Old spamd's and new spamd's can still
communicate with this change.  It would be nice if someone tested spamd
on 64-bit unaligned architectures (with and without this change)
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.5 2008/05/07 08:50:15 reyk Exp $	*/
d314 1
a314 1
			ip.s_addr = (u_int32_t)ntohl(sg->sg_ip);
d339 1
a339 1
			ip.s_addr = (u_int32_t)ntohl(sd->sd_ip);
d360 1
a360 1
			ip.s_addr = (u_int32_t)ntohl(sd->sd_ip);
d459 1
a459 1
	hdr.sh_counter = sync_counter++;
d470 1
a470 1
	sg.sg_ip = htonl((u_int32_t)inet_addr(ip));
d537 1
a537 1
	hdr.sh_counter = sync_counter++;
d549 1
a549 1
	sd.sd_ip = htonl((u_int32_t)inet_addr(ip));
@


1.5
log
@check if the received buffer of a sync element is even big enough to
hold the header with length field.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.4 2007/12/27 10:50:06 reyk Exp $	*/
d427 1
a427 1
	struct iovec iov[6];
d431 2
a432 1
	u_int16_t fromlen, tolen, helolen;
d444 1
d453 3
d460 1
a460 2
	hdr.sh_length = htons(sizeof(hdr) +
	    sizeof(sg) + fromlen + tolen + helolen + sizeof(end));
d468 1
a468 1
	sg.sg_length = htons(sizeof(sg) + fromlen + helolen + tolen);
d491 5
@


1.4
log
@Add a missing length check of received spamd sync packet headers.

From Diego Giagio (dgiagio at gmail)
with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.3 2007/04/13 05:55:03 otto Exp $	*/
d300 2
a301 1
		if (len < ntohs(tlv->st_length))
@


1.3
log
@rename h_name to sh_name. hname gets redefined in netdb.h to a zero
sized array, so memory corruption occurs when writing the field.
problem encountered by Jeremy C. Reed. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.2 2007/03/16 23:08:06 beck Exp $	*/
d276 2
a277 1
	if (hdr->sh_version != SPAM_SYNC_VERSION ||
@


1.2
log
@Fix dribbly HMAC leak.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.1 2007/03/04 03:19:41 beck Exp $	*/
d68 1
a68 1
	struct sockaddr_in	h_addr;
d108 3
a110 3
	shost->h_addr.sin_family = AF_INET;
	shost->h_addr.sin_port = htons(port);
	shost->h_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
d118 1
a118 1
		    inet_ntoa(shost->h_addr.sin_addr), port);
d415 3
a417 3
			    shost->h_name, inet_ntoa(shost->h_addr.sin_addr));
		msg.msg_name = &shost->h_addr;
		msg.msg_namelen = sizeof(shost->h_addr);
@


1.1
log
@
Database synchronizaton for spamd/spamlogd

This adds an HMAC protected synchronization protocol for use by spamd and
spamlogd.

- spamd can receive updates from other hosts for GREY, WHITE, and TRAPPED db
entries, and will update the local /var/db/spamd accordingly.

- spamd can send updates when it makes changes to the GREY or TRAPPED
entries in the db to other hosts running spamd. (Note it does not send
WHITE entries because the other spamd will see the GREY changes and have
complete information to make appropritate decisions)

- spamlogd can send updates for WHITE db entries that it performs on the local
db to other hosts running spamd, which will then apply them on remote hosts.

note that while this diff provides synchronization for changes made to the
spamd db by the daemons, it does *not* provide for sychonizing changes
to the spamd db made manually with the spamdb command.

Synchronization protocol and most of the work by reyk@@,
with a bunch of the spamd, and spamlogd stuff by me.

testing mostly at the U of A, running happily there under big load.

ok reyk@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d500 1
d556 1
@


1.1.2.1
log
@sync the syncer to the latest syncer.
r1.2 Fix dribbly HMAC leak. patch by beck@@, ok reyk@@
r1.3 rename h_name to sh_name to avoid memory corruption. patch by otto@@, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.1 2007/03/04 03:19:41 beck Exp $	*/
d68 1
a68 1
	struct sockaddr_in	sh_addr;
d108 3
a110 3
	shost->sh_addr.sin_family = AF_INET;
	shost->sh_addr.sin_port = htons(port);
	shost->sh_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
d118 1
a118 1
		    inet_ntoa(shost->sh_addr.sin_addr), port);
d415 3
a417 3
			    shost->h_name, inet_ntoa(shost->sh_addr.sin_addr));
		msg.msg_name = &shost->sh_addr;
		msg.msg_namelen = sizeof(shost->sh_addr);
a499 1
	HMAC_CTX_cleanup(&ctx);
a554 1
	HMAC_CTX_cleanup(&ctx);
@


