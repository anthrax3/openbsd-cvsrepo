head	1.151;
access;
symbols
	OPENBSD_6_1:1.150.0.4
	OPENBSD_6_1_BASE:1.150
	OPENBSD_6_0:1.143.0.2
	OPENBSD_6_0_BASE:1.143
	OPENBSD_5_9:1.137.0.2
	OPENBSD_5_9_BASE:1.137
	OPENBSD_5_8:1.128.0.4
	OPENBSD_5_8_BASE:1.128
	OPENBSD_5_7:1.125.0.2
	OPENBSD_5_7_BASE:1.125
	OPENBSD_5_6:1.114.0.4
	OPENBSD_5_6_BASE:1.114
	OPENBSD_5_5:1.113.0.4
	OPENBSD_5_5_BASE:1.113
	OPENBSD_5_4:1.112.0.6
	OPENBSD_5_4_BASE:1.112
	OPENBSD_5_3:1.112.0.4
	OPENBSD_5_3_BASE:1.112
	OPENBSD_5_2:1.112.0.2
	OPENBSD_5_2_BASE:1.112
	OPENBSD_5_1_BASE:1.108
	OPENBSD_5_1:1.108.0.10
	OPENBSD_5_0:1.108.0.8
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.108.0.6
	OPENBSD_4_9_BASE:1.108
	OPENBSD_4_8:1.108.0.4
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.108.0.2
	OPENBSD_4_7_BASE:1.108
	OPENBSD_4_6:1.106.0.4
	OPENBSD_4_6_BASE:1.106
	OPENBSD_4_5:1.104.0.4
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.104.0.2
	OPENBSD_4_4_BASE:1.104
	OPENBSD_4_3:1.103.0.2
	OPENBSD_4_3_BASE:1.103
	OPENBSD_4_2:1.102.0.2
	OPENBSD_4_2_BASE:1.102
	OPENBSD_4_1:1.98.0.2
	OPENBSD_4_1_BASE:1.98
	OPENBSD_4_0:1.83.0.2
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.81.0.2
	OPENBSD_3_9_BASE:1.81
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.71.0.2
	OPENBSD_3_6_BASE:1.71
	OPENBSD_3_5:1.64.0.2
	OPENBSD_3_5_BASE:1.64
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26;
locks; strict;
comment	@ * @;


1.151
date	2017.04.06.15.30.12;	author beck;	state Exp;
branches;
next	1.150;
commitid	lGb3ikEOgZRrDthh;

1.150
date	2017.01.23.09.21.04;	author beck;	state Exp;
branches;
next	1.149;
commitid	JFmQ5NEbcIXorsZa;

1.149
date	2017.01.23.09.09.15;	author beck;	state Exp;
branches;
next	1.148;
commitid	0mioR2aw8t172vdX;

1.148
date	2017.01.17.23.28.04;	author mestre;	state Exp;
branches;
next	1.147;
commitid	Fx7y7hu7tMxGsotK;

1.147
date	2016.11.30.07.54.36;	author mestre;	state Exp;
branches;
next	1.146;
commitid	VrqGVNxtSrMgzVpU;

1.146
date	2016.11.08.09.31.55;	author mestre;	state Exp;
branches;
next	1.145;
commitid	miNHb5dEX7DhuMr0;

1.145
date	2016.11.07.22.18.22;	author mestre;	state Exp;
branches;
next	1.144;
commitid	PpczR3T2OVkupJp1;

1.144
date	2016.09.06.11.06.40;	author henning;	state Exp;
branches;
next	1.143;
commitid	erejksDnq5GNaW28;

1.143
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.142;
commitid	02rKn2WBJ6A1ygkh;

1.142
date	2016.05.17.17.51.47;	author jca;	state Exp;
branches;
next	1.141;
commitid	yDshpBUMAmdLFHXn;

1.141
date	2016.04.27.10.24.50;	author mestre;	state Exp;
branches;
next	1.140;
commitid	VsqgcIH8yPgdcarm;

1.140
date	2016.04.10.03.04.21;	author tedu;	state Exp;
branches;
next	1.139;
commitid	PPeTQkq1uXDgfEw1;

1.139
date	2016.03.25.16.31.32;	author mestre;	state Exp;
branches;
next	1.138;
commitid	TRi0dGNwWyh3bSyk;

1.138
date	2016.03.10.00.07.03;	author gsoares;	state Exp;
branches;
next	1.137;
commitid	c5qCtWzqyaitiTIv;

1.137
date	2015.12.12.20.09.28;	author mmcc;	state Exp;
branches;
next	1.136;
commitid	TosXyFD66Z0p2ETT;

1.136
date	2015.12.10.16.06.29;	author beck;	state Exp;
branches;
next	1.135;
commitid	7YcXEB5v1t3ncjnB;

1.135
date	2015.12.08.03.21.09;	author beck;	state Exp;
branches;
next	1.134;
commitid	rBXxy5NrAMI2Ytcs;

1.134
date	2015.12.05.20.32.53;	author henning;	state Exp;
branches;
next	1.133;
commitid	VxLkyTEKnmokeBgS;

1.133
date	2015.12.02.21.10.17;	author henning;	state Exp;
branches;
next	1.132;
commitid	qJaV9RvKwcSXxEhd;

1.132
date	2015.12.02.20.58.43;	author henning;	state Exp;
branches;
next	1.131;
commitid	sZqSTWnmMGlZR1I1;

1.131
date	2015.12.02.19.03.17;	author henning;	state Exp;
branches;
next	1.130;
commitid	f3TBFamVyidqkoag;

1.130
date	2015.09.10.13.56.12;	author beck;	state Exp;
branches;
next	1.129;
commitid	jHDrnrw3jSoQM6MM;

1.129
date	2015.09.10.10.32.16;	author beck;	state Exp;
branches;
next	1.128;
commitid	BtEPgHouFgIPs0kw;

1.128
date	2015.05.18.16.04.21;	author reyk;	state Exp;
branches;
next	1.127;
commitid	BUauTTbpwkWg0A95;

1.127
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.126;
commitid	6b2lLILbgCR1fvia;

1.126
date	2015.03.12.20.07.20;	author millert;	state Exp;
branches;
next	1.125;
commitid	Vq5ZIDMzQcq9Hlkj;

1.125
date	2015.02.22.14.55.40;	author jsing;	state Exp;
branches;
next	1.124;
commitid	qDSb6EAJHuZKbiwf;

1.124
date	2015.02.12.04.23.17;	author jsing;	state Exp;
branches;
next	1.123;
commitid	YIftjrdQsRMjeEvV;

1.123
date	2015.02.07.10.45.19;	author henning;	state Exp;
branches;
next	1.122;
commitid	KM4HBss9hVRsxfE8;

1.122
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	Uu5nFG3wCl0LACBb;

1.121
date	2015.01.13.23.22.33;	author millert;	state Exp;
branches;
next	1.120;
commitid	suyji0oCKtzvNuFo;

1.120
date	2015.01.13.21.49.36;	author millert;	state Exp;
branches;
next	1.119;
commitid	3EkVQKwYW6DNVlzy;

1.119
date	2015.01.13.21.42.59;	author millert;	state Exp;
branches;
next	1.118;
commitid	FcrTmS5RaNh0dgrr;

1.118
date	2014.12.30.23.27.23;	author millert;	state Exp;
branches;
next	1.117;
commitid	vtPMKSUsQWw7OVC0;

1.117
date	2014.12.29.20.39.27;	author millert;	state Exp;
branches;
next	1.116;
commitid	ItQzfIcpqukU8nSy;

1.116
date	2014.11.23.21.19.47;	author guenther;	state Exp;
branches;
next	1.115;
commitid	pQM9z0R0Rd8tOlkz;

1.115
date	2014.10.09.02.43.43;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	sXea7sxYyxWPNIGe;

1.114
date	2014.03.26.13.09.02;	author gsoares;	state Exp;
branches;
next	1.113;

1.113
date	2013.11.19.18.33.38;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2012.06.19.17.43.40;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2012.04.19.19.11.55;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2012.04.18.18.15.44;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2012.04.13.12.24.51;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.14.00.44.12;	author beck;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.11.09.57.00;	author beck;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.20.20.37.43;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2009.04.20.17.42.21;	author beck;	state Exp;
branches;
next	1.104;

1.104
date	2008.07.11.15.05.59;	author reyk;	state Exp;
branches;
next	1.103;

1.103
date	2007.11.03.19.16.07;	author beck;	state Exp;
branches;
next	1.102;

1.102
date	2007.04.13.22.05.43;	author beck;	state Exp;
branches;
next	1.101;

1.101
date	2007.03.26.16.40.56;	author beck;	state Exp;
branches;
next	1.100;

1.100
date	2007.03.26.16.32.39;	author beck;	state Exp;
branches;
next	1.99;

1.99
date	2007.03.26.15.20.43;	author beck;	state Exp;
branches;
next	1.98;

1.98
date	2007.03.07.11.30.43;	author jmc;	state Exp;
branches;
next	1.97;

1.97
date	2007.03.06.23.38.36;	author beck;	state Exp;
branches;
next	1.96;

1.96
date	2007.03.06.01.59.43;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2007.03.05.21.25.29;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2007.03.05.02.06.14;	author beck;	state Exp;
branches;
next	1.93;

1.93
date	2007.03.04.03.19.41;	author beck;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.27.23.03.09;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.27.23.00.54;	author beck;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.27.14.52.31;	author jmc;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.27.02.10.58;	author beck;	state Exp;
branches;
next	1.88;

1.88
date	2007.02.23.22.40.50;	author beck;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.23.19.36.23;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.23.19.22.07;	author beck;	state Exp;
branches;
next	1.85;

1.85
date	2006.11.27.20.46.03;	author beck;	state Exp;
branches;
next	1.84;

1.84
date	2006.10.29.22.06.28;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.15.16.47.48;	author jcs;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.14.22.49.41;	author beck;	state Exp;
branches;
next	1.81;

1.81
date	2005.11.30.20.44.07;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2005.11.12.02.20.37;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.08.04.09.48.27;	author otto;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.23.21.08.43;	author frantzen;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.16.14.23.35;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2005.04.14.16.07.52;	author beck;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.11.23.09.53;	author beck;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.17.15.29.38;	author beck;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.05.15.20.30;	author beck;	state Exp;
branches;
next	1.72;

1.72
date	2004.09.18.07.29.38;	author beck;	state Exp;
branches;
next	1.71;

1.71
date	2004.08.17.09.38.07;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.07.04.22.45.41;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.29.11.19.06;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.21.17.05.43;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.03.01.37.18;	author dhartmei;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.02.23.48.35;	author dhartmei;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.17.14.42.20;	author beck;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.16.09.19.25;	author jmc;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.15.21.53.39;	author beck;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.14.23.09.44;	author beck;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.13.17.46.15;	author beck;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.12.21.02.58;	author beck;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.11.18.32.17;	author beck;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.10.00.33.39;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.10.00.32.54;	author beck;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.28.00.03.59;	author beck;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.26.07.28.55;	author beck;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.09.07.35.25;	author dhartmei;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.08.09.01.04;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.22.21.31.38;	author beck;	state Exp;
branches;
next	1.49;

1.49
date	2003.10.03.17.05.50;	author beck;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.26.16.07.29;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.26.04.42.11;	author beck;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.26.01.58.55;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.24.01.14.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.24.01.14.48;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.18.23.33.44;	author avsm;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.04.01.20.33;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.03.21.22.19;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.26.18.30.03;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.24.23.20.19;	author dhartmei;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.23.21.22.34;	author dhartmei;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.23.20.36.44;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.11.14.24.46;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.17.02.41.19;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.16.22.30.15;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.15.07.16.14;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.12.23.38.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.08.22.09.53;	author vincent;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.30.01.50.21;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.28.20.35.24;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.28.17.52.24;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.20.01.39.36;	author david;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.13.21.20.42;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.09.19.27.30;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.09.19.22.25;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.08.22.05.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.04.05.54.53;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.03.19.35.17;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.03.14.47.37;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.03.00.51.40;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.02.23.55.11;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.02.23.04.35;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.02.22.30.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.02.20.49.10;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.02.20.40.15;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.02.20.32.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.02.19.22.00;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.11.01.41.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.30.09.47.16;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.24.23.39.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.05.23.10.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.30.22.05.57;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.26.01.12.24;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.23.04.04.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.23.01.09.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.21.18.19.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.21.01.41.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.151
log
@fix missing \ on \n, spotted by Edgar Pettijohn
@
text
@/*	$OpenBSD: spamd.c,v 1.150 2017/01/23 09:21:04 beck Exp $	*/

/*
 * Copyright (c) 2015 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2002-2007 Bob Beck.  All rights reserved.
 * Copyright (c) 2002 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <tls.h>

#include <netdb.h>

#include "sdl.h"
#include "grey.h"
#include "sync.h"

struct con {
	struct pollfd *pfd;
	int state;
	int laststate;
	int af;
	int il;
	struct sockaddr_storage ss;
	void *ia;
	char addr[32];
	char caddr[32];
	char helo[MAX_MAIL], mail[MAX_MAIL], rcpt[MAX_MAIL];
	struct sdlist **blacklists;
	struct tls *cctx;

	/*
	 * we will do stuttering by changing these to time_t's of
	 * now + n, and only advancing when the time is in the past/now
	 */
	time_t r;
	time_t w;
	time_t s;

	char ibuf[8192];
	char *ip;
	char rend[5];	/* any chars in here causes input termination */

	char *obuf;
	char *lists;
	size_t osize;
	char *op;
	int ol;
	int data_lines;
	int data_body;
	int stutter;
	int badcmd;
	int sr;
	int tlsaction;
} *con;

#define	SPAMD_TLS_ACT_NONE		0
#define	SPAMD_TLS_ACT_READ_POLLIN	1
#define	SPAMD_TLS_ACT_READ_POLLOUT	2
#define	SPAMD_TLS_ACT_WRITE_POLLIN	3
#define	SPAMD_TLS_ACT_WRITE_POLLOUT	4

#define	SPAMD_USER			"_spamd"

void     usage(void);
char    *grow_obuf(struct con *, int);
int      parse_configline(char *);
void     parse_configs(void);
void     do_config(void);
int      append_error_string (struct con *, size_t, char *, int, void *);
void     doreply(struct con *);
void     setlog(char *, size_t, char *);
void     initcon(struct con *, int, struct sockaddr *);
void     closecon(struct con *);
int      match(const char *, const char *);
void     nextstate(struct con *);
void     handler(struct con *);
void     handlew(struct con *, int one);
char    *loglists(struct con *);
void     getcaddr(struct con *);
void     gethelo(char *, size_t, char *);
int      read_configline(FILE *);
void	 spamd_tls_init(void);
void	 check_spamd_db(void);

char hostname[HOST_NAME_MAX+1];
struct syslog_data sdata = SYSLOG_DATA_INIT;
char *nreply = "450";
char *spamd = "spamd IP-based SPAM blocker";
int greypipe[2];
int trappipe[2];
FILE *grey;
FILE *trapcfg;
time_t passtime = PASSTIME;
time_t greyexp = GREYEXP;
time_t whiteexp = WHITEEXP;
time_t trapexp = TRAPEXP;
struct passwd *pw;
pid_t jail_pid = -1;
u_short cfg_port;
u_short sync_port;
struct tls_config *tlscfg;
struct tls *tlsctx;
uint8_t	*pubcert;
size_t	 pubcertlen;
uint8_t	*privkey;
size_t	 privkeylen;
char 	*tlskeyfile = NULL;
char 	*tlscertfile = NULL;

extern struct sdlist *blacklists;
extern int pfdev;
extern char *low_prio_mx_ip;

time_t slowdowntill;

int conffd = -1;
int trapfd = -1;
char *cb;
size_t cbs, cbu;

time_t t;

#define MAXCON 800
int maxfiles;
int maxcon = MAXCON;
int maxblack = MAXCON;
int blackcount;
int clients;
int debug;
int greylist = 1;
int grey_stutter = 10;
int verbose;
int stutter = 1;
int window;
int syncrecv;
int syncsend;
#define MAXTIME 400

#define MAXIMUM(a,b) (((a)>(b))?(a):(b))

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-45bdv] [-B maxblack] [-C file] [-c maxcon] "
	    "[-G passtime:greyexp:whiteexp]\n"
	    "\t[-h hostname] [-K file] [-l address] [-M address] [-n name]\n"
	    "\t[-p port] [-S secs] [-s secs] "
	    "[-w window] [-Y synctarget] [-y synclisten]\n",
	    __progname);

	exit(1);
}

char *
grow_obuf(struct con *cp, int off)
{
	char *tmp;

	tmp = realloc(cp->obuf, cp->osize + 8192);
	if (tmp == NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
		return (NULL);
	} else {
		cp->osize += 8192;
		cp->obuf = tmp;
		return (cp->obuf + off);
	}
}

int
parse_configline(char *line)
{
	char *cp, prev, *name, *msg, *tmp;
	char **v4 = NULL, **v6 = NULL;
	const char *errstr;
	u_int nv4 = 0, nv6 = 0;
	int mdone = 0;
	sa_family_t af;

	name = line;

	for (cp = name; *cp && *cp != ';'; cp++)
		;
	if (*cp != ';')
		goto parse_error;
	*cp++ = '\0';
	if (!*cp) {
		sdl_del(name);
		return (0);
	}
	msg = cp;
	if (*cp++ != '"')
		goto parse_error;
	prev = '\0';
	for (; !mdone; cp++) {
		switch (*cp) {
		case '\\':
			if (!prev)
				prev = *cp;
			else
				prev = '\0';
			break;
		case '"':
			if (prev != '\\') {
				cp++;
				if (*cp == ';') {
					mdone = 1;
					*cp = '\0';
				} else {
					if (debug > 0)
						printf("bad message: %s\n", msg);
					goto parse_error;
				}
			}
			break;
		case '\0':
			if (debug > 0)
				printf("bad message: %s\n", msg);
			goto parse_error;
		default:
			prev = '\0';
			break;
		}
	}

	while ((tmp = strsep(&cp, ";")) != NULL) {
		char **av;
		u_int au, ac;

		if (*tmp == '\0')
			continue;

		if (strncmp(tmp, "inet", 4) != 0)
			goto parse_error;
		switch (tmp[4]) {
		case '\0':
			af = AF_INET;
			break;
		case '6':
			if (tmp[5] == '\0') {
				af = AF_INET6;
				break;
			}
			/* FALLTHROUGH */
		default:
			if (debug > 0)
				printf("unsupported address family: %s\n", tmp);
			goto parse_error;
		}

		tmp = strsep(&cp, ";");
		if (tmp == NULL) {
			if (debug > 0)
				printf("missing address count\n");
			goto parse_error;
		}
		ac = strtonum(tmp, 0, UINT_MAX, &errstr);
		if (errstr != NULL) {
			if (debug > 0)
				printf("count \"%s\" is %s\n", tmp, errstr);
			goto parse_error;
		}

		av = reallocarray(NULL, ac, sizeof(char *));
		for (au = 0; au < ac; au++) {
			tmp = strsep(&cp, ";");
			if (tmp == NULL) {
				if (debug > 0)
					printf("expected %u addrs, got %u\n",
					    ac, au + 1);
				free(av);
				goto parse_error;
			}
			if (*tmp == '\0')
				continue;
			av[au] = tmp;
		}
		if (af == AF_INET) {
			if (v4 != NULL) {
				if (debug > 0)
					printf("duplicate inet\n");
				goto parse_error;
			}
			v4 = av;
			nv4 = ac;
		} else {
			if (v6 != NULL) {
				if (debug > 0)
					printf("duplicate inet6\n");
				goto parse_error;
			}
			v6 = av;
			nv6 = ac;
		}
	}
	if (nv4 == 0 && nv6 == 0) {
		if (debug > 0)
			printf("no addresses\n");
		goto parse_error;
	}
	sdl_add(name, msg, v4, nv4, v6, nv6);
	free(v4);
	free(v6);
	return (0);

parse_error:
	if (debug > 0)
		printf("bogus config line - need 'tag;message;af;count;a/m;a/m;a/m...'\n");
	free(v4);
	free(v6);
	return (-1);
}

void
parse_configs(void)
{
	char *start, *end;
	size_t i;

	/* We always leave an extra byte for the NUL. */
	cb[cbu++] = '\0';

	start = cb;
	end = start;
	for (i = 0; i < cbu; i++) {
		if (*end == '\n') {
			*end = '\0';
			if (end > start + 1)
				parse_configline(start);
			start = ++end;
		} else
			++end;
	}
	if (end > start + 1)
		parse_configline(start);
}

void
do_config(void)
{
	int n;

	if (debug > 0)
		printf("got configuration connection\n");

	/* Leave an extra byte for the terminating NUL. */
	if (cbu + 1 >= cbs) {
		char *tmp;

		tmp = realloc(cb, cbs + (1024 * 1024));
		if (tmp == NULL) {
			if (debug > 0)
				warn("realloc");
			goto configdone;
		}
		cbs += 1024 * 1024;
		cb = tmp;
	}

	n = read(conffd, cb + cbu, cbs - cbu);
	if (debug > 0)
		printf("read %d config bytes\n", n);
	if (n == 0) {
		if (cbu != 0)
			parse_configs();
		goto configdone;
	} else if (n == -1) {
		if (debug > 0)
			warn("read");
		goto configdone;
	} else
		cbu += n;
	return;

configdone:
	free(cb);
	cb = NULL;
	cbs = 0;
	cbu = 0;
	close(conffd);
	conffd = -1;
	slowdowntill = 0;
}

int
read_configline(FILE *config)
{
	char *buf;
	size_t len;

	if ((buf = fgetln(config, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else
			return (-1);	/* all valid lines end in \n */
		parse_configline(buf);
	} else {
		syslog_r(LOG_DEBUG, &sdata, "read_configline: fgetln (%m)");
		return (-1);
	}
	return (0);
}

void
spamd_tls_init()
{
	if (tlskeyfile == NULL && tlscertfile == NULL)
		return;
	if (tlskeyfile == NULL || tlscertfile == NULL)
		errx(1, "need key and certificate for TLS");

	if (tls_init() != 0)
		errx(1, "failed to initialise tls");
	if ((tlscfg = tls_config_new()) == NULL)
		errx(1, "failed to get tls config");
	if ((tlsctx = tls_server()) == NULL)
		errx(1, "failed to get tls server");

	if (tls_config_set_protocols(tlscfg, TLS_PROTOCOLS_ALL) != 0)
		errx(1, "failed to set tls protocols");

	/* might need user-specified ciphers, tls_config_set_ciphers */
	if (tls_config_set_ciphers(tlscfg, "all") != 0)
		errx(1, "failed to set tls ciphers");

	if (tls_config_set_cert_mem(tlscfg, pubcert, pubcertlen) == -1)
		errx(1, "unable to set TLS certificate file %s", tlscertfile);
	if (tls_config_set_key_mem(tlscfg, privkey, privkeylen) == -1)
		errx(1, "unable to set TLS key file %s", tlskeyfile);
	if (tls_configure(tlsctx, tlscfg) != 0)
		errx(1, "failed to configure TLS - %s", tls_error(tlsctx));

	/* set hostname to cert's CN unless explicitely given? */
}

int
append_error_string(struct con *cp, size_t off, char *fmt, int af, void *ia)
{
	char sav = '\0';
	static int lastcont = 0;
	char *c = cp->obuf + off;
	char *s = fmt;
	size_t len = cp->osize - off;
	int i = 0;

	if (off == 0)
		lastcont = 0;

	if (lastcont != 0)
		cp->obuf[lastcont] = '-';
	snprintf(c, len, "%s ", nreply);
	i += strlen(c);
	lastcont = off + i - 1;
	if (*s == '"')
		s++;
	while (*s) {
		/*
		 * Make sure we at minimum, have room to add a
		 * format code (4 bytes), and a v6 address(39 bytes)
		 * and a byte saved in sav.
		 */
		if (i >= len - 46) {
			c = grow_obuf(cp, off);
			if (c == NULL)
				return (-1);
			len = cp->osize - (off + i);
		}

		if (c[i-1] == '\n') {
			if (lastcont != 0)
				cp->obuf[lastcont] = '-';
			snprintf(c + i, len, "%s ", nreply);
			i += strlen(c);
			lastcont = off + i - 1;
		}

		switch (*s) {
		case '\\':
		case '%':
			if (!sav)
				sav = *s;
			else {
				c[i++] = sav;
				sav = '\0';
				c[i] = '\0';
			}
			break;
		case '"':
		case 'A':
		case 'n':
			if (*(s+1) == '\0') {
				break;
			}
			if (sav == '\\' && *s == 'n') {
				c[i++] = '\n';
				sav = '\0';
				c[i] = '\0';
				break;
			} else if (sav == '\\' && *s == '"') {
				c[i++] = '"';
				sav = '\0';
				c[i] = '\0';
				break;
			} else if (sav == '%' && *s == 'A') {
				inet_ntop(af, ia, c + i, (len - i));
				i += strlen(c + i);
				sav = '\0';
				break;
			}
			/* FALLTHROUGH */
		default:
			if (sav)
				c[i++] = sav;
			c[i++] = *s;
			sav = '\0';
			c[i] = '\0';
			break;
		}
		s++;
	}
	return (i);
}

char *
loglists(struct con *cp)
{
	static char matchlists[80];
	struct sdlist **matches;
	int s = sizeof(matchlists) - 4;

	matchlists[0] = '\0';
	matches = cp->blacklists;
	if (matches == NULL)
		return (NULL);
	for (; *matches; matches++) {

		/* don't report an insane amount of lists in the logs.
		 * just truncate and indicate with ...
		 */
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1 >= s)
			strlcat(matchlists, " ...", sizeof(matchlists));
		else {
			strlcat(matchlists, " ", s);
			strlcat(matchlists, matches[0]->tag, s);
		}
	}
	return matchlists;
}

void
doreply(struct con *cp)
{
	struct sdlist **matches;
	int off = 0;

	matches = cp->blacklists;
	if (matches == NULL)
		goto nomatch;
	for (; *matches; matches++) {
		int used = 0;
		int left = cp->osize - off;

		used = append_error_string(cp, off, matches[0]->string,
		    cp->af, cp->ia);
		if (used == -1)
			goto bad;
		off += used;
		left -= used;
		if (cp->obuf[off - 1] != '\n') {
			if (left < 1) {
				if (grow_obuf(cp, off) == NULL)
					goto bad;
			}
			cp->obuf[off++] = '\n';
			cp->obuf[off] = '\0';
		}
	}
	return;
nomatch:
	/* No match. give generic reply */
	free(cp->obuf);
	cp->obuf = NULL;
	if (cp->blacklists != NULL)
		cp->osize = asprintf(&cp->obuf,
		    "%s-Sorry %s\n"
		    "%s-You are trying to send mail from an address "
		    "listed by one\n"
		    "%s or more IP-based registries as being a SPAM source.\n",
		    nreply, cp->addr, nreply, nreply);
	else
		cp->osize = asprintf(&cp->obuf,
		    "451 Temporary failure, please try again later.\r\n");
	cp->osize++; /* size includes the NUL (also changes -1 to 0) */
	return;
bad:
	if (cp->obuf != NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
	}
}

void
setlog(char *p, size_t len, char *f)
{
	char *s;

	s = strsep(&f, ":");
	if (!f)
		return;
	while (*f == ' ' || *f == '\t')
		f++;
	s = strsep(&f, " \t");
	if (s == NULL)
		return;
	strlcpy(p, s, len);
	s = strsep(&p, " \t\n\r");
	if (s == NULL)
		return;
	s = strsep(&p, " \t\n\r");
	if (s)
		*s = '\0';
}

/*
 * Get address client connected to, by doing a getsockname call.
 * Must not be used with a NAT'ed connection (use divert-to instead of rdr-to).
 */
void
getcaddr(struct con *cp)
{
	struct sockaddr_storage original_destination;
	struct sockaddr *odp = (struct sockaddr *) &original_destination;
	socklen_t len = sizeof(struct sockaddr_storage);
	int error;

	cp->caddr[0] = '\0';
	if (getsockname(cp->pfd->fd, odp, &len) == -1)
		return;
	error = getnameinfo(odp, odp->sa_len, cp->caddr, sizeof(cp->caddr),
	    NULL, 0, NI_NUMERICHOST);
	if (error)
		cp->caddr[0] = '\0';
}

void
gethelo(char *p, size_t len, char *f)
{
	char *s;

	/* skip HELO/EHLO */
	f+=4;
	/* skip whitespace */
	while (*f == ' ' || *f == '\t')
		f++;
	s = strsep(&f, " \t");
	if (s == NULL)
		return;
	strlcpy(p, s, len);
	s = strsep(&p, " \t\n\r");
	if (s == NULL)
		return;
	s = strsep(&p, " \t\n\r");
	if (s)
		*s = '\0';
}

void
initcon(struct con *cp, int fd, struct sockaddr *sa)
{
	struct pollfd *pfd = cp->pfd;
	char ctimebuf[26];
	time_t tt;
	int error;

	if (sa->sa_family != AF_INET)
		errx(1, "not supported yet");

	time(&tt);
	free(cp->obuf);
	free(cp->blacklists);
	free(cp->lists);
	memset(cp, 0, sizeof(*cp));
	if (grow_obuf(cp, 0) == NULL)
		err(1, "malloc");
	cp->pfd = pfd;
	cp->pfd->fd = fd;
	memcpy(&cp->ss, sa, sa->sa_len);
	cp->af = sa->sa_family;
	cp->ia = &((struct sockaddr_in *)&cp->ss)->sin_addr;
	cp->blacklists = sdl_lookup(blacklists, cp->af, cp->ia);
	cp->stutter = (greylist && !grey_stutter && cp->blacklists == NULL) ?
	    0 : stutter;
	error = getnameinfo(sa, sa->sa_len, cp->addr, sizeof(cp->addr), NULL, 0,
	    NI_NUMERICHOST);
#ifdef useless
	if (error)
		errx(1, "%s", gai_strerror(error));
#endif
	ctime_r(&t, ctimebuf);
	ctimebuf[sizeof(ctimebuf) - 2] = '\0'; /* nuke newline */
	snprintf(cp->obuf, cp->osize, "220 %s ESMTP %s; %s\r\n",
	    hostname, spamd, ctimebuf);
	cp->op = cp->obuf;
	cp->ol = strlen(cp->op);
	cp->w = tt + cp->stutter;
	cp->s = tt;
	strlcpy(cp->rend, "\n", sizeof cp->rend);
	clients++;
	if (cp->blacklists != NULL) {
		blackcount++;
		if (greylist && blackcount > maxblack)
			cp->stutter = 0;
		cp->lists = strdup(loglists(cp));
		if (cp->lists == NULL)
			err(1, "malloc");
	}
	else
		cp->lists = NULL;
}

void
closecon(struct con *cp)
{
	time_t tt;

	if (cp->cctx) {
		tls_close(cp->cctx);
		tls_free(cp->cctx);
	}
	close(cp->pfd->fd);
	cp->pfd->fd = -1;

	slowdowntill = 0;

	time(&tt);
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %lld seconds.%s%s",
	    cp->addr, (long long)(tt - cp->s),
	    ((cp->lists == NULL) ? "" : " lists:"),
	    ((cp->lists == NULL) ? "": cp->lists));
	if (debug > 0)
		printf("%s connected for %lld seconds.\n", cp->addr,
		    (long long)(tt - cp->s));
	free(cp->lists);
	cp->lists = NULL;
	if (cp->blacklists != NULL) {
		blackcount--;
		free(cp->blacklists);
		cp->blacklists = NULL;
	}
	if (cp->obuf != NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
	}
	clients--;
}

int
match(const char *s1, const char *s2)
{
	return (strncasecmp(s1, s2, strlen(s2)) == 0);
}

void
nextstate(struct con *cp)
{
	if (match(cp->ibuf, "QUIT") && cp->state < 99) {
		snprintf(cp->obuf, cp->osize, "221 %s\r\n", hostname);
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 99;
		return;
	}

	if (match(cp->ibuf, "RSET") && cp->state > 2 && cp->state < 50) {
		snprintf(cp->obuf, cp->osize,
		    "250 Ok to start over.\r\n");
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 2;
		return;
	}
	switch (cp->state) {
	case 0:
	tlsinitdone:
		/* banner sent; wait for input */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 1;
		cp->r = t;
		break;
	case 1:
		/* received input: parse, and select next state */
		if (match(cp->ibuf, "HELO") ||
		    match(cp->ibuf, "EHLO")) {
			int nextstate = 2;
			cp->helo[0] = '\0';
			gethelo(cp->helo, sizeof cp->helo, cp->ibuf);
			if (cp->helo[0] == '\0') {
				nextstate = 0;
				snprintf(cp->obuf, cp->osize,
				    "501 helo requires domain name.\r\n");
			} else {
				if (cp->cctx == NULL && tlsctx != NULL &&
				    cp->blacklists == NULL &&
				    match(cp->ibuf, "EHLO")) {
					snprintf(cp->obuf, cp->osize,
					    "250-%s\r\n"
					    "250 STARTTLS\r\n",
					    hostname);
					nextstate = 7;
				} else {
					snprintf(cp->obuf, cp->osize,
					    "250 Hello, spam sender. Pleased "
					    "to be wasting your time.\r\n");
				}
			}
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = nextstate;
			cp->w = t + cp->stutter;
			break;
		}
		goto mail;
	case 2:
		/* sent 250 Hello, wait for input */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 3;
		cp->r = t;
		break;
	case 3:
	mail:
		if (match(cp->ibuf, "MAIL")) {
			setlog(cp->mail, sizeof cp->mail, cp->ibuf);
			snprintf(cp->obuf, cp->osize,
			    "250 You are about to try to deliver spam. "
			    "Your time will be spent, for nothing.\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 4;
			cp->w = t + cp->stutter;
			break;
		}
		goto rcpt;
	case 4:
		/* sent 250 Sender ok */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 5;
		cp->r = t;
		break;
	case 5:
	rcpt:
		if (match(cp->ibuf, "RCPT")) {
			setlog(cp->rcpt, sizeof(cp->rcpt), cp->ibuf);
			snprintf(cp->obuf, cp->osize,
			    "250 This is hurting you more than it is "
			    "hurting me.\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 6;
			cp->w = t + cp->stutter;

			if (cp->mail[0] && cp->rcpt[0]) {
				if (verbose)
					syslog_r(LOG_INFO, &sdata,
					    "(%s) %s: %s -> %s",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail,
					    cp->rcpt);
				if (debug)
					fprintf(stderr, "(%s) %s: %s -> %s\n",
					    cp->blacklists ? "BLACK" : "GREY",
					    cp->addr, cp->mail, cp->rcpt);
				if (greylist && cp->blacklists == NULL) {
					/* send this info to the greylister */
					getcaddr(cp);
					fprintf(grey,
					    "CO:%s\nHE:%s\nIP:%s\nFR:%s\nTO:%s\n",
					    cp->caddr, cp->helo, cp->addr,
					    cp->mail, cp->rcpt);
					fflush(grey);
				}
			}
			break;
		}
		goto spam;
	case 6:
		/* sent 250 blah */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 5;
		cp->r = t;
		break;
	case 7:
		/* sent 250 STARTTLS, wait for input */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 8;
		cp->r = t;
		break;
	case 8:
		if (tlsctx != NULL && cp->blacklists == NULL &&
		    cp->cctx == NULL && match(cp->ibuf, "STARTTLS")) {
			snprintf(cp->obuf, cp->osize,
			    "220 glad you want to burn more CPU cycles on "
			    "your spam\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 9;
			cp->w = t + cp->stutter;
			break;
		}
		goto mail;
	case 9:
		if (tls_accept_socket(tlsctx, &cp->cctx, cp->pfd->fd) == -1) {
			snprintf(cp->obuf, cp->osize,
			    "500 STARTTLS failed\r\n");
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->laststate = cp->state;
			cp->state = 98;
			goto done;
		}	
		goto tlsinitdone;

	case 50:
	spam:
		if (match(cp->ibuf, "DATA")) {
			snprintf(cp->obuf, cp->osize,
			    "354 Enter spam, end with \".\" on a line by "
			    "itself\r\n");
			cp->state = 60;
			if (window && setsockopt(cp->pfd->fd, SOL_SOCKET,
			    SO_RCVBUF, &window, sizeof(window)) == -1) {
				syslog_r(LOG_DEBUG, &sdata,"setsockopt: %m");
				/* don't fail if this doesn't work. */
			}
			cp->ip = cp->ibuf;
			cp->il = sizeof(cp->ibuf) - 1;
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->w = t + cp->stutter;
			if (greylist && cp->blacklists == NULL) {
				cp->laststate = cp->state;
				cp->state = 98;
				goto done;
			}
		} else {
			if (match(cp->ibuf, "NOOP"))
				snprintf(cp->obuf, cp->osize,
				    "250 2.0.0 OK I did nothing\r\n");
			else {
				snprintf(cp->obuf, cp->osize,
				    "500 5.5.1 Command unrecognized\r\n");
				cp->badcmd++;
				if (cp->badcmd > 20) {
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
			}
			cp->state = cp->laststate;
			cp->ip = cp->ibuf;
			cp->il = sizeof(cp->ibuf) - 1;
			cp->op = cp->obuf;
			cp->ol = strlen(cp->op);
			cp->w = t + cp->stutter;
		}
		break;
	case 60:
		/* sent 354 blah */
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->laststate = cp->state;
		cp->state = 70;
		cp->r = t;
		break;
	case 70: {
		char *p, *q;

		for (p = q = cp->ibuf; q <= cp->ip; ++q)
			if (*q == '\n' || q == cp->ip) {
				*q = 0;
				if (q > p && q[-1] == '\r')
					q[-1] = 0;
				if (!strcmp(p, ".") ||
				    (cp->data_body && ++cp->data_lines >= 10)) {
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
				}
				if (!cp->data_body && !*p)
					cp->data_body = 1;
				if (verbose && cp->data_body && *p)
					syslog_r(LOG_DEBUG, &sdata, "%s: "
					    "Body: %s", cp->addr, p);
				else if (verbose && (match(p, "FROM:") ||
				    match(p, "TO:") || match(p, "SUBJECT:")))
					syslog_r(LOG_INFO, &sdata, "%s: %s",
					    cp->addr, p);
				p = ++q;
			}
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->r = t;
		break;
	}
	case 98:
	done:
		doreply(cp);
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		cp->laststate = cp->state;
		cp->state = 99;
		break;
	case 99:
		closecon(cp);
		break;
	default:
		errx(1, "illegal state %d", cp->state);
		break;
	}
}

void
handler(struct con *cp)
{
	int end = 0;
	ssize_t n;

	if (cp->r || cp->tlsaction != SPAMD_TLS_ACT_NONE) {
		if (cp->cctx) {
			cp->tlsaction = SPAMD_TLS_ACT_NONE;
			n = tls_read(cp->cctx, cp->ip, cp->il);
			if (n == TLS_WANT_POLLIN)
				cp->tlsaction = SPAMD_TLS_ACT_READ_POLLIN;
			if (n == TLS_WANT_POLLOUT)
				cp->tlsaction = SPAMD_TLS_ACT_READ_POLLOUT;
			if (cp->tlsaction != SPAMD_TLS_ACT_NONE)
				return;
		} else
			n = read(cp->pfd->fd, cp->ip, cp->il);

		if (n == 0)
			closecon(cp);
		else if (n == -1) {
			if (errno == EAGAIN)
				return;
			if (debug > 0)
				warn("read");
			closecon(cp);
		} else {
			cp->ip[n] = '\0';
			if (cp->rend[0])
				if (strpbrk(cp->ip, cp->rend))
					end = 1;
			cp->ip += n;
			cp->il -= n;
		}
	}
	if (end || cp->il == 0) {
		while (cp->ip > cp->ibuf &&
		    (cp->ip[-1] == '\r' || cp->ip[-1] == '\n'))
			cp->ip--;
		*cp->ip = '\0';
		cp->r = 0;
		nextstate(cp);
	}
}

void
handlew(struct con *cp, int one)
{
	ssize_t n;

	/* kill stutter on greylisted connections after initial delay */
	if (cp->stutter && greylist && cp->blacklists == NULL &&
	    (t - cp->s) > grey_stutter)
		cp->stutter=0;

	if (cp->w || cp->tlsaction != SPAMD_TLS_ACT_NONE) {
		if (*cp->op == '\n' && !cp->sr) {
			/* insert \r before \n */
			if (cp->cctx) {
				cp->tlsaction = SPAMD_TLS_ACT_NONE;
				n = tls_write(cp->cctx, "\r", 1);
				if (n == TLS_WANT_POLLIN)
					cp->tlsaction =
					    SPAMD_TLS_ACT_WRITE_POLLIN;
				if (n == TLS_WANT_POLLOUT)
					cp->tlsaction =
					    SPAMD_TLS_ACT_WRITE_POLLOUT;
				if (cp->tlsaction != SPAMD_TLS_ACT_NONE)
					return;
			} else
				n = write(cp->pfd->fd, "\r", 1);

			if (n == 0) {
				closecon(cp);
				goto handled;
			} else if (n == -1) {
				if (errno == EAGAIN)
					return;
				if (debug > 0 && errno != EPIPE)
					warn("write");
				closecon(cp);
				goto handled;
			}
		}
		if (*cp->op == '\r')
			cp->sr = 1;
		else
			cp->sr = 0;
		if (cp->cctx) {
			cp->tlsaction = SPAMD_TLS_ACT_NONE;
			n = tls_write(cp->cctx, cp->op, cp->ol);
			if (n == TLS_WANT_POLLIN)
				cp->tlsaction = SPAMD_TLS_ACT_WRITE_POLLIN;
			if (n == TLS_WANT_POLLOUT)
				cp->tlsaction = SPAMD_TLS_ACT_WRITE_POLLOUT;
			if (cp->tlsaction != SPAMD_TLS_ACT_NONE)
				return;
		} else
			n = write(cp->pfd->fd, cp->op,
			   (one && cp->stutter) ? 1 : cp->ol);

		if (n == 0)
			closecon(cp);
		else if (n == -1) {
			if (errno == EAGAIN)
				return;
			if (debug > 0 && errno != EPIPE)
				warn("write");
			closecon(cp);
		} else {
			cp->op += n;
			cp->ol -= n;
		}
	}
handled:
	cp->w = t + cp->stutter;
	if (cp->ol == 0) {
		cp->w = 0;
		nextstate(cp);
	}
}

static int
get_maxfiles(void)
{
	int mib[2], maxfiles;
	size_t len;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MAXFILES;
	len = sizeof(maxfiles);
	if (sysctl(mib, 2, &maxfiles, &len, NULL, 0) == -1)
		return(MAXCON);
	if ((maxfiles - 200) < 10)
		errx(1, "kern.maxfiles is only %d, can not continue\n",
		    maxfiles);
	else
		return(maxfiles - 200);
}

/* Symbolic indexes for pfd[] below */
#define PFD_SMTPLISTEN	0
#define PFD_CONFLISTEN	1
#define PFD_SYNCFD	2
#define PFD_CONFFD	3
#define PFD_TRAPFD	4
#define PFD_FIRSTCON	5

int
main(int argc, char *argv[])
{
	struct pollfd *pfd;
	struct sockaddr_in sin;
	struct sockaddr_in lin;
	int ch, smtplisten, conflisten, syncfd = -1, i, one = 1;
	u_short port;
	long long passt, greyt, whitet;
	struct servent *ent;
	struct rlimit rlp;
	char *bind_address = NULL;
	const char *errstr;
	char *sync_iface = NULL;
	char *sync_baddr = NULL;
	struct addrinfo hints, *res;
	char *addr;
	char portstr[6];
	int error;

	tzset();
	openlog_r("spamd", LOG_PID | LOG_NDELAY, LOG_DAEMON, &sdata);

	if ((ent = getservbyname("spamd", "tcp")) == NULL)
		errx(1, "Can't find service \"spamd\" in /etc/services");
	port = ntohs(ent->s_port);
	if ((ent = getservbyname("spamd-cfg", "tcp")) == NULL)
		errx(1, "Can't find service \"spamd-cfg\" in /etc/services");
	cfg_port = ntohs(ent->s_port);
	if ((ent = getservbyname("spamd-sync", "udp")) == NULL)
		errx(1, "Can't find service \"spamd-sync\" in /etc/services");
	sync_port = ntohs(ent->s_port);

	if (gethostname(hostname, sizeof hostname) == -1)
		err(1, "gethostname");
	maxfiles = get_maxfiles();
	if (maxcon > maxfiles)
		maxcon = maxfiles;
	if (maxblack > maxfiles)
		maxblack = maxfiles;
	while ((ch =
	    getopt(argc, argv, "45l:c:B:p:bdG:h:s:S:M:n:vw:y:Y:C:K:")) != -1) {
		switch (ch) {
		case '4':
			nreply = "450";
			break;
		case '5':
			nreply = "550";
			break;
		case 'l':
			bind_address = optarg;
			break;
		case 'B':
			maxblack = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-B %s: %s", optarg, errstr);
			break;
		case 'c':
			maxcon = strtonum(optarg, 1, maxfiles, &errstr);
			if (errstr) {
				fprintf(stderr, "-c %s: %s\n", optarg, errstr);
				usage();
			}
			break;
		case 'p':
			port = strtonum(optarg, 1, USHRT_MAX, &errstr);
			if (errstr)
				errx(1, "-p %s: %s", optarg, errstr);
			break;
		case 'd':
			debug = 1;
			break;
		case 'b':
			greylist = 0;
			break;
		case 'G':
			if (sscanf(optarg, "%lld:%lld:%lld", &passt, &greyt,
			    &whitet) != 3)
				usage();
			passtime = passt;
			greyexp = greyt;
			whiteexp = whitet;
			/* convert to seconds from minutes */
			passtime *= 60;
			/* convert to seconds from hours */
			whiteexp *= (60 * 60);
			/* convert to seconds from hours */
			greyexp *= (60 * 60);
			break;
		case 'h':
			memset(hostname, 0, sizeof(hostname));
			if (strlcpy(hostname, optarg, sizeof(hostname)) >=
			    sizeof(hostname))
				errx(1, "-h arg too long");
			break;
		case 's':
			stutter = strtonum(optarg, 0, 10, &errstr);
			if (errstr)
				usage();
			break;
		case 'S':
			grey_stutter = strtonum(optarg, 0, 90, &errstr);
			if (errstr)
				usage();
			break;
		case 'M':
			low_prio_mx_ip = optarg;
			break;
		case 'n':
			spamd = optarg;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'w':
			window = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-w %s: %s", optarg, errstr);
			break;
		case 'Y':
			if (sync_addhost(optarg, sync_port) != 0)
				sync_iface = optarg;
			syncsend++;
			break;
		case 'y':
			sync_baddr = optarg;
			syncrecv++;
			break;
		case 'C':
			tlscertfile = optarg;
			break;
		case 'K':
			tlskeyfile = optarg;
			break;
		default:
			usage();
			break;
		}
	}

	setproctitle("[priv]%s%s",
	    greylist ? " (greylist)" : "",
	    (syncrecv || syncsend) ? " (sync)" : "");

	if (syncsend || syncrecv) {
		syncfd = sync_init(sync_iface, sync_baddr, sync_port);
		if (syncfd == -1)
			err(1, "sync init");
	}

	if (geteuid())
		errx(1, "need root privileges");

	if ((pw = getpwnam(SPAMD_USER)) == NULL)
		errx(1, "no such user %s", SPAMD_USER);

	if (!greylist) {
		maxblack = maxcon;
	} else if (maxblack > maxcon)
		usage();

	if (tlscertfile &&
		(pubcert=tls_load_file(tlscertfile, &pubcertlen, NULL)) == NULL)
		errx(1, "unable to load TLS certificate file %s", tlscertfile);
	if (tlskeyfile &&
		(privkey=tls_load_file(tlskeyfile, &privkeylen, NULL)) == NULL)
		errx(1, "unable to load TLS key file %s", tlskeyfile);

	rlp.rlim_cur = rlp.rlim_max = maxcon + 15;
	if (setrlimit(RLIMIT_NOFILE, &rlp) == -1)
		err(1, "setrlimit");

	pfd = reallocarray(NULL, PFD_FIRSTCON + maxcon, sizeof(*pfd));
	if (pfd == NULL)
		err(1, "reallocarray");

	con = calloc(maxcon, sizeof(*con));
	if (con == NULL)
		err(1, "calloc");

	con->obuf = malloc(8192);

	if (con->obuf == NULL)
		err(1, "malloc");
	con->osize = 8192;

	for (i = 0; i < maxcon; i++) {
		con[i].pfd = &pfd[PFD_FIRSTCON + i];
		con[i].pfd->fd = -1;
	}

	signal(SIGPIPE, SIG_IGN);

	smtplisten = socket(AF_INET, SOCK_STREAM, 0);
	if (smtplisten == -1)
		err(1, "socket");

	if (setsockopt(smtplisten, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		return (-1);

	conflisten = socket(AF_INET, SOCK_STREAM, 0);
	if (conflisten == -1)
		err(1, "socket");

	if (setsockopt(conflisten, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		return (-1);

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;
	addr = bind_address;
	snprintf(portstr, sizeof(portstr), "%hu", port);

	if ((error = getaddrinfo(addr, portstr, &hints, &res)) != 0) {
		errx(1, "getaddrinfo: %s", gai_strerror(error));
	}

	if (bind(smtplisten, res->ai_addr, res->ai_addrlen) == -1) {
		freeaddrinfo(res);
		err(1, "bind");
	}
	freeaddrinfo(res);

	memset(&lin, 0, sizeof sin);
	lin.sin_len = sizeof(sin);
	lin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	lin.sin_family = AF_INET;
	lin.sin_port = htons(cfg_port);

	if (bind(conflisten, (struct sockaddr *)&lin, sizeof lin) == -1)
		err(1, "bind local");

	if (debug == 0) {
		if (daemon(1, 1) == -1)
			err(1, "daemon");
	}

	if (greylist) {
		pfdev = open("/dev/pf", O_RDWR);
		if (pfdev == -1) {
			syslog_r(LOG_ERR, &sdata, "open /dev/pf: %m");
			exit(1);
		}

		check_spamd_db();

		maxblack = (maxblack >= maxcon) ? maxcon - 100 : maxblack;
		if (maxblack < 0)
			maxblack = 0;

		/* open pipe to talk to greylister */
		if (pipe(greypipe) == -1) {
			syslog(LOG_ERR, "pipe (%m)");
			exit(1);
		}
		/* open pipe to receive spamtrap configs */
		if (pipe(trappipe) == -1) {
			syslog(LOG_ERR, "pipe (%m)");
			exit(1);
		}
		jail_pid = fork();
		switch (jail_pid) {
		case -1:
			syslog(LOG_ERR, "fork (%m)");
			exit(1);
		case 0:
			/* child - continue */
			signal(SIGPIPE, SIG_IGN);
			grey = fdopen(greypipe[1], "w");
			if (grey == NULL) {
				syslog(LOG_ERR, "fdopen (%m)");
				_exit(1);
			}
			close(greypipe[0]);
			trapfd = trappipe[0];
			trapcfg = fdopen(trappipe[0], "r");
			if (trapcfg == NULL) {
				syslog(LOG_ERR, "fdopen (%m)");
				_exit(1);
			}
			close(trappipe[1]);

			if (chroot("/var/empty") == -1) {
				syslog(LOG_ERR, "cannot chroot to /var/empty.");
				exit(1);
			}			
 			if (chdir("/") == -1) {
				syslog(LOG_ERR, "cannot chdir to /");
				exit(1);
			}

			if (setgroups(1, &pw->pw_gid) ||
			    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
			    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
				err(1, "failed to drop privs");

			goto jail;
		}
		/* parent - run greylister */
		grey = fdopen(greypipe[0], "r");
		if (grey == NULL) {
			syslog(LOG_ERR, "fdopen (%m)");
			exit(1);
		}
		close(greypipe[1]);
		trapcfg = fdopen(trappipe[1], "w");
		if (trapcfg == NULL) {
			syslog(LOG_ERR, "fdopen (%m)");
			exit(1);
		}
		close(trappipe[0]);
		return (greywatcher());
	}

jail:
	if (pledge("stdio inet", NULL) == -1)
		err(1, "pledge");

	spamd_tls_init();

	if (listen(smtplisten, 10) == -1)
		err(1, "listen");

	if (listen(conflisten, 10) == -1)
		err(1, "listen");

	if (debug != 0)
		printf("listening for incoming connections.\n");
	syslog_r(LOG_WARNING, &sdata, "listening for incoming connections.");

	/* We always check for trap and sync events if configured. */
	if (trapfd != -1) {
		pfd[PFD_TRAPFD].fd = trapfd;
		pfd[PFD_TRAPFD].events = POLLIN;
	} else {
		pfd[PFD_TRAPFD].fd = -1;
		pfd[PFD_TRAPFD].events = 0;
	}
	if (syncrecv) {
		pfd[PFD_SYNCFD].fd = syncfd;
		pfd[PFD_SYNCFD].events = POLLIN;
	} else {
		pfd[PFD_SYNCFD].fd = -1;
		pfd[PFD_SYNCFD].events = 0;
	}

	/* events and pfd entries for con[] are filled in below. */
	pfd[PFD_SMTPLISTEN].fd = smtplisten;
	pfd[PFD_CONFLISTEN].fd = conflisten;

	while (1) {
		int numcon = 0, n, timeout, writers;

		time(&t);

		writers = 0;
		for (i = 0; i < maxcon; i++) {
			if (con[i].pfd->fd == -1)
				continue;
			con[i].pfd->events = 0;
			if (con[i].r) {
				if (con[i].r + MAXTIME <= t) {
					closecon(&con[i]);
					continue;
				}
				con[i].pfd->events |= POLLIN;
			}
			if (con[i].w) {
				if (con[i].w + MAXTIME <= t) {
					closecon(&con[i]);
					continue;
				}
				if (con[i].w <= t)
					con[i].pfd->events |= POLLOUT;
				writers = 1;
			}
			if (con[i].tlsaction == SPAMD_TLS_ACT_READ_POLLIN ||
			    con[i].tlsaction == SPAMD_TLS_ACT_WRITE_POLLIN)
				con[i].pfd->events = POLLIN;
			if (con[i].tlsaction == SPAMD_TLS_ACT_READ_POLLOUT ||
			    con[i].tlsaction == SPAMD_TLS_ACT_WRITE_POLLOUT)
				con[i].pfd->events = POLLOUT;
			if (i + 1 > numcon)
				numcon = i + 1;
		}
		pfd[PFD_SMTPLISTEN].events = 0;
		pfd[PFD_CONFLISTEN].events = 0;
		pfd[PFD_CONFFD].events = 0;
		pfd[PFD_CONFFD].fd = conffd;
		if (slowdowntill == 0) {
			pfd[PFD_SMTPLISTEN].events = POLLIN;

			/* only one active config conn at a time */
			if (conffd == -1)
				pfd[PFD_CONFLISTEN].events = POLLIN;
			else
				pfd[PFD_CONFFD].events = POLLIN;
		}

		/* If we are not listening, wake up at least once a second */
		if (writers == 0 && slowdowntill == 0)
			timeout = INFTIM;
		else
			timeout = 1000;

		n = poll(pfd, PFD_FIRSTCON + numcon, timeout);
		if (n == -1) {
			if (errno != EINTR)
				err(1, "poll");
			continue;
		}

		/* Check if we can speed up accept() calls */
		if (slowdowntill && slowdowntill > t)
			slowdowntill = 0;

		for (i = 0; i < maxcon; i++) {
			if (con[i].pfd->fd == -1)
				continue;
			if (pfd[PFD_FIRSTCON + i].revents & POLLHUP) {
				closecon(&con[i]);
				continue;
			}
			if (pfd[PFD_FIRSTCON + i].revents & POLLIN) {
				if (con[i].tlsaction ==
				    SPAMD_TLS_ACT_WRITE_POLLIN)
					handlew(&con[i], clients + 5 < maxcon);
				else
					handler(&con[i]);
			}
			if (pfd[PFD_FIRSTCON + i].revents & POLLOUT) {
				if (con[i].tlsaction ==
				    SPAMD_TLS_ACT_READ_POLLOUT)
					handler(&con[i]);
				else
					handlew(&con[i], clients + 5 < maxcon);
			}
		}
		if (pfd[PFD_SMTPLISTEN].revents & (POLLIN|POLLHUP)) {
			socklen_t sinlen;
			int s2;

			sinlen = sizeof(sin);
			s2 = accept4(smtplisten, (struct sockaddr *)&sin, &sinlen,
			    SOCK_NONBLOCK);
			if (s2 == -1) {
				switch (errno) {
				case EINTR:
				case ECONNABORTED:
					break;
				case EMFILE:
				case ENFILE:
					slowdowntill = time(NULL) + 1;
					break;
				default:
					errx(1, "accept");
				}
			} else {
				/* Check if we hit the chosen fd limit */
				for (i = 0; i < maxcon; i++)
					if (con[i].pfd->fd == -1)
						break;
				if (i == maxcon) {
					close(s2);
					slowdowntill = 0;
				} else {
					initcon(&con[i], s2,
					    (struct sockaddr *)&sin);
					syslog_r(LOG_INFO, &sdata,
					    "%s: connected (%d/%d)%s%s",
					    con[i].addr, clients, blackcount,
					    ((con[i].lists == NULL) ? "" :
					    ", lists:"),
					    ((con[i].lists == NULL) ? "":
					    con[i].lists));
				}
			}
		}
		if (pfd[PFD_CONFLISTEN].revents & (POLLIN|POLLHUP)) {
			socklen_t sinlen;

			sinlen = sizeof(lin);
			conffd = accept(conflisten, (struct sockaddr *)&lin,
			    &sinlen);
			if (conffd == -1) {
				switch (errno) {
				case EINTR:
				case ECONNABORTED:
					break;
				case EMFILE:
				case ENFILE:
					slowdowntill = time(NULL) + 1;
					break;
				default:
					errx(1, "accept");
				}
			} else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
				close(conffd);
				conffd = -1;
				slowdowntill = 0;
			}
		} else if (pfd[PFD_CONFFD].revents & (POLLIN|POLLHUP))
			do_config();
		if (pfd[PFD_TRAPFD].revents & (POLLIN|POLLHUP))
			read_configline(trapcfg);
		if (pfd[PFD_SYNCFD].revents & (POLLIN|POLLHUP))
			sync_recv();
	}
	exit(1);
}
@


1.150
log
@check EAGAIN in the correct place,
noticed and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.149 2017/01/23 09:09:15 beck Exp $	*/
d1290 1
a1290 1
				fprintf(stderr, "-c %s: %sn", optarg, errstr);
@


1.149
log
@Switch spamd to nonblocking descriptors so we can count on getting a
short write when the socket buffers are full, instead of blocking.
ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.148 2017/01/17 23:28:04 mestre Exp $	*/
a1101 2
		if (errno == EAGAIN)
			return;
d1103 2
@


1.148
log
@- spamd(8)'s -l accepts an IP address as argument to bind(2) and it calls
inet_pton(3) to check if it's valid and since that function doesn't provide
a proper errno (POSIX doesn't mandate to do so) then if a string is given we
may get this message:
spamd: inet_pton: Undefined error: 0

- Instead replace that code to use getaddrinfo(3) from which is possible to get
a proper error message, and at the same time being able to parse IPs and
hostnames (if either the IP or host is not local then the next bind(2) will
fail)

- By default without arguments, spamd(8) will still bind(2) to 127.0.0.1 as
it did before

With feedback from deraadt@@ and OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.147 2016/11/30 07:54:36 mestre Exp $	*/
d1102 2
d1158 2
d1186 2
d1674 2
a1675 1
			s2 = accept(smtplisten, (struct sockaddr *)&sin, &sinlen);
@


1.147
log
@Check return value of tls_config_set_protocols(3) and bail out in case of
failure

Feedback and OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.146 2016/11/08 09:31:55 mestre Exp $	*/
d1239 4
d1433 8
a1440 9
	memset(&sin, 0, sizeof sin);
	sin.sin_len = sizeof(sin);
	if (bind_address) {
		if (inet_pton(AF_INET, bind_address, &sin.sin_addr) != 1)
			err(1, "inet_pton");
	} else
		sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);
d1442 2
a1443 1
	if (bind(smtplisten, (struct sockaddr *)&sin, sizeof sin) == -1)
d1445 2
@


1.146
log
@Remove redundant & when clearing hostname variable, as per otto@@'s request
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.145 2016/11/07 22:18:22 mestre Exp $	*/
d458 2
a459 1
	tls_config_set_protocols(tlscfg, TLS_PROTOCOLS_ALL);
@


1.145
log
@Replace bzero(3) with memset(3)

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.144 2016/09/06 11:06:40 henning Exp $	*/
d1309 1
a1309 1
			memset(&hostname, 0, sizeof(hostname));
@


1.144
log
@must close our fd unconditionally and not just in the !TLS case; tls_close
doesn't do that for us. found, analyzed and patch supplied by Martin Proyer
<martin at proyer dot net>, many thanks! ok bcook
funny since I just discussed a somewhat mysterious spamd-TLS issue with bob
and brent over breakfast yesterday in cambridge - not sure it is this one,
if it is I've been intensively digging in the wrong corner, almost "missing
the obvious"
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.143 2016/07/13 16:35:47 jsing Exp $	*/
d1309 1
a1309 1
			bzero(&hostname, sizeof(hostname));
@


1.143
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.142 2016/05/17 17:51:47 jca Exp $	*/
d768 2
a769 2
	} else
		close(cp->pfd->fd);
@


1.142
log
@tyop
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.141 2016/04/27 10:24:50 mestre Exp $	*/
d461 1
a461 1
	if (tls_config_set_ciphers(tlscfg, "compat") != 0)
@


1.141
log
@Remove pledge(2)'s that are called before chroot(2) since in the near future
this will be forbidden. The remaining pledge(2) calls after chroot(2) are still
kept.

OK semarie@@ "it is time now"
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.140 2016/04/10 03:04:21 tedu Exp $	*/
d1473 1
a1473 1
		/* open pipe to recieve spamtrap configs */
@


1.140
log
@per rfc, ehlo responses contain hostname, then options. from dyn+bsd
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.139 2016/03/25 16:31:32 mestre Exp $	*/
a1376 3

		if (pledge("stdio rpath inet proc id", NULL) == -1)
			err(1, "pledge");
@


1.139
log
@- Both checks for pw are not needed since it was already done at the start of
the program
- Add error message to syslog if privdrop didn't succeed and then exit
- Remove lint comments

OK beck@@ after his suggestion and also looks good to jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.138 2016/03/10 00:07:03 gsoares Exp $	*/
d852 3
a854 1
					    "250 STARTTLS\r\n");
@


1.138
log
@- add a define for "_spamd" user like others OpenBSD daemons;
- check for root privileges, otherwise exit early with an appropriate
status code and a formatted string;
- be more specific with chroot()/chdir() checks.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.137 2015/12/12 20:09:28 mmcc Exp $	*/
d1510 4
a1513 5
			if (pw)
				if (setgroups(1, &pw->pw_gid) ||
					setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
					setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
					err(1, "failed to drop privs");
a1530 1
		/* NOTREACHED */
@


1.137
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.136 2015/12/10 16:06:29 beck Exp $	*/
d96 2
d1367 5
a1371 2
	if ((pw = getpwnam("_spamd")) == NULL)
		errx(1, "no such user _spamd");
d1501 6
a1506 2
			if (chroot("/var/empty") == -1 || chdir("/") == -1) {
				syslog(LOG_ERR, "cannot chdir to /var/empty.");
@


1.136
log
@tighten the pledge for spamd, from Ricardo Mestre <serial@@helheim.mooo.com>
this loads the tls certificate files pre-pledge then does the bulk of the tls
setup goo pledged.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.135 2015/12/08 03:21:09 beck Exp $	*/
d780 2
a781 4
	if (cp->lists != NULL) {
		free(cp->lists);
		cp->lists = NULL;
	}
@


1.135
log
@Initially pledge spamd
All the work done by Ricardo Mestre <serial@@helheim.mooo.com> - Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.134 2015/12/05 20:32:53 henning Exp $	*/
d114 1
a114 1
void	 spamd_tls_init(char *, char *);
d135 6
d442 1
a442 1
spamd_tls_init(char *keyfile, char *certfile)
d444 1
a444 1
	if (keyfile == NULL && certfile == NULL)
d446 1
a446 1
	if (keyfile == NULL || certfile == NULL)
d462 4
a465 4
	if (tls_config_set_cert_file(tlscfg, certfile) != 0)
		err(1, "could not load certificate %s", certfile);
	if (tls_config_set_key_file(tlscfg, keyfile) != 0)
		err(1, "could not load key %s", keyfile);
a1235 2
	char *tlskeyfile = NULL;
	char *tlscertfile = NULL;
d1378 7
a1461 3
		if (pledge("stdio rpath wpath flock inet proc exec id", NULL) == -1)
			err(1, "pledge");

d1497 12
a1528 13
	spamd_tls_init(tlskeyfile, tlscertfile);

	if (chroot("/var/empty") == -1 || chdir("/") == -1) {
		syslog(LOG_ERR, "cannot chdir to /var/empty.");
		exit(1);
	}

	if (pw)
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			err(1, "failed to drop privs");

d1531 2
@


1.134
log
@adjust to newer tls_read/_write semantics.
quite involved, due to tls_read potentially needing to write and tls_write
potentially needing to read (in the reneg case); that not fitting the spamd
model too well - it needs to keep a little more state.
help & ok bluhm & beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.133 2015/12/02 21:10:17 henning Exp $	*/
d115 1
d1357 10
a1366 1
	if (!greylist)
d1368 4
a1371 1
	else if (maxblack > maxcon)
a1436 9
	if (syncsend || syncrecv) {
		syncfd = sync_init(sync_iface, sync_baddr, sync_port);
		if (syncfd == -1)
			err(1, "sync init");
	}

	if ((pw = getpwnam("_spamd")) == NULL)
		errx(1, "no such user _spamd");

d1449 5
d1521 3
@


1.133
log
@in response to EHLO, don't offer STARTTLS if we already completed the
STARTTLS dance. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.132 2015/12/02 20:58:43 henning Exp $	*/
d87 1
d90 6
d1077 1
a1077 1
	if (cp->r) {
d1079 1
d1081 6
a1095 4
		} if (n < 0) {
			if (debug > 0)
				warn("tls_read unexpected POLLIN/POLLOUT");
			closecon(cp);
d1125 1
a1125 1
	if (cp->w) {
d1129 1
d1131 8
a1149 6
			} else if (n < 0) {
				if (debug > 0)
					warn("tls_write unexpected "
					    "POLLIN/POLLOUT");
				closecon(cp);
				goto handled;
d1157 1
d1159 6
a1174 4
		} else if (n < 0) {
			if (debug > 0)
				warn("tls_write unexpected POLLIN/POLLOUT");
			closecon(cp);
d1569 6
d1616 14
a1629 4
			if (pfd[PFD_FIRSTCON + i].revents & POLLIN)
				handler(&con[i]);
			if (pfd[PFD_FIRSTCON + i].revents & POLLOUT)
				handlew(&con[i], clients + 5 < maxcon);
@


1.132
log
@I misread the standard when adding TLS; clients are supposed to start over
and issue a new EHLO after STARTTLS. The misunderstaning seems to be common,
so we'll still grok MAIL FROM right after the STARTTLS dance, as well as
accepting a second EHLO. ok phessler beck millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.131 2015/12/02 19:03:17 henning Exp $	*/
d834 2
a835 1
				if (tlsctx != NULL && cp->blacklists == NULL &&
@


1.131
log
@fix error messages to say tls_write after tls_write and not tls_read...
with bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.129 2015/09/10 10:32:16 beck Exp $	*/
d814 1
a853 1
	tlsinitdone:
@


1.130
log
@read, tls_read, and tls_write return ssize_t
jointly with jsing@@
@
text
@d1132 2
a1133 1
					warn("tls_read unexpected POLLIN/POLLOUT");
d1156 1
a1156 1
				warn("tls_read unexpected POLLIN/POLLOUT");
@


1.129
log
@fix after libtls api changes
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.128 2015/05/18 16:04:21 reyk Exp $	*/
d1067 1
a1067 1
	int n;
d1107 1
a1107 1
	int n;
@


1.128
log
@Change spamd to use divert-to instead of rdr-to.

divert-to has many advantages over rdr-to for proxies.  For example,
it is much easier to use, requires less code, does not depend on
/dev/pf, works in-band without the asynchronous lookup (DIOCNATLOOK
ioctl), saves us from additional port allocations by the rdr/NAT code,
and even avoids potential collisions and race conditions that could
theoretically happen with the lookup.

Heads up: users will have to update their spamd PF rules from rdr-to
to divert-to.  spamd now also listens to 127.0.0.1 instead of "any"
(0.0.0.0) by default which should be fine with most setups but has to
be considered for some special configurations.

Based on a diff is almost two years old but got delayed several times
... beck@@: "now is the time to get it in" :)

Tested by many
With help from okan@@
OK okan@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.127 2015/04/18 18:28:37 deraadt Exp $	*/
d1071 1
a1071 4
			size_t outlen;
			n = -1;
			if (tls_read(cp->cctx, cp->ip, cp->il, &outlen) == 0)
				n = outlen;
d1081 4
a1107 1
	size_t outlen;
d1118 1
a1118 3
				n = -1;
				if (tls_write(cp->cctx, "\r", 1, &outlen) == 0)
					n = outlen;
d1130 5
d1142 1
a1142 3
			n = -1;
			if (tls_write(cp->cctx, cp->op, cp->ol, &outlen) == 0)
				n = outlen;
d1152 4
@


1.127
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.126 2015/03/12 20:07:20 millert Exp $	*/
a50 3
extern int server_lookup(struct sockaddr *, struct sockaddr *,
    struct sockaddr *);

d648 2
a649 2
 * Get address client connected to, by doing a DIOCNATLOOK call.
 * Uses server_lookup code from ftp-proxy.
a653 2
	struct sockaddr_storage spamd_end;
	struct sockaddr *sep = (struct sockaddr *) &spamd_end;
d660 1
a660 3
	if (getsockname(cp->pfd->fd, sep, &len) == -1)
		return;
	if (server_lookup((struct sockaddr *)&cp->ss, sep, odp) != 0)
d1385 1
a1385 1
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
@


1.126
log
@Use poll(2) instead of select(2).  A pointer to the struct pollfd
is embedded in each struct con so the descriptors can't get out of
sync with the pfd[] array.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.125 2015/02/22 14:55:40 jsing Exp $	*/
d1249 3
a1251 2
			i = atoi(optarg);
			maxblack = i;
d1254 3
a1256 5
			i = atoi(optarg);
			if (i > maxfiles) {
				fprintf(stderr,
				    "%d > system max of %d connections\n",
				    i, maxfiles);
a1258 1
			maxcon = i;
d1261 3
a1263 2
			i = atoi(optarg);
			port = i;
d1292 1
a1292 1
			i = strtonum(optarg, 0, 10, &errstr);
a1294 1
			stutter = i;
d1297 1
a1297 1
			i = strtonum(optarg, 0, 90, &errstr);
a1299 1
			grey_stutter = i;
d1311 3
a1313 3
			window = atoi(optarg);
			if (window <= 0)
				usage();
@


1.125
log
@Set the TLS ciphers to "compat" mode, restoring the previous behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.124 2015/02/12 04:23:17 jsing Exp $	*/
d35 1
d55 1
a55 1
	int fd;
d59 1
a77 1
	int il;
d665 1
a665 1
	if (getsockname(cp->fd, sep, &len) == -1)
d700 2
a701 1
	socklen_t len = sa->sa_len;
a702 1
	char ctimebuf[26];
d705 3
a709 2
	cp->obuf = NULL;
	cp->osize = 0;
a710 1
	cp->blacklists = NULL;
d712 1
a712 2
	cp->lists = NULL;
	bzero(cp, sizeof(struct con));
d715 2
a716 6
	cp->fd = fd;
	cp->cctx = NULL;
	if (len > sizeof(cp->ss))
		errx(1, "sockaddr size");
	if (sa->sa_family != AF_INET)
		errx(1, "not supported yet");
d760 3
a762 1
		close(cp->fd);
a787 1
	cp->fd = -1;
d959 1
a959 1
		if (tls_accept_socket(tlsctx, &cp->cctx, cp->fd) == -1) {
d977 2
a978 2
			if (window && setsockopt(cp->fd, SOL_SOCKET, SO_RCVBUF,
			    &window, sizeof(window)) == -1) {
d1083 1
a1083 1
			n = read(cp->fd, cp->ip, cp->il);
d1129 1
a1129 1
				n = write(cp->fd, "\r", 1);
d1150 1
a1150 1
			n = write(cp->fd, cp->op,
d1190 8
d1201 1
a1201 1
	fd_set *fdsr = NULL, *fdsw = NULL;
d1204 1
a1204 1
	int ch, s, conflisten = 0, syncfd = 0, i, omax = 0, one = 1;
d1352 4
d1366 4
a1369 2
	for (i = 0; i < maxcon; i++)
		con[i].fd = -1;
d1373 2
a1374 2
	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1)
d1377 1
a1377 1
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one,
d1399 1
a1399 1
	if (bind(s, (struct sockaddr *)&sin, sizeof sin) == -1)
d1500 1
a1500 1
	if (listen(s, 10) == -1)
d1510 20
d1531 1
a1531 9
		struct timeval tv, *tvp;
		int max, n;
		int writers;

		max = MAXIMUM(s, conflisten);
		if (syncrecv)
			max = MAXIMUM(max, syncfd);
		max = MAXIMUM(max, conffd);
		max = MAXIMUM(max, trapfd);
a1533 24
		for (i = 0; i < maxcon; i++)
			if (con[i].fd != -1)
				max = MAXIMUM(max, con[i].fd);

		if (max > omax) {
			free(fdsr);
			fdsr = NULL;
			free(fdsw);
			fdsw = NULL;
			fdsr = (fd_set *)calloc(howmany(max+1, NFDBITS),
			    sizeof(fd_mask));
			if (fdsr == NULL)
				err(1, "calloc");
			fdsw = (fd_set *)calloc(howmany(max+1, NFDBITS),
			    sizeof(fd_mask));
			if (fdsw == NULL)
				err(1, "calloc");
			omax = max;
		} else {
			memset(fdsr, 0, howmany(max+1, NFDBITS) *
			    sizeof(fd_mask));
			memset(fdsw, 0, howmany(max+1, NFDBITS) *
			    sizeof(fd_mask));
		}
d1537 4
a1540 1
			if (con[i].fd != -1 && con[i].r) {
d1545 1
a1545 1
				FD_SET(con[i].fd, fdsr);
d1547 1
a1547 1
			if (con[i].fd != -1 && con[i].w) {
d1553 1
a1553 1
					FD_SET(con[i].fd, fdsw);
d1556 2
d1559 4
d1564 1
a1564 1
			FD_SET(s, fdsr);
d1568 1
a1568 1
				FD_SET(conflisten, fdsr);
d1570 1
a1570 1
				FD_SET(conffd, fdsr);
a1572 5
		if (trapfd != -1)
			FD_SET(trapfd, fdsr);
		if (syncrecv)
			FD_SET(syncfd, fdsr);

d1574 4
a1577 7
		if (writers == 0 && slowdowntill == 0) {
			tvp = NULL;
		} else {
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			tvp = &tv;
		}
d1579 1
a1579 1
		n = select(max+1, fdsr, fdsw, NULL, tvp);
d1582 1
a1582 1
				err(1, "select");
d1591 7
a1597 1
			if (con[i].fd != -1 && FD_ISSET(con[i].fd, fdsr))
d1599 1
a1599 1
			if (con[i].fd != -1 && FD_ISSET(con[i].fd, fdsw))
d1602 1
a1602 1
		if (FD_ISSET(s, fdsr)) {
d1607 1
a1607 1
			s2 = accept(s, (struct sockaddr *)&sin, &sinlen);
d1623 1
a1623 1
					if (con[i].fd == -1)
d1641 1
a1641 1
		if (FD_ISSET(conflisten, fdsr)) {
d1664 1
a1664 1
		} else if (conffd != -1 && FD_ISSET(conffd, fdsr))
d1666 1
a1666 1
		if (trapfd != -1 && FD_ISSET(trapfd, fdsr))
d1668 1
a1668 1
		if (syncrecv && FD_ISSET(syncfd, fdsr))
@


1.124
log
@Change TLS_PROTOCOLS_DEFAULT to be TLSv1.2 only. Add a TLS_PROTOCOLS_ALL
that includes all currently supported protocols (TLSv1.0, TLSv1.1 and
TLSv1.2). Change all users of libtls to use TLS_PROTOCOLS_ALL so that they
maintain existing behaviour.

Discussed with tedu@@ and reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.123 2015/02/07 10:45:19 henning Exp $	*/
a442 1
	/* might need user-specified ciphers, tls_config_set_ciphers */
d445 4
@


1.123
log
@add STARTTLS support, using the shiny libtls.
Rationale: when you publish DANE records for certificate pinning, you MUST
offer TLS on the indicated service. Not offering TLS is verboten since
that would re-open the door for a MitM. This is obviously fundamentally
incompatible with having spamd in front of your mailservers - spamd kinda
is a MitM here, but intentional and utterly valid.
DANE is desirable because it allows one to not have to trust the broken
SSL CA model, and, depending on the mode chosen, even show the SSL cert
mafia the middle finger by not needing them at all.
ok reyk jsing bob
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.121 2015/01/13 23:22:33 millert Exp $	*/
d444 2
@


1.122
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d4 1
d26 1
d42 1
d64 1
d109 1
d127 2
d167 1
a167 1
	    "usage: %s [-45bdv] [-B maxblack] [-c maxcon] "
d169 2
a170 2
	    "\t[-h hostname] [-l address] [-M address] [-n name] [-p port]\n"
	    "\t[-S secs] [-s secs] "
d429 26
d711 1
d755 5
a759 1
	close(cp->fd);
d838 10
a847 3
				snprintf(cp->obuf, cp->osize,
				    "250 Hello, spam sender. "
				    "Pleased to be wasting your time.\r\n");
d858 1
d934 33
d1075 8
a1082 1
		n = read(cp->fd, cp->ip, cp->il);
d1112 1
d1122 7
a1128 1
			n = write(cp->fd, "\r", 1);
d1143 8
a1150 1
		n = write(cp->fd, cp->op, (one && cp->stutter) ? 1 : cp->ol);
d1203 2
d1227 1
a1227 1
	    getopt(argc, argv, "45l:c:B:p:bdG:h:s:S:M:n:vw:y:Y:")) != -1) {
d1317 6
d1471 2
@


1.121
log
@Move debug printf for duplicate af to correct location.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.120 2015/01/13 21:49:36 millert Exp $	*/
d20 1
a20 1
#include <sys/param.h>
d24 1
d39 1
d106 1
a106 1
char hostname[MAXHOSTNAMELEN];
d152 2
d1389 1
a1389 1
		max = MAX(s, conflisten);
d1391 3
a1393 3
			max = MAX(max, syncfd);
		max = MAX(max, conffd);
		max = MAX(max, trapfd);
d1398 1
a1398 1
				max = MAX(max, con[i].fd);
@


1.120
log
@Remove bogus getopt.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.119 2015/01/13 21:42:59 millert Exp $	*/
d293 3
a295 3
			if (debug > 0)
				printf("duplicate inet\n");
			if (v4 != NULL)
d297 1
d301 3
a303 3
			if (debug > 0)
				printf("duplicate inet6\n");
			if (v6 != NULL)
d305 1
@


1.119
log
@Use address-family specific lists of addr/mask entries instead of
a union that can store either ipv4 or ipv6.  The old method used
4x as much memory as was really needed for ipv4.  The spamd-setup
protocol has changed from: tag;message;a/m;a/m;a/m...\n
to :tag;message;af;count;a/m;a/m;a/m...[af;count;a/m;a/m;a/m]\n
OK phessler@@ "nice" beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.118 2014/12/30 23:27:23 millert Exp $	*/
a30 1
#include <getopt.h>
@


1.118
log
@Use a 1MB realloc() increment instead of an 8KB one for the config
connection buffer.  Significantly speeds up spamd-setup for lage
blacklists.  Also free the buffer when we are done with it so memory
can be returned to the system (as it can grow quite large).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.117 2014/12/29 20:39:27 millert Exp $	*/
d32 1
d188 4
a191 4
	char *cp, prev, *name, *msg;
	static char **av = NULL;
	static size_t ac = 0;
	size_t au = 0;
d193 1
d224 3
a226 1
				} else
d228 1
d232 2
d241 3
a243 3
	do {
		if (ac == au) {
			char **tmp;
d245 37
a281 1
			tmp = reallocarray(av, ac + 2048, sizeof(char *));
d283 3
d287 1
a287 3
				av = NULL;
				ac = 0;
				return (-1);
d289 18
a306 2
			av = tmp;
			ac += 2048;
d308 4
a311 7
	} while ((av[au++] = strsep(&cp, ";")) != NULL);

	/* toss empty last entry to allow for trailing ; */
	while (au > 0 && (av[au - 1] == NULL || av[au - 1][0] == '\0'))
		au--;

	if (au < 1)
d313 4
a316 2
	else
		sdl_add(name, msg, av, au);
d321 3
a323 1
		printf("bogus config line - need 'tag;message;a/m;a/m;a/m...'\n");
@


1.117
log
@Minor cleanup:
 o doreply() just calls build_reply()
 o remove a few dead stores and useless variables
 o use the asprintf() return value
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.116 2014/11/23 21:19:47 guenther Exp $	*/
d270 1
a270 1
	int i;
d272 1
a272 15
	if (cbu == cbs) {
		char *tmp;

		tmp = realloc(cb, cbs + 8192);
		if (tmp == NULL) {
			if (debug > 0)
				warn("realloc");
			free(cb);
			cb = NULL;
			cbs = cbu = 0;
			return;
		}
		cbs += 8192;
		cb = tmp;
	}
d298 2
a299 1
	if (cbu == cbs) {
d302 1
a302 1
		tmp = realloc(cb, cbs + 8192);
a305 3
			free(cb);
			cb = NULL;
			cbs = 0;
d308 1
a308 1
		cbs += 8192;
d316 2
a317 1
		parse_configs();
d328 3
@


1.116
log
@Delete a bunch of unnecessary #includes
Use <fcntl.h> instead of <sys/{file,fcntl}.h>

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.115 2014/10/09 02:43:43 deraadt Exp $	*/
a90 1
void     build_reply(struct  con *);
d483 1
a483 1
build_reply(struct con *cp)
a492 1
		char *c = cp->obuf + off;
d503 1
a503 2
				c = grow_obuf(cp, off);
				if (c == NULL)
a514 1
	cp->osize = 0;
d516 1
a516 1
		asprintf(&cp->obuf,
d523 1
a523 1
		asprintf(&cp->obuf,
d525 1
a525 4
	if (cp->obuf != NULL)
		cp->osize = strlen(cp->obuf) + 1;
	else
		cp->osize = 0;
a535 6
doreply(struct con *cp)
{
	build_reply(cp);
}

void
d609 1
a609 1
	char *tmp;
d640 2
a641 4
	tmp = strdup(ctime(&t));
	if (tmp == NULL)
		err(1, "malloc");
	tmp[strlen(tmp) - 1] = '\0'; /* nuke newline */
d643 1
a643 2
	    hostname, spamd, tmp);
	free(tmp);
@


1.115
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.114 2014/03/26 13:09:02 gsoares Exp $	*/
a20 2
#include <sys/file.h>
#include <sys/wait.h>
d30 1
@


1.114
log
@strdup() returns NULL if out of memory, we should check it.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.113 2013/11/19 18:33:38 deraadt Exp $	*/
d240 1
a240 1
			tmp = realloc(av, (ac + 2048) * sizeof(char *));
@


1.113
log
@repair format strings for time_t, and some missing protos
ok beck phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.112 2012/06/19 17:43:40 deraadt Exp $	*/
d672 2
@


1.112
log
@use warn() instead of perror(), like the rest of the code does
from Liam J. Foy
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.111 2012/04/19 19:11:55 deraadt Exp $	*/
d101 4
d686 2
a687 2
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.%s%s",
	    cp->addr, (long)(tt - cp->s),
d691 2
a692 2
		printf("%s connected for %ld seconds.\n", cp->addr,
		    (long)(tt - cp->s));
d1057 1
d1122 2
a1123 2
			if (sscanf(optarg, "%d:%d:%d", &passtime, &greyexp,
			    &whiteexp) != 3)
d1125 3
@


1.111
log
@rate-limit accept(); small tweaks and such along the way from gilles,
millert, camield..
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.110 2012/04/18 18:15:44 deraadt Exp $	*/
d276 1
a276 1
				perror("malloc()");
d316 1
a316 1
				perror("malloc()");
d334 1
a334 1
			perror("read()");
d958 1
a958 1
				perror("read()");
d998 1
a998 1
					perror("write()");
d1012 1
a1012 1
				perror("write()");
@


1.110
log
@merge some whitespace changes before bigger changes
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.109 2012/04/13 12:24:51 deraadt Exp $	*/
d123 2
d344 1
d678 3
a702 1
	close(cp->fd);
d1051 1
a1051 2
	int ch, s, s2, conflisten = 0, syncfd = 0, i, omax = 0, one = 1;
	socklen_t sinlen;
d1393 9
a1401 1
		FD_SET(s, fdsr);
a1402 5
		/* only one active config conn at a time */
		if (conffd == -1)
			FD_SET(conflisten, fdsr);
		else
			FD_SET(conffd, fdsr);
d1408 2
a1409 1
		if (writers == 0) {
d1423 4
a1426 2
		if (n == 0)
			continue;
d1435 3
d1440 8
a1447 5
			if (s2 == -1)
				/* accept failed, they may try again */
				continue;
			for (i = 0; i < maxcon; i++)
				if (con[i].fd == -1)
d1449 22
a1470 11
			if (i == maxcon)
				close(s2);
			else {
				initcon(&con[i], s2, (struct sockaddr *)&sin);
				syslog_r(LOG_INFO, &sdata,
				    "%s: connected (%d/%d)%s%s",
				    con[i].addr, clients, blackcount,
				    ((con[i].lists == NULL) ? "" :
				    ", lists:"),
				    ((con[i].lists == NULL) ? "":
				    con[i].lists));
d1474 2
d1479 13
a1491 4
			if (conffd == -1)
				/* accept failed, they may try again */
				continue;
			else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
d1494 1
@


1.109
log
@Don't assume that the new conffd is a unset in the fd_set, it could be a
recyle of a fd which is still set.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.108 2010/01/14 00:44:12 beck Exp $	*/
d569 2
a570 1
getcaddr(struct con *cp) {
a588 1

d643 1
d646 1
d807 1
d868 1
a868 1
                        	snprintf(cp->obuf, cp->osize,
@


1.108
log
@drop connections to confused clients who do repeated command failures -
typically when a client just flings commands at us without looking
for responses and then gets confused.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.107 2010/01/11 09:57:00 beck Exp $	*/
d1454 1
a1454 2
		}
		if (conffd != -1 && FD_ISSET(conffd, fdsr))
@


1.107
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.106 2009/05/20 20:37:43 thib Exp $	*/
d82 1
d864 1
a864 1
			else
d867 7
@


1.106
log
@Do not fall back to using nobody if _user is missing, but
error out.

Add a new user _rwalld for rpc.rwalld, and use that instead
of nobody, also unconditionally drop to _rwalld not only
if rpc.rwalld was started with euid 0 (as root).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.104 2008/07/11 15:05:59 reyk Exp $	*/
d120 1
a120 1
extern char *low_prio_mx_ip; 
d563 1
a563 1
/* 
d583 1
a583 1
	if (error) 
d586 1
a586 1
	
d742 1
a742 1
			cp->helo[0] = '\0'; 
d860 1
a860 1
			if (match(cp->ibuf, "NOOP")) 
d1119 1
a1119 1
			i = strtonum(optarg, 0, 10, &errstr);			
@


1.105
log
@
PR 6090 - from Olli Hauer <ohauer@@gmx.de>

A number of small improvements:

- patch for empty lines and comments in alloweddomains_file
- remove some whitespaces at end of line.
- document comment and empty line handling
- Remove unused parameter 'r' from getopt in spamd.c, it is removed in the 'switch statement'
  but not in getopt.
  http://www.openbsd.org/cgi-bin/cvsweb/src/libexec/spamd/spamd.c.diff?r1=1.94;r2=1.95;f=h
- replace atoi with strtonum
- make debug output more usefull, display only what will be synced and not a second
  message which prints always "sync trapped %s"

- some cosemtic and whitespace fixes.
@
text
@d1231 2
a1232 3
	pw = getpwnam("_spamd");
	if (!pw)
		pw = getpwnam("nobody");
@


1.104
log
@shut off an annoying gcc warning.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.103 2007/11/03 19:16:07 beck Exp $	*/
d1066 1
a1066 1
	    getopt(argc, argv, "45l:c:B:p:bdG:h:r:s:S:M:n:vw:y:Y:")) != -1) {
d1119 2
a1120 2
			i = atoi(optarg);
			if (i < 0 || i > 10)
@


1.103
log
@

PR 5621 - spamd doesn't clear the last entry from an empty TRAP list,
noticed and patch from Piotr Sikora <piotr@@sikora.nu>
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.102 2007/04/13 22:05:43 beck Exp $	*/
d613 1
d630 1
a630 1
	if (sa->sa_len > sizeof(cp->ss))
@


1.102
log
@fix helo to error out if no domain is provided
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.101 2007/03/26 16:40:56 beck Exp $	*/
d195 4
@


1.101
log
@use new license, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.100 2007/03/26 16:32:39 beck Exp $	*/
d736 2
d739 9
a747 3
			snprintf(cp->obuf, cp->osize,
			    "250 Hello, spam sender. "
			    "Pleased to be wasting your time.\r\n");
d751 1
a751 1
			cp->state = 2;
@


1.100
log
@Copyright - I should share the blame.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.99 2007/03/26 15:20:43 beck Exp $	*/
d7 3
a9 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d11 7
a17 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.99
log
@
A couple of spamd improvements

1) Implement the NOOP command, which now seems necessary for certain
windows mail wrappers and sender verification schemes. Tested by me
and sidcarter@@symonds.net, who noticed the problem on his site.
ok millert@@

2) Change the behaviour of the maxblack parameter, instead of hanging
up immediately on new blacklisted connections when the maxblack parameter
is reached, we instead make spamd not stutter at them, so the connection
is instead completed quickly. This seems to handle peaks and spikes
much better than the old way of doing this.
ok deraadt@@, with some man page changes by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.98 2007/03/07 11:30:43 jmc Exp $	*/
d4 1
@


1.98
log
@sync usage(); ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.97 2007/03/06 23:38:36 beck Exp $	*/
d661 2
a662 4
		if (greylist && blackcount > maxblack) {
			closecon(cp); /* close and free */
			return;
		}
d843 10
d854 6
a859 2
			snprintf(cp->obuf, cp->osize,
			    "500 5.5.1 Command unrecognized\r\n");
d861 5
a865 10
		}
		cp->ip = cp->ibuf;
		cp->il = sizeof(cp->ibuf) - 1;
		cp->op = cp->obuf;
		cp->ol = strlen(cp->op);
		cp->w = t + cp->stutter;
		if (greylist && cp->blacklists == NULL) {
			cp->laststate = cp->state;
			cp->state = 98;
			goto done;
@


1.97
log
@Add -M option to specify a local address that is a lower priority MX
address than the primary one. spamd will trap hosts that contact this
address first without first contacting the primary.
- get it in, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.96 2007/03/06 01:59:43 beck Exp $	*/
d160 3
a162 3
	    "\t[-h hostname] [-l address] [-n name] [-p port] "
	    "[-S secs] [-s secs]\n"
	    "\t[-w window] [-Y synctarget] [-y synclisten]\n",
@


1.96
log
@Make the maximum number of connections dependant on kern.maxfiles rather
than a hardcoded value.
ok reyk@@, deraadt@@ with knfisms and saner variable names
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.95 2007/03/05 21:25:29 beck Exp $	*/
d53 3
d64 1
d126 2
d566 25
d813 1
d815 3
a817 3
					    "HE:%s\nIP:%s\nFR:%s\nTO:%s\n",
					    cp->helo, cp->addr, cp->mail,
					    cp->rcpt);
d1053 1
a1053 1
	    getopt(argc, argv, "45l:c:B:p:bdG:h:r:s:S:n:vw:y:Y:")) != -1) {
d1117 3
d1228 6
@


1.95
log
@remove -r option that didn't work anyway.
ok jmc@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.94 2007/03/05 02:06:14 beck Exp $	*/
d31 1
d131 1
d966 18
d1015 5
a1019 1

d1038 4
a1041 1
			if (i > MAXCON)
d1043 1
@


1.94
log
@revert unintentional MAXCON change back to 800, accidentally did last
commit with the U of A value, which may not be safe on all GENERICs with
an unmodified kern.maxfiles
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.93 2007/03/04 03:19:41 beck Exp $	*/
a104 1
char *reply = NULL;
d153 2
a154 2
	    "[-r reply] [-S secs]\n"
	    "\t[-s secs] [-w window] [-Y synctarget] [-y synclisten]\n",
a532 2
	if (reply)
		snprintf(cp->obuf, cp->osize, "%s %s\n", nreply, reply);
a1043 3
			break;
		case 'r':
			reply = optarg;
@


1.93
log
@
Database synchronizaton for spamd/spamlogd

This adds an HMAC protected synchronization protocol for use by spamd and
spamlogd.

- spamd can receive updates from other hosts for GREY, WHITE, and TRAPPED db
entries, and will update the local /var/db/spamd accordingly.

- spamd can send updates when it makes changes to the GREY or TRAPPED
entries in the db to other hosts running spamd. (Note it does not send
WHITE entries because the other spamd will see the GREY changes and have
complete information to make appropritate decisions)

- spamlogd can send updates for WHITE db entries that it performs on the local
db to other hosts running spamd, which will then apply them on remote hosts.

note that while this diff provides synchronization for changes made to the
spamd db by the daemons, it does *not* provide for sychonizing changes
to the spamd db made manually with the spamdb command.

Synchronization protocol and most of the work by reyk@@,
with a bunch of the spamd, and spamlogd stuff by me.

testing mostly at the U of A, running happily there under big load.

ok reyk@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.92 2007/02/27 23:03:09 deraadt Exp $	*/
d130 1
a130 1
#define MAXCON 1800
@


1.92
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.91 2007/02/27 23:00:54 beck Exp $	*/
d50 1
d119 1
d130 1
a130 1
#define MAXCON 800
d141 2
d155 2
a156 1
	    "\t[-s secs] [-w window]\n", __progname);
d973 1
a973 1
	int ch, s, s2, conflisten = 0, i, omax = 0, one = 1;
d980 2
d992 3
d999 2
a1000 1
	while ((ch = getopt(argc, argv, "45l:c:B:p:bdG:h:r:s:S:n:vw:")) != -1) {
d1074 9
d1089 4
d1155 6
d1253 2
d1312 2
d1376 2
@


1.91
log
@fix -b breakage - make greylisting actually be on by default
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.90 2007/02/27 14:52:31 jmc Exp $	*/
d59 1
a59 1
  	char helo[MAX_MAIL], mail[MAX_MAIL], rcpt[MAX_MAIL];
a333 1

d1156 1
a1156 1
		switch(jail_pid) {
@


1.90
log
@sort options and usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.89 2007/02/27 02:10:58 beck Exp $	*/
d134 1
a134 1
int greylist;
@


1.89
log
@Flag day for spamd -
1) config files move to /etc/mail
2) -g option goes away in spamd-setup and spamd - greylisting is now the default
3) option change to spamd, -b addr becomes -l addr.
4) -b option in spamd-setup and spamd to turn on old blacklisting mode.

Man page shortly to be flensed to make this easier to explain
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.88 2007/02/23 22:40:50 beck Exp $	*/
d144 2
d147 6
a152 5
	    "usage: spamd [-45dbv] [-B maxblack] [-l address] [-c maxcon]\n");
	fprintf(stderr,
	    "             [-G mins:hours:hours] [-h host] [-n name] [-p port]\n");
	fprintf(stderr,
	    "             [-r reply] [-S secs] [-s secs] [-w window]\n");
@


1.88
log
@Make spamd include the HELO/EHLO identification string sent by
the connecting hosts in the tuple key when greylisting. catches
a few more bogus hosts and will let us trap based on HELO later.

Changes spamdb(8) output to include the new field.

ok deraadt@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.87 2007/02/23 19:36:23 deraadt Exp $	*/
d145 1
a145 1
	    "usage: spamd [-45dgv] [-B maxblack] [-b address] [-c maxcon]\n");
d987 1
a987 1
	while ((ch = getopt(argc, argv, "45b:c:B:p:dgG:h:r:s:S:n:vw:")) != -1) {
d995 1
a995 1
		case 'b':
d1015 2
a1016 2
		case 'g':
			greylist = 1;
@


1.87
log
@continue collecting lint to be sold as a parsley substitute; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.86 2007/02/23 19:22:07 beck Exp $	*/
d59 1
a59 1
	char mail[MAX_MAIL], rcpt[MAX_MAIL];
d555 22
d708 1
d776 4
a779 2
					fprintf(grey, "IP:%s\nFR:%s\nTO:%s\n",
					    cp->addr, cp->mail, cp->rcpt);
@


1.86
log
@greytrapping improvements
	1) remove requirement for <> around spamtrap addresses
	2) add support for /etc/spamd/alloweddomains to specify
	   suffixes for which any destinations that don't match
	   get trapped

	various knf's by theo, feedback from jmc, millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.85 2006/11/27 20:46:03 beck Exp $	*/
d1192 1
a1192 1
		int max, i, n;
@


1.85
log
@Make spamd error out for a greylisted session only after the DATA
command not after the RCPT command, as this helps people out when
they are faced with retarded sender verification schemes - tested
out by a number of people on tech@@, and running at u of a for a
while. Supposedly this makes verizon sender verification happy.

Suggested as a stable candidate by people on tech@@, I'm ok with
that.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.84 2006/10/29 22:06:28 henning Exp $	*/
d342 1
a342 1
			return(-1);	/* all valid lines end in \n */
d346 1
a346 1
		return(-1);
d348 1
a348 1
	return(0);
d449 1
a449 1
		return(NULL);
d1008 1
a1008 1
				errx(1, "-h arg too long"); 
d1164 1
a1164 1
		return(greywatcher());
@


1.84
log
@use setresuid/gid and check for failure, ok bob
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.83 2006/05/15 16:47:48 jcs Exp $	*/
a755 3
					cp->laststate = cp->state;
					cp->state = 98;
					goto done;
d792 5
@


1.83
log
@add an -h option to override the hostname that is reported in the
SMTP banner

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.82 2006/03/14 22:49:41 beck Exp $	*/
d1172 5
a1176 7
	if (pw) {
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
	}
@


1.82
log
@spamd can show the wrong IP address to clients in a %A message because
the per-connection copy of the connecting address was being pointed
to the on-stack copy. Spotted (and fix suggested) by Michael Durket
in pr 5046
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.81 2005/11/30 20:44:07 deraadt Exp $	*/
d147 1
a147 1
	    "             [-G mins:hours:hours] [-n name] [-p port]\n");
d960 1
a960 1
	while ((ch = getopt(argc, argv, "45b:c:B:p:dgG:r:s:S:n:vw:")) != -1) {
d1001 6
@


1.81
log
@some cleanups prompted by lint, no really nasty bugs; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.80 2005/11/12 02:20:37 deraadt Exp $	*/
d579 1
a579 1
	cp->ia = &((struct sockaddr_in *)sa)->sin_addr;
@


1.80
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.79 2005/08/04 09:48:27 otto Exp $	*/
d425 1
a425 1
			/* fallthrough */
d428 1
a428 1
			c[i++] = sav;
d455 1
a455 2
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1
		    >= s)
d557 1
a557 1
	time_t t;
d561 1
a561 1
	time(&t);
d596 2
a597 2
	cp->w = t + cp->stutter;
	cp->s = t;
d615 1
a615 1
	time_t t;
d617 1
a617 1
	time(&t);
d619 1
a619 1
	    cp->addr, (long)(t - cp->s),
d624 1
a624 1
		    (long)(t - cp->s));
d705 1
a706 1
	case 3:
d728 1
a729 1
	case 5:
d773 1
a774 1
	case 50:
d834 1
a835 1
	case 98:
@


1.79
log
@Fix handling of empty entries at the end of an address list; avoids
always skipping the last address.  ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.78 2005/05/23 21:08:43 frantzen Exp $	*/
d582 2
a583 1
	cp->stutter = (greylist && !grey_stutter && cp->blacklists == NULL) ? 0 : stutter;
d592 2
a593 3
	snprintf(cp->obuf, cp->osize,
		 "220 %s ESMTP %s; %s\r\n",
		 hostname, spamd, tmp);
@


1.78
log
@have to ignore SIGPIPE in the child too or a spammer can kill spamd just by
closing the connection while we're trying to write to it
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.77 2005/04/16 14:23:35 deraadt Exp $	*/
d234 1
a234 1
	if (av[au - 1][0] == '\0');
d240 1
a240 1
		sdl_add(name, msg, av, au - 1);
@


1.77
log
@missing getopt choice; from dennis
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.76 2005/04/14 16:07:52 beck Exp $	*/
d1128 1
@


1.76
log
@Make spamd stutter at greylisted connections for a short period before talking
full speed. By default do this for 10 seconds. Many spammers disconnect by
then. Adds -S option to select the amount of time greylisted connections
will be stuttered at.

	feedback from jmc@@, deraadt@@,   ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.75 2005/03/11 23:09:53 beck Exp $	*/
d961 1
a961 1
	while ((ch = getopt(argc, argv, "45b:c:B:p:dgG:r:s:n:vw:")) != -1) {
@


1.75
log
@"Greytrapping" for spamd - allow for spamd greylisting to maintain
a list of spamtrap destination addresses in the spamd database. When
a spamtrap address gets an attempted greylist delivery, blacklist the
offending host for a day. Does not affect hosts already whitelisted.

ok deraadt@@, jmc@@, dhartmei@@ to get it in so it can be whacked on
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.74 2004/11/17 15:29:38 beck Exp $	*/
d135 1
d149 1
a149 1
	    "             [-r reply] [-s secs] [-w window]\n");
d582 1
a582 1
	cp->stutter = (greylist && cp->blacklists == NULL) ? 0 : stutter;
d891 5
d946 1
d1011 6
@


1.74
log
@- \r\n fix for QUIT command

- Implement RSET in spamd - some virus scanning products (notably symantec's
viruswall) spew a RSET into the smtp stream before every attempted delivery.
(noticed by reitenba@@fh-brandenburg.de and some others). This ensures
such things can successfully talk to a spamd greylister.

ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.73 2004/10/05 15:20:30 beck Exp $	*/
d108 1
d110 1
d114 1
d117 1
d122 1
a178 3
	if (debug > 0)
		printf("read config line %40s ...\n", line);

d232 5
a236 1
	if (au < 2)
d330 20
d936 1
a936 1
	u_short port, cfg_port;
d1103 5
a1114 1
			close(greypipe[0]);
d1120 8
a1130 1
		close(greypipe[1]);
d1136 7
d1178 1
d1232 2
d1292 1
a1292 1
		if (conffd != -1 && FD_ISSET(conffd, fdsr)) {
d1294 2
a1295 2
		}

@


1.73
log
@change default to 451 for greylisting, thanks to a number of
people on misc, and some observations by Evan harris on the greylisting
mailing list that a number of clustered mailers like aol behave better
(and retry from the same IP) when they see a 451, but do not when
they see a 450 (traditionally used for mailbox lock failure)

450 was the original for spamd, as the default for the tarpit is to
encourage quick retries to punish blacklisted smtp servers more. This
got carried over to the greylisting implementation, and isnt' really
optimal for that case.

ok millert@@, henning@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.72 2004/09/18 07:29:38 beck Exp $	*/
d628 1
a628 1
		snprintf(cp->obuf, cp->osize, "221 %s\n", hostname);
d637 10
@


1.72
log
@This should be info, from mike@@tric.ru
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.71 2004/08/17 09:38:07 henning Exp $	*/
d484 1
a484 1
		    "450 Temporary failure, please try again later.\r\n");
@


1.71
log
@impliment QUIT, beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.70 2004/08/08 19:32:45 deraadt Exp $	*/
d706 1
a706 1
					syslog_r(LOG_DEBUG, &sdata,
@


1.70
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.69 2004/07/04 22:45:41 deraadt Exp $	*/
d627 10
@


1.69
log
@typo; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.68 2004/06/29 11:19:06 mickey Exp $	*/
d975 1
a975 1
	
d1059 1
a1059 1
		case -1: 
@


1.68
log
@absolutely no need to include machine/endian.h after sys/types.h and sys/types.h after sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.67 2004/06/21 17:05:43 itojun Exp $	*/
d1124 1
a1124 1
			fdsr = NULL;
@


1.67
log
@use getaddr/nameinfo for address resolution.  beck, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.66 2004/04/03 01:37:18 dhartmei Exp $	*/
a46 2
#include <sys/types.h>
#include <machine/endian.h>
@


1.66
log
@fix logging. without -v, you get just the connection level, no mail data.
with -v, you get From/To/Subject at LOG_INFO, and the first ten body
lines at LOG_DEBUG. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.65 2004/04/02 23:48:35 dhartmei Exp $	*/
d58 1
a58 1
	struct sockaddr_in sin;
d97 1
a97 1
void     initcon(struct con *, int, struct sockaddr_in *);
d531 1
a531 1
initcon(struct con *cp, int fd, struct sockaddr_in *sin)
d535 1
d549 7
a555 3
	memcpy(&cp->sin, sin, sizeof(struct sockaddr_in));
	cp->af = sin->sin_family;
	cp->ia = (void *) &cp->sin.sin_addr;
d558 4
a561 1
	strlcpy(cp->addr, inet_ntoa(sin->sin_addr), sizeof(cp->addr));
d1205 1
a1205 1
				initcon(&con[i], s2, &sin);
@


1.65
log
@nextstate() can get passed a read(2) chunk containing multiple lines,
so separate lines before logging headers/body. doesn't make logging
more verbose, just fixes the case where chunks contain multiple lines.
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.64 2004/03/17 14:42:20 beck Exp $	*/
d744 9
a752 1
	case 60: {
d756 4
a759 2
			if (*q == '\r' || *q == '\n' || q == cp->ip) {
				*q++ = 0;
d775 1
a775 1
				p = q;
a828 3
		if (verbose)
			syslog_r(LOG_DEBUG, &sdata, "%s: says '%s'", cp->addr,
			    cp->ibuf);
@


1.64
log
@fix problem with counter and logging spotted by danh, where logging
would get messed up when the blacklist limit was hit.
tested by danh@@ and me
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.63 2004/03/16 09:19:25 jmc Exp $	*/
d744 23
a766 16
	case 60:
		if (!strcmp(cp->ibuf, ".") ||
		    (cp->data_body && ++cp->data_lines >= 10)) {
			cp->laststate = cp->state;
			cp->state = 98;
			goto done;
		}
		if (!cp->data_body && !*cp->ibuf)
			cp->data_body = 1;
		if (verbose && cp->data_body && *cp->ibuf)
			syslog_r(LOG_DEBUG, &sdata, "%s: Body: %s", cp->addr,
			    cp->ibuf);
		else if (verbose && (match(cp->ibuf, "FROM:") ||
		    match(cp->ibuf, "TO:") || match(cp->ibuf, "SUBJECT:")))
			syslog_r(LOG_INFO, &sdata, "%s: %s", cp->addr,
			    cp->ibuf);
d771 1
@


1.63
log
@sort options and escape a minus sign;
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.62 2004/03/15 21:53:39 beck Exp $	*/
a552 10
	if (cp->blacklists != NULL) {
		blackcount++;
		if (greylist && blackcount > maxblack) {
			closecon(cp); /* close and free */
			return;
		}
		cp->lists = strdup(loglists(cp));
	}
	else
		cp->lists = NULL;
d568 10
@


1.62
log
@Add -B option, with maxblack limit to limit the number of blacklist
connections to something less than maxcon when greylisting. This ensures
you don't completely run out of connections tarpitting spammers, and not
allow real mail through.
ok dhartmei@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.61 2004/03/14 23:09:44 beck Exp $	*/
d141 1
a141 1
	    "usage: spamd [-45dgv] [-b address] [-B maxblack] [-c maxcon]\n");
@


1.61
log
@make window size adjustement on sockets only after the DATA
connection. This ensures that greylisted connections are not delayed
by a small windows size, but blacklisted connections still have to
send the body through a tiny window, and presumably the body is
the vast majority of what is being sent anyway.
ok dhartmei@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.60 2004/03/13 17:46:15 beck Exp $	*/
d127 2
d141 1
a141 1
	    "usage: spamd [-45dgv] [-b address] [-c maxcon]\n");
d553 6
a558 1
	if (cp->blacklists != NULL)
d560 1
d598 1
d887 1
a887 1
	while ((ch = getopt(argc, argv, "45b:c:p:dgG:r:s:n:vw:")) != -1) {
d898 4
d954 5
d1027 4
d1184 2
a1185 2
				    "%s: connected (%d)%s%s",
				    con[i].addr, clients,
@


1.60
log
@Add signal handler to parent, so that when greylisting we don't need to
kill all three processes to make it go away. Adjust daemon() call and
logging appropriately.
ok henning@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.59 2004/03/12 21:02:58 beck Exp $	*/
d719 5
a967 6

	if (window && setsockopt(s, SOL_SOCKET, SO_RCVBUF, &window,
	    sizeof(window)) == -1) {
		syslog(LOG_ERR, "setsockopt: %s", strerror(errno));
		return (-1);
	}
@


1.59
log
@paranoia and cleanup, ensure we use free then NULL everywhere.
ok millert@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.58 2004/03/11 18:32:17 beck Exp $	*/
d115 1
a857 1
	pid_t pid;
d1004 5
d1011 9
a1019 7
		if (pipe(greypipe) == -1)
			err(1, "pipe");

		pid = fork();
		switch(pid) {
		case -1:
			err(1, "fork");
d1025 1
a1025 1
				warn("fdopen");
d1033 4
a1036 2
		if (grey == NULL)
			err(1, "fdopen");
d1061 1
a1061 4
	if (debug == 0) {
		if (daemon(1, 1) == -1)
			err(1, "daemon");
	} else
@


1.58
log
@fix bug where custom 450 messages are not displayed,
found by yongari@@kt-is.co.kr
ok dhartmei@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.57 2004/03/10 00:33:39 beck Exp $	*/
d536 5
a540 2
	if (cp->blacklists)
		free(cp->blacklists);
d592 1
a592 1
	if (cp->osize > 0) {
@


1.57
log
@fix missing space, also from
yongari@@kt-is.co.kr
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.56 2004/03/10 00:32:54 beck Exp $	*/
d445 1
a445 4
	if (matches == NULL) {
		free(cp->obuf);
		cp->obuf = NULL;
		cp->osize = 0;
a446 1
	}
d468 1
d471 3
@


1.56
log
@add -b option to specify local bind address, sent by
yongari@@kt-is.co.kr
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.55 2004/02/28 00:03:59 beck Exp $	*/
d477 1
a477 1
		    "%s-You are trying to send mail from an address"
@


1.55
log
@- ensure greylist entry expiry is not updated until actually whitelisted
  to avoid keeping multiple grey entries around from a single host for
  extra time.
- make -G work
- paranoia and cleanup suggestions from deraadt@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.54 2004/02/26 08:18:56 deraadt Exp $	*/
d138 1
a138 2
	    "usage: spamd [-45dgv] [-c maxcon] [-G mins:hours:hours] [-n name]"
	    "[-p port] [-r reply] [-s secs]\n");
d140 3
a142 1
	    "             [-w window]\n");
d855 1
d870 1
a870 1
	while ((ch = getopt(argc, argv, "45c:p:dgG:r:s:n:vw:")) != -1) {
d878 3
d916 1
d977 5
a981 1
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
@


1.54
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.53 2004/02/26 07:28:55 beck Exp $	*/
a76 1
	int obufalloc;
a149 2
	if (!cp->obufalloc)
		cp->obuf = NULL;
a154 1
		cp->obufalloc = 0;
a158 1
		cp->obufalloc = 1;
d445 1
a445 2
		if (cp->osize)
			free(cp->obuf);
d448 1
a448 1
		goto bad;
d471 2
a472 6
bad:
	/* Out of memory, or no match. give generic reply */
	if (cp->obuf != NULL && cp->obufalloc) {
		free(cp->obuf);
		cp->obuf = NULL;
	}
d483 1
a483 5
	if (cp->obuf == NULL) {
		/* we're having a really bad day.. */
		cp->obufalloc = 0; /* know not to free or mangle */
		cp->obuf = "450 Try again\n";
	} else
d485 9
d499 1
a499 3
	if (reply) {
		if (!cp->obufalloc)
			errx(1, "shouldn't happen");
a500 1
	}
d533 2
a534 4
	if (cp->obufalloc) {
		free(cp->obuf);
		cp->obuf = NULL;
	}
d553 2
a554 3
		tmp = "some time";
	else
		tmp[strlen(tmp) - 1] = '\0'; /* nuke newline */
d556 3
a558 4
	    "220 %s ESMTP %s; %s\r\n",
	    hostname, spamd, tmp);
	if (tmp != NULL)
		free(tmp);
d588 1
a588 1
	if (cp->osize > 0 && cp->obufalloc) {
d997 2
a998 1
		if (pid == -1)
d1000 1
a1000 9
		if (pid != 0) {
			/* parent - run greylister */
			close(greypipe[1]);
			grey = fdopen(greypipe[0], "r");
			if (grey == NULL)
				err(1, "fdopen");
			return(greywatcher());
			/* NOTREACHED */
		} else {
d1008 1
d1010 7
d1019 1
d1041 1
a1041 1
			err(1, "fork");
d1061 1
d1063 1
@


1.53
log
@Add -g option for greylisting support for spamd. The greylisting techinque
originates from a paper by Evan Harris which can be found at
http://projects.puremagic.com/greylisting/. This implementation makes
spamd allow for non-blacklisted addresses to be treated as "greylisted".
where they are tracked in a db file, and whitelisted by addition to a
pf table when the same envelope from and to are retried from the same
source IP address. Testing by many, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.52 2003/11/09 07:35:25 dhartmei Exp $	*/
d416 2
a417 1
loglists(struct con *cp) {
d479 1
a479 1
	if (cp->obuf != NULL && cp->obufalloc)
d481 2
d693 4
a696 4
				if(debug)
				  fprintf(stderr, "(%s) %s: %s -> %s\n",
				    cp->blacklists ? "BLACK" : "GREY",
				    cp->addr, cp->mail, cp->rcpt);
@


1.52
log
@add missing -v to getopt
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.51 2003/11/08 09:01:04 jmc Exp $	*/
d51 1
d61 2
a62 1
	char mail[64], rcpt[64];
d85 2
d95 2
a96 2
char    *build_reply(struct  con *);
char    *doreply(struct con *);
d110 6
d129 1
a134 1

d139 2
a140 2
	    "usage: spamd [-45dv] [-c maxcon] [-n name] [-p port] [-r reply] "
	    "[-s secs]\n");
d165 1
a165 1
	}	
a167 1

a326 1

d415 5
d421 21
a441 1
char *
a444 1
	static char matchlists[80];
d447 1
a447 3
	matchlists[0] = '\0';

	matches = sdl_lookup(blacklists, cp->af, cp->ia);
d456 1
a456 1
		int used = 0, s = sizeof(matchlists) - 4;
a459 10
		/* don't report an insane amount of lists in the logs.
		 * just truncate and indicate with ...
		 */
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1
		    >= s)
			strlcat(matchlists, " ...", sizeof(matchlists));
		else {
			strlcat(matchlists, " ", s);
			strlcat(matchlists, matches[0]->tag, s);
		}
a475 1
	return matchlists;
d478 12
a489 5
	asprintf(&cp->obuf,
	    "%s-Sorry %s\n"
	    "%s-You are trying to send mail from an address listed by one\n"
	    "%s or more IP-based registries as being a SPAM source.\n",
	    nreply, cp->addr, nreply, nreply);
a495 1
	return matchlists;
d498 1
a498 1
char *
a504 1
		return("");
d506 1
a506 1
	return (build_reply(cp));
d535 1
d542 2
d551 6
d558 5
d564 4
a567 2
	    "220 %s ESMTP %s; %s",
	    hostname, spamd, ctime(&t));
d570 1
a570 1
	cp->w = t + stutter;
d582 4
a585 2
	syslog_r(LOG_INFO, &sdata, "%s: disconnected after %ld seconds.",
	    cp->addr, (long)(t - cp->s));
d593 4
d631 1
a631 1
			    "Pleased to be wasting your time.\n");
d636 1
a636 1
			cp->w = t + stutter;
d654 1
a654 1
			    "Your time will be spent, for nothing.\n");
d659 1
a659 1
			cp->w = t + stutter;
d677 1
a677 1
			    "hurting me.\n");
d682 11
a692 3
			cp->w = t + stutter;
			if (cp->mail[0] && cp->rcpt[0])
				syslog_r(LOG_INFO, &sdata, "%s: %s -> %s",
d694 10
d721 1
a721 1
			    "itself\n");
d725 1
a725 1
			    "500 5.5.1 Command unrecognized\n");
d732 1
a732 1
		cp->w = t + stutter;
d737 1
a737 1
		        cp->laststate = cp->state;
d746 2
a747 2
		else if (verbose && (match(cp->ibuf, "FROM:") || 
		     match(cp->ibuf, "TO:") || match(cp->ibuf, "SUBJECT:")))
d756 1
a756 4
		cp->lists = strdup(doreply(cp));
		if (cp->lists != NULL)
			syslog_r(LOG_INFO, &sdata, "%s: matched lists: %s",
			    cp->addr, cp->lists);
d759 1
a759 1
		cp->w = t + stutter;
d780 1
a780 1
		if (n == 0) {
d782 1
a782 1
		} else if (n == -1) {
d814 1
a814 1
		if (*cp->op == '\n') {
d827 6
a832 2
		n = write(cp->fd, cp->op, one ? 1 : cp->ol);
		if (n == 0) {
d834 1
a834 1
		} else if (n == -1) {
d844 1
a844 1
	cp->w = t + stutter;
d857 2
a858 3
	struct passwd *pw;
	int ch, s, s2, conflisten = 0, i, omax = 0;
	int sinlen, one = 1;
d862 1
d877 1
a877 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:vw:")) != -1) {
d898 14
d937 1
a937 1
	rlp.rlim_cur = rlp.rlim_max = maxcon + 7;
d1000 27
d1148 7
a1154 2
				syslog_r(LOG_INFO, &sdata, "%s: connected (%d)",
				    con[i].addr, clients);
d1161 1
a1161 1
			if (conffd == -1) 
@


1.51
log
@add -v and -w window to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.50 2003/10/22 21:31:38 beck Exp $	*/
d812 1
a812 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:w:")) != -1) {
@


1.50
log
@make logging less verbose by default - default logs connect, disconnect
and blacklist matches. Add -v (verbose) flag to allow other detailed
logging (subject, body, smtp dialogue, etc.) when it's needed.
ok dhartmei@@ -> ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.49 2003/10/03 17:05:50 beck Exp $	*/
d129 1
a129 1
	    "usage: spamd [-45d] [-c maxcon] [-n name] [-p port] [-r reply] "
d131 2
@


1.49
log
@1) Don't loop on invalid commands
2) Allow multiple RCPT's
ok mpech@@, helpful stress testing by Chris Nadovich <chris@@jtan.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.48 2003/09/26 16:07:29 deraadt Exp $	*/
d119 1
d677 2
a678 2
		if (cp->data_body && *cp->ibuf)
			syslog_r(LOG_INFO, &sdata, "%s: Body: %s", cp->addr,
d680 2
a681 2
		else if (match(cp->ibuf, "FROM:") || match(cp->ibuf, "TO:") ||
		    match(cp->ibuf, "SUBJECT:"))
d738 3
a740 2
		syslog_r(LOG_DEBUG, &sdata, "%s: says '%s'", cp->addr,
		    cp->ibuf);
d841 3
@


1.48
log
@can free(NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.47 2003/09/26 04:42:11 beck Exp $	*/
d55 1
d572 1
d585 1
d595 1
d608 1
d618 1
d631 1
d644 2
a645 1
		cp->state = 50;
d659 1
d670 1
d696 1
@


1.47
log
@make accept failures not globally fatal.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.46 2003/09/26 01:58:55 deraadt Exp $	*/
d943 2
a944 4
			if (fdsr)
				free(fdsr);
			if (fdsw)
				free(fdsw);
@


1.46
log
@free(NULL) allowed
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.45 2003/09/24 01:14:59 deraadt Exp $	*/
d1016 3
a1018 5
			if (s2 == -1) {
				if (errno == EINTR)
					continue;
				err(1, "accept");
			}
d1034 4
a1037 5
			if (conffd == -1) {
				if (errno == EINTR)
					continue;
				err(1, "accept");
			} else if (ntohs(lin.sin_port) >= IPPORT_RESERVED) {
@


1.45
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.44 2003/09/24 01:14:48 deraadt Exp $	*/
d141 1
a141 2
		if (cp->obuf)
			free(cp->obuf);
d210 1
a210 2
				if (av)
					free(av);
@


1.44
log
@crank max connections to 800 (really, there are poeple doing this)
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.43 2003/09/18 23:33:44 avsm Exp $	*/
d869 2
a870 1
	if (window && setsockopt(s, SOL_SOCKET, SO_RCVBUF, &window, sizeof(window)) == -1) {
@


1.43
log
@realloc spring cleaning, simplifies the code some
beck@@ ok, deraadt@@ ok an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.42 2003/09/04 01:20:33 tedu Exp $	*/
d114 1
a114 1
#define MAXCON 200
@


1.42
log
@forgot to put w in optstring in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.41 2003/09/03 21:22:19 tedu Exp $	*/
d140 8
a147 1
	if (tmp != NULL) {
d152 1
a152 2
	}
	return (NULL);
d210 5
a214 1
			if (tmp == NULL)
d216 1
d346 1
a346 1
				goto no_mem;
a402 7
no_mem:
	/* Out of memory, free obuf and bail, caller must deal */
	if (cp->osize)
		free(cp->obuf);
	cp->obuf = NULL;
	cp->osize = 0;
	return (-1);
d447 1
a447 5
				if (c == NULL) {
					if (cp->osize)
						free(cp->obuf);
					cp->obuf = NULL;
					cp->osize = 0;
a448 1
				}
@


1.41
log
@permit the window/receive buffer to be adjustable.  default back to system
default.  in reponse to pr3435.  ok beck deraadt dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.40 2003/08/26 18:30:03 dhartmei Exp $	*/
d800 1
a800 1
	while ((ch = getopt(argc, argv, "45c:p:dr:s:n:")) != -1) {
@


1.40
log
@re-add logging of matched blacklists lost in previous commit, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.39 2003/08/24 23:20:19 dhartmei Exp $	*/
d119 1
d832 5
d870 1
a870 2
	one = 1;
	if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &one, sizeof(one)) == -1) {
@


1.39
log
@missing colon in syslog msg (cosmetic)
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.38 2003/08/23 21:22:34 dhartmei Exp $	*/
d682 3
@


1.38
log
@add -s to specify stuttering delay, set receive buffer size to 1 byte
(causing a small TCP window size, tying up sender's resources), additional
states: keep connection until ten body lines have been received, improved
logging through syslog (envelope from/to, From:/To:/Subject: in header,
first lines of body) at various levels. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.37 2003/08/23 20:36:44 itojun Exp $	*/
d540 1
a540 1
	syslog_r(LOG_INFO, &sdata, "%s disconnected after %ld seconds.",
@


1.37
log
@fix printf format for time_t.  notified by casha@@e7.pl.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.36 2003/07/29 18:39:23 deraadt Exp $	*/
d80 2
d118 1
d126 2
a127 1
	    "usage: spamd [-45d] [-c maxcon] [-n name] [-p port] [-r reply]\n");
d528 1
a528 1
	cp->w = t + 1;
d530 1
a530 1
	strlcpy(cp->rend, "\n\r", sizeof cp->rend);
d537 1
a537 2
	if (debug > 0) {
		time_t t;
d539 4
a542 1
		time(&t);
a544 1
	}
d586 1
a586 1
			cp->w = t + 1;
d607 1
a607 1
			cp->w = t + 1;
d628 4
a631 1
			cp->w = t + 1;
d645 36
d684 1
a685 1
		cp->w = t + 1;
a687 3
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s %ldsec by lists:%s",
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s),
		    (cp->lists != NULL) ? cp->lists : "");
d720 3
d725 2
d763 1
a763 1
	cp->w = t + 1;
d796 1
a796 1
	while ((ch = getopt(argc, argv, "45c:p:dr:n:")) != -1) {
d820 5
d861 6
d921 1
d1020 1
a1020 1
			else
d1022 3
@


1.36
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.35 2003/06/11 14:24:46 deraadt Exp $	*/
d537 2
a538 1
		printf("%s connected for %d seconds.\n", cp->addr, t - cp->s);
@


1.35
log
@ansi cleanup; ok ian markus
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.34 2003/05/17 02:41:19 beck Exp $	*/
d415 1
a415 1
		int used = 0, s = sizeof(matchlists) - 4; 
d422 2
a423 2
		if (strlen(matchlists) + strlen(matches[0]->tag) + 1 
		    >= s) 
d540 1
a540 1
		free(cp->lists);	  
d644 1
a644 1
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s), 
a975 1
				
@


1.34
log
@strsep does not work that way.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.33 2003/05/16 22:30:15 beck Exp $	*/
d93 1
a93 1
int      match(char *, char *);
d554 1
a554 1
match(char *s1, char *s2)
@


1.33
log
@This was using the wrong buffer, and wrong lengths. fix it from me and
tedu,
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.32 2003/04/15 07:16:14 deraadt Exp $	*/
d485 1
a485 1
	if (!s)
@


1.32
log
@toast some += snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.31 2003/04/12 23:38:01 deraadt Exp $	*/
d658 1
a658 1
	int i, n;
d669 1
d671 2
a672 3
				for (i = 0; i < n; i++)
					if (strchr(cp->rend, cp->op[i]))
						end = 1;
@


1.31
log
@rlimit handling code; aw@@osn.de
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.30 2003/04/08 22:09:53 vincent Exp $	*/
d302 1
a302 1
append_error_string (struct con *cp, size_t off, char *fmt, int af, void *ia)
d316 2
a317 1
	i += snprintf(c, len, "%s ", nreply);
d337 2
a338 1
			i += snprintf(c + i, len, "%s ", nreply);
@


1.30
log
@more logical handling of select() errors

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.29 2003/03/30 01:50:21 beck Exp $	*/
d31 1
d732 1
d779 4
@


1.29
log
@fix logging time to reflect reality. minus crack induced blank lines.
ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.28 2003/03/28 20:35:24 beck Exp $	*/
d926 5
a930 2
		if (n == -1 && errno == EINTR)
			err(1, "select");
@


1.28
log
@logging fix from tholo@@
log which lists are matched, so you can tell what is actually working.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.27 2003/03/28 17:52:24 jason Exp $	*/
d75 1
d536 4
d633 1
a633 2
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s %ldsec by lists:%s",
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s), doreply(cp));
d640 3
@


1.27
log
@report how much time was wasted; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.26 2003/03/20 01:39:36 david Exp $	*/
d86 2
a87 2
void     build_reply(struct  con *);
void     doreply(struct con *);
d393 1
a393 1
void
d397 1
d400 2
d411 1
a411 1
		int used = 0;
d415 10
d446 1
a446 1
	return;
d460 1
d463 1
a463 1
void
d470 1
a470 1
		return;
d472 1
a472 1
	build_reply(cp);
d483 2
d628 2
a629 3
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s %ldsec",
		    cp->addr, cp->mail, cp->rcpt, (long)(t - cp->s));
		doreply(cp);
@


1.26
log
@cmdline options and descriptions in alphabetical order in usage() and manpage
add arguments to the flags that take them in the DESCRIPTION
add "inet" to the rdr rule example to match etc/pf.conf example

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.25 2003/03/13 21:20:42 beck Exp $	*/
d612 2
a613 2
		syslog_r(LOG_INFO, &sdata, "%s: %s -> %s",
		    cp->addr, cp->mail, cp->rcpt);
@


1.25
log
@make spamd-setup/spamd use/require a reserved source port for the
configuration connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.24 2003/03/09 19:27:30 beck Exp $	*/
d121 1
a121 1
	    "usage: spamd [-45d] [-r reply] [-c maxcon] [-p port] [-n name]\n");
@


1.24
log
@typo. henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.23 2003/03/09 19:22:25 beck Exp $	*/
d939 3
d943 1
@


1.23
log
@Fix a few typos, Make spamd and spamd-setup use /etc/services to find
their ports. Adds "spamd" and "spamd-cfg" services to /etc/services.
Mostly from Daniel Lucq <daniel@@lucq.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.22 2003/03/08 22:05:20 deraadt Exp $	*/
d717 1
a717 1
		errx(1, "Can't find service \"spamd-cff\" in /etc/services");
@


1.22
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.21 2003/03/04 05:54:53 beck Exp $	*/
d45 4
d707 2
a708 1
	u_short port = 8025;
d713 7
d800 1
a800 1
	lin.sin_port = htons(port + 1);
@


1.21
log
@ugh. default examples don't work since with an rdr to 127.0.0.1
you can't tell what socket you're talking to. avoid the whole
issue and put the configuration on port + 1,  todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.20 2003/03/03 19:35:17 deraadt Exp $	*/
d407 1
d826 1
@


1.20
log
@oops, removed a char from rend
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.19 2003/03/03 14:47:37 deraadt Exp $	*/
d787 1
a787 1
	lin.sin_port = htons(port);
@


1.19
log
@always set ptr to NULL after free; from cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.18 2003/03/03 00:51:40 cloder Exp $	*/
d501 1
a501 1
	strlcpy(cp->rend, "\n", sizeof cp->rend);
@


1.18
log
@More KNF.  Use a size_t in one place where it makes sense.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.17 2003/03/02 23:55:11 cloder Exp $	*/
d226 1
d266 1
d383 1
a384 1
	cp->obuf = NULL;
d399 1
a400 1
		cp->obuf = NULL;
d419 1
a420 1
					cp->obuf = NULL;
d484 1
@


1.17
log
@Add ANSI prototypes for all functions.  Now compiles with
-ansi -Wstrict-prototypes, update the Makefile to reflect
that.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.16 2003/03/02 23:04:35 kjell Exp $	*/
d84 1
a84 1
void     setlog(char *, int, char *);
d102 1
a102 1
size_t cbs, cbu; 
d206 1
a206 1
 parse_error:
d233 1
a233 1
	
d286 1
a286 1
 configdone:
d377 1
a377 1
 no_mem:
d455 1
a455 1
setlog(char *p, int l, char *f)
d465 1
a465 1
	strlcpy(p, s, l);
d682 1
a682 1
 handled:
@


1.16
log
@KNF and one err->errx. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.15 2003/03/02 22:30:35 deraadt Exp $	*/
a46 20
char hostname[MAXHOSTNAMELEN];
struct syslog_data sdata = SYSLOG_DATA_INIT;
char *reply = NULL;
char *nreply = "450";
char *spamd = "spamd IP-based SPAM blocker";

extern struct sdlist *blacklists;

int conffd = -1;
char *cb;
size_t cbs, cbu;

time_t t;

#define MAXCON 200
int maxcon = MAXCON;
int clients;
int debug;
#define MAXTIME 400

d75 37
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.14 2003/03/02 20:49:10 deraadt Exp $	*/
d35 1
d37 2
d40 3
d44 1
a44 6
#include <pwd.h>
#include <syslog.h>
#include <string.h>
#include <stdlib.h>
#include <getopt.h>
#include <err.h>
d116 1
a116 1
		return(cp->obuf + off);
d118 1
a118 1
	return(NULL);
d131 1
a131 1
	if (debug)
d187 1
a187 1
	return(0);
d215 1
a215 1
	cb[cbu++]='\0';
d255 1
a255 1
	n = read(conffd, cb+cbu, cbs-cbu);
d353 1
a353 1
			sav='\0';
d359 1
a359 1
	return(i);
d366 1
a366 1
	return(-1);
d405 2
a406 2
			cp->obuf[off++]='\n';
			cp->obuf[off]='\0';
d420 1
a420 1
		cp->obuf="450 Try again\n";
d430 1
a430 1
			err(1, "shouldn't happen");
d507 1
a507 1
	return !strncasecmp(s1, s2, strlen(s2));
d744 1
a744 1
		return(-1);
d752 1
a752 1
		return(-1);
@


1.14
log
@unbelievable; buffer mismanagement in new code
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.13 2003/03/02 20:40:15 deraadt Exp $	*/
d166 1
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.12 2003/03/02 20:32:05 deraadt Exp $	*/
d135 1
a135 1
	for (cp = name; *cp != ';'; cp++)
d137 2
@


1.12
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.11 2003/03/02 19:22:00 beck Exp $	*/
d106 2
a107 1
	char * tmp;
d194 1
a195 1
	char *start, *end;
d367 1
a367 1
build_reply(struct  con * cp)
d416 1
a416 1
		cp->obuf="450 Try again\r\n";
d477 1
a477 1
	strlcpy(cp->rend, "\n\r", sizeof cp->rend);
d903 1
a903 1
		if (conffd != -1  && FD_ISSET(conffd, fdsr)) {
@


1.11
log
@Spamd changes to add blacklist awareness to spamd, new spamd-setup.pl
which configures individual blacklists sources and deals with whitelists.
Perl still needs some stylistic changes as suggested by bmc which will go
in shortly.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.10 2003/02/11 01:41:10 deraadt Exp $	*/
d56 1
a56 1
size_t cbs, cbu; 
d123 21
a143 20
	  char *cp, prev, *name, *msg;
	  static char **av = NULL;
	  static size_t ac = 0;
	  size_t au = 0;
	  int mdone = 0;

	  if (debug)
		  printf("read config line %40s ...\n", line);

	  name = line;

	  for (cp = name; *cp != ';'; cp++);
	  *cp++ = '\0';
	  msg = cp;
	  if (*cp++ != '"')
		  goto parse_error;
	  prev = '\0';
	  for (;!mdone;cp++) {
		  switch (*cp) {
		  case '\\':
d146 1
a146 1
			else 
d149 34
a182 34
		  case '"':
			  if (prev != '\\') {
				  cp++;
				  if (*cp == ';') {
					  mdone = 1;
					  *cp = '\0';
				  } else 
					  goto parse_error;
			  }
			break;
		  case '\0':
			  goto parse_error;
		  default:
			  prev = '\0';
		  }
				
	  }

	  do {
		  if (ac == au) {
			  char **tmp;
			  tmp = realloc(av, (ac + 2048) * sizeof(char *));
			  if (tmp == NULL) {
				  return (-1);
			  }
			  av = tmp;
			  ac += 2048;
		  }
	  } while ((av[au++] = strsep(&cp, ";")) != NULL);
	  if (au < 2)
		  goto parse_error;
	  else 
		  sdl_add(name, msg, av, au - 1);
	  return(0);
d185 3
a187 4
	  if (debug > 0)
		  printf("bogus config line - need 'tag;message;a/m;a/m;a/m...'\n");
	  return (-1);

a189 1

d191 2
a192 1
parse_configs(void) {
d196 3
a198 2
	if (cbu == cbs) { 
		char * tmp;
d220 1
a220 2
		}
		else 
a226 1

d235 3
a237 2
	if (cbu == cbs) { 
		char * tmp;
d252 1
a252 1
		printf("read %d config bytes\n", n); 
d260 2
a261 3
	} else {
		cbu += n;  
	}
d263 1
d281 1
a281 1
	if (off == 0) {
d283 1
a283 1
	}
d291 3
a293 2
		/* make sure we at minimum, have room to add a 
		 * format code (4 bytes), and a v6 address(39 bytes) 
d348 1
a348 1
			sav='\0'; 
d390 1
a390 1
			if ( left < 1) {
d416 1
a416 1
	} else {
a417 1
	}
d426 1
a426 2
		snprintf(cp->obuf, cp->osize,
		    "%s %s\n", nreply, reply);
d492 1
a492 1
		cp->osize = 0;	
d851 1
a851 1
		if (conffd == -1) 
a854 1
			
@


1.10
log
@oops; beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.9 2003/01/30 09:47:16 henning Exp $	*/
d44 1
d52 6
d69 3
d88 3
a90 1
	char obuf[8192];
d103 317
d424 3
a426 1
		snprintf(cp->obuf, sizeof cp->obuf,
d430 1
a430 7

	snprintf(cp->obuf, sizeof cp->obuf,
	    "%s-SPAM. www.spews.org/ask.cgi?x=%s\n"
	    "%s-You are trying to send mail from an address listed by one or\n"
	    "%s-more IP-based registries as being in a SPAM-generating netblock.\n"
	    "%s SPAM. www.spews.org/ask.cgi?x=%s\n",
	    nreply, cp->addr, nreply, nreply, nreply, cp->addr);
d459 3
d463 2
d466 3
d470 1
a470 1
	snprintf(cp->obuf, sizeof(cp->obuf),
d490 5
d521 1
a521 1
			snprintf(cp->obuf, sizeof cp->obuf,
d542 1
a542 1
			snprintf(cp->obuf, sizeof cp->obuf,
d544 1
a544 1
			    "Your time will be spent, amounting to nothing.\n");
d563 1
a563 1
			snprintf(cp->obuf, sizeof cp->obuf,
d636 13
d661 1
d674 1
d676 1
a676 1
	int ch, s, s2, i, omax = 0;
d723 6
d742 8
d752 1
d759 9
d788 3
d799 1
a799 1
		int max = s, i, n;
d801 2
d851 7
d894 14
@


1.9
log
@revoke privs a bit later so spamd can bind() to ports < 1024

inspired by Nick Stott <nick at electric-pickle.net>
ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.8 2003/01/24 23:39:28 deraadt Exp $	*/
d442 1
a442 1
			memset(fdsr, howmany(max+1, NFDBITS),
d444 1
a444 1
			memset(fdsw, howmany(max+1, NFDBITS),
@


1.8
log
@plug potential memory leak; vincent ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.7 2003/01/05 23:10:16 deraadt Exp $	*/
a329 17
	pw = getpwnam("_spamd");
	if (!pw)
		pw = getpwnam("nobody");

	if (chroot("/var/empty") == -1 || chdir("/") == -1) {
		syslog(LOG_ERR, "cannot chdir to /var/empty.");
		exit(1);
	}

	if (pw) {
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
	}

d390 17
@


1.7
log
@bit more error checking; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.6 2002/12/30 22:05:57 mickey Exp $	*/
d320 1
d323 1
a323 1
	int ch, s, s2, i;
a417 1
		fd_set *fdsr = NULL, *fdsw = NULL;
d419 1
a419 1
		int max = s, i, n, omax = 0;
@


1.6
log
@dynamically allocate the struct con[], according to the -c arg given or a default, being the max 200
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.5 2002/12/26 01:12:24 mickey Exp $	*/
d31 1
d34 1
d332 2
a333 1
	if (chroot("/var/empty") == -1) {
a336 1
	chdir("/");
d396 1
a396 1
	    sizeof(one))  == -1)
d407 2
a408 1
	listen(s, 10);
d410 4
a413 3
	if (debug == 0)
		daemon(1, 1);
	else
@


1.5
log
@fix a more or less problem; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.4 2002/12/23 04:04:24 deraadt Exp $	*/
d79 1
a79 1
} con[MAXCON];
a346 3
	for (i = 0; i < MAXCON; i++)
		con[i].fd = -1;

d379 7
@


1.4
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.3 2002/12/23 01:09:22 deraadt Exp $	*/
d443 1
a443 1
				if (con[i].r + MAXTIME > t) {
d450 1
a450 1
				if (con[i].w + MAXTIME > t) {
@


1.3
log
@not errx; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.2 2002/12/21 18:19:33 deraadt Exp $	*/
d344 1
a344 1
	if (gethostname(hostname, sizeof hostname) == 1)
@


1.2
log
@epipe and other misc stuff; daniel@@benzedrine.cx
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd.c,v 1.1 2002/12/21 01:41:54 deraadt Exp $	*/
d54 2
a55 1
int debug = 0;
d67 1
a67 1
	int r;
d175 1
a175 1
		cp->r = 1;
d196 1
a196 1
		cp->r = 1;
d217 1
a217 1
		cp->r = 1;
d238 1
a238 1
		cp->r = 1;
d344 2
a345 1
	gethostname(hostname, sizeof hostname);
d387 1
a387 1
		errx(1, "socket");
d399 1
a399 1
		errx(1, "bind");
d427 1
a427 1
				errx(1, "calloc");
d431 1
a431 1
				errx(1, "calloc");
d442 5
a446 1
			if (con[i].fd != -1 && con[i].r)
d448 1
d450 4
d471 1
a471 1
			errx(1, "select");
d487 1
a487 1
				errx(1, "accept");
@


1.1
log
@spamd: work in progress
@
text
@d1 1
a1 1
/*	$OpenBSD: comsat.c,v 1.26 2002/09/06 19:43:54 deraadt Exp $	*/
d54 1
d68 1
d140 1
d145 14
d251 1
a251 3
		close(cp->fd);
		clients--;
		cp->fd = -1;
d268 1
a268 3
			close(cp->fd);
			clients--;
			cp->fd = -1;
d270 3
a272 1
			/* XXX */
d297 1
a297 3
			close(cp->fd);
			clients--;
			cp->fd = -1;
d299 3
a301 1
			/* XXX */
a321 1
	int debug = 0;
d403 2
@

