head	1.64;
access;
symbols
	OPENBSD_5_2:1.63.0.12
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.10
	OPENBSD_5_0:1.63.0.8
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.63.0.6
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.63.0.4
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.62.0.8
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.4
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.59.0.2
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2012.08.16.04.17.11;	author dlg;	state dead;
branches;
next	1.63;

1.63
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.24.16.11.00;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.15.16.25.00;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.13.01.49.52;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.29.11.38.46;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.27.14.44.48;	author chl;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.26.18.39.06;	author jolan;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.04.18.31.03;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.02.20.13.17;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.15.05.52.06;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2006.12.09.00.47.01;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.28.15.14.04;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2006.07.26.16.43.31;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.26.12.34.41;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.26.09.10.03;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.21.21.28.47;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.20.09.42.44;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.14.22.57.46;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.14.22.48.13;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.16.22.40.35;	author beck;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.25.16.14.27;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.17.08.42.05;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.23.17.29.22;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.10.10.22.32;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.05.23.15.19;	author cloder;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.04.09.40.44;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.22.10.52.17;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.18.06.38.02;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.28.15.18.57;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.17.19.45.44;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.27.02.25.30;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.24.20.40.19;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.25.21.11.25;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.04.10.08.51;	author mpech;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.02.01.27.16;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.13.07.44.48;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.01.06.05.22;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.17.09.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.31.14.32.15;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.11.15.18.53;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.09.18.06.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.08.02.23.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.17.19.24.49;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.01.03.23.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.06.23.17.01.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.10.08.06.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.04.08.45.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.06.07.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.29.02.11.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.20.36.37;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.06.11.21.19.47;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.23.49.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.22.03.41.22;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.12.03.00.25.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.12.08.29.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.23.22.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.64
log
@send inetd tftpd to the attic.
@
text
@/*	$OpenBSD: tftpd.c,v 1.63 2009/10/27 23:59:32 deraadt Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Trivial file transfer protocol server.
 *
 * This version includes many modifications by Jim Guyton <guyton@@rand-unix>
 */

#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/tftp.h>
#include <netdb.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <vis.h>

#define TIMEOUT		5		/* packet rexmt timeout */
#define TIMEOUT_MIN	1		/* minimal packet rexmt timeout */
#define TIMEOUT_MAX	255		/* maximal packet rexmt timeout */

struct formats;

int		readit(FILE *, struct tftphdr **, int, int);
void		read_ahead(FILE *, int, int);
int		writeit(FILE *, struct tftphdr **, int, int);
int		write_behind(FILE *, int);
int		synchnet(int);

__dead void	usage(void);
void		tftp(struct tftphdr *, int);
int		validate_access(char *, int);
int		sendfile(struct formats *);
int		recvfile(struct formats *);
void		nak(int);
void		oack(int);
static char	*getip(struct sockaddr *);

FILE			 *file;
extern char		 *__progname;
struct sockaddr_storage	  s_in;
int			  peer;
int			  rexmtval = TIMEOUT;
int			  maxtimeout = 5 * TIMEOUT;
char			 *buf;
char			 *ackbuf;
struct sockaddr_storage	  from;
int			  ndirs;
char 			**dirs;
int			  secure;
int			  cancreate;
int			  logging;
unsigned int		  segment_size = SEGSIZE;
unsigned int		  packet_size = SEGSIZE + 4;
int			  has_options = 0;

struct formats {
	const char	*f_mode;
	int		 (*f_validate)(char *, int);
	int		 (*f_send)(struct formats *);
	int		 (*f_recv)(struct formats *);
	int		 f_convert;
} formats[] = {
	{ "netascii",	validate_access,	sendfile,	recvfile, 1 },
	{ "octet",	validate_access,	sendfile,	recvfile, 0 },
	{ NULL,		NULL,			NULL,		NULL,	  0 }
};

struct options {
	const char	*o_type;
	char		*o_request;
	long long	 o_reply;	/* turn into union if need be */
} options[] = {
	{ "tsize",	NULL, 0 },	/* OPT_TSIZE */
	{ "timeout",	NULL, 0 },	/* OPT_TIMEOUT */
	{ "blksize",	NULL, 0 },	/* OPT_BLKSIZE */
	{ NULL,		NULL, 0 }
};

enum opt_enum {
	OPT_TSIZE = 0,
	OPT_TIMEOUT,
	OPT_BLKSIZE
};

struct errmsg {
	int		 e_code;
	const char	*e_msg;
} errmsgs[] = {
	{ EUNDEF,	"Undefined error code" },
	{ ENOTFOUND,	"File not found" },
	{ EACCESS,	"Access violation" },
	{ ENOSPACE,	"Disk full or allocation exceeded" },
	{ EBADOP,	"Illegal TFTP operation" },
	{ EBADID,	"Unknown transfer ID" },
	{ EEXISTS,	"File already exists" },
	{ ENOUSER,	"No such user" },
	{ EOPTNEG,	"Option negotiation failed" },
	{ -1,		NULL }
};

__dead void
usage(void)
{
	syslog(LOG_ERR, "usage: %s [-cl] [directory ...]", __progname);
	syslog(LOG_ERR, "usage: %s [-cl] -s directory", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int		 n = 0, on = 1, fd = 0, i, c, dobind = 1;
	struct tftphdr	*tp;
	struct passwd	*pw;
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(struct sockaddr_storage))];
	} cmsgbuf;
	struct cmsghdr	*cmsg;
	struct msghdr	 msg;
	struct iovec	 iov;
	pid_t		 pid = 0;
	socklen_t	 j;

	openlog(__progname, LOG_PID|LOG_NDELAY, LOG_DAEMON);

	while ((c = getopt(argc, argv, "cls")) != -1) {
		switch (c) {
		case 'c':
			cancreate = 1;
			break;
		case 'l':
			logging = 1;
			break;
		case 's':
			secure = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	for (; optind != argc; optind++) {
		char **d;

		d = realloc(dirs, (ndirs + 2) * sizeof(char *));
		if (d == NULL) {
			syslog(LOG_ERR, "realloc: %m");
			exit(1);
		}
		dirs = d;
		dirs[n++] = argv[optind];
		dirs[n] = NULL;
		ndirs++;
	}

	pw = getpwnam("_tftpd");
	if (pw == NULL) {
		syslog(LOG_ERR, "no _tftpd: %m");
		exit(1);
	}

	if (secure) {
		if (ndirs == 0) {
			syslog(LOG_ERR, "no -s directory");
			exit(1);
		}
		if (ndirs > 1) {
			syslog(LOG_ERR, "too many -s directories");
			exit(1);
		}
		tzset();
		if (chroot(dirs[0])) {
			syslog(LOG_ERR, "chroot %s: %m", dirs[0]);
			exit(1);
		}
		if (chdir("/")) {
			syslog(LOG_ERR, "chdir: %m");
			exit(1);
		}
	}

	setegid(pw->pw_gid);
	setgid(pw->pw_gid);
	seteuid(pw->pw_uid);
	setuid(pw->pw_uid);

	if (ioctl(fd, FIONBIO, &on) < 0) {
		syslog(LOG_ERR, "ioctl(FIONBIO): %m");
		exit(1);
	}

	j = sizeof(s_in);
	if (getsockname(fd, (struct sockaddr *)&s_in, &j) == -1) {
		syslog(LOG_ERR, "getsockname: %m");
		exit(1);
	}

	switch (s_in.ss_family) {
	case AF_INET:
		if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &on,
		    sizeof(on)) == -1) {
			syslog(LOG_ERR, "setsockopt(IP_RECVDSTADDR): %m");
			exit (1);
		}
		break;
	case AF_INET6:
		if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
		    sizeof(on)) == -1) {
			syslog(LOG_ERR, "setsockopt(IPV6_RECVPKTINFO): %m");
			exit (1);
		}
		break;
	}

	if ((buf = malloc(SEGSIZE_MAX + 4)) == NULL) {
		syslog(LOG_ERR, "malloc: %m");
		exit(1);
	}
	if ((ackbuf = malloc(SEGSIZE_MAX + 4)) == NULL) {
		syslog(LOG_ERR, "malloc: %m");
		exit(1);
	}

	bzero(&msg, sizeof(msg));
	iov.iov_base = buf;
	iov.iov_len = packet_size;
	msg.msg_name = &from;
	msg.msg_namelen = sizeof(from);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	n = recvmsg(fd, &msg, 0);
	if (n < 0) {
		syslog(LOG_ERR, "recvmsg: %m");
		exit(1);
	}

	/*
	 * Now that we have read the message out of the UDP
	 * socket, we fork and exit.  Thus, inetd will go back
	 * to listening to the tftp port, and the next request
	 * to come in will start up a new instance of tftpd.
	 *
	 * We do this so that inetd can run tftpd in "wait" mode.
	 * The problem with tftpd running in "nowait" mode is that
	 * inetd may get one or more successful "selects" on the
	 * tftp port before we do our receive, so more than one
	 * instance of tftpd may be started up.  Worse, if tftpd
	 * breaks before doing the above "recvfrom", inetd would
	 * spawn endless instances, clogging the system.
	 */
	for (i = 1; i < 20; i++) {
		pid = fork();
		if (pid < 0) {
			sleep(i);
			/*
			 * Flush out to most recently sent request.
			 *
			 * This may drop some requests, but those
			 * will be resent by the clients when
			 * they timeout.  The positive effect of
			 * this flush is to (try to) prevent more
			 * than one tftpd being started up to service
			 * a single request from a single client.
			 */
			bzero(&msg, sizeof(msg));
			iov.iov_base = buf;
			iov.iov_len = packet_size;
			msg.msg_name = &from;
			msg.msg_namelen = sizeof(from);
			msg.msg_iov = &iov;
			msg.msg_iovlen = 1;
			msg.msg_control = &cmsgbuf.buf;
			msg.msg_controllen = sizeof(cmsgbuf.buf);

			i = recvmsg(fd, &msg, 0);
			if (i > 0)
				n = i;
		} else
			break;
	}
	if (pid < 0) {
		syslog(LOG_ERR, "fork: %m");
		exit(1);
	} else if (pid != 0)
		exit(0);

	alarm(0);
	close(fd);
	close(1);
	peer = socket(from.ss_family, SOCK_DGRAM, 0);
	if (peer < 0) {
		syslog(LOG_ERR, "socket: %m");
		exit(1);
	}
	memset(&s_in, 0, sizeof(s_in));
	s_in.ss_family = from.ss_family;
	s_in.ss_len = from.ss_len;

	/* get local address if possible */
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == IPPROTO_IP &&
		    cmsg->cmsg_type == IP_RECVDSTADDR) {
			memcpy(&((struct sockaddr_in *)&s_in)->sin_addr,
			    CMSG_DATA(cmsg), sizeof(struct in_addr));
			if (((struct sockaddr_in *)&s_in)->sin_addr.s_addr ==
			    INADDR_BROADCAST)
				dobind = 0;
			break;
		}
		if (cmsg->cmsg_level == IPPROTO_IPV6 &&
		    cmsg->cmsg_type == IPV6_PKTINFO) {
			struct in6_pktinfo *ipi;

			ipi = (struct in6_pktinfo *)CMSG_DATA(cmsg);
			memcpy(&((struct sockaddr_in6 *)&s_in)->sin6_addr,
			    &ipi->ipi6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
			if (IN6_IS_ADDR_LINKLOCAL(&ipi->ipi6_addr))
				((struct sockaddr_in6 *)&s_in)->sin6_scope_id =
				    ipi->ipi6_ifindex;
#endif
			break;
		}
	}

	if (dobind) {
		(void) setsockopt(peer, SOL_SOCKET, SO_REUSEADDR, &on,
		    sizeof(on));
		(void) setsockopt(peer, SOL_SOCKET, SO_REUSEPORT, &on,
		    sizeof(on));

		if (bind(peer, (struct sockaddr *)&s_in, s_in.ss_len) < 0) {
			syslog(LOG_ERR, "bind to %s: %m",
			    inet_ntoa(((struct sockaddr_in *)&s_in)->sin_addr));
			exit(1);
		}
	}
	if (connect(peer, (struct sockaddr *)&from, from.ss_len) < 0) {
		syslog(LOG_ERR, "connect: %m");
		exit(1);
	}
	tp = (struct tftphdr *)buf;
	tp->th_opcode = ntohs(tp->th_opcode);
	if (tp->th_opcode == RRQ || tp->th_opcode == WRQ)
		tftp(tp, n);
	exit(1);
}

/*
 * Handle initial connection protocol.
 */
void
tftp(struct tftphdr *tp, int size)
{
	char		*cp;
	int		 i, first = 1, ecode, opcode, to;
	struct formats	*pf;
	char		*filename, *mode = NULL, *option, *ccp;
	char		 fnbuf[MAXPATHLEN], nicebuf[MAXPATHLEN];
	const char	*errstr;

	cp = tp->th_stuff;
again:
	while (cp < buf + size) {
		if (*cp == '\0')
			break;
		cp++;
	}
	if (*cp != '\0') {
		nak(EBADOP);
		exit(1);
	}
	i = cp - tp->th_stuff;
	if (i >= sizeof(fnbuf)) {
		nak(EBADOP);
		exit(1);
	}
	memcpy(fnbuf, tp->th_stuff, i);
	fnbuf[i] = '\0';
	filename = fnbuf;
	if (first) {
		mode = ++cp;
		first = 0;
		goto again;
	}
	for (cp = mode; *cp; cp++)
		if (isupper(*cp))
			*cp = tolower(*cp);
	for (pf = formats; pf->f_mode; pf++)
		if (strcmp(pf->f_mode, mode) == 0)
			break;
	if (pf->f_mode == 0) {
		nak(EBADOP);
		exit(1);
	}
	while (++cp < buf + size) {
		for (i = 2, ccp = cp; i > 0; ccp++) {
			if (ccp >= buf + size) {
				/*
				 * Don't reject the request, just stop trying
				 * to parse the option and get on with it.
				 * Some Apple OpenFirmware versions have
				 * trailing garbage on the end of otherwise
				 * valid requests.
				 */
				goto option_fail;
			} else if (*ccp == '\0')
				i--;
		}
		for (option = cp; *cp; cp++)
			if (isupper(*cp))
				*cp = tolower(*cp);
		for (i = 0; options[i].o_type != NULL; i++)
			if (strcmp(option, options[i].o_type) == 0) {
				options[i].o_request = ++cp;
				has_options = 1;
			}
		cp = ccp - 1;
	}

option_fail:
	if (options[OPT_TIMEOUT].o_request) {
		to = strtonum(options[OPT_TIMEOUT].o_request,
		    TIMEOUT_MIN, TIMEOUT_MAX, &errstr);
		if (errstr) {
			nak(EBADOP);
			exit(1);
		}
		options[OPT_TIMEOUT].o_reply = rexmtval = to;
	}

	if (options[OPT_BLKSIZE].o_request) {
		segment_size = strtonum(options[OPT_BLKSIZE].o_request,
		    SEGSIZE_MIN, SEGSIZE_MAX, &errstr);
		if (errstr) {
			nak(EBADOP);
			exit(1);
		}
		packet_size = segment_size + 4;
		options[OPT_BLKSIZE].o_reply = segment_size;
	}

	/* save opcode before it gets overwritten by oack() */
	opcode = tp->th_opcode;

	(void)strnvis(nicebuf, filename, MAXPATHLEN, VIS_SAFE|VIS_OCTAL);
	ecode = (*pf->f_validate)(filename, opcode);
	if (logging)
		syslog(LOG_INFO, "%s: %s request for '%s'",
		    getip((struct sockaddr *)&from),
		    opcode == WRQ ? "write" : "read",
		    nicebuf);
	if (has_options)
		oack(opcode);
	if (ecode) {
		syslog(LOG_INFO, "%s: denied %s access to '%s'",
		    getip((struct sockaddr *)&from),
		    opcode == WRQ ? "write" : "read", nicebuf);
		nak(ecode);
		exit(1);
	}
	if (opcode == WRQ)
		(*pf->f_recv)(pf);
	else
		(*pf->f_send)(pf);
	exit(0);
}

/*
 * Validate file access.  Since we
 * have no uid or gid, for now require
 * file to exist and be publicly
 * readable/writable.
 * If we were invoked with arguments
 * from inetd then the file must also be
 * in one of the given directory prefixes.
 * Note also, full path name must be
 * given as we have no login directory.
 */
int
validate_access(char *filename, int mode)
{
	struct stat	 stbuf;
	char		*cp, **dirp;
	int		 fd, wmode;
	const char	*errstr;

	if (!secure) {
		if (*filename != '/')
			return (EACCESS);
		/*
		 * Prevent tricksters from getting around the directory
		 * restrictions.
		 */
		for (cp = filename + 1; *cp; cp++)
			if (*cp == '.' && strncmp(cp - 1, "/../", 4) == 0)
				return (EACCESS);
		for (dirp = dirs; *dirp; dirp++)
			if (strncmp(filename, *dirp, strlen(*dirp)) == 0)
				break;
		if (*dirp == 0 && dirp != dirs)
			return (EACCESS);
	}

	/*
	 * We use a different permissions scheme if `cancreate' is
	 * set.
	 */
	wmode = O_TRUNC;
	if (stat(filename, &stbuf) < 0) {
		if (!cancreate)
			return (errno == ENOENT ? ENOTFOUND : EACCESS);
		else {
			if ((errno == ENOENT) && (mode != RRQ))
				wmode |= O_CREAT;
			else
				return (EACCESS);
		}
	} else {
		if (mode == RRQ) {
			if ((stbuf.st_mode & (S_IREAD >> 6)) == 0)
				return (EACCESS);
		} else {
			if ((stbuf.st_mode & (S_IWRITE >> 6)) == 0)
				return (EACCESS);
		}
	}
	if (options[OPT_TSIZE].o_request) {
		if (mode == RRQ)
			options[OPT_TSIZE].o_reply = stbuf.st_size;
		else {
			/* allows writes of 65535 blocks * SEGSIZE_MAX bytes */
			options[OPT_TSIZE].o_reply =
			    strtonum(options[OPT_TSIZE].o_request,
			    1, 65535LL * SEGSIZE_MAX, &errstr);
			if (errstr) {
				nak(EOPTNEG);
				exit(1);
			}
		}
	}
	fd = open(filename, mode == RRQ ? O_RDONLY : (O_WRONLY|wmode), 0666);
	if (fd < 0)
		return (errno + 100);
	/*
	 * If the file was created, set default permissions.
	 */
	if ((wmode & O_CREAT) && fchmod(fd, 0666) < 0) {
		int serrno = errno;

		close(fd);
		unlink(filename);

		return (serrno + 100);
	}
	file = fdopen(fd, mode == RRQ ? "r" : "w");
	if (file == NULL) {
		close(fd);
		return (errno + 100);
	}
	return (0);
}

/*
 * Send the requested file.
 */
int
sendfile(struct formats *pf)
{
	struct tftphdr		*dp, *r_init(void);
	struct tftphdr		*ap;	/* ack packet */
	struct pollfd		 pfd[1];
	volatile unsigned short	 block = 1;
	int			 n, size, nfds, error, timeouts;

	dp = r_init();
	ap = (struct tftphdr *)ackbuf;

	do {
		/* read data from file */
		size = readit(file, &dp, pf->f_convert, segment_size);
		if (size < 0) {
			nak(errno + 100);
			goto abort;
		}
		dp->th_opcode = htons((u_short)DATA);
		dp->th_block = htons((u_short)block);

		/* send data to client and wait for client ACK */
		for (timeouts = 0, error = 0;;) {
			if (timeouts >= maxtimeout)
				exit(1);

			if (!error) {
				if (send(peer, dp, size + 4, 0) != size + 4) {
					syslog(LOG_ERR, "send: %m");
					goto abort;
				}
				read_ahead(file, pf->f_convert, segment_size);
			}
			error = 0;

			pfd[0].fd = peer;
			pfd[0].events = POLLIN;
			nfds = poll(pfd, 1, rexmtval * 1000);
			if (nfds == 0) {
				timeouts += rexmtval;
				continue;
			}
			if (nfds == -1) {
				error = 1;
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "poll: %m");
				goto abort;
			}
			n = recv(peer, ackbuf, packet_size, 0);
			if (n == -1) {
				error = 1;
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "recv: %m");
				goto abort;
			}
			ap->th_opcode = ntohs((u_short)ap->th_opcode);
			ap->th_block = ntohs((u_short)ap->th_block);

			if (ap->th_opcode == ERROR)
				goto abort;
			if (ap->th_opcode == ACK) {
				if (ap->th_block == block)
					break;
				/* re-synchronize with the other side */
				(void)synchnet(peer);
				if (ap->th_block == (block - 1))
					continue;
			}
			error = 1;	/* FALLTHROUGH */
		}

		block++;
	} while (size == segment_size);

abort:
	fclose(file);
	return (1);
}

/*
 * Receive a file.
 */
int
recvfile(struct formats *pf)
{
	struct tftphdr		*dp, *w_init(void);
	struct tftphdr		*ap;	/* ack buffer */
	struct pollfd		 pfd[1];
	volatile unsigned short	 block = 0;
	int			 n, size, nfds, error, timeouts;

	dp = w_init();
	ap = (struct tftphdr *)ackbuf;

	/* if we have options, do not send a first ACK */
	if (has_options) {
		block++;
		goto noack;
	}

	do {
		/* create new ACK packet */
		ap->th_opcode = htons((u_short)ACK);
		ap->th_block = htons((u_short)block);
		block++;

		/* send ACK to client and wait for client data */
		for (timeouts = 0, error = 0;;) {
			if (timeouts >= maxtimeout)
				exit(1);

			if (!error) {
				if (send(peer, ackbuf, 4, 0) != 4) {
					syslog(LOG_ERR, "send: %m");
					goto abort;
				}
				write_behind(file, pf->f_convert);
			}
			error = 0;

			pfd[0].fd = peer;
			pfd[0].events = POLLIN;
			nfds = poll(pfd, 1, rexmtval * 1000);
			if (nfds == 0) {
				timeouts += rexmtval;
				continue;
			}
			if (nfds == -1) {
				error = 1;
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "poll: %m");
				goto abort;
			}
noack:
			n = recv(peer, dp, packet_size, 0);
			if (n == -1) {
				error = 1;
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "recv: %m");
				goto abort;
			}
			dp->th_opcode = ntohs((u_short)dp->th_opcode);
			dp->th_block = ntohs((u_short)dp->th_block);

			if (dp->th_opcode == ERROR)
				goto abort;
			if (dp->th_opcode == DATA) {
				if (dp->th_block == block)
					break;
				/* re-synchronize with the other side */
				(void)synchnet(peer);
				if (dp->th_block == (block - 1))
					continue;
			}
			error = 1;	/* FALLTHROUGH */
		}

		/* write data to file */
		size = writeit(file, &dp, n - 4, pf->f_convert);
		if (size != (n - 4)) {
			if (size < 0)
				nak(errno + 100);
			else
				nak(ENOSPACE);
			goto abort;
		}
	} while (size == segment_size);

	/* close data file */
	write_behind(file, pf->f_convert);
	(void)fclose(file);

	/* send final ack */
	ap->th_opcode = htons((u_short)ACK);
	ap->th_block = htons((u_short)(block));
	(void)send(peer, ackbuf, 4, 0);

	/* just quit on timeout */
	pfd[0].fd = peer;
	pfd[0].events = POLLIN;
	nfds = poll(pfd, 1, rexmtval * 1000);
	if (nfds < 1)
		exit(1);
	n = recv(peer, buf, packet_size, 0);
	/*
	 * If read some data and got a data block then my last ack was lost
	 * resend final ack.
	 */
	if (n >= 4 && dp->th_opcode == DATA && block == dp->th_block)
		(void)send(peer, ackbuf, 4, 0);

abort:
	return (1);
}

/*
 * Send a nak packet (error message).
 * Error code passed in is one of the
 * standard TFTP codes, or a UNIX errno
 * offset by 100.
 */
void
nak(int error)
{
	struct tftphdr	*tp;
	struct errmsg	*pe;
	int		 length;

	tp = (struct tftphdr *)buf;
	tp->th_opcode = htons((u_short)ERROR);
	tp->th_code = htons((u_short)error);
	for (pe = errmsgs; pe->e_code >= 0; pe++)
		if (pe->e_code == error)
			break;
	if (pe->e_code < 0) {
		pe->e_msg = strerror(error - 100);
		tp->th_code = EUNDEF;   /* set 'undef' errorcode */
	}
	length = strlcpy(tp->th_msg, pe->e_msg, packet_size) + 5;
	if (length > packet_size)
		length = packet_size;
	if (send(peer, buf, length, 0) != length)
		syslog(LOG_ERR, "nak: %m");
}

/*
 * Send an oack packet (option acknowledgement).
 */
void
oack(int opcode)
{
	struct tftphdr	*tp, *ap;
	struct pollfd	 pfd[1];
	char		*bp;
	int		 i, n, size, nfds, error, timeouts;

	tp = (struct tftphdr *)buf;
	bp = buf + 2;
	size = packet_size - 2;
	tp->th_opcode = htons((u_short)OACK);
	for (i = 0; options[i].o_type != NULL; i++) {
		if (options[i].o_request) {
			n = snprintf(bp, size, "%s%c%lld", options[i].o_type,
			    0, options[i].o_reply);
			if (n == -1 || n >= size) {
				syslog(LOG_ERR, "oack: no buffer space");
				exit(1);
			}
			bp += n + 1;
			size -= n + 1;
			if (size < 0) {
				syslog(LOG_ERR, "oack: no buffer space");
				exit(1);
			}
		}
	}
	size = bp - buf;
	ap = (struct tftphdr *)ackbuf;

	/* send OACK to client and wait for client ACK */
	for (timeouts = 0, error = 0;;) {
		if (timeouts >= maxtimeout)
			exit(1);

		if (!error) {
			if (send(peer, buf, size, 0) != size) {
				syslog(LOG_INFO, "oack: %m");
				exit(1);
			}
		}
		error = 0;

		pfd[0].fd = peer;
		pfd[0].events = POLLIN;
		nfds = poll(pfd, 1, rexmtval * 1000);
		if (nfds == 0) {
			timeouts += rexmtval;
			continue;
		}
		if (nfds == -1) {
			error = 1;
			if (errno == EINTR)
				continue;
			syslog(LOG_ERR, "poll: %m");
			exit(1);
		}

		/* no client ACK for write requests with options */
		if (opcode == WRQ)
			break;

		n = recv(peer, ackbuf, packet_size, 0);
		if (n == -1) {
			error = 1;
			if (errno == EINTR)
				continue;
			syslog(LOG_ERR, "recv: %m");
			exit(1);
		}
		ap->th_opcode = ntohs((u_short)ap->th_opcode);
		ap->th_block = ntohs((u_short)ap->th_block);

		if (ap->th_opcode == ERROR)
			exit(1);
		if (ap->th_opcode == ACK && ap->th_block == 0)
			break;
		error = 1;	/* FALLTHROUGH */
	}
}

static char *
getip(struct sockaddr *sa)
{
	static char hbuf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST))
		strlcpy(hbuf, "0.0.0.0", sizeof(hbuf));
	return(hbuf);
}
@


1.63
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.62 2008/03/24 16:11:00 deraadt Exp $	*/
@


1.62
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.61 2008/03/15 16:25:00 deraadt Exp $	*/
a30 11

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)tftpd.c	5.13 (Berkeley) 2/26/91";*/
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.61 2008/03/15 16:25:00 deraadt Exp $";
#endif /* not lint */
@


1.61
log
@Repair more msg_controllen dealing with structures or arrays of
descriptors; ok hshoexer, also looked at by kettenis and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.60 2008/03/13 01:49:52 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.60 2008/03/13 01:49:52 deraadt Exp $";
d289 1
a289 1
	msg.msg_controllen = CMSG_LEN(sizeof(struct sockaddr_storage));
d333 1
a333 1
			msg.msg_controllen = CMSG_LEN(sizeof(struct sockaddr_storage));
@


1.60
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.59 2007/11/29 11:38:46 jmc Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.59 2007/11/29 11:38:46 jmc Exp $";
d289 1
a289 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
d333 1
a333 1
			msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.59
log
@- get synopsis/usage() right
- improve options text

no one objected...
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.58 2007/11/27 14:44:48 chl Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.58 2007/11/27 14:44:48 chl Exp $";
d170 4
a173 1
	char		 cbuf[CMSG_SPACE(sizeof(struct sockaddr_storage))];
d288 2
a289 2
	msg.msg_control = cbuf;
	msg.msg_controllen = CMSG_LEN(sizeof(struct sockaddr_storage));
d332 2
a333 3
			msg.msg_control = cbuf;
			msg.msg_controllen =
			    CMSG_LEN(sizeof(struct sockaddr_storage));
@


1.58
log
@add missing header for inet_ntoa.

"sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.57 2007/11/26 18:39:06 jolan Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.57 2007/11/26 18:39:06 jolan Exp $";
d159 2
a160 1
	syslog(LOG_ERR, "usage: %s [-cls] [directory ...]", __progname);
@


1.57
log
@add logging option, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.56 2007/04/04 18:31:03 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.56 2007/04/04 18:31:03 deraadt Exp $";
d56 1
@


1.56
log
@only do the SO_REUSEADDR/SO_REUSEPORT if we are going to bind; pointed out by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.55 2007/04/02 20:13:17 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.55 2007/04/02 20:13:17 deraadt Exp $";
d90 1
d105 1
d158 1
a158 1
	syslog(LOG_ERR, "usage: %s [-cs] [directory ...]", __progname);
d177 1
a177 1
	while ((c = getopt(argc, argv, "cs")) != -1) {
d182 3
d505 5
d513 2
a514 1
		syslog(LOG_INFO, "denied %s access to '%s'",
d519 1
a519 2
	if (opcode == WRQ) {
		syslog(LOG_DEBUG, "receiving file '%s'", nicebuf);
d521 1
a521 2
	} else {
		syslog(LOG_DEBUG, "sending file '%s'", nicebuf);
a522 1
	}
d937 10
@


1.55
log
@be more forgiving about tftp requests that come from the 255.255.255.255,
as is of particular concern with the sun v215; tested by kettenis, no
regressions spotted by pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.54 2006/12/15 05:52:06 itojun Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.54 2006/12/15 05:52:06 itojun Exp $";
d378 11
a388 9
	(void) setsockopt(peer, SOL_SOCKET, SO_REUSEADDR, &on,
	    sizeof(on));
	(void) setsockopt(peer, SOL_SOCKET, SO_REUSEPORT, &on,
	    sizeof(on));

	if (dobind && bind(peer, (struct sockaddr *)&s_in, s_in.ss_len) < 0) {
		syslog(LOG_ERR, "bind to %s: %m",
		    inet_ntoa(((struct sockaddr_in *)&s_in)->sin_addr));
		exit(1);
@


1.54
log
@reduce RFC2292/3542 #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.53 2006/12/09 00:47:01 itojun Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.53 2006/12/09 00:47:01 itojun Exp $";
d163 1
a163 1
	int		 n = 0, on = 1, fd = 0, i, c;
d357 3
d378 8
a385 2
	if (bind(peer, (struct sockaddr *)&s_in, s_in.ss_len) < 0) {
		syslog(LOG_ERR, "bind: %m");
@


1.53
log
@IPV6_RECVDSTADDR is not standard.  use more standard IPV6_PKTINFO.
also prepare for RFC2292->RFC3542 switch (IPV6_RECVPKTINFO).
glocker ok (he tested), deraadt also looked at
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.52 2006/07/28 15:14:04 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.52 2006/07/28 15:14:04 mglocker Exp $";
a253 1
#ifdef IPV6_RECVPKTINFO
a258 7
#else
		if (setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO, &on,
		    sizeof(on)) == -1) {
			syslog(LOG_ERR, "setsockopt(IPV6_PKTINFO): %m");
			exit (1);
		}
#endif
@


1.52
log
@Make tftpd atoi() free.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.51 2006/07/26 16:43:31 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.51 2006/07/26 16:43:31 deraadt Exp $";
d254 2
a255 1
		if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTADDR, &on,
d257 1
a257 1
			syslog(LOG_ERR, "setsockopt(IPV6_RECVDSTADDR): %m");
d260 7
d368 4
a371 1
		    cmsg->cmsg_type == IPV6_RECVDSTADDR) {
d373 6
a378 1
			    CMSG_DATA(cmsg), sizeof(struct in6_addr));
@


1.51
log
@TIMEOUT* values are not part of the protocol.  tftp.h is a namespace
export of the protocol.  you shall not add non-protocol stuff to such
a file, period.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.50 2006/07/26 12:34:41 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.50 2006/07/26 12:34:41 mglocker Exp $";
d123 1
a123 1
	int		 o_reply;	/* turn into union if need be */
d516 1
d561 2
a562 2
		else
			/* XXX allows writes of all sizes */
d564 7
a570 1
			    atoi(options[OPT_TSIZE].o_request);
d844 1
a844 1
			n = snprintf(bp, size, "%s%c%d", options[i].o_type,
@


1.50
log
@Mini KNF.  No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.49 2006/07/26 09:10:03 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.49 2006/07/26 09:10:03 mglocker Exp $";
d70 4
@


1.49
log
@Fixing several timeout quirks at tftpd and tftp:

- move TIMEOUT* defines to arpa/tftp.h, as they are used several times
  in tftpd and tftp, and the values are part of the RFC definition.
- tftpd and tftp did count the total retransmission time in retries
  instead in seconds.  fixed.
- tftpd rexmt timeout was hardcoded by a define and therefore didn't
  changed when the timeout option was sent.  fixed.
- limit total retransmission timeout in tftp to also 255 seconds.
- replace obvious atoi()'s by strtonum().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.48 2006/07/21 21:28:47 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.48 2006/07/21 21:28:47 mglocker Exp $";
d385 1
a385 1
	int		 i, first = 1, ecode, opcode;
d452 1
a452 1
		int to = strtonum(options[OPT_TIMEOUT].o_request,
@


1.48
log
@- fix protocol for write requests (put) which come with options.
- revert realloc() by fix malloc() because the code relies on a fix packet
  buffer address.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.47 2006/07/20 09:42:44 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.47 2006/07/20 09:42:44 mglocker Exp $";
a70 3
#define	TIMEOUT		5
#define	MAX_TIMEOUTS	5

d92 1
a92 1
int			  max_rexmtval = 2 * TIMEOUT;
d452 3
a454 2
		int to = atoi(options[OPT_TIMEOUT].o_request);
		if (to < 1 || to > 255) {
d457 2
a458 4
		} else if (to <= max_rexmtval)
			options[OPT_TIMEOUT].o_reply = rexmtval = to;
		else
			options[OPT_TIMEOUT].o_request = NULL;
d610 1
a610 1
			if (timeouts == MAX_TIMEOUTS)
d624 1
a624 1
			nfds = poll(pfd, 1, TIMEOUT * 1000);
d626 1
a626 1
				timeouts++;
d697 1
a697 1
			if (timeouts == MAX_TIMEOUTS)
d711 1
a711 1
			nfds = poll(pfd, 1, TIMEOUT * 1000);
d713 1
a713 1
				timeouts++;
d771 1
a771 1
	nfds = poll(pfd, 1, TIMEOUT * 1000);
d852 1
a852 1
		if (timeouts == MAX_TIMEOUTS)
d865 1
a865 1
		nfds = poll(pfd, 1, TIMEOUT * 1000);
d867 1
a867 1
			timeouts++;
@


1.47
log
@Add blksize option support for tftpd according to RFC 2348.

Note:
While testing the new option, we noticed that our stable tftpd has
a problem if any option is set (e.g. tsize) and you try to put a file.
This has nothing todo with our new blksize option.  We fix this as
next.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.46 2006/07/14 22:57:46 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.46 2006/07/14 22:57:46 mglocker Exp $";
d88 1
a88 1
void		oack(void);
d105 1
d261 1
a261 1
	if ((buf = malloc(packet_size)) == NULL) {
d265 1
a265 1
	if ((ackbuf = malloc(packet_size)) == NULL) {
d388 1
a388 1
	int		 i, first = 1, has_options = 0, ecode;
d390 1
a390 1
	char		*filename, *mode = NULL, *option, *ccp, *newp = NULL;
a472 10
		if ((newp = realloc(buf, packet_size)) == NULL) {
			syslog(LOG_ERR, "realloc: %m");
			exit(1);
		}
		buf = newp;
		if ((newp = realloc(ackbuf, packet_size)) == NULL) {
			syslog(LOG_ERR, "realloc: %m");
			exit(1);
		}
		ackbuf = newp;
d476 3
d480 1
a480 1
	ecode = (*pf->f_validate)(filename, tp->th_opcode);
d482 1
a482 1
		oack();
d485 1
a485 1
		    tp->th_opcode == WRQ ? "write" : "read", nicebuf);
d489 1
a489 1
	if (tp->th_opcode == WRQ) {
d687 6
d727 1
d824 1
a824 1
oack(void)
d881 5
@


1.46
log
@Fix some syslog(3) messages.  Prototype usage() by __dead void.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.45 2006/07/14 22:48:13 mglocker Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.45 2006/07/14 22:48:13 mglocker Exp $";
a72 1
#define	PKTSIZE		SEGSIZE + 4
d76 2
a77 2
int		readit(FILE *, struct tftphdr **, int);
void		read_ahead(FILE *, int);
d96 2
a97 2
char			  buf[PKTSIZE];
char			  ackbuf[PKTSIZE];
d103 2
d125 1
d131 2
a132 1
	OPT_TIMEOUT
d260 9
d271 1
a271 1
	iov.iov_len = sizeof(buf);
d315 1
a315 1
			iov.iov_len = sizeof(buf);
d389 1
a389 1
	char		*filename, *mode = NULL, *option, *ccp;
d391 1
d464 21
d610 1
a610 1
		size = readit(file, &dp, pf->f_convert);
d628 1
a628 1
				read_ahead(file, pf->f_convert);
d646 1
a646 1
			n = recv(peer, ackbuf, sizeof(ackbuf), 0);
d671 1
a671 1
	} while (size == SEGSIZE);
d727 1
a727 1
			n = recv(peer, dp, PKTSIZE, 0);
d760 1
a760 1
	} while (size == SEGSIZE);
d777 1
a777 1
	n = recv(peer, buf, sizeof(buf), 0);
d812 3
a814 3
	length = strlcpy(tp->th_msg, pe->e_msg, sizeof(buf)) + 5;
	if (length > sizeof(buf))
		length = sizeof(buf);
d832 1
a832 1
	size = sizeof(buf) - 2;
d880 1
a880 1
		n = recv(peer, ackbuf, sizeof(ackbuf), 0);
@


1.45
log
@knf.  no binary change.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.44 2006/06/16 22:40:35 beck Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.44 2006/06/16 22:40:35 beck Exp $";
d83 1
a83 1
static void	usage(void);
d148 1
a148 1
static void
d151 1
a151 1
	syslog(LOG_ERR, "Usage: %s [-cs] [directory ...]", __progname);
d189 1
a189 1
			syslog(LOG_ERR, "malloc: %m");
d591 1
a591 1
					syslog(LOG_ERR, "tftpd: send: %m");
d609 1
a609 1
				syslog(LOG_ERR, "tftpd: poll: %m");
d617 1
a617 1
				syslog(LOG_ERR, "tftpd: recv: %m");
d672 1
a672 1
					syslog(LOG_ERR, "tftpd: send: %m");
d690 1
a690 1
				syslog(LOG_ERR, "tftpd: poll: %m");
d698 1
a698 1
				syslog(LOG_ERR, "tftpd: recv: %m");
@


1.44
log
@From Markus Glockner <markus@@nazgul.ch>, adds logging of refusals
and debug level logging of transfers to tftpd. all the work done by
markus, I only tested and nitpicked.
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.43 2006/04/25 16:14:27 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.43 2006/04/25 16:14:27 deraadt Exp $";
d49 1
d51 1
a51 1
#include <sys/ioctl.h>
a53 3
#include <unistd.h>
#include <fcntl.h>
#include <vis.h>
a54 1
#include <sys/socket.h>
d59 3
d63 1
a63 1
#include <syslog.h>
d65 1
a65 2
#include <errno.h>
#include <ctype.h>
d67 3
a69 2
#include <stdlib.h>
#include <pwd.h>
d73 1
d75 1
a75 21
extern	char *__progname;
struct	sockaddr_storage s_in;
int	peer;
int	rexmtval = TIMEOUT;
int	max_rexmtval = 2*TIMEOUT;

#define	PKTSIZE	SEGSIZE+4
char	buf[PKTSIZE];
char	ackbuf[PKTSIZE];
struct	sockaddr_storage from;

int	ndirs;
char	**dirs;

int	secure;
int	cancreate;

struct	formats;
int	validate_access(char *filename, int mode);
int	recvfile(struct formats *pf);
int	sendfile(struct formats *pf);
d77 27
a103 1
FILE *file;
d107 4
a110 4
	int	(*f_validate)(char *, int);
	int	(*f_send)(struct formats *);
	int	(*f_recv)(struct formats *);
	int	f_convert;
d116 1
d120 1
a120 1
	int		o_reply;	/* turn into union if need be */
d126 1
d133 1
a133 1
	int	e_code;
a147 11
int	validate_access(char *filename, int mode);
void	tftp(struct tftphdr *tp, int size);
void	nak(int error);
void	oack(void);

int	readit(FILE *file, struct tftphdr **dpp, int convert);
void	read_ahead(FILE *file, int convert);
int	writeit(FILE *file, struct tftphdr **dpp, int ct, int convert);
int	write_behind(FILE *file, int convert);
int	synchnet(int f);

d158 9
a166 9
	int n = 0, on = 1, fd = 0, i, c;
	struct tftphdr *tp;
	struct passwd *pw;
	char cbuf[CMSG_SPACE(sizeof(struct sockaddr_storage))];
	struct cmsghdr *cmsg;
	struct msghdr msg;
	struct iovec iov;
	pid_t pid = 0;
	socklen_t j;
d168 1
a168 1
	openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
d170 1
a170 1
	while ((c = getopt(argc, argv, "cs")) != -1)
d180 1
a180 1
			break;
d182 1
d187 1
a187 1
		d = realloc(dirs, (ndirs+2) * sizeof (char *));
d199 1
a199 1
	if (!pw) {
d292 1
a292 1
			 * flush out to most recently sent request.
d313 1
a313 1
			if (i > 0) {
a314 1
			}
d374 5
a378 5
	char *cp;
	int i, first = 1, has_options = 0, ecode;
	struct formats *pf;
	char *filename, *mode = NULL, *option, *ccp;
	char fnbuf[MAXPATHLEN], nicebuf[MAXPATHLEN];
d436 1
a436 1
		cp = ccp-1;
d451 1
a451 1
	(void) strnvis(nicebuf, filename, MAXPATHLEN, VIS_SAFE|VIS_OCTAL);
d485 3
a487 3
	struct stat stbuf;
	char *cp, **dirp;
	int fd, wmode;
d493 2
a494 2
		 * prevent tricksters from getting around the directory
		 * restrictions
d497 2
a498 2
			if (*cp == '.' && strncmp(cp-1, "/../", 4) == 0)
				return(EACCESS);
d502 1
a502 1
		if (*dirp==0 && dirp!=dirs)
d518 1
a518 1
				return(EACCESS);
d522 1
a522 1
			if ((stbuf.st_mode&(S_IREAD >> 6)) == 0)
d525 1
a525 1
			if ((stbuf.st_mode&(S_IWRITE >> 6)) == 0)
d533 1
a533 1
			/* XXX Allows writes of all sizes. */
d535 1
a535 1
				atoi(options[OPT_TSIZE].o_request);
d551 1
a551 1
	file = fdopen(fd, (mode == RRQ)? "r":"w");
d565 5
a569 5
	struct tftphdr *dp, *r_init(void);
	struct tftphdr *ap;	/* ack packet */
	struct pollfd pfd[1];
	volatile unsigned short block = 1;
	int n, size, nfds, error, timeouts;
d629 1
a629 1
				(void) synchnet(peer);
d650 5
a654 5
	struct tftphdr *dp, *w_init(void);
	struct tftphdr *ap;	/* ack buffer */
	struct pollfd pfd[1];
	volatile unsigned short block = 0;
	int n, size, nfds, error, timeouts;
d710 1
a710 1
				(void) synchnet(peer);
d730 1
a730 1
	(void) fclose(file);
d735 1
a735 1
	(void) send(peer, ackbuf, 4, 0);
d745 2
a746 2
	 * if read some data and got a data block then my last ack was lost
	 * resend final ack
d749 1
a749 1
		(void) send(peer, ackbuf, 4, 0);
d764 3
a766 3
	struct tftphdr *tp;
	struct errmsg *pe;
	int length;
d791 4
a794 4
	struct tftphdr *tp, *ap;
	struct pollfd pfd[1];
	char *bp;
	int i, n, size, nfds, error, timeouts;
@


1.43
log
@kill setjmp() and alarm() methods, which are almost always inverted signal
races.  use poll() instead.  by marcus@@nazgul.ch
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.42 2006/04/17 08:42:05 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.42 2006/04/17 08:42:05 deraadt Exp $";
d55 1
d380 1
a380 1
	char fnbuf[MAXPATHLEN];
d453 1
d458 2
d463 2
a464 1
	if (tp->th_opcode == WRQ)
d466 2
a467 1
	else
d469 1
@


1.42
log
@spaces.
can someone please rewrite this to not use setjmp(), but instead a
poll() loop?  please & thank you
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.41 2006/01/23 17:29:22 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.41 2006/01/23 17:29:22 millert Exp $";
a52 1
#include <signal.h>
a53 1
#include <stdlib.h>
d61 1
a61 1
#include <setjmp.h>
d95 2
d122 16
a465 3

FILE *file;

a553 13
int	timeouts;
jmp_buf	timeoutbuf;

/* ARGSUSED */
static void
timer(int signo)
{
	/* XXX longjmp/signal resource leaks */
	if (++timeouts >= MAX_TIMEOUTS)
		_exit(1);
	longjmp(timeoutbuf, 1);
}

d561 2
a562 1
	struct tftphdr *ap;    /* ack packet */
d564 1
a564 1
	int size, n;
a565 1
	signal(SIGALRM, timer);
d568 1
d570 1
a577 2
		timeouts = 0;
		setjmp(timeoutbuf);
d579 34
a612 12
send_data:
		if (send(peer, dp, size + 4, 0) != size + 4) {
			syslog(LOG_ERR, "tftpd: write: %m");
			goto abort;
		}
		read_ahead(file, pf->f_convert);
		for ( ; ; ) {
			alarm(rexmtval);	/* read the ack */
			n = recv(peer, ackbuf, sizeof (ackbuf), 0);
			alarm(0);
			if (n < 0) {
				syslog(LOG_ERR, "tftpd: read: %m");
a619 1

d621 1
a621 1
				if (ap->th_block == block) {
d623 1
a623 2
				}
				/* Re-synchronize with the other side */
d625 2
a626 3
				if (ap->th_block == (block -1)) {
					goto send_data;
				}
d628 2
a630 1
		}
d633 1
a638 8
/* ARGSUSED */
static void
justquit(int signo)
{
	_exit(0);
}


d646 2
a647 1
	struct tftphdr *ap;    /* ack buffer */
d649 1
a649 1
	int n, size;
a650 1
	signal(SIGALRM, timer);
d653 1
d655 1
a655 1
		timeouts = 0;
d659 29
a687 9
		setjmp(timeoutbuf);
send_ack:
		if (send(peer, ackbuf, 4, 0) != 4) {
			syslog(LOG_ERR, "tftpd: write: %m");
			goto abort;
		}
		write_behind(file, pf->f_convert);
		for ( ; ; ) {
			alarm(rexmtval);
d689 5
a693 3
			alarm(0);
			if (n < 0) {		/* really? */
				syslog(LOG_ERR, "tftpd: read: %m");
d698 1
d702 3
a704 4
				if (dp->th_block == block) {
					break;   /* normal */
				}
				/* Re-synchronize with the other side */
d706 2
a707 2
				if (dp->th_block == (block-1))
					goto send_ack;		/* rexmit */
d709 1
d711 2
a712 1
		/*  size = write(file, dp->th_data, n - 4); */
d714 1
a714 1
		if (size != (n-4)) {			/* ahem */
d722 2
d725 1
a725 1
	(void) fclose(file);		/* close data file */
d727 2
a728 1
	ap->th_opcode = htons((u_short)ACK);    /* send the "final" ack */
d732 14
a745 9
	signal(SIGALRM, justquit);		/* just quit on timeout */
	alarm(rexmtval);
	n = recv(peer, buf, sizeof (buf), 0); /* normally times out and quits */
	alarm(0);
	if (n >= 4 &&			/* if read some data */
	    dp->th_opcode == DATA &&    /* and got a data block */
	    block == dp->th_block) {	/* then my last ack was lost */
		(void) send(peer, ackbuf, 4, 0);	/* resend final ack */
	}
a749 16
struct errmsg {
	int	e_code;
	const char	*e_msg;
} errmsgs[] = {
	{ EUNDEF,	"Undefined error code" },
	{ ENOTFOUND,	"File not found" },
	{ EACCESS,	"Access violation" },
	{ ENOSPACE,	"Disk full or allocation exceeded" },
	{ EBADOP,	"Illegal TFTP operation" },
	{ EBADID,	"Unknown transfer ID" },
	{ EEXISTS,	"File already exists" },
	{ ENOUSER,	"No such user" },
	{ EOPTNEG,	"Option negotiation failed" },
	{ -1,		NULL }
};

d787 1
a787 1
	int size, i, n;
d789 1
d803 2
a804 2
			bp += n+1;
			size -= n+1;
a812 2
	signal(SIGALRM, timer);
	timeouts = 0;
d814 12
a825 5
	(void)setjmp(timeoutbuf);
	if (send(peer, buf, size, 0) != size) {
		syslog(LOG_INFO, "oack: %m");
		exit(1);
	}
d827 19
a845 5
	for (;;) {
		alarm(rexmtval);
		n = recv(peer, ackbuf, sizeof (ackbuf), 0);
		alarm(0);
		if (n < 0) {
d851 1
d856 1
@


1.41
log
@Include <sys/param.h> instead of <sys/types.h> so we get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.40 2005/03/10 10:22:32 claudio Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.40 2005/03/10 10:22:32 claudio Exp $";
d223 1
a223 1
	
d250 1
a250 1
	
d337 1
a337 1
			
d430 1
a430 2
		}
		else if (to <= max_rexmtval)
d679 2
a680 1
			else nak(ENOSPACE);
@


1.40
log
@Bind to the correct outgoing interface by using the IP_RECVDSTADDR setsockopt.
This is a fix for PR4121.
OK henning@@ "I'm happy with" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.39 2005/03/05 23:15:19 cloder Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.39 2005/03/05 23:15:19 cloder Exp $";
d49 1
a49 1
#include <sys/types.h>
@


1.39
log
@Check snprintf return value for failure.  Also fix a dumb error message.
OK otto, henning, hshoexer, krw.  Some input from Moritz which I have
chosen not to heed because I think the code is easier to read my way.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.38 2005/03/04 09:40:44 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.38 2005/03/04 09:40:44 otto Exp $";
d52 1
a84 1
socklen_t fromlen;
d146 4
d217 35
a251 3
	fromlen = sizeof (from);
	n = recvfrom(fd, buf, sizeof (buf), 0,
	    (struct sockaddr *)&from, &fromlen);
d253 1
a253 1
		syslog(LOG_ERR, "recvfrom: %m");
d256 1
d285 12
a296 3
			j = sizeof from;
			i = recvfrom(fd, buf, sizeof (buf), 0,
			    (struct sockaddr *)&from, &j);
a298 1
				fromlen = j;
d320 18
@


1.38
log
@Typos in comments from Niall O'Higgins <niallo at netsoc dot ucd dot ie>
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.37 2005/02/22 10:52:17 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.37 2005/02/22 10:52:17 otto Exp $";
d705 4
d712 1
a712 1
				syslog(LOG_ERR, "oack: buffer overflow");
@


1.37
log
@get timezone right before chroot() by calling tzset()
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.36 2004/09/18 06:38:02 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.36 2004/09/18 06:38:02 deraadt Exp $";
d231 1
a231 1
	 * break before doing the above "recvfrom", inetd would
d241 1
a241 1
			 * This may drop some request, but those
@


1.36
log
@ARGSUSED on signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.35 2004/08/08 19:32:45 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.35 2004/08/08 19:32:45 deraadt Exp $";
d193 1
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.34 2004/04/28 15:18:57 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.34 2004/04/28 15:18:57 deraadt Exp $";
d481 1
d555 1
@


1.34
log
@fd leaks
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.33 2004/04/17 19:45:44 henning Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.33 2004/04/17 19:45:44 henning Exp $";
d449 1
a449 1
		if (mode == RRQ) 
d625 1
a625 1
	signal(SIGALRM, justquit);      /* just quit on timeout */
d632 1
a632 1
		(void) send(peer, ackbuf, 4, 0);     /* resend final ack */
d701 1
a701 1
				     0, options[i].o_reply);
@


1.33
log
@no no no nobody, _tftpd is better, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.32 2004/01/27 02:25:30 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.32 2004/01/27 02:25:30 deraadt Exp $";
d471 2
a472 1
	if (file == NULL)
d474 1
@


1.32
log
@TSIZE & TIMEOUT support; from freebsd via tholo
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.31 2003/09/24 20:40:19 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.31 2003/09/24 20:40:19 deraadt Exp $";
d178 1
a178 1
	pw = getpwnam("nobody");
d180 1
a180 1
		syslog(LOG_ERR, "no nobody: %m");
@


1.31
log
@realloc fixes; ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.30 2003/07/29 18:39:23 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.30 2003/07/29 18:39:23 deraadt Exp $";
d72 1
d78 1
a78 1
int	maxtimeout = 5*TIMEOUT;
d98 1
a98 1
	char	*f_mode;
d106 14
a119 1
	{ 0 }
d125 1
d296 1
a296 1
	int first = 1, ecode;
d298 2
a299 1
	char *filename, *mode = NULL;
d301 1
a301 1
	filename = cp = tp->th_stuff;
d312 8
d335 38
d374 2
d448 8
d476 1
a476 1
int	timeout;
d483 1
a483 2
	timeout += rexmtval;
	if (timeout >= maxtimeout)
d510 1
a510 1
		timeout = 0;
d574 1
a574 1
		timeout = 0;
d638 1
a638 1
	char	*e_msg;
d648 1
d680 54
@


1.30
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.29 2003/07/06 21:57:27 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.29 2003/07/06 21:57:27 deraadt Exp $";
d150 4
a153 5
		if (dirs)
			dirs = realloc(dirs, (ndirs+2) * sizeof (char *));
		else
			dirs = calloc(ndirs+2, sizeof(char *));
		if (dirs == NULL) {
d157 1
@


1.29
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.28 2003/06/25 21:11:25 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.28 2003/06/25 21:11:25 deraadt Exp $";
d157 1
a157 1
		}			
d461 1
a461 1
			
@


1.28
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.27 2003/06/02 19:38:25 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.27 2003/06/02 19:38:25 millert Exp $";
d407 1
a407 1
void
d481 1
a481 1
void
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.26 2002/09/06 19:43:54 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.26 2002/09/06 19:43:54 deraadt Exp $";
d98 3
a100 3
	int	(*f_validate)();
	int	(*f_send)();
	int	(*f_recv)();
d423 1
a423 1
	struct tftphdr *dp, *r_init();
d494 1
a494 1
	struct tftphdr *dp, *w_init();
@


1.26
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.25 2002/07/03 23:39:03 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.25 2002/07/03 23:39:03 deraadt Exp $";
@


1.25
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.24 2002/06/04 10:08:51 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.24 2002/06/04 10:08:51 mpech Exp $";
d87 1
a87 1
int	fromlen;
d132 1
a134 3
	int n = 0;
	int on = 1;
	int fd = 0;
d136 1
a136 2
	int i, j;
	int c;
a147 1

d192 4
a195 4
	(void) setegid(pw->pw_gid);
	(void) setgid(pw->pw_gid);
	(void) seteuid(pw->pw_uid);
	(void) setuid(pw->pw_uid);
a344 1
	int	fd, wmode;
d346 1
d444 1
a444 1
		(void) setjmp(timeoutbuf);
d481 1
a481 1
	(void) fclose(file);
d511 1
a511 1
		(void) setjmp(timeoutbuf);
d594 1
a595 1
	struct errmsg *pe;
@


1.24
log
@fix $OpenBSD$ tag.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.23 2002/06/02 01:27:16 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.23 2002/06/02 01:27:16 deraadt Exp $";
d123 1
a123 1
usage()
d130 1
a130 3
main(argc, argv)
	int    argc;
	char **argv;
d286 1
a286 3
tftp(tp, size)
	struct tftphdr *tp;
	int size;
d346 1
a346 3
validate_access(filename, mode)
	char *filename;
	int mode;
d416 1
a416 1
timer()
d429 1
a429 2
sendfile(pf)
	struct formats *pf;
d490 1
a490 1
justquit()
d500 1
a500 2
recvfile(pf)
	struct formats *pf;
d595 1
a595 2
nak(error)
	int error;
@


1.23
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.22 2002/05/13 07:44:48 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.22 2002/05/13 07:44:48 mpech Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
@


1.22
log
@o) fix order and usage of chroot&chdir;
o) move code up from chroot&chdir block (tftpd);

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.21 2002/02/01 06:05:22 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.21 2002/02/01 06:05:22 itojun Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d366 1
a366 1
			if(*cp == '.' && strncmp(cp-1, "/../", 4) == 0)
@


1.21
log
@make tftpd address family independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.20 2001/12/07 17:09:00 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.20 2001/12/07 17:09:00 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d173 6
d188 6
a193 2
		if (chdir(dirs[0])) {
			syslog(LOG_ERR, "%s: %m", dirs[0]);
a195 11
	}

	pw = getpwnam("nobody");
	if (!pw) {
		syslog(LOG_ERR, "no nobody: %m");
		exit(1);
	}

	if (secure && chroot(".")) {
		syslog(LOG_ERR, "chroot: %m");
		exit(1);
@


1.20
log
@mark longjmp race
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.19 2001/07/31 14:32:15 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.19 2001/07/31 14:32:15 mpech Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d78 1
a78 1
struct	sockaddr_in s_in = { AF_INET };
d86 1
a86 1
struct	sockaddr_in from;
a258 2
	from.sin_len = sizeof(struct sockaddr_in);
	from.sin_family = AF_INET;
d262 1
a262 1
	peer = socket(AF_INET, SOCK_DGRAM, 0);
d267 4
a270 1
	if (bind(peer, (struct sockaddr *)&s_in, sizeof (s_in)) < 0) {
d274 1
a274 1
	if (connect(peer, (struct sockaddr *)&from, sizeof(from)) < 0) {
@


1.19
log
@o) better struct handling;
o) use __progname in openlog(3);
o) better ERROR packets handling;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.18 2001/06/11 15:18:53 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.18 2001/06/11 15:18:53 mickey Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d424 1
a424 1

d428 1
a428 1
	longjmp(timeoutbuf, 1);		/* XXX longjmp/signal resource leaks */
@


1.18
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.17 2001/05/09 18:06:35 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.17 2001/05/09 18:06:35 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d143 1
a143 1
	openlog("tftpd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
d593 1
a593 1
	{ -1,		0 }
d620 4
a623 4
	length = strlcpy(tp->th_msg, pe->e_msg, sizeof(buf) - 4);
	if (length >= sizeof(buf) - 4)
		length = sizeof(buf) - 5;
	if (send(peer, buf, length + 5, 0) != length)
@


1.17
log
@typo; david@@phobia.ms
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.16 2001/03/08 02:23:56 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.16 2001/03/08 02:23:56 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d620 4
a623 5
	strcpy(tp->th_msg, pe->e_msg);
	length = strlen(pe->e_msg);
	tp->th_msg[length] = '\0';
	length += 5;
	if (send(peer, buf, length, 0) != length)
@


1.16
log
@KNF & block size fix from daeron@@student.utwente.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.15 2001/01/17 19:24:49 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.15 2001/01/17 19:24:49 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d376 1
a376 1
	 * We use different a different permissions scheme if `cancreate' is
@


1.15
log
@use _exit() in signal handlers, mark longjmp() as being a possible resource leak
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.14 2000/02/01 03:23:22 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.14 2000/02/01 03:23:22 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d57 2
d92 29
a120 2
int	secure = 0;
int	cancreate = 0;
d134 1
a134 1
	register struct tftphdr *tp;
d136 1
a136 1
	register int n = 0;
d139 1
a139 1
	int pid;
a283 15
int	validate_access();
int	sendfile(), recvfile();

struct formats {
	char	*f_mode;
	int	(*f_validate)();
	int	(*f_send)();
	int	(*f_recv)();
	int	f_convert;
} formats[] = {
	{ "netascii",	validate_access,	sendfile,	recvfile, 1 },
	{ "octet",	validate_access,	sendfile,	recvfile, 0 },
	{ 0 }
};

d287 1
d292 1
a292 1
	register char *cp;
d294 2
a295 2
	register struct formats *pf;
	char *filename, *mode;
d349 1
d434 1
d439 3
a441 2
	register struct tftphdr *ap;    /* ack packet */
	register int block = 1, size, n;
d493 1
d506 1
d511 3
a513 2
	register struct tftphdr *ap;    /* ack buffer */
	register int block = 0, n, size;
d555 2
a556 1
			if (size < 0) nak(errno + 100);
d578 1
a578 1
	return;
d602 1
d606 1
a606 1
	register struct tftphdr *tp;
d608 1
a608 1
	register struct errmsg *pe;
@


1.14
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.13 1999/06/23 17:01:36 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.13 1999/06/23 17:01:36 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d411 2
a412 2
		exit(1);
	longjmp(timeoutbuf, 1);
d480 1
a480 1
	exit(0);
@


1.13
log
@solve a file creation race
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.12 1998/07/10 08:06:26 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.12 1998/07/10 08:06:26 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
a74 1
extern	int errno;
@


1.12
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.11 1997/11/04 08:45:56 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.11 1997/11/04 08:45:56 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d370 1
a370 1
				wmode = O_CREAT;
d383 1
a383 1
	fd = open(filename, mode == RRQ ? O_RDONLY : (O_WRONLY|wmode));
d389 1
a389 1
	if ((wmode == O_CREAT) && fchmod(fd, 0666) < 0) {
@


1.11
log
@use LOG_NDELAY so that syslog works inside chroot; jim@@komodo.reptiles.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.10 1997/10/06 06:07:29 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.10 1997/10/06 06:07:29 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d97 1
a97 1
	syslog(LOG_ERR, "Usage: %s [-cs] [directory ...]\n", __progname);
d137 1
a137 1
			syslog(LOG_ERR, "malloc: %m\n");
d147 1
a147 1
			syslog(LOG_ERR, "no -s directory\n");
d151 1
a151 1
			syslog(LOG_ERR, "too many -s directories\n");
d155 1
a155 1
			syslog(LOG_ERR, "%s: %m\n", dirs[0]);
d162 1
a162 1
		syslog(LOG_ERR, "no nobody: %m\n");
d167 1
a167 1
		syslog(LOG_ERR, "chroot: %m\n");
d177 1
a177 1
		syslog(LOG_ERR, "ioctl(FIONBIO): %m\n");
d184 1
a184 1
		syslog(LOG_ERR, "recvfrom: %m\n");
d226 1
a226 1
		syslog(LOG_ERR, "fork: %m\n");
d238 1
a238 1
		syslog(LOG_ERR, "socket: %m\n");
d242 1
a242 1
		syslog(LOG_ERR, "bind: %m\n");
d246 1
a246 1
		syslog(LOG_ERR, "connect: %m\n");
d442 1
a442 1
			syslog(LOG_ERR, "tftpd: write: %m\n");
d451 1
a451 1
				syslog(LOG_ERR, "tftpd: read: %m\n");
d506 1
a506 1
			syslog(LOG_ERR, "tftpd: write: %m\n");
d515 1
a515 1
				syslog(LOG_ERR, "tftpd: read: %m\n");
d603 1
a603 1
		syslog(LOG_ERR, "nak: %m\n");
@


1.10
log
@unlimit number of tftpd directories; enforce single directory spec for -s
argument. bugs reported by cgd in the netbsd tree, and i've been given the
pleasure of fixing them here before they fix them.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.9 1997/07/29 02:11:11 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.9 1997/07/29 02:11:11 deraadt Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d115 1
a115 1
	openlog("tftpd", LOG_PID, LOG_DAEMON);
@


1.9
log
@what incredible bullshit
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.8 1997/07/23 20:36:37 kstailey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.8 1997/07/23 20:36:37 kstailey Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d88 2
a89 2
#define MAXARG	4
char	*dirs[MAXARG+1];
d132 17
a148 6
		if (!secure) {
			if (n >= MAXARG) {
				syslog(LOG_ERR, "too many directories\n");
				exit(1);
			} else
				dirs[n++] = argv[optind];
d150 6
a155 2
		if (chdir(argv[optind])) {
			syslog(LOG_ERR, "%s: %m\n", argv[optind]);
@


1.8
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.7 1997/06/11 21:19:47 downsj Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tftpd.c,v 1.7 1997/06/11 21:19:47 downsj Exp $: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
a252 3
#ifdef notdef
	{ "mail",	validate_user,		sendmail,	recvmail, 1 },
#endif
@


1.7
log
@Implement and document the -c flag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD$: tftpd.c,v 1.6 1997/02/16 23:49:21 deraadt Exp $";
d435 1
a435 1
			alarm(rexmtval);        /* read the ack */
d502 1
a502 1
			if (n < 0) {            /* really? */
d517 1
a517 1
					goto send_ack;          /* rexmit */
d522 1
a522 1
		if (size != (n-4)) {                    /* ahem */
d529 1
a529 1
	(void) fclose(file);            /* close data file */
d539 1
a539 1
	if (n >= 4 &&                   /* if read some data */
@


1.6
log
@clean
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: tftpd.c,v 1.5 1996/12/22 03:41:22 tholo Exp $";
d92 1
d97 1
a97 1
	syslog(LOG_ERR, "Usage: %s [-s] [directory ...]\n", __progname);
d117 1
a117 1
	while ((c = getopt(argc, argv, "s")) != -1)
d119 3
d328 1
a328 1
	int	fd;
d347 15
a361 5
	if (stat(filename, &stbuf) < 0)
		return (errno == ENOENT ? ENOTFOUND : EACCESS);
	if (mode == RRQ) {
		if ((stbuf.st_mode&(S_IREAD >> 6)) == 0)
			return (EACCESS);
d363 7
a369 2
		if ((stbuf.st_mode&(S_IWRITE >> 6)) == 0)
			return (EACCESS);
d371 1
a371 1
	fd = open(filename, mode == RRQ ? O_RDONLY : (O_WRONLY|O_TRUNC));
d374 11
d386 2
a387 3
	if (file == NULL) {
		return errno+100;
	}
@


1.5
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: tftpd.c,v 1.4 1996/12/03 00:25:52 deraadt Exp $";
d108 2
d180 2
a181 29
	{
		int pid;
		int i, j;

		for (i = 1; i < 20; i++) {
		    pid = fork();
		    if (pid < 0) {
				sleep(i);
				/*
				 * flush out to most recently sent request.
				 *
				 * This may drop some request, but those
				 * will be resent by the clients when
				 * they timeout.  The positive effect of
				 * this flush is to (try to) prevent more
				 * than one tftpd being started up to service
				 * a single request from a single client.
				 */
				j = sizeof from;
				i = recvfrom(fd, buf, sizeof (buf), 0,
				    (struct sockaddr *)&from, &j);
				if (i > 0) {
					n = i;
					fromlen = j;
				}
		    } else {
				break;
		    }
		}
d183 20
a202 5
			syslog(LOG_ERR, "fork: %m\n");
			exit(1);
		} else if (pid != 0) {
			exit(0);
		}
d204 6
@


1.4
log
@O_TRUNC when needed; freebsd pr#2112
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: tftpd.c,v 1.3 1996/08/12 08:29:45 deraadt Exp $";
d148 1
d150 1
@


1.3
log
@whoops
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: tftpd.c,v 1.2 1996/08/11 23:22:00 deraadt Exp $";
d352 1
a352 1
	fd = open(filename, mode == RRQ ? 0 : 1);
@


1.2
log
@getpwent nobody
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: tftpd.c,v 1.1.1.1 1995/10/18 08:43:25 deraadt Exp $";
d69 1
d98 1
d104 1
a104 1
	struct pwent *pw;
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: tftpd.c,v 1.7 1995/06/04 20:48:22 jtc Exp $";
a69 4
/* XXX svr4 defines UID_NOBODY and GID_NOBODY constants in <sys/param.h> */
#define UID_NOBODY	32767
#define GID_NOBODY	32766

d102 1
d135 3
a137 2
	if (secure && chroot(".")) {
		syslog(LOG_ERR, "chroot: %m\n");
d141 2
a142 2
	if (setgid(GID_NOBODY)) {
		syslog(LOG_ERR, "setgid: %m");
d146 2
a147 4
	if (setuid(UID_NOBODY)) {
		syslog(LOG_ERR, "setuid: %m");
		exit(1);
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
