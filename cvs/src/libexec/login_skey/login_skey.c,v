head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.24
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.22
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.18
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.16
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.14
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.12
	OPENBSD_5_0:1.23.0.10
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.8
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.6
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.07.20.15.47.29;	author bluhm;	state Exp;
branches;
next	1.25;
commitid	2ta6Y8xyDnPMJ9gT;

1.25
date	2015.10.16.13.37.43;	author millert;	state Exp;
branches;
next	1.24;
commitid	H99PcNtHGZMrNl2r;

1.24
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2009.06.02.20.42.48;	author jmeltzer;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.24.16.11.00;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.15.16.19.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.13.01.49.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.26.17.48.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.18.19.36.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.30.18.14.33;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.11.17.09.25;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.08.19.32.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.05.13.37.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.10.21.30.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.06.18.45.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.28.01.14.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.02.01.27.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.18.57.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.07.05.15.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.06.05.37.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.13.06.35;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.25.22.10.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.20.22.18.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.12.02.35.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@When login_skey was called for a user without skey, it crashed with
NULL pointer dereference.  It tried to pass a file descriptor that
did not exist.  This has to be done conditionally.
bug found by Raimund Specht with process accounting; OK millert@@
@
text
@/*	$OpenBSD: login_skey.c,v 1.25 2015/10/16 13:37:43 millert Exp $	*/

/*
 * Copyright (c) 2000, 2001, 2004 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <err.h>

#include <login_cap.h>
#include <bsd_auth.h>
#include <skey.h>

#define	MODE_LOGIN	0
#define	MODE_CHALLENGE	1
#define	MODE_RESPONSE	2

void quit(int);
void send_fd(int);
void suspend(int);

volatile sig_atomic_t resumed;
struct skey skey;

int
main(int argc, char *argv[])
{
	FILE *back = NULL;
	char *user = NULL, *cp, *ep;
	char challenge[SKEY_MAX_CHALLENGE+17], response[SKEY_MAX_PW_LEN+1];
	const char *errstr;
	int ch, fd = -1, haskey = 0, mode = MODE_LOGIN;

	(void)signal(SIGINT, quit);
	(void)signal(SIGQUIT, quit);
	(void)signal(SIGALRM, quit);
	(void)signal(SIGTSTP, suspend);
	(void)setpriority(PRIO_PROCESS, 0, 0);

	if (pledge("stdio rpath wpath flock sendfd proc tty", NULL) == -1) {
		syslog(LOG_AUTH|LOG_ERR, "pledge: %m");
		exit(1);
	}

	openlog(NULL, LOG_ODELAY, LOG_AUTH);

	while ((ch = getopt(argc, argv, "ds:v:")) != -1) {
		switch (ch) {
		case 'd':
			back = stdout;
			break;
		case 's':	/* service */
			if (strcmp(optarg, "login") == 0)
				mode = MODE_LOGIN;
			else if (strcmp(optarg, "challenge") == 0)
				mode = MODE_CHALLENGE;
			else if (strcmp(optarg, "response") == 0)
				mode = MODE_RESPONSE;
			else {
				syslog(LOG_ERR, "%s: invalid service", optarg);
				exit(1);
			}
			break;
		case 'v':
			if (strncmp(optarg, "fd=", 3) == 0) {
				fd = strtonum(optarg + 3, 0, INT_MAX, &errstr);
				if (errstr != NULL) {
					syslog(LOG_ERR, "fd is %s: %s",
					    errstr, optarg + 3);
					fd = -1;
				}
			}
			/* silently ignore unsupported variables */
			break;
		default:
			syslog(LOG_ERR, "usage error");
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

	switch (argc) {
	case 2:	/* silently ignore class */
	case 1:
		user = *argv;
		break;
	default:
		syslog(LOG_ERR, "usage error");
		exit(1);
	}

	if (back == NULL && (back = fdopen(3, "r+")) == NULL)  {
		syslog(LOG_ERR, "reopening back channel: %m");
		exit(1);
	}

	/*
	 * Note: our skeychallenge2() will always fill in the challenge,
	 *       even if it has to create a fake one.
	 */
	switch (mode) {
	case MODE_LOGIN:
		haskey = (skeychallenge2(fd, &skey, user, challenge) == 0);
		strlcat(challenge, "\nS/Key Password:", sizeof(challenge));

		/* time out getting passphrase after 2 minutes to avoid a DoS */
		if (haskey)
			alarm(120);
		resumed = 0;
		if (!readpassphrase(challenge, response, sizeof(response), 0))
			exit(1);
		if (response[0] == '\0')
			readpassphrase("S/Key Password [echo on]: ",
			    response, sizeof(response), RPP_ECHO_ON);
		alarm(0);
		if (resumed) {
			/*
			 * We were suspended by the user.  Our lock is
			 * no longer valid so we must regain it so
			 * an attacker cannot do a partial guess of
			 * an S/Key response already in progress.
			 */
			haskey = (skeylookup(&skey, user) == 0);
		}
		break;

	case MODE_CHALLENGE:
		haskey = (skeychallenge2(fd, &skey, user, challenge) == 0);
		strlcat(challenge, "\nS/Key Password:", sizeof(challenge));
		fprintf(back, BI_VALUE " challenge %s\n",
		    auth_mkvalue(challenge));
		fprintf(back, BI_CHALLENGE "\n");
		if (haskey) {
			fprintf(back, BI_FDPASS "\n");
			fflush(back);
			send_fd(fileno(back));
		}
		exit(0);

	case MODE_RESPONSE:
		/* read challenge */
		mode = -1;
		cp = challenge;
		ep = challenge + sizeof(challenge);
		while (cp < ep && read(fileno(back), cp, 1) == 1) {
			if (*cp++ == '\0') {
				mode = MODE_CHALLENGE;
				break;
			}
		}
		if (mode != MODE_CHALLENGE) {
			syslog(LOG_ERR,
			    "protocol error: bad/missing challenge");
			exit(1);
		}

		/* read response */
		cp = response;
		ep = response + sizeof(response);
		while (cp < ep && read(fileno(back), cp, 1) == 1) {
			if (*cp++ == '\0') {
				mode = MODE_RESPONSE;
				break;
			}
		}
		if (mode != MODE_RESPONSE) {
			syslog(LOG_ERR,
			    "protocol error: bad/missing response");
			exit(1);
		}

		/*
		 * Since the entry is locked we do not need to compare
		 * the passed in challenge to the S/Key database but
		 * maybe we should anyway?
		 */
		haskey = (skeychallenge2(fd, &skey, user, challenge) == 0);
		break;
	}

	/*
	 * Ignore keyboard interrupt/suspend during database update.
	 */
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGTSTP, SIG_IGN);

	if (haskey && skeyverify(&skey, response) == 0) {
		if (mode == MODE_LOGIN) {
			if (skey.n <= 1)
				printf("Warning! You MUST change your "
				    "S/Key password now!\n");
			else if (skey.n < 5)
				printf("Warning! Change S/Key password soon\n");
		}
		fprintf(back, BI_AUTH "\n");
		fprintf(back, BI_SECURE "\n");
		exit(0);
	}
	fprintf(back, BI_REJECT "\n");
	exit(1);
}

/* ARGSUSED */
void
quit(int signo)
{

	_exit(1);
}

/* ARGSUSED */
void
suspend(int signo)
{
	sigset_t nset;
	int save_errno = errno;

	/*
	 * Unlock the skey record so we don't sleep holding the lock.
	 * Unblock SIGTSTP, set it to the default action and then
	 * resend it so we are suspended properly.
	 * When we resume, reblock SIGTSTP, reset the signal handler,
	 * set a flag and restore errno.
	 */
	alarm(0);
	skey_unlock(&skey);
	(void)signal(signo, SIG_DFL);
	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, signo);
	(void)sigprocmask(SIG_UNBLOCK, &nset, NULL);
	(void)kill(getpid(), signo);
	(void)sigprocmask(SIG_BLOCK, &nset, NULL);
	(void)signal(signo, suspend);
	resumed = 1;
	errno = save_errno;
}

void
send_fd(int sock)
{
	struct msghdr msg;
	struct cmsghdr *cmp;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;

	memset(&msg, 0, sizeof(msg));
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	cmp = CMSG_FIRSTHDR(&msg);
	cmp->cmsg_len = CMSG_LEN(sizeof(int));
	cmp->cmsg_level = SOL_SOCKET;
	cmp->cmsg_type = SCM_RIGHTS;

	*(int *)CMSG_DATA(cmp) = fileno(skey.keyfile);

	if (sendmsg(sock, &msg, 0) < 0)
		syslog(LOG_ERR, "sendmsg: %m");
}
@


1.25
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.24 2015/01/16 06:39:50 deraadt Exp $	*/
d163 5
a167 3
		fprintf(back, BI_FDPASS "\n");
		fflush(back);
		send_fd(fileno(back));
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.23 2009/06/02 20:42:48 jmeltzer Exp $	*/
d37 1
d68 5
@


1.23
log
@comment spelling fix: ARSGUSED -> ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.22 2008/03/24 16:11:00 deraadt Exp $	*/
a18 1
#include <sys/param.h>
d36 1
@


1.22
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.21 2008/03/15 16:19:02 deraadt Exp $	*/
d234 1
a234 1
/* ARSGUSED */
@


1.21
log
@Repair the simple cases for msg_controllen where it should just be
CMSG_SIZE(sizeof(int)), not sizeof(buffer) which may be larger because
of alignment; ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.20 2008/03/13 01:49:52 deraadt Exp $	*/
d273 1
a273 1
	msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.20
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.19 2007/07/26 17:48:41 millert Exp $	*/
d273 1
a273 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.19
log
@Remove the space after "Password:" in password prompts where echo is
turned off.  This is consistent with historic UNIX behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.18 2007/05/25 21:27:15 krw Exp $	*/
d266 4
a269 1
	char cmsgbuf[CMSG_SPACE(sizeof(int))];
d272 2
a273 2
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.18
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.17 2004/09/18 19:36:54 deraadt Exp $	*/
d128 1
a128 1
		strlcat(challenge, "\nS/Key Password: ", sizeof(challenge));
d153 1
a153 1
		strlcat(challenge, "\nS/Key Password: ", sizeof(challenge));
@


1.17
log
@ARGSUSED signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.16 2004/08/30 18:14:33 millert Exp $	*/
d204 1
a204 1
	 * Ignore keyboard interupt/suspend during database update.
@


1.16
log
@Use CMSG_SPACE when allocating space for the control message.
Fixes fd passing problems on sparc and sparc64.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.15 2004/08/11 17:09:25 millert Exp $	*/
d226 1
d234 1
@


1.15
log
@Rename confusing variable for readability's sake.  No actual code changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.14 2004/08/08 19:32:45 deraadt Exp $	*/
d264 1
a264 1
	char cmsgbuf[CMSG_LEN(sizeof(int))];
d268 1
a268 1
	msg.msg_controllen = sizeof(cmsgbuf);
d270 2
a271 2
	cmp = (struct cmsghdr *)cmsgbuf;
	cmp->cmsg_len = sizeof(cmsgbuf);
d275 1
a275 1
	*(int *)CMSG_DATA(cmsgbuf) = fileno(skey.keyfile);
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.13 2004/08/05 13:37:06 millert Exp $	*/
d260 1
a260 1
send_fd(int fd)
d277 1
a277 1
	if (sendmsg(fd, &msg, 0) < 0)
@


1.13
log
@Add support for passing an fd to the user's S/Key record back and
forth between login_skey and the invoking process.  This allows us
to keep the record locked between an invocation of login_skey that
receives the challenge and another that verifies the response,
preventing an interloper from sniffing the challenge and beating
the legitimate user to the response.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.12 2004/03/10 21:30:27 millert Exp $	*/
d120 1
a120 1
	
@


1.12
log
@More checking for a NULL return value from getpass().  otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.11 2002/09/06 18:45:07 deraadt Exp $	*/
d3 2
a4 2
/*-
 * Copyright (c) 1995 Berkeley Software Design, Inc. All rights reserved.
d6 3
a8 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
d10 7
a16 13
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: login_skey.c,v 1.3 1996/09/04 05:24:56 prb Exp $
d18 1
a18 1
#include <sys/types.h>
d20 1
a39 1
#include <sha1.h>
d42 4
d47 1
d57 4
a60 8
	char *class = 0;
	char *username = 0;
	char skeyprompt[SKEY_MAX_CHALLENGE+17];
	char passbuf[SKEY_MAX_PW_LEN+1];
	int c, haskey;
	int mode = 0;

	skeyprompt[0] = '\0';
d70 3
a72 3
	while ((c = getopt(argc, argv, "ds:v:")) != -1)
		switch (c) {
		case 'd':	/* to remain undocumented */
a74 2
		case 'v':
			break;
d77 1
a77 1
				mode = 0;
d79 1
a79 1
				mode = 1;
d81 1
a81 1
				mode = 2;
d87 11
d102 3
d106 2
a107 3
	switch (argc - optind) {
	case 2:
		class = argv[optind + 1];
d109 1
a109 1
		username = argv[optind];
a115 1

d120 9
d130 1
a130 54
	if (mode == 2) {
		mode = 0;
		c = -1;
		/* XXX - redo these loops! */
		while (++c < sizeof(skeyprompt) &&
		    read(3, &skeyprompt[c], 1) == 1) {
			if (skeyprompt[c] == '\0') {
				mode++;
				break;
			}
		}
		if (mode == 1) {
			c = -1;
			while (++c < sizeof(passbuf) &&
			    read(3, &passbuf[c], 1) == 1) {
				if (passbuf[c] == '\0') {
					mode++;
					break;
				}
			}
		}
		if (mode < 2) {
			syslog(LOG_ERR, "protocol error on back channel");
			exit(1);
		}
		/*
		 * Sigh.  S/Key really is a stateful protocol.
		 * We must assume that a user will only try to
		 * authenticate one at a time and that this call to
		 * skeychallenge will produce the same results as
		 * the call to skeychallenge when mode was 1.
		 *
		 * Furthermore, RFC2289 requires that an entry be
		 * locked against a partial guess race which is
		 * simply not possible if the calling program queries
		 * the user for the passphrase itself.  Oh well.
		 */
		haskey = (skeychallenge(&skey, username, skeyprompt) == 0);
	} else {
		/*
		 * Attempt an S/Key challenge.
		 * The OpenBSD skeychallenge() will always fill in a
		 * challenge, even if it has to cons one up.
		 */
		haskey = (skeychallenge(&skey, username, skeyprompt) == 0);
		strlcat(skeyprompt, "\nS/Key Password: ", sizeof skeyprompt);
		if (mode == 1) {
			fprintf(back, BI_VALUE " challenge %s\n",
			    auth_mkvalue(skeyprompt));
			fprintf(back, BI_CHALLENGE "\n");
			exit(0);
		}

		/* Time out getting passphrase after 2 minutes to avoid a DoS */
d134 1
a134 1
		if (!readpassphrase(skeyprompt, passbuf, sizeof(passbuf), 0))
d136 1
a136 1
		if (passbuf[0] == '\0')
d138 1
a138 1
			    passbuf, sizeof(passbuf), RPP_ECHO_ON);
d147 45
a191 1
			haskey = (skeylookup(&skey, username) == 0);
d193 8
d210 2
a211 2
	if (haskey && skeyverify(&skey, passbuf) == 0) {
		if (mode == 0) {
d257 22
@


1.11
log
@ansi; ok millert pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.10 2002/06/28 01:14:37 deraadt Exp $	*/
d185 2
a186 1
		readpassphrase(skeyprompt, passbuf, sizeof(passbuf), 0);
@


1.10
log
@minor indent cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.9 2002/06/02 01:27:15 deraadt Exp $	*/
d67 1
a67 3
main(argc, argv)
	int argc;
	char **argv;
d225 1
a225 2
quit(signo)
	int signo;
d232 1
a232 2
suspend(signo)
	int signo;
@


1.9
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.8 2002/05/29 18:57:06 deraadt Exp $	*/
d72 2
a73 2
    	char *class = 0;
    	char *username = 0;
d89 1
a89 1
    	while ((c = getopt(argc, argv, "ds:v:")) != -1)
@


1.8
log
@a few more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.7 2002/02/16 21:27:30 millert Exp $	*/
d90 1
a90 1
		switch(c) {
d113 1
a113 1
	switch(argc - optind) {
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.6 2001/12/07 05:15:58 millert Exp $	*/
d175 1
a175 1
		strcat(skeyprompt, "\nS/Key Password: ");
@


1.6
log
@Catch SIGINT, SIGQUIT and SIGTSTP but ignore during the database
update.  We have to be careful and drop our lock if we are suspended
and then regain the lock on resume.  This is necessary because the
user must not be allowed to keep a record locked for a long period
of time to avoid a DoS.  We must be sure to re-lock when we resume
because otherwise an attacker could suspend us until a user starts
to login and then resume and then race the user for login using
the challenge response from the user.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.5 2001/12/06 05:37:04 millert Exp $	*/
d60 2
a61 2
void quit __P((int));
void suspend __P((int));
@


1.5
log
@Do not set handler for SIGINT and SIGQUIT to SIG_IGN since it prevents
getpass()/readpassphrase() from being able to restore the tty mode
on keyboard interrupt.  Along with the recent readpassphrase.c commit
this means that if you ^C things that use login scripts (like su(1))
with a non-CBREAK shell your tty mode will be restored nicely.

TODO:
The various login scripts need to install handlers to avoid leaving
turd files or otherwise ending in a bad state.  It would also be
nice to send BI_REJECT to the back channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.4 2001/10/24 13:06:35 mpech Exp $	*/
d43 1
d48 1
d60 5
a64 1
void timedout __P((int));
a73 1
	struct skey skey;
d81 4
a84 1
	(void)signal(SIGALRM, timedout);
d186 1
d192 9
d203 7
d227 1
a227 1
timedout(signo)
d232 27
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.3 2001/06/25 22:10:29 millert Exp $	*/
a75 2
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
@


1.3
log
@Remove instance stuff now that su uses an explicit option to specify
the invoking user.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.2 2001/06/20 22:18:06 millert Exp $	*/
d83 1
a83 1
    	while ((c = getopt(argc, argv, "ds:v:")) != EOF)
@


1.2
log
@Add an alarm to implement as timeout on the locked record.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_skey.c,v 1.1 2000/12/12 02:35:18 millert Exp $	*/
a72 1
	char *instance;
a186 3
	if ((instance = strchr(username, '.')))
		*instance++ = '\0';

a195 2
		if (instance && strcmp(instance, "root") == 0)
			fprintf(back, BI_ROOTOKAY "\n");
@


1.1
log
@skey login script; authenticates the user via S/Key
will be used when BSD authentication is enabled
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
d79 1
d156 5
d178 3
d182 1
a182 1
		if (passbuf[0] == '\0') {
d185 1
a185 1
		}
d194 2
a195 1
				printf("Warning! You MUST change your S/Key password now!\n");
d207 8
@

