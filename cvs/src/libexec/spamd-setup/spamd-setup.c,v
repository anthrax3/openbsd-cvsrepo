head	1.50;
access;
symbols
	OPENBSD_6_1:1.48.0.8
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.38.0.10
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.8
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.12
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.50
date	2017.07.07.00.10.15;	author djm;	state Exp;
branches;
next	1.49;
commitid	bIDeAUla86Rel2oj;

1.49
date	2017.07.07.00.09.14;	author djm;	state Exp;
branches;
next	1.48;
commitid	lIjwnnU6Rmo7HDpq;

1.48
date	2016.01.04.09.15.24;	author mestre;	state Exp;
branches;
next	1.47;
commitid	0luVEN8FB0Fvk3ig;

1.47
date	2015.12.12.20.09.28;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	TosXyFD66Z0p2ETT;

1.46
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.45;
commitid	GouatFiJVxwlAVIQ;

1.45
date	2015.01.20.16.54.06;	author millert;	state Exp;
branches;
next	1.44;
commitid	4zoVjolvqZifcCus;

1.44
date	2015.01.19.19.25.47;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	7dVvTH0XzaUwzV2J;

1.43
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2015.01.14.11.59.10;	author millert;	state Exp;
branches;
next	1.41;
commitid	rNMHkC7XShaMzGid;

1.41
date	2015.01.13.21.45.53;	author millert;	state Exp;
branches;
next	1.40;
commitid	TXA0vhWwSdC60CIG;

1.40
date	2015.01.13.21.42.59;	author millert;	state Exp;
branches;
next	1.39;
commitid	FcrTmS5RaNh0dgrr;

1.39
date	2014.10.09.02.43.43;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	sXea7sxYyxWPNIGe;

1.38
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.09.16.05.55;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.02.22.38.45;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.03.18.58.52;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.03.14.25.10;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.02.15.19.20;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.27.02.10.58;	author beck;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.25.22.59.38;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.24.19.28.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.14.01.16.22;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.09.19.12.29;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.11.15.37.21;	author dhill;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.26.23.54.00;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.26.19.56.21;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.26.19.18.49;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.26.05.21.28;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.17.17.52.49;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.02.16.45.30;	author dhartmei;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.16.05.35.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.29.11.19.07;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.28.07.32.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.21.08.07.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.21.02.49.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.14.24.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.16.01.01.33;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.28.19.13.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.21.20.42;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.10.19.36.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.10.19.35.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.09.19.22.26;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.09.02.50.54;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.08.22.06.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.08.18.29.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.08.18.17.04;	author beck;	state Exp;
branches;
next	;


desc
@@


1.50
log
@allow fetching lists from https:// URLs too
@
text
@/*	$OpenBSD: spamd-setup.c,v 1.49 2017/07/07 00:09:14 djm Exp $ */

/*
 * Copyright (c) 2003 Bob Beck.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>

#define PATH_FTP		"/usr/bin/ftp"
#define PATH_PFCTL		"/sbin/pfctl"
#define PATH_SPAMD_CONF		"/etc/mail/spamd.conf"
#define SPAMD_ARG_MAX		256 /* max # of args to an exec */
#define SPAMD_USER		"_spamd"

struct cidr {
	u_int32_t addr;
	u_int8_t bits;
};

struct bl {
	u_int32_t addr;
	int8_t b;
	int8_t w;
};

struct blacklist {
	char *name;
	char *message;
	struct bl *bl;
	size_t blc, bls;
	u_int8_t black;
};

u_int32_t	 imask(u_int8_t);
u_int8_t	 maxblock(u_int32_t, u_int8_t);
u_int8_t	 maxdiff(u_int32_t, u_int32_t);
struct cidr	*range2cidrlist(struct cidr *, u_int *, u_int *, u_int32_t,
		     u_int32_t);
void		 cidr2range(struct cidr, u_int32_t *, u_int32_t *);
char		*atop(u_int32_t);
int		 parse_netblock(char *, struct bl *, struct bl *, int);
int		 open_child(char *, char **, int);
int		 fileget(char *);
int		 open_file(char *, char *);
char		*fix_quoted_colons(char *);
void		 do_message(FILE *, char *);
struct bl	*add_blacklist(struct bl *, size_t *, size_t *, gzFile, int);
int		 cmpbl(const void *, const void *);
struct cidr	*collapse_blacklist(struct bl *, size_t, u_int *);
int		 configure_spamd(u_short, char *, char *, struct cidr *, u_int);
int		 configure_pf(struct cidr *);
int		 getlist(char **, char *, struct blacklist *, struct blacklist *);
__dead void	 usage(void);

uid_t		  spamd_uid;
gid_t		  spamd_gid;
int		  debug;
int		  dryrun;
int		  greyonly = 1;

extern char 	 *__progname;

#define MAXIMUM(a,b) (((a)>(b))?(a):(b))

u_int32_t
imask(u_int8_t b)
{
	if (b == 0)
		return (0);
	return (0xffffffffU << (32 - b));
}

u_int8_t
maxblock(u_int32_t addr, u_int8_t bits)
{
	u_int32_t m;

	while (bits > 0) {
		m = imask(bits - 1);

		if ((addr & m) != addr)
			return (bits);
		bits--;
	}
	return (bits);
}

u_int8_t
maxdiff(u_int32_t a, u_int32_t b)
{
	u_int8_t bits = 0;
	u_int32_t m;

	b++;
	while (bits < 32) {
		m = imask(bits);

		if ((a & m) != (b & m))
			return (bits);
		bits++;
	}
	return (bits);
}

struct cidr *
range2cidrlist(struct cidr *list, u_int *cli, u_int *cls, u_int32_t start,
    u_int32_t end)
{
	u_int8_t maxsize, diff;
	struct cidr *tmp;

	while (end >= start) {
		maxsize = maxblock(start, 32);
		diff = maxdiff(start, end);

		maxsize = MAXIMUM(maxsize, diff);
		if (*cls <= *cli + 1) {		/* one extra for terminator */
			tmp = reallocarray(list, *cls + 32,
			    sizeof(struct cidr));
			if (tmp == NULL)
				err(1, NULL);
			list = tmp;
			*cls += 32;
		}
		list[*cli].addr = start;
		list[*cli].bits = maxsize;
		(*cli)++;
		start = start + (1 << (32 - maxsize));
	}
	return (list);
}

void
cidr2range(struct cidr cidr, u_int32_t *start, u_int32_t *end)
{
	*start = cidr.addr;
	*end = cidr.addr + (1 << (32 - cidr.bits)) - 1;
}

char *
atop(u_int32_t addr)
{
	struct in_addr in;

	memset(&in, 0, sizeof(in));
	in.s_addr = htonl(addr);
	return (inet_ntoa(in));
}

int
parse_netblock(char *buf, struct bl *start, struct bl *end, int white)
{
	char astring[16], astring2[16];
	unsigned maskbits;
	struct cidr c;

	/* skip leading spaces */
	while (*buf == ' ')
		buf++;
	/* bail if it's a comment */
	if (*buf == '#')
		return (0);
	/* otherwise, look for a netblock of some sort */
	if (sscanf(buf, "%15[^/]/%u", astring, &maskbits) == 2) {
		/* looks like a cidr */
		memset(&c.addr, 0, sizeof(c.addr));
		if (inet_net_pton(AF_INET, astring, &c.addr, sizeof(c.addr))
		    == -1)
			return (0);
		c.addr = ntohl(c.addr);
		if (maskbits > 32)
			return (0);
		c.bits = maskbits;
		cidr2range(c, &start->addr, &end->addr);
		end->addr += 1;
	} else if (sscanf(buf, "%15[0123456789.]%*[ -]%15[0123456789.]",
	    astring, astring2) == 2) {
		/* looks like start - end */
		memset(&start->addr, 0, sizeof(start->addr));
		memset(&end->addr, 0, sizeof(end->addr));
		if (inet_net_pton(AF_INET, astring, &start->addr,
		    sizeof(start->addr)) == -1)
			return (0);
		start->addr = ntohl(start->addr);
		if (inet_net_pton(AF_INET, astring2, &end->addr,
		    sizeof(end->addr)) == -1)
			return (0);
		end->addr = ntohl(end->addr) + 1;
		if (start > end)
			return (0);
	} else if (sscanf(buf, "%15[0123456789.]", astring) == 1) {
		/* just a single address */
		memset(&start->addr, 0, sizeof(start->addr));
		if (inet_net_pton(AF_INET, astring, &start->addr,
		    sizeof(start->addr)) == -1)
			return (0);
		start->addr = ntohl(start->addr);
		end->addr = start->addr + 1;
	} else
		return (0);

	if (white) {
		start->b = 0;
		start->w = 1;
		end->b = 0;
		end->w = -1;
	} else {
		start->b = 1;
		start->w = 0;
		end->b = -1;
		end->w = 0;
	}
	return (1);
}

void
drop_privileges(void)
{
	if (setgroups(1, &spamd_gid) != 0)
		err(1, "setgroups %ld", (long)spamd_gid);
	if (setresgid(spamd_gid, spamd_gid, spamd_gid) != 0)
		err(1, "setresgid %ld", (long)spamd_gid);
	if (setresuid(spamd_uid, spamd_uid, spamd_uid) != 0)
		err(1, "setresuid %ld", (long)spamd_uid);
}

int
open_child(char *file, char **argv, int drop_privs)
{
	int pdes[2];

	if (pipe(pdes) != 0)
		return (-1);
	switch (fork()) {
	case -1:
		close(pdes[0]);
		close(pdes[1]);
		return (-1);
	case 0:
		/* child */
		close(pdes[0]);
		if (pdes[1] != STDOUT_FILENO) {
			dup2(pdes[1], STDOUT_FILENO);
			close(pdes[1]);
		}
		if (drop_privs)
			drop_privileges();
		closefrom(STDERR_FILENO + 1);
		execvp(file, argv);
		_exit(1);
	}

	/* parent */
	close(pdes[1]);
	return (pdes[0]);
}

int
fileget(char *url)
{
	char *argv[6];

	argv[0] = "ftp";
	argv[1] = "-V";
	argv[2] = "-o";
	argv[3] = "-";
	argv[4] = url;
	argv[5] = NULL;

	if (debug)
		fprintf(stderr, "Getting %s\n", url);

	return (open_child(PATH_FTP, argv, 1));
}

int
open_file(char *method, char *file)
{
	char *url;
	char **ap, **argv;
	int len, i, oerrno;

	if ((method == NULL) || (strcmp(method, "file") == 0))
		return (open(file, O_RDONLY));
	if (strcmp(method, "http") == 0 || strcmp(method, "https") == 0 ||
	    strcmp(method, "ftp") == 0) {
		if (asprintf(&url, "%s://%s", method, file) == -1)
			return (-1);
		i = fileget(url);
		free(url);
		return (i);
	} else if (strcmp(method, "exec") == 0) {
		len = strlen(file);
		argv = calloc(len, sizeof(char *));
		if (argv == NULL)
			return (-1);
		for (ap = argv; ap < &argv[len - 1] &&
		    (*ap = strsep(&file, " \t")) != NULL;) {
			if (**ap != '\0')
				ap++;
		}
		*ap = NULL;
		i = open_child(argv[0], argv, 0);
		oerrno = errno;
		free(argv);
		errno = oerrno;
		return (i);
	}
	errx(1, "Unknown method %s", method);
	return (-1); /* NOTREACHED */
}

/*
 * fix_quoted_colons walks through a buffer returned by cgetent.  We
 * look for quoted strings, to escape colons (:) in quoted strings for
 * getcap by replacing them with \C so cgetstr() deals with it correctly
 * without having to see the \C bletchery in a configuration file that
 * needs to have urls in it. Frees the buffer passed to it, passes back
 * another larger one, with can be used with cgetxxx(), like the original
 * buffer, it must be freed by the caller.
 * This should really be a temporary fix until there is a sanctioned
 * way to make getcap(3) handle quoted strings like this in a nicer
 * way.
 */
char *
fix_quoted_colons(char *buf)
{
	int in = 0;
	size_t i, j = 0;
	char *newbuf, last;

	/* Allocate enough space for a buf of all colons (impossible). */
	newbuf = malloc(2 * strlen(buf) + 1);
	if (newbuf == NULL)
		return (NULL);
	last = '\0';
	for (i = 0; i < strlen(buf); i++) {
		switch (buf[i]) {
		case ':':
			if (in) {
				newbuf[j++] = '\\';
				newbuf[j++] = 'C';
			} else
				newbuf[j++] = buf[i];
			break;
		case '"':
			if (last != '\\')
				in = !in;
			newbuf[j++] = buf[i];
			break;
		default:
			newbuf[j++] = buf[i];
		}
		last = buf[i];
	}
	free(buf);
	newbuf[j] = '\0';
	return (newbuf);
}

void
do_message(FILE *sdc, char *msg)
{
	size_t i, bs = 0, bu = 0, len;
	ssize_t n;	
	char *buf = NULL, last, *tmp;
	int fd;

	len = strlen(msg);
	if (msg[0] == '"' && msg[len - 1] == '"') {
		/* quoted msg, escape newlines and send it out */
		msg[len - 1] = '\0';
		buf = msg + 1;
		bu = len - 2;
		goto sendit;
	} else {
		/*
		 * message isn't quoted - try to open a local
		 * file and read the message from it.
		 */
		fd = open(msg, O_RDONLY);
		if (fd == -1)
			err(1, "Can't open message from %s", msg);
		for (;;) {
			if (bu == bs) {
				tmp = realloc(buf, bs + 8192);
				if (tmp == NULL)
					err(1, NULL);
				bs += 8192;
				buf = tmp;
			}

			n = read(fd, buf + bu, bs - bu);
			if (n == 0) {
				goto sendit;
			} else if (n == -1) {
				err(1, "Can't read from %s", msg);
			} else
				bu += n;
		}
		buf[bu]='\0';
	}
 sendit:
	fprintf(sdc, ";\"");
	last = '\0';
	for (i = 0; i < bu; i++) {
		/* handle escaping the things spamd wants */
		switch (buf[i]) {
		case 'n':
			if (last == '\\')
				fprintf(sdc, "\\\\n");
			else
				fputc('n', sdc);
			last = '\0';
			break;
		case '\n':
			fprintf(sdc, "\\n");
			last = '\0';
			break;
		case '"':
			fputc('\\', sdc);
			/* FALLTHROUGH */
		default:
			fputc(buf[i], sdc);
			last = '\0';
		}
	}
	fputc('"', sdc);
	if (bs != 0)
		free(buf);
}

/* retrieve a list from fd. add to blacklist bl */
struct bl *
add_blacklist(struct bl *bl, size_t *blc, size_t *bls, gzFile gzf, int white)
{
	int i, n, start, bu = 0, bs = 0, serrno = 0;
	char *buf = NULL, *tmp;
	struct bl *blt;

	for (;;) {
		/* read in gzf, then parse */
		if (bu == bs) {
			tmp = realloc(buf, bs + (1024 * 1024) + 1);
			if (tmp == NULL) {
				serrno = errno;
				free(buf);
				buf = NULL;
				bs = 0;
				goto bldone;
			}
			bs += 1024 * 1024;
			buf = tmp;
		}

		n = gzread(gzf, buf + bu, bs - bu);
		if (n == 0)
			goto parse;
		else if (n == -1) {
			serrno = errno;
			goto bldone;
		} else
			bu += n;
	}
 parse:
	start = 0;
	/* we assume that there is an IP for every 14 bytes */
	if (*blc + bu / 7 >= *bls) {
		*bls += bu / 7;
		blt = reallocarray(bl, *bls, sizeof(struct bl));
		if (blt == NULL) {
			*bls -= bu / 7;
			serrno = errno;
			goto bldone;
		}
		bl = blt;
	}
	for (i = 0; i <= bu; i++) {
		if (*blc + 1 >= *bls) {
			*bls += 1024;
			blt = reallocarray(bl, *bls, sizeof(struct bl));
			if (blt == NULL) {
				*bls -= 1024;
				serrno = errno;
				goto bldone;
			}
			bl = blt;
		}
		if (i == bu || buf[i] == '\n') {
			buf[i] = '\0';
			if (parse_netblock(buf + start,
			    bl + *blc, bl + *blc + 1, white))
				*blc += 2;
			start = i + 1;
		}
	}
	if (bu == 0)
		errno = EIO;
 bldone:
	free(buf);
	if (serrno)
		errno = serrno;
	return (bl);
}

int
cmpbl(const void *a, const void *b)
{
	if (((struct bl *)a)->addr > ((struct bl *) b)->addr)
		return (1);
	if (((struct bl *)a)->addr < ((struct bl *) b)->addr)
		return (-1);
	return (0);
}

/*
 * collapse_blacklist takes blacklist/whitelist entries sorts, removes
 * overlaps and whitelist portions, and returns netblocks to blacklist
 * as lists of nonoverlapping cidr blocks suitable for feeding in
 * printable form to pfctl or spamd.
 */
struct cidr *
collapse_blacklist(struct bl *bl, size_t blc, u_int *clc)
{
	int bs = 0, ws = 0, state=0;
	u_int cli, cls, i;
	u_int32_t bstart = 0;
	struct cidr *cl;
	int laststate;
	u_int32_t addr;

	if (blc == 0)
		return (NULL);

	/*
	 * Overallocate by 10% to avoid excessive realloc due to white
	 * entries splitting up CIDR blocks.
	 */
	cli = 0;
	cls = (blc / 2) + (blc / 20) + 1;
	cl = reallocarray(NULL, cls, sizeof(struct cidr));
	if (cl == NULL)
		return (NULL);
	qsort(bl, blc, sizeof(struct bl), cmpbl);
	for (i = 0; i < blc;) {
		laststate = state;
		addr = bl[i].addr;

		do {
			bs += bl[i].b;
			ws += bl[i].w;
			i++;
		} while (bl[i].addr == addr);
		if (state == 1 && bs == 0)
			state = 0;
		else if (state == 0 && bs > 0)
			state = 1;
		if (ws > 0)
			state = 0;
		if (laststate == 0 && state == 1) {
			/* start blacklist */
			bstart = addr;
		}
		if (laststate == 1 && state == 0) {
			/* end blacklist */
			cl = range2cidrlist(cl, &cli, &cls, bstart, addr - 1);
		}
		laststate = state;
	}
	cl[cli].addr = 0;
	*clc = cli;
	return (cl);
}

int
configure_spamd(u_short dport, char *name, char *message,
    struct cidr *blacklists, u_int count)
{
	int lport = IPPORT_RESERVED - 1, s;
	struct sockaddr_in sin;
	FILE* sdc;

	s = rresvport(&lport);
	if (s == -1)
		return (-1);
	memset(&sin, 0, sizeof sin);
	sin.sin_len = sizeof(sin);
	sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(dport);
	if (connect(s, (struct sockaddr *)&sin, sizeof sin) == -1)
		return (-1);
	sdc = fdopen(s, "w");
	if (sdc == NULL) {
		close(s);
		return (-1);
	}
	fputs(name, sdc);
	do_message(sdc, message);
	fprintf(sdc, ";inet;%u", count);
	while (blacklists->addr != 0) {
		fprintf(sdc, ";%s/%u", atop(blacklists->addr),
		    blacklists->bits);
		blacklists++;
	}
	fputc('\n', sdc);
	fclose(sdc);
	close(s);
	return (0);
}


int
configure_pf(struct cidr *blacklists)
{
	char *argv[9]= {"pfctl", "-q", "-t", "spamd", "-T", "replace",
	    "-f" "-", NULL};
	static FILE *pf = NULL;
	int pdes[2];

	if (pf == NULL) {
		if (pipe(pdes) != 0)
			return (-1);
		switch (fork()) {
		case -1:
			close(pdes[0]);
			close(pdes[1]);
			return (-1);
		case 0:
			/* child */
			close(pdes[1]);
			if (pdes[0] != STDIN_FILENO) {
				dup2(pdes[0], STDIN_FILENO);
				close(pdes[0]);
			}
			closefrom(STDERR_FILENO + 1);
			execvp(PATH_PFCTL, argv);
			_exit(1);
		}

		/* parent */
		close(pdes[0]);
		pf = fdopen(pdes[1], "w");
		if (pf == NULL) {
			close(pdes[1]);
			return (-1);
		}
	}
	while (blacklists->addr != 0) {
		fprintf(pf, "%s/%u\n", atop(blacklists->addr),
		    blacklists->bits);
		blacklists++;
	}
	return (0);
}

int
getlist(char ** db_array, char *name, struct blacklist *blist,
    struct blacklist *blistnew)
{
	char *buf, *method, *file, *message;
	int fd, black = 0, serror;
	size_t blc, bls;
	struct bl *bl = NULL;
	gzFile gzf;

	if (cgetent(&buf, db_array, name) != 0)
		err(1, "Can't find \"%s\" in spamd config", name);
	buf = fix_quoted_colons(buf);
	if (cgetcap(buf, "black", ':') != NULL) {
		/* use new list */
		black = 1;
		blc = blistnew->blc;
		bls = blistnew->bls;
		bl = blistnew->bl;
	} else if (cgetcap(buf, "white", ':') != NULL) {
		/* apply to most recent blacklist */
		black = 0;
		blc = blist->blc;
		bls = blist->bls;
		bl = blist->bl;
	} else
		errx(1, "Must have \"black\" or \"white\" in %s", name);

	switch (cgetstr(buf, "msg", &message)) {
	case -1:
		if (black)
			errx(1, "No msg for blacklist \"%s\"", name);
		break;
	case -2:
		err(1, NULL);
	}

	switch (cgetstr(buf, "method", &method)) {
	case -1:
		method = NULL;
		break;
	case -2:
		err(1, NULL);
	}

	switch (cgetstr(buf, "file", &file)) {
	case -1:
		errx(1, "No file given for %slist %s",
		    black ? "black" : "white", name);
	case -2:
		err(1, NULL);
	default:
		fd = open_file(method, file);
		if (fd == -1)
			err(1, "Can't open %s by %s method",
			    file, method ? method : "file");
		free(method);
		free(file);
		gzf = gzdopen(fd, "r");
		if (gzf == NULL)
			errx(1, "gzdopen");
	}
	free(buf);
	bl = add_blacklist(bl, &blc, &bls, gzf, !black);
	serror = errno;
	gzclose(gzf);
	if (bl == NULL) {
		errno = serror;
		warn("Could not add %slist %s", black ? "black" : "white",
		    name);
		return (0);
	}
	if (black) {
		if (debug)
			fprintf(stderr, "blacklist %s %zu entries\n",
			    name, blc / 2);
		blistnew->message = message;
		blistnew->name = name;
		blistnew->black = black;
		blistnew->bl = bl;
		blistnew->blc = blc;
		blistnew->bls = bls;
	} else {
		/* whitelist applied to last active blacklist */
		if (debug)
			fprintf(stderr, "whitelist %s %zu entries\n",
			    name, (blc - blist->blc) / 2);
		blist->bl = bl;
		blist->blc = blc;
		blist->bls = bls;
	}
	return (black);
}

void
send_blacklist(struct blacklist *blist, in_port_t port)
{
	struct cidr *cidrs;
	u_int clc;

	if (blist->blc > 0) {
		cidrs = collapse_blacklist(blist->bl, blist->blc, &clc);
		if (cidrs == NULL)
			err(1, NULL);
		if (!dryrun) {
			if (configure_spamd(port, blist->name,
			    blist->message, cidrs, clc) == -1)
				err(1, "Can't connect to spamd on port %d",
				    port);
			if (!greyonly && configure_pf(cidrs) == -1)
				err(1, "pfctl failed");
		}
		free(cidrs);
		free(blist->bl);
	}
}

__dead void
usage(void)
{

	fprintf(stderr, "usage: %s [-bDdn]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	size_t blc, bls, black, white;
	char *db_array[2], *buf, *name;
	struct blacklist *blists;
	struct servent *ent;
	int daemonize = 0, ch;
	struct passwd *pw;

	while ((ch = getopt(argc, argv, "bdDn")) != -1) {
		switch (ch) {
		case 'n':
			dryrun = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'b':
			greyonly = 0;
			break;
		case 'D':
			daemonize = 1;
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 0)
		usage();

	if ((pw = getpwnam(SPAMD_USER)) == NULL)
		errx(1, "cannot find user %s", SPAMD_USER);
	spamd_uid = pw->pw_uid;
	spamd_gid = pw->pw_gid;

	if (pledge("stdio rpath inet proc exec id", NULL) == -1)
		err(1, "pledge");

	if (daemonize)
		daemon(0, 0);
	else if (chdir("/") != 0)
		err(1, "chdir(\"/\")");

	if ((ent = getservbyname("spamd-cfg", "tcp")) == NULL)
		errx(1, "cannot find service \"spamd-cfg\" in /etc/services");
	ent->s_port = ntohs(ent->s_port);

	db_array[0] = PATH_SPAMD_CONF;
	db_array[1] = NULL;

	if (cgetent(&buf, db_array, "all") != 0)
		err(1, "Can't find \"all\" in spamd config");
	name = strsep(&buf, ": \t"); /* skip "all" at start */
	blists = NULL;
	blc = bls = 0;
	while ((name = strsep(&buf, ": \t")) != NULL) {
		if (*name) {
			/* extract config in order specified in "all" tag */
			if (blc == bls) {
				struct blacklist *tmp;

				bls += 32;
				tmp = reallocarray(blists, bls,
				    sizeof(struct blacklist));
				if (tmp == NULL)
					err(1, NULL);
				blists = tmp;
			}
			if (blc == 0)
				black = white = 0;
			else {
				white = blc - 1;
				black = blc;
			}
			memset(&blists[black], 0, sizeof(struct blacklist));
			black = getlist(db_array, name, &blists[white],
			    &blists[black]);
			if (black && blc > 0) {
				/* collapse and free previous blacklist */
				send_blacklist(&blists[blc - 1], ent->s_port);
			}
			blc += black;
		}
	}
	/* collapse and free last blacklist */
	if (blc > 0)
		send_blacklist(&blists[blc - 1], ent->s_port);
	return (0);
}
@


1.49
log
@switch user to _spamd before executing ftp(1) to fetch lists.
sprinkle in some closefrom(2); ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.48 2016/01/04 09:15:24 mestre Exp $ */
d318 1
a318 1
	if ((strcmp(method, "http") == 0) ||
@


1.48
log
@pledge(2) spamd-setup(8)

It needs these annotations, to at least run the operations next to them:

stdio: malloc(3)
rpath: open(2)
inet: connect(2)/socket(2)
proc: fork(2)
exec: execvp(3)

While here remove netinet/in.h since all we need is already in arpa/inet.h and
sort the headers alphabetically

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.47 2015/12/12 20:09:28 mmcc Exp $ */
d29 1
d35 1
d46 1
d75 1
a75 1
int		 open_child(char *, char **);
d88 2
d249 11
d261 1
a261 1
open_child(char *file, char **argv)
d279 3
d306 1
a306 1
	return (open_child(PATH_FTP, argv));
d336 1
a336 1
		i = open_child(argv[0], argv);
d669 1
d823 1
d849 6
a854 1
	if (pledge("stdio rpath inet proc exec", NULL) == -1)
d859 2
@


1.47
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.46 2015/06/03 02:24:36 millert Exp $ */
d27 1
d29 2
a30 2
#include <netinet/in.h>
#include <arpa/inet.h>
d33 1
a37 2
#include <err.h>
#include <netdb.h>
d827 3
@


1.46
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.45 2015/01/20 16:54:06 millert Exp $ */
d514 1
a514 2
	if (buf)
		free(buf);
@


1.45
log
@Allocate a bit more memory to reduce the change of having to
realloc() which is expensive for large blacklists.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.44 2015/01/19 19:25:47 deraadt Exp $ */
d301 1
a301 2
		asprintf(&url, "%s://%s", method, file);
		if (url == NULL)
d310 1
a310 1
			err(1, NULL);
@


1.44
log
@Does not need netinet/ip_ipsp.h
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.43 2015/01/16 06:39:50 deraadt Exp $ */
d482 3
a484 3
	/* we assume that there is an IP for every 16 bytes */
	if (*blc + bu / 8 >= *bls) {
		*bls += bu / 8;
d487 1
a487 1
			*bls -= bu / 8;
d550 5
d556 3
a558 3
	cls = (blc / 2) + 1;
	cl = calloc(cls, sizeof(struct cidr));
	if (cl == NULL) {
a559 1
	}
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.42 2015/01/14 11:59:10 millert Exp $ */
a36 1
#include <netinet/ip_ipsp.h>
@


1.42
log
@Replace "errx(1, "malloc failed")" with "err(1, NULL)" to get
standard "Cannot allocate memory" message.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.41 2015/01/13 21:45:53 millert Exp $ */
d92 2
d145 1
a145 1
		maxsize = MAX(maxsize, diff);
@


1.41
log
@Fix printing of number of whitelist entries in debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.39 2014/10/09 02:43:43 deraadt Exp $ */
d148 1
a148 1
				errx(1, "malloc failed");
d310 1
a310 1
			errx(1, "malloc failed");
d402 1
a402 1
					errx(1, "malloc failed");
d701 1
a701 1
		errx(1, "malloc failed");
d709 1
a709 1
		errx(1, "malloc failed");
d717 1
a717 1
		errx(1, "malloc failed");
d770 1
a770 1
			errx(1, "malloc failed");
d850 1
a850 1
					errx(1, "malloc failed");
@


1.40
log
@Use address-family specific lists of addr/mask entries instead of
a union that can store either ipv4 or ipv6.  The old method used
4x as much memory as was really needed for ipv4.  The spamd-setup
protocol has changed from: tag;message;a/m;a/m;a/m...\n
to :tag;message;af;count;a/m;a/m;a/m...[af;count;a/m;a/m;a/m]\n
OK phessler@@ "nice" beck@@
@
text
@d740 3
d751 3
a757 3
	if (debug)
		fprintf(stderr, "%slist %s %zu entries\n",
		    black ? "black" : "white", name, blc / 2);
@


1.39
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.38 2012/12/04 02:24:47 deraadt Exp $ */
a62 1
	int count;
d68 1
a68 1
struct cidr	*range2cidrlist(struct cidr *, int *, int *, u_int32_t,
d80 2
a81 2
struct cidr	*collapse_blacklist(struct bl *, size_t);
int		 configure_spamd(u_short, char *, char *, struct cidr *);
d97 1
a97 1
	return (0xffffffff << (32 - b));
d133 1
a133 1
range2cidrlist(struct cidr *list, int *cli, int *cls, u_int32_t start,
d538 1
a538 1
collapse_blacklist(struct bl *bl, size_t blc)
d540 2
a541 1
	int bs = 0, ws = 0, state=0, cli, cls, i;
d582 1
d588 1
a588 1
    struct cidr *blacklists)
d609 1
a609 1
	fprintf(sdc, "%s", name);
d611 1
d762 1
d765 1
a765 1
		cidrs = collapse_blacklist(blist->bl, blist->blc);
d770 1
a770 1
			    blist->message, cidrs) == -1)
@


1.38
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.37 2009/09/09 16:05:55 claudio Exp $ */
d146 2
a147 1
			tmp = realloc(list, (*cls + 32) * sizeof(struct cidr));
d485 1
a485 1
		blt = realloc(bl, *bls * sizeof(struct bl));
d496 1
a496 1
			blt = realloc(bl, *bls * sizeof(struct bl));
d841 2
a842 2
				tmp = realloc(blists,
				    bls * sizeof(struct blacklist));
@


1.37
log
@Change the way memory is allocated to reduce memory footprint. Loading the
large uatraps uses now around 8 times less memory. Other cleanup includes
a fast implementation of imask() (stolen from bgpd), killing some unused
code and try to estimate the memory needed in add_blacklist() to reduce the
realloc() calls.
Tested by many (sthen, matthieu, Stephan A. Rickauer)
OK beck@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.36 2009/06/02 22:38:45 ray Exp $ */
a26 1
#include <sys/param.h>
@


1.36
log
@Protect errno.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.35 2008/10/03 18:58:52 jmc Exp $ */
d67 20
a86 19
u_int32_t	  imask(u_int8_t);
u_int8_t	  maxblock(u_int32_t, u_int8_t);
u_int8_t	  maxdiff(u_int32_t, u_int32_t);
struct cidr	 *range2cidrlist(u_int32_t, u_int32_t);
void		  cidr2range(struct cidr, u_int32_t *, u_int32_t *);
char		 *atop(u_int32_t);
int		  parse_netblock(char *, struct bl *, struct bl *, int);
int		  open_child(char *, char **);
int		  fileget(char *);
int		  open_file(char *, char *);
char		 *fix_quoted_colons(char *);
void		  do_message(FILE *, char *);
struct bl	 *add_blacklist(struct bl *, size_t *, size_t *, gzFile, int);
int		  cmpbl(const void *, const void *);
struct cidr	**collapse_blacklist(struct bl *, size_t);
int		  configure_spamd(u_short, char *, char *, struct cidr **);
int		  configure_pf(struct cidr **);
int		  getlist(char **, char *, struct blacklist *, struct blacklist *);
__dead void	  usage(void);
d97 3
a99 6
	u_int32_t j = 0;
	int i;

	for (i = 31; i > 31 - b; --i)
		j |= (1 << i);
	return (j);
d135 2
a136 1
range2cidrlist(u_int32_t start, u_int32_t end)
a137 2
	struct cidr *list = NULL;
	size_t cs = 0, cu = 0;
d146 2
a147 2
		if (cs <= cu + 1) {		/* one extra for terminator */
			tmp = realloc(list, (cs + 32) * sizeof(struct cidr));
d151 1
a151 1
			cs += 32;
d153 3
a155 5
		list[cu].addr = start;
		list[cu].bits = maxsize;
		cu++;
		list[cu].addr = 0;
		list[cu].bits = 0;
d482 11
d494 1
a494 1
		if (*blc == *bls) {
d538 1
a538 1
struct cidr **
d541 1
a541 1
	int bs = 0, ws = 0, state=0, cli, i;
d543 1
a543 1
	struct cidr **cl;
d549 3
a551 1
	cl = calloc(((blc / 2) + 1), sizeof(struct cidr));
a555 2
	cli = 0;
	cl[cli] = NULL;
d577 1
a577 2
			cl[cli++] = range2cidrlist(bstart, addr - 1);
			cl[cli] = NULL;
d581 1
d587 1
a587 1
    struct cidr **blacklists)
d610 3
a612 6
	while (*blacklists != NULL) {
		struct cidr *b = *blacklists;
		while (b->addr != 0) {
			fprintf(sdc, ";%s/%u", atop(b->addr), (b->bits));
			b++;
		}
d623 1
a623 1
configure_pf(struct cidr **blacklists)
d657 3
a659 7
	while (*blacklists != NULL) {
		struct cidr *b = *blacklists;

		while (b->addr != 0) {
			fprintf(pf, "%s/%u\n", atop(b->addr), (b->bits));
			b++;
		}
d759 1
a759 1
	struct cidr **cidrs, **tmp;
a772 2
		for (tmp = cidrs; *tmp != NULL; tmp++)
			free(*tmp);
d789 2
a790 2
	size_t dbs, dbc, blc, bls, black, white;
	char **db_array, *buf, *name;
d793 1
a793 1
	int daemonize = 0, i, ch;
d826 2
a827 10
	dbs = argc + 2;
	dbc = 0;
	db_array = calloc(dbs, sizeof(char *));
	if (db_array == NULL)
		errx(1, "malloc failed");

	db_array[dbc]= PATH_SPAMD_CONF;
	dbc++;
	for (i = 1; i < argc; i++)
		db_array[dbc++] = argv[i];
a828 2
	blists = NULL;
	blc = bls = 0;
d832 2
a833 1
	blc = 0;
@


1.35
log
@-D before -d;
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.34 2008/10/03 14:25:10 deraadt Exp $ */
d466 1
a469 1
				serrno = errno;
d671 1
a671 1
	int fd, black = 0;
d730 1
d733 1
@


1.34
log
@New option -D to daemonize spamd-setup for early bootup use.  This avoids
spamd-setup hanging if there are various (network?) issues and the system
not proceeding to multiuser so that this can be debugged.  We do not use
& for startup in /etc/rc because this makes the spamd-setup a child of the
rc scripts after bootup (that is gross)
Problem reported in PR 5864, change discussed with beck, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.33 2007/09/02 15:19:20 deraadt Exp $ */
d783 1
a783 1
	fprintf(stderr, "usage: %s [-bdDn]\n", __progname);
@


1.33
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.32 2007/02/27 02:10:58 beck Exp $ */
d783 1
a783 1
	fprintf(stderr, "usage: %s [-bdn]\n", __progname);
d794 1
a794 1
	int i, ch;
d796 1
a796 1
	while ((ch = getopt(argc, argv, "bdn")) != -1) {
d807 3
d819 3
@


1.32
log
@Flag day for spamd -
1) config files move to /etc/mail
2) -g option goes away in spamd-setup and spamd - greylisting is now the default
3) option change to spamd, -b addr becomes -l addr.
4) -b option in spamd-setup and spamd to turn on old blacklisting mode.

Man page shortly to be flensed to make this easier to explain
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.31 2007/02/25 22:59:38 millert Exp $ */
d314 1
a314 1
		argv = malloc(len * sizeof(char *));
d543 1
a543 1
	cl = malloc(((blc / 2) + 1) * sizeof(struct cidr));
@


1.31
log
@Add usage() and error out if given bogus arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.30 2007/02/24 19:28:13 millert Exp $ */
d44 1
a44 1
#define PATH_SPAMD_CONF		"/etc/spamd.conf"
d89 1
a89 1
int		  greyonly;
d783 1
a783 1
	fprintf(stderr, "usage: %s [-dgn]\n", __progname);
d796 1
a796 1
	while ((ch = getopt(argc, argv, "ndg")) != -1) {
d804 2
a805 2
		case 'g':
			greyonly = 1;
@


1.30
log
@When greylisting we don't actually need to use the <spamd> pf table.
We just do no-rdr for things in <spamd-white> and rdr the rest to spamdb.
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.29 2007/02/14 01:16:22 millert Exp $ */
d85 1
d91 2
d779 8
d808 1
d812 4
@


1.29
log
@Fix some realloc() off-by-one errors found by ray@@.
Also simplify fix_quoted_colons() to avoid realloc entirely since
the output buffer is at most 2x the length of the input buffer.
Parts adapted from a diff from tdeval@@.  OK ray@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.28 2007/02/09 19:12:29 millert Exp $ */
d88 1
d461 1
a461 1
			tmp = realloc(buf, bs + 8192 + 1);
d469 1
a469 1
			bs += 8192;
d725 1
d752 24
d785 1
a785 1
	while ((ch = getopt(argc, argv, "nd")) != -1) {
d793 3
d828 1
a828 1
				bls += 1024;
d842 1
a842 1
			blc += getlist(db_array, name, &blists[white],
d844 5
d851 3
a853 24
	for (i = 0; i < blc; i++) {
		struct cidr **cidrs, **tmp;

		if (blists[i].blc > 0) {
			cidrs = collapse_blacklist(blists[i].bl,
			   blists[i].blc);
			if (cidrs == NULL)
				errx(1, "malloc failed");
			if (dryrun)
				continue;

			if (configure_spamd(ent->s_port, blists[i].name,
			    blists[i].message, cidrs) == -1)
				err(1, "Can't connect to spamd on port %d",
				    ent->s_port);
			if (configure_pf(cidrs) == -1)
				err(1, "pfctl failed");
			tmp = cidrs;
			while (*tmp != NULL)
				free(*tmp++);
			free(cidrs);
			free(blists[i].bl);
		}
	}
@


1.28
log
@Fix off by one in blacklist memory allocation.  From tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.27 2006/05/11 15:37:21 dhill Exp $ */
d145 1
a145 1
		if (cs == cu) {
d345 2
a346 2
	size_t nbs, i, j = 0;
	char *newbuf, last, *tmp;
d348 2
a349 2
	nbs = strlen(buf) + 128;
	newbuf = malloc(nbs);
d370 1
a370 7
		if (j == nbs) {
			nbs += 128;
			tmp = realloc(newbuf, nbs);
			if (tmp == NULL)
				errx(1, "malloc failed");
			newbuf = tmp;
		}
@


1.27
log
@fix some type definitions

ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.26 2006/03/26 23:54:00 kjell Exp $ */
d545 1
a545 1
	cl = malloc((blc / 2) * sizeof(struct cidr));
@


1.26
log
@Remove an extraneous prototype
From Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.25 2006/03/26 19:56:21 kjell Exp $ */
d79 1
a79 1
struct bl	 *add_blacklist(struct bl *, int *, int *, gzFile, int);
d81 1
a81 1
struct cidr	**collapse_blacklist(struct bl *, int);
d344 2
a345 1
	int nbs = 0, i = 0, j = 0, in = 0;
d386 2
a387 1
	int i, n, bu = 0, bs = 0, len;
d444 1
a444 1
			/* fall through */
d457 1
a457 1
add_blacklist(struct bl *bl, int *blc, int *bls, gzFile gzf, int white)
d535 1
a535 1
collapse_blacklist(struct bl *bl, int blc)
d673 2
a674 1
	int blc, bls, fd, black = 0;
d751 1
a751 1
		fprintf(stderr, "%slist %s %d entries\n",
@


1.25
log
@More KNF. Prodding from ray@@
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.24 2006/03/26 19:18:49 kjell Exp $ */
a72 1
u_int32_t	  ptoa(char *);
@


1.24
log
@Get this closer to KNF (get rid of block-declared vars)
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.23 2006/03/26 05:21:28 kjell Exp $ */
d67 19
a85 23
u_int32_t	  imask(u_int8_t b);
u_int8_t	  maxblock(u_int32_t addr, u_int8_t bits);
u_int8_t	  maxdiff(u_int32_t a, u_int32_t b);
struct cidr	 *range2cidrlist(u_int32_t start, u_int32_t end);
void		  cidr2range(struct cidr cidr, u_int32_t *start, u_int32_t *end);
char		 *atop(u_int32_t addr);
u_int32_t	  ptoa(char *cp);
int		  parse_netblock(char *buf, struct bl *start, struct bl *end,
		    int white);
int		  open_child(char *file, char **argv);
int		  fileget(char *url);
int		  open_file(char *method, char *file);
char		 *fix_quoted_colons(char *buf);
void		  do_message(FILE *sdc, char *msg);
struct bl	 *add_blacklist(struct bl *bl, int *blc, int *bls, gzFile gzf,
		    int white);
int		  cmpbl(const void *a, const void *b);
struct cidr	**collapse_blacklist(struct bl *bl, int blc);
int		  configure_spamd(u_short dport, char *name, char *message,
		    struct cidr **blacklists);
int		  configure_pf(struct cidr **blacklists);
int		  getlist(char ** db_array, char *name, struct blacklist *blist,
		    struct blacklist *blistnew);
d98 1
a98 1
	return(j);
d104 2
d107 1
a107 1
		u_int32_t m = imask(bits - 1);
d110 1
a110 1
			return(bits);
d113 1
a113 1
	return(bits);
d120 1
d124 1
a124 1
		u_int32_t m = imask(bits);
d127 1
a127 1
			return(bits);
d130 1
a130 1
	return(bits);
d160 1
a160 1
	return(list);
d177 1
a177 1
	return(inet_ntoa(in));
d192 1
a192 1
		return(0);
d199 1
a199 1
			return(0);
d202 1
a202 1
			return(0);
d213 1
a213 1
			return(0);
d217 1
a217 1
			return(0);
d220 1
a220 1
			return(0);
d226 1
a226 1
			return(0);
d230 1
a230 1
		return(0);
d243 1
a243 1
	return(1);
d252 1
a252 1
		return(-1);
d257 1
a257 1
		return(-1);
d271 1
a271 1
	return(pdes[0]);
d289 1
a289 1
	return(open_child(PATH_FTP, argv));
d300 1
a300 1
		return(open(file, O_RDONLY));
d305 1
a305 1
			return(-1);
d308 1
a308 1
		return(i);
d324 1
a324 1
		return(i);
d327 1
a327 1
	return(-1); /* NOTREACHED */
d351 1
a351 1
		return(NULL);
d380 1
a380 1
	return(newbuf);
d388 1
d394 1
a394 1
		buf = msg+1;
a397 2
		int fd;

d514 1
a514 1
	return(bl);
d521 1
a521 1
		return(1);
d523 2
a524 2
		return(-1);
	return(0);
d539 2
d543 1
a543 1
		return(NULL);
d546 1
a546 1
		return(NULL);
d552 2
a553 2
		int laststate = state;
		u_int32_t addr = bl[i].addr;
d577 1
a577 1
	return(cl);
d590 1
a590 1
		return(-1);
d597 1
a597 1
		return(-1);
d601 1
a601 1
		return(-1);
d616 1
a616 1
	return(0);
d630 1
a630 1
			return(-1);
d635 1
a635 1
			return(-1);
d652 1
a652 1
			return(-1);
d664 1
a664 1
	return(0);
d733 1
a733 1
		return(0);
d751 1
a751 1
	return(black);
d845 1
a845 1
	return(0);
@


1.23
log
@KNF. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.22 2006/01/17 17:52:49 millert Exp $ */
d139 2
d143 2
a144 2
		u_int8_t maxsize = maxblock(start, 32);
		u_int8_t diff = maxdiff(start, end);
a147 2
			struct cidr *tmp;

d186 1
a196 2
		struct cidr c;

d290 1
a290 1
	return open_child(PATH_FTP, argv);
d297 2
a303 2
		int i;

a310 3
		char **ap, **argv;
		int len, i, oerrno;

d347 1
a347 1
	char *newbuf, last;
d352 1
a352 1
		return NULL;
a371 2
			char *tmp;

d388 1
a388 1
	char *buf = NULL, last;
a408 2
				char *tmp;

d461 2
a462 1
	char *buf = NULL;
a466 2
			char *tmp;

a491 2
			struct bl *tmp;

d493 2
a494 2
			tmp = realloc(bl, *bls * sizeof(struct bl));
			if (tmp == NULL) {
d499 1
a499 1
			bl = tmp;
d505 2
a506 2
				*blc+=2;
			start = i+1;
@


1.22
log
@Include <sys/param.h> to get MAX macro
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.21 2005/03/02 16:45:30 dhartmei Exp $ */
d67 8
a74 8
u_int32_t	imask(u_int8_t b);
u_int8_t	maxblock(u_int32_t addr, u_int8_t bits);
u_int8_t	maxdiff(u_int32_t a, u_int32_t b);
struct cidr	*range2cidrlist(u_int32_t start, u_int32_t end);
void		cidr2range(struct cidr cidr, u_int32_t *start, u_int32_t *end);
char		*atop(u_int32_t addr);
u_int32_t	ptoa(char *cp);
int		parse_netblock(char *buf, struct bl *start, struct bl *end,
d76 6
a81 6
int		open_child(char *file, char **argv);
int		fileget(char *url);
int		open_file(char *method, char *file);
char		*fix_quoted_colons(char *buf);
void		do_message(FILE *sdc, char *msg);
struct bl	*add_blacklist(struct bl *bl, int *blc, int *bls, gzFile gzf,
d83 1
a83 1
int		cmpbl(const void *a, const void *b);
d85 1
a85 1
int		configure_spamd(u_short dport, char *name, char *message,
d87 2
a88 2
int		configure_pf(struct cidr **blacklists);
int		getlist(char ** db_array, char *name, struct blacklist *blist,
d91 2
a92 2
int		debug;
int		dryrun;
d112 1
a112 1
			return (bits);
d128 1
a128 1
			return (bits);
d527 1
a527 1
	return (bl);
d557 1
a557 1
		return (NULL);
d588 1
a588 1
	return (cl);
d856 1
a856 1
	return (0);
@


1.21
log
@process the last line of an address list even if it's not terminated
by newline. found by Rod Whitworth. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.20 2004/09/16 05:35:24 deraadt Exp $ */
d27 1
a27 1
#include <sys/types.h>
@


1.20
log
@clean C for a change
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.19 2004/06/29 11:19:07 mickey Exp $ */
d476 1
a476 1
			tmp = realloc(buf, bs + 8192);
d499 1
a499 1
	for (i = 0; i < bu; i++) {
d512 1
a512 1
		if (buf[i] == '\n') {
@


1.19
log
@absolutely no need to include machine/endian.h after sys/types.h and sys/types.h after sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.18 2004/04/28 07:32:57 deraadt Exp $ */
d77 1
a77 1
int		fetch(char *url);
a180 10
u_int32_t
ptoa(char *cp)
{
	struct in_addr in;

	memset(&in, 0, sizeof(in));
	(void) inet_aton(cp, &in);
	return ntohl(in.s_addr);
}

a250 1
	pid_t pid;
d255 1
a255 1
	switch (pid = fork()) {
d277 1
a277 1
fetch(char *url)
d279 8
a286 1
	char *argv[6]= {"ftp", "-V", "-o", "-", url, NULL};
d308 1
a308 1
		i = fetch(url);
a637 1
	pid_t pid;
d642 1
a642 1
		switch (pid = fork()) {
@


1.18
log
@fd leaks; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.17 2004/02/26 08:18:56 deraadt Exp $ */
a39 1
#include <machine/endian.h>
@


1.17
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.16 2004/01/21 08:07:41 deraadt Exp $ */
d615 2
a616 1
	if (sdc == NULL)
d618 1
@


1.16
log
@New spamd configuration method.  Many people have trouble with the spam
RBL sites being slow, so now we will provide the maps ourselves through
our www mirrors around the world.  We can also now write our own internal
translators for maps that are in bad formats, and place them into the www
space in the correct format.  tested by beck, djm
@
text
@d1 2
a2 1
/*	$OpenBSD: spamd-setup.c,v 1.15 2004/01/21 02:49:34 deraadt Exp $ */
d269 2
d282 1
d648 2
d661 1
d665 2
a666 1
		if (pf == NULL)
d668 1
@


1.15
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.14 2003/08/22 21:50:34 david Exp $ */
d40 1
d64 1
d81 1
a81 1
struct bl	*add_blacklist(struct bl *bl, int *blc, int *bls, int fd,
d91 3
d289 3
d467 1
a467 1
add_blacklist(struct bl *bl, int *blc, int *bls, int fd, int white)
d473 1
a473 1
		/* read in fd, then parse */
d489 1
a489 1
		n = read(fd, buf + bu, bs - bu);
d515 1
a515 1
			if (parse_netblock (buf + start,
d680 1
d719 2
a720 2
		errx(1, "No file given for %slist %s", black?"black":"white",
		    name);
d727 1
a727 1
			    file, method ? method:"file");
d730 3
d734 2
a735 1
	bl = add_blacklist(bl, &blc, &bls, fd, !black);
d754 3
d767 14
a780 1
	int i;
d783 1
a783 1
		errx(1, "Can't find service \"spamd-cfg\" in /etc/services");
d835 3
@


1.14
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.13 2003/07/29 18:39:23 deraadt Exp $ */
d121 1
d202 1
d261 1
a261 1
	switch(pid = fork()) {
d397 4
a400 1
		/* message isn't quoted - try to open a local
a402 2
		int fd;

d432 1
a432 1
		switch(buf[i]) {
a542 1
	struct cidr ** cl;
d544 1
d562 1
a562 1
			i++ ;
d588 1
a588 1
	int lport = IPPORT_RESERVED - 1;
a590 1
	int s;
d634 1
a634 1
		switch(pid = fork()) {
d655 1
d748 1
d750 1
a750 2
	char **db_array, *buf;
	char *name;
a751 1
	struct servent *ent;
d779 1
d800 1
d807 1
a807 1
					    blists[i].message, cidrs) == -1)
@


1.13
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.12 2003/07/06 21:57:27 deraadt Exp $ */
d330 1
a330 1
 * without having to see the \C bletchery in a configuration file tha
d531 2
a532 2
 * collapse_blacklist takes blacklist/whitelist enties sorts, removes
 * ovelaps and whitelist portions, and returns netblocks to blacklis
@


1.12
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.11 2003/06/11 14:24:46 deraadt Exp $ */
d798 1
a798 1
			cidrs = collapse_blacklist(blists[i].bl, 
@


1.11
log
@ansi cleanup; ok ian markus
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.10 2003/05/16 01:01:33 beck Exp $ */
d64 24
@


1.10
log
@use inet_net_pton, and fix probelem where spamd-setup would crash on a file
consisting only of invalid input
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.9 2003/04/28 19:13:51 deraadt Exp $ */
d655 1
a655 2
	}
	else if (cgetcap(buf, "white", ':') != NULL) {
d661 1
a661 2
	}
	else
@


1.9
log
@return from main
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.8 2003/03/13 21:20:42 beck Exp $ */
d177 3
a179 1
		if (inet_pton(AF_INET, astring, &c.addr) != 1)
d190 4
a193 1
		if (inet_pton(AF_INET, astring, &start->addr) != 1)
d196 2
a197 1
		if (inet_pton(AF_INET, astring2, &end->addr) != 1)
d204 3
a206 1
		if (inet_pton(AF_INET, astring, &start->addr) != 1)
d519 2
d775 17
a791 14
		cidrs = collapse_blacklist(blists[i].bl, blists[i].blc);
		if (cidrs == NULL)
			errx(1, "malloc failed");
		if (configure_spamd(ent->s_port, blists[i].name,
		    blists[i].message, cidrs) == -1)
			err(1, "Can't connect to spamd on port %d",
			    ent->s_port);
		if (configure_pf(cidrs) == -1)
			err(1, "pfctl failed");
		tmp = cidrs;
		while (*tmp != NULL)
			free(*tmp++);
		free(cidrs);
		free(blists[i].bl);
@


1.8
log
@make spamd-setup/spamd use/require a reserved source port for the
configuration connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.7 2003/03/10 19:36:13 deraadt Exp $ */
d780 1
a780 1
	exit(0);
@


1.7
log
@nothing of import
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.6 2003/03/10 19:35:21 deraadt Exp $ */
d551 1
d556 1
a556 1
	s = socket(AF_INET, SOCK_STREAM, 0);
@


1.6
log
@fix exit code, stupid bob, spotted by lebel
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.5 2003/03/09 19:22:26 beck Exp $ */
d120 1
a120 1
				errx(1, "Malloc failed");
d277 1
a277 1
			errx(1, "Malloc failed");
d340 1
a340 1
				errx(1, "Malloc failed");
d377 1
a377 1
					errx(1, "Malloc failed");
d661 1
a661 1
		errx(1, "Malloc failed");
d669 1
a669 1
		errx(1, "Malloc failed");
d677 1
a677 1
		errx(1, "Malloc failed");
d726 1
a726 1
		errx(1, "Malloc failed");
d748 1
a748 1
					errx(1, "Malloc failed");
d766 1
a766 1
			errx(1, "Malloc failed");
@


1.5
log
@Fix a few typos, Make spamd and spamd-setup use /etc/services to find
their ports. Adds "spamd" and "spamd-cfg" services to /etc/services.
Mostly from Daniel Lucq <daniel@@lucq.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.4 2003/03/09 02:50:54 beck Exp $ */
d779 1
a779 1
	exit(1);
@


1.4
log
@missed memset, found by dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.3 2003/03/08 22:06:02 deraadt Exp $ */
d5 1
a5 1
 * Redistribution and use in source and binary forms, with or withou
d8 1
a8 1
 * 1. Redistributions of source code must retain the above copyrigh
d10 1
a10 1
 * 2. Redistributions in binary form must reproduce the above copyrigh
d18 1
a18 1
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BU
d21 1
a21 1
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TOR
d38 2
a44 1
#define SPAMD_CONFIG_PORT	8026
d716 5
d767 1
a767 1
		if (configure_spamd(SPAMD_CONFIG_PORT, blists[i].name,
d770 1
a770 1
			    SPAMD_CONFIG_PORT);
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.2 2003/03/08 18:29:16 deraadt Exp $ */
d751 1
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: spamd-setup.c,v 1.1 2003/03/08 18:17:04 beck Exp $ */
d335 1
d366 1
d373 1
d432 1
d520 1
@


1.1
log
@spamd-setup, in c. ok deraadt@@, he wants to clean in situ.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 5
a43 5
#define PATH_FTP "/usr/bin/ftp"
#define PATH_PFCTL "/sbin/pfctl"
#define PATH_SPAMD_CONF "/etc/spamd.conf"
#define SPAMD_ARG_MAX 256 /* max # of args to an exec*/
#define SPAMD_CONFIG_PORT 8026
d57 2
a58 2
	char * name;
	char * message;
d65 2
a66 1
imask(u_int8_t b) {
d69 1
d73 1
a73 1
};
d76 2
a77 1
maxblock (u_int32_t addr, u_int8_t bits) {
d80 1
d89 2
a90 1
maxdiff (u_int32_t a, u_int32_t b) {
d92 1
a93 1
	
d104 3
a106 2
range2cidrlist (u_int32_t start, u_int32_t end) {
	struct cidr * list = NULL;
d108 1
d112 1
d115 4
a118 3
			struct cidr * tmp;
			tmp = realloc( list, (cs + 32) * sizeof(struct cidr));
			if (tmp == NULL) {
a119 1
			}
d134 2
a135 1
cidr2range (struct cidr cidr, u_int32_t *start, u_int32_t *end) {
d141 2
a142 1
atop(u_int32_t addr) {
d144 1
d151 2
a152 1
ptoa(char * cp) {
d154 1
d161 2
a162 1
parse_netblock(char *buf, struct bl * start, struct bl * end, int white) {
d185 1
a185 1
			  astring, astring2) == 2) {
d203 1
d209 1
a209 2
	}
	else  {
d219 2
a220 1
open_child(char *file, char **argv) {
d223 1
d234 1
a234 1
		        close(pdes[1]);
a237 1
		
d244 3
a246 1
int fetch(char *url) {
d248 1
d252 3
a254 1
int open_file(char * method, char * file) {
d256 2
a257 1
	if ((method == NULL) || (strcmp(method, "file") == 0 ))
d259 2
a260 2
	if((strcmp(method, "http") == 0)
	   || strcmp(method, "ftp") == 0) {
d262 1
d269 1
a269 2
	}
	if (strcmp(method, "exec") == 0) {
d272 1
a272 1
		
d278 1
a278 1
			     (*ap = strsep(&file, " \t")) != NULL;) {
d291 1
a291 1
}	
d293 2
a294 1
/* fix_quoted_colons walks through a buffer returned by cgetent.  We
d306 5
a310 5
fix_quoted_colons(char *buf) {
	char * newbuf;
	char last;
	int nbs=0, i=0, j=0, in = 0;
	
d346 1
a346 1
	
d348 2
a349 1
do_message(FILE *sdc, char * msg) {
d377 1
a377 1
			
d417 1
a417 1
	
d420 2
a421 1
add_blacklist(struct bl *bl, int *blc, int *bls , int fd, int white) {
d423 1
a423 1
	char * buf = NULL;
d440 1
a440 1
		
d454 2
a455 1
			struct bl * tmp;
d484 2
a485 1
cmpbl(const void * a, const void * b) {
a497 1
 *
d499 3
a501 1
struct cidr ** collapse_blacklist(struct bl * bl, int blc) {
d506 1
a506 1
	cl = malloc((blc / 2)  * sizeof(struct cidr));
d543 2
a544 2
     struct cidr **blacklists) {
	int s;
d547 2
a548 1
	
d580 2
a581 1
configure_pf(struct cidr **blacklists) {
d622 3
a624 2
getlist(char ** db_array, char * name, struct blacklist *blist,
    struct blacklist *blistnew){
d648 1
a648 1
	
d669 1
a669 1
		     name);
d676 1
a676 1
			     file, method?method:"file");
d682 2
a683 2
		warn("Could not add %slist %s", black?"black":"white",
		     name );
d703 2
a704 1
main(int argc, char *argv[]) {
d716 1
a716 1
	
d721 1
a721 1
	
d758 1
a758 1
			     SPAMD_CONFIG_PORT);
@

