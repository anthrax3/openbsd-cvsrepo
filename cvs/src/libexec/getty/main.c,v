head	1.48;
access;
symbols
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.14
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.18
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.16
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.14
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.12
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.10
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.8
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2017.05.29.04.40.35;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	hJdZdjEuaDkXxQsT;

1.47
date	2017.05.28.08.51.06;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	VpdSNBMbDkGBPSqq;

1.46
date	2017.05.27.09.34.55;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	cNzMTR11MQASaOqK;

1.45
date	2017.05.27.09.31.13;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	1wlHvGvp9xhwCqUZ;

1.44
date	2017.05.27.09.28.28;	author tedu;	state Exp;
branches;
next	1.43;
commitid	lsaWRurHHrT0z7mu;

1.43
date	2017.01.23.04.57.13;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	TwyNwwchsz0e1xBf;

1.42
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.41;
commitid	JEVxsRygqcjPtWTf;

1.41
date	2015.11.16.18.37.30;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	1CPn3awiBdE7HveB;

1.40
date	2015.11.06.16.42.30;	author tedu;	state Exp;
branches;
next	1.39;
commitid	C6nV2zZZTWJVgVmc;

1.39
date	2015.11.06.16.39.53;	author tedu;	state Exp;
branches;
next	1.38;
commitid	ZHxIsO8HBmNo5eYO;

1.38
date	2015.10.16.22.25.50;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	4S6RMne4jtggBCvX;

1.37
date	2015.07.16.04.31.25;	author tedu;	state Exp;
branches;
next	1.36;
commitid	C0qgiDHJ28LsAZt3;

1.36
date	2015.04.14.02.24.17;	author millert;	state Exp;
branches;
next	1.35;
commitid	DXNTmonwtOp0FN4i;

1.35
date	2015.01.16.05.53.49;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	RBlqkOZMwWRtg8l2;

1.34
date	2014.11.19.13.35.37;	author krw;	state Exp;
branches;
next	1.33;
commitid	mAzZN8w74KfuFeKi;

1.33
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.32;
commitid	G35ycnLxaVis5TX9;

1.32
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.04.22.23.18;	author benno;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.02.09.10.13.34;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.29.18.39.22;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.05.17.02.08;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.25.21.11.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.22.06.35.43;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.29.20.35.55;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.19.22.35.04;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.08.21.18.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.31.19.13.36;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.28.19.34.28;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.19.18.02.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.07.17.02.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.12.09.20.20.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.12.07.19.24.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.10.08.06.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.20.07.39.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.05.23.37.35;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.20.36.25;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.02.08.12.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.06.08.43.41;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.17.19.33.53;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.12.10.07.58.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.12.10.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.22.10.39.28;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.11.27.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@do not need dev[] wasting bss space
@
text
@/*	$OpenBSD: main.c,v 1.47 2017/05/28 08:51:06 deraadt Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <sys/resource.h>
#include <sys/utsname.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <stdio.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "gettytab.h"
#include "pathnames.h"
#include "extern.h"

/*
 * Set the amount of running time that getty should accumulate
 * before deciding that something is wrong and exit.
 */
#define GETTY_TIMEOUT	60 /* seconds */

struct termios tmode, omode;

int crmod, digit, lower, upper;

char	hostname[HOST_NAME_MAX+1];
char	globalhostname[HOST_NAME_MAX+1];
struct	utsname kerninfo;
char	name[LOGIN_NAME_MAX];
char	ttyn[32];
char	*portselector(void);

#define	OBUFSIZ		128
#define	TABBUFSIZ	512

char	defent[TABBUFSIZ];
char	tabent[TABBUFSIZ];

char	*env[128];

char partab[] = {
	0001,0201,0201,0001,0201,0001,0001,0201,
	0202,0004,0003,0205,0005,0206,0201,0001,
	0201,0001,0001,0201,0001,0201,0201,0001,
	0001,0201,0201,0001,0201,0001,0001,0201,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0201
};

#define	ERASE	tmode.c_cc[VERASE]
#define	KILL	tmode.c_cc[VKILL]
#define	EOT	tmode.c_cc[VEOF]

static void
dingdong(int signo)
{
	tmode.c_ispeed = tmode.c_ospeed = 0;
	(void)tcsetattr(0, TCSANOW, &tmode);
	_exit(1);
}

volatile sig_atomic_t interrupt_flag;

static void
interrupt(int signo)
{
	int save_errno = errno;

	interrupt_flag = 1;
	signal(SIGINT, interrupt);
	errno = save_errno;
}

/*
 * Action to take when getty is running too long.
 */
static void
timeoverrun(int signo)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	syslog_r(LOG_ERR, &sdata,
	    "getty exiting due to excessive running time");
	_exit(1);
}

static int	getname(void);
static void	oflush(void);
static void	prompt(void);
static void	putchr(int);
static void	putf(char *);
static void	putpad(char *);
static void	xputs(char *);

int
main(int argc, char *argv[])
{
	extern char **environ;
	char *tname;
	int repcnt = 0, failopenlogged = 0;
	struct rlimit limit;
	int off = 0;

	signal(SIGINT, SIG_IGN);
/*
	signal(SIGQUIT, SIG_DFL);
*/
	openlog("getty", LOG_ODELAY|LOG_CONS|LOG_PID, LOG_AUTH);
	gethostname(hostname, sizeof(hostname));
	if (hostname[0] == '\0')
		strlcpy(hostname, "Amnesiac", sizeof hostname);
	uname(&kerninfo);

	/*
	 * Limit running time to deal with broken or dead lines.
	 */
	(void)signal(SIGXCPU, timeoverrun);
	limit.rlim_max = RLIM_INFINITY;
	limit.rlim_cur = GETTY_TIMEOUT;
	(void)setrlimit(RLIMIT_CPU, &limit);

	ioctl(0, FIOASYNC, &off);	/* turn off async mode */

	/*
	 * The following is a work around for vhangup interactions
	 * which cause great problems getting window systems started.
	 * If the tty line is "-", we do the old style getty presuming
	 * that the file descriptors are already set up for us.
	 * J. Gettys - MIT Project Athena.
	 */
	if (argc <= 2 || strcmp(argv[2], "-") == 0) {
		if (pledge("stdio rpath proc exec tty", NULL) == -1) {
			syslog(LOG_ERR, "pledge: %m");
			exit(1);
		}

		if ((tname = ttyname(0)) == NULL) {
			syslog(LOG_ERR, "stdin: %m");
			exit(1);
		}
		if (strlcpy(ttyn, tname, sizeof(ttyn)) >= sizeof(ttyn)) {
			errno = ENAMETOOLONG;
			syslog(LOG_ERR, "%s: %m", tname);
			exit(1);
		}
	} else {
		int i;

		snprintf(ttyn, sizeof ttyn, "%s%s", _PATH_DEV, argv[2]);
		if (strcmp(argv[0], "+") != 0) {
			chown(ttyn, 0, 0);
			chmod(ttyn, 0600);
			revoke(ttyn);
			/*
			 * Delay the open so DTR stays down long enough to be detected.
			 */
			sleep(2);
			while ((i = open(ttyn, O_RDWR)) == -1) {
				if ((repcnt % 10 == 0) &&
				    (errno != ENXIO || !failopenlogged)) {
					syslog(LOG_ERR, "%s: %m", ttyn);
					closelog();
					failopenlogged = 1;
				}
				repcnt++;
				sleep(60);
			}
			login_tty(i);
		}
	}

	if (pledge("stdio rpath proc exec tty", NULL) == -1) {
		syslog(LOG_ERR, "pledge: %m");
		exit(1);
	}

	/* Start with default tty settings */
	if (tcgetattr(0, &tmode) < 0) {
		syslog(LOG_ERR, "%s: %m", ttyn);
		exit(1);
	}
	omode = tmode;

	gettable("default", defent);
	gendefaults();
	tname = "default";
	if (argc > 1)
		tname = argv[1];
	for (;;) {
		gettable(tname, tabent);
		if (OPset || EPset || APset)
			APset++, OPset++, EPset++;
		setdefaults();
		(void)tcflush(0, TCIOFLUSH);	/* clear out the crap */
		ioctl(0, FIONBIO, &off);	/* turn off non-blocking mode */

		if (IS)
			cfsetispeed(&tmode, IS);
		else if (SP)
			cfsetispeed(&tmode, SP);
		if (OS)
			cfsetospeed(&tmode, OS);
		else if (SP)
			cfsetospeed(&tmode, SP);
		setflags(0);
		setchars();
		if (tcsetattr(0, TCSANOW, &tmode) < 0) {
			syslog(LOG_ERR, "%s: %m", ttyn);
			exit(1);
		}
		if (AB) {
			tname = autobaud();
			continue;
		}
		if (PS) {
			tname = portselector();
			continue;
		}
		if (CL && *CL)
			putpad(CL);
		strlcpy(globalhostname, HN, sizeof(globalhostname));
		if (IM && *IM)
			putf(IM);
		if (TO) {
			signal(SIGALRM, dingdong);
			alarm(TO);
		}
		if (getname()) {
			int i;

			oflush();
			alarm(0);
			signal(SIGALRM, SIG_DFL);
			if (name[0] == '-') {
				xputs("user names may not start with '-'.");
				continue;
			}
			if (!(upper || lower || digit))
				continue;
			setflags(2);
			if (crmod) {
				tmode.c_iflag |= ICRNL;
				tmode.c_oflag |= ONLCR;
			}
			if (UC) {
				tmode.c_iflag |= IUCLC;
				tmode.c_oflag |= OLCUC;
				tmode.c_lflag |= XCASE;
			}
			if (lower || LC) {
				tmode.c_iflag &= ~IUCLC;
				tmode.c_oflag &= ~OLCUC;
				tmode.c_lflag &= ~XCASE;
			}
			if (tcsetattr(0, TCSANOW, &tmode) < 0) {
				syslog(LOG_ERR, "%s: %m", ttyn);
				exit(1);
			}
			signal(SIGINT, SIG_DFL);
			for (i = 0; environ[i] != NULL; i++)
				env[i] = environ[i];
			makeenv(&env[i]);

			limit.rlim_max = RLIM_INFINITY;
			limit.rlim_cur = RLIM_INFINITY;
			(void)setrlimit(RLIMIT_CPU, &limit);
			execle(LO, "login", "-p", "--", name, NULL, env);
			syslog(LOG_ERR, "%s: %m", LO);
			exit(1);
		}
		alarm(0);
		signal(SIGALRM, SIG_DFL);
		signal(SIGINT, SIG_IGN);
		if (NX && *NX)
			tname = NX;
	}
}

static int
getname(void)
{
	unsigned char cs;
	int c, r;
	char *np;

	/*
	 * Interrupt may happen if we use CBREAK mode
	 */
	signal(SIGINT, interrupt);
	setflags(1);
	prompt();
	if (PF > 0) {
		oflush();
		sleep(PF);
		PF = 0;
	}
	if (tcsetattr(0, TCSANOW, &tmode) < 0) {
		syslog(LOG_ERR, "%s: %m", ttyn);
		exit(1);
	}
	crmod = digit = lower = upper = 0;
	np = name;
	for (;;) {
		oflush();
		r = read(STDIN_FILENO, &cs, 1);
		if (r <= 0) {
			if (r == -1 && errno == EINTR && interrupt_flag) {
				interrupt_flag = 0;
				return (0);
			}
			exit(0);
		}
		/* Handle 'printables' we cannot erase */
		if (cs == CTRL('L') || cs == CTRL('K'))
			continue;
		if (cs == '\t')
			cs = ' ';
		if ((c = cs&0177) == 0)
			return (0);

		if (c == EOT)
			exit(1);
		if (c == '\r' || c == '\n' || np >= name + sizeof name -1) {
			putf("\r\n");
			break;
		}
		if (islower(c))
			lower = 1;
		else if (isupper(c))
			upper = 1;
		else if (c == ERASE || c == '\b') {
			if (np > name) {
				if (*--np == '\033')
					xputs("\b\b  \b\b");
				else if (isprint(*np))
					xputs("\b \b");
			}
			continue;
		} else if (c == KILL) {
			putchr('\r');
			putf(LM);
			while (np > name) {
				if (*--np == '\033')
					xputs("  ");
				else if (isprint(*np))
					putchr(' ');
			}
			putchr('\r');
			prompt();
			np = name;
			continue;
		} else if (isdigit(c))
			digit++;
		if (IG && (c <= ' ' || c > 0176))
			continue;
		*np++ = c;
		if (c == '\033') {
			putchr('^');
			putchr('[');
		} else
			putchr(cs);
	}
	signal(SIGINT, SIG_IGN);
	if (interrupt_flag) {
		interrupt_flag = 0;
		return (0);
	}
	*np = 0;
	if (c == '\r')
		crmod = 1;
	return (1);
}

static void
putpad(char *s)
{
	int pad = 0;
	speed_t ospeed = cfgetospeed(&tmode);

	if (isdigit((unsigned char)*s)) {
		while (isdigit((unsigned char)*s)) {
			pad *= 10;
			pad += *s++ - '0';
		}
		pad *= 10;
		if (*s == '.' && isdigit((unsigned char)s[1])) {
			pad += s[1] - '0';
			s += 2;
		}
	}

	xputs(s);
	/*
	 * If no delay needed, or output speed is
	 * not comprehensible, then don't try to delay.
	 */
	if (pad == 0 || ospeed <= 0)
		return;

	/*
	 * Round up by a half a character frame, and then do the delay.
	 * Too bad there are no user program accessible programmed delays.
	 * Transmitting pad characters slows many terminals down and also
	 * loads the system.
	 */
	pad = (pad * ospeed + 50000) / 100000;
	while (pad--)
		putchr(*PC);
}

static void
xputs(char *s)
{
	while (*s)
		putchr(*s++);
}

char	outbuf[OBUFSIZ];
int	obufcnt = 0;

static void
putchr(int cc)
{
	char c;

	c = cc;
	if (!NP) {
		c |= partab[c&0177] & 0200;
		if (OP)
			c ^= 0200;
	}
	if (!UB) {
		outbuf[obufcnt++] = c;
		if (obufcnt >= OBUFSIZ)
			oflush();
	} else
		write(STDOUT_FILENO, &c, 1);
}

static void
oflush(void)
{
	if (obufcnt)
		write(STDOUT_FILENO, outbuf, obufcnt);
	obufcnt = 0;
}

static void
prompt(void)
{

	putf(LM);
	if (CO)
		putchr('\n');
}

static void
putf(char *cp)
{
	char *slash, db[100];
	time_t t;

	while (*cp) {
		if (*cp != '%') {
			putchr(*cp++);
			continue;
		}
		switch (*++cp) {

		case 't':
			slash = strrchr(ttyn, '/');
			if (slash == (char *) 0)
				xputs(ttyn);
			else
				xputs(&slash[1]);
			break;

		case 'h':
			xputs(globalhostname);
			break;

		case 'd': {
			(void)time(&t);
			(void)strftime(db, sizeof(db),
			    "%l:%M%p on %A, %d %B %Y", localtime(&t));
			xputs(db);
			break;
		}

		case 's':
			xputs(kerninfo.sysname);
			break;

		case 'm':
			xputs(kerninfo.machine);
			break;

		case 'r':
			xputs(kerninfo.release);
			break;

		case 'v':
			xputs(kerninfo.version);
			break;

		case '%':
			putchr('%');
			break;
		}
		cp++;
	}
}
@


1.47
log
@Do a better job of not printing sequences we cannot reverse in DELETE or
KILL.  Therefore we can do a better job cleaning up.
testing by benno
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2017/05/27 09:34:55 deraadt Exp $	*/
a67 1
char	dev[] = _PATH_DEV;
d197 1
a197 1
		snprintf(ttyn, sizeof ttyn, "%s%s", dev, argv[2]);
@


1.46
log
@Stop echoing ANSI sequences back to the console, by expanding ESC character
to literal ^[.  This makes getty interaction appear more like login, and
stops a mid-ANSI sequence parsing problem that messed up login, making it
freeze the session until timeout.
ok tedu fcambus
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2017/05/27 09:31:13 deraadt Exp $	*/
d362 5
d382 4
a385 2
				np--;
				xputs("\b \b");
a388 1
			putchr(cs);
d390 8
a397 3
			/* this is the way they do it down under ... */
			if (np > name)
				xputs("                                     \r");
@


1.45
log
@Stop supporting primordial # (erase) and @@ (kill) sequences.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2017/05/27 09:28:28 tedu Exp $	*/
d395 5
a399 1
		putchr(cs);
@


1.44
log
@remove the getname() code trying to handle baud < 1200 terminals.
leave the special down under code until somebody unearths why it exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2017/01/23 04:57:13 deraadt Exp $	*/
d375 1
a375 1
		else if (c == ERASE || c == '#' || c == '\b') {
d381 1
a381 1
		} else if (c == KILL || c == '@@') {
@


1.43
log
@pledge a tiny bit later.  This results in the specified tty being
opened before the first pledge call.
testing by tb and benno and others
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2016/03/16 15:41:10 krw Exp $	*/
d378 1
a378 4
				if (cfgetospeed(&tmode) >= 1200)
					xputs("\b \b");
				else
					putchr(cs);
a383 2
			if (cfgetospeed(&tmode) < 1200)
				putchr('\n');
d385 1
a385 1
			else if (np > name)
@


1.42
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2015/11/16 18:37:30 deraadt Exp $	*/
a172 5
	if (pledge("stdio rpath wpath fattr proc exec tty", NULL) == -1) {
		syslog(LOG_ERR, "pledge: %m");
		exit(1);
	}

d181 5
@


1.41
log
@Observe that FIOASYNC clearing for stdin is only done in the case where
getty receives the fd from init, so hoist it upwards.  Since revoke(2)
is now allowed by pledge "rpath tty", the pledges can be hoisted much
higher.
ok millert semarie tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2015/11/06 16:42:30 tedu Exp $	*/
d309 1
a309 1
			for (i = 0; environ[i] != (char *)0; i++)
d316 1
a316 1
			execle(LO, "login", "-p", "--", name, (char *)0, env);
@


1.40
log
@further PPP reduction, hint from sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2015/11/06 16:39:53 tedu Exp $	*/
d171 7
a219 1
	ioctl(0, FIOASYNC, &off);	/* turn off async mode */
d221 1
a221 1
	if (pledge("stdio rpath fattr proc exec tty", NULL) == -1) {
@


1.39
log
@remove ppplogin support. ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2015/10/16 22:25:50 deraadt Exp $	*/
a58 10

/* defines for auto detection of incoming PPP calls (->PAP/CHAP) */

#define PPP_FRAME	    0x7e  /* PPP Framing character */
#define PPP_STATION	    0xff  /* "All Station" character */
#define PPP_ESCAPE	    0x7d  /* Escape Character */
#define PPP_CONTROL	    0x03  /* PPP Control Field */
#define PPP_CONTROL_ESCAPED 0x23  /* PPP Control Field, escaped */
#define PPP_LCP_HI	    0xc0  /* LCP protocol - high byte */
#define PPP_LCP_LOW	    0x21  /* LCP protocol - low byte */
@


1.38
log
@Hoist clearing of FIOASYNC to much earlier, then getty can use
pledge "stdio rpath fattr proc exec tty".
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2015/07/16 04:31:25 tedu Exp $	*/
d161 1
a161 1
	int rval, off = 0;
d281 1
a281 8
		if ((rval = getname()) == 2) {
			oflush();
			alarm(0);
			signal(SIGALRM, SIG_DFL);
			execle(PP, "ppplogin", ttyn, (char *) 0, env);
			syslog(LOG_ERR, "%s: %m", PP);
			exit(1);
		} else if (rval) {
a334 1
	int ppp_state = 0, ppp_connection = 0;
a368 27
		/*
		 * PPP detection state machine..
		 * Look for sequences:
		 * PPP_FRAME, PPP_STATION, PPP_ESCAPE, PPP_CONTROL_ESCAPED or
		 * PPP_FRAME, PPP_STATION, PPP_CONTROL (deviant from RFC)
		 * See RFC1662.
		 * Derived from code from Michael Hancock <michaelh@@cet.co.jp>
		 * and Erik 'PPP' Olson <eriko@@wrq.com>
		 */
		if (PP && cs == PPP_FRAME) {
			ppp_state = 1;
		} else if (ppp_state == 1 && cs == PPP_STATION) {
			ppp_state = 2;
		} else if (ppp_state == 2 && cs == PPP_ESCAPE) {
			ppp_state = 3;
		} else if ((ppp_state == 2 && cs == PPP_CONTROL) ||
		    (ppp_state == 3 && cs == PPP_CONTROL_ESCAPED)) {
			ppp_state = 4;
		} else if (ppp_state == 4 && cs == PPP_LCP_HI) {
			ppp_state = 5;
		} else if (ppp_state == 5 && cs == PPP_LCP_LOW) {
			ppp_connection = 1;
			break;
		} else {
			ppp_state = 0;
		}

d414 1
a414 1
	return (1 + ppp_connection);
@


1.37
log
@remove ancient support for edited hostnames. ok deraadt (long ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2015/04/14 02:24:17 millert Exp $	*/
d161 1
a161 1
	int rval;
d223 6
a242 2
		int off;

a246 1
		off = 0;
a248 1
		ioctl(0, FIOASYNC, &off);	/* ditto for async mode */
@


1.36
log
@Log a more useful error message if ttyname() fails.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2015/01/16 05:53:49 deraadt Exp $	*/
d75 1
d272 1
a272 1
		edithost(HE);
a535 1
	extern char editedhost[];
d555 1
a555 1
			xputs(editedhost);
@


1.35
log
@adjust to HOST_NAME_MAX+1 & LOGIN_NAME_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2014/11/19 13:35:37 krw Exp $	*/
d188 9
a196 1
		snprintf(ttyn, sizeof ttyn, "%s", ttyname(0));
@


1.34
log
@Nuke yet more obvious #include duplications.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2014/11/18 20:51:00 krw Exp $	*/
a31 1
#include <sys/param.h>
d47 1
d74 1
a74 1
char	hostname[MAXHOSTNAMELEN];
d76 1
a76 1
char	name[MAXLOGNAME];
@


1.33
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2013/11/27 21:25:25 deraadt Exp $	*/
a42 1
#include <fcntl.h>
@


1.32
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2013/06/04 22:23:18 benno Exp $	*/
a47 1
#include <time.h>
@


1.31
log
@do not go into upper to lower case translation mode when a all-caps
username has been entered.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2009/10/27 23:59:31 deraadt Exp $	*/
d449 2
a450 2
	if (isdigit(*s)) {
		while (isdigit(*s)) {
d455 1
a455 1
		if (*s == '.' && isdigit(s[1])) {
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2008/02/09 10:13:34 mbalmer Exp $	*/
d296 1
a296 1
			if (upper || UC) {
a439 4
	if (upper && !lower && !LC || UC)
		for (np = name; *np; np++)
			if (isupper(*np))
				*np = tolower(*np);
@


1.29
log
@Remove an old workaround that was needed in SCCS times (%M% expanding to the
filename).

ok mikeb, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2003/07/29 18:39:22 deraadt Exp $	*/
a30 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)main.c	8.1 (Berkeley) 6/20/93";*/
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2003/07/29 18:39:22 deraadt Exp $";
#endif /* not lint */
@


1.28
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2003/07/05 17:02:08 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 2003/07/05 17:02:08 deraadt Exp $";
a567 3
			static char fmt[] = "%l:% %p on %A, %d %B %Y";

			fmt[4] = 'M';		/* I *hate* SCCS... */
d569 2
a570 1
			(void)strftime(db, sizeof(db), fmt, localtime(&t));
@


1.27
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2003/06/25 21:11:10 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 2003/06/25 21:11:10 deraadt Exp $";
d197 1
a197 1
	 * that the file descriptors are already set up for us. 
@


1.26
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2003/06/02 19:38:24 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 2003/06/02 19:38:24 millert Exp $";
d148 1
a148 1
void
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $";
d92 1
a92 2
char	*portselector();
char	*ttyname();
a266 2
			extern char *autobaud();

@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2002/05/22 06:35:43 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 2002/05/22 06:35:43 deraadt Exp $";
@


1.23
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2002/03/29 20:35:55 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 2002/03/29 20:35:55 deraadt Exp $";
d131 1
a131 1
dingdong()
d141 1
a141 1
interrupt()
d154 1
a154 2
timeoverrun(signo)
	int signo;
d172 1
a172 3
main(argc, argv)
	int argc;
	char *argv[];
d349 1
a349 1
getname()
d466 1
a466 2
putpad(s)
	char *s;
d503 1
a503 2
xputs(s)
	char *s;
d513 1
a513 2
putchr(cc)
	int cc;
d532 1
a532 1
oflush()
d540 1
a540 1
prompt()
d549 1
a549 2
putf(cp)
	char *cp;
@


1.22
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2002/02/16 21:27:30 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 2002/02/16 21:27:30 millert Exp $";
d190 1
a190 1
		strcpy(hostname, "Amnesiac");
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2001/11/19 22:35:04 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 2001/11/19 22:35:04 deraadt Exp $";
d62 1
@


1.20
log
@remove the signal handler races and longjmps, and then do a bit of KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2001/07/08 21:18:08 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2001/07/08 21:18:08 deraadt Exp $";
d163 7
a169 7
static int	getname __P((void));
static void	oflush __P((void));
static void	prompt __P((void));
static void	putchr __P((int));
static void	putf __P((char *));
static void	putpad __P((char *));
static void	xputs __P((char *));
@


1.19
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2001/01/31 19:13:36 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2001/01/31 19:13:36 deraadt Exp $";
a58 1
#include <setjmp.h>
a128 2
jmp_buf timeout;

d132 3
a134 3
	alarm(0);
	signal(SIGALRM, SIG_DFL);
	longjmp(timeout, 1);		/* XXX signal/longjmp resource leaks */
d137 1
a137 1
jmp_buf	intrupt;
d142 1
d144 1
d146 1
a146 1
	longjmp(intrupt, 1);
d156 4
a159 2
	/* XXX signal race */
	syslog(LOG_ERR, "getty exiting due to excessive running time");
a287 5
		if (setjmp(timeout)) {
			tmode.c_ispeed = tmode.c_ospeed = 0;
			(void)tcsetattr(0, TCSANOW, &tmode);
			exit(1);
		}
d300 1
a300 1
			register int i;
d353 1
a353 2
	register int c;
	register char *np;
d355 2
a356 2
	volatile int ppp_state = 0;
	volatile int ppp_connection = 0;
a360 4
	if (setjmp(intrupt)) {
		signal(SIGINT, SIG_IGN);
		return (0);
	}
d377 6
a382 1
		if (read(STDIN_FILENO, &cs, 1) <= 0)
d384 1
d453 4
d469 1
a469 1
	register char *s;
d507 1
a507 1
	register char *s;
d555 1
a555 1
	register char *cp;
d558 1
a559 1
	char *slash, db[100];
d588 1
a604 1
		}
@


1.18
log
@more fat utmp; ianm@@cit.uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2001/01/28 19:34:28 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2001/01/28 19:34:28 niklas Exp $";
d360 2
a361 2
	int ppp_state = 0;
	int ppp_connection = 0;
d470 1
a470 1
	register pad = 0;
@


1.17
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2001/01/19 18:02:26 deraadt Exp $";
d93 1
a93 1
char	name[16];
@


1.16
log
@mark remaining signal races
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: main.c,v 1.15 2000/09/07 17:02:23 deraadt Exp $";
@


1.15
log
@off by one overflow
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.14 1999/12/09 20:20:43 deraadt Exp $";
a132 1

d135 1
a135 1
	longjmp(timeout, 1);
d155 1
a155 1

d157 1
a157 1
	exit(1);
@


1.14
log
@oops
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.12 1998/07/10 08:06:04 deraadt Exp $";
d419 1
a419 1
		if (c == '\r' || c == '\n' || np >= &name[sizeof name]) {
@


1.13
log
@do not crash if stdin is not a tty
@
text
@d205 3
a207 6
	if (isatty(0) == 0) {
		fprintf(stderr, "not a tty\n");
		exit(1);
	} else if (argc <= 2 || strcmp(argv[2], "-") == 0)
		strlcpy(ttyn, ttyname(0), sizeof(ttyn));
	else {
@


1.12
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.11 1997/11/20 07:39:27 deraadt Exp $";
d205 5
a209 2
	if (argc <= 2 || strcmp(argv[2], "-") == 0)
		strcpy(ttyn, ttyname(0));
d213 1
a213 2
		strcpy(ttyn, dev);
		strncat(ttyn, argv[2], sizeof(ttyn)-sizeof(dev));
@


1.11
log
@puts -> xputs
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.10 1997/08/05 23:37:35 angelos Exp $";
d157 1
a157 1
	syslog(LOG_ERR, "getty exiting due to excessive running time\n");
@


1.10
log
@Remove duplicate inclusion of signal.h
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.9 1997/07/23 20:36:25 kstailey Exp $";
d167 1
a167 1
static void	puts __P((char *));
d310 1
a310 1
				puts("user names may not start with '-'.");
d432 1
a432 1
					puts("\b \b");
d444 1
a444 1
				puts("                                     \r");
d485 1
a485 1
	puts(s);
d505 1
a505 1
puts(s)
d570 1
a570 1
				puts(ttyn);
d572 1
a572 1
				puts(&slash[1]);
d576 1
a576 1
			puts(editedhost);
d585 1
a585 1
			puts(db);
d589 1
a589 1
			puts(kerninfo.sysname);
d593 1
a593 1
			puts(kerninfo.machine);
d597 1
a597 1
			puts(kerninfo.release);
d601 1
a601 1
			puts(kerninfo.version);
@


1.9
log
@tabify
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.8 1997/06/02 08:12:10 deraadt Exp $";
a57 1
#include <signal.h>
@


1.8
log
@if getty to# parameter is used, pp option has timeout problem; kfurge@@worldnet.att.net, freebsd pr#3733
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.7 1997/04/06 08:43:41 deraadt Exp $";
d78 4
a81 4
#define PPP_FRAME           0x7e  /* PPP Framing character */
#define PPP_STATION         0xff  /* "All Station" character */
#define PPP_ESCAPE          0x7d  /* Escape Character */
#define PPP_CONTROL         0x03  /* PPP Control Field */
d83 2
a84 2
#define PPP_LCP_HI          0xc0  /* LCP protocol - high byte */
#define PPP_LCP_LOW         0x21  /* LCP protocol - low byte */
@


1.7
log
@clean -Wall
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.6 1996/12/17 19:33:53 tholo Exp $";
d298 3
@


1.6
log
@Add traditional handling of all upper-case input
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.5 1996/12/10 07:58:34 deraadt Exp $";
a176 1
	long allflags;
d358 1
a358 1
	int ppp_state;
@


1.5
log
@PPP autologin code from freebsd; do not use until pppd has been checked for security...
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.4 1996/05/22 12:10:13 deraadt Exp $";
d319 10
a328 6
#if XXX
			if (upper || UC)
				tmode.sg_flags |= LCASE;
			if (lower || LC)
				tmode.sg_flags &= ~LCASE;
#endif
@


1.4
log
@libutil
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.3 1996/02/22 10:39:28 niklas Exp $";
d76 10
d180 1
d298 5
a302 1
		if (getname()) {
d354 3
a356 1
	char cs;
d385 28
d458 1
a458 1
	return (1);
@


1.3
log
@From NetBSD:
Make sure that the user name cannot ever be interpreted as an option to
login(8).  Note: This does *not* fix any security holes.
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.2 1995/11/13 11:27:23 deraadt Exp $";
d64 1
@


1.2
log
@repair indentation
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.1.1.1 1995/10/18 08:43:17 deraadt Exp $";
d321 1
a321 1
			execle(LO, "login", "-p", name, (char *) 0, env);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: main.c,v 1.15 1995/08/13 04:08:27 cgd Exp $";
d196 1
a196 1
	    strcpy(ttyn, ttyname(0));
d198 1
a198 1
	    int i;
d200 19
a218 16
	    strcpy(ttyn, dev);
	    strncat(ttyn, argv[2], sizeof(ttyn)-sizeof(dev));
	    if (strcmp(argv[0], "+") != 0) {
		chown(ttyn, 0, 0);
		chmod(ttyn, 0600);
		revoke(ttyn);
		/*
		 * Delay the open so DTR stays down long enough to be detected.
		 */
		sleep(2);
		while ((i = open(ttyn, O_RDWR)) == -1) {
			if ((repcnt % 10 == 0) &&
			    (errno != ENXIO || !failopenlogged)) {
				syslog(LOG_ERR, "%s: %m", ttyn);
				closelog();
				failopenlogged = 1;
d220 1
a220 2
			repcnt++;
			sleep(60);
a221 2
		login_tty(i);
	    }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
