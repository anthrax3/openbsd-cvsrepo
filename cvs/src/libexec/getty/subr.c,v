head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.28
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.24
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.22
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.20
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.18
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.16
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.14
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.25;
commitid	JEVxsRygqcjPtWTf;

1.25
date	2015.12.22.08.54.16;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	sTDrw9FlbNNwVprE;

1.24
date	2015.08.28.20.28.50;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	slrhzaGdKC9Pah6d;

1.23
date	2015.07.16.04.31.25;	author tedu;	state Exp;
branches;
next	1.22;
commitid	C0qgiDHJ28LsAZt3;

1.22
date	2014.04.12.17.01.23;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2013.12.10.20.56.59;	author naddy;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.21.04.25.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.27.06.36.40;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.01.08.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.08.21.18.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.11.15.18.50;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.28.19.34.28;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.06.22.51.42;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.04.30.19;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	97.04.06.08.43.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.17.19.33.55;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.12.16.20.04.45;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.12.16.17.14.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.16.14.54.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.09.53.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.07.17.20.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: subr.c,v 1.25 2015/12/22 08:54:16 mmcc Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Melbourne getty.
 */
#include <sys/ioctl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <poll.h>
#include <termios.h>

#include "gettytab.h"
#include "pathnames.h"
#include "extern.h"

extern	struct termios tmode, omode;

/*
 * Get a table entry.
 */
void
gettable(char *name, char *buf)
{
	struct gettystrs *sp;
	struct gettynums *np;
	struct gettyflags *fp;
	long n;
	char *dba[2];
	dba[0] = _PATH_GETTYTAB;
	dba[1] = NULL;

	if (cgetent(&buf, dba, name) != 0)
		return;

	for (sp = gettystrs; sp->field; sp++)
		cgetstr(buf, sp->field, &sp->value);
	for (np = gettynums; np->field; np++) {
		if (cgetnum(buf, np->field, &n) == -1)
			np->set = 0;
		else {
			np->set = 1;
			np->value = n;
		}
	}
	for (fp = gettyflags; fp->field; fp++) {
		if (cgetcap(buf, fp->field, ':') == NULL)
			fp->set = 0;
		else {
			fp->set = 1;
			fp->value = 1 ^ fp->invrt;
		}
	}
#ifdef DEBUG
	printf("name=\"%s\", buf=\"%s\"\n", name, buf);
	for (sp = gettystrs; sp->field; sp++)
		printf("cgetstr: %s=%s\n", sp->field, sp->value);
	for (np = gettynums; np->field; np++)
		printf("cgetnum: %s=%d\n", np->field, np->value);
	for (fp = gettyflags; fp->field; fp++)
		printf("cgetflags: %s='%c' set='%c'\n", fp->field,
		    fp->value + '0', fp->set + '0');
	exit(1);
#endif /* DEBUG */
}

void
gendefaults(void)
{
	struct gettystrs *sp;
	struct gettynums *np;
	struct gettyflags *fp;

	for (sp = gettystrs; sp->field; sp++)
		if (sp->value)
			sp->defalt = sp->value;
	for (np = gettynums; np->field; np++)
		if (np->set)
			np->defalt = np->value;
	for (fp = gettyflags; fp->field; fp++)
		if (fp->set)
			fp->defalt = fp->value;
		else
			fp->defalt = fp->invrt;
}

void
setdefaults(void)
{
	struct gettystrs *sp;
	struct gettynums *np;
	struct gettyflags *fp;

	for (sp = gettystrs; sp->field; sp++)
		if (!sp->value)
			sp->value = sp->defalt;
	for (np = gettynums; np->field; np++)
		if (!np->set)
			np->value = np->defalt;
	for (fp = gettyflags; fp->field; fp++)
		if (!fp->set)
			fp->value = fp->defalt;
}

static char **
charnames[] = {
	&ER, &KL, &IN, &QU, &XN, &XF, &ET, &BK,
	&SU, &DS, &RP, &FL, &WE, &LN, 0
};

static char *
charvars[] = {
	&tmode.c_cc[VERASE], &tmode.c_cc[VKILL], &tmode.c_cc[VINTR],
	&tmode.c_cc[VQUIT], &tmode.c_cc[VSTART], &tmode.c_cc[VSTOP],
	&tmode.c_cc[VEOF], &tmode.c_cc[VEOL], &tmode.c_cc[VSUSP],
	&tmode.c_cc[VDSUSP], &tmode.c_cc[VREPRINT], &tmode.c_cc[VDISCARD],
	&tmode.c_cc[VWERASE], &tmode.c_cc[VLNEXT], 0
};

void
setchars(void)
{
	int i;
	char *p;

	for (i = 0; charnames[i]; i++) {
		p = *charnames[i];
		if (p && *p)
			*charvars[i] = *p;
		else
			*charvars[i] = _POSIX_VDISABLE;
	}
}

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))

void
setflags(int n)
{
	tcflag_t iflag, oflag, cflag, lflag;

	switch (n) {
	case 0:
		if (C0set && I0set && L0set && O0set) {
			tmode.c_cflag = C0;
			tmode.c_iflag = I0;
			tmode.c_lflag = L0;
			tmode.c_oflag = O0;
			return;
		}
		break;
	case 1:
		if (C1set && I1set && L1set && O1set) {
			tmode.c_cflag = C1;
			tmode.c_iflag = I1;
			tmode.c_lflag = L1;
			tmode.c_oflag = O1;
			return;
		}
		break;
	default:
		if (C2set && I2set && L2set && O2set) {
			tmode.c_cflag = C2;
			tmode.c_iflag = I2;
			tmode.c_lflag = L2;
			tmode.c_oflag = O2;
			return;
		}
		break;
	}

	iflag = omode.c_iflag;
	oflag = omode.c_oflag;
	cflag = omode.c_cflag;
	lflag = omode.c_lflag;

	if (NP) {
		CLR(cflag, CSIZE|PARENB);
		SET(cflag, CS8);
		CLR(iflag, ISTRIP|INPCK|IGNPAR);
	} else if (AP || EP || OP) {
		CLR(cflag, CSIZE);
		SET(cflag, CS7|PARENB);
		SET(iflag, ISTRIP);
		if (OP && !EP) {
			SET(iflag, INPCK|IGNPAR);
			SET(cflag, PARODD);
			if (AP)
				CLR(iflag, INPCK);
		} else if (EP && !OP) {
			SET(iflag, INPCK|IGNPAR);
			CLR(cflag, PARODD);
			if (AP)
				CLR(iflag, INPCK);
		} else if (AP || (EP && OP)) {
			CLR(iflag, INPCK|IGNPAR);
			CLR(cflag, PARODD);
		}
	} /* else, leave as is */

	if (UC) {
		SET(iflag, IUCLC);
		SET(oflag, OLCUC);
		SET(lflag, XCASE);
	}

	if (HC)
		SET(cflag, HUPCL);
	else
		CLR(cflag, HUPCL);

	if (MB)
		SET(cflag, MDMBUF);
	else
		CLR(cflag, MDMBUF);

	if (NL) {
		SET(iflag, ICRNL);
		SET(oflag, ONLCR|OPOST);
	} else {
		CLR(iflag, ICRNL);
		CLR(oflag, ONLCR);
	}

	if (!HT)
		SET(oflag, OXTABS|OPOST);
	else
		CLR(oflag, OXTABS);

#ifdef XXX_DELAY
	SET(f, delaybits());
#endif

	if (n == 1) {		/* read mode flags */
		if (RW) {
			iflag = 0;
			CLR(oflag, OPOST);
			CLR(cflag, CSIZE|PARENB);
			SET(cflag, CS8);
			lflag = 0;
		} else {
			CLR(lflag, ICANON);
		}
		goto out;
	}

	if (n == 0)
		goto out;

#if 0
	if (CB)
		SET(f, CRTBS);
#endif

	if (CE)
		SET(lflag, ECHOE);
	else
		CLR(lflag, ECHOE);

	if (CK)
		SET(lflag, ECHOKE);
	else
		CLR(lflag, ECHOKE);

	if (PE)
		SET(lflag, ECHOPRT);
	else
		CLR(lflag, ECHOPRT);

	if (EC)
		SET(lflag, ECHO);
	else
		CLR(lflag, ECHO);

	if (XC)
		SET(lflag, ECHOCTL);
	else
		CLR(lflag, ECHOCTL);

	if (DX)
		SET(lflag, IXANY);
	else
		CLR(lflag, IXANY);

out:
	tmode.c_iflag = iflag;
	tmode.c_oflag = oflag;
	tmode.c_cflag = cflag;
	tmode.c_lflag = lflag;
}

#ifdef XXX_DELAY
struct delayval {
	unsigned int	delay;		/* delay in ms */
	int		bits;
};

/*
 * below are random guesses, I can't be bothered checking
 */

struct delayval	crdelay[] = {
	{ 1,		CR1 },
	{ 2,		CR2 },
	{ 3,		CR3 },
	{ 83,		CR1 },
	{ 166,		CR2 },
	{ 0,		CR3 },
};

struct delayval nldelay[] = {
	{ 1,		NL1 },		/* special, calculated */
	{ 2,		NL2 },
	{ 3,		NL3 },
	{ 100,		NL2 },
	{ 0,		NL3 },
};

struct delayval	bsdelay[] = {
	{ 1,		BS1 },
	{ 0,		0 },
};

struct delayval	ffdelay[] = {
	{ 1,		FF1 },
	{ 1750,		FF1 },
	{ 0,		FF1 },
};

struct delayval	tbdelay[] = {
	{ 1,		 TAB1 },
	{ 2,		 TAB2 },
	{ 3,		XTABS },	/* this is expand tabs */
	{ 100,		 TAB1 },
	{ 0,		 TAB2 },
};

int
delaybits()
{
	int f;

	f  = adelay(CD, crdelay);
	f |= adelay(ND, nldelay);
	f |= adelay(FD, ffdelay);
	f |= adelay(TD, tbdelay);
	f |= adelay(BD, bsdelay);
	return (f);
}

int
adelay(int ms, struct delayval *dp)
{
	if (ms == 0)
		return (0);
	while (dp->delay && ms > dp->delay)
		dp++;
	return (dp->bits);
}
#endif

void
makeenv(char *env[])
{
	static char termbuf[128] = "TERM=";
	char *p, *q;
	char **ep;

	ep = env;
	if (TT && *TT) {
		strlcat(termbuf, TT, sizeof(termbuf));
		*ep++ = termbuf;
	}
	if ((p = EV)) {
		q = p;
		while ((q = strchr(q, ','))) {
			*q++ = '\0';
			*ep++ = p;
			p = q;
		}
		if (*p)
			*ep++ = p;
	}
	*ep = NULL;
}

/*
 * This speed select mechanism is written for the Develcon DATASWITCH.
 * The Develcon sends a string of the form "B{speed}\n" at a predefined
 * baud rate. This string indicates the user's actual speed.
 * The routine below returns the terminal type mapped from derived speed.
 */
struct	portselect {
	char	*ps_baud;
	char	*ps_type;
} portspeeds[] = {
	{ "B110",	"std.110" },
	{ "B134",	"std.134" },
	{ "B150",	"std.150" },
	{ "B300",	"std.300" },
	{ "B600",	"std.600" },
	{ "B1200",	"std.1200" },
	{ "B2400",	"std.2400" },
	{ "B4800",	"std.4800" },
	{ "B9600",	"std.9600" },
	{ "B19200",	"std.19200" },
	{ 0 }
};

char *
portselector(void)
{
	char c, baud[20], *type = "default";
	struct portselect *ps;
	int len;

	alarm(5*60);
	for (len = 0; len < sizeof (baud) - 1; len++) {
		if (read(STDIN_FILENO, &c, 1) <= 0)
			break;
		c &= 0177;
		if (c == '\n' || c == '\r')
			break;
		if (c == 'B')
			len = 0;	/* in case of leading garbage */
		baud[len] = c;
	}
	baud[len] = '\0';
	for (ps = portspeeds; ps->ps_baud; ps++)
		if (strcmp(ps->ps_baud, baud) == 0) {
			type = ps->ps_type;
			break;
		}
	sleep(2);	/* wait for connection to complete */
	return (type);
}

/*
 * This auto-baud speed select mechanism is written for the Micom 600
 * portselector. Selection is done by looking at how the character '\r'
 * is garbled at the different speeds.
 */
#include <sys/time.h>

char *
autobaud(void)
{
	struct pollfd pfd[1];
	struct timespec ts;
	char c, *type = "9600-baud";

	(void)tcflush(0, TCIOFLUSH);
	pfd[0].fd = 0;
	pfd[0].events = POLLIN;
	if (poll(pfd, 1, 5 * 1000) <= 0)
		return (type);
	if (read(STDIN_FILENO, &c, sizeof(char)) != sizeof(char))
		return (type);

	ts.tv_sec = 0;
	ts.tv_nsec = 20 * 1000;
	nanosleep(&ts, NULL);
	(void)tcflush(0, TCIOFLUSH);
	switch (c & 0377) {

	case 0200:		/* 300-baud */
		type = "300-baud";
		break;

	case 0346:		/* 1200-baud */
		type = "1200-baud";
		break;

	case  015:		/* 2400-baud */
	case 0215:
		type = "2400-baud";
		break;

	default:		/* 4800-baud */
		type = "4800-baud";
		break;

	case 0377:		/* 9600-baud */
		type = "9600-baud";
		break;
	}
	return (type);
}
@


1.25
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.24 2015/08/28 20:28:50 deraadt Exp $	*/
d416 1
a416 1
	*ep = (char *)0;
@


1.24
log
@remove excess tab at end of line (how did they afford the extra bytes in
the dark ages?)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.23 2015/07/16 04:31:25 tedu Exp $	*/
d60 1
a60 1
	dba[1] = 0;
@


1.23
log
@remove ancient support for edited hostnames. ok deraadt (long ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.22 2014/04/12 17:01:23 jsg Exp $	*/
d491 1
a491 1
	
@


1.22
log
@remove the prototype for compatflags() which was removed in 2013.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.21 2013/12/10 20:56:59 naddy Exp $	*/
a392 40

char	editedhost[48];

void
edithost(char *pat)
{
	char *host = HN;
	char *res = editedhost;

	if (!pat)
		pat = "";
	while (*pat) {
		switch (*pat) {

		case '#':
			if (*host)
				host++;
			break;

		case '@@':
			if (*host)
				*res++ = *host++;
			break;

		default:
			*res++ = *pat;
			break;

		}
		if (res == &editedhost[sizeof editedhost - 1]) {
			*res = '\0';
			return;
		}
		pat++;
	}
	if (*host)
		strlcpy(res, host, sizeof editedhost - (res - editedhost));
	else
		*res = '\0';
}
@


1.21
log
@Drop the f0, f1, f2 gettytab capabilities that were used to poke
magic numbers into sgttyb.  The "modern" replacement for f# is the
set of i#, o#, c#, l# to poke magic numbers into termios.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.20 2013/04/21 04:25:49 deraadt Exp $	*/
a46 2

static void	compatflags(long);
@


1.20
log
@use poll + nanosleep instead of select with a fixed size fd_set
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.19 2009/10/27 23:59:31 deraadt Exp $	*/
a34 1
#define COMPAT_43
a175 23
#ifdef COMPAT_43
	switch (n) {
	case 0:
		if (F0set) {
			compatflags(F0);
			return;
		}
		break;
	case 1:
		if (F1set) {
			compatflags(F1);
			return;
		}
		break;
	default:
		if (F2set) {
			compatflags(F2);
			return;
		}
		break;
	}
#endif

a324 137

#ifdef COMPAT_43
/*
 * Old TTY => termios, snatched from <sys/kern/tty_compat.c>
 */
void
compatflags(long flags)
{
	tcflag_t iflag, oflag, cflag, lflag;

	iflag = BRKINT|ICRNL|IMAXBEL|IXON|IXANY;
	oflag = OPOST|ONLCR|OXTABS;
	cflag = CREAD;
	lflag = ICANON|ISIG|IEXTEN;

	if (ISSET(flags, TANDEM))
		SET(iflag, IXOFF);
	else
		CLR(iflag, IXOFF);
	if (ISSET(flags, ECHO))
		SET(lflag, ECHO);
	else
		CLR(lflag, ECHO);
	if (ISSET(flags, CRMOD)) {
		SET(iflag, ICRNL);
		SET(oflag, ONLCR);
	} else {
		CLR(iflag, ICRNL);
		CLR(oflag, ONLCR);
	}
	if (ISSET(flags, XTABS))
		SET(oflag, OXTABS);
	else
		CLR(oflag, OXTABS);
	if (ISSET(flags, LCASE)) {
		SET(iflag, IUCLC);
		SET(oflag, OLCUC);
		SET(lflag, XCASE);
	}
	else {
		CLR(iflag, IUCLC);
		CLR(oflag, OLCUC);
		CLR(lflag, XCASE);
	}


	if (ISSET(flags, RAW)) {
		iflag &= IXOFF;
		CLR(lflag, ISIG|ICANON|IEXTEN|XCASE);
		CLR(cflag, PARENB);
	} else {
		SET(iflag, BRKINT|IXON|IMAXBEL);
		SET(lflag, ISIG|IEXTEN);
		if (ISSET(iflag, IUCLC) && ISSET(oflag, OLCUC))
			SET(lflag, XCASE);
		if (ISSET(flags, CBREAK))
			CLR(lflag, ICANON);
		else
			SET(lflag, ICANON);
		switch (ISSET(flags, ANYP)) {
		case 0:
			CLR(cflag, PARENB);
			break;
		case ANYP:
			SET(cflag, PARENB);
			CLR(iflag, INPCK);
			break;
		case EVENP:
			SET(cflag, PARENB);
			SET(iflag, INPCK);
			CLR(cflag, PARODD);
			break;
		case ODDP:
			SET(cflag, PARENB);
			SET(iflag, INPCK);
			SET(cflag, PARODD);
			break;
		}
	}

	/* Nothing we can do with CRTBS. */
	if (ISSET(flags, PRTERA))
		SET(lflag, ECHOPRT);
	else
		CLR(lflag, ECHOPRT);
	if (ISSET(flags, CRTERA))
		SET(lflag, ECHOE);
	else
		CLR(lflag, ECHOE);
	/* Nothing we can do with TILDE. */
	if (ISSET(flags, MDMBUF))
		SET(cflag, MDMBUF);
	else
		CLR(cflag, MDMBUF);
	if (ISSET(flags, NOHANG))
		CLR(cflag, HUPCL);
	else
		SET(cflag, HUPCL);
	if (ISSET(flags, CRTKIL))
		SET(lflag, ECHOKE);
	else
		CLR(lflag, ECHOKE);
	if (ISSET(flags, CTLECH))
		SET(lflag, ECHOCTL);
	else
		CLR(lflag, ECHOCTL);
	if (!ISSET(flags, DECCTQ))
		SET(iflag, IXANY);
	else
		CLR(iflag, IXANY);
	CLR(lflag, TOSTOP|FLUSHO|PENDIN|NOFLSH);
	SET(lflag, ISSET(flags, TOSTOP|FLUSHO|PENDIN|NOFLSH));

	if (ISSET(flags, RAW|LITOUT|PASS8)) {
		CLR(cflag, CSIZE);
		SET(cflag, CS8);
		if (!ISSET(flags, RAW|PASS8))
			SET(iflag, ISTRIP);
		else
			CLR(iflag, ISTRIP);
		if (!ISSET(flags, RAW|LITOUT))
			SET(oflag, OPOST);
		else
			CLR(oflag, OPOST);
	} else {
		CLR(cflag, CSIZE);
		SET(cflag, CS7);
		SET(iflag, ISTRIP);
		SET(oflag, OPOST);
	}

	tmode.c_iflag = iflag;
	tmode.c_oflag = oflag;
	tmode.c_cflag = cflag;
	tmode.c_lflag = lflag;
}
#endif
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.18 2003/06/02 19:38:24 millert Exp $	*/
d36 1
d40 1
a41 1
#include <sys/ioctl.h>
d683 2
a684 2
	fd_set rfds;
	struct timeval timeout;
d688 3
a690 5
	FD_ZERO(&rfds);
	FD_SET(0, &rfds);
	timeout.tv_sec = 5;
	timeout.tv_usec = 0;
	if (select(1, &rfds, (fd_set *)NULL, (fd_set *)NULL, &timeout) <= 0)
d694 4
a697 4
	timeout.tv_sec = 0;
	timeout.tv_usec = 20;
	(void) select(0, (fd_set *)NULL, (fd_set *)NULL,
	    (fd_set *)NULL, &timeout);
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.17 2002/07/03 23:39:03 deraadt Exp $	*/
a30 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)subr.c	8.1 (Berkeley) 6/4/93";*/
static char rcsid[] = "$OpenBSD: subr.c,v 1.17 2002/07/03 23:39:03 deraadt Exp $";
#endif /* not lint */
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.16 2002/05/27 06:36:40 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.16 2002/05/27 06:36:40 deraadt Exp $";
@


1.16
log
@unsigned to unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.15 2002/02/16 21:27:30 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.15 2002/02/16 21:27:30 millert Exp $";
d63 1
a63 2
gettable(name, buf)
	char *name, *buf;
d108 1
a108 1
gendefaults()
d128 1
a128 1
setdefaults()
d161 1
a161 1
setchars()
d181 1
a181 2
setflags(n)
	int n;
d363 1
a363 2
compatflags(flags)
long flags;
d555 1
a555 3
adelay(ms, dp)
	ms;
	struct delayval *dp;
d568 1
a568 2
edithost(pat)
	char *pat;
d606 1
a606 2
makeenv(env)
	char *env[];
d654 1
a654 1
portselector()
d689 1
a689 1
autobaud()
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.14 2001/11/19 01:08:14 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.14 2001/11/19 01:08:14 deraadt Exp $";
d500 1
a500 1
	unsigned	delay;		/* delay in ms */
@


1.14
log
@clean & KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.13 2001/07/08 21:18:08 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.13 2001/07/08 21:18:08 deraadt Exp $";
d57 1
a57 1
static void	compatflags __P((long));
@


1.13
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.12 2001/06/11 15:18:50 mickey Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.12 2001/06/11 15:18:50 mickey Exp $";
d66 3
a68 3
	register struct gettystrs *sp;
	register struct gettynums *np;
	register struct gettyflags *fp;
d111 3
a113 3
	register struct gettystrs *sp;
	register struct gettynums *np;
	register struct gettyflags *fp;
d131 3
a133 3
	register struct gettystrs *sp;
	register struct gettynums *np;
	register struct gettyflags *fp;
d164 2
a165 2
	register int i;
	register char *p;
d185 1
a185 1
	register tcflag_t iflag, oflag, cflag, lflag;
d366 1
a366 1
register long flags;
d368 1
a368 1
	register tcflag_t iflag, oflag, cflag, lflag;
d547 1
a547 1
	register int f;
d559 2
a560 2
	register ms;
	register struct delayval *dp;
d574 1
a574 1
	register char *pat;
d576 2
a577 2
	register char *host = HN;
	register char *res = editedhost;
d616 2
a617 2
	register char *p, *q;
	register char **ep;
d664 1
a664 1
	register struct portselect *ps;
@


1.12
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.c,v 1.11 2001/01/28 19:34:28 niklas Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.11 2001/01/28 19:34:28 niklas Exp $";
d263 1
a263 1
		} else if (AP || EP && OP) {
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: subr.c,v 1.10 2000/10/06 22:51:42 deraadt Exp $";
d102 2
a103 2
		printf("cgetflags: %s='%c' set='%c'\n", fp->field, 
		       fp->value + '0', fp->set + '0');
d606 1
a606 1
		strncpy(res, host, sizeof editedhost - (res - editedhost) - 1);
a608 1
	editedhost[sizeof editedhost - 1] = '\0';
@


1.10
log
@use fd_set instead of int
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: subr.c,v 1.9 2000/09/08 04:30:19 aaron Exp $";
@


1.9
log
@Convert this strncat() to strlcat() and avoid one-byte oflow; millert@@ ok
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.8 1997/04/06 08:43:44 deraadt Exp $";
d697 1
a697 1
	int rfds;
d702 2
a703 1
	rfds = 1 << 0;
d706 1
a706 2
	if (select(32, (fd_set *)&rfds, (fd_set *)NULL,
	    (fd_set *)NULL, &timeout) <= 0)
d712 1
a712 1
	(void) select(32, (fd_set *)NULL, (fd_set *)NULL,
@


1.8
log
@clean -Wall
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.7 1996/12/17 19:33:55 tholo Exp $";
d620 1
a620 2
		strncat(termbuf, TT, sizeof(termbuf)-strlen(termbuf));
		termbuf[sizeof(termbuf)-1] = '\0';
@


1.7
log
@Add traditional handling of all upper-case input
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.6 1996/12/16 20:04:45 tholo Exp $";
d624 1
a624 1
	if (p = EV) {
d626 1
a626 1
		while (q = strchr(q, ',')) {
@


1.6
log
@Implement more tty flags for better portability from other systems:

	XCASE - canonical input/output processing
	IUCLC - translate uppercase to lowercase on input
	OLCUC - translate lowercase to uppercase on output
	OCRNL - translate carriage return to newline on output
	ONOCR - do not output carriage return at column 0
	ONLRET - newline performs carriage return function

In addition the tty compatibility interface supports LCASE properly.

Look at termios(4) for a more complete description of the above flags.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.5 1996/12/16 17:14:03 deraadt Exp $";
d267 5
a271 4
#if 0
	if (UC)
		f |= LCASE;
#endif
d392 1
a392 1
	if (ISSET(flags, LCASE))
@


1.5
log
@strncat like THIS
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.4 1996/12/16 14:54:12 deraadt Exp $";
d391 10
d405 1
a405 1
		CLR(lflag, ISIG|ICANON|IEXTEN);
d410 2
@


1.4
log
@yet another strncat botch
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.3 1996/08/31 09:53:42 deraadt Exp $";
d607 1
a607 1
		strncat(termbuf, TT, sizeof(termbuf)-strlen(termbuf)-1);
@


1.3
log
@buf oflow
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.2 1996/08/07 17:20:45 deraadt Exp $";
d607 1
a607 1
		strncat(termbuf, TT, sizeof(termbuf)-1);
@


1.2
log
@expand hostname to 48 chars; pointed out by msaitoh@@spa.is.uec.ac.jp, netbsd pr#2676
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.1.1.1 1995/10/18 08:43:17 deraadt Exp $";
d607 2
a608 1
		strcat(termbuf, TT);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: subr.c,v 1.18 1995/10/05 08:51:31 mycroft Exp $";
d555 1
a555 1
char	editedhost[32];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
