head	1.23;
access;
symbols
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2002.07.15.19.33.47;	author millert;	state dead;
branches;
next	1.22;

1.22
date	2002.06.04.00.09.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.14.18.05.39;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.11.23.11.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.11.22.05.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.11.21.51.07;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.11.17.45.26;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.16.18.40.00;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.27.16.18.58;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.07.09.07.04.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.29.21.37.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.23.23.31;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.19.22.57.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.05.19.41.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.20.18.42.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.08.06.20.41.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.08.22.12.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.08.22.09.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.29.02.22.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.12.18.57.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.01.23.39.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.22.03.41.10;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.14;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2002.03.19.04.28.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.23
log
@atrun is now part of cron(8)
@
text
@/*	$OpenBSD: atrun.c,v 1.22 2002/06/04 00:09:07 deraadt Exp $	*/

/*
 *  atrun.c - run jobs queued by at; run with root privileges.
 *  Copyright (C) 1993, 1994 Thomas Koenig
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author(s) may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* System Headers */

#include <sys/fcntl.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <grp.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <utmp.h>

#include <login_cap.h>
#include <bsd_auth.h>

#define MAIN
#include "privs.h"
#include "pathnames.h"
#include "atrun.h"

#if (MAXLOGNAME-1) > UT_NAMESIZE
#define LOGNAMESIZE UT_NAMESIZE
#else
#define LOGNAMESIZE (MAXLOGNAME-1)
#endif

static const char rcsid[] = "$OpenBSD: atrun.c,v 1.22 2002/06/04 00:09:07 deraadt Exp $";
static int debug = 0;

static void
perr(const char *a)
{
	if (debug)
		perror(a);
	else
		syslog(LOG_ERR, "%s: %m", a);

	exit(EXIT_FAILURE);
}

static void
perr2(char *a, char *b)
{
	if (debug) {
		(void)fputs(a, stderr);
		perror(b);
	} else
		syslog(LOG_ERR, "%s%s: %m", a, b);

	exit(EXIT_FAILURE);
}

static int
write_string(int fd, const char *a)
{
	return(write(fd, a, strlen(a)));
}

/*
 * Run a file by spawning off a process which redirects I/O,
 * spawns a subshell, then waits for it to complete and spawns
 * another process to send mail to the user.
 */
static void
run_file(const char *filename, uid_t uid, gid_t gid)
{
	pid_t pid;
	int fd_out, fd_in;
	int queue;
	char mailbuf[LOGNAMESIZE + 1], *fmt;
	char *mailname = NULL;
	FILE *stream;
	int send_mail = 0;
	struct stat stbuf;
	off_t size;
	struct passwd *pw;
	int fflags;
	uid_t nuid;
	gid_t ngid;
	login_cap_t *lc;
	auth_session_t *as;

	PRIV_START;

	if (chmod(filename, S_IRUSR) != 0)
		perr("Cannot change file permissions");

	PRIV_END;

	pid = fork();
	if (pid == -1)
		perr("Cannot fork");
	else if (pid != 0)
		return;

	/*
	 * Let's see who we mail to.  Hopefully, we can read it from the
	 * command file; if not, send it to the owner, or, failing that, to
	 * root.
	 */
	pw = getpwuid(uid);
	if (pw == NULL) {
		syslog(LOG_ERR,"Userid %u not found - aborting job %s",
		    uid, filename);
		exit(EXIT_FAILURE);
	}

	as = auth_open();
	if (as == NULL || auth_setpwd(as, pw) != 0) {
		syslog(LOG_ERR,"Unable to allocate memory - aborting job %s",
		    filename);
		exit(EXIT_FAILURE);
	}

	if (pw->pw_expire && time(NULL) >= pw->pw_expire) {
		syslog(LOG_ERR, "Userid %u has expired - aborting job %s",
		    uid, filename);
		exit(EXIT_FAILURE);
	}

	PRIV_START;

	fd_in = open(filename, O_RDONLY | O_NONBLOCK | O_NOFOLLOW, 0);

	PRIV_END;

	if (fd_in < 0)
		perr("Cannot open input file");

	if (fstat(fd_in, &stbuf) == -1)
		perr("Error in fstat of input file descriptor");

	if (!S_ISREG(stbuf.st_mode)) {
		syslog(LOG_ERR, "Job %s is not a regular file - aborting",
		    filename);
		exit(EXIT_FAILURE);
	}
	if (stbuf.st_uid != uid) {
		syslog(LOG_ERR, "Uid mismatch for job %s", filename);
		exit(EXIT_FAILURE);
	}
	if (stbuf.st_nlink != 1) {
		syslog(LOG_ERR, "Bad link count for job %s", filename);
		exit(EXIT_FAILURE);
	}
	if ((stbuf.st_mode & ALLPERMS) != S_IRUSR) {
		syslog(LOG_ERR, "Bad file mode for job %s", filename);
		exit(EXIT_FAILURE);
	}
	if ((fflags = fcntl(fd_in, F_GETFD)) < 0)
		perr("Error in fcntl");

	(void)fcntl(fd_in, F_SETFD, fflags & ~FD_CLOEXEC);

	(void) asprintf(&fmt,
	    "#!/bin/sh\n# atrun uid=%%u gid=%%u\n# mail %%%ds %%d",
	    LOGNAMESIZE);
	if (fmt == NULL) {
		syslog(LOG_ERR, "out of memory - aborting");
		exit(EXIT_FAILURE);
	}
	if ((stream = fdopen(dup(fd_in), "r")) == NULL)
		perr("Error duplicating input file descriptor");
	if (fscanf(stream, fmt, &nuid, &ngid, mailbuf, &send_mail) != 4) {
		syslog(LOG_ERR, "File %s is in wrong format - aborting",
		    filename);
		exit(EXIT_FAILURE);
	}
	(void) fclose(stream);
	free(fmt);
	if (mailbuf[0] == '-') {
		syslog(LOG_ERR, "illegal mail name %s in %s", mailbuf, filename);
		exit(EXIT_FAILURE);
	}
	mailname = mailbuf;
	if (nuid != uid) {
		syslog(LOG_ERR, "Job %s - userid %u does not match file uid %u",
		    filename, nuid, uid);
		exit(EXIT_FAILURE);
	}
	if (ngid != gid) {
		syslog(LOG_ERR, "Job %s - groupid %u does not match file gid %u",
		    filename, ngid, gid);
		exit(EXIT_FAILURE);
	}

	PRIV_START;

	if (chdir(_PATH_ATSPOOL) < 0)
		perr2("Cannot chdir to ", _PATH_ATSPOOL);

	/*
	 * Create a file to hold the output of the job we are about to
	 * run. Write the mail header.
	 */

	if ((fd_out = open(filename,
		    O_WRONLY | O_CREAT | O_EXCL, S_IWUSR | S_IRUSR)) < 0)
		perr("Cannot create output file");

	PRIV_END;

	write_string(fd_out, "To: ");
	write_string(fd_out, mailname);
	write_string(fd_out, "\nSubject: Output from your job ");
	write_string(fd_out, filename);
	write_string(fd_out, "\n\n");
	if (fstat(fd_out, &stbuf) == -1)
		perr("Error in fstat of output file descriptor");
	size = stbuf.st_size;

	(void)close(STDIN_FILENO);
	(void)close(STDOUT_FILENO);
	(void)close(STDERR_FILENO);

	pid = fork();
	if (pid < 0)
		perr("Error in fork");
	else if (pid == 0) {
		char *nul = NULL;
		char **nenvp = &nul;

		/*
		 * Set up things for the child; we want standard input from
		 * the input file, and standard output and error sent to
		 * our output file.
		 */
		if (lseek(fd_in, (off_t) 0, SEEK_SET) < 0)
			perr("Error in lseek");

		if (dup(fd_in) != STDIN_FILENO)
			perr("Error in I/O redirection");

		if (dup(fd_out) != STDOUT_FILENO)
			perr("Error in I/O redirection");

		if (dup(fd_out) != STDERR_FILENO)
			perr("Error in I/O redirection");

		(void)close(fd_in);
		(void)close(fd_out);

		PRIV_START;

		if (chdir(_PATH_ATJOBS) < 0)
			perr2("Cannot chdir to ", _PATH_ATJOBS);

		if ((lc = login_getclass(pw->pw_class)) == NULL)
			perr("Cannot get login class");

		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETALL) < 0)
			perr("Cannot set user context");

		if (auth_approval(as, lc, pw->pw_name, "at") <= 0)
			perr2("Approval failure for ", pw->pw_name);

		auth_close(as);
		login_close(lc);

		if (chdir(pw->pw_dir) < 0)
			chdir("/");

		/* First letter indicates requested job priority */
		queue = tolower((unsigned char) *filename);
		if (queue > 'b')
			(void) setpriority(PRIO_PROCESS, 0, queue - 'b');

		if (execle(_PATH_BSHELL, "sh", (char *)NULL, nenvp) != 0)
			perr("Exec failed for /bin/sh");

		PRIV_END;
	}
	/* We're the parent.  Let's wait. */
	(void)close(fd_in);
	(void)close(fd_out);
	waitpid(pid, (int *)NULL, 0);

	/*
	 * Send mail.  Unlink the output file first, so it is deleted
	 * after the run.
	 */
	PRIV_START;

	if (stat(filename, &stbuf) == -1)
		perr("Error in stat of output file");
	if (open(filename, O_RDONLY | O_NOFOLLOW) != STDIN_FILENO)
		perr("Open of jobfile failed");

	(void)unlink(filename);

	PRIV_END;

	if ((stbuf.st_size != size) || send_mail) {
		/* Fork off a child for sending mail */

		PRIV_START;

		if (setusercontext(0, pw, pw->pw_uid, LOGIN_SETALL) < 0)
			perr("Cannot set user context");

		if (chdir(pw->pw_dir))
			chdir("/");

		execl(_PATH_SENDMAIL, "sendmail", "-F", "Atrun Service",
		    "-odi", "-oem", "-t", (char *)NULL);
		perr("Exec failed for mail command");

		PRIV_END;
	}
	exit(EXIT_SUCCESS);
}


int
main(int argc, char **argv)
{
	/*
	 * Browse through  _PATH_ATJOBS, looking for jobs that should be
	 * be executed and/or deleted.  The filename consists of the date
	 * (in seconds since the epoch) followed by a '.' and then the
	 * queue (a letter).  A file which has not been executed yet will
	 * have its execute bit set.  For each file which is to be executed,
	 * run_file() is called, which forks off a child to take care of
	 * I/O redirection, forking off another child for execution and
	 * yet another one, optionally, for sending mail.  Files which
	 * have already run are removed during the next invocation.
	 */
	DIR *spool;
	struct dirent *dirent;
	struct stat stbuf;
	char queue;
	char *ep;
	time_t now, run_time;
	char batch_name[FILENAME_MAX];
	uid_t batch_uid;
	gid_t batch_gid;
	long l;
	int c;
	int run_batch;
	double la, load_avg = ATRUN_MAXLOAD;

	/*
	 * We don't need root privileges all the time; running under uid
	 * and gid nobody is fine except for privileged operations.
	 */
	RELINQUISH_PRIVS_ROOT(NOBODY_UID, NOBODY_GID);

	openlog("atrun", LOG_PID, LOG_CRON);

	errno = 0;
	while ((c = getopt(argc, argv, "dl:")) != -1) {
		switch (c) {
		case 'l':
			errno = EINVAL;
			load_avg = strtod(optarg, &ep);
			if (*ep != '\0' || (errno == ERANGE &&
			    (load_avg == DBL_MAX || load_avg == DBL_MIN)))
				perr2("bad load average: %s", optarg);
			if (load_avg <= 0.)
				load_avg = ATRUN_MAXLOAD;
			break;

		case 'd':
			debug++;
			break;

		default:
			syslog(LOG_ERR, "unknown option");
			exit(EXIT_FAILURE);
		}
	}

	PRIV_START;

	if (chdir(_PATH_ATJOBS) != 0)
		perr2("Cannot change to ", _PATH_ATJOBS);

	/*
	 * Main loop. Open spool directory for reading and look over all
	 * the files in there. If the filename indicates that the job
	 * should be run and the x bit is set, fork off a child which sets
	 * its user and group id to that of the files and exec a /bin/sh
	 * which executes the shell script. Unlink older files if they
	 * should no longer be run.  For deletion, their r bit has to be
	 * turned on.
	 *
	 * Also, pick the oldest batch job to run, at most one per
	 * invocation of atrun.
	 */
	if ((spool = opendir(".")) == NULL)
		perr2("Cannot read ", _PATH_ATJOBS);

	PRIV_END;

	now = time(NULL);
	run_batch = 0;
	batch_uid = (uid_t) -1;
	batch_gid = (gid_t) -1;
	batch_name[0] = '\0';

	while ((dirent = readdir(spool)) != NULL) {
		PRIV_START;

		if (stat(dirent->d_name, &stbuf) != 0)
			perr2("Cannot stat in ", _PATH_ATJOBS);

		PRIV_END;

		/* We don't want directories */
		if (!S_ISREG(stbuf.st_mode))
			continue;

		l = strtol(dirent->d_name, &ep, 10);
		if (*ep != '.' || !isalpha(*(ep + 1)) || l < 0 || l >= INT_MAX)
			continue;
		run_time = (time_t)l;
		queue = *(ep + 1);

		if ((S_IXUSR & stbuf.st_mode) && (run_time <= now)) {
			if (isupper(queue) &&
			    (strcmp(batch_name, dirent->d_name) > 0)) {
				run_batch = 1;
				(void)strlcpy(batch_name, dirent->d_name,
				    sizeof(batch_name));
				batch_uid = stbuf.st_uid;
				batch_gid = stbuf.st_gid;
			}

			/* The file is executable and old enough */
			if (islower(queue))
				run_file(dirent->d_name, stbuf.st_uid,
				    stbuf.st_gid);
		}

		/* Delete older files */
		if ((run_time < now) && !(S_IXUSR & stbuf.st_mode) &&
		    (S_IRUSR & stbuf.st_mode)) {
			PRIV_START;

			(void)unlink(dirent->d_name);

			PRIV_END;
		}
	}

	/* Run the single batch file, if any */
	if (run_batch && ((getloadavg(&la, 1) == 1) && la < load_avg))
		run_file(batch_name, batch_uid, batch_gid);

	closelog();
	exit(EXIT_SUCCESS);
}
@


1.22
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.21 2002/05/14 18:05:39 millert Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.21 2002/05/14 18:05:39 millert Exp $";
@


1.21
log
@Major changes:

Job names are now "runtime.queue" where runtime is when the job will run
in Unix time format.  This is what SysV at does and allows us to nuke
the .SEQ file.

Historic BSD options for atq and atrm are now implemented;
atq and atrm get their own man pages.

At no longer does anything with the -v flag.  We print the execution
time when jobs are submitted so there is no need.

Most *scanf() usage is gone (one remains in atrun).

Better sanity checks in atrun.

Random style/cleanup.

With these changes we have the best of both worlds; POSIX compliance with
the traditional BSD features.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.20 2002/05/11 23:11:59 millert Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.20 2002/05/11 23:11:59 millert Exp $";
d384 1
a384 1
	 * and gid nobody is fine except for priviledged operations.
@


1.20
log
@pass -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.19 2002/05/11 22:05:53 millert Exp $	*/
a29 1
#include <sys/types.h>
d31 2
a34 1
#include <sys/resource.h>
a35 1
#include <sys/param.h>
a38 1
#include <pwd.h>
d41 2
d48 1
a50 1
#include <syslog.h>
a52 1
#include <paths.h>
a55 2
/* Local headers */

a60 2
/* File scope defines */

d67 1
a67 3
/* File scope variables */

static const char rcsid[] = "$OpenBSD: atrun.c,v 1.19 2002/05/11 22:05:53 millert Exp $";
a69 2
/* Local functions */

d99 5
a106 5
	/*
	 * Run a file by spawning off a process which redirects I/O,
	 * spawns a subshell, then waits for it to complete and spawns another
	 * process to send mail to the user.
	 */
d114 1
a114 1
	struct stat buf, lbuf;
a140 1

d163 1
a163 1
	fd_in = open(filename, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0);
d170 1
a170 1
	if (fstat(fd_in, &buf) == -1)
d173 2
a174 9
	PRIV_START;

	if (lstat(filename, &lbuf) == -1)
		perr("Error in lstat of input file");

	PRIV_END;

	if (S_ISLNK(lbuf.st_mode)) {
		syslog(LOG_ERR, "Symbolic link encountered in job %s - aborting",
d178 6
a183 4
	if ((lbuf.st_dev != buf.st_dev) || (lbuf.st_ino != buf.st_ino) ||
	    (lbuf.st_uid != buf.st_uid) || (lbuf.st_gid != buf.st_gid) ||
	    (lbuf.st_size!=buf.st_size)) {
		syslog(LOG_ERR, "Somebody changed files from under us for job %s - aborting", filename);
d186 2
a187 3
	if (buf.st_nlink > 1) {
		syslog(LOG_ERR, "Somebody is trying to run a linked script for job %s",
		    filename);
d248 1
a248 1
	if (fstat(fd_out, &buf) == -1)
d250 1
a250 1
	size = buf.st_size;
d324 1
a324 1
	if (stat(filename, &buf) == -1)
d326 1
a326 1
	if (open(filename, O_RDONLY) != STDIN_FILENO)
d333 1
a333 1
	if ((buf.st_size != size) || send_mail) {
a352 1
/* Global functions */
d358 9
a366 11
	 * Browse through  _PATH_ATJOBS, checking all the jobfiles wether
	 * they should be executed and or deleted. The queue is coded into
	 * the first byte of the job filename, the date (in minutes since
	 * Eon) as a hex number in the following eight bytes, followed by
	 * a dot and a serial number.  A file which has not been executed
	 * yet is denoted by its execute - bit set.  For those files which
	 * are to be executed, run_file() is called, which forks off a
	 * child which takes care of I/O redirection, forks off another
	 * child for execution and yet another one, optionally, for sending
	 * mail.  Files which already have run are removed during the
	 * next invocation.
d370 1
a370 3
	struct stat buf;
	unsigned long ctm;
	int jobno;
d374 1
a374 1
	char batch_name[] = "Z2345678901234";
d377 1
a389 1
	opterr = 0;
a417 1

d439 1
d444 1
a444 1
		if (stat(dirent->d_name, &buf) != 0)
d450 1
a450 1
		if (!S_ISREG(buf.st_mode))
d453 2
a454 1
		if (sscanf(dirent->d_name, "%c%5x%8lx", &queue, &jobno, &ctm) != 3)
d456 2
d459 1
a459 3
		run_time = (time_t) ctm * 60;

		if ((S_IXUSR & buf.st_mode) && (run_time <= now)) {
d463 1
a463 1
				(void)strncpy(batch_name, dirent->d_name,
d465 2
a466 2
				batch_uid = buf.st_uid;
				batch_gid = buf.st_gid;
d471 2
a472 1
				run_file(dirent->d_name, buf.st_uid, buf.st_gid);
d476 2
a477 2
		if ((run_time < now) && !(S_IXUSR & buf.st_mode) &&
		    (S_IRUSR & buf.st_mode)) {
@


1.19
log
@Use strtod() to convert string -> double, not sscanf().
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.18 2002/05/11 21:51:07 millert Exp $	*/
d74 1
a74 2
static char *namep;
static char rcsid[] = "$OpenBSD: atrun.c,v 1.18 2002/05/11 21:51:07 millert Exp $";
d80 1
a80 2
perr(a)
	const char *a;
d91 1
a91 2
perr2(a, b)
	char *a, *b;
d103 1
a103 3
write_string(fd, a)
	int fd;
	const char *a;
d109 1
a109 4
run_file(filename, uid, gid)
	const char *filename;
	uid_t uid;
	gid_t gid;
d132 1
a132 1
	PRIV_START
d137 1
a137 1
	PRIV_END
d171 1
a171 1
	PRIV_START
d175 1
a175 1
	PRIV_END
d183 1
a183 1
	PRIV_START
d188 1
a188 1
	PRIV_END
d243 1
a243 1
	PRIV_START
d257 1
a257 1
	PRIV_END
d299 1
a299 1
		PRIV_START
d327 1
a327 1
		PRIV_END
d338 1
a338 1
	PRIV_START
d347 1
a347 1
	PRIV_END
d352 1
a352 1
		PRIV_START
d364 1
a364 1
		PRIV_END
d372 1
a372 3
main(argc, argv)
	int argc;
	char *argv[];
d406 1
a406 1
	RELINQUISH_PRIVS_ROOT(NOBODY_UID, NOBODY_GID)
d434 1
a434 3
	namep = argv[0];

	PRIV_START
d455 1
a455 1
	PRIV_END
d463 1
a463 1
		PRIV_START
d468 1
a468 1
		PRIV_END
d497 1
a497 1
			PRIV_START
d501 1
a501 1
			PRIV_END
@


1.18
log
@Deal with unknown command line options more sanely.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.17 2002/05/11 17:45:26 millert Exp $	*/
d42 1
d75 1
a75 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.17 2002/05/11 17:45:26 millert Exp $";
d403 1
d425 5
a429 2
			if (sscanf(optarg, "%lf", &load_avg) != 1)
				perr("garbled option -l");
@


1.17
log
@When opening jobs file, use O_NONBLOCK|O_NOFOLLOW for paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.16 2002/03/16 18:40:00 millert Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.16 2002/03/16 18:40:00 millert Exp $";
a432 4
		case '?':
			perr("unknown option");
			break;

d434 2
a435 2
			perr("idiotic option - aborted");
			break;
@


1.16
log
@Avoid potential corruption of passwd pointer auth_approval().
Similar to my recent rshd change.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.15 2001/08/27 16:18:58 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.15 2001/08/27 16:18:58 deraadt Exp $";
a170 5
	PRIV_START

	stream = fopen(filename, "r");

	PRIV_END
d178 7
a184 1
	if (stream == NULL)
a186 3
	if ((fd_in = dup(fileno(stream))) < 0)
		perr("Error duplicating input file descriptor");

d225 2
a229 1
		free(fmt);
d232 1
a248 1
	(void)fclose(stream);
@


1.15
log
@header order
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.14 2001/07/09 07:04:41 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.14 2001/07/09 07:04:41 deraadt Exp $";
d137 1
d164 7
d318 1
a318 1
		if (auth_approval(NULL, lc, pw->pw_name, "at") <= 0)
d321 1
@


1.15.2.1
log
@Pull in patch from current:
Fix (millert):
Avoid potential corruption of passwd pointer by auth_approval().
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.15 2001/08/27 16:18:58 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.15 2001/08/27 16:18:58 deraadt Exp $";
a136 1
	auth_session_t *as;
a162 7

	as = auth_open();
	if (as == NULL || auth_setpwd(as, pw) != 0) {
		syslog(LOG_ERR,"Unable to allocate memory - aborting job %s",
		    filename);
		exit(EXIT_FAILURE);
	}
d310 1
a310 1
		if (auth_approval(as, lc, pw->pw_name, "at") <= 0)
a312 1
		auth_close(as);
@


1.14
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.13 2001/05/29 21:37:16 millert Exp $	*/
d30 1
a31 1
#include <sys/types.h>
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.13 2001/05/29 21:37:16 millert Exp $";
@


1.13
log
@Call auth_checknologin() and auth_approval() as appropriate for BSD
authentication.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.12 2001/05/05 23:23:31 millert Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.12 2001/05/05 23:23:31 millert Exp $";
d323 1
a323 1
		if (execle(_PATH_BSHELL, "sh", NULL, nenvp) != 0)
d360 1
a360 1
		    "-odi", "-oem", "-t", (char *) NULL);
@


1.12
log
@We must lower the process priority *after* the call to setusercontext()
otherwise the priority will just be what login.conf decrees.  Convert
from nice() to setpriority() in the process.  Based on a patch from
<hgw@@d1906.inka.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.11 2001/04/19 22:57:27 deraadt Exp $	*/
d54 1
d74 1
a74 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.11 2001/04/19 22:57:27 deraadt Exp $";
d132 1
a132 1
	struct passwd *pentry;
d136 1
d157 2
a158 2
	pentry = getpwuid(uid);
	if (pentry == NULL) {
d169 1
a169 1
	if (pentry->pw_expire && time(NULL) >= pentry->pw_expire) {
d304 4
a307 1
		if (setusercontext(0, pentry, pentry->pw_uid, LOGIN_SETALL) < 0)
d310 6
a315 1
		if (chdir(pentry->pw_dir) < 0)
d353 1
a353 1
		if (setusercontext(0, pentry, pentry->pw_uid, LOGIN_SETALL) < 0)
d356 1
a356 1
		if (chdir(pentry->pw_dir))
@


1.11
log
@typo; david@@phobia.ms
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.10 2000/12/05 19:41:29 deraadt Exp $	*/
d33 2
d73 1
a73 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.10 2000/12/05 19:41:29 deraadt Exp $";
d247 1
a247 1
	 * Create a file to hold the output of the job we are  about to
a301 5
		queue = *filename;

		if (queue > 'b')
		    nice(queue - 'b');

d307 5
@


1.10
log
@asprintf can safe time doing character counts
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.9 2000/08/20 18:42:37 millert Exp $	*/
d71 1
a71 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.9 2000/08/20 18:42:37 millert Exp $";
d116 1
a116 1
	 * Run a file by by spawning off a process which redirects I/O,
@


1.9
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.8 1999/08/06 20:41:05 deraadt Exp $	*/
d71 1
a71 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.8 1999/08/06 20:41:05 deraadt Exp $";
d123 1
a123 1
	char mailbuf[LOGNAMESIZE + 1], fmt[49];
d208 1
a208 1
	(void)snprintf(fmt, sizeof(fmt),
d211 4
d218 1
d221 1
@


1.8
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.7 1997/09/08 22:12:10 millert Exp $	*/
d51 1
d71 1
a71 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.7 1997/09/08 22:12:10 millert Exp $";
d299 2
a300 11
		if (initgroups(pentry->pw_name, pentry->pw_gid) < 0)
			perr("Cannot init group list");

		if (setegid(pentry->pw_gid) < 0 || setgid(pentry->pw_gid) < 0)
			perr("Cannot change primary group");

		if (setlogin(pentry->pw_name) < 0)
			perr("Cannot set login name");

		if (seteuid(uid) < 0 || setuid(uid) < 0)
			perr("Cannot set user id");
d305 1
a305 1
		if (execle("/bin/sh", "sh", (char *)NULL, nenvp) != 0)
d335 2
a336 11
		if (initgroups(pentry->pw_name, pentry->pw_gid))
			perr("Cannot init group list");

		if (setegid(gid) < 0 || setgid(gid) < 0)
			perr("Cannot change primary group");

		if (setlogin(pentry->pw_name) < 0)
			perr("Cannot set login name");

		if (seteuid(uid) < 0 || setuid(uid) < 0)
			perr("Cannot set user id");
@


1.7
log
@setlogin, and chdir after uid change; do before exec'ing sendmail as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.6 1997/09/08 22:09:28 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.6 1997/09/08 22:09:28 deraadt Exp $";
d208 1
a208 1
	    "#!/bin/sh\n# atrun uid=%%ld gid=%%ld\n# mail %%%ds %%d",
@


1.6
log
@setlogin, and chdir after uid change; came here because of a problem dima reported
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.5 1997/07/29 02:22:46 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.5 1997/07/29 02:22:46 deraadt Exp $";
d304 3
a306 1
		setlogin(pentry->pw_name);
a342 3
		if (chdir(pentry->pw_dir))
			chdir("/");

d349 3
d354 3
@


1.5
log
@sendmail -t please
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.4 1997/04/12 18:57:30 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.4 1997/04/12 18:57:30 millert Exp $";
a297 3
		if (chdir(pentry->pw_dir) < 0)
			chdir("/");

d304 1
d307 3
@


1.4
log
@Fix from FreeBSD (David Nugent <davidn>)
    Submitted by: Philippe Charnier <charnier@@xp11.frmug.org>
    Fixes name size limitation (was hardcoded to 8).
    Closes FreeBSD PR#3258
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.3 1997/03/01 23:39:43 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.3 1997/03/01 23:39:43 millert Exp $";
d248 3
a250 1
	write_string(fd_out, "Subject: Output from your job ");
d353 1
a353 1
		    "-odi", "-oem", mailname, (char *) NULL);
@


1.3
log
@Merge in changes from at 2.9
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
d48 1
d59 8
d70 1
a70 1
static char rcsid[] = "$OpenBSD: atrun.c,v 1.2 1996/12/22 03:41:10 tholo Exp $";
d122 1
a122 1
	char mailbuf[9];
d207 4
a210 2
	if (fscanf(stream, "#!/bin/sh\n# atrun uid=%u gid=%u\n# mail %8s %d",
	    &nuid, &ngid, mailbuf, &send_mail) != 4) {
@


1.2
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 2
d4 2
a5 3
 * atrun.c - run jobs queued by at; run with root privileges.
 * Copyright (c) 1993 by Thomas Koenig
 * All rights reserved.
d19 1
a19 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d34 1
d38 1
d60 2
a61 1
static char rcsid[] = "$Id: atrun.c,v 1.1.1.1 1995/10/18 08:43:14 deraadt Exp $";
d64 1
d69 18
a86 1
	syslog(LOG_ERR, "%s: %m", a);
d95 1
a95 1
	return write(fd, a, strlen(a));
d99 1
a99 1
run_file(filename, uid)
d102 1
d116 1
a116 1
	struct stat buf;
d120 9
d133 1
a133 1
	else if (pid > 0)
d142 6
d150 1
a150 1
	    stream = fopen(filename, "r");
d154 5
a158 3
	pentry = getpwuid(uid);
	if (pentry == NULL)
		perr("UID not in password file!");
d166 26
d195 1
a195 1
	fcntl(fd_in, F_SETFD, fflags & ~FD_CLOEXEC);
d197 5
a201 4
	if (fscanf(stream, "#! /bin/sh\n# mail %8s %d", mailbuf, &send_mail) == 2) {
		mailname = mailbuf;
	} else {
		mailname = pentry->pw_name;
d203 19
a221 1
	fclose(stream);
d223 1
a223 1
		perr("Cannot chdir to " _PATH_ATSPOOL);
d229 1
d234 2
d239 2
a240 1
	fstat(fd_out, &buf);
d243 3
a245 3
	close(STDIN_FILENO);
	close(STDOUT_FILENO);
	close(STDERR_FILENO);
a258 1

d271 5
a275 2
		close(fd_in);
		close(fd_out);
d277 1
a277 1
			perr("Cannot chdir to " _PATH_ATJOBS);
d281 2
a282 1
		PRIV_START
d284 2
a285 2
		    if (queue > 'b')
			nice(queue - 'b');
d290 1
a290 3
		if (setegid(pentry->pw_gid) < 0)
			perr("Cannot change primary group");
		if (setgid(pentry->pw_gid) < 0)
d293 1
a293 3
		if (seteuid(uid) < 0)
			perr("Cannot set user id");
		if (setuid(uid) < 0)
d296 2
a297 4
		chdir("/");

		if (execle("/bin/sh", "sh", (char *) NULL, nenvp) != 0)
			perr("Exec failed");
d302 18
a319 3
	close(fd_in);
	close(fd_out);
	waitpid(pid, (int *) NULL, 0);
a320 1
	stat(filename, &buf);
d323 20
a342 12
		pid = fork();
		if (pid < 0)
			perr("Fork failed");
		else if (pid == 0) {
			if (open(filename, O_RDONLY) != STDIN_FILENO)
				perr("Cannot reopen output file");

			execl(_PATH_SENDMAIL, _PATH_SENDMAIL, mailname,
			    (char *) NULL);
			perr("Exec failed");
		}
		waitpid(pid, (int *) NULL, 0);
a343 1
	unlink(filename);
a369 1
	int older;
d371 1
d373 7
d383 1
a383 1
	 * and gid daemon is fine.
d385 1
a386 1
	RELINQUISH_PRIVS_ROOT(0) /* it's setuid root */
d389 25
d415 3
d419 2
a420 1
		perr("Cannot change to " _PATH_ATJOBS);
d430 3
d435 8
a442 1
		perr("Cannot read " _PATH_ATJOBS);
d445 1
a445 1
		double la;
d448 3
a450 1
			perr("Cannot stat in " _PATH_ATJOBS);
d456 1
a456 1
		if (sscanf(dirent->d_name, "%c%8lx", &queue, &ctm) != 2)
d459 1
a459 3
		if ((queue == 'b') && ((getloadavg(&la, 1) != 1) ||
		    (la > ATRUN_MAXLOAD)))
			continue;
d461 14
a474 8
		older = (time_t) ctm *60 <= time(NULL);

		/* The file is executable and old enough */
		if (older && (S_IXUSR & buf.st_mode)) {
			/*
			 * Now we know we want to run the file, we can turn
			 * off the execute bit
			 */
d476 3
d481 1
a481 2
			    if (chmod(dirent->d_name, S_IRUSR) != 0)
				perr("Cannot change file permissions");
a483 2

			run_file(dirent->d_name, buf.st_uid);
a484 4
		/* Delete older files */
		if (older && !(S_IXUSR & buf.st_mode) &&
		    (S_IRUSR & buf.st_mode))
			unlink(dirent->d_name);
d486 5
@


1.1
log
@Initial revision
@
text
@d57 1
a57 1
static char rcsid[] = "$Id: atrun.c,v 1.2 1995/03/02 22:06:06 cgd Exp $";
d198 2
d203 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
