head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.24
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.22
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.18
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.16
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.14
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.12
	OPENBSD_5_0:1.20.0.10
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.8
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.25
date	2017.04.17.21.48.26;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	mTrEQE58hpyOmOg3;

1.24
date	2016.04.25.15.43.34;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	I3EQuSEiFuZ6Sj6q;

1.23
date	2015.11.16.17.31.14;	author tedu;	state Exp;
branches;
next	1.22;
commitid	eR8GyZHrhWLCQlqG;

1.22
date	2015.02.06.23.21.58;	author millert;	state Exp;
branches;
next	1.21;
commitid	STdsVrA5MGLlnbLm;

1.21
date	2014.08.25.07.50.25;	author doug;	state Exp;
branches;
next	1.20;
commitid	vcwz0sp1JH7QzUmA;

1.20
date	2009.06.04.01.12.39;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.04.01.10.34;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.30.12.03.51;	author ragge;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.05.21.16.59;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.26.19.33.23;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.01.20.06.27;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.21.17.42.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.14.15.33.28;	author moritz;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.20.16.51.38;	author moritz;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2005.07.14.14.48.47;	author moritz;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.24.02.24.57;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.24.02.12.40;	author moritz;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.26.17.35.05;	author moritz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2004.12.20.14.58.57;	author moritz;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.11.08.38.26;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.06.20.52.04;	author moritz;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.29.22.24.57;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.28.20.09.47;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.28.19.12.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.28.18.49.30;	author henning;	state Exp;
branches;
next	;

1.8.2.1
date	2005.07.14.23.34.33;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2006.05.15.23.28.14;	author brad;	state Exp;
branches;
next	;


desc
@@


1.25
log
@freezero() can be used here
@
text
@/*	$OpenBSD: monitor.c,v 1.24 2016/04/25 15:43:34 deraadt Exp $	*/

/*
 * Copyright (c) 2004 Moritz Jodeit <moritz@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "monitor.h"
#include "extern.h"

enum monitor_command {
	CMD_USER,
	CMD_PASS,
	CMD_SOCKET,
	CMD_BIND
};

enum monitor_state {
	PREAUTH,
	POSTAUTH
};

extern char	remotehost[];
extern char	ttyline[20];
extern int	debug;

extern void	set_slave_signals(void);

int	fd_monitor = -1;
int	fd_slave = -1;
int	nullfd;
pid_t	slave_pid = -1;
enum monitor_state	state = PREAUTH;

void	send_data(int, void *, size_t);
void	recv_data(int, void *, size_t);
void	handle_cmds(void);
void	set_monitor_signals(void);
void	sig_pass_to_slave(int);
void	sig_chld(int);
void	fatalx(char *, ...);
void	debugmsg(char *, ...);

/*
 * Send data over a socket and exit if something fails.
 */
void
send_data(int sock, void *buf, size_t len)
{
	ssize_t n;
	size_t pos = 0;
	char *ptr = buf;

	while (len > pos) {
		switch (n = write(sock, ptr + pos, len - pos)) {
		case 0:
			kill_slave("write failure");
			_exit(0);
			/* NOTREACHED */
		case -1:
			if (errno != EINTR && errno != EAGAIN)
				fatalx("send_data: %m");
			break;
		default:
			pos += n;
		}
	}
}

/*
 * Receive data from socket and exit if something fails.
 */
void
recv_data(int sock, void *buf, size_t len)
{
	ssize_t n;
	size_t pos = 0;
	char *ptr = buf;

	while (len > pos) {
		switch (n = read(sock, ptr + pos, len - pos)) {
		case 0:
			kill_slave(NULL);
			_exit(0);
			/* NOTREACHED */
		case -1:
			if (errno != EINTR && errno != EAGAIN)
				fatalx("recv_data: %m");
			break;
		default:
			pos += n;
		}
	}
}

void
set_monitor_signals(void)
{
	struct sigaction act;
	int i;

	sigfillset(&act.sa_mask);
	act.sa_flags = SA_RESTART;

	act.sa_handler = SIG_DFL;
	for (i = 1; i < _NSIG; i++)
		sigaction(i, &act, NULL);

	act.sa_handler = sig_chld;
	sigaction(SIGCHLD, &act, NULL);

	act.sa_handler = sig_pass_to_slave;
	sigaction(SIGHUP, &act, NULL);
	sigaction(SIGINT, &act, NULL);
	sigaction(SIGQUIT, &act, NULL);
	sigaction(SIGTERM, &act, NULL);
}

/*
 * Creates the privileged monitor process. It returns twice.
 * It returns 1 for the unprivileged slave process and 0 for the
 * user-privileged slave process after successful authentication.
 */
int
monitor_init(void)
{
	struct passwd *pw;
	int pair[2];

	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, pair) == -1)
		fatalx("socketpair failed");

	fd_monitor = pair[0];
	fd_slave = pair[1];

	set_monitor_signals();

	slave_pid = fork();
	if (slave_pid == -1)
		fatalx("fork of unprivileged slave failed");
	if (slave_pid == 0) {
		/* Unprivileged slave */
		set_slave_signals();

		if ((pw = getpwnam(FTPD_PRIVSEP_USER)) == NULL)
			fatalx("privilege separation user %s not found",
			    FTPD_PRIVSEP_USER);

		if (chroot(pw->pw_dir) == -1)
			fatalx("chroot %s: %m", pw->pw_dir);
		if (chdir("/") == -1)
			fatalx("chdir /: %m");

		if (setgroups(1, &pw->pw_gid) == -1)
			fatalx("setgroups: %m");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			fatalx("setresgid failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			fatalx("setresuid failed");

		endpwent();
		close(fd_slave);
		return (1);
	}

	setproctitle("%s: [priv pre-auth]", remotehost);

	handle_cmds();

	/* User-privileged slave */
	return (0);
}

/*
 * Creates the user-privileged slave process. It is called
 * from the privileged monitor process and returns twice. It returns 0
 * for the user-privileged slave process and 1 for the monitor process.
 */
int
monitor_post_auth()
{
	slave_pid = fork();
	if (slave_pid == -1)
		fatalx("fork of user-privileged slave failed");

	snprintf(ttyline, sizeof(ttyline), "ftp%ld",
	    slave_pid == 0 ? (long)getpid() : (long)slave_pid);

	if (slave_pid == 0) {
		/* User privileged slave */
		close(fd_slave);
		set_slave_signals();
		return (0);
	}

	/* We have to keep stdout open, because reply() needs it. */
	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
		fatalx("cannot open %s: %m", _PATH_DEVNULL);
	dup2(nullfd, STDIN_FILENO);
	dup2(nullfd, STDERR_FILENO);
	close(nullfd);
	close(fd_monitor);

	return (1);
}

/*
 * Handles commands received from the slave process. It will not return
 * except in one situation: After successful authentication it will
 * return as the user-privileged slave process.
 */
void
handle_cmds(void)
{
	enum monitor_command cmd;
	enum auth_ret auth;
	int err, s, slavequit, serrno, domain;
	pid_t preauth_slave_pid;
	size_t len;
	union sockunion sa;
	socklen_t salen;
	char *name, *pw;

	for (;;) {
		recv_data(fd_slave, &cmd, sizeof(cmd));

		switch (cmd) {
		case CMD_USER:
			debugmsg("CMD_USER received");

			recv_data(fd_slave, &len, sizeof(len));
			if (len == SIZE_MAX)
				fatalx("monitor received invalid user length");
			if ((name = malloc(len + 1)) == NULL)
				fatalx("malloc: %m");
			if (len > 0)
				recv_data(fd_slave, name, len);
			name[len] = '\0';

			user(name);
			free(name);
			break;
		case CMD_PASS:
			debugmsg("CMD_PASS received");

			recv_data(fd_slave, &len, sizeof(len));
			if (len == SIZE_MAX)
				fatalx("monitor received invalid pass length");
			if ((pw = malloc(len + 1)) == NULL)
				fatalx("malloc: %m");
			if (len > 0)
				recv_data(fd_slave, pw, len);
			pw[len] = '\0';

			preauth_slave_pid = slave_pid;

			auth = pass(pw);
			freezero(pw, len);

			switch (auth) {
			case AUTH_FAILED:
				/* Authentication failure */
				debugmsg("authentication failed");
				slavequit = 0;
				send_data(fd_slave, &slavequit,
				    sizeof(slavequit));
				break;
			case AUTH_SLAVE:
				/* User-privileged slave */
				debugmsg("user-privileged slave started");
				return;
				/* NOTREACHED */
			case AUTH_MONITOR:
				/* Post-auth monitor */
				debugmsg("monitor went into post-auth phase");
				state = POSTAUTH;
				setproctitle("%s: [priv post-auth]",
				    remotehost);
				slavequit = 1;

				send_data(fd_slave, &slavequit,
				    sizeof(slavequit));

				while (waitpid(preauth_slave_pid, NULL, 0) < 0 &&
				    errno == EINTR)
					;
				break;
			default:
				fatalx("bad return value from pass()");
				/* NOTREACHED */
			}
			break;
		case CMD_SOCKET:
			debugmsg("CMD_SOCKET received");

			if (state != POSTAUTH)
				fatalx("CMD_SOCKET received in invalid state");

			recv_data(fd_slave, &domain, sizeof(domain));
			if (domain != AF_INET && domain != AF_INET6)
				fatalx("monitor received invalid addr family");

			s = socket(domain, SOCK_STREAM, 0);
			serrno = errno;

			send_fd(fd_slave, s);
			if (s == -1)
				send_data(fd_slave, &serrno, sizeof(serrno));
			else
				close(s);
			break;
		case CMD_BIND:
			debugmsg("CMD_BIND received");

			if (state != POSTAUTH)
				fatalx("CMD_BIND received in invalid state");

			s = recv_fd(fd_slave);

			recv_data(fd_slave, &salen, sizeof(salen));
			if (salen == 0 || salen > sizeof(sa))
				fatalx("monitor received invalid sockaddr len");

			bzero(&sa, sizeof(sa));
			recv_data(fd_slave, &sa, salen);

			if (sa.su_si.si_len != salen)
				fatalx("monitor received invalid sockaddr len");

			if (sa.su_si.si_family != AF_INET &&
			    sa.su_si.si_family != AF_INET6)
				fatalx("monitor received invalid addr family");

			err = bind(s, (struct sockaddr *)&sa, salen);
			serrno = errno;

			if (s >= 0)
				close(s);

			send_data(fd_slave, &err, sizeof(err));
			if (err == -1)
				send_data(fd_slave, &serrno, sizeof(serrno));
			break;
		default:
			fatalx("monitor received unknown command %d", cmd);
			/* NOTREACHED */
		}
	}
}

void
sig_pass_to_slave(int signo)
{
	int olderrno = errno;

	if (slave_pid > 0)
		kill(slave_pid, signo);

	errno = olderrno;
}

/* ARGSUSED */
void
sig_chld(int signo)
{
	pid_t pid;
	int stat, olderrno = errno;

	do {
		pid = waitpid(slave_pid, &stat, WNOHANG);
		if (pid > 0)
			_exit(0);
	} while (pid == -1 && errno == EINTR);

	errno = olderrno;
}

void
kill_slave(char *reason)
{
	if (slave_pid > 0) {
		if (reason)
			syslog(LOG_NOTICE, "kill slave %d: %s",
			    slave_pid, reason);
		kill(slave_pid, SIGQUIT);
	}
}

void
fatalx(char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);

	kill_slave("fatal error");

	_exit(0);
}

void
debugmsg(char *fmt, ...)
{
	va_list ap;

	if (debug) {
		va_start(ap, fmt);
		vsyslog(LOG_DEBUG, fmt, ap);
		va_end(ap);
	}
}

void
monitor_user(char *name)
{
	enum monitor_command cmd;
	size_t len;

	cmd = CMD_USER;
	send_data(fd_monitor, &cmd, sizeof(cmd));

	len = strlen(name);
	send_data(fd_monitor, &len, sizeof(len));
	if (len > 0)
		send_data(fd_monitor, name, len);
}

int
monitor_pass(char *pass)
{
	enum monitor_command cmd;
	int quitnow;
	size_t len;

	cmd = CMD_PASS;
	send_data(fd_monitor, &cmd, sizeof(cmd));

	len = strlen(pass);
	send_data(fd_monitor, &len, sizeof(len));
	if (len > 0)
		send_data(fd_monitor, pass, len);

	recv_data(fd_monitor, &quitnow, sizeof(quitnow));

	return (quitnow);
}

int
monitor_socket(int domain)
{
	enum monitor_command cmd;
	int s, serrno;

	cmd = CMD_SOCKET;
	send_data(fd_monitor, &cmd, sizeof(cmd));
	send_data(fd_monitor, &domain, sizeof(domain));

	s = recv_fd(fd_monitor);
	if (s == -1) {
		recv_data(fd_monitor, &serrno, sizeof(serrno));
		errno = serrno;
	}

	return (s);
}

int
monitor_bind(int s, struct sockaddr *name, socklen_t namelen)
{
	enum monitor_command cmd;
	int ret, serrno;

	cmd = CMD_BIND;
	send_data(fd_monitor, &cmd, sizeof(cmd));

	send_fd(fd_monitor, s);
	send_data(fd_monitor, &namelen, sizeof(namelen));
	send_data(fd_monitor, name, namelen);

	recv_data(fd_monitor, &ret, sizeof(ret));
	if (ret == -1) {
		recv_data(fd_monitor, &serrno, sizeof(serrno));
		errno = serrno;
	}

	return (ret);
}
@


1.24
log
@prefer setres{u,g}id() rather than manipulating both real and effective
ids, it clarifies these are full revocation situations.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.23 2015/11/16 17:31:14 tedu Exp $	*/
d287 1
a287 2
			explicit_bzero(pw, len);
			free(pw);
@


1.23
log
@don't need to ifdef setproctitle
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.22 2015/02/06 23:21:58 millert Exp $	*/
d185 4
a188 8
		if (setegid(pw->pw_gid) == -1)
			fatalx("setegid failed");
		if (setgid(pw->pw_gid) == -1)
			fatalx("setgid failed");
		if (seteuid(pw->pw_uid) == -1)
			fatalx("seteuid failed");
		if (setuid(pw->pw_uid) == -1)
			fatalx("setuid failed");
@


1.22
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.21 2014/08/25 07:50:25 doug Exp $	*/
a51 1
#ifdef HASSETPROCTITLE
a52 1
#endif
a198 1
#ifdef HASSETPROCTITLE
a199 1
#endif
a310 1
#ifdef HASSETPROCTITLE
a312 1
#endif
@


1.21
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.20 2009/06/04 01:12:39 sthen Exp $	*/
a25 1
#include <limits.h>
d30 1
d269 1
a269 1
			if (len == SIZE_T_MAX)
d284 1
a284 1
			if (len == SIZE_T_MAX)
@


1.20
log
@...and now try again with a commit from the right tree. doh!

ftp uses its own ugly "sockunion" to hold addresses, but with CMD_BIND
the monitor treats it as if it were a sockaddr. this is fine for v4 but
fails for v6, so active connections break. problem reported and diff
tested by Maurice Janssen. looks sensible to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.18 2008/06/30 12:03:51 ragge Exp $	*/
d295 1
a295 1
			bzero(pw, len);
@


1.19
log
@ftp uses its own ugly "sockunion" to hold addresses, but with CMD_BIND
the monitor treats it as if it were a sockaddr. this is fine for v4 but
fails for v6, so active connections break. problem reported and diff
tested by Maurice Janssen. looks sensible to deraadt@@.
@
text
@d257 1
a257 1
	struct sockaddr sa;
d362 1
a362 1
				fatalx("monitor received invalid sockaddr len %u");
d367 2
a368 2
			if (sa.sa_len != salen)
				fatalx("monitor received invalid sockaddr len %u/%u",sa.sa_len,sa.su_si.si_len);
d370 2
a371 1
			if (sa.sa_family != AF_INET && sa.sa_family != AF_INET6)
d374 1
a374 1
			err = bind(s, &sa, salen);
@


1.18
log
@Include file order must be "monitor.h" before "extern.h" otherwise enum
auth_ret is referenced before it is declared, which is not allowed by C99.

Ok krw@@, millert@@, gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.17 2007/04/05 21:16:59 moritz Exp $	*/
d362 1
a362 1
				fatalx("monitor received invalid sockaddr len");
d368 1
a368 1
				fatalx("monitor received invalid sockaddr len");
@


1.17
log
@Remove lint comment, which does not apply anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.16 2007/03/26 19:33:23 moritz Exp $	*/
d37 1
a38 1
#include "monitor.h"
@


1.16
log
@Do not log when the slave gets killed because of read()
returning 0. This is normal behavior and should not spam
the logs. Noticed by henning@@

OK henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.15 2007/03/01 20:06:27 otto Exp $	*/
a387 1
	/* NOTREACHED */
@


1.15
log
@- use proper log facility and priority in the slave sig handlers
- if the monitor decides to kill the slave, log that
ok millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.14 2006/04/21 17:42:50 deraadt Exp $	*/
d114 1
a114 1
			kill_slave("read failure");
d422 3
a424 1
		syslog(LOG_NOTICE, "kill slave %d: %s", slave_pid, reason);
@


1.14
log
@lint cleanup; ok ray moritz dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.13 2006/03/14 15:33:28 moritz Exp $	*/
d88 1
a88 1
			kill_slave();
d114 1
a114 1
			kill_slave();
d419 1
a419 1
kill_slave(void)
d421 2
a422 1
	if (slave_pid > 0)
d424 1
d436 1
a436 1
	kill_slave();
@


1.13
log
@Allow anonymous logins without a password, which was broken
by the last commit. Noticed by Armin Wolfermann. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.12 2006/01/20 16:51:38 moritz Exp $	*/
d324 2
a325 2
				while (waitpid(preauth_slave_pid, NULL, 0) < 0
				    && errno == EINTR)
@


1.12
log
@fix integer overflows. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.11 2005/07/14 14:48:47 moritz Exp $	*/
d269 1
a269 1
			if (len == 0 || len == SIZE_T_MAX)
d273 2
a274 1
			recv_data(fd_slave, name, len);
d284 1
a284 1
			if (len == 0 || len == SIZE_T_MAX)
d288 2
a289 1
			recv_data(fd_slave, pw, len);
@


1.12.2.1
log
@MFC:
Fix by moritz@@

Allow anonymous logins without a password, which was broken
by the last commit. Noticed by Armin Wolfermann.

ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.13 2006/03/14 15:33:28 moritz Exp $	*/
d269 1
a269 1
			if (len == SIZE_T_MAX)
d273 1
a273 2
			if (len > 0)
				recv_data(fd_slave, name, len);
d283 1
a283 1
			if (len == SIZE_T_MAX)
d287 1
a287 2
			if (len > 0)
				recv_data(fd_slave, pw, len);
@


1.11
log
@let root create the data socket. fixes PR 4287.
ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.10 2005/05/24 02:24:57 moritz Exp $	*/
d26 1
d269 2
d273 1
a273 2
			if (len > 0)
				recv_data(fd_slave, name, len);
d283 2
d287 1
a287 2
			if (len > 0)
				recv_data(fd_slave, pw, len);
@


1.10
log
@readd endpwent()
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.9 2005/05/24 02:12:40 moritz Exp $	*/
d42 1
d253 1
a253 1
	int err, s, slavequit, serrno;
d328 19
d479 19
@


1.9
log
@no need for endpwent()
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.8 2005/02/26 17:35:05 moritz Exp $	*/
d193 2
@


1.8
log
@fix {send,recv}data so they don't add -1 to pos in the
EINTR/EAGAIN case as found by otto@@.
also make them more quiet as requested by deraadt@@.

ok millert@@ otto@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.7 2004/12/20 14:58:57 moritz Exp $	*/
a176 1
		endpwent();
@


1.8.2.1
log
@MFC:
Fix by moritz@@

let root create the data socket. fixes PR 4287.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.8 2005/02/26 17:35:05 moritz Exp $	*/
a41 1
	CMD_SOCKET,
d251 1
a251 1
	int err, s, slavequit, serrno, domain;
a325 19
		case CMD_SOCKET:
			debugmsg("CMD_SOCKET received");

			if (state != POSTAUTH)
				fatalx("CMD_SOCKET received in invalid state");

			recv_data(fd_slave, &domain, sizeof(domain));
			if (domain != AF_INET && domain != AF_INET6)
				fatalx("monitor received invalid addr family");

			s = socket(domain, SOCK_STREAM, 0);
			serrno = errno;

			send_fd(fd_slave, s);
			if (s == -1)
				send_data(fd_slave, &serrno, sizeof(serrno));
			else
				close(s);
			break;
a457 19
}

int
monitor_socket(int domain)
{
	enum monitor_command cmd;
	int s, serrno;

	cmd = CMD_SOCKET;
	send_data(fd_monitor, &cmd, sizeof(cmd));
	send_data(fd_monitor, &domain, sizeof(domain));

	s = recv_fd(fd_monitor);
	if (s == -1) {
		recv_data(fd_monitor, &serrno, sizeof(serrno));
		errno = serrno;
	}

	return (s);
@


1.7
log
@change mail address

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.6 2004/12/11 08:38:26 moritz Exp $	*/
d80 1
a80 1
	size_t pos;
d83 13
a95 8
	for (pos = 0; len > pos; pos += n) {
		n = write(sock, ptr + pos, len - pos);

		if (n == -1 && !(errno == EINTR || errno == EAGAIN))
			fatalx("send_data: %m");

		if (n == 0)
			fatalx("send_data: connection closed");
d106 1
a106 1
	size_t pos;
d109 13
a121 8
	for (pos = 0; len > pos; pos += n) {
		n = read(sock, ptr + pos, len - pos);

		if (n == -1 && !(errno == EINTR || errno == EAGAIN))
			fatalx("recv_data: %m");

		if (n == 0)
			fatalx("recv_data: connection closed");
@


1.6
log
@make syscalls in the monitor restartable when signals occur, as was
the case before privsep and only wait() for our slave processes.
with help from millert@@

ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.5 2004/12/06 20:52:04 moritz Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Moritz Jodeit <moritz@@jodeit.org>
@


1.5
log
@make signal blocking a lot easier.
ok millert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.4 2004/11/29 22:24:57 henning Exp $	*/
a62 1
volatile sig_atomic_t	quit = 0;
d66 1
a66 2
int	recv_cmd(int, void *, size_t);
int	handle_cmds(void);
a114 16
/*
 * Receive command from socket and return 1 if something fails.
 * If command was received successfuly, 0 is returned.
 */
int
recv_cmd(int sock, void *buf, size_t len)
{
	ssize_t n;

	n = read(sock, buf, len);
	if (n <= 0)
		return (1);

	return (0);
}

d122 1
a122 1
	act.sa_flags = 0;
d192 1
a192 4
	if (handle_cmds() == 1) {
		debugmsg("slave lost. monitor quits now.");
		_exit(0);
	}
d232 3
a234 3
 * Handles commands received from the slave process. It returns twice.
 * It returns 0 for the user-privileged slave process after successful
 * authentication and 1 if the user-privileged slave died.
d236 1
a236 1
int
d242 1
d248 2
a249 7
	while (quit == 0) {
		if (recv_cmd(fd_slave, &cmd, sizeof(cmd)) != 0) {
			if (quit == 1)
				break;
			else
				continue;
		}
d275 2
d292 1
a292 1
				return (0);
a293 1
				break;
d306 4
a313 1
				break;
a349 1
			break;
d352 1
a352 2

	return (1);
d374 3
a376 1
		pid = waitpid(-1, &stat, WNOHANG);
a377 5

	if (pid == slave_pid && stat != PREAUTH_SLAVE_DIED) {
		quit = 1;
		slave_pid = -1;
	}
@


1.4
log
@fix nasty signal races by blocking signals in signal handlers.
with moritz jodeit and theo, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.3 2004/11/28 20:09:47 henning Exp $	*/
d139 1
a139 1
	sigemptyset(&act.sa_mask);
a380 1
	sigset_t allsigs, oldsigs;
a382 3
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &oldsigs);

a385 1
	sigprocmask(SIG_SETMASK, &oldsigs, NULL);
a393 1
	sigset_t allsigs, oldsigs;
a395 3
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &oldsigs);

a404 1
	sigprocmask(SIG_SETMASK, &oldsigs, NULL);
@


1.3
log
@slave_pid -1 by default, not 0, and reset to -1 when it goes away, with theo
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.2 2004/11/28 19:12:31 henning Exp $	*/
d381 1
d384 3
d390 1
d399 1
d402 3
d414 1
@


1.2
log
@fix ttyline setting, fixes proctitle.
notice independently by theo and pval, fix from moritz jodeit
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.1 2004/11/28 18:49:30 henning Exp $	*/
d61 1
a61 1
pid_t	slave_pid;
d383 1
a383 1
	if (slave_pid != 0)
d400 1
a400 1
	if (pid == slave_pid && stat != PREAUTH_SLAVE_DIED)
d402 2
d411 1
a411 1
	if (slave_pid != 0)
@


1.1
log
@privilege seperate ftpd
handle the pre-authentication phase (minus a tiny tiny tiny amount
of code after accept()) in an unprivileged process, asking the
privileged monitor for help where needed.
work by Moritz Jodeit <moritz@@jodeit.org> with help from theo and me
tests theo ian@@ matthieu@@ ben@@networkinsanity.com a.schlichting@@lemarit.com
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d230 4
@

