head	1.223;
access;
symbols
	OPENBSD_6_2_BASE:1.223
	OPENBSD_6_1:1.223.0.4
	OPENBSD_6_1_BASE:1.223
	OPENBSD_6_0:1.217.0.2
	OPENBSD_6_0_BASE:1.217
	OPENBSD_5_9:1.212.0.2
	OPENBSD_5_9_BASE:1.212
	OPENBSD_5_8:1.207.0.6
	OPENBSD_5_8_BASE:1.207
	OPENBSD_5_7:1.207.0.2
	OPENBSD_5_7_BASE:1.207
	OPENBSD_5_6:1.203.0.4
	OPENBSD_5_6_BASE:1.203
	OPENBSD_5_5:1.199.0.4
	OPENBSD_5_5_BASE:1.199
	OPENBSD_5_4:1.197.0.2
	OPENBSD_5_4_BASE:1.197
	OPENBSD_5_3:1.196.0.2
	OPENBSD_5_3_BASE:1.196
	OPENBSD_5_2:1.195.0.2
	OPENBSD_5_2_BASE:1.195
	OPENBSD_5_1_BASE:1.194
	OPENBSD_5_1:1.194.0.2
	OPENBSD_5_0:1.193.0.4
	OPENBSD_5_0_BASE:1.193
	OPENBSD_4_9:1.193.0.2
	OPENBSD_4_9_BASE:1.193
	OPENBSD_4_8:1.191.0.2
	OPENBSD_4_8_BASE:1.191
	OPENBSD_4_7:1.187.0.2
	OPENBSD_4_7_BASE:1.187
	OPENBSD_4_6:1.186.0.4
	OPENBSD_4_6_BASE:1.186
	OPENBSD_4_5:1.185.0.2
	OPENBSD_4_5_BASE:1.185
	OPENBSD_4_4:1.183.0.2
	OPENBSD_4_4_BASE:1.183
	OPENBSD_4_3:1.181.0.2
	OPENBSD_4_3_BASE:1.181
	OPENBSD_4_2:1.180.0.2
	OPENBSD_4_2_BASE:1.180
	OPENBSD_4_1:1.175.0.2
	OPENBSD_4_1_BASE:1.175
	OPENBSD_4_0:1.171.0.2
	OPENBSD_4_0_BASE:1.171
	OPENBSD_3_9:1.170.0.2
	OPENBSD_3_9_BASE:1.170
	OPENBSD_3_8:1.168.0.2
	OPENBSD_3_8_BASE:1.168
	OPENBSD_3_7:1.163.0.2
	OPENBSD_3_7_BASE:1.163
	OPENBSD_3_6:1.153.0.4
	OPENBSD_3_6_BASE:1.153
	OPENBSD_3_5:1.153.0.2
	OPENBSD_3_5_BASE:1.153
	OPENBSD_3_4:1.145.0.2
	OPENBSD_3_4_BASE:1.145
	OPENBSD_3_3:1.140.0.2
	OPENBSD_3_3_BASE:1.140
	OPENBSD_3_2:1.136.0.2
	OPENBSD_3_2_BASE:1.136
	OPENBSD_3_1:1.125.0.2
	OPENBSD_3_1_BASE:1.125
	OPENBSD_3_0:1.105.0.2
	OPENBSD_3_0_BASE:1.105
	OPENBSD_2_9:1.95.0.2
	OPENBSD_2_9_BASE:1.95
	OPENBSD_2_8:1.79.0.2
	OPENBSD_2_8_BASE:1.79
	OPENBSD_2_7:1.71.0.2
	OPENBSD_2_7_BASE:1.71
	OPENBSD_2_6:1.57.0.2
	OPENBSD_2_6_BASE:1.57
	OPENBSD_2_5:1.53.0.2
	OPENBSD_2_5_BASE:1.53
	OPENBSD_2_4:1.49.0.2
	OPENBSD_2_4_BASE:1.49
	OPENBSD_2_3:1.45.0.2
	OPENBSD_2_3_BASE:1.45
	OPENBSD_2_2:1.44.0.2
	OPENBSD_2_2_BASE:1.44
	OPENBSD_2_1:1.35.0.2
	OPENBSD_2_1_BASE:1.35
	OPENBSD_2_0:1.21.0.2
	OPENBSD_2_0_BASE:1.21
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.223
date	2016.09.03.15.00.48;	author jca;	state Exp;
branches;
next	1.222;
commitid	sXVAB3GY5r78VbHv;

1.222
date	2016.09.03.14.53.20;	author jca;	state Exp;
branches;
next	1.221;
commitid	S7Fuvud7MLD4QyVR;

1.221
date	2016.08.31.13.43.36;	author jca;	state Exp;
branches;
next	1.220;
commitid	8jwjNnlduDRhzBwt;

1.220
date	2016.08.30.14.56.39;	author tedu;	state Exp;
branches;
next	1.219;
commitid	7aNtF7TxmgZ8ddc9;

1.219
date	2016.08.26.06.32.10;	author tedu;	state Exp;
branches;
next	1.218;
commitid	aiNxM8iy2xv5nTf9;

1.218
date	2016.08.14.22.56.29;	author guenther;	state Exp;
branches;
next	1.217;
commitid	8Smubfc3nikyhBi5;

1.217
date	2016.07.04.03.24.48;	author guenther;	state Exp;
branches;
next	1.216;
commitid	edxEc3ChY9S5lfHz;

1.216
date	2016.05.04.19.48.08;	author jca;	state Exp;
branches;
next	1.215;
commitid	pjrI8Uv5D3MXA8k7;

1.215
date	2016.04.25.15.43.34;	author deraadt;	state Exp;
branches;
next	1.214;
commitid	I3EQuSEiFuZ6Sj6q;

1.214
date	2016.04.06.07.14.17;	author semarie;	state Exp;
branches;
next	1.213;
commitid	VeRU8zouR7LTZnlI;

1.213
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.212;
commitid	JEVxsRygqcjPtWTf;

1.212
date	2015.12.12.20.09.28;	author mmcc;	state Exp;
branches;
next	1.211;
commitid	TosXyFD66Z0p2ETT;

1.211
date	2015.11.16.17.31.14;	author tedu;	state Exp;
branches;
next	1.210;
commitid	eR8GyZHrhWLCQlqG;

1.210
date	2015.10.25.23.10.53;	author millert;	state Exp;
branches;
next	1.209;
commitid	dV0xt6ZrATpHvSH7;

1.209
date	2015.10.04.11.58.09;	author tedu;	state Exp;
branches;
next	1.208;
commitid	npFkpN0ctNAVbBUf;

1.208
date	2015.09.01.06.50.53;	author jsg;	state Exp;
branches;
next	1.207;
commitid	mJakg7Uxj0Q61iyU;

1.207
date	2015.01.19.01.24.39;	author deraadt;	state Exp;
branches;
next	1.206;
commitid	JP1DuZI6Z7VzXXRK;

1.206
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.205;
commitid	Uu5nFG3wCl0LACBb;

1.205
date	2014.10.25.03.19.22;	author lteo;	state Exp;
branches;
next	1.204;
commitid	H62Mb5ByK9fun2vA;

1.204
date	2014.08.25.07.50.25;	author doug;	state Exp;
branches;
next	1.203;
commitid	vcwz0sp1JH7QzUmA;

1.203
date	2014.03.24.16.41.27;	author tedu;	state Exp;
branches;
next	1.202;

1.202
date	2014.03.17.23.23.37;	author sthen;	state Exp;
branches;
next	1.201;

1.201
date	2014.03.17.21.02.49;	author sthen;	state Exp;
branches;
next	1.200;

1.200
date	2014.03.17.20.54.10;	author sthen;	state Exp;
branches;
next	1.199;

1.199
date	2014.01.08.17.31.36;	author jca;	state Exp;
branches;
next	1.198;

1.198
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.197;

1.197
date	2013.07.26.18.13.02;	author guenther;	state Exp;
branches;
next	1.196;

1.196
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.194;

1.194
date	2011.12.14.18.01.55;	author ajacoutot;	state Exp;
branches;
next	1.193;

1.193
date	2011.02.09.21.13.31;	author millert;	state Exp;
branches;
next	1.192;

1.192
date	2010.08.27.12.00.21;	author lum;	state Exp;
branches;
next	1.191;

1.191
date	2010.08.01.16.53.57;	author tobias;	state Exp;
branches;
next	1.190;

1.190
date	2010.07.30.11.02.56;	author ray;	state Exp;
branches;
next	1.189;

1.189
date	2010.06.18.06.02.57;	author tobias;	state Exp;
branches;
next	1.188;

1.188
date	2010.06.13.15.27.46;	author tobias;	state Exp;
branches;
next	1.187;

1.187
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2009.04.20.21.04.25;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2008.09.30.16.16.21;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2008.09.12.16.12.08;	author moritz;	state Exp;
branches;
next	1.183;

1.183
date	2008.06.30.12.03.51;	author ragge;	state Exp;
branches;
next	1.182;

1.182
date	2008.04.13.00.22.16;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2007.09.02.15.19.20;	author deraadt;	state Exp;
branches;
next	1.180;

1.180
date	2007.07.31.03.35.04;	author ray;	state Exp;
branches;
next	1.179;

1.179
date	2007.07.27.14.12.46;	author moritz;	state Exp;
branches;
next	1.178;

1.178
date	2007.06.21.02.22.51;	author ray;	state Exp;
branches;
next	1.177;

1.177
date	2007.06.19.06.48.23;	author ray;	state Exp;
branches;
next	1.176;

1.176
date	2007.03.22.15.53.10;	author cloder;	state Exp;
branches;
next	1.175;

1.175
date	2007.03.01.20.06.27;	author otto;	state Exp;
branches;
next	1.174;

1.174
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.173;

1.173
date	2006.10.18.21.46.09;	author millert;	state Exp;
branches;
next	1.172;

1.172
date	2006.10.18.21.23.28;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2006.04.21.17.42.50;	author deraadt;	state Exp;
branches;
next	1.170;

1.170
date	2005.12.03.18.23.30;	author deraadt;	state Exp;
branches;
next	1.169;

1.169
date	2005.12.01.17.36.59;	author pvalchev;	state Exp;
branches;
next	1.168;

1.168
date	2005.08.22.17.49.37;	author mickey;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.14.14.48.47;	author moritz;	state Exp;
branches;
next	1.166;

1.166
date	2005.05.24.02.24.57;	author moritz;	state Exp;
branches;
next	1.165;

1.165
date	2005.05.24.02.12.40;	author moritz;	state Exp;
branches;
next	1.164;

1.164
date	2005.04.21.00.12.20;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2005.03.15.12.22.58;	author niallo;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2004.12.06.23.04.14;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2004.12.04.18.00.43;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2004.12.03.23.57.40;	author moritz;	state Exp;
branches;
next	1.159;

1.159
date	2004.11.28.22.29.44;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2004.11.28.19.36.48;	author henning;	state Exp;
branches;
next	1.157;

1.157
date	2004.11.28.19.12.31;	author henning;	state Exp;
branches;
next	1.156;

1.156
date	2004.11.28.18.49.29;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2004.11.22.00.05.15;	author millert;	state Exp;
branches;
next	1.154;

1.154
date	2004.09.30.20.33.52;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2003.12.12.19.45.22;	author deraadt;	state Exp;
branches;
next	1.152;

1.152
date	2003.12.10.22.57.12;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2003.12.09.22.55.47;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2003.12.09.07.22.10;	author beck;	state Exp;
branches;
next	1.149;

1.149
date	2003.11.20.12.32.34;	author jmc;	state Exp;
branches;
next	1.148;

1.148
date	2003.11.12.19.32.01;	author millert;	state Exp;
branches;
next	1.147;

1.147
date	2003.10.01.08.06.31;	author itojun;	state Exp;
branches;
next	1.146;

1.146
date	2003.09.30.06.13.08;	author jmc;	state Exp;
branches;
next	1.145;

1.145
date	2003.07.29.18.39.22;	author deraadt;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2003.07.07.03.18.11;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	2003.06.11.14.24.46;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.141;

1.141
date	2003.04.10.00.04.58;	author millert;	state Exp;
branches;
next	1.140;

1.140
date	2003.02.17.06.52.58;	author mpech;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2002.11.25.22.45.39;	author millert;	state Exp;
branches;
next	1.138;

1.138
date	2002.11.15.19.52.15;	author millert;	state Exp;
branches;
next	1.137;

1.137
date	2002.10.13.21.09.13;	author millert;	state Exp;
branches;
next	1.136;

1.136
date	2002.08.29.22.52.00;	author deraadt;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2002.08.20.18.18.55;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2002.07.24.23.17.07;	author millert;	state Exp;
branches;
next	1.133;

1.133
date	2002.07.24.23.10.01;	author millert;	state Exp;
branches;
next	1.132;

1.132
date	2002.07.20.17.55.45;	author millert;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.14.07.14.09;	author jakob;	state Exp;
branches;
next	1.130;

1.130
date	2002.07.02.18.09.54;	author danh;	state Exp;
branches;
next	1.129;

1.129
date	2002.06.17.19.33.37;	author danh;	state Exp;
branches;
next	1.128;

1.128
date	2002.06.09.00.37.37;	author itojun;	state Exp;
branches;
next	1.127;

1.127
date	2002.05.29.18.57.05;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2002.05.26.09.32.07;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2002.03.30.22.01.51;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2002.03.16.19.15.12;	author millert;	state Exp;
branches;
next	1.123;

1.123
date	2002.03.12.02.22.33;	author millert;	state Exp;
branches;
next	1.122;

1.122
date	2002.03.12.02.15.39;	author millert;	state Exp;
branches;
next	1.121;

1.121
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.120;

1.120
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.119;

1.119
date	2002.02.01.05.02.49;	author itojun;	state Exp;
branches;
next	1.118;

1.118
date	2002.02.01.04.53.28;	author itojun;	state Exp;
branches;
next	1.117;

1.117
date	2002.01.23.20.59.05;	author millert;	state Exp;
branches;
next	1.116;

1.116
date	2002.01.23.17.03.21;	author mpech;	state Exp;
branches;
next	1.115;

1.115
date	2002.01.23.16.31.18;	author mpech;	state Exp;
branches;
next	1.114;

1.114
date	2002.01.23.16.27.35;	author mpech;	state Exp;
branches;
next	1.113;

1.113
date	2002.01.07.03.56.02;	author millert;	state Exp;
branches;
next	1.112;

1.112
date	2001.12.18.00.27.57;	author millert;	state Exp;
branches;
next	1.111;

1.111
date	2001.12.17.23.02.53;	author millert;	state Exp;
branches;
next	1.110;

1.110
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.109;

1.109
date	2001.12.04.21.18.04;	author millert;	state Exp;
branches;
next	1.108;

1.108
date	2001.12.01.23.27.20;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2001.11.17.19.54.56;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2001.11.05.09.51.13;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2001.10.02.17.43.47;	author wilfried;	state Exp;
branches;
next	1.104;

1.104
date	2001.09.05.22.32.36;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2001.07.08.21.18.07;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2001.07.03.21.17.56;	author millert;	state Exp;
branches;
next	1.101;

1.101
date	2001.06.25.16.39.54;	author hin;	state Exp;
branches;
next	1.100;

1.100
date	2001.06.25.16.24.27;	author millert;	state Exp;
branches;
next	1.99;

1.99
date	2001.06.13.20.13.29;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2001.06.11.15.18.49;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2001.05.29.21.35.16;	author millert;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.11.15.34.02;	author art;	state Exp;
branches;
next	1.95;

1.95
date	2001.03.18.17.20.13;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2001.03.09.19.09.12;	author millert;	state Exp;
branches;
next	1.93;

1.93
date	2001.03.09.18.38.25;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2001.02.04.20.33.23;	author pjanzen;	state Exp;
branches;
next	1.91;

1.91
date	2001.02.03.21.48.47;	author pjanzen;	state Exp;
branches;
next	1.90;

1.90
date	2001.01.19.18.02.25;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2001.01.09.06.07.03;	author itojun;	state Exp;
branches;
next	1.88;

1.88
date	2001.01.09.05.07.01;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2001.01.07.07.38.34;	author angelos;	state Exp;
branches;
next	1.86;

1.86
date	2001.01.06.18.24.29;	author millert;	state Exp;
branches;
next	1.85;

1.85
date	2000.12.30.06.08.58;	author angelos;	state Exp;
branches;
next	1.84;

1.84
date	2000.12.04.10.49.31;	author itojun;	state Exp;
branches;
next	1.83;

1.83
date	2000.12.02.18.01.11;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2000.11.26.19.52.56;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	2000.11.23.16.50.51;	author itojun;	state Exp;
branches;
next	1.80;

1.80
date	2000.11.14.20.27.01;	author itojun;	state Exp;
branches;
next	1.79;

1.79
date	2000.09.15.07.13.45;	author deraadt;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2000.08.20.18.42.37;	author millert;	state Exp;
branches;
next	1.77;

1.77
date	2000.07.05.22.15.10;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2000.07.05.21.56.48;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2000.07.05.17.21.02;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2000.06.17.19.42.18;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2000.06.14.15.15.06;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2000.06.12.12.02.55;	author itojun;	state Exp;
branches;
next	1.71;

1.71
date	2000.04.29.14.02.59;	author deraadt;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2000.04.11.11.42.11;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2000.03.03.15.51.45;	author bitblt;	state Exp;
branches;
next	1.68;

1.68
date	2000.01.18.18.26.38;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2000.01.18.05.02.05;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2000.01.14.20.58.21;	author ericj;	state Exp;
branches;
next	1.65;

1.65
date	99.12.10.10.41.44;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	99.12.09.09.03.08;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	99.12.08.13.15.21;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	99.12.03.01.22.46;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	99.12.02.17.34.08;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	99.12.01.06.33.24;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	99.11.29.20.17.09;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	99.11.14.22.25.02;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	99.09.22.05.00.46;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	99.07.21.00.05.47;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	99.07.20.19.55.06;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	99.04.29.21.38.43;	author downsj;	state Exp;
branches;
next	1.53;

1.53
date	99.02.26.00.15.54;	author art;	state Exp;
branches;
next	1.52;

1.52
date	98.12.30.22.01.24;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	98.12.29.07.00.58;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	98.11.18.23.30.08;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	98.07.23.08.13.38;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	98.07.13.02.11.15;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	98.06.08.16.55.34;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	98.06.03.17.44.47;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	97.12.12.08.55.09;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	97.08.06.00.18.00;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	97.08.04.19.25.09;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	97.07.25.19.41.16;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	97.07.23.20.36.24;	author kstailey;	state Exp;
branches;
next	1.40;

1.40
date	97.06.29.07.39.02;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	97.06.29.07.35.44;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	97.06.21.12.44.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	97.06.05.09.22.41;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.06.01.06.40.34;	author downsj;	state Exp;
branches;
next	1.35;

1.35
date	97.05.01.14.45.37;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.04.25.11.06.28;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.03.25.22.47.10;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	97.01.23.06.49.11;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	97.01.15.23.40.58;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.01.05.21.28.07;	author bitblt;	state Exp;
branches;
next	1.29;

1.29
date	97.01.02.21.33.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	96.12.14.23.09.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	96.12.14.22.47.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	96.12.07.09.00.22;	author bitblt;	state Exp;
branches;
next	1.25;

1.25
date	96.12.03.03.07.17;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	96.10.19.12.20.02;	author michaels;	state Exp;
branches;
next	1.23;

1.23
date	96.10.18.20.12.45;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.10.15.12.29.27;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.09.29.22.11.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	96.09.22.09.49.58;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.09.04.15.40.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.09.04.14.41.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.08.27.10.08.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.08.25.21.04.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.08.13.06.34.39;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.08.10.06.12.12;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.08.08.16.22.37;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.08.07.03.27.54;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.08.07.03.17.58;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.07.03.04.22;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.07.29.05.32.59;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.07.29.03.06.35;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.07.29.00.03.19;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.07.28.23.32.16;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.07.28.22.42.45;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.07.28.19.45.36;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.07.27.07.26.39;	author joshd;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.10.09.20;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.16;	author deraadt;	state Exp;
branches;
next	;

1.71.2.1
date	2000.07.05.22.20.08;	author jason;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2000.12.15.19.51.27;	author jason;	state Exp;
branches;
next	;

1.79.2.1
date	2000.12.10.02.48.22;	author jason;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2001.04.23.21.13.53;	author jason;	state Exp;
branches;
next	;

1.136.2.1
date	2003.02.01.20.44.16;	author margarida;	state Exp;
branches;
next	;

1.140.2.1
date	2003.11.20.22.50.32;	author margarida;	state Exp;
branches;
next	1.140.2.2;

1.140.2.2
date	2003.12.20.20.44.29;	author margarida;	state Exp;
branches;
next	;

1.145.2.1
date	2003.11.20.20.44.27;	author brad;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2003.12.23.01.41.00;	author brad;	state Exp;
branches;
next	;

1.163.2.1
date	2005.07.14.23.34.32;	author brad;	state Exp;
branches;
next	;


desc
@@


1.223
log
@Use a single "opt" variable for all setsockopt calls in getdatasock().

on = 65536;
if (setsockopt(... &on ...)

is slightly misleading.
@
text
@/*	$OpenBSD: ftpd.c,v 1.222 2016/09/03 14:53:20 jca Exp $	*/
/*	$NetBSD: ftpd.c,v 1.15 1995/06/03 22:46:47 mycroft Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1988, 1990, 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * FTP server.
 */
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#define	FTP_NAMES
#include <arpa/ftp.h>
#include <arpa/inet.h>
#include <arpa/telnet.h>

#include <bsd_auth.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <limits.h>
#include <login_cap.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <vis.h>
#include <unistd.h>
#include <utmp.h>
#include <poll.h>

#include "pathnames.h"
#include "monitor.h"
#include "extern.h"

extern	off_t restart_point;
extern	char cbuf[];

union sockunion ctrl_addr;
union sockunion data_source;
union sockunion data_dest;
union sockunion his_addr;
union sockunion pasv_addr;

sigset_t allsigs;

int	daemon_mode = 0;
int	data;
int	logged_in;
struct	passwd *pw;
int	debug = 0;
int	timeout = 900;    /* timeout after 15 minutes of inactivity */
int	maxtimeout = 7200;/* don't allow idle time to be set beyond 2 hours */
int	logging;
int	anon_ok = 1;
int	anon_only = 0;
unsigned int minuid = 1000;
int	multihome = 0;
int	guest;
int	stats;
int	statfd = -1;
int	portcheck = 1;
int	dochroot;
int	type;
int	form;
int	stru;			/* avoid C keyword */
int	mode;
int	doutmp = 0;		/* update utmp file */
int	nowtmp = 0;		/* do not update wtmp file */
int	usedefault = 1;		/* for data transfers */
int	pdata = -1;		/* for passive mode */
int	family = AF_UNSPEC;
volatile sig_atomic_t transflag;
off_t	file_size;
off_t	byte_count;
mode_t	defumask = S_IWGRP|S_IWOTH;		/* default umask value */
int	umaskchange = 1;		/* allow user to change umask value. */
char	tmpline[7];
char	hostname[HOST_NAME_MAX+1];
char	remotehost[HOST_NAME_MAX+1];
char	dhostname[HOST_NAME_MAX+1];
char	*guestpw;
char	ttyline[20];
static struct utmp utmp;	/* for utmp */
static	login_cap_t *lc;
static	auth_session_t *as;
static	volatile sig_atomic_t recvurg;

int epsvall = 0;

/*
 * Timeout intervals for retrying connections
 * to hosts that don't accept PORT cmds.  This
 * is a kludge, but given the problems with TCP...
 */
#define	SWAITMAX	90	/* wait at most 90 seconds */
#define	SWAITINT	5	/* interval between retries */

int	swaitmax = SWAITMAX;
int	swaitint = SWAITINT;

char	proctitle[BUFSIZ];	/* initial part of title */

#define LOGCMD(cmd, file) \
	if (logging > 1) \
	    syslog(LOG_INFO,"%s %s%s", cmd, \
		*(file) == '/' ? "" : curdir(), file);
#define LOGCMD2(cmd, file1, file2) \
	 if (logging > 1) \
	    syslog(LOG_INFO,"%s %s%s %s%s", cmd, \
		*(file1) == '/' ? "" : curdir(), file1, \
		*(file2) == '/' ? "" : curdir(), file2);
#define LOGBYTES(cmd, file, cnt) \
	if (logging > 1) { \
		if ((cnt) == -1) \
		    syslog(LOG_INFO,"%s %s%s", cmd, \
			*(file) == '/' ? "" : curdir(), file); \
		else \
		    syslog(LOG_INFO, "%s %s%s = %lld bytes", \
			cmd, (*(file) == '/') ? "" : curdir(), file, \
			(long long)(cnt)); \
	}

static void	 ack(char *);
static void	 sigurg(int);
static void	 myoob(void);
static int	 checkuser(char *, char *);
static FILE	*dataconn(char *, off_t, char *);
static void	 dolog(struct sockaddr *);
static char	*copy_dir(char *, struct passwd *);
static char	*curdir(void);
static void	 end_login(void);
static FILE	*getdatasock(char *);
static int	 guniquefd(char *, char **);
static void	 lostconn(int);
static void	 sigquit(int);
static int	 receive_data(FILE *, FILE *);
static void	 replydirname(const char *, const char *);
static int	 send_data(FILE *, FILE *, off_t, off_t, int);
static struct passwd *
		 sgetpwnam(char *, struct passwd *);
static void	 reapchild(int);
static void	 usage(void);

void	 logxfer(char *, off_t, time_t);
void	 set_slave_signals(void);

static char *
curdir(void)
{
	static char path[PATH_MAX+1];	/* path + '/' */

	if (getcwd(path, sizeof(path)-1) == NULL)
		return ("");
	if (path[1] != '\0')		/* special case for root dir. */
		strlcat(path, "/", sizeof path);
	/* For guest account, skip / since it's chrooted */
	return (guest ? path+1 : path);
}

char *argstr = "AdDhnlm:MSt:T:u:PUvW46";

static void
usage(void)
{
	syslog(LOG_ERR,
	    "usage: ftpd [-46ADdlMnPSUW] [-m minuid] [-T maxtimeout] "
	    "[-t timeout] [-u mask]");
	exit(2);
}

int
main(int argc, char *argv[])
{
	socklen_t addrlen;
	int ch, on = 1, tos;
	char line[LINE_MAX];
	FILE *fp;
	struct hostent *hp;
	struct sigaction sa;
	int error = 0;
	const char *errstr;

	tzset();		/* in case no timezone database in ~ftp */
	sigfillset(&allsigs);	/* used to block signals while root */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;

	while ((ch = getopt(argc, argv, argstr)) != -1) {
		switch (ch) {
		case 'A':
			anon_only = 1;
			break;

		case 'd':
		case 'v':		/* deprecated */
			debug = 1;
			break;

		case 'D':
			daemon_mode = 1;
			break;

		case 'P':
			portcheck = 0;
			break;

		case 'h':		/* deprecated */
			break;

		case 'l':
			logging++;	/* > 1 == extra logging */
			break;

		case 'm':
			minuid = strtonum(optarg, 0, UINT_MAX, &errstr);
			if (errstr) {
				syslog(LOG_ERR,
				    "%s is a bad value for -m, aborting",
				    optarg);
				exit(2);
			}
			break;

		case 'M':
			multihome = 1;
			break;

		case 'n':
			anon_ok = 0;
			break;

		case 'S':
			stats = 1;
			break;

		case 't':
			timeout = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				syslog(LOG_ERR,
				    "%s is a bad value for -t, aborting",
				    optarg);
				exit(2);
			}
			if (maxtimeout < timeout)
				maxtimeout = timeout;
			break;

		case 'T':
			maxtimeout = strtonum(optarg, 0, INT_MAX,
			    &errstr);
			if (errstr) {
				syslog(LOG_ERR,
				    "%s is a bad value for -T, aborting",
				    optarg);
				exit(2);
			}
			if (timeout > maxtimeout)
				timeout = maxtimeout;
			break;

		case 'u':
		    {
			long val = 0;
			char *p;
			umaskchange = 0;

			val = strtol(optarg, &p, 8);
			if (*optarg == '\0' || *p != '\0' || val < 0 ||
			    (val & ~ACCESSPERMS)) {
				syslog(LOG_ERR,
				    "%s is a bad value for -u, aborting",
				    optarg);
				exit(2);
			}
			defumask = val;
			break;
		    }

		case 'U':
			doutmp = 1;
			break;

		case 'W':
			nowtmp = 1;
			break;

		case '4':
			family = AF_INET;
			break;

		case '6':
			family = AF_INET6;
			break;

		default:
			usage();
			break;
		}
	}

	if (nowtmp && doutmp) {
		syslog(LOG_ERR, "options 'U' and 'W' are mutually exclusive");
		exit(1);
	}

	(void) freopen(_PATH_DEVNULL, "w", stderr);

	/*
	 * LOG_NDELAY sets up the logging connection immediately,
	 * necessary for anonymous ftp's that chroot and can't do it later.
	 */
	openlog("ftpd", LOG_PID | LOG_NDELAY, LOG_FTP);

	if (getpwnam(FTPD_PRIVSEP_USER) == NULL) {
		syslog(LOG_ERR, "privilege separation user %s not found",
		    FTPD_PRIVSEP_USER);
		exit(1);
	}
	endpwent();

	if (daemon_mode) {
		int *fds, i, fd;
		struct pollfd *pfds;
		struct addrinfo hints, *res, *res0;
		nfds_t n;

		/*
		 * Detach from parent.
		 */
		if (daemon(1, 1) < 0) {
			syslog(LOG_ERR, "failed to become a daemon");
			exit(1);
		}
		sa.sa_handler = reapchild;
		(void) sigaction(SIGCHLD, &sa, NULL);

		memset(&hints, 0, sizeof(hints));
		hints.ai_family = family;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
		hints.ai_flags = AI_PASSIVE;
		error = getaddrinfo(NULL, "ftp", &hints, &res0);
		if (error) {
			syslog(LOG_ERR, "%s", gai_strerror(error));
			exit(1);
		}

		n = 0;
		for (res = res0; res; res = res->ai_next)
			n++;

		fds = calloc(n, sizeof(int));
		pfds = calloc(n, sizeof(struct pollfd));
		if (!fds || !pfds) {
			syslog(LOG_ERR, "%s", strerror(errno));
			exit(1);
		}

		/*
		 * Open sockets, bind it to the FTP port, and start
		 * listening.
		 */
		n = 0;
		for (res = res0; res; res = res->ai_next) {
			fds[n] = socket(res->ai_family, res->ai_socktype,
			    res->ai_protocol);
			if (fds[n] < 0)
				continue;

			if (setsockopt(fds[n], SOL_SOCKET, SO_KEEPALIVE,
			    &on, sizeof(on)) < 0) {
				close(fds[n]);
				fds[n] = -1;
				continue;
			}

			if (setsockopt(fds[n], SOL_SOCKET, SO_REUSEADDR,
			    &on, sizeof(on)) < 0) {
				close(fds[n]);
				fds[n] = -1;
				continue;
			}

			if (bind(fds[n], res->ai_addr, res->ai_addrlen) < 0) {
				close(fds[n]);
				fds[n] = -1;
				continue;
			}
			if (listen(fds[n], 32) < 0) {
				close(fds[n]);
				fds[n] = -1;
				continue;
			}

			pfds[n].fd = fds[n];
			pfds[n].events = POLLIN;
			n++;
		}
		freeaddrinfo(res0);

		if (n == 0) {
			syslog(LOG_ERR, "could not open control socket");
			exit(1);
		}

		/*
		 * Loop forever accepting connection requests and forking off
		 * children to handle them.
		 */
		while (1) {
			if (poll(pfds, n, INFTIM) < 0) {
				if (errno == EINTR)
					continue;
				syslog(LOG_ERR, "poll: %m");
				exit(1);
			}
			for (i = 0; i < n; i++)
				if (pfds[i].revents & POLLIN) {
					addrlen = sizeof(his_addr);
					fd = accept(pfds[i].fd,
					    (struct sockaddr *)&his_addr,
					    &addrlen);
					if (fd != -1) {
						if (fork() == 0)
							goto child;
						close(fd);
					}
				}
		}

	child:
		/* child */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		for (i = 0; i < n; i++)
			close(fds[i]);
	} else {
		addrlen = sizeof(his_addr);
		if (getpeername(0, (struct sockaddr *)&his_addr,
		    &addrlen) < 0) {
			/* syslog(LOG_ERR, "getpeername (%s): %m", argv[0]); */
			exit(1);
		}
	}

	/* set this here so klogin can use it... */
	(void)snprintf(ttyline, sizeof(ttyline), "ftp%ld", (long)getpid());

	set_slave_signals();

	addrlen = sizeof(ctrl_addr);
	if (getsockname(0, (struct sockaddr *)&ctrl_addr, &addrlen) < 0) {
		syslog(LOG_ERR, "getsockname: %m");
		exit(1);
	}
	if (his_addr.su_family == AF_INET6 &&
	    IN6_IS_ADDR_V4MAPPED(&his_addr.su_sin6.sin6_addr)) {
		syslog(LOG_WARNING,
		    "Connection from IPv4 mapped address is not supported.");
		reply(530, "System not available.");
		exit(1);
	}
	tos = IPTOS_LOWDELAY;
	switch (his_addr.su_family) {
	case AF_INET:
		if (setsockopt(0, IPPROTO_IP, IP_TOS, &tos,
		    sizeof(int)) < 0)
			syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
		break;
	case AF_INET6:
		if (setsockopt(0, IPPROTO_IPV6, IPV6_TCLASS, &tos,
		    sizeof(int)) < 0)
			syslog(LOG_WARNING, "setsockopt (IPV6_TCLASS): %m");
		break;
	}
	data_source.su_port = htons(ntohs(ctrl_addr.su_port) - 1);

	/* Try to handle urgent data inline */
	if (setsockopt(0, SOL_SOCKET, SO_OOBINLINE, &on, sizeof(on)) < 0)
		syslog(LOG_ERR, "setsockopt: %m");

	dolog((struct sockaddr *)&his_addr);

	/*
	 * Set up default state
	 */
	data = -1;
	type = TYPE_A;
	form = FORM_N;
	stru = STRU_F;
	mode = MODE_S;
	tmpline[0] = '\0';

	/* If logins are disabled, print out the message. */
	if ((fp = fopen(_PATH_NOLOGIN, "r")) != NULL) {
		while (fgets(line, sizeof(line), fp) != NULL) {
			line[strcspn(line, "\n")] = '\0';
			lreply(530, "%s", line);
		}
		(void) fflush(stdout);
		(void) fclose(fp);
		reply(530, "System not available.");
		exit(0);
	}
	if ((fp = fopen(_PATH_FTPWELCOME, "r")) != NULL) {
		while (fgets(line, sizeof(line), fp) != NULL) {
			line[strcspn(line, "\n")] = '\0';
			lreply(220, "%s", line);
		}
		(void) fflush(stdout);
		(void) fclose(fp);
		/* reply(220,) must follow */
	}
	(void) gethostname(hostname, sizeof(hostname));

	/* Make sure hostname is fully qualified. */
	hp = gethostbyname(hostname);
	if (hp != NULL)
		strlcpy(hostname, hp->h_name, sizeof(hostname));

	if (multihome) {
		error = getnameinfo((struct sockaddr *)&ctrl_addr,
		    ctrl_addr.su_len, dhostname, sizeof(dhostname), NULL, 0, 0);
	}

	if (error != 0)
		reply(220, "FTP server ready.");
	else
		reply(220, "%s FTP server ready.",
		    (multihome ? dhostname : hostname));

	monitor_init();

	for (;;)
		(void) yyparse();
	/* NOTREACHED */
}

/*
 * Signal handlers.
 */
/*ARGSUSED*/
static void
lostconn(int signo)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	sdata.log_fac = LOG_FTP;
	if (debug)
		syslog_r(LOG_DEBUG, &sdata, "lost connection");
	dologout(1);
}

static void
sigquit(int signo)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	sdata.log_fac = LOG_FTP;
	syslog_r(LOG_DEBUG, &sdata, "got signal %s", sys_signame[signo]);
	dologout(1);
}

/*
 * Save the result of a getpwnam.  Used for USER command, since
 * the data returned must not be clobbered by any other command
 * (e.g., globbing).
 */
static struct passwd *
sgetpwnam(char *name, struct passwd *pw)
{
	static struct passwd *save;
	struct passwd *old;

	if (pw == NULL && (pw = getpwnam(name)) == NULL)
		return (NULL);
	old = save;
	save = pw_dup(pw);
	if (save == NULL) {
		perror_reply(421, "Local resource failure: malloc");
		dologout(1);
		/* NOTREACHED */
	}
	if (old) {
		explicit_bzero(old->pw_passwd, strlen(old->pw_passwd));
		free(old);
	}
	return (save);
}

static int login_attempts;	/* number of failed login attempts */
static int askpasswd;		/* had user command, ask for passwd */
static char curname[LOGIN_NAME_MAX];	/* current USER name */

/*
 * USER command.
 * Sets global passwd pointer pw if named account exists and is acceptable;
 * sets askpasswd if a PASS command is expected.  If logged in previously,
 * need to reset state.  If name is "ftp" or "anonymous", the name is not in
 * _PATH_FTPUSERS, and ftp account exists, set guest and pw, then just return.
 * If account doesn't exist, ask for passwd anyway.  Otherwise, check user
 * requesting login privileges.  Disallow anyone who does not have a standard
 * shell as returned by getusershell().  Disallow anyone mentioned in the file
 * _PATH_FTPUSERS to allow people such as root and uucp to be avoided.
 */
void
user(char *name)
{
	char *cp, *shell, *style, *host;
	char *class = NULL;

	if (logged_in) {
		kill_slave("user already logged in");
		end_login();
	}

	/* Close session from previous user if there was one. */
	if (as) {
		auth_close(as);
		as = NULL;
	}
	if (lc) {
		login_close(lc);
		lc = NULL;
	}

	if ((style = strchr(name, ':')) != NULL)
		*style++ = 0;

	guest = 0;
	askpasswd = 0;
	host = multihome ? dhostname : hostname;
	if (anon_ok &&
	    (strcmp(name, "ftp") == 0 || strcmp(name, "anonymous") == 0)) {
		if (checkuser(_PATH_FTPUSERS, "ftp") ||
		    checkuser(_PATH_FTPUSERS, "anonymous"))
			reply(530, "User %s access denied.", name);
		else if ((pw = sgetpwnam("ftp", NULL)) != NULL) {
			if ((lc = login_getclass(pw->pw_class)) == NULL ||
			    (as = auth_open()) == NULL ||
			    auth_setpwd(as, pw) != 0 ||
			    auth_setoption(as, "FTPD_HOST", host) < 0) {
				if (as) {
					auth_close(as);
					as = NULL;
				}
				if (lc) {
					login_close(lc);
					lc = NULL;
				}
				reply(421, "Local resource failure");
				return;
			}
			guest = 1;
			askpasswd = 1;
			reply(331,
			"Guest login ok, send your email address as password.");
		} else
			reply(530, "User %s unknown.", name);
		if (!askpasswd && logging)
			syslog(LOG_NOTICE,
			    "ANONYMOUS FTP LOGIN REFUSED FROM %s", remotehost);
		return;
	}

	shell = _PATH_BSHELL;
	if ((pw = sgetpwnam(name, NULL))) {
		class = pw->pw_class;
		if (pw->pw_shell != NULL && *pw->pw_shell != '\0')
			shell = pw->pw_shell;
		while ((cp = getusershell()) != NULL)
			if (strcmp(cp, shell) == 0)
				break;
		shell = cp;
		endusershell();
	}

	/* Get login class; if invalid style treat like unknown user. */
	lc = login_getclass(class);
	if (lc && (style = login_getstyle(lc, style, "auth-ftp")) == NULL) {
		login_close(lc);
		lc = NULL;
		pw = NULL;
	}

	/* Do pre-authentication setup. */
	if (lc && ((as = auth_open()) == NULL ||
	    (pw != NULL && auth_setpwd(as, pw) != 0) ||
	    auth_setitem(as, AUTHV_STYLE, style) < 0 ||
	    auth_setitem(as, AUTHV_NAME, name) < 0 ||
	    auth_setitem(as, AUTHV_CLASS, class) < 0 ||
	    auth_setoption(as, "login", "yes") < 0 ||
	    auth_setoption(as, "notickets", "yes") < 0 ||
	    auth_setoption(as, "FTPD_HOST", host) < 0)) {
		if (as) {
			auth_close(as);
			as = NULL;
		}
		login_close(lc);
		lc = NULL;
		reply(421, "Local resource failure");
		return;
	}
	if (logging)
		strlcpy(curname, name, sizeof(curname));

	dochroot = (lc && login_getcapbool(lc, "ftp-chroot", 0)) ||
	    checkuser(_PATH_FTPCHROOT, name);
	if (anon_only && !dochroot) {
		reply(530, "User %s access denied.", name);
		return;
	}
	if (pw) {
		if (pw->pw_uid < minuid) {
			reply(530, "User %s access denied.", name);
			if (logging)
				syslog(LOG_NOTICE,
				    "FTP LOGIN REFUSED FROM %s, %s (UID))",
				    remotehost, name);
			return;
		}
		if ((!shell && !dochroot) || checkuser(_PATH_FTPUSERS, name)) {
			reply(530, "User %s access denied.", name);
			if (logging)
				syslog(LOG_NOTICE,
				    "FTP LOGIN REFUSED FROM %s, %s",
				    remotehost, name);
			pw = NULL;
			return;
		}
	}

	if (as != NULL && (cp = auth_challenge(as)) != NULL)
		reply(331, "%s", cp);
	else
		reply(331, "Password required for %s.", name);

	askpasswd = 1;
	/*
	 * Delay before reading passwd after first failed
	 * attempt to slow down passwd-guessing programs.
	 */
	if (login_attempts)
		sleep((unsigned) login_attempts);
}

/*
 * Check if a user is in the file "fname"
 */
static int
checkuser(char *fname, char *name)
{
	FILE *fp;
	int found = 0;
	char *p, line[BUFSIZ];

	if ((fp = fopen(fname, "r")) != NULL) {
		while (fgets(line, sizeof(line), fp) != NULL)
			if ((p = strchr(line, '\n')) != NULL) {
				*p = '\0';
				if (line[0] == '#')
					continue;
				if (strcmp(line, name) == 0) {
					found = 1;
					break;
				}
			}
		(void) fclose(fp);
	}
	return (found);
}

/*
 * Terminate login as previous user, if any, resetting state;
 * used when USER command is given or login fails.
 */
static void
end_login(void)
{
	sigprocmask (SIG_BLOCK, &allsigs, NULL);
	if (logged_in) {
		if (!nowtmp)
			ftpdlogwtmp(ttyline, "", "");
		if (doutmp)
			ftpd_logout(utmp.ut_line);
	}
	reply(530, "Please reconnect to work as another user");
	_exit(0);
}

enum auth_ret
pass(char *passwd)
{
	int authok;
	unsigned int flags;
	FILE *fp;
	static char homedir[PATH_MAX];
	char *motd, *dir, rootdir[PATH_MAX];
	size_t sz_pw_dir;

	if (logged_in || askpasswd == 0) {
		reply(503, "Login with USER first.");
		return (AUTH_FAILED);
	}
	askpasswd = 0;
	if (!guest) {		/* "ftp" is only account allowed no password */
		authok = 0;
		if (pw == NULL || pw->pw_passwd[0] == '\0') {
			useconds_t us;

			/* Sleep between 1 and 3 seconds to emulate a crypt. */
			us = arc4random_uniform(3000000);
			usleep(us);
			if (as != NULL) {
				auth_close(as);
				as = NULL;
			}
		} else {
			authok = auth_userresponse(as, passwd, 0);
			as = NULL;
		}
		if (authok == 0) {
			reply(530, "Login incorrect.");
			if (logging)
				syslog(LOG_NOTICE,
				    "FTP LOGIN FAILED FROM %s, %s",
				    remotehost, curname);
			pw = NULL;
			if (login_attempts++ >= 5) {
				syslog(LOG_NOTICE,
				    "repeated login failures from %s",
				    remotehost);
				kill_slave("repeated login failures");
				_exit(0);
			}
			return (AUTH_FAILED);
		}
	} else if (lc != NULL) {
		/* Save anonymous' password. */
		free(guestpw);
		guestpw = strdup(passwd);
		if (guestpw == NULL) {
			kill_slave("out of mem");
			fatal("Out of memory.");
		}

		authok = auth_approval(as, lc, pw->pw_name, "ftp");
		auth_close(as);
		as = NULL;
		if (authok == 0) {
			syslog(LOG_INFO|LOG_AUTH,
			    "FTP LOGIN FAILED (HOST) as %s: approval failure.",
			    pw->pw_name);
			reply(530, "Approval failure.");
			kill_slave("approval failure");
			_exit(0);
		}
	} else {
		syslog(LOG_INFO|LOG_AUTH,
		    "FTP LOGIN CLASS %s MISSING for %s: approval failure.",
		    pw->pw_class, pw->pw_name);
		reply(530, "Permission denied.");
		kill_slave("permission denied");
		_exit(0);
	}

	if (monitor_post_auth() == 1) {
		/* Post-auth monitor process */
		logged_in = 1;
		return (AUTH_MONITOR);
	}

	login_attempts = 0;		/* this time successful */
	/* set umask via setusercontext() unless -u flag was given. */
	flags = LOGIN_SETGROUP|LOGIN_SETPRIORITY|LOGIN_SETRESOURCES;
	if (umaskchange)
		flags |= LOGIN_SETUMASK;
	else
		(void) umask(defumask);
	if (setusercontext(lc, pw, 0, flags) != 0) {
		perror_reply(421, "Local resource failure: setusercontext");
		syslog(LOG_NOTICE, "setusercontext: %m");
		dologout(1);
		/* NOTREACHED */
	}

	/* open wtmp before chroot */
	if (!nowtmp)
		ftpdlogwtmp(ttyline, pw->pw_name, remotehost);

	/* open utmp before chroot */
	if (doutmp) {
		memset(&utmp, 0, sizeof(utmp));
		(void)time(&utmp.ut_time);
		(void)strncpy(utmp.ut_name, pw->pw_name, sizeof(utmp.ut_name));
		(void)strncpy(utmp.ut_host, remotehost, sizeof(utmp.ut_host));
		(void)strncpy(utmp.ut_line, ttyline, sizeof(utmp.ut_line));
		ftpd_login(&utmp);
	}

	/* open stats file before chroot */
	if (guest && (stats == 1) && (statfd < 0))
		if ((statfd = open(_PATH_FTPDSTATFILE, O_WRONLY|O_APPEND)) < 0)
			stats = 0;

	logged_in = 1;

	if ((dir = login_getcapstr(lc, "ftp-dir", NULL, NULL))) {
		char *newdir;

		newdir = copy_dir(dir, pw);
		if (newdir == NULL) {
			perror_reply(421, "Local resource failure: malloc");
			dologout(1);
			/* NOTREACHED */
		}
		pw->pw_dir = newdir;
		pw = sgetpwnam(NULL, pw);
		free(dir);
		free(newdir);
	}

	/* make sure pw->pw_dir is big enough to hold "/" */
	sz_pw_dir = strlen(pw->pw_dir) + 1;
	if (sz_pw_dir < 2) {
		pw->pw_dir = "/";
		pw = sgetpwnam(NULL, pw);
		sz_pw_dir = 2;
	}

	if (guest || dochroot) {
		if (multihome && guest) {
			struct stat ts;

			/* Compute root directory. */
			snprintf(rootdir, sizeof(rootdir), "%s/%s",
			    pw->pw_dir, dhostname);
			if (stat(rootdir, &ts) < 0) {
				snprintf(rootdir, sizeof(rootdir), "%s/%s",
				    pw->pw_dir, hostname);
			}
		} else
			strlcpy(rootdir, pw->pw_dir, sizeof(rootdir));
	}
	if (guest) {
		/*
		 * We MUST do a chdir() after the chroot. Otherwise
		 * the old current directory will be accessible as "."
		 * outside the new root!
		 */
		if (chroot(rootdir) < 0 || chdir("/") < 0) {
			reply(550, "Can't set guest privileges.");
			goto bad;
		}
		strlcpy(pw->pw_dir, "/", sz_pw_dir);
		if (setenv("HOME", "/", 1) == -1) {
			reply(550, "Can't setup environment.");
			goto bad;
		}
	} else if (dochroot) {
		if (chroot(rootdir) < 0 || chdir("/") < 0) {
			reply(550, "Can't change root.");
			goto bad;
		}
		strlcpy(pw->pw_dir, "/", sz_pw_dir);
		if (setenv("HOME", "/", 1) == -1) {
			reply(550, "Can't setup environment.");
			goto bad;
		}
	} else if (chdir(pw->pw_dir) < 0) {
		if (chdir("/") < 0) {
			reply(530, "User %s: can't change directory to %s.",
			    pw->pw_name, pw->pw_dir);
			goto bad;
		} else
			lreply(230, "No directory! Logging in with home=/");
	}
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0) {
		reply(550, "Can't set gid.");
		goto bad;
	}
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0) {
		reply(550, "Can't set uid.");
		goto bad;
	}
	sigprocmask(SIG_UNBLOCK, &allsigs, NULL);

	/*
	 * Set home directory so that use of ~ (tilde) works correctly.
	 */
	if (getcwd(homedir, PATH_MAX) != NULL) {
		if (setenv("HOME", homedir, 1) == -1) {
			reply(550, "Can't setup environment.");
			goto bad;
		}
	}

	/*
	 * Display a login message, if it exists.
	 * N.B. reply(230,) must follow the message.
	 */
	motd = login_getcapstr(lc, "welcome", NULL, NULL);
	if ((fp = fopen(motd ? motd : _PATH_FTPLOGINMESG, "r")) != NULL) {
		char line[LINE_MAX];

		while (fgets(line, sizeof(line), fp) != NULL) {
			line[strcspn(line, "\n")] = '\0';
			lreply(230, "%s", line);
		}
		(void) fflush(stdout);
		(void) fclose(fp);
	}
	free(motd);
	if (guest) {
		reply(230, "Guest login ok, access restrictions apply.");
		snprintf(proctitle, sizeof(proctitle),
		    "%s: anonymous/%.*s", remotehost,
		    (int)(sizeof(proctitle) - sizeof(remotehost) -
		    sizeof(": anonymous/")), passwd);
		setproctitle("%s", proctitle);
		if (logging)
			syslog(LOG_INFO, "ANONYMOUS FTP LOGIN FROM %s, %s",
			    remotehost, passwd);
	} else {
		reply(230, "User %s logged in.", pw->pw_name);
		snprintf(proctitle, sizeof(proctitle),
		    "%s: %s", remotehost, pw->pw_name);
		setproctitle("%s", proctitle);
		if (logging)
			syslog(LOG_INFO, "FTP LOGIN FROM %s as %s",
			    remotehost, pw->pw_name);
	}
	login_close(lc);
	lc = NULL;
	return (AUTH_SLAVE);
bad:
	/* Forget all about it... */
	login_close(lc);
	lc = NULL;
	end_login();
	return (AUTH_FAILED);
}

void
retrieve(char *cmd, char *name)
{
	FILE *fin, *dout;
	struct stat st;
	pid_t pid;
	time_t start;

	if (cmd == NULL) {
		fin = fopen(name, "r");
		st.st_size = 0;
	} else {
		char line[BUFSIZ];

		(void) snprintf(line, sizeof(line), cmd, name);
		name = line;
		fin = ftpd_popen(line, "r", &pid);
		st.st_size = -1;
		st.st_blksize = BUFSIZ;
	}
	if (fin == NULL) {
		if (errno != 0) {
			perror_reply(550, name);
			if (cmd == NULL) {
				LOGCMD("get", name);
			}
		}
		return;
	}
	byte_count = -1;
	if (cmd == NULL &&
	    (fstat(fileno(fin), &st) < 0 || !S_ISREG(st.st_mode))) {
		reply(550, "%s: not a plain file.", name);
		goto done;
	}
	if (restart_point) {
		if (type == TYPE_A) {
			off_t i, n;
			int c;

			n = restart_point;
			i = 0;
			while (i++ < n) {
				if ((c = getc(fin)) == EOF) {
					if (ferror(fin)) {
						perror_reply(550, name);
						goto done;
					} else
						break;
				}
				if (c == '\n')
					i++;
			}
		} else if (lseek(fileno(fin), restart_point, SEEK_SET) < 0) {
			perror_reply(550, name);
			goto done;
		}
	}
	dout = dataconn(name, st.st_size, "w");
	if (dout == NULL)
		goto done;
	time(&start);
	send_data(fin, dout, st.st_blksize, st.st_size,
	    (restart_point == 0 && cmd == NULL && S_ISREG(st.st_mode)));
	if ((cmd == NULL) && stats)
		logxfer(name, byte_count, start);
	(void) fclose(dout);
	data = -1;
done:
	if (pdata >= 0)
		(void) close(pdata);
	pdata = -1;
	if (cmd == NULL) {
		LOGBYTES("get", name, byte_count);
		fclose(fin);
	} else {
		ftpd_pclose(fin, pid);
	}
}

void
store(char *name, char *mode, int unique)
{
	FILE *fout, *din;
	int (*closefunc)(FILE *);
	struct stat st;
	int fd;

	if (restart_point && *mode != 'a')
		mode = "r+";

	if (unique && stat(name, &st) == 0) {
		char *nam;

		fd = guniquefd(name, &nam);
		if (fd == -1) {
			LOGCMD(*mode == 'w' ? "put" : "append", name);
			return;
		}
		name = nam;
		fout = fdopen(fd, mode);
	} else
		fout = fopen(name, mode);

	closefunc = fclose;
	if (fout == NULL) {
		perror_reply(553, name);
		LOGCMD(*mode == 'w' ? "put" : "append", name);
		return;
	}
	byte_count = -1;
	if (restart_point) {
		if (type == TYPE_A) {
			off_t i, n;
			int c;

			n = restart_point;
			i = 0;
			while (i++ < n) {
				if ((c = getc(fout)) == EOF) {
					if (ferror(fout)) {
						perror_reply(550, name);
						goto done;
					} else
						break;
				}
				if (c == '\n')
					i++;
			}
			/*
			 * We must do this seek to "current" position
			 * because we are changing from reading to
			 * writing.
			 */
			if (fseek(fout, 0, SEEK_CUR) < 0) {
				perror_reply(550, name);
				goto done;
			}
		} else if (lseek(fileno(fout), restart_point, SEEK_SET) < 0) {
			perror_reply(550, name);
			goto done;
		}
	}
	din = dataconn(name, -1, "r");
	if (din == NULL)
		goto done;
	if (receive_data(din, fout) == 0) {
		if (unique)
			reply(226, "Transfer complete (unique file name:%s).",
			    name);
		else
			reply(226, "Transfer complete.");
	}
	(void) fclose(din);
	data = -1;
	pdata = -1;
done:
	LOGBYTES(*mode == 'w' ? "put" : "append", name, byte_count);
	(*closefunc)(fout);
}

static FILE *
getdatasock(char *mode)
{
	int opt, s, t, tries;

	if (data >= 0)
		return (fdopen(data, mode));
	sigprocmask (SIG_BLOCK, &allsigs, NULL);
	s = monitor_socket(ctrl_addr.su_family);
	if (s < 0)
		goto bad;
	opt = 1;
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
	    &opt, sizeof(opt)) < 0)
		goto bad;
	/* anchor socket to avoid multi-homing problems */
	data_source = ctrl_addr;
	data_source.su_port = htons(20); /* ftp-data port */
	for (tries = 1; ; tries++) {
		if (monitor_bind(s, (struct sockaddr *)&data_source,
		    data_source.su_len) >= 0)
			break;
		if (errno != EADDRINUSE || tries > 10)
			goto bad;
		sleep((unsigned int)tries);
	}
	sigprocmask (SIG_UNBLOCK, &allsigs, NULL);

	opt = IPTOS_THROUGHPUT;
	switch (ctrl_addr.su_family) {
	case AF_INET:
		if (setsockopt(s, IPPROTO_IP, IP_TOS, &opt,
		    sizeof(opt)) < 0)
			syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
		break;
	case AF_INET6:
		if (setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &opt,
		    sizeof(opt)) < 0)
			syslog(LOG_WARNING, "setsockopt (IPV6_TCLASS): %m");
		break;
	}
	/*
	 * Turn off push flag to keep sender TCP from sending short packets
	 * at the boundaries of each write().  Should probably do a SO_SNDBUF
	 * to set the send buffer size as well, but that may not be desirable
	 * in heavy-load situations.
	 */
	opt = 1;
	if (setsockopt(s, IPPROTO_TCP, TCP_NOPUSH, &opt, sizeof(opt)) < 0)
		syslog(LOG_WARNING, "setsockopt (TCP_NOPUSH): %m");
	opt = 65536;
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &opt, sizeof(opt)) < 0)
		syslog(LOG_WARNING, "setsockopt (SO_SNDBUF): %m");

	return (fdopen(s, mode));
bad:
	/* Return the real value of errno (close may change it) */
	t = errno;
	sigprocmask (SIG_UNBLOCK, &allsigs, NULL);
	if (s >= 0)
		(void) close(s);
	errno = t;
	return (NULL);
}

static FILE *
dataconn(char *name, off_t size, char *mode)
{
	char sizebuf[32];
	FILE *file = NULL;
	int retry = 0;
	in_port_t *p;
	u_char *fa, *ha;
	size_t alen;
	int error;

	file_size = size;
	byte_count = 0;
	if (size != -1) {
		(void) snprintf(sizebuf, sizeof(sizebuf), " (%lld bytes)",
		    (long long)size);
	} else
		sizebuf[0] = '\0';
	if (pdata >= 0) {
		union sockunion from;
		int s;
		socklen_t fromlen = sizeof(from);

		(void) alarm ((unsigned) timeout);
		s = accept(pdata, (struct sockaddr *)&from, &fromlen);
		(void) alarm (0);
		if (s < 0) {
			reply(425, "Can't open data connection.");
			(void) close(pdata);
			pdata = -1;
			return (NULL);
		}
		switch (from.su_family) {
		case AF_INET:
			p = (in_port_t *)&from.su_sin.sin_port;
			fa = (u_char *)&from.su_sin.sin_addr;
			ha = (u_char *)&his_addr.su_sin.sin_addr;
			alen = sizeof(struct in_addr);
			break;
		case AF_INET6:
			p = (in_port_t *)&from.su_sin6.sin6_port;
			fa = (u_char *)&from.su_sin6.sin6_addr;
			ha = (u_char *)&his_addr.su_sin6.sin6_addr;
			alen = sizeof(struct in6_addr);
			break;
		default:
			reply(425, "Can't build data connection: "
			    "unknown address family");
			(void) close(pdata);
			(void) close(s);
			pdata = -1;
			return (NULL);
		}
		if (from.su_family != his_addr.su_family ||
		    ntohs(*p) < IPPORT_RESERVED) {
			reply(425, "Can't build data connection: "
			    "address family or port error");
			(void) close(pdata);
			(void) close(s);
			pdata = -1;
			return (NULL);
		}
		if (portcheck && memcmp(fa, ha, alen) != 0) {
			reply(425, "Can't build data connection: "
			    "illegal port number");
			(void) close(pdata);
			(void) close(s);
			pdata = -1;
			return (NULL);
		}
		(void) close(pdata);
		pdata = s;
		reply(150, "Opening %s mode data connection for '%s'%s.",
		    type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
		return (fdopen(pdata, mode));
	}
	if (data >= 0) {
		reply(125, "Using existing data connection for '%s'%s.",
		    name, sizebuf);
		usedefault = 1;
		return (fdopen(data, mode));
	}
	if (usedefault)
		data_dest = his_addr;
	usedefault = 1;
	do {
		if (file != NULL)
			(void) fclose(file);
		file = getdatasock(mode);
		if (file == NULL) {
			char hbuf[HOST_NAME_MAX+1], pbuf[10];

			error = getnameinfo((struct sockaddr *)&data_source,
			    data_source.su_len, hbuf, sizeof(hbuf), pbuf,
			    sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
			if (error != 0)
				reply(425, "Can't create data socket: %s.",
				    strerror(errno));
			else
				reply(425,
				    "Can't create data socket (%s,%s): %s.",
				    hbuf, pbuf, strerror(errno));
			return (NULL);
		}

		/*
		 * attempt to connect to reserved port on client machine;
		 * this looks like an attack
		 */
		switch (data_dest.su_family) {
		case AF_INET:
			p = (in_port_t *)&data_dest.su_sin.sin_port;
			fa = (u_char *)&data_dest.su_sin.sin_addr;
			ha = (u_char *)&his_addr.su_sin.sin_addr;
			alen = sizeof(struct in_addr);
			break;
		case AF_INET6:
			p = (in_port_t *)&data_dest.su_sin6.sin6_port;
			fa = (u_char *)&data_dest.su_sin6.sin6_addr;
			ha = (u_char *)&his_addr.su_sin6.sin6_addr;
			alen = sizeof(struct in6_addr);
			break;
		default:
			reply(425, "Can't build data connection: "
			    "unknown address family");
			(void) fclose(file);
			pdata = -1;
			return (NULL);
		}
		if (data_dest.su_family != his_addr.su_family ||
		    ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) { /* XXX */
			reply(425, "Can't build data connection: "
			    "address family or port error");
			(void) fclose(file);
			return NULL;
		}
		if (portcheck && memcmp(fa, ha, alen) != 0) {
			reply(435, "Can't build data connection: "
			    "illegal port number");
			(void) fclose(file);
			return NULL;
		}

		if (connect(fileno(file), (struct sockaddr *)&data_dest,
		    data_dest.su_len) == 0) {
			reply(150, "Opening %s mode data connection for '%s'%s.",
			    type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
			data = fileno(file);
			return (file);
		}
		if (errno != EADDRINUSE)
			break;
		sleep((unsigned) swaitint);
		retry += swaitint;
	} while (retry <= swaitmax);
	perror_reply(425, "Can't build data connection");
	(void) fclose(file);
	return (NULL);
}

/*
 * Transfer the contents of "instr" to "outstr" peer using the appropriate
 * encapsulation of the data subject to Mode, Structure, and Type.
 *
 * NB: Form isn't handled.
 */
static int
send_data(FILE *instr, FILE *outstr, off_t blksize, off_t filesize, int isreg)
{
	int c, cnt, filefd, netfd;
	char *buf, *bp;
	size_t len;

	transflag++;
	switch (type) {

	case TYPE_A:
		while ((c = getc(instr)) != EOF) {
			if (recvurg)
				goto got_oob;
			byte_count++;
			if (c == '\n') {
				if (ferror(outstr))
					goto data_err;
				(void) putc('\r', outstr);
			}
			(void) putc(c, outstr);
		}
		fflush(outstr);
		transflag = 0;
		if (ferror(instr))
			goto file_err;
		if (ferror(outstr))
			goto data_err;
		reply(226, "Transfer complete.");
		return(0);

	case TYPE_I:
	case TYPE_L:
		/*
		 * isreg is only set if we are not doing restart and we
		 * are sending a regular file
		 */
		netfd = fileno(outstr);
		filefd = fileno(instr);

		if (isreg && filesize < 16 * 1024 * 1024) {
			size_t fsize = (size_t)filesize;

			if (fsize == 0) {
				transflag = 0;
				reply(226, "Transfer complete.");
				return(0);
			}

			buf = mmap(0, fsize, PROT_READ, MAP_SHARED, filefd, 0);
			if (buf == MAP_FAILED) {
				syslog(LOG_WARNING, "mmap(%llu): %m",
				    (unsigned long long)fsize);
				goto oldway;
			}
			bp = buf;
			len = fsize;
			do {
				cnt = write(netfd, bp, len);
				if (recvurg) {
					munmap(buf, fsize);
					goto got_oob;
				}
				len -= cnt;
				bp += cnt;
				if (cnt > 0)
					byte_count += cnt;
			} while(cnt > 0 && len > 0);

			transflag = 0;
			munmap(buf, fsize);
			if (cnt < 0)
				goto data_err;
			reply(226, "Transfer complete.");
			return(0);
		}

oldway:
		if ((buf = malloc((size_t)blksize)) == NULL) {
			transflag = 0;
			perror_reply(451, "Local resource failure: malloc");
			return(-1);
		}

		while ((cnt = read(filefd, buf, (size_t)blksize)) > 0 &&
		    write(netfd, buf, cnt) == cnt)
			byte_count += cnt;
		transflag = 0;
		(void)free(buf);
		if (cnt != 0) {
			if (cnt < 0)
				goto file_err;
			goto data_err;
		}
		reply(226, "Transfer complete.");
		return(0);
	default:
		transflag = 0;
		reply(550, "Unimplemented TYPE %d in send_data", type);
		return(-1);
	}

data_err:
	transflag = 0;
	reply(426, "Data connection");
	return(-1);

file_err:
	transflag = 0;
	reply(551, "Error on input file");
	return(-1);

got_oob:
	myoob();
	recvurg = 0;
	transflag = 0;
	return(-1);
}

/*
 * Transfer data from peer to "outstr" using the appropriate encapulation of
 * the data subject to Mode, Structure, and Type.
 *
 * N.B.: Form isn't handled.
 */
static int
receive_data(FILE *instr, FILE *outstr)
{
	int c;
	int cnt;
	char buf[BUFSIZ];
	struct sigaction sa, sa_saved;
	volatile int bare_lfs = 0;

	transflag++;
	switch (type) {

	case TYPE_I:
	case TYPE_L:
		memset(&sa, 0, sizeof(sa));
		sigfillset(&sa.sa_mask);
		sa.sa_flags = SA_RESTART;
		sa.sa_handler = lostconn;
		(void) sigaction(SIGALRM, &sa, &sa_saved);
		do {
			(void) alarm ((unsigned) timeout);
			cnt = read(fileno(instr), buf, sizeof(buf));
			(void) alarm (0);
			if (recvurg)
				goto got_oob;

			if (cnt > 0) {
				if (write(fileno(outstr), buf, cnt) != cnt)
					goto file_err;
				byte_count += cnt;
			}
		} while (cnt > 0);
		(void) sigaction(SIGALRM, &sa_saved, NULL);
		if (cnt < 0)
			goto data_err;
		transflag = 0;
		return (0);

	case TYPE_E:
		reply(553, "TYPE E not implemented.");
		transflag = 0;
		return (-1);

	case TYPE_A:
		while ((c = getc(instr)) != EOF) {
			if (recvurg)
				goto got_oob;
			byte_count++;
			if (c == '\n')
				bare_lfs++;
			while (c == '\r') {
				if (ferror(outstr))
					goto data_err;
				if ((c = getc(instr)) != '\n') {
					(void) putc ('\r', outstr);
					if (c == '\0' || c == EOF)
						goto contin2;
				}
			}
			(void) putc(c, outstr);
	contin2:	;
		}
		fflush(outstr);
		if (ferror(instr))
			goto data_err;
		if (ferror(outstr))
			goto file_err;
		transflag = 0;
		if (bare_lfs) {
			lreply(226,
			    "WARNING! %d bare linefeeds received in ASCII mode",
			    bare_lfs);
			printf("   File may not have transferred correctly.\r\n");
		}
		return (0);
	default:
		reply(550, "Unimplemented TYPE %d in receive_data", type);
		transflag = 0;
		return (-1);
	}

data_err:
	transflag = 0;
	reply(426, "Data Connection");
	return (-1);

file_err:
	transflag = 0;
	reply(452, "Error writing file");
	return (-1);

got_oob:
	myoob();
	recvurg = 0;
	transflag = 0;
	return (-1);
}

void
statfilecmd(char *filename)
{
	FILE *fin;
	int c;
	int atstart;
	pid_t pid;
	char line[LINE_MAX];

	(void)snprintf(line, sizeof(line), "/bin/ls -lgA %s", filename);
	fin = ftpd_popen(line, "r", &pid);
	if (fin == NULL) {
		reply(451, "Local resource failure");
		return;
	}
	lreply(211, "status of %s:", filename);
	atstart = 1;
	while ((c = getc(fin)) != EOF) {
		if (c == '\n') {
			if (ferror(stdout)){
				perror_reply(421, "control connection");
				(void) ftpd_pclose(fin, pid);
				dologout(1);
				/* NOTREACHED */
			}
			if (ferror(fin)) {
				perror_reply(551, filename);
				(void) ftpd_pclose(fin, pid);
				return;
			}
			(void) putc('\r', stdout);
		}
		if (atstart && isdigit(c))
			(void) putc(' ', stdout);
		(void) putc(c, stdout);
		atstart = (c == '\n');
	}
	(void) ftpd_pclose(fin, pid);
	reply(211, "End of Status");
}

void
statcmd(void)
{
	union sockunion *su;
	u_char *a, *p;
	char hbuf[HOST_NAME_MAX+1];
	int ispassive;
	int error;

	lreply(211, "%s FTP server status:", hostname);
	error = getnameinfo((struct sockaddr *)&his_addr, his_addr.su_len,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
	printf("     Connected to %s", remotehost);
	if (error == 0 && strcmp(remotehost, hbuf) != 0)
		printf(" (%s)", hbuf);
	printf("\r\n");
	if (logged_in) {
		if (guest)
			printf("     Logged in anonymously\r\n");
		else
			printf("     Logged in as %s\r\n", pw->pw_name);
	} else if (askpasswd)
		printf("     Waiting for password\r\n");
	else
		printf("     Waiting for user name\r\n");
	printf("     TYPE: %s", typenames[type]);
	if (type == TYPE_A || type == TYPE_E)
		printf(", FORM: %s", formnames[form]);
	if (type == TYPE_L)
		printf(" 8");
	printf("; STRUcture: %s; transfer MODE: %s\r\n",
	    strunames[stru], modenames[mode]);
	ispassive = 0;
	if (data != -1)
		printf("     Data connection open\r\n");
	else if (pdata != -1) {
		printf("     in Passive mode\r\n");
		su = (union sockunion *)&pasv_addr;
		ispassive++;
		goto printaddr;
	} else if (usedefault == 0) {
		size_t alen;
		int af, i;

		su = (union sockunion *)&data_dest;
printaddr:
		/* PASV/PORT */
		if (su->su_family == AF_INET) {
			if (ispassive)
				printf("211- PASV ");
			else
				printf("211- PORT ");
			a = (u_char *)&su->su_sin.sin_addr;
			p = (u_char *)&su->su_sin.sin_port;
			printf("(%u,%u,%u,%u,%u,%u)\r\n",
			    a[0], a[1], a[2], a[3],
			    p[0], p[1]);
		}

		/* LPSV/LPRT */
		alen = 0;
		switch (su->su_family) {
		case AF_INET:
			a = (u_char *)&su->su_sin.sin_addr;
			p = (u_char *)&su->su_sin.sin_port;
			alen = sizeof(su->su_sin.sin_addr);
			af = 4;
			break;
		case AF_INET6:
			a = (u_char *)&su->su_sin6.sin6_addr;
			p = (u_char *)&su->su_sin6.sin6_port;
			alen = sizeof(su->su_sin6.sin6_addr);
			af = 6;
			break;
		default:
			af = 0;
			break;
		}
		if (af) {
			if (ispassive)
				printf("211- LPSV ");
			else
				printf("211- LPRT ");
			printf("(%u,%llu", af, (unsigned long long)alen);
			for (i = 0; i < alen; i++)
				printf(",%u", a[i]);
			printf(",%u,%u,%u)\r\n", 2, p[0], p[1]);
		}

		/* EPRT/EPSV */
		switch (su->su_family) {
		case AF_INET:
			af = 1;
			break;
		case AF_INET6:
			af = 2;
			break;
		default:
			af = 0;
			break;
		}
		if (af) {
			char pbuf[10];
			union sockunion tmp = *su;

			if (tmp.su_family == AF_INET6)
				tmp.su_sin6.sin6_scope_id = 0;
			if (getnameinfo((struct sockaddr *)&tmp, tmp.su_len,
			    hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
			    NI_NUMERICHOST | NI_NUMERICSERV) == 0) {
				if (ispassive)
					printf("211- EPSV ");
				else
					printf("211- EPRT ");
				printf("(|%u|%s|%s|)\r\n",
				    af, hbuf, pbuf);
			}
		}
	} else
		printf("     No data connection\r\n");
	reply(211, "End of status");
}

void
fatal(char *s)
{

	reply(451, "Error in server: %s", s);
	reply(221, "Closing connection due to server error.");
	dologout(0);
	/* NOTREACHED */
}

void
reply(int n, const char *fmt, ...)
{
	char *buf, *p, *next;
	int rval;
	va_list ap;

	va_start(ap, fmt);
	rval = vasprintf(&buf, fmt, ap);
	va_end(ap);
	if (rval == -1 || buf == NULL) {
		printf("421 Local resource failure: malloc\r\n");
		fflush(stdout);
		dologout(1);
	}
	next = buf;
	while ((p = strsep(&next, "\n\r"))) {
		printf("%d%s %s\r\n", n, (next != NULL) ? "-" : "", p);
		if (debug)
			syslog(LOG_DEBUG, "<--- %d%s %s", n,
			    (next != NULL) ? "-" : "", p);
	}
	(void)fflush(stdout);
	free(buf);
}


void
reply_r(int n, const char *fmt, ...)
{
	char *p, *next;
	char msg[BUFSIZ];
	char buf[BUFSIZ];
	va_list ap;
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	sdata.log_fac = LOG_FTP;
	va_start(ap, fmt);
	vsnprintf(msg, sizeof(msg), fmt, ap);
	va_end(ap);

	next = msg;

	while ((p = strsep(&next, "\n\r"))) {
		snprintf(buf, sizeof(buf), "%d%s %s\r\n", n,
		    (next != NULL) ? "-" : "", p);
		write(STDOUT_FILENO, buf, strlen(buf));
		if (debug) {
			buf[strlen(buf) - 2] = '\0';
			syslog_r(LOG_DEBUG, &sdata, "<--- %s", buf);
		}
	}
}

void
lreply(int n, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)printf("%d- ", n);
	(void)vprintf(fmt, ap);
	va_end(ap);
	(void)printf("\r\n");
	(void)fflush(stdout);
	if (debug) {
		va_start(ap, fmt);
		syslog(LOG_DEBUG, "<--- %d- ", n);
		vsyslog(LOG_DEBUG, fmt, ap);
		va_end(ap);
	}
}

static void
ack(char *s)
{

	reply(250, "%s command successful.", s);
}

void
nack(char *s)
{

	reply(502, "%s command not implemented.", s);
}

/* ARGSUSED */
void
yyerror(char *s)
{
	cbuf[strcspn(cbuf, "\n")] = '\0';
	reply(500, "'%s': command not understood.", cbuf);
}

void
delete(char *name)
{
	struct stat st;

	LOGCMD("delete", name);
	if (stat(name, &st) < 0) {
		perror_reply(550, name);
		return;
	}
	if ((st.st_mode&S_IFMT) == S_IFDIR) {
		if (rmdir(name) < 0) {
			perror_reply(550, name);
			return;
		}
		goto done;
	}
	if (unlink(name) < 0) {
		perror_reply(550, name);
		return;
	}
done:
	ack("DELE");
}

void
cwd(char *path)
{
	FILE *message;

	if (chdir(path) < 0)
		perror_reply(550, path);
	else {
		if ((message = fopen(_PATH_CWDMESG, "r")) != NULL) {
			char line[LINE_MAX];

			while (fgets(line, sizeof(line), message) != NULL) {
				line[strcspn(line, "\n")] = '\0';
				lreply(250, "%s", line);
			}
			(void) fflush(stdout);
			(void) fclose(message);
		}
		ack("CWD");
	}
}

void
replydirname(const char *name, const char *message)
{
	char *p, *ep;
	char npath[PATH_MAX * 2];

	p = npath;
	ep = &npath[sizeof(npath) - 1];
	while (*name) {
		if (*name == '"') {
			if (ep - p < 2)
				break;
			*p++ = *name++;
			*p++ = '"';
		} else {
			if (ep - p < 1)
				break;
			*p++ = *name++;
		}
	}
	*p = '\0';
	reply(257, "\"%s\" %s", npath, message);
}

void
makedir(char *name)
{

	LOGCMD("mkdir", name);
	if (mkdir(name, 0777) < 0)
		perror_reply(550, name);
	else
		replydirname(name, "directory created.");
}

void
removedir(char *name)
{

	LOGCMD("rmdir", name);
	if (rmdir(name) < 0)
		perror_reply(550, name);
	else
		ack("RMD");
}

void
pwd(void)
{
	char path[PATH_MAX];

	if (getcwd(path, sizeof(path)) == NULL)
		perror_reply(550, "Can't get current directory");
	else
		replydirname(path, "is current directory.");
}

char *
renamefrom(char *name)
{
	struct stat st;

	if (stat(name, &st) < 0) {
		perror_reply(550, name);
		return (NULL);
	}
	reply(350, "File exists, ready for destination name");
	return (name);
}

void
renamecmd(char *from, char *to)
{

	LOGCMD2("rename", from, to);
	if (rename(from, to) < 0)
		perror_reply(550, "rename");
	else
		ack("RNTO");
}

static void
dolog(struct sockaddr *sa)
{
	char hbuf[sizeof(remotehost)];

	if (getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, 0) == 0)
		(void) strlcpy(remotehost, hbuf, sizeof(remotehost));
	else
		(void) strlcpy(remotehost, "unknown", sizeof(remotehost));

	snprintf(proctitle, sizeof(proctitle), "%s: connected", remotehost);
	setproctitle("%s", proctitle);

	if (logging) {
		int error;
		error = getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf),
		    NULL, 0, NI_NUMERICHOST);
		syslog(LOG_INFO, "connection from %s [%s]", remotehost,
		    error ? gai_strerror(error) : hbuf);
	}
}

/*
 * Record logout in wtmp file and exit with supplied status.
 * NOTE: because this is called from signal handlers it cannot
 *       use stdio (or call other functions that use stdio).
 */
void
dologout(int status)
{

	transflag = 0;

	if (logged_in) {
		sigprocmask(SIG_BLOCK, &allsigs, NULL);
		if (!nowtmp)
			ftpdlogwtmp(ttyline, "", "");
		if (doutmp)
			ftpd_logout(utmp.ut_line);
	}
	/* beware of flushing buffers after a SIGPIPE */
	_exit(status);
}

/*ARGSUSED*/
static void
sigurg(int signo)
{

	recvurg = 1;
}

static void
myoob(void)
{
	char *cp;
	int ret;

	/* only process if transfer occurring */
	if (!transflag)
		return;
	cp = tmpline;
	ret = get_line(cp, sizeof(tmpline)-1, stdin);
	if (ret == -1) {
		reply(221, "You could at least say goodbye.");
		dologout(0);
	} else if (ret == -2) {
		/* Ignore truncated command */
		return;
	}
	upper(cp);
	if (strcmp(cp, "ABOR\r\n") == 0) {
		tmpline[0] = '\0';
		reply(426, "Transfer aborted. Data connection closed.");
		reply(226, "Abort successful");
	}
	if (strcmp(cp, "STAT\r\n") == 0) {
		tmpline[0] = '\0';
		if (file_size != -1)
			reply(213, "Status: %lld of %lld bytes transferred",
			    (long long)byte_count, (long long)file_size);
		else
			reply(213, "Status: %lld bytes transferred",
			    (long long)byte_count);
	}
}

/*
 * Note: a response of 425 is not mentioned as a possible response to
 *	the PASV command in RFC959. However, it has been blessed as
 *	a legitimate response by Jon Postel in a telephone conversation
 *	with Rick Adams on 25 Jan 89.
 */
void
passive(void)
{
	socklen_t len;
	int on = 1;
	u_char *p, *a;

	if (pw == NULL) {
		reply(530, "Please login with USER and PASS");
		return;
	}
	if (pdata >= 0)
		close(pdata);
	/*
	 * XXX
	 * At this point, it would be nice to have an algorithm that
	 * inserted a growing delay in an attack scenario.  Such a thing
	 * would look like continual passive sockets being opened, but
	 * nothing serious being done with them.  They're not used to
	 * move data; the entire attempt is just to use tcp FIN_WAIT
	 * resources.
	 */
	pdata = socket(AF_INET, SOCK_STREAM, 0);
	if (pdata < 0) {
		perror_reply(425, "Can't open passive connection");
		return;
	}

	if (setsockopt(pdata, SOL_SOCKET, SO_KEEPALIVE,
	    &on, sizeof(on)) < 0)
		goto pasv_error;

	on = IP_PORTRANGE_HIGH;
	if (setsockopt(pdata, IPPROTO_IP, IP_PORTRANGE,
	    &on, sizeof(on)) < 0)
		goto pasv_error;

	pasv_addr = ctrl_addr;
	pasv_addr.su_sin.sin_port = 0;
	if (bind(pdata, (struct sockaddr *)&pasv_addr,
	    pasv_addr.su_len) < 0)
		goto pasv_error;

	len = sizeof(pasv_addr);
	if (getsockname(pdata, (struct sockaddr *)&pasv_addr, &len) < 0)
		goto pasv_error;
	if (listen(pdata, 1) < 0)
		goto pasv_error;
	a = (u_char *)&pasv_addr.su_sin.sin_addr;
	p = (u_char *)&pasv_addr.su_sin.sin_port;

	reply(227, "Entering Passive Mode (%u,%u,%u,%u,%u,%u)", a[0],
	    a[1], a[2], a[3], p[0], p[1]);
	return;

pasv_error:
	perror_reply(425, "Can't open passive connection");
	(void) close(pdata);
	pdata = -1;
	return;
}

int
epsvproto2af(int proto)
{

	switch (proto) {
	case 1:	return AF_INET;
	case 2:	return AF_INET6;
	default: return -1;
	}
}

int
af2epsvproto(int af)
{

	switch (af) {
	case AF_INET:	return 1;
	case AF_INET6:	return 2;
	default:	return -1;
	}
}

/*
 * 228 Entering Long Passive Mode (af, hal, h1, h2, h3,..., pal, p1, p2...)
 * 229 Entering Extended Passive Mode (|||port|)
 */
void
long_passive(char *cmd, int pf)
{
	socklen_t len;
	int on = 1;
	u_char *p, *a;

	if (!logged_in) {
		syslog(LOG_NOTICE, "long passive but not logged in");
		reply(503, "Login with USER first.");
		return;
	}

	if (pf != PF_UNSPEC && ctrl_addr.su_family != pf) {
		/*
		 * XXX
		 * only EPRT/EPSV ready clients will understand this
		 */
		if (strcmp(cmd, "EPSV") != 0)
			reply(501, "Network protocol mismatch"); /*XXX*/
		else
			epsv_protounsupp("Network protocol mismatch");

		return;
	}

	if (pdata >= 0)
		close(pdata);
	/*
	 * XXX
	 * At this point, it would be nice to have an algorithm that
	 * inserted a growing delay in an attack scenario.  Such a thing
	 * would look like continual passive sockets being opened, but
	 * nothing serious being done with them.  They not used to move
	 * data; the entire attempt is just to use tcp FIN_WAIT
	 * resources.
	 */
	pdata = socket(ctrl_addr.su_family, SOCK_STREAM, 0);
	if (pdata < 0) {
		perror_reply(425, "Can't open passive connection");
		return;
	}

	if (setsockopt(pdata, SOL_SOCKET, SO_KEEPALIVE,
	    &on, sizeof(on)) < 0)
		goto pasv_error;

	switch (ctrl_addr.su_family) {
	case AF_INET:
		on = IP_PORTRANGE_HIGH;
		if (setsockopt(pdata, IPPROTO_IP, IP_PORTRANGE,
		    &on, sizeof(on)) < 0)
			goto pasv_error;
		break;
	case AF_INET6:
		on = IPV6_PORTRANGE_HIGH;
		if (setsockopt(pdata, IPPROTO_IPV6, IPV6_PORTRANGE,
		    &on, sizeof(on)) < 0)
			goto pasv_error;
		break;
	}

	pasv_addr = ctrl_addr;
	pasv_addr.su_port = 0;
	if (bind(pdata, (struct sockaddr *)&pasv_addr, pasv_addr.su_len) < 0)
		goto pasv_error;
	len = pasv_addr.su_len;
	if (getsockname(pdata, (struct sockaddr *)&pasv_addr, &len) < 0)
		goto pasv_error;
	if (listen(pdata, 1) < 0)
		goto pasv_error;
	p = (u_char *)&pasv_addr.su_port;

	if (strcmp(cmd, "LPSV") == 0) {
		switch (pasv_addr.su_family) {
		case AF_INET:
			a = (u_char *)&pasv_addr.su_sin.sin_addr;
			reply(228,
			    "Entering Long Passive Mode (%u,%u,%u,%u,%u,%u,%u,%u,%u)",
			    4, 4, a[0], a[1], a[2], a[3], 2, p[0], p[1]);
			return;
		case AF_INET6:
			a = (u_char *)&pasv_addr.su_sin6.sin6_addr;
			reply(228,
			    "Entering Long Passive Mode (%u,%u,%u,%u,%u,%u,"
			    "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u)",
				6, 16, a[0], a[1], a[2], a[3], a[4],
				a[5], a[6], a[7], a[8], a[9], a[10],
				a[11], a[12], a[13], a[14], a[15],
				2, p[0], p[1]);
			return;
		}
	} else if (strcmp(cmd, "EPSV") == 0) {
		switch (pasv_addr.su_family) {
		case AF_INET:
		case AF_INET6:
			reply(229, "Entering Extended Passive Mode (|||%u|)",
			    ntohs(pasv_addr.su_port));
			return;
		}
	} else {
		/* more proper error code? */
	}

  pasv_error:
	perror_reply(425, "Can't open passive connection");
	(void) close(pdata);
	pdata = -1;
	return;
}

/*
 * EPRT |proto|addr|port|
 */
int
extended_port(const char *arg)
{
	char *tmp = NULL;
	char *result[3];
	char *p, *q;
	char delim;
	struct addrinfo hints;
	struct addrinfo *res = NULL;
	int i;
	unsigned long proto;

	if (epsvall) {
		reply(501, "EPRT disallowed after EPSV ALL");
		return -1;
	}

	usedefault = 0;
	if (pdata >= 0) {
		(void) close(pdata);
		pdata = -1;
	}

	tmp = strdup(arg);
	if (!tmp) {
		fatal("not enough core.");
		/*NOTREACHED*/
	}
	p = tmp;
	delim = p[0];
	p++;
	memset(result, 0, sizeof(result));
	for (i = 0; i < 3; i++) {
		q = strchr(p, delim);
		if (!q || *q != delim)
			goto parsefail;
		*q++ = '\0';
		result[i] = p;
		p = q;
	}

	/* some more sanity check */
	p = NULL;
	(void)strtoul(result[2], &p, 10);
	if (!*result[2] || *p)
		goto protounsupp;
	p = NULL;
	proto = strtoul(result[0], &p, 10);
	if (!*result[0] || *p)
		goto protounsupp;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = epsvproto2af((int)proto);
	if (hints.ai_family < 0)
		goto protounsupp;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST;	/*no DNS*/
	if (getaddrinfo(result[1], result[2], &hints, &res))
		goto parsefail;
	if (res->ai_next)
		goto parsefail;
	if (sizeof(data_dest) < res->ai_addrlen)
		goto parsefail;
	memcpy(&data_dest, res->ai_addr, res->ai_addrlen);
	if (his_addr.su_family == AF_INET6 &&
	    data_dest.su_family == AF_INET6) {
		/* XXX more sanity checks! */
		data_dest.su_sin6.sin6_scope_id =
		    his_addr.su_sin6.sin6_scope_id;
	}
	if (pdata >= 0) {
		(void) close(pdata);
		pdata = -1;
	}
	reply(200, "EPRT command successful.");

	free(tmp);
	if (res)
		freeaddrinfo(res);
	return 0;

parsefail:
	reply(500, "Invalid argument, rejected.");
	usedefault = 1;
	free(tmp);
	if (res)
		freeaddrinfo(res);
	return -1;

protounsupp:
	epsv_protounsupp("Protocol not supported");
	usedefault = 1;
	free(tmp);
	if (res)
		freeaddrinfo(res);
	return -1;
}

/*
 * 522 Protocol not supported (proto,...)
 * as we assume address family for control and data connections are the same,
 * we do not return the list of address families we support - instead, we
 * return the address family of the control connection.
 */
void
epsv_protounsupp(const char *message)
{
	int proto;

	proto = af2epsvproto(ctrl_addr.su_family);
	if (proto < 0)
		reply(501, "%s", message);	/*XXX*/
	else
		reply(522, "%s, use (%d)", message, proto);
}

/*
 * Generate unique name for file with basename "local".
 * The file named "local" is already known to exist.
 * Generates failure reply on error.
 */
static int
guniquefd(char *local, char **nam)
{
	static char new[PATH_MAX];
	struct stat st;
	int count, len, fd;
	char *cp;

	cp = strrchr(local, '/');
	if (cp)
		*cp = '\0';
	if (stat(cp ? local : ".", &st) < 0) {
		perror_reply(553, cp ? local : ".");
		return (-1);
	}
	if (cp)
		*cp = '/';
	len = strlcpy(new, local, sizeof(new));
	if (len+2+1 >= sizeof(new)-1)
		return (-1);
	cp = new + len;
	*cp++ = '.';
	for (count = 1; count < 100; count++) {
		(void)snprintf(cp, sizeof(new) - (cp - new), "%d", count);
		fd = open(new, O_RDWR|O_CREAT|O_EXCL, 0666);
		if (fd == -1)
			continue;
		if (nam)
			*nam = new;
		return (fd);
	}
	reply(452, "Unique file name cannot be created.");
	return (-1);
}

/*
 * Format and send reply containing system error number.
 */
void
perror_reply(int code, char *string)
{

	reply(code, "%s: %s.", string, strerror(errno));
}

static char *onefile[] = {
	"",
	0
};

void
send_file_list(char *whichf)
{
	struct stat st;
	DIR *dirp = NULL;
	struct dirent *dir;
	FILE *dout = NULL;
	char **dirlist;
	char *dirname;
	int simple = 0;
	volatile int freeglob = 0;
	glob_t gl;
	size_t prefixlen;

	if (strpbrk(whichf, "~{[*?") != NULL) {
		memset(&gl, 0, sizeof(gl));
		freeglob = 1;
		if (glob(whichf,
		    GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE|GLOB_LIMIT,
		    0, &gl)) {
			reply(550, "not found");
			goto out;
		} else if (gl.gl_pathc == 0) {
			errno = ENOENT;
			perror_reply(550, whichf);
			goto out;
		}
		dirlist = gl.gl_pathv;
	} else {
		onefile[0] = whichf;
		dirlist = onefile;
		simple = 1;
	}

	while ((dirname = *dirlist++)) {
		if (stat(dirname, &st) < 0) {
			/*
			 * If user typed "ls -l", etc, and the client
			 * used NLST, do what the user meant.
			 */
			if (dirname[0] == '-' && *dirlist == NULL &&
			    transflag == 0) {
				retrieve("/bin/ls %s", dirname);
				goto out;
			}
			perror_reply(550, whichf);
			if (dout != NULL) {
				(void) fclose(dout);
				transflag = 0;
				data = -1;
				pdata = -1;
			}
			goto out;
		}

		if (S_ISREG(st.st_mode)) {
			if (dout == NULL) {
				dout = dataconn("file list", -1, "w");
				if (dout == NULL)
					goto out;
				transflag++;
			}
			fprintf(dout, "%s%s\n", dirname,
				type == TYPE_A ? "\r" : "");
			byte_count += strlen(dirname) + 1;
			continue;
		} else if (!S_ISDIR(st.st_mode))
			continue;

		if ((dirp = opendir(dirname)) == NULL)
			continue;

		if (dirname[0] == '.' && dirname[1] == '\0')
			prefixlen = 0;
		else
			prefixlen = strlen(dirname) + 1;
		while ((dir = readdir(dirp)) != NULL) {
			if (recvurg) {
				myoob();
				recvurg = 0;
				transflag = 0;
				goto out;
			}

			if (dir->d_name[0] == '.' && dir->d_namlen == 1)
				continue;
			if (dir->d_name[0] == '.' && dir->d_name[1] == '.' &&
			    dir->d_namlen == 2)
				continue;

			/*
			 * We have to do a stat to insure it's
			 * not a directory or special file.
			 */
			if (simple ||
			    (fstatat(dirfd(dirp), dir->d_name, &st, 0) == 0 &&
			    S_ISREG(st.st_mode))) {
				if (dout == NULL) {
					dout = dataconn("file list", -1, "w");
					if (dout == NULL)
						goto out;
					transflag++;
				}

				if (prefixlen) {
					fprintf(dout, "%s/", dirname);
					byte_count += prefixlen;
				}
				fprintf(dout, "%s%s\n", dir->d_name,
				    type == TYPE_A ? "\r" : "");
				byte_count += dir->d_namlen + 1;
			}
		}
		(void) closedir(dirp);
	}

	if (dout == NULL)
		reply(550, "No files found.");
	else if (ferror(dout) != 0)
		perror_reply(550, "Data connection");
	else
		reply(226, "Transfer complete.");

	transflag = 0;
	if (dout != NULL)
		(void) fclose(dout);
	else {
		if (pdata >= 0)
			close(pdata);
	}
	data = -1;
	pdata = -1;
out:
	if (freeglob) {
		freeglob = 0;
		globfree(&gl);
	}
}

/*ARGSUSED*/
static void
reapchild(int signo)
{
	int save_errno = errno;
	int rval;

	do {
		rval = waitpid(-1, NULL, WNOHANG);
	} while (rval > 0 || (rval == -1 && errno == EINTR));
	errno = save_errno;
}

void
logxfer(char *name, off_t size, time_t start)
{
	char buf[400 + (HOST_NAME_MAX+1)*4 + PATH_MAX*4];
	char dir[PATH_MAX], path[PATH_MAX], rpath[PATH_MAX];
	char vremotehost[(HOST_NAME_MAX+1)*4], vpath[PATH_MAX*4];
	char *vpw;
	time_t now;
	int len;

	if ((statfd >= 0) && (getcwd(dir, sizeof(dir)) != NULL)) {
		time(&now);

		vpw = malloc(strlen(guest ? guestpw : pw->pw_name) * 4 + 1);
		if (vpw == NULL)
			return;

		snprintf(path, sizeof(path), "%s/%s", dir, name);
		if (realpath(path, rpath) == NULL)
			strlcpy(rpath, path, sizeof(rpath));
		strvis(vpath, rpath, VIS_SAFE|VIS_NOSLASH);

		strvis(vremotehost, remotehost, VIS_SAFE|VIS_NOSLASH);
		strvis(vpw, guest? guestpw : pw->pw_name, VIS_SAFE|VIS_NOSLASH);

		len = snprintf(buf, sizeof(buf),
		    "%.24s %lld %s %lld %s %c %s %c %c %s ftp %d %s %s\n",
		    ctime(&now), (long long)(now - start + (now == start)),
		    vremotehost, (long long)size, vpath,
		    ((type == TYPE_A) ? 'a' : 'b'), "*" /* none yet */,
		    'o', ((guest) ? 'a' : 'r'),
		    vpw, 0 /* none yet */,
		    ((guest) ? "*" : pw->pw_name), dhostname);
		free(vpw);

		if (len >= sizeof(buf) || len == -1) {
			if ((len = strlen(buf)) == 0)
				return;		/* should not happen */
			buf[len - 1] = '\n';
		}
		write(statfd, buf, len);
	}
}

void
set_slave_signals(void)
{
	struct sigaction sa;

	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;

	sa.sa_handler = SIG_DFL;
	(void) sigaction(SIGCHLD, &sa, NULL);

	sa.sa_handler = sigurg;
	sa.sa_flags = 0;		/* don't restart syscalls for SIGURG */
	(void) sigaction(SIGURG, &sa, NULL);

	sigfillset(&sa.sa_mask);	/* block all signals in handler */
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigquit;
	(void) sigaction(SIGHUP, &sa, NULL);
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
	(void) sigaction(SIGTERM, &sa, NULL);

	sa.sa_handler = lostconn;
	(void) sigaction(SIGPIPE, &sa, NULL);

	sa.sa_handler = toolong;
	(void) sigaction(SIGALRM, &sa, NULL);

	if (fcntl(fileno(stdin), F_SETOWN, getpid()) == -1)
		syslog(LOG_ERR, "fcntl F_SETOWN: %m");
}

/*
 * Allocate space and return a copy of the specified dir.
 * If 'dir' begins with a tilde (~), expand it.
 */
char *
copy_dir(char *dir, struct passwd *pw)
{
	char *cp;
	char *newdir;
	char *user = NULL;

	/* Nothing to expand */
	if (dir[0] != '~')
		return (strdup(dir));

	/* "dir" is of form ~user/some/dir, lookup user. */
	if (dir[1] != '/' && dir[1] != '\0') {
		if ((cp = strchr(dir + 1, '/')) == NULL)
			cp = dir + strlen(dir);
		if ((user = malloc((size_t)(cp - dir))) == NULL)
			return (NULL);
		strlcpy(user, dir + 1, (size_t)(cp - dir));

		/* Only do lookup if it is a different user. */
		if (strcmp(user, pw->pw_name) != 0) {
			if ((pw = getpwnam(user)) == NULL) {
				/* No such user, interpret literally */
				free(user);
				return(strdup(dir));
			}
		}
		free(user);
	}

	/*
	 * If there is no directory separator (/) then it is just pw_dir.
	 * Otherwise, replace ~foo with pw_dir.
	 */
	if ((cp = strchr(dir + 1, '/')) == NULL) {
		newdir = strdup(pw->pw_dir);
	} else {
		if (asprintf(&newdir, "%s%s", pw->pw_dir, cp) == -1)
			return (NULL);
	}

	return(newdir);
}
@


1.222
log
@Set "lowdelay" and "throughput" Traffic Class on command & data IPv6 sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.221 2016/08/31 13:43:36 jca Exp $	*/
d1279 1
a1279 1
	int on = 1, s, t, tos, tries;
d1287 1
d1289 1
a1289 1
	    &on, sizeof(on)) < 0)
d1304 1
a1304 1
	tos = IPTOS_THROUGHPUT;
d1307 2
a1308 2
		if (setsockopt(s, IPPROTO_IP, IP_TOS, &tos,
		    sizeof(int)) < 0)
d1312 2
a1313 2
		if (setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &tos,
		    sizeof(int)) < 0)
d1323 2
a1324 2
	on = 1;
	if (setsockopt(s, IPPROTO_TCP, TCP_NOPUSH, &on, sizeof(on)) < 0)
d1326 2
a1327 2
	on = 65536;
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &on, sizeof(on)) < 0)
@


1.221
log
@Don't attempt to support IPv4-mapped IPv6 addresses.

We don't consider support for those addreses as desirable, so let's not
give a bad example by keeping application code to handle them.  This is
dead code on OpenBSD anyway since we do not support IPv4-mapped stuff.
But let's keep the check to log and warn the admin if the code gets
ported elsewhere.  Porters of this code should ensure that IPv6 sockets
can't see IPv4-mapped addresses by using the IPV6_V6ONLY sockopt.

Discussed with & ok tedu@@

For a rationale, see https://tools.ietf.org/html/draft-itojun-v6ops-v4mapped-harmful-02
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.220 2016/08/30 14:56:39 tedu Exp $	*/
d534 3
a536 2
	if (his_addr.su_family == AF_INET) {
		tos = IPTOS_LOWDELAY;
d540 6
d1279 1
a1279 1
	int on = 1, s, t, tries;
d1303 4
a1306 3
	if (ctrl_addr.su_family == AF_INET) {
		on = IPTOS_THROUGHPUT;
		if (setsockopt(s, IPPROTO_IP, IP_TOS, &on,
d1309 6
@


1.220
log
@remove ifdef for all the features we have.
retain disabled ip4in6 code until its future is decided.
ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.219 2016/08/26 06:32:10 tedu Exp $	*/
d529 4
a532 36
#if 1
		/*
		 * IPv4 control connection arrived to AF_INET6 socket.
		 * I hate to do this, but this is the easiest solution.
		 */
		union sockunion tmp_addr;
		const int off = sizeof(struct in6_addr) - sizeof(struct in_addr);

		tmp_addr = his_addr;
		memset(&his_addr, 0, sizeof(his_addr));
		his_addr.su_sin.sin_family = AF_INET;
		his_addr.su_sin.sin_len = sizeof(his_addr.su_sin);
		memcpy(&his_addr.su_sin.sin_addr,
		    &tmp_addr.su_sin6.sin6_addr.s6_addr[off],
		    sizeof(his_addr.su_sin.sin_addr));
		his_addr.su_sin.sin_port = tmp_addr.su_sin6.sin6_port;

		tmp_addr = ctrl_addr;
		memset(&ctrl_addr, 0, sizeof(ctrl_addr));
		ctrl_addr.su_sin.sin_family = AF_INET;
		ctrl_addr.su_sin.sin_len = sizeof(ctrl_addr.su_sin);
		memcpy(&ctrl_addr.su_sin.sin_addr,
		    &tmp_addr.su_sin6.sin6_addr.s6_addr[off],
		    sizeof(ctrl_addr.su_sin.sin_addr));
		ctrl_addr.su_sin.sin_port = tmp_addr.su_sin6.sin6_port;
#else
		while (fgets(line, sizeof(line), fd) != NULL) {
			line[strcspn(line, "\n")] = '\0';
			lreply(530, "%s", line);
		}
		(void) fflush(stdout);
		(void) close(fd);
		reply(530,
			"Connection from IPv4 mapped address is not supported.");
		exit(0);
#endif
@


1.219
log
@trim down some NBBY references. 8 bits ought to be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.218 2016/08/14 22:56:29 guenther Exp $	*/
a153 3
#if 0
char	*tty = ttyline;		/* for klogin */
#endif
a565 1
#ifdef IP_TOS
a571 1
#endif
a574 1
#ifdef SO_OOBINLINE
a576 1
#endif
a1327 1
#ifdef IP_TOS
a1333 2
#endif
#ifdef TCP_NOPUSH
a1342 2
#endif
#ifdef SO_SNDBUF
a1345 1
#endif
a2834 1
#ifdef F_SETOWN
a2836 1
#endif
@


1.218
log
@Convert %q to %ll with long long casts for printf()
Delete pointless casts to off_t, void*, and uid_t

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.217 2016/07/04 03:24:48 guenther Exp $	*/
d1830 1
a1830 5
#if NBBY == 8
		printf(" %d", NBBY);
#else
		printf(" %d", bytesize);	/* need definition! */
#endif
@


1.217
log
@Use fstatat() instead of crafting a filename to use with stat()

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.216 2016/05/04 19:48:08 jca Exp $	*/
d188 1
a188 1
		if (cnt == (off_t)-1) \
d192 3
a194 2
		    syslog(LOG_INFO, "%s %s%s = %qd bytes", \
			cmd, (*(file) == '/') ? "" : curdir(), file, cnt); \
d983 1
a983 1
	if (setusercontext(lc, pw, (uid_t)0, flags) != 0) {
d996 1
a996 1
		memset((void *)&utmp, 0, sizeof(utmp));
d1209 1
a1209 1
	send_data(fin, dout, (off_t)st.st_blksize, st.st_size,
d1281 1
a1281 1
			if (fseek(fout, 0L, SEEK_CUR) < 0) {
d1290 1
a1290 1
	din = dataconn(name, (off_t)-1, "r");
d1384 3
a1386 3
	if (size != (off_t) -1) {
		(void) snprintf(sizebuf, sizeof(sizebuf), " (%qd bytes)",
		    size);
d1577 1
a1577 1
		if (isreg && filesize < (off_t)16 * 1024 * 1024) {
d1586 1
a1586 2
			buf = mmap(0, fsize, PROT_READ, MAP_SHARED, filefd,
			    (off_t)0);
d2239 3
a2241 3
		if (file_size != (off_t) -1)
			reply(213, "Status: %qd of %qd bytes transferred",
			    byte_count, file_size);
d2243 2
a2244 1
			reply(213, "Status: %qd bytes transferred", byte_count);
d2684 1
a2684 1
				dout = dataconn("file list", (off_t)-1, "w");
d2725 1
a2725 2
					dout = dataconn("file list", (off_t)-1,
						"w");
d2805 1
a2805 1
		    "%.24s %lld %s %qd %s %c %s %c %c %s ftp %d %s %s\n",
@


1.216
log
@Kill #ifdef INET6 occurrences in userland.

Prompted by and ok millert@@

(tcpdump and libpcap left untouched, the #ifdef force is too strong with
those)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.215 2016/04/25 15:43:34 deraadt Exp $	*/
d2638 1
d2698 4
a2702 2
			char nbuf[PATH_MAX];

a2715 3
			snprintf(nbuf, sizeof(nbuf), "%s/%s", dirname,
				 dir->d_name);

d2720 2
a2721 1
			if (simple || (stat(nbuf, &st) == 0 &&
d2730 8
a2737 7
				if (nbuf[0] == '.' && nbuf[1] == '/')
					fprintf(dout, "%s%s\n", &nbuf[2],
						type == TYPE_A ? "\r" : "");
				else
					fprintf(dout, "%s%s\n", nbuf,
						type == TYPE_A ? "\r" : "");
				byte_count += strlen(nbuf) + 1;
@


1.215
log
@prefer setres{u,g}id() rather than manipulating both real and effective
ids, it clarifies these are full revocation situations.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.214 2016/04/06 07:14:17 semarie Exp $	*/
a2320 1
#ifdef INET6
a2321 1
#endif
a2331 1
#ifdef INET6
a2332 1
#endif
@


1.214
log
@compare pointer to NULL instead of 0

from fritjof ! alokat.org

ok ratchov@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.213 2016/03/16 15:41:10 krw Exp $	*/
d1080 1
a1080 1
	if (setegid(pw->pw_gid) < 0 || setgid(pw->pw_gid) < 0) {
d1084 1
a1084 1
	if (seteuid(pw->pw_uid) < 0 || setuid(pw->pw_uid) < 0) {
@


1.213
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.212 2015/12/12 20:09:28 mmcc Exp $	*/
d1154 1
a1154 1
	if (cmd == 0) {
d1169 1
a1169 1
			if (cmd == 0) {
d1176 2
a1177 1
	if (cmd == 0 && (fstat(fileno(fin), &st) < 0 || !S_ISREG(st.st_mode))) {
d1209 2
a1210 2
	    (restart_point == 0 && cmd == 0 && S_ISREG(st.st_mode)));
	if ((cmd == 0) && stats)
d1218 1
a1218 1
	if (cmd == 0) {
@


1.212
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.211 2015/11/16 17:31:14 tedu Exp $	*/
d2143 1
a2143 1
		return ((char *)0);
@


1.211
log
@don't need to ifdef setproctitle
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.210 2015/10/25 23:10:53 millert Exp $	*/
d942 1
a942 2
		if (guestpw != NULL)
			free(guestpw);
d1115 1
a1115 2
	if (motd != NULL)
		free(motd);
d2534 1
a2534 2
	if (tmp)
		free(tmp);
d2542 1
a2542 2
	if (tmp)
		free(tmp);
d2550 1
a2550 2
	if (tmp)
		free(tmp);
@


1.210
log
@No longer create /var/run/ftpd.pid in daemon mode; OK jung@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.209 2015/10/04 11:58:09 tedu Exp $	*/
a174 1
#ifdef HASSETPROCTITLE
a175 1
#endif /* HASSETPROCTITLE */
a1119 1
#ifdef HASSETPROCTITLE
a1124 1
#endif /* HASSETPROCTITLE */
a1129 1
#ifdef HASSETPROCTITLE
a1132 1
#endif /* HASSETPROCTITLE */
a2171 1
#ifdef HASSETPROCTITLE
a2173 1
#endif /* HASSETPROCTITLE */
@


1.209
log
@fix custom popen to return pid to caller instead of tracking in a giant
array. this implies we can't use a function pointer for close, but also
means we get to repair some abuse of the comma operator.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.208 2015/09/01 06:50:53 jsg Exp $	*/
a98 1
#include <util.h>
a480 3
		/* Stash pid in pidfile */
		if (pidfile(NULL))
			syslog(LOG_ERR, "can't open pidfile: %m");
@


1.208
log
@test pointers with NULL not '\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.207 2015/01/19 01:24:39 deraadt Exp $	*/
d1163 1
a1163 1
	int (*closefunc)(FILE *);
d1167 1
a1167 1
		fin = fopen(name, "r"), closefunc = fclose;
d1174 1
a1174 1
		fin = ftpd_popen(line, "r"), closefunc = ftpd_pclose;
d1229 1
a1229 1
	if (cmd == 0)
d1231 4
a1234 1
	(*closefunc)(fin);
d1777 1
d1781 1
a1781 1
	fin = ftpd_popen(line, "r");
d1792 1
a1792 1
				(void) ftpd_pclose(fin);
d1798 1
a1798 1
				(void) ftpd_pclose(fin);
d1808 1
a1808 1
	(void) ftpd_pclose(fin);
@


1.207
log
@CMASK went out of scope with the recent <sys/param.h> removal.  But oh
golly gee, ftpd can handle that itself due to the glorious old practice
of #ifndef #define.  Remove that junk.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.206 2015/01/16 06:39:50 deraadt Exp $	*/
d1962 1
a1962 1
		printf("%d%s %s\r\n", n, (next != '\0') ? "-" : "", p);
d1965 1
a1965 1
			    (next != '\0') ? "-" : "", p);
d1990 1
a1990 1
		    (next != '\0') ? "-" : "", p);
@


1.206
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.205 2014/10/25 03:19:22 lteo Exp $	*/
d147 1
a147 5
#if !defined(CMASK) || CMASK == 0
#undef CMASK
#define CMASK 022
#endif
mode_t	defumask = CMASK;		/* default umask value */
@


1.205
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.204 2014/08/25 07:50:25 doug Exp $	*/
d154 3
a156 3
char	hostname[MAXHOSTNAMELEN];
char	remotehost[MAXHOSTNAMELEN];
char	dhostname[MAXHOSTNAMELEN];
d230 1
a230 1
	static char path[MAXPATHLEN+1];	/* path + '/' */
d705 1
a705 1
static char curname[MAXLOGNAME];	/* current USER name */
d909 2
a910 2
	static char homedir[MAXPATHLEN];
	char *motd, *dir, rootdir[MAXPATHLEN];
d1104 1
a1104 1
	if (getcwd(homedir, MAXPATHLEN) != NULL) {
d1472 1
a1472 1
			char hbuf[MAXHOSTNAMELEN], pbuf[10];
d1817 1
a1817 1
	char hbuf[MAXHOSTNAMELEN];
d2095 1
a2095 1
	char npath[MAXPATHLEN * 2];
d2140 1
a2140 1
	char path[MAXPATHLEN];
d2599 1
a2599 1
	static char new[MAXPATHLEN];
d2718 1
a2718 1
			char nbuf[MAXPATHLEN];
d2800 3
a2802 3
	char buf[400 + MAXHOSTNAMELEN*4 + MAXPATHLEN*4];
	char dir[MAXPATHLEN], path[MAXPATHLEN], rpath[MAXPATHLEN];
	char vremotehost[MAXHOSTNAMELEN*4], vpath[MAXPATHLEN*4];
@


1.204
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.203 2014/03/24 16:41:27 tedu Exp $	*/
a71 1
#include <netinet/in_systm.h>
@


1.203
log
@remove tcpwrappers support. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.202 2014/03/17 23:23:37 sthen Exp $	*/
d698 1
a698 1
		memset(old->pw_passwd, 0, strlen(old->pw_passwd));
@


1.202
log
@args! fix argstr. from LEVAI Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.201 2014/03/17 21:02:49 sthen Exp $	*/
a103 4
#if defined(TCPWRAPPERS)
#include <tcpd.h>
#endif	/* TCPWRAPPERS */

a167 5
#if defined(TCPWRAPPERS)
int	allow_severity = LOG_INFO;
int	deny_severity = LOG_NOTICE;
#endif	/* TCPWRAPPERS */

a222 3
#if defined(TCPWRAPPERS)
static int	 check_host(struct sockaddr *);
#endif /* TCPWRAPPERS */
a520 5
#if defined(TCPWRAPPERS)
		/* ..in the child. */
		if (!check_host((struct sockaddr *)&his_addr))
			exit(1);
#endif	/* TCPWRAPPERS */
a2875 31

#if defined(TCPWRAPPERS)
static int
check_host(struct sockaddr *sa)
{
	struct sockaddr_in *sin;
	struct hostent *hp;
	char *addr;

	if (sa->sa_family != AF_INET)
		return 1;	/*XXX*/

	sin = (struct sockaddr_in *)sa;
	hp = gethostbyaddr((char *)&sin->sin_addr,
	    sizeof(struct in_addr), AF_INET);
	addr = inet_ntoa(sin->sin_addr);
	if (hp) {
		if (!hosts_ctl("ftpd", hp->h_name, addr, STRING_UNKNOWN)) {
			syslog(LOG_NOTICE, "tcpwrappers rejected: %s [%s]",
			    hp->h_name, addr);
			return (0);
		}
	} else {
		if (!hosts_ctl("ftpd", STRING_UNKNOWN, addr, STRING_UNKNOWN)) {
			syslog(LOG_NOTICE, "tcpwrappers rejected: [%s]", addr);
			return (0);
		}
	}
	return (1);
}
#endif	/* TCPWRAPPERS */
@


1.201
log
@typo, spotted by okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.200 2014/03/17 20:54:10 sthen Exp $	*/
d253 1
a253 1
char *argstr = "AdDhnlMSt:T:u:PUvW46";
@


1.200
log
@Add an option to disallow ftp access to accounts with uid below a certain
number (idea borrowed from pure-ftpd). Enabled by default with minimum uid
1000 to prevent access to admin accounts. tweak/OK millert@@, OK deraadt@@,
gsoares@@ and aja@@ like it too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.199 2014/01/08 17:31:36 jca Exp $	*/
d311 1
a311 1
				    "%s is a bad value for -n, aborting",
@


1.199
log
@If the file size is zero, there's nothing to transmit so avoid spamming
syslog with mmap failures.  Noticed by and ok henning@@, "looks right"
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.198 2013/08/22 04:43:40 guenther Exp $	*/
d133 1
d259 2
a260 1
	    "usage: ftpd [-46ADdlMnPSUW] [-T maxtimeout] [-t timeout] [-u mask]");
d307 10
d844 8
@


1.198
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.197 2013/07/26 18:13:02 guenther Exp $	*/
d1588 6
@


1.197
log
@Make sure tmpline[] is always NUL terminated, to avoid possible
read-beyond-end in get_line().

Analysis and patch by Maxime Villard (rustyBSD (at) gmx.fr)
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.196 2012/12/04 02:24:47 deraadt Exp $	*/
d2815 2
a2816 2
		    "%.24s %d %s %qd %s %c %s %c %c %s ftp %d %s %s\n",
		    ctime(&now), now - start + (now == start),
@


1.196
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.195 2012/03/04 04:05:15 fgsch Exp $	*/
d2228 1
a2228 1
	ret = get_line(cp, 7, stdin);
@


1.195
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.194 2011/12/14 18:01:55 ajacoutot Exp $	*/
a64 1
#include <sys/param.h>
@


1.194
log
@Add a new '-W' option to prevent saving login records to /var/run/wtmp.
This can become pretty handy on busy anonymous servers to avoid filling
up /var with unused wtmp records.
Note that 'U' and 'W' are mutually exclusive.

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.193 2011/02/09 21:13:31 millert Exp $	*/
d2229 1
a2229 1
	ret = getline(cp, 7, stdin);
@


1.193
log
@Set SO_KEEPALIVE on sockets.  OK miod@@.  Also tested by landry@@
"Makes sense" markus@@ and "i don't see a reason not to" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.192 2010/08/27 12:00:21 lum Exp $	*/
d145 1
d253 1
a253 1
char *argstr = "AdDhnlMSt:T:u:UvP46";
d259 1
a259 1
	    "usage: ftpd [-46ADdlMnPSU] [-T maxtimeout] [-t timeout] [-u mask]");
d365 4
d383 5
d893 2
a894 1
		ftpdlogwtmp(ttyline, "", "");
d1000 2
a1001 1
	ftpdlogwtmp(ttyline, pw->pw_name, remotehost);
d2202 2
a2203 1
		ftpdlogwtmp(ttyline, "", "");
@


1.192
log
@In revision 1.14 of ftpd.c the ident variable was removed from its only meaningful usage when a snprintf call was removed, rendering ident useless. Time to remove remaining code.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.191 2010/08/01 16:53:57 tobias Exp $	*/
d442 7
d2250 1
a2250 1
	int on;
d2274 4
d2342 1
a2342 1
	int on;
d2380 4
@


1.191
log
@Properly reset states when a login phase is interrupted by another one.
Prevents ftpd from letting regular users logging in during anonymous-only
mode (-A).

ok millert, ray
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.190 2010/07/30 11:02:56 ray Exp $	*/
a175 3
char	*ident = NULL;


a1108 5
		if (ident != NULL)
			free(ident);
		ident = strdup(passwd);
		if (ident == NULL)
			fatal("Ran out of memory.");
@


1.190
log
@Don't set "success" flags before error checks.
Add check for login_getclass() failure, pointed out by tobias.

OK tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.189 2010/06/18 06:02:57 tobias Exp $	*/
d736 1
@


1.189
log
@Prevent a segmentation fault on ftpd_popen error (memory, file descriptor,
pipe ...) during status command.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.188 2010/06/13 15:27:46 tobias Exp $	*/
d743 2
a744 4
			guest = 1;
			askpasswd = 1;
			lc = login_getclass(pw->pw_class);
			if ((as = auth_open()) == NULL ||
d751 4
a754 2
				login_close(lc);
				lc = NULL;
d758 2
@


1.188
log
@Adjust FTP reply codes (in error conditions) to conform to RFC 959.

ok millert, schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.187 2009/10/27 23:59:31 deraadt Exp $	*/
d1761 4
@


1.187
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.186 2009/04/20 21:04:25 schwarze Exp $	*/
d975 1
a975 1
		perror_reply(451, "Local resource failure: setusercontext");
d1430 1
a1430 1
			reply(435, "Can't build data connection: "
d1935 1
a1935 1
		printf("412 Local resource failure: malloc\r\n");
@


1.186
log
@When receiving a new connection, log the remote IP number
in addition to the remote hostname.

Feature requested by Mark Bucciarelli mkbucc at gmail dot com on misc@@.
"seems OK" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.185 2008/09/30 16:16:21 deraadt Exp $	*/
a60 15

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1985, 1988, 1990, 1992, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ftpd.c	8.4 (Berkeley) 4/16/94";
#else
static const char rcsid[] =
    "$OpenBSD: ftpd.c,v 1.185 2008/09/30 16:16:21 deraadt Exp $";
#endif
#endif /* not lint */
@


1.185
log
@Always say "User %s access denied", in all cases, to avoid some stupid
spinny things which parse those messages.  Do not close the connection
as requested by Josh Grosse, since a 530 is not supposed to do that.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.184 2008/09/12 16:12:08 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.184 2008/09/12 16:12:08 moritz Exp $";
d2177 7
a2183 2
	if (logging)
		syslog(LOG_INFO, "connection from %s", remotehost);
@


1.184
log
@Don't split large commands into multiple commands on a 512-byte
boundary but just fail on them. This prevents CSRF-like attacks,
when a web browser is used to access an ftp server.

Reported by Maksymilian Arciemowicz <cxib@@securityreason.com>.

ok millert@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.183 2008/06/30 12:03:51 ragge Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.183 2008/06/30 12:03:51 ragge Exp $";
d827 1
a827 4
		if (anon_ok)
			reply(530, "Sorry, only anonymous ftp allowed.");
		else
			reply(530, "User %s access denied.", name);
@


1.183
log
@Include file order must be "monitor.h" before "extern.h" otherwise enum
auth_ret is referenced before it is declared, which is not allowed by C99.

Ok krw@@, millert@@, gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.182 2008/04/13 00:22:16 djm Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.182 2008/04/13 00:22:16 djm Exp $";
d2217 1
d2223 2
a2224 1
	if (getline(cp, 7, stdin) == NULL) {
d2227 3
@


1.182
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.181 2007/09/02 15:19:20 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.181 2007/09/02 15:19:20 deraadt Exp $";
d125 1
a126 1
#include "monitor.h"
@


1.181
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.180 2007/07/31 03:35:04 ray Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.180 2007/07/31 03:35:04 ray Exp $";
d923 1
a923 1
			us = arc4random() % 3000000;
@


1.180
log
@From Gilles Chehade:
 - Use strtonum instead of atoi.
 - Improve strtol error checking.
 - Change strchr calls to strcspn and eliminating some unused
   variables as a result.

OK moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.179 2007/07/27 14:12:46 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.179 2007/07/27 14:12:46 moritz Exp $";
d442 2
a443 2
		fds = malloc(n * sizeof(int));
		pfds = malloc(n * sizeof(struct pollfd));
@


1.179
log
@Fix potential memory leak, when snprintf(3) returns an empty buffer.

OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.178 2007/06/21 02:22:51 ray Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.178 2007/06/21 02:22:51 ray Exp $";
d285 1
a285 1
	char *cp, line[LINE_MAX];
d290 1
d336 7
a342 1
			timeout = atoi(optarg);
d348 8
a355 1
			maxtimeout = atoi(optarg);
d367 2
a368 1
			if (*p != '\0' || val < 0 || (val & ~ACCESSPERMS)) {
d370 1
a370 1
				    "%s is a bad value for -u, aborting..",
d373 2
a374 2
			} else
				defumask = val;
d576 1
a576 2
			if ((cp = strchr(line, '\n')) != NULL)
				*cp = '\0';
d617 1
a617 2
			if ((cp = strchr(line, '\n')) != NULL)
				*cp = '\0';
d627 1
a627 2
			if ((cp = strchr(line, '\n')) != NULL)
				*cp = '\0';
d1115 1
a1115 1
		char *cp, line[LINE_MAX];
d1118 1
a1118 2
			if ((cp = strchr(line, '\n')) != NULL)
				*cp = '\0';
d2033 1
a2033 4
	char *cp;

	if ((cp = strchr(cbuf,'\n')))
		*cp = '\0';
d2071 1
a2071 1
			char *cp, line[LINE_MAX];
d2074 1
a2074 2
				if ((cp = strchr(line, '\n')) != NULL)
					*cp = '\0';
@


1.178
log
@Adjust spacing, combine malloc + strlcpy + strlcat into a single
asprintf call.

OK moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.177 2007/06/19 06:48:23 ray Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.177 2007/06/19 06:48:23 ray Exp $";
d2797 1
a2804 1
		free(vpw);
@


1.177
log
@Make sure perror_reply() is only called when errno is set.  When
changing perror_reply() -> reply(), increase error message detail
for ftp client.  Move free() statement to prevent errno clobbering.

OK moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.176 2007/03/22 15:53:10 cloder Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.176 2007/03/22 15:53:10 cloder Exp $";
a2883 1
	size_t dirsiz;
d2892 1
a2892 1
		    cp = dir + strlen(dir);
d2910 1
a2910 1
	 * Otherwise, replace ~foo with  pw_dir.
d2915 1
a2915 2
		dirsiz = strlen(cp) + strlen(pw->pw_dir) + 1;
		if ((newdir = malloc(dirsiz)) == NULL)
a2916 2
		strlcpy(newdir, pw->pw_dir, dirsiz);
		strlcat(newdir, cp, dirsiz);
@


1.176
log
@Do not advertise version in the ftp banner, because there is no reason to.
OK mbalmer@@, xsa@@, henning@@, idea prompted by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.175 2007/03/01 20:06:27 otto Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.175 2007/03/01 20:06:27 otto Exp $";
d1420 2
a1421 1
			perror_reply(425, "Can't build data connection");
d1429 2
a1430 1
			perror_reply(425, "Can't build data connection");
d1437 2
a1438 1
			perror_reply(435, "Can't build data connection");
d1497 2
a1498 1
			perror_reply(425, "Can't build data connection");
d1505 2
a1506 1
			perror_reply(425, "Can't build data connection");
d1511 2
a1512 1
			perror_reply(435, "Can't build data connection");
d1639 1
a1639 1
	perror_reply(426, "Data connection");
d1644 1
a1644 1
	perror_reply(551, "Error on input file");
d1743 1
a1743 1
	perror_reply(426, "Data Connection");
d1748 1
a1748 1
	perror_reply(452, "Error writing file");
d2293 1
a2295 1
	perror_reply(425, "Can't open passive connection");
d2430 1
a2432 1
	perror_reply(425, "Can't open passive connection");
d2906 1
d2917 1
a2917 2
		if ((newdir = malloc(dirsiz)) == NULL) {
			free(user);
a2918 1
		}
a2922 2
	if (user)
		free(user);
@


1.175
log
@- use proper log facility and priority in the slave sig handlers
- if the monitor decides to kill the slave, log that
ok millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.174 2006/12/21 02:28:47 krw Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.174 2006/12/21 02:28:47 krw Exp $";
a127 2
static char version[] = "Version 6.6/OpenBSD";

d635 1
a635 1
		reply(220, "FTP server (%s) ready.", version);
d637 2
a638 2
		reply(220, "%s FTP server (%s) ready.",
		    (multihome ? dhostname : hostname), version);
a1797 1
	printf("     %s\r\n", version);
@


1.174
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.173 2006/10/18 21:46:09 millert Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.173 2006/10/18 21:46:09 millert Exp $";
d658 1
d669 2
a670 1
	syslog_r(LOG_ERR, &sdata, "got signal %s", sys_signame[signo]);
d723 1
a723 1
		kill_slave();
d934 1
a934 1
				kill_slave();
d945 1
a945 1
			kill_slave();
d957 1
a957 1
			kill_slave();
d965 1
a965 1
		kill_slave();
d1964 1
@


1.173
log
@Avoid double fclose() of a file if we exceed retries.  Coverity ID 2669.
OK cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.172 2006/10/18 21:23:28 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.172 2006/10/18 21:23:28 deraadt Exp $";
d1529 1
a1529 1
 * Tranfer the contents of "instr" to "outstr" peer using the appropriate
@


1.172
log
@you do not call fclose() on a file descriptor; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.171 2006/04/21 17:42:50 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.171 2006/04/21 17:42:50 deraadt Exp $";
d1378 1
a1378 1
	FILE *file;
d1457 2
a1519 1
		(void) fclose(file);
@


1.171
log
@lint cleanup; ok ray moritz dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.170 2005/12/03 18:23:30 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.170 2005/12/03 18:23:30 deraadt Exp $";
d568 1
a568 1
		(void) fclose(fd);
@


1.170
log
@remove shadowing variables; ok pval
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.169 2005/12/01 17:36:59 pvalchev Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.169 2005/12/01 17:36:59 pvalchev Exp $";
a132 1
union sockunion server_addr;
d172 1
a172 1
int	defumask = CMASK;		/* default umask value */
d180 1
d182 1
d399 1
a399 1
		int *fds, n, i, fd;
d402 1
d448 1
a448 1
			    (char *)&on, sizeof(on)) < 0) {
d518 1
a518 1
				&addrlen) < 0) {
d534 2
a535 2
	if (his_addr.su_family == AF_INET6
	 && IN6_IS_ADDR_V4MAPPED(&his_addr.su_sin6.sin6_addr)) {
d577 1
a577 1
		if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *)&tos,
d586 1
a586 1
	if (setsockopt(0, SOL_SOCKET, SO_OOBINLINE, (char *)&on, sizeof(on)) < 0)
d591 1
d652 1
a652 1

d893 2
a894 1
	int authok, flags;
d1215 1
a1215 1
	send_data(fin, dout, st.st_blksize, st.st_size,
d1323 1
a1323 1
	    (char *) &on, sizeof(on)) < 0)
d1334 1
a1334 1
		sleep(tries);
d1341 1
a1341 1
		if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&on,
d1354 1
a1354 1
	if (setsockopt(s, IPPROTO_TCP, TCP_NOPUSH, (char *)&on, sizeof(on)) < 0)
d1359 1
a1359 1
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *)&on, sizeof(on)) < 0)
d1382 1
a1382 1
	int alen;
d1389 1
a1389 1
				size);
d1574 3
a1576 1
			buf = mmap(0, filesize, PROT_READ, MAP_SHARED, filefd,
d1579 2
a1580 2
				syslog(LOG_WARNING, "mmap(%lu): %m",
				    (unsigned long)filesize);
d1584 1
a1584 1
			len = filesize;
d1588 1
a1588 1
					munmap(buf, (size_t)filesize);
d1598 1
a1598 1
			munmap(buf, (size_t)filesize);
d1606 1
a1606 1
		if ((buf = malloc((u_int)blksize)) == NULL) {
d1612 1
a1612 1
		while ((cnt = read(filefd, buf, (u_int)blksize)) > 0 &&
d1833 2
a1834 1
		int alen, af, i;
d1844 2
a1845 2
			a = (u_char *) &su->su_sin.sin_addr;
			p = (u_char *) &su->su_sin.sin_port;
d1855 2
a1856 2
			a = (u_char *) &su->su_sin.sin_addr;
			p = (u_char *) &su->su_sin.sin_port;
d1861 2
a1862 2
			a = (u_char *) &su->su_sin6.sin6_addr;
			p = (u_char *) &su->su_sin6.sin6_port;
d1875 1
a1875 1
			printf("(%u,%u", af, alen);
d2191 1
d2264 1
a2264 1
	    (char *)&on, sizeof(on)) < 0)
d2270 1
a2270 1
		 pasv_addr.su_len) < 0)
d2274 1
a2274 1
	if (getsockname(pdata, (struct sockaddr *) &pasv_addr, &len) < 0)
d2278 2
a2279 2
	a = (u_char *) &pasv_addr.su_sin.sin_addr;
	p = (u_char *) &pasv_addr.su_sin.sin_port;
a2291 29
/*
 * convert protocol identifier to/from AF
 */
int
lpsvproto2af(int proto)
{

	switch (proto) {
	case 4:	return AF_INET;
#ifdef INET6
	case 6:	return AF_INET6;
#endif
	default: return -1;
	}
}

int
af2lpsvproto(int af)
{

	switch (af) {
	case AF_INET:	return 4;
#ifdef INET6
	case AF_INET6:	return 6;
#endif
	default:	return -1;
	}
}

d2369 1
a2369 1
		    (char *)&on, sizeof(on)) < 0)
d2375 1
a2375 1
		    (char *)&on, sizeof(on)) < 0)
d2382 1
a2382 1
	if (bind(pdata, (struct sockaddr *) &pasv_addr, pasv_addr.su_len) < 0)
d2385 1
a2385 1
	if (getsockname(pdata, (struct sockaddr *) &pasv_addr, &len) < 0)
d2389 1
a2389 1
	p = (u_char *) &pasv_addr.su_port;
d2394 1
a2394 1
			a = (u_char *) &pasv_addr.su_sin.sin_addr;
d2400 1
a2400 1
			a = (u_char *) &pasv_addr.su_sin6.sin6_addr;
d2744 1
d2887 1
a2887 1
		if ((user = malloc(cp - dir)) == NULL)
d2889 1
a2889 1
		strlcpy(user, dir + 1, cp - dir);
@


1.169
log
@fix double var declarations in same scope, found by lint; ok deraadt cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.168 2005/08/22 17:49:37 mickey Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.168 2005/08/22 17:49:37 mickey Exp $";
d1827 2
a1844 3
	    {
		int alen, af, i;

a1872 1
	    }
a1874 3
	    {
		u_char af;

d1900 1
a1900 1
					af, hbuf, pbuf);
a1902 1
	    }
@


1.168
log
@EOF in ascii mode may also mean EOF so avoid printing a bogus error and behave same as bin mode; beck@@ deraadt@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.167 2005/07/14 14:48:47 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.167 2005/07/14 14:48:47 moritz Exp $";
d398 1
a398 1
		int *fds, n, error, i, fd;
d1892 1
a1892 1
			char hbuf[MAXHOSTNAMELEN], pbuf[10];
@


1.167
log
@let root create the data socket. fixes PR 4287.
ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.166 2005/05/24 02:24:57 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.166 2005/05/24 02:24:57 moritz Exp $";
d1192 6
a1197 3
				if ((c=getc(fin)) == EOF) {
					perror_reply(550, name);
					goto done;
d1265 6
a1270 3
				if ((c=getc(fout)) == EOF) {
					perror_reply(550, name);
					goto done;
@


1.166
log
@readd endpwent()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.165 2005/05/24 02:12:40 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.165 2005/05/24 02:12:40 moritz Exp $";
d1309 1
a1309 1
	s = socket(ctrl_addr.su_family, SOCK_STREAM, 0);
@


1.165
log
@no need for endpwent()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.164 2005/04/21 00:12:20 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.164 2005/04/21 00:12:20 deraadt Exp $";
d395 1
@


1.164
log
@make code prettier so we can tell it is safe when we read it; ok beck cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.163 2005/03/15 12:22:58 niallo Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.163 2005/03/15 12:22:58 niallo Exp $";
a394 1
	endpwent();
@


1.163
log
@better handling of cases where getnameinfo() returns non-zero.
upon failure, don't try to print the contents of the char buffers we passed it.

ok & feedback henning@@, moritz@@ (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.162 2004/12/06 23:04:14 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.162 2004/12/06 23:04:14 deraadt Exp $";
d2802 1
a2802 1
		if ((len = snprintf(buf, sizeof(buf),
d2809 3
a2811 2
		    ((guest) ? "*" : pw->pw_name), dhostname)) >= sizeof(buf)
		    || len < 0) {
@


1.163.2.1
log
@MFC:
Fix by moritz@@

let root create the data socket. fixes PR 4287.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.163 2005/03/15 12:22:58 niallo Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.163 2005/03/15 12:22:58 niallo Exp $";
d1309 1
a1309 1
	s = monitor_socket(ctrl_addr.su_family);
@


1.162
log
@seperate reply_r, like earlier change but safer; moritz ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.160 2004/12/03 23:57:40 moritz Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.160 2004/12/03 23:57:40 moritz Exp $";
d290 1
d629 2
a630 2
		getnameinfo((struct sockaddr *)&ctrl_addr, ctrl_addr.su_len,
		    dhostname, sizeof(dhostname), NULL, 0, 0);
d633 5
a637 2
	reply(220, "%s FTP server (%s) ready.",
	    (multihome ? dhostname : hostname), version);
d1373 1
d1451 1
a1451 1
			getnameinfo((struct sockaddr *)&data_source,
d1454 7
a1460 2
			reply(425, "Can't create data socket (%s,%s): %s.",
			    hbuf, pbuf, strerror(errno));
d1782 1
d1786 1
a1786 1
	getnameinfo((struct sockaddr *)&his_addr, his_addr.su_len,
d1789 1
a1789 1
	if (strcmp(remotehost, hbuf) != 0)
d2149 4
a2152 2
	getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, 0);
	(void) strlcpy(remotehost, hbuf, sizeof(remotehost));
@


1.161
log
@reply() used to play a lot with stdout, expecially fflush(stdout).
The recent change is to avoid stdio.  That's good, except there are
nearly 130 calls to this function, yet what if one of them depended on
fflush() or something else in this code?  The semantic change was
never checked.  That is not how we do development -- back this out
until we know that checking work has been done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.159 2004/11/28 22:29:44 henning Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.159 2004/11/28 22:29:44 henning Exp $";
d1931 27
@


1.160
log
@make reply() reentrant. fixes a signal race.
ok henning@@
@
text
@d1910 2
a1911 3
	char *p, *next;
	char msg[BUFSIZ];
	char buf[BUFSIZ];
a1912 1
	struct syslog_data sdata = SYSLOG_DATA_INIT;
d1915 1
a1915 1
	vsnprintf(msg, sizeof(msg), fmt, ap);
d1917 6
a1922 3

	next = msg;

d1924 4
a1927 7
		snprintf(buf, sizeof(buf), "%d%s %s\r\n", n,
		    (next != '\0') ? "-" : "", p);
		write(STDOUT_FILENO, buf, strlen(buf));
		if (debug) {
			buf[strlen(buf) - 2] = '\0';
			syslog_r(LOG_DEBUG, &sdata, "<--- %s", buf);
		}
d1929 2
@


1.159
log
@logging fixes:
-don't prefix ftpd: in syslog(), it does that for us
-replace a bad (too late) err() by syslog + exit
from moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.158 2004/11/28 19:36:48 henning Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.158 2004/11/28 19:36:48 henning Exp $";
d1910 3
a1912 2
	char *buf, *p, *next;
	int rval;
d1914 1
d1917 1
a1917 1
	rval = vasprintf(&buf, fmt, ap);
d1919 3
a1921 6
	if (rval == -1 || buf == NULL) {
		printf("412 Local resource failure: malloc\r\n");
		fflush(stdout);
		dologout(1);
	}
	next = buf;
d1923 7
a1929 4
		printf("%d%s %s\r\n", n, (next != '\0') ? "-" : "", p);
		if (debug)
			syslog(LOG_DEBUG, "<--- %d%s %s", n,
			    (next != '\0') ? "-" : "", p);
a1930 2
	(void)fflush(stdout);
	free(buf);
@


1.158
log
@bump version
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.157 2004/11/28 19:12:31 henning Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.157 2004/11/28 19:12:31 henning Exp $";
a99 1
#include <err.h>
d355 1
a355 1
				    "ftpd: %s is a bad value for -u, aborting..",
d484 2
a485 1
				err(1, "poll");
@


1.157
log
@fix ttyline setting, fixes proctitle.
notice independently by theo and pval, fix from moritz jodeit
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.156 2004/11/28 18:49:29 henning Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.156 2004/11/28 18:49:29 henning Exp $";
d129 1
a129 1
static char version[] = "Version 6.5/OpenBSD";
@


1.156
log
@privilege seperate ftpd
handle the pre-authentication phase (minus a tiny tiny tiny amount
of code after accept()) in an unprivileged process, asking the
privileged monitor for help where needed.
work by Moritz Jodeit <moritz@@jodeit.org> with help from theo and me
tests theo ian@@ matthieu@@ ben@@networkinsanity.com a.schlichting@@lemarit.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.155 2004/11/22 00:05:15 millert Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.155 2004/11/22 00:05:15 millert Exp $";
d181 1
a181 1
static char ttyline[20];
@


1.155
log
@More sensible error when both the -n and -A flags are used.  Text OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.154 2004/09/30 20:33:52 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.154 2004/09/30 20:33:52 deraadt Exp $";
d127 1
d257 1
d390 7
d524 1
a524 20
	sa.sa_handler = SIG_DFL;
	(void) sigaction(SIGCHLD, &sa, NULL);

	sa.sa_handler = sigurg;
	sa.sa_flags = 0;		/* don't restart syscalls for SIGURG */
	(void) sigaction(SIGURG, &sa, NULL);

	sigfillset(&sa.sa_mask);	/* block all signals in handler */
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigquit;
	(void) sigaction(SIGHUP, &sa, NULL);
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
	(void) sigaction(SIGTERM, &sa, NULL);

	sa.sa_handler = lostconn;
	(void) sigaction(SIGPIPE, &sa, NULL);

	sa.sa_handler = toolong;
	(void) sigaction(SIGALRM, &sa, NULL);
a586 4
#ifdef	F_SETOWN
	if (fcntl(fileno(stdin), F_SETOWN, getpid()) == -1)
		syslog(LOG_ERR, "fcntl F_SETOWN: %m");
#endif
d634 3
d713 2
a714 1
	if (logged_in)
d716 1
a872 1

d880 1
a880 1
	exit(0);
d883 1
a883 1
void
d894 1
a894 1
		return;
d924 2
a925 1
				exit(0);
d927 1
a927 1
			return;
d934 2
a935 1
		if (guestpw == NULL)
d937 1
d947 2
a948 1
			exit(0);
d955 8
a962 1
		exit(0);
d964 1
d1069 5
a1073 1
	if (seteuid(pw->pw_uid) < 0) {
d1137 1
a1137 1
	return;
d1143 1
a1304 1
	(void) seteuid(0);
a1305 1
	(void) seteuid((uid_t)pw->pw_uid);
a1313 1
	(void) seteuid(0);
d1315 1
a1315 1
		if (bind(s, (struct sockaddr *)&data_source,
d1318 1
a1318 2
		if (errno != EADDRINUSE || tries > 10) {
			(void) seteuid(pw->pw_uid);
a1319 1
		}
a1321 1
	(void) seteuid((uid_t)pw->pw_uid);
d1354 2
a1355 1
	(void) close(s);
d2778 35
@


1.154
log
@cope nicer with accept() failures, from freebsd; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.153 2003/12/12 19:45:22 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.153 2003/12/12 19:45:22 deraadt Exp $";
d817 4
a820 1
		reply(530, "Sorry, only anonymous ftp allowed.");
@


1.153
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.152 2003/12/10 22:57:12 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.152 2003/12/10 22:57:12 deraadt Exp $";
d484 5
a488 3
					if (fork() == 0)
						goto child;
					close(fd);
@


1.152
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.151 2003/12/09 22:55:47 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.151 2003/12/09 22:55:47 deraadt Exp $";
d1021 1
a1021 1
				  pw->pw_dir, dhostname);
d1024 1
a1024 1
					  pw->pw_dir, hostname);
d1193 1
a1193 1
		  (restart_point == 0 && cmd == 0 && S_ISREG(st.st_mode)));
d1548 1
a1548 1
				   (off_t)0);
d1564 2
a1565 1
				if (cnt > 0) byte_count += cnt;
d2817 1
a2817 1
	if (dir[0] !=  '~')
@


1.151
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.150 2003/12/09 07:22:10 beck Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d72 2
a73 2
static const char rcsid[] = 
    "$OpenBSD: ftpd.c,v 1.150 2003/12/09 07:22:10 beck Exp $";
d1366 1
a1366 1
		(void) snprintf(sizebuf, sizeof(sizebuf), " (%qd bytes)", 
d1413 1
a1413 1
			perror_reply(435, "Can't build data connection"); 
d1439 2
a1440 2
			getnameinfo((struct sockaddr *)&data_source, 
			    data_source.su_len, hbuf, sizeof(hbuf), pbuf, 
d2508 3
a2510 3
 * as we assume address family for control and data connections are the same, 
 * we do not return the list of address families we support - instead, we 
 * return the address family of the control connection.  
@


1.150
log
@fix PR 3596 by making root create the socket, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.149 2003/11/20 12:32:34 jmc Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.149 2003/11/20 12:32:34 jmc Exp $";
d1471 1
a1471 1
	    	ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) { /* XXX */
@


1.149
log
@ftpd.8:
- simpler macros
- sort options
- some updates

ftpd.c:
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.148 2003/11/12 19:32:01 millert Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.148 2003/11/12 19:32:01 millert Exp $";
d1293 1
d1295 1
@


1.148
log
@Don't hold on to the bind() while we loop around waiting to see if we can
make our connection.  Adapted from FreeBSD via danh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.147 2003/10/01 08:06:31 itojun Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.147 2003/10/01 08:06:31 itojun Exp $";
d276 1
a276 1
	    "usage: ftpd [-AdDlMnPSU46] [-T maxtimeout] [-t timeout] [-u mask]");
@


1.147
log
@listen to bodh IPv4/v6 ftp port on -D by default.  deraadt ok.
comments from markus, millert.  tested by fries
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.146 2003/09/30 06:13:08 jmc Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.146 2003/09/30 06:13:08 jmc Exp $";
d1432 47
a1478 12
	file = getdatasock(mode);
	if (file == NULL) {
		char hbuf[MAXHOSTNAMELEN], pbuf[10];

		getnameinfo((struct sockaddr *)&data_source, data_source.su_len,
		    hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
		    NI_NUMERICHOST | NI_NUMERICSERV);
		reply(425, "Can't create data socket (%s,%s): %s.",
		    hbuf, pbuf, strerror(errno));
		return (NULL);
	}
	data = fileno(file);
d1480 6
a1485 42
	/*
	 * attempt to connect to reserved port on client machine;
	 * this looks like an attack
	 */
	switch (data_dest.su_family) {
	case AF_INET:
		p = (in_port_t *)&data_dest.su_sin.sin_port;
		fa = (u_char *)&data_dest.su_sin.sin_addr;
		ha = (u_char *)&his_addr.su_sin.sin_addr;
		alen = sizeof(struct in_addr);
		break;
	case AF_INET6:
		p = (in_port_t *)&data_dest.su_sin6.sin6_port;
		fa = (u_char *)&data_dest.su_sin6.sin6_addr;
		ha = (u_char *)&his_addr.su_sin6.sin6_addr;
		alen = sizeof(struct in6_addr);
		break;
	default:
		perror_reply(425, "Can't build data connection");
		(void) fclose(file);
		pdata = -1;
		return (NULL);
	}
	if (data_dest.su_family != his_addr.su_family ||
	    ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) {	/* XXX */
		perror_reply(425, "Can't build data connection");
		(void) fclose(file);
		data = -1;
		return NULL;
	}
	if (portcheck && memcmp(fa, ha, alen) != 0) {
		perror_reply(435, "Can't build data connection");
		(void) fclose(file);
		data = -1;
		return NULL;
	}
	while (connect(data, (struct sockaddr *)&data_dest,
	    data_dest.su_len) < 0) {
		if (errno == EADDRINUSE && retry < swaitmax) {
			sleep((unsigned) swaitint);
			retry += swaitint;
			continue;
d1487 2
a1488 1
		perror_reply(425, "Can't build data connection");
d1490 6
a1495 6
		data = -1;
		return (NULL);
	}
	reply(150, "Opening %s mode data connection for '%s'%s.",
	    type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
	return (file);
@


1.146
log
@usage():

- add missing -n (from Jeff Ito PR 3496)
- remove deprecated -h
- sort -T and -t to match man page
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.145 2003/07/29 18:39:22 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.145 2003/07/29 18:39:22 deraadt Exp $";
d119 1
d165 1
a165 1
int	family = AF_INET;
d389 3
a391 2
		int ctl_sock, fd;
		struct servent *sv;
d402 20
a421 6
		/*
		 * Get port number for ftp/tcp.
		 */
		sv = getservbyname("ftp", "tcp");
		if (sv == NULL) {
			syslog(LOG_ERR, "getservbyname for ftp failed");
d424 1
d426 1
a426 1
		 * Open a socket, bind it to the FTP port, and start
d429 28
a456 4
		ctl_sock = socket(family, SOCK_STREAM, 0);
		if (ctl_sock < 0) {
			syslog(LOG_ERR, "control socket: %m");
			exit(1);
d458 4
a461 22
		if (setsockopt(ctl_sock, SOL_SOCKET, SO_REUSEADDR,
		    (char *)&on, sizeof(on)) < 0)
			syslog(LOG_ERR, "control setsockopt: %m");
		memset(&server_addr, 0, sizeof(server_addr));
		server_addr.su_sin.sin_family = family;
		switch (family) {
		case AF_INET:
			server_addr.su_len = sizeof(struct sockaddr_in);
			server_addr.su_sin.sin_port = sv->s_port;
			break;
		case AF_INET6:
			server_addr.su_len = sizeof(struct sockaddr_in6);
			server_addr.su_sin6.sin6_port = sv->s_port;
			break;
		}
		if (bind(ctl_sock, (struct sockaddr *)&server_addr,
			 server_addr.su_len)) {
			syslog(LOG_ERR, "control bind: %m");
			exit(1);
		}
		if (listen(ctl_sock, 32) < 0) {
			syslog(LOG_ERR, "control listen: %m");
d464 1
d473 4
a476 9
			addrlen = sizeof(his_addr);
			fd = accept(ctl_sock, (struct sockaddr *)&his_addr,
				    &addrlen);
			if (fork() == 0) {
				/* child */
				(void) dup2(fd, 0);
				(void) dup2(fd, 1);
				close(ctl_sock);
				break;
d478 10
a487 1
			close(fd);
d490 6
@


1.145
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.144 2003/07/07 03:18:11 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.144 2003/07/07 03:18:11 deraadt Exp $";
d275 1
a275 1
	    "usage: ftpd [-AdDhlMPSU46] [-t timeout] [-T maxtimeout] [-u mask]");
@


1.145.2.1
log
@MFC:
Fix by millert@@

Don't hold on to the bind() while we loop around waiting to see if we can
make our connection.  Adapted from FreeBSD via danh@@

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.145 2003/07/29 18:39:22 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.145 2003/07/29 18:39:22 deraadt Exp $";
d1398 12
a1409 12
	do {
		file = getdatasock(mode);
		if (file == NULL) {
			char hbuf[MAXHOSTNAMELEN], pbuf[10];

			getnameinfo((struct sockaddr *)&data_source, 
			    data_source.su_len, hbuf, sizeof(hbuf), pbuf, 
			    sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
			reply(425, "Can't create data socket (%s,%s): %s.",
			    hbuf, pbuf, strerror(errno));
			return (NULL);
		}
d1411 42
a1452 41
		/*
		 * attempt to connect to reserved port on client machine;
		 * this looks like an attack
		 */
		switch (data_dest.su_family) {
		case AF_INET:
			p = (in_port_t *)&data_dest.su_sin.sin_port;
			fa = (u_char *)&data_dest.su_sin.sin_addr;
			ha = (u_char *)&his_addr.su_sin.sin_addr;
			alen = sizeof(struct in_addr);
			break;
		case AF_INET6:
			p = (in_port_t *)&data_dest.su_sin6.sin6_port;
			fa = (u_char *)&data_dest.su_sin6.sin6_addr;
			ha = (u_char *)&his_addr.su_sin6.sin6_addr;
			alen = sizeof(struct in6_addr);
			break;
		default:
			perror_reply(425, "Can't build data connection");
			(void) fclose(file);
			pdata = -1;
			return (NULL);
		}
		if (data_dest.su_family != his_addr.su_family ||
	    	ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) { /* XXX */
			perror_reply(425, "Can't build data connection");
			(void) fclose(file);
			return NULL;
		}
		if (portcheck && memcmp(fa, ha, alen) != 0) {
			perror_reply(435, "Can't build data connection");
			(void) fclose(file);
			return NULL;
		}

		if (connect(fileno(file), (struct sockaddr *)&data_dest,
		    data_dest.su_len) == 0) {
			reply(150, "Opening %s mode data connection for '%s'%s.",
			    type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
			data = fileno(file);
			return (file);
d1454 1
a1454 2
		if (errno != EADDRINUSE)
			break;
d1456 6
a1461 6
		sleep((unsigned) swaitint);
		retry += swaitint;
	} while (retry <= swaitmax);
	perror_reply(425, "Can't build data connection");
	(void) fclose(file);
	return (NULL);
@


1.145.2.2
log
@MFC:
Fix by beck@@

fix PR 3596 by making root create the socket

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.145.2.1 2003/11/20 20:44:27 brad Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.145.2.1 2003/11/20 20:44:27 brad Exp $";
a1258 1
	(void) seteuid(0);
a1259 1
	(void) seteuid((uid_t)pw->pw_uid);
@


1.144
log
@make this match protos; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.143 2003/06/11 14:24:46 deraadt Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.143 2003/06/11 14:24:46 deraadt Exp $";
d2284 1
a2284 1
 		
d2810 1
a2810 1
			free(user);		
@


1.143
log
@ansi cleanup; ok ian markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.142 2003/06/02 19:38:24 millert Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.142 2003/06/02 19:38:24 millert Exp $";
d848 1
a848 1
			logout(utmp.ut_line);
d948 1
a948 1
		login(&utmp);
d2094 1
a2094 1
			logout(utmp.ut_line);
@


1.142
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.141 2003/04/10 00:04:58 millert Exp $	*/
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.141 2003/04/10 00:04:58 millert Exp $";
d257 1
a257 1
curdir()
d272 1
a272 1
usage()
d280 1
a280 4
main(argc, argv, envp)
	int argc;
	char *argv[];
	char **envp;
d622 1
a622 2
lostconn(signo)
	int signo;
d632 1
a632 2
sigquit(signo)
	int signo;
d646 1
a646 3
sgetpwnam(name, pw)
	char *name;
	struct passwd *pw;
d683 1
a683 2
user(name)
	char *name;
d814 1
a814 3
checkuser(fname, name)
	char *fname;
	char *name;
d841 1
a841 1
end_login()
d855 1
a855 2
pass(passwd)
	char *passwd;
d1101 1
a1101 2
retrieve(cmd, name)
	char *cmd, *name;
d1174 1
a1174 3
store(name, mode, unique)
	char *name, *mode;
	int unique;
d1252 1
a1252 2
getdatasock(mode)
	char *mode;
d1318 1
a1318 4
dataconn(name, size, mode)
	char *name;
	off_t size;
	char *mode;
d1471 1
a1471 5
send_data(instr, outstr, blksize, filesize, isreg)
	FILE *instr, *outstr;
	off_t blksize;
	off_t filesize;
	int isreg;
d1588 1
a1588 2
receive_data(instr, outstr)
	FILE *instr, *outstr;
d1686 1
a1686 2
statfilecmd(filename)
	char *filename;
d1722 1
a1722 1
statcmd()
d1854 1
a1854 2
fatal(s)
	char *s;
d1909 1
a1909 2
ack(s)
	char *s;
d1916 1
a1916 2
nack(s)
	char *s;
d1924 1
a1924 2
yyerror(s)
	char *s;
d1934 1
a1934 2
delete(name)
	char *name;
d1959 1
a1959 2
cwd(path)
	char *path;
d1982 1
a1982 2
replydirname(name, message)
	const char *name, *message;
d2006 1
a2006 2
makedir(name)
	char *name;
d2017 1
a2017 2
removedir(name)
	char *name;
d2028 1
a2028 1
pwd()
d2039 1
a2039 2
renamefrom(name)
	char *name;
d2052 1
a2052 2
renamecmd(from, to)
	char *from, *to;
d2063 1
a2063 2
dolog(sa)
	struct sockaddr *sa;
d2085 1
a2085 2
dologout(status)
	int status;
d2101 1
a2101 2
sigurg(signo)
	int signo;
d2108 1
a2108 1
myoob()
d2143 1
a2143 1
passive()
d2494 1
a2494 3
guniquefd(local, nam)
	char *local;
	char **nam;
d2532 1
a2532 3
perror_reply(code, string)
	int code;
	char *string;
d2544 1
a2544 2
send_file_list(whichf)
	char *whichf;
d2682 1
a2682 2
reapchild(signo)
	int signo;
d2694 1
a2694 4
logxfer(name, size, start)
	char *name;
	off_t size;
	time_t start;
d2738 1
a2738 2
check_host(sa)
	struct sockaddr *sa;
d2772 1
a2772 3
copy_dir(dir, pw)
	char *dir;
	struct passwd *pw;
@


1.141
log
@Replace strcpy() w/ strlcpy() from espie@@

Don't try to free pw_dir -- it is no longer allocated separately.
Instead, add an extra param to sgetpwnam() to allow it to dupe an
existing struct passwd * (instead of doing a lookup by username)
and use this to reallocate pw in the case where pw_dir is the NULL
string.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.140 2003/02/17 06:52:58 mpech Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d73 1
a73 1
    "$OpenBSD: ftpd.c,v 1.140 2003/02/17 06:52:58 mpech Exp $";
@


1.140
log
@reply() -> perror_reply().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.139 2002/11/25 22:45:39 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.139 2002/11/25 22:45:39 millert Exp $";
d251 1
a251 1
		 sgetpwnam(char *);
d655 1
a655 1
sgetpwnam(name)
d657 1
d660 1
a660 1
	struct passwd *pw;
d662 1
a662 1
	if ((pw = getpwnam(name)) == NULL)
d664 1
a664 4
	if (save) {
		memset(save->pw_passwd, 0, strlen(save->pw_passwd));
		free(save);
	}
d671 4
d723 1
a723 1
		else if ((pw = sgetpwnam("ftp")) != NULL) {
d750 1
a750 1
	if ((pw = sgetpwnam(name))) {
d876 1
d982 2
d985 1
a985 2
		free(pw->pw_dir);
		pw->pw_dir = newdir;
d989 5
a993 12
	if (strlen(pw->pw_dir) < 1) {
		char *newdir;

		newdir = malloc(2);
		if (newdir == NULL) {
			perror_reply(421, "Local resource failure: malloc");
			dologout(1);
			/* NOTREACHED */
		}
		strlcpy(newdir, pw->pw_dir, 2);
		free(pw->pw_dir);
		pw->pw_dir = newdir;
d1020 1
a1020 1
		strcpy(pw->pw_dir, "/");
d1030 1
a1030 1
		strcpy(pw->pw_dir, "/");
@


1.140.2.1
log
@MFC:
Fix by millert@@

Don't hold on to the bind() while we loop around waiting to see if we can
make our connection.  Adapted from FreeBSD via danh@@

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.140 2003/02/17 06:52:58 mpech Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.140 2003/02/17 06:52:58 mpech Exp $";
d1423 12
a1434 12
	do {
		file = getdatasock(mode);
		if (file == NULL) {
			char hbuf[MAXHOSTNAMELEN], pbuf[10];

			getnameinfo((struct sockaddr *)&data_source, 
			    data_source.su_len, hbuf, sizeof(hbuf), pbuf, 
			    sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
			reply(425, "Can't create data socket (%s,%s): %s.",
			    hbuf, pbuf, strerror(errno));
			return (NULL);
		}
d1436 42
a1477 41
		/*
		 * attempt to connect to reserved port on client machine;
		 * this looks like an attack
		 */
		switch (data_dest.su_family) {
		case AF_INET:
			p = (in_port_t *)&data_dest.su_sin.sin_port;
			fa = (u_char *)&data_dest.su_sin.sin_addr;
			ha = (u_char *)&his_addr.su_sin.sin_addr;
			alen = sizeof(struct in_addr);
			break;
		case AF_INET6:
			p = (in_port_t *)&data_dest.su_sin6.sin6_port;
			fa = (u_char *)&data_dest.su_sin6.sin6_addr;
			ha = (u_char *)&his_addr.su_sin6.sin6_addr;
			alen = sizeof(struct in6_addr);
			break;
		default:
			perror_reply(425, "Can't build data connection");
			(void) fclose(file);
			pdata = -1;
			return (NULL);
		}
		if (data_dest.su_family != his_addr.su_family ||
	    	ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) { /* XXX */
			perror_reply(425, "Can't build data connection");
			(void) fclose(file);
			return NULL;
		}
		if (portcheck && memcmp(fa, ha, alen) != 0) {
			perror_reply(435, "Can't build data connection");
			(void) fclose(file);
			return NULL;
		}

		if (connect(fileno(file), (struct sockaddr *)&data_dest,
		    data_dest.su_len) == 0) {
			reply(150, "Opening %s mode data connection for '%s'%s.",
			    type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
			data = fileno(file);
			return (file);
d1479 1
a1479 2
		if (errno != EADDRINUSE)
			break;
d1481 6
a1486 6
		sleep((unsigned) swaitint);
		retry += swaitint;
	} while (retry <= swaitmax);
	perror_reply(425, "Can't build data connection");
	(void) fclose(file);
	return (NULL);
@


1.140.2.2
log
@Pull patch from -current:
Fix by beck@@

fix PR 3596 by making root create the socket

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.140.2.1 2003/11/20 22:50:32 margarida Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.140.2.1 2003/11/20 22:50:32 margarida Exp $";
a1280 1
	(void) seteuid(0);
a1281 1
	(void) seteuid((uid_t)pw->pw_uid);
@


1.139
log
@Change a setuid() that should be seteuid(), not iced by grange@@
Move a va_end so it gets called in an error condition as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.138 2002/11/15 19:52:15 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.138 2002/11/15 19:52:15 millert Exp $";
d2073 1
a2073 1
		reply(550, "Can't get current directory: %s.", strerror(errno));
@


1.138
log
@o Once a user is logged in, don't allow a change to another user.
o Run more code with the effective uid of the logged in user.
From Frank Denis
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.137 2002/10/13 21:09:13 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.137 2002/10/13 21:09:13 millert Exp $";
d1046 1
a1046 1
	if (setuid(pw->pw_uid) < 0) {
d1899 1
d1903 3
a1905 1
	if (vasprintf(&buf, fmt, ap) == -1 || buf == NULL) {
a1918 1
	va_end(ap);
@


1.137
log
@Avoid potential printf format string problem with challenge from
auth_challenge().  Currently, none of the auth modules put non-sanitized
data in the prompt so there are no real security implications with
this fix.  Patch from Moritz Jodeit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.136 2002/08/29 22:52:00 deraadt Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.136 2002/08/29 22:52:00 deraadt Exp $";
d698 1
a698 8
	if (logged_in) {
		if (guest) {
			reply(530, "Can't change user from guest login.");
			return;
		} else if (dochroot) {
			reply(530, "Can't change user from chroot user.");
			return;
		}
a699 1
	}
a856 1
	(void) seteuid((uid_t)0);
d862 2
a863 11
	pw = NULL;
	/* umask is restored in ftpcmd.y */
	if (setusercontext(NULL, getpwuid(0), (uid_t)0,
	    LOGIN_SETPRIORITY|LOGIN_SETRESOURCES) != 0) {
		perror_reply(451, "Local resource failure: setusercontext");
		syslog(LOG_NOTICE, "setusercontext: %m");
		exit(1);
	}
	logged_in = 0;
	guest = 0;
	dochroot = 0;
a936 4
	if (setegid((gid_t)pw->pw_gid) < 0) {
		reply(550, "Can't set gid.");
		return;
	}
d1046 1
a1046 1
	if (seteuid((uid_t)pw->pw_uid) < 0) {
a1280 1
	(void) seteuid((uid_t)0);
d1290 1
d1295 2
a1296 1
		if (errno != EADDRINUSE || tries > 10)
d1298 1
a1332 1
	(void) seteuid((uid_t)pw->pw_uid);
a2133 1
		(void) seteuid((uid_t)0);
a2236 1
	(void) seteuid((uid_t)pw->pw_uid);
d2362 1
a2362 3
	(void) seteuid((uid_t) 0);
	if (bind(pdata, (struct sockaddr *) &pasv_addr, pasv_addr.su_len) < 0) {
		(void) seteuid((uid_t) pw->pw_uid);
a2363 2
	}
	(void) seteuid((uid_t) pw->pw_uid);
@


1.136
log
@remove extra arg; jmegq@@post.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.135 2002/08/20 18:18:55 deraadt Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.135 2002/08/20 18:18:55 deraadt Exp $";
d815 1
a815 1
		reply(331, cp);
@


1.136.2.1
log
@Pull patch from current:
Fix by millert@@
Avoid potential printf format string problem with challenge from
auth_challenge(). Currently, none of the auth modules put non-sanitized
data in the prompt so there are no real security implications with
this fix. Patch from Moritz Jodeit.

deraadt@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.136 2002/08/29 22:52:00 deraadt Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.136 2002/08/29 22:52:00 deraadt Exp $";
d815 1
a815 1
		reply(331, "%s", cp);
@


1.135
log
@-n: disallow anon ftp even if ftp account exists
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.134 2002/07/24 23:17:07 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.134 2002/07/24 23:17:07 millert Exp $";
d1781 1
a1781 1
	lreply(211, "%s FTP server status:", hostname, version);
@


1.134
log
@Also check for snprintf() returning < 0
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.133 2002/07/24 23:10:01 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.133 2002/07/24 23:10:01 millert Exp $";
d153 1
d273 1
a273 1
char *argstr = "AdDhlMSt:T:u:UvP46";
d331 4
d724 2
a725 1
	if (strcmp(name, "ftp") == 0 || strcmp(name, "anonymous") == 0) {
@


1.133
log
@What on earth possessed me to use %p instead of %m in syslog() to
indicate the error string?
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.132 2002/07/20 17:55:45 millert Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.132 2002/07/20 17:55:45 millert Exp $";
d2791 1
a2791 1
		len = snprintf(buf, sizeof(buf),
d2794 1
a2794 1
		    vremotehost, (long long) size, vpath,
d2798 5
a2802 4
		    ((guest) ? "*" : pw->pw_name), dhostname);
		if (len >= sizeof(buf)) {
			len = sizeof(buf);
			buf[sizeof(buf) - 1] = '\n';
@


1.132
log
@Exit on setusercontext() failure; noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.131 2002/07/14 07:14:09 jakob Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.131 2002/07/14 07:14:09 jakob Exp $";
d870 1
a870 1
		syslog(LOG_NOTICE, "setusercontext: %p");
d961 1
a961 1
		syslog(LOG_NOTICE, "setusercontext: %p");
@


1.131
log
@make ftpd always listen to a high tcp port for passive data connections.
deprecate and ignore the -h option. ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.130 2002/07/02 18:09:54 danh Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.130 2002/07/02 18:09:54 danh Exp $";
d867 6
a872 2
	setusercontext(NULL, getpwuid(0), (uid_t)0,
	    LOGIN_SETPRIORITY|LOGIN_SETRESOURCES);
d959 6
a964 1
	setusercontext(lc, pw, (uid_t)0, flags);
@


1.130
log
@* use lostconn() as the SIGALRM handler in receive_data() as originally
  done by downsj@@ in revision 1.54.

* some -Wall cleanup
  - only declare check_host() if TCPWRAPPERS is defined.
  - use socklen_t where appropriate instead of int (pointer signedness
    warnings).
  - {u_}char * pointer signedness warnings.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.129 2002/06/17 19:33:37 danh Exp $	*/
d77 1
a77 1
    "$OpenBSD: ftpd.c,v 1.129 2002/06/17 19:33:37 danh Exp $";
a152 1
int	high_data_ports = 0;
d319 1
a319 2
		case 'h':
			high_data_ports = 1;
d2220 1
a2220 2
#ifdef IP_PORTRANGE
	on = high_data_ports ? IP_PORTRANGE_HIGH : IP_PORTRANGE_DEFAULT;
a2223 1
#endif
d2355 1
a2355 2
#ifdef IP_PORTRANGE
		on = high_data_ports ? IP_PORTRANGE_HIGH : IP_PORTRANGE_DEFAULT;
a2358 1
#endif
d2361 1
a2361 3
#ifdef IPV6_PORTRANGE
		on = high_data_ports ? IPV6_PORTRANGE_HIGH
				     : IPV6_PORTRANGE_DEFAULT;
a2364 1
#endif
@


1.129
log
@Initialize SIGALRM handler once in main(), instead of in several
different locations.

This fixes a problem where the SIGALRM handler was being set to an
uninitialized pointer in receive_data().  Originally reported to the
misc@@ list by Colin Harford.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.128 2002/06/09 00:37:37 itojun Exp $	*/
d67 1
a67 1
static char copyright[] =
d74 1
a74 1
static char sccsid[] = "@@(#)ftpd.c	8.4 (Berkeley) 4/16/94";
d76 2
a77 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.128 2002/06/09 00:37:37 itojun Exp $";
d244 1
a244 1
static int	guniquefd(char *, char **);
d253 1
d255 1
d289 2
a290 1
	int addrlen, ch, on = 1, tos;
d1357 1
a1357 1
	char *fa, *ha;
d1369 2
a1370 1
		int s, fromlen = sizeof(from);
d1631 1
d1639 5
d1657 1
d2197 2
a2198 1
	int len, on;
d2317 2
a2318 1
	int len, on;
d2401 1
a2401 1
			a = (char *) &pasv_addr.su_sin6.sin6_addr;
@


1.128
log
@do not present scopeid on wire format (as it is local to a node).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.127 2002/05/29 18:57:05 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.127 2002/05/29 18:57:05 deraadt Exp $";
d497 3
a1366 1
		signal (SIGALRM, toolong);
a1625 1
	struct sigaction sa;
a1632 4
		sigfillset(&sa.sa_mask);
		sa.sa_flags = SA_RESTART;
		sigaction(SIGALRM, &sa, NULL);

@


1.127
log
@a few more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.126 2002/05/26 09:32:07 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.126 2002/05/26 09:32:07 deraadt Exp $";
d1862 5
a1866 1
			if (getnameinfo((struct sockaddr *)su, su->su_len,
d1868 1
a1868 1
			    NI_NUMERICHOST) == 0) {
@


1.126
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.125 2002/03/30 22:01:51 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.125 2002/03/30 22:01:51 deraadt Exp $";
d265 1
a265 1
		strcat(path, "/");
@


1.125
log
@correct an auth_close() misuse; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.124 2002/03/16 19:15:12 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.124 2002/03/16 19:15:12 millert Exp $";
d477 1
a477 1
	(void)snprintf(ttyline, sizeof(ttyline), "ftp%d", getpid());
@


1.124
log
@o Don't allow password-less accounts to login (like in 2.9 and below)
o Stash copy of struct passwd via auth_setpwd() to avoid extra needless
  getpwnam() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.123 2002/03/12 02:22:33 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.123 2002/03/12 02:22:33 millert Exp $";
d891 1
a891 1
			if (as != NULL)
d893 2
@


1.123
log
@bsd_auth.h requires other headers so it can't be first
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.122 2002/03/12 02:15:39 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.122 2002/03/12 02:15:39 millert Exp $";
d100 1
a121 1
#include <bsd_auth.h>
d723 1
d766 1
d885 1
a885 1
		if (pw == NULL) {
d891 2
@


1.122
log
@Fix a couple mis-sorted headers and sync usage() with man page.
From Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.121 2002/02/19 19:39:38 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.121 2002/02/19 19:39:38 millert Exp $";
a99 1
#include <bsd_auth.h>
d121 1
@


1.121
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.120 2002/02/16 21:27:29 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.120 2002/02/16 21:27:29 millert Exp $";
d100 1
d112 1
a121 2
#include <bsd_auth.h>
#include <stdarg.h>
d276 1
a276 1
	    "usage: ftpd [-AdDhlMSUv] [-t timeout] [-T maxtimeout] [-u mask]");
d304 1
a362 4
			break;

		case 'v':
			debug = 1;
@


1.120
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.119 2002/02/01 05:02:49 itojun Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.119 2002/02/01 05:02:49 itojun Exp $";
d121 1
a129 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a1887 1
#ifdef __STDC__
a1888 6
#else
reply(n, fmt, va_alist)
	int n;
	char *fmt;
	va_dcl
#endif
d1892 1
a1892 1
#ifdef __STDC__
a1893 3
#else
	va_start(ap);
#endif
a1911 1
#ifdef __STDC__
a1912 6
#else
lreply(n, fmt, va_alist)
	int n;
	char *fmt;
	va_dcl
#endif
d1915 1
a1915 1
#ifdef __STDC__
a1916 3
#else
	va_start(ap);
#endif
a1922 1
#ifdef __STDC__
a1923 3
#else
		va_start(ap);
#endif
@


1.119
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.118 2002/02/01 04:53:28 itojun Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.118 2002/02/01 04:53:28 itojun Exp $";
d238 16
a253 16
static void	 ack __P((char *));
static void	 sigurg __P((int));
static void	 myoob __P((void));
static int	 checkuser __P((char *, char *));
static FILE	*dataconn __P((char *, off_t, char *));
static void	 dolog __P((struct sockaddr *));
static char	*copy_dir __P((char *, struct passwd *));
static char	*curdir __P((void));
static void	 end_login __P((void));
static FILE	*getdatasock __P((char *));
static int	guniquefd __P((char *, char **));
static void	 lostconn __P((int));
static void	 sigquit __P((int));
static int	 receive_data __P((FILE *, FILE *));
static void	 replydirname __P((const char *, const char *));
static int	 send_data __P((FILE *, FILE *, off_t, off_t, int));
d255 4
a258 4
		 sgetpwnam __P((char *));
static void	 reapchild __P((int));
static int	 check_host __P((struct sockaddr *));
static void	 usage __P((void));
d260 1
a260 1
void	 logxfer __P((char *, off_t, time_t));
d1128 1
a1128 1
	int (*closefunc) __P((FILE *));
d1202 1
a1202 1
	int (*closefunc) __P((FILE *));
@


1.118
log
@make sure pw_dir is big enough for strcpy(pw->pw_dir, "/").
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.117 2002/01/23 20:59:05 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.117 2002/01/23 20:59:05 millert Exp $";
d608 1
a608 1
		strcpy(hostname, hp->h_name);
d1015 1
a1015 1
			strcpy(rootdir, pw->pw_dir);
d2899 2
a2900 2
		strcpy(newdir, pw->pw_dir);
		strcat(newdir, cp);
@


1.117
log
@Plug login_cap and bsd_auth related memory leaks.  Problem noticed
by mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.116 2002/01/23 17:03:21 mpech Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.116 2002/01/23 17:03:21 mpech Exp $";
d984 15
@


1.116
log
@fix potential memory leak.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.115 2002/01/23 16:31:18 mpech Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.115 2002/01/23 16:31:18 mpech Exp $";
d660 1
a660 1
		return (pw);
d693 1
a693 1
	char *cp, *shell, *style;
d704 9
a714 5
		if (as) {
			auth_close(as);
			as = NULL;
		}
		end_login();
d721 1
d730 11
d777 2
a778 1
	    auth_setoption(as, "notickets", "yes") < 0)) {
d918 2
d921 1
a921 1
		if (guestpw == (char *)NULL)
a923 4
		if ((as = auth_open()) == NULL)
			fatal("Out of memory.");
		auth_setoption(as, "FTPD_HOST",
		    multihome ? dhostname : hostname);
@


1.115
log
@Use always '.' in the end of the fatal() message. Consistency is good.

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.114 2002/01/23 16:27:35 mpech Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.114 2002/01/23 16:27:35 mpech Exp $";
d2865 2
a2866 1
		if ((newdir = malloc(dirsiz)) == NULL)
d2868 1
@


1.114
log
@don't use \n in reply().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.113 2002/01/07 03:56:02 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.113 2002/01/07 03:56:02 millert Exp $";
d903 1
a903 1
			fatal("Out of memory");
d906 1
a906 1
			fatal("Out of memory");
@


1.113
log
@To disable a SIGCHLD signal handler use SIG_DFL, *not* SIG_IGN
which now has a different meaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.112 2001/12/18 00:27:57 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.112 2001/12/18 00:27:57 millert Exp $";
d916 1
a916 1
			reply(530, "Approval failure.\n");
d923 1
a923 1
		reply(530, "Permission denied.\n");
d1856 1
a1856 1
	reply(451, "Error in server: %s\n", s);
@


1.112
log
@Don't use sigprocmask() in signal handlers when we can just set the
mask to be what we want with sigaction.  Pointed out by Yar Tikhiy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.111 2001/12/17 23:02:53 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.111 2001/12/17 23:02:53 millert Exp $";
d487 1
a487 1
	sa.sa_handler = SIG_IGN;
@


1.111
log
@Add missing sigaction() call from last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.110 2001/12/07 18:45:32 mpech Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.110 2001/12/07 18:45:32 mpech Exp $";
d487 9
a504 7
	sa.sa_handler = SIG_IGN;
	(void) sigaction(SIGCHLD, &sa, NULL);

	sa.sa_handler = sigurg;
	sa.sa_flags = 0;		/* don't restart syscalls for SIGURG */
	(void) sigaction(SIGURG, &sa, NULL);

a631 1
	sigprocmask(SIG_BLOCK, &allsigs, NULL);
a642 1
	sigprocmask(SIG_BLOCK, &allsigs, NULL);
d1595 2
a1597 1
	char buf[BUFSIZ];
d1604 3
a1606 1
		signal (SIGALRM, lostconn);
@


1.110
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.109 2001/12/04 21:18:04 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.109 2001/12/04 21:18:04 millert Exp $";
d501 1
@


1.109
log
@Kill setjmp/longjmp
 o fix error recovery in the parser so there is no longer a need for jmping
 o make SIGURG handler interupt syscalls and just set a flag that we test
   for later.

Use waitpid() not wait3() for portability.  Restart waitpid() loop
if another signal interrupts us.

Calling dologout() from signal handlers is safe because it doesn't
use stdio, nor do the two functions it calls (logout and ftpdlogwtmp).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.108 2001/12/01 23:27:20 miod Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.108 2001/12/01 23:27:20 miod Exp $";
d2296 1
a2296 1
	register u_char *p, *a;
@


1.108
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.107 2001/11/17 19:54:56 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.107 2001/11/17 19:54:56 deraadt Exp $";
a109 1
#include <setjmp.h>
a150 1
jmp_buf	errcatch, urgcatch;
d192 1
d239 2
a240 1
static void	 myoob __P((int));
d253 1
a253 1
static void	 send_data __P((FILE *, FILE *, off_t, off_t, int));
d295 1
d299 2
d406 2
a407 1
		(void) signal(SIGCHLD, reapchild);
d487 14
a500 8
	(void) signal(SIGHUP, sigquit);
	(void) signal(SIGINT, sigquit);
	(void) signal(SIGQUIT, sigquit);
	(void) signal(SIGTERM, sigquit);
	(void) signal(SIGPIPE, lostconn);
	(void) signal(SIGCHLD, SIG_IGN);
	if (signal(SIGURG, myoob) == SIG_ERR)
		syslog(LOG_ERR, "signal: %m");
d504 1
a504 1
		syslog(LOG_ERR, "getsockname (%s): %m", argv[0]);
a613 1
	(void) setjmp(errcatch);
d632 1
a632 1
	dologout(1);	/* XXX signal race? */
d643 1
a643 1
	dologout(1);	/* XXX signal race? */
d1467 1
a1467 1
static void
a1478 4
	if (setjmp(urgcatch)) {
		transflag = 0;
		return;
	}
d1483 2
d1500 1
a1500 1
		return;
d1523 4
d1537 1
a1537 1
			return;
d1544 1
a1544 1
			return;
d1558 1
a1558 1
		return;
d1562 1
a1562 1
		return;
d1568 1
a1568 1
	return;
d1573 7
a1597 4
	if (setjmp(urgcatch)) {
		transflag = 0;
		return (-1);
	}
d1608 2
d1629 2
d1674 6
d2108 3
a2110 2
 * Record logout in wtmp file
 * and exit with supplied status.
d2131 1
a2131 1
myoob(signo)
d2134 7
a2141 3
	int save_errno = errno;

	/* XXX signal races GALORE */
a2155 1
		longjmp(urgcatch, 1);
a2164 1
	errno = save_errno;
a2621 4
	if (setjmp(urgcatch)) {
		transflag = 0;
		goto out;
	}
d2663 7
d2732 1
d2734 3
a2736 2
	while (wait3(NULL, WNOHANG, NULL) > 0)
		;
@


1.107
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.106 2001/11/05 09:51:13 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.106 2001/11/05 09:51:13 deraadt Exp $";
d446 2
a447 7
		if ((fp = fopen(_PATH_FTPDPID, "w")) == NULL)
			syslog(LOG_ERR, "can't open %s: %m", _PATH_FTPDPID);
		else {
			fprintf(fp, "%d\n", getpid());
			fchmod(fileno(fp), S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
			fclose(fp);
		}
@


1.106
log
@more signal marks, and some syslog_r in handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.105 2001/10/02 17:43:47 wilfried Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.105 2001/10/02 17:43:47 wilfried Exp $";
d175 1
a175 1
sig_atomic_t transflag;
@


1.105
log
@as is aleady closed and freed by auth_userresponse, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.104 2001/09/05 22:32:36 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.104 2001/09/05 22:32:36 deraadt Exp $";
d623 1
d627 2
a628 2
		syslog(LOG_DEBUG, "lost connection");
	dologout(1);
d635 1
d638 2
a639 2
	syslog(LOG_ERR, "got signal %s", sys_signame[signo]);
	dologout(1);
d2116 2
@


1.104
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.103 2001/07/08 21:18:07 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.103 2001/07/08 21:18:07 deraadt Exp $";
a874 1
			auth_close(as);
@


1.103
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.102 2001/07/03 21:17:56 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.102 2001/07/03 21:17:56 millert Exp $";
d1869 1
@


1.102
log
@Use the 'welcome' variable from login.conf instead of hard-coding
/etc/motd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.101 2001/06/25 16:39:54 hin Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.101 2001/06/25 16:39:54 hin Exp $";
d1579 2
a1580 1
	int cnt, bare_lfs = 0;
a1793 1
epsvonly:
d2570 2
a2571 1
	char **dirlist, *dirname;
d2573 1
a2573 1
	int freeglob = 0;
@


1.101
log
@millert didn't compile this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.100 2001/06/25 16:24:27 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.100 2001/06/25 16:24:27 millert Exp $";
d858 1
a858 1
	char *dir, rootdir[MAXPATHLEN];
d962 1
d966 1
d1034 2
a1035 1
	if ((fp = fopen(_PATH_FTPLOGINMESG, "r")) != NULL) {
d1046 2
@


1.100
log
@Set "login" and "notickets" BSD auth options.  We don't need to get
a kerb ticket but we do need AFS tokens.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.99 2001/06/13 20:13:29 markus Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.99 2001/06/13 20:13:29 markus Exp $";
d753 2
a754 2
	    auth_setitem(as, "login", "yes") < 0)) {
	    auth_setitem(as, "notickets", "yes") < 0)) {
@


1.99
log
@more va_start/end fixes, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.98 2001/06/11 15:18:49 mickey Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.98 2001/06/11 15:18:49 mickey Exp $";
d752 3
a754 1
	    auth_setitem(as, AUTHV_CLASS, class)) < 0) {
@


1.98
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.97 2001/05/29 21:35:16 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.97 2001/05/29 21:35:16 millert Exp $";
d1882 1
d1886 5
d1893 1
@


1.97
log
@use BSD authentication
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.96 2001/05/11 15:34:02 art Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: ftpd.c,v 1.94 2001/03/09 19:09:12 millert Exp $";
d2513 1
a2513 2
	(void) strlcpy(new, local, sizeof(new));
	len = strlen(new);
d2705 1
d2710 1
a2710 1
		vpw = (char *)malloc(strlen((guest) ? guestpw : pw->pw_name)*4+1);
d2720 1
a2720 1
		strvis(vpw, (guest) ? guestpw : pw->pw_name, VIS_SAFE|VIS_NOSLASH);
d2722 1
a2722 1
		snprintf(buf, sizeof(buf),
d2730 5
a2734 1
		write(statfd, buf, strlen(buf));
@


1.96
log
@mmap returns MAP_FAILED on error, not 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.95 2001/03/18 17:20:13 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$NetBSD: ftpd.c,v 1.15 1995/06/03 22:46:47 mycroft Exp $";
d121 1
a126 4
#if defined(SKEY)
#include <skey.h>
#endif

d192 2
a193 1
static  login_cap_t *lc;
a199 5
#if defined(KERBEROS)
int	notickets = 1;
char	*krbtkfile_env = NULL;
#endif

a255 1
static char	*sgetsave __P((char *));
d634 1
a634 1
	
a640 18
 * Helper function for sgetpwnam().
 */
static char *
sgetsave(s)
	char *s;
{
	char *new = malloc((unsigned) strlen(s) + 1);

	if (new == NULL) {
		perror_reply(421, "Local resource failure: malloc");
		dologout(1);
		/* NOTREACHED */
	}
	(void) strcpy(new, s);
	return (new);
}

/*
d649 2
a650 2
	static struct passwd save;
	struct passwd *p;
d652 13
a664 19
	if ((p = getpwnam(name)) == NULL)
		return (p);
	if (save.pw_name) {
		free(save.pw_name);
		memset(save.pw_passwd, 0, strlen(save.pw_passwd));
		free(save.pw_passwd);
		free(save.pw_class);
		free(save.pw_gecos);
		free(save.pw_dir);
		free(save.pw_shell);
	}
	save = *p;
	save.pw_name = sgetsave(p->pw_name);
	save.pw_passwd = sgetsave(p->pw_passwd);
	save.pw_class = sgetsave(p->pw_class);
	save.pw_gecos = sgetsave(p->pw_gecos);
	save.pw_dir = sgetsave(p->pw_dir);
	save.pw_shell = sgetsave(p->pw_shell);
	return (&save);
d686 2
a687 6
	char *cp, *shell;

	if (lc) {
		login_close(lc);
		lc = NULL;
	}
d697 6
d706 3
d719 1
a719 1
			    "Guest login ok, type your name as password.");
a726 4
	if (anon_only && !checkuser(_PATH_FTPCHROOT, name)) {
		reply(530, "Sorry, only anonymous ftp allowed.");
		return;
	}
d728 1
d730 3
a732 2
		if ((shell = pw->pw_shell) == NULL || *shell == 0)
			shell = _PATH_BSHELL;
d736 1
d738 9
d748 25
a772 1
		if (cp == NULL || checkuser(_PATH_FTPUSERS, name)) {
d778 1
a778 1
			pw = (struct passwd *) NULL;
a780 1
		lc = login_getclass(pw->pw_class);
d782 4
a785 11
	if (logging)
		strlcpy(curname, name, sizeof(curname));
#ifdef SKEY
	if (!skey_haskey(name)) {
		char *myskey, *skey_keyinfo __P((char *name));

		myskey = skey_keyinfo(name);
		reply(331, "Password [ %s ] for %s required.",
		    myskey ? myskey : "error getting challenge", name);
	} else
#endif
d853 1
a853 1
	int rval, flags;
d864 1
d871 4
a874 2
			rval = 1;	/* failure below */
			goto skip;
d876 1
a876 27
#if defined(KERBEROS)
		rval = klogin(pw, "", hostname, passwd);
		if (rval == 0)
			goto skip;
#endif
#ifdef SKEY
		if (skey_haskey(pw->pw_name) == 0 &&
		   (skey_passcheck(pw->pw_name, passwd) != -1)) {
			rval = 0;
			goto skip;
		}
#endif
		/* the strcmp does not catch null passwords! */
		if (strcmp(crypt(passwd, pw->pw_passwd), pw->pw_passwd) ||
		    *pw->pw_passwd == '\0') {
			rval = 1;	 /* failure */
			goto skip;
		}
		rval = 0;

skip:
		/*
		 * If rval == 1, the user failed the authentication check
		 * above.  If rval == 0, either Kerberos or local authentication
		 * succeeded.
		 */
		if (rval) {
d891 1
a891 1
	} else {
d896 21
a950 2
	dochroot = login_getcapbool(lc, "ftp-chroot", 0) ||
	    checkuser(_PATH_FTPCHROOT, pw->pw_name);
d1279 1
a1279 1
	if (setsockopt(s, IPPROTO_TCP, TCP_NOPUSH, (char *)&on, sizeof on) < 0)
d1284 1
a1284 1
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *)&on, sizeof on) < 0)
d1841 1
d1848 12
a1859 3
	(void)printf("%d ", n);
	(void)vprintf(fmt, ap);
	(void)printf("\r\n");
d1861 1
a1861 4
	if (debug) {
		syslog(LOG_DEBUG, "<--- %d ", n);
		vsyslog(LOG_DEBUG, fmt, ap);
	}
d2022 1
a2022 1
	if (getcwd(path, sizeof path) == (char *)NULL)
a2088 4
#if defined(KERBEROS)
		if (!notickets && krbtkfile_env)
			unlink(krbtkfile_env);
#endif
d2714 1
a2714 1
		snprintf(path, sizeof path, "%s/%s", dir, name);
d2716 1
a2716 1
			strlcpy(rpath, path, sizeof rpath);
@


1.95
log
@use GLOB_LIMIT
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.94 2001/03/09 19:09:12 millert Exp $	*/
d1511 1
a1511 1
			if (!buf) {
@


1.94
log
@Block all signals in lostconn() and sigprocmask() since we are headed
for _exit().  Fixes a signal handler race condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.93 2001/03/09 18:38:25 deraadt Exp $	*/
a2566 2
		int flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;

d2569 3
a2571 1
		if (glob(whichf, flags, 0, &gl)) {
@


1.93
log
@do not strerror() a signo
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.92 2001/02/04 20:33:23 pjanzen Exp $	*/
d151 2
d304 2
a305 1
	tzset();	/* in case no timezone database in ~ftp */
d631 2
a632 1
	/* XXX signal races */
d642 2
a643 1
	/* XXX signal races */
d835 1
a835 2
	sigset_t allsigs;
	sigfillset (&allsigs);
a859 1
	sigset_t allsigs;
a1020 1
	sigfillset(&allsigs);
a1244 1
	sigset_t allsigs;
a1247 1
	sigfillset(&allsigs);
a1267 1
	sigfillset(&allsigs);
a1299 1
	sigfillset (&allsigs);
a2079 1
	sigset_t allsigs;
a2083 1
		sigfillset(&allsigs);
@


1.92
log
@Whoops, don't use strlcpy with utmp; millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.91 2001/02/03 21:48:47 pjanzen Exp $	*/
a637 1
	
d639 1
a639 1
	syslog(LOG_ERR, "got signal %s", strerror(signo));
@


1.91
log
@Long usernames; also some simple strncpy->strlcpy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.90 2001/01/19 18:02:25 deraadt Exp $	*/
d941 3
a943 3
		(void)strlcpy(utmp.ut_name, pw->pw_name, sizeof(utmp.ut_name));
		(void)strlcpy(utmp.ut_host, remotehost, sizeof(utmp.ut_host));
		(void)strlcpy(utmp.ut_line, ttyline, sizeof(utmp.ut_line));
@


1.90
log
@mark remaining signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.89 2001/01/09 06:07:03 itojun Exp $	*/
d697 1
a697 1
static char curname[16];	/* current USER name */
d774 2
a775 4
	if (logging) {
		strncpy(curname, name, sizeof(curname)-1);
		curname[sizeof(curname)-1] = '\0';
	}
d941 3
a943 3
		(void)strncpy(utmp.ut_name, pw->pw_name, sizeof(utmp.ut_name));
		(void)strncpy(utmp.ut_host, remotehost, sizeof(utmp.ut_host));
		(void)strncpy(utmp.ut_line, ttyline, sizeof(utmp.ut_line));
d2064 1
a2064 1
	(void) strncpy(remotehost, hbuf, sizeof(remotehost)-1);
a2065 1
	remotehost[sizeof(remotehost)-1] = '\0';
d2522 1
a2522 2
	(void) strncpy(new, local, sizeof(new)-1);
	new[sizeof(new)-1] = '\0';
d2724 2
a2725 4
		if (realpath(path, rpath) == NULL) {
			strncpy(rpath, path, sizeof rpath-1);
			rpath[sizeof rpath-1] = '\0';
		}
@


1.89
log
@make sure replydirname() do not truncate names, even if the filename
is MAXPATHLEN doublequotes.
From: Paul Janzen <pjanzen@@foatdi.harvard.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.88 2001/01/09 05:07:01 itojun Exp $	*/
d628 1
a628 1

d638 2
a640 1

@


1.88
log
@make sure we do not return stray " at the end of stirng, like bla"\0.
From: "William C. Allen" <allenwc@@home.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.87 2001/01/07 07:38:34 angelos Exp $	*/
d1977 1
a1977 1
	char npath[MAXPATHLEN];
@


1.87
log
@Make the -P option effective (rjmooney@@mediaone.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.86 2001/01/06 18:24:29 millert Exp $	*/
d1982 3
a1984 1
		if (*name == '"' && ep - p >= 2) {
d1987 3
a1989 1
		} else if (ep - p >= 1)
d1991 1
a1991 2
		else
			break;
@


1.86
log
@Expand tilde (~) in ftp-dir login.conf variable.  Closes PR 1382
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.85 2000/12/30 06:08:58 angelos Exp $	*/
d1372 1
a1372 1
		if (memcmp(fa, ha, alen) != 0) {
d1437 1
a1437 1
	if (memcmp(fa, ha, alen) != 0) {
@


1.85
log
@Log the actual bytes transfered, rather than the original file size.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.84 2000/12/04 10:49:31 itojun Exp $	*/
d249 1
d958 8
d967 1
a967 1
		pw->pw_dir = sgetsave(dir);
d2777 55
@


1.84
log
@in replydirname(), avoid one-byte overrun.
From: Kristian Vlaardingerbroek <kris@@obit.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.83 2000/12/02 18:01:11 millert Exp $	*/
d1139 1
a1139 1
		logxfer(name, st.st_size, start);
@


1.83
log
@The man page says the default umask is 027 but it is really 022 since
that is the value of CMASK.

Have setusercontext() set the umask unless the -u flag was specified.
This allows the admin to set the umask either via -u or via a login
class in login.conf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.82 2000/11/26 19:52:56 millert Exp $	*/
d1967 1
a1968 1
	int i;
d1970 10
a1979 4
	for (i = 0; *name != '\0' && i < sizeof(npath) - 1; i++, name++) {
		npath[i] = *name;
		if (*name == '"')
			npath[++i] = '"';
d1981 1
a1981 1
	npath[i] = '\0';
@


1.82
log
@setusercontext should not set umask as this interferes with the
umask specified for ftpd on the command line.  Closed PR #1530
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.81 2000/11/23 16:50:51 itojun Exp $	*/
d181 1
a181 1
#define CMASK 027
d841 1
d853 1
a853 1
	int rval;
d926 7
a932 3
	(void) umask(defumask);
	setusercontext(lc, pw, (uid_t)0,
	    LOGIN_SETGROUP|LOGIN_SETPRIORITY|LOGIN_SETRESOURCES);
@


1.81
log
@typo in LPSV printing.  From: Hiroyuki YAMAMORI <h-yamamo@@db3.so-net.ne.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.80 2000/11/14 20:27:01 itojun Exp $	*/
d842 1
a842 1
	    LOGIN_SETPRIORITY|LOGIN_SETRESOURCES|LOGIN_SETUMASK);
d925 1
a925 1
	(void) umask(defumask);		/* may be overridden by login.conf */
d927 1
a927 1
	    LOGIN_SETGROUP|LOGIN_SETPRIORITY|LOGIN_SETRESOURCES|LOGIN_SETUMASK);
@


1.80
log
@cleanup EPSV/EPRT error handling.  avoid possible memory leak (getaddrinfo).
correct error code on unsupported protocol parameter against EPRT (522).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.79 2000/09/15 07:13:45 deraadt Exp $	*/
d2332 1
a2332 1
				a[11], a[12], a[13], a[14], a[15], 2,
@


1.79
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.78 2000/08/20 18:42:37 millert Exp $	*/
d2182 55
d2252 9
a2260 22
	if (pf != PF_UNSPEC) {
		if (ctrl_addr.su_family != pf) {
			switch (ctrl_addr.su_family) {
			case AF_INET:
				pf = 1;
				break;
			case AF_INET6:
				pf = 2;
				break;
			default:
				pf = 0;
				break;
			}
			/*
			 * XXX
			 * only EPRT/EPSV ready clients will understand this
			 */
			if (strcmp(cmd, "EPSV") == 0 && pf) {
				reply(522, "Network protocol mismatch, "
				    "use (%d)", pf);
			} else
				reply(501, "Network protocol mismatch"); /*XXX*/
d2262 1
a2262 2
			return;
		}
d2353 122
@


1.79.2.1
log
@Pull in patch from current:
Errata 005_ftpd:
OpenBSD 2.8's ftpd contains a one-byte overflow in the replydirname() function.
Fix (itojun):
in replydirname(), avoid one-byte overrun.
From: Kristian Vlaardingerbroek <kris@@obit.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.79 2000/09/15 07:13:45 deraadt Exp $	*/
a1961 1
	char *p, *ep;
d1963 1
d1965 4
a1968 10
	p = npath;
	ep = &npath[sizeof(npath) - 1];
	while (*name) {
		if (*name == '"' && ep - p >= 2) {
			*p++ = *name++;
			*p++ = '"';
		} else if (ep - p >= 1)
			*p++ = *name++;
		else
			break;
d1970 1
a1970 1
	*p = '\0';
@


1.79.2.2
log
@Pull in patch from current:
Fix (deraadt):
Use the GLOB_LIMIT support in glob(3) to constrain a remote denial of
service against ftpd(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.79.2.1 2000/12/10 02:48:22 jason Exp $	*/
d2395 2
d2399 1
a2399 3
		if (glob(whichf,
		    GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE|GLOB_LIMIT,
		    0, &gl)) {
@


1.78
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.77 2000/07/05 22:15:10 deraadt Exp $	*/
d980 4
a983 1
		setenv("HOME", "/", 1);
d990 4
a993 1
		setenv("HOME", "/", 1);
d1012 6
a1017 2
	if (getcwd(homedir, MAXPATHLEN) != NULL)
		setenv("HOME", homedir, 1);
@


1.77
log
@crank version to 6.5
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.76 2000/07/05 21:56:48 deraadt Exp $	*/
d107 1
d193 1
d678 1
d686 1
d714 5
d738 1
d770 1
d841 2
d855 1
a855 1
	char rootdir[MAXPATHLEN];
d925 3
a927 1
	(void) initgroups(pw->pw_name, pw->pw_gid);
d949 6
a954 1
	dochroot = checkuser(_PATH_FTPCHROOT, pw->pw_name);
d1001 1
a1001 1
	sigprocmask(SIG_UNBLOCK,&allsigs,NULL);
d1028 1
a1028 1
		if (ident == (char *)NULL)
d1052 2
a1053 1
	(void) umask(defumask);
d1057 2
@


1.76
log
@another setproctitle
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.75 2000/07/05 17:21:02 deraadt Exp $	*/
d138 1
a138 1
static char version[] = "Version 6.4/OpenBSD";
@


1.75
log
@always setproctitle with %s if using a variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.74 2000/06/17 19:42:18 deraadt Exp $	*/
d2014 1
a2014 1
	setproctitle(proctitle);
@


1.74
log
@pr 772; -u blocks chmod command, michaels@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.73 2000/06/14 15:15:06 itojun Exp $	*/
d1016 1
a1016 1
		setproctitle(proctitle);
d1026 1
a1026 1
		setproctitle(proctitle);
@


1.73
log
@correct STAT command output for LPSV output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.72 2000/06/12 12:02:55 itojun Exp $	*/
d183 1
d351 1
@


1.72
log
@address PR 1274 (-h does not work on EPSV).
the committed code handles IPv6 case too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.71 2000/04/29 14:02:59 deraadt Exp $	*/
d1693 1
a1693 1
		printf("     in Passive mode");
d1742 2
a1743 2
				printf("%u,", a[alen]);
			printf("%u,%u,%u)\r\n", 2, p[0], p[1]);
d1769 1
a1769 1
					printf("211 - EPSV ");
d1771 1
a1771 1
					printf("211 - EPRT ");
@


1.71
log
@strerror
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.70 2000/04/11 11:42:11 deraadt Exp $	*/
d2153 1
a2153 1
	int len;
d2205 21
@


1.71.2.1
log
@Pull in patch from current:
Fix (deraadt):
always setproctitle with %s if using a variable

another setproctitle

crank version to 6.5
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.77 2000/07/05 22:15:10 deraadt Exp $	*/
d138 1
a138 1
static char version[] = "Version 6.5/OpenBSD";
d1014 1
a1014 1
		setproctitle("%s", proctitle);
d1024 1
a1024 1
		setproctitle("%s", proctitle);
d2012 1
a2012 1
	setproctitle("%s", proctitle);
@


1.71.2.2
log
@Pull in patch from current:
Errata (037):
OpenBSD 2.7's ftpd contains a one-byte overflow in the replydirname() function.
Fix:
in replydirname(), avoid one-byte overrun.
From: Kristian Vlaardingerbroek <kris@@obit.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.71.2.1 2000/07/05 22:20:08 jason Exp $	*/
a1926 1
	char *p, *ep;
d1928 1
d1930 4
a1933 10
	p = npath;
	ep = &npath[sizeof(npath) - 1];
	while (*name) {
		if (*name == '"' && ep - p >= 2) {
			*p++ = *name++;
			*p++ = '"';
		} else if (ep - p >= 1)
			*p++ = *name++;
		else
			break;
d1935 1
a1935 1
	*p = '\0';
@


1.70
log
@do not lose descriptors; Takahiro Kambe
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.69 2000/03/03 15:51:45 bitblt Exp $	*/
d633 1
a633 1
	syslog(LOG_ERR, "got signal %s", strsignal(signo));
@


1.69
log
@Turns out that our implementation of STAT wasn't RFC 959 compliant.
This version is now RFC 959 compliant, using a patch adapted from one
sent in by david.leonard@@eecs.uq.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.68 2000/01/18 18:26:38 millert Exp $	*/
d1102 3
a1105 1
done:
d2441 4
@


1.68
log
@Fix a pasto in the last commit.  The genesis of this bug is actually
somewhat interesting.  The getwd() function has historically placed
an error message in the buffer on failure, but getcwd() does not.
Therefor, a bulk search and replace of getwd() with getcwd() can
create bugs like this one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.67 2000/01/18 05:02:05 millert Exp $	*/
d1620 1
d1626 1
d1642 2
d1645 1
@


1.67
log
@"pwd" should print an error, not garbage, if getcwd() fails; form@@vell.nsc.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.66 2000/01/14 20:58:21 ericj Exp $	*/
d1962 1
a1962 1
		reply(550, "Can't get current directory: %s.", path);
@


1.66
log
@call dologout() with 1. not -1
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.65 1999/12/10 10:41:44 deraadt Exp $	*/
d1962 1
a1962 1
		reply(550, "%s.", path);
@


1.65
log
@using u_char * is a lot more convenient than doing & 0xff 80+ times
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.64 1999/12/09 09:03:08 itojun Exp $	*/
d626 1
a626 1
	dologout(-1);
d635 1
a635 1
	dologout(-1);
@


1.64
log
@close passive mode data socket.
From: deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.63 1999/12/08 13:15:21 itojun Exp $	*/
d423 1
a423 1
			syslog(LOG_ERR, "control setsockopt: %m");;
d517 2
a518 2
			&tmp_addr.su_sin6.sin6_addr.s6_addr[off],
			sizeof(his_addr.su_sin.sin_addr));
d526 2
a527 2
			&tmp_addr.su_sin6.sin6_addr.s6_addr[off],
			sizeof(ctrl_addr.su_sin.sin_addr));
d546 1
a546 1
			       sizeof(int)) < 0)
d604 1
a604 1
			dhostname, sizeof(dhostname), NULL, 0, 0);
d608 1
a608 1
	      (multihome ? dhostname : hostname), version);
d1226 1
a1226 1
			       sizeof(int)) < 0)
d1298 1
a1298 1
			alen = sizeof(struct in_addr);;
d1304 1
a1304 1
			alen = sizeof(struct in6_addr);;
d1313 2
a1314 2
		if (from.su_family != his_addr.su_family
		 || ntohs(*p) < IPPORT_RESERVED) {
d1331 1
a1331 1
		     type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
d1346 1
d1348 2
a1349 2
			hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
d1365 1
a1365 1
		alen = sizeof(struct in_addr);;
d1371 1
a1371 1
		alen = sizeof(struct in6_addr);;
d1379 2
a1380 2
	if (data_dest.su_family != his_addr.su_family
	 || ntohs(*p) < IPPORT_RESERVED || ntohs(*p) == 2049) {	/* XXX */
d1405 1
a1405 1
	     type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
d1466 1
a1466 1
				       (unsigned long)filesize);
d1592 1
a1592 1
		"WARNING! %d bare linefeeds received in ASCII mode",
d1594 1
a1594 1
		(void)printf("   File may not have transferred correctly.\r\n");
d1657 1
a1657 1
		hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d1701 3
a1703 4
#define UC(b) (((int) b) & 0xff)
			printf("(%d,%d,%d,%d,%d,%d)\r\n",
				UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				UC(p[0]), UC(p[1]));
d1733 1
a1733 1
			printf("(%d,%d", af, alen);
d1735 2
a1736 3
				printf("%d,", UC(a[alen]));
			printf("%d,%d,%d)\r\n", 2, UC(p[0]), UC(p[1]));
#undef UC
d1741 1
a1741 1
epsvonly:;
d1743 1
a1743 1
		int af;
d1759 2
a1760 2
					hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
					NI_NUMERICHOST) == 0) {
d1765 1
a1765 1
				printf("(|%d|%s|%s|)\r\n",
d2083 1
a2083 1
	char *p, *a;
d2091 9
d2109 1
a2109 1
		       (char *)&on, sizeof(on)) < 0)
d2124 2
a2125 4
	a = (char *) &pasv_addr.su_sin.sin_addr;
	p = (char *) &pasv_addr.su_sin.sin_port;

#define UC(b) (((int) b) & 0xff)
d2127 2
a2128 2
	reply(227, "Entering Passive Mode (%d,%d,%d,%d,%d,%d)", UC(a[0]),
		UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
d2147 1
a2147 1
	register char *p, *a;
d2174 1
a2174 1
					    "use (%d)", pf);
d2184 9
d2211 1
a2211 3
	p = (char *) &pasv_addr.su_port;

#define UC(b) (((int) b) & 0xff)
d2216 4
a2219 4
			a = (char *) &pasv_addr.su_sin.sin_addr;
			reply(228, "Entering Long Passive Mode (%d,%d,%d,%d,%d,%d,%d,%d,%d)",
				4, 4, UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				2, UC(p[0]), UC(p[1]));
d2223 7
a2229 7
			reply(228, "Entering Long Passive Mode (%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)",
				6, 16,
				UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				UC(a[4]), UC(a[5]), UC(a[6]), UC(a[7]),
				UC(a[8]), UC(a[9]), UC(a[10]), UC(a[11]),
				UC(a[12]), UC(a[13]), UC(a[14]), UC(a[15]),
				2, UC(p[0]), UC(p[1]));
a2231 1
#undef UC
d2236 2
a2237 2
			reply(229, "Entering Extended Passive Mode (|||%d|)",
			ntohs(pasv_addr.su_port));
d2510 1
a2510 1
		sizeof(struct in_addr), AF_INET);
@


1.63
log
@IPv6 support from KAME.
XXX kerberos and tcp_wrapper needs checking
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.62 1999/12/03 01:22:46 millert Exp $	*/
d2176 2
@


1.62
log
@Write pid to /var/run/ftpd.pid if running in daemon mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.61 1999/12/02 17:34:08 millert Exp $	*/
d5 29
d143 6
a148 6
struct	sockaddr_in server_addr;
struct	sockaddr_in ctrl_addr;
struct	sockaddr_in data_source;
struct	sockaddr_in data_dest;
struct	sockaddr_in his_addr;
struct	sockaddr_in pasv_addr;
d174 1
d205 2
d245 1
a245 1
static void	 dolog __P((struct sockaddr_in *));
d259 1
a259 1
static int	 check_host __P((struct sockaddr_in *));
d277 1
a277 1
char *argstr = "AdDhlMSt:T:u:UvP";
d370 8
d416 1
a416 1
		ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
d424 12
a435 3
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = INADDR_ANY;
		server_addr.sin_port = sv->s_port;
d437 1
a437 1
			 sizeof(server_addr))) {
d473 1
a473 1
		if (!check_host(&his_addr))
d502 40
d543 6
a548 3
	tos = IPTOS_LOWDELAY;
	if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
		syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
d550 1
a550 1
	data_source.sin_port = htons(ntohs(ctrl_addr.sin_port) - 1);
d562 1
a562 1
	dolog(&his_addr);
d603 2
a604 8
		hp = gethostbyaddr((char *) &ctrl_addr.sin_addr,
		    sizeof (struct in_addr), AF_INET);
		if (hp != NULL) {
			strcpy(dhostname, hp->h_name);
		} else {
			/* Default. */
			strcpy(dhostname, inet_ntoa(ctrl_addr.sin_addr));
		}
d1201 1
a1201 1
	s = socket(AF_INET, SOCK_STREAM, 0);
d1208 2
a1209 3
	data_source.sin_len = sizeof(struct sockaddr_in);
	data_source.sin_family = AF_INET;
	data_source.sin_addr = ctrl_addr.sin_addr;
d1212 1
a1212 1
		    sizeof(data_source)) >= 0)
d1223 6
a1228 3
	on = IPTOS_THROUGHPUT;
	if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&on, sizeof(int)) < 0)
		syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
d1267 4
a1270 1
	int retry = 0, tos;
d1280 1
a1280 1
		struct sockaddr_in from;
d1293 22
a1314 1
		if (ntohs(from.sin_port) < IPPORT_RESERVED) {
d1321 1
a1321 1
		if (from.sin_addr.s_addr != his_addr.sin_addr.s_addr) {
a1329 5
#ifdef IP_TOS
		tos = IPTOS_THROUGHPUT;
		(void) setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos,
		    sizeof(int));
#endif
d1345 6
a1350 3
		reply(425, "Can't create data socket (%s,%d): %s.",
		    inet_ntoa(data_source.sin_addr),
		    ntohs(data_source.sin_port), strerror(errno));
d1359 21
a1379 2
	if (ntohs(data_dest.sin_port) < IPPORT_RESERVED ||
	    ntohs(data_dest.sin_port) == 2049) {		/* XXX */
d1385 1
a1385 1
	if (data_dest.sin_addr.s_addr != his_addr.sin_addr.s_addr) {
d1392 1
a1392 1
	    sizeof(data_dest)) < 0) {
d1648 1
a1648 1
	struct sockaddr_in *sin;
d1650 2
d1655 2
d1658 2
a1659 2
	if (!isdigit(remotehost[0]))
		printf(" (%s)", inet_ntoa(his_addr.sin_addr));
d1681 1
d1686 2
a1687 1
		sin = &pasv_addr;
d1690 1
a1690 2
		printf("     PORT");
		sin = &data_dest;
d1692 8
a1699 2
		a = (u_char *) &sin->sin_addr;
		p = (u_char *) &sin->sin_port;
d1701 36
a1736 2
		printf(" (%d,%d,%d,%d,%d,%d)\r\n", UC(a[0]),
			UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
d1738 33
d1995 2
a1996 2
dolog(sin)
	struct sockaddr_in *sin;
d1998 4
a2001 2
	struct hostent *hp = gethostbyaddr((char *)&sin->sin_addr,
		sizeof(struct in_addr), AF_INET);
a2002 5
	if (hp)
		(void) strncpy(remotehost, hp->h_name, sizeof(remotehost)-1);
	else
		(void) strncpy(remotehost, inet_ntoa(sin->sin_addr),
		    sizeof(remotehost)-1);
d2106 1
a2106 1
	pasv_addr.sin_port = 0;
d2108 1
a2108 1
		 sizeof(pasv_addr)) < 0)
d2116 2
a2117 2
	a = (char *) &pasv_addr.sin_addr;
	p = (char *) &pasv_addr.sin_port;
d2126 105
d2484 3
a2486 1
check_host(sin)
d2488 8
a2495 2
{
	struct hostent *hp = gethostbyaddr((char *)&sin->sin_addr,
d2497 1
a2497 2
	char *addr = inet_ntoa(sin->sin_addr);

@


1.61
log
@Fix thinko on my part, we want to avoid setting mode to "r+" for
append, not for ascii.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.60 1999/12/01 06:33:24 millert Exp $	*/
d263 1
a263 1
	FILE *fd;
d396 8
d482 2
a483 2
	if ((fd = fopen(_PATH_NOLOGIN,"r")) != NULL) {
		while (fgets(line, sizeof(line), fd) != NULL) {
d489 1
a489 1
		(void) fclose(fd);
d493 2
a494 2
	if ((fd = fopen(_PATH_FTPWELCOME, "r")) != NULL) {
		while (fgets(line, sizeof(line), fd) != NULL) {
d500 1
a500 1
		(void) fclose(fd);
d705 1
a705 1
	FILE *fd;
d709 2
a710 2
	if ((fd = fopen(fname, "r")) != NULL) {
		while (fgets(line, sizeof(line), fd) != NULL)
d720 1
a720 1
		(void) fclose(fd);
d752 1
a752 1
	FILE *fd;
d905 1
a905 1
	if ((fd = fopen(_PATH_FTPLOGINMESG, "r")) != NULL) {
d908 1
a908 1
		while (fgets(line, sizeof(line), fd) != NULL) {
d914 1
a914 1
		(void) fclose(fd);
@


1.60
log
@Move initialization of ttyline to be after the fork() so that when
we are in daemon mode it contains the pid of the child, not the parent.
This fixes utmp/wtmp updates in daemon mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.59 1999/11/29 20:17:09 millert Exp $	*/
d1025 1
a1025 1
	if (restart_point && type != TYPE_A)
@


1.59
log
@When restarting a STOR, open with "r+", not "w" so we don't truncate.
Based on a patch from rmooney@@iss.net; closed PR #993
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.58 1999/11/14 22:25:02 deraadt Exp $	*/
a267 3
	/* set this here so klogin can use it... */
	(void)snprintf(ttyline, sizeof(ttyline), "ftp%d", getpid());

d427 3
@


1.58
log
@warning about getpeername() failing is useless
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.57 1999/09/22 05:00:46 deraadt Exp $	*/
d1025 3
a1036 2
		if (restart_point)
			mode = "r+";
@


1.57
log
@correct oob handling for STAT command; ian@@plutotech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.56 1999/07/21 00:05:47 deraadt Exp $	*/
d426 1
a426 1
			syslog(LOG_ERR, "getpeername (%s): %m", argv[0]);
@


1.56
log
@bad umask is an error, syslog; pointed out by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.55 1999/07/20 19:55:06 deraadt Exp $	*/
d1851 1
@


1.55
log
@do not proceed if incorrect args are found; found by form
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.54 1999/04/29 21:38:43 downsj Exp $	*/
d320 1
d322 7
a328 4
			val = strtol(optarg, &optarg, 8);
			if (*optarg != '\0' || val < 0 || (val & ~ACCESSPERMS))
				warnx("bad value for -u");
			else
@


1.54
log
@Work around the blocking read() that causes so many hung ftpd processes.

This has been extensively tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.53 1999/02/26 00:15:54 art Exp $	*/
d228 1
d245 10
a263 1
	char *argstr = "AdDhlMSt:T:u:UvP";
d338 1
a338 1
			warnx("unknown flag -%c ignored", optopt);
@


1.53
log
@implement internal ls
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.52 1998/12/30 22:01:24 deraadt Exp $	*/
d1391 13
a1403 5
		while ((cnt = read(fileno(instr), buf, sizeof(buf))) > 0) {
			if (write(fileno(outstr), buf, cnt) != cnt)
				goto file_err;
			byte_count += cnt;
		}
@


1.52
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.51 1998/12/29 07:00:58 deraadt Exp $	*/
d109 1
a109 1
static char version[] = "Version 6.3/OpenBSD";
@


1.51
log
@use getcwd()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.50 1998/11/18 23:30:08 deraadt Exp $	*/
d486 1
a486 1
		strcpy (hostname, hp->h_name);
d490 1
a490 1
				   sizeof (struct in_addr), AF_INET);
d492 1
a492 1
			strcpy (dhostname, hp->h_name);
d495 1
a495 1
			strcpy (dhostname, inet_ntoa(ctrl_addr.sin_addr));
d830 1
a830 1
			snprintf (rootdir, sizeof(rootdir), "%s/%s",
d833 1
a833 1
				snprintf (rootdir, sizeof(rootdir), "%s/%s",
d837 1
a837 1
			strcpy (rootdir, pw->pw_dir);
@


1.50
log
@check for out-of-range umask bits from strtol()
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.49 1998/07/23 08:13:38 deraadt Exp $	*/
d234 1
a234 1
	static char path[MAXPATHLEN+1+1];	/* path + '/' + '\0' */
d236 1
a236 1
	if (getcwd(path, sizeof(path)-2) == NULL)
d1722 1
a1722 1
	char path[MAXPATHLEN + 1];
d1724 1
a1724 1
	if (getwd(path) == (char *)NULL)
@


1.49
log
@add replydirname() from netbsd; fixes 257 directory replies; problem noted by kstailey
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.48 1998/07/13 02:11:15 millert Exp $	*/
d312 1
a312 1
			if (*optarg != '\0' || val < 0)
@


1.48
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.47 1998/06/08 16:55:34 mickey Exp $	*/
d221 1
d1680 16
d1704 1
a1704 1
		reply(257, "MKD command successful.");
d1727 1
a1727 1
		reply(257, "\"%s\" is current directory.", path);
@


1.47
log
@allow ftpchroot-ed users to also be multihomed
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.46 1998/06/03 17:44:47 deraadt Exp $	*/
d741 5
d762 2
a763 2
		if (pw == NULL || *pw->pw_passwd == '\0' ||
		    strcmp(crypt(passwd, (pw ? pw->pw_passwd : "xx")), pw->pw_passwd)) {
d978 1
a978 1
		} else if (lseek(fileno(fin), restart_point, L_SET) < 0) {
d1052 1
a1052 1
			if (fseek(fout, 0L, L_INCR) < 0) {
d1056 1
a1056 1
		} else if (lseek(fileno(fout), restart_point, L_SET) < 0) {
@


1.46
log
@use SIG_ERR
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.45 1997/12/12 08:55:09 deraadt Exp $	*/
d820 1
a820 1
		if (multihome) {
@


1.45
log
@default to violating the RFC wrt the PORT command. Use -P to conform to the
RFC and possibly open up non-OpenBSD boxes in a trust relationship on your
network to possible ftp bounce attacks...
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.44 1997/08/06 00:18:00 angelos Exp $	*/
d422 1
a422 1
	if ((long)signal(SIGURG, myoob) < 0)
@


1.44
log
@Errno save/restore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.43 1997/08/04 19:25:09 deraadt Exp $	*/
d136 1
d252 1
a252 1
	char *argstr = "AdDhlMSt:T:u:Uv";
d272 4
@


1.43
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.42 1997/07/25 19:41:16 mickey Exp $	*/
d1784 1
d1808 1
@


1.42
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.41 1997/07/23 20:36:24 kstailey Exp $	*/
d2063 5
a2067 1
	while (wait3(NULL, WNOHANG, NULL) > 0);
@


1.41
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.40 1997/06/29 07:39:02 deraadt Exp $	*/
d103 1
a103 1
#if __STDC__
d1539 1
a1539 1
#if __STDC__
d1549 1
a1549 1
#if __STDC__
d1565 1
a1565 1
#if __STDC__
d1575 1
a1575 1
#if __STDC__
@


1.40
log
@crank version
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.39 1997/06/29 07:35:44 deraadt Exp $	*/
d405 1
a405 1
			        &addrlen) < 0) {
d1545 1
a1545 1
        va_dcl
d1571 1
a1571 1
        va_dcl
@


1.39
log
@partial Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.38 1997/06/21 12:44:41 deraadt Exp $	*/
d109 1
a109 1
static char version[] = "Version 6.2/OpenBSD";
@


1.38
log
@attempt to realpath() log entries
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.37 1997/06/05 09:22:41 deraadt Exp $	*/
d89 1
d96 4
d627 1
a627 1
	if (pw = sgetpwnam(name)) {
d709 1
a709 1
		logwtmp(ttyline, "", "");
d794 1
a794 1
	logwtmp(ttyline, pw->pw_name, remotehost);
d893 2
a894 2
		    sizeof(proctitle) - sizeof(remotehost) -
		    sizeof(": anonymous/"), passwd);
d1613 1
a1613 1
	if (cp = strchr(cbuf,'\n'))
d1767 1
a1767 1
		logwtmp(ttyline, "", "");
a1818 1
	u_short port;
d1965 1
a1965 1
	while (dirname = *dirlist++) {
d2098 1
a2098 1
		    vremotehost, size, vpath,
@


1.37
log
@bigger buf
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.36 1997/06/01 06:40:34 downsj Exp $	*/
d2069 1
a2069 1
	char path[MAXPATHLEN];
d2071 1
a2071 1
	char *vname, *vpw;
d2074 1
a2074 1
	if ((statfd >= 0) && (getcwd(path, sizeof(path)) != NULL)) {
a2076 3
		vname = (char *)malloc(strlen(name)*4+1);
		if (vname == NULL)
			return;
d2078 1
a2078 2
		if (vpw == NULL) {
			free(vname);
d2080 5
d2086 1
a2088 2
		strvis(vpath, path, VIS_SAFE|VIS_NOSLASH);
		strvis(vname, name, VIS_SAFE|VIS_NOSLASH);
d2092 7
a2098 7
			 "%.24s %d %s %qd %s/%s %c %s %c %c %s ftp %d %s %s\n",
			 ctime(&now), now - start + (now == start),
			 vremotehost, size, vpath, vname,
			 ((type == TYPE_A) ? 'a' : 'b'), "*" /* none yet */,
			 'o', ((guest) ? 'a' : 'r'),
			 vpw, 0 /* none yet */,
			 ((guest) ? "*" : pw->pw_name), dhostname);
a2099 1
		free(vname);
@


1.36
log
@Support integrated tcp wrappers when in daemon mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.35 1997/05/01 14:45:37 deraadt Exp $	*/
d2068 1
a2068 1
	char buf[2048];
@


1.35
log
@change -A to let in anon | chroot accounts
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.33 1997/03/25 22:47:10 millert Exp $	*/
d91 4
d156 5
d220 1
d391 6
d2104 25
@


1.34
log
@do not allow connect to a 2049 either, helps firewall cases; adam@@math.tau.ac.il
@
text
@d601 1
a601 1
	if (anon_only != 0) {
@


1.33
log
@Splat .message file if it exists when user cd's to a directory
like wu-ftpd.  Based on changes from Oliver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.32 1997/01/23 06:49:11 deraadt Exp $	*/
d1194 2
a1195 1
	if (ntohs(data_dest.sin_port) < IPPORT_RESERVED) {
@


1.32
log
@crank version number
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.31 1997/01/15 23:40:58 millert Exp $	*/
d1626 1
d1630 12
a1641 1
	else
d1643 1
@


1.31
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.30 1997/01/05 21:28:07 bitblt Exp $	*/
d100 1
a100 1
static char version[] = "Version 6.1/OpenBSD";
@


1.30
log
@Signals are now blocked while ftpd runs with euid 0, as suggested by
Weiste Venema.  If this triggers any problems (most likely with ABOR not
working at certain times) let me know.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.29 1997/01/02 21:33:33 deraadt Exp $	*/
d244 1
a244 1
	while ((ch = getopt(argc, argv, argstr)) != EOF) {
@


1.29
log
@avoid SIGURG race; dg@@root.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.28 1996/12/14 23:09:46 deraadt Exp $	*/
d683 3
a685 1

d706 1
d838 2
d1053 1
d1057 2
d1079 3
d1109 2
d1724 2
d1729 2
@


1.28
log
@stop gunique() open/fopen race
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.27 1996/12/14 22:47:38 deraadt Exp $	*/
d1711 1
@


1.27
log
@solve /tmp-style race spotted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.26 1996/12/07 09:00:22 bitblt Exp $	*/
d202 1
a202 1
static char	*gunique __P((char *));
d970 1
d972 4
a975 1
	int (*closefunc) __P((FILE *));
d977 11
a987 5
	if (unique && stat(name, &st) == 0 &&
	    (name = gunique(name)) == NULL) {
		LOGCMD(*mode == 'w' ? "put" : "append", name);
		return;
	}
a988 3
	if (restart_point)
		mode = "r+";
	fout = fopen(name, mode);
d1820 2
a1821 2
static char *
gunique(local)
d1823 1
d1835 1
a1835 1
		return ((char *) 0);
d1843 1
a1843 1
		return (NULL);
d1851 3
a1853 2
		close(fd);
		return (new);
d1856 1
a1856 1
	return (NULL);
@


1.26
log
@ftpd now eventually times out if a ftp client does:
pasv
list
and then crashes.
The timeout should only apply the the accept(), so that transfers can
take as long as necessary to complete.
Thanks to Theo for moving toolong() to extern.h so that it can be used
in ftpd.c as well as in ftpcmd.y.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.25 1996/12/03 03:07:17 deraadt Exp $	*/
d1819 1
a1819 1
	int count, len;
d1840 5
a1844 2
		if (stat(new, &st) < 0)
			return (new);
@


1.25
log
@-A for anon only; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.23 1996/10/18 20:12:45 deraadt Exp $	*/
d1117 2
d1120 1
@


1.24
log
@add ')'.
@
text
@d122 1
d236 1
a236 1
	char *argstr = "dDhlMSt:T:u:Uv";
d246 4
d601 5
@


1.23
log
@forget old password nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.22 1996/10/15 12:29:27 deraadt Exp $	*/
d532 1
a532 1
		memset(save.pw_passwd, 0, strlen(save.pw_passwd);
@


1.22
log
@fd leak spotted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.21 1996/09/29 22:11:50 millert Exp $	*/
d532 1
@


1.21
log
@s/key (otp) challenge is now rfc 1938 compliant.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.20 1996/09/22 09:49:58 deraadt Exp $	*/
d1752 2
@


1.20
log
@vis log entries; noted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.19 1996/09/04 15:40:27 deraadt Exp $	*/
d622 1
a622 1
		reply(331, "Password [%s] for %s required.",
@


1.19
log
@no, bad commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.17 1996/08/27 10:08:37 deraadt Exp $	*/
d87 1
d1992 1
a1992 1
	char buf[1024];
d1994 2
d2001 14
d2018 1
a2018 1
			 remotehost, size, path, name,
d2021 1
a2021 1
			 ((guest) ? guestpw : pw->pw_name), 0 /* none yet */,
d2024 2
@


1.18
log
@clear passwd, for safety
@
text
@d1558 1
a1558 1
	reply(500, "'%s': command not understood: %s.", cbuf, s);
@


1.17
log
@strncpy correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.16 1996/08/25 21:04:56 deraadt Exp $	*/
d1558 1
a1558 1
	reply(500, "'%s': command not understood.", cbuf);
@


1.16
log
@hide our base dir
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.15 1996/08/13 06:34:39 deraadt Exp $	*/
d612 1
a612 1
	if (logging)
d614 2
d1667 1
a1667 1
		(void) strncpy(remotehost, hp->h_name, sizeof(remotehost));
d1670 2
a1671 1
		    sizeof(remotehost));
d1802 1
a1802 1
	int count;
d1814 6
a1819 2
	(void) strncpy(new, local, sizeof(new));
	cp = new + strlen(new);
@


1.15
log
@log non-anon stuff for -S too, from downsj
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.14 1996/08/10 06:12:12 downsj Exp $	*/
d800 2
d807 2
@


1.14
log
@Add multihome support (-M) and make stats logging look like wu-ftpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.13 1996/08/08 16:22:37 downsj Exp $	*/
d935 1
a935 1
	if ((cmd == 0) && guest && stats)
@


1.13
log
@Handle signals better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.12 1996/08/07 03:27:54 downsj Exp $	*/
d121 1
d144 2
d234 2
a235 1
	char *argstr = "dDhlSt:T:u:Uv";
d260 4
d449 19
a467 1
	reply(220, "%s FTP server (%s) ready.", hostname, version);
d547 1
a547 1
static char curname[10];	/* current USER name */
d689 1
d742 5
d776 14
d796 1
a796 1
		if (chroot(pw->pw_dir) < 0 || chdir("/") < 0) {
d801 1
a801 1
		if (chroot(pw->pw_dir) < 0 || chdir("/") < 0) {
d1750 1
d1755 1
d1981 1
a1981 1
	char path[MAXPATHLEN + 1];
d1984 1
a1984 1
	if ((statfd >= 0) && (getwd(path) != NULL)) {
d1986 9
a1994 3
		snprintf(buf, sizeof(buf), "%.20s!%s!%s!%s/%s!%qd!%ld\n",
			 ctime(&now)+4, ident, remotehost,
			 path, name, size, now - start + (now == start));
@


1.12
log
@STATS is not an option.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.11 1996/08/07 03:17:58 downsj Exp $	*/
d199 1
d376 4
d448 4
d459 9
@


1.11
log
@strcpy -> strncpy, kill off a strdup() clone.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.10 1996/08/07 03:04:22 downsj Exp $	*/
a121 1
#ifdef STATS
a123 1
#endif
a151 1
#ifdef STATS
a152 1
#endif
a205 1
#ifdef STATS
a206 1
#endif
a229 1
#ifdef STATS
a230 3
#else
	char *argstr = "dDhlt:T:u:Uv";
#endif
a254 1
#ifdef STATS
a257 1
#endif
a717 1
#ifdef STATS
a721 1
#endif
a775 1
#ifdef STATS
a780 1
#endif
a816 1
#ifdef STATS
a817 1
#endif
a867 1
#ifdef STATS
a868 1
#endif
a870 1
#ifdef STATS
a872 1
#endif
a1907 1
#ifdef STATS
a1925 1
#endif
@


1.10
log
@sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.9 1996/07/29 05:32:59 downsj Exp $	*/
d1763 1
a1763 1
	(void) strcpy(new, local);
@


1.9
log
@Remove some FreeBSD cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.8 1996/07/29 03:06:35 downsj Exp $	*/
d843 2
a844 1
		(void) sprintf(line, cmd, name), name = line;
d1048 5
a1052 4
	if (size != (off_t) -1)
		(void) sprintf(sizebuf, " (%qd bytes)", size);
	else
		(void) strcpy(sizebuf, "");
d1767 1
a1767 1
		(void)sprintf(cp, "%d", count);
d1876 2
a1877 1
			sprintf(nbuf, "%s/%s", dirname, dir->d_name);
@


1.8
log
@Add -h, causing passive mode connections to request the high port range.

Also a few other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.7 1996/07/29 00:03:19 downsj Exp $	*/
a1706 1
	(void) seteuid((uid_t)0);
d1708 1
a1708 2
		       (char *)&on, sizeof(on)) < 0) {
		(void) seteuid((uid_t)pw->pw_uid);
a1709 1
	}
a1712 1
	(void) seteuid((uid_t)0);
d1714 1
a1714 2
		 sizeof(pasv_addr)) < 0) {
		(void) seteuid((uid_t)pw->pw_uid);
a1715 2
	}
	(void) seteuid((uid_t)pw->pw_uid);
@


1.7
log
@Add setenv for HOME (from FreeBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.6 1996/07/28 23:32:16 downsj Exp $	*/
d64 1
d120 1
d237 1
a237 1
	char *argstr = "dDlSt:T:u:Uv";
d239 1
a239 1
	char *argstr = "dDlt:T:u:Uv";
d257 4
d309 2
a386 1
	(void) freopen(_PATH_DEVNULL, "w", stderr);
d1008 17
d1692 2
a1693 1
	int len;
d1696 4
d1705 9
d1717 2
a1718 1
	if (bind(pdata, (struct sockaddr *)&pasv_addr, sizeof(pasv_addr)) < 0) {
d1723 1
@


1.6
log
@Add daemon mode (from FreeBSD), moving a lot of things around.

Also change the advertised version to '6.1/OpenBSD'; using the old version
number from 4.4BSD seems rather silly at this point.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.5 1996/07/28 22:42:45 downsj Exp $	*/
d649 1
d760 7
@


1.5
log
@Add anonymous statistics logging, based on FreeBSD but with the really
obvious bugs fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.4 1996/07/28 19:45:36 downsj Exp $	*/
d98 1
a98 1
static char version[] = "Version 6.00";
d103 1
d110 1
d115 1
a115 1
int	debug;
a153 2

void	logxfer __P((char *, off_t, time_t));
d206 5
d235 1
a235 1
	char *argstr = "dlSt:T:u:Uv";
d237 1
a237 1
	char *argstr = "dlt:T:u:Uv";
d240 1
a240 22
	/*
	 * LOG_NDELAY sets up the logging connection immediately,
	 * necessary for anonymous ftp's that chroot and can't do it later.
	 */
	openlog("ftpd", LOG_PID | LOG_NDELAY, LOG_FTP);
	addrlen = sizeof(his_addr);
	if (getpeername(0, (struct sockaddr *)&his_addr, &addrlen) < 0) {
		syslog(LOG_ERR, "getpeername (%s): %m",argv[0]);
		exit(1);
	}
	addrlen = sizeof(ctrl_addr);
	if (getsockname(0, (struct sockaddr *)&ctrl_addr, &addrlen) < 0) {
		syslog(LOG_ERR, "getsockname (%s): %m",argv[0]);
		exit(1);
	}
#ifdef IP_TOS
	tos = IPTOS_LOWDELAY;
	if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
		syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
#endif
	data_source.sin_port = htons(ntohs(ctrl_addr.sin_port) - 1);
	debug = 0;
d251 4
d302 77
d385 12
d1877 7
@


1.4
log
@New mmap(2)-using send_data() from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.3 1996/07/27 07:26:39 joshd Exp $	*/
d118 4
d148 8
a155 1
#endif 
d229 5
d261 1
a261 1
	while ((ch = getopt(argc, argv, "dlt:T:u:Uv")) != EOF) {
d271 6
d645 7
d698 7
d741 3
d793 3
d798 4
d1801 21
@


1.3
log
@No more ftpd bounce attacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpd.c,v 1.2 1996/06/18 10:09:20 downsj Exp $	*/
d59 1
d191 1
a191 1
static void	 send_data __P((FILE *, FILE *, off_t));
d754 2
a755 1
	send_data(fin, dout, st.st_blksize);
d985 1
a985 1
 * encapsulation of the data subject * to Mode, Structure, and Type.
d990 1
a990 1
send_data(instr, outstr, blksize)
d993 2
d997 2
a998 1
	char *buf;
d1028 33
d1066 1
a1066 2
		netfd = fileno(outstr);
		filefd = fileno(instr);
@


1.2
log
@my netbsd pr#2217: add utmp support to ftpd, some other small changes/fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d905 14
d947 17
@


1.1
log
@Initial revision
@
text
@d1 1
d86 1
d122 1
d138 1
d242 1
a242 1
	(void)sprintf(ttyline, "ftp%d", getpid());
d244 1
a244 1
	while ((ch = getopt(argc, argv, "dlt:T:u:v")) != EOF) {
d278 4
d532 1
a532 1
	if (logged_in)
d534 3
d611 11
d1419 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
