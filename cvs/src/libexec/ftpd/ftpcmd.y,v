head	1.66;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.56.0.6
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.54.0.6
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.4
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.10
	OPENBSD_5_0:1.53.0.8
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.6
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.52.0.6
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.49.0.8
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.6
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.4
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.48.0.6
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.48.0.4
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.43.0.4
	OPENBSD_3_6_BASE:1.43
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.41.0.4
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	OPENBSD_3_0:1.24.0.4
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.66
date	2017.04.27.13.30.54;	author mikeb;	state Exp;
branches;
next	1.65;
commitid	3qRsGk85lK6Ecx8C;

1.65
date	2017.04.17.21.49.01;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	xqdgf1sMQj67SZ2T;

1.64
date	2016.08.26.06.32.10;	author tedu;	state Exp;
branches;
next	1.63;
commitid	aiNxM8iy2xv5nTf9;

1.63
date	2016.08.14.22.56.29;	author guenther;	state Exp;
branches;
next	1.62;
commitid	8Smubfc3nikyhBi5;

1.62
date	2015.11.16.17.31.14;	author tedu;	state Exp;
branches;
next	1.61;
commitid	eR8GyZHrhWLCQlqG;

1.61
date	2015.10.25.22.13.39;	author tedu;	state Exp;
branches;
next	1.60;
commitid	lJUx1CK3UTmRxOQb;

1.60
date	2015.08.18.17.35.59;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	PiH2E145aU40kGHy;

1.59
date	2015.03.17.19.31.30;	author millert;	state Exp;
branches;
next	1.58;
commitid	0y5bUkEOUrNvvJEO;

1.58
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.57;
commitid	IbVxlqGw2UipKdDr;

1.57
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	Uu5nFG3wCl0LACBb;

1.56
date	2014.02.08.13.31.51;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.13.12.04.49;	author moritz;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.12.16.12.08;	author moritz;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.30.12.03.51;	author ragge;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.21.17.42.50;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.11.08.38.26;	author moritz;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.06.23.04.14;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.04.18.00.43;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.03.23.57.40;	author moritz;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.28.18.49.29;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.10.22.57.12;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.19.38.24;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.02.18.09.53;	author danh;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.17.19.33.37;	author danh;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.19.17.58.24;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.30.18.01.46;	author mpech;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.30.17.14.29;	author mpech;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.25.06.43.37;	author mpech;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.25.06.40.14;	author mpech;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.23.16.38.12;	author mpech;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.23.10.28.50;	author mpech;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.17.05.27.35;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.08.01.55.27;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.08.01.52.00;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.28.17.38.17;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.07.18.45.32;	author mpech;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.04.21.18.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.05.09.51.13;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.14.20.27.01;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.13.16.14.44;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.13.15.39.08;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.17.19.42.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.29.14.03.02;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.15.05.10.55;	author ericj;	state Exp;
branches;
next	1.18;

1.18
date	99.12.08.13.15.21;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	99.10.08.14.40.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.05.22.06.46.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.02.03.22.21.21;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.12.18.11.46.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.12.18.11.38.10;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.12.08.55.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.23.20.36.23;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.22.17.50.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.02.19.49.50;	author bitblt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.07.09.00.20;	author bitblt;	state Exp;
branches;
next	1.7;

1.7
date	96.10.16.00.50.35;	author bitblt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.19.01.21.25;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.04.14.41.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.22.07.01.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.07.03.17.55;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.04.23.03.03.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Don't send multiple error messages in response to a single command

While a few commands (such as HELP and NOOP) are allowed in between
USER and PASS, most of the others are not.  However if such command
is issued, ftpd should abort the command evaluation early and reply
with "530 Please login with USER and PASS."

From form@@, with input from deraadt@@ and OK millert@@
@
text
@/*	$OpenBSD: ftpcmd.y,v 1.65 2017/04/17 21:49:01 deraadt Exp $	*/
/*	$NetBSD: ftpcmd.y,v 1.7 1996/04/08 19:03:11 jtc Exp $	*/

/*
 * Copyright (c) 1985, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ftpcmd.y	8.3 (Berkeley) 4/6/94
 */

/*
 * Grammar for FTP commands.
 * See RFC 959.
 */

%{

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/ftp.h>

#include <ctype.h>
#include <errno.h>
#include <glob.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <netdb.h>
#include <limits.h>

#include "monitor.h"
#include "extern.h"

extern	union sockunion data_dest;
extern	int logged_in;
extern	struct passwd *pw;
extern	int guest;
extern	int logging;
extern	int type;
extern	int form;
extern	int debug;
extern	int timeout;
extern	int maxtimeout;
extern  int pdata;
extern	char hostname[], remotehost[];
extern	char proctitle[];
extern	int usedefault;
extern  int transflag;
extern  char tmpline[];
extern	int portcheck;
extern	union sockunion his_addr;
extern	int umaskchange;

off_t	restart_point;

static	int cmd_type;
static	int cmd_form;
static	int cmd_bytesz;
static	int state;
static	int quit;
char	cbuf[512];
char	*fromname;

%}

%union {
	int	i;
	off_t	o;
	char   *s;
}

%token
	A	B	C	E	F	I
	L	N	P	R	S	T

	SP	CRLF	COMMA	ALL

	USER	PASS	ACCT	REIN	QUIT	PORT
	PASV	TYPE	STRU	MODE	RETR	STOR
	APPE	MLFL	MAIL	MSND	MSOM	MSAM
	MRSQ	MRCP	ALLO	REST	RNFR	RNTO
	ABOR	DELE	CWD	LIST	NLST	SITE
	STAT	HELP	NOOP	MKD	RMD	PWD
	CDUP	STOU	SMNT	SYST	SIZE	MDTM

	LPRT	LPSV	EPRT	EPSV

	UMASK	IDLE	CHMOD

	LEXERR

%token	<s> STRING
%token	<i> NUMBER
%token	<o> BIGNUM

%type	<i> check_login check_login_epsvall octal_number byte_size
%type	<i> struct_code mode_code type_code form_code
%type	<i> host_port host_long_port4 host_long_port6
%type	<o> file_size
%type	<s> pathstring pathname password username

%start	cmd_list

%%

cmd_list
	: /* empty */
	| cmd_list cmd
		{
			if (fromname) {
				free(fromname);
				fromname = NULL;
			}
			restart_point = 0;
		}
	| cmd_list rcmd
	;

cmd
	: USER SP username CRLF
		{
			monitor_user($3);
			free($3);
		}
	| PASS SP password CRLF
		{
			quit = monitor_pass($3);
			explicit_bzero($3, strlen($3));
			free($3);

			/* Terminate unprivileged pre-auth slave */
			if (quit)
				_exit(0);
		}
	| PORT check_login_epsvall SP host_port CRLF
		{
			if ($2) {
				if ($4) {
					usedefault = 1;
					reply(500,
					    "Illegal PORT rejected (range errors).");
				} else if (portcheck &&
				    ntohs(data_dest.su_sin.sin_port) < IPPORT_RESERVED) {
					usedefault = 1;
					reply(500,
					    "Illegal PORT rejected (reserved port).");
				} else if (portcheck &&
				    memcmp(&data_dest.su_sin.sin_addr,
				    &his_addr.su_sin.sin_addr,
				    sizeof data_dest.su_sin.sin_addr)) {
					usedefault = 1;
					reply(500,
					    "Illegal PORT rejected (address wrong).");
				} else {
					usedefault = 0;
					if (pdata >= 0) {
						(void) close(pdata);
						pdata = -1;
					}
					reply(200, "PORT command successful.");
				}
			}
		}
	| LPRT check_login_epsvall SP host_long_port4 CRLF
		{
			if ($2) {
				/* reject invalid host_long_port4 */
				if ($4) {
					reply(500,
					    "Illegal LPRT command rejected");
					usedefault = 1;
				} else {
					usedefault = 0;
					if (pdata >= 0) {
						(void) close(pdata);
						pdata = -1;
					}
					reply(200, "LPRT command successful.");
				}
			}
		}

	| LPRT check_login_epsvall SP host_long_port6 CRLF
		{
			if ($2) {
				/* reject invalid host_long_port6 */
				if ($4) {
					reply(500,
					    "Illegal LPRT command rejected");
					usedefault = 1;
				} else {
					usedefault = 0;
					if (pdata >= 0) {
						(void) close(pdata);
						pdata = -1;
					}
					reply(200, "LPRT command successful.");
				}
			}
		}

	| EPRT check_login_epsvall SP STRING CRLF
		{
			if ($2)
				extended_port($4);
			free($4);
		}

	| PASV check_login_epsvall CRLF
		{
			if ($2)
				passive();
		}
	| LPSV check_login_epsvall CRLF
		{
			if ($2)
				long_passive("LPSV", PF_UNSPEC);
		}
	| EPSV check_login SP NUMBER CRLF
		{
			if ($2)
				long_passive("EPSV", epsvproto2af($4));
		}
	| EPSV check_login SP ALL CRLF
		{
			if ($2) {
				reply(200, "EPSV ALL command successful.");
				epsvall++;
			}
		}
	| EPSV check_login CRLF
		{
			if ($2)
				long_passive("EPSV", PF_UNSPEC);
		}
	| TYPE check_login SP type_code CRLF
		{
			if ($2) {
				switch (cmd_type) {

				case TYPE_A:
					if (cmd_form == FORM_N) {
						reply(200, "Type set to A.");
						type = cmd_type;
						form = cmd_form;
					} else
						reply(504, "Form must be N.");
					break;

				case TYPE_E:
					reply(504, "Type E not implemented.");
					break;

				case TYPE_I:
					reply(200, "Type set to I.");
					type = cmd_type;
					break;

				case TYPE_L:
					if (cmd_bytesz == 8) {
						reply(200,
						    "Type set to L (byte size 8).");
						    type = cmd_type;
					} else
						reply(504, "Byte size must be 8.");

				}
			}
		}
	| STRU check_login SP struct_code CRLF
		{
			if ($2) {
				switch ($4) {

				case STRU_F:
					reply(200, "STRU F ok.");
					break;

				default:
					reply(504, "Unimplemented STRU type.");
				}
			}
		}
	| MODE check_login SP mode_code CRLF
		{
			if ($2) {
				switch ($4) {

				case MODE_S:
					reply(200, "MODE S ok.");
					break;

				default:
					reply(502, "Unimplemented MODE type.");
				}
			}
		}
	| ALLO check_login SP NUMBER CRLF
		{
			if ($2) {
				reply(202, "ALLO command ignored.");
			}
		}
	| ALLO check_login SP NUMBER SP R SP NUMBER CRLF
		{
			if ($2) {
				reply(202, "ALLO command ignored.");
			}
		}
	| RETR check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				retrieve(NULL, $4);
			if ($4 != NULL)
				free($4);
		}
	| STOR check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				store($4, "w", 0);
			if ($4 != NULL)
				free($4);
		}
	| APPE check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				store($4, "a", 0);
			if ($4 != NULL)
				free($4);
		}
	| NLST check_login CRLF
		{
			if ($2)
				send_file_list(".");
		}
	| NLST check_login SP STRING CRLF
		{
			if ($2 && $4 != NULL)
				send_file_list($4);
			free($4);
		}
	| LIST check_login CRLF
		{
			if ($2)
				retrieve("/bin/ls -lgA", "");
		}
	| LIST check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				retrieve("/bin/ls -lgA %s", $4);
			if ($4 != NULL)
				free($4);
		}
	| STAT check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				statfilecmd($4);
			if ($4 != NULL)
				free($4);
		}
	| STAT check_login CRLF
		{
			if ($2)
				statcmd();
		}
	| DELE check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				delete($4);
			if ($4 != NULL)
				free($4);
		}
	| RNTO check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL) {
				if (fromname) {
					renamecmd(fromname, $4);
					free(fromname);
					fromname = NULL;
				} else {
					reply(503,
					  "Bad sequence of commands.");
				}
			}
			if ($4 != NULL)
				free($4);
		}
	| ABOR check_login CRLF
		{
			if ($2)
				reply(225, "ABOR command successful.");
		}
	| CWD check_login CRLF
		{
			if ($2)
				cwd(pw->pw_dir);
		}
	| CWD check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				cwd($4);
			if ($4 != NULL)
				free($4);
		}
	| HELP CRLF
		{
			help(cmdtab, NULL);
		}
	| HELP SP STRING CRLF
		{
			char *cp = $3;

			if (strncasecmp(cp, "SITE", 4) == 0) {
				cp = $3 + 4;
				if (*cp == ' ')
					cp++;
				if (*cp)
					help(sitetab, cp);
				else
					help(sitetab, NULL);
			} else
				help(cmdtab, $3);
			free ($3);
		}
	| NOOP CRLF
		{
			reply(200, "NOOP command successful.");
		}
	| MKD check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				makedir($4);
			if ($4 != NULL)
				free($4);
		}
	| RMD check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				removedir($4);
			if ($4 != NULL)
				free($4);
		}
	| PWD check_login CRLF
		{
			if ($2)
				pwd();
		}
	| CDUP check_login CRLF
		{
			if ($2)
				cwd("..");
		}
	| SITE SP HELP CRLF
		{
			help(sitetab, NULL);
		}
	| SITE SP HELP SP STRING CRLF
		{
			help(sitetab, $5);
			free ($5);
		}
	| SITE SP UMASK check_login CRLF
		{
			mode_t oldmask;

			if ($4) {
				oldmask = umask(0);
				(void) umask(oldmask);
				reply(200, "Current UMASK is %03o", oldmask);
			}
		}
	| SITE SP UMASK check_login SP octal_number CRLF
		{
			mode_t oldmask;

			if ($4) {
				if (($6 == -1) || ($6 > 0777)) {
					reply(501, "Bad UMASK value");
				} else if (!umaskchange) {
					reply(550,
					    "No permission to change umask.");
				} else {
					oldmask = umask($6);
					reply(200,
					    "UMASK set to %03o (was %03o)",
					    $6, oldmask);
				}
			}
		}
	| SITE SP CHMOD check_login SP octal_number SP pathname CRLF
		{
			if ($4 && ($8 != NULL)) {
				if (($6 == -1) || ($6 > 0777))
					reply(501,
					    "CHMOD: Mode value must be between "
					    "0 and 0777");
				else if (!umaskchange)
					reply(550,
					    "No permission to change mode of %s.",
					    $8);
				else if (chmod($8, $6) < 0)
					perror_reply(550, $8);
				else
					reply(200,
					    "CHMOD command successful.");
			}
			if ($8 != NULL)
				free($8);
		}
	| SITE SP check_login IDLE CRLF
		{
			if ($3)
				reply(200,
				    "Current IDLE time limit is %d "
				    "seconds; max %d",
				    timeout, maxtimeout);
		}
	| SITE SP check_login IDLE SP NUMBER CRLF
		{
			if ($3) {
				if ($6 < 30 || $6 > maxtimeout) {
					reply(501,
					    "Maximum IDLE time must be between "
					    "30 and %d seconds",
					    maxtimeout);
				} else {
					timeout = $6;
					(void) alarm((unsigned) timeout);
					reply(200,
					    "Maximum IDLE time set to %d seconds",
					    timeout);
				}
			}
		}
	| STOU check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				store($4, "w", 1);
			if ($4 != NULL)
				free($4);
		}
	| SYST check_login CRLF
		{
			if ($2)
			reply(215, "UNIX Type: L8");
		}

		/*
		 * SIZE is not in RFC959, but Postel has blessed it and
		 * it will be in the updated RFC.
		 *
		 * Return size of file in a format suitable for
		 * using with RESTART (we just count bytes).
		 */
	| SIZE check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL)
				sizecmd($4);
			if ($4 != NULL)
				free($4);
		}

		/*
		 * MDTM is not in RFC959, but Postel has blessed it and
		 * it will be in the updated RFC.
		 *
		 * Return modification time of file as an ISO 3307
		 * style time. E.g. YYYYMMDDHHMMSS or YYYYMMDDHHMMSS.xxx
		 * where xxx is the fractional second (of any precision,
		 * not necessarily 3 digits)
		 */
	| MDTM check_login SP pathname CRLF
		{
			if ($2 && $4 != NULL) {
				struct stat stbuf;
				if (stat($4, &stbuf) < 0)
					reply(550, "%s: %s",
					    $4, strerror(errno));
				else if (!S_ISREG(stbuf.st_mode)) {
					reply(550, "%s: not a plain file.", $4);
				} else {
					struct tm *t;
					t = gmtime(&stbuf.st_mtime);
					reply(213,
					    "%04d%02d%02d%02d%02d%02d",
					    1900 + t->tm_year,
					    t->tm_mon+1, t->tm_mday,
					    t->tm_hour, t->tm_min, t->tm_sec);
				}
			}
			if ($4 != NULL)
				free($4);
		}
	| QUIT CRLF
		{
			reply(221, "Goodbye.");
			dologout(0);
		}
	| error
		{
			yyclearin;		/* discard lookahead data */
			yyerrok;		/* clear error condition */
			state = 0;		/* reset lexer state */
		}
	;
rcmd
	: RNFR check_login SP pathname CRLF
		{
			restart_point = 0;
			if ($2 && $4) {
				if (fromname)
					free(fromname);
				fromname = renamefrom($4);
				if (fromname == NULL)
					free($4);
			} else if ($4) {
				free ($4);
			}
		}

	| REST check_login SP file_size CRLF
		{
			if ($2) {
				if (fromname) {
					free(fromname);
					fromname = NULL;
				}
				restart_point = $4;
				reply(350, "Restarting at %lld. %s",
				    (long long)restart_point,
				    "Send STORE or RETRIEVE to initiate transfer.");
			}
		}
	;

username
	: STRING
	;

password
	: /* empty */
		{
			$$ = calloc(1, sizeof(char));
		}
	| STRING
	;

byte_size
	: NUMBER
	;

file_size
	: NUMBER
		{
			$$ = $1;
		}
	| BIGNUM
		{
			$$ = $1;
		}
	;

host_port
	: NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER
		{
			char *a, *p;

			if ($1 < 0 || $1 > 255 || $3 < 0 || $3 > 255 ||
			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255) {
				$$ = 1;
			} else {
				data_dest.su_sin.sin_len = sizeof(struct sockaddr_in);
				data_dest.su_sin.sin_family = AF_INET;
				p = (char *)&data_dest.su_sin.sin_port;
				p[0] = $9; p[1] = $11;
				a = (char *)&data_dest.su_sin.sin_addr;
				a[0] = $1; a[1] = $3; a[2] = $5; a[3] = $7;
				$$ = 0;
			}
		}
	;

host_long_port4
	: NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER
		{
			char *a, *p;

			/* reject invalid LPRT command */
			if ($1 != 4 || $3 != 4 ||
			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255 ||
			    $13 != 2 ||
			    $15 < 0 || $15 > 255 || $17 < 0 || $17 > 255) {
				$$ = 1;
			} else {
				data_dest.su_sin.sin_len =
					sizeof(struct sockaddr_in);
				data_dest.su_family = AF_INET;
				p = (char *)&data_dest.su_port;
				p[0] = $15; p[1] = $17;
				a = (char *)&data_dest.su_sin.sin_addr;
				a[0] = $5; a[1] = $7; a[2] = $9; a[3] = $11;
				$$ = 0;
			}
		}
	;

host_long_port6
	: NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
		NUMBER
		{
			char *a, *p;

			/* reject invalid LPRT command */
			if ($1 != 6 || $3 != 16 ||
			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255 ||
			    $13 < 0 || $13 > 255 || $15 < 0 || $15 > 255 ||
			    $17 < 0 || $17 > 255 || $19 < 0 || $19 > 255 ||
			    $21 < 0 || $21 > 255 || $23 < 0 || $23 > 255 ||
			    $25 < 0 || $25 > 255 || $27 < 0 || $27 > 255 ||
			    $29 < 0 || $29 > 255 || $31 < 0 || $31 > 255 ||
			    $33 < 0 || $33 > 255 || $35 < 0 || $35 > 255 ||
			    $37 != 2 ||
			    $39 < 0 || $39 > 255 || $41 < 0 || $41 > 255) {
				$$ = 1;
			} else {
				data_dest.su_sin6.sin6_len =
					sizeof(struct sockaddr_in6);
				data_dest.su_family = AF_INET6;
				p = (char *)&data_dest.su_port;
				p[0] = $39; p[1] = $41;
				a = (char *)&data_dest.su_sin6.sin6_addr;
				 a[0] =  $5;  a[1] =  $7;
				 a[2] =  $9;  a[3] = $11;
				 a[4] = $13;  a[5] = $15;
				 a[6] = $17;  a[7] = $19;
				 a[8] = $21;  a[9] = $23;
				a[10] = $25; a[11] = $27;
				a[12] = $29; a[13] = $31;
				a[14] = $33; a[15] = $35;
				if (his_addr.su_family == AF_INET6) {
					/* XXX more sanity checks! */
					data_dest.su_sin6.sin6_scope_id =
					    his_addr.su_sin6.sin6_scope_id;
				}

				$$ = 0;
			}
		}
	;

form_code
	: N
		{
			$$ = FORM_N;
		}
	| T
		{
			$$ = FORM_T;
		}
	| C
		{
			$$ = FORM_C;
		}
	;

type_code
	: A
		{
			cmd_type = TYPE_A;
			cmd_form = FORM_N;
		}
	| A SP form_code
		{
			cmd_type = TYPE_A;
			cmd_form = $3;
		}
	| E
		{
			cmd_type = TYPE_E;
			cmd_form = FORM_N;
		}
	| E SP form_code
		{
			cmd_type = TYPE_E;
			cmd_form = $3;
		}
	| I
		{
			cmd_type = TYPE_I;
		}
	| L
		{
			cmd_type = TYPE_L;
			cmd_bytesz = 8;
		}
	| L SP byte_size
		{
			cmd_type = TYPE_L;
			cmd_bytesz = $3;
		}
		/* this is for a bug in the BBN ftp */
	| L byte_size
		{
			cmd_type = TYPE_L;
			cmd_bytesz = $2;
		}
	;

struct_code
	: F
		{
			$$ = STRU_F;
		}
	| R
		{
			$$ = STRU_R;
		}
	| P
		{
			$$ = STRU_P;
		}
	;

mode_code
	: S
		{
			$$ = MODE_S;
		}
	| B
		{
			$$ = MODE_B;
		}
	| C
		{
			$$ = MODE_C;
		}
	;

pathname
	: pathstring
		{
			/*
			 * Problem: this production is used for all pathname
			 * processing, but only gives a 550 error reply.
			 * This is a valid reply in some cases but not in others.
			 */
			if (logged_in && $1 && strchr($1, '~') != NULL) {
				glob_t gl;
				int flags =
				 GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
				char *pptr = $1;

				/*
				 * glob() will only find a leading ~, but
				 * Netscape kindly puts a slash in front of
				 * it for publish URLs.  There needs to be
				 * a flag for glob() that expands tildes
				 * anywhere in the string.
				 */
				if ((pptr[0] == '/') && (pptr[1] == '~'))
					pptr++;

				memset(&gl, 0, sizeof(gl));
				if (glob(pptr, flags, NULL, &gl) ||
				    gl.gl_pathc == 0) {
					reply(550, "not found");
					$$ = NULL;
				} else {
					$$ = strdup(gl.gl_pathv[0]);
				}
				globfree(&gl);
				free($1);
			} else
				$$ = $1;
		}
	;

pathstring
	: STRING
	;

octal_number
	: NUMBER
		{
			int ret, dec, multby, digit;

			/*
			 * Convert a number that was read as decimal number
			 * to what it would be if it had been read as octal.
			 */
			dec = $1;
			multby = 1;
			ret = 0;
			while (dec) {
				digit = dec%10;
				if (digit > 7) {
					ret = -1;
					break;
				}
				ret += digit * multby;
				multby *= 8;
				dec /= 10;
			}
			$$ = ret;
		}
	;


check_login
	: /* empty */
		{
			if (logged_in)
				$$ = 1;
			else {
				reply(530, "Please login with USER and PASS.");
				$$ = 0;
				state = 0;
				YYABORT;
			}
		}
	;

check_login_epsvall
	: /* empty */
		{
			if (!logged_in) {
				reply(530, "Please login with USER and PASS.");
				$$ = 0;
				state = 0;
				YYABORT;
			} else if (epsvall) {
				reply(501, "the command is disallowed "
				    "after EPSV ALL");
				usedefault = 1;
				$$ = 0;
			} else
				$$ = 1;
		}
	;

%%

#define	CMD	0	/* beginning of command */
#define	ARGS	1	/* expect miscellaneous arguments */
#define	STR1	2	/* expect SP followed by STRING */
#define	STR2	3	/* expect STRING */
#define	OSTR	4	/* optional SP then STRING */
#define	ZSTR1	5	/* SP then optional STRING */
#define	ZSTR2	6	/* optional STRING after SP */
#define	SITECMD	7	/* SITE command */
#define	NSTR	8	/* Number followed by a string */

struct tab {
	char	*name;
	short	token;
	short	state;
	short	implemented;	/* 1 if command is implemented */
	char	*help;
};

struct tab cmdtab[] = {		/* In order defined in RFC 765 */
	{ "USER", USER, STR1, 1,	"<sp> username" },
	{ "PASS", PASS, ZSTR1, 1,	"<sp> password" },
	{ "ACCT", ACCT, STR1, 0,	"(specify account)" },
	{ "SMNT", SMNT, ARGS, 0,	"(structure mount)" },
	{ "REIN", REIN, ARGS, 0,	"(reinitialize server state)" },
	{ "QUIT", QUIT, ARGS, 1,	"(terminate service)", },
	{ "PORT", PORT, ARGS, 1,	"<sp> b0, b1, b2, b3, b4" },
	{ "LPRT", LPRT, ARGS, 1,	"<sp> af, hal, h1, h2, h3,..., pal, p1, p2..." },
	{ "EPRT", EPRT, STR1, 1,	"<sp> |af|addr|port|" },
	{ "PASV", PASV, ARGS, 1,	"(set server in passive mode)" },
	{ "LPSV", LPSV, ARGS, 1,	"(set server in passive mode)" },
	{ "EPSV", EPSV, ARGS, 1,	"[<sp> af|ALL]" },
	{ "TYPE", TYPE, ARGS, 1,	"<sp> [ A | E | I | L ]" },
	{ "STRU", STRU, ARGS, 1,	"(specify file structure)" },
	{ "MODE", MODE, ARGS, 1,	"(specify transfer mode)" },
	{ "RETR", RETR, STR1, 1,	"<sp> file-name" },
	{ "STOR", STOR, STR1, 1,	"<sp> file-name" },
	{ "APPE", APPE, STR1, 1,	"<sp> file-name" },
	{ "MLFL", MLFL, OSTR, 0,	"(mail file)" },
	{ "MAIL", MAIL, OSTR, 0,	"(mail to user)" },
	{ "MSND", MSND, OSTR, 0,	"(mail send to terminal)" },
	{ "MSOM", MSOM, OSTR, 0,	"(mail send to terminal or mailbox)" },
	{ "MSAM", MSAM, OSTR, 0,	"(mail send to terminal and mailbox)" },
	{ "MRSQ", MRSQ, OSTR, 0,	"(mail recipient scheme question)" },
	{ "MRCP", MRCP, STR1, 0,	"(mail recipient)" },
	{ "ALLO", ALLO, ARGS, 1,	"allocate storage (vacuously)" },
	{ "REST", REST, ARGS, 1,	"<sp> offset (restart command)" },
	{ "RNFR", RNFR, STR1, 1,	"<sp> file-name" },
	{ "RNTO", RNTO, STR1, 1,	"<sp> file-name" },
	{ "ABOR", ABOR, ARGS, 1,	"(abort operation)" },
	{ "DELE", DELE, STR1, 1,	"<sp> file-name" },
	{ "CWD",  CWD,  OSTR, 1,	"[ <sp> directory-name ]" },
	{ "XCWD", CWD,	OSTR, 1,	"[ <sp> directory-name ]" },
	{ "LIST", LIST, OSTR, 1,	"[ <sp> path-name ]" },
	{ "NLST", NLST, OSTR, 1,	"[ <sp> path-name ]" },
	{ "SITE", SITE, SITECMD, 1,	"site-cmd [ <sp> arguments ]" },
	{ "SYST", SYST, ARGS, 1,	"(get type of operating system)" },
	{ "STAT", STAT, OSTR, 1,	"[ <sp> path-name ]" },
	{ "HELP", HELP, OSTR, 1,	"[ <sp> <string> ]" },
	{ "NOOP", NOOP, ARGS, 1,	"" },
	{ "MKD",  MKD,  STR1, 1,	"<sp> path-name" },
	{ "XMKD", MKD,  STR1, 1,	"<sp> path-name" },
	{ "RMD",  RMD,  STR1, 1,	"<sp> path-name" },
	{ "XRMD", RMD,  STR1, 1,	"<sp> path-name" },
	{ "PWD",  PWD,  ARGS, 1,	"(return current directory)" },
	{ "XPWD", PWD,  ARGS, 1,	"(return current directory)" },
	{ "CDUP", CDUP, ARGS, 1,	"(change to parent directory)" },
	{ "XCUP", CDUP, ARGS, 1,	"(change to parent directory)" },
	{ "STOU", STOU, STR1, 1,	"<sp> file-name" },
	{ "SIZE", SIZE, OSTR, 1,	"<sp> path-name" },
	{ "MDTM", MDTM, OSTR, 1,	"<sp> path-name" },
	{ NULL,   0,    0,    0,	0 }
};

struct tab sitetab[] = {
	{ "UMASK", UMASK, ARGS, 1,	"[ <sp> umask ]" },
	{ "IDLE", IDLE, ARGS, 1,	"[ <sp> maximum-idle-time ]" },
	{ "CHMOD", CHMOD, NSTR, 1,	"<sp> mode <sp> file-name" },
	{ "HELP", HELP, OSTR, 1,	"[ <sp> <string> ]" },
	{ NULL,   0,    0,    0,	0 }
};

static void	 help(struct tab *, char *);
static struct tab *
		 lookup(struct tab *, char *);
static void	 sizecmd(char *);
static int	 yylex(void);

extern int epsvall;

static struct tab *
lookup(p, cmd)
	struct tab *p;
	char *cmd;
{

	for (; p->name != NULL; p++)
		if (strcmp(cmd, p->name) == 0)
			return (p);
	return (NULL);
}

#include <arpa/telnet.h>

/*
 * get_line - a hacked up version of fgets to ignore TELNET escape codes.
 */
int
get_line(s, n, iop)
	char *s;
	int n;
	FILE *iop;
{
	int c;
	char *cs;

	cs = s;
/* tmpline may contain saved command from urgent mode interruption */
	for (c = 0; tmpline[c] != '\0' && --n > 0; ++c) {
		*cs++ = tmpline[c];
		if (tmpline[c] == '\n') {
			*cs++ = '\0';
			if (debug)
				syslog(LOG_DEBUG, "command: %s", s);
			tmpline[0] = '\0';
			return(0);
		}
		if (c == 0)
			tmpline[0] = '\0';
	}
	while ((c = getc(iop)) != EOF) {
		c &= 0377;
		if (c == IAC) {
		    if ((c = getc(iop)) != EOF) {
			c &= 0377;
			switch (c) {
			case WILL:
			case WONT:
				c = getc(iop);
				printf("%c%c%c", IAC, DONT, 0377&c);
				(void) fflush(stdout);
				continue;
			case DO:
			case DONT:
				c = getc(iop);
				printf("%c%c%c", IAC, WONT, 0377&c);
				(void) fflush(stdout);
				continue;
			case IAC:
				break;
			default:
				continue;	/* ignore command */
			}
		    }
		}
		*cs++ = c;
		if (--n <= 0) {
			/*
			 * If command doesn't fit into buffer, discard the
			 * rest of the command and indicate truncation.
			 * This prevents the command to be split up into
			 * multiple commands.
			 */
			while (c != '\n' && (c = getc(iop)) != EOF)
				;
			return (-2);
		}
		if (c == '\n')
			break;
	}
	if (c == EOF && cs == s)
		return (-1);
	*cs++ = '\0';
	if (debug) {
		if (!guest && strncasecmp("pass ", s, 5) == 0) {
			/* Don't syslog passwords */
			syslog(LOG_DEBUG, "command: %.5s ???", s);
		} else {
			char *cp;
			int len;

			/* Don't syslog trailing CR-LF */
			len = strlen(s);
			cp = s + len - 1;
			while (cp >= s && (*cp == '\n' || *cp == '\r')) {
				--cp;
				--len;
			}
			syslog(LOG_DEBUG, "command: %.*s", len, s);
		}
	}
	return (0);
}

/*ARGSUSED*/
void
toolong(signo)
	int signo;
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	reply_r(421,
	    "Timeout (%d seconds): closing control connection.", timeout);
	if (logging)
		syslog_r(LOG_INFO, &sdata, "User %s timed out after %d seconds",
		    (pw ? pw -> pw_name : "unknown"), timeout);
	dologout(1);
}

static int
yylex()
{
	static int cpos;
	char *cp, *cp2;
	struct tab *p;
	int n;
	char c;

	for (;;) {
		switch (state) {

		case CMD:
			(void) alarm((unsigned) timeout);
			n = get_line(cbuf, sizeof(cbuf)-1, stdin);
			if (n == -1) {
				reply(221, "You could at least say goodbye.");
				dologout(0);
			} else if (n == -2) {
				reply(500, "Command too long.");
				alarm(0);
				continue;
			}
			(void) alarm(0);
			if ((cp = strchr(cbuf, '\r'))) {
				*cp++ = '\n';
				*cp = '\0';
			}
			if (strncasecmp(cbuf, "PASS", 4) != 0) {
				if ((cp = strpbrk(cbuf, "\n"))) {
					c = *cp;
					*cp = '\0';
					setproctitle("%s: %s", proctitle, cbuf);
					*cp = c;
				}
			}
			if ((cp = strpbrk(cbuf, " \n")))
				cpos = cp - cbuf;
			if (cpos == 0)
				cpos = 4;
			c = cbuf[cpos];
			cbuf[cpos] = '\0';
			upper(cbuf);
			p = lookup(cmdtab, cbuf);
			cbuf[cpos] = c;
			if (p != NULL) {
				if (p->implemented == 0) {
					nack(p->name);
					return (LEXERR);
				}
				state = p->state;
				yylval.s = p->name;
				return (p->token);
			}
			break;

		case SITECMD:
			if (cbuf[cpos] == ' ') {
				cpos++;
				return (SP);
			}
			cp = &cbuf[cpos];
			if ((cp2 = strpbrk(cp, " \n")))
				cpos = cp2 - cbuf;
			c = cbuf[cpos];
			cbuf[cpos] = '\0';
			upper(cp);
			p = lookup(sitetab, cp);
			cbuf[cpos] = c;
			if (p != NULL) {
				if (p->implemented == 0) {
					state = CMD;
					nack(p->name);
					return (LEXERR);
				}
				state = p->state;
				yylval.s = p->name;
				return (p->token);
			}
			state = CMD;
			break;

		case OSTR:
			if (cbuf[cpos] == '\n') {
				state = CMD;
				return (CRLF);
			}
			/* FALLTHROUGH */

		case STR1:
		case ZSTR1:
		dostr1:
			if (cbuf[cpos] == ' ') {
				cpos++;
				state = state == OSTR ? STR2 : state+1;
				return (SP);
			}
			break;

		case ZSTR2:
			if (cbuf[cpos] == '\n') {
				state = CMD;
				return (CRLF);
			}
			/* FALLTHROUGH */

		case STR2:
			cp = &cbuf[cpos];
			n = strlen(cp);
			cpos += n - 1;
			/*
			 * Make sure the string is nonempty and \n terminated.
			 */
			if (n > 1 && cbuf[cpos] == '\n') {
				cbuf[cpos] = '\0';
				yylval.s = strdup(cp);
				if (yylval.s == NULL)
					fatal("Ran out of memory.");
				cbuf[cpos] = '\n';
				state = ARGS;
				return (STRING);
			}
			break;

		case NSTR:
			if (cbuf[cpos] == ' ') {
				cpos++;
				return (SP);
			}
			if (isdigit((unsigned char)cbuf[cpos])) {
				cp = &cbuf[cpos];
				while (isdigit((unsigned char)cbuf[++cpos]))
					;
				c = cbuf[cpos];
				cbuf[cpos] = '\0';
				yylval.i = atoi(cp);
				cbuf[cpos] = c;
				state = STR1;
				return (NUMBER);
			}
			state = STR1;
			goto dostr1;

		case ARGS:
			if (isdigit((unsigned char)cbuf[cpos])) {
				long long llval;

				cp = &cbuf[cpos];
				errno = 0;
				llval = strtoll(cp, &cp2, 10);
				if (llval < 0 ||
				    (errno == ERANGE && llval == LLONG_MAX))
					break;

				cpos = (int)(cp2 - cbuf);
				if (llval > INT_MAX) {
					yylval.o = llval;
					return (BIGNUM);
				} else {
					yylval.i = (int)llval;
					return (NUMBER);
				}
			}
			if (strncasecmp(&cbuf[cpos], "ALL", 3) == 0 &&
			    !isalnum((unsigned char)cbuf[cpos + 3])) {
				cpos += 3;
				return ALL;
			}
			switch (cbuf[cpos++]) {

			case '\n':
				state = CMD;
				return (CRLF);

			case ' ':
				return (SP);

			case ',':
				return (COMMA);

			case 'A':
			case 'a':
				return (A);

			case 'B':
			case 'b':
				return (B);

			case 'C':
			case 'c':
				return (C);

			case 'E':
			case 'e':
				return (E);

			case 'F':
			case 'f':
				return (F);

			case 'I':
			case 'i':
				return (I);

			case 'L':
			case 'l':
				return (L);

			case 'N':
			case 'n':
				return (N);

			case 'P':
			case 'p':
				return (P);

			case 'R':
			case 'r':
				return (R);

			case 'S':
			case 's':
				return (S);

			case 'T':
			case 't':
				return (T);

			}
			break;

		default:
			fatal("Unknown state in scanner.");
		}
		state = CMD;
		return (LEXERR);
	}
}

void
upper(s)
	char *s;
{
	char *p;

	for (p = s; *p; p++) {
		if (islower((unsigned char)*p))
			*p = (char)toupper((unsigned char)*p);
	}
}

static void
help(ctab, s)
	struct tab *ctab;
	char *s;
{
	struct tab *c;
	int width, NCMDS;
	char *type;

	if (ctab == sitetab)
		type = "SITE ";
	else
		type = "";
	width = 0, NCMDS = 0;
	for (c = ctab; c->name != NULL; c++) {
		int len = strlen(c->name);

		if (len > width)
			width = len;
		NCMDS++;
	}
	width = (width + 8) &~ 7;
	if (s == NULL) {
		int i, j, w;
		int columns, lines;

		lreply(214, "The following %scommands are recognized %s.",
		    type, "(* =>'s unimplemented)");
		columns = 76 / width;
		if (columns == 0)
			columns = 1;
		lines = (NCMDS + columns - 1) / columns;
		for (i = 0; i < lines; i++) {
			printf("   ");
			for (j = 0; j < columns; j++) {
				c = ctab + j * lines + i;
				printf("%s%c", c->name,
					c->implemented ? ' ' : '*');
				if (c + lines >= &ctab[NCMDS])
					break;
				w = strlen(c->name) + 1;
				while (w < width) {
					putchar(' ');
					w++;
				}
			}
			printf("\r\n");
		}
		(void) fflush(stdout);
		reply(214, "Direct comments to ftp-bugs@@%s.", hostname);
		return;
	}
	upper(s);
	c = lookup(ctab, s);
	if (c == NULL) {
		reply(502, "Unknown command %s.", s);
		return;
	}
	if (c->implemented)
		reply(214, "Syntax: %s%s %s", type, c->name, c->help);
	else
		reply(214, "%s%-*s\t%s; unimplemented.", type, width,
		    c->name, c->help);
}

static void
sizecmd(filename)
	char *filename;
{
	switch (type) {
	case TYPE_L:
	case TYPE_I: {
		struct stat stbuf;
		if (stat(filename, &stbuf) < 0 || !S_ISREG(stbuf.st_mode))
			reply(550, "%s: not a plain file.", filename);
		else
			reply(213, "%lld", (long long)stbuf.st_size);
		break; }
	case TYPE_A: {
		FILE *fin;
		int c;
		off_t count;
		struct stat stbuf;
		fin = fopen(filename, "r");
		if (fin == NULL) {
			perror_reply(550, filename);
			return;
		}
		if (fstat(fileno(fin), &stbuf) < 0 || !S_ISREG(stbuf.st_mode)) {
			reply(550, "%s: not a plain file.", filename);
			(void) fclose(fin);
			return;
		}
		if (stbuf.st_size > 10240) {
			reply(550, "%s: file too large for SIZE.", filename);
			(void) fclose(fin);
			return;
		}

		count = 0;
		while((c = getc(fin)) != EOF) {
			if (c == '\n')	/* will get expanded to \r\n */
				count++;
			count++;
		}
		(void) fclose(fin);

		reply(213, "%lld", (long long)count);
		break; }
	default:
		reply(504, "SIZE not implemented for Type %c.", "?AEIL"[type]);
	}
}
@


1.65
log
@memset() of password field should be explicit_bzero().
[Not using freezero() in yacc files yet]
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.64 2016/08/26 06:32:10 tedu Exp $	*/
d959 2
d971 2
@


1.64
log
@trim down some NBBY references. 8 bits ought to be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.63 2016/08/14 22:56:29 guenther Exp $	*/
d160 1
a160 1
			memset($3, 0, strlen($3));
@


1.63
log
@Convert %q to %ll with long long casts for printf()
Delete pointless casts to off_t, void*, and uid_t

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.62 2015/11/16 17:31:14 tedu Exp $	*/
d577 1
a577 1
			reply(215, "UNIX Type: L%d", NBBY);
d836 1
a836 1
			cmd_bytesz = NBBY;
@


1.62
log
@don't need to ifdef setproctitle
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.61 2015/10/25 22:13:39 tedu Exp $	*/
d146 1
a146 1
			restart_point = (off_t) 0;
d641 1
a641 1
			restart_point = (off_t) 0;
@


1.61
log
@unifdef some oldness. (BSD not defined since removal of param.h)
ok jca sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.59 2015/03/17 19:31:30 millert Exp $	*/
a1216 1
#ifdef HASSETPROCTITLE
a1224 1
#endif /* HASSETPROCTITLE */
@


1.60
log
@calloc() is prototyped; do not cast result
@
text
@a576 5
#ifdef unix
#ifdef BSD
			reply(215, "UNIX Type: L%d Version: BSD-%d",
				NBBY, BSD);
#else /* BSD */
a577 4
#endif /* BSD */
#else /* unix */
			reply(215, "UNKNOWN Type: L%d", NBBY);
#endif /* unix */
@


1.59
log
@Eliminate use of TM_YEAR_BASE.  OK guenther@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.58 2015/03/15 00:41:27 millert Exp $	*/
d684 1
a684 1
			$$ = (char *)calloc(1, sizeof(char));
@


1.58
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.57 2015/01/16 06:39:50 deraadt Exp $	*/
d627 1
a627 1
					    TM_YEAR_BASE + t->tm_year,
@


1.57
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.56 2014/02/08 13:31:51 millert Exp $	*/
a53 1
#include <tzfile.h>
@


1.56
log
@Fix REST (restart transfer) for offsets large than 2GB.  OK okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.55 2013/11/27 21:25:25 deraadt Exp $	*/
d42 1
a42 1
#include <sys/param.h>
@


1.55
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.54 2012/03/04 04:05:15 fgsch Exp $	*/
d62 1
d101 1
d127 1
d131 2
a133 1
%type	<i> host_port host_long_port4 host_long_port6
d663 1
a663 1
	| REST check_login SP byte_size CRLF
d670 3
a672 3
				restart_point = $4;	/* XXX $4 is only "int" */
				reply(350, "Restarting at %qd. %s",
				    restart_point,
d694 11
d1346 2
d1349 14
a1362 7
				while (isdigit((unsigned char)cbuf[++cpos]))
					;
				c = cbuf[cpos];
				cbuf[cpos] = '\0';
				yylval.i = atoi(cp);
				cbuf[cpos] = c;
				return (NUMBER);
d1528 1
a1528 1
			reply(213, "%qu", stbuf.st_size);
d1559 1
a1559 1
		reply(213, "%qd", count);
@


1.54
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.53 2009/10/27 23:59:31 deraadt Exp $	*/
d1315 1
a1315 1
			if (isdigit(cbuf[cpos])) {
d1317 1
a1317 1
				while (isdigit(cbuf[++cpos]))
d1330 1
a1330 1
			if (isdigit(cbuf[cpos])) {
d1332 1
a1332 1
				while (isdigit(cbuf[++cpos]))
d1341 1
a1341 1
			    !isalnum(cbuf[cpos + 3])) {
d1423 2
a1424 2
		if (islower(*p))
			*p = (char)toupper(*p);
@


1.53
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.52 2008/09/13 12:04:49 moritz Exp $	*/
d1080 1
a1080 1
 * getline - a hacked up version of fgets to ignore TELNET escape codes.
d1083 1
a1083 1
getline(s, n, iop)
d1198 1
a1198 1
			n = getline(cbuf, sizeof(cbuf)-1, stdin);
@


1.52
log
@Fix minor bug in the previous commit, which could hang the
current session, when the last character of an overly long line
was a newline character. Additionally reply with
500 "Command too long" for commands, which are too large.

Issue found and proposed fix by Luke Mewburn <lukem@@NetBSD.org>.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.51 2008/09/12 16:12:08 moritz Exp $	*/
a40 9

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ftpcmd.y	8.3 (Berkeley) 4/6/94";
#else
static const char rcsid[] =
    "$OpenBSD: ftpcmd.y,v 1.51 2008/09/12 16:12:08 moritz Exp $";
#endif
#endif /* not lint */
@


1.51
log
@Don't split large commands into multiple commands on a 512-byte
boundary but just fail on them. This prevents CSRF-like attacks,
when a web browser is used to access an ftp server.

Reported by Maksymilian Arciemowicz <cxib@@securityreason.com>.

ok millert@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.50 2008/06/30 12:03:51 ragge Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.50 2008/06/30 12:03:51 ragge Exp $";
d1147 1
a1147 1
			while ((c = getc(iop)) != EOF && c != '\n')
d1212 3
a1214 2
				/* Ignore truncated command */
				break;
@


1.50
log
@Include file order must be "monitor.h" before "extern.h" otherwise enum
auth_ret is referenced before it is declared, which is not allowed by C99.

Ok krw@@, millert@@, gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.49 2006/04/21 17:42:50 deraadt Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.49 2006/04/21 17:42:50 deraadt Exp $";
d1091 1
a1091 1
char *
d1109 1
a1109 1
			return(s);
d1140 12
a1151 1
		if (--n <= 0 || c == '\n')
d1155 1
a1155 1
		return (NULL);
d1175 1
a1175 1
	return (s);
d1207 2
a1208 1
			if (getline(cbuf, sizeof(cbuf)-1, stdin) == NULL) {
d1211 3
@


1.49
log
@lint cleanup; ok ray moritz dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.48 2004/12/11 08:38:26 moritz Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.48 2004/12/11 08:38:26 moritz Exp $";
d72 1
a73 1
#include "monitor.h"
@


1.48
log
@make syscalls in the monitor restartable when signals occur, as was
the case before privsep and only wait() for our slave processes.
with help from millert@@

ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.47 2004/12/06 23:04:14 deraadt Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.47 2004/12/06 23:04:14 deraadt Exp $";
d502 1
a502 1
			int oldmask;
d512 1
a512 1
			int oldmask;
d729 5
a733 5
			if ($1 != 4 || $3 != 4
			 || $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255
			 || $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255
			 || $13 != 2
			 || $15 < 0 || $15 > 255 || $17 < 0 || $17 > 255) {
d759 11
a769 11
			if ($1 != 6 || $3 != 16
			 || $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255
			 || $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255
			 || $13 < 0 || $13 > 255 || $15 < 0 || $15 > 255
			 || $17 < 0 || $17 > 255 || $19 < 0 || $19 > 255
			 || $21 < 0 || $21 > 255 || $23 < 0 || $23 > 255
			 || $25 < 0 || $25 > 255 || $27 < 0 || $27 > 255
			 || $29 < 0 || $29 > 255 || $31 < 0 || $31 > 255
			 || $33 < 0 || $33 > 255 || $35 < 0 || $35 > 255
			 || $37 != 2
			 || $39 < 0 || $39 > 255 || $41 < 0 || $41 > 255) {
d1167 1
d1333 2
a1334 2
			if (strncasecmp(&cbuf[cpos], "ALL", 3) == 0
			 && !isalnum(cbuf[cpos + 3])) {
d1417 1
a1417 1
			*p = toupper(*p);
@


1.47
log
@seperate reply_r, like earlier change but safer; moritz ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.45 2004/12/03 23:57:40 moritz Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.45 2004/12/03 23:57:40 moritz Exp $";
d171 1
a171 1
				_exit(PREAUTH_SLAVE_DIED);
@


1.46
log
@reply() used to play a lot with stdout, expecially fflush(stdout).
The recent change is to avoid stdio.  That's good, except there are
nearly 130 calls to this function, yet what if one of them depended on
fflush() or something else in this code?  The semantic change was
never checked.  That is not how we do development -- back this out
until we know that checking work has been done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.44 2004/11/28 18:49:29 henning Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.44 2004/11/28 18:49:29 henning Exp $";
d1173 1
a1173 2
	/* XXX signal races */
	reply(421,
@


1.45
log
@make reply() reentrant. fixes a signal race.
ok henning@@
@
text
@d1173 1
@


1.44
log
@privilege seperate ftpd
handle the pre-authentication phase (minus a tiny tiny tiny amount
of code after accept()) in an unprivileged process, asking the
privileged monitor for help where needed.
work by Moritz Jodeit <moritz@@jodeit.org> with help from theo and me
tests theo ian@@ matthieu@@ ben@@networkinsanity.com a.schlichting@@lemarit.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.43 2003/12/10 22:57:12 deraadt Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.43 2003/12/10 22:57:12 deraadt Exp $";
a1172 1
	/* XXX signal races */
@


1.43
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.42 2003/06/02 19:38:24 millert Exp $	*/
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.42 2003/06/02 19:38:24 millert Exp $";
d73 1
d101 1
d160 1
a160 1
			user($3);
d165 1
a165 1
			pass($3);
d168 4
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.41 2002/07/02 18:09:53 danh Exp $	*/
d46 2
a47 2
static const char rcsid[] = 
    "$OpenBSD: ftpcmd.y,v 1.41 2002/07/02 18:09:53 danh Exp $";
d172 1
a172 1
					reply(500,	
d285 1
a285 1
	
d293 3
a295 3
					       reply(200,
					       "Type set to L (byte size 8).");
					       type = cmd_type;
d297 1
a297 1
					    reply(504, "Byte size must be 8.");
d413 1
a413 1
					reply(503, 
d422 1
a422 1
			if ($2) 
d545 4
a548 3
			  reply(200,
	       		    "Current IDLE time limit is %d seconds; max %d",
				timeout, maxtimeout);
d554 4
a557 4
				reply(501,
				    "Maximum IDLE time must be between "
				    "30 and %d seconds",
				    maxtimeout);
d652 1
a652 1
				if (fromname)  
d665 8
a672 7
			    if (fromname) {
				    free(fromname);
				    fromname = NULL;
			    }
			    restart_point = $4;	/* XXX $4 is only "int" */
			    reply(350, "Restarting at %qd. %s", restart_point,
			       "Send STORE or RETRIEVE to initiate transfer.");
@


1.41
log
@* use lostconn() as the SIGALRM handler in receive_data() as originally
  done by downsj@@ in revision 1.54.

* some -Wall cleanup
  - only declare check_host() if TCPWRAPPERS is defined.
  - use socklen_t where appropriate instead of int (pointer signedness
    warnings).
  - {u_}char * pointer signedness warnings.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.40 2002/06/17 19:33:37 danh Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d47 1
a47 1
    "$OpenBSD: ftpcmd.y,v 1.40 2002/06/17 19:33:37 danh Exp $";
@


1.40
log
@Initialize SIGALRM handler once in main(), instead of in several
different locations.

This fixes a problem where the SIGALRM handler was being set to an
uninitialized pointer in receive_data().  Originally reported to the
misc@@ list by Colin Harford.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.39 2002/02/19 17:58:24 mpech Exp $	*/
d48 1
a48 1
static char sccsid[] = "@@(#)ftpcmd.y	8.3 (Berkeley) 4/6/94";
d50 2
a51 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.39 2002/02/19 17:58:24 mpech Exp $";
@


1.39
log
@Rewrite upper().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.38 2002/02/16 21:27:29 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.38 2002/02/16 21:27:29 millert Exp $";
a1189 1
			(void) signal(SIGALRM, toolong);
@


1.38
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.37 2002/01/30 18:01:46 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.37 2002/01/30 18:01:46 mpech Exp $";
d1409 5
a1413 4
	while (*s != '\0') {
		if (islower(*s))
			*s = toupper(*s);
		s++;
@


1.37
log
@Fix leak in `EPSV ALL`.
Since now ``ALL'' should be treated like CRLF, COMMA, etc.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.36 2002/01/30 17:14:29 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.36 2002/01/30 17:14:29 mpech Exp $";
d1061 1
a1061 1
static void	 help __P((struct tab *, char *));
d1063 3
a1065 3
		 lookup __P((struct tab *, char *));
static void	 sizecmd __P((char *));
static int	 yylex __P((void));
@


1.36
log
@protect `RNTO` from NULL pointer.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.35 2002/01/25 06:43:37 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.35 2002/01/25 06:43:37 mpech Exp $";
a115 1
	ALL
d117 1
a117 1
	SP	CRLF	COMMA
a133 1
%token	<s> ALL
a1330 1
				yylval.s = strdup("ALL");
@


1.35
log
@s is pointer. 0 -> NULL.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.33 2002/01/23 16:38:12 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.33 2002/01/23 16:38:12 mpech Exp $";
d412 1
a412 1
			if ($2) {
@


1.34
log
@Catch not valid chmod value earlier. This make sense, before we didn't
handle some situations and pass value to chmod() instead of fatal.
Idea stolen from `SITE UMASK` handler.

millert@@ ok
@
text
@d1441 1
a1441 1
	if (s == 0) {
@


1.33
log
@lookup() returns pointer. Convert 0 -> NULL.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.32 2002/01/23 10:28:50 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.32 2002/01/23 10:28:50 mpech Exp $";
d530 1
a530 1
				if ($6 > 0777)
@


1.32
log
@``pathname'' can be NULL here too.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.31 2002/01/17 05:27:35 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.31 2002/01/17 05:27:35 itojun Exp $";
d1080 1
a1080 1
	return (0);
d1222 1
a1222 1
			if (p != 0) {
d1246 1
a1246 1
			if (p != 0) {
d1473 1
a1473 1
	if (c == (struct tab *)0) {
@


1.31
log
@reject SIZE request for ascii mode if file is larger than 10k.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.30 2002/01/08 01:55:27 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.30 2002/01/08 01:55:27 millert Exp $";
d422 2
a423 1
			free($4);
@


1.30
log
@Close potential memory leak wrt "fromname"; inspired by similar FreeBSD
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.29 2002/01/08 01:52:00 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.29 2002/01/08 01:52:00 millert Exp $";
d1511 5
d1518 1
a1518 1
		while((c=getc(fin)) != EOF) {
@


1.29
log
@STRING is never NULL so there is no need to test it for NULL before
freeing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.28 2001/12/28 17:38:17 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.28 2001/12/28 17:38:17 millert Exp $";
d151 4
a154 1
			fromname = (char *) 0;
a652 2
			char *renamefrom();

d655 2
d658 1
a658 1
				if (fromname == NULL && $4) {
d660 2
a661 4
				}
			} else {
				if ($4)
					free ($4);
d668 4
a671 1
			    fromname = NULL;
@


1.28
log
@Fix memory leak with EPRT command; Hiroyuki YAMAMORI
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.27 2001/12/07 18:45:32 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.27 2001/12/07 18:45:32 mpech Exp $";
d240 1
a240 2
			if ($4 != NULL)
				free($4);
d374 1
a374 2
			if ($4 != NULL)
				free($4);
d456 1
a456 3

			if ($3 != NULL)
				free ($3);
d493 1
a493 3

			if ($5 != NULL)
				free ($5);
@


1.27
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.26 2001/12/04 21:18:04 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.26 2001/12/04 21:18:04 millert Exp $";
d240 2
@


1.26
log
@Kill setjmp/longjmp
 o fix error recovery in the parser so there is no longer a need for jmping
 o make SIGURG handler interupt syscalls and just set a flag that we test
   for later.

Use waitpid() not wait3() for portability.  Restart waitpid() loop
if another signal interrupts us.

Calling dologout() from signal handlers is safe because it doesn't
use stdio, nor do the two functions it calls (logout and ftpdlogwtmp).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.25 2001/11/05 09:51:13 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.25 2001/11/05 09:51:13 deraadt Exp $";
d1094 1
a1094 1
	register char *cs;
d1147 2
a1148 2
			register char *cp;
			register int len;
@


1.25
log
@more signal marks, and some syslog_r in handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.24 2000/11/14 20:27:01 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.24 2000/11/14 20:27:01 itojun Exp $";
a64 1
#include <setjmp.h>
d102 1
d644 1
a644 1
	| error CRLF
d646 3
a648 1
			yyerrok;
a980 2
extern jmp_buf errcatch;

d1181 1
a1181 1
	static int cpos, state;
d1224 1
a1224 2
					longjmp(errcatch,0);
					/* NOTREACHED */
d1249 1
a1249 2
					longjmp(errcatch,0);
					/* NOTREACHED */
a1401 1
		yyerror((char *) 0);
d1403 1
a1403 1
		longjmp(errcatch,0);
@


1.24
log
@cleanup EPSV/EPRT error handling.  avoid possible memory leak (getaddrinfo).
correct error code on unsupported protocol parameter against EPRT (522).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.23 2000/11/13 16:14:44 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.23 2000/11/13 16:14:44 itojun Exp $";
d1167 1
d1169 1
d1173 1
a1173 1
		syslog(LOG_INFO, "User %s timed out after %d seconds",
@


1.23
log
@combine check_epsvall + check_login into check_login_epsvall.
we cnanot split check_login and check_epsvall.  if we do that, we end up
generating two results against single comand.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.22 2000/11/13 15:39:08 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.22 2000/11/13 15:39:08 itojun Exp $";
d238 2
a239 87
			char *tmp = NULL;
			char *result[3];
			char *p, *q;
			char delim;
			struct addrinfo hints;
			struct addrinfo *res;
			int i;

			if ($2) { /* XXX indentation */

			if (epsvall) {
				reply(501, "EPRT disallowed after EPSV ALL");
				goto eprt_done;
			}
			usedefault = 0;
			if (pdata >= 0) {
				(void) close(pdata);
				pdata = -1;
			}

			/*XXX checks for login */

			tmp = strdup($4);
			if (!tmp) {
				fatal("not enough core.");
				/*NOTREACHED*/
			}
			p = tmp;
			delim = p[0];
			p++;
			memset(result, 0, sizeof(result));
			for (i = 0; i < 3; i++) {
				q = strchr(p, delim);
				if (!q || *q != delim) {
		parsefail:
					reply(500, "Invalid argument, rejected.");
					if (tmp)
						free(tmp);
					usedefault = 1;
					goto eprt_done;
				}
				*q++ = '\0';
				result[i] = p;
				p = q;
			}

			/* some more sanity check */
			p = result[0];
			while (*p) {
				if (!isdigit(*p))
					goto parsefail;
				p++;
			}
			p = result[2];
			while (*p) {
				if (!isdigit(*p))
					goto parsefail;
				p++;
			}

			memset(&hints, 0, sizeof(hints));
			if (atoi(result[0]) == 1)
				hints.ai_family = PF_INET;
			if (atoi(result[0]) == 2)
				hints.ai_family = PF_INET6;
			else
				hints.ai_family = PF_UNSPEC;	/*XXX*/
			hints.ai_socktype = SOCK_STREAM;
			if (getaddrinfo(result[1], result[2], &hints, &res))
				goto parsefail;
			memcpy(&data_dest, res->ai_addr, res->ai_addrlen);
			if (his_addr.su_family == AF_INET6 &&
			    data_dest.su_family == AF_INET6) {
				/* XXX more sanity checks! */
				data_dest.su_sin6.sin6_scope_id =
				    his_addr.su_sin6.sin6_scope_id;
			}
			free(tmp);
			tmp = NULL;
			if (pdata >= 0) {
				(void) close(pdata);
				pdata = -1;
			}
			reply(200, "EPRT command successful.");
		eprt_done:;

			}
d254 2
a255 15
			int pf;
			if ($2) {
				switch ($4) {
				case 1:
					pf = PF_INET;
					break;
				case 2:
					pf = PF_INET6;
					break;
				default:
					pf = -1;	/*junk*/
					break;
				}
				long_passive("EPSV", pf);
			}
@


1.22
log
@make sure to check_login on EPSV/LPSV.  move epvsall check into check_epsvall.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.21 2000/06/17 19:42:18 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.21 2000/06/17 19:42:18 deraadt Exp $";
d138 1
a138 1
%type	<i> check_login check_epsvall octal_number byte_size
d169 1
a169 1
	| PORT check_login check_epsvall SP host_port CRLF
d171 2
a172 2
			if ($2 && $3) {
				if ($5) {
d198 1
a198 1
	| LPRT check_login check_epsvall SP host_long_port4 CRLF
d200 1
a200 1
			if ($2 && $3) {
d202 1
a202 1
				if ($5) {
d217 1
a217 1
	| LPRT check_login check_epsvall SP host_long_port6 CRLF
d219 1
a219 1
			if ($2 && $3) {
d221 1
a221 1
				if ($5) {
d236 1
a236 1
	| EPRT check_login check_epsvall SP STRING CRLF
d246 1
a246 1
			if ($2 && $3) { /* XXX indentation */
d260 1
a260 1
			tmp = strdup($5);
d327 1
a327 1
	| PASV check_login check_epsvall CRLF
d329 1
a329 1
			if ($2 && $3)
d332 1
a332 1
	| LPSV check_login check_epsvall CRLF
d334 1
a334 1
			if ($2 && $3)
d1059 1
a1059 1
check_epsvall
d1062 4
a1065 1
			if (epsvall) {
@


1.21
log
@pr 772; -u blocks chmod command, michaels@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.20 2000/04/29 14:03:02 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.20 2000/04/29 14:03:02 deraadt Exp $";
d138 1
a138 1
%type	<i> check_login octal_number byte_size
d169 1
a169 1
	| PORT check_login SP host_port CRLF
d171 2
a172 2
			if ($2) {
				if ($4) {
d198 1
a198 1
	| LPRT check_login SP host_long_port4 CRLF
d200 13
a212 12
			/* reject invalid host_long_port4 */
			if ($4) {
				reply(500, "Illegal LPRT command rejected");
				usedefault = 1;
			} else if (epsvall) {
				reply(501, "LPRT disallowed after EPSV ALL");
				usedefault = 1;
			} else {
				usedefault = 0;
				if (pdata >= 0) {
					(void) close(pdata);
					pdata = -1;
a213 1
				reply(200, "LPRT command successful.");
d217 1
a217 1
	| LPRT check_login SP host_long_port6 CRLF
d219 13
a231 12
			/* reject invalid host_long_port6 */
			if ($4) {
				reply(500, "Illegal LPRT command rejected");
				usedefault = 1;
			} else if (epsvall) {
				reply(501, "LPRT disallowed after EPSV ALL");
				usedefault = 1;
			} else {
				usedefault = 0;
				if (pdata >= 0) {
					(void) close(pdata);
					pdata = -1;
a232 1
				reply(200, "LPRT command successful.");
d236 1
a236 1
	| EPRT check_login SP STRING CRLF
d246 2
d260 1
a260 1
			tmp = strdup($4);
d323 2
d327 1
a327 1
	| PASV check_login CRLF
d329 1
a329 1
			if ($2) {
a330 1
			}
d332 1
a332 1
	| LPSV CRLF
d334 1
a334 3
			if (epsvall)
				reply(501, "LPSV disallowed after EPSV ALL");
			else
d337 1
a337 1
	| EPSV SP NUMBER CRLF
d340 18
a357 19
			switch ($3) {
			case 1:
				pf = PF_INET;
				break;
			case 2:
				pf = PF_INET6;
				break;
			default:
				pf = -1;	/*junk*/
				break;
			}
			long_passive("EPSV", pf);
		}
	| EPSV SP ALL CRLF
		{
			if (!logged_in) {
				syslog(LOG_NOTICE, "long passive but not logged in");
				reply(503, "Login with USER first.");
			} else {
d362 1
a362 1
	| EPSV CRLF
d364 2
a365 1
			long_passive("EPSV", PF_UNSPEC);
d1056 13
@


1.20
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.19 2000/01/15 05:10:55 ericj Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.19 2000/01/15 05:10:55 ericj Exp $";
d96 1
d613 3
d629 6
a634 1
				"CHMOD: Mode value must be between 0 and 0777");
d638 2
a639 1
					reply(200, "CHMOD command successful.");
d656 2
a657 1
	       		 "Maximum IDLE time must be between 30 and %d seconds",
d663 1
a663 1
					 "Maximum IDLE time set to %d seconds",
@


1.19
log
@(char *)0 -> NULL cleanup. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.18 1999/12/08 13:15:21 itojun Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.18 1999/12/08 13:15:21 itojun Exp $";
d306 2
a307 2
			if (his_addr.su_family == AF_INET6
			 && data_dest.su_family == AF_INET6) {
d310 1
a310 1
					his_addr.su_sin6.sin6_scope_id;
d869 1
a869 1
						his_addr.su_sin6.sin6_scope_id;
@


1.18
log
@IPv6 support from KAME.
XXX kerberos and tcp_wrapper needs checking
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.17 1999/10/08 14:40:35 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.17 1999/10/08 14:40:35 deraadt Exp $";
d442 1
a442 1
				retrieve((char *) 0, $4);
d509 1
a509 1
					fromname = (char *) 0;
d536 1
a536 1
			help(cmdtab, (char *) 0);
d549 1
a549 1
					help(sitetab, (char *) 0);
d586 1
a586 1
			help(sitetab, (char *) 0);
d743 1
a743 1
				if (fromname == (char *) 0 && $4) {
d755 1
a755 1
			    fromname = (char *) 0;
d1271 1
a1271 1
			if (strncasecmp(cbuf, "PASS", 4) != NULL) {
@


1.17
log
@correct; dholland@@hcs.harvard.edu, root@@zen.ics.uwe.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.16 1998/05/22 06:46:09 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.16 1998/05/22 06:46:09 deraadt Exp $";
d74 1
d78 1
a78 1
extern	struct sockaddr_in data_dest;
d95 1
a95 1
extern	struct sockaddr_in his_addr;
d115 1
d127 2
d134 1
d140 1
a140 1
%type	<i> host_port
d176 1
a176 1
				    ntohs(data_dest.sin_port) < IPPORT_RESERVED) {
d181 3
a183 3
				    memcmp(&data_dest.sin_addr,
				    &his_addr.sin_addr,
				    sizeof data_dest.sin_addr)) {
d197 125
d328 37
d790 3
a792 3
				data_dest.sin_len = sizeof(struct sockaddr_in);
				data_dest.sin_family = AF_INET;
				p = (char *)&data_dest.sin_port;
d794 1
a794 1
				a = (char *)&data_dest.sin_addr;
d801 76
d1077 2
d1080 2
d1138 2
d1399 6
@


1.16
log
@use TM_YEAR_BASE; lukem
@
text
@d1 1
a1 1
/*	$OpenBSD: ftpcmd.y,v 1.15 1998/02/03 22:21:21 downsj Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ftpcmd.y,v 1.15 1998/02/03 22:21:21 downsj Exp $";
d1091 1
a1091 1
				state = state == OSTR ? STR2 : ++state;
@


1.15
log
@Work around a glob() and Netscape problem; the local glob() hacker may
want to read the commentary if he wants another project.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD$";
d67 1
d550 1
a550 1
					    1900 + t->tm_year,
@


1.14
log
@Be so specific about the exact details of a PORT command error, that we
strike fear into the hearts of attackers (naw, I bet not...)
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: ftpcmd.y,v 1.7 1996/04/08 19:03:11 jtc Exp $";
d729 1
a729 1
			if (logged_in && $1 && *$1 == '~') {
d733 11
d746 1
a746 1
				if (glob($1, flags, NULL, &gl) ||
@


1.13
log
@bitch if attacker tries to make PORT values overflow each other (they cannot anyways, but let him know we are onto him)
@
text
@d164 10
a173 2
				if ($4 || (portcheck && (ntohs(data_dest.sin_port) <
				    IPPORT_RESERVED ||
d176 1
a176 1
				    sizeof data_dest.sin_addr)))) {
d178 2
a179 1
					reply(500, "Illegal PORT rejected.");
@


1.12
log
@default to violating the RFC wrt the PORT command. Use -P to conform to the
RFC and possibly open up non-OpenBSD boxes in a trust relationship on your
network to possible ftp bounce attacks...
@
text
@d133 1
d164 1
a164 1
				if (portcheck && (ntohs(data_dest.sin_port) <
d168 1
a168 1
				    sizeof data_dest.sin_addr))) {
d607 13
a619 6
			data_dest.sin_len = sizeof(struct sockaddr_in);
			data_dest.sin_family = AF_INET;
			p = (char *)&data_dest.sin_port;
			p[0] = $9; p[1] = $11;
			a = (char *)&data_dest.sin_addr;
			a[0] = $1; a[1] = $3; a[2] = $5; a[3] = $7;
@


1.11
log
@tabify
@
text
@d91 2
d163 14
a176 4
				usedefault = 0;
				if (pdata >= 0) {
					(void) close(pdata);
					pdata = -1;
a177 1
				reply(200, "PORT command successful.");
@


1.10
log
@setproctitle less
@
text
@d322 1
a322 1
                                          "Bad sequence of commands.");
d363 2
a364 2
		        if ($3 != NULL)
		        	free ($3);
d462 1
a462 1
				         "Maximum IDLE time set to %d seconds",
d557 1
a557 1
                        	if ($4)
@


1.9
log
@Fix for the shift-reduce conflict, contributed by dholland@@hcs.harvard.edu,
who is porting the OpenBSD ftpd to (of all things) Linux.
@
text
@d988 1
a988 2
			} else
				setproctitle("%s: %s", proctitle, cbuf);
@


1.8
log
@ftpd now eventually times out if a ftp client does:
pasv
list
and then crashes.
The timeout should only apply the the accept(), so that transfers can
take as long as necessary to complete.
Thanks to Theo for moving toolong() to extern.h so that it can be used
in ftpd.c as well as in ftpcmd.y.
@
text
@d451 1
a451 1
	| SITE SP IDLE check_login SP NUMBER CRLF
d453 1
a453 1
			if ($4) {
@


1.7
log
@Fixed a memory leak associated with the HELP and SITE HELP commands.
@
text
@a847 1
static void	 toolong __P((int));
d943 1
a943 1
static void
@


1.6
log
@reduced the number of command availibe to users who are not logged
in, fixed a memory leak in RNFR
@
text
@d362 3
d401 3
@


1.5
log
@clear passwd, for safety
@
text
@d158 1
a158 1
	| PORT SP host_port CRLF
d160 7
a166 4
			usedefault = 0;
			if (pdata >= 0) {
				(void) close(pdata);
				pdata = -1;
a167 1
			reply(200, "PORT command successful.");
d169 1
a169 1
	| PASV CRLF
d171 3
a173 1
			passive();
d175 1
a175 1
	| TYPE SP type_code CRLF
d177 2
a178 1
			switch (cmd_type) {
d180 15
a194 3
			case TYPE_A:
				if (cmd_form == FORM_N) {
					reply(200, "Type set to A.");
d196 11
a206 25
					form = cmd_form;
				} else
					reply(504, "Form must be N.");
				break;

			case TYPE_E:
				reply(504, "Type E not implemented.");
				break;

			case TYPE_I:
				reply(200, "Type set to I.");
				type = cmd_type;
				break;

			case TYPE_L:
#if NBBY == 8
				if (cmd_bytesz == 8) {
					reply(200,
					    "Type set to L (byte size 8).");
					type = cmd_type;
				} else
					reply(504, "Byte size must be 8.");
#else /* NBBY == 8 */
				UNIMPLEMENTED for NBBY != 8
#endif /* NBBY == 8 */
d209 1
a209 1
	| STRU SP struct_code CRLF
d211 2
a212 1
			switch ($3) {
d214 3
a216 3
			case STRU_F:
				reply(200, "STRU F ok.");
				break;
d218 3
a220 2
			default:
				reply(504, "Unimplemented STRU type.");
d223 1
a223 1
	| MODE SP mode_code CRLF
d225 2
a226 1
			switch ($3) {
d228 3
a230 3
			case MODE_S:
				reply(200, "MODE S ok.");
				break;
d232 3
a234 2
			default:
				reply(502, "Unimplemented MODE type.");
d237 1
a237 1
	| ALLO SP NUMBER CRLF
d239 3
a241 1
			reply(202, "ALLO command ignored.");
d243 1
a243 1
	| ALLO SP NUMBER SP R SP NUMBER CRLF
d245 3
a247 1
			reply(202, "ALLO command ignored.");
d301 1
a301 1
	| STAT CRLF
d303 2
a304 1
			statcmd();
d313 1
a313 1
	| RNTO SP pathname CRLF
d315 9
a323 6
			if (fromname) {
				renamecmd(fromname, $3);
				free(fromname);
				fromname = (char *) 0;
			} else {
				reply(503, "Bad sequence of commands.");
d325 1
a325 1
			free($3);
d327 1
a327 1
	| ABOR CRLF
d329 2
a330 1
			reply(225, "ABOR command successful.");
d438 1
a438 1
	| SITE SP IDLE CRLF
d440 3
a442 2
			reply(200,
			    "Current IDLE time limit is %d seconds; max %d",
d445 1
a445 1
	| SITE SP IDLE SP NUMBER CRLF
d447 2
a448 1
			if ($5 < 30 || $5 > maxtimeout) {
d450 1
a450 1
			"Maximum IDLE time must be between 30 and %d seconds",
d452 7
a458 6
			} else {
				timeout = $5;
				(void) alarm((unsigned) timeout);
				reply(200,
				    "Maximum IDLE time set to %d seconds",
				    timeout);
d468 1
a468 1
	| SYST CRLF
d470 1
d550 3
d555 2
a556 1
	| REST SP byte_size CRLF
d558 6
a563 4
			fromname = (char *) 0;
			restart_point = $3;	/* XXX $3 is only "int" */
			reply(350, "Restarting at %qd. %s", restart_point,
			    "Send STORE or RETRIEVE to initiate transfer.");
@


1.4
log
@de-gibble ftpd for w
@
text
@d155 1
@


1.3
log
@strcpy -> strncpy, kill off a strdup() clone.
@
text
@a943 4
#ifdef HASSETPROCTITLE
			if (strncasecmp(cbuf, "PASS", 4) != NULL)
				setproctitle("%s: %s", proctitle, cbuf);
#endif /* HASSETPROCTITLE */
d948 11
@


1.2
log
@sync with netbsd 960418
@
text
@a810 1
static char	*copy __P((char *));
d1033 3
a1035 1
				yylval.s = copy(cp);
a1152 13
}

static char *
copy(s)
	char *s;
{
	char *p;

	p = malloc((unsigned) strlen(s) + 1);
	if (p == NULL)
		fatal("Ran out of memory.");
	(void) strcpy(p, s);
	return (p);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ftpcmd.y,v 1.6 1995/06/03 22:46:45 mycroft Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: ftpcmd.y,v 1.6 1995/06/03 22:46:45 mycroft Exp $";
d499 3
a501 2
					    "19%02d%02d%02d%02d%02d%02d",
					    t->tm_year, t->tm_mon+1, t->tm_mday,
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
