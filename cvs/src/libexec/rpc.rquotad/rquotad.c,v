head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.42
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.40
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.36
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.34
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.32
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.30
	OPENBSD_5_0:1.20.0.28
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.26
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.24
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.20
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.22
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.18
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.16
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.14
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.12
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.10
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.8
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.10.08.04.29.16;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Udt1w0dzs1fJElqn;

1.20
date	2004.09.14.23.49.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.02.02.21.15;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.05.17.02.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.20.03.43.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.17.42.16;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.09.04.18.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.11.15.18.51;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.12.07.15.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.17.19.23.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.19.01.56.05;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	99.08.17.09.13.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.13.02.11.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.11.05.19.09.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.20.36.31;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.17.07.12.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: rquotad.c,v 1.21 2014/10/08 04:29:16 deraadt Exp $	*/

/*
 * by Manuel Bouyer (bouyer@@ensta.fr). Public domain.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <signal.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <fstab.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <ufs/ufs/quota.h>
#include <rpc/rpc.h>
#include <rpcsvc/rquota.h>
#include <arpa/inet.h>

void rquota_service(struct svc_req *request, SVCXPRT *transp);
void sendquota(struct svc_req *request, SVCXPRT *transp);
void printerr_reply(SVCXPRT *transp);
void initfs(void);
int getfsquota(long id, char *path, struct dqblk *dqblk);
int hasquota(struct fstab *fs, char **qfnamep);

/*
 * structure containing informations about ufs filesystems
 * initialised by initfs()
 */
struct fs_stat {
	struct fs_stat *fs_next;	/* next element */
	char   *fs_file;		/* mount point of the filesystem */
	char   *qfpathname;		/* pathname of the quota file */
	dev_t   st_dev;			/* device of the filesystem */
};
struct fs_stat *fs_begin = NULL;

int from_inetd = 1;

/* ARGSUSED */
static void
cleanup(int signo)
{
	(void) pmap_unset(RQUOTAPROG, RQUOTAVERS);	/* XXX signal races */
	_exit(0);
}

int
main(int argc, char *argv[])
{
	SVCXPRT *transp;
	int sock = 0;
	int proto = 0;
	struct sockaddr_storage from;
	socklen_t fromlen;

	fromlen = sizeof(from);
	if (getsockname(0, (struct sockaddr *)&from, &fromlen) < 0) {
		from_inetd = 0;
		sock = RPC_ANYSOCK;
		proto = IPPROTO_UDP;
	}

	if (!from_inetd) {
		daemon(0, 0);

		(void) pmap_unset(RQUOTAPROG, RQUOTAVERS);

		(void) signal(SIGINT, cleanup);
		(void) signal(SIGTERM, cleanup);
		(void) signal(SIGHUP, cleanup);
	}

	openlog("rpc.rquotad", LOG_CONS|LOG_PID, LOG_DAEMON);

	/* create and register the service */
	transp = svcudp_create(sock);
	if (transp == NULL) {
		syslog(LOG_ERR, "couldn't create udp service.");
		exit(1);
	}
	if (!svc_register(transp, RQUOTAPROG, RQUOTAVERS, rquota_service, proto)) {
		syslog(LOG_ERR, "unable to register (RQUOTAPROG, RQUOTAVERS, %s).",
		    proto ? "udp" : "(inetd)");
		exit(1);
	}

	initfs();		/* init the fs_stat list */
	svc_run();
	syslog(LOG_ERR, "svc_run returned");
	exit(1);
}

void
rquota_service(struct svc_req *request, SVCXPRT *transp)
{
	switch (request->rq_proc) {
	case NULLPROC:
		(void)svc_sendreply(transp, xdr_void, (char *)NULL);
		break;

	case RQUOTAPROC_GETQUOTA:
	case RQUOTAPROC_GETACTIVEQUOTA:
		sendquota(request, transp);
		break;

	default:
		svcerr_noproc(transp);
		break;
	}
	if (from_inetd)
		exit(0);
}

/* read quota for the specified id, and send it */
void
sendquota(struct svc_req *request, SVCXPRT *transp)
{
	struct getquota_args getq_args;
	struct getquota_rslt getq_rslt;
	struct dqblk dqblk;
	struct timeval timev;

	bzero((char *)&getq_args, sizeof(getq_args));
	if (!svc_getargs(transp, xdr_getquota_args, (caddr_t)&getq_args)) {
		svcerr_decode(transp);
		return;
	}
	if (request->rq_cred.oa_flavor != AUTH_UNIX) {
		/* bad auth */
		getq_rslt.status = Q_EPERM;
	} else if (!getfsquota(getq_args.gqa_uid, getq_args.gqa_pathp, &dqblk)) {
		/* failed, return noquota */
		getq_rslt.status = Q_NOQUOTA;
	} else {
		gettimeofday(&timev, NULL);
		getq_rslt.status = Q_OK;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_active = TRUE;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_bsize = DEV_BSIZE;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_bhardlimit =
		    dqblk.dqb_bhardlimit;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_bsoftlimit =
		    dqblk.dqb_bsoftlimit;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_curblocks =
		    dqblk.dqb_curblocks;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_fhardlimit =
		    dqblk.dqb_ihardlimit;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_fsoftlimit =
		    dqblk.dqb_isoftlimit;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_curfiles =
		    dqblk.dqb_curinodes;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_btimeleft =
		    dqblk.dqb_btime - timev.tv_sec;
		getq_rslt.getquota_rslt_u.gqr_rquota.rq_ftimeleft =
		    dqblk.dqb_itime - timev.tv_sec;
	}
	if (!svc_sendreply(transp, xdr_getquota_rslt, (char *)&getq_rslt)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_getquota_args, (caddr_t)&getq_args)) {
		syslog(LOG_ERR, "unable to free arguments");
		exit(1);
	}
}

/* initialise the fs_tab list from entries in /etc/fstab */
void
initfs(void)
{
	struct fs_stat *fs_current = NULL;
	struct fs_stat *fs_next = NULL;
	char *qfpathname;
	struct fstab *fs;
	struct stat st;

	setfsent();
	while ((fs = getfsent())) {
		if (strcmp(fs->fs_vfstype, "ffs"))
			continue;
		if (!hasquota(fs, &qfpathname))
			continue;

		fs_current = malloc(sizeof(struct fs_stat));
		if (fs_current == NULL) {
			syslog(LOG_ERR, "can't malloc: %m");
			exit(1);
		}
		fs_current->fs_next = fs_next;	/* next element */

		fs_current->fs_file = strdup(fs->fs_file);
		if (fs_current->fs_file == NULL) {
			syslog(LOG_ERR, "can't strdup: %m");
			exit(1);
		}

		fs_current->qfpathname = strdup(qfpathname);
		if (fs_current->qfpathname == NULL) {
			syslog(LOG_ERR, "can't strdup: %m");
			exit(1);
		}

		stat(fs_current->fs_file, &st);
		fs_current->st_dev = st.st_dev;

		fs_next = fs_current;
	}
	endfsent();
	fs_begin = fs_current;
}

/*
 * gets the quotas for id, filesystem path.
 * Return 0 if fail, 1 otherwise
 */
int
getfsquota(long id, char *path, struct dqblk *dqblk)
{
	struct stat st_path;
	struct fs_stat *fs;
	int	qcmd, fd, ret = 0;

	if (stat(path, &st_path) < 0)
		return (0);

	qcmd = QCMD(Q_GETQUOTA, USRQUOTA);

	for (fs = fs_begin; fs != NULL; fs = fs->fs_next) {
		/* where the device is the same as path */
		if (fs->st_dev != st_path.st_dev)
			continue;

		/* find the specified filesystem. get and return quota */
		if (quotactl(fs->fs_file, qcmd, id, (char *)dqblk) == 0)
			return (1);

		if ((fd = open(fs->qfpathname, O_RDONLY)) < 0) {
			syslog(LOG_ERR, "open error: %s: %m", fs->qfpathname);
			return (0);
		}
		if (lseek(fd, (off_t)(id * sizeof(struct dqblk)), SEEK_SET) ==
		    (off_t)-1) {
			close(fd);
			return (1);
		}
		switch (read(fd, dqblk, sizeof(struct dqblk))) {
		case 0:
			/*
			 * Convert implicit 0 quota (EOF)
			 * into an explicit one (zero'ed dqblk)
			 */
			bzero((caddr_t) dqblk, sizeof(struct dqblk));
			ret = 1;
			break;
		case sizeof(struct dqblk):	/* OK */
			ret = 1;
			break;
		default:	/* ERROR */
			syslog(LOG_ERR, "read error: %s: %m", fs->qfpathname);
			close(fd);
			return (0);
		}
		close(fd);
	}
	return (ret);
}

/*
 * Check to see if a particular quota is to be enabled.
 * Comes from quota.c, NetBSD 0.9
 */
int
hasquota(struct fstab *fs, char **qfnamep)
{
	static char initname, usrname[100];
	static char buf[BUFSIZ];
	char	*opt, *cp;
	char	*qfextension[] = INITQFNAMES;

	cp = NULL;
	if (!initname) {
		(void)snprintf(usrname, sizeof usrname, "%s%s",
		    qfextension[USRQUOTA], QUOTAFILENAME);
		initname = 1;
	}
	strlcpy(buf, fs->fs_mntops, sizeof buf);
	for (opt = strtok(buf, ","); opt; opt = strtok(NULL, ",")) {
		if ((cp = strchr(opt, '=')))
			*cp++ = '\0';
		if (strcmp(opt, usrname) == 0)
			break;
	}
	if (!opt)
		return (0);
	if (cp) {
		*qfnamep = cp;
		return (1);
	}
	(void)snprintf(buf, sizeof buf, "%s/%s.%s", fs->fs_file,
	    QUOTAFILENAME, qfextension[USRQUOTA]);
	*qfnamep = buf;
	return (1);
}
@


1.21
log
@remove useless cast
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.20 2004/09/14 23:49:49 deraadt Exp $	*/
d7 1
a7 1
#include <sys/param.h>
@


1.20
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.19 2004/06/02 02:21:15 brad Exp $	*/
d195 1
a195 1
		fs_current = (struct fs_stat *) malloc(sizeof(struct fs_stat));
@


1.19
log
@IPv6 support.

From NetBSD

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.18 2003/07/29 18:39:23 deraadt Exp $	*/
d47 1
a47 1
} fs_stat;
d52 1
@


1.18
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.17 2003/07/05 17:02:36 deraadt Exp $	*/
d65 1
a65 1
	struct sockaddr_in from;
@


1.17
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.16 2002/09/06 19:43:54 deraadt Exp $	*/
d105 1
a105 1
void 
d127 1
a127 1
void 
d178 1
a178 1
void 
@


1.16
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.15 2002/07/03 23:39:03 deraadt Exp $	*/
d52 1
a52 1
void 
@


1.15
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.14 2002/06/20 03:43:33 deraadt Exp $	*/
d53 1
a53 1
cleanup(void)
d66 1
a66 1
	int fromlen;
@


1.14
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.13 2002/06/09 17:42:16 itojun Exp $	*/
d53 1
a53 1
cleanup()
@


1.13
log
@new copyright (explicitly public domain) - from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.12 2002/06/09 04:18:55 deraadt Exp $	*/
d60 1
a60 3
main(argc, argv)
	int     argc;
	char   *argv[];
d106 1
a106 3
rquota_service(request, transp)
	struct svc_req *request;
	SVCXPRT *transp;
d128 1
a128 3
sendquota(request, transp)
	struct svc_req *request;
	SVCXPRT *transp;
a176 19
void 
printerr_reply(transp)	/* when a reply to a request failed */
	SVCXPRT *transp;
{
	char   *name;
	struct sockaddr_in *caller;
	int     save_errno;

	save_errno = errno;

	caller = svc_getcaller(transp);
	name = (char *)inet_ntoa(caller->sin_addr);
	errno = save_errno;
	if (errno == 0)
		syslog(LOG_ERR, "couldn't send reply to %s", name);
	else
		syslog(LOG_ERR, "couldn't send reply to %s: %m", name);
}

d179 1
a179 1
initfs()
d227 1
a227 4
getfsquota(id, path, dqblk)
	long id;
	char   *path;
	struct dqblk *dqblk;
d283 1
a283 3
hasquota(fs, qfnamep)
	struct fstab *fs;
	char  **qfnamep;
@


1.12
log
@bit of KNF
@
text
@d1 2
a2 1
/*	$OpenBSD: rquotad.c,v 1.11 2002/02/16 21:27:31 millert Exp $	*/
d4 1
a4 3
 * by Manuel Bouyer (bouyer@@ensta.fr)
 * 
 * There is no copyright, you can use it as you want.
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.10 2001/06/11 15:18:51 mickey Exp $	*/
d97 2
a98 1
		syslog(LOG_ERR, "unable to register (RQUOTAPROG, RQUOTAVERS, %s).", proto?"udp":"(inetd)");
@


1.10
log
@strncpy vs strlcpy, some strlen missuse.
some other related minor cleanups, and spaces.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.9 2001/02/12 07:15:46 deraadt Exp $	*/
d32 6
a37 6
void rquota_service __P((struct svc_req *request, SVCXPRT *transp));
void sendquota __P((struct svc_req *request, SVCXPRT *transp));
void printerr_reply __P((SVCXPRT *transp));
void initfs __P((void));
int getfsquota __P((long id, char *path, struct dqblk *dqblk));
int hasquota __P((struct fstab *fs, char **qfnamep));
@


1.9
log
@er... ffs, not ufs; canacar@@eee.metu.edu.tr
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.8 2001/01/17 19:23:26 deraadt Exp $	*/
d326 1
a326 2
	strncpy(buf, fs->fs_mntops, sizeof buf);
	buf[sizeof(buf) - 1] = '\0';
@


1.8
log
@use _exit() in signal handlers, and flag that the pmap_unset() calls are unsafe
@
text
@d1 1
a1 1
/*	$OpenBSD: rquotad.c,v 1.7 2000/10/19 01:56:05 pjanzen Exp $	*/
d214 1
a214 1
		if (strcmp(fs->fs_vfstype, "ufs"))
@


1.7
log
@Update: check malloc() returns, simplify, be a little more paranoid.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
a57 2
	(void) pmap_unset(RQUOTAPROG, RQUOTAVERS);
	exit(0);
@


1.6
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
d11 1
d25 1
a25 1
#include <varargs.h>
a210 1
	char *qfextension[] = INITQFNAMES;
d213 1
a213 1
	while (fs = getfsent()) {
d220 4
d226 5
a230 2
		fs_current->fs_file = malloc(sizeof(char) * (strlen(fs->fs_file) + 1));
		strcpy(fs_current->fs_file, fs->fs_file);
d232 5
a236 2
		fs_current->qfpathname = malloc(sizeof(char) * (strlen(qfpathname) + 1));
		strcpy(fs_current->qfpathname, qfpathname);
a259 1
	char	*qfextension[] = INITQFNAMES;
d267 1
a267 1
		/* where the devise is the same as path */
d272 1
a272 1
		if (quotactl(fs->fs_file, qcmd, id, dqblk) == 0)
d320 1
d322 2
a323 1
		sprintf(usrname, "%s%s", qfextension[USRQUOTA], QUOTAFILENAME);
d326 2
a327 1
	strcpy(buf, fs->fs_mntops);
d329 1
a329 1
		if (cp = strchr(opt, '='))
d340 2
a341 1
	sprintf(buf, "%s/%s.%s", fs->fs_file, QUOTAFILENAME, qfextension[USRQUOTA]);
@


1.5
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@a9 1
#include <sys/file.h>
d13 6
a19 2
#include <fstab.h>
#include <ctype.h>
a21 4
#include <pwd.h>
#include <grp.h>
#include <errno.h>

@


1.4
log
@remember dev_t of filesystem quotas act on, instead of filesystem quotas file resides on; ovg@@nusun.jinr.ru
@
text
@d270 2
a271 1
		if (lseek(fd, (off_t)(id * sizeof(struct dqblk)), L_SET) == (off_t)-1) {
@


1.3
log
@tabify
@
text
@d228 1
a228 1
		stat(qfpathname, &st);
@


1.2
log
@r?index -> strr?chr
@
text
@d277 3
a279 3
                         * Convert implicit 0 quota (EOF)
                         * into an explicit one (zero'ed dqblk)
                         */
@


1.1
log
@Initial revision
@
text
@d316 1
a316 1
		if (cp = index(opt, '='))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
