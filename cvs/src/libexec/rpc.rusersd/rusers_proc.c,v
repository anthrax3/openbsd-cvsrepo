head	1.26;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.12
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.8
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.22
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.18
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.16
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.14
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.12
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.10
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.8
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.04.27.21.28.00;	author millert;	state Exp;
branches;
next	1.25;
commitid	eW7b7MeL27fide4b;

1.25
date	2016.08.16.04.48.04;	author tedu;	state Exp;
branches;
next	1.24;
commitid	t8YoOL1BGjv1imbU;

1.24
date	2013.11.13.15.24.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.04.02.38.51;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.04.20.09.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.28.15.18.57;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.10.00.04.28;	author david;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.30.00.21.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.28.22.40.33;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.04.06.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.18.23.39.18;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.18.21.38.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.18.18.31.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.08.21.18.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.28.19.34.31;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.17.19.23.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.06.16.10.15.14;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.07.09.15.56.19;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.13.06.22.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.22.08.41.32;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.16.13.50.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Change len arg of getidle() from size_t to int since it is used as
a length parameter to a "%.*s" printf format.  Quiets a compiler
warning (both gcc and clang).
@
text
@/*	$OpenBSD: rusers_proc.c,v 1.25 2016/08/16 04:48:04 tedu Exp $	*/

/*-
 *  Copyright (c) 1993 John Brezak
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>
#include <paths.h>
#include <utmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <rpc/rpc.h>
#include <rpcsvc/rusers.h>	/* New version */
#include <rpcsvc/rnusers.h>	/* Old version */

extern int utmp_fd;

typedef char ut_line_t[UT_LINESIZE+1];
typedef char ut_name_t[UT_NAMESIZE+1];
typedef char ut_host_t[UT_HOSTSIZE+1];

struct rusers_utmp utmps[MAXUSERS];
struct utmpidle *utmp_idlep[MAXUSERS];
struct utmpidle utmp_idle[MAXUSERS];
struct ru_utmp *ru_utmpp[MAXUSERS];
struct ru_utmp ru_utmp[MAXUSERS];
ut_line_t line[MAXUSERS];
ut_name_t name[MAXUSERS];
ut_host_t host[MAXUSERS];

int *rusers_num_svc(void *, struct svc_req *);
struct utmpidlearr *rusersproc_names_2_svc(void *, struct svc_req *);
struct utmpidlearr *rusersproc_allnames_2_svc(void *, struct svc_req *);
struct utmparr *rusersproc_names_1_svc(void *, struct svc_req *);
struct utmparr *rusersproc_allnames_1_svc(void *, struct svc_req *);
void rusers_service(struct svc_req *, SVCXPRT *);

extern int from_inetd;

FILE *ufp;

static long
getidle(char *tty, int len)
{
	char devname[PATH_MAX];
	struct stat st;
	long idle;
	time_t now;

	snprintf(devname, sizeof devname, "%s/%.*s", _PATH_DEV,
	    len, tty);
	if (stat(devname, &st) < 0) {
#ifdef DEBUG
		printf("%s: %m\n", devname);
#endif
		return (0);
	}
	time(&now);
#ifdef DEBUG
	printf("%s: now=%lld atime=%lld\n", devname, (long long)now,
	    (long long)st.st_atime);
#endif
	idle = now - st.st_atime;
	idle = (idle + 30) / 60; /* secs->mins */
	if (idle < 0)
		idle = 0;

	return (idle);
}

int *
rusers_num_svc(void *arg, struct svc_req *rqstp)
{
	static int num_users = 0;
	struct utmp usr;
	int fd;

	fd = dup(utmp_fd);
	if (fd == -1) {
		syslog(LOG_ERR, "%m");
		return (0);
	}
	lseek(fd, 0, SEEK_SET);
	ufp = fdopen(fd, "r");
	if (!ufp) {
		close(fd);
		syslog(LOG_ERR, "%m");
		return (0);
	}

	/* only entries with both name and line fields */
	while (fread(&usr, sizeof(usr), 1, ufp) == 1)
		if (*usr.ut_name && *usr.ut_line)
			num_users++;

	fclose(ufp);
	return (&num_users);
}

static utmp_array *
do_names_3(int all)
{
	static utmp_array ut;
	struct utmp usr;
	int fd, nusers = 0;

	bzero(&ut, sizeof(ut));
	ut.utmp_array_val = &utmps[0];

	fd = dup(utmp_fd);
	if (fd == -1) {
		syslog(LOG_ERR, "%m");
		return (0);
	}
	lseek(fd, 0, SEEK_SET);
	ufp = fdopen(fd, "r");
	if (!ufp) {
		close(fd);
		syslog(LOG_ERR, "%m");
		return (NULL);
	}

	/* only entries with both name and line fields */
	while (fread(&usr, sizeof(usr), 1, ufp) == 1 &&
	    nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line) {
			utmps[nusers].ut_type = RUSERS_USER_PROCESS;
			utmps[nusers].ut_time = usr.ut_time;
			utmps[nusers].ut_idle = getidle(usr.ut_line,
			    sizeof usr.ut_line);
			utmps[nusers].ut_line = line[nusers];
			memset(line[nusers], 0, sizeof(line[nusers]));
			memcpy(line[nusers], usr.ut_line, UT_LINESIZE);
			line[nusers][UT_LINESIZE] = '\0';
			utmps[nusers].ut_user = name[nusers];
			memset(name[nusers], 0, sizeof(name[nusers]));
			memcpy(name[nusers], usr.ut_name, UT_NAMESIZE);
			name[nusers][UT_NAMESIZE] = '\0';
			utmps[nusers].ut_host = host[nusers];
			memset(host[nusers], 0, sizeof(host[nusers]));
			memcpy(host[nusers], usr.ut_host, UT_HOSTSIZE);
			host[nusers][UT_HOSTSIZE] = '\0';
			nusers++;
		}
	ut.utmp_array_len = nusers;

	fclose(ufp);
	return (&ut);
}

utmp_array *
rusersproc_names_3_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_3(0));
}

utmp_array *
rusersproc_allnames_3_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_3(1));
}

static struct utmpidlearr *
do_names_2(int all)
{
	static struct utmpidlearr ut;
	struct utmp usr;
	int fd, nusers = 0;

	bzero(&ut, sizeof(ut));
	ut.uia_arr = utmp_idlep;
	ut.uia_cnt = 0;

	fd = dup(utmp_fd);
	if (fd == -1) {
		syslog(LOG_ERR, "%m");
		return (0);
	}
	lseek(fd, 0, SEEK_SET);
	ufp = fdopen(fd, "r");
	if (!ufp) {
		close(fd);
		syslog(LOG_ERR, "%m");
		return (NULL);
	}

	/* only entries with both name and line fields */
	while (fread(&usr, sizeof(usr), 1, ufp) == 1 &&
	    nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line) {
			utmp_idlep[nusers] = &utmp_idle[nusers];
			utmp_idle[nusers].ui_utmp.ut_time = usr.ut_time;
			utmp_idle[nusers].ui_idle = getidle(usr.ut_line,
			    sizeof usr.ut_line);
			utmp_idle[nusers].ui_utmp.ut_line = line[nusers];
			memset(line[nusers], 0, sizeof(line[nusers]));
			memcpy(line[nusers], usr.ut_line, UT_LINESIZE);
			line[nusers][UT_LINESIZE] = '\0';
			utmp_idle[nusers].ui_utmp.ut_name = name[nusers];
			memset(name[nusers], 0, sizeof(name[nusers]));
			memcpy(name[nusers], usr.ut_name, UT_NAMESIZE);
			name[nusers][UT_NAMESIZE] = '\0';
			utmp_idle[nusers].ui_utmp.ut_host = host[nusers];
			memset(host[nusers], 0, sizeof(host[nusers]));
			memcpy(host[nusers], usr.ut_host, UT_HOSTSIZE);
			host[nusers][UT_HOSTSIZE] = '\0';
			nusers++;
		}

	ut.uia_cnt = nusers;
	fclose(ufp);
	return (&ut);
}

struct utmpidlearr *
rusersproc_names_2_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_2(0));
}

struct utmpidlearr *
rusersproc_allnames_2_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_2(1));
}

static struct utmparr *
do_names_1(int all)
{
	static struct utmparr ut;
	struct utmp usr;
	int fd, nusers = 0;

	bzero(&ut, sizeof(ut));
	ut.uta_arr = ru_utmpp;
	ut.uta_cnt = 0;

	fd = dup(utmp_fd);
	if (fd == -1) {
		syslog(LOG_ERR, "%m");
		return (0);
	}
	lseek(fd, 0, SEEK_SET);
	ufp = fdopen(fd, "r");
	if (!ufp) {
		close(fd);
		syslog(LOG_ERR, "%m");
		return (NULL);
	}

	/* only entries with both name and line fields */
	while (fread(&usr, sizeof(usr), 1, ufp) == 1 &&
	    nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line) {
			ru_utmpp[nusers] = &ru_utmp[nusers];
			ru_utmp[nusers].ut_time = usr.ut_time;
			ru_utmp[nusers].ut_line = line[nusers];
			memcpy(line[nusers], usr.ut_line, UT_LINESIZE);
			line[nusers][UT_LINESIZE] = '\0';
			ru_utmp[nusers].ut_name = name[nusers];
			memcpy(name[nusers], usr.ut_name, UT_NAMESIZE);
			name[nusers][UT_NAMESIZE] = '\0';
			ru_utmp[nusers].ut_host = host[nusers];
			memcpy(host[nusers], usr.ut_host, UT_HOSTSIZE);
			host[nusers][UT_HOSTSIZE] = '\0';
			nusers++;
		}

	ut.uta_cnt = nusers;
	fclose(ufp);
	return (&ut);
}

struct utmparr *
rusersproc_names_1_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_1(0));
}

struct utmparr *
rusersproc_allnames_1_svc(void *arg, struct svc_req *rqstp)
{
	return (do_names_1(1));
}

void
rusers_service(struct svc_req *rqstp, SVCXPRT *transp)
{
	char *(*local)(void *, struct svc_req *);
	xdrproc_t xdr_argument, xdr_result;
	union {
		int fill;
	} argument;
	char *result;

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void)svc_sendreply(transp, xdr_void, (char *)NULL);
		goto leave;

	case RUSERSPROC_NUM:
		xdr_argument = (xdrproc_t)xdr_void;
		xdr_result = (xdrproc_t)xdr_int;
		switch (rqstp->rq_vers) {
		case RUSERSVERS_3:
		case RUSERSVERS_IDLE:
		case RUSERSVERS_ORIG:
			local = (char *(*)(void *, struct svc_req *))
			    rusers_num_svc;
			break;
		default:
			svcerr_progvers(transp, RUSERSVERS_IDLE, RUSERSVERS_3);
			goto leave;
			/*NOTREACHED*/
		}
		break;

	case RUSERSPROC_NAMES:
		xdr_argument = (xdrproc_t)xdr_void;
		xdr_result = (xdrproc_t)xdr_utmp_array;
		switch (rqstp->rq_vers) {
		case RUSERSVERS_3:
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_names_3_svc;
			break;

		case RUSERSVERS_IDLE:
			xdr_result = (xdrproc_t)xdr_utmpidlearr;
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_names_2_svc;
			break;

		case RUSERSVERS_ORIG:
			xdr_result = (xdrproc_t)xdr_utmpidlearr;
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_names_1_svc;
			break;

		default:
			svcerr_progvers(transp, RUSERSVERS_IDLE, RUSERSVERS_3);
			goto leave;
			/*NOTREACHED*/
		}
		break;

	case RUSERSPROC_ALLNAMES:
		xdr_argument = (xdrproc_t)xdr_void;
		xdr_result = (xdrproc_t)xdr_utmp_array;
		switch (rqstp->rq_vers) {
		case RUSERSVERS_3:
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_allnames_3_svc;
			break;

		case RUSERSVERS_IDLE:
			xdr_result = (xdrproc_t)xdr_utmpidlearr;
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_allnames_2_svc;
			break;

		case RUSERSVERS_ORIG:
			xdr_result = (xdrproc_t)xdr_utmpidlearr;
			local = (char *(*)(void *, struct svc_req *))
			    rusersproc_allnames_1_svc;
			break;

		default:
			svcerr_progvers(transp, RUSERSVERS_IDLE, RUSERSVERS_3);
			goto leave;
			/*NOTREACHED*/
		}
		break;

	default:
		svcerr_noproc(transp);
		goto leave;
	}
	bzero((char *)&argument, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		goto leave;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result))
		svcerr_systemerr(transp);

	if (!svc_freeargs(transp, xdr_argument, (caddr_t)&argument)) {
		syslog(LOG_ERR, "unable to free arguments");
		exit(1);
	}
leave:
	if (from_inetd)
		exit(0);
}
@


1.25
log
@fread hasn't taken a char * in about 900 years
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.24 2013/11/13 15:24:21 deraadt Exp $	*/
d74 1
a74 1
getidle(char *tty, size_t len)
@


1.24
log
@repair device checking, somewhat broken from around 10 years.
Bring things into prototypes and remove handling for old X utmp
handling as well
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.23 2012/12/04 02:38:51 deraadt Exp $	*/
d114 1
a114 1
	lseek(fd, (off_t)0, SEEK_SET);
d123 1
a123 1
	while (fread((char *)&usr, sizeof(usr), 1, ufp) == 1)
d138 1
a138 1
	bzero((char *)&ut, sizeof(ut));
d146 1
a146 1
	lseek(fd, (off_t)0, SEEK_SET);
d155 1
a155 1
	while (fread((char *)&usr, sizeof(usr), 1, ufp) == 1 &&
d201 1
a201 1
	bzero((char *)&ut, sizeof(ut));
d210 1
a210 1
	lseek(fd, (off_t)0, SEEK_SET);
d219 1
a219 1
	while (fread((char *)&usr, sizeof(usr), 1, ufp) == 1 &&
d265 1
a265 1
	bzero((char *)&ut, sizeof(ut));
d274 1
a274 1
	lseek(fd, (off_t)0, SEEK_SET);
d283 1
a283 1
	while (fread((char *)&usr, sizeof(usr), 1, ufp) == 1 &&
@


1.23
log
@replace sys/param.h with sys/types.h (and sometimes add limits.h if needed)
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.22 2009/10/27 23:59:31 deraadt Exp $	*/
d74 1
a74 1
getidle(char *tty)
d81 3
a83 17
	idle = 0;
	if (*tty == 'X') {
		long kbd_idle, mouse_idle;
#if !defined(__i386__)
		kbd_idle = getidle("kbd");
#else
		/*
		 * XXX Icky i386 console hack.
		 */
		kbd_idle = getidle("vga");
#endif
		mouse_idle = getidle("mouse");
		idle = (kbd_idle < mouse_idle) ? kbd_idle : mouse_idle;
	} else {
		snprintf(devname, sizeof devname, "%s/%.*s", _PATH_DEV,
		    sizeof(tty), tty);
		if (stat(devname, &st) < 0) {
d85 1
a85 1
			printf("%s: %m\n", devname);
d87 3
a89 3
			return (0);
		}
		time(&now);
d91 2
a92 1
		printf("%s: now=%d atime=%d\n", devname, now, st.st_atime);
d94 2
a95 3
		idle = now - st.st_atime;
		idle = (idle + 30) / 60; /* secs->mins */
	}
d160 2
a161 1
			utmps[nusers].ut_idle = getidle(usr.ut_line);
d224 2
a225 1
			utmp_idle[nusers].ui_idle = getidle(usr.ut_line);
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.21 2004/11/04 20:09:18 deraadt Exp $	*/
a30 1
#include <sys/param.h>
d41 1
@


1.21
log
@some delint, grudging ok from otto, because it is messy stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.20 2004/04/28 15:18:57 deraadt Exp $	*/
a29 4

#ifndef lint
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.20 2004/04/28 15:18:57 deraadt Exp $";
#endif /* not lint */
@


1.20
log
@fd leaks
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.19 2003/07/10 00:04:28 david Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.19 2003/07/10 00:04:28 david Exp $";
d77 1
a77 1
static u_int
d82 1
a82 1
	u_long idle;
d87 1
a87 1
		u_long kbd_idle, mouse_idle;
d100 1
a100 1
			sizeof(tty), tty);
d132 1
a132 1
	lseek(fd, 0, SEEK_SET);
d154 1
a154 2
	int nusers = 0;
	int fd;
d164 1
a164 1
	lseek(fd, 0, SEEK_SET);
d216 1
a216 2
	int nusers = 0;
	int fd;
d227 1
a227 1
	lseek(fd, 0, SEEK_SET);
d279 1
a279 2
	int nusers = 0;
	int fd;
d290 1
a290 1
	lseek(fd, 0, SEEK_SET);
@


1.19
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.18 2003/07/06 21:57:27 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.18 2003/07/06 21:57:27 deraadt Exp $";
d135 1
d168 1
d232 1
d296 1
@


1.18
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.17 2002/06/30 00:21:12 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.17 2002/06/30 00:21:12 deraadt Exp $";
d43 1
@


1.17
log
@more care with utmp strings, and lseek fixes; moritz@@jodeit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.16 2002/06/28 22:40:33 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.16 2002/06/28 22:40:33 deraadt Exp $";
d64 7
@


1.16
log
@go back to running these as root from inetd.  however once rpc.{rusersd,rstatd}
starts, do a chroot to /var/empty and change to user nobody.
hi mom, i'm in jail!
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.15 2002/06/09 04:06:42 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.15 2002/06/09 04:06:42 deraadt Exp $";
d40 1
a51 14
#ifndef _PATH_DEV
#define _PATH_DEV "/dev"
#endif

#ifndef UT_LINESIZE
#define UT_LINESIZE sizeof(((struct utmp *)0)->ut_line)
#endif
#ifndef UT_NAMESIZE
#define UT_NAMESIZE sizeof(((struct utmp *)0)->ut_name)
#endif
#ifndef UT_HOSTSIZE
#define UT_HOSTSIZE sizeof(((struct utmp *)0)->ut_host)
#endif

d70 1
a70 1
getidle(char *tty, char *display)
a76 4
	/*
	 * If this is an X terminal or console, then try the
	 * XIdle extension
	 */
d81 1
a81 1
		kbd_idle = getidle("kbd", NULL);
d86 1
a86 1
		kbd_idle = getidle("vga", NULL);
d88 1
a88 1
		mouse_idle = getidle("mouse", NULL);
d91 2
a92 1
		snprintf(devname, sizeof devname, "%s/%s", _PATH_DEV, tty);
d124 1
a124 1
	lseek(fd, SEEK_SET, 0);
d156 1
a156 1
	lseek(fd, SEEK_SET, 0);
d169 1
a169 1
			utmps[nusers].ut_idle = getidle(usr.ut_line, usr.ut_host);
d172 2
a173 1
			strlcpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d176 2
a177 1
			strlcpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d180 2
a181 1
			strlcpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
d219 1
a219 1
	lseek(fd, SEEK_SET, 0);
d232 1
a232 1
			utmp_idle[nusers].ui_idle = getidle(usr.ut_line, usr.ut_host);
d235 2
a236 1
			strlcpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d239 2
a240 1
			strlcpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d243 2
a244 1
			strlcpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
d282 1
a282 1
	lseek(fd, SEEK_SET, 0);
d296 2
a297 1
			strlcpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d299 2
a300 1
			strlcpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d302 2
a303 1
			strlcpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
@


1.15
log
@some misc cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.14 2002/05/22 06:35:44 deraadt Exp $	*/
d6 1
a6 1
 * 
d17 1
a17 1
 * 
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.14 2002/05/22 06:35:44 deraadt Exp $";
d43 1
d49 1
a49 5
#define	IGNOREUSER	"sleeper"

#ifndef _PATH_UTMP
#define _PATH_UTMP "/etc/utmp"
#endif
d83 1
a83 2
getidle(tty, display)
	char *tty, *display;
d85 1
d87 1
a87 1
	char devname[PATH_MAX];
d89 1
a89 2
	u_long idle;
	
d127 1
a127 1
	
d129 1
a129 3
rusers_num_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d133 1
d135 7
a141 1
	ufp = fopen(_PATH_UTMP, "r");
d149 1
a149 7
		if (*usr.ut_name && *usr.ut_line &&
		    strncmp(usr.ut_name, IGNOREUSER,
			    sizeof(usr.ut_name))
#ifdef USER_PROCESS
		    && usr.ut_type == USER_PROCESS
#endif
		    ) {
a150 1
		}
d162 2
a163 1
	
d166 8
a173 2
	
	ufp = fopen(_PATH_UTMP, "r");
d181 2
a182 8
	       nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line &&
		    strncmp(usr.ut_name, IGNOREUSER,
			    sizeof(usr.ut_name))
#ifdef USER_PROCESS
		    && usr.ut_type == USER_PROCESS
#endif
		    ) {
d184 2
a185 4
			utmps[nusers].ut_time =
				usr.ut_time;
			utmps[nusers].ut_idle =
				getidle(usr.ut_line, usr.ut_host);
d204 1
a204 3
rusersproc_names_3_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d210 1
a210 3
rusersproc_allnames_3_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d221 2
a222 1
	
d226 8
a233 2
	
	ufp = fopen(_PATH_UTMP, "r");
d241 2
a242 8
	       nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line &&
		    strncmp(usr.ut_name, IGNOREUSER,
			    sizeof(usr.ut_name))
#ifdef USER_PROCESS
		    && usr.ut_type == USER_PROCESS
#endif
		    ) {
d244 2
a245 4
			utmp_idle[nusers].ui_utmp.ut_time =
				usr.ut_time;
			utmp_idle[nusers].ui_idle =
				getidle(usr.ut_line, usr.ut_host);
d264 1
a264 3
rusersproc_names_2_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d270 1
a270 3
rusersproc_allnames_2_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d281 2
a282 1
	
d286 8
a293 2
	
	ufp = fopen(_PATH_UTMP, "r");
d301 2
a302 8
	       nusers < MAXUSERS)
		if (*usr.ut_name && *usr.ut_line &&
		    strncmp(usr.ut_name, IGNOREUSER,
			    sizeof(usr.ut_name))
#ifdef USER_PROCESS
		    && usr.ut_type == USER_PROCESS
#endif
		    ) {
d320 1
a320 3
rusersproc_names_1_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d326 1
a326 3
rusersproc_allnames_1_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d332 1
a332 3
rusers_service(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
d334 2
a339 2
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(void *, struct svc_req *);
@


1.14
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.13 2002/02/16 21:27:31 millert Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.13 2002/02/16 21:27:31 millert Exp $";
d375 1
a375 1
					rusers_num_svc;
d390 1
a390 1
					rusersproc_names_3_svc;
d396 1
a396 1
					rusersproc_names_2_svc;
d402 1
a402 1
					rusersproc_names_1_svc;
d418 1
a418 1
					rusersproc_allnames_3_svc;
d424 1
a424 1
					rusersproc_allnames_2_svc;
d430 1
a430 1
					rusersproc_allnames_1_svc;
d450 1
a450 1
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
d452 1
a452 1
	}
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.12 2001/11/18 23:39:18 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.12 2001/11/18 23:39:18 deraadt Exp $";
d112 1
a112 1
		sprintf(devname, "%s/%s", _PATH_DEV, tty);
@


1.12
log
@blow away unused XIDLE signal race crap
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.11 2001/08/18 21:38:55 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.11 2001/08/18 21:38:55 deraadt Exp $";
d360 1
a360 1
	char *(*local) __P((void *, struct svc_req *));
d374 1
a374 1
			local = (char *(*) __P((void *, struct svc_req *)))
d389 1
a389 1
			local = (char *(*) __P((void *, struct svc_req *)))
d395 1
a395 1
			local = (char *(*) __P((void *, struct svc_req *)))
d401 1
a401 1
			local = (char *(*) __P((void *, struct svc_req *)))
d417 1
a417 1
			local = (char *(*) __P((void *, struct svc_req *)))
d423 1
a423 1
			local = (char *(*) __P((void *, struct svc_req *)))
d429 1
a429 1
			local = (char *(*) __P((void *, struct svc_req *)))
@


1.11
log
@i think this pads the buffers correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.10 2001/08/18 18:31:21 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.10 2001/08/18 18:31:21 deraadt Exp $";
a39 1
#include <signal.h>
a44 5
#ifdef XIDLE
#include <setjmp.h>
#include <X11/Xlib.h>
#include <X11/extensions/xidle.h>
#endif
a49 4
#ifdef OSF
#define _PATH_UTMP UTMP_FILE
#endif

a84 46
#ifdef XIDLE
Display *dpy;

static sigjmp_buf openAbort;

static void
abortOpen()
{
	siglongjmp(openAbort, 1);	/* XXX signal/longjmp resource leaks */
}

XqueryIdle(display)
	char *display;
{
	int first_event, first_error;
	Time IdleTime;

	(void) signal(SIGALRM, abortOpen);
	(void) alarm(10);
	if (!sigsetjmp(openAbort)) {
		if ((dpy = XOpenDisplay(display)) == NULL) {
			syslog(LOG_ERR, "cannot open display %s", display);
			return (-1);
		}
		if (XidleQueryExtension(dpy, &first_event, &first_error)) {
			if (!XGetIdleTime(dpy, &IdleTime)) {
				syslog(LOG_ERR, "%s: unable to get idle time", display);
				return (-1);
			}
		} else {
			syslog(LOG_ERR, "%s: Xidle extension not loaded", display);
			return (-1);
		}
		XCloseDisplay(dpy);
	} else {
		syslog(LOG_ERR, "%s: server grabbed for over 10 seconds", display);
		return (-1);
	}
	(void) alarm(0);
	(void) signal(SIGALRM, SIG_DFL);

	IdleTime /= 1000;
	return ((IdleTime + 30) / 60);
}
#endif

a97 4
#ifdef XIDLE
	if (display && *display && (idle = XqueryIdle(display)) >= 0)
		return (idle);
#endif
@


1.10
log
@strlcpy invades the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.9 2001/07/08 21:18:10 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.9 2001/07/08 21:18:10 deraadt Exp $";
d78 3
a80 3
typedef char ut_line_t[UT_LINESIZE];
typedef char ut_name_t[UT_NAMESIZE];
typedef char ut_host_t[UT_HOSTSIZE];
d254 1
d257 1
d260 1
d319 1
d322 1
d325 1
@


1.9
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers_proc.c,v 1.8 2001/01/28 19:34:31 niklas Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.8 2001/01/28 19:34:31 niklas Exp $";
d254 1
a254 1
			strncpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d256 1
a256 1
			strncpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d258 1
a258 1
			strncpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
d316 1
a316 1
			strncpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d318 1
a318 1
			strncpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d320 1
a320 1
			strncpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
d375 1
a375 1
			strncpy(line[nusers], usr.ut_line, sizeof(line[nusers]));
d377 1
a377 1
			strncpy(name[nusers], usr.ut_name, sizeof(name[nusers]));
d379 1
a379 1
			strncpy(host[nusers], usr.ut_host, sizeof(host[nusers]));
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers_proc.c,v 1.7 2001/01/17 19:23:27 deraadt Exp $";
d35 3
a37 1
#include <signal.h>
d40 1
d44 1
a45 3
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/stat.h>
@


1.7
log
@use _exit() in signal handlers, and flag that the pmap_unset() calls are unsafe
@
text
@d1 2
d32 1
a32 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.6 1999/06/16 10:15:14 espie Exp $";
@


1.6
log
@Missed i386 -> __i386__
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.5 1997/07/09 15:56:19 kstailey Exp $";
d100 1
a100 1
	siglongjmp(openAbort, 1);
@


1.5
log
@Use syslog(3), not fprintf(3) for error messages.
OSF is not the only OS that uses USER_PROCESS in ut_type.
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.4 1997/02/13 06:22:42 millert Exp $";
d158 1
a158 1
#if !defined(i386)
@


1.4
log
@Return idle time of 0, not -1 for users w/o a tty.
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.3 1996/09/22 08:41:32 tholo Exp $";
d208 1
a208 1
#ifdef OSF
d241 1
a241 1
#ifdef OSF
d303 1
a303 1
#ifdef OSF
d365 1
a365 1
#ifdef OSF
d505 1
a505 1
		(void)fprintf(stderr, "unable to free arguments\n");
@


1.3
log
@Make this work properly with corrected rnusers.x
Also implement protocol version 1 while at it
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.2 1995/12/16 13:50:46 deraadt Exp $";
d174 1
a174 1
			return (-1);
@


1.2
log
@handle time_t things that really are not time_t
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.12 1995/12/14 21:58:33 thorpej Exp $";
d82 2
d312 6
a317 3
			strncpy(utmp_idle[nusers].ui_utmp.ut_line, usr.ut_line, sizeof(utmp_idle[nusers].ui_utmp.ut_line));
			strncpy(utmp_idle[nusers].ui_utmp.ut_name, usr.ut_name, sizeof(utmp_idle[nusers].ui_utmp.ut_name));
			strncpy(utmp_idle[nusers].ui_utmp.ut_host, usr.ut_host, sizeof(utmp_idle[nusers].ui_utmp.ut_host));
d342 59
d424 1
d450 6
d476 6
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers_proc.c,v 1.11 1995/07/09 00:30:15 pk Exp $";
d159 3
a161 3
#if __GNUC__ >= 2
#warning i386 console hack here
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
