head	1.34;
access;
symbols
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.16
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.12
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.10
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.8
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.6
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2014.03.17.19.53.26;	author tedu;	state dead;
branches;
next	1.33;

1.33
date	2013.03.11.17.40.10;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.02.00.48.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.13.02.33.09;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.02.02.21.15;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.27.19.15.45;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.26.09.32.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.18.45.33;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.09.07.04.45;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.28.19.34.35;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.17.19.46.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.20.18.42.38;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.01.03.23.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.07.05.18.48.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.05.22.04.33.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.04.22.14.19.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.31.08.24.01;	author deraadt;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	97.08.04.19.25.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.06.02.06.28.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.06.13.34.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.03.41.24;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.12.03.01.29.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.10.26.04.59.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.02.13.12.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.10.23.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.22.02.00.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.25;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	98.04.22.14.20.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@today's conan quote: two or three years ago it was just another snake cult.
@
text
@/*	$OpenBSD: uucpd.c,v 1.33 2013/03/11 17:40:10 deraadt Exp $	*/

/*
 * Copyright (c) 1985 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Adams.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * 4.2BSD TCP/IP server for uucico
 * uucico's TCP channel causes this server to be run at the remote end.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <pwd.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <login_cap.h>
#include <utmp.h>
#include <fcntl.h>
#include "pathnames.h"

void doit(struct sockaddr *);
int readline(char *, int n);
void dologout(void);
void dologin(struct passwd *, struct sockaddr *);

struct	sockaddr_storage hisctladdr;
socklen_t hisaddrlen = sizeof hisctladdr;
pid_t	mypid;

char Username[64], Loginname[64];
char *nenv[] = {
	Username,
	Loginname,
	NULL,
};

extern char **environ;

char utline[UT_LINESIZE+1];

int
main(int argc, char *argv[])
{
#ifndef BSDINETD
	int s, tcp_socket;
	struct servent *sp;
#endif /* !BSDINETD */
	pid_t childpid;

	environ = nenv;
#ifdef BSDINETD
	close(1); close(2);
	dup(0); dup(0);
	hisaddrlen = sizeof (hisctladdr);
	if (getpeername(0, (struct sockaddr *)&hisctladdr, &hisaddrlen) < 0) {
		fprintf(stderr, "%s: ", argv[0]);
		perror("getpeername");
		_exit(1);
	}
	if ((childpid = fork()) == 0)
		doit((struct sockaddr *)&hisctladdr);
	snprintf(utline, sizeof(utline), "uucp%.4ld", (long)childpid);
	dologout();
	exit(1);
#else /* !BSDINETD */
	sp = getservbyname("uucp", "tcp");
	if (sp == NULL){
		perror("uucpd: getservbyname");
		exit(1);
	}
	if (fork())
		exit(0);
	snprintf(utline, sizeof(utline), "uucp%.4ld", (long)childpid);

	if ((s = open(_PATH_TTY, 2)) >= 0){
		ioctl(s, TIOCNOTTY, (char *)0);
		close(s);
	}

	bzero((char *)&myctladdr, sizeof (myctladdr));
	myctladdr.sin_len = sizeof(struct sockaddr_in);
	myctladdr.sin_family = AF_INET;
	myctladdr.sin_port = sp->s_port;
	tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (tcp_socket < 0) {
		perror("uucpd: socket");
		exit(1);
	}
	if (bind(tcp_socket, (char *)&myctladdr, sizeof (myctladdr)) < 0) {
		perror("uucpd: bind");
		exit(1);
	}
	listen(tcp_socket, 3);	/* at most 3 simultaneuos uucp connections */
	signal(SIGCHLD, dologout);

	for(;;) {
		s = accept(tcp_socket, &hisctladdr, &hisaddrlen);
		if (s < 0){
			if (errno == EINTR || errno == EWOULDBLOCK ||
			    errno == ECONNABORTED)
				continue;
			perror("uucpd: accept");
			exit(1);
		}
		if (fork() == 0) {
			close(0); close(1); close(2);
			dup(s); dup(s); dup(s);
			close(tcp_socket); close(s);
			doit(&hisctladdr);
			exit(1);
		}
		close(s);
	}
#endif	/* !BSDINETD */
}

void
doit(struct sockaddr *sa)
{
	char user[64], passwd[64];
	char *xpasswd;
	struct passwd *pw;

	alarm(60);
	do {
		printf("login: ");
		fflush(stdout);
		if (readline(user, sizeof user) < 0) {
			fprintf(stderr, "user read\n");
			return;
		}
	} while (user[0] == '\0');
	user[MAXLOGNAME] = '\0';

	pw = getpwnam(user);
	if (pw == NULL) {
		printf("Password: ");
		fflush(stdout);
		if (readline(passwd, sizeof passwd) < 0) {
			fprintf(stderr, "passwd read\n");
			return;
		}
		fprintf(stderr, "Login incorrect.");
		return;
	}
	if (pw->pw_passwd && *pw->pw_passwd != '\0') {
		printf("Password: ");
		fflush(stdout);
		if (readline(passwd, sizeof passwd) < 0) {
			fprintf(stderr, "passwd read\n");
			return;
		}
		xpasswd = crypt(passwd, pw->pw_passwd);
		if (strcmp(xpasswd, pw->pw_passwd)) {
			fprintf(stderr, "Login incorrect.");
			return;
		}
	}
	if (strcmp(pw->pw_shell, _PATH_UUCICO)) {
		fprintf(stderr, "Login incorrect.\n");
		return;
	}
	alarm(0);
	(void) snprintf(Username, sizeof(Username), "USER=%s", user);
	(void) snprintf(Loginname, sizeof(Loginname), "LOGNAME=%s", user);
	dologin(pw, sa);
	if (setusercontext(0, pw, pw->pw_uid, LOGIN_SETALL) != 0) {
		perror("unable to set user context");
		return;
	}
	chdir(pw->pw_dir);
	execl(_PATH_UUCICO, "uucico", (char *)NULL);
	perror("uucico server: execl");
}

int
readline(char *p, int n)
{
	char c;

	while (n-- > 0) {
		if (read(STDIN_FILENO, &c, 1) <= 0)
			return(-1);
		c &= 0177;
		if (c == '\r') {
			*p = '\0';
			return(0);
		}
		if (c != '\n')
			*p++ = c;
	}
	return(-1);
}

#define	SCPYN(a, b)	strncpy(a, b, sizeof (a))

struct	utmp utmp;

void
dologout(void)
{
	int save_errno = errno;
	int status, wtmp;
	pid_t pid;

#ifdef BSDINETD
	while ((pid=wait(&status)) > 0) {
#else  /* !BSDINETD */
	while ((pid=wait3(&status, WNOHANG, 0)) > 0) {
#endif /* !BSDINETD */
		wtmp = open(_PATH_WTMP, O_WRONLY|O_APPEND);
		if (wtmp >= 0) {
			SCPYN(utmp.ut_line, utline);
			SCPYN(utmp.ut_name, "");
			SCPYN(utmp.ut_host, "");
			(void) time(&utmp.ut_time);
			(void) write(wtmp, (char *)&utmp, sizeof (utmp));
			(void) close(wtmp);
		}
	}
	errno = save_errno;
}

/*
 * Record login in wtmp file.
 */
void
dologin(struct passwd *pw, struct sockaddr *sa)
{
	char line[32];
	char hbuf[NI_MAXHOST];
	int wtmp, f;

	if (getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf), NULL, 0, 0))
		(void)strlcpy(hbuf, "?", sizeof(hbuf));
	wtmp = open(_PATH_WTMP, O_WRONLY|O_APPEND);
	if (wtmp >= 0) {
		/* hack, but must be unique and no tty line */
		(void) snprintf(line, sizeof line, "uucp%.4ld", (long)getpid());
		SCPYN(utmp.ut_line, line);
		SCPYN(utmp.ut_name, pw->pw_name);
		SCPYN(utmp.ut_host, hbuf);
		time(&utmp.ut_time);
		(void) write(wtmp, (char *)&utmp, sizeof (utmp));
		(void) close(wtmp);
	}
	if ((f = open(_PATH_LASTLOG, O_RDWR)) >= 0) {
		struct lastlog ll;

		time(&ll.ll_time);
		lseek(f, pw->pw_uid * sizeof(struct lastlog), SEEK_SET);
		SCPYN(ll.ll_line, hbuf);
		SCPYN(ll.ll_host, hbuf);
		(void) write(f, (char *) &ll, sizeof ll);
		(void) close(f);
	}
}
@


1.33
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.32 2009/10/27 23:59:32 deraadt Exp $	*/
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.31 2006/04/02 00:48:55 deraadt Exp $	*/
d139 2
a140 1
			if (errno == EINTR)
@


1.31
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.30 2005/04/13 02:33:09 deraadt Exp $	*/
a33 11

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1985 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)uucpd.c	5.10 (Berkeley) 2/26/91";*/
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.30 2005/04/13 02:33:09 deraadt Exp $";
#endif /* not lint */
@


1.30
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.29 2004/06/02 02:21:15 brad Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.29 2004/06/02 02:21:15 brad Exp $";
d301 1
a301 1
		lseek(f, pw->pw_uid * sizeof(struct lastlog), 0);
@


1.29
log
@IPv6 support.

From NetBSD

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.28 2004/05/27 19:15:45 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.28 2004/05/27 19:15:45 deraadt Exp $";
d232 1
a232 1
		if (read(0, &c, 1) <= 0)
@


1.28
log
@accept login names over 8 chars; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.27 2003/07/29 18:39:23 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.27 2003/07/29 18:39:23 deraadt Exp $";
d72 1
a72 1
void doit(struct sockaddr_in *);
d75 1
a75 1
void dologin(struct passwd *, struct sockaddr_in *);
d77 1
a77 1
struct	sockaddr_in hisctladdr;
a78 1
struct	sockaddr_in myctladdr;
d112 1
a112 1
		doit(&hisctladdr);
d168 1
a168 1
doit(struct sockaddr_in *sinp)
d216 1
a216 1
	dologin(pw, sinp);
d278 1
a278 1
dologin(struct passwd *pw, struct sockaddr_in *sin)
d281 1
a281 1
	char remotehost[MAXHOSTNAMELEN];
a282 11
	struct hostent *hp;

	hp = gethostbyaddr((char *)&sin->sin_addr,
	    sizeof (struct in_addr), AF_INET);

	if (hp) {
		strlcpy(remotehost, hp->h_name, sizeof(remotehost));
		endhostent();
	} else
		strlcpy(remotehost, inet_ntoa(sin->sin_addr),
		    sizeof(remotehost));
d284 2
d292 1
a292 1
		SCPYN(utmp.ut_host, remotehost);
d302 2
a303 2
		SCPYN(ll.ll_line, remotehost);
		SCPYN(ll.ll_host, remotehost);
@


1.27
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.26 2003/06/02 19:38:25 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.26 2003/06/02 19:38:25 millert Exp $";
d184 2
a185 2
	/* truncate username to 8 characters */
	user[8] = '\0';
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.25 2002/09/06 19:43:54 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.25 2002/09/06 19:43:54 deraadt Exp $";
d151 1
a151 1
			if (errno == EINTR) 
@


1.25
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.24 2002/07/03 23:39:03 deraadt Exp $";
@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.23 2002/05/26 09:32:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.23 2002/05/26 09:32:08 deraadt Exp $";
d82 1
a82 1
int	hisaddrlen = sizeof hisctladdr;
@


1.23
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.22 2002/05/22 06:35:44 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.22 2002/05/22 06:35:44 deraadt Exp $";
d98 1
a98 3
main(argc, argv)
int argc;
char **argv;
d131 1
a131 1
	if ((s=open(_PATH_TTY, 2)) >= 0){
d173 1
a173 2
doit(sinp)
struct sockaddr_in *sinp;
d176 2
a177 2
	char *xpasswd, *crypt();
	struct passwd *pw, *getpwnam();
d232 1
a232 3
readline(p, n)
char *p;
int n;
d255 1
a255 1
dologout()
d283 1
a283 3
dologin(pw, sin)
struct passwd *pw;
struct sockaddr_in *sin;
@


1.22
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.21 2002/02/16 21:27:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.21 2002/02/16 21:27:31 millert Exp $";
d82 1
a82 1
int hisaddrlen = sizeof hisctladdr;
d84 1
a84 1
int mypid;
d120 1
a120 1
	snprintf(utline, sizeof(utline), "uucp%.4d", childpid);
d131 1
a131 1
	snprintf(utline, sizeof(utline), "uucp%.4d", childpid);
d263 2
a264 1
	int status, pid, wtmp;
d310 1
a310 1
		(void) snprintf(line, sizeof line, "uucp%.4d", getpid());
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.20 2001/12/07 18:45:33 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.20 2001/12/07 18:45:33 mpech Exp $";
d309 1
a309 1
		(void) sprintf(line, "uucp%.4d", getpid());
@


1.20
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.19 2001/07/09 07:04:45 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.19 2001/07/09 07:04:45 deraadt Exp $";
d76 4
a79 4
void doit __P((struct sockaddr_in *));
int readline __P((char *, int n));
void dologout __P((void));
void dologin __P((struct passwd *, struct sockaddr_in *));
@


1.19
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: uucpd.c,v 1.18 2001/01/28 19:34:35 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.18 2001/01/28 19:34:35 niklas Exp $";
d77 1
a77 1
int readline __P((register char *, register int n));
d103 1
a103 1
	register int s, tcp_socket;
d236 2
a237 2
register char *p;
register int n;
@


1.18
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: uucpd.c,v 1.17 2001/01/17 19:46:11 deraadt Exp $";
d230 1
a230 1
	execl(_PATH_UUCICO, "uucico", (char *)0);
@


1.17
log
@remove sprintf signal race, by pre-preparing wtmp entry
@
text
@d1 2
d47 1
a47 1
static char rcsid[] = "$Id: uucpd.c,v 1.16 2000/08/20 18:42:38 millert Exp $";
@


1.16
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.15 2000/02/01 03:23:23 deraadt Exp $";
d70 2
d90 1
d93 2
d104 1
d116 1
a116 1
	if (fork() == 0)
d118 1
d129 2
a252 3
#include <utmp.h>
#include <fcntl.h>

a259 1
	int status;
d261 1
a261 1
	int pid, wtmp;
d270 1
a270 1
			(void) sprintf(utmp.ut_line, "uucp%.4d", pid);
d292 4
a295 2
	struct hostent *hp = gethostbyaddr((char *)&sin->sin_addr,
		sizeof (struct in_addr), AF_INET);
d298 1
a298 1
		strncpy(remotehost, hp->h_name, sizeof(remotehost)-1);
d301 3
a303 3
		strncpy(remotehost, inet_ntoa(sin->sin_addr),
		    sizeof(remotehost)-1);
	remotehost[sizeof(remotehost)-1] = '\0';
@


1.15
log
@no need to extern int errno if errno.h is included
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.14 1998/07/05 18:48:58 deraadt Exp $";
d69 1
d214 4
a217 6
	setlogin(user);
	setegid(pw->pw_gid);
	setgid(pw->pw_gid);
	initgroups(pw->pw_name, pw->pw_gid);
	seteuid(pw->pw_uid);
	setuid(pw->pw_uid);
@


1.14
log
@man page; mrg
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.13 1998/05/22 04:33:08 deraadt Exp $";
a97 1
	extern int errno;
@


1.13
log
@stop username info gathering, always go through login/passwd cycle
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.12 1998/04/22 14:19:51 deraadt Exp $";
d173 2
a174 1
		printf("login: "); fflush(stdout);
d184 2
a185 1
		printf("Password: "); fflush(stdout);
d194 2
a195 1
		printf("Password: "); fflush(stdout);
d207 1
a207 1
		fprintf(stderr, "Login incorrect.");
@


1.12
log
@buf oflow; bmartin@@obscure.sekurity.org
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.11 1997/08/31 08:24:01 deraadt Exp $";
d183 5
a187 4
		fprintf(stderr, "user unknown\n");
		return;
	}
	if (strcmp(pw->pw_shell, _PATH_UUCICO)) {
d203 4
d312 1
a312 3
		strncpy(line, remotehost, sizeof line-1);
		line[sizeof line-1] = '\0';
		SCPYN(ll.ll_line, line);
@


1.11
log
@union wait dies
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.10 1997/08/04 19:25:13 deraadt Exp $";
d307 2
a308 1
		strcpy(line, remotehost);
@


1.11.4.1
log
@update release: buf oflow; bmartin@@obscure.sekurity.org
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.12 1998/04/22 14:19:51 deraadt Exp $";
d307 1
a307 2
		strncpy(line, remotehost, sizeof line-1);
		line[sizeof line-1] = '\0';
@


1.10
log
@save errno in sigchld handlers
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.9 1997/06/02 06:28:13 deraadt Exp $";
d248 1
a248 1
	union wait status;
d253 1
a253 1
	while ((pid=wait((int *)&status)) > 0) {
d255 1
a255 1
	while ((pid=wait3((int *)&status,WNOHANG,0)) > 0) {
@


1.9
log
@let uucpd prompt for loginname multiple times, if \r is a problem; tron@@lyssa.owl.de
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.8 1997/02/06 13:34:45 deraadt Exp $";
d249 1
d267 1
@


1.8
log
@expand hostname to MAXHOSTNAMELEN
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.7 1996/12/22 03:41:24 tholo Exp $";
d172 7
a178 5
	printf("login: "); fflush(stdout);
	if (readline(user, sizeof user) < 0) {
		fprintf(stderr, "user read\n");
		return;
	}
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.6 1996/12/03 01:29:54 deraadt Exp $";
d275 1
a275 1
	char remotehost[32];
@


1.6
log
@\r and \n must be distinguished in some cases (telnet); netbsd pr#2969;
darcy@@druid.com
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.5 1996/10/26 04:59:20 millert Exp $";
d205 1
d208 1
@


1.5
log
@set $LOGNAME and pass -Wall
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.4 1996/09/02 13:12:23 deraadt Exp $";
d224 1
a224 1
		if (c == '\n' || c == '\r') {
d228 2
a229 1
		*p++ = c;
@


1.4
log
@setlogin
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.3 1996/08/27 10:23:00 deraadt Exp $";
d71 5
d81 1
a81 1
char Username[64];
d84 1
d89 1
a98 1
	int dologout();
d163 1
d201 2
a202 1
	sprintf(Username, "USER=%s", user);
d213 1
d240 1
d253 1
a253 1
			sprintf(utmp.ut_line, "uucp%.4d", pid);
d266 1
d287 1
a287 1
		sprintf(line, "uucp%.4d", getpid());
@


1.3
log
@strncpy correctly
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.2 1996/07/22 02:00:12 deraadt Exp $";
d196 1
@


1.2
log
@do not chdir as root
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.1.1.1 1995/10/18 08:43:25 deraadt Exp $";
d266 1
a266 1
		strncpy(remotehost, hp->h_name, sizeof (remotehost));
d270 2
a271 1
		    sizeof (remotehost));
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
static char rcsid[] = "$Id: uucpd.c,v 1.4 1995/06/03 22:48:48 mycroft Exp $";
d198 1
a199 1
	setuid(pw->pw_uid);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
