head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2;
locks; strict;
comment	@ * @;


1.16
date	2016.09.03.11.01.44;	author gsoares;	state Exp;
branches;
next	1.15;
commitid	DCW0sY9KHDSPPLXZ;

1.15
date	2016.08.16.04.44.38;	author tedu;	state Exp;
branches;
next	1.14;
commitid	lwsnf8drFDMgS8ET;

1.14
date	2016.04.24.18.52.52;	author benno;	state Exp;
branches;
next	1.13;
commitid	FS4XKu66nXQgz1b3;

1.13
date	2015.10.22.23.56.30;	author bmercer;	state Exp;
branches;
next	1.12;
commitid	msjcTAx29786VX6p;

1.12
date	2015.10.05.16.09.56;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	s51uhUE7RXGCrwIY;

1.11
date	2015.09.22.21.47.37;	author millert;	state Exp;
branches;
next	1.10;
commitid	NcEIFVlQZTYF9om3;

1.10
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	Uu5nFG3wCl0LACBb;

1.9
date	2014.05.28.12.59.03;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.02.15.34.13;	author benno;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.04.18.49.12;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.23.00.50.44;	author halex;	state Exp;
branches;
next	1.4;

1.4
date	2012.02.01.16.07.28;	author dhill;	state Exp;
branches;
next	1.3;

1.3
date	2012.01.31.16.58.38;	author sobrado;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.20.01.41.57;	author dhill;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.18.15.49.46;	author dhill;	state Exp;
branches;
next	;


desc
@@


1.16
log
@convert to use readpassphrase() instead of DEPRECATED/getpass()
OK millert@@
@
text
@/* $OpenBSD: login_yubikey.c,v 1.15 2016/08/16 04:44:38 tedu Exp $ */

/*
 * Copyright (c) 2010 Daniel Hartmeier <daniel@@benzedrine.cx>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/unistd.h>
#include <ctype.h>
#include <login_cap.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

#include "yubikey.h"

#define	MODE_LOGIN	0
#define	MODE_CHALLENGE	1
#define	MODE_RESPONSE	2

#define	AUTH_OK		0
#define	AUTH_FAILED	-1

static const char *path = "/var/db/yubikey";

static int clean_string(const char *);
static int yubikey_login(const char *, const char *);

int
main(int argc, char *argv[])
{
	int ch, ret, mode = MODE_LOGIN, count;
	FILE *f = NULL;
	char *username, *password = NULL;
	char pbuf[1024];
	char response[1024];

	setpriority(PRIO_PROCESS, 0, 0);

	if (pledge("stdio tty wpath rpath cpath", NULL) == -1) {
		syslog(LOG_AUTH|LOG_ERR, "pledge: %m");
		exit(EXIT_FAILURE);
	}

	openlog(NULL, LOG_ODELAY, LOG_AUTH);

	while ((ch = getopt(argc, argv, "dv:s:")) != -1) {
		switch (ch) {
		case 'd':
			f = stdout;
			break;
		case 'v':
			break;
		case 's':
			if (!strcmp(optarg, "login"))
				mode = MODE_LOGIN;
			else if (!strcmp(optarg, "response"))
				mode = MODE_RESPONSE;
			else if (!strcmp(optarg, "challenge"))
				mode = MODE_CHALLENGE;
			else {
				syslog(LOG_ERR, "%s: invalid service", optarg);
				exit(EXIT_FAILURE);
			}
			break;
		default:
			syslog(LOG_ERR, "usage error1");
			exit(EXIT_FAILURE);
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 2 && argc != 1) {
		syslog(LOG_ERR, "usage error2");
		exit(EXIT_FAILURE);
	}
	username = argv[0];
	/* passed by sshd(8) for non-existing users */
	if (!strcmp(username, "NOUSER"))
		exit(EXIT_FAILURE);
	if (!clean_string(username)) {
		syslog(LOG_ERR, "clean_string username");
		exit(EXIT_FAILURE);
	}

	if (f == NULL && (f = fdopen(3, "r+")) == NULL) {
		syslog(LOG_ERR, "user %s: fdopen: %m", username);
		exit(EXIT_FAILURE);
	}

	switch (mode) {
	case MODE_LOGIN:
		if ((password = readpassphrase("Password:", pbuf, sizeof(pbuf),
			    RPP_ECHO_OFF)) == NULL) {
			syslog(LOG_ERR, "user %s: readpassphrase: %m",
			    username);
			exit(EXIT_FAILURE);
		}
		break;
	case MODE_CHALLENGE:
		/* see login.conf(5) section CHALLENGES */
		fprintf(f, "%s\n", BI_SILENT);
		exit(EXIT_SUCCESS);
		break;
	case MODE_RESPONSE:
		/* see login.conf(5) section RESPONSES */
		/* this happens e.g. when called from sshd(8) */
		mode = 0;
		count = -1;
		while (++count < sizeof(response) &&
		    read(3, &response[count], 1) == 1) {
			if (response[count] == '\0' && ++mode == 2)
				break;
			if (response[count] == '\0' && mode == 1)
				password = response + count + 1;
		}
		if (mode < 2) {
			syslog(LOG_ERR, "user %s: protocol error "
			    "on back channel", username);
			exit(EXIT_FAILURE);
		}
		break;
	}

	ret = yubikey_login(username, password);
	explicit_bzero(password, strlen(password));
	if (ret == AUTH_OK) {
		syslog(LOG_INFO, "user %s: authorize", username);
		fprintf(f, "%s\n", BI_AUTH);
	} else {
		syslog(LOG_INFO, "user %s: reject", username);
		fprintf(f, "%s\n", BI_REJECT);
	}
	closelog();
	return (EXIT_SUCCESS);
}

static int
clean_string(const char *s)
{
	while (*s) {
		if (!isalnum((unsigned char)*s) && *s != '-' && *s != '_')
			return (0);
		++s;
	}
	return (1);
}

static int
yubikey_login(const char *username, const char *password)
{
	char fn[PATH_MAX];
	char hexkey[33], key[YUBIKEY_KEY_SIZE];
	char hexuid[13], uid[YUBIKEY_UID_SIZE];
	FILE *f;
	yubikey_token_st tok;
	u_int32_t last_ctr = 0, ctr;
	int r, i = 0, mapok = 0, crcok = 0;

	snprintf(fn, sizeof(fn), "%s/%s.uid", path, username);
	if ((f = fopen(fn, "r")) == NULL) {
		syslog(LOG_ERR, "user %s: fopen: %s: %m", username, fn);
		return (AUTH_FAILED);
	}
	if (fscanf(f, "%12s", hexuid) != 1) {
		syslog(LOG_ERR, "user %s: fscanf: %s: %m", username, fn);
		fclose(f);
		return (AUTH_FAILED);
	}
	fclose(f);

	snprintf(fn, sizeof(fn), "%s/%s.key", path, username);
	if ((f = fopen(fn, "r")) == NULL) {
		syslog(LOG_ERR, "user %s: fopen: %s: %m", username, fn);
		return (AUTH_FAILED);
	}
	if (fscanf(f, "%32s", hexkey) != 1) {
		syslog(LOG_ERR, "user %s: fscanf: %s: %m", username, fn);
		fclose(f);
		return (AUTH_FAILED);
	}
	fclose(f);
	if (strlen(hexkey) != 32) {
		syslog(LOG_ERR, "user %s: key len != 32", username);
		return (AUTH_FAILED);
	}

	snprintf(fn, sizeof(fn), "%s/%s.ctr", path, username);
	if ((f = fopen(fn, "r")) != NULL) {
		if (fscanf(f, "%u", &last_ctr) != 1)
			last_ctr = 0;
		fclose(f);
	}

	yubikey_hex_decode(uid, hexuid, YUBIKEY_UID_SIZE);
	yubikey_hex_decode(key, hexkey, YUBIKEY_KEY_SIZE);

	explicit_bzero(hexkey, sizeof(hexkey));

	/*
	 * Cycle through the key mapping table.
         * XXX brute force, unoptimized; a lookup table for valid mappings may
	 * be appropriate.
	 */
	while (1) {
		r = yubikey_parse((uint8_t *)password, (uint8_t *)key, &tok, i++);
		switch (r) {
		case EMSGSIZE:
			syslog(LOG_INFO, "user %s failed: password too short.",
			    username);
			explicit_bzero(key, sizeof(key));
			return (AUTH_FAILED);
		case EINVAL:	/* keyboard mapping invalid */
			continue;
		case 0:		/* found a valid keyboard mapping */
			mapok++;
			if (!yubikey_crc_ok_p((uint8_t *)&tok))
				continue;	/* try another one */
			crcok++;
			syslog(LOG_DEBUG, "user %s: crc %04x ok",
			    username, tok.crc);

			if (memcmp(tok.uid, uid, YUBIKEY_UID_SIZE)) {
				char h[13];

				yubikey_hex_encode(h, (const char *)tok.uid,
				    YUBIKEY_UID_SIZE);
				syslog(LOG_DEBUG, "user %s: uid %s != %s",
				    username, h, hexuid);
				continue;	/* try another one */
			}
			break; /* uid matches */
		case -1:
			syslog(LOG_INFO, "user %s: could not decode password "
			    "with any keymap (%d crc ok)",
			    username, crcok);
			explicit_bzero(key, sizeof(key));
			return (AUTH_FAILED);
		default:
			syslog(LOG_DEBUG, "user %s failed: %s",
			    username, strerror(r));
			explicit_bzero(key, sizeof(key));
			return (AUTH_FAILED);
		}
		break; /* only reached through the bottom of case 0 */
	}

	explicit_bzero(key, sizeof(key));

	syslog(LOG_INFO, "user %s uid %s: %d matching keymaps (%d checked), "
	    "%d crc ok", username, hexuid, mapok, i, crcok);

	ctr = ((u_int32_t)yubikey_counter(tok.ctr) << 8) | tok.use;
	if (ctr <= last_ctr) {
		syslog(LOG_INFO, "user %s: counter %u.%u <= %u.%u "
		    "(REPLAY ATTACK!)", username, ctr / 256, ctr % 256,
		    last_ctr / 256, last_ctr % 256);
		return (AUTH_FAILED);
	}
	syslog(LOG_INFO, "user %s: counter %u.%u > %u.%u",
	    username, ctr / 256, ctr % 256, last_ctr / 256, last_ctr % 256);
	umask(S_IRWXO);
	if ((f = fopen(fn, "w")) == NULL) {
		syslog(LOG_ERR, "user %s: fopen: %s: %m", username, fn);
		return (AUTH_FAILED);
	}
	fprintf(f, "%u", ctr);
	fclose(f);

	return (AUTH_OK);
}
@


1.15
log
@remove unneeded casts
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.14 2016/04/24 18:52:52 benno Exp $ */
d40 1
d70 1
d128 3
a130 2
		if ((password = getpass("Password:")) == NULL) {
			syslog(LOG_ERR, "user %s: getpass: %m",
@


1.14
log
@explicit_bzero some keys after use.
From fritjof () alokat ! org, thanks!

ok semarie@@
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.13 2015/10/22 23:56:30 bmercer Exp $ */
d143 1
a143 2
		    read(3, &response[count], (size_t)1) ==
		    (ssize_t)1) {
@


1.13
log
@Add pledge support to login_yubikey. Much feedback and OK millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.12 2015/10/05 16:09:56 deraadt Exp $ */
d231 2
d244 1
d270 1
d275 1
d280 2
@


1.12
log
@KNF a switch statement, moving a local variable up a frame as well -
carefully.
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.11 2015/09/22 21:47:37 millert Exp $ */
d36 1
d72 6
@


1.11
log
@Use explicit_bzero() to zero out the password.  From Michael McConville.
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.10 2015/01/16 06:39:50 deraadt Exp $ */
d65 1
a65 1
	int ch, ret, mode = MODE_LOGIN;
d118 29
a146 33
		case MODE_LOGIN:
			if ((password = getpass("Password:")) == NULL) {
				syslog(LOG_ERR, "user %s: getpass: %m",
				    username);
				exit(EXIT_FAILURE);
			}
			break;
		case MODE_CHALLENGE:
			/* see login.conf(5) section CHALLENGES */
			fprintf(f, "%s\n", BI_SILENT);
			exit(EXIT_SUCCESS);
			break;
		case MODE_RESPONSE: {
			/* see login.conf(5) section RESPONSES */
			/* this happens e.g. when called from sshd(8) */
			int count;
			mode = 0;
			count = -1;
			while (++count < sizeof(response) &&
			    read(3, &response[count], (size_t)1) ==
			    (ssize_t)1) {
				if (response[count] == '\0' && ++mode == 2)
					break;
				if (response[count] == '\0' && mode == 1) {
					password = response + count + 1;
				}
			}
			if (mode < 2) {
				syslog(LOG_ERR, "user %s: protocol error "
				    "on back channel", username);
				exit(EXIT_FAILURE);
			}
			break;
d148 1
d224 1
a224 1
	/* 
d236 1
a236 1
		case EINVAL: 	/* keyboard mapping invalid */
d261 1
a261 1
		default: 
@


1.10
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.9 2014/05/28 12:59:03 otto Exp $ */
d155 1
a155 1
	memset(password, 0, strlen(password));
@


1.9
log
@missing space in error message
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.8 2013/11/27 21:25:25 deraadt Exp $ */
a32 1
#include <sys/param.h>
d45 1
d181 1
a181 1
	char fn[MAXPATHLEN];
@


1.8
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.7 2013/11/02 15:34:13 benno Exp $ */
d260 1
a260 1
			syslog(LOG_INFO, "user %s: could not decode password"
@


1.7
log
@do not log passwords, even if they are wrong.
ok mcbride halex
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.6 2013/06/04 18:49:12 mcbride Exp $ */
d171 1
a171 1
		if (!isalnum(*s) && *s != '-' && *s != '_')
@


1.6
log
@Add handling for keyboard layouts which break modhex (like dvorak and many
others); concept and keymap table (covering about 400 layouts) from
modhex.js by Daniel Holth.

ok sthen@@, ok halex@@ (who also provided much testing and feedback)
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.5 2012/12/23 00:50:44 halex Exp $ */
d236 2
a237 2
			syslog(LOG_INFO, "user %s failed: password %s: %s",
			    username, password, "too short.");
d260 1
a260 1
			syslog(LOG_INFO, "user %s: %p could not decode "
d262 1
a262 1
			    username, password, crcok);
d265 2
a266 2
			syslog(LOG_DEBUG, "user %s failed: %s: %s",
			    username, password, strerror(r));
@


1.5
log
@Make the per-user counter file r/w by group auth

xlock issue pointed out and diff tested by Andreas Bartelt, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.4 2012/02/01 16:07:28 dhill Exp $ */
d46 1
d187 1
a187 8

	if (strlen(password) > 32)
		password = password + strlen(password) - 32;
	if (strlen(password) != 32) {
		syslog(LOG_INFO, "user %s: password len %zu != 32",
		    username, strlen(password));
		return (AUTH_FAILED);
	}
d226 44
a269 5
	yubikey_parse((uint8_t *)password, (uint8_t *)key, &tok);
	if (!yubikey_crc_ok_p((uint8_t *)&tok)) {
		syslog(LOG_DEBUG, "user %s: crc %04x failed: %s",
		    username, tok.crc, password);
		return (AUTH_FAILED);
a270 4
	syslog(LOG_DEBUG, "user %s: crc %04x ok", username, tok.crc);

	if (memcmp(tok.uid, uid, YUBIKEY_UID_SIZE)) {
		char h[13];
d272 2
a273 5
		yubikey_hex_encode(h, (const char *)tok.uid, YUBIKEY_UID_SIZE);
		syslog(LOG_INFO, "user %s: uid %s != %s", username, h, hexuid);
		return (AUTH_FAILED);
	}
	syslog(LOG_DEBUG, "user %s: uid %s matches", username, hexuid);
@


1.4
log
@document login_yubikey options
ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.3 2012/01/31 16:58:38 sobrado Exp $ */
d34 1
d258 1
@


1.3
log
@remove superfluous RCS identifiers; while here, indent identifier
on Makefile to match style used by other login_* utilities.

ok dhill@@
@
text
@d1 1
a1 1
/* $OpenBSD: login_yubikey.c,v 1.2 2012/01/20 01:41:57 dhill Exp $ */
a76 1
			syslog(LOG_INFO, "-v %s", optarg);
@


1.2
log
@Do not log the password at LOG_INFO, but at LOG_DEBUG instead.
Change the successes from LOG_INFO to LOG_DEBUG as well.
@
text
@d1 1
a1 2
/* $OpenBSD: login_yubikey.c,v 1.1 2012/01/18 15:49:46 dhill Exp $ */
/* $Id: login_yubikey.c,v 1.1 2012/01/18 15:49:46 dhill Exp $ */
@


1.1
log
@Welcome dhartmei@@'s login_yubikey.  To be worked on in-tree.

ok millert@@
support from mcbride@@ and others
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $Id: login_yubikey.c,v 1.1.1.1 2010/03/16 14:13:08 dhartmei Exp $ */
d61 2
a62 1
int main(int argc, char *argv[])
d191 2
a192 2
		syslog(LOG_INFO, "user %s: password %s: len %d != 32",
		    username, password, (int)strlen(password));
d235 1
a235 1
		syslog(LOG_INFO, "user %s: crc %04x failed: %s",
d239 1
a239 1
	syslog(LOG_INFO, "user %s: crc %04x ok", username, tok.crc);
d248 1
a248 1
	syslog(LOG_INFO, "user %s: uid %s matches", username, hexuid);
@

