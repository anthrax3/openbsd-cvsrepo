head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.14
	OPENBSD_5_0:1.25.0.12
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.10
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.8
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.4
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.10
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.8
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.6
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.28
date	2014.04.22.11.06.22;	author reyk;	state dead;
branches;
next	1.27;

1.27
date	2013.06.21.13.35.26;	author ajacoutot;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.01.01.43.19;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.14.14.53.44;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.24.14.04.19;	author todd;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.13.00.27.56;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.12.13.28.00;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.13.18.46.03;	author biorn;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.06.10.47.27;	author biorn;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.07.11.12.38;	author hin;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.06.18.45.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.30.06.09.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.22.06.35.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.27.09.52.45;	author hin;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.06.09.18.31;	author hin;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.12.21.55.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.26.05.03.27;	author hin;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.22.02.13;	author hin;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.21.36.49;	author hin;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.18.58.59;	author hin;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.15.49.21;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.14.21.30;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.25.05.23.13;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.02.54.02;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.25.02.52.41;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.01.04.41;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.00.07.08;	author hin;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Remove the kerberos login methods.
@
text
@/*	$OpenBSD: login_krb5.c,v 1.27 2013/06/21 13:35:26 ajacoutot Exp $	*/

/*-
 * Copyright (c) 2001, 2002 Hans Insulander <hin@@openbsd.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "common.h"

#include <kerberosV/krb5.h>

krb5_error_code ret;
krb5_context context;
krb5_ccache ccache;
krb5_principal princ;

char *__progname;

static void
krb5_syslog(krb5_context context, int level, krb5_error_code code, char *fmt, ...)
{
	va_list ap;
	char buf[256];
	const char *s = krb5_get_error_message(context, code);

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	syslog(level, "%s: %s", buf, s);
	krb5_free_error_message(context, s);
}

static void
store_tickets(struct passwd *pwd, int ticket_newfiles, int ticket_store,
    int token_install)
{
	char cc_file[MAXPATHLEN];
	krb5_ccache ccache_store;
#ifdef KRB524
	int get_krb4_ticket = 0;
	char krb4_ticket_file[MAXPATHLEN];
#endif

	if (ticket_newfiles)
		snprintf(cc_file, sizeof(cc_file), "FILE:/tmp/krb5cc_%d",
		    pwd->pw_uid);
	else
		snprintf(cc_file, sizeof(cc_file), "%s",
		    krb5_cc_default_name(context));

	if (ticket_store) {
		ret = krb5_cc_resolve(context, cc_file, &ccache_store);
		if (ret != 0) {
			krb5_syslog(context, LOG_ERR, ret,
			    "krb5_cc_resolve");
			exit(1);
		}

		ret = krb5_cc_copy_cache(context, ccache, ccache_store);
		if (ret != 0)
			krb5_syslog(context, LOG_ERR, ret,
			    "krb5_cc_copy_cache");

		chown(krb5_cc_get_name(context, ccache_store),
		    pwd->pw_uid, pwd->pw_gid);

		fprintf(back, BI_SETENV " KRB5CCNAME %s:%s\n",
		    krb5_cc_get_type(context, ccache_store),
		    krb5_cc_get_name(context, ccache_store));

#ifdef KRB524
		get_krb4_ticket = krb5_config_get_bool_default (context,
		    NULL, get_krb4_ticket, "libdefaults",
		    "krb4_get_tickets", NULL);
		if (get_krb4_ticket) {
			CREDENTIALS c;
			krb5_creds cred;
			krb5_cc_cursor cursor;

			ret = krb5_cc_start_seq_get(context, ccache, &cursor);
			if (ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
				    "start seq");
				exit(1);
			}

			ret = krb5_cc_next_cred(context, ccache,
			    &cursor, &cred);
			if (ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
				    "next cred");
				exit(1);
			}

			ret = krb5_cc_end_seq_get(context, ccache,
			    &cursor);
			if (ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
				    "end seq");
				exit(1);
			}

			ret = krb524_convert_creds_kdc_ccache(context, ccache,
			    &cred, &c);
			if (ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
				    "convert");
			} else {
				snprintf(krb4_ticket_file,
				    sizeof(krb4_ticket_file),
				    "%s%d", TKT_ROOT, pwd->pw_uid);
				krb_set_tkt_string(krb4_ticket_file);
				tf_setup(&c, c.pname, c.pinst);
				chown(krb4_ticket_file,
				    pwd->pw_uid, pwd->pw_gid);
			}
		}
#endif
	}

	/* Need to chown the ticket file */
#ifdef KRB524
	if (get_krb4_ticket)
		fprintf(back, BI_SETENV " KRBTKFILE %s\n",
		    krb4_ticket_file);
#endif
}

int
krb5_login(char *username, char *invokinguser, char *password, int login,
    int tickets, char *class)
{
	login_cap_t *lc;
	int return_code = AUTH_FAILED;
	int noverify = 0;

	if (username == NULL || password == NULL)
		return (AUTH_FAILED);

	if (strcmp(__progname, "krb5-or-pwd") == 0 &&
	    strcmp(username,"root") == 0 && invokinguser[0] == '\0')
		return (AUTH_FAILED);

	lc = login_getclass(class);
	if (lc != NULL)
		noverify = login_getcapbool(lc, "krb5-noverify", noverify);

	ret = krb5_init_context(&context);
	if (ret != 0) {
		krb5_syslog(context, LOG_ERR, ret, "krb5_init_context");
		exit(1);
	}

	ret = krb5_cc_new_unique(context, krb5_mcc_ops.prefix, NULL, &ccache);
	if (ret != 0) {
		krb5_syslog(context, LOG_ERR, ret, "krb5_cc_new_unique");
		exit(1);
	}

	if (strcmp(username, "root") == 0 && invokinguser[0] != '\0') {
		char *tmp;

		ret = asprintf(&tmp, "%s/root", invokinguser);
		if (ret == -1) {
			krb5_syslog(context, LOG_ERR, ret, "asprintf");
			exit(1);
		}
		ret = krb5_parse_name(context, tmp, &princ);
		free(tmp);
	} else
		ret = krb5_parse_name(context, username, &princ);
	if (ret != 0) {
		krb5_syslog(context, LOG_ERR, ret, "krb5_parse_name");
		exit(1);
	}

	ret = krb5_verify_user_lrealm(context, princ, ccache,
	    password, !noverify, NULL);

	switch (ret) {
	case 0: {
		struct passwd *pwd;

		pwd = getpwnam(username);
		if (pwd == NULL) {
			krb5_syslog(context, LOG_ERR, ret,
			    "%s: no such user", username);
			return (AUTH_FAILED);
		}
		fprintf(back, BI_AUTH "\n");
		store_tickets(pwd, login && tickets, login && tickets, login);
		return_code = AUTH_OK;
		break;
	}
	case KRB5KRB_AP_ERR_MODIFIED:
		/* XXX syslog here? */
	case KRB5KRB_AP_ERR_BAD_INTEGRITY:
		break;
	default:
		krb5_syslog(context, LOG_ERR, ret, "verify");
		break;
	}

	krb5_free_principal(context, princ);
	krb5_cc_close(context, ccache);
	krb5_free_context(context);

	return (return_code);
}
@


1.27
log
@Stop using deprecated Kerberos functions.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.26 2012/06/01 01:43:19 dlg Exp $	*/
@


1.26
log
@add a krb5-noverify option for login.conf that disables verification
of the server against a local host keytab file when you're authing
users with login_krb5. useful for when you need to auth users but
dealing with the domain admins is painful...

ok sthen@@ jj@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.25 2009/01/14 14:53:44 jacekm Exp $	*/
d45 1
d50 2
a51 1
	syslog(level, "%s: %s", buf, krb5_get_err_text(context, code));
d76 1
a76 1
			    "krb5_cc_gen_new");
d175 1
a175 1
	ret = krb5_cc_gen_new(context, &krb5_mcc_ops, &ccache);
d177 1
a177 1
		krb5_syslog(context, LOG_ERR, ret, "krb5_cc_gen_new");
@


1.25
log
@context could be used after being freed by krb5_free_context; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.24 2008/04/24 14:04:19 todd Exp $	*/
d150 1
a150 1
    int tickets)
d152 1
d154 1
d163 4
d197 1
a197 1
	    password, 1, NULL);
@


1.24
log
@compare strings with reality for expected behavior; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.23 2005/11/13 00:27:56 deraadt Exp $	*/
a216 1
	krb5_free_context(context);
d219 1
@


1.23
log
@handle asprintf() failure; from dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.22 2005/11/12 13:28:00 deraadt Exp $	*/
d157 1
a157 1
	if (strcmp(__progname, "login_krb5-or-pwd") == 0 &&
@


1.22
log
@use snprintf; ok cloder dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.21 2005/04/13 18:46:03 biorn Exp $	*/
d176 5
a180 1
		asprintf(&tmp, "%s/root", invokinguser);
@


1.21
log
@
Do as login_krb5-or-pwd(8) says: "When root tries to login,
     login_krb5-or-pwd skips KerberosV authentication,"

ok beck@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.20 2005/03/06 10:47:27 biorn Exp $	*/
a174 1
		int len = strlen(invokinguser)+6;
d176 1
a176 2
		tmp = malloc(len);
		snprintf(tmp, len, "%s/root", invokinguser);
@


1.20
log
@
don't use invokinguser if its empty
sync man page with reality

spelling corrected by jmc@@, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.19 2003/08/07 11:12:38 hin Exp $	*/
d38 2
d155 4
@


1.19
log
@krb4 bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.18 2003/07/06 21:57:27 deraadt Exp $	*/
d167 1
a167 1
	if (strcmp(username, "root") == 0) {
@


1.18
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.17 2002/09/06 18:45:06 deraadt Exp $	*/
a31 3
#ifdef KRB524
#include <kerberosIV/krb.h>
#endif
@


1.17
log
@ansi; ok millert pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.16 2002/05/30 06:09:21 deraadt Exp $	*/
d41 1
a41 1
void
d53 1
a53 1
void
@


1.16
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.15 2002/05/22 06:35:44 deraadt Exp $	*/
d78 1
a78 1
		
d83 1
a83 1
	
d86 1
a86 1
		
d99 1
a99 1
			
d106 1
a106 1
			
d114 1
a114 1
			
d122 1
a122 1
			
d140 1
a140 1
	
@


1.15
log
@a bunch more strcpy -> strlcpy and sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.14 2002/02/27 09:52:45 hin Exp $	*/
d42 1
a42 1
krb5_syslog(krb5_context context, int level, krb5_error_code code, char *fmt, ...) 
d44 7
a50 6
    va_list ap;
    char buf[256];
    va_start(ap, fmt);
    vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    syslog(level, "%s: %s", buf, krb5_get_err_text(context, code));
d55 2
a56 1
	      int token_install) {
d66 1
a66 1
			 pwd->pw_uid);
d68 2
a69 2
		snprintf(cc_file, sizeof(cc_file),"%s",
			 krb5_cc_default_name(context));
d75 1
a75 1
				    "krb5_cc_gen_new");
d79 2
a80 3
		ret = krb5_cc_copy_cache(context, ccache,
					 ccache_store);
		if (ret != 0) {
d82 1
a82 2
				    "krb5_cc_copy_cache");
		}
d85 1
a85 1
		      pwd->pw_uid, pwd->pw_gid);
d88 2
a89 2
			krb5_cc_get_type(context, ccache_store),
			krb5_cc_get_name(context, ccache_store));
d92 3
a94 6
		get_krb4_ticket =
			krb5_config_get_bool_default (context, NULL,
						      get_krb4_ticket,
						      "libdefaults",
						      "krb4_get_tickets",
						      NULL);
d103 1
a103 1
					    "start seq");
d108 1
a108 1
						&cursor, &cred);
d111 1
a111 1
					    "next cred");
d116 1
a116 1
						  &cursor);
d119 1
a119 1
					    "end seq");
d124 1
a124 1
							      &cred, &c);
d127 1
a127 1
					    "convert");
d130 2
a131 2
					 sizeof(krb4_ticket_file),
					 "%s%d", TKT_ROOT, pwd->pw_uid);
d135 1
a135 1
				      pwd->pw_uid, pwd->pw_gid);
d145 1
a145 1
			krb4_ticket_file);
d150 2
a151 1
krb5_login(char *username, char *invokinguser, char *password, int login, int tickets)
d185 2
a186 4
	ret = krb5_verify_user_lrealm(context, princ, ccache, 
				      password,
				      1,	/* verify with keytab */
				      NULL);
d188 1
a188 1
	switch(ret) {
d195 1
a195 1
				    "%s: no such user", username);
a198 1
		
a199 1

@


1.14
log
@Small fix from Bjorn Sandell <biorn@@dce.chalmers.se> that makes it compile
when KRB524 is not defined.

Closes PR #2305
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.13 2002/02/06 09:18:31 hin Exp $	*/
d174 4
a177 2
		tmp = malloc(strlen(invokinguser)+6);
		sprintf(tmp, "%s/root", invokinguser);
@


1.13
log
@Fix for heimdal-0.4e
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.12 2001/08/12 21:55:46 millert Exp $	*/
d57 1
d60 1
d141 1
a142 1
#endif
@


1.12
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.11 2001/06/26 05:03:27 hin Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001 Hans Insulander <hin@@openbsd.org>.
d124 2
a125 2
			ret = krb524_convert_creds_kdc(context, ccache,
						       &cred, &c);
@


1.11
log
@Cleanup and unify login_passwd, login_krb4, login_krb4-or-pwd, login_krb5 and
login_krb5-or-pwd.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.10 2001/06/25 22:02:13 hin Exp $	*/
d60 1
a60 1
	if(ticket_newfiles)
d67 1
a67 1
	if(ticket_store) {
d69 1
a69 1
		if(ret != 0) {
d77 1
a77 1
		if(ret != 0) {
d96 1
a96 1
		if(get_krb4_ticket) {
d102 1
a102 1
			if(ret != 0) {
d110 1
a110 1
			if(ret != 0) {
d118 1
a118 1
			if(ret != 0) {
d126 1
a126 1
			if(ret != 0) {
d144 1
a144 1
	if(get_krb4_ticket)
d155 2
a156 2
	if(username == NULL || password == NULL)
		return AUTH_FAILED;
d159 1
a159 1
	if(ret != 0) {
d165 1
a165 1
	if(ret != 0) {
d170 1
a170 1
	if(strcmp(username, "root") == 0) {
d178 1
a178 1
	if(ret != 0) {
d193 1
a193 1
		if(pwd == NULL) {
d196 1
a196 1
			return AUTH_FAILED;
d218 1
a218 1
	return return_code;
@


1.10
log
@#ifdef KRB4  ->  #ifdef KRB524
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.9 2001/06/25 21:36:49 hin Exp $	*/
d29 1
a29 15
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/resource.h>
#include <sys/param.h>

#include <syslog.h>
#include <stdlib.h>
#include <unistd.h>
#include <login_cap.h>
#include <bsd_auth.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <err.h>
#include <util.h>
a35 8
#define MODE_LOGIN 0
#define MODE_CHALLENGE 1
#define MODE_RESPONSE 2

#define AUTH_OK 0
#define AUTH_FAILED -1

FILE *back = NULL;
a218 158
}

#ifdef PASSWD
int
pwd_login(char *username, char *password)
{
	struct passwd *pwd;
	char *salt;

	pwd = getpwnam(username);

	/* Check for empty password */
	if((pwd != NULL) && (*pwd->pw_passwd == '\0')) {
		fprintf(back, BI_AUTH "\n");
		return AUTH_OK;
	}

	if(pwd)
		salt = pwd->pw_passwd;
	else
		salt = "xx";

	setpriority(PRIO_PROCESS, 0, -4);

	salt = crypt(password, salt);
	memset(password, 0, strlen(password));
	if (!pwd || strcmp(salt, pwd->pw_passwd) != 0)
		return AUTH_FAILED;

	if(login_check_expire(back, pwd, NULL, 0))
		return AUTH_FAILED;

	fprintf(back, BI_AUTH "\n");

	return AUTH_OK;
}
#endif PASSWD

int
main(int argc, char **argv)
{
	int opt, mode = 0, ret;
	char *username, *password = NULL;
	char response[1024];
	int arg_login = 0, arg_notickets = 0;
	char invokinguser[MAXLOGNAME];

	invokinguser[0] = '\0';

	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	setpriority(PRIO_PROCESS, 0, 0);

	openlog(NULL, LOG_ODELAY, LOG_AUTH);

	while((opt = getopt(argc, argv, "ds:v:")) != -1) {
		switch(opt) {
		case 'd':
			back = stdout;
			break;
		case 's':	/* service */
			if(strcmp(optarg, "login") == 0)
				mode = MODE_LOGIN;
			else if(strcmp(optarg, "challenge") == 0)
				mode = MODE_CHALLENGE;
			else if(strcmp(optarg, "response") == 0)
				mode = MODE_RESPONSE;
			else {
				syslog(LOG_ERR, "%s: invalid service", optarg);
				exit(1);
			}
			break;
		case 'v':
			if(strcmp(optarg, "login=yes") == 0)
				arg_login = 1;
			else if(strcmp(optarg, "notickets=yes") == 0)
				arg_notickets = 1;
			else if(strncmp(optarg, "invokinguser=", 13) == 0)
				snprintf(invokinguser, sizeof(invokinguser),
					 "%s", &optarg[13]);
			/* All other arguments are silently ignored */
			break;
		default:
			syslog(LOG_ERR, "usage error1");
			exit(1);
		}
	}

	switch(argc - optind) {
	case 2:
		/* class = argv[optind + 1]; */
	case 1:
		username = argv[optind];
		break;
	default:
		syslog(LOG_ERR, "usage error2");
		exit(1);
	}

	if(back == NULL && (back = fdopen(3, "r+")) == NULL) {
		syslog(LOG_ERR, "reopening back channel: %m");
		exit(1);
	}

	/*
	 * Read password, either as from the terminal or if the
	 * response mode is active from the caller program.
	 *
	 * XXX  This is completely ungrokkable, and should be rewritten.
	 */
	switch(mode) {
	case MODE_RESPONSE: {
		int count;
		mode = 0;
		count = -1;
		while(++count < sizeof(response) &&
		      read(3, &response[count], 1) == 1) {
			if(response[count] == '\0' && ++mode == 2)
				break;
			if(response[count] == '\0' && mode == 1) {
				password = response + count + 1;
			}
		}
		if(mode < 2) {
			syslog(LOG_ERR, "protocol error on back channel");
			exit(1);
		}
		break;
	}

	case MODE_LOGIN:
		password = getpass("Password:");
		break;
		
	case MODE_CHALLENGE:
		fprintf(back, BI_AUTH "\n");
		exit(0);
		break;
	default:
		syslog(LOG_ERR, "%d: unknown mode", mode);
		exit(1);
		break;
	}

	ret = krb5_login(username, invokinguser, password, arg_login,
			 !arg_notickets);
			 
#ifdef PASSWD
	if(ret != AUTH_OK)
		ret = pwd_login(username, password);
#endif
	memset(password, 0, strlen(password));
	if(ret != AUTH_OK)
		fprintf(back, BI_REJECT "\n");

	closelog();

	return 0;
@


1.9
log
@Support su'ing with local root password or with a root instance.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.8 2001/06/25 18:58:59 hin Exp $	*/
d46 1
a46 1
#ifdef KRB4
d111 1
a111 1
#ifdef KRB4
d165 1
a165 1
#ifdef KRB4
@


1.8
log
@Lots of changes and cleanup.
 - Make a separate function for ticket storing.
 - Support challenge mode.
 - Use hints passed from login and su that this is a user actually logging in.

This means login_krb5 and login_krb5-or-pwd is ready for prime-time.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.7 2001/06/25 15:49:21 hin Exp $	*/
d173 1
a173 1
krb5_login(char *username, char *password, int login, int tickets)
a175 1
	char *instance, *tmp_name;
a179 3
	if(strcmp(username, "root") == 0)
		return AUTH_FAILED;

d192 8
a199 1
	ret = krb5_parse_name(context, username, &princ);
a204 8
	instance = strchr(username, '/');
	if(instance != NULL) {
		*instance++ = '\0';
	} else
		instance = "";

	krb5_unparse_name(context, princ, &tmp_name);

a213 16
		/*
		 * The only instance a user should be allowed to login with
		 * is "root".
		 */
		if((strcmp(instance, "root") == 0)) {
			if(krb5_kuserok(context, princ, "root"))
				fprintf(back, BI_AUTH " root\n");
			else {
				fprintf(back, BI_REJECT "\n");
				exit(0);
			}
		} else if(strlen(instance) != 0) {
			fprintf(back, BI_REJECT "\n");
			exit(0);
		}

d286 4
a289 1
	
d318 3
d328 1
d385 2
a386 1
	ret = krb5_login(username, password, arg_login, !arg_notickets);
@


1.7
log
@Support for checking local passwords, for login_krb5-or-pwd.

Support the response protocol, used for terminal locking etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.6 2001/06/25 14:21:30 hin Exp $	*/
d58 4
d74 98
d173 1
a173 1
krb5_login(char *username, char *password)
a176 4
	krb5_error_code ret;
	krb5_context context;
	krb5_ccache ccache;
	krb5_principal princ;
a216 1
		krb5_ccache ccache_store;
a217 3
		int get_krb4_ticket = 0;
		char krb4_ticket_file[MAXPATHLEN];
		char cc_file[MAXPATHLEN];
d239 1
a240 73
		snprintf(cc_file, sizeof(cc_file), "FILE:/tmp/krb5cc_%d",
			 pwd->pw_uid);

		ret = krb5_cc_resolve(context, cc_file, &ccache_store);
		if(ret != 0) {
			krb5_syslog(context, LOG_ERR, ret, "krb5_cc_gen_new");
			exit(1);
		}

		ret = krb5_cc_copy_cache(context, ccache, ccache_store);
		if(ret != 0) {
			krb5_syslog(context, LOG_ERR, ret,
				    "krb5_cc_copy_cache");
		}

#ifdef KRB4
		get_krb4_ticket =
			krb5_config_get_bool_default (context, NULL,
						      get_krb4_ticket,
						      "libdefaults",
						      "krb4_get_tickets",
						      NULL);
#if 1
		if(get_krb4_ticket) {
			CREDENTIALS c;
			krb5_creds cred;
			krb5_cc_cursor cursor;

			ret = krb5_cc_start_seq_get(context, ccache, &cursor);
			if(ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
					    "start seq");
				exit(1);
			}

			ret = krb5_cc_next_cred(context, ccache, &cursor,
						&cred);
			if(ret != 0) {
				krb5_syslog(context, LOG_ERR, ret,
					    "next cred");
				exit(1);
			}

			ret = krb5_cc_end_seq_get(context, ccache, &cursor);
			if(ret != 0) {
				krb5_syslog(context, LOG_ERR, ret, "end seq");
				exit(1);
			}
			
			ret = krb524_convert_creds_kdc(context, ccache, &cred,
						       &c);
			if(ret != 0) {
				krb5_syslog(context, LOG_ERR, ret, "convert");
			} else {
				snprintf(krb4_ticket_file,
					 sizeof(krb4_ticket_file),
					 "%s%d", TKT_ROOT, pwd->pw_uid);
				krb_set_tkt_string(krb4_ticket_file);
				tf_setup(&c, c.pname, c.pinst);
				chown(krb4_ticket_file,
				      pwd->pw_uid, pwd->pw_gid);
			}
		}
#endif
#endif

		if(strcmp(instance, "root") == 0) {
		} else {
			/* Need to chown the ticket file */
			chown(krb5_cc_get_name(context, ccache_store),
			      pwd->pw_uid, pwd->pw_gid);
		}

d243 1
a243 8
		fprintf(back, BI_SETENV " KRB5CCNAME %s:%s\n",
			krb5_cc_get_type(context, ccache_store),
			krb5_cc_get_name(context, ccache_store));
#ifdef KRB4
		if(get_krb4_ticket)
			fprintf(back, BI_SETENV " KRBTKFILE %s\n",
				krb4_ticket_file);
#endif
d306 2
a307 1

d332 5
a336 1
			/* silently ignore -v options */
d365 2
a366 1
	if(mode == MODE_RESPONSE) {
d382 4
a385 1
	} else
d387 11
d399 2
a400 1
	ret = krb5_login(username, password);
@


1.6
log
@Move the password checking into a separare function to make the code more
readable, and easier to extend.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.5 2001/06/25 05:23:13 hin Exp $	*/
d43 1
d80 3
d249 35
d288 3
a290 2
	int opt, mode, ret;
	char *username, *password;
d339 24
a362 1
	password = getpass("Password:");
d365 5
a369 1

@


1.5
log
@Use getpass() to read password instead of libkrb5, just to make sure that
login_krb5 _always_ behave like the other BSD Auth login scripts.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.4 2001/06/25 02:54:02 hin Exp $	*/
d53 6
d70 1
a70 1
main(int argc, char **argv)
d72 2
a73 5
	int opt, mode;
	FILE *back = NULL;
	char *class, *username = NULL, *instance, *password, pw_prompt[256];
	char *tmp_name;

d79 2
a80 47
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	setpriority(PRIO_PROCESS, 0, 0);

	openlog(NULL, LOG_ODELAY, LOG_AUTH);

	while((opt = getopt(argc, argv, "ds:v:")) != -1) {
		switch(opt) {
		case 'd':
			back = stdout;
			break;
		case 's':	/* service */
			if(strcmp(optarg, "login") == 0)
				mode = MODE_LOGIN;
			else if(strcmp(optarg, "challenge") == 0)
				mode = MODE_CHALLENGE;
			else if(strcmp(optarg, "response") == 0)
				mode = MODE_RESPONSE;
			else {
				syslog(LOG_ERR, "%s: invalid service", optarg);
				exit(1);
			}
			break;
		case 'v':
			/* silently ignore -v options */
			break;
		default:
			syslog(LOG_ERR, "usage error1");
			exit(1);
		}
	}
	switch(argc - optind) {
	case 2:
		class = argv[optind + 1];
	case 1:
		username = argv[optind];
		break;
	default:
		syslog(LOG_ERR, "usage error2");
		exit(1);
	}

	if(back == NULL && (back = fdopen(3, "r+")) == NULL) {
		syslog(LOG_ERR, "reopening back channel: %m");
		exit(1);
	}

a106 3
	snprintf(pw_prompt, sizeof(pw_prompt), "%s's Password: ", tmp_name);

	password = getpass(pw_prompt);
d226 1
a231 1
		fprintf(back, BI_REJECT "\n");
d241 64
@


1.4
log
@close_log()
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.3 2001/06/25 02:52:41 hin Exp $	*/
d68 2
a69 1
	char *class, *username = NULL, *instance;
d148 5
d154 1
a154 1
				      NULL,	/* Let krb5 lib ask for pw */
d276 1
a276 1
		fprintf(back, BI_REJECT " 2\n");
@


1.3
log
@Silently ignore -v options.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.2 2001/06/25 01:04:41 hin Exp $	*/
d280 2
@


1.2
log
@Rework errrorhandling so that it syslogs any error, instead of writing them
to stderr.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_krb5.c,v 1.1 2001/06/25 00:07:08 hin Exp $	*/
d81 1
a81 1
	while((opt = getopt(argc, argv, "ds:")) != -1) {
d97 3
@


1.1
log
@BSD Auth login script for KerberosV. Written by me with assistance from
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 10
d121 4
a124 2
	if(ret != 0)
		krb5_err(context, 1, ret, "krb5_init_context");
d127 4
a130 2
	if(ret != 0)
		errx(1, "krb5_cc_gen_new: %d", ret);
d133 4
a136 2
	if(ret != 0)
		errx(1, "krb5_parse_name: %d", ret);
d174 4
a177 3
		if(pwd == NULL)
			errx(1, "%s: no such user", username);

d182 4
a185 2
		if(ret != 0)
			krb5_err(context, 1, ret, "krb5_cc_gen_new");
d188 4
a191 2
		if(ret != 0)
			krb5_err(context, 1, ret, "krb5_cc_copy_cache");
d207 5
a211 2
			if(ret != 0)
				krb5_err(context, 1, ret, "start seq");
d215 5
a219 2
			if(ret != 0)
				krb5_err(context, 1, ret, "next cred");
d222 4
a225 2
			if(ret != 0)
				krb5_err(context, 1, ret, "end seq");
d229 3
a231 3
			if(ret != 0)
				krb5_warn(context, ret, "convert");
			else {
a238 1

d270 1
a270 1
		krb5_err(context, 1, ret, "verify");
@

