head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.20
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.16
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.14
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.12
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.34
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.30
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.28
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.26
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.24
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.22
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.20
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.18
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.16
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.12
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.03.24.13.56.00;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.17.19.24.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.06.17.03;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.5
log
@libwrap is going away, so can this.
ok tedu
@
text
@/*	$OpenBSD: safe_finger.c,v 1.4 2009/10/27 23:59:31 deraadt Exp $	*/

 /*
  * safe_finger - finger client wrapper that protects against nasty stuff
  * from finger servers. Use this program for automatic reverse finger
  * probes, not the raw finger command.
  * 
  * Build with: cc -o safe_finger safe_finger.c
  * 
  * The problem: some programs may react to stuff in the first column. Other
  * programs may get upset by thrash anywhere on a line. File systems may
  * fill up as the finger server keeps sending data. Text editors may bomb
  * out on extremely long lines. The finger server may take forever because
  * it is somehow wedged. The code below takes care of all this badness.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* System libraries */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <pwd.h>

/* Local stuff */

char    path[] = "PATH=/bin:/usr/bin:/usr/sbin:/sbin";

#define	TIME_LIMIT	60		/* Do not keep listinging forever */
#define	INPUT_LENGTH	100000		/* Do not keep listinging forever */
#define	LINE_LENGTH	128		/* Editors can choke on long lines */
#define	FINGER_PROGRAM	"finger"	/* Most, if not all, UNIX systems */
#define	UNPRIV_NAME	"nobody"	/* Preferred privilege level */
#define	UNPRIV_UGID	32767		/* Default uid and gid */

int     finger_pid;

int	pipe_stdin(char **);

void    cleanup(sig)
int     sig;
{
    kill(finger_pid, SIGKILL);
    _exit(0);
}

int main(argc, argv)
int     argc;
char  **argv;
{
    int     c;
    int     line_length = 0;
    int     finger_status;
    int     wait_pid;
    int     input_count = 0;
    struct passwd *pwd;

    /*
     * First of all, let's don't run with superuser privileges.
     */
    if (getuid() == 0 || geteuid() == 0) {
	if ((pwd = getpwnam(UNPRIV_NAME)) && pwd->pw_uid > 0) {
	    setgid(pwd->pw_gid);
	    setuid(pwd->pw_uid);
	} else {
	    setgid(UNPRIV_UGID);
	    setuid(UNPRIV_UGID);
	}
    }

    /*
     * Redirect our standard input through the raw finger command.
     */
    if (putenv(path)) {
	fprintf(stderr, "%s: putenv: out of memory", argv[0]);
	exit(1);
    }
    argv[0] = FINGER_PROGRAM;
    finger_pid = pipe_stdin(argv);

    /*
     * Don't wait forever (Peter Wemm <peter@@gecko.DIALix.oz.au>).
     */
    signal(SIGALRM, cleanup);
    (void) alarm(TIME_LIMIT);

    /*
     * Main filter loop.
     */
    while ((c = getchar()) != EOF) {
	if (input_count++ >= INPUT_LENGTH) {	/* don't listen forever */
	    fclose(stdin);
	    printf("\n\n Input truncated to %d bytes...\n", input_count - 1);
	    break;
	}
	if (c == '\n') {			/* good: end of line */
	    putchar(c);
	    line_length = 0;
	} else {
	    if (line_length >= LINE_LENGTH) {	/* force end of line */
		printf("\\\n");
		line_length = 0;
	    }
	    if (line_length == 0) {		/* protect left margin */
		putchar(' ');
		line_length++;
	    }
	    if (isascii(c) && (isprint(c) || isspace(c))) {	/* text */
		if (c == '\\') {
		    putchar(c);
		    line_length++;
		}
		putchar(c);
		line_length++;
	    } else {				/* quote all other thash */
		printf("\\%03o", c & 0377);
		line_length += 4;
	    }
	}
    }

    /*
     * Wait until the finger child process has terminated and account for its
     * exit status. Which will always be zero on most systems.
     */
    while ((wait_pid = wait(&finger_status)) != -1 && wait_pid != finger_pid)
	 /* void */ ;
    return (wait_pid != finger_pid || finger_status != 0);
}

/* perror_exit - report system error text and terminate */

void    perror_exit(text)
char   *text;
{
    perror(text);
    exit(1);
}

/* pipe_stdin - pipe stdin through program (from my ANSI to OLD C converter) */

int     pipe_stdin(argv)
char  **argv;
{
    int     pipefds[2];
    int     pid;
    int     i;
    struct stat st;

    /*
     * The code that sets up the pipe requires that file descriptors 0,1,2
     * are already open. All kinds of mysterious things will happen if that
     * is not the case. The following loops makes sure that descriptors 0,1,2
     * are set up properly.
     */

    for (i = 0; i < 3; i++) {
	if (fstat(i, &st) == -1 && open("/dev/null", O_RDWR) != i)
	    perror_exit("open /dev/null");
    }

    /*
     * Set up the pipe that interposes the command into our standard input
     * stream.
     */

    if (pipe(pipefds))
	perror_exit("pipe");

    switch (pid = fork()) {
    case -1:					/* error */
	perror_exit("fork");
	/* NOTREACHED */
    case 0:					/* child */
	(void) close(pipefds[0]);		/* close reading end */
	(void) close(1);			/* connect stdout to pipe */
	if (dup(pipefds[1]) != 1)
	    perror_exit("dup");
	(void) close(pipefds[1]);		/* close redundant fd */
	(void) execvp(argv[0], argv);
	perror_exit(argv[0]);
	/* NOTREACHED */
    default:					/* parent */
	(void) close(pipefds[1]);		/* close writing end */
	(void) close(0);			/* connect stdin to pipe */
	if (dup(pipefds[0]) != 0)
	    perror_exit("dup");
	(void) close(pipefds[0]);		/* close redundant fd */
	return (pid);
    }
}
@


1.4
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: safe_finger.c,v 1.3 2002/02/16 21:27:31 millert Exp $	*/
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: safe_finger.c,v 1.2 2001/01/17 19:24:28 deraadt Exp $	*/
a17 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#) safe_finger.c 1.4 94/12/28 17:42:41";
#else
static char rcsid[] = "$OpenBSD: safe_finger.c,v 1.2 2001/01/17 19:24:28 deraadt Exp $";
#endif
#endif
@


1.2
log
@use _exit() in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: safe_finger.c,v 1.1 1997/02/26 06:17:03 downsj Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: safe_finger.c,v 1.1 1997/02/26 06:17:03 downsj Exp $";
d53 1
a53 1
int	pipe_stdin __P((char **));
@


1.1
log
@Initial integration of userland tcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD$";
d59 1
a59 1
    exit(0);
@

