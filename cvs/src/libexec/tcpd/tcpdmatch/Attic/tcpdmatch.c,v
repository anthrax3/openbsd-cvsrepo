head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.24.13.56.01;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.26.07.53.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.32.04;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.14.00.56.15;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.06.06.18.58.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.06.06.15.34.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.05.23.17.19.23;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.06.17.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.9
log
@libwrap is going away, so can this.
ok tedu
@
text
@/*	$OpenBSD: tcpdmatch.c,v 1.8 2009/10/27 23:59:32 deraadt Exp $	*/

 /*
  * tcpdmatch - explain what tcpd would do in a specific case
  * 
  * usage: tcpdmatch [-d] [-i inet_conf] daemon[@@host] [user@@]host
  * 
  * -d: use the access control tables in the current directory.
  * 
  * -i: location of inetd.conf file.
  * 
  * All errors are reported to the standard error stream, including the errors
  * that would normally be reported via the syslog daemon.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <setjmp.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#include <tcpd.h>

#ifndef	INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

#ifndef S_ISDIR
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif

/* Application-specific. */

#include "inetcf.h"
#include "scaffold.h"

static void usage(char *);
static void expand(char *, char *, struct request_info *);
static void tcpdmatch(struct request_info *);

/* The main program */

int     main(int argc, char *argv[])
{
    struct addrinfo *res, *res0;
    char   *myname = argv[0];
    char   *client;
    char   *server;
    char   *user;
    char   *daemon;
    struct request_info request;
    int     ch;
    char   *inetcf = 0;
    int     count;
    struct sockaddr_storage server_ss;
    struct sockaddr_storage client_ss;
    struct stat st;

    /*
     * Show what rule actually matched.
     */
    hosts_access_verbose = 2;

    /*
     * Parse the JCL.
     */
    while ((ch = getopt(argc, argv, "di:")) != -1) {
	switch (ch) {
	case 'd':
	    hosts_allow_table = "hosts.allow";
	    hosts_deny_table = "hosts.deny";
	    break;
	case 'i':
	    inetcf = optarg;
	    break;
	default:
	    usage(myname);
	    /* NOTREACHED */
	}
    }
    if (argc != optind + 2)
	usage(myname);

    /*
     * When confusion really strikes...
     */
    if (check_path(REAL_DAEMON_DIR, &st) < 0) {
	tcpd_warn("REAL_DAEMON_DIR %s: %m", REAL_DAEMON_DIR);
    } else if (!S_ISDIR(st.st_mode)) {
	tcpd_warn("REAL_DAEMON_DIR %s is not a directory", REAL_DAEMON_DIR);
    }

    /*
     * Default is to specify a daemon process name. When daemon@@host is
     * specified, separate the two parts.
     */
    if ((server = split_at(argv[optind], '@@')) == 0)
	server = unknown;
    if (argv[optind][0] == '/') {
	daemon = strrchr(argv[optind], '/') + 1;
	tcpd_warn("%s: daemon name normalized to: %s", argv[optind], daemon);
    } else {
	daemon = argv[optind];
    }

    /*
     * Default is to specify a client hostname or address. When user@@host is
     * specified, separate the two parts.
     */
    if ((client = split_at(argv[optind + 1], '@@')) != 0) {
	user = argv[optind + 1];
    } else {
	client = argv[optind + 1];
	user = unknown;
    }

    /*
     * Analyze the inetd (or tlid) configuration file, so that we can warn
     * the user about services that may not be wrapped, services that are not
     * configured, or services that are wrapped in an incorrect manner. Allow
     * for services that are not run from inetd, or that have tcpd access
     * control built into them.
     */
    inetcf = inet_cfg(inetcf);
    inet_set("portmap", WR_NOT);
    inet_set("rpcbind", WR_NOT);
    switch (inet_get(daemon)) {
    case WR_UNKNOWN:
	tcpd_warn("%s: no such process name in %s", daemon, inetcf);
	break;
    case WR_NOT:
	tcpd_warn("%s: service possibly not wrapped", daemon);
	break;
    }

    /*
     * Check accessibility of access control files.
     */
    (void) check_path(hosts_allow_table, &st);
    (void) check_path(hosts_deny_table, &st);

    /*
     * Fill in what we have figured out sofar. Use socket and DNS routines
     * for address and name conversions. We attach stdout to the request so
     * that banner messages will become visible.
     */
    request_init(&request, RQ_DAEMON, daemon, RQ_USER, user, RQ_FILE, 1, 0);
    sock_methods(&request);

    /*
     * If a server hostname is specified, insist that the name maps to at
     * most one address. eval_hostname() warns the user about name server
     * problems, while using the request.server structure as a cache for host
     * address and name conversion results.
     */
    if (NOT_INADDR(server) == 0 || HOSTNAME_KNOWN(server)) {
	if ((res0 = find_inet_addr(server, 0)) == NULL)
	    exit(1);
	memset((char *) &server_ss, 0, sizeof(server_ss));
	request_set(&request, RQ_SERVER_SIN, &server_ss, 0);

	count = 0;
	for (res = res0; res; res = res->ai_next) {
	    count++;
	    if (res->ai_addrlen > sizeof(server_ss))
		continue;
	    memcpy(&server_ss, res->ai_addr, res->ai_addrlen);

	    /*
	     * Force evaluation of server host name and address. Host name
	     * conflicts will be reported while eval_hostname() does its job.
	     */
	    request_set(&request, RQ_SERVER_NAME, "", RQ_SERVER_ADDR, "", 0);
	    if (STR_EQ(eval_hostname(request.server), unknown))
		tcpd_warn("host address %s->name lookup failed",
			  eval_hostaddr(request.server));
	}
	if (count > 1) {
	    fprintf(stderr, "Error: %s has more than one address\n", server);
	    fprintf(stderr, "Please specify an address instead\n");
	    exit(1);
	}
	freeaddrinfo(res0);
    } else {
	request_set(&request, RQ_SERVER_NAME, server, 0);
    }

    /*
     * If a client address is specified, we simulate the effect of client
     * hostname lookup failure.
     */
    res0 = find_inet_addr(client, AI_NUMERICHOST);
    if (res0 && !res0->ai_next) {
	request_set(&request, RQ_CLIENT_SIN, res0->ai_addr);
	tcpdmatch(&request);
	freeaddrinfo(res0);
	exit(0);
    }
    if (res0)
	freeaddrinfo(res0);

    /*
     * Perhaps they are testing special client hostname patterns that aren't
     * really host names at all.
     */
    if (NOT_INADDR(client) && HOSTNAME_KNOWN(client) == 0) {
	request_set(&request, RQ_CLIENT_NAME, client, 0);
	tcpdmatch(&request);
	exit(0);
    }

    /*
     * Otherwise, assume that a client hostname is specified, and insist that
     * the address can be looked up. The reason for this requirement is that
     * in real life the client address is available (at least with IP). Let
     * eval_hostname() figure out if this host is properly registered, while
     * using the request.client structure as a cache for host name and
     * address conversion results.
     */
    if ((res0 = find_inet_addr(client, 0)) == NULL)
	exit(1);
    memset((char *) &client_ss, 0, sizeof(client_ss));
    request_set(&request, RQ_CLIENT_SIN, &client_ss, 0);

    count = 0;
    for (res = res0; res; res = res->ai_next) {
	count++;
	if (res->ai_addrlen > sizeof(client_ss))
	    continue;
	memcpy(&client_ss, res->ai_addr, res->ai_addrlen);

	/*
	 * Force evaluation of client host name and address. Host name
	 * conflicts will be reported while eval_hostname() does its job.
	 */
	request_set(&request, RQ_CLIENT_NAME, "", RQ_CLIENT_ADDR, "", 0);
	if (STR_EQ(eval_hostname(request.client), unknown))
	    tcpd_warn("host address %s->name lookup failed",
		      eval_hostaddr(request.client));
	tcpdmatch(&request);
	if (res->ai_next)
	    printf("\n");
    }
    freeaddrinfo(res0);
    exit(0);
}

/* Explain how to use this program */

static void usage(myname)
char   *myname;
{
    fprintf(stderr, "usage: %s [-d] [-i inet_conf] daemon[@@host] [user@@]host\n",
	    myname);
    fprintf(stderr, "	-d: use allow/deny files in current directory\n");
    fprintf(stderr, "	-i: location of inetd.conf file\n");
    exit(1);
}

/* Print interesting expansions */

static void expand(text, pattern, request)
char   *text;
char   *pattern;
struct request_info *request;
{
    char    buf[BUFSIZ];

    if (STR_NE(percent_x(buf, sizeof(buf), pattern, request), unknown))
	printf("%s %s\n", text, buf);
}

/* Try out a (server,client) pair */

static void tcpdmatch(request)
struct request_info *request;
{
    int     verdict;

    /*
     * Show what we really know. Suppress uninteresting noise.
     */
    expand("client:   hostname", "%n", request);
    expand("client:   address ", "%a", request);
    expand("client:   username", "%u", request);
    expand("server:   hostname", "%N", request);
    expand("server:   address ", "%A", request);
    expand("server:   process ", "%d", request);

    /*
     * Reset stuff that might be changed by options handlers. In dry-run
     * mode, extension language routines that would not return should inform
     * us of their plan, by clearing the dry_run flag. This is a bit clumsy
     * but we must be able to verify hosts with more than one network
     * address.
     */
    rfc931_timeout = RFC931_TIMEOUT;
    allow_severity = SEVERITY;
    deny_severity = LOG_WARNING;
    dry_run = 1;

    /*
     * When paranoid mode is enabled, access is rejected no matter what the
     * access control rules say.
     */
#ifdef PARANOID
    if (STR_EQ(eval_hostname(request->client), paranoid)) {
	printf("access:   denied (PARANOID mode)\n\n");
	return;
    }
#endif

    /*
     * Report the access control verdict.
     */
    verdict = hosts_access(request);
    printf("access:   %s\n",
	   dry_run == 0 ? "delegated" :
	   verdict ? "granted" : "denied");
}
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.7 2003/06/26 07:53:27 deraadt Exp $	*/
@


1.7
log
@simple protos
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.6 2002/06/07 03:32:04 itojun Exp $	*/
a16 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#) tcpdmatch.c 1.5 96/02/11 17:01:36";
#else
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.6 2002/06/07 03:32:04 itojun Exp $";
#endif
#endif
@


1.6
log
@support scoped IPv6 address.
no visible API change, old config files work just fine.
now  you can use expressions like "ALL: [fe80::%lo0/64]".  theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.5 2000/10/14 00:56:15 itojun Exp $	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.5 2000/10/14 00:56:15 itojun Exp $";
d62 1
a62 3
int     main(argc, argv)
int     argc;
char  **argv;
@


1.5
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.4 1999/06/06 18:58:54 deraadt Exp $	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.4 1999/06/06 18:58:54 deraadt Exp $";
d56 3
a58 2
static void usage();
static void tcpdmatch();
d66 1
a66 1
    struct hostent *hp;
a69 1
    char   *addr;
d76 2
a77 2
    struct sockaddr_storage server_sin;
    struct sockaddr_storage client_sin;
a78 5
    char *ap;
    int alen;
#ifdef INET6
    struct sockaddr_in6 in6;
#endif
d178 1
a178 16
	if ((hp = find_inet_addr(server)) == 0)
	    exit(1);
	memset((char *) &server_sin, 0, sizeof(server_sin));
	server_sin.ss_family = hp->h_addrtype;
	switch (hp->h_addrtype) {
	case AF_INET:
	    ap = (char *)&((struct sockaddr_in *)&server_sin)->sin_addr;
	    alen = sizeof(struct in_addr);
	    break;
#ifdef INET6
	case AF_INET6:
	    ap = (char *)&((struct sockaddr_in6 *)&server_sin)->sin6_addr;
	    alen = sizeof(struct in6_addr);
	    break;
#endif
	default:
d180 2
a181 2
	}
	request_set(&request, RQ_SERVER_SIN, &server_sin, 0);
d183 6
a188 2
	for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	    memcpy(ap, addr, alen);
d204 1
a204 1
	free((char *) hp);
d213 3
a215 8
    if (dot_quad_addr_new(client, NULL)) {
	request_set(&request, RQ_CLIENT_ADDR, client, 0);
	tcpdmatch(&request);
	exit(0);
    }
#ifdef INET6
    if (inet_pton(AF_INET6, client, &in6) == 1) {
	request_set(&request, RQ_CLIENT_ADDR, client, 0);
d217 1
d220 2
a221 1
#endif
d241 1
a241 16
    if ((hp = find_inet_addr(client)) == 0)
	exit(1);
    memset((char *) &client_sin, 0, sizeof(client_sin));
    client_sin.ss_family = hp->h_addrtype;
    switch (hp->h_addrtype) {
    case AF_INET:
	ap = (char *)&((struct sockaddr_in *)&client_sin)->sin_addr;
	alen = sizeof(struct in_addr);
	break;
#ifdef INET6
    case AF_INET6:
	ap = (char *)&((struct sockaddr_in6 *)&client_sin)->sin6_addr;
	alen = sizeof(struct in6_addr);
	break;
#endif
    default:
d243 2
a244 2
    }
    request_set(&request, RQ_CLIENT_SIN, &client_sin, 0);
d246 6
a251 2
    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	memcpy(ap, addr, alen);
d262 1
a262 1
	if (hp->h_addr_list[count + 1])
d265 1
a265 1
    free((char *) hp);
@


1.4
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.3 1999/06/06 15:34:57 deraadt Exp $	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.3 1999/06/06 15:34:57 deraadt Exp $";
d76 2
a77 2
    struct sockaddr_in server_sin;
    struct sockaddr_in client_sin;
d79 5
d186 15
a200 1
	server_sin.sin_family = AF_INET;
d204 1
a204 2
	    memcpy((char *) &server_sin.sin_addr, addr,
		   sizeof(server_sin.sin_addr));
d234 7
d263 15
a277 1
    client_sin.sin_family = AF_INET;
d281 1
a281 2
	memcpy((char *) &client_sin.sin_addr, addr,
	       sizeof(client_sin.sin_addr));
@


1.3
log
@use dot_quad_addr_new() as required
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.2 1999/05/23 17:19:23 aaron Exp $	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.2 1999/05/23 17:19:23 aaron Exp $";
d211 1
a211 1
    if (dot_quad_addr(client, NULL)) {
@


1.2
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdmatch.c,v 1.1 1997/02/26 06:17:10 downsj Exp $	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD: tcpdmatch.c,v 1.1 1997/02/26 06:17:10 downsj Exp $";
d211 1
a211 1
    if (dot_quad_addr(client) != INADDR_NONE) {
@


1.1
log
@Initial integration of userland tcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 1
a22 1
static char rcsid[] = "$OpenBSD$";
d88 1
a88 1
    while ((ch = getopt(argc, argv, "di:")) != EOF) {
@

