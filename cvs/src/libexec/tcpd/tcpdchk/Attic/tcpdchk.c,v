head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.03.24.13.56.01;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.20.01.50.30;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.26.07.53.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.22.27.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.32.04;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.08.21.18.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.14.00.56.14;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.06.06.15.34.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.05.23.17.19.23;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.06.17.09;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.12
log
@libwrap is going away, so can this.
ok tedu
@
text
@/*	$OpenBSD: tcpdchk.c,v 1.11 2009/10/27 23:59:32 deraadt Exp $	*/

 /*
  * tcpdchk - examine all tcpd access control rules and inetd.conf entries
  * 
  * Usage: tcpdchk [-a] [-d] [-i inet_conf] [-v]
  * 
  * -a: complain about implicit "allow" at end of rule.
  * 
  * -d: rules in current directory.
  * 
  * -i: location of inetd.conf file.
  * 
  * -v: show all rules.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <setjmp.h>
#include <errno.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#ifdef NETGROUP
#include <netgroup.h>
#endif

#include <tcpd.h>

#ifndef INADDR_NONE
#define INADDR_NONE     (-1)		/* XXX should be 0xffffffff */
#endif

#ifndef S_ISDIR
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif

/* Application-specific. */

#include "inetcf.h"
#include "scaffold.h"

 /*
  * Stolen from hosts_access.c...
  */
static char sep[] = ", \t\n";

#define	BUFLEN 2048

int     resident = 0;
int     hosts_access_verbose = 0;
char   *hosts_allow_table = HOSTS_ALLOW;
char   *hosts_deny_table = HOSTS_DENY;
extern jmp_buf tcpd_buf;

 /*
  * Local stuff.
  */
static void usage(void);
static void parse_table(char *, struct request_info *);
static void print_list(char *, char *);
static void check_daemon_list(char *);
static void check_client_list(char *);
static void check_daemon(char *);
static void check_user(char *);
#ifdef INET6
static int check_inet_addr(char *);
#endif
static int check_host(char *);
static int reserved_name(char *);

#define PERMIT	1
#define DENY	0

#define YES	1
#define	NO	0

static int defl_verdict;
static char *myname;
static int allow_check;
static char *inetcf;

int     main(int argc, char *argv[])
{
    struct request_info request;
    struct stat st;
    int     c;

    myname = argv[0];

    /*
     * Parse the JCL.
     */
    while ((c = getopt(argc, argv, "adi:v")) != -1) {
	switch (c) {
	case 'a':
	    allow_check = 1;
	    break;
	case 'd':
	    hosts_allow_table = "hosts.allow";
	    hosts_deny_table = "hosts.deny";
	    break;
	case 'i':
	    inetcf = optarg;
	    break;
	case 'v':
	    hosts_access_verbose++;
	    break;
	default:
	    usage();
	    /* NOTREACHED */
	}
    }
    if (argc != optind)
	usage();

    /*
     * When confusion really strikes...
     */
    if (check_path(REAL_DAEMON_DIR, &st) < 0) {
	tcpd_warn("REAL_DAEMON_DIR %s: %m", REAL_DAEMON_DIR);
    } else if (!S_ISDIR(st.st_mode)) {
	tcpd_warn("REAL_DAEMON_DIR %s is not a directory", REAL_DAEMON_DIR);
    }

    /*
     * Process the inet configuration file (or its moral equivalent). This
     * information is used later to find references in hosts.allow/deny to
     * unwrapped services, and other possible problems.
     */
    inetcf = inet_cfg(inetcf);
    if (hosts_access_verbose)
	printf("Using network configuration file: %s\n", inetcf);

    /*
     * These are not run from inetd but may have built-in access control.
     */
    inet_set("portmap", WR_NOT);
    inet_set("rpcbind", WR_NOT);

    /*
     * Check accessibility of access control files.
     */
    (void) check_path(hosts_allow_table, &st);
    (void) check_path(hosts_deny_table, &st);

    /*
     * Fake up an arbitrary service request.
     */
    request_init(&request,
		 RQ_DAEMON, "daemon_name",
		 RQ_SERVER_NAME, "server_hostname",
		 RQ_SERVER_ADDR, "server_addr",
		 RQ_USER, "user_name",
		 RQ_CLIENT_NAME, "client_hostname",
		 RQ_CLIENT_ADDR, "client_addr",
		 RQ_FILE, 1,
		 0);

    /*
     * Examine all access-control rules.
     */
    defl_verdict = PERMIT;
    parse_table(hosts_allow_table, &request);
    defl_verdict = DENY;
    parse_table(hosts_deny_table, &request);
    return (0);
}

/* usage - explain */

static void usage()
{
    fprintf(stderr, "usage: %s [-adv] [-i inet_conf]\n", myname);
    fprintf(stderr, "	-a: report rules with implicit \"ALLOW\" at end\n");
    fprintf(stderr, "	-d: use allow/deny files in current directory\n");
    fprintf(stderr, "	-i: location of inetd.conf file\n");
    fprintf(stderr, "	-v: list all rules\n");
    exit(1);
}

/* parse_table - like table_match(), but examines _all_ entries */

static void parse_table(table, request)
char   *table;
struct request_info *request;
{
    FILE   *fp;
    int     real_verdict;
    char    sv_list[BUFLEN];		/* becomes list of daemons */
    char   *cl_list;			/* becomes list of requests */
    char   *sh_cmd;			/* becomes optional shell command */
#ifndef PROCESS_OPTIONS
    char    buf[BUFSIZ];
#endif
    int     verdict;
    struct tcpd_context saved_context;

    saved_context = tcpd_context;		/* stupid compilers */

    if ((fp = fopen(table, "r")) != (FILE *)NULL) {
	tcpd_context.file = table;
	tcpd_context.line = 0;
	while (xgets(sv_list, sizeof(sv_list), fp)) {
	    if (sv_list[strlen(sv_list) - 1] != '\n') {
		tcpd_warn("missing newline or line too long");
		continue;
	    }
	    if (sv_list[0] == '#' || sv_list[strspn(sv_list, " \t\r\n")] == 0)
		continue;
	    if ((cl_list = split_at(sv_list, ':')) == 0) {
		tcpd_warn("missing \":\" separator");
		continue;
	    }
	    sh_cmd = split_at(cl_list, ':');

	    if (hosts_access_verbose)
		printf("\n>>> Rule %s line %d:\n",
		       tcpd_context.file, tcpd_context.line);

	    if (hosts_access_verbose)
		print_list("daemons:  ", sv_list);
	    check_daemon_list(sv_list);

	    if (hosts_access_verbose)
		print_list("clients:  ", cl_list);
	    check_client_list(cl_list);

#ifdef PROCESS_OPTIONS
	    real_verdict = defl_verdict;
	    if (sh_cmd) {
		verdict = setjmp(tcpd_buf);
		if (verdict != 0) {
		    real_verdict = (verdict == AC_PERMIT);
		} else {
		    dry_run = 1;
		    process_options(sh_cmd, request);
		    if (dry_run == 1 && real_verdict && allow_check)
			tcpd_warn("implicit \"allow\" at end of rule");
		}
	    } else if (defl_verdict && allow_check) {
		tcpd_warn("implicit \"allow\" at end of rule");
	    }
	    if (hosts_access_verbose)
		printf("access:   %s\n", real_verdict ? "granted" : "denied");
#else
	    if (sh_cmd)
		shell_cmd(percent_x(buf, sizeof(buf), sh_cmd, request));
	    if (hosts_access_verbose)
		printf("access:   %s\n", defl_verdict ? "granted" : "denied");
#endif
	}
	(void) fclose(fp);
    } else if (errno != ENOENT) {
	tcpd_warn("cannot open %s: %m", table);
    }
    tcpd_context = saved_context;
}

/* print_list - pretty-print a list */

static void print_list(title, list)
char   *title;
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *next;

    fputs(title, stdout);
    strlcpy(buf, list, sizeof buf);

    for (cp = strtok(buf, sep); cp != 0; cp = next) {
	fputs(cp, stdout);
	next = strtok((char *) 0, sep);
	if (next != 0)
	    fputs(" ", stdout);
    }
    fputs("\n", stdout);
}

/* check_daemon_list - criticize daemon list */

static void check_daemon_list(list)
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *host;
    int     daemons = 0;

    strlcpy(buf, list, sizeof buf);

    for (cp = strtok(buf, sep); cp != 0; cp = strtok((char *) 0, sep)) {
	if (STR_EQ(cp, "EXCEPT")) {
	    daemons = 0;
	} else {
	    daemons++;
	    if ((host = split_at(cp + 1, '@@')) != 0 && check_host(host) > 1) {
		tcpd_warn("host %s has more than one address", host);
		tcpd_warn("(consider using an address instead)");
	    }
	    check_daemon(cp);
	}
    }
    if (daemons == 0)
	tcpd_warn("daemon list is empty or ends in EXCEPT");
}

/* check_client_list - criticize client list */

static void check_client_list(list)
char   *list;
{
    char    buf[BUFLEN];
    char   *cp;
    char   *host;
    int     clients = 0;
#ifdef INET6
    int l;
#endif

    strlcpy(buf, list, sizeof buf);

    for (cp = strtok(buf, sep); cp != 0; cp = strtok((char *) 0, sep)) {
#ifdef INET6
	l = strlen(cp);
	if (cp[0] == '[' && cp[l - 1] == ']') {
	    cp[l - 1] = '\0';
	    cp++;
	}
#endif
	if (STR_EQ(cp, "EXCEPT")) {
	    clients = 0;
	} else {
	    clients++;
	    if ((host = split_at(cp + 1, '@@')) != NULL) {	/* user@@host */
		check_user(cp);
		check_host(host);
	    } else {
		check_host(cp);
	    }
	}
    }
    if (clients == 0)
	tcpd_warn("client list is empty or ends in EXCEPT");
}

/* check_daemon - criticize daemon pattern */

static void check_daemon(pat)
char   *pat;
{
    if (pat[0] == '@@') {
	tcpd_warn("%s: daemon name begins with \"@@\"", pat);
    } else if (pat[0] == '.') {
	tcpd_warn("%s: daemon name begins with dot", pat);
    } else if (pat[0] == '\0') {
	tcpd_warn("%s: daemon name begins with NUL", pat);
    } else if (pat[strlen(pat) - 1] == '.') {
	tcpd_warn("%s: daemon name ends in dot", pat);
    } else if (STR_EQ(pat, "ALL") || STR_EQ(pat, unknown)) {
	 /* void */ ;
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {
	tcpd_warn("%s: daemon name may be reserved word", pat);
    } else {
	switch (inet_get(pat)) {
	case WR_UNKNOWN:
	    tcpd_warn("%s: no such process name in %s", pat, inetcf);
	    inet_set(pat, WR_YES);		/* shut up next time */
	    break;
	case WR_NOT:
	    tcpd_warn("%s: service possibly not wrapped", pat);
	    inet_set(pat, WR_YES);
	    break;
	}
    }
}

/* check_user - criticize user pattern */

static void check_user(pat)
char   *pat;
{
    if (pat[0] == '@@') {			/* @@netgroup */
	tcpd_warn("%s: user name begins with \"@@\"", pat);
    } else if (pat[0] == '.') {
	tcpd_warn("%s: user name begins with dot", pat);
    } else if (pat[0] == '\0') {
	tcpd_warn("%s: user name begins with NUL", pat);
    } else if (pat[strlen(pat) - 1] == '.') {
	tcpd_warn("%s: user name ends in dot", pat);
    } else if (STR_EQ(pat, "ALL") || STR_EQ(pat, unknown)
	       || STR_EQ(pat, "KNOWN")) {
	 /* void */ ;
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {
	tcpd_warn("%s: user name may be reserved word", pat);
    }
}

#ifdef INET6
static int check_inet_addr(pat)
char	*pat;
{
	struct addrinfo *res;

	res = find_inet_addr(pat, AI_NUMERICHOST);
	if (res) {
		freeaddrinfo(res);
		return 1;
	} else
		return 0;
}
#endif

/* check_host - criticize host pattern */
static int check_host(pat)
char   *pat;
{
    char   *mask;
    int     addr_count = 1;

    if (pat[0] == '@@') {			/* @@netgroup */
#ifdef NO_NETGRENT
	/* SCO has no *netgrent() support */
#else
#ifdef NETGROUP
	const char   *machinep;
	const char   *userp;
	const char   *domainp;

	setnetgrent(pat + 1);
	if (getnetgrent(&machinep, &userp, &domainp) == 0)
	    tcpd_warn("%s: unknown or empty netgroup", pat + 1);
	endnetgrent();
#else
	tcpd_warn("netgroup support disabled");
#endif
#endif
    } else if ((mask = split_at(pat, '/')) != NULL) {	/* network/netmask */
#ifdef INET6
	char *ep;
#endif
	if (dot_quad_addr_new(pat, NULL) && dot_quad_addr_new(mask, NULL))
	    ; /*okay*/
#ifdef INET6
	else if (check_inet_addr(pat) && check_inet_addr(mask))
	    ; /*okay*/
	else if (check_inet_addr(pat) &&
	    (ep = NULL, strtoul(mask, &ep, 10), ep && !*ep))
	    ; /*okay*/
#endif
	else
	    tcpd_warn("%s/%s: bad net/mask pattern", pat, mask);
    } else if (STR_EQ(pat, "FAIL")) {		/* obsolete */
	tcpd_warn("FAIL is no longer recognized");
	tcpd_warn("(use EXCEPT or DENY instead)");
    } else if (reserved_name(pat)) {		/* other reserved */
	 /* void */ ;
    } else if (NOT_INADDR(pat)) {		/* internet name */
	if (pat[0] == '\0') {
	    tcpd_warn("%s: domain or host name begins with NUL", pat);
	} else if (pat[strlen(pat) - 1] == '.') {
	    tcpd_warn("%s: domain or host name ends in dot", pat);
	} else if (pat[0] != '.') {
	    addr_count = check_dns(pat);
	}
    } else {					/* numeric form */
	if (STR_EQ(pat, "0.0.0.0") || STR_EQ(pat, "255.255.255.255")) {
	    /* void */ ;
	} else if (pat[0] == '.') {
	    tcpd_warn("%s: network number begins with dot", pat);
	} else if (pat[0] == '\0') {
	    tcpd_warn("%s: network number begins with NUL", pat);
	} else if (pat[strlen(pat) - 1] != '.') {
	    check_dns(pat);
	}
    }
    return (addr_count);
}

/* reserved_name - determine if name is reserved */

static int reserved_name(pat)
char   *pat;
{
    return (STR_EQ(pat, unknown)
	    || STR_EQ(pat, "KNOWN")
	    || STR_EQ(pat, paranoid)
	    || STR_EQ(pat, "ALL")
	    || STR_EQ(pat, "LOCAL"));
}
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.10 2008/05/17 23:31:52 sobrado Exp $	*/
@


1.10
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.9 2006/12/20 01:50:30 ray Exp $	*/
a17 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#) tcpdchk.c 1.8 97/02/12 02:13:25";
#else
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.9 2006/12/20 01:50:30 ray Exp $";
#endif
#endif
@


1.9
log
@More strlen("") fixes.

OK otto@@, ``If it makes you feel better'' millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.8 2003/06/26 07:53:27 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.8 2003/06/26 07:53:27 deraadt Exp $";
d191 1
a191 1
    fprintf(stderr, "usage: %s [-a] [-d] [-i inet_conf] [-v]\n", myname);
@


1.8
log
@simple protos
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.7 2002/07/30 22:27:20 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.7 2002/07/30 22:27:20 deraadt Exp $";
d375 2
d409 2
d484 3
a486 1
	if (pat[strlen(pat) - 1] == '.') {
d496 2
@


1.7
log
@some snprintf and strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.6 2002/06/07 03:32:04 itojun Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.6 2002/06/07 03:32:04 itojun Exp $";
d100 1
a100 3
int     main(argc, argv)
int     argc;
char  **argv;
@


1.6
log
@support scoped IPv6 address.
no visible API change, old config files work just fine.
now  you can use expressions like "ALL: [fe80::%lo0/64]".  theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.5 2001/07/08 21:18:13 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.5 2001/07/08 21:18:13 deraadt Exp $";
d290 1
a290 1
    strcpy(buf, list);
d311 1
a311 1
    strcpy(buf, list);
d342 1
a342 1
    strcpy(buf, list);
@


1.5
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.4 2000/10/14 00:56:14 itojun Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.4 2000/10/14 00:56:14 itojun Exp $";
a30 3
#ifdef INET6
#include <sys/socket.h>
#endif
d76 12
a87 9
static void usage();
static void parse_table();
static void print_list();
static void check_daemon_list();
static void check_client_list();
static void check_daemon();
static void check_user();
static int check_host();
static int reserved_name();
d422 15
a437 1

d463 1
a463 1
	struct in6_addr in6;
d465 1
a465 2
	if (dot_quad_addr_new(pat, NULL)
	    && dot_quad_addr_new(mask, NULL))
d468 1
a468 2
	else if (inet_pton(AF_INET6, pat, &in6) == 1
	      && inet_pton(AF_INET6, mask, &in6) == 1)
d470 2
a471 3
	else if (inet_pton(AF_INET6, pat, &in6) == 1
	      && strchr(mask, ':') == NULL
	      && 0 <= atoi(mask) && atoi(mask) <= 128)
@


1.4
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.3 1999/06/06 15:34:57 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.3 1999/06/06 15:34:57 deraadt Exp $";
d37 1
@


1.3
log
@use dot_quad_addr_new() as required
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.2 1999/05/23 17:19:23 aaron Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.2 1999/05/23 17:19:23 aaron Exp $";
d31 3
d337 3
d344 7
d355 1
a355 1
	    if ((host = split_at(cp + 1, '@@'))) {	/* user@@host */
d446 17
a462 2
    } else if ((mask = split_at(pat, '/'))) {	/* network/netmask */
	if (!dot_quad_addr_new(pat, NULL) || !dot_quad_addr_new(mask, NULL))
@


1.2
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdchk.c,v 1.1 1997/02/26 06:17:09 downsj Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: tcpdchk.c,v 1.1 1997/02/26 06:17:09 downsj Exp $";
d434 1
a434 2
	if (dot_quad_addr(pat) == INADDR_NONE
	    || dot_quad_addr(mask) == INADDR_NONE)
@


1.1
log
@Initial integration of userland tcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD$";
d109 1
a109 1
    while ((c = getopt(argc, argv, "adi:v")) != EOF) {
@

