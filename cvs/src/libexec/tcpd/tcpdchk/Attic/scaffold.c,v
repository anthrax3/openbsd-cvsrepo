head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.32
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.28
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.26
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.24
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.22
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.20
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.18
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.24.13.56.01;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.22.27.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.32.04;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.07.23.01.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.14.00.56.14;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.06.06.18.58.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.06.06.15.34.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.06.17.07;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.9
log
@libwrap is going away, so can this.
ok tedu
@
text
@/*	$OpenBSD: scaffold.c,v 1.8 2009/10/27 23:59:32 deraadt Exp $	*/

 /*
  * Routines for testing only. Not really industrial strength.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* System libraries. */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>
#include <setjmp.h>
#include <string.h>
#include <stdlib.h>

#include <tcpd.h>

#ifndef INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

/* Application-specific. */

#include "scaffold.h"

 /*
  * These are referenced by the options module and by rfc931.c.
  */
int     allow_severity = SEVERITY;
int     deny_severity = LOG_WARNING;
int	rfc931_timeout = RFC931_TIMEOUT;

/* find_inet_addr - find all addresses for this host, result to free() */

struct addrinfo *find_inet_addr(host, flags)
char   *host;
int	flags;
{
    struct addrinfo hints, *res;
    int error;

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_CANONNAME | flags;
    error = getaddrinfo(host, "0", &hints, &res);
    if (error) {
	tcpd_warn("%s: %s", host, gai_strerror(error));
	return (0);
    }

    if (res->ai_canonname && STR_NE(host, res->ai_canonname)) {
	tcpd_warn("%s: hostname alias", host);
	tcpd_warn("(official name: %.*s)", STRING_LENGTH, res->ai_canonname);
    }
    return (res);
}

/* check_dns - give each address thorough workout, return address count */

int     check_dns(host)
char   *host;
{
    struct request_info request;
    struct sockaddr_storage ss;
    struct addrinfo *res0, *res;
    int     count;

    if ((res0 = find_inet_addr(host, 0)) == NULL)
	return (0);
    memset(&ss, 0, sizeof(ss));
    request_init(&request, RQ_CLIENT_SIN, &ss, 0);
    sock_methods(&request);

    count = 0;
    for (res = res0; res; res = res->ai_next) {
	count++;
	if (res->ai_addrlen > sizeof(ss))
	    continue;
	memcpy(&ss, res->ai_addr, res->ai_addrlen);

	/*
	 * Force host name and address conversions. Use the request structure
	 * as a cache. Detect hostname lookup problems. Any name/name or
	 * name/address conflicts will be reported while eval_hostname() does
	 * its job.
	 */
	request_set(&request, RQ_CLIENT_ADDR, "", RQ_CLIENT_NAME, "", 0);
	if (STR_EQ(eval_hostname(request.client), unknown))
	    tcpd_warn("host address %s->name lookup failed",
		      eval_hostaddr(request.client));
	    tcpd_warn("%s %s", eval_hostname(request.client), unknown);
    }
    freeaddrinfo(res0);
    return (count);
}

/* dummy function to intercept the real shell_cmd() */

/* ARGSUSED */

void    shell_cmd(command)
char   *command;
{
    if (hosts_access_verbose)
	printf("command: %s", command);
}

/* dummy function  to intercept the real clean_exit() */

/* ARGSUSED */

void    clean_exit(request)
struct request_info *request;
{
    exit(0);
}

/* dummy function  to intercept the real rfc931() */

/* ARGSUSED */
void    rfc931(a1, a2, d1)
struct sockaddr *a1, *a2;
char *d1;
{
}

/* check_path - examine accessibility */

int     check_path(path, st)
char   *path;
struct stat *st;
{
    struct stat stbuf;
    char    buf[BUFSIZ];

    if (stat(path, st) < 0)
	return (-1);
#ifdef notdef
    if (st->st_uid != 0)
	tcpd_warn("%s: not owned by root", path);
    if (st->st_mode & 020)
	tcpd_warn("%s: group writable", path);
#endif
    if (st->st_mode & 002)
	tcpd_warn("%s: world writable", path);
    if (path[0] == '/' && path[1] != 0) {
	strrchr((strlcpy(buf, path, sizeof buf), buf), '/')[0] = 0;
	(void) check_path(buf[0] ? buf : "/", &stbuf);
    }
    return (0);
}
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.7 2002/07/30 22:27:20 deraadt Exp $	*/
@


1.7
log
@some snprintf and strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.6 2002/06/07 03:32:04 itojun Exp $	*/
a7 8

#ifndef lint
#if 0
static char sccs_id[] = "@@(#) scaffold.c 1.5 95/01/03 09:13:48";
#else
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.6 2002/06/07 03:32:04 itojun Exp $";
#endif
#endif
@


1.6
log
@support scoped IPv6 address.
no visible API change, old config files work just fine.
now  you can use expressions like "ALL: [fe80::%lo0/64]".  theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.5 2002/05/07 23:01:07 deraadt Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.5 2002/05/07 23:01:07 deraadt Exp $";
d162 1
a162 1
	strrchr(strcpy(buf, path), '/')[0] = 0;
@


1.5
log
@wrong size of address; harding@@motd.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.4 2000/10/14 00:56:14 itojun Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.4 2000/10/14 00:56:14 itojun Exp $";
d46 1
a46 37
int     rfc931_timeout = RFC931_TIMEOUT;

/* dup_hostent - create hostent in one memory block */

static struct hostent *dup_hostent(hp)
struct hostent *hp;
{
    struct hostent_block {
	struct hostent host;
	char   *addr_list[1];
    };
    struct hostent_block *hb;
    int     count;
    char   *data;
    char   *addr;

    for (count = 0; hp->h_addr_list[count] != 0; count++)
	 /* void */ ;

    if ((hb = (struct hostent_block *) malloc(sizeof(struct hostent_block)
			 + (hp->h_length + sizeof(char *)) * count)) == 0) {
	fprintf(stderr, "Sorry, out of memory\n");
	exit(1);
    }
    memset((char *) &hb->host, 0, sizeof(hb->host));
    hb->host.h_addrtype = hp->h_addrtype;
    hb->host.h_length = hp->h_length;
    hb->host.h_addr_list = hb->addr_list;
    hb->host.h_addr_list[count] = 0;
    data = (char *) (hb->host.h_addr_list + count + 1);

    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	hb->host.h_addr_list[count] = data + hp->h_length * count;
	memcpy(hb->host.h_addr_list[count], addr, hp->h_length);
    }
    return (&hb->host);
}
d50 1
a50 1
struct hostent *find_inet_addr(host)
d52 1
d54 2
a55 7
    struct in_addr addr;
    struct hostent *hp;
    static struct hostent h;
    static char *addr_list[2];
#ifdef INET6
    static struct in6_addr in6;
#endif
d57 7
a63 9
    /*
     * Host address: translate it to internal form.
     */
    if (dot_quad_addr_new(host, &addr.s_addr)) {
	h.h_addr_list = addr_list;
	h.h_addr_list[0] = (char *) &addr;
	h.h_length = sizeof(addr);
	h.h_addrtype = AF_INET;
	return (dup_hostent(&h));
a64 9
#ifdef INET6
    if (inet_pton(AF_INET6, host, &in6) == 1) {
	h.h_addr_list = addr_list;
	h.h_addr_list[0] = (char *) &in6;
	h.h_length = sizeof(in6);
	h.h_addrtype = AF_INET6;
	return (dup_hostent(&h));
    }
#endif
d66 1
a66 38
    /*
     * Map host name to a series of addresses. Watch out for non-internet
     * forms or aliases. The NOT_INADDR() is here in case gethostbyname() has
     * been "enhanced" to accept numeric addresses. Make a copy of the
     * address list so that later gethostbyXXX() calls will not clobber it.
     */
#ifdef INET6
    if (NOT_INADDR(host) == 0 && inet_pton(AF_INET6, host, &in6) == 1)
#else
    if (NOT_INADDR(host) == 0)
#endif
    {
	tcpd_warn("%s: not an internet address", host);
	return (0);
    }
#ifdef INET6
    /*
     * XXX this behavior may, or may not be desirable.
     * - we may better use getipnodebyname() to addresses of get both AFs,
     *   however, getipnodebyname() is not widely implemented.
     * - it may be better to have a way to specify the AF to use.
     */
    if ((hp = gethostbyname2(host, AF_INET)) == 0
     && (hp = gethostbyname2(host, AF_INET6)) == 0) {
	tcpd_warn("%s: host not found", host);
	return (0);
    }
#else
    if ((hp = gethostbyname(host)) == 0) {
	tcpd_warn("%s: host not found", host);
	return (0);
    }
    if (hp->h_addrtype != AF_INET) {
	tcpd_warn("%d: not an internet host", hp->h_addrtype);
	return (0);
    }
#endif
    if (STR_NE(host, hp->h_name)) {
d68 1
a68 1
	tcpd_warn("(official name: %s)", hp->h_name);
d70 1
a70 1
    return (dup_hostent(hp));
d79 2
a80 2
    struct sockaddr_storage sin;
    struct hostent *hp;
a81 3
    char   *addr;
    char *ap;
    int alen;
d83 1
a83 1
    if ((hp = find_inet_addr(host)) == 0)
d85 2
a86 1
    request_init(&request, RQ_CLIENT_SIN, &sin, 0);
a87 16
    memset((char *) &sin, 0, sizeof(sin));
    sin.ss_family = hp->h_addrtype;
    switch (hp->h_addrtype) {
    case AF_INET:
	ap = (char *)&((struct sockaddr_in *)&sin)->sin_addr;
	alen = sizeof(struct in_addr);
	break;
#ifdef INET6
    case AF_INET6:
	ap = (char *)&((struct sockaddr_in6 *)&sin)->sin6_addr;
	alen = sizeof(struct in6_addr);
	break;
#endif
    default:
	return (0);
    }
d89 6
a94 2
    for (count = 0; (addr = hp->h_addr_list[count]) != 0; count++) {
	memcpy(ap, addr, alen);
d106 1
d108 1
a108 1
    free((char *) hp);
@


1.4
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.3 1999/06/06 18:58:54 deraadt Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.3 1999/06/06 18:58:54 deraadt Exp $";
d183 1
a183 1
	alen = sizeof(struct in6_addr);
@


1.3
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.2 1999/06/06 15:34:57 deraadt Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.2 1999/06/06 15:34:57 deraadt Exp $";
d71 1
d93 3
d104 1
d107 9
d123 6
a128 1
    if (NOT_INADDR(host) == 0) {
d132 13
d153 1
d167 1
a167 1
    struct sockaddr_in sin;
d171 2
d179 15
a193 1
    sin.sin_family = AF_INET;
d196 1
a196 1
	memcpy((char *) &sin.sin_addr, addr, sizeof(sin.sin_addr));
d238 1
a238 1
struct sockaddr_in *a1, *a2;
@


1.2
log
@use dot_quad_addr_new() as required
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.1 1997/02/26 06:17:07 downsj Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.1 1997/02/26 06:17:07 downsj Exp $";
d96 1
a96 1
    if (dot_quad_addr(host, &addr.s_addr)) {
@


1.1
log
@Initial integration of userland tcpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: scaffold.c,v 1.1 1997/02/26 03:06:56 downsj Exp $	*/
d13 1
a13 1
static char rcsid[] = "$OpenBSD: scaffold.c,v 1.1 1997/02/26 03:06:56 downsj Exp $";
d96 1
a96 1
    if ((addr.s_addr = dot_quad_addr(host)) != INADDR_NONE) {
@

