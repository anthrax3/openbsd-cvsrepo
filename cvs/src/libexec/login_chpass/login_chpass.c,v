head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.16.0.14
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.6
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.26
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.24
	OPENBSD_5_0:1.15.0.22
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.20
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.11.26.19.01.47;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	0NbTNVgy2y455HVw;

1.19
date	2015.10.25.08.39.26;	author ajacoutot;	state Exp;
branches;
next	1.18;
commitid	cLlYHAKgT7hh5C62;

1.18
date	2015.10.22.12.32.33;	author tedu;	state Exp;
branches;
next	1.17;
commitid	eiozEsHyKysLLYUw;

1.17
date	2015.10.05.17.31.17;	author millert;	state Exp;
branches;
next	1.16;
commitid	TEnCycDCWPhCYHBk;

1.16
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.09.19.14.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.14.18.33.42;	author biorn;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.28.21.52.40;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.10.21.30.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.12.13.14.08;	author hin;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.06.18.45.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.28.01.14.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.02.01.27.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.26.09.32.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.06.21.53.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.07.04.22.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.06.05.37.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.13.06.35;	author mpech;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.12.02.30.44;	author millert;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Delete YP password related code.  As a result, these can also be
pledged.  Keep an eye out for regressions, because they could be
uncomfortable.
ok beck semarie
@
text
@/*	$OpenBSD: login_chpass.c,v 1.19 2015/10/25 08:39:26 ajacoutot Exp $	*/

/*-
 * Copyright (c) 1995,1996 Berkeley Software Design, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: login_chpass.c,v 1.3 1996/08/21 21:01:48 prb Exp $
 */
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <login_cap.h>

#define	_PATH_LOGIN_LCHPASS	"/usr/libexec/auth/login_lchpass"

#define BACK_CHANNEL	3

void	local_chpass(char **);

int
main(int argc, char *argv[])
{
	struct rlimit rl;
	int c;

	rl.rlim_cur = 0;
	rl.rlim_max = 0;
	(void)setrlimit(RLIMIT_CORE, &rl);

	(void)setpriority(PRIO_PROCESS, 0, 0);

	if (pledge("stdio exec", NULL) == -1)
		err(1, "pledge");

	openlog("login", LOG_ODELAY, LOG_AUTH);

	while ((c = getopt(argc, argv, "s:v:")) != -1)
		switch (c) {
		case 'v':
			break;
		case 's':	/* service */
			if (strcmp(optarg, "login") != 0) {
				syslog(LOG_ERR, "%s: invalid service", optarg);
				exit(1);
			}
			break;
		default:
			syslog(LOG_ERR, "usage error");
			exit(1);
		}

	switch (argc - optind) {
	case 2:
		/* class is not used */
	case 1:
		break;
	default:
		syslog(LOG_ERR, "usage error");
		exit(1);
	}

	local_chpass(argv);
	/* NOTREACHED */
	exit(0);
}

void
local_chpass(char *argv[])
{

	/* login_lchpass doesn't check instance so don't bother restoring it */
	argv[0] = strrchr(_PATH_LOGIN_LCHPASS, '/') + 1;
	execv(_PATH_LOGIN_LCHPASS, argv);
	syslog(LOG_ERR, "%s: %m", _PATH_LOGIN_LCHPASS);
	exit(1);
}
@


1.19
log
@No need to declare pwd_gensalt; it's unused and gone.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.18 2015/10/22 12:32:33 tedu Exp $	*/
a53 10
#ifdef YP
# include <netdb.h>
# include <rpc/rpc.h>
# include <rpcsvc/yp_prot.h>
# include <rpcsvc/ypclnt.h>
# define passwd yp_passwd_rec
# include <rpcsvc/yppasswd.h>
# undef passwd
#endif

a57 9
#ifdef  YP
struct iovec iov[2] = { { BI_SILENT, sizeof(BI_SILENT) - 1 }, { "\n", 1 } };

int	_yp_check(char **);
char	*ypgetnewpasswd(struct passwd *, char **);
struct passwd *ypgetpwnam(char *);
void	kbintr(int);
#endif

a58 1
void	yp_chpass(char *);
a62 3
#ifdef YP
	char *username;
#endif
d72 3
a95 3
#ifdef YP
		username = argv[optind];
#endif
a101 4
#ifdef  YP
	if (_yp_check(NULL))
		yp_chpass(username);
#endif
a116 123

#ifdef YP
void
yp_chpass(char *username)
{
	char *master;
	int r, rpcport, status;
	struct yppasswd yppasswd;
	struct passwd *pw;
	struct timeval tv;
	CLIENT *client;
	extern char *domain;

	(void)signal(SIGINT, kbintr);
	(void)signal(SIGQUIT, kbintr);

	if ((r = yp_get_default_domain(&domain)) != 0) {
		warnx("can't get local YP domain. Reason: %s", yperr_string(r));
		exit(1);
	}

	/*
	 * Find the host for the passwd map; it should be running
	 * the daemon.
	 */
	if ((r = yp_master(domain, "passwd.byname", &master)) != 0) {
		warnx("can't find the master YP server. Reason: %s",
		    yperr_string(r));
		exit(1);
	}

	/* Ask the portmapper for the port of the daemon. */
	if ((rpcport = getrpcport(master, YPPASSWDPROG,
	    YPPASSWDPROC_UPDATE, IPPROTO_UDP)) == 0) {
		warnx("master YP server not running yppasswd daemon.");
		warnx("Can't change password.");
		exit(1);
	}

	if (rpcport >= IPPORT_RESERVED) {
		warnx("yppasswd daemon is on an invalid port.");
		exit(1);
	}

	/* If user doesn't exist, just prompt for old password and exit. */
	pw = ypgetpwnam(username);
	if (pw) {
		if (pw->pw_uid == 0) {
			syslog(LOG_ERR, "attempted root password change");
			pw = NULL;
		} else if (*pw->pw_passwd == '\0') {
			syslog(LOG_ERR, "%s attempting to add password",
			    username);
			pw = NULL;
		}
	}
	if (pw == NULL) {
		char *p;
		/* no such user, but fake to thwart timing attack */
		if ((p = getpass("Old password:")) != NULL) {
			crypt_checkpass(p, NULL);
			explicit_bzero(p, strlen(p));
		}
		warnx("YP passwd database unchanged.");
		exit(1);
	}

	/* prompt for new password */
	yppasswd.newpw.pw_passwd = ypgetnewpasswd(pw, &yppasswd.oldpass);

	/* tell rpc.yppasswdd */
	yppasswd.newpw.pw_name	= pw->pw_name;
	yppasswd.newpw.pw_uid	= pw->pw_uid;
	yppasswd.newpw.pw_gid	= pw->pw_gid;
	yppasswd.newpw.pw_gecos = pw->pw_gecos;
	yppasswd.newpw.pw_dir	= pw->pw_dir;
	yppasswd.newpw.pw_shell	= pw->pw_shell;

	client = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, "udp");
	if (client == NULL) {
		warnx("cannot contact yppasswdd on %s: Reason: %s",
		    master, yperr_string(YPERR_YPBIND));
		free(yppasswd.newpw.pw_passwd);
		exit(1);
	}
	client->cl_auth = authunix_create_default();
	tv.tv_sec = 2;
	tv.tv_usec = 0;
	r = clnt_call(client, YPPASSWDPROC_UPDATE,
	    xdr_yppasswd, &yppasswd, xdr_int, &status, tv);
	if (r)
		warnx("rpc to yppasswdd failed.");
	else if (status) {
		printf("Couldn't change YP password.\n");
		free(yppasswd.newpw.pw_passwd);
		exit(1);
	}
	printf("The YP password has been changed on %s, the master YP passwd server.\n",
	    master);
	free(yppasswd.newpw.pw_passwd);
	(void)writev(BACK_CHANNEL, iov, 2);
	exit(0);
}

/* ARGSUSED */
void
kbintr(int signo)
{
	char msg[] = "YP passwd database unchanged.\n";
	struct iovec iv[3];
	extern char *__progname;

	iv[0].iov_base = __progname;
	iv[0].iov_len = strlen(__progname);
	iv[1].iov_base = ": ";
	iv[1].iov_len = 2;
	iv[2].iov_base = msg;
	iv[2].iov_len = sizeof(msg) - 1;
	writev(STDERR_FILENO, iv, 3);

	_exit(1);
}
#endif
@


1.18
log
@use crypt_checkpass instead of doing things the hard way with crypt.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.17 2015/10/05 17:31:17 millert Exp $	*/
a74 1
int	pwd_gensalt(char *, int, login_cap_t *, char);
@


1.17
log
@Use explicit_bzero() instead of memset() for zeroing out secrets.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.16 2012/12/04 02:24:47 deraadt Exp $	*/
d202 2
a203 4
		char *p, salt[_PASSWORD_LEN + 1];
		login_cap_t *lc;

		/* no such user, get appropriate salt to thwart timing attack */
d205 1
a205 4
			if ((lc = login_getclass(NULL)) == NULL ||
			    pwd_gensalt(salt, sizeof(salt), lc, 'y') == 0)
				strlcpy(salt, "xx", sizeof(salt));
			crypt(p, salt);
@


1.16
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.15 2006/03/09 19:14:09 millert Exp $	*/
d211 1
a211 1
			memset(p, 0, strlen(p));
@


1.15
log
@Foil potential timing attacks by using the correct password hash
instead of "xx".  In practice this means bcrypt() will be used for
non-existent users instead of DES crypt().
Adapted from a patch by Peter Philipp.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.14 2005/04/14 18:33:42 biorn Exp $	*/
a35 1
#include <sys/param.h>
@


1.14
log
@
drop some krb4 stuff

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.13 2004/09/28 21:52:40 deraadt Exp $	*/
d76 1
d203 9
a211 3
		char *p = getpass("Old password:");
		if (p != NULL) {
			crypt(p, "xx");
@


1.13
log
@pass lint
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.12 2004/03/10 21:30:27 millert Exp $	*/
a78 1
void	krb_chpass(char *, char *, char **);
@


1.12
log
@More checking for a NULL return value from getpass().  otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.11 2003/08/12 13:14:08 hin Exp $	*/
d69 1
a71 1
#ifdef  YP
d85 1
d87 1
d118 1
d120 1
d249 1
@


1.11
log
@Cleanup obsolete kerberos 4 stuff.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.10 2002/09/06 18:45:06 deraadt Exp $	*/
d200 4
a203 2
		crypt(p, "xx");
		memset(p, 0, strlen(p));
@


1.10
log
@ansi; ok millert pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.9 2002/06/28 01:14:37 deraadt Exp $	*/
a64 7
#ifdef KERBEROS
# include <netinet/in.h>
# include <kerberosIV/krb.h>
# include <kerberosIV/kadm.h>
# include <kerberosIV/kadm_err.h>
#endif

a77 5
#ifdef KERBEROS
int	get_pw_new_pwd(char *, int, krb_principal *, int);
char	realm[REALM_SZ];
#endif

d85 1
a85 1
	char *username, *instance;
a122 11
	/* Instance ignored for all but Kerberos. */
	instance = strchr(username, '.');
	if (instance)
		*instance++ = '\0';
	else
		instance = "";

#ifdef KERBEROS
	if (krb_get_lrealm(realm, 0) == KSUCCESS)
		krb_chpass(username, instance, argv);
#endif
a258 61
}
#endif

#ifdef KERBEROS
void
krb_chpass(char *username, char *instance, char *argv[])
{
	int rval;
	char pword[MAX_KPW_LEN];
	char tktstring[MAXPATHLEN];
	krb_principal principal;
	sigset_t set;

	sigemptyset(&set);
	sigaddset(&set, SIGINT);
	sigaddset(&set, SIGQUIT);
	(void)sigprocmask(SIG_BLOCK, &set, NULL);

	memset(&principal, 0, sizeof(principal));
	krb_get_default_principal(principal.name,
	    principal.instance, principal.realm);

	snprintf(tktstring, sizeof(tktstring), "%s.chpass.%s.%ld",
	    TKT_ROOT, username, (long)getpid());
	krb_set_tkt_string(tktstring);

	(void)setpriority(PRIO_PROCESS, 0, -4);

	if (get_pw_new_pwd(pword, sizeof(pword), &principal, 0)) {
		dest_tkt();
		exit(1);
	}

	rval = kadm_init_link (PWSERV_NAME, KRB_MASTER, principal.realm);
	if (rval != KADM_SUCCESS)
		com_err(argv[0], rval, "while initializing");
	else {
		des_cblock newkey;
		char *pw_msg; /* message from server */

		des_string_to_key(pword, &newkey);
		rval = kadm_change_pw_plain((u_char *)&newkey, pword, &pw_msg);
		memset(newkey, 0, sizeof(newkey));

		if (rval == KADM_INSECURE_PW)
			warnx("Insecure password: %s", pw_msg);
		else if (rval != KADM_SUCCESS)
			com_err(argv[0], rval, "attempting to change password.");
	}
	memset(pword, 0, sizeof(pword));

	if (rval != KADM_SUCCESS)
		fprintf(stderr, "Password NOT changed.\n");
	else
		printf("Password changed.\n");

	dest_tkt();

	if (rval == 0)
		(void)writev(BACK_CHANNEL, iov, 2);
	exit(rval);
@


1.9
log
@minor indent cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.8 2002/06/02 01:27:15 deraadt Exp $	*/
d95 1
a95 3
main(argc, argv)
	int argc;
	char *argv[];
d97 1
a98 2
	char *username;
	char *instance;
d156 1
a156 2
local_chpass(argv)
	char *argv[];
d168 1
a168 2
yp_chpass(username)
	char *username;
d266 2
a267 2
void kbintr(signo)
	int signo;
d287 1
a287 4
krb_chpass(username, instance, argv)
	char *username;
	char *instance;
	char *argv[];
@


1.8
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.7 2002/05/26 09:32:08 deraadt Exp $	*/
d99 4
a102 4
    	struct rlimit rl;
    	char *username;
    	char *instance;
    	int c;
d112 1
a112 1
    	while ((c = getopt(argc, argv, "s:v:")) != -1)
d144 1
a144 1
	
d239 1
a239 1
	yppasswd.newpw.pw_uid 	= pw->pw_uid;
d324 1
a324 1
	if (rval != KADM_SUCCESS) 
d350 1
a350 1
    	exit(rval);
@


1.7
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.6 2002/02/16 21:27:30 millert Exp $	*/
d113 1
a113 1
		switch(c) {
d127 1
a127 1
	switch(argc - optind) {
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.5 2002/01/06 21:53:28 millert Exp $	*/
d312 2
a313 2
	snprintf(tktstring, sizeof(tktstring), "%s.chpass.%s.%d",
	    TKT_ROOT, username, getpid());
@


1.5
log
@Don't let root change it's password via login_l?chpass(8).
At some point in the future, passwd(1) may call these auth methods
at which time we will need a flag to allow root to do a password
change and also to allow account w/o a password to be given one.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.4 2001/12/07 04:22:41 millert Exp $	*/
d79 4
a82 4
int	_yp_check __P((char **));
char	*ypgetnewpasswd __P((struct passwd *, char **));
struct passwd *ypgetpwnam __P((char *));
void	kbintr __P((int));
d86 1
a86 1
int	get_pw_new_pwd __P((char *, int, krb_principal *, int));
d90 3
a92 3
void	local_chpass __P((char **));
void	krb_chpass __P((char *, char *, char **));
void	yp_chpass __P((char *));
@


1.4
log
@o Use writev() to send status on the backchannel instead of fdopen()ing
  fd 3 and using stdio.

o Add SIGINT/SIGQUIT signal handler for yp_chpass() now that getpass()
  is interuptible.

o Block SIGINT/SIGQUIT in krb_chpass() until it is made to clean up
  after itself properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.3 2001/12/06 05:37:03 millert Exp $	*/
d215 12
a226 1
	if ((pw = ypgetpwnam(username)) == NULL) {
a231 6
	}

	if (*pw->pw_passwd == '\0') {
		syslog(LOG_ERR, "%s attempting to add password", username);
		(void)writev(BACK_CHANNEL, iov, 2);
		exit(0);
@


1.3
log
@Do not set handler for SIGINT and SIGQUIT to SIG_IGN since it prevents
getpass()/readpassphrase() from being able to restore the tty mode
on keyboard interrupt.  Along with the recent readpassphrase.c commit
this means that if you ^C things that use login scripts (like su(1))
with a non-CBREAK shell your tty mode will be restored nicely.

TODO:
The various login scripts need to install handlers to avoid leaving
turd files or otherwise ending in a bad state.  It would also be
nice to send BI_REJECT to the back channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.2 2001/10/24 13:06:35 mpech Exp $	*/
d41 1
d74 4
d82 1
a174 1
	FILE *back;
d183 2
a184 4
	if (!(back = fdopen(3, "a")))  {
		syslog(LOG_ERR, "reopening back channel: %m");
		exit(1);
	}
d225 1
a225 1
		fprintf(back, BI_SILENT "\n");
d262 1
a262 1
	fprintf(back, BI_SILENT "\n");
d265 18
a291 1
	FILE *back;
d296 1
d298 4
a301 4
	if (!(back = fdopen(3, "a")))  {
		syslog(LOG_ERR, "reopening back channel: %m");
		exit(1);
	}
d344 1
a344 1
		fprintf(back, BI_SILENT "\n");
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: login_chpass.c,v 1.1 2000/12/12 02:30:44 millert Exp $	*/
a101 2
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
@


1.1
log
@chpass login script; changes local, yp, or kerberos password
will be used when BSD authentication is enabled
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
    	while ((c = getopt(argc, argv, "s:v:")) != EOF)
@

