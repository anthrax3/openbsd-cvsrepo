head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.6
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.20
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.16
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.18
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.14
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2015.10.05.17.31.17;	author millert;	state Exp;
branches;
next	1.18;
commitid	TEnCycDCWPhCYHBk;

1.18
date	2013.12.03.01.29.00;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.27.21.25.25;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.07.12.17.20;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.13.21.21.17;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.15.10.18.42;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.12.14.13.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.23.04.09;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.20.17.32.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.16.12.38.40;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.28.01.14.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.18.18.31.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.28.21.18.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.20.20.08.23;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.20.01.54.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.20.01.52.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.20.01.41.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use explicit_bzero() instead of memset() for zeroing out secrets.
OK deraadt@@
@
text
@/*	$OpenBSD: token.c,v 1.18 2013/12/03 01:29:00 deraadt Exp $	*/

/*-
 * Copyright (c) 1995 Migration Associates Corp. All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: token.c,v 1.2 1996/08/28 22:07:55 prb Exp $
 */

/*
 * DES functions for one-way encrypting Authentication Tokens.
 * All knowledge of DES is confined to this file.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <ctype.h>
#include <stdio.h>
#include <syslog.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <openssl/des.h>

#include "token.h"
#include "tokendb.h"

/*
 * Define a union of various types of arguments to DES functions.
 * All native DES types are modulo 8 bytes in length. Cipher text
 * needs a trailing null byte.
 */

typedef	union {
	DES_cblock	cb;
	char		ct[9];
	uint32_t	ul[2];
} TOKEN_CBlock;

/*
 * Static definition of random number challenge for token.
 * Challenge length is 8 bytes, left-justified with trailing null byte.
 */

static	TOKEN_CBlock tokennumber;

/*
 * Static function prototypes
 */

static	void	tokenseed(TOKEN_CBlock *);
static	void	lcase(char *);
static	void	h2d(char *);
static	void	h2cb(char *, TOKEN_CBlock *);
static	void	cb2h(TOKEN_CBlock, char *);

/*
 * Generate random DES cipherblock seed. Feedback key into
 * new_random_key to strengthen.
 */

static void
tokenseed(TOKEN_CBlock *cb)
{
	cb->ul[0] = arc4random();
	cb->ul[1] = arc4random();
}

/*
 * Send a random challenge string to the token. The challenge
 * is always base 10 as there are no alpha keys on the keyboard.
 */

void
tokenchallenge(char *user, char *challenge, int size, char *card_type)
{
	TOKENDB_Rec tr;
	TOKEN_CBlock cb;
	DES_key_schedule ks;
	int r, c;

	r = 1;	/* no reduced input mode by default! */

	if ((tt->modes & TOKEN_RIM) &&
	    tokendb_getrec(user, &tr) == 0 &&
	    (tr.mode & TOKEN_RIM)) {
		c = 0;
		while ((r = tokendb_lockrec(user, &tr, TOKEN_LOCKED)) == 1) {
			if (c++ >= 60)
				break;
			sleep(1);
		}
		tr.flags &= ~TOKEN_LOCKED;
		if (r == 0 && tr.rim[0]) {
			h2cb(tr.secret, &cb);
			DES_fixup_key_parity(&cb.cb);
			DES_key_sched(&cb.cb, &ks);
			DES_ecb_encrypt(&tr.rim, &cb.cb, &ks, DES_ENCRYPT);
			memcpy(tr.rim, cb.cb, 8);
			for (r = 0; r < 8; ++r) {
				if ((tr.rim[r] &= 0xf) > 9)
					tr.rim[r] -= 10;
				tr.rim[r] |= 0x30;
			}
			r = 0;		/* reset it back */
			memcpy(tokennumber.ct, tr.rim, 8);
			tokennumber.ct[8] = 0;
			tokendb_putrec(user, &tr);
		}
	}
	if (r != 0 || tr.rim[0] == '\0') {
		memset(tokennumber.ct, 0, sizeof(tokennumber.ct));
		snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%8.8u",
		    arc4random());
		if (r == 0) {
			memcpy(tr.rim, tokennumber.ct, 8);
			tokendb_putrec(user, &tr);
		}
	}

	snprintf(challenge, size, "%s Challenge \"%s\"\r\n%s Response: ",
	    card_type, tokennumber.ct, card_type);
}

/*
 * Verify response from user against token's predicted cipher
 * of the random number challenge.
 */

int
tokenverify(char *username, char *challenge, char *response)
{
	char	*state;
	TOKENDB_Rec tokenrec;
	TOKEN_CBlock tmp;
	TOKEN_CBlock cmp_text;
	TOKEN_CBlock user_seed;
	TOKEN_CBlock cipher_text;
	DES_key_schedule key_schedule;


	memset(cmp_text.ct, 0, sizeof(cmp_text.ct));
	memset(user_seed.ct, 0, sizeof(user_seed.ct));
	memset(cipher_text.ct, 0, sizeof(cipher_text.ct));
	memset(tokennumber.ct, 0, sizeof(tokennumber.ct));

	(void)strtok(challenge, "\"");
	state = strtok(NULL, "\"");
	tmp.ul[0] = strtoul(state, NULL, 10);
	snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%8.8u",tmp.ul[0]);

	/*
	 * Retrieve the db record for the user. Nuke it as soon as
	 * we have translated out the user's shared secret just in
	 * case we (somehow) get core dumped...
	 */

	if (tokendb_getrec(username, &tokenrec))
		return (-1);

	h2cb(tokenrec.secret, &user_seed);
	explicit_bzero(&tokenrec.secret, sizeof(tokenrec.secret));

	if (!(tokenrec.flags & TOKEN_ENABLED))
		return (-1);

	/*
	 * Compute the anticipated response in hex. Nuke the user's
	 * shared secret asap.
	 */

	DES_fixup_key_parity(&user_seed.cb);
	DES_key_sched(&user_seed.cb, &key_schedule);
	explicit_bzero(user_seed.ct, sizeof(user_seed.ct));
	DES_ecb_encrypt(&tokennumber.cb, &cipher_text.cb, &key_schedule,
	    DES_ENCRYPT);
	explicit_bzero(&key_schedule, sizeof(key_schedule));

	/*
	 * The token thinks it's descended from VAXen.  Deal with i386
	 * endian-ness of binary cipher prior to generating ascii from first
	 * 32 bits.
	 */

	HTONL(cipher_text.ul[0]);
	snprintf(cmp_text.ct, sizeof(cmp_text.ct), "%8.8x", cipher_text.ul[0]);

	if (tokenrec.mode & TOKEN_PHONEMODE) {
		/*
		 * If we are a CRYPTOCard, we need to see if we are in
		 * "telephone number mode".  If so, transmogrify the fourth
		 * digit of the cipher.  Lower case response just in case
		 * it's * hex.  Compare hex cipher with anticipated response
		 * from token.
		 */

		lcase(response);

		if (response[3] == '-')
			cmp_text.ct[3] = '-';
	}

	if ((tokenrec.mode & TOKEN_HEXMODE) && !strcmp(response, cmp_text.ct))
		return (0);

	/*
	 * No match against the computed hex cipher.  The token could be
	 * in decimal mode.  Pervert the string to magic decimal equivalent.
	 */

	h2d(cmp_text.ct);

	if ((tokenrec.mode & TOKEN_DECMODE) && !strcmp(response, cmp_text.ct))
		return (0);

	return (-1);
}

/*
 * Initialize a new user record in the token database.
 */

int
tokenuserinit(int flags, char *username, unsigned char *usecret, unsigned mode)
{
	TOKENDB_Rec tokenrec;
	TOKEN_CBlock secret;
	TOKEN_CBlock nulls;
	TOKEN_CBlock checksum;
	TOKEN_CBlock checktxt;
	DES_key_schedule key_schedule;

	memset(&secret, 0, sizeof(secret));

	/*
	 * If no user secret passed in, create one
	 */

	if ( (flags & TOKEN_GENSECRET) )
		tokenseed(&secret);
	else
		memcpy(&secret, usecret, sizeof(DES_cblock));

	DES_fixup_key_parity(&secret.cb);

	/*
	 * Check if the db record already exists.  If there's no
	 * force-init flag and it exists, go away. Else,
	 * create the user's db record and put to the db.
	 */


	if (!(flags & TOKEN_FORCEINIT) &&
	    tokendb_getrec(username, &tokenrec) == 0)
		return (1);

	memset(&tokenrec, 0, sizeof(tokenrec));
	strlcpy(tokenrec.uname, username, sizeof(tokenrec.uname));
	cb2h(secret, tokenrec.secret);
	tokenrec.mode = 0;
	tokenrec.flags = TOKEN_ENABLED | TOKEN_USEMODES;
	tokenrec.mode = mode;
	memset(tokenrec.reserved_char1, 0, sizeof(tokenrec.reserved_char1));
	memset(tokenrec.reserved_char2, 0, sizeof(tokenrec.reserved_char2));

	if (tokendb_putrec(username, &tokenrec))
		return (-1);

	/*
	 * Check if the shared secret was generated here. If so, we
	 * need to inform the user about it in order that it can be
	 * programmed into the token. See tokenverify() (above) for
	 * discussion of cipher generation.
	 */

	if (!(flags & TOKEN_GENSECRET)) {
		explicit_bzero(&secret, sizeof(secret));
		return (0);
	}

	printf("Shared secret for %s\'s token: "
	    "%03o %03o %03o %03o %03o %03o %03o %03o\n",
	    username, secret.cb[0], secret.cb[1], secret.cb[2], secret.cb[3],
	    secret.cb[4], secret.cb[5], secret.cb[6], secret.cb[7]);

	DES_key_sched(&secret.cb, &key_schedule);
	explicit_bzero(&secret, sizeof(secret));
	memset(&nulls, 0, sizeof(nulls));
	DES_ecb_encrypt(&nulls.cb, &checksum.cb, &key_schedule, DES_ENCRYPT);
	explicit_bzero(&key_schedule, sizeof(key_schedule));
	HTONL(checksum.ul[0]);
	snprintf(checktxt.ct, sizeof(checktxt.ct), "%8.8x", checksum.ul[0]);
	printf("Hex Checksum: \"%s\"", checktxt.ct);

	h2d(checktxt.ct);
	printf("\tDecimal Checksum: \"%s\"\n", checktxt.ct);

	return (0);
}

/*
 * Magically transform a hex character string into a decimal character
 * string as defined by the token card vendor. The string should have
 * been lowercased by now.
 */

static	void
h2d(char *cp)
{
	int	i;

	for (i=0; i<sizeof(DES_cblock); i++, cp++) {
		if (*cp >= 'a' && *cp <= 'f')
			*cp = tt->map[*cp - 'a'];
	}
}

/*
 * Translate an hex 16 byte ascii representation of an unsigned
 * integer to a DES_cblock.
 */

static	void
h2cb(char *hp, TOKEN_CBlock *cb)
{
	char	scratch[9];

	strlcpy(scratch, hp, sizeof(scratch));
	cb->ul[0] = strtoul(scratch, NULL, 16);

	strlcpy(scratch, hp + 8, sizeof(scratch));
	cb->ul[1] = strtoul(scratch, NULL, 16);
}

/*
 * Translate a DES_cblock to an 16 byte ascii hex representation.
 */

static	void
cb2h(TOKEN_CBlock cb, char* hp)
{
	char	scratch[17];

	snprintf(scratch,   9, "%8.8x", cb.ul[0]);
	snprintf(scratch+8, 9, "%8.8x", cb.ul[1]);
	memcpy(hp, scratch, 16);
}

/*
 * Lowercase possible hex response
 */

static	void
lcase(char *cp)
{
	while (*cp) {
		if (isupper((unsigned char)*cp))
			*cp = tolower((unsigned char)*cp);
		cp++;
	}
}
@


1.18
log
@use LOGIN_NAME_MAX instead of L_cuserid, and adjust .h includes; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.17 2013/11/27 21:25:25 deraadt Exp $	*/
d192 1
a192 1
	memset(&tokenrec.secret, 0, sizeof(tokenrec.secret));
d204 1
a204 1
	memset(user_seed.ct, 0, sizeof(user_seed.ct));
d207 1
a207 1
	memset(&key_schedule, 0, sizeof(key_schedule));
d307 1
a307 1
		memset(&secret, 0, sizeof(secret));
d317 1
a317 1
	memset(&secret, 0, sizeof(secret));
d320 1
a320 1
	memset(&key_schedule, 0, sizeof(key_schedule));
@


1.17
log
@unsigned char for ctype
ok okan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.16 2013/08/22 04:43:40 guenther Exp $	*/
d49 1
@


1.16
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.15 2013/05/07 12:17:20 tedu Exp $	*/
d386 2
a387 2
		if (isupper(*cp))
			*cp = tolower(*cp);
@


1.15
log
@fixed size types should be fixed size. long -> uint32_t.
from Matthias Pitzl pitzl at genua de
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.14 2013/01/13 21:21:17 fgsch Exp $	*/
d179 1
a179 1
	snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%8.8lu",tmp.ul[0]);
d215 1
a215 1
	snprintf(cmp_text.ct, sizeof(cmp_text.ct), "%8.8lx", cipher_text.ul[0]);
d321 1
a321 1
	snprintf(checktxt.ct, sizeof(checktxt.ct), "%8.8lx", checksum.ul[0]);
d373 2
a374 2
	snprintf(scratch,   9, "%8.8lx", cb.ul[0]);
	snprintf(scratch+8, 9, "%8.8lx", cb.ul[1]);
@


1.14
log
@Fix warnings.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.13 2012/12/04 02:24:47 deraadt Exp $	*/
d66 1
a66 1
	unsigned long	ul[2];
@


1.13
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.12 2010/10/15 10:18:42 jsg Exp $	*/
d176 1
a176 1
	state = strtok(challenge, "\"");
d262 1
a262 1
	memset(&secret.ct, 0, sizeof(secret));
d306 1
a306 1
		memset(&secret.ct, 0, sizeof(secret));
d316 1
a316 1
	memset(&secret.ct, 0, sizeof(secret));
@


1.12
log
@Switch the remaining users of libdes in src to libcrypto,
telnet portion partially from the latest heimdal.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.11 2005/11/12 14:13:16 deraadt Exp $	*/
a42 1
#include <sys/param.h>
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.10 2005/05/26 23:04:09 avsm Exp $	*/
d53 1
a53 1
#include <des.h>
d65 1
a65 1
	des_cblock	cb;
d109 1
a109 1
	des_key_schedule ks;
d126 3
a128 3
			des_fixup_key_parity(&cb.cb);
			des_key_sched(&cb.cb, ks);
			des_ecb_encrypt(&tr.rim, &cb.cb, ks, DES_ENCRYPT);
d169 1
a169 1
	des_key_schedule key_schedule;
d202 2
a203 2
	des_fixup_key_parity(&user_seed.cb);
	des_key_sched(&user_seed.cb, key_schedule);
d205 1
a205 1
	des_ecb_encrypt(&tokennumber.cb, &cipher_text.cb, key_schedule,
d207 1
a207 1
	memset(key_schedule, 0, sizeof(key_schedule));
d261 1
a261 1
	des_key_schedule key_schedule;
d272 1
a272 1
		memcpy(&secret, usecret, sizeof(des_cblock));
d274 1
a274 1
	des_fixup_key_parity(&secret.cb);
d316 1
a316 1
	des_key_sched(&secret.cb, key_schedule);
d319 2
a320 2
	des_ecb_encrypt(&nulls.cb, &checksum.cb, key_schedule, DES_ENCRYPT);
	memset(key_schedule, 0, sizeof(key_schedule));
d342 1
a342 1
	for (i=0; i<sizeof(des_cblock); i++, cp++) {
d350 1
a350 1
 * integer to a des_cblock.
d366 1
a366 1
 * Translate a des_cblock to an 16 byte ascii hex representation.
@


1.10
log
@memset to 0, not '0'; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.9 2003/02/20 17:32:28 millert Exp $	*/
d144 1
a144 1
				arc4random());
d152 1
a152 1
			card_type, tokennumber.ct, card_type);
@


1.9
log
@remove useless cast in memset()
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.8 2002/07/16 12:38:40 jufi Exp $	*/
d293 2
a294 2
	memset(tokenrec.reserved_char1, '0', sizeof(tokenrec.reserved_char1));
	memset(tokenrec.reserved_char2, '0', sizeof(tokenrec.reserved_char2));
@


1.8
log
@
typos / double words
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.7 2002/06/28 01:14:37 deraadt Exp $	*/
d192 1
a192 1
	memset((char*)&tokenrec.secret, 0, sizeof(tokenrec.secret));
@


1.7
log
@minor indent cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.6 2001/08/18 18:31:21 deraadt Exp $	*/
d277 1
a277 1
	 * Check if the db record already exists.  If no
@


1.6
log
@strlcpy invades the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.5 2001/06/28 21:18:45 millert Exp $	*/
d118 1
a118 1
        	while ((r = tokendb_lockrec(user, &tr, TOKEN_LOCKED)) == 1) {
d121 1
a121 1
                	sleep(1);
d127 1
a127 1
        		des_key_sched(&cb.cb, ks);
d314 1
a314 2
	    secret.cb[4], secret.cb[5], secret.cb[6], secret.cb[7]); 

@


1.5
log
@Remove tokenrandomnumber(), call arc4random() directly; markus@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.4 2000/12/20 20:08:23 markus Exp $	*/
d288 1
a288 1
	strncpy(tokenrec.uname, username, sizeof(tokenrec.uname));
@


1.4
log
@use arc4random, clear secrets, use readpassphrase in tokeninit; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.3 2000/12/20 01:54:42 millert Exp $	*/
a80 1
static	long	tokenrandomnumber(void);
a99 15
 * Generate a random key of eight decimal digits. Actually,
 * with the CRYPTOCard, this could be up to 64 digits.
 * This string must be zero filled
 * and padded to a 64-bit boundary with a trailing null byte.
 * It could also be hex, but decimal is easier for the user
 * to enter into the token.
 */

static long
tokenrandomnumber(void)
{
	return arc4random();
}

/*
d143 2
a144 2
		snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%8.8lu",
				tokenrandomnumber());
@


1.3
log
@Fix a warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.2 2000/12/20 01:52:12 millert Exp $	*/
d82 1
a82 1
static	void	tokenseed(des_cblock *);
d94 1
a94 1
tokenseed(des_cblock *cb)
d96 2
a97 8
	static int first_time = 1;

	if (first_time) {
		first_time = 0;
		des_random_key(*cb);
		des_init_random_number_generator(cb);
	}
	des_new_random_key(cb);
d112 1
a112 4
	TOKEN_CBlock seed;

	tokenseed(&seed.cb);
	return (((seed.ul[0] ^ seed.ul[1]) % 99999999));
d158 2
a159 2
		memset(tokennumber.ct, 0, sizeof(tokennumber));
		snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%08.8lu",
d188 4
a191 4
	memset(cmp_text.ct, 0, sizeof(cmp_text));
	memset(user_seed.ct, 0, sizeof(user_seed));
	memset(cipher_text.ct, 0, sizeof(cipher_text));
	memset(tokennumber.ct, 0, sizeof(tokennumber));
d196 1
a196 1
	snprintf(tokennumber.ct, sizeof(tokennumber.ct), "%08.8lu",tmp.ul[0]);
d223 1
d232 1
a232 1
	snprintf(cmp_text.ct, sizeof(cmp_text.ct), "%08.8lx", cipher_text.ul[0]);
d279 2
d286 2
a287 3
		tokenseed(&secret.cb);
	else {
		memset(&secret, 0, sizeof(secret));
d289 2
a290 2
		des_fixup_key_parity(&secret.cb);
	}
d322 2
a323 1
	if (!(flags & TOKEN_GENSECRET))
d325 1
d334 1
d337 1
d339 1
a339 1
	snprintf(checktxt.ct, sizeof(checktxt.ct), "%08.8lx", checksum.ul[0]);
d391 2
a392 2
	snprintf(scratch,   9, "%08.8lx", cb.ul[0]);
	snprintf(scratch+8, 9, "%08.8lx", cb.ul[1]);
@


1.2
log
@correct copyright notice
@
text
@d1 1
a1 1
/*	$OpenBSD: token.c,v 1.1 2000/12/20 01:41:53 millert Exp $	*/
d82 1
a82 1
static	void	tokenseed(des_cblock);
d94 1
a94 1
tokenseed(des_cblock cb)
d100 1
a100 1
		des_random_key(cb);
d120 1
a120 1
	tokenseed(seed.cb);
d292 1
a292 1
		tokenseed(secret.cb);
@


1.1
log
@Provides ActivCard, CRYPTOCard and SNK-004 authentication from BSDi
Will be used when BSD authentication is enabled
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1995 Berkeley Software Design, Inc. All rights reserved.
@

