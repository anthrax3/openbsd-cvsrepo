head	1.42;
access;
symbols
	OPENBSD_3_8:1.41.0.4
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17;
locks; strict;
comment	@ * @;


1.42
date	2005.11.24.17.12.50;	author deraadt;	state dead;
branches;
next	1.41;

1.41
date	2005.03.05.23.11.19;	author cloder;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.24.15.49.08;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.19.20.58.59;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.19.00.47.23;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.11.01.54.36;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.06.19.49.11;	author dhartmei;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.14.21.51.44;	author dhartmei;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.22.16.10.30;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.29.14.46.06;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.28.01.04.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.23.17.22.29;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.20.01.34.48;	author david;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.23.23.15.16;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.19.18.19.10;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.19.01.29.03;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.19.01.27.56;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.07.08.54.50;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.03.23.39.03;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.01.03.12;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.23.10.22.14;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.12.08.01.51;	author dhartmei;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.10.19.35.07;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.14.18.12.41;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.10.15.32.39;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.21.18.06.25;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.05.20.40.10;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.28.19.57.29;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.28.19.35.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.22.05.28.16;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.19.20.43.56;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.19.18.24.13;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.19.17.33.12;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.19.17.20.34;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.19.15.37.01;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.19.15.19.28;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.19.15.02.02;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.19.13.43.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.19.05.50.50;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.05.22.37;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.04.11.12;	author beck;	state Exp;
branches;
next	;


desc
@@


1.42
log
@code is not being used; toss into Attic
@
text
@/*	$OpenBSD: ftp-proxy.c,v 1.41 2005/03/05 23:11:19 cloder Exp $ */

/*
 * Copyright (c) 1996-2001
 *	Obtuse Systems Corporation.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Obtuse Systems nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY OBTUSE SYSTEMS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL OBTUSE SYSTEMS CORPORATION OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * ftp proxy, Originally based on juniper_ftp_proxy from the Obtuse
 * Systems juniper firewall, written by Dan Boulet <danny@@obtuse.com>
 * and Bob Beck <beck@@obtuse.com>
 *
 * This version basically passes everything through unchanged except
 * for the PORT and the * "227 Entering Passive Mode" reply.
 *
 * A PORT command is handled by noting the IP address and port number
 * specified and then configuring a listen port on some very high port
 * number and telling the server about it using a PORT message.
 * We then watch for an in-bound connection on the port from the server
 * and connect to the client's port when it happens.
 *
 * A "227 Entering Passive Mode" reply is handled by noting the IP address
 * and port number specified and then configuring a listen port on some
 * very high port number and telling the client about it using a
 * "227 Entering Passive Mode" reply.
 * We then watch for an in-bound connection on the port from the client
 * and connect to the server's port when it happens.
 *
 * supports tcp wrapper lookups/access control with the -w flag using
 * the real destination address - the tcp wrapper stuff is done after
 * the real destination address is retrieved from pf
 *
 */

/*
 * TODO:
 * Plenty, this is very basic, with the idea to get it in clean first.
 *
 * - IPv6 and EPASV support
 * - Content filter support
 * - filename filter support
 * - per-user rules perhaps.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>

#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <syslog.h>
#include <unistd.h>

#include "util.h"

#ifdef LIBWRAP
#include <tcpd.h>
int allow_severity = LOG_INFO;
int deny_severity = LOG_NOTICE;
#endif /* LIBWRAP */

int min_port = IPPORT_HIFIRSTAUTO;
int max_port = IPPORT_HILASTAUTO;

#define STARTBUFSIZE  1024	/* Must be at least 3 */

/*
 * Variables used to support PORT mode connections.
 *
 * This gets a bit complicated.
 *
 * If PORT mode is on then client_listen_sa describes the socket that
 * the real client is listening on and server_listen_sa describes the
 * socket that we are listening on (waiting for the real server to connect
 * with us).
 *
 * If PASV mode is on then client_listen_sa describes the socket that
 * we are listening on (waiting for the real client to connect to us on)
 * and server_listen_sa describes the socket that the real server is
 * listening on.
 *
 * If the socket we are listening on gets a connection then we connect
 * to the other side's socket.  Similarly, if a connected socket is
 * shutdown then we shutdown the other side's socket.
 */

double xfer_start_time;

struct sockaddr_in real_server_sa;
struct sockaddr_in client_listen_sa;
struct sockaddr_in server_listen_sa;
struct sockaddr_in proxy_sa;
struct in_addr src_addr;

int client_listen_socket = -1;	/* Only used in PASV mode */
int client_data_socket = -1;	/* Connected socket to real client */
int server_listen_socket = -1;	/* Only used in PORT mode */
int server_data_socket = -1;	/* Connected socket to real server */
int client_data_bytes, server_data_bytes;

int AnonFtpOnly;
int Verbose;
int NatMode;
int ReverseMode;

char ClientName[NI_MAXHOST];
char RealServerName[NI_MAXHOST];
char OurName[NI_MAXHOST];

const char *User = "proxy";
const char *Group;

extern int Debug_Level;
extern int Use_Rdns;
extern in_addr_t Bind_Addr;
extern char *__progname;

typedef enum {
	UNKNOWN_MODE,
	PORT_MODE,
	PASV_MODE,
	EPRT_MODE,
	EPSV_MODE
} connection_mode_t;

connection_mode_t connection_mode;

extern void	debuglog(int debug_level, const char *fmt, ...);
double		wallclock_time(void);
void		show_xfer_stats(void);
void		log_control_command (char *cmd, int client);
int		new_dataconn(int server);
void		do_client_cmd(struct csiob *client, struct csiob *server);
void		do_server_reply(struct csiob *server, struct csiob *client);
static void
usage(void)
{
	syslog(LOG_NOTICE,
	    "usage: %s [-AnrVw] [-a address] [-D debuglevel] [-g group]"
	    " [-M maxport] [-m minport] [-R address[:port]] [-S address]"
	    " [-t timeout] [-u user]", __progname);
	exit(EX_USAGE);
}

static void
close_client_data(void)
{
	if (client_data_socket >= 0) {
		shutdown(client_data_socket, 2);
		close(client_data_socket);
		client_data_socket = -1;
	}
}

static void
close_server_data(void)
{
	if (server_data_socket >= 0)  {
		shutdown(server_data_socket, 2);
		close(server_data_socket);
		server_data_socket = -1;
	}
}

static void
drop_privs(void)
{
	struct passwd *pw;
	struct group *gr;
	uid_t uid = 0;
	gid_t gid = 0;

	if (User != NULL) {
		pw = getpwnam(User);
		if (pw == NULL) {
			syslog(LOG_ERR, "cannot find user %s", User);
			exit(EX_USAGE);
		}
		uid = pw->pw_uid;
		gid = pw->pw_gid;
	}

	if (Group != NULL) {
		gr = getgrnam(Group);
		if (gr == NULL) {
			syslog(LOG_ERR, "cannot find group %s", Group);
			exit(EX_USAGE);
		}
		gid = gr->gr_gid;
	}

	if (gid != 0 && (setegid(gid) == -1 || setgid(gid) == -1)) {
		syslog(LOG_ERR, "cannot drop group privs (%m)");
		exit(EX_CONFIG);
	}

	if (uid != 0 && (seteuid(uid) == -1 || setuid(uid) == -1)) {
		syslog(LOG_ERR, "cannot drop root privs (%m)");
		exit(EX_CONFIG);
	}
}

#ifdef LIBWRAP
/*
 * Check a connection against the tcpwrapper, log if we're going to
 * reject it, returns: 0 -> reject, 1 -> accept. We add in hostnames
 * if we are set to do reverse DNS, otherwise no.
 */
static int
check_host(struct sockaddr_in *client_sin, struct sockaddr_in *server_sin)
{
	char cname[NI_MAXHOST];
	char sname[NI_MAXHOST];
	struct request_info request;
	int i;

	request_init(&request, RQ_DAEMON, __progname, RQ_CLIENT_SIN,
	    client_sin, RQ_SERVER_SIN, server_sin, RQ_CLIENT_ADDR,
	    inet_ntoa(client_sin->sin_addr), 0);

	if (Use_Rdns)  {
		/*
		 * We already looked these up, but we have to do it again
		 * for tcp wrapper, to ensure that we get the DNS name, since
		 * the tcp wrapper cares about these things, and we don't
		 * want to pass in a printed address as a name.
		 */
		i = getnameinfo((struct sockaddr *) &client_sin->sin_addr,
		    sizeof(&client_sin->sin_addr), cname, sizeof(cname),
		    NULL, 0, NI_NAMEREQD);

		if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN)
			strlcpy(cname, STRING_UNKNOWN, sizeof(cname));

		i = getnameinfo((struct sockaddr *)&server_sin->sin_addr,
		    sizeof(&server_sin->sin_addr), sname, sizeof(sname),
		    NULL, 0, NI_NAMEREQD);

		if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN)
			strlcpy(sname, STRING_UNKNOWN, sizeof(sname));
	} else {
		/*
		 * ensure the TCP wrapper doesn't start doing
		 * reverse DNS lookups if we aren't supposed to.
		 */
		strlcpy(cname, STRING_UNKNOWN, sizeof(cname));
		strlcpy(sname, STRING_UNKNOWN, sizeof(sname));
	}

	request_set(&request, RQ_SERVER_ADDR, inet_ntoa(server_sin->sin_addr),
	    0);
	request_set(&request, RQ_CLIENT_NAME, cname, RQ_SERVER_NAME, sname, 0);

	if (!hosts_access(&request)) {
		syslog(LOG_NOTICE, "tcpwrappers rejected: %s -> %s",
		    ClientName, RealServerName);
		return(0);
	}
	return(1);
}
#endif /* LIBWRAP */

double
wallclock_time(void)
{
	struct timeval tv;

	gettimeofday(&tv, NULL);
	return(tv.tv_sec + tv.tv_usec / 1e6);
}

/*
 * Show the stats for this data transfer
 */
void
show_xfer_stats(void)
{
	char tbuf[1000];
	double delta;
	size_t len;
	int i = -1;

	if (!Verbose)
		return;

	delta = wallclock_time() - xfer_start_time;

	if (delta < 0.001)
		delta = 0.001;

	if (client_data_bytes == 0 && server_data_bytes == 0) {
		syslog(LOG_INFO,
		  "data transfer complete (no bytes transferred)");
		return;
	}

	len = sizeof(tbuf);

	if (delta >= 60) {
		int idelta;

		idelta = delta + 0.5;
		if (idelta >= 60*60) {
			i = snprintf(tbuf, len,
			    "data transfer complete (%dh %dm %ds",
			    idelta / (60*60), (idelta % (60*60)) / 60,
			    idelta % 60);
			if (i == -1 || i >= len)
				goto logit;
			len -= i;
		} else {
			i = snprintf(tbuf, len,
			    "data transfer complete (%dm %ds", idelta / 60,
			    idelta % 60);
			if (i == -1 || i >= len)
				goto logit;
			len -= i;
		}
	} else {
		i = snprintf(tbuf, len, "data transfer complete (%.1fs",
		    delta);
		if (i == -1 || i >= len)
			goto logit;
		len -= i;
	}

	if (client_data_bytes > 0) {
		i = snprintf(&tbuf[strlen(tbuf)], len,
		    ", %d bytes to server) (%.1fKB/s", client_data_bytes,
		    (client_data_bytes / delta) / (double)1024);
		if (i == -1 || i >= len)
			goto logit;
		len -= i;
	}
	if (server_data_bytes > 0) {
		i = snprintf(&tbuf[strlen(tbuf)], len,
		    ", %d bytes to client) (%.1fKB/s", server_data_bytes,
		    (server_data_bytes / delta) / (double)1024);
		if (i == -1 || i >= len)
			goto logit;
		len -= i;
	}
	strlcat(tbuf, ")", sizeof(tbuf));
 logit:
	if (i != -1)
		syslog(LOG_INFO, "%s", tbuf);
}

void
log_control_command (char *cmd, int client)
{
	/* log an ftp control command or reply */
	const char *logstring;
	int level = LOG_DEBUG;

	if (!Verbose)
		return;

	/* don't log passwords */
	if (strncasecmp(cmd, "pass ", 5) == 0)
		logstring = "PASS XXXX";
	else
		logstring = cmd;
	if (client) {
		/* log interesting stuff at LOG_INFO, rest at LOG_DEBUG */
		if ((strncasecmp(cmd, "user ", 5) == 0) ||
		    (strncasecmp(cmd, "retr ", 5) == 0) ||
		    (strncasecmp(cmd, "cwd ", 4) == 0) ||
		    (strncasecmp(cmd, "stor " ,5) == 0))
			level = LOG_INFO;
	}
	syslog(level, "%s %s", client ? "client:" : " server:",
	    logstring);
}

/*
 * set ourselves up for a new data connection. Direction is toward client if
 * "server" is 0, towards server otherwise.
 */
int
new_dataconn(int server)
{
	/*
	 * Close existing data conn.
	 */

	if (client_listen_socket != -1) {
		close(client_listen_socket);
		client_listen_socket = -1;
	}
	close_client_data();

	if (server_listen_socket != -1) {
		close(server_listen_socket);
		server_listen_socket = -1;
	}
	close_server_data();

	if (server) {
		bzero(&server_listen_sa, sizeof(server_listen_sa));
		server_listen_socket = get_backchannel_socket(SOCK_STREAM,
		    min_port, max_port, -1, 1, &server_listen_sa);

		if (server_listen_socket == -1) {
			syslog(LOG_INFO, "server socket bind() failed (%m)");
			exit(EX_OSERR);
		}
		if (listen(server_listen_socket, 5) != 0) {
			syslog(LOG_INFO, "server socket listen() failed (%m)");
			exit(EX_OSERR);
		}
	} else {
		bzero(&client_listen_sa, sizeof(client_listen_sa));
		client_listen_socket = get_backchannel_socket(SOCK_STREAM,
		    min_port, max_port, -1, 1, &client_listen_sa);

		if (client_listen_socket == -1) {
			syslog(LOG_NOTICE,
			    "cannot get client listen socket (%m)");
			exit(EX_OSERR);
		}
		if (listen(client_listen_socket, 5) != 0) {
			syslog(LOG_NOTICE,
			    "cannot listen on client socket (%m)");
			exit(EX_OSERR);
		}
	}
	return(0);
}

static void
connect_pasv_backchannel(void)
{
	struct sockaddr_in listen_sa;
	socklen_t salen;

	/*
	 * We are about to accept a connection from the client.
	 * This is a PASV data connection.
	 */
	debuglog(2, "client listen socket ready");

	close_server_data();
	close_client_data();

	salen = sizeof(listen_sa);
	client_data_socket = accept(client_listen_socket,
	    (struct sockaddr *)&listen_sa, &salen);

	if (client_data_socket < 0) {
		syslog(LOG_NOTICE, "accept() failed (%m)");
		exit(EX_OSERR);
	}
	close(client_listen_socket);
	client_listen_socket = -1;
	memset(&listen_sa, 0, sizeof(listen_sa));

	server_data_socket = get_backchannel_socket(SOCK_STREAM, min_port,
	    max_port, -1, 1, &listen_sa);
	if (server_data_socket < 0) {
		syslog(LOG_NOTICE, "get_backchannel_socket() failed (%m)");
		exit(EX_OSERR);
	}
	if (connect(server_data_socket, (struct sockaddr *) &server_listen_sa,
	    sizeof(server_listen_sa)) != 0) {
		syslog(LOG_NOTICE, "connect() failed (%m)");
		exit(EX_NOHOST);
	}
	client_data_bytes = 0;
	server_data_bytes = 0;
	xfer_start_time = wallclock_time();
}

static void
connect_port_backchannel(void)
{
	struct sockaddr_in listen_sa;
	socklen_t salen;

	/*
	 * We are about to accept a connection from the server.
	 * This is a PORT or EPRT data connection.
	 */
	debuglog(2, "server listen socket ready");

	close_server_data();
	close_client_data();

	salen = sizeof(listen_sa);
	server_data_socket = accept(server_listen_socket,
	    (struct sockaddr *)&listen_sa, &salen);
	if (server_data_socket < 0) {
		syslog(LOG_NOTICE, "accept() failed (%m)");
		exit(EX_OSERR);
	}
	close(server_listen_socket);
	server_listen_socket = -1;

	if (getuid() != 0)  {
		/*
		 * We're not running as root, so we get a backchannel
		 * socket bound in our designated range, instead of
		 * getting one bound to port 20 - This is deliberately
		 * not RFC compliant.
		 */
		bcopy(&src_addr, &listen_sa.sin_addr, sizeof(struct in_addr));
		client_data_socket =  get_backchannel_socket(SOCK_STREAM,
		    min_port, max_port, -1, 1, &listen_sa);
		if (client_data_socket < 0) {
			syslog(LOG_NOTICE,  "get_backchannel_socket() failed (%m)");
			exit(EX_OSERR);
		}

	} else {

		/*
		 * We're root, get our backchannel socket bound to port
		 * 20 here, so we're fully RFC compliant.
		 */
		client_data_socket = socket(AF_INET, SOCK_STREAM, 0);

		salen = 1;
		listen_sa.sin_family = AF_INET;
		bcopy(&src_addr, &listen_sa.sin_addr, sizeof(struct in_addr));
		listen_sa.sin_port = htons(20);

		if (setsockopt(client_data_socket, SOL_SOCKET, SO_REUSEADDR,
		    &salen, sizeof(salen)) == -1) {
			syslog(LOG_NOTICE, "setsockopt() failed (%m)");
			exit(EX_OSERR);
		}

		if (bind(client_data_socket, (struct sockaddr *)&listen_sa,
		    sizeof(listen_sa)) == - 1) {
			syslog(LOG_NOTICE, "data channel bind() failed (%m)");
			exit(EX_OSERR);
		}
	}

	if (connect(client_data_socket, (struct sockaddr *) &client_listen_sa,
	    sizeof(client_listen_sa)) != 0) {
		syslog(LOG_INFO, "cannot connect data channel (%m)");
		exit(EX_NOHOST);
	}

	client_data_bytes = 0;
	server_data_bytes = 0;
	xfer_start_time = wallclock_time();
}

void
do_client_cmd(struct csiob *client, struct csiob *server)
{
	int i, j, rv;
	char tbuf[100];
	char *sendbuf = NULL;

	log_control_command((char *)client->line_buffer, 1);

	/* client->line_buffer is an ftp control command.
	 * There is no reason for these to be very long.
	 * In the interest of limiting buffer overrun attempts,
	 * we catch them here.
	 */
	if (strlen((char *)client->line_buffer) > 512) {
		syslog(LOG_NOTICE, "excessively long control command");
		exit(EX_DATAERR);
	}

	/*
	 * Check the client user provided if needed
	 */
	if (AnonFtpOnly && strncasecmp((char *)client->line_buffer, "user ",
	    strlen("user ")) == 0) {
		char *cp;

		cp = (char *) client->line_buffer + strlen("user ");
		if ((strcasecmp(cp, "ftp\r\n") != 0) &&
		    (strcasecmp(cp, "anonymous\r\n") != 0)) {
			/*
			 * this isn't anonymous - give the client an
			 * error before they send a password
			 */
			snprintf(tbuf, sizeof(tbuf),
			    "500 Only anonymous FTP is allowed\r\n");
			j = 0;
			i = strlen(tbuf);
			do {
				rv = send(client->fd, tbuf + j, i - j, 0);
				if (rv == -1 && errno != EAGAIN &&
				    errno != EINTR)
					break;
				else if (rv != -1)
					j += rv;
			} while (j >= 0 && j < i);
			sendbuf = NULL;
		} else
			sendbuf = (char *)client->line_buffer;
	} else if ((strncasecmp((char *)client->line_buffer, "eprt ",
	    strlen("eprt ")) == 0)) {

		/* Watch out for EPRT commands */
		char *line = NULL,  *q, *p, *result[3], delim;
		struct addrinfo hints, *res = NULL;
		unsigned long proto;

		j = 0;
		line = strdup((char *)client->line_buffer+strlen("eprt "));
		if (line == NULL) {
			syslog(LOG_ERR, "insufficient memory");
			exit(EX_UNAVAILABLE);
		}
		p = line;
		delim = p[0];
		p++;

		memset(result,0, sizeof(result));
		for (i = 0; i < 3; i++) {
			q = strchr(p, delim);
			if (!q || *q != delim)
				goto parsefail;
			*q++ = '\0';
			result[i] = p;
			p = q;
		}

		proto = strtoul(result[0], &p, 10);
		if (!*result[0] || *p)
			goto protounsupp;

		memset(&hints, 0, sizeof(hints));
		if (proto != 1) /* 1 == AF_INET - all we support for now */
			goto protounsupp;
		hints.ai_family = AF_INET;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = AI_NUMERICHOST;	/*no DNS*/
		if (getaddrinfo(result[1], result[2], &hints, &res))
			goto parsefail;
		if (res->ai_next)
			goto parsefail;
		if (sizeof(client_listen_sa) < res->ai_addrlen)
			goto parsefail;
		memcpy(&client_listen_sa, res->ai_addr, res->ai_addrlen);

		debuglog(1, "client wants us to use %s:%u",
		    inet_ntoa(client_listen_sa.sin_addr),
		    htons(client_listen_sa.sin_port));

		/*
		 * Configure our own listen socket and tell the server about it
		 */
		new_dataconn(1);
		connection_mode = EPRT_MODE;

		debuglog(1, "we want server to use %s:%u",
		    inet_ntoa(server->sa.sin_addr),
		    ntohs(server_listen_sa.sin_port));

		snprintf(tbuf, sizeof(tbuf), "EPRT |%d|%s|%u|\r\n", 1,
		    inet_ntoa(server->sa.sin_addr),
		    ntohs(server_listen_sa.sin_port));
		debuglog(1, "to server (modified): %s", tbuf);
		sendbuf = tbuf;
		goto out;
parsefail:
		snprintf(tbuf, sizeof(tbuf),
		    "500 Invalid argument; rejected\r\n");
		sendbuf = NULL;
		goto out;
protounsupp:
		/* we only support AF_INET for now */
		if (proto == 2)
			snprintf(tbuf, sizeof(tbuf),
			    "522 Protocol not supported, use (1)\r\n");
		else
			snprintf(tbuf, sizeof(tbuf),
			    "501 Protocol not supported\r\n");
		sendbuf = NULL;
out:
		if (line)
			free(line);
		if (res)
			freeaddrinfo(res);
		if (sendbuf == NULL) {
			debuglog(1, "to client (modified): %s", tbuf);
			i = strlen(tbuf);
			do {
				rv = send(client->fd, tbuf + j, i - j, 0);
				if (rv == -1 && errno != EAGAIN &&
				    errno != EINTR)
					break;
				else if (rv != -1)
					j += rv;
			} while (j >= 0 && j < i);
		}
	} else if (!NatMode && (strncasecmp((char *)client->line_buffer,
	    "epsv", strlen("epsv")) == 0)) {

		/*
		 * If we aren't in NAT mode, deal with EPSV.
		 * EPSV is a problem - Unlike PASV, the reply from the
		 * server contains *only* a port, we can't modify the reply
		 * to the client and get the client to connect to us without
		 * resorting to using a dynamic rdr rule we have to add in
		 * for the reply to this connection, and take away afterwards.
		 * so this will wait until we have the right solution for rule
		 * additions/deletions in pf.
		 *
		 * in the meantime we just tell the client we don't do it,
		 * and most clients should fall back to using PASV.
		 */

		snprintf(tbuf, sizeof(tbuf),
		    "500 EPSV command not understood\r\n");
		debuglog(1, "to client (modified): %s", tbuf);
		j = 0;
		i = strlen(tbuf);
		do {
			rv = send(client->fd, tbuf + j, i - j, 0);
			if (rv == -1 && errno != EAGAIN && errno != EINTR)
				break;
			else if (rv != -1)
				j += rv;
		} while (j >= 0 && j < i);
		sendbuf = NULL;
	} else if (strncasecmp((char *)client->line_buffer, "port ",
	    strlen("port ")) == 0) {
		unsigned int values[6];
		char *tailptr;

		debuglog(1, "Got a PORT command");

		tailptr = (char *)&client->line_buffer[strlen("port ")];
		values[0] = 0;

		i = sscanf(tailptr, "%u,%u,%u,%u,%u,%u", &values[0],
		    &values[1], &values[2], &values[3], &values[4],
		    &values[5]);
		if (i != 6) {
			syslog(LOG_INFO, "malformed PORT command (%s)",
			    client->line_buffer);
			exit(EX_DATAERR);
		}

		for (i = 0; i<6; i++) {
			if (values[i] > 255) {
				syslog(LOG_INFO,
				    "malformed PORT command (%s)",
				    client->line_buffer);
				exit(EX_DATAERR);
			}
		}

		client_listen_sa.sin_family = AF_INET;
		client_listen_sa.sin_addr.s_addr = htonl((values[0] << 24) |
		    (values[1] << 16) | (values[2] <<  8) |
		    (values[3] <<  0));

		client_listen_sa.sin_port = htons((values[4] << 8) |
		    values[5]);
		debuglog(1, "client wants us to use %u.%u.%u.%u:%u",
		    values[0], values[1], values[2], values[3],
		    (values[4] << 8) | values[5]);

		/*
		 * Configure our own listen socket and tell the server about it
		 */
		new_dataconn(1);
		connection_mode = PORT_MODE;

		debuglog(1, "we want server to use %s:%u",
		    inet_ntoa(server->sa.sin_addr),
		    ntohs(server_listen_sa.sin_port));

		snprintf(tbuf, sizeof(tbuf), "PORT %u,%u,%u,%u,%u,%u\r\n",
		    ((u_char *)&server->sa.sin_addr.s_addr)[0],
		    ((u_char *)&server->sa.sin_addr.s_addr)[1],
		    ((u_char *)&server->sa.sin_addr.s_addr)[2],
		    ((u_char *)&server->sa.sin_addr.s_addr)[3],
		    ((u_char *)&server_listen_sa.sin_port)[0],
		    ((u_char *)&server_listen_sa.sin_port)[1]);

		debuglog(1, "to server (modified): %s", tbuf);

		sendbuf = tbuf;
	} else
		sendbuf = (char *)client->line_buffer;

	/*
	 *send our (possibly modified) control command in sendbuf
	 * on it's way to the server
	 */
	if (sendbuf != NULL) {
		j = 0;
		i = strlen(sendbuf);
		do {
			rv = send(server->fd, sendbuf + j, i - j, 0);
			if (rv == -1 && errno != EAGAIN && errno != EINTR)
				break;
			else if (rv != -1)
				j += rv;
		} while (j >= 0 && j < i);
	}
}

void
do_server_reply(struct csiob *server, struct csiob *client)
{
	int code, i, j, rv;
	struct in_addr *iap;
	static int continuing = 0;
	char tbuf[100], *sendbuf, *p;

	log_control_command((char *)server->line_buffer, 0);

	if (strlen((char *)server->line_buffer) > 512) {
		/*
		 * someone's playing games. Have a cow in the syslogs and
		 * exit - we don't pass this on for fear of hurting
		 * our other end, which might be poorly implemented.
		 */
		syslog(LOG_NOTICE, "long FTP control reply");
		exit(EX_DATAERR);
	}

	/*
	 * Watch out for "227 Entering Passive Mode ..." replies
	 */
	code = strtol((char *)server->line_buffer, &p, 10);
	if (isspace(server->line_buffer[0]))
		code = 0;
	if (!*(server->line_buffer) || (*p != ' ' && *p != '-')) {
		if (continuing)
			goto sendit;
		syslog(LOG_INFO, "malformed control reply");
		exit(EX_DATAERR);
	}
	if (code <= 0 || code > 999) {
		if (continuing)
			goto sendit;
		syslog(LOG_INFO, "invalid server reply code %d", code);
		exit(EX_DATAERR);
	}
	if (*p == '-')
		continuing = 1;
	else
		continuing = 0;
	if (code == 227 && !NatMode) {
		unsigned int values[6];
		char *tailptr;

		debuglog(1, "Got a PASV reply");
		debuglog(1, "{%s}", (char *)server->line_buffer);

		tailptr = (char *)strchr((char *)server->line_buffer, '(');
		if (tailptr == NULL) {
			tailptr = strrchr((char *)server->line_buffer, ' ');
			if (tailptr == NULL) {
				syslog(LOG_NOTICE, "malformed 227 reply");
				exit(EX_DATAERR);
			}
		}
		tailptr++; /* skip past space or ( */

		values[0] = 0;

		i = sscanf(tailptr, "%u,%u,%u,%u,%u,%u", &values[0],
		    &values[1], &values[2], &values[3], &values[4],
		    &values[5]);
		if (i != 6) {
			syslog(LOG_INFO, "malformed PASV reply (%s)",
			    client->line_buffer);
			exit(EX_DATAERR);
		}
		for (i = 0; i<6; i++)
			if (values[i] > 255) {
				syslog(LOG_INFO, "malformed PASV reply(%s)",
				    client->line_buffer);
				exit(EX_DATAERR);
			}

		server_listen_sa.sin_family = AF_INET;
		server_listen_sa.sin_addr.s_addr = htonl((values[0] << 24) |
		    (values[1] << 16) | (values[2] <<  8) | (values[3] <<  0));
		server_listen_sa.sin_port = htons((values[4] << 8) |
		    values[5]);

		debuglog(1, "server wants us to use %s:%u",
		    inet_ntoa(server_listen_sa.sin_addr), (values[4] << 8) |
		    values[5]);

		new_dataconn(0);
		connection_mode = PASV_MODE;
		if (ReverseMode)
			iap = &(proxy_sa.sin_addr);
		else
			iap = &(server->sa.sin_addr);

		debuglog(1, "we want client to use %s:%u", inet_ntoa(*iap),
		    htons(client_listen_sa.sin_port));

		snprintf(tbuf, sizeof(tbuf),
		    "227 Entering Passive Mode (%u,%u,%u,%u,%u,%u)\r\n",
		    ((u_char *)iap)[0], ((u_char *)iap)[1],
		    ((u_char *)iap)[2], ((u_char *)iap)[3],
		    ((u_char *)&client_listen_sa.sin_port)[0],
		    ((u_char *)&client_listen_sa.sin_port)[1]);
		debuglog(1, "to client (modified): %s", tbuf);
		sendbuf = tbuf;
	} else {
 sendit:
		sendbuf = (char *)server->line_buffer;
	}

	/*
	 * send our (possibly modified) control command in sendbuf
	 * on it's way to the client
	 */
	j = 0;
	i = strlen(sendbuf);
	do {
		rv = send(client->fd, sendbuf + j, i - j, 0);
		if (rv == -1 && errno != EAGAIN && errno != EINTR)
			break;
		else if (rv != -1)
			j += rv;
	} while (j >= 0 && j < i);

}

int
main(int argc, char *argv[])
{
	struct csiob client_iob, server_iob;
	struct sigaction new_sa, old_sa;
	int sval, ch, flags, i;
	socklen_t salen;
	int one = 1;
	long timeout_seconds = 0;
	struct timeval tv;
#ifdef LIBWRAP
	int use_tcpwrapper = 0;
#endif /* LIBWRAP */

	while ((ch = getopt(argc, argv, "a:D:g:m:M:R:S:t:u:AnVwr")) != -1) {
		char *p;
		switch (ch) {
		case 'a':
			if (!*optarg)
				usage();
			if ((Bind_Addr = inet_addr(optarg)) == INADDR_NONE) {
				syslog(LOG_NOTICE,
					"%s: invalid address", optarg);
				usage();
			}
			break;
		case 'A':
			AnonFtpOnly = 1; /* restrict to anon usernames only */
			break;
		case 'D':
			Debug_Level = strtol(optarg, &p, 10);
			if (!*optarg || *p)
				usage();
			break;
		case 'g':
			Group = optarg;
			break;
		case 'm':
			min_port = strtol(optarg, &p, 10);
			if (!*optarg || *p)
				usage();
			if (min_port < 0 || min_port > USHRT_MAX)
				usage();
			break;
		case 'M':
			max_port = strtol(optarg, &p, 10);
			if (!*optarg || *p)
				usage();
			if (max_port < 0 || max_port > USHRT_MAX)
				usage();
			break;
		case 'n':
			NatMode = 1; /* pass all passives, we're using NAT */
			break;
		case 'r':
			Use_Rdns = 1; /* look up hostnames */
			break;
		case 'R': {
			char *s, *t;

			if (!*optarg)
				usage();
			if ((s = strdup(optarg)) == NULL) {
				syslog (LOG_NOTICE,
				    "Insufficient memory (malloc failed)");
				exit(EX_UNAVAILABLE);
			}
			memset(&real_server_sa, 0, sizeof(real_server_sa));
			real_server_sa.sin_len = sizeof(struct sockaddr_in);
			real_server_sa.sin_family = AF_INET;
			t = strchr(s, ':');
			if (t == NULL)
				real_server_sa.sin_port = htons(21);
			else {
				long port = strtol(t + 1, &p, 10);

				if (*p || port <= 0 || port > 65535)
					usage();
				real_server_sa.sin_port = htons(port);
				*t = 0;
			}
			real_server_sa.sin_addr.s_addr = inet_addr(s);
			if (real_server_sa.sin_addr.s_addr == INADDR_NONE)
				usage();
			free(s);
			ReverseMode = 1;
			break;
		}
		case 'S':
			if (!inet_aton(optarg, &src_addr))
				usage();
			break;
		case 't':
			timeout_seconds = strtol(optarg, &p, 10);
			if (!*optarg || *p)
				usage();
			break;
		case 'u':
			User = optarg;
			break;
		case 'V':
			Verbose = 1;
			break;
#ifdef LIBWRAP
		case 'w':
			use_tcpwrapper = 1; /* do the libwrap thing */
			break;
#endif /* LIBWRAP */
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (max_port < min_port)
		usage();

	openlog(__progname, LOG_NDELAY|LOG_PID, LOG_DAEMON);

	setlinebuf(stdout);
	setlinebuf(stderr);

	memset(&client_iob, 0, sizeof(client_iob));
	memset(&server_iob, 0, sizeof(server_iob));

	if (get_proxy_env(0, &real_server_sa, &client_iob.sa,
	    &proxy_sa) == -1)
		exit(EX_PROTOCOL);

	/*
	 * We may now drop root privs, as we have done our ioctl for
	 * pf. If we do drop root, we can't make backchannel connections
	 * for PORT and EPRT come from port 20, which is not strictly
	 * RFC compliant. This shouldn't cause problems for all but
	 * the stupidest ftp clients and the stupidest packet filters.
	 */
	drop_privs();

	/*
	 * We check_host after get_proxy_env so that checks are done
	 * against the original destination endpoint, not the endpoint
	 * of our side of the rdr. This allows the use of tcpwrapper
	 * rules to restrict destinations as well as sources of connections
	 * for ftp.
	 */
	if (Use_Rdns)
		flags = 0;
	else
		flags = NI_NUMERICHOST | NI_NUMERICSERV;

	i = getnameinfo((struct sockaddr *)&client_iob.sa,
	    sizeof(client_iob.sa), ClientName, sizeof(ClientName), NULL, 0,
	    flags);

	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (client)");
		exit(EX_OSERR);
	}

	i = getnameinfo((struct sockaddr *)&real_server_sa,
	    sizeof(real_server_sa), RealServerName, sizeof(RealServerName),
	    NULL, 0, flags);

	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (server)");
		exit(EX_OSERR);
	}

#ifdef LIBWRAP
	if (use_tcpwrapper && !check_host(&client_iob.sa, &real_server_sa))
		exit(EX_NOPERM);
#endif

	client_iob.fd = 0;

	syslog(LOG_INFO, "accepted connection from %s:%u to %s:%u", ClientName,
		ntohs(client_iob.sa.sin_port), RealServerName,
		ntohs(real_server_sa.sin_port));

	server_iob.fd = get_backchannel_socket(SOCK_STREAM, min_port, max_port,
	    -1,	1, &server_iob.sa);

	if (connect(server_iob.fd, (struct sockaddr *)&real_server_sa,
	    sizeof(real_server_sa)) != 0) {
		syslog(LOG_INFO, "cannot connect to %s:%u (%m)", RealServerName,
		    ntohs(real_server_sa.sin_port));
		exit(EX_NOHOST);
	}

	/*
	 * Now that we are connected to the real server, get the name
	 * of our end of the server socket so we know our IP address
	 * from the real server's perspective.
	 */
	salen = sizeof(server_iob.sa);
	getsockname(server_iob.fd, (struct sockaddr *)&server_iob.sa, &salen);

	i = getnameinfo((struct sockaddr *)&server_iob.sa,
	    sizeof(server_iob.sa), OurName, sizeof(OurName), NULL, 0, flags);

	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (local)");
		exit(EX_OSERR);
	}

	debuglog(1, "local socket is %s:%u", OurName,
	    ntohs(server_iob.sa.sin_port));

	/* ignore SIGPIPE */
	bzero(&new_sa, sizeof(new_sa));
	new_sa.sa_handler = SIG_IGN;
	(void)sigemptyset(&new_sa.sa_mask);
	new_sa.sa_flags = SA_RESTART;
	if (sigaction(SIGPIPE, &new_sa, &old_sa) != 0) {
		syslog(LOG_ERR, "sigaction() failed (%m)");
		exit(EX_OSERR);
	}

	if (setsockopt(client_iob.fd, SOL_SOCKET, SO_OOBINLINE, (char *)&one,
	    sizeof(one)) == -1) {
		syslog(LOG_NOTICE, "cannot set SO_OOBINLINE (%m)");
		exit(EX_OSERR);
	}

	client_iob.line_buffer_size = STARTBUFSIZE;
	client_iob.line_buffer = malloc(client_iob.line_buffer_size);
	client_iob.io_buffer_size = STARTBUFSIZE;
	client_iob.io_buffer = malloc(client_iob.io_buffer_size);
	client_iob.next_byte = 0;
	client_iob.io_buffer_len = 0;
	client_iob.alive = 1;
	client_iob.who = "client";
	client_iob.send_oob_flags = 0;
	client_iob.real_sa = client_iob.sa;

	server_iob.line_buffer_size = STARTBUFSIZE;
	server_iob.line_buffer = malloc(server_iob.line_buffer_size);
	server_iob.io_buffer_size = STARTBUFSIZE;
	server_iob.io_buffer = malloc(server_iob.io_buffer_size);
	server_iob.next_byte = 0;
	server_iob.io_buffer_len = 0;
	server_iob.alive = 1;
	server_iob.who = "server";
	server_iob.send_oob_flags = MSG_OOB;
	server_iob.real_sa = real_server_sa;

	if (client_iob.line_buffer == NULL || client_iob.io_buffer == NULL ||
	    server_iob.line_buffer == NULL || server_iob.io_buffer == NULL) {
		syslog (LOG_NOTICE, "insufficient memory");
		exit(EX_UNAVAILABLE);
	}

	while (client_iob.alive || server_iob.alive) {
		int maxfd = 0;
		fd_set *fdsp;

		if (client_iob.fd > maxfd)
			maxfd = client_iob.fd;
		if (client_listen_socket > maxfd)
			maxfd = client_listen_socket;
		if (client_data_socket > maxfd)
			maxfd = client_data_socket;
		if (server_iob.fd > maxfd)
			maxfd = server_iob.fd;
		if (server_listen_socket > maxfd)
			maxfd = server_listen_socket;
		if (server_data_socket > maxfd)
			maxfd = server_data_socket;

		debuglog(3, "client is %s; server is %s",
		    client_iob.alive ? "alive" : "dead",
		    server_iob.alive ? "alive" : "dead");

		fdsp = (fd_set *)calloc(howmany(maxfd + 1, NFDBITS),
		    sizeof(fd_mask));
		if (fdsp == NULL) {
			syslog(LOG_NOTICE, "insufficient memory");
			exit(EX_UNAVAILABLE);
		}

		if (client_iob.alive && telnet_getline(&client_iob,
		    &server_iob)) {
			debuglog(3, "client line buffer is \"%s\"",
			    (char *)client_iob.line_buffer);
			if (client_iob.line_buffer[0] != '\0')
				do_client_cmd(&client_iob, &server_iob);
		} else if (server_iob.alive && telnet_getline(&server_iob,
		    &client_iob)) {
			debuglog(3, "server line buffer is \"%s\"",
			    (char *)server_iob.line_buffer);
			if (server_iob.line_buffer[0] != '\0')
				do_server_reply(&server_iob, &client_iob);
		} else {
			if (client_iob.alive) {
				FD_SET(client_iob.fd, fdsp);
				if (client_listen_socket >= 0)
					FD_SET(client_listen_socket, fdsp);
				if (client_data_socket >= 0)
					FD_SET(client_data_socket, fdsp);
			}
			if (server_iob.alive) {
				FD_SET(server_iob.fd, fdsp);
				if (server_listen_socket >= 0)
					FD_SET(server_listen_socket, fdsp);
				if (server_data_socket >= 0)
					FD_SET(server_data_socket, fdsp);
			}
			tv.tv_sec = timeout_seconds;
			tv.tv_usec = 0;

		doselect:
			sval = select(maxfd + 1, fdsp, NULL, NULL,
			    (tv.tv_sec == 0) ? NULL : &tv);
			if (sval == 0) {
				/*
				 * This proxy has timed out. Expire it
				 * quietly with an obituary in the syslogs
				 * for any passing mourners.
				 */
				syslog(LOG_INFO,
				    "timeout: no data for %ld seconds",
				    timeout_seconds);
				exit(EX_OK);
			}
			if (sval == -1) {
				if (errno == EINTR || errno == EAGAIN)
					goto doselect;
				syslog(LOG_NOTICE,
				    "select() failed (%m)");
				exit(EX_OSERR);
			}
			if (client_data_socket >= 0 &&
			    FD_ISSET(client_data_socket, fdsp)) {
				int rval;

				debuglog(3, "transfer: client to server");
				rval = xfer_data("client to server",
				    client_data_socket,
				    server_data_socket,
				    client_iob.sa.sin_addr,
				    real_server_sa.sin_addr);
				if (rval <= 0) {
					close_client_data();
					close_server_data();
					show_xfer_stats();
				} else
					client_data_bytes += rval;
			}
			if (server_data_socket >= 0 &&
			    FD_ISSET(server_data_socket, fdsp)) {
				int rval;

				debuglog(3, "transfer: server to client");
				rval = xfer_data("server to client",
				    server_data_socket,
				    client_data_socket,
				    real_server_sa.sin_addr,
				    client_iob.sa.sin_addr);
				if (rval <= 0) {
					close_client_data();
					close_server_data();
					show_xfer_stats();
				} else
					server_data_bytes += rval;
			}
			if (server_listen_socket >= 0 &&
			    FD_ISSET(server_listen_socket, fdsp)) {
				connect_port_backchannel();
			}
			if (client_listen_socket >= 0 &&
			    FD_ISSET(client_listen_socket, fdsp)) {
				connect_pasv_backchannel();
			}
			if (client_iob.alive &&
			    FD_ISSET(client_iob.fd, fdsp)) {
				client_iob.data_available = 1;
			}
			if (server_iob.alive &&
			    FD_ISSET(server_iob.fd, fdsp)) {
				server_iob.data_available = 1;
			}
		}
		free(fdsp);
		if (client_iob.got_eof) {
			shutdown(server_iob.fd, 1);
			shutdown(client_iob.fd, 0);
			client_iob.got_eof = 0;
			client_iob.alive = 0;
		}
		if (server_iob.got_eof) {
			shutdown(client_iob.fd, 1);
			shutdown(server_iob.fd, 0);
			server_iob.got_eof = 0;
			server_iob.alive = 0;
		}
	}

	if (Verbose)
		syslog(LOG_INFO, "session ended");

	exit(EX_OK);
}
@


1.41
log
@Check snprintf return value for -1.
OK otto, henning, hshoexer, krw, beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.40 2005/02/24 15:49:08 dhartmei Exp $ */
@


1.40
log
@const correctness, string literals are const char *, no functional change
from Joerg Sonnenberger joerg(at)britannica(dot)bec(dot)de
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.39 2005/01/19 20:58:59 millert Exp $ */
d320 1
a320 1
	int i;
d347 1
a347 1
			if (i >= len)
d354 1
a354 1
			if (i >= len)
d361 1
a361 1
		if (i >= len)
d370 1
a370 1
		if (i >= len)
d378 1
a378 1
		if (i >= len)
d384 2
a385 1
	syslog(LOG_INFO, "%s", tbuf);
@


1.39
log
@Fix -S flag for non-root; from Ewen McNeill (closes PR 4066)
OK dhartmei@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.38 2004/11/19 00:47:23 jmc Exp $ */
d149 2
a150 2
char *User = "proxy";
char *Group;
d391 1
a391 1
	char *logstring;
@


1.38
log
@options sort and sync usage();
from wiz@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.37 2004/07/11 01:54:36 brad Exp $ */
d544 1
a544 1
		bzero(&listen_sa.sin_addr, sizeof(struct in_addr));
@


1.37
log
@addr -> address in usage() for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.36 2004/07/06 19:49:11 dhartmei Exp $ */
d178 3
a180 3
	    "usage: %s [-AnrVw] [-a address] [-D debuglevel [-g group]"
	    " [-M maxport] [-m minport] [-t timeout] [-u user]"
	    " [-R address[:port]] [-S address]", __progname);
@


1.36
log
@The 'reverse ftp-proxy' mode adds a command line option -R to
ftp-proxy which proxies connection from external ftp clients to
an internal ftp server, supporting client passive mode (where
server listens on a random port for data connections, and the
client connects to the server for data connections).

This is the reverse mode to normal operation, where ftp-proxy
proxies connections from local clients to external servers,
supporting client active mode.

ok beck@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.35 2004/03/14 21:51:44 dhartmei Exp $ */
d180 1
a180 1
	    " [-R addr[:port]] [-S addr]", __progname);
@


1.35
log
@#include fixes, from Max Laier, ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.34 2004/01/22 16:10:30 beck Exp $ */
d131 2
d143 1
d179 2
a180 1
	    " [-M maxport] [-m minport] [-t timeout] [-u user]", __progname);
d562 1
a562 1
		bzero(&listen_sa.sin_addr, sizeof(struct in_addr));
d932 4
a935 1
		iap = &(server->sa.sin_addr);
d983 1
a983 1
	while ((ch = getopt(argc, argv, "a:D:g:m:M:t:u:AnVwr")) != -1) {
d1026 35
d1096 2
a1097 1
	if (get_proxy_env(0, &real_server_sa, &client_iob.sa) == -1)
@


1.34
log
@Add a -a address option to set the address which the proxy will use
to bind the local end of outgoing connections, and some man page
cleanup. Based on diff provided in pr 3538 by Karl O. Pinc <kop@@meme.com>
Closes pr 3538. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.33 2003/08/22 21:50:34 david Exp $ */
d70 1
a70 1
#include <sys/types.h>
@


1.33
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.32 2003/07/29 14:46:06 henning Exp $ */
d151 1
d175 2
a176 3
	    "usage: %s [-AnrVw] [-D debuglevel] [-g group] %s %s",
	    __progname, "[-m minport] [-M maxport] [-t timeout]",
	    "[-u user]");
d976 1
a976 1
	while ((ch = getopt(argc, argv, "D:g:m:M:t:u:AnVwr")) != -1) {
d979 9
@


1.32
log
@correctly handle multiline responses with leading space followed by number
PR3378 mayonez@@ssnet.xim.pl, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.31 2003/06/28 01:04:57 deraadt Exp $ */
d122 1
a122 1
 * to the other side's socket.  Similarily, if a connected socket is
@


1.31
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.30 2003/06/23 17:22:29 deraadt Exp $ */
d864 2
@


1.30
log
@delinting from beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.29 2003/03/20 01:34:48 david Exp $ */
d163 7
a169 2
extern void debuglog(int debug_level, const char *fmt, ...);

@


1.29
log
@cmdline options in alphabetical order in usage() and manpage
and make sure they are consistent

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.28 2003/01/23 23:15:16 djm Exp $ */
d464 1
a464 1
	int salen;
d507 1
a507 1
	int salen;
d606 1
a606 1
		cp = client->line_buffer + strlen("user ");
d627 1
a627 1
			sendbuf = client->line_buffer;
d637 1
a637 1
		line = strdup(client->line_buffer+strlen("eprt "));
d758 1
a758 2
		int byte_number;
		u_char *tailptr;
d762 1
a762 2
		tailptr = &client->line_buffer[strlen("port ")];
		byte_number = 0;
d816 1
a816 1
		sendbuf = client->line_buffer;
d877 1
a877 2
		u_char *tailptr;
		int byte_number;
d882 1
a882 1
		tailptr = strchr((char *)server->line_buffer, '(');
a891 1
		byte_number = 0;
d936 1
a936 1
		sendbuf = server->line_buffer;
d960 2
a961 1
	int sval, ch, salen, flags, i;
@


1.28
log
@Honour TCP_WRAPPERS mk.conf setting; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.27 2002/12/19 18:19:10 deraadt Exp $ */
d169 3
a171 3
	    "usage: %s [-AnrVw] [-t timeout] [-D debuglevel] %s %s",
	    __progname, "[-g group] [-u user] [-m min_port]",
	    "[-M max_port]");
@


1.27
log
@various tweaks.  someone mailed in a huge diff that was so wrong in so
many ways, and i wasted 2 hours finding the gems in it...
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.25 2002/12/19 01:27:56 deraadt Exp $ */
a90 1
#include <tcpd.h>
d95 2
d99 1
d233 1
d291 1
d965 1
a965 1
	int use_tcpwrapper = 0, one = 1;
d968 3
d1017 1
d1021 1
d1083 1
d1086 1
@


1.26
log
@accidental commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.24 2002/07/07 08:54:50 jufi Exp $ */
d204 1
a204 1
			syslog(LOG_ERR, "can't find user %s", User);
d214 1
a214 1
			syslog(LOG_ERR, "can't find group %s", Group);
d221 1
a221 1
		syslog(LOG_ERR, "can't drop group privs (%m)");
d226 1
a226 1
		syslog(LOG_ERR, "can't drop root privs (%m)");
d258 2
a259 1
		if (i == -1)
d265 2
a266 1
		if (i == -1)
d319 1
a319 1
		  "data transfer completed (no bytes transferred)");
d331 1
a331 1
			    "data transfer completed (%dh %dm %ds",
d339 1
a339 1
			    "data transfer completed (%dm %ds", idelta / 60,
d346 1
a346 1
		i = snprintf(tbuf, len, "data transfer completed (%.1fs",
d355 1
a355 1
		    ", %d (%.1fKB/s) to server", client_data_bytes,
d363 1
a363 1
		    ", %d (%.1fKB/s) to client", server_data_bytes,
d397 1
a397 1
	syslog(level, "%s %s", (client?"from client:":"server reply:"),
d430 1
a430 1
			syslog(LOG_INFO, "bind of server socket failed (%m)");
d434 1
a434 1
			syslog(LOG_INFO, "server socket listen failed (%m)");
d444 1
a444 1
			    "can't get client listen socket (%m)");
d449 1
a449 1
			    "can't listen on client socket (%m)");
d476 1
a476 1
		syslog(LOG_NOTICE, "accept failed (%m)");
d486 1
a486 1
		syslog(LOG_NOTICE, "backchannel failed (%m)");
d491 1
a491 1
		syslog(LOG_NOTICE, "connect failed (%m)");
d518 1
a518 1
		syslog(LOG_NOTICE, "accept failed (%m)");
d535 1
a535 1
			syslog(LOG_NOTICE,  "backchannel failed (%m)");
d554 1
a554 1
			syslog(LOG_NOTICE, "setsockopt failed (%m)");
d560 1
a560 1
			syslog(LOG_NOTICE, "bind to port 20 failed (%m)");
d567 1
a567 1
		syslog(LOG_INFO, "can't connect data connection (%m)");
d610 1
a610 1
			    "500 Only anonymous ftp is allowed\r\n");
d687 1
a687 1
		debuglog(1, "to server(modified):  %s", tbuf);
d692 1
a692 1
		    "500 Invalid argument, rejected\r\n");
d710 1
a710 1
			debuglog(1, "to client(modified):  %s", tbuf);
d740 1
a740 1
		debuglog(1, "to client(modified):  %s", tbuf);
d810 1
a810 1
		debuglog(1, "to server(modified):  %s", tbuf);
d849 1
a849 1
		syslog(LOG_NOTICE, "Long (> 512 bytes) ftp control reply");
d932 1
a932 1
		debuglog(1, "to client(modified):  %s", tbuf);
d1052 2
a1054 2
	else
		flags = 0;
d1060 2
a1061 2
	if (i == -1) {
		syslog (LOG_ERR, "getnameinfo failed (%m)");
d1069 2
a1070 2
	if (i == -1) {
		syslog (LOG_ERR, "getnameinfo failed (%m)");
d1079 3
a1081 5
	debuglog(1, "client is %s:%u", ClientName,
	    ntohs(client_iob.sa.sin_port));

	debuglog(1, "target server is %s:%u", RealServerName,
	    ntohs(real_server_sa.sin_port));
d1088 1
a1088 1
		syslog(LOG_INFO, "Can't connect to %s:%u (%m)", RealServerName,
d1104 6
a1109 1
	debuglog(1, "our end of socket to server is %s:%u", OurName,
d1118 1
a1118 1
		syslog(LOG_ERR, "sigaction failed (%m)");
d1124 1
a1124 1
		syslog(LOG_NOTICE, "Can't set SO_OOBINLINE (%m) - exiting");
d1152 1
a1152 1
		syslog (LOG_NOTICE,  "Insufficient memory (malloc failed)");
d1173 1
a1173 1
		debuglog(3, "client is %s, server is %s",
d1180 1
a1180 1
			syslog(LOG_NOTICE, "Insufficient memory");
d1224 1
a1224 1
				    "timeout, no data for %ld seconds",
d1232 1
a1232 1
				    "select failed (%m) - exiting");
d1239 1
a1239 1
				debuglog(3, "xfer client to server");
d1256 1
a1256 1
				debuglog(3, "xfer server to client");
d1300 4
@


1.25
log
@missing .Pp
@
text
@d204 1
a204 1
			syslog(LOG_ERR, "cannot find user %s", User);
d214 1
a214 1
			syslog(LOG_ERR, "cannot find group %s", Group);
d221 1
a221 1
		syslog(LOG_ERR, "cannot drop group privs (%m)");
d226 1
a226 1
		syslog(LOG_ERR, "cannot drop root privs (%m)");
d258 1
a258 2

		if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN)
d264 1
a264 2

		if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN)
d280 2
a281 1
		syslog(LOG_NOTICE, "connection rejected by tcpwrappers");
d317 1
a317 1
		  "data transfer complete (no bytes transferred)");
d329 1
a329 1
			    "data transfer complete (%dh %dm %ds",
d337 1
a337 1
			    "data transfer complete (%dm %ds", idelta / 60,
d344 1
a344 1
		i = snprintf(tbuf, len, "data transfer complete (%.1fs",
d353 1
a353 1
		    ", %d bytes to server) (%.1fKB/s", client_data_bytes,
d361 1
a361 1
		    ", %d bytes to client) (%.1fKB/s", server_data_bytes,
d395 1
a395 1
	syslog(level, "%s %s", client ? "client:" : " server:",
d428 1
a428 1
			syslog(LOG_INFO, "server socket bind() failed (%m)");
d432 1
a432 1
			syslog(LOG_INFO, "server socket listen() failed (%m)");
d442 1
a442 1
			    "cannot get client listen socket (%m)");
d447 1
a447 1
			    "cannot listen on client socket (%m)");
d474 1
a474 1
		syslog(LOG_NOTICE, "accept() failed (%m)");
d484 1
a484 1
		syslog(LOG_NOTICE, "get_backchannel_socket() failed (%m)");
d489 1
a489 1
		syslog(LOG_NOTICE, "connect() failed (%m)");
d516 1
a516 1
		syslog(LOG_NOTICE, "accept() failed (%m)");
d533 1
a533 1
			syslog(LOG_NOTICE,  "get_backchannel_socket() failed (%m)");
d552 1
a552 1
			syslog(LOG_NOTICE, "setsockopt() failed (%m)");
d558 1
a558 1
			syslog(LOG_NOTICE, "data channel bind() failed (%m)");
d565 1
a565 1
		syslog(LOG_INFO, "cannot connect data channel (%m)");
d608 1
a608 1
			    "500 Only anonymous FTP is allowed\r\n");
d685 1
a685 1
		debuglog(1, "to server (modified): %s", tbuf);
d690 1
a690 1
		    "500 Invalid argument; rejected\r\n");
d708 1
a708 1
			debuglog(1, "to client (modified): %s", tbuf);
d738 1
a738 1
		debuglog(1, "to client (modified): %s", tbuf);
d808 1
a808 1
		debuglog(1, "to server (modified): %s", tbuf);
d847 1
a847 1
		syslog(LOG_NOTICE, "long FTP control reply");
d930 1
a930 1
		debuglog(1, "to client (modified): %s", tbuf);
d1050 2
a1052 2
	else
		flags = NI_NUMERICHOST | NI_NUMERICSERV;
d1058 2
a1059 2
	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (client)");
d1067 2
a1068 2
	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (server)");
d1077 5
a1081 3
	syslog(LOG_INFO, "accepted connection from %s:%u to %s:%u", ClientName,
		ntohs(client_iob.sa.sin_port), RealServerName,
		ntohs(real_server_sa.sin_port));
d1088 1
a1088 1
		syslog(LOG_INFO, "cannot connect to %s:%u (%m)", RealServerName,
d1104 1
a1104 6
	if (i != 0 && i != EAI_NONAME && i != EAI_AGAIN) {
		debuglog(2, "name resolution failure (local)");
		exit(EX_OSERR);
	}

	debuglog(1, "local socket is %s:%u", OurName,
d1113 1
a1113 1
		syslog(LOG_ERR, "sigaction() failed (%m)");
d1119 1
a1119 1
		syslog(LOG_NOTICE, "cannot set SO_OOBINLINE (%m)");
d1147 1
a1147 1
		syslog (LOG_NOTICE, "insufficient memory");
d1168 1
a1168 1
		debuglog(3, "client is %s; server is %s",
d1175 1
a1175 1
			syslog(LOG_NOTICE, "insufficient memory");
d1219 1
a1219 1
				    "timeout: no data for %ld seconds",
d1227 1
a1227 1
				    "select() failed (%m)");
d1234 1
a1234 1
				debuglog(3, "transfer: client to server");
d1251 1
a1251 1
				debuglog(3, "transfer: server to client");
a1294 4

	if (Verbose)
		syslog(LOG_INFO, "session ended");

@


1.24
log
@
typos/grammar/better words
in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.23 2002/07/03 23:39:03 deraadt Exp $ */
d204 1
a204 1
			syslog(LOG_ERR, "can't find user %s", User);
d214 1
a214 1
			syslog(LOG_ERR, "can't find group %s", Group);
d221 1
a221 1
		syslog(LOG_ERR, "can't drop group privs (%m)");
d226 1
a226 1
		syslog(LOG_ERR, "can't drop root privs (%m)");
d258 2
a259 1
		if (i == -1)
d265 2
a266 1
		if (i == -1)
d282 1
a282 2
		syslog(LOG_NOTICE, "tcpwrappers rejected: %s -> %s",
		    ClientName, RealServerName);
d318 1
a318 1
		  "data transfer completed (no bytes transferred)");
d330 1
a330 1
			    "data transfer completed (%dh %dm %ds",
d338 1
a338 1
			    "data transfer completed (%dm %ds", idelta / 60,
d345 1
a345 1
		i = snprintf(tbuf, len, "data transfer completed (%.1fs",
d354 1
a354 1
		    ", %d (%.1fKB/s) to server", client_data_bytes,
d362 1
a362 1
		    ", %d (%.1fKB/s) to client", server_data_bytes,
d396 1
a396 1
	syslog(level, "%s %s", (client?"from client:":"server reply:"),
d429 1
a429 1
			syslog(LOG_INFO, "bind of server socket failed (%m)");
d433 1
a433 1
			syslog(LOG_INFO, "server socket listen failed (%m)");
d443 1
a443 1
			    "can't get client listen socket (%m)");
d448 1
a448 1
			    "can't listen on client socket (%m)");
d475 1
a475 1
		syslog(LOG_NOTICE, "accept failed (%m)");
d485 1
a485 1
		syslog(LOG_NOTICE, "backchannel failed (%m)");
d490 1
a490 1
		syslog(LOG_NOTICE, "connect failed (%m)");
d517 1
a517 1
		syslog(LOG_NOTICE, "accept failed (%m)");
d534 1
a534 1
			syslog(LOG_NOTICE,  "backchannel failed (%m)");
d553 1
a553 1
			syslog(LOG_NOTICE, "setsockopt failed (%m)");
d559 1
a559 1
			syslog(LOG_NOTICE, "bind to port 20 failed (%m)");
d566 1
a566 1
		syslog(LOG_INFO, "can't connect data connection (%m)");
d609 1
a609 1
			    "500 Only anonymous ftp is allowed\r\n");
d686 1
a686 1
		debuglog(1, "to server(modified):  %s", tbuf);
d691 1
a691 1
		    "500 Invalid argument, rejected\r\n");
d709 1
a709 1
			debuglog(1, "to client(modified):  %s", tbuf);
d739 1
a739 1
		debuglog(1, "to client(modified):  %s", tbuf);
d809 1
a809 1
		debuglog(1, "to server(modified):  %s", tbuf);
d848 1
a848 1
		syslog(LOG_NOTICE, "Long (> 512 bytes) ftp control reply");
d931 1
a931 1
		debuglog(1, "to client(modified):  %s", tbuf);
d1051 2
a1053 2
	else
		flags = 0;
d1059 2
a1060 2
	if (i == -1) {
		syslog (LOG_ERR, "getnameinfo failed (%m)");
d1068 2
a1069 2
	if (i == -1) {
		syslog (LOG_ERR, "getnameinfo failed (%m)");
d1078 3
a1080 5
	debuglog(1, "client is %s:%u", ClientName,
	    ntohs(client_iob.sa.sin_port));

	debuglog(1, "target server is %s:%u", RealServerName,
	    ntohs(real_server_sa.sin_port));
d1087 1
a1087 1
		syslog(LOG_INFO, "Can't connect to %s:%u (%m)", RealServerName,
d1103 6
a1108 1
	debuglog(1, "our end of socket to server is %s:%u", OurName,
d1117 1
a1117 1
		syslog(LOG_ERR, "sigaction failed (%m)");
d1123 1
a1123 1
		syslog(LOG_NOTICE, "Can't set SO_OOBINLINE (%m) - exiting");
d1151 1
a1151 1
		syslog (LOG_NOTICE,  "Insufficient memory (malloc failed)");
d1172 1
a1172 1
		debuglog(3, "client is %s, server is %s",
d1179 1
a1179 1
			syslog(LOG_NOTICE, "Insufficient memory");
d1223 1
a1223 1
				    "timeout, no data for %ld seconds",
d1231 1
a1231 1
				    "select failed (%m) - exiting");
d1238 1
a1238 1
				debuglog(3, "xfer client to server");
d1255 1
a1255 1
				debuglog(3, "xfer server to client");
d1299 4
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.22 2002/06/09 01:03:12 beck Exp $ */
d64 1
a64 1
 * - Ipv6 and EPASV support
d730 1
a730 1
		 * addtions/deletions in pf.
@


1.22
log
@no newlines in syslog
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.21 2002/05/23 10:22:14 deraadt Exp $ */
d164 1
a164 1
usage()
d174 1
a174 1
close_client_data()
d184 1
a184 1
close_server_data()
d194 1
a194 1
drop_privs()
d288 1
a288 1
wallclock_time()
d300 1
a300 1
show_xfer_stats()
d455 1
a455 1
connect_pasv_backchannel()
d498 1
a498 1
connect_port_backchannel()
d954 1
a954 1
main(int argc, char **argv)
@


1.21
log
@KNF during an audit; found an improperly initialized sockaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.20 2002/03/12 08:01:51 dhartmei Exp $ */
d169 1
a169 1
	    "[-M max_port]\n");
d464 1
a464 1
	debuglog(2, "client listen socket ready\n");
d507 1
a507 1
	debuglog(2, "server listen socket ready\n");
d668 1
a668 1
		debuglog(1, "client wants us to use %s:%u\n",
d678 1
a678 1
		debuglog(1, "we want server to use %s:%u\n",
d708 1
a708 1
			debuglog(1, "to client(modified):  %s\n", tbuf);
d738 1
a738 1
		debuglog(1, "to client(modified):  %s\n", tbuf);
d755 1
a755 1
		debuglog(1, "Got a PORT command\n");
d786 1
a786 1
		debuglog(1, "client wants us to use %u.%u.%u.%u:%u\n",
d796 1
a796 1
		debuglog(1, "we want server to use %s:%u\n",
d876 2
a877 2
		debuglog(1, "Got a PASV reply\n");
		debuglog(1, "{%s}\n", (char *)server->line_buffer);
d913 1
a913 1
		debuglog(1, "server wants us to use %s:%u\n",
d921 1
a921 1
		debuglog(1, "we want client to use %s:%u\n", inet_ntoa(*iap),
d930 1
a930 1
		debuglog(1, "to client(modified):  %s\n", tbuf);
d1077 1
a1077 1
	debuglog(1, "client is %s:%u\n", ClientName,
d1080 1
a1080 1
	debuglog(1, "target server is %s:%u\n", RealServerName,
d1104 1
a1104 1
	debuglog(1, "our end of socket to server is %s:%u\n", OurName,
d1168 1
a1168 1
		debuglog(3, "client is %s, server is %s\n",
d1181 1
a1181 1
			debuglog(3, "client line buffer is \"%s\"\n",
d1187 1
a1187 1
			debuglog(3, "server line buffer is \"%s\"\n",
d1234 1
a1234 1
				debuglog(3, "xfer client to server\n");
d1251 1
a1251 1
				debuglog(3, "xfer server to client\n");
@


1.20
log
@Pass full length to strlcat(). From Brian Poole.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.19 2002/01/10 19:35:07 mickey Exp $ */
a172 1

a182 1

a192 1

d255 3
a257 4
		i = getnameinfo(
			(struct sockaddr *) &client_sin->sin_addr,
			sizeof(&client_sin->sin_addr), cname,
			sizeof(cname), NULL, 0, NI_NAMEREQD);
d261 3
a263 4
		i = getnameinfo(
			(struct sockaddr *)&server_sin->sin_addr,
			sizeof(&server_sin->sin_addr), sname,
			sizeof(sname), NULL, 0, NI_NAMEREQD);
d423 1
a423 1
		bzero (&server_listen_sa, sizeof(server_listen_sa));
a453 2


a463 1

a496 2


a506 1

a573 1

d770 1
a770 1
		for (i = 0; i<6; i++)
d777 1
a777 1

d801 6
a806 6
			 ((u_char *)&server->sa.sin_addr.s_addr)[0],
			 ((u_char *)&server->sa.sin_addr.s_addr)[1],
			 ((u_char *)&server->sa.sin_addr.s_addr)[2],
			 ((u_char *)&server->sa.sin_addr.s_addr)[3],
			 ((u_char *)&server_listen_sa.sin_port)[0],
			 ((u_char *)&server_listen_sa.sin_port)[1]);
d869 2
a870 2
	else 
		continuing = 0;	  
d887 1
a887 1
		tailptr++; /* skip past space or ( */ 
@


1.19
log
@print proper host name for the proxy's peer; bob ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.18 2001/12/14 18:12:41 beck Exp $ */
d56 1
a56 1
 * the real destination address is retreived from pf
d167 3
a169 2
	    "usage: %s [-ArVw] [-t timeout] [-D debuglevel] %s",
	    __progname, "[-m min_port] [-M max_port]\n");
d372 1
a372 1
	strlcat(tbuf, ")", len);
@


1.18
log
@RFC 959 wasn't clear about what happens around a PASV reply, and in
fact RFC 1123 does say that it may not contain parenthesis, and you
just have to look at the end of the line. Tholo managed to find a
TOPS20 ftp server (toad.xkl.com) that doesn't put parens around the
reply - This fixes it so it will handle either case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.17 2001/10/10 15:32:39 beck Exp $ */
a1108 3
	i = getnameinfo((struct sockaddr *)&client_iob.sa,
	    sizeof(client_iob.sa), OurName, sizeof(OurName), NULL, 0, flags);

d1111 3
@


1.17
log
@  fix multi-line contunuations - ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.16 2001/09/21 18:06:25 beck Exp $ */
d892 5
a896 2
			syslog(LOG_NOTICE, "malformed 227 reply");
			exit(EX_DATAERR);
d898 1
d903 1
a903 2

		i = sscanf(tailptr, "(%u,%u,%u,%u,%u,%u)", &values[0],
@


1.16
log
@ Drop privs to named group, not group with same name as user.
noticed by itojun, thanks.

 fries, you need to catch this for what you're using with faithd
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.15 2001/09/05 20:40:10 beck Exp $ */
d847 1
d867 2
d873 2
d878 4
d940 2
a941 1
	} else
d943 1
@


1.15
log
@-Make ftp-proxy drop privs to user "proxy" by default.
   *WARNING* this means that it will die when it can't find user proxy
   if you are not running with a passwd database generated from current
- Speling cleanup and missing va_end() noticed by  <d.doroshenko@@omnitel.net>
- fix logging of getpwnam|getgrnam failures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.14 2001/08/28 19:57:29 beck Exp $ */
d214 1
a214 1
		gr = getgrnam(User);
@


1.14
log
@remove unneeded code (this is done later)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.13 2001/08/28 19:35:04 deraadt Exp $ */
d144 2
a145 1
char *User, *Group;
d206 1
a206 1
			syslog(LOG_ERR, "can't find user %s (%m)", User);
d216 1
a216 1
			syslog(LOG_ERR, "can't find group %s (%m)", Group);
d735 1
a735 1
		 * EPSV is a problem - Unliks PASV, the reply from the
@


1.13
log
@oh, some cleanups etc etc
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.12 2001/08/22 05:28:16 beck Exp $ */
a1071 9

	/*
	 * Check to see if we have a timeout defined, if so,
	 * set a timeout for this select call to that value, so
	 * we may time out if don't see any data in timeout
	 * seconds.
	 */
	tv.tv_sec = timeout_seconds;
	tv.tv_usec = 0;
@


1.12
log
@-Functionify some of the main loop, so it isn't so horrificly deep and is
a bit easier to look at, for small values of easier.

-Add two options for -u user and -g group to optionally make the proxy drop
privs after doing it's pf ioctl's to find out where to go. Running as non
root does mean that the PORT and EPRT backchannels do not come from port 20,
but this isn't a problem for most sensible ftp clients and sets of packet
filter rules that aren't written by a knuckle dragging ape living in the 90's.
I would make it drop privs by default, but technically this breaks the ftp
specs, and for the upcoming stuff to deal with EPRT, we will need root privs
to manipulate rdr rules).
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.11 2001/08/19 20:43:56 beck Exp $ */
d30 1
a30 1
 * 
a145 2
char *argstr = "D:g:m:M:t:u:AnVwr";

d167 1
a167 1
	    __progname, "[-m min_port] [-M max_port ]\n");
d172 1
a172 1
static void 
d175 2
a176 2
	if (client_data_socket >= 0) { 
		shutdown(client_data_socket,2);
d185 1
a185 1
{ 
d187 1
a187 1
		shutdown(server_data_socket,2);
d198 3
a200 3
	struct group *gr; 	
	int uid = 0;
	int gid = 0;
d219 1
a219 2
	} 
	
a231 3

	

a236 1

a239 1

d262 1
a262 1
		
d295 1
a295 1
	gettimeofday(&tv,NULL);
a301 1

a408 1

d459 1
a459 1
static void 
d505 1
a505 1
static void 
d532 1
a532 2

		/* 
d534 1
a534 1
		 * socket bound in our designated range, instead of 
d538 1
a538 3
	  
		bzero(&listen_sa.sin_addr,
		     sizeof(struct in_addr));
d550 1
a550 1
		 * 20 here, so we're fully RFC compliant.  
a551 1
	
d556 1
a556 2
		bzero(&listen_sa.sin_addr,
		     sizeof(struct in_addr));
d571 1
a571 1
	
d587 1
a587 1
	int i,j,rv;
d633 1
a633 1
 	    strlen("eprt ")) == 0)) {
d690 1
a690 1
		    ntohs(server_listen_sa.sin_port));	
d729 1
a729 1
	} else if (!NatMode && (strncasecmp((char *)client->line_buffer, 
d774 2
a775 2
		if (i != 6) { 
			syslog(LOG_INFO, "malformed PORT command (%s)", 
d780 1
a780 1
		for (i=0; i<6; i++)
d782 1
a782 1
				syslog(LOG_INFO, 
d784 1
a784 1
				     client->line_buffer);
d808 1
a808 1
		    ntohs(server_listen_sa.sin_port));	
d880 1
a880 1
		tailptr = strchr((char *)server->line_buffer,'(');
d893 2
a894 2
		if (i != 6) { 
			syslog(LOG_INFO, "malformed PASV reply (%s)", 
d898 1
a898 1
		for (i=0; i<6; i++)
d901 1
a901 1
				     client->line_buffer);
a952 2
	struct timeval tv;
	long timeout_seconds = 0;
d955 3
a957 2
	int use_tcpwrapper = 0;
	int one = 1;
d959 1
a959 1
	while ((ch = getopt(argc, argv, argstr)) != -1) {
a1035 1
	
a1037 1

d1073 2
a1074 1
	/*  Check to see if we have a timeout defined, if so,
a1080 1
	timeout_seconds=tv.tv_sec;
d1159 1
a1159 1
		
d1172 1
a1172 1
		
d1177 1
a1177 1
		fdsp = (fd_set *)calloc(howmany(maxfd + 1, NFDBITS), 
d1224 2
a1225 2
				   "timeout, no data for %ld seconds",
				   timeout_seconds);
d1232 1
a1232 1
				     "select failed (%m) - exiting");
d1236 1
a1236 1
			    FD_ISSET(client_data_socket,fdsp)) {
d1253 1
a1253 1
			    FD_ISSET(server_data_socket,fdsp)) {
d1270 1
a1270 1
			    FD_ISSET(server_listen_socket,fdsp)) {
d1274 1
a1274 1
			    FD_ISSET(client_listen_socket,fdsp)) {
d1278 1
a1278 1
			    FD_ISSET(client_iob.fd,fdsp)) {
d1282 1
a1282 1
			    FD_ISSET(server_iob.fd,fdsp)) {
d1294 2
a1295 2
			shutdown(client_iob.fd,1);
			shutdown(server_iob.fd,0);
d1298 1
a1298 2
                }

@


1.11
log
@unsmokecrack - thanks millert
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.10 2001/08/19 18:24:13 beck Exp $ */
d81 1
d83 1
d144 3
a146 1
char *argstr = "m:M:D:t:AnVwr";
d173 65
d427 2
a428 5
	if (client_data_socket != -1) {
		shutdown(client_data_socket,2);
		close(client_data_socket);
		client_data_socket = -1;
	}
d433 1
a433 5
	if (server_data_socket != -1) {
		shutdown(server_data_socket,2);
		close(server_data_socket);
		server_data_socket = -1;
	}
d445 1
a445 1
			syslog(LOG_INFO, "listen on server socket failed (%m)");
d467 132
d744 2
a745 2
	} else if (!NatMode && (strncasecmp((char *)client->line_buffer, "epsv",
	    strlen("epsv")) == 0)) {
d760 1
d915 1
a915 2
				syslog(LOG_INFO, 
				    "malformed PASV reply(%s)",
a980 11
		case 'w':
			use_tcpwrapper = 1; /* do the libwrap thing */
			break;
		case 'V':
			Verbose = 1;
			break;
		case 't':
			timeout_seconds = strtol(optarg, &p, 10);
			if (!*optarg || *p)
				usage();
			break;
d986 2
a987 5
		case 'r':
			Use_Rdns = 1; /* look up hostnames */
			break;
		case 'n':
			NatMode = 1; /* pass all passives, we're using NAT */
d1003 20
d1046 11
d1233 3
a1235 3
			switch (sval = select(maxfd + 1, fdsp, NULL, NULL,
			    (tv.tv_sec == 0) ? NULL : &tv)) {
			case 0:
d1245 2
a1246 3
				break;

			case -1:
d1250 1
a1250 1
				    "select failed (%m) - exiting");
a1251 187
				break;

			default:
				if (client_data_socket >= 0 &&
				    FD_ISSET(client_data_socket,fdsp)) {
					int rval;

					debuglog(3, "xfer client to server\n");
					rval = xfer_data("client to server",
					    client_data_socket,
					    server_data_socket,
					    client_iob.sa.sin_addr,
					    real_server_sa.sin_addr);
					if (rval <= 0) {
						shutdown(client_data_socket,2);
						close(client_data_socket);
						client_data_socket = -1;
						shutdown(server_data_socket,2);
						close(server_data_socket);
						server_data_socket = -1;
						show_xfer_stats();
					} else
						client_data_bytes += rval;
				}
				if (server_data_socket >= 0 &&
				    FD_ISSET(server_data_socket,fdsp)) {
					int rval;

					debuglog(3, "xfer server to client\n");
					rval = xfer_data("server to client",
					    server_data_socket,
					    client_data_socket,
					    real_server_sa.sin_addr,
					    client_iob.sa.sin_addr);
					if (rval <= 0) {
						shutdown(client_data_socket,2);
						close(client_data_socket);
						client_data_socket = -1;
						shutdown(server_data_socket,2);
						close(server_data_socket);
						server_data_socket = -1;
						show_xfer_stats();
					} else
						server_data_bytes += rval;
				}
				if (server_listen_socket >= 0 &&
				    FD_ISSET(server_listen_socket,fdsp)) {
					struct sockaddr_in listen_sa;

					/*
					 * We are about to accept a
					 * connection from the server.
					 * This is a PORT or EPRT data
					 * connection.
					 */
					debuglog(2, 
					    "server listen socket ready\n");

					if (server_data_socket >= 0) {
						shutdown(server_data_socket,2);
						close(server_data_socket);
						server_data_socket = -1;
					}
					if (client_data_socket >= 0) {
						shutdown(client_data_socket,2);
						close(client_data_socket);
						client_data_socket = -1;
					}
					salen = sizeof(listen_sa);
					server_data_socket =
					    accept(server_listen_socket,
					    (struct sockaddr *)&listen_sa,
					    &salen);
					if (server_data_socket < 0) {
						syslog(LOG_NOTICE,
						    "accept failed (%m)");
						exit(EX_OSERR);
					}
					close(server_listen_socket);
					server_listen_socket = -1;
					client_data_socket = socket(AF_INET,
				    	    SOCK_STREAM, 0);
					salen = 1;

					listen_sa.sin_family = AF_INET;

					bzero(&listen_sa.sin_addr,
					    sizeof(struct in_addr));

					debuglog(2, "setting sin_addr to %s\n",
					    inet_ntoa(client_iob.sa.sin_addr));

					listen_sa.sin_port = htons(20);
					salen = 1;
					setsockopt(client_data_socket,
					    SOL_SOCKET, SO_REUSEADDR, &salen,
					    sizeof(salen));
					if (bind(client_data_socket,
					    (struct sockaddr *)&listen_sa,
					    sizeof(listen_sa)) < 0) {
						syslog(LOG_NOTICE,
						    "bind to 20 failed (%m)");
						exit(EX_OSERR);
					}

					if (connect(client_data_socket,
					    (struct sockaddr *)
					    &client_listen_sa,
					    sizeof(client_listen_sa)) != 0) {
						syslog(LOG_INFO,
						   "can't connect (%m)");
						exit(EX_NOHOST);
					}
					client_data_bytes = 0;
					server_data_bytes = 0;
					xfer_start_time = wallclock_time();
				}
				if (client_listen_socket >= 0 &&
				    FD_ISSET(client_listen_socket,fdsp)) {
					struct sockaddr_in listen_sa;
					int salen;

					/*
					 * We are about to accept a
					 * connection from the client.
					 * This is a PASV data
					 * connection.
					 */
					debuglog(2,
					    "client listen socket ready\n");

					if (server_data_socket >= 0) {
						shutdown(server_data_socket,2);
						close(server_data_socket);
						server_data_socket = -1;
					}
					if (client_data_socket >= 0) {
						shutdown(client_data_socket,2);
						close(client_data_socket);
						client_data_socket = -1;
					}
					salen = sizeof(listen_sa);
					client_data_socket =
					    accept(client_listen_socket,
					    (struct sockaddr *)&listen_sa,
					    &salen);
					if (client_data_socket < 0) {
						syslog(LOG_NOTICE,
						   "accept failed (%m)");
						exit(EX_OSERR);
					}

					close(client_listen_socket);
					client_listen_socket = -1;
					memset(&listen_sa, 0,
					    sizeof(listen_sa));
					server_data_socket =
					    get_backchannel_socket(SOCK_STREAM,
					    min_port, max_port, -1, 1,
					    &listen_sa);
					if (server_data_socket < 0) {
						syslog(LOG_NOTICE,
						    "backchannel failed (%m)");
						exit(EX_OSERR);
					}
					if (connect(server_data_socket,
					    (struct sockaddr *)
					    &server_listen_sa,
					    sizeof(server_listen_sa)) != 0) {
						syslog(LOG_NOTICE,
						    "connect failed (%m)");
						exit(EX_NOHOST);
					}
					client_data_bytes = 0;
					server_data_bytes = 0;
					xfer_start_time = wallclock_time();
				}
				if (client_iob.alive &&
				    FD_ISSET(client_iob.fd,fdsp)) {
					client_iob.data_available = 1;
				}

				if (server_iob.alive &&
				    FD_ISSET(server_iob.fd,fdsp)) {
					server_iob.data_available = 1;
				}

d1253 50
a1302 1
			free(fdsp);
d1304 1
a1304 1

a1310 1

d1312 2
a1313 2
			shutdown(client_iob.fd, 1);
			shutdown(server_iob.fd, 0);
d1316 2
a1317 1
		}
@


1.10
log
@decruftify with prejudice
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.9 2001/08/19 17:33:12 beck Exp $ */
d188 1
a188 1
	if (Use_Rdns) {
d195 5
a199 19
		if (Use_Rdns)  {
			i = getnameinfo(
			    (struct sockaddr *) &client_sin->sin_addr,
			    sizeof(&client_sin->sin_addr), cname,
			    sizeof(cname), NULL, 0, NI_NAMEREQD);
			if (i == -1)
				strlcpy(cname, STRING_UNKNOWN, sizeof(cname));

			i = getnameinfo(
			    (struct sockaddr *)&server_sin->sin_addr,
			    sizeof(&server_sin->sin_addr), sname,
			    sizeof(sname), NULL, 0, NI_NAMEREQD);
			if (i == -1)
				strlcpy(sname, STRING_UNKNOWN, sizeof(sname));
		} else {
			/*
			 * ensure the TCP wrapper doesn't start doing
			 * reverse DNS lookups if we aren't supposed to.
			 */
d201 6
d208 7
a214 1
		}
@


1.9
log
@decruftify
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.8 2001/08/19 17:20:34 beck Exp $ */
d602 9
d696 1
a696 1
		u_char ch, *tailptr;
a707 1
		tailptr += 1;	/* Move past the open-parentheses */
a709 21
		while ((ch = *tailptr) == ',' || isdigit(ch)) {
			if (isdigit(ch)) {
				values[byte_number] = values[byte_number]
				    * 10 + ch - '0';
				if (values[byte_number] > 255) {
					syslog(LOG_NOTICE,
					    "malformed 227 reply");
					exit(EX_DATAERR);
				}
			} else if (ch == ',') {
				byte_number += 1;
				if (byte_number < 6) {
					values[byte_number] = 0;
				} else {
					syslog(LOG_NOTICE,
					    "malformed 227 reply");
					exit(EX_DATAERR);
				}
			}
			tailptr += 1;
		}
a710 8
		/*
		 * The PASV reply should be terminated by a closing
		 * parentheses.
		 */
		if (ch != ')') {
			syslog(LOG_INFO, "malformed 227 reply, junk at end");
			exit(EX_DATAERR);
		}
d712 6
a717 4
		/* we need the righr number of bytes for ipv4 and port here */
		if (byte_number != 5) {
			syslog(LOG_NOTICE,
			    "malformed 227 reply, missing bytes");
d720 7
d746 1
a746 1
		    "227 Entering Passive Mode (%u,%u,%u,%u,%u,%u\r\n",
@


1.8
log
@Argh. I must be wearing a stupid sign today
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.7 2001/08/19 15:37:01 beck Exp $ */
d585 1
a585 1
		u_char *tailptr, ch;
a591 24
		while ((ch = *tailptr) == ',' || isdigit(ch)) {
			if (isdigit(ch)) {
				values[byte_number] = values[byte_number]
				  * 10 + ch - '0';
				if (values[byte_number] > 255) {
					syslog(LOG_NOTICE, "%s %s %s",
					    "ERROR - byte value greater",
					    "than 255 in PORT command",
					    "- terminating session");
					exit(EX_DATAERR);
				}
			} else if (ch == ',') {
				byte_number += 1;
				if (byte_number < 6)
					values[byte_number] = 0;
				else {
					syslog(LOG_NOTICE, "%s %s",
					    "too many byte values in PORT",
					    "command - terminating session");
					exit(EX_DATAERR);
				}
			}
			tailptr += 1;
		}
d593 6
a598 3
		if (byte_number != 5) {
			syslog(LOG_NOTICE, "Too few byte values in %s",
			    "PORT command - session terminated");
@


1.7
log
@bye bye atoi.
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.6 2001/08/19 15:19:28 beck Exp $ */
d1011 1
a1011 1
			maxfd = server_data_socket;
@


1.6
log
@oops
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.5 2001/08/19 15:02:02 beck Exp $ */
d680 1
a680 1
	char tbuf[100], *sendbuf;
d697 5
a701 1
	code = atoi((char *)server->line_buffer);
d817 1
d829 3
a831 1
			timeout_seconds = atoi(optarg);
d834 3
a836 1
			Debug_Level = atoi(optarg);
d845 3
a847 1
			min_port = atoi(optarg);
d852 4
a855 2
			max_port = atoi(optarg);
			if (min_port < 0 || min_port > USHRT_MAX)
@


1.5
log
@I'm a knuckle-dragging moron, the fd_set is overflowable - make it so
it isn't.
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.4 2001/08/19 13:43:09 deraadt Exp $ */
d1006 1
a1006 1
		fdsp = (fd_set *)calloc(howmany(maxfd+1, NFDBITS), 
d1044 1
a1044 1
			switch (sval = select(FD_SETSIZE, fdsp, NULL, NULL,
@


1.4
log
@1564 lines of cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.3 2001/08/19 05:50:50 beck Exp $ */
a316 4
/*
 * Are we in PORT mode, PASV mode or unknown mode?
 */

d986 16
a1001 8
		fd_set fds;

		/*
		 * we use a static fd_set here, any individual
		 * instance of this program can't possibly have too
		 * many open files for FD_SETSIZE - we deal here only
		 * with one ftp connection
		 */
d1006 6
a1011 1
		FD_ZERO(&fds);
d1027 1
a1027 1
				FD_SET(client_iob.fd, &fds);
d1029 1
a1029 1
					FD_SET(client_listen_socket, &fds);
d1031 1
a1031 1
					FD_SET(client_data_socket, &fds);
d1034 1
a1034 1
				FD_SET(server_iob.fd, &fds);
d1036 1
a1036 1
					FD_SET(server_listen_socket, &fds);
d1038 1
a1038 1
					FD_SET(server_data_socket, &fds);
d1044 1
a1044 1
			switch (sval = select(FD_SETSIZE, &fds, NULL, NULL,
d1068 1
a1068 1
				    FD_ISSET(client_data_socket,&fds)) {
d1089 1
a1089 1
				    FD_ISSET(server_data_socket,&fds)) {
d1110 1
a1110 1
				    FD_ISSET(server_listen_socket,&fds)) {
d1119 2
a1120 1
					debuglog(2, "server listen socket ready\n");
d1182 1
a1182 1
				    FD_ISSET(client_listen_socket,&fds)) {
d1242 1
a1242 1
				    FD_ISSET(client_iob.fd,&fds)) {
d1247 1
a1247 1
				    FD_ISSET(server_iob.fd,&fds)) {
d1252 1
@


1.3
log
@KNF
@
text
@d1 2
a2 1
/* $OpenBSD: ftp-proxy.c,v 1.2 2001/08/19 05:22:37 beck Exp $ */
d23 1
a23 1
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
d28 1
a28 1
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
d30 1
a30 1
 *   
d57 1
a57 1
 * 
d60 1
a60 1
/* 
d63 2
a64 2
 * 
 * - Ipv6 and EPASV support 
a137 1

d169 1
a169 1
/* 
d184 1
a184 1
	request_init(&request, RQ_DAEMON, __progname, RQ_CLIENT_SIN, 
a188 1

a194 1
		
d198 1
a198 1
			    sizeof(&client_sin->sin_addr), cname, 
d204 2
a205 2
			    (struct sockaddr *)&server_sin->sin_addr, 
			    sizeof(&server_sin->sin_addr), sname, 
d218 1
a218 1
	
d235 1
a235 1
	
d251 1
a251 1
	
d256 2
a257 2
	
	if (delta < 0.001) 
d265 1
a265 1
	
d270 1
a270 1
		
d275 1
a275 1
			    idelta / (60*60), (idelta % (60*60)) / 60, 
a279 1
				
d281 1
a281 1
			i = snprintf(tbuf, len, 
d297 1
a297 1
		i = snprintf(&tbuf[strlen(tbuf)], len, 
d312 3
a314 3
	strlcat(tbuf,")", len);
 logit:	
	syslog(LOG_INFO,"%s",tbuf);
d321 2
a322 2
void 
log_control_command (char * cmd, int client)
d325 1
a325 1
	char * logstring;
d328 1
a328 1
	if (!Verbose) 
d332 1
a332 1
	if (strncasecmp(cmd,"pass ",5) == 0)
d338 4
a341 4
		if ((strncasecmp(cmd,"user ",5) == 0) || 
		    (strncasecmp(cmd,"retr ",5) == 0) ||
		    (strncasecmp(cmd,"cwd ",4) == 0) ||
		    (strncasecmp(cmd,"stor ",5) == 0))
a347 1

a351 1

d355 1
a355 1
	
d359 1
a359 1
	
d378 1
a378 1
	
d381 3
a383 9
		
		server_listen_socket = get_backchannel_socket(
			SOCK_STREAM,
			min_port,
			max_port,
			-1,
			1,
		&server_listen_sa);
		
d385 1
a385 1
			syslog(LOG_INFO,"bind of server socket failed (%m)");
d389 1
a389 1
			syslog(LOG_INFO,"listen on server socket failed (%m)");
a391 1
		
d393 1
a393 2
		bzero(&client_listen_sa, sizeof(client_listen_sa)); 
		
d416 1
a416 1
	char *sendbuf = NULL; 
d419 1
a419 1
	
d423 1
a423 1
	 * we catch them here. 
a424 1
	
d433 3
a436 3
	if (AnonFtpOnly && strncasecmp((char *)client->line_buffer,"user ",
	    strlen("user ")) == 0) {
		char * cp;
d438 2
a439 2
		if ((strcasecmp(cp,"ftp\r\n") != 0) 
		    && (strcasecmp(cp, "anonymous\r\n") != 0)) {
d441 1
a441 1
			 * this isn't anonymous - give the client an 
d444 1
a444 1
			snprintf(tbuf, sizeof(tbuf), 
d450 1
a450 1
				if (rv == -1 && errno != EAGAIN && 
d457 1
a457 1
		} else 
d459 3
a461 3
	} else if ((strncasecmp((char *)client->line_buffer,"eprt ", 
 	    strlen("eprt ")) == 0)) { 
		
d463 3
a466 8
		char *line = NULL; 
		char *q, *p;
		char *result[3];
		char delim;
		struct addrinfo hints;
		struct addrinfo *res = NULL;
		unsigned long proto;
		
d504 3
a506 3
		
		debuglog(1,"client wants us to use %s:%u\n",
		    inet_ntoa(client_listen_sa.sin_addr), 
a511 1

a512 1
		
d515 1
a515 1
		debuglog(1,"we want server to use %s:%u\n",
d517 1
a517 1
		    ntohs(server_listen_sa.sin_port));	 
d520 3
a522 3
		    inet_ntoa(server->sa.sin_addr), 
		    ntohs(server_listen_sa.sin_port));		
		debuglog(1,"to server(modified):  %s",tbuf);
d526 1
a526 1
		snprintf(tbuf, sizeof(tbuf), 
d530 1
a530 1
protounsupp: 
d533 1
a533 1
			snprintf(tbuf, sizeof(tbuf), 
d536 1
a536 1
			snprintf(tbuf, sizeof(tbuf), 
d545 1
a545 1
			debuglog(1, "to client(modified):  %s\n",tbuf);
d549 1
a549 1
				if (rv == -1 && errno != EAGAIN && 
d556 2
a557 2
	} else if (!NatMode && (strncasecmp((char *)client->line_buffer,"epsv",
	    strlen("epsv")) == 0)) { 
d561 1
a561 1
		 * EPSV is a problem - Unliks PASV, the reply from the 
d567 1
a567 1
		 * addtions/deletions in pf. 
d569 1
a569 1
		 * in the meantime we just tell the client we don't do it, 
d572 1
a572 2
		
		snprintf(tbuf, sizeof(tbuf), 
d574 1
a574 1
		debuglog(1, "to client(modified):  %s\n",tbuf);
d585 2
a586 2
	} else if (strncasecmp((char *)client->line_buffer,"port ", 
	    strlen("port ")) == 0) { 
d591 2
a592 2
		debuglog(1,"Got a PORT command\n");
		
d626 1
a626 1
		
d628 7
a634 7
		client_listen_sa.sin_addr.s_addr = htonl((values[0] << 24) 
		    | (values[1] << 16) | (values[2] <<  8) 
		    | (values[3] <<  0));

		client_listen_sa.sin_port = htons((values[4] << 8) 
		    | values[5]);
		debuglog(1,"client wants us to use %u.%u.%u.%u:%u\n",
d637 1
a637 1
		
a640 1

a641 1
		
d643 2
a644 2
		
		debuglog(1,"we want server to use %s:%u\n",
d646 2
a647 2
		    ntohs(server_listen_sa.sin_port));	 
		
d655 3
a657 3
		
		debuglog(1,"to server(modified):  %s",tbuf);
		
d661 2
a662 2
	
	/* 
d684 2
a685 3
	char tbuf[100];
	char *sendbuf;
	
d687 1
a687 1
	
d697 1
a697 1
	
a700 1
	
d703 1
a703 1
		syslog(LOG_INFO,"invalid server reply code %d", code);
d707 2
a708 2
		u_char ch;
		u_char *tailptr;
d710 1
a710 2
		unsigned int values[6];
		
d712 2
a713 2
		debuglog(1, "{%s}\n",(char *)server->line_buffer);
		
d719 1
a719 1
		
d744 1
a744 1
		
a748 1
		
d750 1
a750 1
			syslog(LOG_INFO,"malformed 227 reply, junk at end");
a754 1
		
d760 1
a760 1
		
d764 1
a764 1
		server_listen_sa.sin_port = htons((values[4] << 8) | 
d767 1
a767 1
		debuglog(1,"server wants us to use %s:%u\n",
d770 1
a770 1
		
a771 1
		
a772 1
		
d774 2
a775 2
		
		debuglog(1,"we want client to use %s:%u\n", inet_ntoa(*iap),
d777 1
a777 1
		
d784 1
a784 3
		
		debuglog(1, "to client(modified):  %s\n",tbuf);
		
d786 1
a786 1
	} else 
d789 2
a790 2
	/* 
	 *send our (possibly modified) control command in sendbuf
a792 1

d812 1
a812 1
	int sval, ch, salen, flags, i; 
a855 1
	
d857 1
a857 1
	if (max_port < min_port) 
d861 1
a861 1
	
d864 1
a864 1
	
d867 2
a868 2
	
	if (get_proxy_env(0, &real_server_sa, &client_iob.sa) == -1) 
d870 1
a870 1
	
d872 1
a872 1
	 * We check_host after get_proxy_env so that checks are done 
d878 1
a878 2

	if (Use_Rdns) 
d880 1
a880 1
	else 
d890 1
a890 1
	}	
d892 1
a892 1
	i = getnameinfo((struct sockaddr *)&real_server_sa, 
d899 1
a899 1
	}	
d905 3
a907 4
	
	
	/*  Check to see if we have a timeout defined, if so, 
	 * set a timeout for this select call to that value, so 
d909 1
a909 1
	 * seconds. 
a910 1
	
d912 1
a912 2
	tv.tv_usec = 0;	
	
d914 1
a914 2
	
	
d917 1
a917 1
	
d920 1
a920 1
	
d923 1
a923 1
		
d930 1
a930 1
	
d934 1
a934 1
	 * from the real server's perspective.  
d936 2
a938 3
	i = getnameinfo((struct sockaddr *)&client_iob.sa, 
	    sizeof(client_iob.sa), OurName, sizeof(OurName), NULL, 0, flags);
	
d941 1
a941 1
	
d944 3
a946 3
	
	/* ignore sigpipe */
	
a949 1

d951 1
a951 1
		syslog(LOG_ERR,"sigaction failed (%m)");
d954 1
a954 1
	
d957 1
a957 1
		syslog(LOG_NOTICE,"Can't set SO_OOBINLINE (%m) - exiting");
d960 1
a960 1
		    
d971 1
a971 2
	
	
d974 1
a974 1
	server_iob.io_buffer_size = STARTBUFSIZE; 
d983 2
a984 3
	if (client_iob.line_buffer == NULL  ||  client_iob.io_buffer == NULL
	     || server_iob.line_buffer == NULL || server_iob.io_buffer == NULL)
	    {	
d987 2
a988 3
	    }
	
	
d998 3
a1000 4
		
		debuglog(3,"client is %s, server is %s\n",
			client_iob.alive ? "alive" : "dead",
			server_iob.alive ? "alive" : "dead");
d1003 2
a1004 2
		
		if (client_iob.alive && telnet_getline(&client_iob, 
d1008 1
a1008 1
			if (client_iob.line_buffer[0] != '\0') 
d1012 1
a1012 1
			debuglog(3,"server line buffer is \"%s\"\n",
d1014 1
a1014 1
			if (server_iob.line_buffer[0] != '\0') 
d1019 1
a1019 1
				if (client_listen_socket >= 0) 
d1025 1
a1025 1
				FD_SET(server_iob.fd, &fds); 
d1028 1
a1028 1
				if (server_data_socket >= 0) 
a1030 1
			
d1032 1
a1032 1
			tv.tv_usec = 0;	
d1038 3
a1040 3
				/* 
				 * This proxy has timed out. Expire it 
				 * quietly with an obituary in the syslogs 
d1043 1
a1043 1
				syslog(LOG_INFO, 
d1046 1
a1046 1
				exit(EX_OK); 
d1048 1
a1048 1
				
d1050 1
a1050 1
				if (errno == EINTR  || errno == EAGAIN)
d1056 1
a1056 1
				
d1061 2
a1062 1
					debuglog(3,"xfer client to server\n");
d1076 1
a1076 1
					} else 
d1082 2
a1083 2
					
					debuglog(3,"xfer server to client\n");
d1097 1
a1097 1
					} else 
d1103 1
a1103 1
					
d1105 1
a1105 1
					 * We are about to accept a 
d1110 2
a1111 4
					
					debuglog(2,
					    "server listen socket ready\n");
					
d1139 1
a1139 1
					
d1142 2
a1143 2
					
					debuglog(2,"setting sin_addr to %s\n",
d1145 1
a1145 1
					
d1151 3
a1153 3
					if (bind(client_data_socket, 
					     (struct sockaddr *)&listen_sa,
					     sizeof(listen_sa)) < 0) {
d1158 1
a1158 1
					
d1175 1
a1175 1
					
d1180 1
a1180 1
					 * connection. 
a1181 1
					
d1184 1
a1184 1
					
d1196 1
a1196 1
					client_data_socket = 
d1201 1
a1201 1
						syslog(LOG_NOTICE, 
d1205 1
a1205 1
					
d1235 1
a1235 1
				
d1240 1
a1240 1
				
d1243 1
a1243 1
		
d1245 2
a1246 2
			shutdown(server_iob.fd,1);
			shutdown(client_iob.fd,0);
d1250 1
a1250 1
		
d1252 2
a1253 2
			shutdown(client_iob.fd,1);
			shutdown(server_iob.fd,0);
a1256 1
		
@


1.2
log
@gratuitous KNFism's, don't have it looking like it's your first day
with your new crack pipe
@
text
@d1 1
a1 1
/* $OpenBSD: ftp-proxy.c,v 1.1 2001/08/19 04:11:12 beck Exp $ */
d283 1
a283 2
		}
		else {
d473 2
a474 2
	}

d476 1
a476 6
	/*
	 * Watch out for EPRT commands.
	 */
	
	else if ((strncasecmp((char *)client->line_buffer,"eprt ", 
 	    strlen("eprt ")) == 0)) { 
@


1.1
log
@transparent ftp proxy, based on Obtuse Systems juniper stuff with much
modernizing and cleanup. still needs looking at.

Currently supports PORT PASV EPRT data connections with only a pf rdr to
capture the control connection. (I.E. you don't need ip forwarding
or other NAT stuff). Runs from inetd.

Supports all passive (EPSV PASV) when using -n flag, where the proxy
ignores passive mode data connections (and assumes nat will get them
through).

Todo yet:
	More audit
	IpV6
	Handle EPSV in proxy (with an rdr added then removed)
	Option to Daemonize and bind only to the loopback
	More Content/Login filtering, etc. etc. and more bloat
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d797 4
a800 8
		server_listen_sa.sin_addr.s_addr = htonl(
			(values[0] << 24) |
			(values[1] << 16) |
			(values[2] <<  8) |
			(values[3] <<  0)
			);
		server_listen_sa.sin_port = htons((values[4] << 8)
						  | values[5]);
d803 2
a804 2
			inet_ntoa(server_listen_sa.sin_addr),
			(values[4] << 8) | values[5]);
d813 1
a813 2
		    (((u_char *)&client_listen_sa.sin_port)[0] << 8)
			| ((u_char *)&client_listen_sa.sin_port)[1]);
@

