head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.19.0.18
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.16
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.12
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.14
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.10
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2016.03.16.14.47.04;	author mestre;	state Exp;
branches;
next	1.26;
commitid	JhTzEE4nWLnICvzM;

1.26
date	2015.12.11.17.16.52;	author beck;	state Exp;
branches;
next	1.25;
commitid	q1C4i45vO0GUB39V;

1.25
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	3o2AkhiRPQXvG94X;

1.24
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2014.10.25.03.19.22;	author lteo;	state Exp;
branches;
next	1.22;
commitid	H62Mb5ByK9fun2vA;

1.22
date	2013.08.21.16.13.30;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2011.03.18.22.37.06;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.04.21.01.49;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.05.14.55.09;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.05.14.53.42;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.04.03.25.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.04.03.19.41;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.04.21.41.37;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.03.19.39.33;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.26.13.27.57;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.25.19.17.55;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.18.07.33.03;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.16.05.35.02;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.10.16.06.01;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.14.21.22.18;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.11.17.48.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.10.00.35.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.07.20.20.07;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.01.17.03.10;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.18.25.49;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.26.07.28.55;	author beck;	state Exp;
branches;
next	;


desc
@@


1.27
log
@- Check if user running spamlogd(8) has root privileges and if not then stop
program early
- #define SPAMD_USER "_spamd" and use it on getpwnam(3) call
- Set usage() as __dead void
- Remove lint-style comments

OK beck@@
@
text
@/*	$OpenBSD: spamlogd.c,v 1.26 2015/12/11 17:16:52 beck Exp $	*/

/*
 * Copyright (c) 2006 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2006 Berk D. Demir.
 * Copyright (c) 2004-2007 Bob Beck.
 * Copyright (c) 2001 Theo de Raadt.
 * Copyright (c) 2001 Can Erkin Acar.
 * All rights reserved
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* watch pf log for mail connections, update whitelist entries. */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/signal.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <net/pfvar.h>
#include <net/if_pflog.h>

#include <db.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>
#include <unistd.h>
#include <pcap.h>

#include "grey.h"
#include "sync.h"

#define MIN_PFLOG_HDRLEN	45
#define PCAPSNAP		512
#define PCAPTIMO		500	/* ms */
#define PCAPOPTZ		1	/* optimize filter */
#define PCAPFSIZ		512	/* pcap filter string size */

#define SPAMD_USER		"_spamd"

int debug = 1;
int greylist = 1;
FILE *grey = NULL;

u_short sync_port;
int syncsend;
u_int8_t		 flag_debug = 0;
u_int8_t		 flag_inbound = 0;
char			*networkif = NULL;
char			*pflogif = "pflog0";
char			 errbuf[PCAP_ERRBUF_SIZE];
pcap_t			*hpcap = NULL;
struct syslog_data	 sdata	= SYSLOG_DATA_INIT;
time_t			 whiteexp = WHITEEXP;
extern char		*__progname;

void	logmsg(int , const char *, ...);
void	sighandler_close(int);
int	init_pcap(void);
void	logpkt_handler(u_char *, const struct pcap_pkthdr *, const u_char *);
int	dbupdate(char *, char *);
__dead void	usage(void);

void
logmsg(int pri, const char *msg, ...)
{
	va_list	ap;
	va_start(ap, msg);

	if (flag_debug) {
		vfprintf(stderr, msg, ap);
		fprintf(stderr, "\n");
	} else
		vsyslog_r(pri, &sdata, msg, ap);

	va_end(ap);
}

void
sighandler_close(int signal)
{
	if (hpcap != NULL)
		pcap_breakloop(hpcap);	/* sighdlr safe */
}

int
init_pcap(void)
{
	struct bpf_program	bpfp;
	char	filter[PCAPFSIZ] = "ip and port 25 and action pass "
		    "and tcp[13]&0x12=0x2";

	if ((hpcap = pcap_open_live(pflogif, PCAPSNAP, 1, PCAPTIMO,
	    errbuf)) == NULL) {
		logmsg(LOG_ERR, "Failed to initialize: %s", errbuf);
		return (-1);
	}

	if (pcap_datalink(hpcap) != DLT_PFLOG) {
		logmsg(LOG_ERR, "Invalid datalink type");
		pcap_close(hpcap);
		hpcap = NULL;
		return (-1);
	}

	if (networkif != NULL) {
		strlcat(filter, " and on ", PCAPFSIZ);
		strlcat(filter, networkif, PCAPFSIZ);
	}

	if (pcap_compile(hpcap, &bpfp, filter, PCAPOPTZ, 0) == -1 ||
	    pcap_setfilter(hpcap, &bpfp) == -1) {
		logmsg(LOG_ERR, "%s", pcap_geterr(hpcap));
		return (-1);
	}

	pcap_freecode(&bpfp);

	if (ioctl(pcap_fileno(hpcap), BIOCLOCK) < 0) {
		logmsg(LOG_ERR, "BIOCLOCK: %s", strerror(errno));
		return (-1);
	}

	return (0);
}

void
logpkt_handler(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	sa_family_t		 af;
	u_int8_t		 hdrlen;
	u_int32_t		 caplen = h->caplen;
	const struct ip		*ip = NULL;
	const struct pfloghdr	*hdr;
	char			 ipstraddr[40] = { '\0' };

	hdr = (const struct pfloghdr *)sp;
	if (hdr->length < MIN_PFLOG_HDRLEN) {
		logmsg(LOG_WARNING, "invalid pflog header length (%u/%u). "
		    "packet dropped.", hdr->length, MIN_PFLOG_HDRLEN);
		return;
	}
	hdrlen = BPF_WORDALIGN(hdr->length);

	if (caplen < hdrlen) {
		logmsg(LOG_WARNING, "pflog header larger than caplen (%u/%u). "
		    "packet dropped.", hdrlen, caplen);
		return;
	}

	/* We're interested in passed packets */
	if (hdr->action != PF_PASS)
		return;

	af = hdr->af;
	if (af == AF_INET) {
		ip = (const struct ip *)(sp + hdrlen);
		if (hdr->dir == PF_IN)
			inet_ntop(af, &ip->ip_src, ipstraddr,
			    sizeof(ipstraddr));
		else if (hdr->dir == PF_OUT && !flag_inbound)
			inet_ntop(af, &ip->ip_dst, ipstraddr,
			    sizeof(ipstraddr));
	}

	if (ipstraddr[0] != '\0') {
		if (hdr->dir == PF_IN)
			logmsg(LOG_DEBUG,"inbound %s", ipstraddr);
		else 
			logmsg(LOG_DEBUG,"outbound %s", ipstraddr);
		dbupdate(PATH_SPAMD_DB, ipstraddr);
	}
}

int
dbupdate(char *dbname, char *ip)
{
	HASHINFO	hashinfo;
	DBT		dbk, dbd;
	DB		*db;
	struct gdata	gd;
	time_t		now;
	int		r;
	struct in_addr	ia;

	now = time(NULL);
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_HASH, &hashinfo);
	if (db == NULL) {
		logmsg(LOG_ERR, "Can not open db %s: %s", dbname,
		    strerror(errno));
		return (-1);
	}
	if (inet_pton(AF_INET, ip, &ia) != 1) {
		logmsg(LOG_NOTICE, "Invalid IP address %s", ip);
		goto bad;
	}
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(ip);
	dbk.data = ip;
	memset(&dbd, 0, sizeof(dbd));

	/* add or update whitelist entry */
	r = db->get(db, &dbk, &dbd, 0);
	if (r == -1) {
		logmsg(LOG_NOTICE, "db->get failed (%m)");
		goto bad;
	}

	if (r) {
		/* new entry */
		memset(&gd, 0, sizeof(gd));
		gd.first = now;
		gd.bcount = 1;
		gd.pass = now;
		gd.expire = now + whiteexp;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(ip);
		dbk.data = ip;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		if (r) {
			logmsg(LOG_NOTICE, "db->put failed (%m)");
			goto bad;
		}
	} else {
		/* XXX - backwards compat */
		if (gdcopyin(&dbd, &gd) == -1) {
			/* whatever this is, it doesn't belong */
			db->del(db, &dbk, 0);
			goto bad;
		}
		gd.pcount++;
		gd.expire = now + whiteexp;
		memset(&dbk, 0, sizeof(dbk));
		dbk.size = strlen(ip);
		dbk.data = ip;
		memset(&dbd, 0, sizeof(dbd));
		dbd.size = sizeof(gd);
		dbd.data = &gd;
		r = db->put(db, &dbk, &dbd, 0);
		if (r) {
			logmsg(LOG_NOTICE, "db->put failed (%m)");
			goto bad;
		}
	}
	db->close(db);
	db = NULL;
	if (syncsend)
		sync_white(now, now + whiteexp, ip);
	return (0);
 bad:
	db->close(db);
	db = NULL;
	return (-1);
}

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-DI] [-i interface] [-l pflog_interface] "
	    "[-W whiteexp] [-Y synctarget]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int		 ch;
	struct passwd	*pw;
	pcap_handler	 phandler = logpkt_handler;
	int syncfd = 0;
	struct servent *ent;
	char *sync_iface = NULL;
	char *sync_baddr = NULL;
	const char *errstr;

	if (geteuid())
		errx(1, "need root privileges");

	if ((ent = getservbyname("spamd-sync", "udp")) == NULL)
		errx(1, "Can't find service \"spamd-sync\" in /etc/services");
	sync_port = ntohs(ent->s_port);

	while ((ch = getopt(argc, argv, "DIi:l:W:Y:")) != -1) {
		switch (ch) {
		case 'D':
			flag_debug = 1;
			break;
		case 'I':
			flag_inbound = 1;
			break;
		case 'i':
			networkif = optarg;
			break;
		case 'l':
			pflogif = optarg;
			break;
		case 'W':
			/* limit whiteexp to 2160 hours (90 days) */
			whiteexp = strtonum(optarg, 1, (24 * 90), &errstr);
			if (errstr)
				usage();
			/* convert to seconds from hours */
			whiteexp *= (60 * 60);
			break;
		case 'Y':
			if (sync_addhost(optarg, sync_port) != 0)
				sync_iface = optarg;
			syncsend++;
			break;
		default:
			usage();
		}
	}

	signal(SIGINT , sighandler_close);
	signal(SIGQUIT, sighandler_close);
	signal(SIGTERM, sighandler_close);

	logmsg(LOG_DEBUG, "Listening on %s for %s %s", pflogif,
	    (networkif == NULL) ? "all interfaces." : networkif,
	    (flag_inbound) ? "Inbound direction only." : "");

	if (init_pcap() == -1)
		err(1, "couldn't initialize pcap");

	if (syncsend) {
		syncfd = sync_init(sync_iface, sync_baddr, sync_port);
		if (syncfd == -1)
			err(1, "sync init");
	}

	/* privdrop */
	if ((pw = getpwnam(SPAMD_USER)) == NULL)
		errx(1, "no such user %s", SPAMD_USER);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		err(1, "failed to drop privs");

	if (!flag_debug) {
		if (daemon(0, 0) == -1)
			err(1, "daemon");
		tzset();
		openlog_r("spamlogd", LOG_PID | LOG_NDELAY, LOG_DAEMON, &sdata);
	}

	if (syncsend) {
		if (pledge("stdio rpath wpath inet flock", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath wpath flock", NULL) == -1)
			err(1, "pledge");
	}

	pcap_loop(hpcap, -1, phandler, NULL);

	logmsg(LOG_NOTICE, "exiting");
	if (!flag_debug)
		closelog_r(&sdata);

	exit(0);
}
@


1.26
log
@pledge spamlogd - again from  Ricardo Mestre <serial@@helheim.mooo.com> - Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.25 2015/01/21 21:50:33 deraadt Exp $	*/
d63 2
d86 1
a86 1
void	usage(void);
a102 1
/* ARGSUSED */
a150 1
/* ARGSUSED */
d306 3
a341 1
			/* NOTREACHED */
d363 2
a364 3
	pw = getpwnam("_spamd");
	if (pw == NULL)
		errx(1, "User '_spamd' not found! ");
@


1.25
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.24 2015/01/16 06:39:50 deraadt Exp $	*/
d375 8
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.23 2014/10/25 03:19:22 lteo Exp $	*/
a31 1
#include <net/if_pflog.h>
d38 1
@


1.23
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.22 2013/08/21 16:13:30 millert Exp $	*/
d29 1
@


1.22
log
@Remove the use of time_t in the greylist db file and use int64_t instead
with backwards compatibility for records with 32-bit times.
OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.21 2011/03/18 22:37:06 okan Exp $	*/
a33 1
#include <netinet/in_systm.h>
@


1.21
log
@actually set and use whiteexp in the new -W option.

my goof noticed by Boudewijn Dijkstra.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.20 2011/03/04 21:01:49 okan Exp $	*/
d253 2
a254 1
		if (dbd.size != sizeof(gd)) {
a258 1
		memcpy(&gd, dbd.data, sizeof(gd));
@


1.20
log
@add -W flag (whiteexp), as opposed to pulling in a hardcoded default
value from spamd/grey.c; mostly from ohauer@@gmx.de in PR/6142.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.19 2007/03/05 14:55:09 beck Exp $	*/
d297 1
a297 1
	int		 ch, i;
d326 1
a326 1
			i = strtonum(optarg, 1, (24 * 90), &errstr);
@


1.19
log
@nuke annoying debug log
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.18 2007/03/05 14:53:42 beck Exp $	*/
d76 1
d240 1
a240 1
		gd.expire = now + WHITEEXP;
d260 1
a260 1
		gd.expire = now + WHITEEXP;
d276 1
a276 1
		sync_white(now, now + WHITEEXP, ip);
d288 2
a289 1
	    "usage: %s [-DI] [-i interface] [-l pflog_interface] [-Y synctarget]\n",
d297 1
a297 1
	int		 ch;
d304 1
d310 1
a310 1
	while ((ch = getopt(argc, argv, "DIi:l:Y:")) != -1) {
d323 8
@


1.18
log
@Make spamlogd log inbound/outbound like it did before.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.17 2007/03/04 03:25:54 deraadt Exp $	*/
d274 1
a274 2
	if (syncsend) {
		syslog_r(LOG_DEBUG, &sdata, "sync_white %s,", ip);
a275 1
	}
@


1.17
log
@cleanup usage
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.16 2007/03/04 03:19:41 beck Exp $	*/
d190 4
a193 1
		logmsg(LOG_DEBUG,"add %s to db", ipstraddr);
@


1.16
log
@
Database synchronizaton for spamd/spamlogd

This adds an HMAC protected synchronization protocol for use by spamd and
spamlogd.

- spamd can receive updates from other hosts for GREY, WHITE, and TRAPPED db
entries, and will update the local /var/db/spamd accordingly.

- spamd can send updates when it makes changes to the GREY or TRAPPED
entries in the db to other hosts running spamd. (Note it does not send
WHITE entries because the other spamd will see the GREY changes and have
complete information to make appropritate decisions)

- spamlogd can send updates for WHITE db entries that it performs on the local
db to other hosts running spamd, which will then apply them on remote hosts.

note that while this diff provides synchronization for changes made to the
spamd db by the daemons, it does *not* provide for sychonizing changes
to the spamd db made manually with the spamdb command.

Synchronization protocol and most of the work by reyk@@,
with a bunch of the spamd, and spamlogd stuff by me.

testing mostly at the U of A, running happily there under big load.

ok reyk@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.15 2007/01/04 21:41:37 beck Exp $	*/
d285 2
a286 1
	fprintf(stderr, "usage: %s [-DI] [-i interface] [-l pflog_interface] [-Y synctarget ]\n",
@


1.15
log
@        Using DB_BTREE for spamd is wrong, order is never required
and the rebalancing really slags big databases. Make spamd use DB_HASH
instead, and convert if the old type is noticed on startup.

Testing by me, djm, ian, others
ok deraadt@@, millert@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.14 2006/11/03 19:39:33 henning Exp $	*/
d44 1
d55 1
d63 6
d271 4
d285 1
a285 1
	fprintf(stderr, "usage: %s [-DI] [-i interface] [-l pflog_interface]\n",
d296 8
d305 1
a305 1
	while ((ch = getopt(argc, argv, "DIi:l:")) != -1) {
d319 5
d340 6
@


1.14
log
@donot for tcpdump, use libpcap directly.
joint work with Berk D. Demir, ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.13 2006/10/26 13:27:57 jmc Exp $	*/
d6 1
a6 1
 * Copyright (c) 2004 Bob Beck.
d190 1
a190 1
	BTREEINFO	btreeinfo;
d199 2
a200 2
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
@


1.13
log
@- sort options
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.12 2006/10/25 19:17:55 henning Exp $	*/
d4 6
a9 1
 * Copyright (c) 2004 Bob Beck.  All rights reserved.
d28 5
d34 2
d37 3
d42 1
d44 1
d46 1
d51 1
a53 1
#define PATH_TCPDUMP "/usr/sbin/tcpdump"
d55 85
a139 2
struct syslog_data sdata = SYSLOG_DATA_INIT;
int inbound; /* do we only whitelist inbound smtp? */
d141 45
a185 1
extern char *__progname;
d201 5
a205 2
	if (db == NULL)
		return(-1);
d207 1
a207 1
		syslog_r(LOG_NOTICE, &sdata, "invalid ip address %s", ip);
d214 1
d218 1
a218 1
		syslog_r(LOG_NOTICE, &sdata, "db->get failed (%m)");
d221 1
d237 1
a237 1
			syslog_r(LOG_NOTICE, &sdata, "db->put failed (%m)");
d257 1
a257 1
			syslog_r(LOG_NOTICE, &sdata, "db->put failed (%m)");
d270 1
a270 1
static void
d273 1
a273 1
	fprintf(stderr, "usage: %s [-I] [-i interface] [-l pflog_interface]\n",
a277 7
char *targv[19] = {
	"tcpdump", "-l",  "-n", "-e", "-i", "pflog0", "-q",
	"-t", "port", "25", "and", "action", "pass",
	"and", "tcp[13]&0x12=0x2",
	NULL, NULL, NULL, NULL
};

d281 3
a283 4
	int ch, p[2];
	char *buf, *lbuf;
	size_t len;
	FILE *f;
d285 1
a285 2

	while ((ch = getopt(argc, argv, "l:i:I")) != -1) {
d287 2
a288 6
		case 'i':
			if (targv[17])	/* may only set once */
				usage();
			targv[15] = "and";
			targv[16] = "on";
			targv[17] = optarg;
d291 4
a294 1
			inbound = 1;
d297 1
a297 1
			targv[5] = optarg;
d301 1
a301 1
			break;
d305 27
a331 38
	if (daemon(1, 1) == -1)
		err(1, "daemon");
	if (pipe(p) == -1)
		err(1, "pipe");
	switch (fork()) {
	case -1:
		err(1, "fork");
	case 0:
		/* child */
		close(p[0]);
		close(STDERR_FILENO);
		if (dup2(p[1], STDOUT_FILENO) == -1) {
			warn("dup2");
			_exit(1);
		}
		close(p[1]);
		execvp(PATH_TCPDUMP, targv);
		warn("exec of %s failed", PATH_TCPDUMP);
		_exit(1);
	}

	/* parent */
	close(p[1]);
	f = fdopen(p[0], "r");
	if (f == NULL)
		err(1, "fdopen");
	tzset();
	openlog_r("spamlogd", LOG_PID | LOG_NDELAY, LOG_DAEMON, &sdata);

	lbuf = NULL;
	while ((buf = fgetln(f, &len))) {
		char *cp = NULL;
		char *buf2;

		if ((buf2 = malloc(len + 1)) == NULL) {
			syslog_r(LOG_ERR, &sdata, "malloc failed");
			exit(1);
		}
d333 1
a333 11
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = (char *)malloc(len + 1)) == NULL) {
				syslog_r(LOG_ERR, &sdata, "malloc failed");
				exit(1);
			}
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
d335 3
a337 41
		if (strstr(buf, "pass out") != NULL) {
			/*
			 * this is outbound traffic - we whitelist
			 * the destination address, because we assume
			 * that a reply may come to this outgoing mail
			 * we are sending.
			 */
			if (!inbound && (cp = (strchr(buf, '>'))) != NULL) {
				if (sscanf(cp, "> %s", buf2) == 1) {
					cp = strrchr(buf2, '.');
					if (cp != NULL) {
						*cp = '\0';
						cp = buf2;
						syslog_r(LOG_DEBUG, &sdata,
						    "outbound %s\n", cp);
					}
				} else
					cp = NULL;
			}

		} else {
			/*
			 * this is inbound traffic - we whitelist
			 * the source address, because this is
			 * traffic presumably to our real MTA
			 */
			if ((cp = (strchr(buf, '>'))) != NULL) {
				while (*cp != '.' && cp >= buf) {
					*cp = '\0';
					cp--;
				}
				*cp ='\0';
				while (*cp != ' ' && cp >= buf)
					cp--;
				cp++;
				syslog_r(LOG_DEBUG, &sdata,
				    "inbound %s\n", cp);
			}
		}
		if (cp != NULL)
			dbupdate(PATH_SPAMD_DB, cp);
a338 4
		free(lbuf);
		lbuf = NULL;
		free(buf2);
	}
@


1.12
log
@allow spamlogd to use an alternate pflog interface
spamlogd was the #1 reason for me to implement the multiple pflog thing,
so now you can finally have a nice seperation between logging and spamlogd
tracking smtp connections
joint work with djm, ok djm bob and kinda "Berk D. Demir" <bdd@@mindcast.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.11 2004/09/18 07:33:03 beck Exp $	*/
d123 1
a123 1
	fprintf(stderr, "usage: %s [-I] [-i interface] [-l pflog-interface]\n",
@


1.11
log
@fix pr 3914, spamd doesn't log only incoming with -I,
and change to look only at S/SA so people logging all crud don't
get slaughtered by entries.
again from mike@@tric.tomsk.gov.ru
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.10 2004/09/16 05:35:02 deraadt Exp $	*/
d123 2
a124 1
	fprintf(stderr, "usage: %s [-I] [-i interface]\n", __progname);
d144 1
a144 1
	while ((ch = getopt(argc, argv, "i:I")) != -1) {
d155 3
@


1.10
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.9 2004/08/10 16:06:01 otto Exp $	*/
d127 1
a127 1
char *targv[17] = {
d130 1
d146 1
a146 1
			if (targv[15])	/* may only set once */
d148 3
a150 3
			targv[13] = "and";
			targv[14] = "on";
			targv[15] = optarg;
d212 1
a212 1
		if (!inbound && strstr(buf, "pass out") != NULL) {
d219 1
a219 1
			if ((cp = (strchr(buf, '>'))) != NULL) {
@


1.9
log
@Variable size arrays are not ANSI C. Replace by malloc/free.
ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.8 2004/07/14 21:22:18 jmc Exp $	*/
d120 1
a120 1
static int
a138 1
	pid_t pid;
d164 1
a164 1
	switch (pid = fork()) {
@


1.8
log
@sync usage() w/ SYNOPSIS;
from Andrey Matveev;
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.7 2004/03/11 17:48:59 millert Exp $	*/
d193 6
a198 1
		char buf2[len + 1];
d256 1
@


1.7
log
@Remove sync() calls that immediately precede databse close().  Since
close() calls sync() itself the standalone sync() is a no-op.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.6 2004/03/10 00:35:55 deraadt Exp $	*/
d123 1
a123 1
	fprintf(stderr, "usage: %s [-I] [-i netif]\n", __progname);
@


1.6
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.5 2004/03/07 20:20:07 otto Exp $	*/
a110 1
	db->sync(db, 0);
a114 1
	db->sync(db, 0);
@


1.5
log
@remove some unused variables and includes; KNF
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.4 2004/03/01 17:03:10 otto Exp $	*/
d48 3
a50 3
	struct gdata 	gd;
	time_t 		now;
	int 		r;
d191 1
a191 1
	
d210 1
a210 1
			/* 
d222 2
a223 2
						syslog_r(LOG_DEBUG, &sdata, 
							 "outbound %s\n", cp);
d225 1
a225 2
				}
				else
d230 1
a230 1
			/* 
d232 1
a232 1
			 * the source address, because this is 
d244 2
a245 3
				syslog_r(LOG_DEBUG, &sdata, 
					 "inbound %s\n", cp);
				
@


1.4
log
@uset inet_pton(3) instead of home grown address validator; some other cleanup
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.3 2004/02/27 18:25:49 beck Exp $	*/
a22 4
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <net/if.h>
a23 1
#include <net/pfvar.h>
a26 1
#include <errno.h>
a27 1
#include <pwd.h>
a31 1
#include <time.h>
a36 4
extern struct passwd *pw;
extern FILE * grey;
extern int debug;

a37 2
size_t whitecount, whitealloc;
char **whitelist;
d39 2
a40 1
int pfdev;
d119 1
a119 1
	return(-1);
d125 1
a125 1
	fprintf(stderr, "usage: spamlogd [-I] [-i netif]\n");
@


1.3
log
@make spamlogd watch the destination of outbound smtp connections,
so that replies to mail sent out do not get greylisting delays.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamlogd.c,v 1.2 2004/02/26 08:18:56 deraadt Exp $	*/
a54 14
/* borrowed from dhartmei.. */
static int
address_valid_v4(const char *a)
{
	if (!*a)
		return (0);
	while (*a)
		if ((*a >= '0' && *a <= '9') || *a == '.')
			a++;
		else
			return (0);
	return (1);
}

d64 1
d71 1
a71 1
	if (!address_valid_v4(ip)) {
d266 2
a267 4
		if (lbuf != NULL) {
			free(lbuf);
			lbuf = NULL;
		}
@


1.2
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
d49 1
d52 1
a54 5
DB		*db;
DBT		dbk, dbd;
BTREEINFO	btreeinfo;


d72 6
a77 3
	struct gdata gd;
	time_t now;
	int r;
d85 1
a85 1
		warnx("invalid ip address %s\n", ip);
d95 1
a95 1
		warn("db->get failed");
d113 1
a113 1
			warn("db->put failed");
d133 1
a133 1
			warn("db->put failed");
d151 1
a151 1
	fprintf(stderr, "usage: spamlogd [-i netif]\n");
d155 1
a155 1
char *targv[19] = {
d157 1
a157 1
	"-t", "inbound", "and", "port", "25", "and", "action", "pass",
d170 2
a171 1
	while ((ch = getopt(argc, argv, "i:")) != -1) {
d174 1
a174 1
			if (targv[17])	/* may only set once */
d176 6
a181 3
			targv[15] = "and";
			targv[16] = "on";
			targv[17] = optarg;
d215 3
d220 2
a221 1
		char *cp;
d226 4
a229 2
			if ((lbuf = (char *)malloc(len + 1)) == NULL)
				err(1, NULL);
d234 20
a253 5
		if ((cp = (strchr(buf, '>'))) != NULL) {
			/* XXX replace this grot with an sscanf */
			while (*cp != '.' && cp >= buf) {
				*cp = '\0';
				cp--;
d255 22
a276 4
			*cp ='\0';
			while (*cp != ' ' && cp >= buf)
				cp--;
			cp++;
d278 1
a278 1
		}
@


1.1
log
@Add -g option for greylisting support for spamd. The greylisting techinque
originates from a paper by Evan Harris which can be found at
http://projects.puremagic.com/greylisting/. This implementation makes
spamd allow for non-blacklisted addresses to be treated as "greylisted".
where they are tracked in a db file, and whitelisted by addition to a
pf table when the same envelope from and to are retried from the same
source IP address. Testing by many, ok deraadt@@
@
text
@d1 2
d138 1
d143 1
d151 1
a151 1
	exit(-1);
d172 2
d206 1
@

