head	1.16;
access;
symbols
	OPENBSD_6_1:1.15.0.6
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.24
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.26
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.20
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.18
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.16
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.14
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.12
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2017.05.27.07.39.27;	author tedu;	state Exp;
branches;
next	1.15;
commitid	C3VxY3vwnv2nGAaT;

1.15
date	2016.04.25.15.43.34;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	I3EQuSEiFuZ6Sj6q;

1.14
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.20.20.37.43;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.02.02.21.15;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.06.21.57.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.26.07.53.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.06.19.43.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.05.00.21.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.28.01.04.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.08.21.18.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.19.34.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.17.19.23.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.22.03.41.18;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove support for OSF
@
text
@/*	$OpenBSD: rwalld.c,v 1.15 2016/04/25 15:43:34 deraadt Exp $	*/

/*
 * Copyright (c) 1993 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <pwd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>
#include <rpc/rpc.h>
#include <rpcsvc/rwall.h>

#define WALL_CMD "/usr/bin/wall -n"

void wallprog_1(struct svc_req *, SVCXPRT *);

int from_inetd = 1;

static void
cleanup(int signo)
{
	(void) pmap_unset(WALLPROG, WALLVERS);		/* XXX signal race */
	_exit(0);
}

int
main(int argc, char *argv[])
{
	int sock = 0, proto = 0;
	socklen_t fromlen;
	struct sockaddr_storage from;
	SVCXPRT *transp;

	struct passwd *pw = getpwnam("_rwalld");
	if (pw == NULL) {
		syslog(LOG_ERR, "no such user _rwalld");
		exit(1);
	}

	setgroups(1, &pw->pw_gid);
	setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
	setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);

	/*
	 * See if inetd started us
	 */
	fromlen = sizeof(from);
	if (getsockname(0, (struct sockaddr *)&from, &fromlen) < 0) {
		from_inetd = 0;
		sock = RPC_ANYSOCK;
		proto = IPPROTO_UDP;
	}

	if (!from_inetd) {
		daemon(0, 0);

		(void) pmap_unset(WALLPROG, WALLVERS);

		(void) signal(SIGINT, cleanup);
		(void) signal(SIGTERM, cleanup);
		(void) signal(SIGHUP, cleanup);
	}

	openlog("rpc.rwalld", LOG_CONS|LOG_PID, LOG_DAEMON);

	transp = svcudp_create(sock);
	if (transp == NULL) {
		syslog(LOG_ERR, "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, WALLPROG, WALLVERS, wallprog_1, proto)) {
		syslog(LOG_ERR, "unable to register (WALLPROG, WALLVERS, %s).",
		    proto ? "udp" : "(inetd)");
		exit(1);
	}

	svc_run();
	syslog(LOG_ERR, "svc_run returned");
	exit(1);

}

void *
wallproc_wall_1_svc(char **s, struct svc_req *rqstp)
{
	FILE *pfp;

	pfp = popen(WALL_CMD, "w");
	if (pfp != NULL) {
		fprintf(pfp, "\007\007%s", *s);
		pclose(pfp);
	}

	return (*s);
}

void
wallprog_1(struct svc_req *rqstp, SVCXPRT *transp)
{
	char *(*local)(char **, struct svc_req *);
	xdrproc_t xdr_argument, xdr_result;
	union {
		char *wallproc_wall_1_arg;
	} argument;
	char *result;

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void)svc_sendreply(transp, xdr_void, (char *)NULL);
		goto leave;

	case WALLPROC_WALL:
		xdr_argument = (xdrproc_t)xdr_wrapstring;
		xdr_result = (xdrproc_t)xdr_void;
		local = (char *(*)(char **, struct svc_req *))
		    wallproc_wall_1_svc;
		break;

	default:
		svcerr_noproc(transp);
		goto leave;
	}
	bzero((char *)&argument, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		goto leave;
	}
	result = (*local)((char **)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (caddr_t)&argument)) {
		syslog(LOG_ERR, "unable to free arguments");
		exit(1);
	}
leave:
	if (from_inetd)
		exit(0);
}
@


1.15
log
@prefer setres{u,g}id() rather than manipulating both real and effective
ids, it clarifies these are full revocation situations.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.14 2009/10/27 23:59:31 deraadt Exp $	*/
a45 3
#ifdef OSF
#define WALL_CMD "/usr/sbin/wall"
#else
a46 1
#endif
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.13 2009/05/20 20:37:43 thib Exp $	*/
d78 2
a79 4
	setegid(pw->pw_gid);
	setgid(pw->pw_gid);
	seteuid(pw->pw_uid);
	setuid(pw->pw_uid);
@


1.13
log
@Do not fall back to using nobody if _user is missing, but
error out.

Add a new user _rwalld for rpc.rwalld, and use that instead
of nobody, also unconditionally drop to _rwalld not only
if rpc.rwalld was started with euid 0 (as root).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.11 2003/07/06 21:57:27 deraadt Exp $	*/
a30 4

#ifndef lint
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.11 2003/07/06 21:57:27 deraadt Exp $";
#endif /* not lint */
@


1.12
log
@IPv6 support.

From NetBSD

ok millert@@
@
text
@d75 5
a79 2
	if (geteuid() == 0) {
		struct passwd *pw = getpwnam("nobody");
d81 5
a85 11
		if (pw) {
			setgroups(1, &pw->pw_gid);
			setegid(pw->pw_gid);
			setgid(pw->pw_gid);
			seteuid(pw->pw_uid);
			setuid(pw->pw_uid);
		} else {
			seteuid(getuid());
			setuid(getuid());
		}
	}
@


1.11
log
@bring protos into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.10 2003/06/26 07:53:26 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.10 2003/06/26 07:53:26 deraadt Exp $";
d72 1
a72 1
	struct sockaddr_in from;
@


1.10
log
@simple protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.9 2002/09/06 19:43:54 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.9 2002/09/06 19:43:54 deraadt Exp $";
d60 1
a60 1
void
@


1.9
log
@use socklen_t more; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.8 2002/09/05 00:21:24 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.8 2002/09/05 00:21:24 deraadt Exp $";
d56 1
a56 1
void wallprog_1();
@


1.8
log
@kill groups too when we revoke privs
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.7 2002/06/28 01:04:15 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.7 2002/06/28 01:04:15 deraadt Exp $";
d70 2
a71 1
	int sock = 0, proto = 0, fromlen;
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.6 2002/02/16 21:27:31 millert Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.6 2002/02/16 21:27:31 millert Exp $";
d75 1
a75 1
		struct passwd *pep = getpwnam("nobody");
d77 6
a82 3
		if (pep) {
			seteuid(pep->pw_uid);
			setuid(pep->pw_uid);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.5 2001/07/08 21:18:11 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.5 2001/07/08 21:18:11 deraadt Exp $";
d61 1
a61 1
cleanup()
d68 1
a68 3
main(argc, argv)
	int argc;
	char *argv[];
d70 2
a72 4
	int sock = 0;
	int proto = 0;
	struct sockaddr_in from;
	int fromlen;
d76 1
d80 1
a80 2
		}
		else {
d114 2
a115 1
		syslog(LOG_ERR, "unable to register (WALLPROG, WALLVERS, %s).", proto?"udp":"(inetd)");
d126 1
a126 3
wallproc_wall_1_svc(s, rqstp )
	char **s;
	struct svc_req *rqstp;
d140 1
a140 3
wallprog_1(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
d142 2
a147 2
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(char **, struct svc_req *);
d158 1
a158 1
			wallproc_wall_1_svc;
@


1.5
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rwalld.c,v 1.4 2001/01/28 19:34:32 niklas Exp $	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.4 2001/01/28 19:34:32 niklas Exp $";
d154 1
a154 1
	char *(*local) __P((char **, struct svc_req *));
d164 1
a164 1
		local = (char *(*) __P((char **, struct svc_req *)))
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD: rwalld.c,v 1.3 2001/01/17 19:23:27 deraadt Exp $";
a35 1
#include <unistd.h>
d37 2
d40 1
d45 1
a45 1
#include <sys/socket.h>
a46 1
#include <sys/wait.h>
d67 1
@


1.3
log
@use _exit() in signal handlers, and flag that the pmap_unset() calls are unsafe
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: rwalld.c,v 1.2 1996/12/22 03:41:18 tholo Exp $";
@


1.2
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: rwalld.c,v 1.1.1.1 1995/10/18 08:43:21 deraadt Exp $";
d60 2
a61 2
	(void) pmap_unset(WALLPROG, WALLVERS);
	exit(0);
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: rwalld.c,v 1.9 1995/07/09 00:30:17 pk Exp $";
d76 2
a77 1
		if (pep)
d79 3
a81 1
		else
d83 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
