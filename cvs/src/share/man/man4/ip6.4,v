head	1.40;
access;
symbols
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.33.0.8
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.6
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.10
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.8
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@.\" @;


1.40
date	2016.06.28.17.32.58;	author jca;	state Exp;
branches;
next	1.39;
commitid	YvDBjhrwkQL4A58z;

1.39
date	2016.06.28.11.23.57;	author jca;	state Exp;
branches;
next	1.38;
commitid	mxY2sjY4QhjIl06P;

1.38
date	2016.06.27.16.33.48;	author jca;	state Exp;
branches;
next	1.37;
commitid	s8BpQvqrMutiVjd6;

1.37
date	2016.05.19.21.02.21;	author jmc;	state Exp;
branches;
next	1.36;
commitid	SezKEitSKn2zYZsh;

1.36
date	2016.05.19.12.08.17;	author jmc;	state Exp;
branches;
next	1.35;
commitid	huxEuMaHBdGlnSy2;

1.35
date	2015.11.03.02.17.45;	author jca;	state Exp;
branches;
next	1.34;
commitid	91UPuEoGUUCXLjnB;

1.34
date	2015.10.25.14.43.07;	author florian;	state Exp;
branches;
next	1.33;
commitid	YdNR4Tx8Af0XRTgT;

1.33
date	2014.06.11.16.59.47;	author chrisz;	state Exp;
branches;
next	1.32;
commitid	eCVZBBFwEoAYGCDT;

1.32
date	2013.10.27.18.29.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.10.07.07.12;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.26.17.34.38;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.17.21.12.42;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.17.20.01.26;	author yasuoka;	state Exp;
branches;
next	1.26;

1.26
date	2012.06.20.07.37.01;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.08.16.43.56;	author giovanni;	state Exp;
branches;
next	1.24;

1.24
date	2011.08.25.14.39.29;	author haesbaert;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.31.04.46.32;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.31.19.19.50;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.06.03.50.46;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.02.18.18.15;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.01.03.35.53;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.31.21.26.40;	author jaredy;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.20.03.26.43;	author itojun;	state dead;
branches;
next	1.16;

1.16
date	2003.08.08.09.51.53;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.06.10.29.41;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.30.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.18.23.53.49;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.26.07.55.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.05.14.45.53;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.10.28.20;	author wilfried;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.05.57.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.02.33.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.22.12.15.45;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.16.11.17;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.24.10.25.12;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.03.21.19.36;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.12.22.06.52.28;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.20.04.34.21;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.19.03.14.27;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.40
log
@IP_MINTTL and IPV6_MINHOPCOUNT work on TCP and UDP sockets

Input from and ok bluhm@@
@
text
@.\"	$OpenBSD: ip6.4,v 1.39 2016/06/28 11:23:57 jca Exp $
.\"
.\" Copyright (c) 1983, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.Dd $Mdocdate: June 28 2016 $
.Dt IP6 4
.Os
.Sh NAME
.Nm ip6
.Nd Internet Protocol version 6 (IPv6) network layer
.Sh SYNOPSIS
.In sys/types.h
.In sys/socket.h
.In netinet/in.h
.Ft int
.Fn socket AF_INET6 SOCK_RAW proto
.Sh DESCRIPTION
The IPv6 network layer is used by the IPv6 protocol family for
transporting data.
IPv6 packets contain an IPv6 header that is not provided as part of the
payload contents when passed to an application.
IPv6 header options affect the behavior of this protocol and may be used
by high-level protocols (such as the
.Xr tcp 4
and
.Xr udp 4
protocols) as well as directly by
.Dq raw sockets ,
which process IPv6 messages at a lower-level and may be useful for
developing new protocols and special-purpose applications.
.Ss Header
All IPv6 packets begin with an IPv6 header.
When data received by the kernel are passed to the application, this
header is not included in buffer, even when raw sockets are being used.
Likewise, when data are sent to the kernel for transmit from the
application, the buffer is not examined for an IPv6 header:
the kernel always constructs the header.
To directly access IPv6 headers from received packets and specify them
as part of the buffer passed to the kernel, link-level access
.Po
.Xr bpf 4 ,
for example
.Pc
must instead be utilized.
.Pp
The header has the following definition:
.Bd -literal -offset indent
struct ip6_hdr {
     union {
          struct ip6_hdrctl {
               u_int32_t ip6_un1_flow;	/* 20 bits of flow ID */
               u_int16_t ip6_un1_plen;	/* payload length */
               u_int8_t	 ip6_un1_nxt;	/* next header */
               u_int8_t	 ip6_un1_hlim;	/* hop limit */
          } ip6_un1;
          u_int8_t ip6_un2_vfc;   /* version and class */
     } ip6_ctlun;
     struct in6_addr ip6_src;	/* source address */
     struct in6_addr ip6_dst;	/* destination address */
} __packed;

#define ip6_vfc		ip6_ctlun.ip6_un2_vfc
#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt		ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim
.Ed
.Pp
All fields are in network-byte order.
Any options specified (see
.Sx Options
below) must also be specified in network-byte order.
.Pp
.Va ip6_flow
specifies the flow ID.
.Va ip6_plen
specifies the payload length.
.Va ip6_nxt
specifies the type of the next header.
.Va ip6_hlim
specifies the hop limit.
.Pp
The top 4 bits of
.Va ip6_vfc
specify the class and the bottom 4 bits specify the version.
.Pp
.Va ip6_src
and
.Va ip6_dst
specify the source and destination addresses.
.Pp
The IPv6 header may be followed by any number of extension headers that start
with the following generic definition:
.Bd -literal -offset indent
struct ip6_ext {
     u_int8_t ip6e_nxt;
     u_int8_t ip6e_len;
} __packed;
.Ed
.Ss Options
IPv6 allows header options on packets to manipulate the behavior of the
protocol.
These options and other control requests are accessed with the
.Xr getsockopt 2
and
.Xr setsockopt 2
system calls at level
.Dv IPPROTO_IPV6
and by using ancillary data in
.Xr recvmsg 2
and
.Xr sendmsg 2 .
They can be used to access most of the fields in the IPv6 header and
extension headers.
.Pp
The following socket options are supported:
.Bl -tag -width Ds
.It Dv IPV6_UNICAST_HOPS Fa "int *"
Get or set the default hop limit header field for outgoing unicast
datagrams sent on this socket.
A value of \-1 resets to the default value.
.It Dv IPV6_MINHOPCOUNT Fa "int *"
Get or set the minimum hop limit header field for incoming
packets received on TCP and UDP sockets.
This can be used to implement the
.Em Generalized TTL Security Mechanism (GTSM)
according to RFC 5082.
.It Dv IPV6_MULTICAST_IF Fa "u_int *"
Get or set the interface from which multicast packets will be sent.
For hosts with multiple interfaces, each multicast transmission is sent
from the primary network interface.
The interface is specified as its index as provided by
.Xr if_nametoindex 3 .
A value of zero specifies the default interface.
.It Dv IPV6_MULTICAST_HOPS Fa "int *"
Get or set the default hop limit header field for outgoing multicast
datagrams sent on this socket.
This option controls the scope of multicast datagram transmissions.
.Pp
Datagrams with a hop limit of 1 are not forwarded beyond the local
network.
Multicast datagrams with a hop limit of zero will not be transmitted on
any network but may be delivered locally if the sending host belongs to
the destination group and if multicast loopback (see below) has not been
disabled on the sending socket.
Multicast datagrams with a hop limit greater than 1 may be forwarded to
the other networks if a multicast router (such as
.Xr mrouted 8 )
is attached to the local network.
.It Dv IPV6_MULTICAST_LOOP Fa "u_int *"
Get or set the status of whether multicast datagrams will be looped back
for local delivery when a multicast datagram is sent to a group to which
the sending host belongs.
.Pp
This option improves performance for applications that may have no more
than one instance on a single host (such as a router daemon) by
eliminating the overhead of receiving their own transmissions.
It should generally not be used by applications for which there may be
more than one instance on a single host (such as a conferencing program)
or for which the sender does not belong to the destination group
(such as a time-querying program).
.Pp
A multicast datagram sent with an initial hop limit greater than 1 may
be delivered to the sending host on a different interface from that on
which it was sent if the host belongs to the destination group on that
other interface.
The multicast loopback control option has no effect on such delivery.
.It Dv IPV6_JOIN_GROUP Fa "struct ipv6_mreq *"
Join a multicast group.
A host must become a member of a multicast group before it can receive
datagrams sent to the group.
.Bd -literal
struct ipv6_mreq {
	struct in6_addr	ipv6mr_multiaddr;
	unsigned int	ipv6mr_interface;
};
.Ed
.Pp
.Va ipv6mr_interface
may be set to zeroes to choose the default multicast interface or to the
index of a particular multicast-capable interface if the host is
multihomed.
Membership is associated with a single interface; programs running on
multihomed hosts may need to join the same group on more than one
interface.
.Pp
If the multicast address is unspecified (i.e., all zeroes), messages
from all multicast addresses will be accepted by this group.
Note that setting to this value requires superuser privileges.
.It Dv IPV6_LEAVE_GROUP Fa "struct ipv6_mreq *"
Drop membership from the associated multicast group.
Memberships are automatically dropped when the socket is closed or when
the process exits.
.It Dv IPV6_PORTRANGE Fa "int *"
Get or set the allocation policy of ephemeral ports for when the kernel
automatically binds a local address to this socket.
The following values are available:
.Pp
.Bl -tag -width IPV6_PORTRANGE_DEFAULT -compact
.It Dv IPV6_PORTRANGE_DEFAULT
Use the regular range of non-reserved ports (varies, see
.Xr sysctl 8 ) .
.It Dv IPV6_PORTRANGE_HIGH
Use a high range (varies, see
.Xr sysctl 8 ) .
.It Dv IPV6_PORTRANGE_LOW
Use a low, reserved range (600\-1023).
.El
.It Dv IPV6_RECVPKTINFO Fa "int *"
Get or set whether additional information about subsequent packets will
be provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The information is stored in the following structure in the ancillary
data returned:
.Bd -literal
struct in6_pktinfo {
	struct in6_addr ipi6_addr;    /* src/dst IPv6 address */
	unsigned int    ipi6_ifindex; /* send/recv if index */
};
.Ed
.Pp
Turning this option on will result in this socket getting cmsg data of
type IPV6_PKTINFO.
.It Dv IPV6_RECVHOPLIMIT Fa "int *"
Get or set whether the hop limit header field from subsequent packets
will be provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The value is stored as an
.Vt int
in the ancillary data returned.
Turning this option on will result in this socket getting cmsg data of
type IPV6_HOPLIMIT.
.It Dv IPV6_RECVHOPOPTS Fa "int *"
Get or set whether the hop-by-hop options from subsequent packets will be
provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The option is stored in the following structure in the ancillary data
returned:
.Bd -literal
struct ip6_hbh {
	u_int8_t ip6h_nxt;	/* next header */
	u_int8_t ip6h_len;	/* length in units of 8 octets */
/* followed by options */
} __packed;
.Ed
.Pp
The
.Fn inet6_opt_init
routine and family of routines may be used to manipulate this data.
.Pp
This option requires superuser privileges.
Turning this option on will result in this socket getting cmsg data of
type IPV6_HOPOPTS.
.It Dv IPV6_RECVDSTOPTS Fa "int *"
Get or set whether the destination options from subsequent packets will
be provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The option is stored in the following structure in the ancillary data
returned:
.Bd -literal
struct ip6_dest {
	u_int8_t ip6d_nxt;	/* next header */
	u_int8_t ip6d_len;	/* length in units of 8 octets */
/* followed by options */
} __packed;
.Ed
.Pp
The
.Fn inet6_opt_init
routine and family of routines may be used to manipulate this data.
.Pp
This option requires superuser privileges.
Turning this option on will result in this socket getting cmsg data of
type IPV6_DSTOPTS.
.It Dv IPV6_TCLASS Fa "int *"
Get or set the value of the traffic class field used for outgoing datagrams
on this socket.
The value must be between \-1 and 255.
A value of \-1 resets to the default value.
.It Dv IPV6_RECVTCLASS Fa "int *"
Get or set the status of whether the traffic class header field will be
provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The header field is stored as a single value of type
.Vt int .
.It Dv IPV6_RECVRTHDR Fa "int *"
Get or set whether the routing header from subsequent packets will be
provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The header is stored in the following structure in the ancillary data
returned:
.Bd -literal
struct ip6_rthdr {
	u_int8_t ip6r_nxt;	/* next header */
	u_int8_t ip6r_len;	/* length in units of 8 octets */
	u_int8_t ip6r_type;	/* routing type */
	u_int8_t ip6r_segleft;	/* segments left */
/* followed by routing-type-specific data */
} __packed;
.Ed
.Pp
The
.Fn inet6_rth_space
routine and family of routines may be used to manipulate this data.
.Pp
This option requires superuser privileges.
Turning this option on will result in this socket getting cmsg data of
type IPV6_RTHDR.
.It Dv IPV6_CHECKSUM Fa "int *"
Get or set the byte offset into a packet where the 16-bit checksum is
located.
When set, this byte offset is where incoming packets will be expected
to have checksums of their data stored and where outgoing packets will
have checksums of their data computed and stored by the kernel.
A value of \-1 specifies that no checksums will be checked on incoming
packets and that no checksums will be computed or stored on outgoing
packets.
The offset of the checksum for ICMPv6 sockets cannot be relocated or
turned off.
.It Dv IPV6_V6ONLY Fa "int *"
Get or set whether only IPv6 connections can be made to this socket.
For wildcard sockets, this can restrict connections to IPv6 only.
With
.Ox
IPv6 sockets are always IPv6-only, so the socket option is read-only
(not modifiable).
.It Dv IPV6_USE_MIN_MTU Fa "int *"
Get or set whether the minimal IPv6 maximum transmission unit (MTU) size
will be used to avoid fragmentation from occurring for subsequent
outgoing datagrams.
.It Dv IPV6_AUTH_LEVEL Fa "int *"
Get or set the
.Xr ipsec 4
authentication level.
.It Dv IPV6_ESP_TRANS_LEVEL Fa "int *"
Get or set the ESP transport level.
.It Dv IPV6_ESP_NETWORK_LEVEL Fa "int *"
Get or set the ESP encapsulation level.
.It Dv IPV6_IPCOMP_LEVEL Fa "int *"
Get or set the
.Xr ipcomp 4
level.
.It Dv IPV6_RECVDSTPORT Fa "int *"
Get or set the status of whether the destination port for a UDP datagram
will be provided as ancillary data along with the payload in subsequent
.Xr recvmsg 2
calls.
The information is stored as a single value of type
.Vt u_int16_t
in network byte order.
.Pp
Turning this option on will result in this socket getting cmsg data of
type IPV6_RECVDSTPORT.
.El
.Pp
The
.Dv IPV6_RECVPKTINFO ,
.Dv IPV6_RECVHOPLIMIT ,
.Dv IPV6_RECVHOPOPTS ,
.Dv IPV6_RECVDSTOPTS ,
and
.Dv IPV6_RTHDR
options will return ancillary data along with payload contents in subsequent
.Xr recvmsg 2
calls with
.Va cmsg_level
set to
.Dv IPPROTO_IPV6
and
.Va cmsg_type
set to respective option name value (e.g.,
.Dv IPV6_HOPLIMIT ) .
These options may also be used directly as ancillary
.Va cmsg_type
values in
.Xr sendmsg 2
to set options on the packet being transmitted by the call.
The
.Va cmsg_level
value must be
.Dv IPPROTO_IPV6 .
For these options, the ancillary data object value format is the same
as the value returned as explained for each when received with
.Xr recvmsg 2 .
.Pp
Note that using
.Xr sendmsg 2
to specify options on particular packets works only on UDP and raw sockets.
To manipulate header options for packets on TCP sockets, only the socket
options may be used.
.Pp
In some cases, there are multiple APIs defined for manipulating an IPv6
header field.
A good example is the outgoing interface for multicast datagrams, which
can be set by the
.Dv IPV6_MULTICAST_IF
socket option, through the
.Dv IPV6_RECVPKTINFO
option, and through the
.Va sin6_scope_id
field of the socket address passed to the
.Xr sendto 2
system call.
.Pp
Resolving these conflicts is implementation dependent.
This implementation determines the value in the following way:
options specified by using ancillary data (i.e.,
.Xr sendmsg 2 )
are considered first,
options specified by using the individual, basic, and direct socket
options (e.g.,
.Dv IPV6_UNICAST_HOPS )
are considered second,
and options specified in the socket address supplied to
.Xr sendto 2
are the last choice.
.Ss Multicasting
IPv6 multicasting is supported only on
.Dv AF_INET6
sockets of type
.Dv SOCK_DGRAM
and
.Dv SOCK_RAW ,
and only on networks where the interface driver supports
multicasting.
Socket options (see above) that manipulate membership of
multicast groups and other multicast options include
.Dv IPV6_MULTICAST_IF ,
.Dv IPV6_MULTICAST_HOPS ,
.Dv IPV6_MULTICAST_LOOP ,
.Dv IPV6_LEAVE_GROUP ,
and
.Dv IPV6_JOIN_GROUP .
.Ss Raw Sockets
Raw IPv6 sockets are connectionless and are normally used with the
.Xr sendto 2
and
.Xr recvfrom 2
calls, although the
.Xr connect 2
call may be used to fix the destination address for future outgoing
packets so that
.Xr send 2
may instead be used and the
.Xr bind 2
call may be used to fix the source address for future outgoing
packets instead of having the kernel choose a source address.
.Pp
By using
.Xr connect 2
or
.Xr bind 2 ,
raw socket input is constrained to only packets with their
source address matching the socket destination address if
.Xr connect 2
was used and to packets with their destination address
matching the socket source address if
.Xr bind 2
was used.
.Pp
If the
.Ar proto
argument to
.Xr socket 2
is zero, the default protocol
.Pq Dv IPPROTO_RAW
is used for outgoing packets.
For incoming packets, protocols recognized by kernel are
.Sy not
passed to the application socket (e.g.,
.Xr tcp 4
and
.Xr udp 4 )
except for some ICMPv6 messages.
The ICMPv6 messages not passed to raw sockets include echo, timestamp,
and address mask requests.
If
.Ar proto
is non-zero, only packets with this protocol will be passed to the
socket.
.Pp
IPv6 fragments are also not passed to application sockets until
they have been reassembled.
If reception of all packets is desired, link-level access (such as
.Xr bpf 4 )
must be used instead.
.Pp
Outgoing packets automatically have an IPv6 header prepended to them
(based on the destination address and the protocol number the socket
was created with).
Incoming packets are received by an application without the IPv6 header
or any extension headers.
.Pp
Outgoing packets will be fragmented automatically by the kernel if they
are too large.
Incoming packets will be reassembled before being sent to the raw socket,
so packet fragments or fragment headers will never be seen on a raw socket.
.Sh EXAMPLES
The following determines the hop limit on the next packet received:
.Bd -literal
struct iovec iov[2];
u_char buf[BUFSIZ];
struct cmsghdr *cm;
struct msghdr m;
int found, optval;
u_char data[2048];

/* Create socket. */

(void)memset(&m, 0, sizeof(m));
(void)memset(&iov, 0, sizeof(iov));

iov[0].iov_base = data;		/* buffer for packet payload */
iov[0].iov_len = sizeof(data);	/* expected packet length */

m.msg_name = &from;		/* sockaddr_in6 of peer */
m.msg_namelen = sizeof(from);
m.msg_iov = iov;
m.msg_iovlen = 1;
m.msg_control = (caddr_t)buf;	/* buffer for control messages */
m.msg_controllen = sizeof(buf);

/*
 * Enable the hop limit value from received packets to be
 * returned along with the payload.
 */
optval = 1;
if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &optval,
    sizeof(optval)) == -1)
	err(1, "setsockopt");

found = 0;
while (!found) {
	if (recvmsg(s, &m, 0) == -1)
		err(1, "recvmsg");
	for (cm = CMSG_FIRSTHDR(&m); cm != NULL;
	     cm = CMSG_NXTHDR(&m, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int))) {
			found = 1;
			(void)printf("hop limit: %d\en",
			    *(int *)CMSG_DATA(cm));
			break;
		}
	}
}
.Ed
.Sh DIAGNOSTICS
A socket operation may fail with one of the following errors returned:
.Bl -tag -width EADDRNOTAVAILxx
.It Bq Er EISCONN
when trying to establish a connection on a socket which
already has one or when trying to send a datagram with the destination
address specified and the socket is already connected.
.It Bq Er ENOTCONN
when trying to send a datagram, but
no destination address is specified, and the socket hasn't been
connected.
.It Bq Er ENOBUFS
when the system runs out of memory for
an internal data structure.
.It Bq Er EADDRNOTAVAIL
when an attempt is made to create a
socket with a network address for which no network interface
exists.
.It Bq Er EACCES
when an attempt is made to create
a raw IPv6 socket by a non-privileged process.
.El
.Pp
The following errors specific to IPv6 may occur when setting or getting
header options:
.Bl -tag -width EADDRNOTAVAILxx
.It Bq Er EINVAL
An unknown socket option name was given.
.It Bq Er EINVAL
An ancillary data object was improperly formed.
.El
.Sh SEE ALSO
.Xr getsockopt 2 ,
.Xr recv 2 ,
.Xr send 2 ,
.Xr setsockopt 2 ,
.Xr socket 2 ,
.\" .Xr inet6_opt_init 3 ,
.\" .Xr inet6_rth_space 3 ,
.Xr if_nametoindex 3 ,
.Xr bpf 4 ,
.Xr icmp6 4 ,
.Xr inet6 4 ,
.Xr netintro 4 ,
.Xr tcp 4 ,
.Xr udp 4
.Sh STANDARDS
.Rs
.%A S. Deering
.%A R. Hinden
.%D December 1998
.%R RFC 2460
.%T Internet Protocol, Version 6 (IPv6) Specification
.Re
.Pp
.Rs
.%A R. Gilligan
.%A S. Thomson
.%A J. Bound
.%A J. McCann
.%A W. Stevens
.%D February 2003
.%R RFC 3493
.%T Basic Socket Interface Extensions for IPv6
.Re
.Pp
.Rs
.%A W. Stevens
.%A M. Thomas
.%A E. Nordmark
.%A T. Jinmei
.%D May 2003
.%R RFC 3542
.%T Advanced Sockets Application Program Interface (API) for IPv6
.Re
.Pp
The
.Dv IPV6_PORTRANGE
socket option and the conflict resolution rule are not defined in the
RFCs and should be considered implementation dependent.
@


1.39
log
@IPV6_MINHOPCOUNT now supports UDP (unicast and multicast)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.38 2016/06/27 16:33:48 jca Exp $
d29 1
a29 1
.Dd $Mdocdate: June 27 2016 $
d149 1
a149 1
packets received on this socket.
@


1.38
log
@Implement IPV6_MINHOPCOUNT support.

Useful to implement GTSM support in daemons such as bgpd(8). Diff from
2013 revived by renato@@.  Input from bluhm@@, ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.37 2016/05/19 21:02:21 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: May 19 2016 $
d148 2
a149 4
Get or set the minimum hop limit header field for incoming unicast
datagrams received on this
.Dv SOCK_STREAM
socket.
@


1.37
log
@revert this part of my last commit: sthen points out that this text
concerns sockets, and is still present;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.36 2016/05/19 12:08:17 jmc Exp $
d147 8
@


1.36
log
@no more v6only;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.35 2015/11/03 02:17:45 jca Exp $
d29 1
a29 1
.Dd $Mdocdate: November 3 2015 $
d345 7
@


1.35
log
@RFC2292 and IPV6_PKTOPTIONS are dead; ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.34 2015/10/25 14:43:07 florian Exp $
d29 1
a29 1
.Dd $Mdocdate: October 25 2015 $
a344 7
.It Dv IPV6_V6ONLY Fa "int *"
Get or set whether only IPv6 connections can be made to this socket.
For wildcard sockets, this can restrict connections to IPv6 only.
With
.Ox
IPv6 sockets are always IPv6-only, so the socket option is read-only
(not modifiable).
@


1.34
log
@Remove IPV6_NEXTHOP implementation. Source routing is considered to be
a bad idea these days.
kill it mpi@@
general agreement in the network hackers room at u2k15
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.33 2014/06/11 16:59:47 chrisz Exp $
d29 1
a29 1
.Dd $Mdocdate: June 11 2014 $
a333 29
.It Dv IPV6_PKTOPTIONS Fa "struct cmsghdr *"
Get or set all header options and extension headers at one time on the
last packet sent or received on the socket.
All options must fit within the size of an mbuf (see
.Xr mbuf 9 ) .
Options are specified as a series of
.Vt cmsghdr
structures followed by corresponding values.
.Va cmsg_level
is set to
.Dv IPPROTO_IPV6 ,
.Va cmsg_type
to one of the other values in this list, and trailing data to the option
value.
When setting options, if the length
.Va optlen
to
.Xr setsockopt 2
is zero, all header options will be reset to their default values.
Otherwise, the length should specify the size the series of control
messages consumes.
.Pp
Instead of using
.Xr sendmsg 2
to specify option values, the ancillary data used in these calls that
correspond to the desired header options may be directly specified as
the control message in the series of control messages provided as the
argument to
.Xr setsockopt 2 .
a434 5
options specified by using
.Dv IPV6_PKTOPTIONS
to set
.Dq sticky
options are considered second,
d438 1
a438 1
are considered third,
@


1.33
log
@Remove manpages about deprecated RFC2292 ancillary data convenience functions.
They are obsoleted by the RFC3542 api.

ok mpi@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.32 2013/10/27 18:29:02 deraadt Exp $
d29 1
a29 1
.Dd $Mdocdate: October 27 2013 $
a253 11
.It Dv IPV6_NEXTHOP Fa "int *"
Get or set whether the address of the next hop for subsequent
packets will be provided as ancillary data along with the payload in
subsequent
.Xr recvmsg 2
calls.
The option is stored as a
.Vt sockaddr
structure in the ancillary data returned.
.Pp
This option requires superuser privileges.
@


1.32
log
@remove chunks about options we do not have, and uncomment the ones we
do have.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.31 2013/07/10 07:07:12 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: July 10 2013 $
d281 1
a281 1
.Fn inet6_option_space
d303 1
a303 1
.Fn inet6_option_space
d339 1
a339 1
.Fn inet6_option_space
d656 2
a657 2
.\" .Xr inet6_option_space 3 ,
.\" .Xr inet6_rthdr_space 3 ,
@


1.31
log
@rfc 3493 obsoletes 2553. i spotted this after reading hiroki sato's changes
in freebsd src commit r253066. our man pages had been updated, but i must
have missed the following:

- getnameinfo.3: 2553 -> 3493
- ip6.4: we listed both. remove 2553.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.30 2013/03/14 11:18:37 mpi Exp $
d29 1
a29 1
.Dd $Mdocdate: March 14 2013 $
a142 1
.\" .It Dv IPV6_OPTIONS
a146 11
.\" .It Dv IPV6_RECVOPTS Fa "int *"
.\" Get or set the status of whether all header options will be
.\" delivered along with the datagram when it is received.
.\" .It Dv IPV6_RECVRETOPTS Fa "int *"
.\" Get or set the status of whether header options will be delivered
.\" for reply.
.\" .It Dv IPV6_RECVDSTADDR Fa "int *"
.\" Get or set the status of whether datagrams are received with
.\" destination addresses.
.\" .It Dv IPV6_RETOPTS
.\" Get or set IPv6 options.
d254 11
a264 11
.\" .It Dv IPV6_NEXTHOP Fa "int *"
.\" Get or set whether the address of the next hop for subsequent
.\" packets will be provided as ancillary data along with the payload in
.\" subsequent
.\" .Xr recvmsg 2
.\" calls.
.\" The option is stored as a
.\" .Vt sockaddr
.\" structure in the ancillary data returned.
.\" .Pp
.\" This option requires superuser privileges.
a422 1
.\" .Dv IPV6_RECVNEXTHOP ,
@


1.30
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.29 2012/09/26 17:34:38 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: September 26 2012 $
a684 10
.Re
.Pp
.Rs
.%A R. Gilligan
.%A S. Thomson
.%A J. Bound
.%A W. Stevens
.%D March 1999
.%R RFC 2553
.%T Basic Socket Interface Extensions for IPv6
@


1.29
log
@last stage of rfc changes, using consistent Rs/Re blocks, and moving the
references into a STANDARDS section;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.28 2012/09/17 21:12:42 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: September 17 2012 $
a403 4
.It Dv IPV6_FAITH Fa "int *"
Get or set the status of whether
.Xr faith 4
connections can be made to this socket.
@


1.28
log
@zap trailing whitespace;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.27 2012/09/17 20:01:26 yasuoka Exp $
d682 1
d686 2
a688 2
.%R RFC 2460
.%D December 1998
d690 1
d696 2
a698 2
.%R RFC 2553
.%D March 1999
d700 1
d702 4
d707 3
a709 3
.%A B. Fenner
.%A A. Rudoff
.%T UNIX Network Programming, third edition
d711 1
d717 2
a719 2
.%R RFC 3542
.%D May 2003
d721 1
a721 5
.Sh STANDARDS
Most of the socket options are defined in RFC 2553 or RFC 3542.
The
.Dv IPV6_V6ONLY
socket option is defined in RFC 3493.
@


1.27
log
@add IPV6_RECVDSTPORT socket option, which enables us to get original
(= before divert) destination port of a UDP packet.  The way to use
this option is same as IP_RECVDSTPORT.

from UMEZAWA Takeshi
tweaks from jmc; ok henning bluhm
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.26 2012/06/20 07:37:01 guenther Exp $
d29 1
a29 1
.Dd $Mdocdate: June 20 2012 $
d426 1
a426 1
will be provided as ancillary data along with the payload in subsequent 
@


1.26
log
@Reflect the changes made by RFC 3542

From Peter J Philipp (pjp at centroid.eu)
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.25 2011/09/08 16:43:56 giovanni Exp $
d29 1
a29 1
.Dd $Mdocdate: September 8 2011 $
d424 11
@


1.25
log
@
sys/types.h is needed before sys/socket.h
spotted by Thomas de Grivel, ok matthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.24 2011/08/25 14:39:29 haesbaert Exp $
d29 1
a29 1
.Dd $Mdocdate: August 25 2011 $
d240 1
a240 1
.It Dv IPV6_PKTINFO Fa "int *"
d253 4
a256 1
.It Dv IPV6_HOPLIMIT Fa "int *"
d264 2
d277 1
a277 1
.It Dv IPV6_HOPOPTS Fa "int *"
d297 3
a299 1
.It Dv IPV6_DSTOPTS Fa "int *"
d319 2
d333 1
a333 1
.It Dv IPV6_RTHDR Fa "int *"
d355 2
d427 5
a431 5
.Dv IPV6_PKTINFO ,
.\" .Dv IPV6_NEXTHOP ,
.Dv IPV6_HOPLIMIT ,
.Dv IPV6_HOPOPTS ,
.Dv IPV6_DSTOPTS ,
d443 1
a443 1
.Dv IPV6_HOPTLIMIT ) .
d469 1
a469 1
.Dv IPV6_PKTINFO
d604 1
a604 1
if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &optval,
a671 7
.%A W. Stevens
.%A M. Thomas
.%T Advanced Sockets API for IPv6
.%R RFC 2292
.%D February 1998
.Re
.Rs
d693 9
d703 1
a703 1
Most of the socket options are defined in RFC 2292 or RFC 2553.
@


1.24
log
@Document IPV6_TCLASS and IPV6_RECVTCLASS in ip6(4). Text from FreeBSD.

ok mcbride@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.23 2009/08/31 04:46:32 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: August 31 2009 $
d36 1
@


1.23
log
@IPV6_V6ONLY is defined in RFC 3493, not 3542;
from Kenji Rikitake, freebsd pr docs/134127
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.22 2007/05/31 19:19:50 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: May 31 2007 $
d311 12
@


1.22
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.21 2005/01/06 03:50:46 itojun Exp $
d29 1
a29 1
.Dd $Mdocdate$
d680 1
a680 1
socket option is defined in RFC 3542.
@


1.21
log
@IPv6 manpage, wrote from scratch.  deraadt ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.20 2005/01/02 18:18:15 jmc Exp $
d29 1
a29 1
.Dd December 29, 2004
@


1.20
log
@remove broken Xrs;
ok jaredy@@
@
text
@d1 2
a2 1
.\"	$OpenBSD: ip6.4,v 1.19 2005/01/01 03:35:53 jmc Exp $
d376 4
d677 4
a680 1
Most of the socket options are defined in RFC 2292 and RFC 2553.
@


1.19
log
@sort sections;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.18 2004/12/31 21:26:40 jaredy Exp $
d388 1
a388 3
Get or set the
.Xr esp 4
transport level.
d390 1
a390 3
Get or set the
.Xr esp 4
encapsulation level.
@


1.18
log
@ip6.4 comes back, rewritten from scratch
@
text
@d1 1
a1 1
.\"	$OpenBSD$
a630 6
.Sh STANDARDS
Most of the socket options are defined in RFC 2292 and RFC 2553.
The
.Dv IPV6_PORTRANGE
socket option and the conflict resolution rule are not defined in the
RFCs and should be considered implementation dependent.
d675 6
@


1.17
log
@remove manpages based on RFC.  requested by deraadt
@
text
@d1 1
a1 30
.\"	$OpenBSD: ip6.4,v 1.16 2003/08/08 09:51:53 jmc Exp $
.\"	$KAME: ip6.4,v 1.12 2000/06/08 21:19:39 itojun Exp $
.\"
.\" Copyright (C) 1999 WIDE Project.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the project nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
d28 1
a28 2
.\"
.Dd December 17, 1999
d33 1
a33 1
.Nd Internet Protocol version 6 (IPv6)
d35 2
a36 2
.Fd #include <sys/socket.h>
.Fd #include <netinet/in.h>
d40 71
a110 9
.Tn IPv6
is the network layer protocol used by the Internet protocol version 6 family
.Pq Dv AF_INET6 .
Options may be set at the
.Tn IPv6
level when using higher-level protocols that are based on
.Tn IPv6
(such as
.Tn TCP
d112 2
a113 16
.Tn UDP ) .
It may also be accessed through a
.Dq raw socket
when developing new protocols, or special-purpose applications.
.Pp
There are several
.Tn IPv6-level
.Xr setsockopt 2 / Ns Xr getsockopt 2
options.
They are separated into the basic IPv6 sockets API
.Pq defined in RFC 2553 ,
and the advanced API
.Pq defined in RFC 2292 .
The basic API looks very similar to the API presented in
.Xr ip 4 .
Advanced API uses ancillary data and can handle more complex cases.
d115 2
a116 17
To specify some socket options, a certain level of privilege
(i.e. root privilege) is required.
.\"
.Ss Basic IPv6 sockets API
.Dv IPV6_UNICAST_HOPS
may be used to set the hoplimit field in the
.Tn IPv6
header.
As the symbol name suggests, the option controls the hoplimit field
on unicast packets.
If -1 is specified, the kernel will use a default value.
If a value of 0 to 255 is specified, the packet will have the specified
value as hoplimit.
Other values are considered invalid, and
.Dv EINVAL
will be returned.
For example:
d118 16
a133 9
int hlim = 60;                   /* max = 255 */
setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &hlim, sizeof(hlim));
.Ed
.Pp
.Tn IPv6
multicasting is supported only on
.Dv AF_INET6
sockets of type
.Dv SOCK_DGRAM
d135 3
a137 2
.Dv SOCK_RAW ,
and only on networks where the interface driver supports multicasting.
d139 67
a205 7
The
.Dv IPV6_MULTICAST_HOPS
option changes the hoplimit for outgoing multicast datagrams
in order to control the scope of the multicasts:
.Bd -literal -offset indent
unsigned int hlim;	/* range: 0 to 255, default = 1 */
setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &hlim, sizeof(hlim));
d208 7
a214 7
Datagrams with a hoplimit of 1 are not forwarded beyond the local network.
Multicast datagrams with a hoplimit of 0 will not be transmitted on any network,
but may be delivered locally if the sending host belongs to the destination
group and if multicast loopback has not been disabled on the sending socket
(see below).
Multicast datagrams with a hoplimit greater than 1 may be forwarded
to other networks if a multicast router is attached to the local network.
d216 67
a282 10
For hosts with multiple interfaces, each multicast transmission is
sent from the primary network interface.
The
.Dv IPV6_MULTICAST_IF
option overrides the default for
subsequent transmissions from a given socket:
.Bd -literal -offset indent
unsigned int outif;
outif = if_nametoindex("ne0");
setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_IF, &outif, sizeof(outif));
d285 3
a287 2
where "outif" is an interface index of the desired interface,
or 0 to specify the default interface.
d289 14
a302 10
If a multicast datagram is sent to a group to which the sending host itself
belongs (on the outgoing interface), a copy of the datagram is, by default,
looped back by the IPv6 layer for local delivery.
The
.Dv IPV6_MULTICAST_LOOP
option gives the sender explicit control
over whether or not subsequent datagrams are looped back:
.Bd -literal -offset indent
u_char loop;	/* 0 = disable, 1 = enable (default) */
setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop, sizeof(loop));
d305 3
a307 14
This option
improves performance for applications that may have no more than one
instance on a single host (such as a router daemon), by eliminating
the overhead of receiving their own transmissions.
It should generally not be used by applications for which there
may be more than one instance on a single host (such as a conferencing
program) or for which the sender does not belong to the destination
group (such as a time querying program).
.Pp
A multicast datagram sent with an initial hoplimit greater than 1 may be
delivered to the sending host on a different interface from that on which
it was sent, if the host belongs to the destination group on that other
interface.
The loopback control option has no effect on such delivery.
d309 16
a324 8
A host must become a member of a multicast group before it can receive
datagrams sent to the group.
To join a multicast group, use the
.Dv IPV6_JOIN_GROUP
option:
.Bd -literal -offset indent
struct ipv6_mreq mreq6;
setsockopt(s, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq6, sizeof(mreq6));
d327 3
a329 9
where
.Fa mreq6
is the following structure:
.Bd -literal -offset indent
struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;
    unsigned int ipv6mr_interface;
};
.Ed
d331 22
a352 7
.Dv ipv6mr_interface
should be 0 to choose the default multicast interface, or the
interface index of a particular multicast-capable interface if
the host is multihomed.
Membership is associated with a single interface;
programs running on multihomed hosts may need to
join the same group on more than one interface.
d354 46
a399 5
To drop a membership, use:
.Bd -literal -offset indent
struct ipv6_mreq mreq6;
setsockopt(s, IPPROTO_IPV6, IPV6_LEAVE_GROUP, &mreq6, sizeof(mreq6));
.Ed
d401 1
a401 26
where
.Fa mreq6
contains the same values as used to add the membership.
Memberships are dropped when the socket is closed or the process exits.
.Pp
.Dv IPV6_PORTRANGE
controls how ephemeral ports are allocated for
.Dv SOCK_STREAM
and
.Dv SOCK_DGRAM
sockets.
For example,
.Bd -literal -offset indent
int range = IPV6_PORTRANGE_LOW;       /* see <netinet/in.h> */
setsockopt(s, IPPROTO_IPV6, IPV6_PORTRANGE, &range, sizeof(range));
.Ed
.\"
.Ss Advanced IPv6 sockets API
The advanced IPv6 sockets API lets userland programs specify or obtain
details about the IPv6 header and the IPv6 extension headers on packets.
The advanced API uses ancillary data for passing data from/to the kernel.
.Pp
There are
.Xr setsockopt 2 / Ns Xr getsockopt 2
options to get optional information on incoming packets.
They are
d403 1
d408 7
a414 26
.Dv IPV6_RTHDR .
.Bd -literal -offset indent
int  on = 1;

setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO,  &on, sizeof(on));
setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &on, sizeof(on));
setsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS,  &on, sizeof(on));
setsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS,  &on, sizeof(on));
setsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR,    &on, sizeof(on));
.Ed
.Pp
When any of these options are enabled, the corresponding data is
returned as control information by
.Xr recvmsg 2 ,
as one or more ancillary data objects.
.Pp
If
.Dv IPV6_PKTINFO
is enabled, the destination IPv6 address and the arriving interface index
will be available via
.Li struct in6_pktinfo
on ancillary data stream.
You can pick the structure by checking for an ancillary data item with
.Li cmsg_level
equal to
.Dv IPPROTO_IPV6 ,
d416 8
a423 45
.Li cmsg_type
equal to
.Dv IPV6_PKTINFO .
.Pp
If
.Dv IPV6_HOPLIMIT
is enabled, the hoplimit value on the packet will be made available to the
userland program.
The ancillary data stream will contain an integer data item with
.Li cmsg_level
equal to
.Dv IPPROTO_IPV6 ,
and
.Li cmsg_type
equal to
.Dv IPV6_HOPLIMIT .
.Pp
.Xr inet6_option_space 3
and friends help parse ancillary data items for
.Dv IPV6_HOPOPTS
and
.Dv IPV6_DSTOPTS .
Similarly,
.Xr inet6_rthdr_space 3
and friends help parse ancillary data items for
.Dv IPV6_RTHDR .
.Pp
.Dv IPV6_HOPOPTS
and
.Dv IPV6_DSTOPTS
may appear multiple times on an ancillary data stream
(note that the behavior is slightly different than the specification).
Other ancillary data items can appear no more than once.
.Pp
For outgoing direction,
ancillary data items with normal payload data can be passed using
.Xr sendmsg 2 .
Ancillary data items will be parsed by the kernel, and used to construct
the IPv6 header and extension headers.
For the 5
.Li cmsg_level
values listed above, the ancillary data format is the same as the inbound case.
Additionally, the
.Dv IPV6_NEXTHOP
data object can also be specified.
d425 6
a430 17
.Dv IPV6_NEXTHOP
ancillary data object specifies the next hop for the
datagram as a socket address structure.
In the
.Li cmsghdr
structure
containing this ancillary data, the
.Li cmsg_level
member will be
.Dv IPPROTO_IPV6 ,
the
.Li cmsg_type
member will be
.Dv IPV6_NEXTHOP ,
and the first byte of
.Li cmsg_data[]
will be the first byte of the socket address structure.
d432 1
a432 12
If the socket address structure contains an IPv6 address (i.e., the
sin6_family member is
.Dv AF_INET6
), then the node identified by that
address must be a neighbor of the sending host.
If that address
equals the destination IPv6 address of the datagram, then this is
equivalent to the existing
.Dv SO_DONTROUTE
socket option.
.Pp
For applications that do not, or are unable to use
d434 16
a449 17
or
.Xr recvmsg 2 ,
the
.Dv IPV6_PKTOPTIONS
socket option is defined.
Setting the socket option specifies any of the optional output fields:
.Bd -literal -offset indent
setsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &buf, len);
.Ed
.Pp
The fourth argument points to a buffer containing one or more
ancillary data objects, and the fifth argument is the total length of
all these objects.
The application fills in this buffer exactly as
if the buffer were being passed to
.Xr sendmsg 2
as control information.
d451 6
a456 3
The options set by calling
.Xr setsockopt 2
for
d458 29
a486 82
are
called "sticky" options because once set they apply to all packets
sent on that socket.
The application can call
.Xr setsockopt 2
again to
change all the sticky options, or it can call
.Xr setsockopt 2
with a
length of 0 to remove all the sticky options for the socket.
.Pp
The corresponding receive option
.Bd -literal -offset indent
getsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &buf, &len);
.Ed
.Pp
returns a buffer with one or more ancillary data objects for all the
optional receive information that the application has previously
specified that it wants to receive.
The fourth argument points to
the buffer that is filled in by the call.
The fifth argument is a
pointer to a value-result integer: when the function is called the
integer specifies the size of the buffer pointed to by the fourth
argument, and on return this integer contains the actual number of
bytes that were returned.
The application processes this buffer
exactly as if the buffer were returned by
.Xr recvmsg 2
as control information.
.\"
.Ss Advanced API and TCP sockets
When using
.Xr getsockopt 2
with the
.Dv IPV6_PKTOPTIONS
option and a
.Tn TCP
socket, only the options from the most recently received segment are
retained and returned to the caller, and only after the socket option
has been set.
.\" That is,
.\" .Tn TCP
.\" need not start saving a copy of the options until the application says
.\" to do so.
The application is not allowed to specify ancillary data in a call to
.Xr sendmsg 2
on a
.Tn TCP
socket, and none of the ancillary data that we
described above is ever returned as control information by
.Xr recvmsg 2
on a
.Tn TCP
socket.
.\"
.Ss Conflict resolution
In some cases, there are multiple APIs defined for manipulating
a IPv6 header field.
A good example is the outgoing interface for multicast datagrams:
it can be manipulated by
.Dv IPV6_MULTICAST_IF
in basic API,
.Dv IPV6_PKTINFO
in advanced API, and the
.Li sin6_scope_id
field of the socket address passed to
.Xr sendto 2 .
.Pp
When conflicting options are given to the kernel,
the kernel will get the value in the following order of preference:
(1) options specified by using ancillary data,
(2) options specified by a sticky option of the advanced API,
(3) options specified by using the basic API, and lastly
(4) options specified by a socket address.
Note that the conflict resolution is undefined in the API specification
and implementation dependent.
.\"
.Ss "Raw IPv6 Sockets"
Raw
.Tn IPv6
sockets are connectionless, and are normally used with the
d490 11
a500 1
calls, though the
a501 3
call may also be used to fix the destination for future
packets (in which case the
.Xr read 2
d503 20
a522 1
.Xr recv 2
d524 4
a527 5
.Xr write 2
or
.Xr send 2
system calls may be used).
.Pp
d529 3
a531 33
.Fa proto
is 0, the default protocol
.Dv IPPROTO_RAW
is used for outgoing packets, and only incoming packets destined
for that protocol are received.
If
.Fa proto
is non-zero, that protocol number will be used on outgoing packets
and to filter incoming packets.
.Pp
Outgoing packets automatically have an
.Tn IPv6
header prepended to them (based on the destination address and the
protocol number the socket is created with).
Incoming packets are received without an
.Tn IPv6
header or extension headers.
.Pp
All data sent via raw sockets MUST be in network byte order and all
data received via raw sockets will be in network byte order.
This differs from the IPv4 raw sockets, which did not specify a byte
ordering and typically used the host's byte order.
.Pp
Another difference from IPv4 raw sockets is that complete packets
(that is, IPv6 packets with extension headers) cannot be read or
written using the IPv6 raw sockets API.
Instead, ancillary data
objects are used to transfer the extension headers, as described above.
Should an application need access to the
complete IPv6 packet, some other technique, such as the datalink
interfaces, such as
.Xr bpf 4 ,
must be used.
d533 66
a598 54
All fields in the IPv6 header that an application might want to
change (i.e., everything other than the version number) can be
modified using ancillary data and/or socket options by the
application for output.
All fields in a received IPv6 header (other
than the version number and Next Header fields) and all extension
headers are also made available to the application as ancillary data
on input.
Hence there is no need for a socket option similar to the
IPv4
.Dv IP_HDRINCL
socket option.
.Pp
When writing to a raw socket the kernel will automatically fragment
the packet if its size exceeds the path MTU, inserting the required
fragmentation headers.
On input the kernel reassembles received fragments, so the reader
of a raw socket never sees any fragment headers.
.Pp
Most IPv4 implementations give special treatment to a raw socket
created with a third argument to
.Xr socket 2
of
.Dv IPPROTO_RAW ,
whose value is normally 255.
We note that this value has no special meaning to
an IPv6 raw socket (and the IANA currently reserves the value of 255
when used as a next-header field).
.\" Note: This feature was added to
.\" IPv4 in 1988 by Van Jacobson to support traceroute, allowing a
.\" complete IP header to be passed by the application, before the
.\" .Dv IP_HDRINCL
.\" socket option was added.
.Pp
For ICMPv6 raw sockets,
the kernel will calculate and insert the ICMPv6 checksum
since this checksum is mandatory.
.Pp
For other raw IPv6 sockets (that is, for raw IPv6 sockets created
with a third argument other than IPPROTO_ICMPV6), the application
must set the new IPV6_CHECKSUM socket option to have the kernel (1)
compute and store a pseudo-header checksum for output,
and (2) verify the received
pseudo-header checksum on input,
discarding the packet if the checksum is in error.
This option prevents applications from having to perform source
address selection on the packets they send.
The checksum will
incorporate the IPv6 pseudo-header, defined in Section 8.1 of RFC 2460.
This new socket option also specifies an integer offset into
the user data of where the checksum is located.
.Bd -literal -offset indent
int offset = 2;
setsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset, sizeof(offset));
a599 12
.Pp
By default, this socket option is disabled.
Setting the offset to -1 also disables the option.
By disabled we mean (1) the kernel will
not calculate and store a checksum for outgoing packets, and (2) the
kernel will not verify a checksum for received packets.
.Pp
Note: Since the checksum is always calculated by the kernel for an
ICMPv6 socket, applications are not able to generate ICMPv6 packets
with incorrect checksums (presumably for testing purposes) using this
API.
.\"
d602 1
a602 1
.Bl -tag -width [EADDRNOTAVAIL]
d604 2
a605 2
when trying to establish a connection on a socket which already
has one, or when trying to send a datagram with the destination
d608 3
a610 2
when trying to send a datagram, but no destination address is
specified, and the socket hasn't been connected.
d612 2
a613 1
when the system runs out of memory for an internal data structure.
d615 3
a617 2
when an attempt is made to create a socket with a network address
for which no network interface exists.
d619 2
a620 1
when an attempt is made to create a raw IPv6 socket by a non-privileged process.
d623 2
a624 3
The following errors specific to
.Tn IPv6
may occur:
d629 1
a629 1
The ancillary data items were improperly formed, or option name was unknown.
d631 6
a636 1
.\"
d642 5
a646 2
.Xr inet6_option_space 3 ,
.Xr inet6_rthdr_space 3 ,
d648 4
a651 1
.Xr inet6 4
d655 1
a657 1
.%T "Advanced Sockets API for IPv6"
d662 1
a664 1
.%T "Internet Protocol, Version 6 (IPv6) Specification"
d671 1
a673 1
.%T "Basic Socket Interface Extensions for IPv6"
d675 6
a680 20
.\"
.Sh STANDARDS
Most of the socket options are defined in
RFC 2292 and/or RFC 2553.
.Dv IPV6_PORTRANGE
and conflict resolution rule
is not defined in the RFCs and should be considered implementation dependent.
.\"
.Sh HISTORY
The implementation is based on KAME stack
.Po
which is a descendant of WIDE hydrangea IPv6 stack kit
.Pc .
.Pp
Part of the document was shamelessly copied from RFC 2553 and RFC 2292.
.\"
.Sh BUGS
The
.Dv IPV6_NEXTHOP
object/option is not fully implemented as of writing this.
@


1.16
log
@refer to RFCs consistently (RFC XXXX);
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.15 2003/06/06 10:29:41 jmc Exp $
@


1.15
log
@- section reorder
- some macro fixes
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.14 2003/06/02 23:30:12 millert Exp $
d90 1
a90 1
.Pq defined in RFC2553 ,
d92 1
a92 1
.Pq defined in RFC2292 .
d559 1
a559 1
incorporate the IPv6 pseudo-header, defined in Section 8.1 of RFC2460.
d619 1
a619 2
.%R RFC
.%N 2292
d626 1
a626 2
.%R RFC
.%N 2460
d635 1
a635 2
.%R RFC
.%N 2553
d642 1
a642 1
RFC2292 and/or RFC2553.
d653 1
a653 1
Part of the document was shamelessly copied from RFC2553 and RFC2292.
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.13 2003/01/18 23:53:49 deraadt Exp $
d105 1
a105 1
As the symbol name suggests, the option controls the hoplimit field 
d125 1
a125 1
.Dv SOCK_RAW,
d569 1
a569 1
By disabled we mean (1) the kernel will 
d609 1
a611 1
.Xr recv 2 ,
@


1.13
log
@inet6 fixes from jmc@@prioris.mini.pw.edu.pl
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.12 2002/09/26 07:55:40 miod Exp $
d42 1
a42 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Incomplete section 4 mi manual page cleanup.
- make configuration lines match GENERIC files
- more Xr (hopefully usefule Xr)
- never mention intro(4) on non-physical devices (i.e. protocols), always
mention it for physical devices
- random text style and quoting fixes
- drivers ported from FreeBSD did mention rc.conf instead of hostname.if as
the place to put mediaopt
- some .Tn UNIX -> .Ox replacements
- etc, etc...

reviewd in part by deraadt@@ (until he got bored of this)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.11 2001/10/05 14:45:53 mpech Exp $
d101 1
a101 1
To specify some of socket options, certain privilege
d109 2
a110 1
As symbol name suggests, the option controls hoplimit field on unicast packets.
d146 1
a146 1
Multicast datagrams with hoplimit greater than 1 may be forwarded
d178 1
a178 1
instance on a single host (such as a router demon), by eliminating
d280 1
a280 1
equals to
d284 1
a284 1
equals to
d289 1
a289 1
is enabled, hoplimit value on the packet will be made available to the
d291 1
a291 1
Ancillary data stream will contain an integer data item with
d293 1
a293 1
equals to
d297 1
a297 1
equals to
d301 1
a301 1
and friends will help you parse ancillary data items for
d307 1
a307 1
and friends will help you parse ancillary data items for
d315 1
a315 1
Other ancillary data item will appear no more than once.
d318 1
a318 1
you can pass ancillary data items with normal payload data, using
d324 2
a325 2
values listed above, ancillary data format is the same as inbound case.
Additionally, you can specify
d327 1
a327 1
data object.
d358 1
a358 1
For applications that do not, or unable to use
d362 1
d446 1
a446 1
in advanced API, and
d452 1
a452 1
the kernel will get the value in the following preference:
d495 1
a495 1
Incoming packets are received without
d497 1
a497 1
header nor extension headers.
d550 1
a550 1
the kernel will calculate and insert the ICMPv6 checksum for
d556 1
a556 1
compute and store a pseudo header checksum for output,
d558 1
a558 1
pseudo header checksum on input,
d588 1
a588 1
address specified and the socket is already connected;
d591 1
a591 1
specified, and the socket hasn't been connected;
d593 1
a593 1
when the system runs out of memory for an internal data structure;
d657 1
a657 1
which is descendant of WIDE hydrangea IPv6 stack kit
@


1.11
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.10 2001/10/04 10:28:20 wilfried Exp $
a615 1
.Xr intro 4 ,
@


1.10
log
@e.g. and i.e. cleanup
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.9 2001/06/23 05:57:05 deraadt Exp $
d184 4
a187 3
A multicast datagram sent with an initial hoplimit greater than 1 may be delivered
to the sending host on a different interface from that on which it was sent,
if the host belongs to the destination group on that other interface.
d528 3
a530 3
fragmentation headers.  On input the kernel reassembles received
fragments, so the reader of a raw socket never sees any fragment
headers.
d569 3
a571 2
By default, this socket option is disabled.  Setting the offset to -1
also disables the option.  By disabled we mean (1) the kernel will
@


1.9
log
@ok, tmac is now fixed
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.8 2001/06/23 02:33:12 deraadt Exp $
d345 1
a345 1
If the socket address structure contains an IPv6 address (e.g., the
@


1.8
log
@join .%A entries; most by bk@@rt.fm
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.7 2001/06/22 12:15:45 mpech Exp $
d618 2
a619 1
.%A W. Stevens and M. Thomas
d626 2
a627 1
.%A S. Deering and R. Hinden
@


1.7
log
@o) remove unnecessary .Pp;
o) remove unnecessary .Nm args;
o) closes .Bl;
o) .Sh AUTHOR -> .Sh AUTHORS;
o) sort SEE ALSO;
o) better -mdoc style;
o) typos;

aaron@@ ok.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.6 2001/03/01 16:11:17 aaron Exp $
d618 1
a618 2
.%A W. Stevens
.%A M. Thomas
d625 1
a625 2
.%A S. Deering
.%A R. Hinden
@


1.6
log
@A slew of share/ man page fixes; nordin@@cse.ogi.edu. These have been sitting
in my INBOX since Nov 6, 2000, probably forgot about them since the tree was
frozen at that time.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.5 2000/11/24 10:25:12 itojun Exp $
a64 1
.\"
a67 1
.\"
a72 1
.\"
@


1.5
log
@sync with recent kame document.
- on AF_INET6, :: does not mean local node.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.4 2000/04/03 21:19:36 aaron Exp $
d457 1
a457 1
Note that the conflict resolution is undefined in the API specifcation
d556 1
a556 1
compute and store a psuedo header checksum for output,
d657 1
a657 1
which is decendant of WIDE hydrangea IPv6 stack kit
@


1.4
log
@Remove trailing whitespace.
@
text
@d1 2
a2 1
.\"	$OpenBSD: ip6.4,v 1.3 1999/12/22 06:52:28 itojun Exp $
a61 2
.\"	KAME Id: ip6.4,v 1.6 1999/12/22 06:49:12 itojun Exp
.\"
d96 1
a96 1
They are be separated into the basic IPv6 sockets API
d208 1
a208 1
    u_int ipv6mr_interface;
@


1.3
log
@wording fixes.  sync with reality.
(bring in latest from KAME tree)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.2 1999/12/20 04:34:21 itojun Exp $
d5 1
a5 1
.\" 
d17 1
a17 1
.\" 
d309 1
a309 1
and friends will help you parse ancillary data items for 
@


1.2
log
@wording fixes (sync with kame)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ip6.4,v 1.1 1999/12/19 03:14:27 itojun Exp $
d61 1
a61 1
.\"	KAME Id: ip6.4,v 1.3 1999/12/20 01:53:35 jinmei Exp
d245 1
a245 1
The advanced IPv6 sockets API lets userland programs to specify, or obtain,
d251 1
a251 1
flags to get optional information on packets for incoming packets.
d271 1
a271 1
.Xr recvmsg2 ,
d276 2
a277 2
is enabled, destination IPv6 address and arriving interface index
will be made available via
d293 1
a293 1
ancillary data stream will contain an integer data item with
d315 2
a316 1
may appear multiple times on an ancillary data stream.
d454 6
a459 3
(1) options specified by using advanced API,
(2) options specified by socket address, and lastly
(3) options specified by using basic API.
d637 10
d662 5
@


1.1
log
@add icmp6(4) and ip6(4).  may need some update to sync with reality.

in inet6(4), state that we do not support RFC1933 due to security reasons.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d61 1
a61 1
.\"	KAME Id: ip6.4,v 1.2 1999/12/19 03:11:04 itojun Exp
d97 1
a97 1
They are be separated into basic IPv6 socket API
d99 1
a99 1
and advanced API
d101 1
a101 1
Basic API looks very similar to the API presented in
d108 1
a108 1
.Ss Basic IPv6 socket API
d244 4
a247 4
.Ss Advanced IPv6 socket API
Advanced IPv6 socket API lets userland program to specify, or obtain,
details about IPv6 header and IPv6 extension headers on packets.
Advanced API uses ancillary data for passing data from/to the kernel.
@

