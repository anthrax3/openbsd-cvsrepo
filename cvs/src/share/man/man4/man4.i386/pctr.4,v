head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.14
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.16
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.12
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.10
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.8
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.22
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.20
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.18
	OPENBSD_5_0:1.29.0.16
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.14
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.12
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.8
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.14
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.12
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.10
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.8
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.6
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.30
date	2013.07.16.16.05.49;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2008.02.11.07.58.28;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2008.02.05.16.14.16;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.04.22.55.52;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.17.12.04.06;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.24.17.56.54;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.21.09.50.22;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.19.20.58.59;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.31.19.19.55;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.09.16.06.07;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.09.13.26.20;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.06.10.29.42;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.05.13.51.58;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.07.09.39.07;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.01.07.14.14;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.03.14.30.26;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.07.04.15;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.05.05.05.39;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.10.08.17.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.05.13.46.53;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.06.05.13.18.35;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	98.09.06.22.23.20;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	98.09.01.16.38.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.08.30.23.11.16;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	98.03.09.02.52.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.02.06.23.49.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.16.07.52.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.13.09.35.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.10.09.06.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.08.16.00.02.54;	author dm;	state Exp;
branches;
next	;


desc
@@


1.30
log
@use .Mt for email addresses; from Jan Stary <hans at stare dot cz>; ok jmc@@
@
text
@.\"	$OpenBSD: pctr.4,v 1.29 2008/02/11 07:58:28 jmc Exp $
.\"
.\" Pentium performance counter driver for OpenBSD.
.\" Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
.\"
.\" Modification and redistribution in source and binary forms is
.\" permitted provided that due credit is given to the author and the
.\" OpenBSD project by leaving this copyright notice intact.
.\"
.Dd $Mdocdate: February 11 2008 $
.Dt PCTR 4 i386
.Os
.Sh NAME
.Nm pctr
.Nd driver for CPU performance counters
.Sh SYNOPSIS
.Cd "pseudo-device pctr 1"
.Sh DESCRIPTION
The
.Nm
device provides access to the performance counters on AMD and Intel brand
processors, and to the TSC on others.
.Pp
Intel processors have two 40-bit performance counters which can be
programmed to count events such as cache misses, branch target buffer hits,
TLB misses, dual-issues, interrupts, pipeline flushes, and more.
While AMD processors have four 48-bit counters, their precision is decreased
to 40 bits.
.Pp
There is one
.Em ioctl
call to read the status of all counters, and one
.Em ioctl
call to program the function of each counter.
All require the following includes:
.Bd -literal -offset indent
#include <sys/types.h>
#include <machine/cpu.h>
#include <machine/pctr.h>
.Ed
.Pp
The current state of all counters can be read with the
.Dv PCIOCRD
.Em ioctl ,
which takes an argument of type
.Dv "struct pctrst" :
.Bd -literal -offset indent
#define PCTR_NUM	4
struct pctrst {
	u_int pctr_fn[PCTR_NUM];
	pctrval pctr_tsc;
	pctrval pctr_hwc[PCTR_NUM];
};
.Ed
.Pp
In this structure,
.Em ctr_fn
contains the functions of the counters, as previously set by the
.Dv PCIOCS0 ,
.Dv PCIOCS1 ,
.Dv PCIOCS2
and
.Dv PCIOCS3
ioctls (see below).
.Em pctr_hwc
contains the actual value of the hardware counters.
.Em pctr_tsc
is a free-running, 64-bit cycle counter.
.Pp
The functions of the counters can be programmed with ioctls
.Dv PCIOCS0 ,
.Dv PCIOCS1 ,
.Dv PCIOCS2
and
.Dv PCIOCS3
which require a writeable file descriptor and take an argument of type
.Dv "unsigned int" . \&
The meaning of this integer is dependent on the particular CPU.
.Ss Time stamp counter
The time stamp counter is available on most of the AMD K6, Intel Pentium
and higher class CPUs, as well as on some 486s and non-intel CPUs.
It is set to zero at boot time, and then increments with each cycle.
Because the counter is 64-bits wide, it does not overflow.
.Pp
The time stamp counter can be read directly from user-mode using
the
.Fn rdtsc
macro, which returns a 64-bit value of type
.Em pctrval .
The following example illustrates a simple use of
.Fn rdtsc
to measure the execution time of a hypothetical subroutine called
.Fn functionx :
.Bd -literal -offset indent
void
time_functionx(void)
{
	pctrval tsc;

	tsc = rdtsc();
	functionx();
	tsc = rdtsc() - tsc;
	printf("Functionx took %llu cycles.\en", tsc);
}
.Ed
.Pp
The value of the time stamp counter is also returned by the
.Dv PCIOCRD
.Em ioctl ,
so that one can get an exact timestamp on readings of the hardware
event counters.
.Ss Intel Pentium counters
The Intel Pentium counters are programmed with a 9 bit function.
The top three bits contain the following flags:
.Bl -tag -width P5CTR_C
.It Dv P5CTR_K
Enables counting of events that occur in kernel mode.
.It Dv P5CTR_U
Enables counting of events that occur in user mode.
You must set at least one of
.Dv P5CTR_U
and
.Dv P5CTR_K
to count anything.
.It Dv P5CTR_C
When this flag is set, the counter attempts to count the number of
cycles spent servicing a particular event, rather than simply the
number of occurrences of that event.
.El
.Pp
The bottom 6 bits set the particular event counted.
A list of possible event functions could be obtained by running a
.Xr pctr 1
command with
.Fl l
option.
.Ss "Counters for AMD K6, Intel Pentium Pro and newer CPUs"
Unlike the Pentium counters, these counters can be read
directly from user-mode without need to invoke the kernel.
The macro
.Fn rdpmc ctr
takes 0, 1, 2 or 3 as an argument to specify a counter, and returns that
counter's 40-bit value (which will be of type
.Em pctrval ) .
This is generally preferable to making a system call as it introduces
less distortion in measurements.
.Pp
Counter functions supported by these CPUs contain several parts.
The most significant byte (an 8-bit integer shifted left by
.Dv PCTR_CM_SHIFT )
contains a
.Em "counter mask" .
If non-zero, this sets a threshold for the number of times an event
must occur in one cycle for the counter to be incremented.
The
.Em "counter mask"
can therefore be used to count cycles in which an event
occurs at least some number of times.
The next byte contains several flags:
.Bl -tag -width PCTR_EN
.It Dv PCTR_U
Enables counting of events that occur in user mode.
.It Dv PCTR_K
Enables counting of events that occur in kernel mode.
You must set at least one of
.Dv PCTR_K
and
.Dv PCTR_U
to count anything.
.It Dv PCTR_E
Counts edges rather than cycles.
For some functions this allows you
to get an estimate of the number of events rather than the number of
cycles occupied by those events.
.It Dv PCTR_EN
Enable counters.
This bit must be set in the function for counter 0
in order for either of the counters to be enabled.
This bit should probably be set in counter 1 as well.
.It Dv PCTR_I
Inverts the sense of the
.Em "counter mask" . \&
When this bit is set, the counter only increments on cycles in which
there are no
.Em more
events than specified in the
.Em "counter mask" .
.El
.Pp
The next byte (shifted left by the
.Dv PCTR_UM_SHIFT )
contains flags specific to the event being counted, also known as the
.Em "unit mask" .
.Pp
For events dealing with the L2 cache, the following flags are valid
on Intel brand processors:
.Bl -tag -width PCTR_UM_M
.It Dv PCTR_UM_M
Count events involving modified cache coherency state lines.
.It Dv PCTR_UM_E
Count events involving exclusive cache coherency state lines.
.It Dv PCTR_UM_S
Count events involving shared cache coherency state lines.
.It Dv PCTR_UM_I
Count events involving invalid cache coherency state lines.
.El
.Pp
To measure all L2 cache activity, all these bits should be set.
They can be set with the macro
.Dv PCTR_UM_MESI
which contains the bitwise or of all of the above.
.Pp
For event types dealing with bus transactions, there is another flag
that can be set in the
.Em "unit mask" :
.Bl -tag -width PCTR_UM_A
.It Dv PCTR_UM_A
Count all appropriate bus events, not just those initiated by the
processor.
.El
.Pp
Events marked
.Em (MESI)
require the
.Dv PCTR_UM_[MESI]
bits in the
.Em "unit mask" . \&
Events marked
.Em (A)
can take the
.Dv PCTR_UM_A
bit.
.Pp
Finally, the least significant byte of the counter function is the
event type to count.
A list of possible event functions could be obtained by running a
.Xr pctr 1
command with
.Fl l
option.
.Sh FILES
.Bl -tag -width /dev/pctr -compact
.It Pa /dev/pctr
.El
.Sh ERRORS
.Bl -tag -width "[ENODEV]"
.It Bq Er ENODEV
An attempt was made to set the counter functions on a CPU that does
not support counters.
.It Bq Er EINVAL
An invalid counter function was provided as an argument to the
.Dv PCIOCSx
.Em ioctl .
.It Bq Er EPERM
An attempt was made to set the counter functions, but the device was
not open for writing.
.El
.Sh SEE ALSO
.Xr pctr 1 ,
.Xr ioctl 2
.Sh HISTORY
A
.Nm
device first appeared in
.Ox 2.0
but was subsequently extended to support AMD and newer Intel CPUs in
.Ox 4.3 .
.Sh AUTHORS
The
.Nm
device was written by
.An David Mazieres Aq Mt dm@@lcs.mit.edu .
.Sh BUGS
Not all counter functions are completely accurate.
Some of the functions may not make any sense at all.
Also you should be aware of the possibility of an interrupt between
invocations of
.Fn rdpmc
and/or
.Fn rdtsc
that can potentially decrease the accuracy of measurements.
@


1.29
log
@bump Mdocdate for pages committed in "febuary", necessary because
of a typo in rcs.c;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.28 2008/02/05 16:14:16 jmc Exp $
d10 1
a10 1
.Dd $Mdocdate$
d272 1
a272 1
.An David Mazieres Aq dm@@lcs.mit.edu .
@


1.28
log
@extented -> extended;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.27 2008/02/04 22:55:52 mikeb Exp $
d10 1
a10 1
.Dd $Mdocdate: Febuary 4 2008 $
@


1.27
log
@Fix release number.

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.26 2007/11/17 12:04:06 jmc Exp $
d10 1
a10 1
.Dd $Mdocdate: November 17 2007 $
d266 1
a266 1
but was subsequently extented to support AMD and newer Intel CPUs in
@


1.26
log
@quote macro calls containing >9 args;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.25 2007/10/24 17:56:54 mikeb Exp $
d10 1
a10 1
.Dd $Mdocdate: October 24 2007 $
d267 1
a267 1
.Ox 4.2 .
@


1.25
log
@Remove idle loop counter.

ok art deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.24 2007/10/21 09:50:22 jmc Exp $
d10 1
a10 1
.Dd $Mdocdate: October 21 2007 $
d137 1
a137 1
.Ss Counters for AMD K6, Intel Pentium Pro and newer CPUs
@


1.24
log
@use .Pp instead of a blank space;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.23 2007/10/19 20:58:59 mikeb Exp $
d10 1
a10 1
.Dd $Mdocdate: October 19 2007 $
a52 1
	pctrval pctr_idl;
a68 3
Finally,
.Em pctr_idl
is a 64-bit count of idle-loop iterations.
@


1.23
log
@Man page update due to the recent pctr codebase rewrite.

ok deraadt jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.22 2007/05/31 19:19:55 jmc Exp $
d10 1
a10 1
.Dd $Mdocdate: May 31 2007 $
d151 1
a151 1

@


1.22
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.21 2003/11/09 16:06:07 jmc Exp $
d10 1
a10 1
.Dd $Mdocdate$
d21 2
a22 2
device provides access to the performance counters on Intel brand processors,
and to the TSC on others.
d24 5
a28 4
Intel processors have two 40-bit performance
counters which can be programmed to count events such as cache misses,
branch target buffer hits, TLB misses, dual-issues, interrupts,
pipeline flushes, and more.
d48 1
a48 1
#define PCTR_NUM 2
d58 5
a62 3
.Dv ctr_fn
contains the functions of the two counters, as previously set by the
.Dv PCIOCS0
d64 1
a64 1
.Dv PCIOCS1
d66 3
a68 3
.Dv pctr_hwc
contains the actual value of the two hardware counters.
.Dv pctr_tsc
d71 1
a71 1
.Dv pctr_idl
d74 4
a77 2
The functions of the two counters can be programmed with ioctls
.Dv PCIOCS0
d79 1
a79 1
.Dv PCIOCS1 ,
a82 15
.\" The
.\" following procedure can be used to determine which counters are
.\" available on a given CPU:
.\" .Bd -literal -offset indent
.\" ctrval id = __cpuid();
.\" if (__hasp5ctr(id)) {
.\"	/* The machine has Pentium counters */
.\" } else if (__hasp6ctr(id)) {
.\"	/* The machine has Pentium Pro counters */
.\" } else if (__hastsc(id)) {
.\"	/* The machine just has a time stamp counter */
.\" } else {
.\"	/* No counters at all */
.\"}
.\" .Ed
d84 2
a85 2
The time stamp counter is available on all machines with Pentium and
Pentium Pro counters, as well as on some 486s and non-intel CPUs.
d93 1
a93 1
.Dv pctrval .
d95 1
a95 1
.Dv rdtsc
d107 1
a107 1
	printf ("Functionx took %qd cycles.\en", tsc);
d116 2
a117 2
.Ss Pentium counters
The Pentium counters are programmed with a 9 bit function.
d136 17
a152 83
Here is the event type of each permissible value for the bottom 6 bits of the
counter function:
.Pp
.Bl -tag -width 0x00 -compact -offset indent
.It 0x00
Data read
.It 0x01
Data write
.It 0x02
Data TLB miss
.It 0x03
Data read miss
.It 0x04
Data write miss
.It 0x05
Write (hit) to M or E state lines
.It 0x06
Data cache lines written back
.It 0x07
Data cache snoops
.It 0x08
Data cache snoop hits
.It 0x09
Memory accesses in both pipes
.It 0x0a
Bank conflicts
.It 0x0b
Misaligned data memory references
.It 0x0c
Code read
.It 0x0d
Code TLB miss
.It 0x0e
Code cache miss
.It 0x0f
Any segment register load
.It 0x12
Branches
.It 0x13
BTB hits
.It 0x14
Taken branch or BTB hit
.It 0x15
Pipeline flushes
.It 0x16
Instructions executed
.It 0x17
Instructions executed in the V-pipe
.It 0x18
Bus utilization (clocks)
.It 0x19
Pipeline stalled by write backup
.It 0x1a
Pipeline stalled by data memory read
.It 0x1b
Pipeline stalled by write to E or M line
.It 0x1c
Locked bus cycle
.It 0x1d
I/O read or write cycle
.It 0x1e
Non-cacheable memory references
.It 0x1f
AGI (Address Generation Interlock)
.It 0x22
Floating-point operations
.It 0x23
Breakpoint 0 match
.It 0x24
Breakpoint 1 match
.It 0x25
Breakpoint 2 match
.It 0x26
Breakpoint 3 match
.It 0x27
Hardware interrupts
.It 0x28
Data read or data write
.It 0x29
Data read miss or data write miss
.El
.Ss Pentium Pro counters
The Pentium Pro counter functions contain several parts.
d154 1
a154 1
.Dv P6CTR_CM_SHIFT )
d156 1
a156 1
.Em "counter mask" . \&
d164 2
a165 2
.Bl -tag -width P6CTR_EN
.It Dv P6CTR_U
d167 1
a167 1
.It Dv P6CTR_K
d170 1
a170 1
.Dv P6CTR_K
d172 1
a172 1
.Dv P6CTR_U
d174 1
a174 1
.It Dv P6CTR_E
d179 1
a179 1
.It Dv P6CTR_EN
d184 1
a184 1
.It Dv P6CTR_I
d194 16
a209 13
The next byte, also known as the
.Em "unit mask" ,
contains flags specific to the event being counted.
For events dealing with the L2 cache, the following flags are valid:
.Bl -tag -width P6CTR_UM_M
.It Dv P6CTR_UM_M
Count events involving modified cache lines.
.It Dv P6CTR_UM_E
Count events involving exclusive cache lines.
.It Dv P6CTR_UM_S
Count events involving shared cache lines.
.It Dv P6CTR_UM_I
Count events involving invalid cache lines.
d211 1
d214 1
a214 1
.Dv P6CTR_UM_MESI
d220 2
a221 2
.Bl -tag -width P6CTR_UM_A
.It Dv P6CTR_UM_A
d226 4
a229 154
Finally, the least significant byte of the counter function is the
event type to count.
The following values are available:
.Pp
.Bl -tag -width 0x00 -compact
.It 0x03 LD_BLOCKS
Number of store buffer blocks.
.It 0x04 SB_DRAINS
Number of store buffer drain cycles.
.It 0x05 MISALIGN_MEM_REF
Number of misaligned data memory references.
.It 0x06 SEGMENT_REG_LOADS
Number of segment register loads.
.It 0x10 FP_COMP_OPS_EXE  (ctr0 only)
Number of computational floating-point operations executed.
.It 0x11 FP_ASSIST  (ctr1 only)
Number of floating-point exception cases handled by microcode.
.It 0x12 MUL  (ctr1 only)
Number of multiplies.
.It 0x13 DIV  (ctr1 only)
Number of divides.
.It 0x14 CYCLES_DIV_BUSY  (ctr0 only)
Number of cycles during which the divider is busy.
.It 0x21 L2_ADS
Number of L2 address strobes.
.It 0x22 L2_DBUS_BUSY
Number of cycles during which the data bus was busy.
.It 0x23 L2_DBUS_BUSY_RD
Number of cycles during which the data bus was busy transferring data
from L2 to the processor.
.It 0x24 L2_LINES_IN
Number of lines allocated in the L2.
.It 0x25 L2_M_LINES_INM
Number of modified lines allocated in the L2.
.It 0x26 L2_LINES_OUT
Number of lines removed from the L2 for any reason.
.It 0x27 L2_M_LINES_OUTM
Number of modified lines removed from the L2 for any reason.
.It 0x28 L2_IFETCH/mesi
Number of L2 instruction fetches.
.It 0x29 L2_LD/mesi
Number of L2 data loads.
.It 0x2a L2_ST/mesi
Number of L2 data stores.
.It 0x2e L2_RQSTS/mesi
Number of L2 requests.
.It 0x43 DATA_MEM_REFS
All memory references, both cacheable and non-cacheable.
.It 0x45 DCU_LINES_IN
Total lines allocated in the DCU.
.It 0x46 DCU_M_LINES_IN
Number of M state lines allocated in the DCU.
.It 0x47 DCU_M_LINES_OUT
Number of M state lines evicted from the DCU.
This includes evictions via snoop HITM, intervention or replacement.
.It 0x48 DCU_MISS_OUTSTANDING
Weighted number of cycles while a DCU miss is outstanding.
.It 0x60 BUS_REQ_OUTSTANDING
Number of bus requests outstanding.
.It 0x61 BUS_BNR_DRV
Number of bus clock cycles during which the processor is driving the
BNR pin.
.It 0x62 BUS_DRDY_CLOCKS/a
Number of clocks during which DRDY is asserted.
.It 0x63 BUS_LOCK_CLOCKS/a
Number of clocks during which LOCK is asserted.
.It 0x64 BUS_DATA_RCV
Number of bus clock cycles during which the processor is receiving
data.
.It 0x65 BUS_TRAN_BRD/a
Number of burst read transactions.
.It 0x66 BUS_TRAN_RFO/a
Number of read for ownership transactions.
.It 0x67 BUS_TRANS_WB/a
Number of write back transactions.
.It 0x68 BUS_TRAN_IFETCH/a
Number of instruction fetch transactions.
.It 0x69 BUS_TRAN_INVAL/a
Number of invalidate transactions.
.It 0x6a BUS_TRAN_PWR/a
Number of partial write transactions.
.It 0x6b BUS_TRANS_P/a
Number of partial transactions.
.It 0x6c BUS_TRANS_IO/a
Number of I/O transactions.
.It 0x6d BUS_TRAN_DEF/a
Number of deferred transactions.
.It 0x6e BUS_TRAN_BURST/a
Number of burst transactions.
.It 0x6f BUS_TRAN_MEM/a
Number of memory transactions.
.It 0x70 BUS_TRAN_ANY/a
Number of all transactions.
.It 0x79 CPU_CLK_UNHALTED
Number of cycles during which the processor is not halted.
.It 0x7a BUS_HIT_DRV
Number of bus clock cycles during which the processor is driving the
HIT pin.
.It 0x7b BUS_HITM_DRV
Number of bus clock cycles during which the processor is driving the
HITM pin.
.It 0x7e BUS_SNOOP_STALL
Number of clock cycles during which the bus is snoop stalled.
.It 0x80 IFU_IFETCH
Number of instruction fetches, both cacheable and non-cacheable.
.It 0x81 IFU_IFETCH_MISS
Number of instruction fetch misses.
.It 0x85 ITLB_MISS
Number of ITLB misses.
.It 0x86 IFU_MEM_STALL
Number of cycles that the instruction fetch pipe stage is stalled,
including cache misses, ITLB misses, ITLB faults, and victim cache
evictions.
.It 0x87 ILD_STALL
Number of cycles that the instruction length decoder is stalled.
.It 0xa2 RESOURCE_STALLS
Number of cycles during which there are resource-related stalls.
.It 0xc0 INST_RETIRED
Number of instructions retired.
.It 0xc1 FLOPS  (ctr0 only)
Number of computational floating-point operations retired.
.It 0xc2 UOPS_RETIRED
Number of UOPs retired.
.It 0xc4 BR_INST_RETIRED
Number of branch instructions retired.
.It 0xc5 BR_MISS_PRED_RETIRED
Number of mispredicted branches retired.
.It 0xc6 CYCLES_INT_MASKED
Number of processor cycles for which interrupts are disabled.
.It 0xc7 CYCLES_INT_PENDING_AND_MASKED
Number of processor cycles for which interrupts are disabled and
interrupts are pending.
.It 0xc8 HW_INT_RX
Number of hardware interrupts received.
.It 0xc9 BR_TAKEN_RETIRED
Number of taken branches retired.
.It 0xca BR_MISS_PRED_TAKEN_RET
Number of taken mispredicted branches retired.
.It 0xd0 INST_DECODER
Number of instructions decoded.
.It 0xd2 PARTIAL_RAT_STALLS
Number of cycles or events for partial stalls.
.It 0xe0 BR_INST_DECODED
Number of branch instructions decoded.
.It 0xe2 BTB_MISSES
Number of branches that miss the BTB.
.It 0xe4 BR_BOGUS
Number of bogus branches.
.It 0xe6 BACLEARS
Number of times BACLEAR is asserted.
.El
.Pp
Events marked /mesi require the
.Dv P6CTR_UM_[MESI]
d232 4
a235 2
Events marked /a can take the
.Dv P6CTR_UM_A
d238 7
a244 14
Unlike the Pentium counters, the Pentium Pro counters can be read
directly from user-mode without need to invoke the kernel.
The macro
.Fn rdpmc ctr
takes 0 or 1 as an argument to specify a counter, and returns that
counter's 40-bit value (which will be of type
.Dv pctrval ) .
This is generally preferable to making a system call as it introduces
less distortion in measurements.
However, you should be aware of the possibility of an interrupt between
invocations of
.Fn rdpmc
and/or
.Fn rdtsc .
d256 1
a256 3
.Dv PCIOCS0
or
.Dv PCIOCS1
d269 3
a271 1
.Ox 2.0 .
d279 7
a285 1
Some of the functions don't seem to make any sense at all.
@


1.21
log
@remove .Pp's before lists and displays;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.20 2003/07/09 13:26:20 jmc Exp $
d10 1
a10 1
.Dd August 15, 1996
@


1.20
log
@- fix lists/displays
- quote .Cd's
- add/remove .Pp's as necessary
- fix some .Re/.Rs's
- simplify macros
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.19 2003/06/06 10:29:42 jmc Exp $
a128 1
.Pp
a239 1
.Pp
a273 1
.Pp
@


1.19
log
@- section reorder
- some macro fixes
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.18 2003/05/05 13:51:58 jmc Exp $
d17 1
a17 1
.Cd pseudo-device pctr 1
@


1.18
log
@corrections from Leandro Costa.

- corrections to tradenames
- updated URLs
- general typos

thanks Leandro!
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.17 2003/03/07 09:39:07 jmc Exp $
d8 1
a8 1
.\" OpenBSD project by leaving this copyright notice intact. 
d475 4
a492 4
.El
.Sh FILES
.Bl -tag -width /dev/pctr -compact
.It Pa /dev/pctr
@


1.17
log
@typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.16 2002/10/01 07:14:14 miod Exp $
d80 1
a80 1
.\" available on a given cpu:
d208 1
a208 1
Noncacheable memory references
@


1.16
log
@Manpage cleaning police:
- more and better .Xr
- prefer "option FOO" rather than "options FOO", and put the option
  lines after the device definition lines in SYNOPSIS
- identify these manpages as section 4/i386, not section 4.
- long awaited update to intro(4/i386)
- npx(4/i386) was too NetBSD-ish - we only provide one math emulator
- random touches

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.15 2001/08/03 14:30:26 mpech Exp $
d355 1
a355 1
This includes evictions via snoop HITM, intervention or replacement
d412 2
a413 2
including cache mises, ITLB misses, ITLB faults, and victim cache
evictions
d415 1
a415 1
Number of cycles that the instruction length decoder is stalled
@


1.15
log
@o) Remove unneeded .Nm arguments;
o) Sort SEE ALSO;
o) Minor .Nm and .Nd fixes;
o) Typo;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.14 2001/06/23 07:04:15 pjanzen Exp $
d17 1
a17 1
.Cd pseudo-device pctr
d495 2
a496 1
.Xr pctr 1
d505 2
a506 2
device was written by David Mazieres
.Aq dm@@lcs.mit.edu .
@


1.14
log
@spelling fixes and minor repairs almost entirely from jsyn@@nthought.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.13 2001/06/05 05:05:39 pvalchev Exp $
d40 1
a40 1

d55 1
a55 1

d70 1
a70 1

@


1.13
log
@License clarification from David Mazieres, ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.12 2001/04/10 08:17:55 deraadt Exp $
d327 1
a327 1
Number of cycles durring which the data bus was busy.
d438 1
a438 1
Number of taken mispredictioned branches retired.
@


1.12
log
@someone should bellow at people who spell below wrong
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.11 2000/07/05 13:46:53 aaron Exp $
d8 1
a8 2
.\" OpenBSD project (for instance by leaving this copyright notice
.\" intact).
@


1.11
log
@man4.i386 repairs.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.10 1999/06/05 13:18:35 aaron Exp $
d63 1
a63 1
ioctls (see bellow).
@


1.10
log
@more .Os cleanup, remove some trailing whitespace, cleanse some .Nm
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.9 1998/09/06 22:23:20 aaron Exp $
d16 1
a16 1
.Nd driver for cpu performance counters
d34 2
a35 2
call to program the function of each counter.  All require the
following includes:
d67 2
a68 1
is a free-running, 64-bit cycle counter.  Finally,
d96 2
a97 2
Pentium Pro counters, as well as on some 486s and non-intel CPUs.  It
is set to zero at boot time, and then increments with each cycle.
d128 2
a129 2
The Pentium counters are programmed with a 9 bit function.  The top
three bits contain the following flags:
d135 2
a136 2
Enables counting of events that occur in user mode.  You must set at
least one of
d147 3
a149 3
The bottom 6 bits set the particular event counted.  Here is the event
type of each permissible value for the bottom 6 bits of the counter
function:
d151 1
a151 1
.Bl -tag -width "0x00" -compact -offset indent
d230 2
a231 2
The Pentium Pro counter functions contain several parts.  The most
significant byte (an 8-bit integer shifted left by
d236 2
a237 1
must occur in one cycle for the counter to be incremented.  The
d247 2
a248 2
Enables counting of events that occur in kernel mode.  You must set at
least one of
d254 2
a255 1
Counts edges rather than cycles.  For some functions this allows you
d259 4
a262 3
Enable counters.  This bit must be set in the function for counter 0
in order for either of the counters to be enabled.  This bit should
probably be set in counter 1 as well.
d275 2
a276 2
contains flags specific to the event being counted.  For events
dealing with the L2 cache, the following flags are valid:
d288 2
a289 2
To measure all L2 cache activity, all these bits should be set.  They
can be set with the macro
d303 2
a304 1
event type to count.  The following values are available:
d355 2
a356 2
Number of M state lines evicted from the DCU.  This includes evictions
via snoop HITM, intervention or replacement
d463 2
a464 1
directly from user-mode without need to invoke the kernel.  The macro
d470 3
a472 2
less distortion in measurements.  However, you should be aware of the
possibility of an interrupt between invocations of
a475 14
.Sh SEE ALSO
.Xr pctr 1
.Sh FILES
.Pa /dev/pctr
.Sh HISTORY
A
.Nm
device first appeared in
.Ox 2.0 .
.Sh AUTHORS
The
.Nm
device was written by David Mazieres
.Aq dm@@lcs.mit.edu .
d491 16
d508 2
a509 2
Not all counter functions are completely accurate.  Some of the
functions don't seem to make any sense at all.
@


1.9
log
@More man page fixes. Spelling, grammar, some typos. Lots of double-word
occurrences squashed as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.8 1998/09/01 16:38:22 deraadt Exp $
d13 1
a13 1
.Os OpenBSD
@


1.8
log
@more man page fixes; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.7 1998/08/30 23:11:16 downsj Exp $
d99 1
a99 1
The time stamp counter can be be read directly from user-mode using
@


1.7
log
@Clean up.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.6 1998/03/09 02:52:56 millert Exp $
d67 1
a67 1
is a free-runing, 64-bit cycle counter.  Finally,
d143 1
a143 1
number of occurences of that event.
d222 1
a222 1
Hardware interupts
@


1.6
log
@Add i386 tags
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.5 1998/02/06 23:49:03 deraadt Exp $
d11 1
a11 1
.Dd Aug 15, 1996
d16 1
a16 1
.Nd Driver for Pentium/Pentium Pro performance counters
d22 4
a25 2
device provides access to the performance counters on the Pentium and
Pentium Pro processors.  These processors have two 40-bit performance
d29 1
a29 1

d77 16
a92 16
The meaning of this integer is dependent on the particular CPU.  The
following procedure can be used to determine which counters are
available on a given cpu:
.Bd -literal -offset indent
ctrval id = __cpuid();
if (__hasp5ctr(id)) {
	/* The machine has Pentium counters */
} else if (__hasp6ctr(id)) {
	/* The machine has Pentium Pro counters */
} else if (__hastsc(id)) {
	/* The machine just has a time stamp counter */
} else {
	/* No counters at all */
}
.Ed

a93 1

d98 1
a98 1

d120 1
a120 1

a125 1

a126 1

d129 1
a129 1

d145 1
a145 1

d149 1
a149 1

a227 1

a228 1

a238 1

d240 1
d268 1
a268 1

d273 1
a283 1

d288 1
a288 1

d297 1
a297 1

d300 1
a300 1

d448 1
a448 1

d456 1
a456 1

a468 1

d470 1
a470 1
pctr(1)
d476 2
a477 1
device first appeared in the OpenBSD operating system.
a483 1

@


1.5
log
@indent
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.4 1997/09/16 07:52:17 deraadt Exp $
d12 1
a12 1
.Dt PCTR 4
@


1.4
log
@no need to include sys/ioccom.h; guy@@netapp.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.3 1997/09/13 09:35:49 deraadt Exp $
d48 4
a51 4
  u_int pctr_fn[PCTR_NUM];
  pctrval pctr_tsc;
  pctrval pctr_hwc[PCTR_NUM];
  pctrval pctr_idl;
d82 1
a82 2
}
else if (__hasp6ctr(id)) {
d84 1
a84 2
}
else if (__hastsc(id)) {
d86 1
a86 2
}
else {
@


1.3
log
@spelling error
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.2 1996/12/10 09:06:24 deraadt Exp $
a35 1
#include <sys/ioccom.h>
@


1.2
log
@"the the" purge
@
text
@d1 1
a1 1
.\"	$OpenBSD: pctr.4,v 1.1 1996/08/16 00:02:54 dm Exp $
d464 1
a464 1
Unlike the Pentium counters, the Pentium Pro conters can be read
@


1.1
log
@Man page for pctr.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d456 1
a456 1
Events marked /mesi require the the
@

