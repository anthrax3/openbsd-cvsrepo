head	1.86;
access;
symbols
	OPENBSD_6_0:1.86.0.6
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.85.0.8
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.85.0.6
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.83.0.4
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.74.0.6
	OPENBSD_5_3_BASE:1.74
	OPENBSD_5_2:1.74.0.4
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.2
	OPENBSD_5_0:1.72.0.4
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.71.0.2
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.60.0.4
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.59.0.2
	OPENBSD_4_2_BASE:1.59
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.56.0.4
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.52.0.2
	OPENBSD_3_6_BASE:1.52
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7;
locks; strict;
comment	@.\" @;


1.86
date	2015.10.15.02.26.27;	author lteo;	state Exp;
branches;
next	1.85;
commitid	U4e3rlOMn9q2uiEi;

1.85
date	2014.04.18.21.42.04;	author jmc;	state Exp;
branches;
next	1.84;

1.84
date	2014.04.18.11.18.40;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2014.01.21.03.13.10;	author lteo;	state Exp;
branches;
next	1.81;

1.81
date	2014.01.11.14.37.51;	author florian;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.20.04.27.23;	author lteo;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.04.02.11.46;	author lteo;	state Exp;
branches;
next	1.78;

1.78
date	2013.07.04.00.18.59;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2013.07.02.05.57.37;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2013.07.02.01.42.01;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2013.06.01.17.15.02;	author lteo;	state Exp;
branches;
next	1.74;

1.74
date	2012.02.10.00.08.20;	author haesbaert;	state Exp;
branches;
next	1.73;

1.73
date	2011.12.23.17.00.47;	author jmc;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.28.13.56.11;	author jmc;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.31.18.33.54;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.25.21.27.13;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.23.02.43.50;	author sthen;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.12.07.58.17;	author jmc;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.15.21.01.30;	author mpf;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.01.13.44.01;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.02.13.46.06;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.17.21.37.31;	author jmc;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.10.14.57.37;	author jmc;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.04.13.50.37;	author jmc;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.02.12.08.04;	author pascoe;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.31.19.19.51;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.09.11.39.06;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.10.16.13.00;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.06.04.38.41;	author pascoe;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.14.16.13.25;	author jaredy;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.10.03.29.02;	author jaredy;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.24.03.13.46;	author jaredy;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.14.20.55.54;	author cedric;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.22.16.06.07;	author jmc;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.31.08.20.57;	author jmc;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.27.17.15.30;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.21.19.47.59;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.19.21.29.51;	author cedric;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.24.18.54.40;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.31.14.03.01;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.15.05.18.40;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.04.17.18.56;	author mcbride;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.02.00.25.42;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.01.14.32.54;	author cedric;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.28.09.41.22;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.21.19.12.59;	author frantzen;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.11.20.39.38;	author dhartmei;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.09.13.36.25;	author dhartmei;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.06.10.29.41;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.24.14.29.29;	author cedric;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.11.16.52.48;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.14.09.41.42;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.28.10.40.20;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.20.17.50.41;	author cedric;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.29.20.07.34;	author cedric;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.22.20.02.54;	author mcbride;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.22.02.04.00;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.15.18.58.50;	author margarida;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.15.18.46.15;	author margarida;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.02.15.28.35;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.29.18.37.12;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.25.09.27.54;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.15.14.04.28;	author pb;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.15.12.57.27;	author pb;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.26.09.38.30;	author dhartmei;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.14.23.03.19;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.16.23.42.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.10.22.02.05;	author weingart;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.10.18.28.33;	author dhartmei;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.13.19.09.59;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.13.18.51.24;	author dhartmei;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.13.18.26.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.05.14.45.53;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.05.12.34.44;	author dhartmei;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.01.22.07.35;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.01.22.05.51;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.05.45.52;	author kjell;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.05.37.04;	author kjell;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Add missing includes to make the pf(4) man page example program compile
again.

Spotted by and based on a diff from Jack J. Woehr.
@
text
@.\"	$OpenBSD: pf.4,v 1.85 2014/04/18 21:42:04 jmc Exp $
.\"
.\" Copyright (C) 2001, Kjell Wooding.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the project nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd $Mdocdate: April 18 2014 $
.Dt PF 4
.Os
.Sh NAME
.Nm pf
.Nd packet filter
.Sh SYNOPSIS
.Cd "pseudo-device pf"
.Sh DESCRIPTION
Packet filtering takes place in the kernel.
A pseudo-device,
.Pa /dev/pf ,
allows userland processes to control the
behavior of the packet filter through an
.Xr ioctl 2
interface.
There are commands to enable and disable the filter, load rulesets,
add and remove individual rules or state table entries,
and retrieve statistics.
The most commonly used functions are covered by
.Xr pfctl 8 .
.Pp
Manipulations like loading a ruleset that involve more than a single
.Xr ioctl 2
call require a so-called
.Em ticket ,
which prevents the occurrence of
multiple concurrent manipulations.
.Pp
Fields of
.Xr ioctl 2
parameter structures that refer to packet data (like
addresses and ports) are generally expected in network byte-order.
.Pp
Rules and address tables are contained in so-called
.Em anchors .
When servicing an
.Xr ioctl 2
request, if the anchor field of the argument structure is empty,
the kernel will use the default anchor (i.e., the main ruleset)
in operations.
Anchors are specified by name and may be nested, with components
separated by
.Sq /
characters, similar to how file system hierarchies are laid out.
The final component of the anchor path is the anchor under which
operations will be performed.
Anchor names with characters after the terminating null byte are
considered invalid; if used in an ioctl,
.Er EINVAL
will be returned.
.Sh IOCTL INTERFACE
.Nm
supports the following
.Xr ioctl 2
commands, available through
.In net/pfvar.h :
.Bl -tag -width xxxxxx
.It Dv DIOCSTART
Start the packet filter.
.It Dv DIOCSTOP
Stop the packet filter.
.It Dv DIOCADDRULE Fa "struct pfioc_rule *pr"
.Bd -literal
struct pfioc_rule {
	u_int32_t	action;
	u_int32_t	ticket;
	u_int32_t	nr;
	char		anchor[MAXPATHLEN];
	char		anchor_call[MAXPATHLEN];
	struct pf_rule	rule;
};
.Ed
.Pp
Add
.Va rule
at the end of the inactive ruleset.
This call requires a
.Va ticket
obtained through a preceding
.Dv DIOCXBEGIN
call.
The optional
.Va anchor
name indicates the anchor in which to append the rule.
.Va nr
and
.Va action
are ignored.
.It Dv DIOCADDQUEUE Fa "struct pfioc_queue *q"
Add a queue.
.Bd -literal
struct pfioc_queue {
	u_int32_t		ticket;
	u_int			nr;
	struct pf_queuespec	queue;
};
.Ed
.It Dv DIOCGETRULES Fa "struct pfioc_rule *pr"
Get a
.Va ticket
for subsequent
.Dv DIOCGETRULE
calls and the number
.Va nr
of rules in the active ruleset.
.It Dv DIOCGETRULE Fa "struct pfioc_rule *pr"
Get a
.Va rule
by its number
.Va nr
using the
.Va ticket
obtained through a preceding
.Dv DIOCGETRULES
call.
If
.Va action
is set to
.Dv PF_GET_CLR_CNTR ,
the per-rule statistics on the requested rule are cleared.
.It Dv DIOCGETQUEUES Fa "struct pfioc_queue *pq"
Get a
.Va ticket
for subsequent
.Dv DIOCGETQUEUE
calls and the number
.Va nr
of queues in the active list.
.It Dv DIOCGETQUEUE Fa "struct pfioc_queue *pq"
Get the queueing discipline
by its number
.Va nr
using the
.Va ticket
obtained through a preceding
.Dv DIOCGETQUEUES
call.
.It Dv DIOCGETQSTATS Fa "struct pfioc_qstats *pq"
Get the statistics on a queue.
.Bd -literal
struct pfioc_qstats {
	u_int32_t	 	 ticket;
	u_int32_t	 	 nr;
	struct pf_queuespec	 queue;
	void			*buf;
	int		 	 nbytes;
};
.Ed
.Pp
This call fills in a pointer to the buffer of statistics
.Va buf ,
of length
.Va nbytes ,
for the queue specified by
.Va nr .
.It Dv DIOCGETRULESETS Fa "struct pfioc_ruleset *pr"
.Bd -literal
struct pfioc_ruleset {
	u_int32_t	 nr;
	char		 path[MAXPATHLEN];
	char		 name[PF_ANCHOR_NAME_SIZE];
};
.Ed
.Pp
Get the number
.Va nr
of rulesets (i.e., anchors) directly attached to the anchor named by
.Va path
for use in subsequent
.Dv DIOCGETRULESET
calls.
Nested anchors, since they are not directly attached to the given
anchor, will not be included.
This ioctl returns
.Er EINVAL
if the given anchor does not exist.
.It Dv DIOCGETRULESET Fa "struct pfioc_ruleset *pr"
Get a ruleset (i.e., an anchor)
.Va name
by its number
.Va nr
from the given anchor
.Va path ,
the maximum number of which can be obtained from a preceding
.Dv DIOCGETRULESETS
call.
This ioctl returns
.Er EINVAL
if the given anchor does not exist or
.Er EBUSY
if another process is concurrently updating a ruleset.
.It Dv DIOCADDSTATE Fa "struct pfioc_state *ps"
Add a state entry.
.Bd -literal
struct pfioc_state {
	struct pfsync_state	state;
};
.Ed
.It Dv DIOCGETSTATE Fa "struct pfioc_state *ps"
Extract the entry identified by the
.Va id
and
.Va creatorid
fields of the
.Va state
structure from the state table.
.It Dv DIOCKILLSTATES Fa "struct pfioc_state_kill *psk"
Remove matching entries from the state table.
This ioctl returns the number of killed states in
.Va psk_killed .
.Bd -literal
struct pfioc_state_kill {
	struct pf_state_cmp	psk_pfcmp;
	sa_family_t		psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
	char			psk_ifname[IFNAMSIZ];
	char			psk_label[PF_RULE_LABEL_SIZE];
	u_int			psk_killed;
	u_int16_t		psk_rdomain;
};
.Ed
.It Dv DIOCCLRSTATES Fa "struct pfioc_state_kill *psk"
Clear all states.
It works like
.Dv DIOCKILLSTATES ,
but ignores all fields of the
.Vt pfioc_state_kill
structure, except
.Va psk_ifname .
.It Dv DIOCGETSTATUS Fa "struct pf_status *s"
Get the internal packet filter statistics.
.Bd -literal
struct pf_status {
	u_int64_t	counters[PFRES_MAX];
	u_int64_t	lcounters[LCNT_MAX];	/* limit counters */
	u_int64_t	fcounters[FCNT_MAX];
	u_int64_t	scounters[SCNT_MAX];
	u_int64_t	pcounters[2][2][3];
	u_int64_t	bcounters[2][2];
	u_int64_t	stateid;
	time_t		since;
	u_int32_t	running;
	u_int32_t	states;
	u_int32_t	src_nodes;
	u_int32_t	debug;
	u_int32_t	hostid;
	u_int32_t	reass;			/* reassembly */
	char		ifname[IFNAMSIZ];
	u_int8_t	pf_chksum[MD5_DIGEST_LENGTH];
};
.Ed
.It Dv DIOCCLRSTATUS
Clear the internal packet filter statistics.
.It Dv DIOCNATLOOK Fa "struct pfioc_natlook *pnl"
Look up a state table entry by source and destination addresses and ports.
.Bd -literal
struct pfioc_natlook {
	struct pf_addr	 saddr;
	struct pf_addr	 daddr;
	struct pf_addr	 rsaddr;
	struct pf_addr	 rdaddr;
	u_int16_t	 rdomain;
	u_int16_t	 rrdomain;
	u_int16_t	 sport;
	u_int16_t	 dport;
	u_int16_t	 rsport;
	u_int16_t	 rdport;
	sa_family_t	 af;
	u_int8_t	 proto;
	u_int8_t	 direction;
};
.Ed
.Pp
This was primarily used to support transparent proxies with rdr-to rules.
New proxies should use divert-to rules instead.
These do not require access to the privileged
.Pa /dev/pf
device and preserve the original destination address for
.Xr getsockname 2 .
For
.Dv SOCK_DGRAM
sockets, the
.Xr ip 4
socket options
.Dv IP_RECVDSTADDR
and
.Dv IP_RECVDSTPORT
can be used to retrieve the destination address and port.
.It Dv DIOCSETDEBUG Fa "u_int32_t *level"
Set the debug level.
See the
.Xr syslog 3
man page for a list of valid debug levels.
.It Dv DIOCGETSTATES Fa "struct pfioc_states *ps"
Get state table entries.
.Bd -literal
struct pfioc_states {
	int	ps_len;
	union {
		caddr_t		     psu_buf;
		struct pfsync_state *psu_states;
	} ps_u;
#define ps_buf		ps_u.psu_buf
#define ps_states	ps_u.psu_states
};
.Ed
.Pp
If
.Va ps_len
is non-zero on entry, as many states as possible that can fit into this
size will be copied into the supplied buffer
.Va ps_states .
On exit,
.Va ps_len
is always set to the total size required to hold all state table entries
(i.e., it is set to
.Li sizeof(struct pfsync_state) * nr ) .
.It Dv DIOCCHANGERULE Fa "struct pfioc_rule *pcr"
Add or remove the
.Va rule
in the ruleset specified by
.Va rule.action .
.Pp
The type of operation to be performed is indicated by
.Va action ,
which can be any of the following:
.Bd -literal
enum	{ PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
	  PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
	  PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };
.Ed
.Pp
.Va ticket
must be set to the value obtained with
.Dv PF_CHANGE_GET_TICKET
for all actions except
.Dv PF_CHANGE_GET_TICKET .
.Va anchor
indicates to which anchor the operation applies.
.Va nr
indicates the rule number against which
.Dv PF_CHANGE_ADD_BEFORE ,
.Dv PF_CHANGE_ADD_AFTER ,
or
.Dv PF_CHANGE_REMOVE
actions are applied.
.It Dv DIOCSETTIMEOUT Fa "struct pfioc_tm *pt"
.Bd -literal
struct pfioc_tm {
	int		 timeout;
	int		 seconds;
};
.Ed
.Pp
Set the state timeout of
.Va timeout
to
.Va seconds .
The old value will be placed into
.Va seconds .
For possible values of
.Va timeout ,
consult the
.Dv PFTM_*
values in
.In net/pfvar.h .
.It Dv DIOCGETTIMEOUT Fa "struct pfioc_tm *pt"
Get the state timeout of
.Va timeout .
The value will be placed into the
.Va seconds
field.
.It Dv DIOCCLRRULECTRS
Clear per-rule statistics.
.It Dv DIOCSETLIMIT Fa "struct pfioc_limit *pl"
Set the hard limits on the memory pools used by the packet filter.
.Bd -literal
struct pfioc_limit {
	int		index;
	unsigned	limit;
};

enum	{ PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS,
	  PF_LIMIT_TABLES, PF_LIMIT_TABLE_ENTRIES, PF_LIMIT_MAX };
.Ed
.It Dv DIOCGETLIMIT Fa "struct pfioc_limit *pl"
Get the hard
.Va limit
for the memory pool indicated by
.Va index .
.It Dv DIOCRCLRTABLES Fa "struct pfioc_table *io"
Clear all tables.
All the ioctls that manipulate radix tables
use the same structure described below.
For
.Dv DIOCRCLRTABLES ,
.Va pfrio_ndel
contains on exit the number of tables deleted.
.Bd -literal
struct pfioc_table {
	struct pfr_table	 pfrio_table;
	void			*pfrio_buffer;
	int			 pfrio_esize;
	int			 pfrio_size;
	int			 pfrio_size2;
	int			 pfrio_nadd;
	int			 pfrio_ndel;
	int			 pfrio_nchange;
	int			 pfrio_flags;
	u_int32_t		 pfrio_ticket;
};
#define pfrio_exists    pfrio_nadd
#define pfrio_nzero     pfrio_nadd
#define pfrio_nmatch    pfrio_nadd
#define pfrio_naddr     pfrio_size2
#define pfrio_setflag   pfrio_size2
#define pfrio_clrflag   pfrio_nadd
.Ed
.It Dv DIOCRADDTABLES Fa "struct pfioc_table *io"
Create one or more tables.
On entry,
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_table
containing at least
.Vt pfrio_size
elements.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_table .
On exit,
.Va pfrio_nadd
contains the number of tables effectively created.
.Bd -literal
struct pfr_table {
	char		pfrt_anchor[MAXPATHLEN];
	char		pfrt_name[PF_TABLE_NAME_SIZE];
	u_int32_t	pfrt_flags;
	u_int8_t	pfrt_fback;
};
.Ed
.It Dv DIOCRDELTABLES Fa "struct pfioc_table *io"
Delete one or more tables.
On entry,
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_table
containing at least
.Vt pfrio_size
elements.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_table .
On exit,
.Va pfrio_ndel
contains the number of tables effectively deleted.
.It Dv DIOCRGETTABLES Fa "struct pfioc_table *io"
Get the list of all tables.
On entry,
.Va pfrio_buffer[pfrio_size]
contains a valid writeable buffer for
.Vt pfr_table
structures.
On exit,
.Va pfrio_size
contains the number of tables written into the buffer.
If the buffer is too small, the kernel does not store anything but just
returns the required buffer size, without error.
.It Dv DIOCRGETTSTATS Fa "struct pfioc_table *io"
This call is like
.Dv DIOCRGETTABLES
but is used to get an array of
.Vt pfr_tstats
structures.
.Bd -literal
struct pfr_tstats {
	struct pfr_table pfrts_t;
	u_int64_t	 pfrts_packets
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_bytes
			     [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
	u_int64_t	 pfrts_match;
	u_int64_t	 pfrts_nomatch;
	time_t		 pfrts_tzero;
	int		 pfrts_cnt;
	int		 pfrts_refcnt[PFR_REFCNT_MAX];
};
#define pfrts_name	 pfrts_t.pfrt_name
#define pfrts_flags	 pfrts_t.pfrt_flags
.Ed
.It Dv DIOCRCLRTSTATS Fa "struct pfioc_table *io"
Clear the statistics of one or more tables.
On entry,
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_table
containing at least
.Vt pfrio_size
elements.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_table .
On exit,
.Va pfrio_nzero
contains the number of tables effectively cleared.
.It Dv DIOCRCLRADDRS Fa "struct pfioc_table *io"
Clear all addresses in a table.
On entry,
.Va pfrio_table
contains the table to clear.
On exit,
.Va pfrio_ndel
contains the number of addresses removed.
.It Dv DIOCRADDADDRS Fa "struct pfioc_table *io"
Add one or more addresses to a table.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_addr
containing at least
.Vt pfrio_size
elements to add to the table.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_addr .
On exit,
.Va pfrio_nadd
contains the number of addresses effectively added.
.Bd -literal
struct pfr_addr {
	union {
		struct in_addr	 _pfra_ip4addr;
		struct in6_addr	 _pfra_ip6addr;
	}		 pfra_u;
	char		 pfra_ifname[IFNAMSIZ];
	u_int32_t	 pfra_states;
	u_int16_t	 pfra_weight;
	u_int8_t	 pfra_af;
	u_int8_t	 pfra_net;
	u_int8_t	 pfra_not;
	u_int8_t	 pfra_fback;
	u_int8_t	 pfra_type;
	u_int8_t	 pad[7];
};
#define pfra_ip4addr    pfra_u._pfra_ip4addr
#define pfra_ip6addr    pfra_u._pfra_ip6addr
.Ed
.It Dv DIOCRDELADDRS Fa "struct pfioc_table *io"
Delete one or more addresses from a table.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_addr
containing at least
.Vt pfrio_size
elements to delete from the table.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_addr .
On exit,
.Va pfrio_ndel
contains the number of addresses effectively deleted.
.It Dv DIOCRSETADDRS Fa "struct pfioc_table *io"
Replace the content of a table by a new address list.
This is the most complicated command, which uses all the structure members.
.Pp
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_addr
containing at least
.Vt pfrio_size
elements which become the new contents of the table.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_addr .
Additionally, if
.Va pfrio_size2
is non-zero,
.Va pfrio_buffer[pfrio_size..pfrio_size2]
must be a writeable buffer, into which the kernel can copy the
addresses that have been deleted during the replace operation.
On exit,
.Va pfrio_ndel ,
.Va pfrio_nadd ,
and
.Va pfrio_nchange
contain the number of addresses deleted, added, and changed by the
kernel.
If
.Va pfrio_size2
was set on entry,
.Va pfrio_size2
will point to the size of the buffer used, exactly like
.Dv DIOCRGETADDRS .
.It Dv DIOCRGETADDRS Fa "struct pfioc_table *io"
Get all the addresses of a table.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains a valid writeable buffer for
.Vt pfr_addr
structures.
On exit,
.Va pfrio_size
contains the number of addresses written into the buffer.
If the buffer was too small, the kernel does not store anything but just
returns the required buffer size, without returning an error.
.It Dv DIOCRGETASTATS Fa "struct pfioc_table *io"
This call is like
.Dv DIOCRGETADDRS
but is used to get an array of
.Vt pfr_astats
structures.
.Bd -literal
struct pfr_astats {
	struct pfr_addr	 pfras_a;
	u_int64_t	 pfras_packets
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	u_int64_t	 pfras_bytes
			     [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
	time_t		 pfras_tzero;
};
.Ed
.It Dv DIOCRCLRASTATS Fa "struct pfioc_table *io"
Clear the statistics of one or more addresses.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_addr
containing at least
.Vt pfrio_size
elements to be cleared from the table.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_addr .
On exit,
.Va pfrio_nzero
contains the number of addresses effectively cleared.
.It Dv DIOCRTSTADDRS Fa "struct pfioc_table *io"
Test if the given addresses match a table.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_addr
containing at least
.Vt pfrio_size
elements, each of which will be tested for a match in the table.
.Vt pfrio_esize
must be the size of
.Vt struct pfr_addr .
On exit, the kernel updates the
.Vt pfr_addr
array by setting the
.Va pfra_fback
member appropriately.
.It Dv DIOCRSETTFLAGS Fa "struct pfioc_table *io"
Change the
.Dv PFR_TFLAG_CONST
or
.Dv PFR_TFLAG_PERSIST
flags of a table.
On entry,
.Va pfrio_buffer
must point to an array of
.Vt struct pfr_table
containing at least
.Vt pfrio_size
elements.
.Va pfrio_esize
must be the size of
.Vt struct pfr_table .
.Va pfrio_setflag
must contain the flags to add, while
.Va pfrio_clrflag
must contain the flags to remove.
On exit,
.Va pfrio_nchange
and
.Va pfrio_ndel
contain the number of tables altered or deleted by the kernel.
Yes, tables can be deleted if one removes the
.Dv PFR_TFLAG_PERSIST
flag of an unreferenced table.
.It Dv DIOCRINADEFINE Fa "struct pfioc_table *io"
Defines a table in the inactive set.
On entry,
.Va pfrio_table
contains the table ID and
.Va pfrio_buffer[pfrio_size]
contains an array of
.Vt pfr_addr
structures to put in the table.
A valid ticket must also be supplied to
.Va pfrio_ticket .
On exit,
.Va pfrio_nadd
contains 0 if the table was already defined in the inactive list
or 1 if a new table has been created.
.Va pfrio_naddr
contains the number of addresses effectively put in the table.
.It Dv DIOCXBEGIN Fa "struct pfioc_trans *io"
.Bd -literal
struct pfioc_trans {
	int		 size;	/* number of elements */
	int		 esize;	/* size of each element in bytes */
	struct pfioc_trans_e {
		int		type;
		char		anchor[MAXPATHLEN];
		u_int32_t	ticket;
	}		*array;
};
.Ed
.Pp
Clear all the inactive rulesets specified in the
.Vt pfioc_trans_e
array.
For each ruleset, a ticket is returned for subsequent "add rule" ioctls,
as well as for the
.Dv DIOCXCOMMIT
and
.Dv DIOCXROLLBACK
calls.
.Pp
Ruleset types, identified by
.Va type ,
can be one of the following:
.Pp
.Bl -tag -width PF_TRANS_RULESET -offset ind -compact
.It Dv PF_TRANS_RULESET
Filter rules.
.It Dv PF_TRANS_TABLE
Address tables.
.El
.It Dv DIOCXCOMMIT Fa "struct pfioc_trans *io"
Atomically switch a vector of inactive rulesets to the active rulesets.
This call is implemented as a standard two-phase commit, which will either
fail for all rulesets or completely succeed.
All tickets need to be valid.
This ioctl returns
.Er EBUSY
if another process is concurrently updating some of the same rulesets.
.It Dv DIOCXROLLBACK Fa "struct pfioc_trans *io"
Clean up the kernel by undoing all changes that have taken place on the
inactive rulesets since the last
.Dv DIOCXBEGIN .
.Dv DIOCXROLLBACK
will silently ignore rulesets for which the ticket is invalid.
.It Dv DIOCSETHOSTID Fa "u_int32_t *hostid"
Set the host ID, which is used by
.Xr pfsync 4
to identify which host created state table entries.
.It Dv DIOCOSFPFLUSH
Flush the passive OS fingerprint table.
.It Dv DIOCOSFPADD Fa "struct pf_osfp_ioctl *io"
.Bd -literal
struct pf_osfp_ioctl {
	struct pf_osfp_entry	fp_os;
	pf_tcpopts_t		fp_tcpopts;	/* packed TCP options */
	u_int16_t		fp_wsize;	/* TCP window size */
	u_int16_t		fp_psize;	/* ip->ip_len */
	u_int16_t		fp_mss;		/* TCP MSS */
	u_int16_t		fp_flags;
	u_int8_t		fp_optcnt;	/* TCP option count */
	u_int8_t		fp_wscale;	/* TCP window scaling */
	u_int8_t		fp_ttl;		/* IPv4 TTL */

	int			fp_getnum;	/* DIOCOSFPGET number */
};

struct pf_osfp_entry {
	SLIST_ENTRY(pf_osfp_entry) fp_entry;
	pf_osfp_t		fp_os;
	int			fp_enflags;
#define PF_OSFP_EXPANDED	0x001		/* expanded entry */
#define PF_OSFP_GENERIC		0x002		/* generic signature */
#define PF_OSFP_NODETAIL	0x004		/* no p0f details */
#define PF_OSFP_LEN	32
	u_char			fp_class_nm[PF_OSFP_LEN];
	u_char			fp_version_nm[PF_OSFP_LEN];
	u_char			fp_subtype_nm[PF_OSFP_LEN];
};
.Ed
.Pp
Add a passive OS fingerprint to the table.
Set
.Va fp_os.fp_os
to the packed fingerprint,
.Va fp_os.fp_class_nm
to the name of the class (Linux, Windows, etc),
.Va fp_os.fp_version_nm
to the name of the version (NT, 95, 98), and
.Va fp_os.fp_subtype_nm
to the name of the subtype or patchlevel.
The members
.Va fp_mss ,
.Va fp_wsize ,
.Va fp_psize ,
.Va fp_ttl ,
.Va fp_optcnt ,
and
.Va fp_wscale
are set to the TCP MSS, the TCP window size, the IP length, the IP TTL,
the number of TCP options, and the TCP window scaling constant of the
TCP SYN packet, respectively.
.Pp
The
.Va fp_flags
member is filled according to the
.In net/pfvar.h
include file
.Dv PF_OSFP_*
defines.
The
.Va fp_tcpopts
member contains packed TCP options.
Each option uses
.Dv PF_OSFP_TCPOPT_BITS
bits in the packed value.
Options include any of
.Dv PF_OSFP_TCPOPT_NOP ,
.Dv PF_OSFP_TCPOPT_SACK ,
.Dv PF_OSFP_TCPOPT_WSCALE ,
.Dv PF_OSFP_TCPOPT_MSS ,
or
.Dv PF_OSFP_TCPOPT_TS .
.Pp
The
.Va fp_getnum
member is not used with this ioctl.
.Pp
The structure's slack space must be zeroed for correct operation;
.Xr memset 3
the whole structure to zero before filling and sending to the kernel.
.It Dv DIOCOSFPGET Fa "struct pf_osfp_ioctl *io"
Get the passive OS fingerprint number
.Va fp_getnum
from the kernel's fingerprint list.
The rest of the structure members will come back filled.
Get the whole list by repeatedly incrementing the
.Va fp_getnum
number until the ioctl returns
.Er EBUSY .
.It Dv DIOCGETSRCNODES Fa "struct pfioc_src_nodes *psn"
.Bd -literal
struct pfioc_src_nodes {
	int	psn_len;
	union {
		caddr_t		psu_buf;
		struct pf_src_node	*psu_src_nodes;
	} psn_u;
#define psn_buf		psn_u.psu_buf
#define psn_src_nodes	psn_u.psu_src_nodes
};
.Ed
.Pp
Get the list of source nodes kept by sticky addresses and source
tracking.
The ioctl must be called once with
.Va psn_len
set to 0.
If the ioctl returns without error,
.Va psn_len
will be set to the size of the buffer required to hold all the
.Va pf_src_node
structures held in the table.
A buffer of this size should then be allocated, and a pointer to this buffer
placed in
.Va psn_buf .
The ioctl must then be called again to fill this buffer with the actual
source node data.
After that call,
.Va psn_len
will be set to the length of the buffer actually used.
.It Dv DIOCCLRSRCNODES
Clear the tree of source tracking nodes.
.It Dv DIOCIGETIFACES Fa "struct pfioc_iface *io"
Get the list of interfaces and interface drivers known to
.Nm .
All the ioctls that manipulate interfaces
use the same structure described below:
.Bd -literal
struct pfioc_iface {
	char			 pfiio_name[IFNAMSIZ];
	void			*pfiio_buffer;
	int			 pfiio_esize;
	int			 pfiio_size;
	int			 pfiio_nzero;
	int			 pfiio_flags;
};
.Ed
.Pp
If not empty,
.Va pfiio_name
can be used to restrict the search to a specific interface or driver.
.Va pfiio_buffer[pfiio_size]
is the user-supplied buffer for returning the data.
On entry,
.Va pfiio_size
contains the number of
.Vt pfi_kif
entries that can fit into the buffer.
The kernel will replace this value by the real number of entries it wants
to return.
.Va pfiio_esize
should be set to
.Li sizeof(struct pfi_kif) .
.Pp
The data is returned in the
.Vt pfi_kif
structure described below:
.Bd -literal
struct pfi_kif {
	char				 pfik_name[IFNAMSIZ];
	RB_ENTRY(pfi_kif)		 pfik_tree;
	u_int64_t			 pfik_packets[2][2][2];
	u_int64_t			 pfik_bytes[2][2][2];
	time_t				 pfik_tzero;
	int				 pfik_flags;
	int				 pfik_flags_new;
	void				*pfik_ah_cookie;
	struct ifnet			*pfik_ifp;
	struct ifg_group		*pfik_group;
	int				 pfik_states;
	int				 pfik_rules;
	int				 pfik_routes;
	TAILQ_HEAD(, pfi_dynaddr)	 pfik_dynaddrs;
};
.Ed
.It Dv DIOCSETSTATUSIF Fa "struct pfioc_iface *pi"
Specify the interface for which statistics are accumulated.
.It Dv DIOCSETIFFLAG Fa "struct pfioc_iface *io"
Set the user settable flags (described above) of the
.Nm
internal interface description.
The filtering process is the same as for
.Dv DIOCIGETIFACES .
.Bd -literal
#define PFI_IFLAG_SKIP	0x0100	/* skip filtering on interface */
.Ed
.It Dv DIOCCLRIFFLAG Fa "struct pfioc_iface *io"
Works as
.Dv DIOCSETIFFLAG
above but clears the flags.
.It Dv DIOCKILLSRCNODES Fa "struct pfioc_src_node_kill *psnk"
Explicitly remove source tracking nodes.
.Bd -literal
struct pfioc_src_node_kill {
	sa_family_t		 psnk_af;
	struct pf_rule_addr	 psnk_src;
	struct pf_rule_addr	 psnk_dst;
	u_int			 psnk_killed;
};
.Ed
.El
.Sh FILES
.Bl -tag -width /dev/pf -compact
.It Pa /dev/pf
packet filtering device.
.El
.Sh EXAMPLES
The following example demonstrates how to use the
.Dv DIOCGETLIMIT
command to show the hard limit of a memory pool used by the packet filter:
.Bd -literal
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/pfvar.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>

static const struct {
	const char	*name;
	int		index;
} pf_limits[] = {
	{ "states",		PF_LIMIT_STATES },
	{ "src-nodes",		PF_LIMIT_SRC_NODES },
	{ "frags",		PF_LIMIT_FRAGS },
	{ "tables",		PF_LIMIT_TABLES },
	{ "table-entries",	PF_LIMIT_TABLE_ENTRIES },
	{ NULL,			0 }
};

void
usage(void)
{
	extern char *__progname;
	int i;

	fprintf(stderr, "usage: %s [", __progname);
	for (i = 0; pf_limits[i].name; i++)
		fprintf(stderr, "%s%s", (i > 0 ? "|" : ""), pf_limits[i].name);
	fprintf(stderr, "]\en");
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct pfioc_limit pl;
	int i, dev;
	int pool_index = -1;

	if (argc != 2)
		usage();

	for (i = 0; pf_limits[i].name; i++)
		if (!strcmp(argv[1], pf_limits[i].name)) {
			pool_index = pf_limits[i].index;
			break;
		}

	if (pool_index == -1) {
		warnx("no such memory pool: %s", argv[1]);
		usage();
	}

	dev = open("/dev/pf", O_RDWR);
	if (dev == -1)
		err(1, "open(\e"/dev/pf\e") failed");

	bzero(&pl, sizeof(struct pfioc_limit));
	pl.index = pool_index;

	if (ioctl(dev, DIOCGETLIMIT, &pl))
		err(1, "DIOCGETLIMIT");

	printf("The %s memory pool has ", pf_limits[i].name);
	if (pl.limit == UINT_MAX)
		printf("unlimited entries.\en");
	else
		printf("a hard limit of %u entries.\en", pl.limit);

	return (0);
}
.Ed
.Sh SEE ALSO
.Xr ioctl 2 ,
.Xr bridge 4 ,
.Xr pflog 4 ,
.Xr pflow 4 ,
.Xr pfsync 4 ,
.Xr pf.conf 5 ,
.Xr pfctl 8
.Sh HISTORY
The
.Nm
packet filtering mechanism first appeared in
.Ox 3.0 .
@


1.85
log
@fix SEE ALSO;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.84 2014/04/18 11:18:40 henning Exp $
d1012 1
d1015 1
@


1.84
log
@stop talking about altq
this manpage needs a bigger sync with reality...
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.82 2014/01/21 03:13:10 lteo Exp $
d29 1
a29 1
.Dd $Mdocdate: January 21 2014 $
d1091 1
a1091 1
.Xr pfctl 8 ,
@


1.83
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@a90 5
.It Dv DIOCSTARTALTQ
Start the ALTQ bandwidth control system (see
.Xr altq 9 ) .
.It Dv DIOCSTOPALTQ
Stop the ALTQ bandwidth control system.
a126 10
.It Dv DIOCADDALTQ Fa "struct pfioc_altq *pa"
Add an ALTQ discipline or queue.
.Bd -literal
struct pfioc_altq {
	u_int32_t	action;
	u_int32_t	ticket;
	u_int32_t	nr;
	struct pf_altq  altq;
};
.Ed
a184 36
.It Dv DIOCGETALTQS Fa "struct pfioc_altq *pa"
Get a
.Va ticket
for subsequent
.Dv DIOCGETALTQ
calls and the number
.Va nr
of queues in the active list.
.It Dv DIOCGETALTQ Fa "struct pfioc_altq *pa"
Get the queueing discipline
.Va altq
by its number
.Va nr
using the
.Va ticket
obtained through a preceding
.Dv DIOCGETALTQS
call.
.It Dv DIOCGETALTQSTATS Fa "struct pfioc_altqstats *pq"
Get the statistics on an ALTQ queue.
.Bd -literal
struct pfioc_altqstats {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	void		*buf;
	int		 nbytes;
	u_int8_t	 scheduler;
};
.Ed
.Pp
This call fills in a pointer to the buffer of statistics
.Va buf ,
of length
.Va nbytes ,
for the queue specified by
.Va nr .
a377 1
.\" It Dv DIOCCHANGEALTQ Fa "struct pfioc_altq *pcr"
a773 2
.It Dv PF_TRANS_ALTQ
ALTQ disciplines.
a1091 1
.Xr altq 9
@


1.82
log
@Update the names of the DIOCXBEGIN ruleset types.

Also tweak the text a little bit to make it clear that this is the
complete list of ruleset types.

ok henning@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.81 2014/01/11 14:37:51 florian Exp $
d29 1
a29 1
.Dd $Mdocdate: January 11 2014 $
d85 1
a85 1
.Aq Pa net/pfvar.h :
d449 1
a449 1
.Aq Pa net/pfvar.h .
d906 1
a906 1
.Aq Pa net/pfvar.h
@


1.81
log
@Sync description of struct pf_osfp_entry to rev 1.393 of pfvar.h
OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.80 2013/10/20 04:27:23 lteo Exp $
d29 1
a29 1
.Dd $Mdocdate: October 20 2013 $
d821 1
a821 1
include the following:
d823 2
a824 2
.Bl -tag -width PF_RULESET_FILTER -offset ind -compact
.It Dv PF_RULESET_FILTER
d826 1
a826 1
.It Dv PF_RULESET_ALTQ
d828 1
a828 1
.It Dv PF_RULESET_TABLE
@


1.80
log
@Document the ioctl commands of the new queueing system: DIOCADDQUEUE,
DIOCGETQUEUES, DIOCGETQUEUE, and DIOCGETQSTATS (the older version has
been renamed to DIOCGETALTQSTATS).

ok henning jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.79 2013/07/04 02:11:46 lteo Exp $
d29 1
a29 1
.Dd $Mdocdate: July 4 2013 $
d875 3
a877 3
	char			fp_class_nm[PF_OSFP_LEN];
	char			fp_version_nm[PF_OSFP_LEN];
	char			fp_subtype_nm[PF_OSFP_LEN];
@


1.79
log
@Fix two errors:

- DIOCSETSTATUSIF uses struct pfioc_iface, not pfioc_if.  The definition
  of pfioc_iface is already listed under DIOCIGETIFACES, so move the
  description of DIOCSETSTATUSIF below DIOCIGETIFACES.

- DIOCKILLSRCNODES uses struct pfioc_src_node_kill, not pfioc_iface.
  Add the definition of pfioc_src_node_kill while here.

ok henning jmc mikeb
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.78 2013/07/04 00:18:59 guenther Exp $
d123 9
d165 35
d218 2
a219 2
.It Dv DIOCGETQSTATS Fa "struct pfioc_qstats *pq"
Get the statistics on a queue.
d221 1
a221 1
struct pfioc_qstats {
@


1.78
log
@Re-commit: use time_t for storing time_t values.  This is an ABI
change for pf, but that's fine at this time.  You'll need to rebuild
pf userland after updating your kernel.

change to 'since' member ok henning@@
rest ok henning@@ deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.77 2013/07/02 05:57:37 guenther Exp $
d29 1
a29 1
.Dd $Mdocdate: July 2 2013 $
a267 7
.It Dv DIOCSETSTATUSIF Fa "struct pfioc_if *pi"
Specify the interface for which statistics are accumulated.
.Bd -literal
struct pfioc_if {
	char		 ifname[IFNAMSIZ];
};
.Ed
d982 2
d997 1
a997 1
.It Dv DIOCKILLSRCNODES Fa "struct pfioc_iface *io"
d999 8
@


1.77
log
@Revert previous: sizeof(time_t) != sizeof(long) on LP64, so there was
an ABI change involved.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.76 2013/07/02 01:42:01 guenther Exp $
d286 1
a289 1
	u_int32_t	since;
d530 1
a530 1
	long		 pfrts_tzero;
d675 1
a675 1
	long		 pfras_tzero;
d977 1
a977 1
	u_int32_t			 pfik_tzero;
@


1.76
log
@Use time_t for storing time_t values.  No change to the underlying
type**, so no ABI change.

ok henning@@ deraadt@@

** ...yet
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.75 2013/06/01 17:15:02 lteo Exp $
d29 1
a29 1
.Dd $Mdocdate: June 1 2013 $
d530 1
a530 1
	time_t		 pfrts_tzero;
d675 1
a675 1
	time_t		 pfras_tzero;
d977 1
a977 1
	time_t				 pfik_tzero;
@


1.75
log
@Make pfioc_natlook and pfr_addr match net/pfvar.h

ok benno henning jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.74 2012/02/10 00:08:20 haesbaert Exp $
d29 1
a29 1
.Dd $Mdocdate: February 10 2012 $
d530 1
a530 1
	long		 pfrts_tzero;
d675 1
a675 1
	long		 pfras_tzero;
d977 1
a977 1
	u_int32_t			 pfik_tzero;
@


1.74
log
@Clarify pf manpage and change example from DIOCNATLOOK to DIOCGETLIMIT.
From Lawrence Teo, input from sthen@@ and jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.73 2011/12/23 17:00:47 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: December 23 2011 $
d308 1
d584 2
@


1.73
log
@some spelling fixes, found using freebsd's "igor" document verifier;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.72 2010/12/28 13:56:11 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: December 28 2010 $
d317 16
d1009 2
a1010 2
.Dv DIOCNATLOOK
command to find the internal host/port of a NATed connection:
a1016 1
#include <netinet/in.h>
a1017 1
#include <err.h>
d1020 2
d1023 11
a1033 8
u_int32_t
read_address(const char *s)
{
	int a, b, c, d;

	sscanf(s, "%i.%i.%i.%i", &a, &b, &c, &d);
	return htonl(a << 24 | b << 16 | c << 8 | d);
}
d1036 1
a1036 1
print_address(u_int32_t a)
d1038 8
a1045 3
	a = ntohl(a);
	printf("%d.%d.%d.%d", a >> 24 & 255, a >> 16 & 255,
	    a >> 8 & 255, a & 255);
d1051 3
a1053 2
	struct pfioc_natlook nl;
	int dev;
d1055 12
a1066 4
	if (argc != 5) {
		printf("%s <gwy addr> <gwy port> <ext addr> <ext port>\en",
		    argv[0]);
		return 1;
d1073 5
a1077 8
	memset(&nl, 0, sizeof(struct pfioc_natlook));
	nl.saddr.v4.s_addr	= read_address(argv[1]);
	nl.sport		= htons(atoi(argv[2]));
	nl.daddr.v4.s_addr	= read_address(argv[3]);
	nl.dport		= htons(atoi(argv[4]));
	nl.af			= AF_INET;
	nl.proto		= IPPROTO_TCP;
	nl.direction		= PF_IN;
d1079 5
a1083 2
	if (ioctl(dev, DIOCNATLOOK, &nl))
		err(1, "DIOCNATLOOK");
d1085 1
a1085 4
	printf("internal host ");
	print_address(nl.rsaddr.v4.s_addr);
	printf(":%u\en", ntohs(nl.rsport));
	return 0;
@


1.72
log
@correct description of DIOCSETDEBUG; from Thomas Pfaff
ok henning
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.71 2010/05/31 18:33:54 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: May 31 2010 $
d971 1
a971 1
Set the user setable flags (described above) of the
@


1.71
log
@update structs;
from damian southard, documentation/6390
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.70 2010/03/25 21:27:13 schwarze Exp $
d29 1
a29 1
.Dd $Mdocdate: March 25 2010 $
d319 3
a321 4
.Bd -literal
enum	{ PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC,
	  PF_DEBUG_NOISY };
.Ed
@


1.70
log
@The "\\" escape sequence is low-level roff, don't use it in mdoc(7);
instead, use "\e".  This patch does not change rendering with (g)roff,
but it lets mandoc render the page correctly.

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.69 2010/03/23 02:43:50 sthen Exp $
d29 1
a29 1
.Dd $Mdocdate: March 23 2010 $
a100 1
	u_int32_t	pool_ticket;
d280 1
a280 1
	u_int64_t	lcounters[LCNT_MAX];
d292 1
d329 2
a330 2
		caddr_t		 psu_buf;
		struct pf_state *psu_states;
d346 1
a346 1
.Li sizeof(struct pf_state) * nr ) .
d567 1
d572 2
d747 1
a747 1
		int		rs_num;
d765 1
a765 1
.Va rs_num ,
d799 5
a803 11
	struct pf_osfp_entry {
		SLIST_ENTRY(pf_osfp_entry) fp_entry;
		pf_osfp_t		fp_os;
		char			fp_class_nm[PF_OSFP_LEN];
		char			fp_version_nm[PF_OSFP_LEN];
		char			fp_subtype_nm[PF_OSFP_LEN];
	} 			fp_os;
	pf_tcpopts_t		fp_tcpopts;
	u_int16_t		fp_wsize;
	u_int16_t		fp_psize;
	u_int16_t		fp_mss;
d805 18
a822 4
	u_int8_t		fp_optcnt;
	u_int8_t		fp_wscale;
	u_int8_t		fp_ttl;
	int			fp_getnum;
d955 1
a956 1
	char				 pfik_name[IFNAMSIZ];
d961 1
a961 3
	struct pf_state_tree_lan_ext	 pfik_lan_ext;
	struct pf_state_tree_ext_gwy	 pfik_ext_gwy;
	TAILQ_ENTRY(pfi_kif)		 pfik_w_states;
d967 1
@


1.69
log
@struct pfioc_natlook has rdomain now.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.68 2010/01/12 07:58:17 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: January 12 2010 $
d1022 1
a1022 1
		printf("%s <gwy addr> <gwy port> <ext addr> <ext port>\\n",
d1029 1
a1029 1
		err(1, "open(\\"/dev/pf\\") failed");
d1045 1
a1045 1
	printf(":%u\\n", ntohs(nl.rsport));
@


1.68
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.67 2010/01/12 03:20:51 mcbride Exp $
d307 1
@


1.67
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.66 2009/11/15 21:01:30 mpf Exp $
d29 1
a29 1
.Dd $Mdocdate: November 15 2009 $
a95 5
.Dv DIOCADDRULE
or
.Dv DIOCCHANGERULE
call.
All other members of the structure are ignored.
d268 1
a268 1
.Va psk_ifname.
@


1.66
log
@Update DIOCKILLSTATES and DIOCCLRSTATES sections.
Pointed out by ohauer at gmx.de.
OK henning.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.65 2009/09/01 13:44:01 henning Exp $
d29 1
a29 1
.Dd $Mdocdate: September 1 2009 $
a95 30
.It Dv DIOCBEGINADDRS Fa "struct pfioc_pooladdr *pp"
.Bd -literal
struct pfioc_pooladdr {
	u_int32_t		action;
	u_int32_t		ticket;
	u_int32_t		nr;
	u_int32_t		r_num;
	u_int8_t		r_action;
	u_int8_t		r_last;
	u_int8_t		af;
	u_int8_t		which;
	u_int8_t		pad[3];
	char			anchor[MAXPATHLEN];
	struct pf_pooladdr	addr;
};
.Ed
.Pp
Clear the buffer address pool and get a
.Va ticket
for subsequent
.Dv DIOCADDADDR ,
.Dv DIOCADDRULE ,
and
.Dv DIOCCHANGERULE
calls.
.It Dv DIOCADDADDR Fa "struct pfioc_pooladdr *pp"
.Pp
Add the pool address
.Va addr
to the buffer address pool to be used in the following
a120 4
call and a
.Va pool_ticket
obtained through a
.Dv DIOCBEGINADDRS
a121 2
.Dv DIOCADDADDR
must also be called if any pool addresses are required.
a161 27
.It Dv DIOCGETADDRS Fa "struct pfioc_pooladdr *pp"
Get a
.Va ticket
for subsequent
.Dv DIOCGETADDR
calls and the number
.Va nr
of pool addresses in the rule specified with
.Va r_action ,
.Va r_num ,
and
.Va anchor .
.It Dv DIOCGETADDR Fa "struct pfioc_pooladdr *pp"
Get the pool address
.Va addr
by its number
.Va nr
from the rule specified with
.Va r_action ,
.Va r_num ,
and
.Va anchor
using the
.Va ticket
obtained through a preceding
.Dv DIOCGETADDRS
call.
a370 7
.Va pool_ticket
must be set to the value obtained with the
.Dv DIOCBEGINADDRS
call for all actions except
.Dv PF_CHANGE_REMOVE
and
.Dv PF_CHANGE_GET_TICKET .
a380 8
.It Dv DIOCCHANGEADDR Fa "struct pfioc_pooladdr *pca"
Add or remove the pool address
.Va addr
from the rule specified by
.Va r_action ,
.Va r_num ,
and
.Va anchor .
@


1.65
log
@i have no idea who smuggled this in my tree but it is right
(adopt for new pf)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.64 2009/04/02 13:46:06 sthen Exp $
d29 1
a29 1
.Dd $Mdocdate: April 2 2009 $
d315 1
a315 1
.Va psk_af .
d318 1
d324 3
d333 1
a333 7
but ignores the
.Va psk_af ,
.Va psk_proto ,
.Va psk_src ,
and
.Va psk_dst
fields of the
d335 2
a336 1
structure.
@


1.64
log
@Anchor names with characters after the terminating null byte are invalid.
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.63 2009/03/17 21:37:31 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: March 17 2009 $
d106 2
a848 2
.It Dv PF_RULESET_SCRUB
Scrub (packet normalization) rules.
a850 6
.It Dv PF_RULESET_NAT
NAT (Network Address Translation) rules.
.It Dv PF_RULESET_BINAT
Bidirectional NAT rules.
.It Dv PF_RULESET_RDR
Redirect rules.
@


1.63
log
@+.Xr pf.conf 5 ,
from bofh
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.62 2008/09/10 14:57:37 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: September 10 2008 $
d76 4
@


1.62
log
@+.Xr pflow 4 ,
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.61 2008/09/04 13:50:37 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: September 4 2008 $
d1140 1
@


1.61
log
@- document DIOCKILLSRCNODES; requested by Johan Strom
- fix some line wrap in DIOCSETIFFLAG

ok henning
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.60 2007/12/02 12:08:04 pascoe Exp $
d29 1
a29 1
.Dd $Mdocdate: December 2 2007 $
d1138 1
@


1.60
log
@DIOC{GET,ADD}STATE incorrectly use a user provided pointer without using
copyin/out.  Change the API so that the state is included in the ioctl
argument, so the ioctl wrappers take care of copying memory as appropriate.

Also change the DIOCGETSTATE API to be more useful.  Instead of getting
an arbitrarily "numbered" state (using numbering that can change between
calls), instead search based on id and creatorid.  If you want to monitor
only a particular state, you can now use the bulk functions first to find
the appropriate id/creatorid and then fetch it directly from then on.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.59 2007/05/31 19:19:51 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: May 31 2007 $
d1053 1
a1053 1
#define PFI_IFLAG_SKIP		0x0100	/* skip filtering on interface */
d1059 2
@


1.59
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.58 2007/02/09 11:39:06 henning Exp $
d29 1
a29 1
.Dd $Mdocdate$
d295 1
a295 2
	u_int32_t	 nr;
	struct pf_state	 state;
d299 7
a305 3
Extract the entry with the specified number
.Va nr
from the state table.
@


1.58
log
@document how to clear rule counters with DIOCGETRULES
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.57 2006/06/10 16:13:00 beck Exp $
d29 1
a29 1
.Dd June 24, 2001
@


1.57
log
@clarify the requirements for table ioctls so the word "table" is not
used to refer to everything not even a pf table, and some of the
size fields are actually documented. help from jmc@@
ok jmc@@ dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.56 2005/08/06 04:38:41 pascoe Exp $
d187 5
@


1.56
log
@DIOCRDELTABLES modifies pfrio_ndel, not _nadd.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.55 2005/06/14 16:13:25 jaredy Exp $
d521 9
a529 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_table
structures.
d544 9
a552 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_table
structures.
d593 9
a601 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_table
structures.
d618 9
a626 4
.Va pfrio_buffer[pfrio_size]
contains the list of
.Vt pfr_addr
structures to add.
d649 9
a657 4
.Va pfrio_buffer[pfrio_size]
contains the list of
.Vt pfr_addr
structures to delete.
d668 9
a676 4
.Va pfrio_buffer[pfrio_size]
contains the new list of
.Vt pfr_addr
structures.
d731 9
a739 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_addr
structures to clear.
d748 9
a756 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_addr
structures to test.
d759 1
a759 1
table by setting the
d769 9
a777 4
.Va pfrio_buffer[pfrio_size]
contains a table of
.Vt pfr_table
structures, and
d779 1
a779 1
contains the flags to add, while
d781 1
a781 1
contains the flags to remove.
d796 1
a796 1
contains the list of
@


1.55
log
@- catch up to recent pf changes
- clarify description of DIOCGETSTATES, as reported by
  Henrik Gustafsson <openbsd@@fnord.se> via tech@@

ok henning, jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.54 2004/12/22 17:17:55 dhartmei Exp $
d544 1
a544 1
.Va pfrio_nadd
@


1.54
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.53 2004/12/10 03:29:02 jaredy Exp $
d349 1
d393 4
a396 3
is zero, all states will be gathered into
.Va pf_states
and
d398 2
a399 1
will be set to the size they take in memory (i.e.,
a400 7
If
.Va ps_len
is non-zero, as many states that can fit into
.Va ps_len
as possible will be gathered, and
.Va ps_len
will be updated to the size those rules take in memory.
d482 2
a483 1
enum { PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS };
a952 4

#define PFI_FLAG_GROUP     0x0001  /* gets groups of interfaces */
#define PFI_FLAG_INSTANCE  0x0002  /* gets single interfaces */
#define PFI_FLAG_ALLMASK   0x0003
d962 2
a963 2
represents the number of
.Va pfi_if
d969 2
a970 7
.Li sizeof(struct pfi_if) .
.Va pfiio_flags
should be set to
.Dv PFI_FLAG_GROUP ,
.Dv PFI_FLAG_INSTANCE ,
or both, to tell the kernel to return a group of interfaces
(drivers, like "fxp"), real interface instances (like "fxp1") or both.
d972 1
a972 1
.Vt pfi_if
d975 16
a990 10
struct pfi_if {
	char				 pfif_name[IFNAMSIZ];
	u_int64_t			 pfif_packets[2][2][2];
	u_int64_t			 pfif_bytes[2][2][2];
	u_int64_t			 pfif_addcnt;
	u_int64_t			 pfif_delcnt;
	long				 pfif_tzero;
	int				 pfif_states;
	int				 pfif_rules;
	int				 pfif_flags;
a991 6

#define PFI_IFLAG_GROUP		0x0001	/* group of interfaces */
#define PFI_IFLAG_INSTANCE	0x0002	/* single instance */
#define PFI_IFLAG_CLONABLE	0x0010	/* clonable group */
#define PFI_IFLAG_DYNAMIC	0x0020	/* dynamic group */
#define PFI_IFLAG_ATTACHED	0x0040	/* interface attached */
a992 11
.It Dv DIOCICLRISTATS Fa "struct pfioc_iface *io"
Clear the statistics counters of one or more interfaces.
.Va pfiio_name
and
.Va pfiio_flags
can be used to select which interfaces need to be cleared.
The filtering process is the same as for
.Dv DIOCIGETIFACES .
.Va pfiio_nzero
will be set by the kernel to the number of interfaces and drivers
that have been cleared.
d994 3
a996 2
Set the user setable flags (described below) of the pf internal interface
description.
d1000 1
a1000 2
#define PFI_IFLAG_SKIP		0x0100	/* skip interface */
#define PFI_IFLAG_SETABLE_MASK	0x0100	/* mask */
@


1.53
log
@sync to recent rate limiting changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.52 2004/08/24 03:13:46 jaredy Exp $
d1016 13
@


1.52
log
@sync to reality w.r.t. recursive anchors
- update header file excerpts
- update descriptions
- drop DIOCGETANCHOR(S)

ok jmc, dhartmei

and some minor mdoc fixes (Vt for variable types)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.51 2004/06/14 20:55:54 cedric Exp $
d336 1
@


1.51
log
@Remove obsolete ioctls. ok beck@@ dhartmei@@ henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.50 2004/05/22 16:06:07 jmc Exp $
d52 4
a55 1
ioctl call require a so-called ticket, which prevents the occurrence of
d58 3
a60 1
Fields of ioctl parameter structures that refer to packet data (like
d63 13
a75 4
Anchor and ruleset manipulations can be supplied with empty strings for
these parameters, in which case modifications will manipulate the
.Dq main
packet filter ruleset.
d102 1
a102 2
	char			anchor[PF_ANCHOR_NAME_SIZE];
	char			ruleset[PF_RULESET_NAME_SIZE];
d132 2
a133 2
	char		anchor[PF_ANCHOR_NAME_SIZE];
	char		ruleset[PF_RULESET_NAME_SIZE];
d154 1
a154 3
and
.Va ruleset
names indicate the anchor and ruleset in which to append the rule.
a196 1
.Va anchor ,
d198 1
a198 1
.Va ruleset .
a206 1
.Va anchor ,
d208 1
a208 1
.Va ruleset
a249 22
.It Dv DIOCGETANCHORS Fa "struct pfioc_anchor *pa"
.Bd -literal
struct pfioc_anchor {
	u_int32_t	 nr;
	char		 name[PF_ANCHOR_NAME_SIZE];
};
.Ed
.Pp
Get the number
.Va nr
of anchors in the active list for use in subsequent
.Dv DIOCGETANCHOR
calls.
.It Dv DIOCGETANCHOR Fa "struct pfioc_anchor *pa"
Get an anchor by its number
.Va nr ,
the maximum number of which can be obtained from a preceding
.Dv DIOCGETANCHORS
call.
This ioctl returns
.Er EBUSY
if another process is concurrently updating an anchor.
d254 2
a255 2
	char		 anchor[PF_ANCHOR_NAME_SIZE];
	char		 name[PF_RULESET_NAME_SIZE];
d261 2
a262 2
of rulesets in the given
.Va anchor
d266 2
d272 3
a274 1
Get a ruleset by its number
d276 2
a277 2
from the given
.Va anchor ,
d322 1
a322 1
.Va pfioc_state_kill
d381 1
a381 1
		caddr_t psu_buf;
a430 1
.Pp
d432 1
a432 3
and
.Va ruleset
indicate to which anchor and ruleset the operation applies.
a446 1
.Va anchor ,
d448 1
a448 1
.Va ruleset .
d525 1
a525 1
.Va pfr_table
d532 1
a532 2
	char		pfrt_anchor[PF_ANCHOR_NAME_SIZE];
	char		pfrt_ruleset[PF_RULESET_NAME_SIZE];
d543 1
a543 1
.Va pfr_table
d553 1
a553 1
.Va pfr_table
d564 1
a564 1
.Va pfr_tstats
d587 1
a587 1
.Va pfr_table
d607 1
a607 1
.Va pfr_addr
d633 1
a633 1
.Va pfr_addr
d647 1
a647 1
.Va pfr_addr
d675 1
a675 1
.Va pfr_addr
d686 1
a686 1
.Va pfr_astats
d705 1
a705 1
.Va pfr_addr
d717 1
a717 1
.Va pfr_addr
d720 1
a720 1
.Va pfr_addr
d733 1
a733 1
.Va pfr_table
d754 1
a754 1
.Va pfr_addr
d771 1
a771 2
		char		anchor[PF_ANCHOR_NAME_SIZE];
		char		ruleset[PF_RULESET_NAME_SIZE];
d778 1
a778 1
.Va pfioc_trans_e
d983 1
a983 1
.Va pfi_if
@


1.50
log
@updates and improvements from jared yanovich;
ok dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.49 2004/03/31 08:20:57 jmc Exp $
a760 19
.It Dv DIOCBEGINALTQS Fa "u_int32_t *ticket"
Clear all inactive ALTQ disciplines and get a
.Va ticket
for subsequent ALTQ discipline additions, as well as for the
.Dv DIOCCOMMITALTQS
and
.Dv DIOCXROLLBACK
calls.
.Pp
Unfortunately, there is currently no
.Dv DIOCROLLBACKALTQS
ioctl, so
.Dv DIOCXROLLBACK
must be used to achieve the desired effect.
.It Dv DIOCCOMMITALTQS Fa "u_int32_t *ticket"
Switch all inactive ALTQ disciplines to the active ruleset.
This ioctl returns
.Er EBUSY
if another process is concurrently updating the ALTQ ruleset.
a777 72
.It Dv DIOCRINABEGIN Fa "struct pfioc_table *io"
Clear all addresses in the inactive table and get a
.Va ticket
for subsequent table address entry modifications, as well as for the
.Dv DIOCRINACOMMIT
and
.Dv DIOCXROLLBACK
calls.
.Pp
On exit,
.Va pfrio_ndel
contains the number of addresses that were removed from the inactive
table.
.Pp
Unfortunately, there is currently no
.Dv DIOCRINAROLLBACK
ioctl, so
.Dv DIOCXROLLBACK
must be used to achieve the desired effect.
.It Dv DIOCRINACOMMIT Fa "struct pfioc_table *io"
Switch an inactive table of addresses to the active ruleset.
.Pp
On entry, a valid
.Va ticket
from a previous
.Dv DIOCRINABEGIN
call must be supplied.
On exit,
.Va pfrio_nadd
will contain the number of addresses added to the table and
.Va pfrio_nchange
will contain the number of addresses changed (negated).
.Pp
This ioctl returns
.Er EBUSY
if another process is concurrently updating the same table.
.It Dv DIOCBEGINRULES Fa "struct pfioc_rule *pr"
Clear all inactive rules in the given
.Va anchor
and
.Va ruleset
and get a
.Va ticket
for subsequent rule additions, as well as for the
.Dv DIOCCOMMITRULES
and
.Dv DIOCXROLLBACK
calls.
This ioctl returns
.Er EINVAL
if the given
.Va anchor
and
.Va ruleset
do not exist.
.Pp
Unfortunately, there is currently no
.Dv DIOCROLLBACKRULES
ioctl, so
.Dv DIOCXROLLBACK
must be used to achieve the desired effect.
.It Dv DIOCCOMMITRULES Fa "struct pfioc_rule *pr"
Switch an inactive ruleset to the active ruleset using the
.Va ticket
obtained from a preceding
.Dv DIOCBEGINRULES
call.
This ioctl returns
.Er EINVAL
if the given anchor and ruleset is invalid or
.Er EBUSY
if another process is concurrently updating the same ruleset.
@


1.49
log
@from Jared Yanovich:

- sync w/ header
- consistency fixes
- better macro usage
- wording corrections/improvements

ok dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.48 2004/03/27 17:15:30 henning Exp $
d57 5
d78 1
a78 1
.It Dv DIOCBEGINADDRS Fa "struct pfioc_pooladdr"
d102 1
a102 1
.It Dv DIOCADDADDR Fa "struct pfioc_pooladdr"
d112 1
a112 1
.It Dv DIOCADDRULE Fa "struct pfioc_rule"
d148 1
a148 1
.It Dv DIOCADDALTQ Fa "struct pfioc_altq"
d158 1
a158 1
.It Dv DIOCGETRULES Fa "struct pfioc_rule"
d166 1
a166 1
.It Dv DIOCGETRULE Fa "struct pfioc_rule"
d176 1
a176 1
.It Dv DIOCGETADDRS Fa "struct pfioc_pooladdr"
d189 1
a189 1
.It Dv DIOCGETADDR Fa "struct pfioc_pooladdr"
d205 1
a205 1
.It Dv DIOCGETALTQS Fa "struct pfioc_altq"
d213 1
a213 1
.It Dv DIOCGETALTQ Fa "struct pfioc_altq"
d218 1
a218 1
using a
d223 1
a223 1
.It Dv DIOCGETQSTATS Fa "struct pfioc_qstats"
d241 55
a295 1
.It Dv DIOCADDSTATE Fa "struct pfioc_state"
d303 1
a303 1
.It Dv DIOCGETSTATE Fa "struct pfioc_state"
d307 1
a307 1
.It Dv DIOCKILLSTATES Fa "struct pfioc_state_kill"
d309 1
a309 1
This call returns the number of killed states in
d320 1
a320 1
.It Dv DIOCCLRSTATES Fa "struct pfioc_state_kill"
d333 1
a333 1
.It Dv DIOCSETSTATUSIF Fa "struct pfioc_if"
d340 1
a340 1
.It Dv DIOCGETSTATUS Fa "struct pf_status"
d361 1
a361 1
.It Dv DIOCNATLOOK Fa "struct pfioc_natlook"
d378 1
a378 1
.It Dv DIOCSETDEBUG Fa "u_int32_t"
d384 1
a384 1
.It Dv DIOCGETSTATES Fa "struct pfioc_states"
d413 1
a413 1
.It Dv DIOCCHANGERULE Fa "struct pfioc_rule"
d452 2
a453 1
.It Dv DIOCCHANGEADDR Fa "struct pfioc_pooladdr"
d462 1
a462 1
.It Dv DIOCSETTIMEOUT Fa "struct pfioc_tm"
d482 1
a482 1
.It Dv DIOCGETTIMEOUT Fa "struct pfioc_tm"
d490 1
a490 1
.It Dv DIOCSETLIMIT Fa "struct pfioc_limit"
d500 1
a500 1
.It Dv DIOCGETLIMIT Fa "struct pfioc_limit"
d505 1
a505 1
.It Dv DIOCRCLRTABLES Fa "struct pfioc_table"
d533 1
a533 1
.It Dv DIOCRADDTABLES Fa "struct pfioc_table"
d552 1
a552 1
.It Dv DIOCRDELTABLES Fa "struct pfioc_table"
d562 1
a562 1
.It Dv DIOCRGETTABLES Fa "struct pfioc_table"
d574 1
a574 1
.It Dv DIOCRGETTSTATS Fa "struct pfioc_table"
d596 1
a596 1
.It Dv DIOCRCLRTSTATS Fa "struct pfioc_table"
d606 1
a606 1
.It Dv DIOCRCLRADDRS Fa "struct pfioc_table"
d614 1
a614 1
.It Dv DIOCRADDADDRS Fa "struct pfioc_table"
d640 1
a640 1
.It Dv DIOCRDELADDRS Fa "struct pfioc_table"
d652 1
a652 1
.It Dv DIOCRSETADDRS Fa "struct pfioc_table"
d682 1
a682 1
.It Dv DIOCRGETADDRS Fa "struct pfioc_table"
d696 1
a696 1
.It Dv DIOCRGETASTATS Fa "struct pfioc_table"
d712 1
a712 1
.It Dv DIOCRCLRASTATS Fa "struct pfioc_table"
d724 1
a724 1
.It Dv DIOCRTSTADDRS Fa "struct pfioc_table"
d738 1
a738 1
.It Dv DIOCRSETTFLAGS Fa "struct pfioc_table"
d761 20
a780 1
.It Dv DIOCRINADEFINE Fa "struct pfioc_table"
d793 1
a793 1
contains 0 if the table was already defined in the inactive list,
d797 73
a869 1
.It Dv DIOCXBEGIN Fa "struct pfioc_trans"
a870 2
#define PF_RULESET_ALTQ         (PF_RULESET_MAX)
#define PF_RULESET_TABLE        (PF_RULESET_MAX+1)
d892 22
a913 1
.It Dv DIOCXCOMMIT Fa "struct pfioc_trans"
d918 1
a918 1
Returns
d920 2
a921 3
if a concurrent process is trying to update some of the same rulesets
concurrently.
.It Dv DIOCXROLLBACK Fa "struct pfioc_trans"
d927 4
d933 1
a933 1
.It Dv DIOCOSFPADD Fa "struct pf_osfp_ioctl"
d1005 1
a1005 1
.It Dv DIOCOSFPGET Fa "struct pf_osfp_ioctl"
d1014 1
a1014 1
.It Dv DIOCGETSRCNODES Fa "struct pfioc_src_nodes"
d1047 1
a1047 1
.It Dv DIOCIGETIFACES Fa "struct pfioc_iface"
d1110 1
a1110 1
.It Dv DIOCICLRISTATS Fa "struct pfioc_iface"
@


1.48
log
@sync struct pf_status with reality, reminded by joel knight, theo ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.47 2004/03/21 19:47:59 miod Exp $
a56 5
.Sh FILES
.Bl -tag -width /dev/pf -compact
.It Pa /dev/pf
packet filtering device.
.El
d58 2
a59 1
pf supports the following
d61 2
a62 1
commands:
d65 1
a65 1
Starts the packet filter.
d67 1
a67 1
Stops the packet filter.
d69 2
a70 1
Starts the ALTQ bandwidth control system.
d72 2
a73 2
Stops the ALTQ bandwidth control system.
.It Dv DIOCBEGINADDRS  Fa "struct pfioc_pooladdr"
d89 1
a89 2
Clears the buffer address pool
and returns a
d91 7
a97 2
for subsequent DIOCADDADDR, DIOCADDRULE and DIOCCHANGERULE calls.
.It Dv DIOCADDADDR     Fa "struct pfioc_pooladdr"
d99 1
a99 1
Adds pool address
d102 4
a105 1
DIOCADDRULE or DIOCCHANGERULE call.
d107 1
a107 1
.It Dv DIOCADDRULE     Fa "struct pfioc_rule"
d120 1
a120 1
Adds
d123 1
a123 1
Requires
d125 3
a127 1
obtained through preceding DIOCXBEGIN call, and
d129 5
a133 2
obtained through DIOCBEGINADDRS call.
DIOCADDADDR must also be called if any pool addresses are required.
d143 2
a144 2
.It Dv DIOCADDALTQ     Fa "struct pfioc_altq"
Adds
d150 1
a150 1
	struct pf_altq   altq;
d153 2
a154 2
.It Dv DIOCGETRULES    Fa "struct pfioc_rule"
Returns
d156 3
a158 1
for subsequent DIOCGETRULE calls and
d161 2
a162 2
.It Dv DIOCGETRULE     Fa "struct pfioc_rule"
Returns
d164 1
a164 1
number
d166 1
a166 1
using
d168 5
a172 3
obtained through a preceding DIOCGETRULES call.
.It Dv DIOCGETADDRS    Fa "struct pfioc_pooladdr"
Returns
d174 3
a176 1
for subsequent DIOCGETADDR calls and
d181 1
a181 1
.Va anchor
d184 2
a185 2
.It Dv DIOCGETADDR     Fa "struct pfioc_pooladdr"
Returns pool address
d187 1
a187 1
number
d192 1
a192 1
.Va anchor
d195 1
a195 1
using
d197 5
a201 3
obtained through a preceding DIOCGETADDRS call.
.It Dv DIOCGETALTQS    Fa "struct pfioc_altq"
Returns
d203 3
a205 1
for subsequent DIOCGETALTQ calls and
d208 2
a209 2
.It Dv DIOCGETALTQ     Fa "struct pfioc_altq"
Returns
d211 1
a211 1
number
d213 1
a213 1
using
d215 5
a219 3
obtained through a preceding DIOCGETALTQS call.
.It Dv DIOCGETQSTATS   Fa "struct pfioc_qstats"
Returns statistics on a queue.
d230 2
a231 2
A pointer to a buffer of statistics
.Va buf
d233 1
a233 1
.Va nbytes
d236 2
a237 3
.It Dv DIOCADDSTATE    Fa "struct pfioc_state"
Adds a state entry.
.It Dv DIOCGETSTATE    Fa "struct pfioc_state"
d244 8
a251 5
.Pp
Extracts the entry with the specified number from the state table.
.It Dv DIOCKILLSTATES  Fa "struct pfioc_state_kill"
Removes matching entries from the state table.
Returns the number of killed states in psk_af.
d254 1
a254 1
	int			psk_af;
d261 2
a262 2
.It Dv DIOCCLRSTATES  Fa "struct pfioc_state_kill"
Clears all states.
d265 8
a272 2
but ignores the psk_af, psk_proto, psk_src and psk_dst fields of the
.Fa pfioc_state_kill
d275 1
d281 2
a282 3
.Pp
Specifies the interface for which statistics are accumulated.
.It Dv DIOCGETSTATUS   Fa "struct pf_status"
a299 2
.Pp
Gets the internal packet filter statistics.
d301 3
a303 3
Clears the internal packet filter statistics.
.It Dv DIOCNATLOOK     Fa "struct pfioc_natlook"
Looks up a state table entry by source and destination addresses and ports.
d319 2
a320 2
.It Dv DIOCSETDEBUG    Fa "u_int32_t"
Sets the debug level.
d322 2
a323 1
enum	{ PF_DEBUG_NONE=0, PF_DEBUG_URGENT=1, PF_DEBUG_MISC=2 };
d325 2
a326 1
.It Dv DIOCGETSTATES   Fa "struct pfioc_states"
d338 18
a355 2
.It Dv DIOCCHANGERULE  Fa "struct pfioc_rule"
Adds or removes the
d359 4
d364 3
a366 3
enum	{ PF_CHANGE_ADD_HEAD=1, PF_CHANGE_ADD_TAIL=2,
	  PF_CHANGE_ADD_BEFORE=3, PF_CHANGE_ADD_AFTER=4,
	  PF_CHANGE_REMOVE=5, PF_CHANGE_GET_TICKET=6 };
a368 3
The type of operation to be performed is indicated by
.Va action .
.Pp
d370 4
a373 2
must be set to the value obtained with PF_CHANGE_GET_TICKET
for all actions except PF_CHANGE_GET_TICKET.
d375 6
a380 2
must be set to the value obtained with the DIOCBEGINADDRS call
for all actions except PF_CHANGE_REMOVE and PF_CHANGE_GET_TICKET.
d385 1
a385 1
indicate which anchor and ruleset the operation applies to.
d387 8
a394 4
indicates the rule number against which PF_CHANGE_ADD_BEFORE,
PF_CHANGE_ADD_AFTER or PF_CHANGE_REMOVE actions are applied.
.It Dv DIOCCHANGEADDR  Fa "struct pfioc_pooladdr"
Adds or removes a pool address
d396 1
a396 1
from a rule specified with
d399 1
a399 1
.Va anchor
d402 1
a402 1
.It Dv DIOCSETTIMEOUT  Fa "struct pfioc_tm"
d409 19
a427 1
.It Dv DIOCGETTIMEOUT  Fa "struct pfioc_tm"
d430 2
a431 2
.It Dv DIOCSETLIMIT   Fa "struct pfioc_limit"
Sets hard limits on the memory pools used by the packet filter.
d437 2
d440 5
a444 1
.It Dv DIOCGETLIMIT   Fa "struct pfioc_limit"
d447 1
a447 1
All the IOCTLs that manipulate radix tables
d450 3
a452 2
.Dv DIOCRCLRTABLES, pfrio_ndel contains on exit the number
of tables deleted.
d455 10
a464 10
        struct pfr_table         pfrio_table;
        void                    *pfrio_buffer;
        int                      pfrio_esize;
        int                      pfrio_size;
        int                      pfrio_size2;
        int                      pfrio_nadd;
        int                      pfrio_ndel;
        int                      pfrio_nchange;
        int                      pfrio_flags;
        int                      pfrio_ticket;
d474 9
a482 3
Creates one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nadd contains the number of tables effectively created.
d485 5
a489 5
        char                     pfrt_anchor[PF_ANCHOR_NAME_SIZE];
        char                     pfrt_ruleset[PF_RULESET_NAME_SIZE];
        char                     pfrt_name[PF_TABLE_NAME_SIZE];
        u_int32_t                pfrt_flags;
        u_int8_t                 pfrt_fback;
d493 9
a501 3
Deletes one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nadd contains the number of tables effectively deleted.
d504 8
a511 3
On entry, pfrio_buffer[pfrio_size] contains a valid writeable buffer for
pfr_table structures.
On exit, pfrio_size contains the number of tables written into the buffer.
d515 5
a519 3
Like
.Dv DIOCRGETTABLES ,
but returns an array of pfr_tstats structures.
d522 10
a531 10
        struct pfr_table pfrts_t;
        u_int64_t        pfrts_packets
                             [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
        u_int64_t        pfrts_bytes
                             [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
        u_int64_t        pfrts_match;
        u_int64_t        pfrts_nomatch;
        long             pfrts_tzero;
        int              pfrts_cnt;
        int              pfrts_refcnt[PFR_REFCNT_MAX];
d533 2
a534 2
#define pfrts_name      pfrts_t.pfrt_name
#define pfrts_flags     pfrts_t.pfrt_flags
d537 9
a545 3
Clears the statistics of one or more tables.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures.
On exit, pfrio_nzero contains the number of tables effectively cleared.
d548 6
a553 2
On entry, pfrio_table contains the table to clear.
On exit, pfrio_ndel contains the number of addresses removed.
d556 10
a565 3
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to add.
On exit, pfrio_nadd contains the number of addresses effectively added.
d568 8
a575 8
        union {
                struct in_addr   _pfra_ip4addr;
                struct in6_addr  _pfra_ip6addr;
        }                pfra_u;
        u_int8_t         pfra_af;
        u_int8_t         pfra_net;
        u_int8_t         pfra_not;
        u_int8_t         pfra_fback;
d582 10
a591 3
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to delete.
On exit, pfrio_ndel contains the number of addresses effectively deleted.
d595 26
a620 9
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the new list of pfr_addr structures.
In addition to that, if size2 is nonzero, pfrio_buffer[pfrio_size..pfrio_size2]
must be a writeable buffer, into which the kernel can copy the addresses that
have been deleted during the replace operation.
On exit, pfrio_ndel, pfrio_nadd and pfrio_nchange contain the number of
addresses deleted, added and changed by the kernel.
If pfrio_size2 was set on
entry, pfrio_size2 will point to the size of the buffer used, exactly like
d624 10
a633 3
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a valid writeable buffer for pfr_addr structures.
On exit, pfrio_size contains the number of addresses written into the buffer.
d635 1
a635 1
return the required buffer size, without returning an error.
d637 5
a641 3
Like
.Dv DIOCRGETADDRS ,
but returns an array of pfr_astats structures.
d644 6
a649 6
        struct pfr_addr  pfras_a;
        u_int64_t        pfras_packets
                             [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
        u_int64_t        pfras_bytes
                             [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
        long             pfras_tzero;
d653 11
a663 4
Clears the statistics of one or more addresses.
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a table of pfr_addr structures to clear.
On exit, pfrio_nzero contains the number of addresses effectively cleared.
d666 11
a676 3
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains a table of pfr_addr structures to test.
On exit, the kernel updates the pfr_addr table by setting the pfra_fback
d680 1
a680 1
.Va const
d682 16
a697 7
.Va persist
flag of a table.
On entry, pfrio_buffer[pfrio_size] contains a table of pfr_table structures,
and pfrio_setflag contains the flags to add, while pfrio_clrflag contains the
flags to remove.
On exit, pfrio_nchange and pfrio_ndel contain the number of tables altered
or deleted by the kernel.
d699 1
a699 1
.Va persist
d703 15
a717 6
On entry, pfrio_table contains the table id and pfrio_buffer[pfrio_size]
contains the list of pfr_addr structures to put in the table.
A valid ticket must also be supplied to pfrio_ticket.
On exit, pfrio_nadd contains 0 if the table was already defined in the
inactive list, or 1 if a new table has been created.
pfrio_naddr contains the number of addresses effectively put in the table.
d723 8
a730 8
        int              size;  /* number of elements */
        int              esize; /* size of each element in bytes */
        struct pfioc_trans_e {
                int             rs_num;
                char            anchor[PF_ANCHOR_NAME_SIZE];
                char            ruleset[PF_RULESET_NAME_SIZE];
                u_int32_t       ticket;
        }               *array;
d734 2
a735 2
Clears all the inactive rulesets specified in the
.Fa "struct pfioc_trans_e"
d737 1
a737 1
For each ruleset, a ticket is returned for subsequent "add rule" IOCTLs,
d745 2
a746 2
Implemented as a standard 2-phase commit, which will either fail for all
rulesets or completely succeed.
d749 1
a749 1
.Dv EBUSY
d758 1
a758 1
.It Dv DIOCFPFLUSH
d760 1
a760 1
.It Dv DIOCFPADD Fa "struct pf_osfp_ioctl"
d770 1
a770 1
	u_int16_t		fp_mss;
d773 4
a777 2
	u_int8_t		fp_wscale;
	u_int8_t		fp_flags;
d797 1
d800 4
a803 2
are set to the TCP MSS, the TCP window size, the IP length and the IP TTL of
the TCP SYN packet respectively.
d806 19
a824 1
member is filled according to the net/pfvar.h include file PF_OSFP_* defines.
d827 1
a827 1
is not used with this ioctl.
d829 2
a830 1
The structure's slack space must be zeroed for correct operation; memset
d832 1
a832 20
.It Dv DIOCFPGET Fa "struct pf_osfp_ioctl"
.Bd -literal
struct pf_osfp_ioctl {
	struct pf_osfp_entry {
		SLIST_ENTRY(pf_osfp_entry) fp_entry;
		pf_osfp_t		fp_os;
		char			fp_class_nm[PF_OSFP_LEN];
		char			fp_version_nm[PF_OSFP_LEN];
		char			fp_subtype_nm[PF_OSFP_LEN];
	} 			fp_os;
	u_int16_t		fp_mss;
	u_int16_t		fp_wsize;
	u_int16_t		fp_psize;
	u_int8_t		fp_ttl;
	u_int8_t		fp_wscale;
	u_int8_t		fp_flags;
	int			fp_getnum;
};
.Ed
.Pp
d839 2
a840 1
number until the ioctl returns EBUSY.
d844 7
a850 7
        int     psn_len;
        union {
                caddr_t          psu_buf;
                struct pf_src_node      *psu_src_nodes;
        } psn_u;
#define psn_buf         psn_u.psu_buf
#define psn_src_nodes   psn_u.psu_src_nodes
d854 2
a855 5
Get the list of source nodes kept by the
.Ar sticky-address
and
.Ar source-track
options.
d869 1
a869 1
After the ioctl call
d872 1
a872 1
.It Dv DIOCCLRSRCNODES Fa "struct pfioc_table"
d875 1
a875 1
Gets the list of interfaces and interface drivers known to
d877 1
a877 1
All the IOCTLs that manipulate interfaces
d881 6
a886 6
        char                     pfiio_name[IFNAMSIZ];
        void                    *pfiio_buffer;
        int                      pfiio_esize;
        int                      pfiio_size;
        int                      pfiio_nzero;
        int                      pfiio_flags;
d907 2
a908 1
should be set to sizeof(struct pfi_if).
d911 3
a913 2
.Dv PFI_FLAG_GROUP , PFI_FLAG_INSTANCE ,
or both to tell the kernel to return a group of interfaces
d920 16
a935 17
        char                             pfif_name[IFNAMSIZ];
        u_int64_t                        pfif_packets[2][2][2];
        u_int64_t                        pfif_bytes[2][2][2];
        u_int64_t                        pfif_addcnt;
        u_int64_t                        pfif_delcnt;
        long                             pfif_tzero;
        int                              pfif_states;
        int                              pfif_rules;
        int                              pfif_flags;
};

#define PFI_IFLAG_GROUP         0x0001  /* group of interfaces */
#define PFI_IFLAG_INSTANCE      0x0002  /* single instance */
#define PFI_IFLAG_CLONABLE      0x0010  /* clonable group */
#define PFI_IFLAG_DYNAMIC       0x0020  /* dynamic group */
#define PFI_IFLAG_ATTACHED      0x0040  /* interface attached */
#define PFI_IFLAG_REFERENCED    0x0080  /* referenced by rules */
d941 1
a941 1
.Va pfrio_flags
d949 5
d955 3
a957 2
The following example demonstrates how to use the DIOCNATLOOK command
to find the internal host/port of a NATed connection.
d1026 2
a1027 1
.Xr pfctl 8
@


1.47
log
@Homogeneize config lines for pseudo-devices, and do not put fixed values.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.46 2004/02/19 21:29:51 cedric Exp $
d260 1
d266 1
@


1.46
log
@Makes pfctl -Fs and pfctl -w works with the optional -i specifier.
Kernel/Userland Sync needed. ok dhartmei@@ jmc@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.45 2004/01/24 18:54:40 deraadt Exp $
d36 1
a36 1
.Cd "pseudo-device pf 1"
@


1.45
log
@wrong docs for an ioctl; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.44 2003/12/31 14:03:01 jmc Exp $
a213 2
.It Dv DIOCCLRSTATES
Clears the state table.
d234 1
d237 7
@


1.44
log
@delete some blank lines;
mark up new ioctls a little better;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.43 2003/12/31 11:18:25 cedric Exp $
d75 1
a75 1
.It Dv DIOCBEGINADDRS  Fa "pfioc_pool_addr"
@


1.43
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.42 2003/12/15 05:18:40 jmc Exp $
a678 2


d680 2
a681 1
Gets the list of interfaces and interface drivers known to PF.
d699 10
a708 5
If not empty, pfiio_name can be used to restrict the search to a specific
interface or driver.
pfiio_buffer[pfiio_size] is the user-supplied buffer for returning the data.
On entry, pfiio_size represents the number of pfi_if entries that can fit
into the buffer.
d711 10
a720 5
pfiio_esize should be set to sizeof(struct pfi_if).
pfiio_flags should be set to PFI_FLAG_GROUP, PFI_FLAG_INSTANCE or both to tell
the kernel to return group of interfaces (drivers, like "fxp"), real interface
instances (like "fxp1") or both. The data is returned in the pfi_if structure
described below:
d743 5
a747 2
pfiio_name and pfrio_flags can be used to select which interfaces need to
be cleared. The filtering process is the same than for
d749 2
a750 1
pfiio_nzero will be set by the kernel to the number of interfaces and drivers
@


1.42
log
@- end sentence with full stop, not comma
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.41 2003/12/15 00:02:03 mcbride Exp $
d679 60
@


1.41
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.40 2003/10/04 17:18:56 mcbride Exp $
d647 1
a647 1
        union { 
d663 1
a663 1
set to 0,
@


1.40
log
@DIOCBEGINADDRS takes struct pfioc_pooladdr, not u_int32_t

Fixes PR3511 from apaterno@@dsnsecurity.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.39 2003/10/02 00:25:42 mcbride Exp $
d249 11
a259 9
	u_int64_t	 counters[PFRES_MAX];
	u_int64_t	 fcounters[FCNT_MAX];
	u_int64_t	 pcounters[2][2][3];
	u_int64_t	 bcounters[2][2];
	u_int32_t	 running;
	u_int32_t	 states;
	u_int32_t	 since;
	u_int32_t	 debug;
	char		 ifname[IFNAMSIZ];
d643 36
@


1.39
log
@Sync with pfvar.h
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.38 2003/10/01 14:32:54 cedric Exp $
d75 1
a75 5
.It Dv DIOCBEGINADDRS  Fa "u_int32_t"
Clears the buffer address pool
and returns a ticket for subsequent DIOCADDADDR, DIOCADDRULE and
DIOCCHANGERULE calls.
.It Dv DIOCADDADDR     Fa "struct pfioc_pooladdr"
d90 6
@


1.38
log
@Document new transaction IOCTLs, remove old ones.
Ok jmc@@ mcbride@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.37 2003/08/28 09:41:22 jmc Exp $
d135 1
d255 1
d274 1
a274 1
	u_int8_t	 af;
@


1.37
log
@tweak;
ok frantzen@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.36 2003/08/22 21:50:34 david Exp $
a99 5
.It Dv DIOCBEGINRULES  Fa "u_int32_t"
Clears the inactive ruleset for the type of rule indicated by
.Va rule.action
and returns a ticket for subsequent
DIOCADDRULE and DIOCCOMMITRULES calls.
d118 1
a118 1
obtained through preceding DIOCBEGINRULES call, and
a130 7
.It Dv DIOCCOMMITRULES Fa "u_int32_t"
Switch inactive to active filter ruleset.
Requires
.Va ticket .
.It Dv DIOCBEGINALTQS  Fa "u_int32_t"
Clears the inactive list of queues and returns a ticket for subsequent
DIOCADDALTQ and DIOCCOMMITALTQS calls.
a139 4
.It Dv DIOCCOMMITALTQS Fa "u_int32_t"
Switch inactive to active list of queues.
Requires
.Va ticket .
a511 13
.It Dv DIOCRINABEGIN Fa "struct pfioc_table"
Starts a transaction with the inactive set of tables.
Cleans up any leftover from a previously aborted transaction, and returns
a new ticket.
On exit, pfrio_ndel contains the number of leftover table deleted, and
pfrio_ticket contains a valid ticket to use for the following two IOCTLs.
.It Dv DIOCRINACOMMIT Fa "struct pfioc_table"
Commit the inactive set of tables into the active set.
While copying the addresses, do a best effort to keep statistics for
addresses present before and after the commit.
On entry, io->pfrio_ticket takes a valid ticket.
On exit, io->pfrio_nadd and io->pfrio_nchange contain the number of tables
added and altered by the commit operation.
d520 40
@


1.36
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.35 2003/08/21 19:12:59 frantzen Exp $
d582 4
a585 4
.Va fp_mss
.Va fp_wsize
.Va fp_psize
.Va fp_ttl
d621 1
a621 1
from the kernels fingerprint list.
@


1.35
log
@document passive OS fingerprinting
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.34 2003/08/11 20:39:38 dhartmei Exp $
d623 1
a623 1
Get the whole list by repeatadly incrementing the
@


1.34
log
@DIOCCHANGEADDR takes pfioc_pooladdr, not pfioc_addr.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.33 2003/08/09 13:36:25 dhartmei Exp $
d549 77
@


1.33
log
@missing #includes in the code example
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.32 2003/06/06 10:29:41 jmc Exp $
d338 1
a338 1
.It Dv DIOCCHANGEADDR  Fa "struct pfioc_addr"
@


1.32
log
@- section reorder
- some macro fixes
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.31 2003/05/24 14:29:29 cedric Exp $
d561 1
d563 1
@


1.31
log
@sync
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.30 2003/04/11 16:52:48 tedu Exp $
d419 2
a420 1
.Dv DIOCRGETTABLES, but returns an array of pfr_tstats structures.
d481 1
a481 1
.Dv DIOCRGETADDRS.
d491 2
a492 1
.Dv DIOCRGETADDRS, but returns an array of pfr_astats structures.
@


1.30
log
@tweak to clarify we can add/remove states too.  ok henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.29 2003/02/14 09:41:42 henning Exp $
d377 1
d399 2
d403 1
d431 1
a431 1
        int              pfrts_refcnt;
@


1.29
log
@new sentence, new line
whitespace
some typos

krause, 10x!
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.28 2003/01/28 10:40:20 jmc Exp $
d46 2
a47 2
add and remove individual rules or retrieve state table entries and
statistics.
@


1.28
log
@typos; added white boldface to examples

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.27 2003/01/20 17:50:41 cedric Exp $
d367 3
a369 2
Clear all tables. All the IOCTLs that manipulate radix tables
use the same structure described below. 
d403 1
a403 1
Deletes one or more tables. 
d414 1
a414 1
Like 
d433 1
a433 1
Clears the statistics of one or more tables. 
d473 2
a474 1
addresses deleted, added and changed by the kernel. if pfrio_size2 was set on
d485 1
a485 1
Like 
d498 1
a498 1
Clears the statistics of one or more addresses. 
d513 1
a513 1
flag of a table. 
d518 2
a519 1
or deleted by the kernel. Yes, tables can be deleted if one removes the
d523 3
a525 2
Starts a transaction with the inactive set of tables. Cleans up any leftover
from a previously aborted transaction, and returns a new ticket.
d529 3
a531 3
Commit the inactive set of tables into the active set. While copying the
addresses, do a best effort to keep statistics for addresses present before
and after the commit.
d538 2
a539 2
contains the list of pfr_addr structures to put in the table. A valid ticket
must also be supplied to pfrio_ticket.
d541 2
a542 2
inactive list, or 1 if a new table has been created. pfrio_naddr contains
the number of addresses effectively put in the table.
@


1.27
log
@Add definition of all structures involved in the radix table ioctls.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.26 2003/01/09 10:40:44 cedric Exp $
d39 3
a41 1
A pseudo-device, /dev/pf, allows userland processes to control the
d77 1
a77 1
and returns ticket for subsequent DIOCADDADDR, DIOCADDRULE and
d103 1
a103 1
and returns ticket for subsequent
d141 1
a141 1
Clears the inactive list of queues and returns ticket for subsequent
d411 1
a411 1
return the required buffer size, without error.
d441 1
a441 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d460 1
a460 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d466 1
a466 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d471 1
a471 1
On exit, pfrio_ndel, pfrio_nadd and pfrio_nchange contains the number of
d477 1
a477 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d497 1
a497 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d502 1
a502 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d504 1
a504 1
On exit, the kernel update the pfr_addr table by setting the pfra_fback
d513 4
a516 4
and pfrio_setflag contain the flags to add, while pfrio_clrflag the flags to
remove.
On exit, pfrio_nchange and pfrio_ndel contains the number of tables altered
or deleted by the kernel. Yes, tables can be deleted if one remove the
d521 1
a521 1
from a previous aborted transaction, and returns a new ticket.
d523 1
a523 1
pfrio_ticket contain a valid ticket to use for the following two IOCTLs.
d529 1
a529 1
On exit, io->pfrio_nadd and io->pfrio_nchange contains the number of tables
d533 1
a533 1
On entry, pfrio_table contain the table id and pfrio_buffer[pfrio_size]
d605 1
a606 1
.Xr ioctl 2 ,
@


1.26
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.25 2002/12/29 20:07:34 cedric Exp $
d393 6
d413 16
d442 14
d483 10
@


1.25
log
@Add support for radix tables for source and destination of PF rules.
ok dhartmei@@, mcbride@@, henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.24 2002/12/22 20:02:54 mcbride Exp $
d380 1
d384 4
d420 1
a420 1
.It Dv DIOCRDELTABLES Fa "struct pfioc_table"
d425 1
a425 1
.It Dv DIOCRSETTABLES Fa "struct pfioc_table"
d458 33
a490 16
.It Dv DIOCRWRAPTABLE Fa "struct pfioc_table"
Compute the SHA1 hash of a table and pack it into a pf_addr_wrap structure,
along with a magic mask in the first word of the mask.
On entry, pfrio_table contain the table id, and pfrio_buffer[pfrio_size]
should contain a buffer large enough to contain one pf_addr_wrap structure.
If the kernel should check if the table exists, then pfrio_exists must be
set to a nonzero value.
On exit, the kernel fill the pf_addr_wrap structure and set pfrio_exists
if that flag was requested.
.It Dv DIOCRUNWRTABLE Fa "struct pfioc_table"
Do the opposite of
.Dv DIOCRWRAPTABLE, and lookup a table from its hash value.
On entry, pfrio_buffer[pfrio_size] should point to a pf_addr_wrap structure
(a one-entry table).
On exit, the kernel fills pfrio_table or returns ENOENT if it cannot find
the matching table.
@


1.24
log
@Add altq ioctls. Just the bare minimum, more details to come.

ok henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.23 2002/12/22 02:04:00 mcbride Exp $
d364 105
@


1.23
log
@Bring this closer to the reality of pf_ioctl.c;
Not perfect, just a first pass.

ok henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.22 2002/12/15 18:58:50 margarida Exp $
d69 4
d77 1
a77 1
.It Dv DIOCADDADDR  Fa "struct pfioc_pooladdr"
d96 2
a97 2
DIOCADDRULE or DIOCCHANGERULE call. All other members of the structure
are ignored.
d118 1
a118 1
at the end of the inactive filter ruleset.
d123 2
a124 2
obtained through DIOCBEGINADDRS call. DIOCADDADDR must also be called if
any pool addresses are required.
d138 16
d159 1
a159 1
of rules in the active filter ruleset.
d161 1
a161 1
Returns filter
d193 32
a335 1
.Pp
@


1.22
log
@Add ioctl(2) .Xr

henning@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.21 2002/12/15 18:46:15 margarida Exp $
d69 25
d95 3
a97 1
Clears the inactive filter ruleset, returns ticket for subsequent
d102 7
a108 3
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_rule	 rule;
d112 1
a112 1
Adds filter
d117 9
a125 1
obtained through preceding DIOCBEGINRULES call.
d127 3
a129 1
is ignored.
d148 25
a172 36
.It Dv DIOCBEGINNATS   Fa "u_int32_t"
.It Dv DIOCADDNAT      Fa "struct pfioc_nat"
.Bd -literal
struct pfioc_nat {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_nat	 nat;
};
.Ed
.It Dv DIOCCOMMITNATS  Fa "u_int32_t"
.It Dv DIOCGETNATS     Fa "struct pfioc_nat"
.It Dv DIOCGETNAT      Fa "struct pfioc_nat"
.It Dv DIOCBEGINBINATS Fa "u_int32_t"
.It Dv DIOCADDBINAT    Fa "struct pfioc_binat"
.Bd -literal
struct pfioc_binat {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_binat	 binat;
};
.Ed
.It Dv DIOCCOMMITBINATS Fa "u_int32_t"
.It Dv DIOCGETBINATS   Fa "struct pfioc_binat"
.It Dv DIOCGETBINAT    Fa "struct pfioc_binat"
.It Dv DIOCBEGINRDRS   Fa "u_int32_t"
.It Dv DIOCADDRDR      Fa "struct pfioc_rdr"
.Bd -literal
struct pfioc_rdr {
	u_int32_t	 ticket;
	u_int32_t	 nr;
	struct pf_rdr	 rdr;
};
.Ed
.It Dv DIOCCOMMITRDRS  Fa "u_int32_t"
.It Dv DIOCGETRDRS     Fa "struct pfioc_rdr"
.It Dv DIOCGETRDR      Fa "struct pfioc_rdr"
d248 1
a248 1
        union {
d256 5
a260 2
.It Dv DIOCCHANGERULE  Fa "struct pfioc_changerule"
Adds or removes a filter rule in the active filter ruleset.
a261 6
struct pfioc_changerule {
	u_int32_t	 action;
	struct pf_rule	 oldrule;
	struct pf_rule	 newrule;
};

d264 1
a264 28
	  PF_CHANGE_REMOVE=5 };
.Ed
.It Dv DIOCCHANGENAT   Fa "struct pfioc_changenat"
Adds or removes a nat rule in the active nat ruleset.
.Bd -literal
struct pfioc_changenat {
	u_int32_t	 action;
	struct pf_nat	 oldnat;
	struct pf_nat	 newnat;
};
.Ed
.It Dv DIOCCHANGEBINAT   Fa "struct pfioc_changebinat"
Adds or removes a binat rule in the active binat ruleset.
.Bd -literal
struct pfioc_changebinat {
	u_int32_t	action;
	struct pf_binat	oldbinat;
	struct pf_binat	newbinat;
};
.Ed
.It Dv DIOCCHANGERDR   Fa "struct pfioc_changerdr"
Adds or removes a rdr rule in the active rdr ruleset.
.Bd -literal
struct pfioc_changerdr {
	u_int32_t	 action;
	struct pf_rdr	 oldrdr;
	struct pf_rdr	 newrdr;
};
d266 28
d369 1
a369 1
        if (ioctl(dev, DIOCNATLOOK, &nl))
@


1.21
log
@rule set(s) -> ruleset(s)

henning@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.20 2002/12/02 15:28:35 henning Exp $
d352 1
@


1.20
log
@spelling; from Jolan <jolan at cryptonomicon.org>
Danke!
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.19 2002/11/29 18:37:12 mickey Exp $
d43 1
a43 1
There are commands to enable and disable the filter, load rule sets,
d49 1
a49 1
Manipulations like loading a rule set that involve more than a single
d70 1
a70 1
Clears the inactive filter rule set, returns ticket for subsequent
d83 1
a83 1
at the end of the inactive filter rule set.
d90 1
a90 1
Switch inactive to active filter rule set.
d98 1
a98 1
of rules in the active filter rule set.
d227 1
a227 1
Adds or removes a filter rule in the active filter rule set.
d240 1
a240 1
Adds or removes a nat rule in the active nat rule set.
d249 1
a249 1
Adds or removes a binat rule in the active binat rule set.
d258 1
a258 1
Adds or removes a rdr rule in the active rdr rule set.
@


1.19
log
@das ist pfsync.4
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.18 2002/10/25 09:27:54 mpech Exp $
d50 1
a50 1
ioctl call require a so-called ticket, which prevents the occurance of
@


1.18
log
@Fix example.
If error don't use 0 in err/errx. More commits are comming.

dhartmei@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.17 2002/07/15 14:04:28 pb Exp $
d353 1
@


1.17
log
@fix pasto, additionally fix DIOCGETBINAT
both noticed by Dries Schellekens
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.16 2002/07/15 12:57:27 pb Exp $
d330 1
a330 1
		err(0, "open(\\"/dev/pf\\") failed");
d342 1
a342 1
		err(0, "DIOCNATLOOK");
@


1.16
log
@catch up with reality (DIOC[SG]ETLIMIT)

ok henning@@, dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.15 2002/03/26 09:38:30 dhartmei Exp $
d130 1
a130 1
.It Dv DIOCGETBINAT    Fa "struct pfioc_changebinat"
d280 2
a281 4
	int			psk_af;
	int			psk_proto;
	struct pf_rule_addr	psk_src;
	struct pf_rule_addr	psk_dst;
@


1.15
log
@Document DIOCKILLSTATES. From Denis Afonin.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.14 2002/02/14 23:03:19 dhartmei Exp $
d276 11
@


1.14
log
@Some fixes and additions, from Denis Afonin.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.13 2001/12/16 23:42:16 deraadt Exp $
d156 11
@


1.13
log
@KNF the code block
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.12 2001/12/10 22:02:05 weingart Exp $
d92 1
a92 2
.Va ticket
.
d119 12
d169 2
a170 2
	u_int64_t	 pcounters[2][3];
	u_int64_t	 bcounters[2];
d180 1
d193 1
d199 1
a202 1
Sets the debug level.
d223 1
d237 9
d263 2
@


1.12
log
@pf.4: Grammar & xref
pflog.4: New, thanks to frantzen for feedback.
Ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.11 2001/12/10 18:28:33 dhartmei Exp $
d254 2
a255 1
u_int32_t read_address(const char *s)
d258 1
d263 2
a264 1
void print_address(u_int32_t a)
d267 1
a267 1
	printf("%i.%i.%i.%i", a >> 24 & 255, a >> 16 & 255,
d271 2
a272 1
int main(int argc, char *argv[])
d274 1
a275 1
	struct pfioc_natlook nl;
d299 2
a300 1
	printf("internal host "); print_address(nl.rsaddr.v4.s_addr);
a301 2

	close(dev);
@


1.11
log
@Add an ioctl to add state entries (DIOCADDSTATE) for proxies.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.10 2001/11/13 19:09:59 dhartmei Exp $
d61 1
a61 1
pf supports to following
d304 1
@


1.10
log
@Escape \ in example.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.9 2001/11/13 18:51:24 dhartmei Exp $
d134 2
@


1.9
log
@Improve introduction, add example.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.8 2001/11/13 18:26:53 deraadt Exp $
d272 1
a272 1
		printf("%s <gwy addr> <gwy port> <ext addr> <ext port>\n",
d279 1
a279 1
		err(0, "open(\"/dev/pf\") failed");
d294 1
a294 1
	printf(":%u\n", ntohs(nl.rsport));
@


1.8
log
@kill BUGS sections that basically say "there might be bugs".  Like, WTF?
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.7 2001/10/05 14:45:53 mpech Exp $
d38 17
a54 8
The
.Nm
interface is a packet filter pseudo-device for IPv4 and IPv6.
.Pp
.Nm
is administered using the
.Xr pfctl 8
utility, or through an ioctl interface.
d239 61
@


1.7
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.6 2001/09/15 03:54:40 frantzen Exp $
a237 2
.Sh BUGS
Probably several.
@


1.6
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.5 2001/09/05 12:34:44 dhartmei Exp $
d81 2
a82 1
Switch inactive to active filter rule set. Requires
@


1.5
log
@Begin to document ioctl interface.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.4 2001/07/01 22:07:35 angelos Exp $
d40 1
a40 1
interface is a packet filter pseudo-device for IPv4.
d161 4
a164 4
	u_int32_t	 saddr;
	u_int32_t	 daddr;
	u_int32_t	 rsaddr;
	u_int32_t	 rdaddr;
@


1.4
log
@Remember to end list.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.3 2001/07/01 22:05:51 angelos Exp $
d50 178
@


1.3
log
@IPF cleanups; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.2 2001/06/25 05:45:52 kjell Exp $
d50 1
@


1.2
log
@fix copyright, for what it is worth
@
text
@d1 1
a1 1
.\"	$OpenBSD: pf.4,v 1.1 2001/06/25 05:37:04 kjell Exp $
d46 4
d53 5
a57 1
.\"
d59 1
a59 1
Probably Several
@


1.1
log
@Skeleton of a manpage for pf, dhartmei's shiny new packet filter.
This is a little sparse yet.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d3 1
a3 2
.\" Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
.\" All rights reserved.
@

