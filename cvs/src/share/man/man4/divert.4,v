head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.2
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6;
locks; strict;
comment	@.\" @;


1.17
date	2017.08.25.16.11.01;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	1EfY3IqW9800LVnB;

1.16
date	2015.09.10.17.55.21;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	PeV7Ql0T6htfMjhP;

1.15
date	2014.10.24.02.02.08;	author lteo;	state Exp;
branches;
next	1.14;
commitid	jDWIIhFiOYI8zp6w;

1.14
date	2014.06.05.03.36.46;	author lteo;	state Exp;
branches;
next	1.13;
commitid	n8riS3g7plEpwfzg;

1.13
date	2013.06.02.01.07.47;	author benno;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.01.18.41.43;	author lteo;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.24.22.57.41;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.21.15.25.42;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.21.13.06.02;	author benno;	state Exp;
branches;
next	1.8;

1.8
date	2012.03.29.17.09.41;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.25.16.34.56;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.06.18.32.43;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.06.15.39.24;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.04.20.02.36;	author jmc;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.08.17.52.17;	author michele;	state dead;
branches;
next	1.1;

1.1
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Document the limitations of divert-packet in divert(4) so that they
can be addressed.
input jmc@@ benno@@ mortimer@@
@
text
@.\"     $OpenBSD: divert.4,v 1.16 2015/09/10 17:55:21 schwarze Exp $
.\"
.\" Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
.\" Copyright (c) 2012-2014 Lawrence Teo <lteo@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: September 10 2015 $
.Dt DIVERT 4
.Os
.Sh NAME
.Nm divert
.Nd kernel packet diversion mechanism
.Sh SYNOPSIS
.In sys/types.h
.In sys/socket.h
.In netinet/in.h
.Ft int
.Fn socket AF_INET SOCK_RAW IPPROTO_DIVERT
.Ft int
.Fn socket AF_INET6 SOCK_RAW IPPROTO_DIVERT
.Sh DESCRIPTION
Divert sockets are part of a mechanism completely integrated with
.Xr pf 4
that queues raw packets from the kernel stack to userspace applications,
and vice versa.
.Pp
A divert socket must be bound to a divert port through
.Xr bind 2 ,
which only the superuser can do.
Divert ports have their own number space, completely separated from
.Xr tcp 4
and
.Xr udp 4 .
When
.Xr pf 4
processes a packet that matches a rule with the
.Ar divert-packet
parameter
(see
.Xr pf.conf 5
for details) it is sent to the divert socket listening on the
divert port specified in the rule.
Note that
.Ar divert-packet
should not be confused with
.Ar divert-to
or
.Ar divert-reply ,
which do not use divert sockets.
If there are no divert sockets listening, the packets are dropped.
.Pp
Packets can be read via
.Xr read 2 ,
.Xr recv 2 ,
or
.Xr recvfrom 2
from the divert socket.
The application that is processing the packets can then reinject them into the
kernel.
With
.Xr recvfrom 2 ,
an interface IP address is passed if it is an inbound packet.
Outbound packets provide the unspecified address.
When reinjecting, use this address as argument to
.Xr sendto 2 .
This allows the kernel to guess the original incoming interface and
and process it as an incoming packet.
If no interface IP address is given, the reinjected packet is treated
as an outgoing packet.
Since the userspace application could have modified the packets, upon
reinjection basic sanity checks are done to ensure that the packets are still
valid.
The packets' IPv4 and protocol checksums (TCP, UDP, ICMP, and ICMPv6) are also
recalculated.
.Pp
Writing to a divert socket can be achieved using
.Xr sendto 2
and it will skip
.Xr pf 4
filters to avoid loops.
Note that this means that a reinjected inbound packet will also not
run through the pf out rules after being forwarded.
A diverted packet that is not reinjected into the kernel stack is lost.
.Pp
Receive and send divert socket buffer space can be tuned through
.Xr sysctl 8 .
.Xr netstat 1
shows information relevant to divert sockets.
Note that the default is 64k and too short to handle full sized UDP
packets.
.Pp
The IP_DIVERTFL socket option on the IPPROTO_IP level controls
whether both inbound and outbound packets are diverted (the default)
or only packets travelling in one direction.
It cannot be reset once set.
Valid values are
.Dv IPPROTO_DIVERT_INIT
for the direction of the initial packet of a flow, and
.Dv IPPROTO_DIVERT_RESP
for the direction of the response packets.
The direction is relative to the packet direction.
So for pf out rules, it is the other way around.
If one filter is active, it specifies which packets should not be
diverted.
Both directions can be combined as bit fields, but then the traffic
is not filtered; not using the P_DIVERTFL option has the same effect.
.Sh EXAMPLES
The following PF rule queues outbound IPv4 packets to TCP port 80,
as well as the return traffic, on the em0 interface to divert port 700:
.Bd -literal -offset indent
pass out on em0 inet proto tcp to port 80 divert-packet port 700
.Ed
.Pp
The following program reads packets on divert port 700 and reinjects them
back into the kernel.
This program does not perform any processing of the packets,
apart from discarding invalid IP packets.
.Bd -literal
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>
#include <err.h>

#define DIVERT_PORT 700

int
main(int argc, char *argv[])
{
	int fd, s;
	struct sockaddr_in sin;
	socklen_t sin_len;

	fd = socket(AF_INET, SOCK_RAW, IPPROTO_DIVERT);
	if (fd == -1)
		err(1, "socket");

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(DIVERT_PORT);
	sin.sin_addr.s_addr = 0;

	sin_len = sizeof(struct sockaddr_in);

	s = bind(fd, (struct sockaddr *) &sin, sin_len);
	if (s == -1)
		err(1, "bind");

	for (;;) {
		ssize_t n;
		char packet[IP_MAXPACKET];
		struct ip *ip;
		struct tcphdr *th;
		int hlen;
		char src[48], dst[48];

		memset(packet, 0, sizeof(packet));
		n = recvfrom(fd, packet, sizeof(packet), 0,
		    (struct sockaddr *) &sin, &sin_len);
		if (n == -1) {
			warn("recvfrom");
			continue;
		}
		if (n < sizeof(struct ip)) {
			warnx("packet is too short");
			continue;
		}

		ip = (struct ip *) packet;
		hlen = ip->ip_hl << 2;
		if (hlen < sizeof(struct ip) || ntohs(ip->ip_len) < hlen ||
		    n < ntohs(ip->ip_len)) {
			warnx("invalid IPv4 packet");
			continue;
		}

		th = (struct tcphdr *) (packet + hlen);

		if (inet_ntop(AF_INET, &ip->ip_src, src,
		    sizeof(src)) == NULL)
			(void)strlcpy(src, "?", sizeof(src));

		if (inet_ntop(AF_INET, &ip->ip_dst, dst,
		    sizeof(dst)) == NULL)
			(void)strlcpy(dst, "?", sizeof(dst));

		printf("%s:%u -> %s:%u\en",
		    src,
		    ntohs(th->th_sport),
		    dst,
		    ntohs(th->th_dport)
		);

		n = sendto(fd, packet, n, 0, (struct sockaddr *) &sin,
		    sin_len);
		if (n == -1)
			warn("sendto");
	}

	return 0;
}
.Ed
.Sh SEE ALSO
.Xr setsockopt 2 ,
.Xr socket 2 ,
.Xr ip 4 ,
.Xr pf.conf 5
.Sh HISTORY
The
.Nm
protocol first appeared in
.Ox 4.7 .
@


1.16
log
@use .In rather than .Fd #include
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.15 2014/10/24 02:02:08 lteo Exp $
d18 1
a18 1
.Dd $Mdocdate: October 24 2014 $
a60 3
.Xr pf 4
reassembles TCP streams by default (if IP reassembly is not disabled)
before sending them to the divert sockets.
d71 10
a80 4
After being reinjected, inbound and outbound packets are treated differently.
Inbound packets are added to the relevant input queue and a soft interrupt is
scheduled to signal that a new packet is ready to be processed; outbound ones
are processed directly by the relevant IPv4/IPv6 output function.
d92 2
d100 2
d112 6
@


1.15
log
@netinet/in_systm.h is not needed by the example program

pointed out by millert@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.14 2014/06/05 03:36:46 lteo Exp $
d18 1
a18 1
.Dd $Mdocdate: June 5 2014 $
d25 3
a27 3
.Fd #include <sys/types.h>
.Fd #include <sys/socket.h>
.Fd #include <netinet/in.h>
@


1.14
log
@Improve the divert(4) example program:

- Remove unnecessary includes
- bzero -> memset
- Better sanity checks and return value checks
- Use the tcphdr struct instead of tcpiphdr so that the program will
  work even if there are IP options
- Use more conventional variable names and buffer sizes

Also add myself to the copyright.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.13 2013/06/02 01:07:47 benno Exp $
d18 1
a18 1
.Dd $Mdocdate: June 2 2013 $
a119 1
#include <netinet/in_systm.h>
@


1.13
log
@improve the divert-* description a bit more
ok lteo & jmc
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.12 2013/06/01 18:41:43 lteo Exp $
d4 1
d18 1
a18 1
.Dd $Mdocdate: June 1 2013 $
a121 1
#include <netinet/ip_var.h>
a122 1
#include <netinet/tcpip.h>
a124 1
#include <stdlib.h>
d141 1
a141 1
	bzero(&sin, sizeof(sin));
d154 5
a158 4
		char packet[10000];
		struct ip *ip_hdr;
		struct tcpiphdr *tcpip_hdr;
		char srcip[40], dstip[40];
d160 1
a160 1
		bzero(packet, sizeof(packet));
d163 6
a168 10

		tcpip_hdr = (struct tcpiphdr *) packet;
		ip_hdr = (struct ip *) packet;

		bzero(srcip, sizeof(srcip));
		bzero(dstip, sizeof(dstip));

		if (inet_ntop(AF_INET, &ip_hdr->ip_src, srcip,
		    sizeof(srcip)) == NULL) {
			fprintf(stderr, "Invalid IPv4 source packet\en");
d171 6
a176 4
		if (inet_ntop(AF_INET, &ip_hdr->ip_dst, dstip,
		    sizeof(dstip)) == NULL) {
			fprintf(stderr, "Invalid IPv4 destination "
			    "packet\en");
d180 10
d191 4
a194 4
			srcip,
			ntohs(tcpip_hdr->ti_sport),
			dstip,
			ntohs(tcpip_hdr->ti_dport)
d199 2
@


1.12
log
@Document my divert(4) changes done in April 2013, where reinjected
packets will now go through basic sanity checks and will have their
IPv4 and protocol checksums (TCP, UDP, ICMP, and ICMPv6) recalculated.

Also clarify that divert(4) relates to the PF divert-packet parameter,
not divert-to (prodded by beck@@, also suggested by benno@@ and reyk@@).

ok benno jmc
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.11 2012/10/24 22:57:41 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 24 2012 $
d51 1
a51 1
for details) it is immediately sent to the divert socket listening on the
d56 4
a59 2
.Ar divert-to ,
which does not use divert sockets.
@


1.11
log
@clarify -r1.9; help/ok benno
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.10 2012/10/21 15:25:42 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 21 2012 $
d46 4
a49 1
processes a packet that matches a divert rule (see
d52 6
a57 1
port specified in the rule.
d74 6
a79 2
are processed directly by the relevant IP/IPv6 output function.
The packets' checksums are recalculated upon reinjection.
@


1.10
log
@tweak previous;
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.9 2012/10/21 13:06:02 benno Exp $
d81 4
a84 3
The IP_DIVERTFL socket option on the IPPROTO_IP level controls if inbound and
outbound packets are diverted (the default) or only one direction.
Only the superuser can change this setting, and it cannot be reset once set.
@


1.9
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.8 2012/03/29 17:09:41 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: March 29 2012 $
d87 2
a88 3
.Dv IPPROTO_DIVERT_RESP 
for the direction of the response packets .
.El
d183 1
a184 1
.Xr setsockopt 2 ,
@


1.8
log
@avoid line wrap in EXAMPLES; from Thomas Pfaff
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.7 2012/01/25 16:34:56 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: January 25 2012 $
d80 10
d185 1
@


1.7
log
@add an EXAMPLES section; from Lawrence Teo
tweaked slightly by myself, and ok michele
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.6 2009/12/06 18:32:43 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: December 6 2009 $
d138 2
a139 2
		n = recvfrom(fd, packet, sizeof(packet), 0, (struct sockaddr *) &sin,
		    &sin_len);
d147 2
a148 1
		if (inet_ntop(AF_INET, &ip_hdr->ip_src, srcip, sizeof(srcip)) == NULL) {
d152 4
a155 2
		if (inet_ntop(AF_INET, &ip_hdr->ip_dst, dstip, sizeof(dstip)) == NULL) {
			fprintf(stderr, "Invalid IPv4 destination packet\en");
d166 2
a167 1
		n = sendto(fd, packet, n, 0, (struct sockaddr *) &sin, sin_len);
@


1.6
log
@missing space;
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.5 2009/12/06 15:39:24 michele Exp $
d80 89
@


1.5
log
@Improve divert.4 man page.
Be more clear about what happens to the packets when they are queued to
userspace or reinjected in the kernel.

input by jmc@@
ok claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.4 2009/10/04 20:02:36 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 4 2009 $
d88 1
a88 1
.Ox 4.7.
@


1.4
log
@tweak previous;
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.3 2009/10/04 16:08:37 michele Exp $
d29 2
d32 9
a40 7
Divert sockets can be bound through
.Xr bind 2
to a divert port and they will receive every packet
diverted to that port by
.Xr pf 4 .
Divert ports have their own number space, completely
separated from
d43 4
a46 3
.Xr udp 4
ones.
Consult
d48 2
a49 3
for the correct syntax.
Packets can also be reinjected into the divert socket, in which case they
re-enter kernel packet processing skipping
d51 3
a53 1
filters, avoiding loops.
d55 1
a55 1
Diverted packets can be read via
d61 8
a68 6
.Xr pf 4
will reassemble the IP packets by default before sending them to the divert
socket.
In addition, TCP reassembling is enabled for packet divert rules; see
.Xr pf.conf 5
for details.
d74 1
d76 4
a79 4
If
.Xr pf 4
diverts packets but there are no divert sockets listening,
the packets are dropped.
@


1.3
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD$
d17 1
a17 2

.Dd $Mdocdate: Sep 7 2009 $
d22 1
a22 1
.Nd Kernel packet diversion mechanism
d58 1
a58 1
In addition, TCP reassembling is enabled for packet divert rules, see
d74 1
a74 1
.Xr pf.conf 5 ,
@


1.2
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
.\"     $OpenBSD: divert.4,v 1.1 2009/09/08 17:00:41 michele Exp $
d18 1
a18 1
.Dd $Mdocdate: September 8 2009 $
d36 6
d59 1
a59 1
In addition, TCP reassembling can be enabled on a per-rule basis, see
@


1.1
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@d1 1
a1 1
.\"     $OpenBSD$
d18 1
a18 1
.Dd $Mdocdate: Sep 7 2009 $
@

