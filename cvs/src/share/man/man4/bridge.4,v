head	1.75;
access;
symbols
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.73.0.4
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.71.0.10
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.8
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.71.0.6
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.70.0.2
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.69.0.14
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.69.0.12
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.10
	OPENBSD_5_0:1.69.0.8
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.69.0.6
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.69.0.4
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.66.0.10
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.66.0.6
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.66.0.4
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.66.0.2
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.64.0.2
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.61.0.2
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.58.0.8
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.58.0.6
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.58.0.4
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.53.0.2
	OPENBSD_3_4_BASE:1.53
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8;
locks; strict;
comment	@.\" @;


1.75
date	2016.09.04.18.55.08;	author jmc;	state Exp;
branches;
next	1.74;
commitid	N4NpK7vrN4Skkw3p;

1.74
date	2016.09.04.16.06.47;	author yasuoka;	state Exp;
branches;
next	1.73;
commitid	rlsPkGMnLukqwJ3t;

1.73
date	2016.06.07.20.25.48;	author sthen;	state Exp;
branches;
next	1.72;
commitid	dbMM8GJxFHKiOURH;

1.72
date	2015.09.14.17.09.26;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	S61RkPHYGNo5TpDc;

1.71
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2013.07.16.16.05.48;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2009.12.11.07.43.59;	author jmc;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.22.22.01.55;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.09.03.16.07;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.03.20.15.06;	author sthen;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.31.19.19.49;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.26.18.03.10;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.23.07.01.35;	author jmc;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.22.22.46.41;	author mcbride;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.12.13.33.57;	author jmc;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.26.04.02.59;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.09.19.03.04;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.11.16.55.43;	author jaredy;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.04.16.29.30;	author cedric;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.04.15.53.22;	author cedric;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.08.10.03.43;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.09.16.06.07;	author jmc;	state Exp;
branches;
next	1.53;

1.53
date	2003.07.09.13.26.20;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.25.13.29.31;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.11.17.03.09;	author pb;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.06.10.29.41;	author jmc;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.02.18.51.33;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.05.13.51.57;	author jmc;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.26.08.26.01;	author jmc;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.25.22.34.12;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.18.07.35.13;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.30.22.02.13;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.30.21.45.25;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.15.02.26.44;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.28.17.50.04;	author jasoni;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.28.02.21.06;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.15.08.40.56;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.05.16.08.23;	author hugh;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.07.12.24.39;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.05.14.45.53;	author mpech;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.03.15.21.16;	author mpech;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.18.22.53.57;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.01.22.02.15;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.26.23.24.10;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.23.07.19.32;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.30.03.24.15;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.30.21.57.21;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2000.12.21.05.32.52;	author aaron;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.10.20.02.16;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.19.18.21.27;	author hin;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.18.16.32.11;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.13.18.56.50;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.03.05.04.18;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.02.18.43.49;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.03.21.19.36;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.11.04.22.27;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.05.02.22.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.02.20.12.11;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.25.22.06.27;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.10.22.46.12;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.01.19.14.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.12.06.01.32.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.09.23.04.12.04;	author alex;	state Exp;
branches;
next	1.12;

1.12
date	99.09.03.12.47.12;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	99.07.09.13.35.48;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.06.25.22.27.46;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	99.05.17.14.57.43;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	99.03.31.02.00.29;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	99.03.19.22.47.33;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.03.19.02.46.54;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.03.12.02.40.42;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.03.05.21.10.58;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.16.55.56;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.02.27.07.55.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.17.01.36;	author jason;	state Exp;
branches;
next	;


desc
@@


1.75
log
@tweak previous;
@
text
@.\"	$OpenBSD: bridge.4,v 1.74 2016/09/04 16:06:47 yasuoka Exp $
.\"
.\" Copyright (c) 1999-2001 Jason L. Wright (jason@@thought.net)
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
.\" DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
.\" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: September 4 2016 $
.Dt BRIDGE 4
.Os
.Sh NAME
.Nm bridge
.Nd Ethernet bridge interface
.Sh SYNOPSIS
.Cd "pseudo-device bridge"
.Pp
.In sys/types.h
.In net/if.h
.In netinet/in.h
.In netinet/if_ether.h
.In net/if_bridge.h
.Sh DESCRIPTION
The
.Nm
device creates a logical link between two or more Ethernet interfaces or
encapsulation interfaces (see
.Xr etherip 4 ) .
This link between the interfaces selectively forwards frames from
each interface on the bridge to every other interface on the bridge.
A bridge can serve several services, including isolation of traffic between
sets of machines so that traffic local to one set of machines is not
available on the wire of another set of machines, and it can act as
a transparent filter for
.Xr ip 4
datagrams.
.Pp
A
.Nm
interface can be created at runtime using the
.Ic ifconfig bridge Ns Ar N Ic create
command or by setting up a
.Xr hostname.if 5
configuration file for
.Xr netstart 8 .
.Pp
The bridges provided by this interface are learning bridges with
filtering; see
.Xr pf 4 .
In general a bridge works like a hub, forwarding traffic from one interface
to another.
It differs from a hub in that it will "learn" which machines
are on each of its attached segments by actively listening to
incoming traffic and examining the headers of each frame.
A table is built containing the MAC address and segment to which the
MAC address is attached.
This allows a bridge to be more selective about what it forwards,
which can be used to reduce traffic on a set of segments and also to provide
an IP firewall without changing the topology of the network.
.Pp
The algorithm works as follows by default, but can be modified via
.Xr ioctl 2
or the utility
.Xr ifconfig 8 .
When a frame comes in, the origin segment and the source address are
recorded.
If the bridge has no knowledge about where the destination is to be found,
the bridge will forward the frame to all attached segments.
If the destination is known to be on a different segment from its origin, the
bridge will forward the packet only to the destination segment.
If the destination is on the same segment as the origin segment, the bridge
will drop the packet because the receiver has already had a chance to see
the frame.
Before forwarding a frame, the bridge will check to see if the packet
contains an
.Xr ip 4
or
.Xr ip6 4
datagram; if so, the datagram is run through the
pf interface so that it can be filtered.
See the
.Sx NOTES
section for details.
.Sh SPANNING TREE
The bridge has support for 802.1D-2004 Spanning Tree Protocol (STP),
which can be used to detect and remove loops in a network topology.
Using the
.Cm stp
or
.Cm -stp
commands
to
.Nm ,
STP can be enabled or disabled on each port.
.Pp
The bridge will use the Rapid Spanning Tree Protocol (RSTP) by default
to allow rapid transitions to the forwarding state.
The
.Cm proto
command to
.Nm
can be used to force operation in the common Spanning Tree Protocol
without rapid state transitions.
Note that RSTP will be compatible with remote bridges running common STP.
.Pp
STP will not work on
.Xr etherip 4
members because they lack a hardware MAC address.
.Sh SPAN PORTS
The bridge can have interfaces added to it as span ports.
Span ports transmit a copy of every frame received by the bridge.
This is most useful for snooping a bridged network passively on
another host connected to one of the span ports of the bridge.
Span ports cannot be bridge members; instead, the
.Cm addspan
and
.Cm delspan
commands are used to add and delete span ports to and from a bridge.
.Sh IOCTLS
A
.Nm
interface responds to all of the
.Xr ioctl 2
calls specific to other interfaces listed in
.Xr netintro 4 .
The following
.Xr ioctl 2
calls are specific to
.Nm
devices.
They are defined in
.In sys/sockio.h .
Some
.Xr ioctl 2
calls are used by
.Xr switch 4
as well.
.Bl -tag -width Ds
.It Dv SIOCBRDGIFS Fa "struct ifbifconf *"
Retrieve member interface list from a bridge.
This request takes an
.Vt ifbifconf
structure (see below) as a value-result parameter.
The
.Va ifbic_len
field should be initially set to the size of the buffer
pointed to by
.Va ifbic_buf .
On return it will contain the length, in bytes, of the configuration
list.
.Pp
Alternatively, if the
.Va ifbic_len
passed in is set to 0,
.Dv SIOCBRDGIFS
will set
.Va ifbic_len
to the size that
.Va ifbic_buf
needs to be to fit the entire configuration list,
and will not fill in the other parameters.
This is useful for determining the exact size that
.Va ifbic_buf
needs to be in advance.
.Pp
The argument structure is defined as follows:
.Bd -literal
struct ifbreq {
	char	  ifbr_name[IFNAMSIZ];	 /* bridge ifs name */
	char	  ifbr_ifsname[IFNAMSIZ];/* member ifs name */
	u_int32_t ifbr_ifsflags;  /* member ifs flags */
	u_int8_t  ifbr_state;	  /* member stp state */
	u_int8_t  ifbr_priority;  /* member stp priority */
	u_int32_t ifbr_portno;	  /* member port number */
	u_int32_t ifbr_path_cost; /* member stp path cost */
};

/* ifbr_ifsflags flags about interfaces */
#define	IFBIF_LEARNING	 0x0001 /* ifs can learn */
#define	IFBIF_DISCOVER	 0x0002 /* sends packets w/unknown dst */
#define	IFBIF_BLOCKNONIP 0x0004 /* ifs blocks non-IP/ARP in/out */
#define	IFBIF_STP	 0x0008 /* participate in spanning tree*/
#define	IFBIF_SPAN	 0x0100 /* ifs is a span port (ro) */
#define	IFBIF_RO_MASK	 0xff00 /* read only bits */

struct ifbifconf {
	char	  ifbic_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t ifbic_len;		/* buffer size */
	union {
		caddr_t	ifbicu_buf;
		struct	ifbreq *ifbicu_req;
	} ifbic_ifbicu;
#define	ifbic_buf	ifbic_ifbicu.ifbicu_buf
#define	ifbic_req	ifbic_ifbicu.ifbicu_req
};
.Ed
.It Dv SIOCBRDGADD Fa "struct ifbreq *"
Add the interface named in
.Va ifbr_ifsname
to the bridge named in
.Va ifbr_name .
.It Dv SIOCBRDGDEL Fa "struct ifbreq *"
Delete the interface named in
.Va ifbr_ifsname
from the bridge named in
.Va ifbr_name .
.It Dv SIOCBRDGADDS Fa "struct ifbreq *"
Add the interface named in
.Va ifbr_ifsname
as a span port to the bridge named in
.Va ifbr_name .
.It Dv SIOCBRDGDELS Fa "struct ifbreq *"
Delete the interface named in
.Va ifbr_ifsname
from the list of span ports of the bridge named in
.Va ifbr_name .
.It Dv SIOCBRDGSIFFLGS Fa "struct ifbreq *"
Set the bridge member interface flags for the interface named in
.Va ifbr_ifsname
attached to the bridge
.Va ifbr_name .
If the flag
.Dv IFBIF_LEARNING
is set on an interface, source addresses from frames received on the
interface are recorded in the address cache.
If the flag
.Dv IFBIF_DISCOVER
is set, the interface will receive packets destined for unknown
destinations, otherwise a frame that has a destination not found
in the address cache is not forwarded to this interface.
The default for newly added interfaces has both flags set.
If the flag
.Dv IFBIF_BLOCKNONIP
is set, only
.Xr ip 4 ,
.Xr ip6 4 ,
.Xr arp 4 ,
and
Reverse ARP packets will be bridged from and to the interface.
.It Dv SIOCBRDGGIFFLGS Fa "struct ifbreq *"
Retrieve the bridge member interface flags for the interface named in
.Va ifbr_ifsname
attached to the bridge
.Va ifbr_name .
.It Dv SIOCBRDGRTS Fa "struct ifbaconf *"
Retrieve the address cache of the bridge named in
.Va ifbac_name .
This request takes an
.Vt ifbaconf
structure (see below) as a value-result parameter.
The
.Va ifbac_len
field should be initially set to the size of the buffer pointed to by
.Va ifbac_buf .
On return, it will contain the length, in bytes, of the configuration list.
.Pp
Alternatively, if the
.Va ifbac_len
passed in is set to 0,
.Dv SIOCBRDGRTS
will set it to the size that
.Va ifbac_buf
needs to be to fit the entire configuration list, and will not fill in the other
parameters.
As with
.Dv SIOCBRDGIFS ,
this is useful for determining the exact size that
.Va ifbac_buf
needs to be in advance.
.Pp
The argument structure is defined as follows:
.Bd -literal
struct ifbareq {
	char	 ifba_name[IFNAMSIZ];	/* bridge name */
	char	 ifba_ifsname[IFNAMSIZ];/* destination ifs */
	u_int8_t ifba_age;		/* address age */
	u_int8_t ifba_flags;		/* address flags */
	struct ether_addr ifba_dst;	/* destination addr */
};

#define	IFBAF_TYPEMASK	0x03		/* address type mask */
#define	IFBAF_DYNAMIC	0x00		/* dynamically learned */
#define	IFBAF_STATIC	0x01		/* static address */

struct ifbaconf {
	char	  ifbac_name[IFNAMSIZ];	/* bridge ifs name */
	u_int32_t ifbac_len;		/* buffer size */
	union {
		caddr_t	ifbacu_buf;	/* buffer */
		struct ifbareq *ifbacu_req; /* request pointer */
	} ifbac_ifbacu;
#define	ifbac_buf	ifbac_ifbacu.ifbacu_buf
#define	ifbac_req	ifbac_ifbacu.ifbacu_req
};
.Ed
.Pp
Address cache entries with the type set to
.Dv IFBAF_DYNAMIC
in
.Va ifba_flags
are entries learned by the bridge.
Entries with the type set to
.Dv IFBAF_STATIC
are manually added entries.
.It Dv SIOCBRDGSADDR Fa "struct ifbareq *"
Add an entry, manually, to the address cache for the bridge named in
.Va ifba_name .
The address and its associated interface and flags are set in the
.Va ifba_dst ,
.Va ifba_ifsname ,
and
.Va ifba_flags
fields, respectively.
.It Dv SIOCBRDGDADDR Fa "struct ifbareq *"
Delete an entry from the address cache of the bridge named in
.Va ifba_name .
Entries are deleted strictly based on the address field
.Va ifba_dst .
.It Dv SIOCBRDGFLUSH Fa "struct ifbreq *"
Flush addresses from the cache.
.Va ifbr_name
contains the name of the bridge device, and
.Va ifbr_ifsflags
should be set to
.Dv IFBF_FLUSHALL
to flush all addresses from the cache or
.Dv IFBF_FLUSHDYN
to flush only the dynamically learned addresses from the cache.
.It Dv SIOCBRDGSCACHE Fa "struct ifbrparam *"
Set the maximum address cache size for the bridge named in
.Va ifbrp_name
to
.Va ifbrp_csize
entries.
.Pp
The argument structure is as follows:
.Bd -literal
struct ifbrparam {
	char		  ifbrp_name[IFNAMSIZ];
	union {
		u_int32_t ifbrpu_csize;	    /* cache size */
		int	  ifbrpu_ctime;	    /* cache time */
		u_int16_t ifbrpu_prio;	    /* bridge priority */
		u_int8_t  ifbrpu_hellotime; /* hello time */
		u_int8_t  ifbrpu_fwddelay;  /* fwd delay */
		u_int8_t  ifbrpu_maxage;    /* max age */
		u_int64_t ifbrpu_datapath;  /* datapath-id */
		u_int32_t ifbrpu_maxgroup;  /* group size */
	} ifbrp_ifbrpu;
};
#define	ifbrp_csize	ifbrp_ifbrpu.ifbrpu_csize
#define	ifbrp_ctime	ifbrp_ifbrpu.ifbrpu_ctime
#define	ifbrp_prio	ifbrp_ifbrpu.ifbrpu_prio
#define	ifbrp_hellotime	ifbrp_ifbrpu.ifbrpu_hellotime
#define	ifbrp_fwddelay	ifbrp_ifbrpu.ifbrpu_fwddelay
#define	ifbrp_maxage	ifbrp_ifbrpu.ifbrpu_maxage
#define	ifbrp_datapath  ifbrp_ifbrpu.ifbrpu_datapath
#define	ifbrp_maxflow   ifbrp_ifbrpu.ifbrpu_csize
#define	ifbrp_maxgroup  ifbrp_ifbrpu.ifbrpu_maxgroup
.Ed
.Pp
Note that the
.Va ifbrp_ctime , ifbrp_hellotime , ifbrp_fwddelay
and
.Va ifbrp_maxage
fields are in seconds.
.It Dv SIOCBRDGGCACHE Fa "struct ifbrparam *"
Retrieve the maximum size of the address cache for the bridge
.Va ifbrp_name .
.It Dv SIOCBRDGSTO Fa "struct ifbrparam *"
Set the time, in seconds, for how long addresses which have not been
seen on the network (i.e., have not transmitted a packet) will remain in
the cache to the value
.Va ifbrp_ctime .
If the time is set to zero, no aging is performed on the address cache.
.It Dv SIOCBRDGGTO Fa "struct ifbrparam *"
Retrieve the address cache expiration time (see above).
.It Dv SIOCBRDGARL Fa "struct ifbrlreq *"
Add an Ethernet address filtering rule to the bridge on a specific interface.
.Va ifbr_name
contains the name of the bridge device, and
.Va ifbr_ifsname
contains the name of the bridge member interface.
.Pp
Rules are applied in the order in which they were added to the bridge,
and the first matching rule's action parameter determines the fate of
the packet.
The
.Va ifbr_action
field is one of
.Dv BRL_ACTION_PASS
or
.Dv BRL_ACTION_BLOCK ,
to pass or block matching frames, respectively.
The
.Va ifbr_flags
field specifies whether the rule should match on input, output, or both
by using the flags
.Dv BRL_FLAG_IN
and
.Dv BRL_FLAG_OUT .
At least one of these flags must be set.
.Pp
The
.Va ifbr_flags
field
also specifies whether either (or both) of the source and destination
addresses should be matched by using the
.Dv BRL_FLAG_SRCVALID
and
.Dv BRL_FLAG_DSTVALID
flags.
The
.Va ifbr_src
field is the source address that triggers the rule (only considered if
.Va ifbr_flags
has the
.Dv BRL_FLAG_SRCVALID
bit set).
The
.Va ifbr_src
field is the destination address that triggers the rule (only considered if
.Va ifbr_flags
has the
.Dv BRL_FLAG_DSTVALID
bit set).
If neither bit is set, the rule matches all frames.
.Pp
The argument structure is as follows:
.Bd -literal
struct ifbrlreq {
	char	 ifbr_name[IFNAMSIZ];	 /* bridge ifs name */
	char	 ifbr_ifsname[IFNAMSIZ]; /* member ifs name */
	u_int8_t ifbr_action;		 /* disposition */
	u_int8_t ifbr_flags;		 /* flags */
	struct ether_addr ifbr_src;	 /* source mac */
	struct ether_addr ifbr_dst;	 /* destination mac */
	char	 ifbr_tagname[PF_TAG_NAME_SIZE]; /* pf tagname */
};
#define	BRL_ACTION_BLOCK	0x01	 /* block frame */
#define	BRL_ACTION_PASS		0x02	 /* pass frame */
#define	BRL_FLAG_IN		0x08	 /* input rule */
#define	BRL_FLAG_OUT		0x04	 /* output rule */
#define	BRL_FLAG_SRCVALID	0x02	 /* src valid */
#define	BRL_FLAG_DSTVALID	0x01	 /* dst valid */
.Ed
.It Dv SIOCBRDGFRL Fa "struct ifbrlreq *"
Remove all filtering rules from a bridge interface member.
.Va ifbr_name
contains the name of the bridge device, and
.Va ifbr_ifsname
contains the name of the bridge member interface.
.It Dv SIOCBRDGGRL Fa "struct ifbrlconf *"
Retrieve all of the rules from the bridge,
.Va ifbrl_name ,
for the member interface,
.Va ifbrl_ifsname .
This request takes an
.Vt ifbrlconf
structure (see below) as a value-result parameter.
The
.Va ifbrl_len
field should be initially set to the size of the buffer pointed to by
.Va ifbrl_buf .
On return, it will contain the length, in bytes, of the configuration list.
.Pp
Alternatively, if the
.Va ifbrl_len
passed in is set to 0,
.Dv SIOCBRDGGRL
will set it to the size that
.Va ifbrl_buf
needs to be to fit the entire configuration list, and will not fill in the other
parameters.
As with
.Dv SIOCBRDGIFS ,
this is useful for determining the exact size that
.Va ifbrl_buf
needs to be in advance.
.Pp
The argument structure is defined as follows:
.Bd -literal
struct ifbrlconf {
	char	  ifbrl_name[IFNAMSIZ];	   /* bridge ifs name */
	char	  ifbrl_ifsname[IFNAMSIZ]; /* member ifs name */
	u_int32_t ifbrl_len;		   /* buffer size */
	union {
		caddr_t	ifbrlu_buf;
		struct	ifbrlreq *ifbrlu_req;
	} ifbrl_ifbrlu;
#define	ifbrl_buf ifbrl_ifbrlu.ifbrlu_buf
#define	ifbrl_req ifbrl_ifbrlu.ifbrlu_req
};
.Ed
.\" .It Dv SIOCBRDGGSIFS Fa "struct ifbreq *"
.It Dv SIOCBRDGGPRI Fa "struct ifbrparam *"
Retrieve the Spanning Tree Protocol (STP) priority parameter of the bridge into
the
.Va ifbrp_prio
field.
.It Dv SIOCBRDGSPRI Fa "struct ifbrparam *"
Set the STP priority parameter of the bridge to the value in
.Va ifbrp_prio .
.It Dv SIOCBRDGGHT Fa "struct ifbrparam *"
Retrieve the STP hello time parameter, in seconds, of the bridge into the
.Va ifbrp_hellotime
field.
.It Dv SIOCBRDGSHT Fa "struct ifbrparam *"
Set the STP hello time parameter, in seconds, of the bridge to the value in
.Va ifbrp_hellotime .
The value in
.Va ifbrp_hellotime
cannot be zero.
.It Dv SIOCBRDGGFD Fa "struct ifbrparam *"
Retrieve the STP forward delay parameter, in seconds, of the bridge into the
.Va ifbrp_fwddelay
field.
.It Dv SIOCBRDGSFD Fa "struct ifbrparam *"
Set the STP forward delay parameter, in seconds, of the bridge to the value in
.Va ifbrp_fwddelay .
The value in
.Va ifbrp_fwddelay
cannot be zero.
.It Dv SIOCBRDGGMA Fa "struct ifbrparam *"
Retrieve the STP maximum age parameter, in seconds, of the bridge into the
.Va ifbrp_maxage
field.
.It Dv SIOCBRDGSMA Fa "struct ifbrparam *"
Set the STP maximum age parameter, in seconds, of the bridge to the value in
.Va ifbrp_maxage .
The value in
.Va ifbrp_maxage
cannot be zero.
.It Dv SIOCBRDGSIFPRIO Fa "struct ifbreq *"
Set the STP priority parameter of the interface named in
.Va ifbr_ifsname
to the value in
.Va ifbr_priority .
.It Dv SIOCBRDGSIFCOST Fa "struct ifbreq *"
Set the STP cost parameter of the interface named in
.Va ifbr_ifsname
to the value in
.Va ifbr_path_cost .
The value in
.Va ifbr_path_cost
must be greater than or equal to one.
.El
.Sh ERRORS
If the
.Xr ioctl 2
call fails,
.Xr errno 2
is set to one of the following values:
.Bl -tag -width Er
.It Bq Er ENOENT
For an add request, this means that the named interface is not configured
into the system.
For a delete operation, it means that the named interface is not a member
of the bridge.
For an address cache deletion, the address was not found in the table.
.It Bq Er ENOMEM
Memory could not be allocated for an interface or cache entry
to be added to the bridge.
.It Bq Er EEXIST
The named interface is already a member of the bridge.
.It Bq Er EBUSY
The named interface is already a member of another bridge.
.It Bq Er EINVAL
The named interface is not an Ethernet interface, or an invalid ioctl
was performed on the bridge.
.It Bq Er ENETDOWN
Address cache operation (flush, add, or delete) on a bridge that is
in the down state.
.It Bq Er EPERM
Super-user privilege is required to add and delete interfaces to and from
bridges and to set the bridge interface flags.
.It Bq Er EFAULT
The buffer used in a
.Dv SIOCBRDGIFS
or
.Dv SIOCBRDGRTS
request points outside of the process's allocated address space.
.It Bq Er ESRCH
No such member interface in the bridge.
.El
.Sh NOTES
Bridged packets pass through
.Xr pf 4
filters once as input on the receiving interface and once
as output on all interfaces on which they are forwarded.
In order to pass through the bridge packets must pass
any
.Ar in
rules on the input and any
.Ar out
rules on the output interface.
Packets may be blocked either entering or leaving the bridge.
.Pp
Return packets generated by pf itself are not routed using the
kernel routing table.
Instead, pf will send these replies back to the same Ethernet
address that the original packet came from.
This applies to rules with
.Ic return ,
.Ic return-rst ,
.Ic return-icmp ,
.Ic return-icmp6 ,
or
.Ic synproxy
defined.
At the moment, only
.Ic return-rst
on IPv4 is implemented and the other packet generating rules
are unsupported.
.Pp
If an IP packet is too large for the outgoing interface, the bridge
will perform IP fragmentation.
This can happen when bridge members
have different MTUs or when IP fragments are reassembled by pf.
Non-IP packets which are too large for the outgoing interface will be
dropped.
.Pp
If the
.Dv IFF_LINK2
flag is set on the
.Nm
interface, the bridge will also perform transparent
.Xr ipsec 4
processing on the packets (encrypt or decrypt them), according to the
policies set with the
.Xr ipsecctl 8
command by the administrator.
If appropriate security associations (SAs) do not exist, any key
management daemons such as
.Xr isakmpd 8
that are running on the bridge will be invoked to establish the
necessary SAs.
These daemons have to be configured as if they were running on the
host whose traffic they are protecting (i.e., they need to have the
appropriate authentication and authorization material, such as keys
and certificates, to impersonate the protected host(s)).
.Sh SEE ALSO
.Xr errno 2 ,
.Xr ioctl 2 ,
.Xr arp 4 ,
.Xr etherip 4 ,
.Xr ip 4 ,
.Xr ip6 4 ,
.Xr ipsec 4 ,
.Xr netintro 4 ,
.Xr pf 4 ,
.Xr switch 4 ,
.Xr vether 4 ,
.Xr hostname.if 5 ,
.Xr ifconfig 8 ,
.Xr ipsecctl 8 ,
.Xr isakmpd 8 ,
.Xr netstart 8
.Sh HISTORY
The
.Nm
kernel interface first appeared in
.Ox 2.5 .
.Sh AUTHORS
The
.Nm
kernel interface was written by
.An Jason L. Wright Aq Mt jason@@thought.net
as part of an undergraduate independent study at the
University of North Carolina at Greensboro.
.Pp
Support for rapid spanning tree reconfigurations (RSTP) was added by
.An Andrew Thompson Aq Mt thompsa@@freebsd.org
and ported to
.Ox
by
.An Reyk Floeter Aq Mt reyk@@openbsd.org .
.Sh BUGS
There are some rather special network interface chipsets which will
not work in a bridge configuration.
Some chipsets have serious flaws when running in promiscuous mode, like the
TI ThunderLAN (see
.Xr tl 4 ) ,
which receives its own transmissions (this renders the address learning
cache useless).
Most other chipsets work fine though.
@


1.74
log
@Add switch(4) man page and update the bridge(4) man page about the
modification for switch(4).

ok goda
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.73 2016/06/07 20:25:48 sthen Exp $
d27 1
a27 1
.Dd $Mdocdate: June 7 2016 $
d151 1
a151 1
Some of
@


1.73
log
@etherip(4) was introduced in 5.9 as a clean alternative to gif(4)'s layer-2
mode that was enabled when it was added to a bridge(4). Update the manual
pages to direct people towards using etherip(4) for this purpose.
Reads fine to jmc@@, ok mpi@@.

This code will be removed from gif(4) in the future. Switching should be
as simple as renaming the config file (hostname.gifX -> hostname.etheripX),
changing the interface name in hostname.bridgeX, and updating firewall
rules etc. to match - I've tested this with etherip+bridge+isakmpd+ospf
tunnels.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.72 2015/09/14 17:09:26 schwarze Exp $
d27 1
a27 1
.Dd $Mdocdate: September 14 2015 $
d151 5
d192 1
a192 1
	u_int8_t  ifbr_portno;	  /* member port number */
d365 2
d375 3
d670 1
@


1.72
log
@convert .Fd #include to .In
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.71 2014/01/21 03:15:46 schwarze Exp $
d27 1
a27 1
.Dd $Mdocdate: January 21 2014 $
d46 1
a46 1
.Xr gif 4 ) .
d125 1
a125 1
.Xr gif 4
d654 1
a654 1
.Xr gif 4 ,
@


1.71
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.70 2013/07/16 16:05:48 schwarze Exp $
d27 1
a27 1
.Dd $Mdocdate: July 16 2013 $
d36 5
a40 5
.Fd #include <sys/types.h>
.Fd #include <net/if.h>
.Fd #include <netinet/in.h>
.Fd #include <netinet/if_ether.h>
.Fd #include <net/if_bridge.h>
@


1.70
log
@use .Mt for email addresses; from Jan Stary <hans at stare dot cz>; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.69 2009/12/11 07:43:59 jmc Exp $
d27 1
a27 1
.Dd $Mdocdate: December 11 2009 $
d150 1
a150 1
.Aq Pa sys/sockio.h .
@


1.69
log
@blocknonip fix; from Holger Mikolon
ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.68 2009/11/22 22:01:55 deraadt Exp $
d27 1
a27 1
.Dd $Mdocdate: November 22 2009 $
d675 1
a675 1
.An Jason L. Wright Aq jason@@thought.net
d680 1
a680 1
.An Andrew Thompson Aq thompsa@@freebsd.org
d684 1
a684 1
.An Reyk Floeter Aq reyk@@openbsd.org .
@


1.68
log
@Move information describing the bridge and brconfig behaviour into
the relevant manual pages.  Functionality is described in the (4)
pages, controlling the functionality in ifconfig(8), and the hostname.if
gains the old bridgename.if(5) functionality.
ok claudio jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.67 2009/11/09 03:16:07 deraadt Exp $
d27 1
a27 1
.Dd $Mdocdate: November 9 2009 $
d247 1
a247 1
is set, packets that are one of
d251 2
a252 2
or
Reverse ARP will not be bridged from and to the interface.
@


1.67
log
@vether(4) is a virtual ethernet device driver which can be used
so that a bridge-etherip-tunnel host can join into the bridge itself.
It is ridiculous that this capability was missing from our network
stack portfolio, considering we have bgp and ospf daemons...
discussed at length with claudio
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.66 2007/10/03 20:15:06 sthen Exp $
d27 1
a27 1
.Dd $Mdocdate: October 3 2007 $
d61 1
a61 1
.Xr bridgename.if 5
d82 1
a82 1
.Xr brconfig 8 .
d102 35
d661 2
a662 2
.Xr bridgename.if 5 ,
.Xr brconfig 8 ,
a667 2
.Xr brconfig 8
command and the
a672 2
.Xr brconfig 8
command and the
d674 1
a674 1
kernel interface were written by
d678 16
@


1.66
log
@Clarifications about the interaction of bridge and PF.
From Geoff Steckel with a few changes

"please commit it (if no one objects)" jmc, "yes" henning
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.66 2007/10/03 20:13:18 sthen Exp $
d625 1
@


1.65
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.64 2006/10/26 18:03:10 jmc Exp $
d27 1
a27 1
.Dd $Mdocdate$
d99 3
d562 9
a570 15
twice.
They can be filtered on any interface, in both directions.
For stateful filtering, filtering on only one interface
and passing all traffic on the other interfaces
(using
.Ic no state
or
.Ic set skip )
is recommended.
A state entry only permits outgoing packets from initial source to
destination and incoming packets from initial destination to source.
Since bridged packets pass through the filter twice with the source
and destination addresses reversed between interfaces, two state
entries (one for each direction) are required when all interfaces
are filtered statefully.
@


1.64
log
@no need to cause every reference to pf to be an Xr; on the other
hand, referencing `PF' is not so helpful either;

mutated from a diff from okan demirmen;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.63 2006/10/23 07:01:35 jmc Exp $
d27 1
a27 1
.Dd February 26, 1999
@


1.63
log
@remove trailing space;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.62 2006/10/22 22:46:41 mcbride Exp $
d66 1
a66 1
filtering, see
d98 1
a98 2
.Xr pf 4
interface so that it can be filtered.
d575 1
a575 1
Return packets generated by PF itself are not routed using the
d577 1
a577 1
Instead, PF will send these replies back to the same Ethernet
d595 1
a595 2
have different MTUs or when IP fragments are reassembled by
.Xr pf 4 .
@


1.62
log
@'keep state' is now the default.

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.61 2006/07/12 13:33:57 jmc Exp $
d562 2
a563 2
For stateful filtering, filtering on only one interface 
and passing all traffic on the other interfaces 
d565 1
a565 1
.Ic \&no state 
@


1.61
log
@add includes; from peter philipp (pr #5177)
ok mickey
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.60 2006/05/26 04:02:59 deraadt Exp $
d562 7
a568 3
For stateful filtering, filtering on only one interface (using
.Ic keep state )
and passing all traffic on the other interfaces is recommended.
@


1.60
log
@let us not talk about ipsecadm and vpn anymore; ok reyk
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.59 2006/05/09 19:03:04 jmc Exp $
d35 6
@


1.59
log
@no need to specify a "count" argument: ifconfig(8) handles these
"on demand";

from jan niemann;
ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.58 2004/08/11 16:55:43 jaredy Exp $
d599 1
a599 1
.Xr ipsecadm 8
d622 1
a622 1
.Xr ipsecadm 8 ,
@


1.58
log
@sync to reality, document missing ioctls
mdoc fixes
normalize ioctl listing
slightly reorganize some parts
grammar, punctuation, and rewording fixes
remove crud introduced in rev 1.17 and never removed

Note: this update does *not* include the controversial stuff discussed
on h@@; it contains what is in the header file.

help and ok (previously) jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.57 2004/05/04 16:29:30 cedric Exp $
d34 1
a34 1
.Cd "pseudo-device bridge" Op Ar count
@


1.57
log
@uppercase + whitespace fix from jmc@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.56 2004/05/04 15:53:22 cedric Exp $
d53 1
a53 1
.Ic ifconfig bridgeN create
d108 2
a109 3
.Bl -tag -width SIOCBRDGGIFFLGS
.It Dv SIOCBRDGIFS
.Pq Li "struct ifbifconf"
d112 1
a112 1
.Li ifbifconf
d115 1
a115 1
.Fa ifbic_len
d118 1
a118 1
.Fa ifbic_buf .
d121 1
d123 1
a123 1
.Fa ifbic_len
d127 1
a127 1
.Fa ifbic_len
d129 1
a129 1
.Fa ifbic_buf
d133 1
a133 1
.Fa ifbic_buf
d137 1
a137 1
.Bd -literal -offset indent
d139 7
a145 3
	char ifbr_name[IFNAMSIZ];    /* brdg nam */
	char ifbr_ifsname[IFNAMSIZ]; /* if name */
	u_int32_t ifbr_ifsflags;     /* if flags */
d148 7
a154 2
#define IFBIF_LEARNING  0x1 /* learns addrs */
#define IFBIF_DISCOVER  0x2 /* gets fwd'd pkts */
d157 2
a158 2
	char ifbic_name[IFNAMSIZ]; /* brdg name */
	u_int32_t       ifbic_len; /* buf size */
d160 2
a161 2
		caddr_t ifbicu_buf; /* buffer */
		struct  ifbreq *ifbicu_req;
d163 2
a164 2
#define ifbic_buf       ifbic_ifbicu.ifbicu_buf
#define ifbic_req       ifbic_ifbicu.ifbicu_req
d167 1
a167 2
.It Dv SIOCBRDGADD
.Pq Li "struct ifbreq"
d169 1
a169 1
.Fa ifbr_ifsname
d171 2
a172 3
.Fa ifbr_name .
.It Dv SIOCBRDGDEL
.Pq Li "struct ifbreq"
d174 1
a174 1
.Fa ifbr_ifsname
d176 2
a177 3
.Fa ifbr_name .
.It Dv SIOCBRDGADDS
.Pq Li "struct ifbreq"
d179 1
a179 1
.Fa ifbr_ifsname
d181 2
a182 3
.Fa ifbr_name .
.It Dv SIOCBRDGDELS
.Pq Li "struct ifbreq"
d184 1
a184 1
.Fa ifbr_ifsname
d186 2
a187 3
.Fa ifbr_name .
.It Dv SIOCBRDGSIFFLGS
.Pq Li "struct ifbreq"
d189 1
a189 1
.Fa ifbr_ifsname
d191 1
a191 1
.Fa ifbr_name .
d209 2
a210 2
Reverse ARP, will not be bridged from and to the interface.
.It Dv SIOCBRDGGIFFLGS
d212 1
a212 1
.Fa ifbr_ifsname
d214 2
a215 3
.Fa ifbr_name .
.It Dv SIOCBRDGRTS
.Pq Li "struct ifbaconf"
d217 1
a217 1
.Fa ifbac_name .
d219 2
a220 2
.Li ifbaconf
structure (see below) as a value result parameter.
d222 1
a222 1
.Fa ifbac_len
d224 1
a224 1
.Fa ifbac_buf .
d226 1
d228 1
a228 1
.Fa ifbac_len
d232 2
a233 2
.Fa ifbac_buf
needs to be to fit the entire configuration list and not fill in the other
d238 1
a238 1
.Fa ifbac_buf
d242 1
a242 1
.Bd -literal -offset indent
d244 5
a248 5
	char ifba_name[IFNAMSIZ];   /* brdg nam */
	char ifba_ifsname[IFNAMSIZ];/* dest ifs */
	u_int8_t ifba_age;          /* addr age */
	u_int8_t ifba_flags;        /* addr flag */
	struct ether_addr ifba_dst; /* dst addr */
d251 3
a253 3
#define IFBAF_TYPEMASK 0x03  /* addr type mask */
#define IFBAF_DYNAMIC  0x00  /* dynamic addr */
#define IFBAF_STATIC   0x01  /* static address */
d256 2
a257 2
	char ifbac_name[IFNAMSIZ]; /* brdg name */
	u_int32_t ifbac_len;       /* buf size */
d259 2
a260 2
		caddr_t ifbacu_buf;     /* buf */
		struct ifbareq *ifbacu_req;
d262 2
a263 2
#define	ifbac_buf       ifbac_ifbacu.ifbacu_buf
#define	ifbac_req       ifbac_ifbacu.ifbacu_req
d266 1
d270 1
a270 1
.Fa ifba_flags
d275 1
a275 2
.It Dv SIOCBRDGSADDR
.Pq Li "struct ifbareq"
d277 1
a277 1
.Fa ifba_name .
d279 2
a280 2
.Fa ifba_dst ,
.Fa ifba_ifsname ,
d282 1
a282 1
.Fa ifba_flags
d284 1
a284 2
.It Dv SIOCBRDGDADDR
.Pq Li "struct ifbareq"
d286 1
a286 1
.Fa ifba_name .
d288 12
a299 3
.Fa ifba_dst .
.It Dv SIOCBRDGSCACHE
.Pq Li "struct ifbcachereq"
d301 1
a301 1
.Fa ifbc_name
d303 1
a303 1
.Fa ifbc_size
d307 11
a317 4
.Bd -literal -offset indent
struct ifbcachereq {
	char ifbc_name[IFNAMSIZ]; /* bridge */
	u_int32_t ifbc_size;      /* size */
d319 6
d326 7
a332 2
.It Dv SIOCBRDGGCACHE
.Pq Li "struct ifbcachereq"
d334 6
a339 5
.Fa ifbc_name .
.It Dv SIOCBRDGSTO
.Pq Li "struct ifbcachetoreq"
Set the time, in seconds, that addresses which have not been
seen on the network (transmitted a packet) remain in the cache.
d341 1
a341 9
The argument structure is as follows:
.Bd -literal -offset indent
struct ifbcachetoreq {
	char ifbct_name[IFNAMSIZ]; /* bridge */
	u_int32_t ifbct_time;      /* time */
};
.Ed
.It Dv SIOCBRDGGTO
.Pq Li "struct ifbcachetoreq"
d343 1
a343 13
.It Dv SIOCBRDGFLUSH
.Pq Li "struct ifbreq"
Flush addresses from the cache.
.Fa ifbr_name
contains the name of the bridge device, and
.Fa ifbr_ifsflags
should be set to
.Dv IFBF_FLUSHALL
to flush all addresses from the cache or
.Dv IFBF_FLUSHDYN
to flush only the dynamically learned addresses from the cache.
.It Dv SIOCBRDGARL
.Pq Li "struct ifbrlreq"
d345 1
a345 1
.Fa ifbr_name
d347 1
a347 1
.Fa ifbr_ifsname
d349 4
d354 1
a354 1
.Fa ifbr_action
d356 1
a356 1
.Fa BRL_ACTION_PASS
d358 2
a359 2
.Fa BRL_ACTION_BLOCK ,
to pass or block matching frames respectively.
d361 4
a364 4
.Fa ifbr_flags
specifies whether the rule should match on input, output, or both
be using the flags
.Fa BRL_FLAG_IN
d366 7
a372 2
.Fa BRL_FLAG_OUT .
It also specifies whether either (or both) of the source and destination
d374 1
a374 1
.Fa BRL_FLAG_SRCVALID
d376 1
a376 1
.Fa BRL_FLAG_DSTVALID
d379 1
a379 1
.Fa ifbr_src
d381 1
a381 1
.Fa ifbr_flags
d383 1
a383 1
.Fa BRL_FLAG_SRCVALID
d386 1
a386 1
.Fa ifbr_src
d388 1
a388 1
.Fa ifbr_flags
d390 1
a390 1
.Fa BRL_FLAG_DSTVALID
d392 1
d395 1
a395 1
.Bd -literal -offset indent
d397 7
a403 7
        char ifbr_name[IFNAMSIZ];
        char ifbr_ifsname[IFNAMSIZ];
        u_int8_t ifbr_action;
        u_int8_t ifbr_flags;
        struct ether_addr ifbr_src;
        struct ether_addr ifbr_dst;
        char ifbr_tagname[PF_TAG_NAME_SIZE];
d405 6
a410 4
#define BRL_ACTION_BLOCK 0x01
#define BRL_ACTION_PASS  0x02
#define BRL_FLAG_IN      0x08
#define BRL_FLAG_OUT     0x04
d412 1
a412 2
.It Dv SIOCBRDGFRL
.Pq Li "struct ifbrlreq"
d414 1
a414 1
.Fa ifbr_name
d416 1
a416 1
.Fa ifbr_ifsname
d418 1
a418 2
.It Dv SIOCBRDGGRL
.Pq Li "struct ifbrlconf"
d420 1
a420 1
.Fa ifbrl_name ,
d422 1
a422 1
.Fa ifbrl_ifsname .
d424 2
a425 2
.Li ifbrlconf
structure (see below) as a value result parameter.
d427 1
a427 1
.Fa ifbrl_len
d429 1
a429 1
.Fa ifbrl_buf .
d431 1
d433 1
a433 1
.Fa ifbrl_len
d437 2
a438 2
.Fa ifbrl_buf
needs to be to fit the entire configuration list and not fill in the other
d443 1
a443 1
.Fa ifbrl_buf
d447 1
a447 1
.Bd -literal -offset indent
d449 3
a451 3
        char ifbrl_name[IFNAMSIZ];   /* brdg nam */
	char ifbrl_ifsname[IFNAMSIZ];/* ifs name */
        u_int32_t ifbr_len;         /* buf len */
d453 2
a454 106
                caddr_t ifbrlu_buf;
                struct ifbrlreq *ifbrlu_req;
        } ifrl_ifbrlu;
#define ifbrl_buf ifbrl_ifbrlu.ifbrlu_buf
#define ifbrl_req ifbrl_ifbrlu.ifbrlu_req
};
.Ed
.It Dv SIOCBRDGARL
.Pq Li "struct ifbrlreq"
Add a filtering rule to the bridge named in
.Fa ifbr_name
on the interface named in
.Fa ifbr_ifsname .
The argument structure is as follows:
.Bd -literal -offset indent
struct ifbrlreq {
	char ifbr_name[IFNAMSIZ];    /* bridge */
	char ifbr_ifsname[IFNAMSIZ]; /* ifs */
	u_int8_t ifbr_action;        /* handling */
	u_int8_t ifbr_flags;         /* flags */
	struct ether_addr ifbr_src;  /* src mac */
	struct ether_addr ifbr_dst;  /* dst mac */
};
#define BRL_ACTION_BLOCK        0x01
#define BRL_ACTION_PASS         0x02
#define BRL_FLAG_IN             0x08
#define BRL_FLAG_OUT            0x04
#define BRL_FLAG_SRCVALID       0x02
#define BRL_FLAG_DSTVALID       0x01
.Ed
.Pp
Rules are applied in the order in which they were added to the bridge,
and the first matching rule's action parameter determines the fate of
the packet.
The
.Fa ifbr_action
parameter specifies whether a frame matching the rule is to
be blocked or passed.
.Pp
If the
.Dv BRL_FLAG_IN
bit is set in
.Fa ifbr_flags ,
then the rule applies to frames received by the interface.
If the
.Dv BRL_FLAG_OUT
bit is set, then the rule applies to frame transmitted by the interface.
At least one of
.Dv BRL_FLAG_IN
or
.Dv BRL_FLAG_OUT
must be set.
.Pp
The source Ethernet address in
.Fa ifbr_src
is checked if the
.Dv BRL_FLAG_SRCVALID
bit is set in
.Fa ifbr_flags .
The destination address in
.Fa ifbr_dst
is checked if the
.Dv BRL_FLAG_DSTVALID
bit is set.
If neither bit is set, the rule matches all frames.
.It Dv SIOCBRDGFRL
.Pq Li "struct ifbrlreq"
Flush rules from the bridge
.Fa ifbr_name
on the interface
.Fa ifbr_ifsname .
.It Dv SIOCBRDGGRL
.Pq Li "struct ifbrlconf"
Retrieve an array of rules from the bridge for a particular interface.
This request takes an
.Li ifbrlconf
structure (see below) as a value-result parameter.
The
.Fa ifbrl_len
field should be initially set to the size of the buffer
pointed to by
.Fa ifbrl_buf .
On return it will contain the length, in bytes, of the rule list.
Alternatively, if the
.Fa ifbrl_len
passed in is set to 0,
.Dv SIOCBRDGGRL
will set
.Fa ifbrl_len
to the size that
.Fa ifbrl_buf
needs to be to fit the entire configuration list,
and will not fill in the other parameters.
This is useful for determining the exact size that
.Fa ifbrl_buf
needs to be in advance.
.Pp
The argument structure is as follows:
.Bd -literal -offset indent
struct ifbrlconf {
	char ifbrl_name[IFNAMSIZ];   /* bridge */
	char ifbrl_ifsname[IFNAMSIZ];/* member */
	u_int32_t ifbrl_len;         /* buflen */
	union {
		caddr_t ifbrlu_buf;
		struct  ifbrlreq *ifbrlu_req;
d456 2
a457 2
#define ifbrl_buf ifbrl_ifbrlu.ifbrlu_buf
#define ifbrl_req ifbrl_ifbrlu.ifbrlu_req
d460 52
d520 1
a520 1
.It Bq Eq ENOENT
d526 1
a526 1
.It Bq Eq ENOMEM
d529 1
a529 1
.It Bq Eq EEXIST
d531 1
a531 1
.It Bq Eq EBUSY
d533 2
a534 2
.It Bq Eq EINVAL
The named interface is not an Ethernet interface or an invalid ioctl
d536 2
a537 2
.It Bq Eq ENETDOWN
Address cache operation (flush, add, delete) on a bridge that is
d539 1
a539 1
.It Bq Eq EPERM
d542 1
a542 1
.It Bq Eq EFAULT
d548 1
a548 1
.It Bq Eq ESRCH
d557 1
a557 1
.Sq keep state )
d571 4
a574 4
.Ar return ,
.Ar return-rst ,
.Ar return-icmp ,
.Ar return-icmp6
d576 1
a576 1
.Ar synproxy
d579 1
a579 1
.Ar return-rst
d583 1
a583 1
If an IP packet is too large for the outgoing interface the bridge
d591 4
a594 2
If the LINK2 flag is set on the
.Nm bridge
d609 1
a609 1
and certificates, to impersonate the protected host(s).
d623 2
a624 1
.Xr isakmpd 8
d629 1
a629 1
.Nm bridge
d636 1
a636 1
.Nm bridge
@


1.56
log
@Talk about return-rst improvements. noticed+ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.55 2003/12/08 10:03:43 markus Exp $
d598 2
a599 2
Instead, PF will send these replies back to the same ethernet
address that the original packet came from. 
@


1.55
log
@mention ifconfig create; sync synopsis like (Op Ar count). with jmc, deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.54 2003/11/09 16:06:07 jmc Exp $
d596 4
a599 1
It is unsupported to use filter rules which would generate packets.
d608 4
@


1.54
log
@remove .Pp's before lists and displays;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.53 2003/07/09 13:26:20 jmc Exp $
d34 1
a34 1
.Cd "pseudo-device bridge 2"
d49 9
@


1.53
log
@- fix lists/displays
- quote .Cd's
- add/remove .Pp's as necessary
- fix some .Re/.Rs's
- simplify macros
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.52 2003/06/25 13:29:31 henning Exp $
a98 1
.Pp
@


1.52
log
@sync struct ifbrlreq with reality
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.51 2003/06/11 17:03:09 pb Exp $
d34 1
a34 1
.Cd pseudo-device bridge 2
@


1.51
log
@document that is is unsupported to use return-rst/icmp or synproxy
on bridging firewalls

henning@@ ok, spelling fixes from jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.50 2003/06/06 10:29:41 jmc Exp $
d374 1
@


1.50
log
@- section reorder
- some macro fixes
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.49 2003/06/02 18:51:33 jason Exp $
d586 10
@


1.49
log
@Nuke clause 3 & 4.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.48 2003/05/05 13:51:57 jmc Exp $
d596 1
a596 1
.Xr bridge 4
d626 7
d637 1
a637 1
.Xr bridge 4
a641 7
.Sh HISTORY
The
.Xr brconfig 8
command and the
.Xr bridge 4
kernel interface first appeared in
.Ox 2.5 .
@


1.48
log
@corrections from Leandro Costa.

- corrections to tradenames
- updated URLs
- general typos

thanks Leandro!
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.47 2003/02/26 08:26:01 jmc Exp $
a13 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by Jason L. Wright
.\" 4. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
@


1.47
log
@various typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.46 2003/02/25 22:34:12 jason Exp $
d595 2
a596 2
have different mtu's or when IP fragments are reassembled by
.Xr pf 4 . 
@


1.46
log
@document SIOCBRDGARL; pointed out by jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.45 2002/09/18 07:35:13 deraadt Exp $
d48 1
a48 1
A bridge can serve several services, including, isolation of traffic between
d330 1
a330 1
Add a Ethernet address filtering rule to the bridge on a specific interface.
d488 1
a488 1
is check if the
d491 1
a491 1
If neither bit is set, the rule is matches all frames.
d549 1
a549 1
For delete operation, it means that the named interface is not a member
d551 1
a551 1
For a address cache deletion, the address was not found in the table.
d610 1
a610 1
.Xr isakmpd 8 .
@


1.45
log
@no photurisd
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.44 2002/06/30 22:02:13 miod Exp $
d331 39
d372 12
@


1.44
log
@Do not end an enumerations of Xr with a dot, and do not let a dot hide
inside an enumeration as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.43 2002/06/30 21:45:25 deraadt Exp $
d559 1
a559 3
.Xr isakmpd 8
or
.Xr photurisd 8
d579 1
a579 2
.Xr isakmpd 8 ,
.Xr photurisd 8
@


1.43
log
@Xr cleanup; seb@@todesplanet.de
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.42 2002/06/15 02:26:44 angelos Exp $
d582 1
a582 1
.Xr photurisd 8 ,
@


1.42
log
@Document transparent IPsec.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.41 2002/05/28 17:50:04 jasoni Exp $
d582 1
a582 1
.Xr photurisd 8,
@


1.41
log
@document when the bridge will fragment ip packets..
- ok jason@@, dhartmei@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.40 2002/04/28 02:21:06 deraadt Exp $
d548 20
d575 1
d579 4
a582 1
.Xr brconfig 8
@


1.40
log
@ip6 corrections; pb@@sysfive.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.39 2001/12/15 08:40:56 jason Exp $
d540 8
@


1.39
log
@add support for creating span ports so that one can snoop a bridge
from another interface/machine/network.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.38 2001/12/05 16:08:23 hugh Exp $
d86 1
a86 1
.Xr ip 6
d543 1
d546 1
@


1.38
log
@Make nroff happy with .Sq rather than literal quotes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.37 2001/10/07 12:24:39 dhartmei Exp $
d3 1
a3 1
.\" Copyright (c) 1999, 2000 Jason L. Wright (jason@@thought.net)
d166 12
@


1.37
log
@Document bridge/pf interaction more appropriately. Ok Jason Wright.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.36 2001/10/05 14:45:53 mpech Exp $
d520 2
a521 2
'keep state') and passing all traffic on the other interfaces is
recommended.
@


1.36
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.35 2001/08/03 15:21:16 mpech Exp $
a89 4
The datagram is only checked against the
.Xr pf 4
input rules for the source interface;
output rules have no effect.
d514 14
a552 5
.Sh BUGS
Incoming packets are only checked against
.Xr pf 4
input rules.
There is no easy way to handle output rules.
@


1.35
log
@o) We don't like .Pp before/after .Sh;
o) .Nm always has argument in .Sh SYNOPSIS;
o) We always closes .Bl and .Bd tags;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.34 2001/07/18 22:53:57 kjell Exp $
d546 2
a547 1
input rules. There is no easy way to handle output rules.
@


1.34
log
@Clarify the wording of the input-rules-only restriction. ok jason@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.33 2001/07/01 22:02:15 angelos Exp $
a543 1
.Pp
@


1.33
log
@IPF->PF Xr reference; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.32 2001/06/26 23:24:10 angelos Exp $
d90 1
a90 1
Only the
d92 1
a92 1
input rules for the source interface are checked with the datagram;
d545 1
a545 1
Only
d547 1
a547 2
input rules are checked with incoming packets; there is no easy way to
handle output rules.
@


1.32
log
@PF-related text/references (jsyn@@nthought.com)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.31 2001/06/23 07:19:32 angelos Exp $
a522 1
.\".Xr ipf 4 ,
d524 1
@


1.31
log
@Remove loop detection bug, even though we may not be quite finished
with it yet. We should be done in the next few days.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.30 2001/05/30 03:24:15 millert Exp $
d55 3
a57 4
.\"XXX - replace with ipfw when it is in-tree
.\"The bridges provided by this interface are learning bridges with
.\"IP filtering, see
..\"Xr ipf 4 .
d82 12
a93 11
.\"XXX - replace with ipfw when it is in-tree
.\"Before forwarding a frame, the bridge will check to see if the packet
.\"contains an
.\".Xr ip 4
.\"datagram; if so, the datagram is run through the
.\".Xr ipf 4
.\"interface so that it can be filtered.
.\"Only the
.\".Xr ipf 4
.\"input rules for the source interface are checked with the datagram;
.\"output rules have no effect.
d543 6
a548 7
.\".Sh BUGS
.\"XXX - replace with ipfw when it is in-tree
.\".Pp
.\"Only
.\".Xr ipf 4
.\"input rules are checked with incoming packet; there is no easy way to
.\"handle output rules.
@


1.30
log
@comment out references to ipf to be replaced in the future with whatever packet filter we end up using
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.29 2000/12/30 21:57:21 angelos Exp $
d543 1
a543 4
.Sh BUGS
There is currently no loop detection.
Care must be taken to ensure that loops are not created when a bridge
is brought up.
@


1.29
log
@Update for use of gif.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.28 2000/12/21 05:32:52 aaron Exp $
d55 4
a58 3
The bridges provided by this interface are learning bridges with
IP filtering, see
.Xr ipf 4 .
d83 11
a93 10
Before forwarding a frame, the bridge will check to see if the packet
contains an
.Xr ip 4
datagram; if so, the datagram is run through the
.Xr ipf 4
interface so that it can be filtered.
Only the
.Xr ipf 4
input rules for the source interface are checked with the datagram;
output rules have no effect.
d523 1
a523 1
.Xr ipf 4 ,
d547 6
a552 5
.Pp
Only
.Xr ipf 4
input rules are checked with incoming packet; there is no easy way to
handle output rules.
@


1.28
log
@Various repairs.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.27 2000/11/10 20:02:16 todd Exp $
d45 1
a45 1
.Xr enc 4 ) .
d519 1
a519 1
.Xr enc 4 ,
@


1.27
log
@.Sh AUTHOR -> AUTHORS, ok aaron@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.26 2000/10/19 18:21:27 hin Exp $
d110 3
a112 2
Retrieve member interface list from a bridge.  This request takes an
.Ar ifbifconf
d115 1
a115 1
.Ar ifbic_len
d118 1
a118 1
.Ar ifbic_buf .
d122 1
a122 1
.Ar ifbic_len
d124 3
a126 2
SIOCBRDGIFS will set
.Ar ifbic_len
d128 1
a128 1
.Ar ifbic_buf
d132 1
a132 1
.Ar ifbic_buf
d160 1
a160 1
.Ar ifbr_ifsname
d162 1
a162 1
.Ar ifbr_name .
d166 1
a166 1
.Ar ifbr_ifsname
d168 1
a168 1
.Ar ifbr_name .
d172 1
a172 1
.Ar ifbr_ifsname
d174 1
a174 1
.Ar ifbr_name .
d176 1
a176 1
.Ar IFBIF_LEARNING
d180 1
a180 1
.Ar IFBIF_DISCOVER
d186 1
a186 1
.Ar IFBIF_BLOCKNONIP
d195 1
a195 1
.Ar ifbr_ifsname
d197 1
a197 1
.Ar ifbr_name .
d201 1
a201 1
.Ar ifbac_name .
d203 1
a203 1
.Ar ifbaconf
d206 1
a206 1
.Ar ifbac_len
d208 1
a208 1
.Ar ifbac_buf .
d211 5
a215 3
.Ar ifbac_len
passed in is set to 0, SIOCBRDGRTS will set it to the size that
.Ar ifbac_buf
d218 4
a221 2
As with SIOCBRDGIFS, this is useful for determining the exact size that
.Ar ifbac_buf
d250 1
a250 1
.Ar IFBAF_DYNAMIC
d252 1
a252 1
.Ar ifba_flags
d255 1
a255 1
.Ar IFBAF_STATIC
d260 1
a260 1
.Ar ifba_name .
d262 4
a265 3
.Ar ifba_dst ,
.Ar ifba_ifsname ,
.Ar ifba_flags
d270 1
a270 1
.Ar ifba_name .
d272 1
a272 1
.Ar ifba_dst .
d276 1
a276 1
.Ar ifbc_name
d278 1
a278 1
.Ar ifbc_size
d291 1
a291 1
.Ar ifbc_name .
d296 2
a297 2
If the time is set to zero, no aging is performed on the address
cache.  The argument structure is as follows:
d310 1
a310 1
.Ar ifbr_name
d312 1
a312 1
.Ar ifbr_ifsflags
d314 1
a314 1
.Ar IFBF_FLUSHALL
d316 1
a316 1
.Ar IFBF_FLUSHDYN
d320 2
a321 2
Add a Ethernet address filtering rule to the bridge on a specific
interface.  The argument structure is as follows:
d327 1
a327 1
.Ar ifbr_name
d329 1
a329 1
.Ar ifbr_ifsname
d334 1
a334 1
.Ar ifbrl_name ,
d336 1
a336 2
.Ar ifbrl_ifsname .

d338 1
a338 1
.Ar ifbrlconf
d341 1
a341 1
.Ar ifbrl_len
d343 1
a343 1
.Ar ifbrl_buf .
d346 5
a350 3
.Ar ifbrl_len
passed in is set to 0, SIOCBRDGGRL will set it to the size that
.Ar ifbrl_buf
d353 4
a356 2
As with SIOCBRDGIFS, this is useful for determining the exact size that
.Ar ifbrl_buf
d376 1
a376 1
.Ar ifbr_name
d378 1
a378 1
.Ar ifbr_ifsname .
d401 1
a401 1
.Ar ifbr_action
d406 1
a406 1
.Ar BRL_FLAG_IN
d408 1
a408 1
.Ar ifbr_flags ,
d411 2
a412 3
.Ar BRL_FLAG_OUT
bit is set,
then the rule applies to frame transmitted by the interface.
d414 1
a414 1
.Ar BRL_FLAG_IN
d416 1
a416 1
.Ar BRL_FLAG_OUT
d420 1
a420 1
.Ar ifbr_src
d422 1
a422 1
.Ar BRL_FLAG_SRCVALID
d424 1
a424 1
.Ar ifbr_flags .
d426 1
a426 1
.Ar ifbr_dst
d428 1
a428 1
.Ar BRL_FLAG_DSTVALID
d434 1
a434 1
.Ar ifbr_name
d436 1
a436 1
.Ar ifbr_ifsname .
d439 3
a441 3
Retrieve an array of rules from the bridge for a
particular interface.  This request takes an
.Ar ifbrlconf
d444 1
a444 1
.Ar ifbrl_len
d447 1
a447 1
.Ar ifbrl_buf .
d450 1
a450 1
.Ar ifbrl_len
d452 3
a454 2
SIOCBRDGGRL will set
.Ar ifbrl_len
d456 1
a456 1
.Ar ifbrl_buf
d460 1
a460 1
.Ar ifbrl_buf
d508 5
a512 2
The buffer used in a SIOCBRDGIFS or SIOCBRDGRTS request points outside
of the process's allocated address space.
a524 7
.Sh HISTORY
The
.Xr brconfig 8
command and the
.Xr bridge 4
kernel interface first appeared in
.Ox 2.5 .
d534 7
d542 3
a544 2
There is currently no loop detection.  Care must be taken to make sure
that loops are not created when a bridge is brought up.
@


1.26
log
@Remove merge conflict marker accidentaly left in this file.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.25 2000/10/18 16:32:11 aaron Exp $
d519 1
a519 1
.Sh AUTHOR
@


1.25
log
@ethernet -> Ethernet
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.24 2000/10/13 18:56:50 aaron Exp $
a466 1
>>>>>>> 1.17
@


1.24
log
@Purely mdoc fixes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.23 2000/08/03 05:04:18 jason Exp $
d410 1
a410 1
The source ethernet address in
@


1.23
log
@fix conflict remnant; jakob@@crt.se
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.22 2000/05/02 18:43:49 jason Exp $
d42 1
a42 1
.Nm bridge
d45 1
a45 1
.Xr enc 4 ).
d94 1
a94 1
.Nm bridge
d102 1
a102 1
.Nm bridge
@


1.22
log
@mention enc interfaces, too
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.21 2000/04/03 21:19:36 aaron Exp $
a310 1
<<<<<<< bridge.4
@


1.21
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.20 2000/02/11 04:22:27 jason Exp $
d43 3
a45 1
device creates a logical link between two or more Ethernet interfaces.
d508 1
@


1.20
log
@Use .An and Aq constructs
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.19 2000/02/05 02:22:54 deraadt Exp $
d68 1
a68 1
.Xr ioctl 2 
d301 1
a301 1
.Ar ifbr_name 
d305 1
a305 1
.Ar IFBF_FLUSHALL 
d459 1
a459 1
		caddr_t ifbrlu_buf; 
d531 1
a531 1
Only 
@


1.19
log
@typo
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.18 2000/02/02 20:12:11 jason Exp $
d523 4
a526 3
kernel interface were written by Jason L. Wright <jason@@thought.net> as
part of an undergraduate independent study
at the University of North Carolina at Greensboro.
@


1.18
log
@only ipf input rules are used
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.17 2000/01/25 22:06:27 jason Exp $
a361 1
=======
@


1.17
log
@add ethernet MAC filtering capability
also includes split of bridgeintr() with some optimizations for quicker
frame handling
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.16 2000/01/10 22:46:12 angelos Exp $
d86 4
d309 54
d467 1
d530 5
@


1.16
log
@Document the blocknonip flag.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.15 2000/01/01 19:14:24 deraadt Exp $
d3 1
a3 1
.\" Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
d305 104
@


1.15
log
@Xr bridgename.if(5)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.14 1999/12/06 01:32:38 deraadt Exp $
d177 8
@


1.14
log
@there is no IP(4) manpage...
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.13 1999/09/23 04:12:04 alex Exp $
d339 1
@


1.13
log
@Typo fixes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.12 1999/09/03 12:47:12 jason Exp $
d50 1
a50 1
.Xr IP 4
@


1.12
log
@Don't delete the cache on down/up transitions unless it's empty.  Instead
flush the dynamics.  Required other handling of the cache table to accomodate.
Modify SIOCBRDGFLUSH to handle flushall and flush dynamic requests.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.11 1999/07/09 13:35:48 aaron Exp $
d73 1
a73 1
If the bridge has no knowlege about where the destination is to be found,
@


1.11
log
@- remove all trailing whitespace
     * except when it is escaped with a `\' at the end of the line
- fix remaining .Nm usage as well
- this is from a patch I received from kwesterback@@home.com, who has been
  working on some scripts for fixing formatting errors in mdoc'd man pages

Ok, so there could be a cost/benefit debate with this commit, but since I have
the patch we might as well commit it...
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.10 1999/06/25 22:27:46 jason Exp $
d43 9
a51 5
device allows an Ethernet bridge to be created between two or more interfaces.
The bridges provided by this interface are learning bridges with the ability
to do IP filtering, see
.Xr ipf 4 , Ns
before packets are forwarded by the bridge.
d53 6
a58 5
A bridge is a device that has multiple interfaces attached to it.
It functions much like a hub, listening to incoming traffic on
each segment it is attached to and forwarding the traffic to every other
segment.
A bridge differs from a hub in that it will "learn" which machines
d63 3
a65 3
This allows a bridge to be more selective about what it forwards.
This can be used to reduce traffic on a network and also to provide
an IP firewall without modifying the topology of the network.
d68 3
a70 1
.Xr ioctl 2 .
d80 6
d167 10
d229 8
d288 9
a296 1
Flush all dynamically learned addresses from the cache.
d336 1
@


1.10
log
@longer explanation of what a bridge is and why you'd use this one
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.9 1999/05/17 14:57:43 jason Exp $
d80 1
a80 1
The following 
@


1.9
log
@Typos; Suzanne M. Lea <smlea@@uncg.edu>
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.8 1999/03/31 02:00:29 jason Exp $
d48 25
@


1.8
log
@finish documenting ioctls and errors
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.7 1999/03/19 22:47:33 jason Exp $
d159 5
a163 5
	char ifba_name[IFNAMSIZ];    /* brdg nam */
	char ifba_ifsname[IFNAMSIZ]; /* dest ifs */
	u_int8_t ifba_age;           /* addr age */
	u_int8_t ifba_flags;         /* addr age */
	struct ether_addr ifba_dst;  /* dst addr */
d288 1
a288 1
part of an undergraduate indenpendent study
@


1.7
log
@Add flag to allow some interfaces to not see packets with unknown destination.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.6 1999/03/19 02:46:54 jason Exp $
d63 1
a63 1
.Bl -tag -width SIOCBRDGIDX
d92 3
a94 3
	char ifbr_name[IFNAMSIZ];    /* bridge name */
	char ifbr_ifsname[IFNAMSIZ]; /* member name */
	u_int32_t ifbr_ifsflags;     /* member flags */
d97 2
a98 2
#define IFBIF_LEARNING  0x1 /* ifs can learn addrs */
#define IFBIF_DISCOVER  0x2 /* ifs gets fwd'd pkts */
d101 2
a102 2
	char ifbic_name[IFNAMSIZ]; /* bridge name */
	u_int32_t       ifbic_len; /* buffer size */
d159 1
a159 1
	char ifba_name[IFNAMSIZ];    /* bridge name */
d163 1
a163 1
	struct ether_addr ifba_dst;  /* dest addr */
d166 2
a167 2
#define IFBAF_TYPEMASK 0x03  /* address type mask */
#define IFBAF_DYNAMIC  0x00  /* dynamically learned */
d171 2
a172 2
	char ifbac_name[IFNAMSIZ]; /* bridge name */
	u_int32_t ifbac_len;       /* buffer size */
d174 1
a174 1
		caddr_t ifbacu_buf;     /* buffer */
d230 3
d246 1
d255 2
a256 1
The named interface is not an Ethernet interface.
d258 2
a259 1
The named interface is not ready for receiving packets.
d266 2
@


1.6
log
@Add the ability to mark an interface as "non-learning"
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.5 1999/03/12 02:40:42 jason Exp $
d97 2
a98 1
#define IFBIF_LEARNING 0x1 /* ifs can learn addrs */
@


1.5
log
@big overhaul:
o SNAP encapsulated IP filtering
o static address cache entries
o address deletion from cache
o dynamic & full cache flush
o filter packets based on each interface, not on the bridge as a whole
o KNF nits
o allow addition of ~IFF_UP interfaces
o man page & user level fixes to match the above
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.4 1999/03/05 21:10:58 jason Exp $
d97 2
d121 11
@


1.4
log
@Make address cache expiration actually work and provide a knob
for adjusting the timeout.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.3 1999/03/01 16:55:56 jason Exp $
d145 5
a149 3
	char ifba_name[IFNAMSIZ]; /* destination ifs */
	u_int32_t ifba_age;         /* addr age */
	struct ether_addr ifba_dst; /* dest addr */
d152 4
d167 15
d230 2
a231 1
Memory could not be allocated for an interface to be added to the bridge.
@


1.3
log
@reflect new ioctl interfaces
move sections around to match mdoc.template
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.2 1999/02/27 07:55:26 deraadt Exp $
d160 1
d180 15
@


1.2
log
@spacing
@
text
@d1 1
a1 1
.\"	$OpenBSD: bridge.4,v 1.1 1999/02/26 17:01:36 jason Exp $
d32 1
a32 1
.Dd January 14, 1999
d64 25
a88 3
.It Dv SIOCBRDGIDX
.Pq Li "struct ifbreq"
Retrieve a member interface from a bridge by index number (zero based).
d92 14
a105 3
	char ifbname[IFNAMSIZ]; /* bridge interface */
	char ifsname[IFNAMSIZ]; /* member interface */
	u_int32_t index;        /* interface index */
a107 5
.Pp
To get a list of interface members, set index to zero, and perform sucessive
.Xr ioctl 2
calls with increasing values of index.  When the call returns ENOENT,
there are no more interface members.
d110 4
a113 1
Add the interface named in ifsname to the bridge named in ifbname.
d116 26
a141 4
Delete the interface named in ifsname from the bridge named in ifbname.
.It Dv SIOCBRDGRT
.Pq Li "struct ifbrtreq"
Retrieve a list of routes by index number (zero based).
d144 15
a158 6
struct ifbrtreq {
	char ifbname[IFNAMSIZ]; /* bridge interface */
	u_int32_t index;        /* iteration index */
	struct ether_addr dst;  /* destination addr */
	char ifsname[IFNAMSIZ]; /* destination ifs */   
	u_int16_t age;          /* route age */
d160 19
a191 3
For an interface list or route list request, it means
that there is no route or interface that corresponds to the given index
number.
d205 3
d215 7
a232 7
.Sh HISTORY
The
.Xr brconfig 8
command and the
.Xr bridge 4
kernel interface first appeared in
.Ox 2.5 .
@


1.1
log
@Ethernet bridge/IP firewall driver.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d46 1
a46 1
.Xr ipf 4 ,
@

