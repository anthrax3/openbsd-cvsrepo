head	1.38;
access;
symbols
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.31.0.14
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.12
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.10
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.38
date	2016.04.28.19.07.19;	author natano;	state Exp;
branches;
next	1.37;
commitid	yl4fnExQD6pgj3sf;

1.37
date	2016.03.10.04.48.27;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	iF5qi5Sm24aG4dW9;

1.36
date	2015.01.16.03.07.03;	author lteo;	state Exp;
branches;
next	1.35;
commitid	3yuUMFZjo8aJyWTZ;

1.35
date	2015.01.15.20.37.36;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	VwT6DmpwXYKHzEuv;

1.34
date	2014.01.21.11.03.32;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.21.03.15.45;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.14.08.39.29;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.09.16.25.21;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.01.18.59.50;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.31.19.19.49;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.25.23.00.26;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.03.20.00.18;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.13.11.59.49;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.15.18.15.30;	author jaredy;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.08.00.23.05;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.07.16.28.38;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.31.17.06.37;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.21.19.47.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.13.22.50.48;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.22.18.42.40;	author canacar;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.09.11.45.44;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.23.21.19.52;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.20.20.55.16;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.06.10.29.41;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.28.10.40.20;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.29.23.30.07;	author naddy;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.05.14.45.53;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.02.18.04.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.23.07.03.52;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.22.12.15.44;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.28.19.51.06;	author dugsong;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.26.05.36.06;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.02.11.08;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.03.21.19.36;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.09.05.17.41.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.17.07.59.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.03.26.20.18.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Only one bpf device is required; pointed out by and ok jmc
@
text
@.\"	$OpenBSD: bpf.4,v 1.37 2016/03/10 04:48:27 deraadt Exp $
.\"     $NetBSD: bpf.4,v 1.7 1995/09/27 18:31:50 thorpej Exp $
.\"
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that: (1) source code distributions
.\" retain the above copyright notice and this paragraph in its entirety, (2)
.\" distributions including binary code include the above copyright notice and
.\" this paragraph in its entirety in the documentation or other materials
.\" provided with the distribution, and (3) all advertising materials mentioning
.\" features or use of this software display the following acknowledgement:
.\" ``This product includes software developed by the University of California,
.\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
.\" the University nor the names of its contributors may be used to endorse
.\" or promote products derived from this software without specific prior
.\" written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
.\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
.\"
.\" This document is derived in part from the enet man page (enet.4)
.\" distributed with 4.3BSD Unix.
.\"
.Dd $Mdocdate: March 10 2016 $
.Dt BPF 4
.Os
.Sh NAME
.Nm bpf
.Nd Berkeley Packet Filter
.Sh SYNOPSIS
.Cd "pseudo-device bpfilter"
.Sh DESCRIPTION
The Berkeley Packet Filter provides a raw interface to data link layers in
a protocol-independent fashion.
All packets on the network, even those destined for other hosts, are
accessible through this mechanism.
.Pp
The packet filter appears as a character special device,
.Pa /dev/bpf .
After opening the device, the file descriptor must be bound to a specific
network interface with the
.Dv BIOCSETIF
.Xr ioctl 2 .
A given interface can be shared between multiple listeners, and the filter
underlying each descriptor will see an identical packet stream.
.Pp
Associated with each open instance of a
.Nm
file is a user-settable
packet filter.
Whenever a packet is received by an interface, all file descriptors
listening on that interface apply their filter.
Each descriptor that accepts the packet receives its own copy.
.Pp
Reads from these files return the next group of packets that have matched
the filter.
To improve performance, the buffer passed to read must be the same size as
the buffers used internally by
.Nm bpf .
This size is returned by the
.Dv BIOCGBLEN
.Xr ioctl 2
and can be set with
.Dv BIOCSBLEN .
Note that an individual packet larger than this size is necessarily truncated.
.Pp
A packet can be sent out on the network by writing to a
.Nm
file descriptor.
Each descriptor can also have a user-settable filter
for controlling the writes.
Only packets matching the filter are sent out of the interface.
The writes are unbuffered, meaning only one packet can be processed per write.
.Pp
Once a descriptor is configured, further changes to the configuration
can be prevented using the
.Dv BIOCLOCK
.Xr ioctl 2 .
.Sh IOCTL INTERFACE
The
.Xr ioctl 2
command codes below are defined in
.In net/bpf.h .
All commands require these includes:
.Pp
.nr nS 1
.In sys/types.h
.In sys/time.h
.In sys/ioctl.h
.In net/bpf.h
.nr nS 0
.Pp
Additionally,
.Dv BIOCGETIF
and
.Dv BIOCSETIF
require
.In sys/socket.h
and
.In net/if.h .
.Pp
The (third) argument to the
.Xr ioctl 2
call should be a pointer to the type indicated.
.Pp
.Bl -tag -width Ds -compact
.It Dv BIOCGBLEN Fa "u_int *"
Returns the required buffer length for reads on
.Nm
files.
.Pp
.It Dv BIOCSBLEN Fa "u_int *"
Sets the buffer length for reads on
.Nm
files.
The buffer must be set before the file is attached to an interface with
.Dv BIOCSETIF .
If the requested buffer size cannot be accommodated, the closest allowable
size will be set and returned in the argument.
A read call will result in
.Er EINVAL
if it is passed a buffer that is not this size.
.Pp
.It Dv BIOCGDLT Fa "u_int *"
Returns the type of the data link layer underlying the attached interface.
.Er EINVAL
is returned if no interface has been specified.
The device types, prefixed with
.Dq DLT_ ,
are defined in
.In net/bpf.h .
.Pp
.It Dv BIOCGDLTLIST Fa "struct bpf_dltlist *"
Returns an array of the available types of the data link layer
underlying the attached interface:
.Bd -literal -offset indent
struct bpf_dltlist {
	u_int bfl_len;
	u_int *bfl_list;
};
.Ed
.Pp
The available types are returned in the array pointed to by the
.Va bfl_list
field while their length in
.Vt u_int
is supplied to the
.Va bfl_len
field.
.Er ENOMEM
is returned if there is not enough buffer space and
.Er EFAULT
is returned if a bad address is encountered.
The
.Va bfl_len
field is modified on return to indicate the actual length in
.Vt u_int
of the array returned.
If
.Va bfl_list
is
.Dv NULL ,
the
.Va bfl_len
field is set to indicate the required length of the array in
.Vt u_int .
.Pp
.It Dv BIOCSDLT Fa "u_int *"
Changes the type of the data link layer underlying the attached interface.
.Er EINVAL
is returned if no interface has been specified or the specified
type is not available for the interface.
.Pp
.It Dv BIOCPROMISC
Forces the interface into promiscuous mode.
All packets, not just those destined for the local host, are processed.
Since more than one file can be listening on a given interface, a listener
that opened its interface non-promiscuously may receive packets promiscuously.
This problem can be remedied with an appropriate filter.
.Pp
The interface remains in promiscuous mode until all files listening
promiscuously are closed.
.Pp
.It Dv BIOCFLUSH
Flushes the buffer of incoming packets and resets the statistics that are
returned by
.Dv BIOCGSTATS .
.Pp
.It Dv BIOCLOCK
This ioctl is designed to prevent the security issues associated
with an open
.Nm
descriptor in unprivileged programs.
Even with dropped privileges, an open
.Nm
descriptor can be abused by a rogue program to listen on any interface
on the system, send packets on these interfaces if the descriptor was
opened read-write and send signals to arbitrary processes using the
signaling mechanism of
.Nm bpf .
By allowing only
.Dq known safe
ioctls, the
.Dv BIOCLOCK
ioctl prevents this abuse.
The allowable ioctls are
.Dv BIOCFLUSH ,
.Dv BIOCGBLEN ,
.Dv BIOCGDIRFILT ,
.Dv BIOCGDLT ,
.Dv BIOCGDIRFILT ,
.Dv BIOCGDLTLIST ,
.Dv BIOCGETIF ,
.Dv BIOCGHDRCMPLT ,
.Dv BIOCGRSIG ,
.Dv BIOCGRTIMEOUT ,
.Dv BIOCGSTATS ,
.Dv BIOCIMMEDIATE ,
.Dv BIOCLOCK ,
.Dv BIOCSRTIMEOUT ,
.Dv BIOCVERSION ,
.Dv TIOCGPGRP ,
and
.Dv FIONREAD .
Use of any other ioctl is denied with error
.Er EPERM .
Once a descriptor is locked, it is not possible to unlock it.
A process with root privileges is not affected by the lock.
.Pp
A privileged program can open a
.Nm
device, drop privileges, set the interface, filters and modes on the
descriptor, and lock it.
Once the descriptor is locked, the system is safe
from further abuse through the descriptor.
Locking a descriptor does not prevent writes.
If the application does not need to send packets through
.Nm bpf ,
it can open the device read-only to prevent writing.
If sending packets is necessary, a write-filter can be set before locking the
descriptor to prevent arbitrary packets from being sent out.
.Pp
.It Dv BIOCGETIF Fa "struct ifreq *"
Returns the name of the hardware interface that the file is listening on.
The name is returned in the
.Fa ifr_name
field of the
.Li struct ifreq .
All other fields are undefined.
.Pp
.It Dv BIOCSETIF Fa "struct ifreq *"
Sets the hardware interface associated with the file.
This command must be performed before any packets can be read.
The device is indicated by name using the
.Fa ifr_name
field of the
.Li struct ifreq .
Additionally, performs the actions of
.Dv BIOCFLUSH .
.Pp
.It Dv BIOCSRTIMEOUT Fa "struct timeval *"
.It Dv BIOCGRTIMEOUT Fa "struct timeval *"
Sets or gets the read timeout parameter.
The
.Ar timeval
specifies the length of time to wait before timing out on a read request.
This parameter is initialized to zero by
.Xr open 2 ,
indicating no timeout.
.Pp
.It Dv BIOCGSTATS Fa "struct bpf_stat *"
Returns the following structure of packet statistics:
.Bd -literal -offset indent
struct bpf_stat {
	u_int bs_recv;
	u_int bs_drop;
};
.Ed
.Pp
The fields are:
.Bl -tag -width bs_recv
.It Fa bs_recv
Number of packets received by the descriptor since opened or reset (including
any buffered since the last read call).
.It Fa bs_drop
Number of packets which were accepted by the filter but dropped by the kernel
because of buffer overflows (i.e., the application's reads aren't keeping up
with the packet traffic).
.El
.Pp
.It Dv BIOCIMMEDIATE Fa "u_int *"
Enables or disables
.Dq immediate mode ,
based on the truth value of the argument.
When immediate mode is enabled, reads return immediately upon packet reception.
Otherwise, a read will block until either the kernel buffer becomes full or a
timeout occurs.
This is useful for programs like
.Xr rarpd 8 ,
which must respond to messages in real time.
The default for a new file is off.
.Pp
.It Dv BIOCSETF Fa "struct bpf_program *"
Sets the filter program used by the kernel to discard uninteresting packets.
An array of instructions and its length are passed in using the following
structure:
.Bd -literal -offset indent
struct bpf_program {
	u_int bf_len;
	struct bpf_insn *bf_insns;
};
.Ed
.Pp
The filter program is pointed to by the
.Fa bf_insns
field, while its length in units of
.Li struct bpf_insn
is given by the
.Fa bf_len
field.
Also, the actions of
.Dv BIOCFLUSH
are performed.
.Pp
See section
.Sx FILTER MACHINE
for an explanation of the filter language.
.Pp
.It Dv BIOCSETWF Fa "struct bpf_program *"
Sets the filter program used by the kernel to filter the packets
written to the descriptor before the packets are sent out on the
network.
See
.Dv BIOCSETF
for a description of the filter program.
This ioctl also acts as
.Dv BIOCFLUSH .
.Pp
Note that the filter operates on the packet data written to the descriptor.
If the
.Dq header complete
flag is not set, the kernel sets the link-layer source address
of the packet after filtering.
.Pp
.It Dv BIOCVERSION Fa "struct bpf_version *"
Returns the major and minor version numbers of the filter language currently
recognized by the kernel.
Before installing a filter, applications must check that the current version
is compatible with the running kernel.
Version numbers are compatible if the major numbers match and the application
minor is less than or equal to the kernel minor.
The kernel version number is returned in the following structure:
.Bd -literal -offset indent
struct bpf_version {
	u_short bv_major;
	u_short bv_minor;
};
.Ed
.Pp
The current version numbers are given by
.Dv BPF_MAJOR_VERSION
and
.Dv BPF_MINOR_VERSION
from
.In net/bpf.h .
An incompatible filter may result in undefined behavior (most likely, an
error returned by
.Xr ioctl 2
or haphazard packet matching).
.Pp
.It Dv BIOCSRSIG Fa "u_int *"
.It Dv BIOCGRSIG Fa "u_int *"
Sets or gets the receive signal.
This signal will be sent to the process or process group specified by
.Dv FIOSETOWN .
It defaults to
.Dv SIGIO .
.Pp
.It Dv BIOCSHDRCMPLT Fa "u_int *"
.It Dv BIOCGHDRCMPLT Fa "u_int *"
Sets or gets the status of the
.Dq header complete
flag.
Set to zero if the link level source address should be filled in
automatically by the interface output routine.
Set to one if the link level source address will be written,
as provided, to the wire.
This flag is initialized to zero by default.
.Pp
.It Dv BIOCSFILDROP Fa "u_int *"
.It Dv BIOCGFILDROP Fa "u_int *"
Sets or gets the status of the
.Dq filter drop
flag.
If non-zero, packets matching any filters will be reported to the
associated interface so that they can be dropped.
.Pp
.It Dv BIOCSDIRFILT Fa "u_int *"
.It Dv BIOCGDIRFILT Fa "u_int *"
Sets or gets the status of the
.Dq direction filter
flag.
If non-zero, packets matching the specified direction (either
.Dv BPF_DIRECTION_IN
or
.Dv BPF_DIRECTION_OUT )
will be ignored.
.El
.Ss Standard ioctls
.Nm
now supports several standard ioctls which allow the user to do asynchronous
and/or non-blocking I/O to an open
.Nm
file descriptor.
.Pp
.Bl -tag -width Ds -compact
.It Dv FIONREAD Fa "int *"
Returns the number of bytes that are immediately available for reading.
.Pp
.It Dv FIONBIO Fa "int *"
Sets or clears non-blocking I/O.
If the argument is non-zero, enable non-blocking I/O.
If the argument is zero, disable non-blocking I/O.
If non-blocking I/O is enabled, the return value of a read while no data
is available will be 0.
The non-blocking read behavior is different from performing non-blocking
reads on other file descriptors, which will return \-1 and set
.Va errno
to
.Er EAGAIN
if no data is available.
Note: setting this overrides the timeout set by
.Dv BIOCSRTIMEOUT .
.Pp
.It Dv FIOASYNC Fa "int *"
Enables or disables asynchronous I/O.
When enabled (argument is non-zero), the process or process group specified
by
.Dv FIOSETOWN
will start receiving
.Dv SIGIO
signals when packets arrive.
Note that you must perform an
.Dv FIOSETOWN
command in order for this to take effect, as the system will not do it by
default.
The signal may be changed via
.Dv BIOCSRSIG .
.Pp
.It Dv FIOSETOWN Fa "int *"
.It Dv FIOGETOWN Fa "int *"
Sets or gets the process or process group (if negative) that should receive
.Dv SIGIO
when packets are available.
The signal may be changed using
.Dv BIOCSRSIG
(see above).
.El
.Ss BPF header
The following structure is prepended to each packet returned by
.Xr read 2 :
.Bd -literal -offset indent
struct bpf_hdr {
	struct bpf_timeval bh_tstamp;
	u_int32_t	bh_caplen;
	u_int32_t	bh_datalen;
	u_int16_t	bh_hdrlen;
};
.Ed
.Pp
The fields, stored in host order, are as follows:
.Bl -tag -width Ds
.It Fa bh_tstamp
Time at which the packet was processed by the packet filter.
.It Fa bh_caplen
Length of the captured portion of the packet.
This is the minimum of the truncation amount specified by the filter and the
length of the packet.
.It Fa bh_datalen
Length of the packet off the wire.
This value is independent of the truncation amount specified by the filter.
.It Fa bh_hdrlen
Length of the BPF header, which may not be equal to
.Li sizeof(struct bpf_hdr) .
.El
.Pp
The
.Fa bh_hdrlen
field exists to account for padding between the header and the link level
protocol.
The purpose here is to guarantee proper alignment of the packet data
structures, which is required on alignment-sensitive architectures and
improves performance on many other architectures.
The packet filter ensures that the
.Fa bpf_hdr
and the network layer header will be word aligned.
Suitable precautions must be taken when accessing the link layer protocol
fields on alignment restricted machines.
(This isn't a problem on an Ethernet, since the type field is a
.Li short
falling on an even offset, and the addresses are probably accessed in a
bytewise fashion).
.Pp
Additionally, individual packets are padded so that each starts on a
word boundary.
This requires that an application has some knowledge of how to get from packet
to packet.
The macro
.Dv BPF_WORDALIGN
is defined in
.In net/bpf.h
to facilitate this process.
It rounds up its argument to the nearest word aligned value (where a word is
.Dv BPF_ALIGNMENT
bytes wide).
For example, if
.Va p
points to the start of a packet, this expression will advance it to the
next packet:
.Pp
.Dl p = (char *)p + BPF_WORDALIGN(p->bh_hdrlen + p->bh_caplen);
.Pp
For the alignment mechanisms to work properly, the buffer passed to
.Xr read 2
must itself be word aligned.
.Xr malloc 3
will always return an aligned buffer.
.Ss Filter machine
A filter program is an array of instructions with all branches forwardly
directed, terminated by a
.Dq return
instruction.
Each instruction performs some action on the pseudo-machine state, which
consists of an accumulator, index register, scratch memory store, and
implicit program counter.
.Pp
The following structure defines the instruction format:
.Bd -literal -offset indent
struct bpf_insn {
	u_int16_t	code;
	u_char		jt;
	u_char		jf;
	u_int32_t	k;
};
.Ed
.Pp
The
.Fa k
field is used in different ways by different instructions, and the
.Fa jt
and
.Fa jf
fields are used as offsets by the branch instructions.
The opcodes are encoded in a semi-hierarchical fashion.
There are eight classes of instructions:
.Dv BPF_LD ,
.Dv BPF_LDX ,
.Dv BPF_ST ,
.Dv BPF_STX ,
.Dv BPF_ALU ,
.Dv BPF_JMP ,
.Dv BPF_RET ,
and
.Dv BPF_MISC .
Various other mode and operator bits are logically OR'd into the class to
give the actual instructions.
The classes and modes are defined in
.In net/bpf.h .
Below are the semantics for each defined
.Nm
instruction.
We use the convention that A is the accumulator, X is the index register,
P[] packet data, and M[] scratch memory store.
P[i:n] gives the data at byte offset
.Dq i
in the packet, interpreted as a word (n=4), unsigned halfword (n=2), or
unsigned byte (n=1).
M[i] gives the i'th word in the scratch memory store, which is only addressed
in word units.
The memory store is indexed from 0 to
.Dv BPF_MEMWORDS Ns \-1 .
.Fa k ,
.Fa jt ,
and
.Fa jf
are the corresponding fields in the instruction definition.
.Dq len
refers to the length of the packet.
.Bl -tag -width Ds
.It Dv BPF_LD
These instructions copy a value into the accumulator.
The type of the source operand is specified by an
.Dq addressing mode
and can be a constant
.Pf ( Dv BPF_IMM ) ,
packet data at a fixed offset
.Pf ( Dv BPF_ABS ) ,
packet data at a variable offset
.Pf ( Dv BPF_IND ) ,
the packet length
.Pf ( Dv BPF_LEN ) ,
or a word in the scratch memory store
.Pf ( Dv BPF_MEM ) .
For
.Dv BPF_IND
and
.Dv BPF_ABS ,
the data size must be specified as a word
.Pf ( Dv BPF_W ) ,
halfword
.Pf ( Dv BPF_H ) ,
or byte
.Pf ( Dv BPF_B ) .
The semantics of all recognized
.Dv BPF_LD
instructions follow.
.Pp
.Bl -tag -width 32n -compact
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_W No +
.Dv BPF_ABS
.Xc
.Sm on
A <- P[k:4]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_H No +
.Dv BPF_ABS
.Xc
.Sm on
A <- P[k:2]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_B No +
.Dv BPF_ABS
.Xc
.Sm on
A <- P[k:1]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_W No +
.Dv BPF_IND
.Xc
.Sm on
A <- P[X+k:4]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_H No +
.Dv BPF_IND
.Xc
.Sm on
A <- P[X+k:2]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_B No +
.Dv BPF_IND
.Xc
.Sm on
A <- P[X+k:1]
.Sm off
.It Xo Dv BPF_LD No + Dv BPF_W No +
.Dv BPF_LEN
.Xc
.Sm on
A <- len
.Sm off
.It Dv BPF_LD No + Dv BPF_IMM
.Sm on
A <- k
.Sm off
.It Dv BPF_LD No + Dv BPF_MEM
.Sm on
A <- M[k]
.El
.It Dv BPF_LDX
These instructions load a value into the index register.
Note that the addressing modes are more restricted than those of the
accumulator loads, but they include
.Dv BPF_MSH ,
a hack for efficiently loading the IP header length.
.Pp
.Bl -tag -width 32n -compact
.Sm off
.It Xo Dv BPF_LDX No + Dv BPF_W No +
.Dv BPF_IMM
.Xc
.Sm on
X <- k
.Sm off
.It Xo Dv BPF_LDX No + Dv BPF_W No +
.Dv BPF_MEM
.Xc
.Sm on
X <- M[k]
.Sm off
.It Xo Dv BPF_LDX No + Dv BPF_W No +
.Dv BPF_LEN
.Xc
.Sm on
X <- len
.Sm off
.It Xo Dv BPF_LDX No + Dv BPF_B No +
.Dv BPF_MSH
.Xc
.Sm on
X <- 4*(P[k:1]&0xf)
.El
.It Dv BPF_ST
This instruction stores the accumulator into the scratch memory.
We do not need an addressing mode since there is only one possibility for
the destination.
.Pp
.Bl -tag -width 32n -compact
.It Dv BPF_ST
M[k] <- A
.El
.It Dv BPF_STX
This instruction stores the index register in the scratch memory store.
.Pp
.Bl -tag -width 32n -compact
.It Dv BPF_STX
M[k] <- X
.El
.It Dv BPF_ALU
The ALU instructions perform operations between the accumulator and index
register or constant, and store the result back in the accumulator.
For binary operations, a source mode is required
.Pf ( Dv BPF_K
or
.Dv BPF_X ) .
.Pp
.Bl -tag -width 32n -compact
.Sm off
.It Xo Dv BPF_ALU No + BPF_ADD No +
.Dv BPF_K
.Xc
.Sm on
A <- A + k
.Sm off
.It Xo Dv BPF_ALU No + BPF_SUB No +
.Dv BPF_K
.Xc
.Sm on
A <- A - k
.Sm off
.It Xo Dv BPF_ALU No + BPF_MUL No +
.Dv BPF_K
.Xc
.Sm on
A <- A * k
.Sm off
.It Xo Dv BPF_ALU No + BPF_DIV No +
.Dv BPF_K
.Xc
.Sm on
A <- A / k
.Sm off
.It Xo Dv BPF_ALU No + BPF_AND No +
.Dv BPF_K
.Xc
.Sm on
A <- A & k
.Sm off
.It Xo Dv BPF_ALU No + BPF_OR No +
.Dv BPF_K
.Xc
.Sm on
A <- A | k
.Sm off
.It Xo Dv BPF_ALU No + BPF_LSH No +
.Dv BPF_K
.Xc
.Sm on
A <- A << k
.Sm off
.It Xo Dv BPF_ALU No + BPF_RSH No +
.Dv BPF_K
.Xc
.Sm on
A <- A >> k
.Sm off
.It Xo Dv BPF_ALU No + BPF_ADD No +
.Dv BPF_X
.Xc
.Sm on
A <- A + X
.Sm off
.It Xo Dv BPF_ALU No + BPF_SUB No +
.Dv BPF_X
.Xc
.Sm on
A <- A - X
.Sm off
.It Xo Dv BPF_ALU No + BPF_MUL No +
.Dv BPF_X
.Xc
.Sm on
A <- A * X
.Sm off
.It Xo Dv BPF_ALU No + BPF_DIV No +
.Dv BPF_X
.Xc
.Sm on
A <- A / X
.Sm off
.It Xo Dv BPF_ALU No + BPF_AND No +
.Dv BPF_X
.Xc
.Sm on
A <- A & X
.Sm off
.It Xo Dv BPF_ALU No + BPF_OR No +
.Dv BPF_X
.Xc
.Sm on
A <- A | X
.Sm off
.It Xo Dv BPF_ALU No + BPF_LSH No +
.Dv BPF_X
.Xc
.Sm on
A <- A << X
.Sm off
.It Xo Dv BPF_ALU No + BPF_RSH No +
.Dv BPF_X
.Xc
.Sm on
A <- A >> X
.Sm off
.It Dv BPF_ALU No + BPF_NEG
.Sm on
A <- -A
.El
.It Dv BPF_JMP
The jump instructions alter flow of control.
Conditional jumps compare the accumulator against a constant
.Pf ( Dv BPF_K )
or the index register
.Pf ( Dv BPF_X ) .
If the result is true (or non-zero), the true branch is taken, otherwise the
false branch is taken.
Jump offsets are encoded in 8 bits so the longest jump is 256 instructions.
However, the jump always
.Pf ( Dv BPF_JA )
opcode uses the 32-bit
.Fa k
field as the offset, allowing arbitrarily distant destinations.
All conditionals use unsigned comparison conventions.
.Pp
.Bl -tag -width 32n -compact
.Sm off
.It Dv BPF_JMP No + BPF_JA
pc += k
.Sm on
.Sm off
.It Xo Dv BPF_JMP No + BPF_JGT No +
.Dv BPF_K
.Xc
.Sm on
pc += (A > k) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JGE No +
.Dv BPF_K
.Xc
.Sm on
pc += (A >= k) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JEQ No +
.Dv BPF_K
.Xc
.Sm on
pc += (A == k) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JSET No +
.Dv BPF_K
.Xc
.Sm on
pc += (A & k) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JGT No +
.Dv BPF_X
.Xc
.Sm on
pc += (A > X) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JGE No +
.Dv BPF_X
.Xc
.Sm on
pc += (A >= X) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JEQ No +
.Dv BPF_X
.Xc
.Sm on
pc += (A == X) ? jt : jf
.Sm off
.It Xo Dv BPF_JMP No + BPF_JSET No +
.Dv BPF_X
.Xc
.Sm on
pc += (A & X) ? jt : jf
.El
.It Dv BPF_RET
The return instructions terminate the filter program and specify the
amount of packet to accept (i.e., they return the truncation amount)
or, for the write filter, the maximum acceptable size for the packet
(i.e., the packet is dropped if it is larger than the returned
amount).
A return value of zero indicates that the packet should be ignored/dropped.
The return value is either a constant
.Pf ( Dv BPF_K )
or the accumulator
.Pf ( Dv BPF_A ) .
.Pp
.Bl -tag -width 32n -compact
.It Dv BPF_RET No + Dv BPF_A
Accept A bytes.
.It Dv BPF_RET No + Dv BPF_K
Accept k bytes.
.El
.It Dv BPF_MISC
The miscellaneous category was created for anything that doesn't fit into
the above classes, and for any new instructions that might need to be added.
Currently, these are the register transfer instructions that copy the index
register to the accumulator or vice versa.
.Pp
.Bl -tag -width 32n -compact
.Sm off
.It Dv BPF_MISC No + Dv BPF_TAX
.Sm on
X <- A
.Sm off
.It Dv BPF_MISC No + Dv BPF_TXA
.Sm on
A <- X
.El
.El
.Pp
The
.Nm
interface provides the following macros to facilitate array initializers:
.Bd -filled -offset indent
.Dv BPF_STMT ( Ns Ar opcode ,
.Ar operand )
.Pp
.Dv BPF_JUMP ( Ns Ar opcode ,
.Ar operand ,
.Ar true_offset ,
.Ar false_offset )
.Ed
.Sh FILES
.Bl -tag -width /dev/bpf -compact
.It Pa /dev/bpf
.Nm
device
.El
.Sh EXAMPLES
The following filter is taken from the Reverse ARP daemon.
It accepts only Reverse ARP requests.
.Bd -literal -offset indent
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_REVARP, 0, 3),
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, REVARP_REQUEST, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, sizeof(struct ether_arp) +
	    sizeof(struct ether_header)),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
.Ed
.Pp
This filter accepts only IP packets between host 128.3.112.15 and
128.3.112.35.
.Bd -literal -offset indent
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 8),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 26),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 2),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 3, 4),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 0, 3),
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
.Ed
.Pp
Finally, this filter returns only TCP finger packets.
We must parse the IP header to reach the TCP header.
The
.Dv BPF_JSET
instruction checks that the IP fragment offset is 0 so we are sure that we
have a TCP header.
.Bd -literal -offset indent
struct bpf_insn insns[] = {
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 10),
	BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, IPPROTO_TCP, 0, 8),
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 6, 0),
	BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 2, 0),
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16),
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 0, 1),
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1),
	BPF_STMT(BPF_RET+BPF_K, 0),
};
.Ed
.Sh SEE ALSO
.Xr ioctl 2 ,
.Xr read 2 ,
.Xr select 2 ,
.Xr signal 3 ,
.Xr MAKEDEV 8 ,
.Xr tcpdump 8
.Rs
.%A McCanne, S.
.%A Jacobson, V.
.%D January 1993
.%J 1993 Winter USENIX Conference
.%T The BSD Packet Filter: A New Architecture for User-level Packet Capture
.Re
.Sh HISTORY
The Enet packet filter was created in 1980 by Mike Accetta and Rick Rashid
at Carnegie-Mellon University.
Jeffrey Mogul, at Stanford, ported the code to
.Bx
and continued its
development from 1983 on.
Since then, it has evolved into the Ultrix Packet Filter at DEC, a STREAMS
NIT module under SunOS 4.1, and BPF.
.Sh AUTHORS
.An -nosplit
.An Steve McCanne
of Lawrence Berkeley Laboratory implemented BPF in Summer 1990.
Much of the design is due to
.An Van Jacobson .
.Sh BUGS
The read buffer must be of a fixed size (returned by the
.Dv BIOCGBLEN
ioctl).
.Pp
A file that does not request promiscuous mode may receive promiscuously
received packets as a side effect of another file requesting this mode on
the same hardware interface.
This could be fixed in the kernel with additional processing overhead.
However, we favor the model where all files must assume that the interface
is promiscuous, and if so desired, must utilize a filter to reject foreign
packets.
@


1.37
log
@BIOCGDIRFILT is allowed when locked, from Guy Harris
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.36 2015/01/16 03:07:03 lteo Exp $
d26 1
a26 1
.Dd $Mdocdate: January 16 2015 $
d41 1
a41 3
.Pa /dev/bpf0 ,
.Pa /dev/bpf1 ,
etc.
a48 10
A separate device file is required for each minor device.
If a file is in use, the open will fail and
.Va errno
will be set to
.Er EBUSY .
The number of open files can be increased by creating additional
device nodes with the
.Xr MAKEDEV 8
script.
.Pp
d950 2
a951 2
.Bl -tag -width /dev/bpf[0-9] -compact
.It Pa /dev/bpf[0-9]
d953 1
a953 1
devices
@


1.36
log
@The BPF paper referenced in the SEE ALSO section was most likely an unpublished
draft.  Replace it with the authors' 1993 Winter USENIX paper, which is a more
authoritative reference on BPF.

ok deraadt@@ jmc@@ millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.35 2015/01/15 20:37:36 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: January 15 2015 $
d225 1
@


1.35
log
@Use .An in the AUTHORS section where appropriate;
from Kaspars at Bankovskis dot net
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.34 2014/01/21 11:03:32 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: January 21 2014 $
d1032 3
a1034 1
.%J "An efficient, extensible, and portable network monitor"
@


1.34
log
@do not abuse .Cd for userland stuff; use .In or .Fd
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.33 2014/01/21 03:15:45 schwarze Exp $
d1044 5
a1048 2
Steve McCanne of Lawrence Berkeley Laboratory implemented BPF in Summer 1990.
Much of the design is due to Van Jacobson.
@


1.33
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.32 2013/08/14 08:39:29 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: August 14 2013 $
d99 7
a105 6
.Bd -unfilled -offset indent
.Cd #include <sys/types.h>
.Cd #include <sys/time.h>
.Cd #include <sys/ioctl.h>
.Cd #include <net/bpf.h>
.Ed
@


1.32
log
@some Bx/Ox conversion;
From: Jan Stary
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.31 2010/04/09 16:25:21 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: April 9 2010 $
d97 1
a97 1
.Aq Pa net/bpf.h .
d111 1
a111 1
.Aq Pa sys/socket.h
d113 1
a113 1
.Aq Pa net/if.h .
d144 1
a144 1
.Aq Pa net/bpf.h .
d377 1
a377 1
.Aq Pa net/bpf.h .
d523 1
a523 1
.Aq Pa net/bpf.h
d580 1
a580 1
.Aq Pa net/bpf.h .
@


1.31
log
@remove SIOCGIFADDR; from natex, documentation/6352;
ok claudio
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.30 2009/03/01 18:59:50 otto Exp $
d26 1
a26 1
.Dd $Mdocdate: March 1 2009 $
d1036 3
a1038 1
Jeffrey Mogul, at Stanford, ported the code to BSD and continued its
@


1.30
log
@bpf can handle variable length headers; some wording improvements;
mostly from Guy Harris; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.29 2007/05/31 19:19:49 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate$
a430 3
.Pp
.It Dv SIOCGIFADDR Fa "struct ifreq *"
Returns the address associated with the interface.
@


1.29
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.28 2006/03/25 23:00:26 djm Exp $
a80 10
The packet filter will support any link level protocol that has fixed length
headers.
Currently, only Ethernet, SLIP, and PPP drivers have been modified to
interact with
.Nm bpf .
.Pp
Since packet data is in network byte order, applications should use the
.Xr byteorder 3
macros to extract multi-byte values.
.Pp
d134 1
a134 1
.Er EIO
d275 1
a275 1
Set or get the read timeout parameter.
d304 1
a304 1
Enable or disable
d321 1
a321 1
	int bf_len;
d385 1
a385 1
Set or get the receive signal.
d393 1
a393 1
Set or get the status of the
d402 1
d404 1
a404 2
.It Dv BIOCSFILDROP Fa "u_int *"
Get or set the status of the
d410 1
d412 1
a412 2
.It Dv BIOCSDIRFILT Fa "u_int *"
Get or set the status of the
d436 1
a436 1
Set or clear non-blocking I/O.
d451 1
a451 1
Enable or disable asynchronous I/O.
d467 1
a467 1
Set or get the process or process group (if negative) that should receive
a1057 2
.Pp
Data link protocols with variable length headers are not currently supported.
@


1.28
log
@document BIOCGDIRFILT/BIOCSDIRFILT ioctls
sync/sort the list of allowed ioctls under BIOCLOCK too
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.27 2005/11/03 20:00:18 reyk Exp $
d26 1
a26 1
.Dd May 23, 1991
@


1.27
log
@re-implement the bpf "filter drop" option that it actually works. the
bpf FILDROP interface exists for about one year but the required
interface to the drivers was missing - so it was useless. this new
approach based on a design by henning@@ uses a new mbuf flag to mark
filtered packets and to drop them in the generic network stack input
routines (like ether_input).

for example; after some additional testing, this could be used by
dhclient to filter everything except DHCP packets (track tech@@
for a corresponding dhclient diff). the "filter dropped" packets won't
reach the network stack. so it's probably some kind of a very basic
application layer packet filter ;).

ok canacar@@, discussed with henning@@ and others
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.26 2005/10/13 11:59:49 reyk Exp $
d230 1
d232 1
a232 1
.Dv BIOCFLUSH ,
d234 1
d236 2
d239 3
a242 2
.Dv BIOCIMMEDIATE ,
.Dv BIOCGSTATS ,
a243 2
.Dv BIOCGRSIG ,
.Dv BIOCGHDRCMPLT ,
d419 11
@


1.26
log
@comment out the "filter drop" option because it has never been fully
implemented and is not useable at all.

ok henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.25 2005/04/15 18:15:30 jaredy Exp $
d408 8
a415 8
.\" .Pp
.\" .It Dv BIOCGFILDROP Fa "u_int *"
.\" .It Dv BIOCSFILDROP Fa "u_int *"
.\" Get or set the status of the
.\" .Dq filter drop
.\" flag.
.\" If non-zero, packets matching any filters will be reported to the
.\" associated interface so that they can be dropped.
@


1.25
log
@- sync to reality w.r.t. available ioctls and their arguments
- tweak layout of ioctl section
- other minor (mdoc, punctuation) fixes

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.24 2005/01/08 00:23:05 jmc Exp $
d408 8
a415 8
.Pp
.It Dv BIOCGFILDROP Fa "u_int *"
.It Dv BIOCSFILDROP Fa "u_int *"
Get or set the status of the
.Dq filter drop
flag.
If non-zero, packets matching any filters will be reported to the
associated interface so that they can be dropped.
@


1.24
log
@new sentence, new line;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.23 2005/01/07 16:28:38 reyk Exp $
d47 1
a47 1
ioctl.
d76 2
a77 1
ioctl (see below), and under BSD, can be set with
d102 5
a106 3
ioctl.
.Ss Ioctls
The ioctl command codes below are defined in
d128 3
a130 2
.Bl -tag -width Ds
.It Dv BIOCGBLEN ( Li int )
d134 2
a135 1
.It Dv BIOCSBLEN ( Li u_int )
d146 2
a147 1
.It Dv BIOCGDLT ( Li u_int )
d155 2
a156 1
.It Dv BIOCGDLTLIST (struct bpf_dltlist)
d190 2
a191 1
.It Dv BIOCSDLT (u_int)
d196 1
d206 1
d211 1
d261 2
a262 1
.It Dv BIOCGETIF ( Li "struct ifreq" )
d269 2
a270 1
.It Dv BIOCSETIF ( Li "struct ifreq" )
d279 3
a281 1
.It Dv BIOCSRTIMEOUT , BIOCGRTIMEOUT ( Li "struct timeval" )
d289 2
a290 1
.It Dv BIOCGSTATS ( Li "struct bpf_stat" )
d309 2
a310 1
.It Dv BIOCIMMEDIATE ( Li u_int )
d321 2
a322 1
.It Dv BIOCSETF ( Li "struct bpf_program" )
d347 2
a348 1
.It Dv BIOCSETWF ( Li "struct bpf_program" )
d363 2
a364 1
.It Dv BIOCVERSION ( Li "struct bpf_version" )
d389 3
a391 1
.It Dv BIOCSRSIG , BIOCGRSIG ( Li u_int )
d397 6
a402 2
.It Dv BIOCSHDRCMPLT , BIOCGHDRCMPLT ( Li u_int )
Set or get the status of the ``header complete'' flag.
d408 8
d423 3
a425 2
.Bl -tag -width Ds
.It Dv FIONREAD ( Li int )
d427 2
a428 1
.It Dv SIOCGIFADDR ( Li "struct ifreq" )
d430 2
a431 1
.It Dv FIONBIO ( Li int )
d445 2
a446 1
.It Dv FIOASYNC ( Li int )
d460 3
a462 1
.It Dv FIOSETOWN , FIOGETOWN ( Li int )
d961 2
a962 1
BPF devices
d1029 1
a1029 1
.%A Jacobson V.
@


1.23
log
@add support for BIOCGDLTLIST and BIOCSDLT, see bpf(4)

ok canacar@@, fgsch@@, tested by some other people
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.22 2004/05/31 17:06:37 canacar Exp $
d169 2
a170 1
is returned if a bad address is encountered. The
@


1.22
log
@document cloning of bpf devices. no need to change kernel config to
add new bpf devices anymore. ok jmc, makrus, grange, deraadt.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.21 2004/03/21 19:47:59 miod Exp $
d149 38
@


1.21
log
@Homogeneize config lines for pseudo-devices, and do not put fixed values.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.20 2004/03/13 22:50:48 jmc Exp $
d33 1
a33 1
.Cd "pseudo-device bpfilter" Op Ar count
a49 4
The total number of open files is limited to the value given in the kernel
configuration; the example given in the
.Sx SYNOPSIS
above sets the limit to 8.
d56 4
d945 1
@


1.20
log
@.DV -> .Dv
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.19 2003/10/22 18:42:40 canacar Exp $
d33 1
a33 1
.Cd "pseudo-device bpfilter 8"
@


1.19
log
@Add locking and write filtering to bpf descriptors.
Locking prevents dangerous ioctls such as changing the
interface and sending signals to be executed by an
unprivileged process. A filter can also be applied
to packets injected through a bpf descriptor.

These features allow programs using bpf descriptors to
safely drop/seperate privileges.

ok frantzen@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.18 2003/07/09 11:45:44 jmc Exp $
d177 1
a177 1
.DV BIOCLOCK
@


1.18
log
@- much simpler macros
- add missing .Sm off
- remove extra .Pp's
- sort postcript formatting problem
- fix lists
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.17 2003/06/23 21:19:52 jmc Exp $
d46 1
a46 1
.Dv BIOSETIF
d93 3
d97 5
a101 1
Currently, only writes to Ethernets and SLIP links are supported.
d118 2
d162 49
d290 15
d832 6
a837 3
The return instructions terminate the filter program and specify the amount
of packet to accept (i.e., they return the truncation amount).
A return value of zero indicates that the packet should be ignored.
@


1.17
log
@better wording of FIONBIO behaviour;
work done by Otto Moerbeek.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.16 2003/06/20 20:55:16 jmc Exp $
d33 1
a33 1
.Cd pseudo-device bpfilter 8
d99 1
a99 2
.Pp
.Bd -offset indent
d117 1
a117 1
.It Dv BIOCGBLEN Pf ( Li int Ns No )
d121 1
a121 1
.It Dv BIOCSBLEN Pf ( Li u_int Ns No )
d132 1
a132 1
.It Dv BIOCGDLT Pf ( Li u_int Ns No )
d153 1
a153 1
.It Dv BIOCGETIF Pf ( Li "struct ifreq" Ns No )
d160 1
a160 1
.It Dv BIOCSETIF Pf ( Li "struct ifreq" Ns No )
d169 1
a169 3
.It Xo Dv BIOCSRTIMEOUT , Dv BIOCGRTIMEOUT (
.Li struct timeval Ns No )
.Xc
d177 1
a177 1
.It Dv BIOCGSTATS Pf ( Li "struct bpf_stat" Ns No )
a178 1
.Pp
a186 1
.Pp
d196 1
a196 1
.It Dv BIOCIMMEDIATE Pf ( Li u_int Ns No )
d207 1
a207 1
.It Dv BIOCSETF Pf ( Li "struct bpf_program" Ns No )
a210 1
.Pp
d232 1
a232 1
.It Dv BIOCVERSION Pf ( Li "struct bpf_version" Ns No )
a239 1
.Pp
d257 1
a257 3
.It Xo Dv BIOCSRSIG , Dv BIOCGRSIG (
.Li u_int Ns No )
.Xc
d263 1
a263 3
.It Xo Dv BIOCSHDRCMPLT , Dv BIOCGHDRCMPLT (
.Li u_int Ns No )
.Xc
d278 1
a278 1
.It Dv FIONREAD Pf ( Li int Ns No )
d280 1
a280 1
.It Dv SIOCGIFADDR Pf ( Li "struct ifreq" Ns No )
d282 1
a282 1
.It Dv FIONBIO Pf ( Li int Ns No )
d296 1
a296 1
.It Dv FIOASYNC Pf ( Li int Ns No )
d310 1
a310 3
.It Xo Dv FIOSETOWN , Dv FIOGETOWN (
.Li int Ns No )
.Xc
a320 1
.Pp
a321 1

a396 1
.Pp
d440 1
a440 1
.Dv BPF_MEMWORDS Ns No \-1 .
a447 1
.Pp
d524 1
d794 3
d798 1
a798 5
.Bd -offset indent
.Dv BPF_STMT Ns No ( Ns Ar opcode ,
.Ar operand Ns No )
.Pp
.Dv BPF_JUMP Ns No ( Ns Ar opcode ,
d801 1
a801 1
.Ar false_offset Ns No )
a810 1
.Pp
a824 1
.Pp
a846 1
.Pp
@


1.16
log
@correct what FIONBIO returns;
closes PR 2696;

work done by Otto Moerbeek.

also sorted the .Rs/.Re section.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.15 2003/06/06 10:29:41 jmc Exp $
d295 4
a298 3
If the argument is non-zero, then doing a read while no data is available will
return 0.
If the argument is zero, non-blocking I/O is disabled.
@


1.15
log
@- section reorder
- some macro fixes
- kill whitespace at EOL
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.14 2003/01/28 10:40:20 jmc Exp $
d295 5
a299 2
If the argument is non-zero, then doing a read when no data is available will
return \-1 and
d301 3
a303 3
will be set to
.Er EWOULDBLOCK .
If the argument is zero, non-blocking I/O is disabled.
d890 2
a891 1
.%A McCanne, S., Jacobson V.
@


1.14
log
@typos; added white boldface to examples

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.13 2002/06/29 23:30:07 naddy Exp $
d816 5
a889 8
.Sh FILES
.Bl -tag -width /dev/bpf[0-9] -compact
.It Pa /dev/bpf[0-9]
BPF devices
.El
.Sh AUTHORS
Steve McCanne of Lawrence Berkeley Laboratory implemented BPF in Summer 1990.
Much of the design is due to Van Jacobson.
d897 3
a913 1
.Pp
@


1.13
log
@the the
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.12 2001/10/05 14:45:53 mpech Exp $
d48 1
a48 1
A given interface can be shared between multiple listeners and the filter
d214 1
a214 1
An array of instructions and its length is passed in using the following
d226 1
a226 1
field while its length in units of
d437 1
a437 1
given the actual instructions.
d776 1
a776 1
of the accumulator
@


1.12
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.11 2001/10/02 18:04:35 deraadt Exp $
d277 1
a277 1
automatically by the the interface output routine.
@


1.11
log
@change timeval to bpf_timeval; 32 bit in size, permitting much greater portability
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.10 2001/06/23 07:03:52 pjanzen Exp $
d275 6
a280 5
Set or get the status of the ``header complete'' flag.  Set to zero if
the link level source address should be filled in automatically by the
the interface output routine.  Set to one if the link level source
address will be written, as provided, to the wire.  This flag is
initialized to zero by default.
@


1.10
log
@spelling fixes and minor repairs almost entirely from jsyn@@nthought.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.9 2001/06/22 12:15:44 mpech Exp $
d331 1
d333 4
a336 4
	struct timeval bh_tstamp;
	u_long bh_caplen;
	u_long bh_datalen;
	u_short bh_hdrlen;
d410 4
a413 4
	u_short code;
	u_char jt;
	u_char jf;
	long k;
a913 7
Under SunOS, if a
.Nm
application reads more than 2^31 bytes of data, read will fail with
.Er EINVAL .
You can either fix the bug in SunOS, or lseek to 0 when read fails for this
reason.

@


1.9
log
@o) remove unnecessary .Pp;
o) remove unnecessary .Nm args;
o) closes .Bl;
o) .Sh AUTHOR -> .Sh AUTHORS;
o) sort SEE ALSO;
o) better -mdoc style;
o) typos;

aaron@@ ok.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.8 2001/05/28 19:51:06 dugsong Exp $
d128 1
a128 1
If the requested buffer size cannot be accomodated, the closest allowable
d130 1
a130 1
A read call will reseult in
d241 1
a241 1
Before installating a filter, applications must check that the current version
d263 1
a263 1
or haphazard packet mactching).
d365 1
a365 1
Suitable precuations must be taken when accessing the link layer protocol
d541 1
a541 1
Note that the addressign modes are more restricted than those of the
d889 1
a889 1
Steve McCanne of Lawrence Berkeley Laboratary implemented BPF in Summer 1990.
d906 1
a906 1
This could be fixed in the kernel with additional processing overead.
@


1.8
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.7 2001/03/26 05:36:06 aaron Exp $
d772 1
a772 1
The return value is either a constnat
@


1.7
log
@mdoc'ifying manpages is a really easy way to kill loads of time on the plane.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bpf.4,v 1.6 2001/01/29 02:11:08 niklas Exp $
d272 8
@


1.6
log
@$OpenBSD$
@
text
@d1 2
a2 4
.\" -*- nroff -*-
.\"
.\"	$OpenBSD: bpf.4,v 1.7 1995/09/27 18:31:50 thorpej Exp $
.\"	$NetBSD: bpf.4,v 1.7 1995/09/27 18:31:50 thorpej Exp $
d26 14
a39 12
.TH BPF 4  "23 May 1991"
.SH NAME
bpf \- Berkeley Packet Filter
.SH SYNOPSIS
.B "pseudo-device bpfilter 16"
.SH DESCRIPTION
The Berkeley Packet Filter
provides a raw interface to data link layers in a protocol
independent fashion.
All packets on the network, even those destined for other hosts,
are accessible through this mechanism.
.PP
d41 2
a42 1
.I /dev/bpf0, /dev/bpf1,
d44 5
a48 3
After opening the device, the file descriptor must be bound to a
specific network interface with the BIOSETIF ioctl.
A given interface can be shared be multiple listeners, and the filter
d50 5
a54 4
The total number of open
files is limited to the value given in the kernel configuration; the
example given in the SYNOPSIS above sets the limit to 16.
.PP
d57 4
a60 3
.I errno
will be set to EBUSY.
.PP
d62 5
a66 4
.I bpf
file is a user-settable packet filter.
Whenever a packet is received by an interface,
all file descriptors listening on that interface apply their filter.
d68 12
a79 11
.PP
Reads from these files return the next group of packets
that have matched the filter.
To improve performance, the buffer passed to read must be
the same size as the buffers used internally by
.I bpf.
This size is returned by the BIOCGBLEN ioctl (see below), and under
BSD, can be set with BIOCSBLEN.
Note that an individual packet larger than this size is necessarily
truncated.
.PP
d81 5
a85 4
headers.  Currently, only Ethernet, SLIP and PPP drivers have been
modified to interact with
.I bpf.
.PP
d87 1
a87 1
.I byteorder(3n)
d89 1
a89 1
.PP
d91 3
a93 3
.I bpf
file descriptor.  The writes are unbuffered, meaning only one
packet can be processed per write.
d95 19
a113 17
.SH IOCTLS
The
.I ioctl
command codes below are defined in <net/bpf.h>.  All commands require
these includes:
.ft B
.nf

	#include <sys/types.h>
	#include <sys/time.h>
	#include <sys/ioctl.h>
	#include <net/bpf.h>

.fi
.ft R
Additionally, BIOCGETIF and BIOCSETIF require \fB<net/if.h>\fR.

d115 4
a118 4
.I ioctl
should be a pointer to the type indicated.
.TP 10
.B BIOCGBLEN (u_int)
d120 1
a120 1
.I bpf
d122 1
a122 2
.TP 10
.B BIOCSBLEN (u_int)
d124 10
a133 8
.I bpf
files.  The buffer must be set before the file is attached to an interface
with BIOCSETIF.
If the requested buffer size cannot be accommodated, the closest
allowable size will be set and returned in the argument.
A read call will result in EIO if it is passed a buffer that is not this size.
.TP 10
.B BIOCGDLT (u_int)
d135 7
a141 4
EINVAL is returned if no interface has been specified.
The device types, prefixed with ``DLT_'', are defined in <net/bpf.h>.
.TP 10
.B BIOCPROMISC
d144 4
a147 5
Since more than one file can be listening on a given interface,
a listener that opened its interface non-promiscuously may receive
packets promiscuously.  This problem can be remedied with an
appropriate filter.
.IP
d150 5
a154 6
.TP 10
.B BIOCFLUSH
Flushes the buffer of incoming packets,
and resets the statistics that are returned by BIOCGSTATS.
.TP 10
.B BIOCGETIF (struct ifreq)
d156 4
a159 2
The name is returned in the ifr_name field of
.I ifr.
d161 3
a163 4
.TP 10
.B BIOCSETIF (struct ifreq)
Sets the hardware interface associated with the file.  This
command must be performed before any packets can be read.
d165 1
a165 1
.I ifr_name
d167 6
a172 4
.I ifreq.
Additionally, performs the actions of BIOCFLUSH.
.TP 10
.B BIOCSRTIMEOUT, BIOCGRTIMEOUT (struct timeval)
d175 2
a176 3
.I timeval
specifies the length of time to wait before timing
out on a read request.
d178 1
a178 1
.IR open(2),
d180 1
a180 2
.TP 10
.B BIOCGSTATS (struct bpf_stat)
d182 2
a183 3
.ft B
.nf

d188 2
a189 3
.fi
.ft R
.IP
d191 17
a207 18
.RS
.TP 15
.I bs_recv
the number of packets received by the descriptor since opened or reset
(including any buffered since the last read call);
and
.TP
.I bs_drop
the number of packets which were accepted by the filter but dropped by the
kernel because of buffer overflows
(i.e., the application's reads aren't keeping up with the packet traffic).
.RE
.TP 10
.B BIOCIMMEDIATE (u_int)
Enable or disable ``immediate mode'', based on the truth value of the argument.
When immediate mode is enabled, reads return immediately upon packet
reception.  Otherwise, a read will block until either the kernel buffer
becomes full or a timeout occurs.
d209 1
a209 1
.I rarpd(8c),
d212 6
a217 8
.TP 10
.B BIOCSETF (struct bpf_program)
Sets the filter program used by the kernel to discard uninteresting
packets.  An array of instructions and its length is passed in using
the following structure:
.ft B
.nf

d222 2
a223 3
.fi
.ft R
.IP
d225 5
a229 3
.I bf_insns
field while its length in units of `struct bpf_insn' is given by the
.I bf_len
d231 8
a238 5
Also, the actions of BIOCFLUSH are performed.
.IP
See section \fBFILTER MACHINE\fP for an explanation of the filter language.
.TP 10
.B BIOCVERSION (struct bpf_version)
d240 8
a247 8
recognized by the kernel.  Before installing a filter, applications must check
that the current version is compatible with the running kernel.  Version
numbers are compatible if the major numbers match and the application minor
is less than or equal to the kernel minor.  The kernel version number is
returned in the following structure:
.ft B
.nf

d252 2
a253 3
.fi
.ft R
.IP
d255 1
a255 1
.B BPF_MAJOR_VERSION
d257 21
a277 16
.B BPF_MINOR_VERSION
from <net/bpf.h>.
An incompatible filter
may result in undefined behavior (most likely, an error returned by
.I ioctl()
or haphazard packet matching).
.TP 10
.B BIOCSRSIG BIOCGRSIG (u_int signal)
Set or get the receive signal.  This signal will be sent to the process or process group
specified by FIOSETOWN.  It defaults to SIGIO.
.SH STANDARD IOCTLS
.I bpf
now supports several standard
.I ioctls
which allow the user to do async and/or non-blocking I/O to an open
.I bpf
d279 2
a280 2
.TP 10
.B FIONREAD (int)
d282 1
a282 2
.TP 10
.B SIOCGIFADDR (struct ifreq)
d284 35
a318 21
.TP 10
.B FIONBIO (int)
Set or clear non-blocking I/O.  If arg is non-zero, then doing a
.I read
when no data is available will return -1 and
.I errno
will be set to EWOULDBLOCK.
If arg is zero, non-blocking I/O is disabled.  Note:  setting this
overrides the timeout set by BIOCSRTIMEOUT.
.TP 10
.B FIOASYNC (int)
Enable or disable async I/O.  When enabled (arg is non-zero), the process or
process group specified by FIOSETOWN will start receiving SIGIO's when packets
arrive.  Note that you must do an FIOSETOWN in order for this to take effect, as
the system will not default this for you.
The signal may be changed via BIOCSRSIG.
.TP 10
.B FIOSETOWN FIOGETOWN (int)
Set or get the process or process group (if negative) that should receive SIGIO
when packets are available.  The signal may be changed using BIOCSRSIG (see above).
.SH BPF HEADER
d320 3
a322 5
.I read(2):
.in 15
.ft B
.nf

d329 12
a340 15
.fi
.ft R
.in -15
.PP
The fields, whose values are stored in host order, and are:
.TP 15
.I bh_tstamp
The time at which the packet was processed by the packet filter.
.TP
.I bh_caplen
The length of the captured portion of the packet.  This is the minimum of
the truncation amount specified by the filter and the length of the packet.
.TP
.I bh_datalen
The length of the packet off the wire.
d342 5
a346 6
.TP
.I bh_hdrlen
The length of the BPF header, which may not be equal to
.I sizeof(struct bpf_hdr).
.RE
.PP
d348 37
a384 34
.I bh_hdrlen
field exists to account for
padding between the header and the link level protocol.
The purpose here is to guarantee proper alignment of the packet
data structures, which is required on alignment sensitive
architectures and improves performance on many other architectures.
The packet filter insures that the
.I bpf_hdr
and the \fInetwork layer\fR header will be word aligned.  Suitable precautions
must be taken when accessing the link layer protocol fields on alignment
restricted machines.  (This isn't a problem on an Ethernet, since
the type field is a short falling on an even offset,
and the addresses are probably accessed in a bytewise fashion).
.PP
Additionally, individual packets are padded so that each starts
on a word boundary.  This requires that an application
has some knowledge of how to get from packet to packet.
The macro BPF_WORDALIGN is defined in <net/bpf.h> to facilitate
this process.  It rounds up its argument
to the nearest word aligned value (where a word is BPF_ALIGNMENT bytes wide).
.PP
For example, if `p' points to the start of a packet, this expression
will advance it to the next packet:
.sp
.RS
.ce 1
.nf
p = (char *)p + BPF_WORDALIGN(p->bh_hdrlen + p->bh_caplen)
.fi
.RE
.PP
For the alignment mechanisms to work properly, the
buffer passed to
.I read(2)
d386 1
a386 1
.I malloc(3)
d388 9
a396 8
.ft R
.SH FILTER MACHINE
A filter program is an array of instructions, with all branches forwardly
directed, terminated by a \fBreturn\fP instruction.
Each instruction performs some action on the pseudo-machine state,
which consists of an accumulator, index register, scratch memory store,
and implicit program counter.

d398 2
a399 4
.RS
.ft B
.nf

d401 3
a403 3
	u_short	code;
	u_char 	jt;
	u_char 	jf;
d406 9
a414 7
.fi
.ft R
.RE

The \fIk\fP field is used in different ways by different instructions,
and the \fIjt\fP and \fIjf\fP fields are used as offsets
by the branch instructions.
d416 17
a432 6
There are eight classes of instructions: BPF_LD, BPF_LDX, BPF_ST, BPF_STX,
BPF_ALU, BPF_JMP, BPF_RET, and BPF_MISC.  Various other mode and
operator bits are or'd into the class to give the actual instructions.
The classes and modes are defined in <net/bpf.h>.

Below are the semantics for each defined BPF instruction.
d435 51
a485 23
P[i:n] gives the data at byte offset ``i'' in the packet,
interpreted as a word (n=4),
unsigned halfword (n=2), or unsigned byte (n=1).
M[i] gives the i'th word in the scratch memory store, which is only
addressed in word units.  The memory store is indexed from 0 to BPF_MEMWORDS-1.
\fIk\fP, \fIjt\fP, and \fIjf\fP are the corresponding fields in the
instruction definition.  ``len'' refers to the length of the packet.

.TP 10
.B BPF_LD
These instructions copy a value into the accumulator.  The type of the
source operand is specified by an ``addressing mode'' and can be
a constant (\fBBPF_IMM\fP), packet data at a fixed offset (\fBBPF_ABS\fP),
packet data at a variable offset (\fBBPF_IND\fP), the packet length
(\fBBPF_LEN\fP),
or a word in the scratch memory store (\fBBPF_MEM\fP).
For \fBBPF_IND\fP and \fBBPF_ABS\fP, the data size must be specified as a word
(\fBBPF_W\fP), halfword (\fBBPF_H\fP), or byte (\fBBPF_B\fP).
The semantics of all the recognized BPF_LD instructions follow.

.RS
.TP 30
.B BPF_LD+BPF_W+BPF_ABS
d487 5
a491 2
.TP
.B BPF_LD+BPF_H+BPF_ABS
d493 5
a497 2
.TP
.B BPF_LD+BPF_B+BPF_ABS
d499 5
a503 2
.TP
.B BPF_LD+BPF_W+BPF_IND
d505 5
a509 2
.TP
.B BPF_LD+BPF_H+BPF_IND
d511 5
a515 2
.TP
.B BPF_LD+BPF_B+BPF_IND
d517 5
a521 2
.TP
.B BPF_LD+BPF_W+BPF_LEN
d523 3
a525 2
.TP
.B BPF_LD+BPF_IMM
d527 2
a528 2
.TP
.B BPF_LD+BPF_MEM
d530 6
a535 8
.RE

.TP 10
.B BPF_LDX
These instructions load a value into the index register.  Note that
the addressing modes are more restricted than those of the accumulator loads,
but they include
.B BPF_MSH,
d537 7
a543 3
.RS
.TP 30
.B BPF_LDX+BPF_W+BPF_IMM
d545 5
a549 2
.TP
.B BPF_LDX+BPF_W+BPF_MEM
d551 5
a555 2
.TP
.B BPF_LDX+BPF_W+BPF_LEN
d557 5
a561 2
.TP
.B BPF_LDX+BPF_B+BPF_MSH
d563 2
a564 4
.RE

.TP 10
.B BPF_ST
d566 5
a570 5
We do not need an addressing mode since there is only one possibility
for the destination.
.RS
.TP 30
.B BPF_ST
d572 2
a573 4
.RE

.TP 10
.B BPF_STX
d575 3
a577 3
.RS
.TP 30
.B BPF_STX
d579 15
a593 11
.RE

.TP 10
.B BPF_ALU
The alu instructions perform operations between the accumulator and
index register or constant, and store the result back in the accumulator.
For binary operations, a source mode is required (\fBBPF_K\fP or
\fBBPF_X\fP).
.RS
.TP 30
.B BPF_ALU+BPF_ADD+BPF_K
d595 5
a599 2
.TP
.B BPF_ALU+BPF_SUB+BPF_K
d601 5
a605 2
.TP
.B BPF_ALU+BPF_MUL+BPF_K
d607 5
a611 2
.TP
.B BPF_ALU+BPF_DIV+BPF_K
d613 5
a617 2
.TP
.B BPF_ALU+BPF_AND+BPF_K
d619 5
a623 2
.TP
.B BPF_ALU+BPF_OR+BPF_K
d625 5
a629 2
.TP
.B BPF_ALU+BPF_LSH+BPF_K
d631 5
a635 2
.TP
.B BPF_ALU+BPF_RSH+BPF_K
d637 5
a641 2
.TP
.B BPF_ALU+BPF_ADD+BPF_X
d643 5
a647 2
.TP
.B BPF_ALU+BPF_SUB+BPF_X
d649 5
a653 2
.TP
.B BPF_ALU+BPF_MUL+BPF_X
d655 5
a659 2
.TP
.B BPF_ALU+BPF_DIV+BPF_X
d661 5
a665 2
.TP
.B BPF_ALU+BPF_AND+BPF_X
d667 5
a671 2
.TP
.B BPF_ALU+BPF_OR+BPF_X
d673 5
a677 2
.TP
.B BPF_ALU+BPF_LSH+BPF_X
d679 5
a683 2
.TP
.B BPF_ALU+BPF_RSH+BPF_X
d685 3
a687 2
.TP
.B BPF_ALU+BPF_NEG
d689 9
a697 8
.RE

.TP 10
.B BPF_JMP
The jump instructions alter flow of control.  Conditional jumps
compare the accumulator against a constant (\fBBPF_K\fP) or
the index register (\fBBPF_X\fP).  If the result is true (or non-zero),
the true branch is taken, otherwise the false branch is taken.
d699 4
a702 1
However, the jump always (\fBBPF_JA\fP) opcode uses the 32 bit \fIk\fP
d705 4
a708 3
.RS
.TP 30
.B BPF_JMP+BPF_JA
d710 6
a715 2
.TP
.B BPF_JMP+BPF_JGT+BPF_K
d717 5
a721 2
.TP
.B BPF_JMP+BPF_JGE+BPF_K
d723 5
a727 2
.TP
.B BPF_JMP+BPF_JEQ+BPF_K
d729 5
a733 2
.TP
.B BPF_JMP+BPF_JSET+BPF_K
d735 5
a739 2
.TP
.B BPF_JMP+BPF_JGT+BPF_X
d741 5
a745 2
.TP
.B BPF_JMP+BPF_JGE+BPF_X
d747 5
a751 2
.TP
.B BPF_JMP+BPF_JEQ+BPF_X
d753 5
a757 2
.TP
.B BPF_JMP+BPF_JSET+BPF_X
d759 2
a760 3
.RE
.TP 10
.B BPF_RET
d762 23
a784 21
of packet to accept (i.e., they return the truncation amount).  A return
value of zero indicates that the packet should be ignored.
The return value is either a constant (\fBBPF_K\fP) or the accumulator
(\fBBPF_A\fP).
.RS
.TP 30
.B BPF_RET+BPF_A
accept A bytes
.TP
.B BPF_RET+BPF_K
accept k bytes
.RE
.TP 10
.B BPF_MISC
The miscellaneous category was created for anything that doesn't
fit into the above classes, and for any new instructions that might need to
be added.  Currently, these are the register transfer instructions
that copy the index register to the accumulator or vice versa.
.RS
.TP 30
.B BPF_MISC+BPF_TAX
d786 3
a788 2
.TP
.B BPF_MISC+BPF_TXA
d790 21
a810 18
.RE
.PP
The BPF interface provides the following macros to facilitate
array initializers:
.RS
\fBBPF_STMT\fI(opcode, operand)\fR
.br
and
.br
\fBBPF_JUMP\fI(opcode, operand, true_offset, false_offset)\fR
.RE
.PP
.SH EXAMPLES
The following filter is taken from the Reverse ARP Daemon.  It accepts
only Reverse ARP requests.
.RS
.nf

d817 1
a817 1
		 sizeof(struct ether_header)),
d820 2
a821 3
.fi
.RE
.PP
d824 2
a825 3
.RS
.nf

d839 10
a848 10
.fi
.RE
.PP
Finally, this filter returns only TCP finger packets.  We must parse
the IP header to reach the TCP header.  The \fBBPF_JSET\fP instruction
checks that the IP fragment offset is 0 so we are sure
that we have a TCP header.
.RS
.nf

d864 31
a894 12
.fi
.RE
.SH SEE ALSO
tcpdump(8), signal(3), ioctl(2), read(2), select(2)
.LP
McCanne, S., Jacobson V.,
.RI ` "An efficient, extensible, and portable network monitor" '
.SH FILES
/dev/bpf0, /dev/bpf1, ...
.SH BUGS
The read buffer must be of a fixed size (returned by the BIOCGBLEN ioctl).
.PP
d896 7
a902 6
received packets as a side effect of another file requesting this
mode on the same hardware interface.  This could be fixed in the kernel
with additional processing overhead.  However, we favor the model where
all files must assume that the interface is promiscuous, and if
so desired, must utilize a filter to reject foreign packets.
.PP
d904 8
a911 15
.PP
Under SunOS, if a BPF application reads more than 2^31 bytes of
data, read will fail in EINVAL.  You can either fix the bug in SunOS,
or lseek to 0 when read fails for this reason.
.SH HISTORY
.PP
The Enet packet filter was created in 1980 by Mike Accetta and
Rick Rashid at Carnegie-Mellon University.  Jeffrey Mogul, at
Stanford, ported the code to BSD and continued its development from
1983 on.  Since then, it has evolved into the Ultrix Packet Filter
at DEC, a STREAMS NIT module under SunOS 4.1, and BPF.
.SH AUTHORS
.PP
Steven McCanne, of Lawrence Berkeley Laboratory, implemented BPF in
Summer 1990.  Much of the design is due to Van Jacobson.
@


1.5
log
@Remove trailing whitespace.
@
text
@d3 1
@


1.4
log
@more man page repairs; aaron@@ug.cs.dal.ca
@
text
@d34 1
a34 1
provides a raw interface to data link layers in a protocol 
d42 1
a42 1
After opening the device, the file descriptor must be bound to a 
d46 1
a46 1
The total number of open 
d50 2
a51 2
A separate device file is required for each minor device.  
If a file is in use, the open will fail and 
d58 1
a58 1
Whenever a packet is received by an interface, 
d65 1
a65 1
the same size as the buffers used internally by 
d81 1
a81 1
A packet can be sent out on the network by writing to a 
d87 1
a87 1
The 
d103 1
a103 1
The (third) argument to the 
d113 1
a113 1
Sets the buffer length for reads on 
d131 1
a131 1
packets promiscuously.  This problem can be remedied with an 
d134 1
a134 1
The interface remains in promiscuous mode until all files listening 
d143 1
a143 1
The name is returned in the ifr_name field of 
d152 1
a152 1
field of the 
d158 2
a159 2
The 
.I timeval 
d187 1
a187 1
the number of packets which were accepted by the filter but dropped by the 
d194 1
a194 1
When immediate mode is enabled, reads return immediately upon packet 
d203 1
a203 1
Sets the filter program used by the kernel to discard uninteresting 
d242 1
a242 1
The current version numbers are given by 
d244 1
a244 1
and 
d289 1
a289 1
The following structure is prepended to each packet returned by 
d323 1
a323 1
The 
d328 1
a328 1
data structures, which is required on alignment sensitive 
d330 1
a330 1
The packet filter insures that the 
d356 1
a356 1
buffer passed to 
d358 1
a358 1
must itself be word aligned.  
d384 1
a384 1
The \fIk\fP field is used in different ways by different instructions, 
d389 1
a389 1
BPF_ALU, BPF_JMP, BPF_RET, and BPF_MISC.  Various other mode and 
d407 2
a408 2
source operand is specified by an ``addressing mode'' and can be 
a constant (\fBBPF_IMM\fP), packet data at a fixed offset (\fBBPF_ABS\fP), 
d492 1
a492 1
For binary operations, a source mode is required (\fBBPF_K\fP or 
d551 1
a551 1
compare the accumulator against a constant (\fBBPF_K\fP) or 
d555 1
a555 1
However, the jump always (\fBBPF_JA\fP) opcode uses the 32 bit \fIk\fP 
d617 1
a617 1
The BPF interface provides the following macros to facilitate 
d622 1
a622 1
and 
d638 1
a638 1
	BPF_STMT(BPF_RET+BPF_K, sizeof(struct ether_arp) + 
d703 2
a704 2
with additional processing overhead.  However, we favor the model where 
all files must assume that the interface is promiscuous, and if 
d716 1
a716 1
Stanford, ported the code to BSD and continued its development from 
@


1.3
log
@fix Xr
@
text
@d148 1
a148 1
Sets the hardware interface associate with the file.  This
d281 1
a281 1
arrive.  Note that you must do an FIOSETOWN in order for this to take affect, as
d329 1
a329 1
architectures and and improves performance on many other architectures.
@


1.2
log
@fix a bunch of errors
@
text
@d691 1
a691 1
tcpdump(8), signal(3), ioctl(2), read(2), select(2), filio(2)
@


1.1
log
@Initial revision
@
text
@d117 1
a117 1
If the requested buffer size cannot be accomodated, the closest
d122 1
a122 1
Returns the type of the data link layer underyling the attached interface.
d143 1
a143 1
The name is returned in the if_name field of 
d151 1
a151 1
.I if_name
d226 1
a226 1
Returns the major and minor version numbers of the filter languange currently
d384 1
a384 1
The \fIk\fP field is used in differnet ways by different insutructions, 
d386 1
a386 1
by the branch intructions.
d388 1
a388 1
There are eight classes of intructions: BPF_LD, BPF_LDX, BPF_ST, BPF_STX,
d449 1
a449 1
the addressing modes are more retricted than those of the accumulator loads,
d606 1
a606 1
be added.  Currently, these are the register transfer intructions
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
