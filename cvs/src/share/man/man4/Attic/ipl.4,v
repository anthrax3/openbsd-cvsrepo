head	1.10;
access;
symbols
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@# @;


1.10
date	2001.05.30.02.12.14;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2000.04.13.19.59.40;	author kjell;	state Exp;
branches;
next	1.8;

1.8
date	99.07.07.10.50.10;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.07.04.16.13.35;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.07.04.15.34.52;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.02.07.21.20.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.09.07.16.44.36;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	96.10.08.01.20.29;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.18.15.29.59;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.21.39.30;	author dm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@.\"	$OpenBSD: ipl.4,v 1.9 2000/04/13 19:59:40 kjell Exp $
.\"
.TH IPL 4
.SH NAME
ipl \- IP packet log device
.SH DESCRIPTION
The \fBipl\fP pseudo device's purpose is to provide an easy way to gather
packet headers of packets you wish to log.  If a packet header is to be
logged, the entire header is logged (including any IP options \- TCP/UDP
options are not included when it calculates header size) or not at all.
The packet contents are also logged after the header.  If the log reader
is busy or otherwise unable to read log records, upto IPLLOGSIZE (8192 is the
default) bytes of data are stored.
.PP
Prepending every packet header logged is a structure containing information
relevant to the packet following and why it was logged.  The structure's
format is as follows:
.LP
.nf
/*
 * Log structure.  Each packet header logged is prepended by one of these.
 * Following this in the log records read from the device will be an ipflog
 * structure which is then followed by any packet data.
 */
typedef struct iplog    {
        u_long  ipl_sec;
        u_long  ipl_usec;
        u_int   ipl_len;
        u_int   ipl_count;
        size_t  ipl_dsize;
        struct  iplog   *ipl_next;
} iplog_t;


typedef struct  ipflog  {
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603))
        u_char  fl_ifname[IFNAMSIZ];
#else
        u_int   fl_unit;
        u_char  fl_ifname[4];
#endif
        u_char  fl_plen;        /* extra data after hlen */
        u_char  fl_hlen;        /* length of IP headers saved */
        u_short fl_rule;        /* assume never more than 64k rules, total */
        u_32_t  fl_flags;
} ipflog_t;

.fi
.PP
When reading from the \fBipl\fP device, it is necessary to call read(2) with
a buffer big enough to hold at least 1 complete log record - reading of partial
log records is not supported.
.PP
If the packet contents is more then 128 bytes when \fBlog body\fP is used,
then only 128 bytes of the packet contents is logged.
.PP
Although it is only possible to read from the \fBipl\fP device, opening it
for writing is required when using an ioctl which changes any kernel data.
.PP
The ioctls which are loaded with this device can be found under \fBipf(4)\fP.
The ioctls which are for use with logging and don't affect the filter are:
.LP
.nf
        ioctl(fd, SIOCIPFFB, int *)
        ioctl(fd, FIONREAD, int *)
.fi
.PP
The SIOCIPFFB ioctl flushes the log buffer and returns the number of bytes
flushed.  FIONREAD returns the number of bytes currently used for storing
log data.  If IPFILTER_LOG is not defined when compiling, SIOCIPFFB is not
available and FIONREAD will return but not do anything.
.PP
There is currently no support for non-blocking IO with this device, meaning
all read operations should be considered blocking in nature (if there is no
data to read, it will sleep until some is made available).
.SH SEE ALSO
ipf(4)
.SH BUGS
Packet headers are dropped when the internal buffer (static size) fills.
.SH FILES
/dev/ipl
@


1.9
log
@Long overdue documentation update for IPFilter. These
are taken directly from the ipf distribution, and are
not mandoc'ed. ipf(8), ipfstat(8), and ipnat(8) are yet
to go and must be done manually. (sigh)
@
text
@d1 1
a1 1
.\"	$OpenBSD$
@


1.8
log
@The proper order of the ``introductory'' macros in a man page is .Dd/.Dt/.Os.
Out of the approximately 1450 man pages, only about 90 of them were wrong.
Thanks to kwesterback@@home.com for coming up with a script and patch to repair
this. The patch also inserted a .Os macro in the few man pages that were
missing one.
@
text
@d1 32
a32 37
.Dd June 13, 1999
.Dt IPL 4
.Os
.Sh NAME
.Nm ipl
.Nd IP packet log device
.Sh DESCRIPTION
The
.Nm
pseudo device's purpose is to provide an easy way to gather
packet headers of packets you wish to log. If a packet header is to be
logged, either the entire header (including any
.Tn IP
options \(en
.Tn TCP/UDP
options are not included when it calculates header size) is logged or nothing.
Up to 128 bytes of the packet content are logged after the header.
.Pp
Prepending every packet header logged are two structures containing information
relevant to the packet following and why it was logged. The first structure
is
.Fa iplog
and the second is
.Fa ipflog .
Both are declared in
.Aq Pa netinet/ip_fil.h .
and their formats are as follows:
.Bd -literal -offset indent
struct	iplog	{
	u_long	ipl_magic;	/* IPL_MAGIC 0x49504c4d 'IPLM' */
	u_long	ipl_sec;
	u_long	ipl_usec;
	u_int	ipl_len;
	u_int	ipl_count;
	size_t	ipl_dsize;
	struct	iplog	*ipl_next;
}
d34 39
a72 31
struct	ipflog	{
	u_char	fl_ifname[IFNAMSIZ];
	u_char	fl_plen;	/* extra data after hlen       */
	u_char	fl_hlen;	/* length of IP headers saved  */
	u_short	fl_rule;	/* assume < 64k rules, total   */
	u_short	fl_group;
	u_32_t	fl_flags;
}
.Ed
.Pp
In the case of the header causing the buffer to finish on a non-32-bit
boundary, padding will be appended to ensure that the next log entry
is aligned to a 32-bit boundary.
.Pp
If the packet content is more than 128 bytes, only
the first 128 bytes of the
packet content are logged. Should the packet content finish on a non-32-bit
boundary, then the last few bytes are not logged to ensure the log entry
is aligned to a 32-bit boundary.
.Pp
.Nm
is a read-only (sequential) character pseudo-device.
.Pp
The ioctls which are loaded with this device can be found under
.Xr ipf 4 .
The only ioctl which is used for logging and doesn't affect the filter is:
.Pp
.Dl Fn ioctl fd SIOCIPFFB "int *"
.Pp
This ioctl flushes the log buffer and returns the number of bytes flushed.
.Pp
d76 3
a78 9
.Sh FILES
.Bl -tag -width /dev/ipl -compact
.It Pa /dev/ipl
IP packet logging pseudo-device
.El
.Sh SEE ALSO
.Xr ipf 4 ,
.Xr ipmon 8
.Sh BUGS
d80 2
@


1.7
log
@repairs
@
text
@d2 1
a3 1
.Dt IPL 4
@


1.6
log
@new -mdoc man pages; kwesterback@@home.com
@
text
@d1 1
a1 1
.Dd 13 June, 1999
d26 1
a26 1
.Pa netinet/ip_fil.h .
d49 1
a49 1
In the case of the header causing the buffer to finish on a non-32bit
d51 1
a51 1
is aligned to a 32bit boundary.
d55 1
a55 1
packet content are logged. Should the packet content finish on a non-32bit
d57 1
a57 1
is aligned to a 32bit boundary.
d73 5
a82 2
.Sh FILES
.Pa /dev/ipl
@


1.5
log
@xref ipmon(8)
@
text
@d1 48
a48 33
.TH IPL 4
.SH NAME
ipl - IP packet log device
.SH DESCRIPTION
The \fBipl\fP pseudo device's purpose is to provide an easy way to gather
packet headers of packets you wish to log.  If a packet header is to be
logged, the entire header is logged (including any IP options - TCP/UDP
options are not included when it calculates header size) or not at all.
The packet contents is also logged after the header.
.LP
.PP
Prepending every packet header logged is a structure containing information
relevant to the packet following and why it was logged.  The structure's
format is as follows:
.LP
.nf
struct ipl_ci   {
        u_long  sec;      /* time when the packet was logged */
        u_long  usec;
        u_long  plen;     /* length of packet data logged */
        u_short hlen;     /* length of headers logged */
        u_short rule;     /* rule number (for log ...) or 0 if result = log */
        u_long  flags:24; /* XXX FIXME do we care about the extra bytes? */
#if (defined(OpenBSD) && (OpenBSD <= 1991011) && (OpenBSD >= 199606))
        u_long  filler:8; /* XXX FIXME do we care? */
        u_char  ifname[IFNAMSIZ];
#else
        u_long  unit:8;
        u_char  ifname[4];
#endif
};
.nf
.PP
d50 1
a50 1
boundary, padding will be `appended' to ensure that the next log entry
d52 4
a55 4
.LP
.PP
If the packet contents is more than 128 bytes, then only 128 bytes of the
packet contents is logged. Should the packet contents finish on a non-32bit
d58 6
a63 4

\fBipl\fP is a read-only (sequential) character pseudo-device.

The ioctls which are loaded with this device can be found under \fBipf(4)\fP.
d65 3
a67 5
.LP
.nf
        ioctl(fd, SIOCIPFFB, int *)
.fi
.PP
d69 1
a69 1
.PP
d73 4
a76 3
.SH SEE ALSO
ipf(4), ipmon(8)
.SH BUGS
d78 2
a79 2
.SH FILES
/dev/ipl0
@


1.4
log
@More man page fixes. Particularly fix uses of it's/its, affect/effect,
then/than and such. Other miscellaneous problems fixed across these source
files.
@
text
@d59 1
a59 1
ipf(4)
@


1.3
log
@Attempt at cleanup.
@
text
@d39 1
a39 1
If the packet contents is more then 128 bytes, then only 128 bytes of the
@


1.2
log
@Ipfilter 3.1.0 (forgot to check it in yesterday).
@
text
@d18 1
a18 1
        u_long  sec;    /* time when the packet was logged */
d20 3
a22 3
        u_long  plen;   /* length of packet data logged */
        u_short hlen;   /* length of headers logged */
        u_short rule;   /* rule number (for log ...) or 0 if result = log */
d24 2
a25 2
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606))
        u_long  filler:8;                       /* XXX FIXME do we care? */
@


1.1
log
@ipfilter 3.0.4
@
text
@d23 8
a30 3
        u_short flags:12; /* flags, ie BLOCK, PASS, SHORT, etc */
        u_short unit:4; /* interface unit # */
        u_char  ifname[2]; /* 2 character interface abbreviation */
@
