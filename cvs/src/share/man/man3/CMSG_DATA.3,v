head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.2
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.5.0.38
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.34
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.30
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.32
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.24
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.28
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.26
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.22
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.20
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.18
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@.\" @;


1.6
date	2017.04.03.19.40.43;	author otto;	state Exp;
branches;
next	1.5;
commitid	ijHbejnLMBhU9DH1;

1.5
date	2008.03.24.16.11.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2008.03.15.16.27.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.31.19.19.48;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.04.03.03.16;	author jaredy;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Send and receive 1 byte of data in addition to the control message. This is
needed to make the code work in more cases.
Sending actually is not really needed, but do it anyway, to avoid confusing
mismatch between producer and consumer.
Problem noted by Luke Small; ok deraadt@@
@
text
@.\"	$OpenBSD: CMSG_DATA.3,v 1.5 2008/03/24 16:11:07 deraadt Exp $
.\" Written by Jared Yanovich <jaredy@@openbsd.org>
.\" Public domain, July 3, 2005
.Dd $Mdocdate: March 24 2008 $
.Dt CMSG_DATA 3
.Os
.Sh NAME
.Nm CMSG_DATA ,
.Nm CMSG_FIRSTHDR ,
.Nm CMSG_LEN ,
.Nm CMSG_NXTHDR ,
.Nm CMSG_SPACE
.Nd socket control message routines
.Sh SYNOPSIS
.In sys/socket.h
.Ft void *
.Fn CMSG_DATA "struct cmsghdr *"
.Ft struct cmsghdr *
.Fn CMSG_FIRSTHDR "struct msghdr *"
.Ft size_t
.Fn CMSG_LEN "size_t"
.Ft struct cmsghdr *
.Fn CMSG_NXTHDR "struct msghdr *" "struct cmsghdr *"
.Ft size_t
.Fn CMSG_SPACE "size_t"
.Sh DESCRIPTION
The control message API is used to construct ancillary data objects for
use in control messages sent and received across sockets.
.Pp
Control messages are passed around by the
.Xr recvmsg 2
and
.Xr sendmsg 2
system calls.
The
.Vt cmsghdr
structure, described in
.Xr recvmsg 2 ,
is used to specify a chain of control messages.
.Pp
These routines should be used instead of directly accessing the control
message header members and data buffers as they ensure that necessary
alignment constraints are met.
.Pp
The following routines are provided:
.Bl -tag -width Ds
.It Fn CMSG_DATA cmsg
This routine accesses the data portion of the control message header
.Fa cmsg .
It ensures proper alignment constraints on the beginning of ancillary
data are met.
.It Fn CMSG_FIRSTHDR mhdr
This routine accesses the first control message attached to the
message
.Fa msg .
If no control messages are attached to the message, this routine
returns
.Dv NULL .
.It Fn CMSG_LEN len
This routine determines the size in bytes of a control message,
which includes the control message header.
.Fa len
specifies the length of the data held by the control message.
This value is what is normally stored in the
.Fa cmsg_len
of each control message.
This routine accounts for any alignment constraints on the beginning of
ancillary data.
.It Fn CMSG_NXTHDR mhdr cmsg
This routine returns the location of the control message following
.Fa cmsg
in the message
.Fa mhdr .
If
.Fa cmsg
is the last control message in the chain, this routine returns
.Dv NULL .
.It Fn CMSG_SPACE len
This routine determines the size in bytes needed to hold a control
message and its contents of length
.Fa len ,
which includes the control message header.
This value is what is normally stored in
.Fa msg_msgcontrollen .
This routine accounts for any alignment constraints on the beginning of
ancillary data as well as any needed to pad the next control message.
.El
.Sh EXAMPLES
The following example constructs a control message containing a file
descriptor and passes it over a socket:
.Bd -literal -offset indent
struct msghdr	 msg;
struct cmsghdr	*cmsg;
union {
	struct cmsghdr hdr;
	unsigned char	 buf[CMSG_SPACE(sizeof(int))];
} cmsgbuf;
struct iovec io_vector[1];

io_vector[0].iov_base = &ch;
io_vector[0].iov_len = 1;

memset(&msg, 0, sizeof(msg));
msg.msg_control = &cmsgbuf.buf;
msg.msg_controllen = sizeof(cmsgbuf.buf);
msg.msg_iov = io_vector;
msg.msg_iovlen = 1;

cmsg = CMSG_FIRSTHDR(&msg);
cmsg->cmsg_len = CMSG_LEN(sizeof(int));
cmsg->cmsg_level = SOL_SOCKET;
cmsg->cmsg_type = SCM_RIGHTS;
*(int *)CMSG_DATA(cmsg) = fd;

if (sendmsg(s, &msg, 0) == -1)
	err(1, "sendmsg");
.Ed
.Pp
And an example that receives and decomposes the control message:
.Bd -literal -offset indent
struct msghdr	 msg;
struct cmsghdr	*cmsg;
union {
	struct cmsghdr hdr;
	unsigned char	 buf[CMSG_SPACE(sizeof(int))];
} cmsgbuf;
struct iovec io_vector[1];

io_vector[0].iov_base = &ch;
io_vector[0].iov_len = 1;

memset(&msg, 0, sizeof(msg));
msg.msg_control = &cmsgbuf.buf;
msg.msg_controllen = sizeof(cmsgbuf.buf);
msg.msg_iov = io_vector;
msg.msg_iovlen = 1;

if (recvmsg(s, &msg, 0) == -1)
	err(1, "recvmsg");
if ((msg.msg_flags & MSG_TRUNC) || (msg.msg_flags & MSG_CTRUNC))
	errx(1, "control message truncated");
for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
	if (cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&
	    cmsg->cmsg_level == SOL_SOCKET &&
	    cmsg->cmsg_type == SCM_RIGHTS) {
		fd = *(int *)CMSG_DATA(cmsg);
		/* Do something with the descriptor. */
	}
}
.Ed
.Sh SEE ALSO
.Xr recvmsg 2 ,
.Xr sendmsg 2 ,
.Xr socket 2
.Sh HISTORY
The control message API first appeared in
.Bx 4.2 .
@


1.5
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
.\"	$OpenBSD: CMSG_DATA.3,v 1.3 2008/03/13 01:49:53 deraadt Exp $
d4 1
a4 1
.Dd $Mdocdate: March 13 2008 $
d98 4
d106 2
d127 4
d135 2
@


1.4
log
@show the correct idiom
@
text
@d64 1
a64 1
This value is what is normally stored in
d66 1
a66 2
and
.Fa msg_msgcontrollen .
d101 1
a101 1
msg.msg_controllen = CMSG_LEN(sizeof(int));
d124 1
a124 1
msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.3
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
.\"	$OpenBSD: CMSG_DATA.3,v 1.2 2007/05/31 19:19:48 jmc Exp $
d4 1
a4 1
.Dd $Mdocdate: May 31 2007 $
d65 3
a67 1
.Fa cmsg_len .
d102 1
a102 1
msg.msg_controllen = sizeof(cmsgbuf.buf);
d125 1
a125 1
msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.2
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: CMSG_DATA.3,v 1.1 2005/07/04 03:03:16 jaredy Exp $
d4 1
a4 1
.Dd $Mdocdate$
d64 2
d82 2
d93 4
a96 1
unsigned char	 buf[CMSG_SPACE(sizeof(int))];
d99 2
a100 2
msg.msg_control = buf;
msg.msg_controllen = CMSG_LEN(sizeof(int));
d116 4
a119 1
unsigned char	 buf[CMSG_SPACE(sizeof(int))];
d122 2
a123 2
msg.msg_control = buf;
msg.msg_controllen = sizeof(buf);
@


1.1
log
@add a manpage describing the socket control message macros.

lots of help and ok millert, ok henning, jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d4 1
a4 1
.Dd July 3, 2005
@

