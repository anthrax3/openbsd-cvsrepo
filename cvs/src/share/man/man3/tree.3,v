head	1.28;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4;
locks; strict;
comment	@.\" @;


1.28
date	2016.03.14.22.39.23;	author jmc;	state Exp;
branches;
next	1.27;
commitid	LwuzxMe5PYfiknq2;

1.27
date	2015.11.10.23.48.17;	author jmc;	state Exp;
branches;
next	1.26;
commitid	QU70QaxjyBAtj4Rv;

1.26
date	2014.09.08.01.27.55;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	cPoapLAXYNe1fcgV;

1.25
date	2013.08.14.06.32.31;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.05.03.42.03;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.09.08.43.01;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.09.00.20.36;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.05.18.17.41;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.28.12.22.48;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.28.10.26.48;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.21.16.54.12;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.30.20.19.16;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.12.17.54.02;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.11.22.19.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.24.12.04.13;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.31.19.19.48;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.06.11.35;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.17.19.32.13;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.05.19.41.33;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.20.09.13.38;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.08.08.08.46;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.12.01.09.20;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.19.02.50;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.22.16.41.54;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.08.21.07.54;	author dugsong;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.25.21.53.39;	author frantzen;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.00.07.45;	author vincent;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.24.19.42.46;	author provos;	state Exp;
branches;
next	;


desc
@@


1.28
log
@some Xr; from michal mazurek
@
text
@.\"	$OpenBSD: tree.3,v 1.27 2015/11/10 23:48:17 jmc Exp $
.\"/*
.\" * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
.\" * All rights reserved.
.\" *
.\" * Redistribution and use in source and binary forms, with or without
.\" * modification, are permitted provided that the following conditions
.\" * are met:
.\" * 1. Redistributions of source code must retain the above copyright
.\" *    notice, this list of conditions and the following disclaimer.
.\" * 2. Redistributions in binary form must reproduce the above copyright
.\" *    notice, this list of conditions and the following disclaimer in the
.\" *    documentation and/or other materials provided with the distribution.
.\" *
.\" * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\" */
.Dd $Mdocdate: November 10 2015 $
.Dt SPLAY_INIT 3
.Os
.Sh NAME
.Nm SPLAY_PROTOTYPE ,
.Nm SPLAY_GENERATE ,
.Nm SPLAY_ENTRY ,
.Nm SPLAY_HEAD ,
.Nm SPLAY_INITIALIZER ,
.Nm SPLAY_ROOT ,
.Nm SPLAY_EMPTY ,
.Nm SPLAY_NEXT ,
.Nm SPLAY_MIN ,
.Nm SPLAY_MAX ,
.Nm SPLAY_FIND ,
.Nm SPLAY_LEFT ,
.Nm SPLAY_RIGHT ,
.Nm SPLAY_FOREACH ,
.Nm SPLAY_INIT ,
.Nm SPLAY_INSERT ,
.Nm SPLAY_REMOVE ,
.Nm RB_PROTOTYPE ,
.Nm RB_PROTOTYPE_STATIC ,
.Nm RB_GENERATE ,
.Nm RB_GENERATE_STATIC ,
.Nm RB_ENTRY ,
.Nm RB_HEAD ,
.Nm RB_INITIALIZER ,
.Nm RB_ROOT ,
.Nm RB_EMPTY ,
.Nm RB_NEXT ,
.Nm RB_PREV ,
.Nm RB_MIN ,
.Nm RB_MAX ,
.Nm RB_FIND ,
.Nm RB_NFIND ,
.Nm RB_LEFT ,
.Nm RB_RIGHT ,
.Nm RB_PARENT ,
.Nm RB_FOREACH ,
.Nm RB_FOREACH_SAFE ,
.Nm RB_FOREACH_REVERSE ,
.Nm RB_FOREACH_REVERSE_SAFE ,
.Nm RB_INIT ,
.Nm RB_INSERT ,
.Nm RB_REMOVE
.Nd implementations of splay and red-black trees
.Sh SYNOPSIS
.In sys/tree.h
.Pp
.Fn SPLAY_PROTOTYPE "NAME" "TYPE" "FIELD" "CMP"
.Fn SPLAY_GENERATE "NAME" "TYPE" "FIELD" "CMP"
.Fn SPLAY_ENTRY "TYPE"
.Fn SPLAY_HEAD "HEADNAME" "TYPE"
.Ft "struct TYPE *"
.Fn SPLAY_INITIALIZER "SPLAY_HEAD *head"
.Fn SPLAY_ROOT "SPLAY_HEAD *head"
.Ft "int"
.Fn SPLAY_EMPTY "SPLAY_HEAD *head"
.Ft "struct TYPE *"
.Fn SPLAY_NEXT "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn SPLAY_MIN "NAME" "SPLAY_HEAD *head"
.Ft "struct TYPE *"
.Fn SPLAY_MAX "NAME" "SPLAY_HEAD *head"
.Ft "struct TYPE *"
.Fn SPLAY_FIND "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn SPLAY_LEFT "struct TYPE *elm" "SPLAY_ENTRY NAME"
.Ft "struct TYPE *"
.Fn SPLAY_RIGHT "struct TYPE *elm" "SPLAY_ENTRY NAME"
.Fn SPLAY_FOREACH "VARNAME" "NAME" "SPLAY_HEAD *head"
.Ft void
.Fn SPLAY_INIT "SPLAY_HEAD *head"
.Ft "struct TYPE *"
.Fn SPLAY_INSERT "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn SPLAY_REMOVE "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
.Pp
.Fn RB_PROTOTYPE "NAME" "TYPE" "FIELD" "CMP"
.Fn RB_PROTOTYPE_STATIC "NAME" "TYPE" "FIELD" "CMP"
.Fn RB_GENERATE "NAME" "TYPE" "FIELD" "CMP"
.Fn RB_GENERATE_STATIC "NAME" "TYPE" "FIELD" "CMP"
.Fn RB_ENTRY "TYPE"
.Fn RB_HEAD "HEADNAME" "TYPE"
.Fn RB_INITIALIZER "RB_HEAD *head"
.Ft "struct TYPE *"
.Fn RB_ROOT "RB_HEAD *head"
.Ft "int"
.Fn RB_EMPTY "RB_HEAD *head"
.Ft "struct TYPE *"
.Fn RB_NEXT "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn RB_PREV "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn RB_MIN "NAME" "RB_HEAD *head"
.Ft "struct TYPE *"
.Fn RB_MAX "NAME" "RB_HEAD *head"
.Ft "struct TYPE *"
.Fn RB_FIND "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn RB_NFIND "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn RB_LEFT "struct TYPE *elm" "RB_ENTRY NAME"
.Ft "struct TYPE *"
.Fn RB_RIGHT "struct TYPE *elm" "RB_ENTRY NAME"
.Ft "struct TYPE *"
.Fn RB_PARENT "struct TYPE *elm" "RB_ENTRY NAME"
.Fn RB_FOREACH "VARNAME" "NAME" "RB_HEAD *head"
.Fn RB_FOREACH_SAFE "VARNAME" "NAME" "RB_HEAD *head" "TEMP_VARNAME"
.Fn RB_FOREACH_REVERSE "VARNAME" "NAME" "RB_HEAD *head"
.Fn RB_FOREACH_REVERSE_SAFE "VARNAME" "NAME" "RB_HEAD *head" "TEMP_VARNAME"
.Ft void
.Fn RB_INIT "RB_HEAD *head"
.Ft "struct TYPE *"
.Fn RB_INSERT "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Ft "struct TYPE *"
.Fn RB_REMOVE "NAME" "RB_HEAD *head" "struct TYPE *elm"
.Sh DESCRIPTION
These macros define data structures for different types of trees:
splay trees and red-black trees.
.Pp
In the macro definitions,
.Fa TYPE
is the name tag of a user defined structure that must contain a field named
.Fa FIELD ,
of type
.Li SPLAY_ENTRY
or
.Li RB_ENTRY .
The argument
.Fa HEADNAME
is the name tag of a user defined structure that must be declared
using the macros
.Fn SPLAY_HEAD
or
.Fn RB_HEAD .
The argument
.Fa NAME
has to be a unique name prefix for every tree that is defined.
.Pp
The function prototypes are declared with
.Li SPLAY_PROTOTYPE ,
.Li RB_PROTOTYPE ,
or
.Li RB_PROTOTYPE_STATIC .
The function bodies are generated with
.Li SPLAY_GENERATE ,
.Li RB_GENERATE ,
or
.Li RB_GENERATE_STATIC .
See the examples below for further explanation of how these macros are used.
.Sh SPLAY TREES
A splay tree is a self-organizing data structure.
Every operation on the tree causes a splay to happen.
The splay moves the requested node to the root of the tree and partly
rebalances it.
.Pp
This has the benefit that request locality causes faster lookups as
the requested nodes move to the top of the tree.
On the other hand, every lookup causes memory writes.
.Pp
The Balance Theorem bounds the total access time for m operations
and n inserts on an initially empty tree as O((m + n)lg n).
The amortized cost for a sequence of m accesses to a splay tree is O(lg n).
.Pp
A splay tree is headed by a structure defined by the
.Fn SPLAY_HEAD
macro.
A
.Fa SPLAY_HEAD
structure is declared as follows:
.Bd -literal -offset indent
SPLAY_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
where
.Fa HEADNAME
is the name of the structure to be defined, and struct
.Fa TYPE
is the type of the elements to be inserted into the tree.
.Pp
The
.Fn SPLAY_ENTRY
macro declares a structure that allows elements to be connected in the tree.
.Pp
In order to use the functions that manipulate the tree structure,
their prototypes need to be declared with the
.Fn SPLAY_PROTOTYPE
macro,
where
.Fa NAME
is a unique identifier for this particular tree.
The
.Fa TYPE
argument is the type of the structure that is being managed
by the tree.
The
.Fa FIELD
argument is the name of the element defined by
.Fn SPLAY_ENTRY .
.Pp
The function bodies are generated with the
.Fn SPLAY_GENERATE
macro.
It takes the same arguments as the
.Fn SPLAY_PROTOTYPE
macro, but should be used only once.
.Pp
Finally,
the
.Fa CMP
argument is the name of a function used to compare trees' nodes
with each other.
The function takes two arguments of type
.Fa "struct TYPE *" .
If the first argument is smaller than the second, the function returns a
value smaller than zero.
If they are equal, the function returns zero.
Otherwise, it should return a value greater than zero.
The compare function defines the order of the tree elements.
.Pp
The
.Fn SPLAY_INIT
macro initializes the tree referenced by
.Fa head .
.Pp
The splay tree can also be initialized statically by using the
.Fn SPLAY_INITIALIZER
macro like this:
.Bd -literal -offset indent
SPLAY_HEAD(HEADNAME, TYPE) head = SPLAY_INITIALIZER(&head);
.Ed
.Pp
The
.Fn SPLAY_INSERT
macro inserts the new element
.Fa elm
into the tree.
Upon success,
.Va NULL
is returned.
If a matching element already exists in the tree, the insertion is
aborted, and a pointer to the existing element is returned.
.Pp
The
.Fn SPLAY_REMOVE
macro removes the element
.Fa elm
from the tree pointed by
.Fa head .
Upon success, a pointer to the removed element is returned.
.Va NULL
is returned if
.Fa elm
is not present in the tree.
.Pp
The
.Fn SPLAY_FIND
macro can be used to find a particular element in the tree.
.Bd -literal -offset indent
struct TYPE find, *res;
find.key = 30;
res = SPLAY_FIND(NAME, &head, &find);
.Ed
.Pp
The
.Fn SPLAY_ROOT ,
.Fn SPLAY_MIN ,
.Fn SPLAY_MAX ,
and
.Fn SPLAY_NEXT
macros can be used to traverse the tree:
.Bd -literal -offset indent
for (np = SPLAY_MIN(NAME, &head); np != NULL; np = SPLAY_NEXT(NAME, &head, np))
.Ed
.Pp
Or, for simplicity, one can use the
.Fn SPLAY_FOREACH
macro:
.Bd -literal -offset indent
SPLAY_FOREACH(np, NAME, &head)
.Ed
.Pp
The
.Fn SPLAY_EMPTY
macro should be used to check whether a splay tree is empty.
.Sh RED-BLACK TREES
A red-black tree is a binary search tree with the node color as an
extra attribute.
It fulfills a set of conditions:
.Pp
.Bl -enum -compact -offset indent
.It
every search path from the root to a leaf consists of the same number of
black nodes,
.It
each red node (except for the root) has a black parent,
.It
each leaf node is black.
.El
.Pp
Every operation on a red-black tree is bounded as O(lg n).
The maximum height of a red-black tree is 2lg (n+1).
.Pp
A red-black tree is headed by a structure defined by the
.Fn RB_HEAD
macro.
A
.Fa RB_HEAD
structure is declared as follows:
.Bd -literal -offset indent
RB_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
where
.Fa HEADNAME
is the name of the structure to be defined, and struct
.Fa TYPE
is the type of the elements to be inserted into the tree.
.Pp
The
.Fn RB_ENTRY
macro declares a structure that allows elements to be connected in the tree.
.Pp
In order to use the functions that manipulate the tree structure,
their prototypes need to be declared with the
.Fn RB_PROTOTYPE
or
.Fn RB_PROTOTYPE_STATIC
macros,
where
.Fa NAME
is a unique identifier for this particular tree.
The
.Fa TYPE
argument is the type of the structure that is being managed
by the tree.
The
.Fa FIELD
argument is the name of the element defined by
.Fn RB_ENTRY .
.Pp
The function bodies are generated with the
.Fn RB_GENERATE
or
.Fn RB_GENERATE_STATIC
macros.
These macros take the same arguments as the
.Fn RB_PROTOTYPE
and
.Fn RB_PROTOTYPE_STATIC
macros, but should be used only once.
.Pp
Finally,
the
.Fa CMP
argument is the name of a function used to compare trees' nodes
with each other.
The function takes two arguments of type
.Fa "struct TYPE *" .
If the first argument is smaller than the second, the function returns a
value smaller than zero.
If they are equal, the function returns zero.
Otherwise, it should return a value greater than zero.
The compare function defines the order of the tree elements.
.Pp
The
.Fn RB_INIT
macro initializes the tree referenced by
.Fa head .
.Pp
The red-black tree can also be initialized statically by using the
.Fn RB_INITIALIZER
macro like this:
.Bd -literal -offset indent
RB_HEAD(HEADNAME, TYPE) head = RB_INITIALIZER(&head);
.Ed
.Pp
The
.Fn RB_INSERT
macro inserts the new element
.Fa elm
into the tree.
Upon success,
.Va NULL
is returned.
If a matching element already exists in the tree, the insertion is
aborted, and a pointer to the existing element is returned.
.Pp
The
.Fn RB_REMOVE
macro removes the element
.Fa elm
from the tree pointed by
.Fa head .
.Fn RB_REMOVE
returns
.Fa elm .
.Pp
The
.Fn RB_FIND
and
.Fn RB_NFIND
macros can be used to find a particular element in the tree.
.Fn RB_FIND
finds the node with the same key as
.Fa elm .
.Fn RB_NFIND
finds the first node greater than or equal to the search key.
.Bd -literal -offset indent
struct TYPE find, *res;
find.key = 30;
res = RB_FIND(NAME, &head, &find);
.Ed
.Pp
The
.Fn RB_ROOT ,
.Fn RB_MIN ,
.Fn RB_MAX ,
.Fn RB_NEXT ,
and
.Fn RB_PREV
macros can be used to traverse the tree:
.Bd -literal -offset indent
for (np = RB_MIN(NAME, &head); np != NULL; np = RB_NEXT(NAME, &head, np))
.Ed
.Pp
Or, for simplicity, one can use the
.Fn RB_FOREACH
or
.Fn RB_FOREACH_REVERSE
macros:
.Bd -literal -offset indent
RB_FOREACH(np, NAME, &head)
.Ed
.Pp
The macros
.Fn RB_FOREACH_SAFE
and
.Fn RB_FOREACH_REVERSE_SAFE
traverse the tree referenced by head
in a forward or reverse direction respectively,
assigning each element in turn to np.
However, unlike their unsafe counterparts,
they permit both the removal of np
as well as freeing it from within the loop safely
without interfering with the traversal.
.Pp
The
.Fn RB_EMPTY
macro should be used to check whether a red-black tree is empty.
.Sh EXAMPLES
The following example demonstrates how to declare a red-black tree
holding integers.
Values are inserted into it and the contents of the tree are printed
in order.
Lastly, the internal structure of the tree is printed.
.Bd -literal -offset 3n
#include <sys/tree.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>

struct node {
	RB_ENTRY(node) entry;
	int i;
};

int
intcmp(struct node *e1, struct node *e2)
{
	return (e1->i < e2->i ? -1 : e1->i > e2->i);
}

RB_HEAD(inttree, node) head = RB_INITIALIZER(&head);
RB_GENERATE(inttree, node, entry, intcmp)

int testdata[] = {
	20, 16, 17, 13, 3, 6, 1, 8, 2, 4, 10, 19, 5, 9, 12, 15, 18,
	7, 11, 14
};

void
print_tree(struct node *n)
{
	struct node *left, *right;

	if (n == NULL) {
		printf("nil");
		return;
	}
	left = RB_LEFT(n, entry);
	right = RB_RIGHT(n, entry);
	if (left == NULL && right == NULL)
		printf("%d", n->i);
	else {
		printf("%d(", n->i);
		print_tree(left);
		printf(",");
		print_tree(right);
		printf(")");
	}
}

int
main()
{
	int i;
	struct node *n;

	for (i = 0; i < sizeof(testdata) / sizeof(testdata[0]); i++) {
		if ((n = malloc(sizeof(struct node))) == NULL)
			err(1, NULL);
		n->i = testdata[i];
		RB_INSERT(inttree, &head, n);
	}

	RB_FOREACH(n, inttree, &head) {
		printf("%d\en", n->i);
	}
	print_tree(RB_ROOT(&head));
	printf("\en");
	return (0);
}
.Ed
.Sh SEE ALSO
.Xr queue 3
.Sh NOTES
Trying to free a tree in the following way is a common error:
.Bd -literal -offset indent
SPLAY_FOREACH(var, NAME, &head) {
	SPLAY_REMOVE(NAME, &head, var);
	free(var);
}
free(head);
.Ed
.Pp
Since
.Va var
is free'd, the
.Fn FOREACH
macro refers to a pointer that may have been reallocated already.
Proper code needs a second variable.
.Bd -literal -offset indent
for (var = SPLAY_MIN(NAME, &head); var != NULL; var = nxt) {
	nxt = SPLAY_NEXT(NAME, &head, var);
	SPLAY_REMOVE(NAME, &head, var);
	free(var);
}
.Ed
.Sh AUTHORS
The author of the tree macros is
.An Niels Provos .
@


1.27
log
@update NAME section to include all documented functions,
or otherwise change Dt to reflect the name of an existing function;

feedback/ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.26 2014/09/08 01:27:55 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: September 8 2014 $
d552 2
@


1.26
log
@obvious cases of missing .An;
found with the new mandoc(1) MANDOCERR_AN_MISSING warning;
no text changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.25 2013/08/14 06:32:31 jmc Exp $
d26 2
a27 2
.Dd $Mdocdate: August 14 2013 $
.Dt TREE 3
@


1.25
log
@no longer any need to quote macro lines with >9 args;
From: Jan Stary
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.24 2013/06/05 03:42:03 tedu Exp $
d26 1
a26 1
.Dd $Mdocdate: June 5 2013 $
d576 2
a577 1
The author of the tree macros is Niels Provos.
@


1.24
log
@use fancy .In macros for includes. from Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.23 2011/07/09 08:43:01 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: July 9 2011 $
d72 1
a72 1
.Nd "implementations of splay and red-black trees"
@


1.23
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.22 2011/07/09 00:20:36 pirofti Exp $
d74 1
a74 1
.Fd #include <sys/tree.h>
@


1.22
log
@Document the newly added FOREACH_SAFE marcos.
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.21 2010/05/05 18:17:41 nicm Exp $
d26 1
a26 1
.Dd $Mdocdate: May 5 2010 $
d463 11
a473 6
The macros RB_FOREACH_SAFE and RB_FOREACH_REVERSE_SAFE traverse the
tree referenced by head in the forward or reverse direction respectively,
assigning each element in turn to np.  However, unlike their unsafe
counterparts, RB_FOREACH and RB_FOREACH_REVERSE permit to both
remove np as well as free it from within the loop safely without interfering
with the traversal.
@


1.21
log
@Move the return values of RB_INSERT, RB_REMOVE, SPLAY_INSERT and
SPLAY_REMOVE closer to whether the macros are documents rather than in a
separate section. Also describe the actual return values of the remove
macros.

Tweaked version of a diff from Tim van der Molen.

ok jmc henning
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.20 2009/01/28 12:22:48 stsp Exp $
d26 1
a26 1
.Dd $Mdocdate: January 28 2009 $
d66 1
d68 1
d135 1
d137 1
d462 7
@


1.20
log
@Document the return value of RB_INSERT in tree(3).
wording fixes and ok henning@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.19 2009/01/28 10:26:48 stsp Exp $
d261 5
d273 5
d418 3
a558 17
.Pp
Both
.Fn RB_INSERT
and
.Fn SPLAY_INSERT
return
.Va NULL
if the element was inserted in the tree successfully, otherwise they
return a pointer to the element with the colliding key.
.Pp
Accordingly,
.Fn RB_REMOVE
and
.Fn SPLAY_REMOVE
return the pointer to the removed element, otherwise they return
.Va NULL
to indicate an error.
@


1.19
log
@Document the difference between RB_FIND and RB_NFIND in tree(3).
Added text was copied from comments found in sys/tree.h.
"go ahead, if something's wrong with it, jmc will fix it" mcbride@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.18 2008/12/21 16:54:12 tedu Exp $
d26 1
a26 1
.Dd $Mdocdate: December 21 2008 $
d396 5
@


1.18
log
@fix example comparison function to work with large ranges of numbers.  ok djm otto
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.17 2008/11/30 20:19:16 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: November 30 2008 $
d409 5
@


1.17
log
@fixes from Jacek Masiulaniec, tweaked by otto and myself;
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.16 2008/05/12 17:54:02 millert Exp $
d26 1
a26 1
.Dd $Mdocdate: May 12 2008 $
d459 1
a459 1
	return (e1->i - e2->i);
@


1.16
log
@Remove clauses 3 and 4 from the license to match the license on
tree.h.  OK'd by Niels.
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.15 2008/05/11 22:19:09 millert Exp $
d26 1
a26 1
.Dd $Mdocdate: May 11 2008 $
d146 4
a149 2
is the name tag of a user defined structure that must contain a field of type
.Li SPLAY_ENTRY ,
d151 1
a151 3
.Li RB_ENTRY ,
named
.Fa ENTRYNAME .
d234 1
a234 1
argument is the name of a function used to compare trees noded
d369 1
a369 1
argument is the name of a function used to compare trees noded
@


1.15
log
@Add RB_PROTOTYPE_STATIC, RB_GENERATE_STATIC, RB_PREV, RB_NFIND,
and RB_FOREACH_REVERSE from FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.14 2007/12/24 12:04:13 otto Exp $
a13 5
.\" * 3. All advertising materials mentioning features or use of this software
.\" *    must display the following acknowledgement:
.\" *      This product includes software developed by Niels Provos.
.\" * 4. The name of the author may not be used to endorse or promote products
.\" *    derived from this software without specific prior written permission.
d26 1
a26 1
.Dd $Mdocdate: December 24 2007 $
@


1.14
log
@bool -> int
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.13 2007/05/31 19:19:48 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate$
d53 1
d55 1
d62 1
d66 1
d71 1
d109 1
d111 1
d122 2
d130 2
d138 1
d168 3
a170 2
The function prototypes are declared with either
.Li SPLAY_PROTOTYPE
d172 4
a175 3
.Li RB_PROTOTYPE .
The function bodies are generated with either
.Li SPLAY_GENERATE
d177 1
a177 1
.Li RB_GENERATE .
d345 3
a347 1
macro,
d362 4
a365 2
macro.
It takes the same arguments as the
d367 3
a369 1
macro, but should be used only once.
d411 3
a413 1
macro can be used to find a particular element in the tree.
d424 1
d426 1
a426 1
.Fn RB_NEXT
d434 3
a436 1
macro:
@


1.13
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.12 2005/04/16 06:11:35 otto Exp $
d81 1
a81 1
.Ft "bool"
d110 1
a110 1
.Ft "bool"
@


1.12
log
@Give a complete, working example how to use the tree macros. The
existing descripion is rather terse, and without an example it's
hard to get going.  ok millert@@ mpech@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.11 2004/02/17 19:32:13 jmc Exp $
d31 1
a31 1
.Dd February 24, 2002
@


1.11
log
@typos;
from Maxim Tsyplakov;
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.10 2003/11/05 19:41:33 jmc Exp $
d419 74
@


1.10
log
@correct errors in code examples; from Dries Schellekens;
ok niels@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.9 2003/05/20 09:13:38 jmc Exp $
d369 1
a369 1
The redblack tree can also be initialized statically by using the
d418 1
a418 1
macro should be used to check whether a splay tree is empty.
@


1.9
log
@typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.8 2002/11/08 08:08:46 mpech Exp $
d266 1
a266 1
res = SPLAY_FIND(NAME, head, &find);
d284 1
a284 1
SPLAY_FOREACH(np, NAME, head)
d294 1
d395 1
a395 1
res = RB_FIND(NAME, head, &find);
d413 1
a413 1
RB_FOREACH(np, NAME, head)
d422 2
a423 2
SPLAY_FOREACH(var, NAME, head) {
	SPLAY_REMOVE(NAME, head, var);
d436 3
a438 3
for (var = SPLAY_MIN(NAME, head); var != NULL; var = nxt) {
	nxt = SPLAY_NEXT(NAME, head, var);
	SPLAY_REMOVE(NAME, head, var);
@


1.8
log
@Time to cleanup:
o) start new sentence on a new line;
o) wrap long lines;
o) don't use .Pp before/after .Sh, .Ss;
o) OpenBSD -> .Ox;
o) typos;
o) close .Rs;
o) use space between arguments in tag, for example:
   .Xr blabla ) .

miod@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.7 2002/06/12 01:09:20 provos Exp $
d35 2
a36 2
.Nm SPLAY_PROTOTYPE,
.Nm SPLAY_GENERATE,
d52 2
a53 2
.Nm RB_PROTOTYPE,
.Nm RB_GENERATE,
d134 1
a134 1
These macros defines data structures for different types of trees:
d149 1
a149 1
.Fn SPLAY_HEAD ,
d157 1
a157 1
.Li SPLAY_PROTOTYPE,
d161 1
a161 1
.Li SPLAY_GENERATE,
d177 1
a177 1
The amortized cost for a sequence of m accesses to a splay tree is O(lg n);
d206 1
a206 1
The 
d225 1
a225 1
argument is the name of a function used to compare tree noded
d334 1
a334 1
The 
d353 1
a353 1
argument is the name of a function used to compare tree noded
d455 1
a455 1
return the pointer to the removed element otherwise they return
@


1.7
log
@correct prototypes
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.6 2002/06/11 19:02:50 provos Exp $
d166 4
a169 3
A splay tree is a self-organizing data structure.  Every operation
on the tree causes a splay to happen.  The splay moves the requested
node to the root of the tree and partly rebalances it.
d172 2
a173 2
the requested nodes move to the top of the tree.  On the other hand,
every lookup causes memory writes.
d176 2
a177 2
and n inserts on an initially empty tree as O((m + n)lg n).  The
amortized cost for a sequence of m accesses to a splay tree is O(lg n);
d217 2
a218 1
macro. It takes the same arguments as the
d226 2
a227 1
with each other.  The function takes two arguments of type
d230 4
a233 3
value smaller than zero. If they are equal, the function returns zero.
Otherwise, it should return a value greater than zero.  The compare
function defines the order of the tree elements.
a289 1
.Pp
d292 2
a293 1
extra attribute.  It fulfills a set of conditions:
d345 2
a346 1
macro. It takes the same arguments as the
d354 2
a355 1
with each other.  The function takes two arguments of type
d358 4
a361 3
value smaller than zero. If they are equal, the function returns zero.
Otherwise, it should return a value greater than zero.  The compare
function defines the order of the tree elements.
a417 1
.Pp
@


1.6
log
@document return values
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.5 2002/04/22 16:41:54 provos Exp $
d98 1
a98 1
.Ft void
d100 1
a100 1
.Ft void
d129 1
a129 1
.Ft void
d131 1
a131 1
.Ft void
@


1.5
log
@fix example showing how to properly free a tree; pointed out by dugsong@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.4 2002/04/08 21:07:54 dugsong Exp $
d435 17
@


1.4
log
@sync *_{MIN,MAX} synopsis with reality. ok provos@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.3 2002/03/25 21:53:39 frantzen Exp $
d415 2
a416 1
SPLAY_FOREACH(var, NAME, head)
d418 1
d431 1
@


1.3
log
@document the {SPLAY,RB}_INITIALIZER and {SPLAY,RB}_EMPTY() macros
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.2 2002/03/19 00:07:45 vincent Exp $
d86 1
a86 1
.Fn SPLAY_MIN "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
d88 1
a88 1
.Fn SPLAY_MAX "NAME" "SPLAY_HEAD *head" "struct TYPE *elm"
d115 1
a115 1
.Fn RB_MIN "NAME" "RB_HEAD *head" "struct TYPE *elm"
d117 1
a117 1
.Fn RB_MAX "NAME" "RB_HEAD *head" "struct TYPE *elm"
@


1.2
log
@ Free/tree typos.

 ok provos@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: tree.3,v 1.1 2002/02/24 19:42:46 provos Exp $
d39 1
d41 1
d56 1
d58 1
d79 1
d81 2
d107 1
d110 2
d236 7
d283 4
d361 7
d407 4
@


1.1
log
@queue.h like implementation of splay and red-black trees
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d241 1
a241 1
macro can be used to find a particular element in the free.
d355 1
a355 1
macro can be used to find a particular element in the free.
@

