head	1.109;
access;
symbols
	OPENBSD_6_1:1.106.0.4
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.100.0.2
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.56.0.4
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4;
locks; strict;
comment	@.\" @;


1.109
date	2017.06.19.18.36.13;	author jmc;	state Exp;
branches;
next	1.108;
commitid	uprcDRTKcJmrm5Jc;

1.108
date	2017.06.19.17.58.49;	author bluhm;	state Exp;
branches;
next	1.107;
commitid	o1URxEJIRKTXxlGk;

1.107
date	2017.05.19.05.59.27;	author jmc;	state Exp;
branches;
next	1.106;
commitid	PYblWHlB0a44lLjW;

1.106
date	2017.03.29.23.05.05;	author claudio;	state Exp;
branches;
next	1.105;
commitid	8nVhaW9pnpztUPKD;

1.105
date	2016.10.17.02.53.47;	author lteo;	state Exp;
branches;
next	1.104;
commitid	kMKoNy6xnp0AkjUZ;

1.104
date	2016.09.15.00.00.40;	author dlg;	state Exp;
branches;
next	1.103;
commitid	4cpeDghFp8TKfeYT;

1.103
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.102;
commitid	MhzOL3PcQJk4ZhiI;

1.102
date	2016.09.04.02.26.44;	author lteo;	state Exp;
branches;
next	1.101;
commitid	YZAOK9fYGxPGlqNg;

1.101
date	2016.09.04.02.07.48;	author lteo;	state Exp;
branches;
next	1.100;
commitid	Ee1R5fPlvp6ONzd0;

1.100
date	2016.07.19.08.13.46;	author mpi;	state Exp;
branches;
next	1.99;
commitid	ECRL6QXqoTrZfqgd;

1.99
date	2016.04.08.10.01.12;	author dlg;	state Exp;
branches;
next	1.98;
commitid	F8YdRwULzUZMnwbM;

1.98
date	2016.04.08.03.23.13;	author dlg;	state Exp;
branches;
next	1.97;
commitid	f5TKxvA5MusUTz78;

1.97
date	2016.04.08.03.19.33;	author dlg;	state Exp;
branches;
next	1.96;
commitid	RSHwKhUVszKXBeyl;

1.96
date	2016.04.08.03.04.15;	author dlg;	state Exp;
branches;
next	1.95;
commitid	60mPlWJQPxSaGwx1;

1.95
date	2015.11.23.17.53.57;	author jmc;	state Exp;
branches;
next	1.94;
commitid	GVTTSAMZ93Lz4hmE;

1.94
date	2015.11.13.10.12.39;	author mpi;	state Exp;
branches;
next	1.93;
commitid	BHDkuvEKkivQfKxx;

1.93
date	2015.11.12.10.07.14;	author mpi;	state Exp;
branches;
next	1.92;
commitid	DLHQ4NjCPIqpY9kD;

1.92
date	2015.10.30.21.21.19;	author benno;	state Exp;
branches;
next	1.91;
commitid	m0th3qafb2qrTR13;

1.91
date	2015.10.08.14.09.34;	author jmc;	state Exp;
branches;
next	1.90;
commitid	LV6jo6qcKrSFUVI7;

1.90
date	2015.10.08.11.36.15;	author dlg;	state Exp;
branches;
next	1.89;
commitid	U8z6RYthMST4iApN;

1.89
date	2015.09.21.11.30.50;	author mpi;	state Exp;
branches;
next	1.88;
commitid	JiDQBod2KVaTYhoB;

1.88
date	2015.07.08.07.21.49;	author mpi;	state Exp;
branches;
next	1.87;
commitid	9ERVupAoYqW4Iok9;

1.87
date	2015.06.17.06.24.46;	author mpi;	state Exp;
branches;
next	1.86;
commitid	qlrqL3TQLE2Q12SU;

1.86
date	2015.06.16.11.17.02;	author mpi;	state Exp;
branches;
next	1.85;
commitid	mmZtoJeVfIyuAedv;

1.85
date	2015.02.19.05.53.46;	author dlg;	state Exp;
branches;
next	1.84;
commitid	1SYM4o9x9DnSiq55;

1.84
date	2015.02.16.16.38.54;	author naddy;	state Exp;
branches;
next	1.83;
commitid	ne9aoqc3owhFBWUD;

1.83
date	2015.02.10.04.08.00;	author lteo;	state Exp;
branches;
next	1.82;
commitid	0agkuL2WLCDXzVaT;

1.82
date	2015.02.10.03.50.30;	author lteo;	state Exp;
branches;
next	1.81;
commitid	MeF3IDaGYk1y2KwO;

1.81
date	2015.02.07.02.53.04;	author dlg;	state Exp;
branches;
next	1.80;
commitid	fV0p8UouOEBhOsHW;

1.80
date	2015.02.07.02.30.28;	author dlg;	state Exp;
branches;
next	1.79;
commitid	PmyMCibFRT2l5yea;

1.79
date	2015.02.01.03.32.32;	author lteo;	state Exp;
branches;
next	1.78;
commitid	SwCxBm4djIt95QMp;

1.78
date	2015.01.31.03.08.33;	author lteo;	state Exp;
branches;
next	1.77;
commitid	y8AfiAkftL6rIUMQ;

1.77
date	2015.01.31.03.06.25;	author lteo;	state Exp;
branches;
next	1.76;
commitid	xAA5tZSB3G79P6Rj;

1.76
date	2014.08.18.04.06.16;	author dlg;	state Exp;
branches;
next	1.75;
commitid	EElxWqZWwFLxGTC9;

1.75
date	2014.07.13.10.59.49;	author jmc;	state Exp;
branches;
next	1.74;
commitid	PKHLPZnQvYuIcGWm;

1.74
date	2014.07.13.09.52.48;	author dlg;	state Exp;
branches;
next	1.73;
commitid	EPHrRog2Cgp9jFyM;

1.73
date	2014.07.13.05.23.24;	author dlg;	state Exp;
branches;
next	1.72;
commitid	npZSWwf7KlhdJZxO;

1.72
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.14.09.06.41;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.27.10.30.58;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2013.11.27.13.28.37;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.25.18.42.36;	author lteo;	state Exp;
branches;
next	1.65;

1.65
date	2013.08.21.05.21.42;	author dlg;	state Exp;
branches;
next	1.64;

1.64
date	2013.06.11.01.01.15;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.05.11.30.23;	author jmc;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.05.03.28.43;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2013.06.04.19.27.09;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.23.18.33.43;	author lteo;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.03.07.53.22;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2012.11.17.10.55.21;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.27.16.15.00;	author jmc;	state Exp;
branches;
next	1.56;

1.56
date	2011.12.02.10.57.16;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2011.11.30.10.26.56;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.29.12.59.28;	author blambert;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.05.11.59.11;	author blambert;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.04.20.31.47;	author jmc;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.03.12.33.47;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.03.09.49.24;	author blambert;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.30.16.51.38;	author jmc;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.30.15.20.13;	author stsp;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.07.09.16.36;	author blambert;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.29.16.43.54;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.10.10.53.33;	author jmc;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.09.11.40.58;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.02.23.37.08;	author blambert;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.28.23.08.58;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.26.11.51.14;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.14.23.39.05;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.29.15.44.37;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.29.02.39.30;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.03.22.16.51;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.15.17.16.14;	author naddy;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.29.08.13.08;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.13.14.13.14;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2008.03.30.15.01.56;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.11.07.58.28;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2008.02.03.17.20.21;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.14.16.16.08;	author mk;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.10.14.53.25;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.12.14.52.13;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.03.06.37.37;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.12.07.24.31;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.11.22.39.46;	author mpf;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.05.18.00.34;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.28.19.02.46;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.25.23.33.40;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.29.00.47.36;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.10.05.44.40;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.27.00.59.14;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.25.21.54.55;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.16.21.23.08;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.27.05.01.52;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.12.10.25.00;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.17.05.08.39;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.14.19.44.32;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.14.19.29.54;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.14.19.27.48;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.02.03.39.07;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.14.17.25.19;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.12.07.25.35;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.06.10.08.47;	author jjbg;	state Exp;
branches;
next	1.2;

1.2
date	99.09.22.09.54.38;	author espie;	state dead;
branches;
next	1.1;

1.1
date	99.09.22.03.16.47;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.109
log
@missing letter in previous;
@
text
@.\"     $OpenBSD: mbuf.9,v 1.108 2017/06/19 17:58:49 bluhm Exp $
.\"
.\" Copyright (c) 2001 Jean-Jacques Bernard-Gundol <jjbg@@openbsd.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: June 19 2017 $
.Dt MGET 9
.Os
.Sh NAME
.Nm m_copym ,
.Nm m_free ,
.Nm m_get ,
.Nm MGET ,
.Nm m_getclr ,
.Nm m_gethdr ,
.Nm m_resethdr ,
.Nm MGETHDR ,
.Nm m_prepend ,
.Nm M_PREPEND ,
.Nm m_pulldown ,
.Nm m_pullup ,
.Nm m_split ,
.Nm m_makespace ,
.Nm m_getptr ,
.Nm m_adj ,
.Nm m_copyback ,
.Nm m_defrag ,
.Nm m_freem ,
.Nm m_freemp ,
.Nm m_purge ,
.Nm m_reclaim ,
.Nm m_copydata ,
.Nm m_cat ,
.Nm m_devget ,
.Nm m_apply ,
.Nm MCLGET ,
.Nm MCLGETI ,
.Nm MEXTADD ,
.Nm M_ALIGN ,
.Nm MH_ALIGN ,
.Nm M_READONLY ,
.Nm M_LEADINGSPACE ,
.Nm M_TRAILINGSPACE ,
.Nm mtod ,
.Nm m_dup_pkt ,
.Nm m_dup_pkthdr
.Nd kernel memory management for networking protocols
.Sh SYNOPSIS
.In sys/mbuf.h
.Ft struct mbuf *
.Fn m_copym "struct mbuf *m" "int off" "int len" "int wait"
.Ft struct mbuf *
.Fn m_free "struct mbuf *m"
.Ft struct mbuf *
.Fn m_get "int how" "int type"
.Fn MGET "struct mbuf *m" "int how" "int type"
.Ft struct mbuf *
.Fn m_getclr "int how" "int type"
.Ft void
.Fn m_resethdr "struct mbuf *m"
.Ft struct mbuf *
.Fn m_gethdr "int how" "int type"
.Fn MGETHDR "struct mbuf *m" "int how" "int type"
.Ft struct mbuf *
.Fn m_prepend "struct mbuf *m" "int len" "int how"
.Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
.Ft struct mbuf *
.Fn m_pulldown "struct mbuf *m" "int off" "int len" "int *offp"
.Ft struct mbuf *
.Fn m_pullup "struct mbuf *n" "int len"
.Ft struct mbuf *
.Fn m_split "struct mbuf *m0" "int len0" "int wait"
.Ft struct mbuf *
.Fn m_makespace "struct mbuf *m0" "int skip" "int hlen" "int *off"
.Ft struct mbuf *
.Fn m_getptr "struct mbuf *m" "int loc" "int *off"
.Ft void
.Fn m_adj "struct mbuf *mp" "int req_len"
.Ft int
.Fn m_copyback "struct mbuf *m0" "int off" "int len" "const void *cp" "int wait"
.Ft int
.Fn m_defrag "struct mbuf *m" "int wait"
.Ft struct mbuf *
.Fn m_freem "struct mbuf *m"
.Ft struct mbuf *
.Fn m_freemp "struct mbuf **mp"
.Ft void
.Fn m_purge "struct mbuf *m"
.Ft void
.Fn m_reclaim "void"
.Ft void
.Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
.Ft void
.Fn m_cat "struct mbuf *m" "struct mbuf *n"
.Ft struct mbuf *
.Fn m_devget "char *buf" "int totlen" "int off"
.Ft int
.Fn m_apply "struct mbuf *m" "int off" "int len" \
"int (*func)(caddr_t, caddr_t, unsigned int)" "caddr_t fstate"
.Fn MCLGET "struct mbuf *m" "int how"
.Ft struct mbuf *
.Fn MCLGETI "struct mbuf *m" "int how" "struct ifnet *ifp" "int len"
.Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int flags" \
"void (*free)(caddr_t, u_int, void *)" "void *arg"
.Fn M_ALIGN "struct mbuf *m" "int len"
.Fn MH_ALIGN "struct mbuf *m" "int len"
.Fn M_READONLY "struct mbuf *m"
.Fn M_LEADINGSPACE "struct mbuf *m"
.Fn M_TRAILINGSPACE "struct mbuf *m"
.Ft struct mbuf *
.Fn m_dup_pkt "struct mbuf *m" "u_int adj" "int how"
.Ft int
.Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from" "int how"
.Bd -literal
#define MSIZE           256

#define MLEN            (MSIZE - sizeof(struct m_hdr))
#define MHLEN           (MLEN - sizeof(struct pkthdr))

#define MAXMCLBYTES     (64 * 1024)
#define MINCLSIZE       (MHLEN + MLEN + 1)
#define M_MAXCOMPRESS   (MHLEN / 2)

#define MCLSHIFT        11

#define MCLBYTES        (1 << MCLSHIFT)
#define MCLOFSET        (MCLBYTES - 1)

#define mtod(m,t)       ((t)((m)->m_data))

struct m_hdr {
        struct  mbuf *mh_next;
        struct  mbuf *mh_nextpkt;
        caddr_t mh_data;
        u_int   mh_len;
        short   mh_type;
        u_short mh_flags;
#ifndef __LP64__
        u_int   mh_pad;
#endif
};

struct pkthdr {
	void			*ph_cookie;
	SLIST_HEAD(, m_tag)	 ph_tags;
	int64_t			 ph_timestamp;
	int			 len;
	u_int16_t		 ph_tagsset;
	u_int16_t		 ph_flowid;
	u_int16_t		 csum_flags;
	u_int16_t		 ether_vtag;
	u_int			 ph_rtableid;
	u_int			 ph_ifidx;
	u_int8_t		 ph_loopcnt;
	struct pkthdr_pf	 pf;
};

struct pkthdr_pf {
	struct pf_state_key *statekey;
	struct inpcb *inp;
	u_int32_t qid;
	u_int16_t tag;
	u_int8_t  flags;
	u_int8_t  routed;
	u_int8_t  prio;
	u_int8_t  pad[3];
};

struct mbuf_ext {
	caddr_t ext_buf;
	void	*ext_arg;
	u_int	ext_free_fn;
	u_int   ext_size;
	struct mbuf *ext_nextref;
	struct mbuf *ext_prevref;
};

struct mbuf {
        struct  m_hdr m_hdr;
        union {
                struct {
                        struct  pkthdr MH_pkthdr;
                        union {
                                struct  mbuf_ext MH_ext;
                                char    MH_databuf[MHLEN];
                        } MH_dat;
                } MH;
                char    M_databuf[MLEN];
        } M_dat;
};

#define m_next          m_hdr.mh_next
#define m_len           m_hdr.mh_len
#define m_data          m_hdr.mh_data
#define m_type          m_hdr.mh_type
#define m_flags         m_hdr.mh_flags
#define m_nextpkt       m_hdr.mh_nextpkt
#define m_pkthdr        M_dat.MH.MH_pkthdr
#define m_ext           M_dat.MH.MH_dat.MH_ext
#define m_pktdat        M_dat.MH.MH_dat.MH_databuf
#define m_dat           M_dat.M_databuf
.Ed
.Sh DESCRIPTION
The
.Nm mbuf
functions provide a way to manage the memory buffers used by the kernel's
networking subsystem.
Several functions and macros are used to allocate and deallocate mbufs,
but also to get, inject, remove, copy, modify, prepend or append data
inside these mbufs.
The size of an
.Nm mbuf
is defined by MSIZE.
.Pp
An
.Nm mbuf
structure is defined as an
.Fa m_hdr
structure followed by a
union.
The header contains the following elements:
.Bl -tag -width foobarmoocow
.It Fa mh_next
A pointer to the next mbuf in the mbuf chain.
.It Fa mh_nextpkt
A pointer to the next mbuf chain (i.e., packet) in the queue.
.It Fa mh_data
Indicates the address of the beginning of data in the mbuf.
.It Fa mh_len
Indicates the amount of data in the mbuf.
.It Fa mh_type
Indicates the type of data contained in the mbuf (see below).
.It Fa mh_flags
Flags (see below).
.El
.Pp
The
.Fa mh_type
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv MT_FREE
the mbuf should be on the free list.
.It Dv MT_DATA
the data in the mbuf was dynamically allocated.
.It Dv MT_HEADER
the data contains a packet header.
.It Dv MT_SONAME
the data is a socket name.
.It Dv MT_SOOPTS
the data are socket options.
.It Dv MT_FTABLE
the data is a fragment reassembly header.
.It Dv MT_CONTROL
the mbuf contains extra-data protocol message.
.It Dv MT_OOBDATA
the data consists of out-of-band data.
.El
.Pp
The
.Fa mh_flags
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv M_EXT
mbuf has associated external storage.
.It Dv M_PKTHDR
the mbuf is the first that forms a packet.
.It Dv M_EOR
end of record.
.It Dv M_EXTWR
external storage is writable.
.It Dv M_PROTO1
protocol-specific.
.It Dv M_VLANTAG
.Fa m_pkthdr.ether_vtag
variable is valid.
.It Dv M_LOOP
for mbuf statistics.
.It Dv M_ACAST
received as IPv6 anycast.
.It Dv M_BCAST
packet sent/received as link-level broadcast.
.It Dv M_MCAST
packet sent/received as link-level multicast.
.It Dv M_CONF
packet was encrypted (ESP-transport).
.It Dv M_AUTH
packet was authenticated (AH or ESP).
.It Dv M_TUNNEL
header was IP-in-IP encapsulated by tunnel mode IPsec.
.It Dv M_ZEROIZE
Zero the data part of the mbufs in the mbuf chain pointed to by
.Nm m_free .
.It Dv M_COMP
header was decompressed.
.It Dv M_LINK0
link layer specific flag.
.El
.Pp
An external cluster is used when the data to hold in the mbuf is
large.
The size of an external cluster is between MCLBYTES and MAXMCLBYTES.
A cluster should be used when the size of the data reach MINCLSIZE
(the minimum size to be held by an external cluster).
.Pp
The combination of the M_EXT and M_PKTHDR flags give four types of
mbuf.
When none of these constants are in use, the mbuf is a "normal"
one, where the data part of the mbuf has the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_dat
buffer holding the data (size MLEN).
.El
.Pp
When only M_PKTHDR is set, the data contained in the mbuf is a packet header.
The data itself is contained in the mbuf (just like the previous case),
but part of the mbuf is used to store a packet header.
The data part has then the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_pkthdr
packet header, containing the length of the data, a pointer to the
interface on which the data was received, checksum information
and list of
.Xr mbuf_tags 9 .
.It Fa m_pktdat
buffer holding the data (size MHLEN).
.El
.Pp
The
.Fa m_pkthdr.csum_flags
variable can take the following values:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv M_IPV4_CSUM_OUT
IPv4 checksum needed.
.It Dv M_TCP_CSUM_OUT
TCP checksum needed.
.It Dv M_UDP_CSUM_OUT
UDP checksum needed.
.It Dv M_ICMP_CSUM_OUT
ICMP/ICMPv6 checksum needed.
.It Dv M_IPV4_CSUM_IN_OK
IPv4 checksum verified.
.It Dv M_IPV4_CSUM_IN_BAD
IPv4 checksum bad.
.It Dv M_TCP_CSUM_IN_OK
TCP checksum verified.
.It Dv M_TCP_CSUM_IN_BAD
TCP checksum bad.
.It Dv M_UDP_CSUM_IN_OK
UDP checksum verified.
.It Dv M_UDP_CSUM_IN_BAD
UDP checksum bad.
.It Dv M_ICMP_CSUM_IN_OK
ICMP/ICMPv6 checksum verified.
.It Dv M_ICMP_CSUM_IN_BAD
ICMP/ICMPv6 checksum bad.
.El
.Pp
The
.Fa m_pkthdr.flowid
variable can contain a low resolution (15-bit) classification of a
flow or connection that the current mbuf is part of.
If the flowid is valid, it may be used as an alternative to hashing
the packets content to pick between different paths for the traffic.
The following masks can be ORed with the flowid:
.Pp
.Bl -tag -compact -offset indent -width XXXXXXXXXXXXXXXXXX
.It Dv M_FLOWID_VALID
The flow ID has been set.
.It Dv M_FLOWID_MASK
The flow ID.
.El
.Pp
When only M_EXT flag is set, an external storage buffer is being used to
hold the data, which is no longer stored in the mbuf.
The data part of the mbuf has now the following elements:
.Bl -tag -width foobarmoocow
.It Fa m_pkthdr
a packet header, just like the previous case, but it is empty.
No information is stored here.
.It Fa m_ext
a structure containing information about the external storage
buffer.
The information consists of the address of the external buffer,
a pointer to the function used to free the buffer, a pointer to the
arguments of the function, the size of the buffer, the type of the
buffer, and pointers to the previous and next mbufs using this
cluster.
.El
.Pp
When both the M_EXT and M_PKTHDR flags are set, an external storage buffer
is being used to store the data and this data contains a packet header.
The structure used is the same as the previous one except that the
.Fa m_pkthdr
element is not empty, it contains the same information as when
M_PKTHDR is used alone.
.Bl -tag -width Ds
.It Fn m_copym "struct mbuf *m" "int off" "int len" "int wait"
Copy an mbuf chain starting at
.Fa off
bytes from the beginning
and continuing for
.Fa len
bytes.
If
.Fa off
is zero and
.Fa m
has the M_PKTHDR flag set,
the header is copied.
If
.Fa len
is M_COPYALL
the whole mbuf is copied.
The
.Fa wait
parameter can be M_WAIT or
M_DONTWAIT.
It does not copy clusters, it just increases their reference count.
.It Fn m_free "struct mbuf *m"
Free the mbuf pointed to by
.Fa m .
A pointer to the successor of the mbuf,
if it exists, is returned by the function.
If
.Fa m
is a
.Dv NULL
pointer, no action occurs and
.Dv NULL
is returned.
.It Fn m_get "int how" "int type"
Return a pointer to an mbuf of the type specified.
If the
.Fa how
argument is
.Fa M_WAITOK ,
the function may call
.Xr tsleep 9
to await resources.
If
.Fa how
is
.Fa M_DONTWAIT
and resources are not available,
.Fn m_get
returns NULL.
.It Fn MGET "struct mbuf *m" "int how" "int type"
Return a pointer to an mbuf in
.Fa m
of the type specified.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_getclr "int how" "int type"
Return a pointer to an mbuf of the type specified, and clear the data
area of the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_resethdr "struct mbuf *m"
Deletes all
.Xr pf 4
data and all tags attached to a
.Fa mbuf .
.It Fn m_gethdr "int how" "int type"
Return a pointer to an mbuf of the type specified after initializing
it to contain a packet header.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MGETHDR "struct mbuf *m" "int how" "int type"
Return a pointer to an mbuf of the type specified after initializing
it to contain a packet header.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_prepend "struct mbuf *m" "int len" "int how"
Allocate a new mbuf and prepend it to the mbuf chain pointed to by
.Fa m .
If
.Fa m
points to an mbuf with a packet header, it is moved to the new
mbuf that has been prepended.
The return value is a pointer on the new mbuf chain.
If this function fails to allocate a new mbuf,
.Fa m
is freed.
See
.Fn m_get
for a description of
.Fa how .
.Pp
.Fn m_prepend
should never be called directly.
Use
.Fn M_PREPEND
instead.
.It Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
Prepend space of size
.Fa plen
to the mbuf pointed to by
.Fa m .
If a new mbuf must be allocated,
.Fa how
specifies whether to wait or not.
If this function fails to allocate a new mbuf,
.Fa m
is freed.
.It Fn m_pulldown "struct mbuf *m" "int off" "int len" "int *offp"
Ensure that the data in the mbuf chain starting at
.Fa off
and ending at
.Fa off+len
will be put in a continuous memory region.
If memory must be allocated, then it will fail if the
.Fa len
argument is greater than MAXMCLBYTES.
The pointer returned points to an mbuf in the chain and the new offset
for data in this mbuf is
.Fa *offp .
If this function fails,
.Fa m
is freed.
.It Fn m_pullup "struct mbuf *n" "int len"
Ensure that the data in the mbuf chain starting at the beginning of
the chain and ending at
.Fa len
will be put in continuous memory region.
If memory must be allocated, then it will fail if the
.Fa len
argument is greater than MAXMCLBYTES.
If this function fails,
.Fa n
is freed.
.It Fn m_split "struct mbuf *m0" "int len0" "int wait"
Split an mbuf chain in two pieces, returning a pointer to
the tail (which is made of the previous mbuf chain except the first
.Fa len0
bytes).
.It Fn m_makespace "struct mbuf *m0" "int skip" "int hlen" "int *off"
Make space for a continuous memory region of length
.Fa hlen
at
.Fa skip
bytes into the mbuf chain.
On success, the mbuf of the continuous memory is returned
together with an offset
.Fa off
into the mbuf.
On failure, NULL is returned and the mbuf chain may have been modified.
The caller is assumed to always free the chain.
.It Fn m_getptr "struct mbuf *m" "int loc" "int *off"
Returns a pointer to the mbuf containing the data located at
.Fa loc
bytes of the beginning.
The offset in the new mbuf is pointed to by
.Fa off .
.It Fn m_adj "struct mbuf *mp" "int req_len"
Trims
.Fa req_len
bytes of data from the mbuf chain pointed to by
.Fa mp .
If
.Fa req_len
is positive, the data will be trimmed from the head of the mbuf chain
and if it is negative, it will be trimmed from the tail of the mbuf
chain.
.It Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp" "int wait"
Copy data from a buffer pointed to by
.Fa cp
back into the mbuf chain pointed to by
.Fa m0
starting at
.Fa off
bytes from the beginning, extending the mbuf chain if
necessary, sleeping for mbufs if
.Fa wait
is
.Fa M_WAIT .
If
.Fa M_NOWAIT
is set and no mbufs are available,
.Fn m_copyback
returns
.Er ENOBUFS .
The mbuf chain must be initialized properly, including setting
.Fa m_len .
.It Fn m_defrag "struct mbuf *m" "int wait"
Defragment the data mbufs referenced by
.Fa m
by replacing the chain with a copy of their contents made into a
single mbuf or cluster.
.Fa wait
specifies whether it can wait or not for the replacement storage.
.Fn m_defrag
returns 0 on success or
.Er ENOBUFS
on failure.
The mbuf pointer
.Fa m
remains in existence and unchanged on failure.
.It Fn m_freem "struct mbuf *m"
Free the mbuf chain pointed to by
.Fa m .
A pointer to the next mbuf in the list linked by m_nextpkt,
if it exists, is returned by the function.
If
.Fa m
is a
.Dv NULL
pointer, no action occurs and
.Dv NULL
is returned.
.It Fn m_freemp "struct mbuf **mp"
Set the input mbuf pointer to
.Dv NULL
and call
.Fn m_freem .
.It Fn m_purge "struct mbuf *m"
Free the list of mbufs linked by m_nextpkt that is pointed to by
.Fa m .
Each mbuf is freed by a call to
.Fn m_freem .
If
.Fa m
is a
.Dv NULL
pointer, no action occurs.
.It Fn m_reclaim "void"
Ask protocols to free unused memory space.
.It Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
Copy data from the mbuf chain pointed to by
.Fa m
starting at
.Fa off
bytes from the beginning and continuing for
.Fa len
bytes into the buffer pointed to by
.Fa cp .
.It Fn m_cat "struct mbuf *m" "struct mbuf *n"
Concatenate the mbuf chain pointed to by
.Fa n
to the mbuf chain pointed to by
.Fa m .
The mbuf chains must be of the same type.
.It Fn m_devget "char *buf" "int totlen" "int off"
Copy
.Fa totlen
bytes of data from device local memory pointed to by
.Fa buf .
The data is copied into an mbuf chain at offset
.Fa off
and a pointer to the head of the chain is returned.
Returns NULL on failure.
.It Fn m_apply "struct mbuf *m" "int off" "int len" \
"int (*func)(caddr_t, caddr_t, unsigned int)" "caddr_t fstate"
Apply the function
.Fa func
to the data in the mbuf chain pointed to by
.Fa m
starting at
.Fa off
bytes from the beginning and continuing for
.Fa len
bytes.
.It Fn mtod "struct mbuf *m" "datatype"
Return a pointer to the data contained in the specified mbuf
.Fa m
cast to
.Fa datatype .
.It Fn MCLGET "struct mbuf *m" "int how"
Allocate and add an mbuf cluster to the mbuf pointed to by
.Fa m .
On success, the flag M_EXT is set in the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MCLGETI "struct mbuf *m" "int how" "struct ifnet *ifp" "int len"
If
.Fa m
is NULL, allocate it.
Then allocate and add an mbuf cluster of length
.Fa len
to the mbuf pointed to by
.Fa m .
Returns either the mbuf
.Fa m
that was passed in, or the newly allocated one which was allocated; in
either case the flag M_EXT is set in the mbuf.
See
.Fn m_get
for a description of
.Fa how .
.It Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int flags" \
"void (*free)(caddr_t, u_int, void *)" "void *arg"
Add pre-allocated storage to the mbuf pointed to by
.Fa m .
On success, the flag M_EXT is set in the mbuf, and M_EXTWR is specified in
.Fa flags .
.It Fn M_ALIGN "struct mbuf *m" "int len"
Set the
.Fa m_data
pointer of the newly allocated mbuf with
.Fn m_get
or
.Fn MGET
pointed to by
.Fa m
to an object of the specified size
.Fa len
at the end of the mbuf, longword aligned.
.It Fn MH_ALIGN "m" "len"
Same as
.Fn M_ALIGN
except it is for an mbuf allocated with
.Fn m_gethdr
or
.Fn MGETHDR .
.It Fn M_READONLY "struct mbuf *m"
Check if the data of the mbuf pointed to by
.Fa m
is read-only.
This is true for non-cluster external storage and for clusters that
are being referenced by more than one mbuf.
.It Fn M_LEADINGSPACE "struct mbuf *m"
Compute the amount of space available before the current start of data
in the mbuf pointed to by
.Fa m .
.It Fn M_TRAILINGSPACE "struct mbuf *m"
Compute the amount of space available after the end of data in the
mbuf pointed to by
.Fa m .
.It Fn m_dup_pkt "struct mbuf *m" "u_int adj" "int how"
Allocate a new mbuf and storage and copy the packet data and header,
including mbuf tags, from
.Fa m .
The data in the new mbuf will be offset from the start of the storage by
.Fa adj
bytes.
See
.Fn m_get
for a description of
.Fa how .
.It Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from" "int how"
Copy mbuf packet header, including mbuf tags, from
.Fa from
to
.Fa to .
See
.Fn m_get
for a description of
.Fa how .
.El
.Sh CODE REFERENCES
The mbuf management functions are implemented in the files
.Pa sys/kern/uipc_mbuf.c
and
.Pa sys/kern/uipc_mbuf2.c .
The function prototypes and the macros are located in
.Pa sys/sys/mbuf.h .
.Sh SEE ALSO
.Xr netstat 1 ,
.Xr mbuf_tags 9 ,
.Xr mutex 9 ,
.Xr spl 9
.Rs
.%A Jun-Ichiro Hagino
.%T "Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)"
.%B "Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference"
.%D June 2000
.Re
@


1.108
log
@When dealing with mbuf pointers passed down as function parameters,
bugs could easily result in use-after-free or double free.  Introduce
m_freemp() which automatically resets the pointer before freeing
it.  So we have less dangling pointers in the kernel.
OK krw@@ mpi@@ claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.107 2017/05/19 05:59:27 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: May 19 2017 $
d108 1
a108 1
.Fn m_freem "struct mbuf **mp"
@


1.107
log
@header updates from kevlo;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.106 2017/03/29 23:05:05 claudio Exp $
d28 1
a28 1
.Dd $Mdocdate: May 18 2017 $
d51 1
d107 2
d643 5
@


1.106
log
@m_devget() lost its ipf pointer argument, update man page.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.105 2016/10/17 02:53:47 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: October 17 2016 $
d157 3
d165 1
d190 2
a191 2
	void    (*ext_free)(caddr_t, u_int, void *);
	void    *ext_arg;
@


1.105
log
@"send/received" -> "sent/received"
ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.104 2016/09/15 00:00:40 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: September 15 2016 $
d115 1
a115 1
.Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp"
d663 1
a663 1
.It Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp"
@


1.104
log
@remove m_copym2 as its use has been replaced by m_dup_pkt

ok millert@@ mpi@@ henning@@ claudio@@ markus@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.103 2016/09/13 19:56:55 markus Exp $
d28 1
a28 1
.Dd $Mdocdate: September 13 2016 $
d298 1
a298 1
packet send/received as link-level broadcast.
d300 1
a300 1
packet send/received as link-level multicast.
@


1.103
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.102 2016/09/04 02:26:44 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: September 4 2016 $
a31 1
.Nm m_copym2 ,
a71 2
.Fn m_copym2 "struct mbuf *m" "int off" "int len" "int wait"
.Ft struct mbuf *
a436 6
.It Fn m_copym2 "struct mbuf *m" "int off" "int len" "int wait"
The same as
.Fn m_copym
except that it copies cluster mbufs, whereas
.Fn m_copym
just increases the reference count of the clusters.
@


1.102
log
@Sync struct pkthdr with sys/mbuf.h
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.101 2016/09/04 02:07:48 lteo Exp $
d46 1
a46 1
.Nm m_inject ,
d98 1
a98 1
.Fn m_inject "struct mbuf *m0" "int len0" "int siz" "int wait"
d571 12
a582 12
.It Fn m_inject "struct mbuf *m0" "int len0" "int siz" "int wait"
Inject a new mbuf chain of length
.Fa siz
into the mbuf chain pointed to by
.Fa m0
at position
.Fa len0 .
If there is enough space for an object of size
.Fa siz
in the appropriate location, no memory will be allocated.
On failure, the function returns NULL (the mbuf is left untouched) and
on success, a pointer to the first injected mbuf is returned.
@


1.101
log
@Fix incorrect formatting and add the missing argument name for m_resethdr().

ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.100 2016/07/19 08:13:46 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: July 19 2016 $
d172 1
@


1.100
log
@Use a flag to indicate that a packet has been received on an IPv6
anycast address.

This will allow us to split ip6_input() in two parts using a queue
in the middle.

ok jca@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.99 2016/04/08 10:01:12 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: April 8 2016 $
d84 1
a84 1
.Fn m_resethdr struct mbuf *
d488 1
a488 1
.It Fn m_resethdr "struct mbuf *"
@


1.99
log
@bare .Nm gets turned into m_copym2, which is wrong when describing mbufs.

use explicit .Nm mbuf where appropriate.

discussed with jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.98 2016/04/08 03:23:13 dlg Exp $
d297 2
a298 4
.It Dv M_FILDROP
dropped by
.Xr bpf 4
filter.
@


1.98
log
@document m_purge.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.97 2016/04/08 03:19:33 dlg Exp $
d222 1
a222 1
.Nm
d229 1
a229 1
.Nm
d233 1
a233 1
.Nm
@


1.97
log
@m_freem returns an mbuf like m_free now

this steals the m_free words to describe what m_freem does now.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.96 2016/04/08 03:04:15 dlg Exp $
d52 1
d110 2
d646 10
@


1.96
log
@document m_dup_pkt()
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.95 2015/11/23 17:53:57 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: November 23 2015 $
d106 1
a106 1
.Ft void
d634 2
d640 3
a642 1
pointer, no action occurs.
@


1.95
log
@add missing NAME entries;
feedback/ok schwarze
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.94 2015/11/13 10:12:39 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: November 13 2015 $
d66 1
d129 2
d744 11
@


1.94
log
@Use ph_ prefix for tag-related fields.

ok dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.93 2015/11/12 10:07:14 mpi Exp $
d28 2
a29 2
.Dd $Mdocdate: November 12 2015 $
.Dt MBUF 9
d32 35
a66 1
.Nm mbuf
@


1.93
log
@Prefix flowid with ph_ and print it in m_print().

ok dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.92 2015/10/30 21:21:19 benno Exp $
d28 1
a28 1
.Dd $Mdocdate: October 30 2015 $
d124 1
a124 1
	SLIST_HEAD(packet_tags, m_tag) tags;
d126 1
a126 1
	u_int16_t		 tagsset;
@


1.92
log
@document m_resethdr
ok and feedback mikeb@@, reminded by jmc@@ about MLINKS
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.91 2015/10/08 14:09:34 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: October 8 2015 $
d127 1
a127 1
	u_int16_t		 flowid;
@


1.91
log
@tweak previous;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.90 2015/10/08 11:36:15 dlg Exp $
d47 2
d450 5
@


1.90
log
@steal some padding in mbuf pkthdrs to store a flow id.

the flowid roughly identifies a flow or connection that the mbuf
is a part of, and can be used instead of hashing contents of the
packet (like src+dst mac and ip addresses) to decide which path a
packet should take.

ok mpi@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.89 2015/09/21 11:30:50 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: September 21 2015 $
d340 1
a340 1
variable can contain a low resolution (15 bit) classification of a
d348 1
a348 1
The flow id has been set.
d350 1
a350 1
The flow id.
@


1.89
log
@Document that m_free(9) and m_freem(9) now accept NULL.

From Michael McConville, ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.88 2015/07/08 07:21:49 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: July 8 2015 $
d125 1
a125 1
	u_int16_t		 pad;
d336 15
@


1.88
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.87 2015/06/17 06:24:46 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: June 17 2015 $
d395 7
d575 5
@


1.87
log
@Move mbuf_list and mbuf_queue documentation in their own manual.

ok jmc@@, deraadt@@, dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.86 2015/06/16 11:17:02 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: June 16 2015 $
a41 1
.Fn MFREE "struct mbuf *m" "struct mbuf *n"
a394 9
.It Fn MFREE "struct mbuf *m" "struct mbuf *n"
Free the mbuf pointed to by
.Fa m
and use
.Fa n
to point to the next mbuf in
the chain if it exists.
See
.Fn m_free .
@


1.86
log
@Sync with recent changes.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.85 2015/02/19 05:53:46 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: February 19 2015 $
a32 19
.\" .Nm ml_init ,
.\" .Nm ml_enqueue ,
.\" .Nm ml_dequeue ,
.\" .Nm ml_dechain ,
.\" .Nm ml_len ,
.\" .Nm ml_empty ,
.\" .Nm MBUF_LIST_INITIALIZER ,
.\" .Nm MBUF_LIST_FOREACH ,
.\" .Nm mq_init ,
.\" .Nm mq_enqueue ,
.\" .Nm mq_dequeue ,
.\" .Nm mq_enlist ,
.\" .Nm mq_delist ,
.\" .Nm mq_dechain ,
.\" .Nm mq_len ,
.\" .Nm mq_empty ,
.\" .Nm mq_drops ,
.\" .Nm mq_set_maxlen ,
.\" .Nm MBUF_QUEUE_INITIALIZER
a94 48
.Ft void
.Fn "ml_init" "struct mbuf_list *ml"
.Ft void
.Fn "ml_enqueue" "struct mbuf_list *ml" "struct mbuf *m"
.Ft struct mbuf *
.Fn "ml_dequeue" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fn "ml_dechain" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fo ml_filter
.Fa "struct mbuf_list *ml"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
.Ft unsigned int
.Fn "ml_len" "struct mbuf_list *ml"
.Ft int
.Fn "ml_empty" "struct mbuf_list *ml"
.Ft struct mbuf_list
.Fn "MBUF_LIST_INITIALIZER"
.Fn "MBUF_LIST_FOREACH" "struct mbuf_list *ml" "VARNAME"
.Fn "mq_init" "struct mbuf_queue *mq" "unsigned int maxlen" "int ipl"
.Ft int
.Fn "mq_enqueue" "struct mbuf_queue *mq" "struct mbuf *m"
.Ft struct mbuf *
.Fn "mq_dequeue" "struct mbuf_queue *mq"
.Ft int
.Fn "mq_enlist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
.Ft void
.Fn "mq_delist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
.Ft struct mbuf *
.Fn "mq_dechain" "struct mbuf_queue *mq"
.Ft struct mbuf *
.Fo mq_filter
.Fa "struct mbuf_queue *mq"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
.Ft unsigned int
.Fn "mq_len" "struct mbuf_queue *mq"
.Ft int
.Fn "mq_empty" "struct mbuf_queue *mq"
.Ft unsigned int
.Fn "mq_drops" "struct mbuf_queue *mq"
.Ft void
.Fn "mq_set_maxlen" "struct mbuf_queue *mq" "unsigned int"
.Ft struct mbuf_queue
.Fn "MBUF_QUEUE_INITIALIZER" "unsigned int maxlen" "int ipl"
a692 245
.Pp
The mbuf list and mbuf queue API provides implementions of data
structures and operations for managing lists of mbufs or for queueing
mbufs and lists of mbufs between contexts.
.Pp
mbuf_list structures support the following functionality:
.Pp
.Bl -enum -compact -offset indent
.It
Insertion of a new mbuf at the end of the list.
.It
Removal of an mbuf from the head of the list.
.It
Removal of the entire chain of mbufs on the list.
.El
.Bl -tag -width Ds
.It Fn "ml_init" "struct mbuf_list *ml"
Initialise the
.Fa ml
mbuf_list structure.
.It Fn "MBUF_LIST_INITIALIZER"
An initialiser for an mbuf_list structure declaration.
.It Fn "ml_enqueue" "struct mbuf_list *ml" "struct mbuf *m"
Enqueue mbuf
.Fa m
on the end of the
.Fa ml
mbuf list.
.It Fn "ml_dequeue" "struct mbuf_list *ml"
Dequeue an mbuf from the front of the
.Fa ml
mbuf list.
.It Fn "ml_dechain" "struct mbuf_list *ml"
Dequeues all mbufs from the
.Fa ml
mbuf list.
.It Fo ml_filter
.Fa "struct mbuf_list *ml"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
Iterates over the mbufs on the
.Fa ml
mbuf list, passing each of them to the
.Fa filter
function.
If the
.Fa filter
returns non-zero, the packet is removed from the
.Fa ml
mbuf list to be returned as part of an mbuf chain by
.Fn ml_filter .
.Fa context
is passed as the first argument to each call of
.Fa filter .
.It Fn "ml_len" "struct mbuf_list *ml"
Return the number of mbufs on the
.Fa ml
mbuf list.
.It Fn "ml_empty" "struct mbuf_list *ml"
Return if the
.Fa ml
mbuf list is empty.
.It Fn "MBUF_LIST_FOREACH" "struct mbuf_list *ml" "VARNAME"
A convenience macro that can be used to iterate over the contents of the
.Fa ml
mbuf list.
.Fa VARNAME
identifies the name (not the address) of an mbuf pointer that will
be set to each entry on the list.
Note that it is unsafe to modify the list while iterating over it.
.El
.Pp
mbuf_queue data structures provide a superset of the functionality
available in mbuf_lists, and protect themselves internally with a
.Xr mutex 9 ,
making them useful for moving mbufs between contexts or subsystems.
Additionally, mbuf_queues provide a limit on the number of mbufs that
may be queued.
The additional functionality mbuf_queues provides is:
.Pp
.Bl -enum -compact -offset indent
.It
Insertion of the mbufs in an mbuf_list at the end of the queue.
.It
Removal of all the mbufs on the queue as an mbuf_list.
.El
.Bl -tag -width Ds
.It Fn "mq_init" "struct mbuf_queue *mq" "unsigned int maxlen" "int ipl"
Initialises the mbuf queue structure
.Fa mq .
The maximum number of mbufs that can be queued is specified with
.Fa maxlen .
The highest interrupt priority level the queue will be operated at is
specified via
.Fa ipl .
.It Fn "MBUF_QUEUE_INITIALIZER" "unsigned int maxlen" "int ipl"
Initialises an mbuf queue structure declaration.
The maximum number of mbufs that can be queued is specified with
.Fa maxlen .
The highest interrupt priority level the queue will be operated at is
specified via
.Fa ipl .
.It Fn "mq_enqueue" "struct mbuf_queue *mq" "struct mbuf *m"
Enqueue mbuf
.Fa m
on the end of the
.Fa mq
mbuf queue.
.It Fn "mq_dequeue" "struct mbuf_queue *mq"
Dequeue an mbuf from the front of the
.Fa mq
mbuf queue.
.It Fn "mq_enlist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
Enqueue all the mbufs on the
.Fa ml
mbuf list on to the end of the
.Fa mq
mbuf queue.
Note, the number of mbufs placed on the queue may exceed its maximum length.
.It Fn "mq_delist" "struct mbuf_queue *mq" "struct mbuf_list *ml"
Dequeue all the mbufs on the
.Fa mq
mbuf queue on to the
.Fa ml
mbuf list.
.It Fn "mq_dechain" "struct mbuf_queue *mq"
Dequeue all mbufs from the
.Fa mq
mbuf queue.
.It Fo mq_filter
.Fa "struct mbuf_queue *mq"
.Fa "int (*filter)(void *, struct mbuf *)"
.Fa "void *context"
.Fc
Iterates over the mbufs on the
.Fa mq
mbuf queue, passing each of them to the
.Fa filter
function.
If the
.Fa filter
returns non-zero, the packet is removed from the
.Fa mq
mbuf queue to be returned as part of an mbuf chain by
.Fn mq_filter .
.Fa context
is passed as the first argument to each call of
.Fa filter .
.It Fn "mq_len" "struct mbuf_queue *mq"
Return the number of mbufs on the
.Fa ml
mbuf queue.
.It Fn "mq_empty" "struct mbuf_queue *mq"
Return if the
.Fa mq
mbuf queue is empty.
.It Fn "mq_drops" "struct mbuf_queue *mq"
Return how many mbufs were dropped and freed by
.Xr m_freem 9
if the
.Fa mq
mbuf queue was too full.
.It Fn "mq_set_maxlen" "struct mbuf_queue *mq" "unsigned int"
Alter the maximum number of mbufs that can be queued on the
.Fa mq
mbuf queue.
Note,
.Fn mq_set_maxlen
will only set a new limit, it will not free any excess mbufs that may
already exist on the queue.
.El
.Sh CONTEXT
.Fn ml_init ,
.Fn ml_enqueue ,
.Fn ml_dequeue ,
.Fn ml_dechain ,
.Fn ml_len ,
.Fn ml_empty ,
.Fn MBUF_LIST_INITIALIZER ,
.Fn MBUF_LIST_FOREACH ,
.Fn mq_init ,
.Fn mq_enqueue ,
.Fn mq_dequeue ,
.Fn mq_enlist ,
.Fn mq_delist ,
.Fn mq_dechain ,
.Fn mq_len ,
.Fn mq_empty ,
.Fn mq_drops ,
.Fn mq_set_maxlen ,
.Fn MBUF_QUEUE_INITIALIZER
can be called during autoconf, from process context, or from interrupt context.
.Sh RETURN VALUES
.Fn ml_dequeue
and
.Fn mq_dequeue
return the mbuf that was at the head of their respective list or queue.
If the list or queue was empty,
.Dv NULL
is returned.
.Pp
.Fn ml_dechain
and
.Fn mq_dechain
return all the mbufs that were on the respective list or queues via
a pointer to an mbuf with the chain accessible via m_nextpkt members.
If the list or queue was empty,
.Dv NULL
is returned.
.Pp
.Fn ml_filter
and
.Fn mq_filter
return the mbufs that were successfully matched by the filter
function on the respective list or queue via a pointer to a chain
of mbufs.
If no packets matched the filter,
.Dv NULL
is returned.
.Pp
.Fn ml_len
and
.Fn mq_len
return the number of mbufs on the list or queue respectively.
.Pp
.Fn ml_empty
and
.Fn mq_empty
return a non-zero value if the list or queue is empty,
otherwise 0.
.Pp
.Fn mq_enqueue
returns 0 if the mbuf was successfully queued, or non-zero if the
mbuf was freed because it would cause the queue to exceed its maximum
length.
.Pp
.Fn mq_enlist
returns the number of mbufs that were dropped from the list if the
length of the queue exceeded its maximum length.
.Pp
.Fn mq_drops
returns the number of mbufs that were freed during
.Fn mq_enqueue
operations that would have caused the queue to exceed its maximum length.
@


1.85
log
@remove errant reference to mq_enqueue in the mq_enlist description.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.84 2015/02/16 16:38:54 naddy Exp $
d28 1
a28 1
.Dd $Mdocdate: February 16 2015 $
d189 1
a189 1
	struct  ifnet *rcvif;
d191 8
a198 8
	int     len;
	u_int16_t tagsset;
	u_int16_t pad;
	u_int16_t csum_flags;
	u_int16_t ether_vtag;
	u_int	 ph_rtableid;
	void	*ph_cookie;
	struct	pkthdr_pf pf;
@


1.84
log
@Replace \*(Lt \*(Le \*(Gt \*(Ge with literal < <= > >= respectively,
except for instances where \*(Le and \*(Ge are clearly understood as
mathematical symbols.  Discussed with schwarze@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.83 2015/02/10 04:08:00 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: February 10 2015 $
a879 1
.Fn mq_enqueue .
@


1.83
log
@Sync and sort the M_* mbuf flags to match the way they are listed in
<sys/mbuf.h>.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.82 2015/02/10 03:50:30 lteo Exp $
d177 1
a177 1
#define mtod(m,t)       ((t)((m)-\*(Gtm_data))
@


1.82
log
@Zap m_act here too.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.81 2015/02/07 02:53:04 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: February 7 2015 $
d314 2
a315 2
.It Dv M_CLUSTER
the external storage is a cluster.
d318 9
d335 2
d340 2
a341 2
.It Dv M_TUNNEL
header was IP-in-IP encapsulated by tunnel mode IPsec.
a343 9
.It Dv M_LOOP
for mbuf statistics.
.It Dv M_FILDROP
dropped by
.Xr bpf 4
filter.
.It Dv M_VLANTAG
.Fa m_pkthdr.ether_vtag
variable is valid.
@


1.81
log
@mq_enlist can drop mbufs now.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.80 2015/02/07 02:30:28 dlg Exp $
a240 1
#define m_act           m_nextpkt
@


1.80
log
@try and document ml_filter and mq_filter.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.79 2015/02/01 03:32:32 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: February 1 2015 $
d878 1
a878 2
Note, if the number of mbufs placed on the queue exceeds its maximum length,
the extra mbufs are NOT freed as they are with
d998 2
a999 2
returns 0 if the new length of the queue after adding the list is less than
the queue's maximum length, otherwise non-zero.
@


1.79
log
@Sync struct pkthdr_pf and struct mbuf_ext with their actual definitions
in sys/mbuf.h.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.78 2015/01/31 03:08:33 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: January 31 2015 $
d122 6
d146 6
d795 19
d891 19
d969 10
@


1.78
log
@Add missing period.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.77 2015/01/31 03:06:25 lteo Exp $
d190 2
a191 1
	void	 *statekey;
a204 3
	int     ext_type;
	u_short ext_ifidx;
	int     ext_backend;
@


1.77
log
@Document MSIZE, MCLSHIFT, MCLBYTES, MCLOFSET, and MAXMCLBYTES which have
been moved from sys/param.h to sys/mbuf.h (MAXMCLBYTES was moved two
years ago; the rest were done recently).  Remove references to
sys/param.h accordingly.

ok deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.76 2014/08/18 04:06:16 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: August 18 2014 $
d401 1
a401 1
No information is stored here
@


1.76
log
@introduce mbuf list and queue apis. both manage fifo lists of mbufs
and a count of the mbufs.

struct mbuf_list and the ml_foo() apis can be used to build lists of
mbufs where you dont need locking (eg, on the stack).

struct mbuf_queue and mq_foo() wrap mbuf_lists with a mutex, and
limits the number of mbufs that can be queued. they can be useful
for moving mbufs between contexts/subsystems.

with help from jmc@@ for the manpage bits
mpi@@ is keen
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.75 2014/07/13 10:59:49 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: July 13 2014 $
d151 2
d156 1
d160 5
d247 1
a247 2
is MSIZE
.Pq defined in In sys/param.h .
d337 1
a337 2
The size of an external cluster is between MCLBYTES and MAXMCLBYTES
.Pq also defined in In sys/param.h .
@


1.75
log
@tweak previous; ok dlg
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.74 2014/07/13 09:52:48 dlg Exp $
d33 19
d114 36
d743 199
d951 3
a953 1
.Xr mbuf_tags 9
@


1.74
log
@treat external storage allocated by the mbuf layer the same as
external storage attached to an mbuf anywhere else. this means it
uses MEXTADD to wire it up to the mbuf, and it relies on the ext_free
and ext_arg bits in the header to call the right free function
against the right pool.

M_CLUSTER gets renamed to M_EXTWR. the type field in MEXTADD gets
reused as a flags field so anything attaching storage to an mbuf
can say if it is writable or not.

ok claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.73 2014/07/13 05:23:24 dlg Exp $
d643 2
a644 2
On success, the flag M_EXT is set in the mbuf, and M_EXTWR if specified in
.Fa flags ..
@


1.73
log
@we dont do per interface accounting in the mbuf layer anymore
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.72 2014/04/22 14:41:03 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: April 22 2014 $
d86 1
a86 1
.Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int type" \
d639 1
a639 1
.It Fn MEXTADD "struct mbuf *m" "caddr_t buf" "u_int size" "int type" \
d643 2
a644 1
On success, the flag M_EXT is set in the mbuf.
@


1.72
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.71 2014/04/14 09:06:41 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: April 14 2014 $
a630 4
If
.Fa ifp
is passed in, then per-interface accounting for the mbuf will occur,
and thus mbuf allocation can fail when limits are reached.
@


1.71
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.70 2014/03/27 10:30:58 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: March 27 2014 $
a126 1
	void	 *hdr;
@


1.70
log
@Store an ifp index instead of a pointer in the "struct mbuf_ext".

This is part of the plan to remove the ifp pointer from the packet
header that will allow us to stop garbage collecting mbuf(9)s when
an ifp is detached/destroyed.

ok mikeb@@, lteo@@, benno@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.69 2014/03/19 10:09:19 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: March 19 2014 $
d121 1
a121 1
	u_int	rdomain;
@


1.69
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.68 2014/01/21 03:15:46 schwarze Exp $
d28 1
a28 1
.Dd $Mdocdate: January 21 2014 $
d143 1
a143 1
	struct ifnet* ext_ifp;
@


1.68
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.67 2013/11/27 13:28:37 mpi Exp $
d28 1
a28 1
.Dd $Mdocdate: November 27 2013 $
d122 1
@


1.67
log
@M_AUTH_AH got removed in 2012, no reason to document it.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.66 2013/10/25 18:42:36 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: October 25 2013 $
d185 1
a185 1
.Pq defined in Aq Pa sys/param.h .
d276 1
a276 1
.Pq also defined in Aq Pa sys/param.h .
@


1.66
log
@Now that the M_ICMP_CSUM_* flags are actually used in the kernel by PF,
document them in the mbuf(9) man page.

OK henning@@ jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.65 2013/08/21 05:21:42 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: August 21 2013 $
a254 2
.It Dv M_AUTH_AH
header was authenticated (AH).
@


1.65
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.64 2013/06/11 01:01:15 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: June 11 2013 $
d316 2
d330 4
@


1.64
log
@return ENOBUFS on failure from m_defrag and m_tag_copy_chain.

m_foo functions that return errors are now consistent as far as i can tell.

ok bluhm@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.63 2013/06/05 11:30:23 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: June 5 2013 $
d79 1
a79 2
.Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp" \
"void (*func)(const void *, void *, size_t)"
d586 1
a586 2
.It Fn m_devget "char *buf" "int totlen" "int off" "struct ifnet *ifp" \
"void (*func)(const void *, void *, size_t)"
d590 1
a590 8
.Fa buf
using the function
.Fa func
or
.Fn bcopy
if
.Fa func
is NULL.
@


1.63
log
@\-1;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.62 2013/06/05 03:28:43 dlg Exp $
d561 3
a563 1
returns 0 on success or \-1 on failure.
@


1.62
log
@m_defrag(9) wasnt documented.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.61 2013/06/04 19:27:09 schwarze Exp $
d28 1
a28 1
.Dd $Mdocdate: June 4 2013 $
d561 1
a561 1
returns 0 on success or -1 on failure.
@


1.61
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.60 2013/03/23 18:33:43 lteo Exp $
d28 1
a28 1
.Dd $Mdocdate: March 23 2013 $
d68 2
d553 12
@


1.60
log
@Sync checksum flags with mbuf.h by renaming M_{TCP,UDP}V4_CSUM_OUT to
M_{TCP,UDP}_CSUM_OUT.  Also rename m_pkthdr.csum to m_pkthdr.csum_flags.

Remove "/IPv4" from the descriptions of the M_{TCP,UDP}_CSUM_IN_* flags
since they are also used to calculate TCP or UDP checksums over IPv6,
such as on newer bge(4) chips (pointed out by naddy@@).

feedback/ok naddy, ok haesbaert jmc
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.59 2013/01/03 07:53:22 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: January 3 2013 $
d35 1
a35 1
.Fd #include <sys/mbuf.h>
@


1.59
log
@update from Ryan Ozmun;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.58 2012/11/17 10:55:21 henning Exp $
d28 1
a28 1
.Dd $Mdocdate: January 2 2013 $
d305 1
a305 1
.Fa m_pkthdr.csum
d311 1
a311 1
.It Dv M_TCPV4_CSUM_OUT
d313 1
a313 1
.It Dv M_UDPV4_CSUM_OUT
d320 1
a320 1
TCP/IPv4 checksum verified.
d322 1
a322 1
TCP/IPv4 checksum bad.
d324 1
a324 1
UDP/IPv4 checksum verified.
d326 1
a326 1
UDP/IPv4 checksum bad.
@


1.58
log
@sync m_copydata prototype with reality, ok jsg phessler
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.56 2011/12/02 10:57:16 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: September 27 2012 $
d113 8
a120 5
        struct  ifnet *rcvif;
        SLIST_HEAD(packet_tags, m_tag) tags;
        int     len;
        u_int16_t csum_flags;
        u_int16_t ether_vtag;
d126 1
a126 1
	u_int	  rtableid;
d131 2
d135 10
a144 8
struct m_ext {
        caddr_t ext_buf;
        void    (*ext_free)(caddr_t, u_int, void *);
        void    *ext_arg;
        u_int   ext_size;
        int     ext_type;
        struct mbuf *ext_nextref;
        struct mbuf *ext_prevref;
d153 1
a153 1
                                struct  m_ext MH_ext;
@


1.57
log
@replace m_zero(9) with M_ZEROIZE; original diff from markus
ok mikeb markus
@
text
@d28 1
a28 1
.Dd $Mdocdate: December 2 2011 $
d67 1
a67 1
.Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp" "int wait"
@


1.56
log
@it's MAXMCLBYTES, not MAXCLBYTES.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.55 2011/11/30 10:26:56 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: November 30 2011 $
a78 2
.Ft void
.Fn m_zero "struct mbuf *m"
d249 3
a580 3
.It Fn m_zero "struct mbuf *m"
Zeroize the data part of the mbufs in the mbuf chain pointed to by
.Fa m .
@


1.55
log
@this diff introduces the MAXMCLBYTES macro to describe the largest
cluster the generic network stack will be able to give you.

it also recognises that external storage on an mbuf may be bigger than
MCLBYTES. its only when m_pullup or m_pulldown need to allocate
another cluster that they now check the len argument, and now they
do it against MAXMCLBYTES.

this is required for me to do pfsync on jumbo frames as the m_pulldown
for the subregions fail beyond MCLBYTES into the packet.

ok deraadt@@ mikeb@@ henning@@ blambert@@
manpage changes ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.54 2011/07/29 12:59:28 blambert Exp $
d28 1
a28 1
.Dd $Mdocdate: July 29 2011 $
d472 1
a472 1
argument is greater than MAXCLBYTES.
d486 1
a486 1
argument is greater than MAXCLBYTES.
@


1.54
log
@Remove references to a function that no longer exists, reminded by claudio@@

ok jmc@@, claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.53 2011/04/05 11:59:11 blambert Exp $
d28 1
a28 1
.Dd $Mdocdate: April 5 2011 $
d268 1
a268 1
The size of an external cluster is MCLBYTES
d470 1
d472 1
a472 1
must be smaller than or equal to MCLBYTES.
d484 1
a484 1
The
d486 1
a486 1
argument must be smaller than or equal to MCLBYTES.
@


1.53
log
@Arguments to m_dup_pkthdr() have changed; sync man page with reality.

ok claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.52 2011/04/04 20:31:47 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: April 4 2011 $
a58 2
.Fn m_pullup2 "struct mbuf *n" "int len"
.Ft struct mbuf *
d471 1
a471 1
must be smaller or equal than MCLBYTES.
a482 5
To avoid being called again,
.Fn m_pullup
will attempt to copy
.Fa "max_protohdr - len"
bytes into the first mbuf.
d485 1
a485 1
argument must be smaller or equal than MHLEN.
a488 16
.It Fn m_pullup2 "struct mbuf *n" "int len"
Just like
.Fn m_pullup ,
ensure that the data starting at the beginning of the mbuf chain and
ending at
.Fa len
will be put in continuous memory region.
The
.Fa len
argument can be up to MCLBYTES.
.Fn m_pullup2
will simply call
.Fn m_pullup
if
.Fa len
is smaller or equal to MHLEN.
@


1.52
log
@Nd strings do not start uppercase;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.51 2011/04/03 12:33:47 blambert Exp $
d28 1
a28 1
.Dd $Mdocdate: April 3 2011 $
d97 1
a97 1
.Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from"
d687 1
a687 1
.It Fn m_dup_pkthdr "struct mbuf *to" "struct mbuf *from"
d692 4
@


1.51
log
@fix typo; found by and ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.50 2011/04/03 09:49:24 blambert Exp $
d33 1
a33 1
.Nd Kernel memory management for networking protocols
@


1.50
log
@Document m_dup_pkthdr function.

ok claudio@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.49 2011/01/30 16:51:38 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: January 30 2011 $
d97 1
a97 1
.Fn m_dup_pkthder "struct mbuf *to" "struct mbuf *from"
@


1.49
log
@zap unneeded Pp;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.48 2011/01/30 15:20:13 stsp Exp $
d96 2
d687 5
@


1.48
log
@missing space: out-of-banddata -> out-of-band data
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.47 2010/07/07 09:16:36 blambert Exp $
d28 1
a28 1
.Dd $Mdocdate: July 7 2010 $
a95 1
.Pp
@


1.47
log
@update manpage to reflect recent changes to m_copyback

nag and ok sthen@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.46 2010/05/29 16:43:54 damien Exp $
d28 1
a28 1
.Dd $Mdocdate: May 29 2010 $
d224 1
a224 1
the data consists of out-of-banddata.
@


1.46
log
@restore a line that was removed by blambert@@ along with MCHTYPE.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.45 2010/01/10 10:53:33 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: January 10 2010 $
d68 2
a69 2
.Ft void
.Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp"
d544 1
a544 1
.It Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp"
d552 10
a561 1
necessary.
@


1.45
log
@remove references to docs we no longer install;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.44 2009/08/09 11:40:58 deraadt Exp $
d28 1
a28 1
.Dd $Mdocdate: August 9 2009 $
d676 1
@


1.44
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.43 2009/03/02 23:37:08 blambert Exp $
d28 1
a28 1
.Dd $Mdocdate: March 2 2009 $
a686 3
.Pp
"Networking Implementation Notes",
.Pa /usr/share/doc/smm/18.net .
@


1.43
log
@Remove MEXTMALLOC and MCHTYPE from mbuf.9, as they have not existed
for some time.

ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.42 2009/01/28 23:08:58 claudio Exp $
d28 1
a28 1
.Dd $Mdocdate: January 28 2009 $
d87 1
@


1.42
log
@Correctly document MINCLSIZE which changed some time ago.
OK mbalmer@@ a long time ago
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.41 2009/01/26 11:51:14 bluhm Exp $
d28 1
a28 1
.Dd $Mdocdate: January 26 2009 $
a85 1
.Fn MEXTMALLOC "struct mbuf *m" "int size" "int how"
a94 1
.Fn MCHTYPE "struct mbuf *m" "int type"
a637 10
.It Fn MEXTMALLOC "struct mbuf *m" "int size" "int how"
Allocate external storage of size
.Fa size
and add it to the mbuf pointed to by
.Fa m .
On success, the flag M_EXT is set in the mbuf.
See
.Fn m_get
for a description of
.Fa how .
a674 6
.Fa m .
.It Fn MCHTYPE "struct mbuf *m" "int type"
Change the type of the mbuf pointed to by
.Fa m
to
.Fa type .
@


1.41
log
@Fix whitespace typo in mbuf man page.

ok grunk@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.40 2008/12/14 23:39:05 dlg Exp $
d28 1
a28 1
.Dd $Mdocdate: December 14 2008 $
d102 1
a102 1
#define MINCLSIZE       (MHLEN + 1)
@


1.40
log
@MCLGETI takes an mbuf *, not an mbuf.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.39 2008/11/29 15:44:37 deraadt Exp $
d28 1
a28 1
.Dd $Mdocdate: November 29 2008 $
d116 1
a116 1
struct  pkthdr {
@


1.39
log
@extra word deleted; spotted by jmc
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.38 2008/11/29 02:39:30 deraadt Exp $
d88 1
a88 2
.Ft struct mbuf *
.Fn MCLGETI "struct mbuf" "int how" "struct ifnet *ifp" "int len"
@


1.38
log
@document MCLGETI
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.37 2008/11/03 22:16:51 claudio Exp $
d28 1
a28 1
.Dd $Mdocdate: November 3 2008 $
d632 1
a632 1
and thus mbuf allocation can fail in when limits are reached.
@


1.37
log
@Forgot this docu bit in the M_ANYCAST6 removal. This is actually from naddy@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.36 2008/10/14 18:01:53 naddy Exp $
d28 1
a28 1
.Dd $Mdocdate: October 14 2008 $
d88 2
d617 20
@


1.36
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.35 2008/09/18 15:16:30 naddy Exp $
d28 1
a28 1
.Dd $Mdocdate: September 18 2008 $
a253 2
.It Dv M_ANYCAST6
received as IPv6 anycast.
@


1.35
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.34 2008/09/15 17:16:14 naddy Exp $
d28 1
a28 1
.Dd $Mdocdate: September 15 2008 $
d584 7
a590 6
.Fa func .
The data is copied into an mbuf chain and a pointer to the head of it
is returned.
If
.Fa off
is non-zero, it means the packet is trailer-encapsulated and
d592 1
a592 2
bytes plus the type and length fields will be skipped before doing the
copy.
@


1.34
log
@briefly document the M_LINK0 and M_FILDROP flags; ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.33 2008/08/29 08:13:08 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: August 29 2008 $
d119 2
a120 1
        int     csum_flags;
d264 3
@


1.33
log
@MSIZE and MCLBYTES are now defined in sys/param.h; from Jordan Gordeev
ok thib
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.32 2008/04/13 14:13:14 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: April 13 2008 $
d255 2
d259 4
@


1.32
log
@MSIZE is defined in sys/param.h, not machine/param.h;
from Jonathan Thornburg, documentation/5792
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.31 2008/03/30 15:01:56 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: March 30 2008 $
d262 1
a262 1
.Pq also defined in Aq Pa machine/param.h .
@


1.31
log
@correct arg name; from Matthew Dempsky
ok claudio
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.30 2008/02/11 07:58:28 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate: February 11 2008 $
d179 1
a179 1
.Pq defined in Aq Pa machine/param.h .
@


1.30
log
@bump Mdocdate for pages committed in "febuary", necessary because
of a typo in rcs.c;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.29 2008/02/03 17:20:21 claudio Exp $
d28 1
a28 1
.Dd $Mdocdate$
d485 1
a485 1
.Fa m
@


1.29
log
@Fix the struct pkthdr definition.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.28 2007/09/14 16:16:08 mk Exp $
d28 1
a28 1
.Dd $Mdocdate: September 14 2007 $
@


1.28
log
@sleep(9) was removed aeons ago according to miod, so remove references
to it.  Because man pages are named after functions (at least they
should be) and sleep(9) doesn't exist anymore, sleep.9 is renamed to
tsleep.9.

Input and reminders from jmc and ratchov.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.27 2007/08/10 14:53:25 henning Exp $
d28 1
a28 1
.Dd $Mdocdate: August 10 2007 $
d120 1
a120 1
	struct	pkthdr_pf;
@


1.27
log
@sync structs with reality
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.26 2007/05/31 19:20:00 jmc Exp $
d28 1
a28 1
.Dd $Mdocdate$
d387 1
a387 1
.Xr sleep 9
@


1.26
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.25 2007/04/12 14:52:13 claudio Exp $
d120 10
@


1.25
log
@m_prepend() should never be called directly. So tell people to use
M_PREPEND() instead. Whit help by jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.24 2007/04/03 06:37:37 jasper Exp $
d28 1
a28 1
.Dd December 4, 2001
@


1.24
log
@put "CODE REFERENCES" before "SEE ALSO" for consistency

ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.23 2006/10/12 07:24:31 jmc Exp $
d430 6
@


1.23
log
@- give smm/18.net a title
- mark up `>'
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.22 2006/10/11 22:39:46 mpf Exp $
d649 7
a667 7
.Sh CODE REFERENCES
The mbuf management functions are implemented in the files
.Pa sys/kern/uipc_mbuf.c
and
.Pa sys/kern/uipc_mbuf2.c .
The function prototypes and the macros are located in
.Pa sys/sys/mbuf.h .
@


1.22
log
@Remove unused variable and simplify m_copym0(). Diff from bret.lambert at gmail.com.
Kill another unused variable in m_devget(). Pointed out by mcbride.
Rename all offset variables from off0 to off.
OK markus@@, deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.21 2006/09/05 18:00:34 thib Exp $
d104 1
a104 1
#define mtod(m,t)       ((t)((m)->m_data))
d651 3
a653 1
.Xr mbuf_tags 9 ,
@


1.21
log
@mention that the 'cp' argument to m_copyback is the buffer to be
copied from.

ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.20 2006/08/28 19:02:46 damien Exp $
d37 1
a37 1
.Fn m_copym2 "struct mbuf *m" "int off0" "int len" "int wait"
d39 1
a39 1
.Fn m_copym "struct mbuf *m" "int off0" "int len" "int wait"
d79 1
a79 1
.Fn m_devget "char *buf" "int totlen" "int off0" "struct ifnet *ifp" \
d328 1
a328 1
.It Fn m_copym "struct mbuf *m" "int off0" "int len" "int wait"
d330 1
a330 1
.Fa off0
d336 1
a336 1
.Fa off0
d350 1
a350 1
.It Fn m_copym2 "struct mbuf *m" "int off0" "int len" "int wait"
d551 1
a551 1
.It Fn m_devget "char *buf" "int totlen" "int off0" "struct ifnet *ifp" \
d562 1
a562 1
.Fa off0
d564 1
a564 1
.Fa off0
@


1.20
log
@sync MEXTADD prototype with reality.
it takes an extra "size" argument.

ok jmc@@, deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.19 2005/04/25 23:33:40 brad Exp $
d521 3
a523 1
Copy data from a buffer back into the mbuf chain pointed to by
@


1.19
log
@csum -> csum_flags

reminded by markus@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.18 2005/01/29 00:47:36 jmc Exp $
d88 1
a88 1
.Fn MEXTADD "struct mbuf *m" "caddr_t buf" "int type" \
d603 1
a603 1
.It Fn MEXTADD "struct mbuf *m" "caddr_t buf" "int type" \
@


1.18
log
@quote %T and %B to prevent madness;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.17 2005/01/10 05:44:40 jsg Exp $
d119 1
a119 1
        int     csum;
@


1.17
log
@m_hdr.mh_flags has been u_short for some time now.
Kill uneeded line while here.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.16 2004/11/27 00:59:14 pvalchev Exp $
d653 2
a654 2
.%T Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)
.%B Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference
@


1.16
log
@proper prototypes for some functions that were missing them; ok deraadt dhartmei
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.15 2004/11/25 21:54:55 markus Exp $
d112 1
a112 1
        short   mh_flags;
a119 1

@


1.15
log
@resolve conflict between M_TUNNEL and M_ANYCAST6, remove M_COMP (it's
only set and never read), update documentation; ok fgsch, deraadt, millert
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.14 2004/04/16 21:23:08 jmc Exp $
d362 1
a362 1
.It Fn MFREE "m" "n"
d387 1
a387 1
.It Fn MGET "m" "how" "type"
d409 1
a409 1
.It Fn MGETHDR "m" "int how" "int type"
d431 1
a431 1
.It Fn M_PREPEND "m" "plen" "how"
d609 1
a609 1
.It Fn M_ALIGN "m" "len"
d628 1
a628 1
.It Fn M_READONLY "m"
d634 1
a634 1
.It Fn M_LEADINGSPACE "m"
d638 1
a638 1
.It Fn M_TRAILINGSPACE "m"
d642 1
a642 1
.It Fn MCHTYPE "m" "type"
@


1.14
log
@list/display fixes, and whitespace;
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.13 2003/12/27 05:01:52 mcbride Exp $
d239 1
a239 3
packet was authenticated (AH).
.It Dv M_COMP
packet was compressed (IPCOMP).
d243 1
a243 19
IP-in-IP added by tunnel mode IPsec.
.It Dv M_IPV4_CSUM_OUT
IPv4 checksum needed.
.It Dv M_TCPV4_CSUM_OUT
TCP checksum needed.
.It Dv M_UDPV4_CSUM_OUT
UDP checksum needed.
.It Dv M_IPV4_CSUM_IN_OK
IPv4 checksum verified.
.It Dv M_IPV4_CSUM_IN_BAD
IPv4 checksum bad.
.It Dv M_TCP_CSUM_IN_OK
TCP/IPv4 checksum verified.
.It Dv M_TCP_CSUM_IN_BAD
TCP/IPv4 checksum bad.
.It Dv M_UDP_CSUM_IN_OK
UDP/IPv4 checksum verified.
.It Dv M_UDP_CSUM_IN_BAD
UDP/IPv4 checksum bad.
d273 3
a275 2
interface on which the data was received and a generic pointer to a
structure containing information for IPsec processing.
d278 25
@


1.13
log
@Mention that m is free'd if m_pulldown fails.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.12 2003/12/12 10:25:00 jmc Exp $
d322 1
a322 2
.Pp
.Bl -tag -width compact
@


1.12
log
@sync with <sys/mbuf.h>, as pointed out by Dragos Ruiu;
ok deraadt@@ itojun@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.11 2003/04/17 05:08:39 jmc Exp $
d448 3
@


1.11
log
@typos;

md5(9): ok tedu@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.10 2003/03/14 19:44:32 jason Exp $
d117 1
d119 1
a119 1
        void    *tdbi;
d125 2
a126 2
        void    (*ext_free)
(struct mbuf *);
d128 3
a130 3
        void    (*ext_ref)
(struct mbuf *);
        void    *ext_handle;
a146 5
union mcluster {
        union   mcluster *mcl_next;
        char    mcl_buf[MCLBYTES];
};

d186 2
d197 1
d220 1
d242 4
@


1.10
log
@more cleaning: document 'how'
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.9 2003/03/14 19:29:54 jason Exp $
d72 1
a72 1
.Ft void 
d289 2
a290 2
interface onwhich the data was received and a generic pointer to a
structure containing information for IPsec processing. 
d314 1
a314 1
The structure used is the same than the previous one except that the
d316 1
a316 1
element is not empty, it contains the same information than when
d345 1
a345 1
except that it copies cluster mbufs, where
d371 3
a373 1
If how is
d557 1
a557 1
.Fa m
d572 1
a572 1
casted to
d639 1
a639 1
.Pa /usr/share/doc/smm/18.net.
d642 2
a643 2
.%T "Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)"
.%B "Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference"
@


1.9
log
@dead functions
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.8 2003/03/14 19:27:48 jason Exp $
d44 1
a44 1
.Fn m_get "int nowait" "int type"
d47 1
a47 1
.Fn m_getclr "int nowait" "int type"
d49 1
a49 1
.Fn m_gethdr "int nowait" "int type"
d362 1
a362 1
.It Fn m_get "int nowait" "int type"
d364 12
a379 1
Returns NULL on failure.
d381 4
a384 2
.Fn m_get .
.It Fn m_getclr "int nowait" "int type"
d387 11
a397 6
Returns NULL on failure.
.It Fn m_gethdr "int nowait" "int type"
Return a pointer to an mbuf after initializing it to contain a packet
header.
Returns NULL on failure.
The type is specified.
d399 2
a400 3
Return a pointer to an mbuf in m after initializing it to contain a
packet header.
Returns NULL on failure.
d402 3
a404 1
.Fn m_gethdr .
d416 4
d576 4
d586 4
@


1.8
log
@This still needs work, but it's alot closer.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.7 2003/02/02 03:39:07 jason Exp $
a59 4
.Ft struct mbuf *
.Fn m_retry "int i" "int t"
.Ft struct mbuf *
.Fn m_retryhdr "int i" "int t"
@


1.7
log
@:%s/MEXTALLOC/MEXTMALLOC/g; pointed out by angelos
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.6 2002/06/14 17:25:19 aaron Exp $
d286 3
a288 5
When the M_PKTHDR is set, it means that the data contained in the mbuf
is a packet header.
The data itself is contained in the mbuf (just like the previous case)
but 8 bytes are taken from the data portion to store a packet
header.
d299 2
a300 2
When the M_EXT flag is set, it means that an external storage buffer
is used to hold the data, which is no more stored in the mbuf.
d316 2
a317 3
When both the M_EXT and M_PKTHDR flags are set, it means that an
external storage buffer is used to store the data and this data
contains a packet header.
d325 1
a325 1
Make a copy of an mbuf chain starting at
d331 10
d372 1
d378 1
d382 1
d387 1
d391 1
a391 1
Allocates a new mbuf and prepend it to the mbuf chain pointed to by
d398 3
d409 3
d428 5
d436 3
a454 11
.It Fn m_retry "int i" "int t"
Used when
.Fn MGET
fails.
.Fn m_retry
asks protocols to free memory space and re-attempts to allocate an mbuf.
.It Fn m_retryhdr "int i" "int t"
Same as
.Fn m_retry
except it retries a failed
.Fn MRETRYHDR .
d456 2
a457 2
Attempts to split an mbuf chain in 2 pieces, returning a pointer on
the tail (which is made of the previous mbuf chain but the first
d461 1
a461 1
Injects a new mbuf chain of length
d463 1
a463 1
in the mbuf chain pointed to by
d493 1
a493 1
bytes from the beginning and extending the mbuf chain if
d495 1
a495 1
The mbufs need to be initialized properly, including the setting of
d533 1
d614 1
a614 1
.%B "Proceedings of the freenix track: 2000 USENIX annual technical conference"
@


1.6
log
@Typo.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.5 2002/06/12 07:25:35 aaron Exp $
d90 1
a90 1
.Fn MEXTALLOC "struct mbuf *m" "int size" "int how"
d542 1
a542 1
.It Fn MEXTALLOC "struct mbuf *m" "int size" "int how"
@


1.5
log
@Finish the first sentence (has anyone ever read this man page?).
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.4 2002/02/16 21:27:39 millert Exp $
d344 1
a344 1
just increase the reference count of the clusters.
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
.\"     $OpenBSD: mbuf.9,v 1.3 2001/12/06 10:08:47 jjbg Exp $
d170 2
a171 1
functions provide a way to manage the memory buffers used by the
@


1.3
log
@mbuf(9) man page. Thanks for art@@ and mpech@@ corrections.
@
text
@d1 1
a1 1
.\"     $OpenBSD$
d129 1
a129 1
                    __P((struct mbuf *));
d132 1
a132 1
                    __P((struct mbuf *));
@


1.2
log
@REVERT TO PREVIOUS STATE OF AFFAIR.

If those pages are different from the NetBSD version, maybe there's a
reason ?

Like, possibly, I just read our source code, which just happens to do
things in DIFFERENT ways than NetBSD does ?

As far as the added pages go, they obviously haven't been checked against
actual code as well, hence they're worse than useless, since a large part
of the information is definitely misleading.
@
text
@d1 1
a1 2
.\"	$OpenBSD: mbuf.9,v 1.1 1999/09/22 03:16:47 csapuntz Exp $
.\"	$NetBSD: mbuf.9,v 1.7 1999/03/16 00:40:47 garbled Exp $
d3 1
a3 1
.\" Copyright (c) 1997 The NetBSD Foundation, Inc.
a5 3
.\" This documentation is derived from text contributed to The NetBSD Foundation
.\" by S.P.Zeidler (aka stargazer).
.\"
d14 2
a15 7
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"        This product includes software developed by the NetBSD
.\"        Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
d17 10
a26 11
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
d28 1
a28 1
.Dd October 3, 1997
d32 2
a33 34
.Nm mbuf ,
.Nm m_get ,
.Nm m_getclr ,
.Nm m_gethdr ,
.Nm m_devget ,
.Nm m_copym ,
.Nm m_copypacket ,
.Nm m_copydata ,
.Nm m_copyback ,
.Nm m_cat ,
.Nm m_prepend ,
.Nm m_pullup ,
.Nm m_split ,
.Nm m_adj ,
.Nm m_free ,
.Nm m_freem ,
.Nm mtod ,
.Nm mtocl ,
.Nm cltom ,
.Nm MGET ,
.Nm MGETHDR ,
.Nm MEXTMALLOC ,
.Nm MEXTADD ,
.Nm MCLGET ,
.Nm M_COPY_PKTHDR ,
.Nm M_ALIGN ,
.Nm MH_ALIGN ,
.Nm M_LEADINGSPACE ,
.Nm M_TRAILINGSPACE ,
.Nm M_PREPEND ,
.Nm MCHTYPE ,
.Nm MEXTREMOVE ,
.Nm MFREE ,
.Nd functions and macros for managing memory used by networking code
d37 7
d45 1
d50 1
d52 4
a55 1
.Fn m_devget "char *buf" "int totlen" "int off0" "struct ifnet *ifp" "void (*copy) __P((const void *, void *, size_t))"
d57 1
a57 1
.Fn m_copym "struct mbuf *m" "int off0" "int len" "int wait"
d59 1
a59 7
.Fn m_copypacket "struct mbuf *m" "int how"
.Ft void
.Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
.Ft void
.Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp"
.Ft void
.Fn m_cat "struct mbuf *m" "struct mbuf *n"
d61 1
a61 1
.Fn m_prepend "struct mbuf *m" "int len" "int how"
d63 1
a63 1
.Fn m_pullup "struct mbuf *n" "int len"
d66 4
d72 2
a73 2
.Ft struct mbuf *
.Fn m_free "struct mbuf *m"
d76 2
a77 6
.Ft int
.Fn mtod "struct mbuf *m" "datatype"
.Ft u_long
.Fn mtocl "void *datapointer"
.Ft caddr_t
.Fn cltom "u_long clusternum"
d79 1
a79 1
.Fn MGET "struct mbuf *m" "int how" "int type"
d81 4
a84 5
.Fn MGETHDR "struct mbuf *m" "int how" "int type"
.Ft void
.Fn MEXTMALLOC "struct mbuf *m" "int len" "int how"
.Ft void
.Fn MEXTADD "struct mbuf *m" "caddr_t buf" "int type" "void (*free) __P((caddr_t, u_int, void *))" "void *arg"
d86 5
d92 2
a93 3
.Ft void
.Fn M_COPY_PKTHDR "struct mbuf *to" "struct mbuf *from"
.Ft void
a94 1
.Ft void
d96 1
a96 1
.Ft int
a97 1
.Ft int
a98 3
.Ft void
.Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
.Ft void
d100 67
a166 4
.Ft void
.Fn MEXTREMOVE "struct mbuf *m"
.Ft void
.Fn MFREE "struct mbuf *m" "struct mbuf *n"
d170 9
a178 2
functions and macros provide an easy and consistent way to handle
a networking stack's memory management needs.
d180 18
a197 16
.Nm mbuf
consists of a header and a data area.
It is of a fixed size,
.Dv MSIZE
.Pq defined in Aq Pa machine/param.h ,
which includes overhead.
The header contains a pointer to the next
.Nm mbuf
in the
.Nm mbuf chain ,
a pointer to the next
.Nm mbuf chain ,
a pointer to the data area, the amount of data in this mbuf, its type
and a
.Dv flags
field.
d200 3
a202 3
.Dv type
variable can signify:
.Bl -tag -compact -offset indent -width "XXXXXXXXXXX"
d204 1
a204 1
the mbuf should be on the ``free'' list
d206 1
a206 1
data was dynamically allocated
d208 1
a208 1
data is a packet header
d210 1
a210 1
data is a socket name
d212 1
a212 1
data is socket options
d214 1
a214 1
data is the fragment reassembly header
d216 1
a216 1
mbuf contains ancillary \&(protocol control\&) data
d218 1
a218 1
mbuf contains out-of-band data.
d222 3
a224 5
.Dv flags
variable contains information describing the
.Nm mbuf ,
notably:
.Bl -tag -compact -offset indent -width "XXXXXXXXXXX"
d226 1
a226 1
has external storage
d228 1
a228 1
is start of record
d230 1
a230 1
is end of record
d232 66
a297 1
external storage is a cluster.
d300 15
a314 15
If an
.Nm mbuf
designates the start of a record
.Pq Dv M_PKTHDR ,
its
.Dv flags
field may contain additional information describing the content of
the record:
.Bl -tag -compact -offset indent -width "XXXXXXXXXXX"
.It Dv M_BCAST
sent/received as link-level broadcast
.It Dv M_MCAST
sent/received as link-level multicast
.It Dv M_LINK0 , M_LINK1, MLINK2
three link-level specific flags.
d317 8
a324 12
An
.Nm mbuf
may add a single
.Nm mbuf cluster
of
.Dv MCLBYTES
bytes
.Pq also defined in Aq Pa machine/param.h ,
which has no additional overhead
and is used instead of the internal data area; this is done when at least
.Dv MINCLSIZE
bytes of data must be stored.
a325 45
.It Fn m_get "int nowait" "int type"
Allocates an mbuf and initializes it to contain internal data.
The
.Fa nowait
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
.Dv M_WAIT
means the call cannot fail, but may take forever.
The
.Fa type
parameter is an mbuf type.
.It Fn m_getclr "int nowait" "int type"
Allocates an mbuf and initializes it to contain internal data, then
zeros the data area.
The
.Fa nowait
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
The
.Fa type
parameter is an mbuf type.
.It Fn m_gethdr "int nowait" "int type"
Allocates an mbuf and initializes it to contain a packet header and internal
data.
The
.Fa nowait
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
The
.Fa type
parameter is an mbuf type.
.It Fn m_devget "char *buf" "int totlen" "int off0" "struct ifnet *ifp" "void (*copy) __P((const void *, void *, size_t))"
Copies
.Fa len
bytes from device local memory into mbufs using copy routine
.Fa copy .
If parameter
.Fa off
is non-zero, the packet is supposed to be trailer-encapsulated and
.Fa off
bytes plus the type and length fields will be skipped before copying.
Returns the top of the mbuf chain it created.
d327 1
a327 1
Creates a copy of an mbuf chain starting
d329 2
a330 3
bytes from the beginning, continuing for
.Fa len
bytes.  If the
d332 1
a332 3
requested is
.Dv M_COPYALL ,
the complete mbuf chain will be copied.
d335 16
a350 11
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
.It Fn m_copypacket "struct mbuf *m" "int how"
Copies an entire packet, including header (which must be present).
This function is an optimization of the common case
.Li m_copym(m, 0, Dv M_COPYALL, Fa how ) .
.It Fn m_copydata "struct mbuf *m" "int off" "int len" "caddr_t cp"
Copies
.Fa len
bytes data from mbuf chain
d352 1
a352 17
into the buffer
.Fa cp ,
starting
.Fa off
bytes from the beginning.
.It Fn m_copyback "struct mbuf *m0" "int off" "int len" "caddr_t cp"
Copies
.Fa len
bytes data from buffer
.Fa cp
back into the mbuf chain
.Fa m0 ,
starting
.Fa off
bytes from the beginning, extending the mbuf chain if necessary.
.It Fn m_cat "struct mbuf *m" "struct mbuf *n"
Concatenates mbuf chain
d354 26
a379 1
to
d381 1
a381 7
Both chains must be of the same type; packet headers will
.Em not
be updated if present.
.It Fn m_prepend "struct mbuf *m" "int len" "int how"
Lesser-used path for
.Fn M_PREPEND :
allocates new mbuf
d383 9
a391 4
of size
.Fa len
to prepend to the chain, copying junk along.
The
d393 47
a439 21
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
.It Fn m_pullup "struct mbuf *m" "int len"
Rearranges an mbuf chain so that
.Fa len
bytes are contiguous
and in the data area of an mbuf (so that
.Fn mtod
will work for a structure of size
.Fa len ) .
Returns the resulting
mbuf chain on success, frees it and returns
.Dv NULL
on failure.
If there is room, it will add up to
.Dv max_protohdr
-
.Fa len
extra bytes to the
contiguous region to possibly avoid being called again.
d441 2
a442 2
Partitions an mbuf chain in two pieces, returning the tail,
which is all but the first
d444 19
a462 4
bytes.  In case of failure, it returns
.Dv NULL
and attempts to
restore the chain to its original state.
d464 1
a464 1
Shaves off
d466 2
a467 1
bytes from head or tail of the (valid) data area.
d470 12
a481 8
is greater than zero, front bytes are being shaved off, if it's smaller,
from the back (and if it is zero, the mbuf will stay bearded).
This function does not move data in any way, but is used to manipulate the
data area pointer and data length variable of the mbuf in a non-clobbering
way.
.It Fn m_free "struct mbuf *m"
Frees mbuf
.Fa m .
d483 1
a483 1
Frees the mbuf chain beginning with
d485 4
a488 24
This function contains the elementary sanity check for a
.Dv NULL
pointer.
.It Fn mtod "struct mbuf *m" "datatype"
Returns a pointer to the data contained in the specified mbuf
.Fa m ,
type-casted to the specified data type
.Fa datatype .
Implemented as a macro.
.It Fn mtocl "void *datapointer"
Takes a
.Fa datapointer
within an mbuf cluster and returns the cluster index number of the mbuf
owning the data.
Avoid this; it may be deprecated in the future.
Implemented as a macro.
.It Fn cltom "u_long clusternum"
Takes an mbuf cluster index number
.Fa clusternum
and returns a pointer to the beginning of the cluster.
Avoid this; it may be deprecated in the future.
Implemented as a macro.
.It Fn MGET "struct mbuf *m" "int how" "int type"
Allocates mbuf
d490 3
a492 13
and initializes it to contain internal data.
See
.Fn m_get .
Implemented as a macro.
.It Fn MGETHDR "struct mbuf *m" "int how" "int type"
Allocates mbuf
.Fa m
and initializes it to contain a packet header.
See
.Fn m_gethdr .
Implemented as a macro.
.It Fn MEXTMALLOC "struct mbuf *m" "int len" "int how"
Allocates external storage of size
d494 6
a499 1
for mbuf
d501 6
a506 11
The
.Fa how
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
The flag
.Dv M_EXT
is set upon success.
Implemented as a macro.
.It Fn MEXTADD "struct mbuf *m" "caddr_t buf" "int type" "void (*free) __P((caddr_t, u_int, void *))" "void *arg"
Adds pre-allocated external storage
d508 18
a525 46
to a normal mbuf
.Fa m ;
the parameters
.Fa type ,
.Fa free
and
.Fa arg
describe the external storage.
.Fa type
describes the
.Xr malloc 9
type of the storage,
.Fa free
is a free routine (if not the usual one), and
.Fa arg
is a possible argument to the free routine.
The flag
.Dv M_EXT
is set upon success.
Implemented as a macro.
.It Fn MCLGET "struct mbuf *m" "int how"
Allocates and adds an mbuf cluster to a normal mbuf
.Fa m .
The
.Fa how
parameter is a choice of
.Dv M_WAIT / M_DONTWAIT
from caller.
The flag
.Dv M_EXT
is set upon success.
Implemented as a macro.
.It Fn M_COPY_PKTHDR "struct mbuf *to" "struct mbuf *from"
Copies the mbuf pkthdr from mbuf
.Fa from
to mbuf
.Fa to .
.Fa from
must have the type flag
.Dv M_PKTHDR
set, and
.Fa to
must be empty.
Implemented as a macro.
.It Fn M_ALIGN "struct mbuf *m" "int len"
Sets the data pointer of a newly allocated mbuf
d527 3
a529 1
to
d531 3
a533 8
bytes from the end of the mbuf data area, so that
.Fa len
bytes of data written to the mbuf
.Fa m ,
starting at the data pointer, will be aligned to the end of the data area.
Implemented as a macro.
.It Fn MH_ALIGN "struct mbuf *m" "int len"
Sets the data pointer of a newly allocated packetheader mbuf
d535 4
a538 11
to
.Fa len
bytes from the end of the mbuf data area, so that
.Fa len
bytes of data written to the mbuf
.Fa m ,
starting at the data pointer, will be aligned to the end of the data area.
Implemented as a macro.
.It Fn M_LEADINGSPACE "struct mbuf *m"
Returns the amount of space available before the current start of valid
data in mbuf
d540 5
a544 4
Implemented as a macro.
.It Fn M_TRAILINGSPACE "struct mbuf *m"
Returns the amount of space available after the current end of valid
data in mbuf
d546 4
a549 5
Implemented as a macro.
.It Fn M_PREPEND "struct mbuf *m" "int plen" "int how"
Prepends space of size
.Fa plen
to mbuf
d551 9
a559 8
If a new mbuf must be allocated,
.Fa how
specifies whether to wait.
If
.Fa how
is
.Dv M_DONTWAIT
and allocation fails, the original mbuf chain is freed and
d561 12
a572 5
is set to
.Dv NULL .
Implemented as a macro.
.It Fn MCHTYPE "struct mbuf *m" "int type"
Change mbuf
d574 10
a583 5
to new type
.Fa type .
Implemented as a macro.
.It Fn MEXTREMOVE "struct mbuf *m"
Removes external storage from mbuf
d585 2
a586 6
The flag
.Dv M_EXT
is removed.
Implemented as a macro.
.It Fn MFREE "struct mbuf *m" "struct mbuf *n"
Frees a single mbuf
d588 2
a589 3
and places the successor, if any, in mbuf
.Fa n .
Implemented as a macro.
a590 1
.\" .Sh ERRORS
a591 1
.Xr /usr/share/doc/smm/18.net ,
d593 14
a606 18
.Xr malloc 9
.Sh AUTHORS
The original mbuf data structures were designed by Rob Gurwitz
when he did the initial TCP/IP implementation at BBN.
.br
Further extensions and enhancements were made by Bill Joy, Sam Leffler,
and Mike Karels at CSRG.
.br
Current implementation of external storage by Matt Thomas
.br
<matt@@3am-software.com> and Jason R. Thorpe <thorpej@@NetBSD.ORG>.
.Sh FILES
The
.Nm mbuf
management functions are implemented within the file
.Pa sys/kern/uipc_mbuf.c .
Function prototypes, and the functions implemented as macros
are located in
a607 5
Both pathnames are relative to the root of the
.Nx
source tree,
.Pa /usr/src .
.\" .Sh HISTORY
@


1.1
log
@

Add/update some man9 pages from NetBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: mbuf.9,v 1.7 1999/03/16 00:40:47 garbled Exp $
@

