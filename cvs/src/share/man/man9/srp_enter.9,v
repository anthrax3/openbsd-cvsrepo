head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.6
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.2.0.4
	OPENBSD_5_8_BASE:1.2;
locks; strict;
comment	@.\" @;


1.15
date	2017.01.18.13.18.07;	author dlg;	state Exp;
branches;
next	1.14;
commitid	rlRAKEcgeZqEAvqP;

1.14
date	2016.07.27.12.55.41;	author jca;	state Exp;
branches;
next	1.13;
commitid	afX2PXJQKrkSD6Qs;

1.13
date	2016.06.07.14.37.46;	author jmc;	state Exp;
branches;
next	1.12;
commitid	z2DXULnpn7fMqGVc;

1.12
date	2016.06.07.11.59.31;	author dlg;	state Exp;
branches;
next	1.11;
commitid	djJCOBhkca0Pf8He;

1.11
date	2016.05.18.03.58.13;	author dlg;	state Exp;
branches;
next	1.10;
commitid	ti6TjacQuFYBXsPy;

1.10
date	2016.05.18.03.46.03;	author dlg;	state Exp;
branches;
next	1.9;
commitid	q5zkugIMulsP5tHa;

1.9
date	2016.02.12.12.52.28;	author dlg;	state Exp;
branches;
next	1.8;
commitid	V77pEYWmBOQbeHlB;

1.8
date	2016.02.12.12.48.44;	author dlg;	state Exp;
branches;
next	1.7;
commitid	kBZt7nFyOaTPhGEd;

1.7
date	2016.02.12.12.47.04;	author dlg;	state Exp;
branches;
next	1.6;
commitid	CAIwmoNI8G9vDHxk;

1.6
date	2015.10.02.09.26.16;	author sobrado;	state Exp;
branches;
next	1.5;
commitid	AaJvHZKpW3AedQQh;

1.5
date	2015.09.14.15.14.55;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	TPchOLbdlEugnrt2;

1.4
date	2015.09.01.03.47.58;	author dlg;	state Exp;
branches;
next	1.3;
commitid	l5lNCKsqAztANagW;

1.3
date	2015.08.14.05.18.50;	author dlg;	state Exp;
branches;
next	1.2;
commitid	xhtYu1xEB5mhCYDG;

1.2
date	2015.07.02.01.38.35;	author dlg;	state Exp;
branches;
next	1.1;
commitid	KNOzxH6iD8zVooxc;

1.1
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	;
commitid	HBmwORlhlW47BLMN;


desc
@@


1.15
log
@didnt rename enough things after copy/paste
@
text
@.\"	$OpenBSD: srp_enter.9,v 1.14 2016/07/27 12:55:41 jca Exp $
.\"
.\" Copyright (c) 2015 David Gwynne <dlg@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: July 27 2016 $
.Dt SRP_ENTER 9
.Os
.Sh NAME
.Nm srp_init ,
.Nm srp_gc_init ,
.Nm srp_update ,
.Nm srp_update_locked ,
.Nm srp_swap ,
.Nm srp_swap_locked ,
.Nm srp_enter ,
.Nm srp_follow ,
.Nm srp_leave ,
.Nm srp_get_locked ,
.Nm srp_finalize ,
.Nm srp_gc_finalize ,
.Nm SRP_INITIALIZER ,
.Nm SRP_GC_INITIALIZER
.Nd shared reference pointers
.Sh SYNOPSIS
.In sys/srp.h
.Ft void
.Fn srp_init "struct srp *p"
.Ft void
.Fo srp_gc_init
.Fa "struct srp_gc *gc"
.Fa "void (*dtor)(void *, void *)"
.Fa "void *ctx"
.Fc
.Ft void *
.Fn srp_swap "struct srp *p" "void *v"
.Ft void *
.Fn srp_swap_locked "struct srp *p" "void *v"
.Ft void
.Fn srp_update "struct srp_gc *gc" "struct srp *p" "void *v"
.Ft void
.Fn srp_update_locked "struct srp_gc *gc" "struct srp *p" "void *v"
.Ft void *
.Fn srp_enter "struct srp_ref *sr" "struct srp *p"
.Ft void *
.Fn srp_follow "struct srp_ref *sr" "struct srp *n"
.Ft void
.Fn srp_leave "struct srp_ref *sr"
.Ft void *
.Fn srp_get_locked "struct srp *p"
.Ft void
.Fn srp_finalize "void *v"
.Ft void
.Fn srp_gc_finalize "struct srp_gc *gc"
.Fn SRP_INITIALIZER
.Fo SRP_GC_INITIALIZER
.Fa "void (*dtor)(void *, void *)"
.Fa "void *ctx"
.Fc
.Sh DESCRIPTION
An
srp
structure represents a pointer or reference to an object in memory.
The
srp
API provides concurrent lock free access to these objects, and can
guarantee that the data isn't destroyed while that reference is in
use.
It does not prevent concurrent modification of the referenced object.
.Pp
.Fn srp_init
initialises the srp structure
.Fa p
to an empty state.
.Pp
.Fn srp_gc_init
initialises the srp_gc structure
.Fa gc
so it can be used as a garbage collector for data that gets referenced by srp
structures.
An update to an srp structure will cause the old data to be destroyed when it
is no longer referenced by any CPU in the system.
The old data will be destroyed by the garbage collector by a call to
.Fa dtor
with
.Fa ctx
as the first argument and the pointer to the data as the second argument.
.Pp
.Fn srp_update
and
.Fn srp_update_locked
replace the data referenced by the srp struct
.Fa p
with the data referenced by
.Fa v .
When the original data is no longer in use it will be destroyed by the garbage
collector
.Fa gc .
.Fn srp_update
uses atomic CPU operations to change the references.
.Fn srp_update_locked
may be used if modifications to
.Fa p
are already serialised by the caller.
Both
.Fn srp_update
and
.Fn srp_update_locked
may sleep.
.Pp
.Fn srp_swap
and
.Fn srp_swap_locked
replace the data referenced by the srp struct
.Fa p
with the data referenced by
.Fa v .
When clearing or replacing the last reference to a data structure,
.Fn srp_finalize
must be used to ensure that the data is no longer in use via any srp
structures.
.Fn srp_swap
uses atomic CPU operations to change the reference.
.Fn srp_swap_locked
may be used if modifications to
.Fa p
are already serialised by the caller.
.Pp
.Fn srp_enter
returns a pointer to a data structure referenced by the srp struct
.Fa p
and guarantees it will remain available for use until it is released with a
call to
.Fn srp_leave
or
.Fn srp_follow .
The reference is held via
.Fa sr .
.Pp
.Fn srp_follow
replaces the reference held via
.Fa sr
with a reference to the data structure represented by
.Fa p .
.Pp
.Fn srp_leave
releases the reference held via
.Fa sr
and makes it available for garbage collection.
.Pp
.Fn srp_get_locked
provides access to the data referenced by the srp
.Fa p
if the caller has excluded updates to
.Fa p .
.Pp
.Fn srp_finalize
sleeps until there are no longer any references to
.Fa v
via any srp structure in the system.
.Pp
.Fn srp_gc_finalize
sleeps until all references to data by srp structures using the
garbage collector
.Fa gc
have completed.
That in turn means the
.Fa gc
structure will no longer be referenced and can itself be destroyed.
.Pp
A srp structure declaration can be initialised with the
.Fn SRP_INITIALIZER
macro.
.Pp
A srp_gc structure declaration can be initialised with the
.Fn SRP_GC_INITIALIZER
macro.
Data will be destroyed by the garbage collector by a call to
.Fa dtor
with
.Fa ctx
as the first argument and the pointer to the data as the second argument.
.Sh CONTEXT
.Fn srp_init ,
.Fn srp_gc_init ,
.Fn srp_update ,
.Fn srp_update_locked ,
.Fn srp_get_locked ,
.Fn srp_finalize ,
and
.Fn srp_gc_finalize
can be called during autoconf or from process context.
.Pp
.Fn srp_swap ,
.Fn srp_swap_locked ,
.Fn srp_enter ,
.Fn srp_follow ,
and
.Fn srp_leave
can be called during autoconf, from process context, or from interrupt context.
.Sh RETURN VALUES
.Fn srp_swap
and
.Fn srp_swap_locked
return a pointer to the previous value referenced by the srp structure
.Fa p .
.Pp
.Fn srp_enter ,
.Fn srp_follow ,
and
.Fn srp_get_locked
return a pointer to the data referenced by the srp structure
.Fa p
or
.Dv NULL .
.Sh HISTORY
The srp API was originally written by
.An Jonathan Matthew Aq Mt jmatthew@@openbsd.org
and
.An David Gwynne Aq Mt dlg@@openbsd.org .
The srp API first appeared in
.Ox 5.8 .
@


1.14
log
@Missing word ("no").
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.13 2016/06/07 14:37:46 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: June 7 2016 $
d135 1
a135 1
.Fn srp_update_locked
@


1.13
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.12 2016/06/07 11:59:31 dlg Exp $
d131 2
a132 1
must be used to ensure that the data is longer in use via any srp structures.
@


1.12
log
@document the new bits in the srp api
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.11 2016/05/18 03:58:13 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: May 18 2016 $
d199 1
a200 1
.Fn srp_finalize
d202 1
a202 1
can be called during autoconf, or from process context.
@


1.11
log
@rename srp_finalize to srp_gc_finalize
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.10 2016/05/18 03:46:03 dlg Exp $
d25 2
d31 1
d46 4
d63 2
d122 17
d167 5
d200 1
d204 2
d212 6
@


1.10
log
@rework the srp api so it takes an srp_ref struct that the caller provides.

the srp_ref struct is used to track the location of the callers
hazard pointer so later calls to srp_follow and srp_enter already
know what to clear. this in turn means most of the caveats around
using srps go away. specifically, you can now:

- switch cpus while holding an srp ref
  - ie, you can sleep while holding an srp ref
- you can take and release srp refs in any order

the original intent was to simplify use of the api when dealing
with complicated data structures. the caller now no longer has to
track the location of the srp a value was fetched from, the srp_ref
effectively does that for you.

srp lists have been refactored to use srp_refs instead of srpl_iter
structs.

this is in preparation of using srps inside the ART code. ART is a
complicated data structure, and lookups require overlapping holds
of srp references.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.9 2016/02/12 12:52:28 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: February 12 2016 $
d29 1
a29 1
.Nm srp_finalize ,
d56 1
a56 1
.Fn srp_finalize "struct srp_gc *gc"
d141 1
a141 1
.Fn srp_finalize
d169 1
a169 1
.Fn srp_finalize
@


1.9
log
@i think this is a grammar fix
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.7 2016/02/12 12:47:04 dlg Exp $
d48 1
a48 1
.Fn srp_enter "struct srp *p"
d50 1
a50 1
.Fn srp_follow "struct srp *p" "void *v" "struct srp *n"
d52 1
a52 1
.Fn srp_leave "struct srp *p" "void *v"
d121 2
d125 4
a128 25
returns a pointer to the data structure referenced by the srp struct
.Fa n
that exists within the structure referenced by
.Fa v
via
.Fa p ,
while releasing the reference to
.Fa v
and making it available for garbage collection.
It is equivalent to a call to
.Fn srp_enter
using
.Fa n
as an argument
followed by a call to
.Fn srp_leave
with
.Fa p
and
.Fa v
as arguments.
.Fn srp_follow
is necessary to correctly order the taking and releasing of SRP
critical sections in situations such as following a chain of data
structures linked with SRPs.
d131 2
a132 4
releases the reference to
.Fa v
by the srp struct
.Fa p
a176 16
Calling
.Fn srp_follow
or
.Fn srp_leave
from a different context or on a different CPU to the preceding
.Fn srp_enter
or
.Fn srp_follow
calls will lead to undefined behaviour.
.Pp
SRP critical sections must be released with
.Fn srp_leave
in the opposite order in which they were taken with
.Fn srp_enter
unless a critical section is exchanged with
.Fn srp_follow .
@


1.8
log
@srp_update_get_locked doesnt exist, i meant srp_get_locked
@
text
@d219 1
a219 1
returns a pointer to the data referenced by the srp structure
@


1.7
log
@tweak the description and make it obvious updates can sleep.

based on discussion with haesbart and jmatthew
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.6 2015/10/02 09:26:16 sobrado Exp $
d17 1
a17 1
.Dd $Mdocdate: October 2 2015 $
d188 1
a188 1
.Fn srp_update_get_locked ,
@


1.6
log
@typos.
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.5 2015/09/14 15:14:55 schwarze Exp $
d17 1
a17 1
.Dd $Mdocdate: September 14 2015 $
d63 3
d68 4
a71 2
API provides concurrent lock free access to data structures and guarantees the
data isn't destroyed while it is in use.
d107 5
@


1.5
log
@Remove useless quoting from .Fo and .Fn function names, to prevent
development of a cargo cult in case people look at existing files
for examples.  This achieves a consistent .Fo and .Fn quoting style
across the whole tree.
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.4 2015/09/01 03:47:58 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: September 1 2015 $
d161 1
a161 1
A srp structure declaraction can be initialised with the
d165 1
a165 1
A srp_gc structure declaraction can be initialised with the
@


1.4
log
@mattieu baptiste reported a problem with bpf+srps where the per cpu
hazard pointers were becoming corrupt and therefore panics.

the problem turned out to be that bridge_input calls if_input on
behalf of a hardware interface which then calls bpf_mtap at splsoftnet,
while the actual hardware nic calls if_input and bpf_mtap at splnet.
the hardware interrupts ran in the middle of the bpf calls bridge
runs at softnet. this means the same srps are being entered and
left on the same cpu at different ipls, which led to races because
of the order of operations on the per cpu hazard pointers.

after a lot of experimentation, jmatthew@@ figured out how to deal
with this problem without introducing per cpu critical sections
(ie, splhigh) calls in srp_enter and srp_leave, and without introducing
atomic operations.

the solution is to iterate forward through the array of hazard
pointers in srp_enter, and backward in srp_leave to clear. if you
guarantee that you leave srps in the reverse order to entering them,
then you can use the same set of SRPs at different IPLs on the same
CPU.

the ordering requirement is a problem if we want to build linked
data structures out of srps because you need to hold a ref to the
current element containing the next srp to use it, before giving
up the current ref. we're adding srp_follow() to support taking the
next ref and giving up the current one while preserving the structure
of the hazard pointer list. srp_follow() does this by reusing the
hazard pointer for the current reference for the next ref.

both mattieu baptiste and jmatthew@@ have been hitting this pretty
hard with a tweaked version of srp+bpf that uses srp_follow instead
of interleaved srp_enter/srp_leave sequences. neither can reproduce
the panics anymore.

thanks to mattieu for the report and tests
ok jmatthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.3 2015/08/14 05:18:50 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: August 14 2015 $
d36 1
a36 1
.Fn "srp_init" "struct srp *p"
d38 1
a38 1
.Fo "srp_gc_init"
d44 1
a44 1
.Fn "srp_update" "struct srp_gc *gc" "struct srp *p" "void *v"
d46 1
a46 1
.Fn "srp_update_locked" "struct srp_gc *gc" "struct srp *p" "void *v"
d48 1
a48 1
.Fn "srp_enter" "struct srp *p"
d50 1
a50 1
.Fn "srp_follow" "struct srp *p" "void *v" "struct srp *n"
d52 1
a52 1
.Fn "srp_leave" "struct srp *p" "void *v"
d54 1
a54 1
.Fn "srp_get_locked" "struct srp *p"
d56 3
a58 3
.Fn "srp_finalize" "struct srp_gc *gc"
.Fn "SRP_INITIALIZER"
.Fo "SRP_GC_INITIALIZER"
@


1.3
log
@imply you cant sleep while holding a ref via srp
@
text
@d1 1
a1 1
.\"	$OpenBSD: srp_enter.9,v 1.1 2015/07/02 01:33:59 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: July 2 2015 $
d26 1
d49 2
d106 32
a137 2
and guarantees it will remain available for use until a call to
.Fn srp_leave .
d183 2
a184 1
.Fn srp_enter
d189 2
d194 10
a203 1
call will lead to undefined behaviour.
d205 2
a206 1
.Fn srp_enter
@


1.2
log
@mikeb@@ suggested making it clear that srp_enter and srp_leave pairs
have to be called in the same context.
@
text
@d156 1
a156 1
from a different context to the preceding
@


1.1
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
d154 5
@

