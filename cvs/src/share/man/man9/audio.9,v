head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.23.0.12
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.8
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.10
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@.\" @;


1.26
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	qGgYgJTgEFuAoGj4;

1.25
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.24;
commitid	pi1a9KN0itEngOc4;

1.24
date	2016.09.01.10.14.08;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	7UDYQuGDckjALsRV;

1.23
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.27.07.53.24;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.26.15.07.25;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.07;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.31.11.22.09;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.23.18.31.34;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.15.04.14.29;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.28.09.47.21;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.08.23.17.18;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.29;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.29.17.27.26;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.24.12.23.15;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.22.00.13.34;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.03.15.06.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.12.18.05.57;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.18.29.26;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.22.09.54.37;	author espie;	state dead;
branches;
next	1.1;

1.1
date	99.09.22.03.16.47;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove unused getdev() audio driver functions.
@
text
@.\"	$OpenBSD: audio.9,v 1.22 2010/07/15 03:43:11 jakemsr Exp $
.\"	$NetBSD: audio.9,v 1.14 2000/02/11 22:56:15 kleink Exp $
.\"
.\" Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Lennart Augustsson.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: July 15 2010 $
.Dt AUDIO 9
.Os
.Sh NAME
.Nm audio
.Nd interface between low and high level audio drivers
.Sh DESCRIPTION
The audio device driver is divided into a high level,
hardware independent layer, and a low level, hardware
dependent layer.
The interface between these is the
.Va audio_hw_if
structure.
.Bd -literal
struct audio_hw_if {
	int	(*open)(void *, int);
	void	(*close)(void *);
	int	(*set_params)(void *, int, int,
		    struct audio_params *, struct audio_params *);
	int	(*round_blocksize)(void *, int);

	int	(*commit_settings)(void *);

	int	(*init_output)(void *, void *, int);
	int	(*init_input)(void *, void *, int);
	int	(*start_output)(void *, void *, int,
		    void (*)(void *), void *);
	int	(*start_input)(void *, void *, int,
		    void (*)(void *), void *);
	int	(*halt_output)(void *);
	int	(*halt_input)(void *);

	int	(*speaker_ctl)(void *, int);
#define SPKR_ON  1
#define SPKR_OFF 0

	int	(*setfd)(void *, int);

	int	(*set_port)(void *, struct mixer_ctrl *);
	int	(*get_port)(void *, struct mixer_ctrl *);

	int	(*query_devinfo)(void *, struct mixer_devinfo *);

	void	*(*allocm)(void *, int, size_t, int, int);
	void	(*freem)(void *, void *, int);
	size_t	(*round_buffersize)(void *, int, size_t);
	int 	(*get_props)(void *);

	int	(*trigger_output)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
	int	(*trigger_input)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
};

struct audio_params {
	u_long	sample_rate;		/* sample rate */
	u_int	encoding;		/* mu-law, linear, etc */
	u_int	precision;		/* bits/sample */
	u_int	bps;			/* bytes/sample */
	u_int	msb;			/* data alignment */
	u_int	channels;		/* mono(1), stereo(2) */
};
.Ed
.Pp
The high level audio driver attaches to the low level driver
when the latter calls
.Fn audio_attach_mi .
This call is:
.Bd -literal -offset indent
struct device *
audio_attach_mi(struct audio_hw_if *ahwp, void *hdl,
		struct device *dev);
.Ed
.Pp
The
.Va audio_hw_if
struct is as shown above.
The
.Fa hdl
argument is a handle to some low level data structure.
It is sent as the first argument to all the functions in
.Fa ahwp
when the high level driver calls them.
.Fa dev
is the device struct for the hardware device.
.Pp
The upper layer of the audio driver allocates one buffer for playing
and one for recording.
It handles the buffering of data from the user processes in these.
The data is presented to the lower level in smaller chunks, called blocks.
During playback, if there is no data available from the user process
when the hardware requests another block, a block of silence will be
used instead.
Similarly, if the user process does not read data quickly enough during
recording, data will be thrown away.
.Pp
The fields of
.Va audio_hw_if
are described in some more detail below.
Some fields are optional and can be set to
.Dv NULL
if not needed.
.Bl -tag -width indent
.It Fn "int (*open)" "void *hdl" "int flags"
This function is called when the audio device is opened, with
.Fa flags
the kernel representation of flags passed to the
.Xr open 2
system call
.Po
see
.Dv OFLAGS
and
.Dv FFLAGS
in
.In sys/fcntl.h
.Pc .
It initializes the hardware for I/O.
Every successful call to
.Fn open
is matched by a call to
.Fn close .
This function returns 0 on success, otherwise an error code.
.It Fn "void (*close)" "void *hdl"
This function is called when the audio device is closed.
.It Fn "int (*set_params)" "void *hdl" "int setmode" "int usemode" \
"struct audio_params *play" "struct audio_params *rec"
This function is called to set the audio encoding mode.
.Fa setmode
is a combination of the
.Dv AUMODE_RECORD
and
.Dv AUMODE_PLAY
flags to indicate which mode(s) are to be set.
.Fa usemode
is also a combination of these flags, but indicates the current
mode of the device (i.e., the value corresponding to the
.Va flags
argument to the
.Fn open
function).
The
.Fa play
and
.Fa rec
structures contain the encoding parameters that will be set.
The values of the structures must also be modified if the hardware
cannot be set to exactly the requested mode (e.g., if the requested
sampling rate is not supported, but one close enough is).
Except the channel count, the same value is passed in both
.Fa play
and
.Fa rec .
.Pp
The machine independent audio driver does some preliminary parameter checking;
it verifies that the precision is compatible with the encoding,
and it translates
.Dv AUDIO_ENCODING_[US]LINEAR
to
.Dv AUDIO_ENCODING_[US]LINEAR_{LE,BE} .
.Pp
This function returns 0 on success, otherwise an error code.
.It Fn "int (*round_blocksize)" "void *hdl" "int bs"
This function is optional.
If supplied, it is called with the block size,
.Fa bs ,
which has been computed by the upper layer.
It returns a block size, possibly changed according to the needs of the
hardware driver.
.It Fn "int (*commit_settings)" "void *hdl"
This function is optional.
If supplied, it is called after all calls to
.Fn set_params
and
.Fn set_port
are done.
A hardware driver that needs to get the hardware in
and out of command mode for each change can save all the changes
during previous calls and do them all here.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*init_output)" "void *hdl" "void *buffer" "int size"
This function is optional.
If supplied, it is called before any output starts, but only after the total
.Fa size
of the output
.Fa buffer
has been determined.
It can be used to initialize looping DMA for hardware that needs it.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*init_input)" "void *hdl" "void *buffer" "int size"
This function is optional.
If supplied, it is called before any input starts, but only after the total
.Fa size
of the input
.Fa buffer
has been determined.
It can be used to initialize looping DMA for hardware that needs it.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*start_output)" "void *hdl" "void *block" "int bsize" \
"void (*intr)(void *)" "void *intrarg"
This function is called to start the transfer of
.Fa bsize
bytes from
.Fa block
to the audio hardware.
The call returns when the data transfer
has been initiated (normally with DMA).
When the hardware is ready to accept more samples the function
.Fa intr
will be called with the argument
.Fa intrarg .
Calling
.Fa intr
will normally initiate another call to
.Fn start_output .
This function returns 0 on success, otherwise an error code.
.It Fn "int (*start_input)" "void *hdl" "void *block" "int bsize" \
"void (*intr)(void *)" "void *intrarg"
This function is called to start the transfer of
.Fa bsize
bytes to
.Fa block
from the audio hardware.
The call returns when the data transfer
has been initiated (normally with DMA).
When the hardware is ready to deliver more samples the function
.Fa intr
will be called with the argument
.Fa intrarg .
Calling
.Fa intr
will normally initiate another call to
.Fn start_input .
This function returns 0 on success, otherwise an error code.
.It Fn "int (*halt_output)" "void *hdl"
This function is called to abort the output transfer (started by
.Fn start_output )
in progress.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*halt_input)" "void *hdl"
This function is called to abort the input transfer (started by
.Fn start_input )
in progress.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*speaker_ctl)" "void *hdl" "int on"
This function is optional.
If supplied, it is called when a half duplex device changes between
playing and recording.
It can, e.g., be used to turn the speaker on and off.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*setfd)" "void *hdl" "int fd"
This function is optional.
If supplied, it is called when the device is opened in full-duplex mode,
but only if the device has
.Dv AUDIO_PROP_FULLDUPLEX
set.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*set_port)" "void *hdl" "struct mixer_ctrl *mc"
This function is called when the
.Dv AUDIO_MIXER_WRITE
.Xr ioctl 2
is used.
It takes data from
.Fa mc
and sets the corresponding mixer values.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*get_port)" "void *hdl" "struct mixer_ctrl *mc"
This function is called when the
.Dv AUDIO_MIXER_READ
.Xr ioctl 2
is used.
It fills
.Fa mc
and returns 0 on success, or it returns an error code on failure.
.It Fn "int (*query_devinfo)" "void *hdl" "struct mixer_devinfo *di"
This function is called when the
.Dv AUDIO_MIXER_DEVINFO
.Xr ioctl 2
is used.
It fills
.Fa di
and returns 0 on success, or it returns an error code on failure.
.It Fn "void *(*allocm)" "void *hdl" "int direction" "size_t size" "int type" \
"int flags"
This function is optional.
If supplied, it is called to allocate the device buffers.
If not supplied,
.Xr malloc 9
is used instead (with the same arguments but the first two).
The reason for using a device dependent routine instead of
.Xr malloc 9
is that some buses need special allocation to do DMA.
.Fa direction
is
.Dv AUMODE_PLAY
or
.Dv AUMODE_RECORD .
This function returns the address of the buffer on success, or 0 on failure.
.It Fn "void (*freem)" "void *hdl" "void *addr" "int type"
This function is optional.
If supplied, it is called to free memory allocated by
.Fn allocm .
If not supplied,
.Xr free 9
is used instead.
.\" XXX: code passes int instead of size_t, but decl is size_t
.It Fn "size_t (*round_buffersize)" "void *hdl" "int direction" \
"size_t bufsize"
This function is optional.
If supplied, it is called at startup to determine the audio buffer size.
The upper layer supplies the suggested size in
.Fa bufsize ,
which the hardware driver can then change if needed.
E.g., DMA on the ISA bus cannot exceed 65536 bytes.
Note that the buffer size is always a multiple of the block size, so
.Fn round_blocksize
and
.Fn round_buffersize
must be consistent.
.It Fn "int (*get_props)" "void *hdl"
This function returns a combination of
.Dv AUDIO_PROP_xxx
properties.
.It Fn "int (*trigger_output)" "void *hdl" "void *start" "void *end" "int blksize" \
"void (*intr)(void *)" "void *intrarg" "struct audio_params *param"
This function is optional.
If supplied, it is called to start the transfer of data from the circular
buffer delimited by
.Fa start
and
.Fa end
to the audio hardware, parameterized as in
.Fa param .
The call returns when the data transfer
has been initiated (normally with DMA).
When the hardware is finished transferring each
.Fa blksize
sized block, the function
.Fa intr
will be called with the argument
.Fa intrarg
(typically from the audio hardware interrupt service routine).
Once started, the transfer may be stopped using
.Fn halt_output .
This function returns 0 on success, otherwise an error code.
.It Fn "int (*trigger_input)" "void *hdl" "void *start" "void *end" "int blksize" \
"void (*intr)(void *)" "void *intrarg" "struct audio_params *param"
This function is optional.
If supplied, it is called to start the transfer of data from the audio
hardware, parameterized as in
.Fa param ,
to the circular buffer delimited by
.Fa start
and
.Fa end .
The call returns when the data transfer
has been initiated (normally with DMA).
When the hardware is finished transferring each
.Fa blksize
sized block, the function
.Fa intr
will be called with the argument
.Fa intrarg
(typically from the audio hardware interrupt service routine).
Once started, the transfer may be stopped using
.Fn halt_input .
This function returns 0 on success, otherwise an error code.
.El
.Pp
If the audio hardware is capable of input from more
than one source it should define
.Dv AudioNsource
in class
.Dv AudioCrecord .
This mixer control should be of type
.Dv AUDIO_MIXER_ENUM
or
.Dv AUDIO_MIXER_SET
and enumerate the possible input sources.
For each of the named sources there should be
a control in the
.Dv AudioCinputs
class of type
.Dv AUDIO_MIXER_VALUE
if recording level of the source can be set.
If the overall recording level can be changed (i.e., regardless
of the input source) then this control should be named
.Dv AudioNrecord
and be of class
.Dv AudioCinputs .
.Pp
If the audio hardware is capable of output to more than
one destination it should define
.Dv AudioNoutput
in class
.Dv AudioCmonitor .
This mixer control should be of type
.Dv AUDIO_MIXER_ENUM
or
.Dv AUDIO_MIXER_SET
and enumerate the possible destinations.
For each of the named destinations there should be
a control in the
.Dv AudioCoutputs
class of type
.Dv AUDIO_MIXER_VALUE
if output level of the destination can be set.
If the overall output level can be changed (i.e., regardless
of the destination) then this control should be named
.Dv AudioNmaster
and be of class
.Dv AudioCoutputs .
.Sh SEE ALSO
.Xr ioctl 2 ,
.Xr open 2 ,
.Xr sio_open 3 ,
.Xr audio 4 ,
.Xr free 9 ,
.Xr malloc 9
.Sh HISTORY
This
.Nm
interface first appeared in
.Ox 1.2 .
@


1.25
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@a66 1
	int	(*getdev)(void *, struct audio_device *);
a280 5
.It Fn "int (*getdev)" "void *hdl" "struct audio_device *ret"
This function fills
.Fa ret
with relevant information about the driver and returns 0 on success,
or it returns an error code on failure.
@


1.24
log
@Remove references to removed ioctls and data structures.
Suggested by jmc@@.
@
text
@a47 3
	int	(*drain)(void *);

	int	(*query_encoding)(void *, struct audio_encoding *);
a77 2
	paddr_t	(*mappage)(void *, void *, off_t, int);

a83 1
	void	(*get_default_params)(void *, int, struct audio_params *);
a156 16
.It Fn "int (*drain)" "void *hdl"
This function is optional.
If supplied, it is called before the device is closed or when the
.Dv AUDIO_DRAIN
.Xr ioctl 2
is called.
It makes sure that no samples remain to be played that could
be lost when
.Fn close
is called.
This function returns 0 on success, otherwise an error code.
.It Fn "int (*query_encoding)" "void *hdl" "struct audio_encoding *ae"
This function fills
.Fa ae
and returns 0 or, if there is no encoding with the given number, returns
.Er EINVAL .
a355 12
.It Fn "paddr_t (*mappage)" "void *hdl" "void *addr" "off_t offs" "int prot"
This function is optional.
If supplied, it is called for
.Xr mmap 2 .
It returns the map value for the page at offset
.Fa offs
from address
.Fa addr
mapped with protection
.Fa prot .
This function returns \-1 on failure, or a machine dependent opaque
value on success.
a403 15
.It Fn "void (*get_default_params)" "void *hdl" "int direction" \
"struct audio_params *param"
This function is optional.
If supplied, it is called to retrieve the default configuration
for the given
.Fa direction ,
parameterized in
.Fa param .
.Fa direction
is
.Dv AUMODE_PLAY
or
.Dv AUMODE_RECORD .
The default configuration should not include emulated formats, and should
reflect the optimal operating configuration for the underlying hardware.
a450 1
.Xr mmap 2 ,
@


1.23
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@a98 3
	/* Software en/decode functions, set if SW coding required by HW */
	void	(*sw_code)(void *, u_char *, int);
	int	factor;			/* coding space change */
d175 1
a175 5
This function is used when the
.Dv AUDIO_GETENC
.Xr ioctl 2
is called.
It fills
d190 5
a194 5
mode of the device (i.e., the value of
.Va mode
in the
.Va audio_info
struct).
d200 1
a200 10
If the hardware requires software assistance with some encoding
(e.g., it might be lacking mu-law support), it will fill the
.Va sw_code
and
.Va factor
fields of these structures.
See
.Pa /usr/src/sys/dev/auconv.h
for available software support.
The values of the structures may also be modified if the hardware
d203 1
a203 3
If the device does not have the
.Dv AUDIO_PROP_INDEPENDENT
property, the same value is passed in both
d206 1
a206 7
.Fa rec
and the encoding parameters from
.Fa play
are copied into
.Fa rec
after the call to
.Fn set_params .
d311 2
a312 4
If supplied, it is called when the
.Dv AUDIO_SETFD
.Xr ioctl 2
is used, but only if the device has
d391 1
a391 5
This function returns the device properties, as per
.Xr audio 4
.Dv AUDIO_GETPROPS
.Xr ioctl 2 ,
i.e., a combination of
a453 6
.Pp
The
.Fn query_devinfo
method should define certain mixer controls for
.Dv AUDIO_SETINFO
to be able to change the port and gain.
@


1.22
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.21 2008/10/27 07:53:24 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate: October 27 2008 $
d156 1
a156 1
.Aq Pa sys/fcntl.h
@


1.21
log
@sa_open -> sio_open, after recent changes;
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.20 2008/10/26 15:07:25 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate: October 26 2008 $
d96 2
@


1.20
log
@add some audio/libsa cross refs;
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.19 2008/06/26 05:42:07 ray Exp $
d31 1
a31 1
.Dd $Mdocdate: June 26 2008 $
d536 1
a536 1
.Xr sa_open 3 ,
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.18 2008/04/21 00:32:42 jakemsr Exp $
d31 1
a31 1
.Dd $Mdocdate: April 21 2008 $
d536 1
@


1.18
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.17 2007/05/31 19:20:00 jmc Exp $
a17 7
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"        This product includes software developed by the NetBSD
.\"        Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
d31 1
a31 1
.Dd $Mdocdate: May 31 2007 $
@


1.17
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.16 2004/01/31 11:22:09 jmc Exp $
d38 1
a38 1
.Dd $Mdocdate$
d96 1
d473 15
@


1.16
log
@update from Jared Yanovich:

- sync with header
- macro fixes
- readability fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.15 2003/10/23 18:31:34 jmc Exp $
d38 1
a38 1
.Dd February 11, 2000
@


1.15
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.14 2003/06/06 20:56:32 jmc Exp $
d46 1
a46 1
hardware independent layer, and a low level hardware
d80 2
a81 2
	int	(*set_port)(void *, mixer_ctrl_t *);
	int	(*get_port)(void *, mixer_ctrl_t *);
d83 1
a83 1
	int	(*query_devinfo)(void *, mixer_devinfo_t *);
d88 1
a88 1
	int	(*mappage)(void *, void *, int, int);
d111 6
a116 8
.Va audio_attach_mi .
This call should be
.Bd -literal
    void
    audio_attach_mi(ahwp, hdl, dev)
	struct audio_hw_if *ahwp;
	void *hdl;
	struct device *dev;
d123 1
a123 1
.Va hdl
d125 2
a126 3
It is sent as the first argument to all the functions
in
.Va audio_hw_if
d128 1
a128 1
.Va dev
d144 3
a146 1
Some fields are optional and can be set to 0 if not needed.
d148 3
a150 3
.It Dv int open(void *hdl, int flags)
is called when the audio device is opened, with
.Va flags
d162 1
a162 1
It should initialize the hardware for I/O.
d164 1
a164 1
.Va open
d166 7
a172 6
.Va close .
Return 0 on success, otherwise an error code.
.It Dv void close(void *hdl)
is called when the audio device is closed.
.It Dv int drain(void *hdl)
optional, is called before the device is closed or when
d174 1
d176 1
a176 1
It should make sure that no samples remain to be played that could
d178 1
a178 1
.Va close
d180 3
a182 3
Return 0 on success, otherwise an error code.
.It Dv int query_encoding(void *hdl, struct audio_encoding *ae)
is used when
d184 1
d186 8
a193 9
It should fill the
.Va audio_encoding
structure and return 0 or, if there is no encoding with the
given number, return EINVAL.
.It Dv int set_params(void *hdl, int setmode, int usemode,
.Dv "struct audio_params *play, struct audio_params *rec)"
.br
Called to set the audio encoding mode.
.Va setmode
d199 1
a199 1
.Va usemode
d207 1
a207 1
.Va play
d209 2
a210 2
.Va rec
structures contain the encoding parameters that should be set.
d212 1
a212 1
(e.g., it might be lacking mu-law support) it should fill the
d225 2
a226 2
property the same value is passed in both
.Va play
d228 1
a228 1
.Va rec
d230 3
a232 3
.Va play
is copied into
.Va rec
d234 3
a236 2
.Va set_params .
The machine independent audio driver does some preliminary parameter checking:
d242 8
a249 6
Return 0 on success, otherwise an error code.
.It Dv int round_blocksize(void *hdl, int bs)
optional, is called with the block size,
.Va bs ,
that has been computed by the upper layer.
It should return a block size, possibly changed according to the needs of the
d251 4
a254 3
.It Dv int commit_settings(void *hdl)
optional, is called after all calls to
.Va set_params ,
d256 1
a256 1
.Va set_port ,
d261 5
a265 4
Return 0 on success, otherwise an error code.
.It Dv int init_output(void *hdl, void *buffer, int size)
optional, is called before any output starts, but when the total
.Va size
d267 1
a267 1
.Va buffer
d270 5
a274 4
Return 0 on success, otherwise an error code.
.It Dv int init_input(void *hdl, void *buffer, int size)
optional, is called before any input starts, but when the total
.Va size
d276 1
a276 1
.Va buffer
d279 5
a283 6
Return 0 on success, otherwise an error code.
.It Dv int start_output(void *hdl, void *block, int bsize,
.Dv "void (*intr)(void*), void *intrarg)"
.br
is called to start the transfer of
.Va bsize
d285 1
a285 1
.Va block
d287 2
a288 2
The call should return when the data
transfer has been initiated (normally with DMA).
d290 3
a292 3
.Va intr
should be called with the argument
.Va intrarg .
d294 1
a294 1
.Va intr
d296 6
a301 7
.Va start_output .
Return 0 on success, otherwise an error code.
.It Dv int start_input(void *hdl, void *block, int bsize,
.Dv "void (*intr)(void*), void *intrarg)"
.br
is called to start the transfer of
.Va bsize
d303 1
a303 1
.Va block
d305 2
a306 2
The call should return when the data
transfer has been initiated (normally with DMA).
d308 3
a310 3
.Va intr
should be called with the argument
.Va intrarg .
d312 1
a312 1
.Va intr
d314 5
a318 5
.Va start_input .
Return 0 on success, otherwise an error code.
.It Dv int halt_output(void *hdl)
is called to abort the output transfer (started by
.Va start_output )
d320 4
a323 4
Return 0 on success, otherwise an error code.
.It Dv int halt_input(void *hdl)
is called to abort the input transfer (started by
.Va start_input )
d325 4
a328 3
Return 0 on success, otherwise an error code.
.It Dv int speaker_ctl(void *hdl, int on)
optional, is called when a half duplex device changes between
d331 9
a339 8
Return 0 on success, otherwise an error code.
.It Dv int getdev(void *hdl, struct audio_device *ret)
Should fill the
.Va audio_device
struct with relevant information about the driver.
Return 0 on success, otherwise an error code.
.It Dv int setfd(void *hdl, int fd)
optional, is called when
d341 7
a347 4
is used, but only if the device has AUDIO_PROP_FULLDUPLEX set.
Return 0 on success, otherwise an error code.
.It Dv int set_port(void *hdl, mixer_ctl_t *mc)
is called when
d349 1
d351 6
a356 6
It should take data from the
.Va mixer_ctl_t
struct and set the corresponding mixer values.
Return 0 on success, otherwise an error code.
.It Dv int get_port(void *hdl, mixer_ctl_t *mc)
is called when
d358 1
d360 5
a364 6
It should fill the
.Va mixer_ctl_t
struct.
Return 0 on success, otherwise an error code.
.It Dv int query_devinfo(void *hdl, mixer_devinfo_t *di)
is called when
d366 1
d368 8
a375 8
It should fill the
.Va mixer_devinfo_t
struct.
Return 0 on success, otherwise an error code.
.It Dv "void *allocm(void *hdl, int direction, size_t size, int type, int flags)"
.br
optional, is called to allocate the device buffers.
If not present
d381 1
a381 1
.Va direction
d386 5
a390 4
Returns the address of the buffer, or 0 on failure.
.It Dv void freem(void *hdl, void *addr, int type)
optional, is called to free memory allocated by
.Va allocm .
d393 6
a398 4
is used.
.It Dv size_t round_buffersize(void *hdl, int direction, size_t bufsize)
optional, is called at startup to determine the audio
buffer size.
d400 1
a400 1
.Va bufsize ,
d407 4
a410 4
should be consistent.
.It Dv "int mappage(void *hdl, void *addr, int offs, int prot)"
.br
optional, is called for
d412 2
a413 2
Should return the map value for the page at offset
.Va offs
d415 1
a415 1
.Va addr
d417 5
a421 5
.Va prot .
Returns -1 on failure, or a machine dependent opaque value
on success.
.It Dv int get_props(void *hdl)
Should return the device properties, as per
d424 10
a433 10
ioctl, i.e., a combination of
.Dv AUDIO_PROP_xxx .
.It Dv int trigger_output(void *hdl, void *start, void *end,
.Dv "int blksize, void (*intr)(void*), void *intrarg,"
.br
.Dv "struct audio_params *param)"
.br
optional, is called to start the transfer of data from the circular buffer
delimited by
.Va start
d435 1
a435 1
.Va end
d437 3
a439 3
.Va param .
The call should return when the data transfer has been initiated
(normally with DMA).
d441 1
a441 1
.Va bsize
d443 3
a445 3
.Va intr
should be called with the argument
.Va intrarg
d447 9
a455 11
Once started the transfer may be stopped using
.Va halt_output .
Return 0 on success, otherwise an error code.
.It Dv int trigger_input(void *hdl, void *start, void *end,
.Dv "int blksize, void (*intr)(void*), void *intrarg,"
.br
.Dv "struct audio_params *param)"
.br
optional, is called to start the transfer of data from the audio hardware,
parameterized as in
.Va param ,
d457 1
a457 1
.Va start
d459 3
a461 3
.Va end .
The call should return when the data transfer has been initiated
(normally with DMA).
d463 1
a463 1
.Va bsize
d465 3
a467 3
.Va intr
should be called with the argument
.Va intrarg
d469 3
a471 3
Once started the transfer may be stopped using
.Va halt_input .
Return 0 on success, otherwise an error code.
d475 1
a475 1
.Va query_devinfo
d524 6
a529 1
.Xr audio 4
@


1.14
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.13 2003/04/15 04:14:29 jmc Exp $
d152 1
a152 1
the kernel represention of flags passed to the
@


1.13
log
@typos;

VOP, crypto and disklabel ok tedu@@
audio(9) ok naddy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.12 2003/03/28 09:47:21 jmc Exp $
d309 1
a309 1
.Va start_input.
@


1.12
log
@mu-law and A-law spelling;
mu-law and u-law are the same, so used mu-law for consistency;

ok jason@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.11 2003/03/08 23:17:18 jmc Exp $
d161 1
a161 1
.Pa sys/fcntl.h
d234 3
a236 2
The mi audio driver does some preliminary parameter checking: it verifies
that the precision is compatible with the encoding, and it translates
d337 1
a337 1
is called in when
d342 1
a342 1
struct at set the corresponding mixer values.
d345 1
a345 1
is called in when
d353 1
a353 1
is called in when
d378 1
a378 1
If not supplied
@


1.11
log
@.Xr's for section9:

- MLINKS for uvm stuff
- MLINK vgone.9 vgonel.9
- typos
- fixed SYNOPSIS of extattr(9)

lots of help from miod and art
ok miod@@ art@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.10 2002/02/17 19:42:29 millert Exp $
d100 1
a100 1
	u_int	encoding;		/* ulaw, linear, etc */
d211 1
a211 1
(e.g., it might be lacking mulaw support) it should fill the
d215 1
a215 1
fields of these structures. 
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.9 2002/02/16 21:27:39 millert Exp $
d406 1
a406 1
.Xr audio 2
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.8 2001/12/29 17:27:26 mickey Exp $
d58 2
a59 2
	int	(*set_params)__P((void *, int, int,
			struct audio_params *, struct audio_params *));
d66 4
a69 4
	int	(*start_output)__P((void *, void *, int,
				    void (*)(void *), void *));
	int	(*start_input)__P((void *, void *, int,
				   void (*)(void *), void *));
d92 4
a95 4
	int	(*trigger_output)__P((void *, void *, void *, int,
			void (*)(void *), void *, struct audio_params *));
	int	(*trigger_input)__P((void *, void *, void *, int,
			void (*)(void *), void *, struct audio_params *));
@


1.8
log
@proper history
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.7 2001/09/24 12:23:15 espie Exp $
d53 3
a55 3
	int	(*open)__P((void *, int));
	void	(*close)__P((void *));
	int	(*drain)__P((void *));
d57 1
a57 1
	int	(*query_encoding)__P((void *, struct audio_encoding *));
d60 1
a60 1
	int	(*round_blocksize)__P((void *, int));
d62 1
a62 1
	int	(*commit_settings)__P((void *));
d64 2
a65 2
	int	(*init_output)__P((void *, void *, int));
	int	(*init_input)__P((void *, void *, int));
d70 2
a71 2
	int	(*halt_output)__P((void *));
	int	(*halt_input)__P((void *));
d73 1
a73 1
	int	(*speaker_ctl)__P((void *, int));
d77 2
a78 2
	int	(*getdev)__P((void *, struct audio_device *));
	int	(*setfd)__P((void *, int));
d80 2
a81 2
	int	(*set_port)__P((void *, mixer_ctrl_t *));
	int	(*get_port)__P((void *, mixer_ctrl_t *));
d83 1
a83 1
	int	(*query_devinfo)__P((void *, mixer_devinfo_t *));
d85 4
a88 4
	void	*(*allocm)__P((void *, int, size_t, int, int));
	void	(*freem)__P((void *, void *, int));
	size_t	(*round_buffersize)__P((void *, int, size_t));
	int	(*mappage)__P((void *, void *, int, int));
d90 1
a90 1
	int 	(*get_props)__P((void *));
d104 1
a104 1
	void	(*sw_code)__P((void *, u_char *, int));
@


1.7
log
@Somewhat more extensive detail
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.6 2000/12/22 00:13:34 avsm Exp $
d515 1
a515 1
.Nx 1.3 .
@


1.6
log
@more typo fixes; aaron@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.5 2000/12/03 15:06:08 espie Exp $
d79 1
a79 1
	
d84 1
a84 1
	
d138 1
a138 1
If there, during playback, is no data available from the user process
d141 1
a141 1
Furthermore, if the user process does not read data quickly enough during
d150 13
a162 1
is called when the audio device is opened.
d215 4
a218 1
fields of these structures.
d234 5
d368 5
d387 5
d405 5
a409 2
Should return the device properties; i.e., a combination of
AUDIO_PROP_xxx.
@


1.5
log
@typo (d@@)
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.4 2000/10/12 18:05:57 aaron Exp $
d380 1
a380 1
.Dv "stuct audio_params *param)"
d404 1
a404 1
.Dv "stuct audio_params *param)"
@


1.4
log
@General man page cleanups, mostly to remove trailing whitespace, hard
sentence breaks, and other such things.
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.3 2000/04/27 18:29:26 mickey Exp $
d351 1
a351 1
.Va alloc .
@


1.3
log
@audio(9) from netbsd, seems to match pretty well
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d47 3
a49 3
dependent layer.  The interface between these is 
the 
.Va audio_hw_if 
d58 1
a58 1
	int	(*set_params)__P((void *, int, int, 
d121 1
a121 1
The 
d123 3
a125 2
struct is as shown above.  The
.Va hdl 
d135 8
a142 7
and one for recording.  It handles the buffering of data from the
user processes in these.  The data is presented to the lower level
in smaller chunks, called blocks.  If there, during playback, is
no data available from the user process when the hardware request
another block a block of silence will be used instead.  Furthermore,
if the user process does not read data quickly enough during recording
data will be thrown away.
d150 3
a152 2
is called when the audio device is opened.  It should initialize
the hardware for I/O.  Every successful call to
d162 3
a164 2
is called.  It should make sure that no samples remain
in to be played that could be lost when 
d171 2
a172 1
is called.  It should fill the 
d176 1
a176 1
.It Dv int set_params(void *hdl, int setmode, int usemode, 
d188 1
a188 1
mode of the device (i.e. the value of
d205 1
a205 1
cannot be set to exactly the requested mode (e.g. if the requested
d223 2
a224 2
that has been computed by the upper layer.  It should return
a block size, possibly changed according to the needs of the
d231 2
a232 1
are done.  A hardware driver that needs to get the hardware in
d240 3
a242 3
.Va buffer 
has been determined.  It can be used to initialize looping DMA
for hardware that needs that.
d248 3
a250 3
.Va buffer 
has been determined.  It can be used to initialize looping DMA
for hardware that needs that.
d259 4
a262 3
to the audio hardware.  The call should return when the data
transfer has been initiated (normally with DMA).  When the
hardware is ready to accept more samples the function
d278 4
a281 3
from the audio hardware.  The call should return when the data
transfer has been initiated (normally with DMA).  When the
hardware is ready to deliver more samples the function
d302 2
a303 2
playing and recording.  It can, e.g., be used to turn on
and off the speaker.
d306 1
a306 1
Should fill the 
d318 2
a319 1
is used.  It should take data from the
d326 2
a327 1
is used.  It should fill the
d334 2
a335 1
is used.  It should fill the
d341 2
a342 1
optional, is called to allocate the device buffers.  If not present
d357 2
a358 2
buffer size.  The upper layer supplies the suggested
size in
d375 1
a375 1
Should return the device properties; i.e. a combination of
d390 2
a391 2
(normally with DMA).  When the hardware is finished transferring
each
d414 2
a415 2
(normally with DMA).  When the hardware is finished transferring
each
d449 1
a449 1
If the overall recording level can be changed (i.e. regardless
d471 1
a471 1
If the overall output level can be changed (i.e. regardless
@


1.2
log
@REVERT TO PREVIOUS STATE OF AFFAIR.

If those pages are different from the NetBSD version, maybe there's a
reason ?

Like, possibly, I just read our source code, which just happens to do
things in DIFFERENT ways than NetBSD does ?

As far as the added pages go, they obviously haven't been checked against
actual code as well, hence they're worse than useless, since a large part
of the information is definitely misleading.
@
text
@d1 2
a2 2
.\"	$OpenBSD: audio.9,v 1.1 1999/09/22 03:16:47 csapuntz Exp $
.\"	$NetBSD: audio.9,v 1.13 1999/06/16 14:19:27 kleink Exp $
d4 1
a4 1
.\" Copyright (c) 1999 The NetBSD Foundation, Inc.
d38 1
a38 1
.Dd October 19, 1997
d91 5
d115 1
a115 1
    audio_attach_mi(ahwp, mhwp, hdl, dev)
a116 1
	struct midi_hw_if *mhwp;
d123 1
a123 3
struct is as shown above and the
.Va midi_hw_if
is unused (at the moment).  The 
d365 48
@


1.1
log
@

Add/update some man9 pages from NetBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: audio.9,v 1.13 1999/06/16 14:19:27 kleink Exp $
@

