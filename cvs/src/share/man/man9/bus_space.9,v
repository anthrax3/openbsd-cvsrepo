head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@.\" @;


1.31
date	2015.09.10.15.59.18;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	nVuRWJDyjSSrKiR4;

1.30
date	2014.09.08.01.27.55;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	cPoapLAXYNe1fcgV;

1.29
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.19.08.11.19;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.04.19.27.04;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.29.14.22.09;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.29.01.37.00;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.29.01.31.59;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.29.01.30.43;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.29.01.19.27;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.10.13.03.54;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.18.48.53;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.28.10.26.26;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.23.08.25.06;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.12.12.21.08;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.20.22.12.43;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.26.23.49.58;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.20.18.13.15;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.16.21.23.08;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.16.07.34.57;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.15.04.14.29;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.09.21.14.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.05.14.45.54;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.28.22.14.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.20.45.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.22.00.54.46;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	99.09.22.09.54.37;	author espie;	state dead;
branches;
next	1.1;

1.1
date	99.09.22.03.16.47;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.31
log
@delete bogus trailing comma from .Nm in NAME section
@
text
@.\"	$OpenBSD: bus_space.9,v 1.30 2014/09/08 01:27:55 schwarze Exp $
.\" $NetBSD: bus_space.9,v 1.15 2000/08/09 03:11:00 tv Exp $
.\"
.\" Copyright (c) 1997 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Christopher G. Demetriou.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: September 8 2014 $
.Dt BUS_SPACE 9
.Os
.Sh NAME
.Nm bus_space ,
.Nm bus_space_alloc ,
.Nm bus_space_barrier ,
.Nm bus_space_copy_1 ,
.Nm bus_space_copy_2 ,
.Nm bus_space_copy_4 ,
.Nm bus_space_copy_8 ,
.Nm bus_space_free ,
.Nm bus_space_map ,
.Nm bus_space_mmap ,
.Nm bus_space_read_1 ,
.Nm bus_space_read_2 ,
.Nm bus_space_read_4 ,
.Nm bus_space_read_8 ,
.Nm bus_space_read_multi_1 ,
.Nm bus_space_read_multi_2 ,
.Nm bus_space_read_multi_4 ,
.Nm bus_space_read_multi_8 ,
.\".Nm bus_space_read_raw_multi_1 ,
.Nm bus_space_read_raw_multi_2 ,
.Nm bus_space_read_raw_multi_4 ,
.Nm bus_space_read_raw_multi_8 ,
.Nm bus_space_read_raw_2 ,
.Nm bus_space_read_raw_4 ,
.Nm bus_space_read_raw_8 ,
.Nm bus_space_read_region_1 ,
.Nm bus_space_read_region_2 ,
.Nm bus_space_read_region_4 ,
.Nm bus_space_read_region_8 ,
.\".Nm bus_space_read_raw_region_1 ,
.Nm bus_space_read_raw_region_2 ,
.Nm bus_space_read_raw_region_4 ,
.Nm bus_space_read_raw_region_8 ,
.\".Nm bus_space_read_stream_1 ,
.\".Nm bus_space_read_stream_2 ,
.\".Nm bus_space_read_stream_4 ,
.\".Nm bus_space_read_stream_8 ,
.Nm bus_space_set_multi_1 ,
.Nm bus_space_set_multi_2 ,
.Nm bus_space_set_multi_4 ,
.Nm bus_space_set_multi_8 ,
.Nm bus_space_set_region_1 ,
.Nm bus_space_set_region_2 ,
.Nm bus_space_set_region_4 ,
.Nm bus_space_set_region_8 ,
.Nm bus_space_subregion ,
.Nm bus_space_unmap ,
.Nm bus_space_vaddr ,
.Nm bus_space_write_1 ,
.Nm bus_space_write_2 ,
.Nm bus_space_write_4 ,
.Nm bus_space_write_8 ,
.Nm bus_space_write_multi_1 ,
.Nm bus_space_write_multi_2 ,
.Nm bus_space_write_multi_4 ,
.Nm bus_space_write_multi_8 ,
.\".Nm bus_space_write_raw_multi_1 ,
.Nm bus_space_write_raw_2 ,
.Nm bus_space_write_raw_4 ,
.Nm bus_space_write_raw_8 ,
.Nm bus_space_write_raw_multi_2 ,
.Nm bus_space_write_raw_multi_4 ,
.Nm bus_space_write_raw_multi_8 ,
.Nm bus_space_write_region_1 ,
.Nm bus_space_write_region_2 ,
.Nm bus_space_write_region_4 ,
.Nm bus_space_write_region_8 ,
.\".Nm bus_space_write_raw_region_1 ,
.Nm bus_space_write_raw_region_2 ,
.Nm bus_space_write_raw_region_4 ,
.Nm bus_space_write_raw_region_8
.\".Nm bus_space_write_stream_1 ,
.\".Nm bus_space_write_stream_2 ,
.\".Nm bus_space_write_stream_4 ,
.\".Nm bus_space_write_stream_8 ,
.Nd bus space manipulation functions
.Sh SYNOPSIS
.In machine/bus.h
.Ft int
.Fn bus_space_map "bus_space_tag_t space" "bus_addr_t address" \
"bus_size_t size" "int flags" "bus_space_handle_t *handlep"
.Ft void
.Fn bus_space_unmap "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t size"
.Ft int
.Fn bus_space_subregion "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "bus_size_t size" "bus_space_handle_t *nhandlep"
.Ft int
.Fo bus_space_alloc
.Fa "bus_space_tag_t space" "bus_addr_t reg_start" "bus_addr_t reg_end"
.Fa "bus_size_t size" "bus_size_t alignment" "bus_size_t boundary"
.Fa "int flags" "bus_addr_t *addrp" "bus_space_handle_t *handlep"
.Fc
.Ft void
.Fn bus_space_free "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t size"
.Ft void *
.Fn bus_space_vaddr "bus_space_tag_t space" "bus_space_handle_t handle"
.Ft paddr_t
.Fn bus_space_mmap "bus_space_tag_t space" "bus_addr_t addr" "off_t off" \
"int prot" "int flags"
.Ft u_int8_t
.Fn bus_space_read_1 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset"
.Ft u_int16_t
.Fn bus_space_read_2 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset"
.Ft u_int32_t
.Fn bus_space_read_4 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset"
.Ft u_int64_t
.Fn bus_space_read_8 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset"
.Ft u_int16_t
.Fn bus_space_read_raw_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset"
.Ft u_int32_t
.Fn bus_space_read_raw_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset"
.Ft u_int64_t
.Fn bus_space_read_raw_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset"
.Ft void
.Fn bus_space_write_1 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int8_t value"
.Ft void
.Fn bus_space_write_2 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int16_t value"
.Ft void
.Fn bus_space_write_4 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int32_t value"
.Ft void
.Fn bus_space_write_8 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int64_t value"
.Ft void
.Fn bus_space_write_raw_2 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int16_t value"
.Ft void
.Fn bus_space_write_raw_4 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int32_t value"
.Ft void
.Fn bus_space_write_raw_8 "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "u_int64_t value"
.Ft void
.Fn bus_space_barrier "bus_space_tag_t space" "bus_space_handle_t handle" \
"bus_size_t offset" "bus_size_t length" "int flags"
.Ft void
.Fn bus_space_read_region_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_region_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_region_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_region_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t *datap" \
"bus_size_t count"
.\".Ft void
.\".Fn bus_space_read_raw_region_1 "bus_space_tag_t space" \
.\""bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
.\""bus_size_t count"
.Ft void
.Fn bus_space_read_raw_region_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_raw_region_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_raw_region_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_region_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_region_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int16_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_region_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int32_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_region_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int64_t *datap" \
"bus_size_t count"
.\".Ft void
.\".Fn bus_space_write_raw_region_1 "bus_space_tag_t space" \
.\""bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
.\""bus_size_t count"
.Ft void
.Fn bus_space_write_raw_region_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_raw_region_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_write_raw_region_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_copy_1 "bus_space_tag_t space" \
"bus_space_handle_t srchandle" "bus_size_t srcoffset" \
"bus_space_handle_t dsthandle" "bus_size_t dstoffset" "bus_size_t count"
.Ft void
.Fn bus_space_copy_2 "bus_space_tag_t space" \
"bus_space_handle_t srchandle" "bus_size_t srcoffset" \
"bus_space_handle_t dsthandle" "bus_size_t dstoffset" "bus_size_t count"
.Ft void
.Fn bus_space_copy_4 "bus_space_tag_t space" \
"bus_space_handle_t srchandle" "bus_size_t srcoffset" \
"bus_space_handle_t dsthandle" "bus_size_t dstoffset" "bus_size_t count"
.Ft void
.Fn bus_space_copy_8 "bus_space_tag_t space" \
"bus_space_handle_t srchandle" "bus_size_t srcoffset" \
"bus_space_handle_t dsthandle" "bus_size_t dstoffset" "bus_size_t count"
.Ft void
.Fn bus_space_set_multi_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_multi_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_multi_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_multi_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_region_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_region_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_region_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_set_region_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t value" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_multi_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_multi_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_multi_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t *datap" \
"bus_size_t count"
.Ft void
.Fn bus_space_read_multi_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t *datap" \
"bus_size_t count"
.\".Ft void
.\".Fn bus_space_read_raw_multi_1 "bus_space_tag_t space" \
.\""bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
.\""bus_size_t size"
.Ft void
.Fn bus_space_read_raw_multi_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_read_raw_multi_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_read_raw_multi_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_multi_1 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_multi_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int16_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_multi_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int32_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_multi_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int64_t *datap" \
"bus_size_t size"
.\".Ft void
.\".Fn bus_space_write_raw_multi_1 "bus_space_tag_t space" \
.\""bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
.\""bus_size_t size"
.Ft void
.Fn bus_space_write_raw_multi_2 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_raw_multi_4 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t size"
.Ft void
.Fn bus_space_write_raw_multi_8 "bus_space_tag_t space" \
"bus_space_handle_t handle" "bus_size_t offset" "const u_int8_t *datap" \
"bus_size_t size"
.Sh DESCRIPTION
The
.Nm
functions exist to allow device drivers machine-independent access to
bus memory and register areas.
All of the functions and types described in this document can be used by
including the
.In machine/bus.h
header file.
.Pp
Many common devices are used on multiple architectures, but are accessed
differently on each because of architectural constraints.
For instance, a device which is mapped in one system's I/O space may be
mapped in memory space on a second system.
On a third system, architectural limitations might change the way
registers need to be accessed (e.g. creating a non-linear register
space).
In some cases, a single driver may need to access the same type of
device in multiple ways in a single system or architecture.
The goal of the
.Nm
functions is to allow a single driver source file to manipulate a set of
devices on different system architectures, and to allow a single driver
object file to manipulate a set of devices on multiple bus types on a
single architecture.
.Pp
Not all buses have to implement all functions described in this
document, though that is encouraged if the operations are logically
supported by the bus.
Unimplemented functions should cause compile-time errors if possible.
.Pp
All of the interface definitions described in this document are shown as
function prototypes and discussed as if they were required to be
functions.
Implementations are encouraged to implement prototyped (type-checked)
versions of these interfaces, but may implement them as macros if
appropriate.
Machine-dependent types, variables, and functions should be marked
clearly in
.In machine/bus.h
to avoid confusion with the machine-independent types and functions,
and, if possible, should be given names which make the
machine-dependence clear.
.Sh CONCEPTS AND GUIDELINES
Bus spaces are described by bus space tags, which can be created only by
machine-dependent code.
A given machine may have several different types of bus space (e.g.\&
memory space and I/O space), and thus may provide multiple different bus
space tags.
Individual buses or devices on a machine may use more than one bus
space tag.
For instance, ISA devices are given an ISA memory space tag and an ISA
I/O space tag.
Architectures may have several different tags which represent the same
type of space, for instance because of multiple different host bus
interface chipsets.
.Pp
A range in bus space is described by a bus address and a bus size.
The bus address describes the start of the range in bus space.
The bus size describes the size of the range in bytes.
Buses which are not byte addressable may require use of bus space
ranges with appropriately aligned addresses and properly rounded sizes.
.Pp
Access to regions of bus space is facilitated by use of bus space
handles, which are usually created by mapping a specific range of a bus
space.
Handles may also be created by allocating and mapping a range of bus
space, the actual location of which is picked by the implementation
within bounds specified by the caller of the allocation function.
.Pp
All of the bus space access functions require one bus space tag
argument, at least one handle argument, and at least one offset argument
(a bus size).
The bus space tag specifies the space, each handle specifies a region in
the space, and each offset specifies the offset into the region of the
actual location(s) to be accessed.
Offsets are given in bytes, though buses may impose alignment constraints.
The offset used to access data relative to a given handle must be such
that all of the data being accessed is in the mapped region that the
handle describes.
Trying to access data outside that region is an error.
.Pp
Because some architectures' memory systems use buffering to improve
memory and device access performance, there is a mechanism which can be
used to create
.Dq barriers
in the bus space read and write stream.
There are three types of barriers: read, write, and read/write.
All reads started to the region before a read barrier must complete
before any reads after the read barrier are started.
The analogous requirement is true for write barriers.
Read/write barriers force all reads and writes started before the
barrier to complete before any reads or writes after the barrier are
started.
Correctly-written drivers will include all appropriate barriers, and
assume only the read/write ordering imposed by the barrier operations.
.Pp
People trying to write portable drivers with the
.Nm
functions should try to make minimal assumptions about what the system
allows.
In particular, they should expect that the system requires bus space
addresses being accessed to be naturally aligned (i.e. base address of
handle added to offset is a multiple of the access size), and that the
system does alignment checking on pointers (i.e. pointer to objects
being read and written must point to properly-aligned data).
.Pp
The descriptions of the
.Nm
functions given below all assume that they are called with proper
arguments.
If called with invalid arguments or arguments that are out of range
(e.g. trying to access data outside of the region mapped when a given
handle was created), undefined behaviour results.
In that case, they may cause the system to halt, either intentionally
(via panic) or unintentionally (by causing a fatal trap or by some other
means) or may cause improper operation which is not immediately fatal.
Functions which return void or which return data read from bus space
(i.e. functions which don't obviously return an error code) do not
fail.
They could only fail if given invalid arguments, and in that case their
behaviour is undefined.
Functions which take a count of bytes have undefined results if the
specified
.Fa count
is zero.
.Sh TYPES
Several types are defined in
.In machine/bus.h
to facilitate use of the
.Nm
functions by drivers.
.Pp
.Bl -ohang -compact
.It Fa bus_addr_t
.Pp
The
.Fa bus_addr_t
type is used to describe bus addresses.
It must be an unsigned integral type capable of holding the largest bus
address usable by the architecture.
This type is primarily used when mapping and unmapping bus space.
.Pp
.It Fa bus_size_t
.Pp
The
.Fa bus_size_t
type is used to describe sizes of ranges in bus space.
It must be an unsigned integral type capable of holding the size of the
largest bus address range usable on the architecture.
This type is used by virtually all of the
.Nm
functions, describing sizes when mapping regions and offsets into
regions when performing space access operations.
.Pp
.It Fa bus_space_tag_t
.Pp
The
.Fa bus_space_tag_t
type is used to describe a particular bus space on a machine.
Its contents are machine-dependent and should be considered opaque by
machine-independent code.
This type is used by all
.Nm
functions to name the space on which they're operating.
.Pp
.It Fa bus_space_handle_t
.Pp
The
.Fa bus_space_handle_t
type is used to describe a mapping of a range of bus space.
Its contents are machine-dependent and should be considered opaque by
machine-independent code.
This type is used when performing bus space access operations.
.El
.Sh MAPPING AND UNMAPPING BUS SPACE
Bus space must be mapped before it can be used, and should be unmapped
when it is no longer needed.
The
.Fn bus_space_map
and
.Fn bus_space_unmap
functions provide these capabilities.
.Pp
Some drivers need to be able to pass a subregion of already-mapped bus
space to another driver or module within a driver.
The
.Fn bus_space_subregion
function allows such subregions to be created.
.Pp
.Bl -ohang -compact
.It Fn bus_space_map "space" "address" "size" "flags" "handlep"
.Pp
The
.Fn bus_space_map
function maps the region of bus space named by the
.Fa space ,
.Fa address ,
and
.Fa size
arguments.
If successful, it returns zero and fills in the bus space handle pointed
to by
.Fa handlep
with the handle that can be used to access the mapped region.
If unsuccessful, it will return non-zero and leave the bus space handle
pointed to by
.Fa handlep
in an undefined state.
.Pp
The
.Fa flags
argument controls how the space is to be mapped.
Supported flags include:
.Bl -tag -width BUS_SPACE_MAP_CACHEABLE -offset indent
.It Dv BUS_SPACE_MAP_CACHEABLE
Try to map the space so that access can be cached by the system cache.
If this flag is not specified, the implementation should map the space
so that it will not be cached.
This mapping method will only be useful in very rare occasions.
.Pp
This flag must have a value of 1 on all implementations for backward
compatibility.
.It Dv BUS_SPACE_MAP_PREFETCHABLE
Try to map the space so that accesses can be prefetched by the system,
and writes can be buffered.
This means, accesses should be side effect free (idempotent).
The
.Fn bus_space_barrier
methods will flush the write buffer or force actual read accesses.
If this flag is not specified, the
implementation should map the space so that it will not be prefetched
or delayed.
.It Dv BUS_SPACE_MAP_LINEAR
Try to map the space so that its contents can be accessed linearly via
normal memory access methods (e.g. pointer dereferencing and structure
accesses).
The
.Fn bus_space_vaddr
method can be used to obtain the kernel virtual address of the mapped range.
This is useful when software wants to do direct access to a memory
device, e.g. a frame buffer.
If this flag is specified and linear mapping is not possible, the
.Fn bus_space_map
call should fail.
If this
flag is not specified, the system may map the space in whatever way is
most convenient.
Use of this mapping method is not encouraged for normal device access;
where linear access is not essential, use of the
.Fn bus_space_read/write
methods is strongly recommended.
.El
.Pp
.\"Not all combinations of flags make sense or are supported with all
.\"spaces.
.\"For instance,
.Dv BUS_SPACE_MAP_CACHEABLE
may be meaningless when used on many systems' I/O port spaces.
and on some systems
.Dv BUS_SPACE_MAP_LINEAR
without
.Dv BUS_SPACE_MAP_PREFETCHABLE
may never work.
When the system hardware or firmware provides hints as to how spaces should be
mapped (e.g. the PCI memory mapping registers' "prefetchable" bit), those
hints should be followed for maximum compatibility.
On some systems,
requesting a mapping that cannot be satisfied (e.g. requesting a
non-prefetchable mapping when the system can only provide a prefetchable one)
will cause the request to fail.
.Pp
Some implementations may keep track of use of bus space for some or all
bus spaces and refuse to allow duplicate allocations.
This is encouraged for bus spaces which have no notion of slot-specific
space addressing, such as ISA and VME, and for spaces which coexist with
those spaces (e.g. EISA and PCI memory and I/O spaces coexisting with
ISA memory and I/O spaces).
.Pp
Mapped regions may contain areas for which there is no device on the bus.
If space in those areas is accessed, the results are bus-dependent.
.Pp
.It Fn bus_space_unmap "space" "handle" "size"
.Pp
The
.Fn bus_space_unmap
function unmaps a region of bus space mapped with
.Fn bus_space_map .
When unmapping a region, the
.Fa size
specified should be the same as the size given to
.Fn bus_space_map
when mapping that region.
.Pp
After
.Fn bus_space_unmap
is called on a handle, that handle is no longer valid.
If copies were made of the handle they are no longer valid, either.
.Pp
This function will never fail.
If it would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case,
.Fn bus_space_unmap
will never return.
.Pp
.It Fn bus_space_subregion "space" "handle" "offset" "size" "nhandlep"
.Pp
The
.Fn bus_space_subregion
function is a convenience function which makes a new handle to some
subregion of an already-mapped region of bus space.
The subregion described by the new handle starts at byte offset
.Fa offset
into the region described by
.Fa handle ,
with the size give by
.Fa size ,
and must be wholly contained within the original region.
.Pp
If successful,
.Fn bus_space_subregion
returns zero and fills in the bus space handle pointed to by
.Fa nhandlep .
If unsuccessful, it returns non-zero and leaves the bus space handle
pointed to by
.Fa nhandlep
in an undefined state.
In either case, the handle described by
.Fa handle
remains valid and is unmodified.
.Pp
When done with a handle created by
.Fn bus_space_subregion ,
the handle should be thrown away.
Under no circumstances should
.Fn bus_space_unmap
be used on the handle.
Doing so may confuse any resource management being done on the space,
and will result in undefined behaviour.
When
.Fn bus_space_unmap
or
.Fn bus_space_free
is called on a handle, all subregions of that handle become invalid.
.Pp
.It Fn bus_space_vaddr "tag" "handle"
.Pp
This method returns the kernel virtual address of a mapped bus space if and
only if it was mapped with the
.Dv BUS_SPACE_MAP_LINEAR
flag.
The range can be accessed by normal (volatile) pointer dereferences.
If mapped with the
.Dv BUS_SPACE_MAP_PREFETCHABLE
flag, the
.Fn bus_space_barrier
method must be used to force a particular access order.
.Pp
.It Fn bus_space_mmap "tag" "addr" "off" "prot" "flags"
.Pp
This method is used to provide support for memory mapping bus space
into user applications.
If an address space is addressable via volatile pointer dereferences,
.Fn bus_space_mmap
will return the physical address (possibly encoded as a machine-dependent
cookie) of the bus space indicated by
.Fa addr
and
.Fa off .
.Fa addr
is the base address of the device or device region, and
.Fa off
is the offset into that region that is being requested.
If the region cannot be mapped (either the address does not exist,
or the constraints cannot be met),
.Fn bus_space_mmap
returns \-1 to indicate failure.
.Pp
Note that it is not necessary that the region being requested by a
.Fn bus_space_mmap
call be mapped into a
.Fa bus_space_handle_t .
.Pp
.Fn bus_space_mmap
is called once per
.Dv PAGE_SIZE
page in the range.
The
.Fa prot
argument indicates the memory protection requested by the user application
for the range.
.El
.Sh ALLOCATING AND FREEING BUS SPACE
Some devices require or allow bus space to be allocated by the operating
system for device use.
When the devices no longer need the space, the operating system should
free it for use by other devices.
The
.Fn bus_space_alloc
and
.Fn bus_space_free
functions provide these capabilities.
.Pp
.Bl -ohang -compact
.It Xo
.Fo bus_space_alloc
.Fa "space" "reg_start" "reg_end" "size"
.Fa "alignment" "boundary" "flags" "addrp" "handlep"
.Fc
.Xc
.Pp
The
.Fn bus_space_alloc
function allocates and maps a region of bus space with the size given by
.Fa size ,
corresponding to the given constraints.
If successful, it returns zero, fills in the bus address pointed to by
.Fa addrp
with the bus space address of the allocated region, and fills in the bus
space handle pointed to by
.Fa handlep
with the handle that can be used to access that region.
If unsuccessful, it returns non-zero and leaves the bus address pointed
to by
.Fa addrp
and the bus space handle pointed to by
.Fa handlep
in an undefined state.
.Pp
Constraints on the allocation are given by the
.Fa reg_start ,
.Fa reg_end ,
.Fa alignment ,
and
.Fa boundary
parameters.
The allocated region will start at or after
.Fa reg_start
and end before or at
.Fa reg_end .
The
.Fa alignment
constraint must be a power of two, and the allocated region will start
at an address that is an even multiple of that power of two.
The
.Fa boundary
constraint, if non-zero, ensures that the region is allocated so that
.Fa "first address in region"
/
.Fa boundary
has the same value as
.Fa "last address in region"
/
.Fa boundary .
If the constraints cannot be met,
.Fn bus_space_alloc
will fail.
It is an error to specify a set of constraints that can never be met
.Po
for example,
.Fa size
greater than
.Fa boundary
.Pc .
.Pp
The
.Fa flags
parameter is the same as the like-named parameter to
.Fn bus_space_map ,
the same flag values should be used, and they have the same meanings.
.Pp
Handles created by
.Fn bus_space_alloc
should only be freed with
.Fn bus_space_free .
Trying to use
.Fn bus_space_unmap
on them causes undefined behaviour.
The
.Fn bus_space_subregion
function can be used on handles created by
.Fn bus_space_alloc .
.Pp
.It Fn bus_space_free "space" "handle" "size"
.Pp
The
.Fn bus_space_free
function unmaps and frees a region of bus space mapped and allocated
with
.Fn bus_space_alloc .
When unmapping a region, the
.Fa size
specified should be the same as the size given to
.Fn bus_space_alloc
when allocating the region.
.Pp
After
.Fn bus_space_free
is called on a handle, that handle is no longer valid.
If copies were made of the handle, they are no longer valid, either.
.Pp
This function will never fail.
If it would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case,
.Fn bus_space_free
will never return.
.El
.Sh READING AND WRITING SINGLE DATA ITEMS
The simplest way to access bus space is to read or write a single data
item.
The
.Fn bus_space_read_N
and
.Fn bus_space_write_N
families of functions provide the ability to read and write 1, 2, 4, and
8 byte data items on buses which support those access sizes.
.Pp
.Bl -ohang -compact
.It Fn bus_space_read_1 "space" "handle" "offset"
.It Fn bus_space_read_2 "space" "handle" "offset"
.It Fn bus_space_read_4 "space" "handle" "offset"
.It Fn bus_space_read_8 "space" "handle" "offset"
.Pp
The
.Fn bus_space_read_N
family of functions reads a 1, 2, 4, or 8 byte data item from
the offset specified by
.Fa offset
into the region specified by
.Fa handle
of the bus space specified by
.Fa space .
The location being read must lie within the bus space region specified
by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data item being
read.
On some systems, not obeying this requirement may cause incorrect data
to be read, on others it may cause a system crash.
.Pp
Read operations done by the
.Fn bus_space_read_N
functions may be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_write_1 "space" "handle" "offset" "value"
.It Fn bus_space_write_2 "space" "handle" "offset" "value"
.It Fn bus_space_write_4 "space" "handle" "offset" "value"
.It Fn bus_space_write_8 "space" "handle" "offset" "value"
.Pp
The
.Fn bus_space_write_N
family of functions writes a 1, 2, 4, or 8 byte data item to the offset
specified by
.Fa offset
into the region specified by
.Fa handle
of the bus space specified by
.Fa space .
The location being written must lie within the bus space region
specified by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data item being
written.
On some systems, not obeying this requirement may cause incorrect data
to be written, on others it may cause a system crash.
.Pp
Write operations done by the
.Fn bus_space_write_N
functions may be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.El
.Sh BARRIERS
In order to allow high-performance buffering implementations to avoid
bus activity on every operation, read and write ordering should be
specified explicitly by drivers when necessary.
The
.Fn bus_space_barrier
function provides that ability.
.Pp
.Bl -ohang -compact
.It Fn bus_space_barrier "space" "handle" "offset" "length" "flags"
.Pp
The
.Fn bus_space_barrier
function enforces ordering of bus space read and write operations for
the specified subregion (described by the
.Fa offset
and
.Fa length
parameters) of the region named by
.Fa handle
in the space named by
.Fa space .
.Pp
The
.Fa flags
argument controls what types of operations are to be ordered.
Supported flags are:
.Bl -tag -width BUS_SPACE_BARRIER_WRITE -offset indent
.It Dv BUS_SPACE_BARRIER_READ
Synchronize read operations.
.It Dv BUS_SPACE_BARRIER_WRITE
Synchronize write operations.
.El
.Pp
Those flags can be combined (or-ed together) to enforce ordering on both
read and write operations.
.Pp
All of the specified type(s) of operation which are done to the region
before the barrier operation are guaranteed to complete before any of
the specified type(s) of operation done after the barrier.
.Pp
Example: Consider a hypothetical device with two single-byte ports, one
write-only input port (at offset 0) and a read-only output port (at
offset 1).
Operation of the device is as follows: data bytes are written to the
input port, and are placed by the device on a stack, the top of which is
read by reading from the output port.
The sequence to correctly write two data bytes to the device then read
those two data bytes back would be:
.Bd -literal
/*
 * t and h are the tag and handle for the mapped device's
 * space.
 */
bus_space_write_1(t, h, 0, data0);
bus_space_barrier(t, h, 0, 1, BUS_SPACE_BARRIER_WRITE);  /* 1 */
bus_space_write_1(t, h, 0, data1);
bus_space_barrier(t, h, 0, 2,
    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);     /* 2 */
ndata1 = bus_space_read_1(t, h, 1);
bus_space_barrier(t, h, 1, 1, BUS_SPACE_BARRIER_READ);   /* 3 */
ndata0 = bus_space_read_1(t, h, 1);
/* data0 == ndata0, data1 == ndata1 */
.Ed
.Pp
The first barrier makes sure that the first write finishes before the
second write is issued, so that two writes to the input port are done in
order and are not collapsed into a single write.
This ensures that the data bytes are written to the device correctly and
in order.
.Pp
The second barrier makes sure that the writes to the output port finish
before any of the reads to the input port are issued, thereby making
sure that all of the writes are finished before data is read.
This ensures that the first byte read from the device really is the last
one that was written.
.Pp
The third barrier makes sure that the first read finishes before the
second read is issued, ensuring that data is read correctly and in order.
.Pp
The barriers in the example above are specified to cover the absolute
minimum number of bus space locations.
It is correct (and often easier) to make barrier operations cover the
device's whole range of bus space, that is, to specify an offset of zero
and the size of the whole region.
.El
.Sh REGION OPERATIONS
Some devices use buffers which are mapped as regions in bus space.
Often, drivers want to copy the contents of those buffers to or from
memory, e.g. into mbufs which can be passed to higher levels of the
system or from mbufs to be output to a network.
In order to allow drivers to do this as efficiently as possible, the
.Fn bus_space_read_region_N
and
.Fn bus_space_write_region_N
families of functions are provided.
.Pp
Drivers occasionally need to copy one region of a bus space to another,
or to set all locations in a region of bus space to contain a single
value.
The
.Fn bus_space_copy_N
family of functions and the
.Fn bus_space_set_region_N
family of functions allow drivers to perform these operations.
.Pp
.Bl -ohang -compact
.It Fn bus_space_read_region_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_region_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_region_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_region_8 "space" "handle" "offset" "datap" "count"
.Pp
The
.Fn bus_space_read_region_N
family of functions reads
.Fa count
1, 2, 4, or 8 byte data items from bus space starting at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space
and writes them into the array specified by
.Fa datap .
Each successive data item is read from an offset
1, 2, 4, or 8 bytes after the previous data item (depending on which
function is used).
All locations being read must lie within the bus space region specified
by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data items being
read and the data array pointer should be properly aligned.
On some systems, not obeying these requirements may cause incorrect data
to be read, on others it may cause a system crash.
.Pp
Read operations done by the
.Fn bus_space_read_region_N
functions may be executed in any order.
They may also be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
There is no way to insert barriers between reads of individual bus space
locations executed by the
.Fn bus_space_read_region_N
functions.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_write_region_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_region_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_region_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_region_8 "space" "handle" "offset" "datap" "count"
.Pp
The
.Fn bus_space_write_region_N
family of functions reads
.Fa count
1, 2, 4, or 8 byte data items from the array specified by
.Fa datap
and writes them to bus space starting at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space .
Each successive data item is written to an offset 1, 2, 4, or 8 bytes
after the previous data item (depending on which function is used).
All locations being written must lie within the bus space region
specified by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data items being
written and the data array pointer should be properly aligned.
On some systems, not obeying these requirements may cause incorrect data
to be written, on others it may cause a system crash.
.Pp
Write operations done by the
.Fn bus_space_write_region_N
functions may be executed in any order.
They may also be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
There is no way to insert barriers between writes of individual bus
space locations executed by the
.Fn bus_space_write_region_N
functions.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_copy_1 "space" "srchandle" "srcoffset" "dsthandle" \
"dstoffset" "count"
.It Fn bus_space_copy_2 "space" "srchandle" "srcoffset" "dsthandle" \
"dstoffset" "count"
.It Fn bus_space_copy_4 "space" "srchandle" "srcoffset" "dsthandle" \
"dstoffset" "count"
.It Fn bus_space_copy_8 "space" "srchandle" "srcoffset" "dsthandle" \
"dstoffset" "count"
.Pp
The
.Fn bus_space_copy_N
family of functions copies
.Fa count
1, 2, 4, or 8 byte data items in bus space from the area starting at
byte offset
.Fa srcoffset
in the region specified by
.Fa srchandle
of the bus space specified by
.Fa space
to the area starting at byte offset
.Fa dstoffset
in the region specified by
.Fa dsthandle
in the same bus space.
Each successive data item read or written has an offset 1, 2, 4, or 8
bytes after the previous data item (depending on which function is
used).
All locations being read and written must lie within the bus space
region specified by their respective handles.
.Pp
For portability, the starting addresses of the regions specified by
each handle plus its respective offset should be a multiple of the size
of data items being copied.
On some systems, not obeying this requirement may cause incorrect data
to be copied, on others it may cause a system crash.
.Pp
Read and write operations done by the
.Fn bus_space_copy_N
functions may be executed in any order.
They may also be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier function .
There is no way to insert barriers between reads or writes of individual
bus space locations executed by the
.Fn bus_space_copy_N
functions.
.Pp
Overlapping copies between different subregions of a single region of
bus space are handled correctly by the
.Fn bus_space_copy_N
functions.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_set_region_1 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_region_2 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_region_4 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_region_8 "space" "handle" "offset" "value" "count"
.Pp
The
.Fn bus_space_set_region_N
family of functions writes the given
.Fa value
to
.Fa count
1, 2, 4, or 8 byte data items in bus space starting at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space .
Each successive data item has an offset 1, 2, 4, or 8 bytes after the
previous data item (depending on which function is used).
All locations being written must lie within the bus space region
specified by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data items being
written.
On some systems, not obeying this requirement may cause incorrect data
to be written, on others it may cause a system crash.
.Pp
Write operations done by the
.Fn bus_space_set_region_N
functions may be executed in any order.
They may also be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
There is no way to insert barriers between writes of individual bus
space locations executed by the
.Fn bus_space_set_region_N
functions.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.El
.Sh READING AND WRITING A SINGLE LOCATION MULTIPLE TIMES
Some devices implement single locations in bus space which are to be
read or written multiple times to communicate data, e.g. some Ethernet
devices' packet buffer FIFOs.
In order to allow drivers to manipulate these types of devices as
efficiently as possible, the
.Fn bus_space_read_multi_N ,
.Fn bus_space_write_multi_N ,
and
.Fn bus_space_set_multi_N
families of functions are provided.
.Pp
.Bl -ohang -compact
.It Fn bus_space_read_multi_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_multi_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_multi_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_multi_8 "space" "handle" "offset" "datap" "count"
.Pp
The
.Fn bus_space_read_multi_N
family of functions reads
.Fa count
1, 2, 4, or 8 byte data items from bus space at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space
and writes them into the array specified by
.Fa datap .
Each successive data item is read from the same location in bus space.
The location being read must lie within the bus space region specified
by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data items being
read and the data array pointer should be properly aligned.
On some systems, not obeying these requirements may cause incorrect data
to be read, on others it may cause a system crash.
.Pp
Read operations done by the
.Fn bus_space_read_multi_N
functions may be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
Because the
.Fn bus_space_read_multi_N
functions read the same bus space location multiple times, they place an
implicit read barrier between each successive read of that bus space
location.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_write_multi_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_multi_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_multi_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_multi_8 "space" "handle" "offset" "datap" "count"
.Pp
The
.Fn bus_space_write_multi_N
family of functions reads
.Fa count
1, 2, 4, or 8 byte data items from the array specified by
.Fa datap
and writes them into bus space at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space .
Each successive data item is written to the same location in bus space.
The location being written must lie within the bus space region
specified by
.Fa handle .
.Pp
For portability, the starting address of the region specified by
.Fa handle
plus the offset should be a multiple of the size of data items being
written and the data array pointer should be properly aligned.
On some systems, not obeying these requirements may cause incorrect data
to be written, on others it may cause a system crash.
.Pp
Write operations done by the
.Fn bus_space_write_multi_N
functions may be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
Because the
.Fn bus_space_write_multi_N
functions write the same bus space location multiple times, they place
an implicit write barrier between each successive write of that bus
space location.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.Pp
.It Fn bus_space_set_multi_1 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_multi_2 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_multi_4 "space" "handle" "offset" "value" "count"
.It Fn bus_space_set_multi_8 "space" "handle" "offset" "value" "count"
.Pp
The
.Fn bus_space_set_multi_N
family of functions writes the 1, 2, 4, or 8 byte value
.Fa value
into bus space
.Fa count
times at byte offset
.Fa offset
in the region specified by
.Fa handle
of the bus space specified by
.Fa space .
The location being written must lie within the bus space region
specified by
.Fa handle .
.Pp
For portability, the address specified by
.Fa handle
plus the offset should be a multiple of the size of the data value being
written.
On some systems, not obeying these requirements may cause
incorrect data to be written, on others it may cause a system crash.
.Pp
Write operations done by the
.Fn bus_space_set_multi_N
functions may be executed out of order with respect to other pending
read and write operations unless order is enforced by use of the
.Fn bus_space_barrier
function.
Because the
.Fn bus_space_set_multi_N
functions write the same bus space location multiple times, they place
an implicit write barrier between each successive write of that bus
space location.
.Pp
These functions will never fail.
If they would fail (e.g. because of an argument error), that indicates a
software bug which should cause a panic.
In that case, they will never return.
.El
.Sh RAW FUNCTIONS
Most of the
.Nm
functions imply a host byte-order and a bus byte-order and take care of
any translation for the caller.
In some cases, however, hardware may map a FIFO or some other memory
region for which the caller may want to use untranslated access.
Access to these types of memory regions should be with the following functions.
.Pp
.Bl -ohang -compact
.It Fn bus_space_read_raw_2 "space" "handle" "offset"
.It Fn bus_space_read_raw_4 "space" "handle" "offset"
.It Fn bus_space_read_raw_8 "space" "handle" "offset"
.It Fn bus_space_write_raw_2 "space" "handle" "offset" "value"
.It Fn bus_space_write_raw_4 "space" "handle" "offset" "value"
.It Fn bus_space_write_raw_8 "space" "handle" "offset" "value"
.El
.Pp
The
.Fn bus_space_{read,write}_raw_N
functions take the same arguments and return the same types as their
non-raw counterparts, but do not do any translation of the values.
.Pp
.Bl -ohang -compact
.\".It Fn bus_space_read_stream_1 "space" "handle" "offset"
.\".It Fn bus_space_read_stream_2 "space" "handle" "offset"
.\".It Fn bus_space_read_stream_4 "space" "handle" "offset"
.\".It Fn bus_space_read_stream_8 "space" "handle" "offset"
.\".It Fn bus_space_read_raw_multi_1 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_multi_2 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_multi_4 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_multi_8 "space" "handle" "offset" "datap" "size"
.\".It Fn bus_space_read_raw_region_1 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_region_2 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_region_4 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_read_raw_region_8 "space" "handle" "offset" "datap" "size"
.\".It Fn bus_space_write_stream_1 "space" "handle" "offset" "value"
.\".It Fn bus_space_write_stream_2 "space" "handle" "offset" "value"
.\".It Fn bus_space_write_stream_4 "space" "handle" "offset" "value"
.\".It Fn bus_space_write_stream_8 "space" "handle" "offset" "value"
.\".It Fn bus_space_write_raw_multi_1 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_multi_2 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_multi_4 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_multi_8 "space" "handle" "offset" "datap" "size"
.\".It Fn bus_space_write_raw_region_1 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_region_2 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_region_4 "space" "handle" "offset" "datap" "size"
.It Fn bus_space_write_raw_region_8 "space" "handle" "offset" "datap" "size"
.El
.Pp
These functions, unlike their non-raw counterparts, all take a
u_int8_t pointer for the
.Fa datap
argument and a byte count for the
.Fa size
argument regardless of the access width being requested.
.Pp
.Fa datap
must reference a buffer that is correctly aligned for the
access width being requested or the results are undefined.
.Pp
.Fa size
must be a multiple of the access width or the results are undefined.
.Pp
In all other respects these functions are the same as their non-raw
counterparts.
Please consult the documentation for those functions for further
information.
.Sh SEE ALSO
.Xr bus_dma 9
.Sh HISTORY
The
.Nm
functions were introduced in a different form (memory and I/O spaces
were accessed via different sets of functions) in
.Nx 1.2 .
The functions were merged to work on generic
.Dq spaces
early in the
.Nx 1.3
development cycle, and many drivers were converted to use them.
This document was written later during the
.Nx 1.3
development cycle and the specification was updated to fix some
consistency problems and to add some missing functionality.
.Pp
The
.Ox
development team added the *_raw_* API, and discarded the *_stream_*
API.
.Sh AUTHORS
.An -nosplit
The
.Nm
interfaces were designed and implemented by the
.Nx
developer community.
Primary contributors and implementors were
.An Chris Demetriou ,
.An Jason Thorpe ,
and
.An Charles Hannum ,
but the rest of the
.Nx
developers and the user community played a significant role in
development.
.Pp
.An Chris Demetriou
wrote this manual page.
.Pp
.An Niklas Hallqvist
did the *_raw_* API for
.Ox .
@


1.30
log
@obvious cases of missing .An;
found with the new mandoc(1) MANDOCERR_AN_MISSING warning;
no text changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.29 2014/01/21 03:15:46 schwarze Exp $
d31 1
a31 1
.Dd $Mdocdate: January 21 2014 $
d105 1
a105 1
.Nm bus_space_write_raw_region_8 ,
@


1.29
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.28 2014/01/19 08:11:19 schwarze Exp $
d31 1
a31 1
.Dd $Mdocdate: January 19 2014 $
d1499 1
d1505 6
a1510 2
Primary contributors and implementors were Chris Demetriou, Jason
Thorpe, and Charles Hannum, but the rest of the
d1515 2
a1516 1
Chris Demetriou wrote this manual page.
d1518 2
a1519 1
Niklas Hallqvist did the *_raw_* API for
@


1.28
log
@Fix obvious typo in macro, bus_space_map() is .Fn, not .Fa.
Found with mandocdb(8).
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.27 2013/06/04 19:27:04 schwarze Exp $
d31 1
a31 1
.Dd $Mdocdate: June 4 2013 $
d364 1
a364 1
.Aq Pa machine/bus.h
d396 1
a396 1
.Aq Pa machine/bus.h
d485 1
a485 1
.Aq Pa machine/bus.h
@


1.27
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.26 2013/01/29 14:22:09 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate: January 29 2013 $
d826 1
a826 1
.Fa bus_space_map ,
@


1.26
log
@zap trailing whitespace;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.25 2013/01/29 01:37:00 dlg Exp $
d112 1
a112 1
.Fd #include <machine/bus.h>
@


1.25
log
@remove the EXPECTED CHANGES TO THE BUS_SPACE FUNCTIONS section. talk is
cheap, if we wanted this stuff there'd be a diff by now.

requested by miod@@ and kettenis@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.23 2013/01/29 01:30:43 dlg Exp $
d150 1
a150 1
"bus_space_handle_t handle" "bus_size_t offset" 
@


1.24
log
@useless comments are useless
@
text
@a1475 49
.Sh EXPECTED CHANGES TO THE BUS_SPACE FUNCTIONS
The definition of the
.Nm
functions should not yet be considered finalized.
There are several changes and improvements which should be explored,
including:
.Bl -bullet
.It
Providing a mechanism by which incorrectly-written drivers will be
automatically given barriers and properly-written drivers won't be
forced to use more barriers than they need.
This should probably be done via a
.Li #define
in the incorrectly-written drivers.
Unfortunately, at this time, few drivers actually use barriers correctly
(or at all).
Because of that,
.Nm
implementations on architectures which do buffering must always do the
barriers inside the
.Nm
calls, to be safe.
That has a potentially significant performance impact.
.It
Exporting the
.Nm
functions to user-land so that applications (such as X servers) have
easier, more portable access to device space.
.It
Redefining bus space tags and handles so that machine-independent bus
interface drivers (for example PCI to VME bridges) could define and
implement bus spaces without requiring machine-dependent code.
If this is done, it should be done in such a way that machine-dependent
optimizations should remain possible.
.It
Converting bus spaces (such as PCI configuration space) which currently
use space-specific access methods to use the
.Nm
functions where that is appropriate.
.It
Redefining the way bus space is mapped and allocated, so that mapping
and allocation are done with bus specific functions which return bus
space tags.
This would allow further optimization than is currently possible, and
would also ease translation of the
.Nm
functions into user space (since mapping in user space would look like
it just used a different bus-specific mapping function).
.El
@


1.23
log
@bus_space_{read,write}_N dont take different arguments to their non raw
counterparts, so list them separately to the ones that do.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.22 2013/01/29 01:19:27 dlg Exp $
a1526 13
.\".Sh STANDARDS
.\".Pp
.\"The current version of the
.\".Nm
.\"interface specification differs slightly from the original
.\"specification that came into wide use.
.\"A few of the function names and arguments have changed
.\"for consistency and increased functionality.
.\"Drivers that were written to the
.\"old, deprecated specification can be compiled by defining the
.\".Dv __BUS_SPACE_COMPAT_OLDDEFS
.\"preprocessor symbol before including
.\".Pa Aq machine/bus.h .
@


1.22
log
@document bus_space_{read,write}_raw_N(). needs some polishing...
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.21 2012/12/10 13:03:54 mpi Exp $
d31 1
a31 1
.Dd $Mdocdate: December 10 2012 $
d1415 15
a1429 3
Access to these types of memory regions should be with the
.Fn bus_space_{read,write}_raw_*N
functions.
a1436 3
.It Fn bus_space_read_raw_2 "space" "handle" "offset"
.It Fn bus_space_read_raw_4 "space" "handle" "offset"
.It Fn bus_space_read_raw_8 "space" "handle" "offset"
a1448 3
.It Fn bus_space_write_raw_2 "space" "handle" "offset" "value"
.It Fn bus_space_write_raw_4 "space" "handle" "offset" "value"
.It Fn bus_space_write_raw_8 "space" "handle" "offset" "value"
@


1.21
log
@Document bus_space_mmap(9) from NetBSD with some tweaks by jmc@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.20 2009/07/26 18:48:53 miod Exp $
d31 1
a31 1
.Dd $Mdocdate: July 26 2009 $
d57 3
d92 3
d148 9
d170 9
d1414 1
a1414 2
region for which the caller may want to use multi-word, yet untranslated
access.
d1416 1
a1416 1
.Fn bus_space_*_raw_*_N
d1425 3
d1440 3
@


1.20
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.19 2008/06/26 05:42:08 ray Exp $
d31 1
a31 1
.Dd $Mdocdate: June 26 2008 $
d44 1
d127 3
d691 34
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.18 2007/05/31 19:20:00 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate: May 31 2007 $
d108 1
a108 1
"bus_size_t size" "int cacheable" "bus_space_handle_t *handlep"
d119 1
a119 1
.Fa "int cacheable" "bus_addr_t *addrp" "bus_space_handle_t *handlep"
d520 1
a520 1
.It Fn bus_space_map "space" "address" "size" "cacheable" "handlep"
d540 1
a540 1
.Fa cacheable
d703 1
a703 1
.Fa "alignment" "boundary" "cacheable" "addrp" "handlep"
d762 1
a762 1
.Fa cacheable
@


1.18
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.17 2006/10/28 10:26:26 jmc Exp $
a17 7
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgment:
.\" 	This product includes software developed by the NetBSD
.\" 	Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
d31 1
a31 1
.Dd $Mdocdate$
@


1.17
log
@prefer `buses' to `busses' for the noun plural;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.16 2005/08/23 08:25:06 jmc Exp $
d38 1
a38 1
.Dd November 20, 2000
@


1.16
log
@heh, two different spellings in the same sentence: co-exist and coexist;
prefer coexist, since all other man pages do too, and oxford agree.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.15 2005/03/12 12:21:08 jmc Exp $
d362 1
a362 1
Not all busses have to implement all functions described in this
d385 1
a385 1
Individual busses or devices on a machine may use more than one bus
d396 1
a396 1
Busses which are not byte addressable may require use of bus space
d412 1
a412 1
Offsets are given in bytes, though busses may impose alignment constraints.
d819 1
a819 1
8 byte data items on busses which support those access sizes.
@


1.15
log
@escape `.' at eol to avoid double spacing issue;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.14 2004/12/20 22:12:43 jsg Exp $
d612 1
a612 1
those spaces (e.g. EISA and PCI memory and I/O spaces co-existing with
@


1.14
log
@ethernet -> Ethernet
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.13 2004/11/26 23:49:58 marco Exp $
d382 1
a382 1
A given machine may have several different types of bus space (e.g.
@


1.13
log
@Grammo ok many.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.12 2004/10/20 18:13:15 ian Exp $
d1205 1
a1205 1
read or written multiple times to communicate data, e.g. some ethernet
@


1.12
log
@Tiny typo
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.11 2004/04/16 21:23:08 jmc Exp $
d615 1
a615 2
Mapped regions may contain areas for which no there is no device on the
bus.
@


1.11
log
@list/display fixes, and whitespace;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.10 2003/06/06 20:56:32 jmc Exp $
d451 1
a451 1
(via panic) or unintentionally (by causing a fatal trap of by some other
@


1.10
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.9 2003/04/16 07:34:57 mickey Exp $
a945 1
.Pp
@


1.9
log
@uncomment the bus_space_vaddr() since at least sparc64 has it
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.8 2003/04/15 04:14:29 jmc Exp $
d572 2
a573 1
accesses). The
d577 2
a578 2
device, e.g. a frame buffer.  If this flag is specified and linear
mapping is not possible, the
d688 2
a689 1
flag. The range can be accessed by normal (volatile) pointer dereferences.
d1461 3
a1463 1
.\".Sh COMPATIBILITY
a1511 2
.Sh SEE ALSO
.Xr bus_dma 9
@


1.8
log
@typos;

VOP, crypto and disklabel ok tedu@@
audio(9) ok naddy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.7 2002/10/09 21:14:36 deraadt Exp $
d85 1
a85 1
.\".Nm bus_space_vaddr ,
d131 2
a132 2
.\".Ft void *
.\".Fn bus_space_vaddr "bus_space_tag_t space" "bus_space_handle_t handle"
d559 28
a586 28
.\".It Dv BUS_SPACE_MAP_PREFETCHABLE
.\"Try to map the space so that accesses can be prefetched by the system,
.\"and writes can be buffered.
.\"This means, accesses should be side effect free (idempotent).
.\"The
.\".Fn bus_space_barrier
.\"methods will flush the write buffer or force actual read accesses.
.\"If this flag is not specified, the
.\"implementation should map the space so that it will not be prefetched
.\"or delayed.
.\".It Dv BUS_SPACE_MAP_LINEAR
.\"Try to map the space so that its contents can be accessed linearly via
.\"normal memory access methods (e.g. pointer dereferencing and structure
.\"accesses). The
.\".Fn bus_space_vaddr
.\"method can be used to obtain the kernel virtual address of the mapped range.
.\"This is useful when software wants to do direct access to a memory
.\"device, e.g. a frame buffer.  If this flag is specified and linear
.\"mapping is not possible, the
.\".Fn bus_space_map
.\"call should fail.
.\"If this
.\"flag is not specified, the system may map the space in whatever way is
.\"most convenient.
.\"Use of this mapping method is not encouraged for normal device access;
.\"where linear access is not essential, use of the
.\".Fn bus_space_read/write
.\"methods is strongly recommended.
d594 12
a605 12
.\"and on some systems
.\".Dv BUS_SPACE_MAP_LINEAR
.\"without
.\".Dv BUS_SPACE_MAP_PREFETCHABLE
.\"may never work.
.\"When the system hardware or firmware provides hints as to how spaces should be
.\"mapped (e.g. the PCI memory mapping registers' "prefetchable" bit), those
.\"hints should be followed for maximum compatibility.
.\"On some systems,
.\"requesting a mapping that cannot be satisfied (e.g. requesting a
.\"non-prefetchable mapping when the system can only provide a prefetchable one)
.\"will cause the request to fail.
d681 12
a692 12
.\".Pp
.\".It Fn bus_space_vaddr "tag" "handle"
.\".Pp
.\"This method returns the kernel virtual address of a mapped bus space if and
.\"only if it was mapped with the
.\".Dv BUS_SPACE_MAP_LINEAR
.\"flag. The range can be accessed by normal (volatile) pointer dereferences.
.\"If mapped with the
.\".Dv BUS_SPACE_MAP_PREFETCHABLE
.\"flag, the
.\".Fn bus_space_barrier
.\"method must be used to force a particular access order.
@


1.7
log
@missing comma; hiten@@uk.FreeBSD.org
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.6 2001/10/05 14:45:54 mpech Exp $ 
d6 1
a6 1
.\" 
d9 1
a9 1
.\" 
d25 1
a25 1
.\" 
d343 1
a343 1
.Pa Aq machine/bus.h
d375 1
a375 1
.Pa Aq machine/bus.h
d464 1
a464 1
.Pa Aq machine/bus.h
d552 1
a552 1
Try to map the space so that accesses can be cached by the system cache.
d1129 1
a1129 1
For portability, the starting addresses of the regions specified by the
@


1.6
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.5 2001/06/28 22:14:23 millert Exp $ 
d101 1
a101 1
.Nm bus_space_write_region_8
@


1.5
log
@speling; jsyn@@nthought.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.4 2001/06/25 20:45:56 mickey Exp $ 
d454 1
a454 1
(i.e., functions which don't obviously return an error code) do not
@


1.4
log
@make raw functions take count' to distract from evil bus.h remarks
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_space.9,v 1.3 2001/02/22 00:54:46 krw Exp $ 
d348 1
a348 1
For instance, a device which is mapped in one systems's I/O space may be
@


1.3
log
@First attempt at bringing in bus_space.9 from NetBSD.

Changes from NetBSD bus_space.9 v1.15:

1) All references to the following functions were '.\"'d out:

	bus_space_read_raw_multi_1
	bus_space_read_raw_region_1
	bus_space_read_stream_1
	bus_space_read_stream_2
	bus_space_read_stream_4
	bus_space_read_stream_8
	bus_space_vaddr
	bus_space_write_raw_multi_1
	bus_space_write_raw_region_1
	bus_space_write_stream_1
	bus_space_write_stream_2
	bus_space_write_stream_4
	bus_space_write_stream_8

2) All references to the following defines were '.\"'d out:

	BUS_SPACE_MAP_PREFETCHABLE
	BUS_SPACE_MAP_LINEAR

3) The entire COMPATIBILITY section with its discussion of of
   __BUS_SPACE_COMPAT_OLDDEFS was deleted as __BUS_SPACE_COMPAT_OLDDEFS
   does not seem to be used at all anywhere in the tree.

4) Added the already documented bus_space_alloc() to list of functions
   at head of page

5) Added bus_space_set_multi_N(t,h,o,v,c) definitions and descriptions

6) Renamed bus_space_copy_region_N to bus_space_copy_N

7) Replaced *_stream_* documentation with *_raw_* documentation

8) Rename the parameter 'flags' in bus_space_map and bus_space_alloc
   to 'cacheable' as that's the only flag we provide. Other more
   descriptive parameter names were retained rather than change to
   terse one/two letter parameter names used in bus.h

9) Eliminated short lines, made all new sentences start
   on new line, deleted extraneous .Pp's, removed some excess
   parenthesis, trailing white space, etc.


** Issues with bus_space.9 **

vax/bus.h and mac68k/bus.h still define

   bus_space_copy_region_N()

instead of

   bus_space_copy_N

like other architectures, though some of the comments do refer to
bus_space_copy_N.

powerpc/bus.h still defines

   bus_space_read_raw_multi_1()
   bus_space_write_raw_multi_1()

vax/bus.h still defines

	BUS_SPACE_MAP_PREFETCHABLE

while vax/bus.h and mac68k/bus.h both still define

	BUS_SPACE_MAP_LINEAR
@
text
@d1 1
a1 1
.\"	$OpenBSD$ 
d291 1
a291 1
.\""bus_size_t count"
d295 1
a295 1
"bus_size_t count"
d299 1
a299 1
"bus_size_t count"
d303 1
a303 1
"bus_size_t count"
d307 1
a307 1
"bus_size_t count"
d311 1
a311 1
"bus_size_t count"
d315 1
a315 1
"bus_size_t count"
d319 1
a319 1
"bus_size_t count"
d323 1
a323 1
.\""bus_size_t count"
d327 1
a327 1
"bus_size_t count"
d331 1
a331 1
"bus_size_t count"
d335 1
a335 1
"bus_size_t count"
d1370 8
a1377 8
.\".It Fn bus_space_read_raw_multi_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_multi_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_multi_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_multi_8 "space" "handle" "offset" "datap" "count"
.\".It Fn bus_space_read_raw_region_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_region_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_region_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_read_raw_region_8 "space" "handle" "offset" "datap" "count"
d1382 8
a1389 8
.\".It Fn bus_space_write_raw_multi_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_multi_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_multi_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_multi_8 "space" "handle" "offset" "datap" "count"
.\".It Fn bus_space_write_raw_region_1 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_region_2 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_region_4 "space" "handle" "offset" "datap" "count"
.It Fn bus_space_write_raw_region_8 "space" "handle" "offset" "datap" "count"
d1396 1
a1396 1
.Fa count
d1403 1
a1403 1
.Fa count
@


1.2
log
@REVERT TO PREVIOUS STATE OF AFFAIR.

If those pages are different from the NetBSD version, maybe there's a
reason ?

Like, possibly, I just read our source code, which just happens to do
things in DIFFERENT ways than NetBSD does ?

As far as the added pages go, they obviously haven't been checked against
actual code as well, hence they're worse than useless, since a large part
of the information is definitely misleading.
@
text
@d1 2
a2 2
.\" $OpenBSD: bus_space.9,v 1.1 1999/09/22 03:16:47 csapuntz Exp $
.\" $NetBSD: bus_space.9,v 1.10 1999/03/16 00:40:47 garbled Exp $
d38 1
a38 1
.Dd August 13, 1997
d43 1
d45 4
a48 4
.Nm bus_space_copy_region_1 ,
.Nm bus_space_copy_region_2 ,
.Nm bus_space_copy_region_4 ,
.Nm bus_space_copy_region_8 ,
d59 4
d67 12
d85 1
d94 4
d102 8
d115 1
a115 1
"bus_size_t size" "int flags" "bus_space_handle_t *handlep"
d126 1
a126 1
.Fa "int flags" "bus_addr_t *addrp" "bus_space_handle_t *handlep"
d131 2
d176 16
d194 1
a194 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
d198 1
a198 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t *datap" \
d202 1
a202 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t *datap" \
d206 17
a222 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t *datap" \
d225 1
a225 1
.Fn bus_space_copy_region_1 "bus_space_tag_t space" \
d229 1
a229 1
.Fn bus_space_copy_region_2 "bus_space_tag_t space" \
d233 1
a233 1
.Fn bus_space_copy_region_4 "bus_space_tag_t space" \
d237 1
a237 1
.Fn bus_space_copy_region_8 "bus_space_tag_t space" \
d241 16
d288 16
d306 1
a306 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int8_t *datap" \
d310 1
a310 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int16_t *datap" \
d314 1
a314 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int32_t *datap" \
d318 17
a334 1
"bus_space_handle_t handle" "bus_size_t offset" "u_int64_t *datap" \
a336 1
.Pp
d339 4
a342 4
functions exist to allow device drivers
machine-independent access to bus memory and register areas.  All of the
functions and types described in this document can be used by including
the 
d349 7
a355 6
mapped in memory space on a second system.  On a third system, architectural
limitations might change the way registers need to be accessed (e.g.
creating a non-linear register space).
In some cases, a single
driver may need to access the same type of device in multiple ways in a
single system or architecture.  The goal of the
d357 2
a358 2
functions is to allow a single driver source file to manipulate a set
of devices on different system architectures, and to allow a single driver
d364 2
a365 2
supported by the bus.  Unimplemented functions should cause
compile-time errors if possible.
d369 6
a374 4
functions.  Implementations are encouraged to implement prototyped
(type-checked) versions of these interfaces, but may implement them as
macros if appropriate.  Machine-dependent types, variables, and functions
should be marked clearly in
d376 3
a378 3
to avoid confusion with the
machine-independent types and functions, and, if possible, should be
given names which make the machine-dependence clear.
a379 1
.Pp
d381 24
a404 22
machine-dependent code.  A given machine may have several different types
of bus space (e.g. memory space and I/O space), and thus may provide
multiple different bus space tags.
Individual busses or devices on a machine may use more than one bus space
tag.  For instance, ISA devices are
given an ISA memory space tag and an ISA I/O space tag.  Architectures
may have several different tags which represent the same type of
space, for instance because of multiple different host bus interface
chipsets.
.Pp
A range in bus space is described by a bus address and a bus size.  The
bus address describes the start of the range in bus space.  The bus
size describes the size of the range in bytes.  Busses which are not byte
addressable may require use of bus space ranges with appropriately
aligned addresses and properly rounded sizes.
.Pp
Access to regions of bus space is facilitated by use of bus space handles,
which are usually created by mapping a specific range of a bus space.
Handles may also be created by allocating
and mapping a range of bus space, the actual location of which is picked
by the implementation within bounds specified by the caller of the
allocation function.
d411 6
a416 5
actual location(s) to be accessed.  Offsets are given in bytes, though busses
may impose alignment constraints.  The offset used to access data
relative to a given handle must be such that all of the data being
accessed is in the mapped region that the handle describes.  Trying to
access data outside that region is an error.
d422 10
a431 9
in the bus space read and write stream.  There
are three types of barriers: read, write, and read/write.  All reads
started to the region before a read barrier must complete before any reads
after the read barrier are started.  (The analogous requirement is true for
write barriers.)  Read/write barriers force all reads and writes started
before the barrier to complete before any reads or writes after the
barrier are started.  Correctly-written drivers will include all
appropriate barriers, and assume only the read/write ordering imposed by
the barrier operations.
d435 7
a441 7
functions should
try to make minimal assumptions about what the system allows.  In particular,
they should expect that the system requires bus space addresses being
accessed to be naturally aligned (i.e. base address of handle added to
offset is a multiple of the access size), and that the system does
alignment checking on pointers (i.e. pointer to objects being read and
written must point to properly-aligned data).
d445 17
a461 12
functions given below all assume that
they are called with proper arguments.  If called with invalid arguments
or arguments that are out of range (e.g. trying to access data outside of
the region mapped when a given handle was created), undefined behaviour
results.  In that case, they may cause the
system to halt, either intentionally (via panic) or unintentionally (by
causing a fatal trap of by some other means) or may cause improper
operation which is not immediately fatal.  Functions which return
void or which return data read from bus space (i.e., functions which
don't obviously return an error code) do not fail.  They could only fail
if given invalid arguments, and in that case their behaviour is undefined.
.Pp
d474 4
a477 4
type is used to describe bus addresses.  It must be an
unsigned integral type
capable of holding the largest bus address usable by the architecture.  This
type is primarily used when mapping and unmapping bus space.
d483 4
a486 4
type is used to describe sizes of ranges in bus space.  It must be an
unsigned integral type capable of holding the size of the largest bus
address range usable on the architecture.  This type is used by virtually all
of the
d488 2
a489 2
functions, describing sizes when mapping regions and
offsets into regions when performing space access operations.
d495 4
a498 3
type is used to describe a particular bus space on a machine.  Its
contents are machine-dependent and should be considered opaque by
machine-independent code.  This type is used by all
d506 4
a509 4
type is used to describe a mapping of a range of bus space.  Its
contents are machine-dependent and should be considered opaque by
machine-independent code.  This type is used when performing bus space
access operations.
a510 1
.Pp
d512 3
a514 3
.Pp
Bus space must be mapped before it can be used, and should be
unmapped when it is no longer needed.  The
d521 2
a522 1
space to another driver or module within a driver.  The
d527 1
a527 1
.It Fn bus_space_map "space" "address" "size" "flags" "handlep"
d536 3
a538 2
arguments.  If successful, it returns zero
and fills in the bus space handle pointed to by 
d540 3
a542 4
with the handle
that can be used to access the mapped region.  If unsuccessful,
it will return non-zero and leave the bus space handle pointed
to by 
d547 3
a549 2
.Fa flags
argument controls how the space is to be mapped.  Supported flags include:
d552 4
a555 4
Try to map the space so that accesses can be cached and/or
prefetched by the system.  If this flag is not specified, the
implementation should map the space so that it will not be cached or
prefetched.
d559 28
a586 11
.It Dv BUS_SPACE_MAP_LINEAR
Try to map the space so that its contents can be accessed linearly via
normal memory access methods (e.g. pointer dereferencing and structure
accesses).
This is useful when software wants to do direct access to a memory
device, e.g. a frame buffer.  If this flag is specified and linear
mapping is not possible, the
.Fn bus_space_map
call should fail.  If this
flag is not specified, the system may map the space in whatever way is
most convenient.
d589 3
a591 2
Not all combinations of flags make sense or are supported with all
spaces.  For instance, 
d593 13
a605 12
may be meaningless when
used on many systems' I/O port spaces, and on some systems
.Dv BUS_SPACE_MAP_LINEAR
without
.Dv BUS_SPACE_MAP_CACHEABLE
may never work.
When the system hardware or firmware provides hints as to how spaces should be
mapped (e.g. the PCI memory mapping registers' "prefetchable" bit), those
hints should be followed for maximum compatibility.  On some systems,
requesting a mapping that cannot be satisfied (e.g. requesting a
non-cacheable mapping when the system can only provide a cacheable one)
will cause the request to fail.
d608 5
a612 5
bus spaces and refuse to allow duplicate allocations.  This is encouraged
for bus spaces which have no notion of slot-specific space addressing,
such as ISA and VME, and for spaces which coexist with those spaces
(e.g. EISA and PCI memory and I/O spaces co-existing with ISA memory and
I/O spaces).
d615 2
a616 2
bus.  If space in those areas is accessed, the results are
bus-dependent.
d624 1
a624 1
When unmapping a region, the 
d626 1
a626 2
specified should be
the same as the size given to
d632 7
a638 7
is called on a handle, that handle is no longer
valid.  (If copies were made of the handle they are no longer valid,
either.)
.Pp
This function will never fail.  If it would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, 
d646 3
a648 3
function is a convenience function which makes a
new handle to some subregion of an already-mapped region of bus space.
The subregion described by the new handle starts at byte offset 
d650 1
a650 1
into the region described by 
d652 1
a652 1
with the size give by 
d658 1
a658 2
returns zero and fills in the bus
space handle pointed to by
d663 2
a664 2
in an
undefined state.  In either case, the handle described by
d668 1
a668 1
When done with a handle created by 
d670 2
a671 2
the handle should
be thrown away.  Under no circumstances should
d673 4
a676 2
be used on the handle.  Doing so may confuse any resource management
being done on the space, and will result in undefined behaviour.  When
d681 12
a693 1
.Pp
a694 1
.Pp
d696 4
a699 2
system for device use.  When the devices no longer need the space, the
operating system should free it for use by other devices.  The
d709 1
a709 1
.Fa "alignment" "boundary" "flags" "addrp" "handlep"
d717 2
a718 2
corresponding to the given constraints.  If successful, it returns
zero, fills in the bus address pointed to by
d720 2
a721 2
with the bus space address of the allocated region, and fills in
the bus space handle pointed to by 
d724 2
a725 1
If unsuccessful, it returns non-zero and leaves the bus address pointed to by
d727 1
a727 1
and the bus space handle pointed to by 
d731 1
a731 1
Constraints on the allocation are given by the 
d737 2
a738 1
parameters.  The allocated region will start at or after
d744 3
a746 2
constraint must be a power of two, and the allocated region will start at
an address that is an even multiple of that power of two.  The
d758 2
a759 2
will fail.  It is an error to specify a set of
constraints that can never be met
d768 1
a768 1
.Fa flags
d771 1
a771 2
the same flag values should be used, and they have the
same meanings.
d779 2
a780 1
on them causes undefined behaviour.  The
d782 1
a782 2
function can be used on
handles created by
d789 2
a790 2
function unmaps and frees a region of bus space mapped
and allocated with
d800 2
a801 2
is called on a handle, that handle is no longer valid.  (If copies were
made of the handle, they are no longer valid, either.)
d803 4
a806 3
This function will never fail.  If it would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case,
a809 1
.Pp
a810 1
.Pp
d812 2
a813 1
item.  The
d817 2
a818 3
families of functions provide
the ability to read and write 1, 2, 4, and 8 byte data items on busses
which support those access sizes.
d831 1
a831 1
into the region specified by 
d833 1
a833 1
of the bus space specified by 
d835 2
a836 1
The location being read must lie within the bus space region specified by
d841 4
a844 3
plus the offset should be a multiple of the size of data item being read.
On some systems, not obeying this requirement may cause incorrect data to
be read, on others it may cause a system crash.
d846 1
a846 1
Read operations done by the 
d848 2
a849 3
functions may be executed out
of order with respect to other pending read and write operations unless
order is enforced by use of the
d853 4
a856 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d870 1
a870 1
of the bus space specified by 
d872 2
a873 2
The location being written must lie within
the bus space region specified by
d879 3
a881 2
written.  On some systems, not obeying this requirement may cause
incorrect data to be written, on others it may cause a system crash.
d885 2
a886 3
functions may be executed
out of order with respect to other pending read and write operations
unless order is enforced by use of the
d890 4
a893 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
a894 1
.Pp
d896 4
a899 4
.Pp
In order to allow high-performance buffering implementations to avoid bus
activity on every operation, read and write ordering should be specified
explicitly by drivers when necessary.  The
d908 2
a909 2
function enforces ordering of bus space read and write operations
for the specified subregion (described by the
d911 1
a911 1
and 
d918 1
a918 1
The 
d933 2
a934 2
before the barrier operation are guaranteed to complete before any of the
specified type(s) of operation done after the barrier.
d938 6
a943 5
offset 1).  Operation of the device is as follows: data bytes are written
to the input port, and are placed by the device on a stack, the top of
which is read by reading from the output port.  The sequence to correctly
write two data bytes to the device then read those two data bytes back
would be:
d962 4
a965 3
second write is issued, so that two writes to the input port are done
in order and are not collapsed into a single write.  This ensures that
the data bytes are written to the device correctly and in order.
d968 4
a971 4
before any of the reads to the input port are issued, thereby making sure
that all of the writes are finished before data is read.  This ensures
that the first byte read from the device really is the last one that was
written.
d977 4
a980 4
minimum number of bus space locations.  It is correct (and often
easier) to make barrier operations cover the device's whole range of bus
space, that is, to specify an offset of zero and the size of the
whole region.
a981 1
.Pp
a982 1
.Pp
d986 2
a987 2
system or from mbufs to be output to a network.  In order to allow
drivers to do this as efficiently as possible, the
d995 3
a997 2
value.  The
.Fn bus_space_copy_region_N
d1012 1
a1012 2
1, 2, 4, or 8 byte data items from bus space
starting at byte offset
d1022 3
a1024 2
function is used).  All locations being read must lie within the bus
space region specified by
d1030 3
a1032 3
read and the data array pointer should be properly aligned.  On some
systems, not obeying these requirements may cause incorrect data to be
read, on others it may cause a system crash.
d1036 3
a1038 3
functions may be executed in any order.  They may also be executed out
of order with respect to other pending read and write operations unless
order is enforced by use of the
d1040 3
a1042 2
function.  There is no way to insert barriers between reads of
individual bus space locations executed by the
d1046 4
a1049 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d1060 1
a1060 2
1, 2, 4, or 8 byte data items from the array
specified by
d1066 5
a1070 6
of the bus space specified
by
.Fa space . 
Each successive data item is written to an offset 1, 2, 4,
or 8 bytes after the previous data item (depending on which function is
used).  All locations being written must lie within the bus space region
d1077 3
a1079 3
written and the data array pointer should be properly aligned.  On some
systems, not obeying these requirements may cause incorrect data to be
written, on others it may cause a system crash.
d1083 3
a1085 4
functions may be
executed in any order.  They may also be executed out of order with
respect to other pending read and write operations unless order is
enforced by use of the
d1087 3
a1089 2
function.  There is no way to insert barriers between writes of
individual bus space locations executed by the
d1093 4
a1096 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d1098 1
a1098 1
.It Fn bus_space_copy_region_1 "space" "srchandle" "srcoffset" "dsthandle" \
d1100 1
a1100 1
.It Fn bus_space_copy_region_2 "space" "srchandle" "srcoffset" "dsthandle" \
d1102 1
a1102 1
.It Fn bus_space_copy_region_4 "space" "srchandle" "srcoffset" "dsthandle" \
d1104 1
a1104 1
.It Fn bus_space_copy_region_8 "space" "srchandle" "srcoffset" "dsthandle" \
d1108 1
a1108 1
.Fn bus_space_copy_region_N
d1111 2
a1112 2
1, 2, 4, or 8 byte data items in bus space
from the area starting at byte offset
d1122 6
a1127 4
in the same bus space.  Each successive data item read or written has
an offset 1, 2, 4, or 8 bytes after the previous data item (depending
on which function is used).  All locations being read and written must
lie within the bus space region specified by their respective handles.
d1131 3
a1133 3
of data items being copied.  On some systems, not obeying this
requirement may cause incorrect data to be copied, on others it may cause
a system crash.
d1136 4
a1139 4
.Fn bus_space_copy_region_N
functions may be executed in any order.  They may also be executed out
of order with respect to other pending read and write operations unless
order is enforced by use of the
d1141 3
a1143 3
There is no way to insert barriers between reads or writes of
individual bus space locations executed by the
.Fn bus_space_copy_region_N
d1146 3
a1148 3
Overlapping copies between different subregions of a single region
of bus space are handled correctly by the
.Fn bus_space_copy_region_N
d1151 4
a1154 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d1167 1
a1167 2
1, 2, 4, or 8 byte
data items in bus space starting at byte offset
d1171 2
a1172 2
of the bus space specified by 
.Fa space . 
d1174 3
a1176 3
previous data item (depending on which function is used).  All
locations being written must lie within the bus space region specified
by
d1182 3
a1184 2
written.  On some systems, not obeying this requirement may cause
incorrect data to be written, on others it may cause a system crash.
d1188 3
a1190 4
functions may be
executed in any order.  They may also be executed out of order with
respect to other pending read and write operations unless order is
enforced by use of the
d1192 3
a1194 2
function.  There is no way to insert barriers between writes of
individual bus space locations executed by the
d1198 4
a1201 3
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
a1202 1
.Pp
d1204 7
a1210 6
.Pp
Some devices implement single locations in bus space which are to be read
or written multiple times to communicate data, e.g. some ethernet
devices' packet buffer FIFOs.  In order to allow drivers to manipulate
these types of devices as efficiently as possible, the
.Fn bus_space_read_multi_N
d1212 1
a1212 1
.Fn bus_space_write_multi_N
d1225 1
a1225 2
1, 2, 4, or 8 byte data items from bus space
at byte offset
d1233 3
a1235 3
Each successive data item is read from the same location in bus
space.  The location being read must lie within the bus space region
specified by
d1241 3
a1243 3
read and the data array pointer should be properly aligned.  On some
systems, not obeying these requirements may cause incorrect data to be
read, on others it may cause a system crash.
d1247 2
a1248 3
functions may be
executed out of order with respect to other pending read and write
operations unless order is enforced by use of the
d1250 2
a1251 1
function.  Because the
d1253 8
a1260 7
functions read the same bus space location multiple times, they
place an implicit read barrier between each successive read of that bus
space location.
.Pp
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d1271 1
a1271 2
1, 2, 4, or 8 byte data items from the array
specified by
d1279 3
a1281 3
Each successive data item is written to the same location in
bus space.  The location being written must lie within the bus space
region specified by
d1287 3
a1289 3
written and the data array pointer should be properly aligned.  On some
systems, not obeying these requirements may cause incorrect data to be
written, on others it may cause a system crash.
d1296 2
a1297 1
function.  Because the
d1299 91
a1389 7
functions write the same bus space location multiple times, they
place an implicit write barrier between each successive write of that
bus space location.
.Pp
These functions will never fail.  If they would fail (e.g. because of an
argument error), that indicates a software bug which should cause a
panic.  In that case, they will never return.
d1392 18
a1410 1
.Pp
d1413 3
a1415 3
functions should not yet be considered finalized.  There are several
changes and improvements which should be explored, including:
.Pp
d1419 3
a1421 2
automatically given barriers and properly-written drivers won't be forced
to use more barriers than they need.  This should probably be done via a
d1425 2
a1426 1
(or at all).  Because of that,
d1428 2
a1429 2
implementations on architectures which do buffering must always
do the barriers inside the
d1431 2
a1432 2
calls, to be safe.  That has a potentially significant
performance impact.
d1436 2
a1437 2
functions to user-land so that applications
(such as X servers) have easier, more portable access to device space.
d1441 2
a1442 2
implement bus spaces without requiring machine-dependent code.  If this
is done, it should be done in such a way that machine-dependent
d1452 3
a1454 2
space tags.  This would allow further optimization than is currently
possible, and would also ease translation of the
d1456 2
a1457 3
functions
into user space (since mapping in user space would look like it just used
a different bus-specific mapping function).
d1459 13
a1471 15
.Pp
.Sh COMPATIBILITY
.Pp
The current version of the
.Nm
interface specification differs slightly from the original
specification that came into wide use.
A few of the function names and arguments have changed
for consistency and increased functionality.
Drivers that were written to the
old, deprecated specification can be compiled by defining the
.Dv __BUS_SPACE_COMPAT_OLDDEFS
preprocessor symbol before including
.Pa Aq machine/bus.h .
.Pp
a1472 1
.Pp
d1488 4
a1492 1
.Pp
d1497 3
a1499 3
developer
community.  Primary contributors and implementors were Chris Demetriou,
Jason Thorpe, and Charles Hannum, but the rest of the
d1501 2
a1502 1
developers and the user community played a significant role in development.
d1506 2
@


1.1
log
@

Add/update some man9 pages from NetBSD
@
text
@d1 1
a1 1
.\" $OpenBSD: bus_space.9,v 1.10 1999/03/16 00:40:47 garbled Exp $
@

