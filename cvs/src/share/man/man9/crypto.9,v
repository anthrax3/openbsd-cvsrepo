head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.8
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.8
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.8
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.6
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.27.0.14
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.12
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.10
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.8
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.6
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@.\" @;


1.42
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.41;
commitid	T0HbsCFlrwPATHlH;

1.41
date	2015.11.23.17.53.57;	author jmc;	state Exp;
branches;
next	1.40;
commitid	GVTTSAMZ93Lz4hmE;

1.40
date	2015.11.13.15.29.55;	author naddy;	state Exp;
branches;
next	1.39;
commitid	kI77GdyYKaka3fwk;

1.39
date	2015.11.13.12.28.04;	author mikeb;	state Exp;
branches;
next	1.38;
commitid	4lAt42TwHKgu6ZhC;

1.38
date	2015.05.05.11.17.34;	author mikeb;	state Exp;
branches;
next	1.37;
commitid	EDVCseQ2dlqPXiFD;

1.37
date	2014.08.20.11.23.42;	author mikeb;	state Exp;
branches;
next	1.36;
commitid	vzc4wz1s3pDevb7K;

1.36
date	2013.07.17.20.21.52;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.04.19.27.04;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.17.21.54.18;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.18.07.59.40;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.09.18.55.58;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.09.16.14.00;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.27.05.32.30;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.19.22.20.05;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.23.18.31.34;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.11.13.47.41;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.17.12.56.49;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.15.04.14.29;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.20.06.35.25;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.21.19.42.39;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.16.06.31.57;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.29.23.30.07;	author naddy;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.28.09.07.07;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.23.21.45.49;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.26.18.12.09;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.03.15.21.17;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.08.41.35;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.05.00.28;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.04.55.51;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.18.43.36;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.17.04.07.18;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.07.01.52.08;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.20.05.48.41;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.18.03.10.50;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.06.04.32.23;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.28.14.03.45;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.28.05.51.40;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.28.05.42.50;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@.\"	$OpenBSD: crypto.9,v 1.41 2015/11/23 17:53:57 jmc Exp $
.\"
.\" The author of this man page is Angelos D. Keromytis (angelos@@cis.upenn.edu)
.\"
.\" Copyright (c) 2000, 2001 Angelos D. Keromytis
.\"
.\" Permission to use, copy, and modify this software with or without fee
.\" is hereby granted, provided that this entire notice is included in
.\" all source code copies of any software which is or includes a copy or
.\" modification of this software.
.\"
.\" THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
.\" IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
.\" REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
.\" MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
.\" PURPOSE.
.\"
.Dd $Mdocdate: November 23 2015 $
.Dt CRYPTO_GET_DRIVERID 9
.Os
.Sh NAME
.Nm crypto_get_driverid ,
.Nm crypto_register ,
.Nm crypto_unregister ,
.Nm crypto_done ,
.Nm crypto_newsession ,
.Nm crypto_freesession ,
.Nm crypto_dispatch ,
.Nm crypto_getreq ,
.Nm crypto_freereq
.Nd API for cryptographic services in the kernel
.Sh SYNOPSIS
.In crypto/cryptodev.h
.Ft int32_t
.Fn crypto_get_driverid "u_int8_t"
.Ft int
.Fn crypto_register "u_int32_t" "int *" "int (*)(u_int32_t *, struct cryptoini *)" "int (*)(u_int64_t)" "int (*)(struct cryptop *)"
.Ft int
.Fn crypto_unregister "u_int32_t" "int"
.Ft void
.Fn crypto_done "struct cryptop *"
.Ft int
.Fn crypto_newsession "u_int64_t *" "struct cryptoini *" "int"
.Ft int
.Fn crypto_freesession "u_int64_t"
.Ft int
.Fn crypto_dispatch "struct cryptop *"
.Ft struct cryptop *
.Fn crypto_getreq "int"
.Ft void
.Fn crypto_freereq "struct cryptop *"
.Bd -literal

#define EALG_MAX_BLOCK_LEN      16

struct cryptoini {
	int                cri_alg;
	int                cri_klen;
	int                cri_rnd;
	caddr_t            cri_key;
	u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN];
	struct cryptoini  *cri_next;
};

struct cryptodesc {
	int                crd_skip;
	int                crd_len;
	int                crd_inject;
	int                crd_flags;
	struct cryptoini   CRD_INI;
	struct cryptodesc *crd_next;
};

struct cryptop {
	u_int64_t          crp_sid;
	int                crp_ilen;
	int                crp_olen;
	int                crp_alloctype;
	int                crp_etype;
	int                crp_flags;
	void              *crp_buf;
	void              *crp_opaque;
	struct cryptodesc *crp_desc;
	int              (*crp_callback)(struct cryptop *);
	struct cryptop    *crp_next;
	caddr_t            crp_mac;
};
.Ed
.Sh DESCRIPTION
.Nm
is a framework for drivers of cryptographic hardware to register with
the kernel so
.Dq consumers
(other kernel subsystems, and eventually
users through an appropriate device) are able to make use of it.
Drivers register with the framework the algorithms they support,
and provide entry points (functions) the framework may call to
establish, use, and tear down sessions.
Sessions are used to cache cryptographic information in a particular driver
(or associated hardware), so initialization is not needed with every request.
Consumers of cryptographic services pass a set of
descriptors that instruct the framework (and the drivers registered
with it) of the operations that should be applied on the data (more
than one cryptographic operation can be requested).
.Pp
Since the consumers may not be associated with a process, drivers may
not use
.Xr tsleep 9 .
The same holds for the framework.
Thus, a callback mechanism is used
to notify a consumer that a request has been completed (the
callback is specified by the consumer on a per-request basis).
The callback is invoked by the framework whether the request was
successfully completed or not.
An error indication is provided in the latter case.
A specific error code,
.Er EAGAIN ,
is used to indicate that a session number has changed and that the
request may be re-submitted immediately with the new session number.
Errors are only returned to the invoking function if not
enough information to call the callback is available (meaning, there
was a fatal error in verifying the arguments).
For session initialization and teardown there is no callback mechanism used.
.Pp
The
.Fn crypto_newsession
routine is called by consumers of cryptographic services (such as the
.Xr ipsec 4
stack) that wish to establish a new session with the framework.
On success, the first argument will contain the Session Identifier (SID).
The second argument contains all the necessary information for
the driver to establish the session.
The third argument indicates whether a
hardware driver should be used (1) or not (0).
The various fields in the
.Fa cryptoini
structure are:
.Bl -tag -width foobarmoocow
.It Fa cri_alg
Contains an algorithm identifier.
Currently supported encryption algorithms are:
.Bd -literal
CRYPTO_3DES_CBC
CRYPTO_BLF_CBC
CRYPTO_CAST_CBC
CRYPTO_AES_CBC
CRYPTO_AES_CTR
CRYPTO_AES_XTS
.Ed
.Pp
Authentication algorithms are:
.Bd -literal
CRYPTO_MD5_HMAC
CRYPTO_SHA1_HMAC
CRYPTO_RIPEMD160_HMAC
CRYPTO_SHA2_256_HMAC
CRYPTO_SHA2_384_HMAC
CRYPTO_SHA2_512_HMAC
.Ed
.Pp
Algorithms performing authenticated encryption are:
.Bd -literal
CRYPTO_AES_GCM_16
CRYPTO_AES_GMAC
CRYPTO_CHACHA20_POLY1305
.Ed
.It Fa cri_klen
Specifies the length of the key in bits, for variable-size key
algorithms.
.It Fa cri_rnd
Specifies the number of rounds to be used with the algorithm, for
variable-round algorithms.
.It Fa cri_key
Contains the key to be used with the algorithm.
.It Fa cri_iv
Contains an explicit initialization vector (IV), if it does not prefix
the data.
This field is ignored during initialization.
If no IV is explicitly passed (see below on details), a random IV is used
by the device driver processing the request.
.Pp
In the case of the CRYPTO_AES_XTS transform, the IV should be provided
as a 64-bit block number in host byte order.
.It Fa cri_next
Contains a pointer to another
.Fa cryptoini
structure.
Multiple such structures may be linked to establish multi-algorithm sessions
.Pf ( Xr ipsec 4
is an example consumer of such a feature).
.El
.Pp
The
.Fa cryptoini
structure and its contents will not be modified by the framework (or
the drivers used).
Subsequent requests for processing that use the
SID returned will avoid the cost of re-initializing the hardware (in
essence, SID acts as an index in the session cache of the driver).
.Pp
.Fn crypto_freesession
is called with the SID returned by
.Fn crypto_newsession
to disestablish the session.
.Pp
.Fn crypto_dispatch
is called to process a request.
The various fields in the
.Fa cryptop
structure are:
.Bl -tag -width crp_alloctype
.It Fa crp_sid
Contains the SID.
.It Fa crp_ilen
Indicates the total length in bytes of the buffer to be processed.
.It Fa crp_olen
On return, contains the length of the result, not including
.Fa crd_skip .
For symmetric crypto operations, this will be the same as the input length.
.It Fa crp_alloctype
Indicates the type of buffer, as used in the kernel
.Xr malloc 9
routine.
This will be used if the framework needs to allocate a new
buffer for the result (or for re-formatting the input).
.It Fa crp_callback
This routine is invoked upon completion of the request, whether
successful or not.
It is invoked through the
.Fn crypto_done
routine.
If the request was not successful, an error code is set in the
.Fa crp_etype
field.
It is the responsibility of the callback routine to set the appropriate
.Xr spl 9
level.
.It Fa crp_etype
Contains the error type, if any errors were encountered, or zero if
the request was successfully processed.
If the
.Er EAGAIN
error code is returned, the SID has changed (and has been recorded in the
.Fa crp_sid
field).
The consumer should record the new SID and use it in all subsequent requests.
In this case, the request may be re-submitted immediately.
This mechanism is used by the framework to perform
session migration (move a session from one driver to another, because
of availability, performance, or other considerations).
.Pp
Note that this field only makes sense when examined by
the callback routine specified in
.Fa crp_callback .
Errors are returned to the invoker of
.Fn crypto_process
only when enough information is not present to call the callback
routine (i.e., if the pointer passed is
.Dv NULL
or if no callback routine was specified).
.It Fa crp_flags
Is a bitmask of flags associated with this request.
Currently defined flags are:
.Bl -tag -width CRYPTO_F_IMBUF
.It Dv CRYPTO_F_IMBUF
The buffer pointed to by
.Fa crp_buf
is an mbuf chain.
.El
.It Fa crp_buf
Points to the input buffer.
On return (when the callback is invoked),
it contains the result of the request.
The input buffer may be an mbuf
chain or a struct uio depending on
.Fa crp_flags .
.It Fa crp_opaque
This is passed through the crypto framework untouched and is
intended for the invoking application's use.
.It Fa crp_desc
This is a linked list of descriptors.
Each descriptor provides
information about what type of cryptographic operation should be done
on the input buffer.
The various fields are:
.Bl -tag -width "crd_inject"
.It Fa crd_skip
The offset in the input buffer where processing should start.
.It Fa crd_len
How many bytes, after
.Fa crd_skip ,
should be processed.
.It Fa crd_inject
Offset from the beginning of the buffer to insert any results.
For encryption algorithms, this is where the initialization vector
(IV) will be inserted when encrypting or where it can be found when
decrypting (subject to
.Fa crd_flags ) .
For MAC algorithms, this is where the result of the keyed hash will be
inserted.
.It Fa crd_flags
The following flags are defined:
.Bl -tag -width CRD_F_IV_EXPLICIT
.It Dv CRD_F_ENCRYPT
For encryption algorithms, this bit is set when encryption is required
(when not set, decryption is performed).
.It Dv CRD_F_IV_PRESENT
For encryption algorithms, this bit is set when the IV already
precedes the data, so the
.Fa crd_inject
value will be ignored and no IV will be written in the buffer.
Otherwise, the IV used to encrypt the packet will be written
at the location pointed to by
.Fa crd_inject .
The IV length is assumed to be equal to the blocksize of the
encryption algorithm.
Some applications that do special
.Dq IV cooking ,
such as the half-IV mode in
.Xr ipsec 4 ,
can use this flag to indicate that the IV should not be written on the packet.
This flag is typically used in conjunction with the
.Dv CRD_F_IV_EXPLICIT
flag.
.It Dv CRD_F_IV_EXPLICIT
For encryption algorithms, this bit is set when the IV is explicitly
provided by the consumer in the
.Fa crd_iv
fields.
Otherwise, for encryption operations the IV is provided for by
the driver used to perform the operation, whereas for decryption
operations it is pointed to by the
.Fa crd_inject
field.
This flag is typically used when the IV is calculated
.Dq on the fly
by the consumer, and does not precede the data (some
.Xr ipsec 4
configurations, and the encrypted swap are two such examples).
.It Dv CRD_F_COMP
For compression algorithms, this bit is set when compression is required (when
not set, decompression is performed).
.El
.It Fa CRD_INI
This
.Fa cryptoini
structure will not be modified by the framework or the device drivers.
Since this information accompanies every cryptographic
operation request, drivers may re-initialize state on-demand
(typically an expensive operation).
Furthermore, the cryptographic
framework may re-route requests as a result of full queues or hardware
failure, as described above.
.It Fa crd_next
Point to the next descriptor.
Linked operations are useful in protocols such as
.Xr ipsec 4 ,
where multiple cryptographic transforms may be applied on the same
block of data.
.El
.El
.Pp
.Fn crypto_getreq
allocates a
.Fa cryptop
structure with a linked list of as many
.Fa cryptodesc
structures as were specified in the argument passed to it.
.Pp
.Fn crypto_freereq
deallocates a structure
.Fa cryptop
and any
.Fa cryptodesc
structures linked to it.
Note that it is the responsibility of the
callback routine to do the necessary cleanups associated with the
opaque field in the
.Fa cryptop
structure.
.Sh DRIVER-SIDE API
The
.Fn crypto_get_driverid ,
.Fn crypto_register ,
.Fn crypto_unregister ,
and
.Fn crypto_done
routines are used by drivers that provide support for cryptographic
primitives to register and unregister with the kernel crypto services
framework.
Drivers must first use the
.Fn crypto_get_driverid
function to acquire a driver identifier, specifying the
.Fa cc_flags
as an argument (normally 0, but software-only drivers should specify
.Dv CRYPTOCAP_F_SOFTWARE ) .
For each algorithm the driver supports, it must then call
.Fn crypto_register .
The first argument is the driver identifier.
The second argument is an array of
.Dv CRYPTO_ALGORITHM_MAX + 1
elements, indicating which algorithms are supported.
The last three arguments are pointers to three
driver-provided functions that the framework may call to establish new
cryptographic context with the driver, free already established
context, and ask for a request to be processed (encrypt, decrypt, etc.\&)
.Fn crypto_unregister
is called by drivers that wish to withdraw support for an algorithm.
The two arguments are the driver and algorithm identifiers, respectively.
Typically, drivers for
.Xr pcmcia 4
crypto cards that are being ejected will invoke this routine for all
algorithms supported by the card.
If called with
.Dv CRYPTO_ALGORITHM_ALL ,
all algorithms registered for a driver will be unregistered in one go
and the driver will be disabled (no new sessions will be allocated on
that driver, and any existing sessions will be migrated to other
drivers).
The same will be done if all algorithms associated with a driver are
unregistered one by one.
.Pp
The calling convention for the three driver-supplied routines is:
.Bd -literal
int (*newsession) (u_int32_t *, struct cryptoini *);
int (*freesession) (u_int64_t);
int (*process) (struct cryptop *);
.Ed
.Pp
On invocation, the first argument to
.Fn newsession
contains the driver identifier obtained via
.Fn crypto_get_driverid .
On successfully returning, it should contain a driver-specific session
identifier.
The second argument is identical to that of
.Fn crypto_newsession .
.Pp
The
.Fn freesession
routine takes as argument the SID (which is the concatenation of the
driver identifier and the driver-specific session identifier).
It should clear any context associated with the session (clear hardware
registers, memory, etc.).
.Pp
The
.Fn process
routine is invoked with a request to perform crypto processing.
This routine must not block, but should queue the request and return
immediately.
Upon processing the request, the callback routine should be invoked.
In case of error, the error indication must be placed in the
.Fa crp_etype
field of the
.Fa cryptop
structure.
When the request is completed, or an error is detected, the
.Fn process
routine should invoke
.Fn crypto_done .
Session migration may be performed, as mentioned previously.
.Sh RETURN VALUES
.Fn crypto_register ,
.Fn crypto_unregister ,
.Fn crypto_newsession ,
and
.Fn crypto_freesession
return 0 on success, or an error code on failure.
.Fn crypto_get_driverid
returns a non-negative value on error, and \-1 on failure.
.Fn crypto_getreq
returns a pointer to a
.Fa cryptop
structure and
.Dv NULL
on failure.
.Fn crypto_dispatch
returns
.Er EINVAL
if its argument or the callback function was
.Dv NULL ,
and 0 otherwise.
The callback is provided with an error code in case of failure, in the
.Fa crp_etype
field.
.Sh FILES
.Bl -tag -width sys/crypto/crypto.c
.It Pa sys/crypto/crypto.c
most of the framework code
.El
.Sh SEE ALSO
.Xr ipsec 4 ,
.Xr pcmcia 4 ,
.Xr malloc 9 ,
.Xr tsleep 9
.Sh HISTORY
The cryptographic framework first appeared in
.Ox 2.7
and was written by
.An Angelos D. Keromytis Aq Mt angelos@@openbsd.org .
.Sh BUGS
The framework currently assumes that all the algorithms in a
.Fn crypto_newsession
operation must be available by the same driver.
If that's not the case, session initialization will fail.
.Pp
The framework also needs a mechanism for determining which driver is
best for a specific set of algorithms associated with a session.
Some type of benchmarking is in order here.
.Pp
Multiple instances of the same algorithm in the same session are not
supported.
.Pp
A queue for completed operations should be implemented and processed
at some software
.Xr spl 9
level, to avoid overall system latency issues, and potential kernel
stack exhaustion while processing a callback.
@


1.41
log
@add missing NAME entries;
feedback/ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.40 2015/11/13 15:29:55 naddy Exp $
d18 1
a18 1
.Dd $Mdocdate: November 13 2015 $
a142 1
CRYPTO_DES_CBC
a512 3
Note that 3DES is considered one algorithm (and not three
instances of DES).
Thus, 3DES and DES could be mixed in the same request.
@


1.40
log
@remove unused ARC4 support; ok mikeb@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.39 2015/11/13 12:28:04 mikeb Exp $
d19 1
a19 1
.Dt CRYPTO 9
d22 9
a30 1
.Nm crypto
@


1.39
log
@Update the list of supported cryptographic algorithms; reminded by naddy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.38 2015/05/05 11:17:34 mikeb Exp $
d18 1
a18 1
.Dd $Mdocdate: May 5 2015 $
a141 1
CRYPTO_ARC4
@


1.38
log
@Remove references to APIs that don't exist anymore.
Based on a diff from Vincent Gross <dermiste@@kilob.yt>, thanks!
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.37 2014/08/20 11:23:42 mikeb Exp $
d18 1
a18 1
.Dd $Mdocdate: August 20 2014 $
d133 1
a133 1
Currently supported algorithms are:
a138 3
CRYPTO_MD5_HMAC
CRYPTO_SHA1_HMAC
CRYPTO_RIPEMD160_HMAC
d143 17
a159 2
CRYPTO_MD5
CRYPTO_SHA1
@


1.37
log
@Remove userland bits related to the crypto(4) interface;  ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.36 2013/07/17 20:21:52 schwarze Exp $
d18 1
a18 1
.Dd $Mdocdate: July 17 2013 $
a30 2
.Fn crypto_kregister "u_int32_t" "int *" "int (*)(struct cryptkop *)"
.Ft int
a33 2
.Ft void
.Fn crypto_kdone "struct cryptkop *"
a39 2
.Ft int
.Fn crypto_kdispatch "struct cryptkop *"
a79 18

struct crparam {
        caddr_t         crp_p;
        u_int           crp_nbits;
};

#define CRK_MAXPARAM    8

struct cryptkop {
        u_int              krp_op;         /* ie. CRK_MOD_EXP or other */
        u_int              krp_status;     /* return status */
        u_short            krp_iparams;    /* # of input parameters */
        u_short            krp_oparams;    /* # of output parameters */
	u_int32_t	   krp_hid;
        struct crparam     krp_param[CRK_MAXPARAM];	  /* kvm */
        int               (*krp_callback)(struct cryptkop *);
        struct cryptkop   *krp_next;
};
a97 5
Keying operations are supported as well.
Unlike the symmetric operators described above,
these sessionless commands perform mathematical operations using
input and output parameters.
.Pp
a141 2
CRYPTO_MD5_KPDK
CRYPTO_SHA1_KPDK
a362 26
.Pp
.Fn crypto_kdispatch
is called to perform a keying operation.
The various fields in the
.Fa cryptkop
structure are:
.Bl -tag -width crp_alloctype
.It Fa krp_op
Operation code, such as CRK_MOD_EXP.
.It Fa krp_status
Return code.
This errno-style variable indicates whether there were lower level reasons
for operation failure.
.It Fa krp_iparams
Number of input parameters to the specified operation.
Note that each operation has a (typically hardwired) number of such parameters.
.It Fa krp_oparams
Number of output parameters from the specified operation.
Note that each operation has a (typically hardwired) number of such parameters.
.It Fa krp_kvp
An array of kernel memory blocks containing the parameters.
.It Fa krp_hid
Identifier specifying which low-level driver is being used.
.It Fa krp_callback
Callback called on completion of a keying operation.
.El
a366 1
.Fn crypto_kregister ,
a409 1
int (*kprocess) (struct cryptkop *);
a443 16
.Pp
The
.Fn kprocess
routine is invoked with a request to perform crypto key processing.
This routine must not block, but should queue the request and return
immediately.
Upon processing the request, the callback routine should be invoked.
In case of error, the error indication must be placed in the
.Fa krp_status
field of the
.Fa cryptkop
structure.
When the request is completed, or an error is detected, the
.Fn kprocess
routine should invoke
.Fn crypto_kdone .
a445 1
.Fn crypto_kregister ,
@


1.36
log
@use .Mt for AUTHORS email; from Jan Stary <hans at stare dot cz>; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.35 2013/06/04 19:27:04 schwarze Exp $
d18 1
a18 1
.Dd $Mdocdate: June 4 2013 $
a579 4
.Pp
When SMP time comes, we will support use of a second processor (or
more) as a crypto device (this is actually AMP, but we need the same
basic support).
@


1.35
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.34 2013/01/17 21:54:18 jmc Exp $
d18 1
a18 1
.Dd $Mdocdate: January 17 2013 $
d558 1
a558 1
.An Angelos D. Keromytis Aq angelos@@openbsd.org .
@


1.34
log
@various macro fixes;
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.33 2010/10/06 22:19:20 mikeb Exp $
d18 1
a18 1
.Dd $Mdocdate: October 6 2010 $
d25 1
a25 1
.Fd #include <crypto/cryptodev.h>
@


1.33
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.32 2010/07/18 07:59:40 jmc Exp $
d18 1
a18 1
.Dd $Mdocdate: July 18 2010 $
a179 1
.Pp
a282 1
.Pp
@


1.32
log
@- grammar fix from Glen Barber (freebsd pr 148701)
- fix some list issues found by mandoc
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.31 2008/06/09 18:55:58 jmc Exp $
d18 1
a18 1
.Dd $Mdocdate: June 9 2008 $
a167 1
CRYPTO_SKIPJACK_CBC
@


1.31
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.30 2008/06/09 16:14:00 djm Exp $
d133 1
a133 1
callback is specified by the consumer on an per-request basis).
d302 1
a302 1
.Bl -tag
d307 1
a307 1
.Fa Fa crd_skip ,
d314 1
a314 1
.Fa Fa crd_flags ) .
@


1.30
log
@mention CRYPTO_AES_CTR, CRYPTO_AES_XTS

describe special requirement for passing in IV/block number for
CRYPTO_AES_XTS
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.29 2007/05/31 19:20:00 jmc Exp $
d18 1
a18 1
.Dd $Mdocdate: May 31 2007 $
d198 1
a198 1
as 64 bit block number in host byte order.
@


1.29
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.28 2007/05/27 05:32:30 tedu Exp $
d18 1
a18 1
.Dd $Mdocdate$
d175 2
d196 3
@


1.28
log
@crp_buf is not a contiguous buffer, it's a uio.  very different.
ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.27 2004/02/19 22:20:05 jmc Exp $
d18 1
a18 1
.Dd April 21, 2000
@


1.27
log
@escape full stops where necessary to kill erroneous double spaces;
softly, softly, catchy monkey...
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.26 2003/10/23 18:31:34 jmc Exp $
d79 2
a80 2
	caddr_t            crp_buf;
	caddr_t            crp_opaque;
d286 1
a286 3
chain or a contiguous buffer (of a type identified by
.Fa crp_alloctype ) ,
depending on
@


1.26
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.25 2003/07/11 13:47:41 jmc Exp $
d446 1
a446 2
context, and ask for a request to be processed (encrypt, decrypt,
etc.)
@


1.25
log
@fix some lists and macros;
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.24 2003/06/17 12:56:49 jfb Exp $
d398 1
a398 1
.Fa crytokop
@


1.24
log
@Fix the crypto_freereq() prototype to show the right argument type
(struct cryptop* instead of void*) and update the definition of
struct cryptkop to match the real world

Work by jmc@@ and me, ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.23 2003/06/06 20:56:32 jmc Exp $
a144 1
.br
d299 1
a299 1
.Bl -tag -width=crd_inject
@


1.23
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.22 2003/04/15 04:14:29 jmc Exp $
d49 1
a49 1
.Fn crypto_freereq "void"
d82 1
a82 1
	int              (*crp_callback) (struct cryptop *);
d99 2
a100 5
        u_int              krp_pad1;
        struct crparam     krp_param[CRK_MAXPARAM];
        struct crparam     krp_kvp[CRK_MAXPARAM];

        u_int32_t          krp_hid;
a104 1
.br
@


1.22
log
@typos;

VOP, crypto and disklabel ok tedu@@
audio(9) ok naddy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.21 2003/02/20 06:35:25 jason Exp $
d441 1
a441 1
.Dv CRYPTOCAP_F_SOFTWARE Ns ).
d563 2
a564 1
and was written by Angelos D. Keromytis <angelos@@openbsd.org>.
@


1.21
log
@I found my missing 24 bytes... crp_olen = the total length of the result - crp_skip
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.20 2002/11/21 19:42:39 jason Exp $
d160 1
a160 1
hardware driver (1) should be used or not (0).
d410 1
a410 1
This errno-style variable indicates whether lower level reasons
d413 2
a414 2
Number if input parameters to the specified operation.
Note that each operation has a (typically hardwired) number of such parameters. 
d416 2
a417 2
Number if output parameters from the specified operation.
Note that each operation has a (typically hardwired) number of such parameters. 
d423 1
a423 1
Callback called on completion of a keying operation. 
d506 1
a506 1
routine should invoked
d523 1
a523 1
routine should invoked
d544 1
a544 1
is its argument or the callback function was
@


1.20
log
@From angelos; document new registration API
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.19 2002/07/16 06:31:57 angelos Exp $
d232 2
a233 1
On return, contains the total length of the result.
@


1.19
log
@Update to document use of CRYPTO_ALGORITHM_ALL in crypto_unregister().
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.18 2002/06/29 23:30:07 naddy Exp $
d29 1
a29 1
.Fn crypto_register "u_int32_t" "int" "u_int16_t" "u_int32_t" "int (*)(u_int32_t *, struct cryptoini *)" "int (*)(u_int64_t)" "int (*)(struct cryptop *)"
d31 1
a31 1
.Fn crypto_kregister "u_int32_t" "int" "u_int32_t" "int (*)(struct cryptkop *)"
d443 5
a447 8
The first two arguments are the driver and algorithm identifiers.
The next two arguments specify the largest possible operator length (in bits,
important for public key operations) and flags (e.g., whether an hardware RNG is
available) for this algorithm.
The last three arguments must be provided in the first call to
.Fn crypto_register
and are ignored in all subsequent calls.
They are pointers to three
@


1.18
log
@the the
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.17 2002/05/28 09:07:07 mpech Exp $
d462 8
@


1.17
log
@	man9/:
o) Start new sentence on a new line;
o) FreeBSD -> .Fx;
o) OpenBSD -> .Ox;
o) Close .Bl/Bd lists;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.16 2002/04/23 21:45:49 deraadt Exp $
d338 1
a338 1
can use this flag to indicate the the IV should not be written on the packet.
@


1.16
log
@document the keying operations
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.15 2002/01/26 18:12:09 angelos Exp $
d126 2
a127 2
Keying operations are supported as well.  Unlike the symmetric operators
described above,
d158 4
a161 2
the driver to establish the session.  The third argument indicates whether a
hardware driver (1) should be used or not (0).  The various fields in the
d400 2
a401 1
is called to perform a keying operation.  The various fields in the
d408 2
a409 1
Return code.  This errno-style variable indicates whether lower level reasons
d446 2
a447 2
available) for this algorithm.  The last three arguments must be provided in the
first call to
@


1.15
log
@Sync with reality, from Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.14 2001/11/09 03:11:38 deraadt Exp $
d31 2
d36 2
d44 2
d55 6
a60 6
    int                cri_alg;
    int                cri_klen;
    int                cri_rnd;
    caddr_t            cri_key;
    u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN];
    struct cryptoini  *cri_next;
d64 6
a69 6
    int                crd_skip;
    int                crd_len;
    int                crd_inject;
    int                crd_flags;
    struct cryptoini   CRD_INI;
    struct cryptodesc *crd_next;
d73 33
a105 12
    u_int64_t          crp_sid;
    int                crp_ilen;
    int                crp_olen;
    int                crp_alloctype;
    int                crp_etype;
    int                crp_flags;
    caddr_t            crp_buf;
    caddr_t            crp_opaque;
    struct cryptodesc *crp_desc;
    int              (*crp_callback) (struct cryptop *);
    struct cryptop    *crp_next;
    caddr_t            crp_mac;
d126 5
d149 1
d158 1
a158 1
the driver to establish the session.  The third argument indicates wether a
d396 24
d424 1
d441 1
a441 1
important for public key operations) and flags (e.g., wether an hardware RNG is
d464 1
d499 16
d517 1
@


1.14
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.13 2001/08/03 15:21:17 mpech Exp $
d25 1
a25 1
.Fd #include <crypto/crypto.h>
d29 1
a29 1
.Fn crypto_register "u_int32_t" "int" "int (*)(u_int32_t *, struct cryptoini *)" "int (*)(u_int64_t)" "int (*)(struct cryptop *)"
d35 1
a35 1
.Fn crypto_newsession "u_int64_t *" "struct cryptoini *"
d46 1
a46 1
#define EALG_MAX_BLOCK_LEN      8
d77 2
d125 2
a126 2
the driver to establish the session.
The various fields in the
d144 4
d322 3
d326 2
a327 4
.It Xo Fa crd_alg , crd_klen , crd_rnd ,
.Fa crd_key , crd_iv
.Xc
These have the exact same meaning as the corresponding fields in the
d329 1
a329 2
structure.
These fields will not be modified by the framework or the device drivers.
d382 4
a385 1
The last three arguments must be provided in the first call to
@


1.13
log
@o) We don't like .Pp before/after .Sh;
o) .Nm always has argument in .Sh SYNOPSIS;
o) We always closes .Bl and .Bd tags;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.12 2001/06/27 08:41:35 aaron Exp $
d27 1
a27 1
.Fn crypto_get_driverid "void"
d48 1
a48 2
struct cryptoini
{
d57 1
a57 2
struct cryptodesc
{
d66 1
a66 2
struct cryptop
{
d369 4
a372 1
function to acquire a driver identifier.
@


1.12
log
@Correct order of SEE ALSO entries. Move HISTORY section before BUGS.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.11 2001/06/25 05:00:28 angelos Exp $
a359 1
.Pp
a430 1
.Pp
@


1.11
log
@With or without fee.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.10 2001/06/25 04:55:51 angelos Exp $
d464 1
a465 1
.Xr pcmcia 4 ,
d467 4
a495 4
.Sh HISTORY
The cryptographic framework first appeared in
.Ox 2.7
and was written by Angelos D. Keromytis <angelos@@openbsd.org>.
@


1.10
log
@HISTORY section.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.9 2001/06/23 18:43:36 deraadt Exp $
d7 1
a7 1
.\" Permission to use, copy, and modify this software without fee
@


1.9
log
@duh
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.8 2000/11/17 04:07:18 angelos Exp $
d5 1
a5 1
.\" Copyright (c) 2000 Angelos D. Keromytis
d464 1
a465 1
.Xr malloc 9 ,
a488 6
We need a userland device for exposing the framework to userland.
This will be particularly useful for public key operations in hardware.
.Pp
We have not experimented yet with public key operations hardware.
The framework should support this.
.Pp
d492 4
@


1.8
log
@*HMAC96->HMAC
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.7 2000/11/07 01:52:08 aaron Exp $
d25 1
a25 1
.Fd #include <crypto/crypto>
@


1.7
log
@mdoc nit
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.6 2000/06/20 05:48:41 angelos Exp $
d140 3
a142 3
CRYPTO_MD5_HMAC96
CRYPTO_SHA1_HMAC96
CRYPTO_RIPEMD160_HMAC96
@


1.6
log
@Add text about crypto_done()
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.5 2000/06/18 03:10:50 angelos Exp $
d237 1
a237 1
.It crp_flags
@


1.5
log
@Point out that the callbacks are responsible for setting the appropriate
spl level.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.4 2000/06/06 04:32:23 angelos Exp $
d32 2
d205 3
d365 1
d367 1
a367 1
.Fn crypto_unregister
d426 5
a430 2
structure, and the callback routine invoked as well, to perform the
necessary cleanup or to re-issue the request.
@


1.4
log
@Document change in the cryptop structure.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.3 2000/04/28 14:03:45 aaron Exp $
d206 3
@


1.3
log
@- Correct a lot of mdoc macro usage.
- Correct some typos.
- Remove hard sentence breaks.
- Remove trailing whitespace.
- Reorder Xr's in SEE ALSO.
- Change CODE REFERENCES section to a FILES section (more standard)
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.2 2000/04/28 05:51:40 angelos Exp $
d75 1
a75 4
    caddr_t            crp_opaque1;
    caddr_t            crp_opaque2;
    caddr_t            crp_opaque3;
    caddr_t            crp_opaque4;
d248 2
a249 2
.It Fa crp_opaque1 , crp_opaque2 , crp_opaque3 , crp_opaque4
These are passed through the crypto framework untouched and are
d349 1
a349 1
opaque fields in the
@


1.2
log
@Fix the types of functions passed to crypto_register(), as per Theo's
change in the include file.
@
text
@d1 1
a1 1
.\"	$OpenBSD: crypto.9,v 1.1 2000/04/28 05:42:50 angelos Exp $
d87 5
a91 3
the kernel so ``consumers'' (other kernel subsystems, and eventually
users through an appropriate device) are able to make use of
it. Drivers register with the framework the algorithms they support,
d93 4
a96 4
establish, use, and tear down sessions. Sessions are used to cache
cryptographic information in a particular driver (or associated
hardware), so initialization is not needed with every
request. Consumers of cryptographic services pass a set of
d104 2
a105 1
The same holds for the framework. Thus, a callback mechanism is used
d107 6
a112 5
callback is specified by the consumer on an per-request basis). The
callback is invoked by the framework whether the request was
successfully completed or not. An error indication is provided in the
latter case. A specific error code,
.Va EAGAIN ,
d114 2
a115 2
request may be re-submitted immediately with the new session
number. Errors are only returned to the invoking function if not
d117 2
a118 2
was a fatal error in verifying the arguments). For session
initialization and teardown there is no callback mechanism used.
d124 6
a129 5
stack) that wish to establish a new session with the framework. On
success, the first argument will contain the Session Identifier
(SID). The second argument contains all the necessary information for
the driver to establish the session. The various fields in the
.Va cryptoini
d131 4
a134 3
.Bl -tag -width foobarmoocow 
.It cri_alg
Contains an algorithm identifier. Currently supported algorithms are:
d147 2
a148 2
.Br
.It cri_klen
d151 1
a151 1
.It cri_rnd
d154 1
a154 1
.It cri_key
d156 1
a156 1
.It cri_iv
d158 5
a162 4
the data. This field is ignored during initialization. If no IV is
explicitly passed (see below on details), a random IV is used by the
device driver processing the request.
.It cri_next
d164 4
a167 4
.Va cryptoini
structure. Multiple such structures may be linked, to establish
multi-algorithm sessions (
.Xr ipsec 4
d172 1
a172 1
.Va cryptoini
d174 2
a175 1
the drivers used). Subsequent requests for processing that use the
d185 3
a187 2
is called to process a request. The various fields in the
.Va cryptop
d190 1
a190 1
.It crp_sid
d192 1
a192 1
.It crp_ilen
d194 4
a197 4
.It crp_olen
On return, contains the total length of the result. For symmetric
crypto operations, this will be the same as the input length.
.It crp_alloctype
d200 2
a201 1
routine. This will be used if the framework needs to allocate a new
d203 1
a203 1
.It crp_callback
d205 3
a207 3
successful or not. If the request was not successful, an error code is
set in the
.Va crp_etype
d209 1
a209 1
.It crp_etype 
d211 9
a219 8
the request was successfully processed. If the
.Va EAGAIN
error code is returned, the SID has changed (and has been recorded in
the
.Va crp_sid
field). The consumer should record the new SID and use it in all
subsequent requests. In this case, the request may be re-submitted
immediately. This mechanism is used by the framework to perform
d225 1
a225 1
.Va crp_callback .
d233 2
a234 2
Is a bitmask of flags associated with this request. Currently defined
flags are:
d236 1
a236 1
.It CRYPTO_F_IMBUF
d238 1
a238 1
.Va crp_buf
d241 6
a246 4
.Br
.It crp_buf
Points to the input buffer. On return (when the callback is invoked),
it contains the result of the request. The input buffer may be an mbuf
d248 1
a248 1
.Va crp_alloctype ),
d250 2
a251 5
.Va crp_flags .
.It crp_opaque1
.It crp_opaque2
.It crp_opaque3
.It crp_opaque4
d254 3
a256 2
.It crp_desc
This is a linked list of descriptors. Each descriptor provides
d258 2
a259 1
on the input buffer. The various fields are:
d261 1
a261 1
.It crd_skip
d263 1
a263 1
.It crd_len
d265 1
a265 1
.Va crd_skip ,
d267 3
a269 3
.It crd_inject
Offset from the beginning of the buffer to insert any results. For
encryption algorithms, this is where the initialization vector
d272 1
a272 1
.Va crd_flags ).
d275 1
a275 1
.It crd_flags
d277 2
a278 2
.Bl -tag -width=CRD_F_IV_EXPLICIT
.it CRD_F_ENCRYPT
d281 1
a281 1
.It CRD_F_IV_PRESENT
d284 3
a286 3
.Va crd_inject
value will be ignored and no IV will be written in the
buffer. Otherwise, the IV used to encrypt the packet will be written
d288 1
a288 1
.Va crd_inject .
d290 4
a293 2
encryption algorithm. Some applications that do special ``IV
cooking'', such as the half-IV mode in
d295 3
a297 3
can use this flag to indicate the the IV should not be written on the
packet. This flag is typically used in conjunction with the
.Va CRD_F_IV_EXPLICIT
d299 1
a299 1
.It CRD_F_IV_EXPLICIT
d302 3
a304 2
.Va crd_iv
fiels. Otherwise, for encryption operations the IV is provided for by
d307 5
a311 3
.Va crd_inject
field. This flag is typically used when the IV is calculated ``on the
fly'' by the consumer, and does not precede the data (some
d315 3
a317 5
.It crd_alg
.It crd_klen
.It crd_rnd
.It crd_key
.It crd_iv
d319 4
a322 3
.Va cryptoini
structure. These fields will not be modified by the framework or the
device drivers. Since this information accompanies every cryptographic
d324 2
a325 1
(typically an expensive operation). Furthermore, the cryptographic
d328 3
a330 3
.It crd_next
Point to the next descriptor. Linked operations are useful in
protocols such as
d339 1
a339 1
.Va cryptop
d341 1
a341 1
.Va cryptodesc
d346 1
a346 1
.Va cryptop
d348 3
a350 2
.Va cryptodesc
structures linked to it. Note that it is the responsibility of the
d353 1
a353 1
.Va cryptop
d364 2
a365 1
framework. Drivers must first use the
d367 2
a368 2
function to acquire a driver identifier. For each algorithm the driver
supports, it must then call
d370 2
a371 2
The first two arguments are the driver and algorithm identifiers. The
last three arguments must be provided in the first call to
d373 2
a374 1
and are ignored in all subsequent calls. They are pointers to three
d380 3
a382 3
is called by drivers that wish to withdraw support for an
algorithm. The two arguments are the driver and algorithm identifiers
respectively. Typically, drivers for
d399 2
a400 1
identifier. The second argument is identical to that of
d406 3
a408 3
driver identifier and the driver-specific session identifier). It
should clear any context associated with the session (clear hardware
registers, memory, etc.)
d412 6
a417 6
routine is invoked with a request to perform crypto processing. This
routine must not block, but should queue the request and return
immediately. Upon processing the request, the callback routine
should be invoked. In case of error, the error indication must be
placed in the
.Va crp_etype
d419 1
a419 1
.Va cryptop
d421 2
a422 2
necessary cleanup or to re-issue the request. Session migration may be
performed, as mentioned previously.
d432 1
a432 1
returns a non-negative value on error,and \-1 on failure.
d435 1
a435 1
.Va cryptop
d441 1
a441 1
.Dv EINVAL
d444 3
a446 3
and 0 otherwise. The callback is provided with an error code in case
of failure, in the
.Va crp_etype
d448 5
a452 5
.Br
.Sh CODE REFERENCES
Most of the framework code can be found in
.Pa sys/crypto/crypto.c
.Br
d455 1
a456 1
.Xr pcmcia 4 ,
a457 1
.Br
d461 2
a462 2
operation must be available by the same driver. If that's not the
case, session initialization will fail.
d465 2
a466 2
best for a specific set of algorithms associated with a session. Some
type of benchmarking is in order here.
d469 4
a472 3
supported. Note that 3DES is considered one algorithm (and not three
instances of DES). Thus, 3DES and DES could be mixed in the same
request.
d480 2
a481 2
We need a userland device for exposing the framework to userland. This
will be particularly useful for public key operations in hardware.
d483 2
a484 2
We have not experimented yet with public key operations hardware. The
framework should support this.
@


1.1
log
@man page for the kernel crypto framework, more or less complete
(hopefully accurate too).
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d29 1
a29 1
.Fn crypto_register "u_int32_t" "int" "void *" "void *" "void *"
@

