head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.10
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.8
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.8
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.28.0.6
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@.\" @;


1.36
date	2015.11.23.17.53.57;	author jmc;	state Exp;
branches;
next	1.35;
commitid	GVTTSAMZ93Lz4hmE;

1.35
date	2015.09.21.11.01.37;	author jmc;	state Exp;
branches;
next	1.34;
commitid	kN8K0YOtQh0nh0jS;

1.34
date	2015.01.24.19.20.26;	author jmc;	state Exp;
branches;
next	1.33;
commitid	8kMJ3qPPCik6LMrH;

1.33
date	2015.01.24.16.06.46;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	0b10jkk0rc8fhJDX;

1.32
date	2014.09.08.01.27.55;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	cPoapLAXYNe1fcgV;

1.31
date	2013.06.04.19.27.04;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.10.13.01.26;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.26.15.40.57;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.20.00.46.47;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.08;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.26.04.14.31;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.28.10.26.26;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.27.00.29.55;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.26.14.47.26;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.28.20.16.00;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.18.21.52.47;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.10.18.14.42;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.25.14.31.54;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.15.04.14.29;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.01.19.34.31;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.11.06.14.35;	author wcobb;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.08.08.08.47;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.12.07.10.36;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.28.09.07.07;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.07.18.09.24;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.03.09.29.18;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.02.18.37.34;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.04.04.59.20;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.02.00.19.56;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.29.02.10.05;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.28.22.14.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.22.00.54.01;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	99.09.22.09.54.37;	author espie;	state dead;
branches;
next	1.1;

1.1
date	99.09.22.03.16.47;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.36
log
@add missing NAME entries;
feedback/ok schwarze
@
text
@.\"	$OpenBSD: bus_dma.9,v 1.35 2015/09/21 11:01:37 jmc Exp $
.\" $NetBSD: bus_dma.9,v 1.14 2000/06/14 06:49:19 cgd Exp $
.\"
.\" Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
.\" NASA Ames Research Center.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: September 21 2015 $
.Dt BUS_DMAMAP_CREATE 9
.Os
.Sh NAME
.Nm bus_dmamap_create ,
.Nm bus_dmamap_destroy ,
.Nm bus_dmamap_load ,
.Nm bus_dmamap_load_mbuf ,
.Nm bus_dmamap_load_uio ,
.Nm bus_dmamap_load_raw ,
.Nm bus_dmamap_unload ,
.Nm bus_dmamap_sync ,
.Nm bus_dmamem_alloc ,
.Nm bus_dmamem_alloc_range ,
.Nm bus_dmamem_free ,
.Nm bus_dmamem_map ,
.Nm bus_dmamem_unmap ,
.Nm bus_dmamem_mmap
.Nd bus and machine independent DMA mapping interface
.Sh SYNOPSIS
.In machine/bus.h
.Sh DESCRIPTION
The
.Nm
interface provides a bus and machine independent mechanism
for managing DMA data transfers to and from devices.
.Pp
The basic abstraction is
.Fa bus_dmamap_t ,
a pointer to a structure describing an individual DMA mapping.
The structure contains an array of segments
.Pq Fa dm_segs ,
and a count of segments
.Pq Fa dm_nsegs .
.Pp
Each segment in
.Fa dm_segs
describes a single physical area of memory suitable for DMA, with a starting
address
.Pq Fa ds_addr
and a length
.Pq Fa ds_len .
These are the values that must be communicated to the DMA device.
Taken together the segments exactly and completely describe the buffer
being used to transfer data.
.Pp
.Fa bus_dma_tag_t
is an opaque type.
.Fa bus_dma_tag_t
values are received from higher software layers and are never created,
changed, deleted or even examined in this interface.
.Pp
The basic cycle to transfer data to/from a DMA device is:
.Bd -literal
bus_dmamap_create();         /* get a dmamap to load/unload          */

for each DMA xfer {
        bus_dmamem_alloc();  /* allocate some DMA'able memory        */
        bus_dmamem_map();    /* map it into the kernel address space */

        /*
         * Fill the allocated DMA'able memory with whatever data
         * is to be sent out, using the pointer obtained with
         * bus_dmamem_map().
         */

        bus_dmamap_load();   /* initialize the segments of dmamap    */
        bus_dmamap_sync();   /* synchronize/flush any DMA cache      */

        for (i = 0; i < dm_nsegs; i++) {
                /*
                 * Tell the DMA device the physical address
                 * (dmamap->dm_segs[i].ds_addr) and the length
                 * (dmamap->dm_segs[i].ds_len) of the memory to xfer.
                 *
                 * Start the DMA, wait until it's done
                 */
        }

        bus_dmamap_sync();   /* synchronize/flush any DMA cache      */
        bus_dmamap_unload(); /* prepare dmamap for reuse             */

        /*
         * Copy any data desired from the DMA'able memory using the
         * pointer created by bus_dmamem_map().
         */

        bus_dmamem_unmap();  /* free kernel virtual address space    */
        bus_dmamem_free();   /* free DMA'able memory                 */
}

bus_dmamap_destroy();        /* release any resources used by dmamap */
.Ed
.Sh DATA TYPES
Individual implementations may name these structures whatever they wish,
providing that the external representations are:
.Bl -tag -width "bus_dma_segment_t"
.It Fa bus_addr_t
A device bus address to be used for CPU access or DMA.
.It Fa bus_size_t
The size of a bus address range.
.It Fa bus_dma_tag_t
A machine-dependent opaque type describing the implementation of DMA for
a given host/bus.
Machine-dependent code is responsible for passing these structures to a
bus's autoconfiguration machinery, which in turn passes it down to the device
drivers.
.It Fa bus_dma_segment_t
A structure describing an individual DMA segment.
The structure may have machine-dependent members and arbitrary layout, but
has at least the following members:
.Bd -literal
	bus_addr_t	ds_addr;
	bus_size_t	ds_len;
.Ed
.Pp
The values in
.Fa ds_addr
and
.Fa ds_len
are suitable for programming into a DMA controller's address and length
registers.
.It Fa bus_dmamap_t
A pointer to a structure describing an individual DMA mapping.
The structure may have machine-dependent members and arbitrary layout, but
has at least the following members:
.Bd -literal
	int		   dm_nsegs;
	bus_dma_segment_t *dm_segs;
.Ed
.Pp
The
.Fa dm_segs
member may be an array of segments or a pointer to an array of segments.
The
.Fa dm_nsegs
member indicates the number of segments in
.Fa dm_segs .
.El
.Sh DMA MAPS
.nr nS 1
.Ft int
.Fn bus_dmamap_create "bus_dma_tag_t tag" "bus_size_t size" "int nsegments" \
                      "bus_size_t maxsegsz" "bus_size_t boundary" "int flags" \
                      "bus_dmamap_t *dmamp"
.Ft void
.Fn bus_dmamap_destroy "bus_dma_tag_t tag" "bus_dmamap_t dmam"
.nr nS 0
.Pp
The
.Fn bus_dmamap_create
function allocates a DMA handle and initializes it according to the parameters
provided.
This function returns 0 on success, an error code otherwise.
.Pp
The
.Fn bus_dmamap_create
arguments are as follows:
.Bl -tag -width nsegments -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa size
The maximum DMA transfer that can be mapped by the handle.
.It Fa nsegments
Number of segments the device can support in a single DMA transaction.
This may be the number of scatter-gather descriptors supported by the
device.
.It Fa maxsegsz
The maximum number of bytes that may be transferred by any given DMA
segment.
.It Fa boundary
Some DMA controllers are not able to transfer data that crosses a
particular boundary.
This argument allows this boundary to be specified.
The boundary lines begin at 0, and occur every
.Fa boundary
bytes.
Mappings may begin on a boundary line but may not end on or cross a
boundary line.
If no boundary condition needs to be observed, a
.Fa boundary
argument of 0 should be used.
.It Fa flags
Flags are defined as follows:
.Bl -tag -width BUS_DMA_ALLOCNOW -compact
.It Dv BUS_DMA_WAITOK
It is safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_NOWAIT
It is not safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_ALLOCNOW
Perform any resource allocation this handle may need now.
If this is not specified, the allocation may be deferred to
.Fn bus_dmamap_load .
If this flag is specified,
.Fn bus_dmamap_load
will not block on resource allocation.
.It Dv BUS_DMA_BUS[1-4]
These flags are placeholders, and may be used by buses to provide
bus-dependent functionality.
.El
.It Fa dmamp
A
.Fa bus_dmamap_t
pointer.
A DMA map will be allocated and pointed to by
.Fa dmamp
upon successful completion of this routine.
.El
.Pp
The
.Fn bus_dmamap_destroy
function frees all resources associated with a given DMA handle.
This function always succeeds if given valid arguments.
.Pp
The
.Fn bus_dmamap_destroy
arguments are as follows:
.Bl -tag -width dmam -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa dmam
The DMA handle to destroy.
.El
.Pp
In the event that the DMA handle contains a valid mapping, the mapping
will be unloaded via the same mechanism used by
.Fn bus_dmamap_unload .
.Sh DMA MAP SEGMENTS
.nr nS 1
.Ft int
.Fn bus_dmamap_load "bus_dma_tag_t tag" "bus_dmamap_t dmam" "void *buf" \
                    "bus_size_t buflen" "struct proc *p" "int flags"
.Ft int
.Fn bus_dmamap_load_mbuf "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
                         "struct mbuf *chain" "int flags"
.Ft int
.Fn bus_dmamap_load_uio "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
                        "struct uio *uio" "int flags"
.Ft int
.Fn bus_dmamap_load_raw "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
                        "bus_dma_segment_t *segs" "int nsegs" \
                        "bus_size_t size" "int flags"
.Ft void
.Fn bus_dmamap_unload "bus_dma_tag_t tag" "bus_dmamap_t dmam"
.nr nS 0
.Pp
The
.Fn bus_dmamap_load
function loads a DMA handle with mappings for a DMA transfer.
It assumes that all pages involved in a DMA transfer are wired.
This function returns 0 on success, an error code otherwise.
.Pp
The
.Fn bus_dmamap_load
arguments are as follows:
.Bl -tag -width buflen -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa dmam
The DMA handle with which to map the transfer.
.It Fa buf
The buffer to be used for the DMA transfer.
.It Fa buflen
The size of the buffer.
.It Fa p
Used to indicate the address space in which the buffer is located.
If
.Dv NULL ,
the buffer is assumed to be in kernel space.
Otherwise, the buffer is assumed to be in process
.Fa p Ns 's
address space.
.It Fa flags
Flags are defined as follows:
.Bl -tag -width BUS_DMA_STREAMING -compact
.It Dv BUS_DMA_WAITOK
It is safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_NOWAIT
It is not safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_BUS[1-4]
These flags are placeholders, and may be used by buses to provide
bus-dependent functionality.
.It Dv BUS_DMA_STREAMING
By default, the
.Nm
API assumes that there is coherency between memory and the device
performing the DMA transaction.
Some platforms, however, have special hardware, such as an
.Dq I/O cache ,
which may improve performance
of some types of DMA transactions, but which break the assumption
that there is coherency between memory and the device performing
the DMA transaction.
This flag allows the use of this special hardware, provided that
the device is doing sequential, unidirectional transfers which
conform to certain alignment and size constraints defined by the
platform.
If the platform does not support the feature, or if
the buffer being loaded into the DMA map does not conform to the
constraints required for use of the feature, then this flag will
be silently ignored.
Also refer to the use of this flag with the
.Fn bus_dmamem_alloc
function.
.It Dv BUS_DMA_READ
This is a hint to the machine-dependent back-end that indicates the
mapping will be used only for a
.Em "device -\*[Gt] memory"
transaction.
The back-end may perform optimizations based on this information.
.It Dv BUS_DMA_WRITE
This is a hint to the machine-dependent back-end that indicates the
mapping will be used only for a
.Em "memory -\*[Gt] device"
transaction.
The back-end may perform optimizations based on this information.
.El
.El
.Pp
As noted above, if a DMA handle is created with
.Dv BUS_DMA_ALLOCNOW ,
.Fn bus_dmamap_load
will never block.
.Pp
If a call to
.Fn bus_dmamap_load
fails, the mapping in the DMA handle will be invalid.
It is the responsibility of the caller to clean up any inconsistent
device state resulting from incomplete iteration through the uio.
.Pp
The
.Fn bus_dmamap_load_mbuf
function is a variation of
.Fn bus_dmamap_load
which maps mbuf chains for DMA transfers.
Mbuf chains are assumed to be in kernel virtual address space.
.Pp
The
.Fn bus_dmamap_load_uio
function is a variation of
.Fn bus_dmamap_load
which maps buffers pointed to by
.Fa uio
for DMA transfers.
The value of
.Fa "uio->uio_segflg"
will determine if the buffers are in user or kernel virtual address
space.
If the buffers are in user address space, the buffers are assumed to be
in
.Fa "uio->uio_procp" Ns 's
address space.
.Pp
The
.Fn bus_dmamap_load_raw
function is a variation of
.Fn bus_dmamap_load
which maps buffers allocated by
.Fn bus_dmamem_alloc
(see below).
The
.Fa segs
argument is a
.Fa bus_dma_segment_t
array filled in by
.Fn bus_dmamem_alloc .
The
.Fa nsegs
argument is the number of segments in the array.
The
.Fa size
argument is the size of the DMA transfer.
.Pp
The
.Fn bus_dmamap_unload
function deletes the mappings for a given DMA handle.
This function always succeeds if given valid arguments.
Attempting to unload a map that is already unloaded is
not valid.
.Pp
The
.Fn bus_dmamap_unload
arguments are as follows:
.Bl -tag -width dmam -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa dmam
The DMA handle containing the mappings which are to be deleted.
.El
.Pp
If the DMA handle was created with
.Dv BUS_DMA_ALLOCNOW ,
.Fn bus_dmamap_unload
will not free the corresponding resources which were allocated by
.Fn bus_dmamap_create .
This is to ensure that
.Fn bus_dmamap_load
will never block on resources if the handle was created with
.Dv BUS_DMA_ALLOCNOW .
.Sh SYNCHRONIZATION
.nr nS 1
.Ft void
.Fn bus_dmamap_sync "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
                    "bus_addr_t offset" "bus_size_t size" \
                    "int ops"
.nr nS 0
.Pp
The
.Fn bus_dmamap_sync
function performs pre- and post-DMA operation cache and/or buffer
synchronization.
This function always succeeds if given valid arguments.
.Pp
The
.Fn bus_dmamap_sync
arguments are as follows:
.Bl -tag -width "offset" -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa dmam
The DMA mapping to be synchronized.
.It Fa offset
Offset in the DMA mapping to be synchronized.
.It Fa size
The size of the region to be synchronized.
.It Fa ops
One or more synchronization operations to perform.
The following DMA synchronization operations are defined:
.Bl -tag -width BUS_DMASYNC_POSTWRITE -compact
.It Dv BUS_DMASYNC_PREREAD
Perform any pre-read DMA cache and/or bounce operations.
.It Dv BUS_DMASYNC_POSTREAD
Perform any post-read DMA cache and/or bounce operations.
.It Dv BUS_DMASYNC_PREWRITE
Perform any pre-write DMA cache and/or bounce operations.
.It Dv BUS_DMASYNC_POSTWRITE
Perform any post-write DMA cache and/or bounce operations.
.El
.Pp
More than one operation may be performed in a given synchronization call.
Mixing of
.Em PRE
and
.Em POST
operations is not allowed, and behavior is undefined if this is attempted.
.El
.Pp
Synchronization operations are expressed from the perspective of the
host RAM, e.g., a
.Em "device -> memory"
operation is a
.Em READ
and a
.Em "memory -> device"
operation is a
.Em WRITE .
.Pp
.Fn bus_dmamap_sync
may consult state kept within the DMA map to determine if the memory is
mapped in a DMA coherent fashion.
If so,
.Fn bus_dmamap_sync
may elect to skip certain expensive operations, such as flushing of the
data cache.
See
.Fn bus_dmamem_map
for more information on this subject.
.Pp
On platforms which implement reordered stores,
.Fn bus_dmamap_sync
will always cause the store buffer to be flushed.
.Pp
This function exists so that multiple read and write transfers can be
performed with the same buffer, and so that drivers can explicitly
inform the
.Nm
code when their data is
.Dq ready
in its DMA buffer.
.Pp
An example of multiple read-write use of a single mapping
might look like:
.Bd -literal
bus_dmamap_load(...);

while (not done) {
	/* invalidate soon-to-be-stale cache blocks */
	bus_dmamap_sync(..., BUS_DMASYNC_PREREAD);

	[ do read DMA ]

	/* copy from bounce */
	bus_dmamap_sync(..., BUS_DMASYNC_POSTREAD);

	/* read data now in driver-provided buffer */

	[ computation ]

	/* data to be written now in driver-provided buffer */

	/* flush write buffers and writeback, copy to bounce */
	bus_dmamap_sync(..., BUS_DMASYNC_PREWRITE);

	[ do write DMA ]

	/* probably a no-op, but provided for consistency */
	bus_dmamap_sync(..., BUS_DMASYNC_POSTWRITE);
}

bus_dmamap_unload(...);
.Ed
.Pp
If DMA read and write operations are not preceded and followed by the
appropriate synchronization operations, behavior is undefined.
.Sh DMA-SAFE MEMORY
.nr nS 1
.Ft int
.Fn bus_dmamem_alloc "bus_dma_tag_t tag" "bus_size_t size" \
                     "bus_size_t alignment" "bus_size_t boundary" \
                     "bus_dma_segment_t *segs" "int nsegs" "int *rsegs" \
                     "int flags"
.Ft int
.Fn bus_dmamem_alloc_range "bus_dma_tag_t tag" "bus_size_t size" \
                     "bus_size_t alignment" "bus_size_t boundary" \
                     "bus_dma_segment_t *segs" "int nsegs" "int *rsegs" \
                     "int flags" "bus_addr_t low" "bus_addr_t high"
.Ft void
.Fn bus_dmamem_free "bus_dma_tag_t tag" "bus_dma_segment_t *segs" "int nsegs"
.nr nS 0
.Pp
The
.Fn bus_dmamem_alloc
function allocates memory that is "DMA safe" for the bus corresponding to the
given tag.
This function returns 0 on success, or an error code indicating mode of
failure.
.Pp
The mapping of this memory is machine-dependent (or "opaque");
machine-independent code should not assume that the addresses returned
are valid in kernel virtual address space, or that the addresses
returned are system physical addresses.
The address value returned as part of
.Fa segs
can thus not be used to program DMA controller address registers.
Only the values in the
.Fa dm_segs
array of a successfully loaded DMA map (using
.Fn bus_dmamap_load )
can be used for this purpose.
.Pp
Allocations will always be rounded to the hardware page size.
Callers may wish to take advantage of this, and cluster allocation of
small data structures.
.Pp
The
.Fn bus_dmamem_alloc
arguments are as follows:
.Bl -tag -width alignment -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa size
The amount of memory to allocate.
.It Fa alignment
Each segment in the allocated memory will be aligned to this value.
If the alignment is less than a hardware page size, it will be rounded
up to the hardware page size.
This value must be a power of two.
.It Fa boundary
Each segment in the allocated memory must not cross this boundary
(relative to zero).
This value must be a power of two.
A boundary value less than the size of the allocation is invalid.
.It Fa segs
The
.Fa bus_dma_segment_t
array, filled in as memory is allocated,
representing the opaque addresses of the memory chunks.
.It Fa nsegs
The number of segments available in
.Fa segs .
Used to specify the maximum number of segments that the allocated memory may
be divided into.
.It Fa rsegs
The number of segments used in
.Fa segs .
Used to return the actual number of segments the memory was divided into.
.It Fa flags
Flags are defined as follows:
.Bl -tag -width BUS_DMA_STREAMING -compact
.It Dv BUS_DMA_WAITOK
It is safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_NOWAIT
It is not safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_ZERO
The memory allocated should be zeroed.
.It Dv BUS_DMA_STREAMING
Adjusts, if necessary, the size, alignment, and boundary constraints
to conform to the platform-dependent requirements for the use of the
.Dv BUS_DMA_STREAMING
flag with the
.Fn bus_dmamap_load
function.
If the platform does not support the
.Dv BUS_DMA_STREAMING
feature, or if the size, alignment, and boundary constraints
would already satisfy the platform's requirements, this flag
is silently ignored.
The
.Dv BUS_DMA_STREAMING
flag will never relax the constraints specified in the call.
.It Dv BUS_DMA_BUS[1-4]
These flags are placeholders, and may be used by buses to provide
bus-dependent functionality.
.El
.El
.Pp
The
.Fn bus_dmamem_alloc_range
function is a variation of
.Fn bus_dmamem_alloc
that allows specification of the "DMA safe" bus address range
supported by the device.
The additional
.Fa low
and
.Fa high
arguments specify the lowest and highest bus address that the device
can use for DMA transfers.
This function should only be used if that address range differs from
the default address range for the bus.
.Pp
All pages allocated by
.Fn bus_dmamem_alloc
and
.Fn bus_dmameme_alloc_range
will be wired down until they are freed by
.Fn bus_dmamem_free .
.Pp
The
.Fn bus_dmamem_free
function frees memory previously allocated by
.Fn bus_dmamem_alloc
or
.Fn bus_dmamem_alloc_range ,
invalidating any mapping.
This function always succeeds if given valid arguments.
.Pp
The
.Fn bus_dmamem_free
arguments are as follows:
.Bl -tag -width nsegs -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa segs
The
.Fa bus_dma_segment_t
array filled in by
.Fn bus_dmamem_alloc .
.It Fa nsegs
The number of segments in
.Fa segs .
.El
.Sh MAPPING DMA-SAFE MEMORY
.nr nS 1
.Ft int
.Fn bus_dmamem_map "bus_dma_tag_t tag" "bus_dma_segment_t *segs" "int nsegs" \
                   "size_t size" "caddr_t *kvap" "int flags"
.Ft void
.Fn bus_dmamem_unmap "bus_dma_tag_t tag" "caddr_t kva" "size_t size"
.Ft paddr_t
.Fn bus_dmamem_mmap "bus_dma_tag_t tag" "bus_dma_segment_t *segs" \
                    "int nsegs" "off_t off" "int prot" "int flags"
.nr nS 0
.Pp
The
.Fn bus_dmamem_map
function maps memory allocated with
.Fn bus_dmamem_alloc
or
.Fn bus_dmamem_alloc_range
into kernel virtual address space.
This function returns 0 on success, an error code otherwise, and must not be
called from an interrupt context.
.Pp
The
.Fn bus_dmamem_map
arguments are as follows:
.Bl -tag -width flags -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa segs
The
.Fa bus_dma_segment_t
array filled in by
.Fn bus_dmamem_alloc ,
representing the memory regions to map.
.It Fa nsegs
The number of segments in
.Fa segs .
.It Fa size
The size of the mapping.
.It Fa kvap
Filled in to specify the kernel virtual address where the memory is
mapped.
.It Fa flags
Flags are defined as follows:
.Bl -tag -width BUS_DMA_COHERENT -compact
.It Dv BUS_DMA_WAITOK
It is safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_NOWAIT
It is not safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_BUS[1-4]
These flags are placeholders, and may be used by buses to provide
bus-dependent functionality.
.It Dv BUS_DMA_COHERENT
This flag is a
.Em hint
to machine-dependent code.
If possible, map the memory in such a way as it will be DMA coherent.
This may include mapping the pages into uncached address space or
setting the cache-inhibit bits in page table entries.
If implementation of DMA coherent mappings is impossible, this is
ignored.
.Pp
Later, when this memory is loaded into a DMA map, machine-dependent code
will take whatever steps are necessary to determine if the memory was
mapped in a DMA coherent fashion.
This may include checking if the kernel virtual address lies within
uncached address space or if the cache-inhibit bits are set in page
table entries.
If it is determined that the mapping is DMA coherent, state may be
placed into the DMA map for use by later calls to
.Fn bus_dmamap_sync .
.It Dv BUS_DMA_NOCACHE
This flag is a
.Em hint
to machine-dependent code.
If possible, map the memory uncached.
.El
.El
.Pp
The
.Fn bus_dmamem_unmap
function unmaps memory previously mapped with
.Fn bus_dmamem_map ,
freeing the kernel virtual address space used by the mapping.
This function always succeeds if given valid arguments, but must not be
called from an interrupt context.
.Pp
.Fn bus_dmamem_unmap
arguments are as follows:
.Bl -tag -width size -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa kva
The kernel virtual address of the mapped memory.
.It Fa size
The size of the mapping.
.El
.Pp
The
.Fn bus_dmamem_mmap
function provides support for user
.Xr mmap 2 Ns 'ing
of DMA-safe memory.
.Fn bus_dmamem_mmap
is to be called by a device driver's
.Fn (*d_mmap)
entry point, which is called by the device pager for each page to be mapped.
This function returns a physical address to be passed to
.Fn pmap_enter
by the device pager, or -1 on failure.
.Fn bus_dmamem_mmap
arguments are
as follows:
.Bl -tag -width nsegs -compact
.It Fa tag
The
.Fa bus_dma_tag_t
passed down from the parent driver via
.Fa <bus>_attach_args .
.It Fa segs
The
.Fa bus_dma_segment_t
array filled in by
.Fn bus_dmamem_alloc ,
representing the memory to be
.Xr mmap 2 Ns 'ed .
.It Fa nsegs
The number of elements in the
.Fa segs
array.
.It Fa off
The offset of the page in DMA memory which is to be mapped.
.It Fa prot
The protection codes for the mapping.
.It Fa flags
Flags are defined as follows:
.Bl -tag -width BUS_DMA_COHERENT -compact
.It Dv BUS_DMA_WAITOK
It is safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_NOWAIT
It is not safe to wait (sleep) for resources during this call.
.It Dv BUS_DMA_BUS[1-4]
These flags are placeholders, and may be used by buses to provide
bus-dependent functionality.
.It Dv BUS_DMA_COHERENT
See
.Fn bus_dmamem_map
above for a description of this flag.
.It Dv BUS_DMA_NOCACHE
See
.Fn bus_dmamem_map
above for a description of this flag.
.El
.El
.Sh SEE ALSO
.Xr bus_space 9
.Sh HISTORY
The
.Nm
interface appeared in
.Nx 1.3 .
.Sh AUTHORS
The
.Nm
interface was designed and implemented by
.An Jason R. Thorpe
of the Numerical Aerospace Simulation Facility, NASA Ames Research Center.
Additional input on the
.Nm
design was provided by Chris Demetriou, Charles Hannum, Ross Harvey,
Matthew Jacob, Jonathan Stone, and Matt Thomas.
@


1.35
log
@spelling fix;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.34 2015/01/24 19:20:26 jmc Exp $
d32 2
a33 2
.Dd $Mdocdate: January 24 2015 $
.Dt BUS_DMA 9
d36 14
a49 1
.Nm bus_dma
@


1.34
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.33 2015/01/24 16:06:46 kettenis Exp $
d655 1
a655 1
function is a variaton of
@


1.33
log
@Document bus_dmamem_alloc_range(9).
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.32 2014/09/08 01:27:55 schwarze Exp $
d32 1
a32 1
.Dd $Mdocdate: September 8 2014 $
d658 2
a659 1
supported by the device.  The additional
d666 1
a666 1
the the default address range for the bus.
@


1.32
log
@obvious cases of missing .An;
found with the new mandoc(1) MANDOCERR_AN_MISSING warning;
no text changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.31 2013/06/04 19:27:04 schwarze Exp $
d32 1
a32 1
.Dd $Mdocdate: June 4 2013 $
d555 5
d653 14
d669 2
d677 3
a679 1
.Fn bus_dmamem_alloc ,
d717 2
@


1.31
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.30 2012/12/10 13:01:26 mpi Exp $
d32 1
a32 1
.Dd $Mdocdate: December 10 2012 $
d846 3
a848 2
interface was designed and implemented by Jason R. Thorpe of the
Numerical Aerospace Simulation Facility, NASA Ames Research Center.
@


1.30
log
@Mention the BUS_DMA_NOCACHE flag, prodded by oga, reads ok to jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.29 2010/12/26 15:40:57 miod Exp $
d32 1
a32 1
.Dd $Mdocdate: December 26 2010 $
d39 1
a39 1
.Fd #include <machine/bus.h>
@


1.29
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.28 2009/04/20 00:46:47 oga Exp $
d32 1
a32 1
.Dd $Mdocdate: April 20 2009 $
d750 5
d827 4
@


1.28
log
@Document BUS_DMA_ZERO.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.27 2008/06/26 05:42:08 ray Exp $
d32 1
a32 1
.Dd $Mdocdate: June 26 2008 $
d784 3
a786 2
This function returns an opaque value to be interpreted by the device
pager, or -1 on failure.
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.26 2008/05/26 04:14:31 brad Exp $
d32 1
a32 1
.Dd $Mdocdate: May 26 2008 $
d625 2
@


1.26
log
@formatting nit in the pseudocode.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.25 2007/05/31 19:20:00 jmc Exp $
a18 7
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgment:
.\" 	This product includes software developed by the NetBSD
.\" 	Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
d32 1
a32 1
.Dd $Mdocdate: May 31 2007 $
@


1.25
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.24 2006/10/28 10:26:26 jmc Exp $
d39 1
a39 1
.Dd $Mdocdate$
d95 1
a95 1
        for (i=0; i<dm_nsegs; i++) {
@


1.24
log
@prefer `buses' to `busses' for the noun plural;
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.23 2006/05/27 00:29:55 krw Exp $
d39 1
a39 1
.Dd November 23, 2000
@


1.23
log
@Eradicate the type 'bus_dmasync_op_t'. Unused. Sporadically
implemented. Use int.

ok mickey@@ miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.22 2006/03/26 14:47:26 marco Exp $
d226 1
a226 1
These flags are placeholders, and may be used by busses to provide
d315 1
a315 1
These flags are placeholders, and may be used by busses to provide
d648 1
a648 1
These flags are placeholders, and may be used by busses to provide
d734 1
a734 1
These flags are placeholders, and may be used by busses to provide
d823 1
a823 1
These flags are placeholders, and may be used by busses to provide
@


1.22
log
@Better verbiage on unloading a map.  PR 5059

from jason@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.21 2005/11/28 20:16:00 krw Exp $
d442 1
a442 1
                    "bus_dmasync_op_t ops"
@


1.21
log
@Some verbiage tweaks and cleanup. Sprinkle .Fa around for types and
fields. No semantic changes or additions.

ok jmc@@ marco@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.20 2005/09/18 21:52:47 dlg Exp $
d412 2
@


1.20
log
@missing word

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.19 2004/05/10 18:14:42 pvalchev Exp $
d53 15
a67 7
The basic abstraction is the bus_dmamap_t, a pointer to a structure
which contains an array of bus_dma_segment_t's (dm_segs) and a count
of how many are currently valid (dm_nsegs).
.Pp
Each segment in the array describes a single physical area of memory
which can be DMA'd, with a starting address (ds_addr) and a length
(ds_len).
d72 5
a76 3
bus_dma_tag_t's are an opaque type, received from higher software
layers and are never created, changed, deleted or even examined in
this interface.
d186 3
a188 1
This is the bus_dma_tag_t passed down from the parent driver via
d191 1
a191 1
This is the maximum DMA transfer that can be mapped by the handle.
d230 3
a232 1
This is a pointer to a bus_dmamap_t.
d248 3
a250 1
This is the bus_dma_tag_t passed down from the parent driver via
d289 3
a291 1
This is the bus_dma_tag_t passed down from the parent driver via
d397 3
a399 1
argument is an array of bus_dma_segment_t's filled in by
d418 3
a420 1
This is the bus_dma_tag_t passed down from the parent driver via
d452 1
a452 1
.Bl -tag -width "dmam" -compact
d454 3
a456 1
This is the bus_dma_tag_t passed down from the parent driver via
d593 3
a595 1
This is the bus_dma_tag_t passed down from the parent driver via
d610 3
a612 1
An array of bus_dma_segment_t's, filled in as memory is allocated,
d615 4
a618 4
Specifies the number of segments in
.Fa segs ,
and this is the maximum number of segments that the allocated memory may
contain.
d620 3
a622 1
Used to return the actual number of segments the memory contains.
d668 3
a670 1
This is the bus_dma_tag_t passed down from the parent driver via
d673 3
a675 1
The array of bus_dma_segment_t's filled in by
d706 3
a708 1
This is the bus_dma_tag_t passed down from the parent driver via
d711 3
a713 1
The array of bus_dma_segment_t's filled in by
d768 3
a770 1
This is the bus_dma_tag_t passed down from the parent driver via
d784 3
a786 2
is to be called by a device driver's (*d_mmap)() entry
point, which is called by the device pager for each page to be mapped.
d794 3
a796 1
This is the bus_dma_tag_t passed down from the parent driver via
d799 3
a801 1
The array of bus_dma_segment_t's filled in by
@


1.19
log
@correct description of bus_dmamap_sync; help & ok mickey
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.18 2003/06/06 20:56:32 jmc Exp $
d454 1
a454 1
More than one operation may performed in a given synchronization call.
@


1.18
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.17 2003/04/25 14:31:54 jmc Exp $
d417 1
d436 4
@


1.17
log
@removed unused .Bl
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.16 2003/04/15 04:14:29 jmc Exp $
a412 1
.Pp
d781 5
a794 5
.Sh HISTORY
The
.Nm
interface appeared in
.Nx 1.3 .
@


1.16
log
@typos;

VOP, crypto and disklabel ok tedu@@
audio(9) ok naddy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.14 2003/01/11 06:14:35 wcobb Exp $
a155 1
.Bl -tag -width compact
@


1.15
log
@dma -> DMA

ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.14 2003/01/11 06:14:35 wcobb Exp $ 
d6 1
a6 1
.\" 
d10 1
a10 1
.\" 
d323 1
a323 1
This is a hint to the machine-dependent back-end that indicates the  
d438 1
a438 1
One or more synchronization operation to perform.
d545 1
a545 1
machine-independent code is not to assume that the addresses returned
d604 1
a604 1
If the platform does not support the  
@


1.14
log
@- arrange the prototypes in sections.
- describe bus_addr_t and bus_size_t in DATA TYPES.
- remove redundant NOTES section.
ok art@@, jason@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.13 2002/11/08 08:08:47 mpech Exp $ 
d68 1
a68 1
The basic cycle to transfer data to/from a dma device is:
d72 1
a72 1
for each dma xfer {
d83 1
a83 1
        bus_dmamap_sync();   /* synchronize/flush any dma cache      */
d95 1
a95 1
        bus_dmamap_sync();   /* synchronize/flush any dma cache      */
@


1.13
log
@Time to cleanup:
o) start new sentence on a new line;
o) wrap long lines;
o) don't use .Pp before/after .Sh, .Ss;
o) OpenBSD -> .Ox;
o) typos;
o) close .Rs;
o) use space between arguments in tag, for example:
   .Xr blabla ) .

miod@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.12 2002/06/12 07:10:36 aaron Exp $ 
d43 1
a43 14
.Nm bus_dma ,
.Nm bus_dmamap_create ,
.Nm bus_dmamap_destroy ,
.Nm bus_dmamap_load ,
.Nm bus_dmamap_load_mbuf ,
.Nm bus_dmamap_load_uio ,
.Nm bus_dmamap_load_raw ,
.Nm bus_dmamap_unload ,
.Nm bus_dmamap_sync ,
.Nm bus_dmamem_alloc ,
.Nm bus_dmamem_free ,
.Nm bus_dmamem_map ,
.Nm bus_dmamem_unmap ,
.Nm bus_dmamem_mmap
a46 35
.Ft int
.Fn bus_dmamap_create "bus_dma_tag_t tag" "bus_size_t size" "int nsegments" \
"bus_size_t maxsegsz" "bus_size_t boundary" "int flags" "bus_dmamap_t *dmamp"
.Ft void
.Fn bus_dmamap_destroy "bus_dma_tag_t tag" "bus_dmamap_t dmam"
.Ft int
.Fn bus_dmamap_load "bus_dma_tag_t tag" "bus_dmamap_t dmam" "void *buf" \
"bus_size_t buflen" "struct proc *p" "int flags"
.Ft int
.Fn bus_dmamap_load_mbuf "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
"struct mbuf *chain" "int flags"
.Ft int
.Fn bus_dmamap_load_uio "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
"struct uio *uio" "int flags"
.Ft int
.Fn bus_dmamap_load_raw "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
"bus_dma_segment_t *segs" "int nsegs" "bus_size_t size" "int flags"
.Ft void
.Fn bus_dmamap_unload "bus_dma_tag_t tag" "bus_dmamap_t dmam"
.Ft void
.Fn bus_dmamap_sync "bus_dma_tag_t tag" "bus_dmamap_t dmam" "bus_dmasync_op_t ops"
.Ft int
.Fn bus_dmamem_alloc "bus_dma_tag_t tag" "bus_size_t size" \
"bus_size_t alignment" "bus_size_t boundary" "bus_dma_segment_t *segs" \
"int nsegs" "int *rsegs" "int flags"
.Ft void
.Fn bus_dmamem_free "bus_dma_tag_t tag" "bus_dma_segment_t *segs" "int nsegs"
.Ft int
.Fn bus_dmamem_map "bus_dma_tag_t tag" "bus_dma_segment_t *segs" "int nsegs" \
"size_t size" "caddr_t *kvap" "int flags"
.Ft void
.Fn bus_dmamem_unmap "bus_dma_tag_t tag" "caddr_t kva" "size_t size"
.Ft paddr_t
.Fn bus_dmamem_mmap "bus_dma_tag_t tag" "bus_dma_segment_t *segs" \
"int nsegs" "off_t off" "int prot" "int flags"
a108 11
.Sh NOTES
All data structures, function prototypes, and macros are defined in
the architecture-specific header
.Aq Pa machine/bus.h .
Note that this document assumes the existence of types already defined
by the current "bus.h" interface.
.Pp
Unless otherwise noted, all function calls in this interface may be
defined as
.Xr cpp 1
macros.
d112 5
a116 1
.Bl -tag -width compact
d119 4
a122 1
a given bus.
d124 3
a126 1
A structure with at least the following members:
d131 1
a131 2
.sp
The structure may have machine-dependent members and arbitrary layout.
d136 1
a136 1
are suitable for programming into DMA controller address and length
d139 3
a141 1
A pointer to a structure with at least the following members:
d146 1
a146 2
.sp
The structure may have machine-dependent members and arbitrary layout.
d155 1
a155 1
.Sh FUNCTIONS
d157 12
a168 2
.It Fn bus_dmamap_create "tag" "size" "nsegments" "maxsegsz" "boundary" "flags" "dmamp"
Allocates a DMA handle and initializes it according to the parameters
d170 5
a174 1
Arguments are as follows:
d225 4
a228 2
Behavior is not defined if invalid arguments are passed to
.Fn bus_dmamap_create .
d230 3
a232 4
Returns 0 on success, or an error code to indicate mode of failure.
.It Fn bus_dmamap_destroy "tag" "dmam"
Frees all resources associated with a given DMA handle.
Arguments are as follows:
d244 18
d263 5
a267 2
Behavior is not defined if invalid arguments are passed to
.Fn bus_dmamap_destroy .
d269 3
a271 7
If given valid arguments,
.Fn bus_dmamap_destroy
always succeeds.
.It Fn bus_dmamap_load "tag" "dmam" "buf" "buflen" "p" "flags"
Loads a DMA handle with mappings for a DMA transfer.
It assumes that all pages involved in a DMA transfer are wired.
Arguments are as follows:
d348 3
a350 6
Behavior is not defined if invalid arguments are passed to
.Fn bus_dmamap_load .
.Pp
Returns 0 on success, or an error code to indicate mode of failure.
.It Fn bus_dmamap_load_mbuf "tag" "dmam" "chain" "flags"
This is a variation of
d354 4
a357 2
.It Fn bus_dmamap_load_uio "tag" "dmam" "uio" "flags"
This is a variation of
d370 4
a373 2
.It Fn bus_dmamap_load_raw "tag" "dmam" "segs" "nsegs" "size" "flags"
This is a variation of
d388 9
a396 3
.It Fn bus_dmamap_unload "tag" "dmam"
Deletes the mappings for a given DMA handle.
Arguments are as follows:
d415 12
a426 2
Behavior is not defined if invalid arguments are passed to
.Fn bus_dmamap_unload .
d428 4
a431 7
If given valid arguments,
.Fn bus_dmamap_unload
always succeeds.
.It Fn bus_dmamap_sync "tag" "dmam" "ops"
Performs pre- and post-DMA operation cache and/or buffer synchronization.
Arguments are as follows:
.Bl -tag -width offset -compact
d526 10
d537 3
a539 9
Behavior is not defined if invalid arguments are passed to
.Fn bus_dmamap_sync .
.Pp
If given valid arguments,
.Fn bus_dmamap_sync
always succeeds.
.\" XXX: This does not work with all the arguments.
.It Fn bus_dmamem_alloc "tag" "size" "alignment" "boundary" "segs" "..."
Allocates memory that is "DMA safe" for the bus corresponding to the
d541 2
d560 4
a563 1
Arguments are as follows:
d623 6
a628 2
Behavior is undefined if invalid arguments are passed to
.Fn bus_dmamem_alloc .
d630 3
a632 6
Returns 0 on success, or an error code indicating mode of failure.
.It Fn bus_dmamem_free "tag" "segs" "nsegs"
Frees memory previously allocated by
.Fn bus_dmamem_alloc .
Any mappings will be invalidated.
Arguments are as follows:
d644 11
d656 3
a658 8
Behavior is undefined if invalid arguments are passed to
.Fn bus_dmamem_free .
.Pp
If given valid arguments,
.Fn bus_dmamem_free
always succeeds.
.It Fn bus_dmamem_map "tag" "segs" "nsegs" "size" "kvap" "flags"
Maps memory allocated with
d661 6
a666 1
Arguments are as follows:
d715 3
a717 7
Behavior is undefined if invalid arguments are passed to
.Fn bus_dmamem_map .
This function must not be called from an interrupt context.
.Pp
Returns 0 on success, or an error code indicating mode of failure.
.It Fn bus_dmamem_unmap "tag" "kva" "size"
Unmaps memory previously mapped with
d720 5
a724 1
The arguments are as follows:
d735 3
a737 9
Behavior is undefined if invalid arguments are passed to
.Fn bus_dmamem_unmap .
This function must not be called from an interrupt context.
.Pp
If given valid arguments,
.Fn bus_dmamem_unmap
always succeeds.
.It Fn bus_dmamem_mmap "tag" "segs" "nsegs" "off" "prot" "flags"
Provides support for user
d740 2
a741 1
This function is to be called by a device driver's (*d_mmap)() entry
d743 4
a746 1
The arguments are
a779 9
.El
.Pp
Behavior is undefined if invalid arguments are passed
to
.Fn bus_dmamem_mmap .
.Pp
Returns -1 to indicate failure.
Otherwise, returns an opaque value to be interpreted by the device
pager.
@


1.12
log
@Minor typographical fixes and spelling.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.11 2002/05/28 09:07:07 mpech Exp $ 
d322 2
a323 2
performing the DMA transaction.  Some platforms, however, have
special hardware, such as an
@


1.11
log
@	man9/:
o) Start new sentence on a new line;
o) FreeBSD -> .Fx;
o) OpenBSD -> .Ox;
o) Close .Bl/Bd lists;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.10 2002/03/07 18:09:24 jason Exp $ 
d147 1
a147 1
         * copy any data desired from the DMA'able memory using the
d160 1
a160 1
.Pa Aq machine/bus.h .
d309 2
a310 2
are defined as follows:
.Bl -tag -width "BUS_DMA_STREAMING" -compact
d464 1
a464 1
host RAM, e.g. a
d492 3
a494 1
code when their data is 'ready' in its DMA buffer.
d552 2
a553 2
.Fn bus_dmamap_load
) can be used for this purpose.
d561 1
a561 1
The is the bus_dma_tag_t passed down from the parent driver via
d593 1
a593 1
Adjusts, if necessary, the size, alignment, and boundary constrains
@


1.10
log
@Add descriptions of BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
(from NetBSD)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.9 2001/09/03 09:29:18 art Exp $ 
d332 2
a333 1
platform.  If the platform does not support the feature, or if
d336 2
a337 1
be silently ignored.  Also refer to the use of this flag with the
d344 2
a345 2
transaction.  The back-end may perform optimizations based on this
information.
d350 2
a351 2
transaction.  The back-end may perform optimizations based on this
information.
d596 2
a597 1
function.  If the platform does not support the  
d601 2
a602 1
is silently ignored.  The
@


1.9
log
@Catch up with API changes.
From "Brian J. Kifiak" <bk@@rt.fm>
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.8 2001/08/02 18:37:34 mpech Exp $ 
d310 1
a310 1
.Bl -tag -width "BUS_DMA_BUS[1-4]" -compact
d318 32
d583 1
a583 1
.Bl -tag -width BUS_DMA_BUS[1-4] -compact
d588 13
@


1.8
log
@o) .Sh AUTHOR -> .Sh AUTHORS;
o) .Sh EXAMPLE -> .Sh EXAMPLES;
o) Delete .Sh OPTIONS. Text moved to .Sh DESCRIPTION;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.7 2001/07/04 04:59:20 jason Exp $ 
d80 1
a80 1
.Fn bus_dmamap_sync "bus_dma_tag_t tag" "bus_dmamap_t dmam" "int ops"
d92 1
a92 1
.Ft int
d94 1
a94 1
"int nsegs" "int off" "int prot" "int flags"
@


1.7
log
@couple of typo's; netbsd
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.6 2001/07/02 00:19:56 jason Exp $ 
d726 1
a726 1
.Sh AUTHOR
@


1.6
log
@english is my first and only language... you'd never know it.
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.5 2001/06/29 02:10:05 jason Exp $ 
d26 1
a26 1
.\" 
d690 1
a690 1
.Xr mmap 2 Ns 'ed.
@


1.5
log
@note safety (discussed with art)
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.4 2001/06/28 22:14:23 millert Exp $ 
d648 2
a649 2
.Fn bus_dmamem_map 
and must not be called from an interrupt context.
d668 2
a669 2
.Fn bus_dmamem_unmap
and must not be call from an interrupt context.
@


1.4
log
@speling; jsyn@@nthought.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.3 2001/02/22 00:54:01 krw Exp $ 
d648 2
a649 1
.Fn bus_dmamem_map .
d668 2
a669 1
.Fn bus_dmamem_unmap .
@


1.3
log
@First attempt at porting bus_dma.9 from NetBSD.

Changes to bus_dma.9 from NetBSD v1.14:

1) Delete two parameters (3rd & 4th) from bus_dmamap_sync (offset &
len)

2) Delete dm_mapsize as a 'required' member of bus_dmamap_t (only
present in vax/bus.h and alpha/bus.h)

3) Usual OpenBSD style-istic changes: no trailing white space, new
lines for all sentences, reparagraph to eliminate short lines

** Issues with bus_dma.9 **

vax/bus.h still defines two parameters in bus_dmamap_sync() that are
removed elsewhere (offset & len)
@
text
@d1 1
a1 1
.\"	$OpenBSD$ 
d515 1
a515 1
array of a sucessfully loaded DMA map (using
@


1.2
log
@REVERT TO PREVIOUS STATE OF AFFAIR.

If those pages are different from the NetBSD version, maybe there's a
reason ?

Like, possibly, I just read our source code, which just happens to do
things in DIFFERENT ways than NetBSD does ?

As far as the added pages go, they obviously haven't been checked against
actual code as well, hence they're worse than useless, since a large part
of the information is definitely misleading.
@
text
@d1 2
a2 2
.\"	$OpenBSD: bus_dma.9,v 1.1 1999/09/22 03:16:47 csapuntz Exp $
.\"	$NetBSD: bus_dma.9,v 1.11 1999/03/16 00:40:47 garbled Exp $
d39 1
a39 1
.Dd February 3, 1998
d57 1
a57 1
.Nd Bus and Machine Independent DMA Mapping Interface
d80 1
a80 2
.Fn bus_dmamap_sync "bus_dma_tag_t tag" "bus_dmamap_t dmam" \
"bus_addr_t offset" "bus_size_t len" "int ops"
d96 61
a156 1
Provide a bus- and machine-independent "DMA mapping interface."
d158 2
a159 3
.Pp
All data structures, function prototypes, and macros will be defined
by the port-specific header
d161 2
a162 3
Note that this document
assumes the existence of types already defined by the current "bus.h"
interface.
d169 2
a170 3
.Pp
Individual implementations may name these structures whatever they
wish, providing that the external representations are:
d173 2
a174 2
A machine-dependent opaque type describing the implementation of
DMA for a given bus.
d187 2
a188 2
are suitable for programming into
DMA controller address and length registers.
d192 1
a192 2
	bus_size_t	dm_mapsize;
	int		dm_nsegs;
d198 2
a199 3
.Fa dm_mapsize
member indicates the size of the mapping.  A value of 0 indicates the
mapping is invalid.
a200 3
.Fa dm_segs
member may be an array of segments or a pointer to an
array of segments.  The
d226 3
a228 2
particular boundary.  This argument allows this boundary to be
specified.  The boundary lines begin at 0, and occur every
d230 4
a233 2
bytes.  Mappings may begin on a boundary line but may not end on or
cross a boundary line.  If no boundary condition needs to be observed, a
d244 2
a245 2
Perform any resource allocation this handle may need now.  If this is
not specified, the allocation may be deferred to
d249 1
a249 2
will not block on resource
allocation.
d255 2
a256 2
This is a pointer to a bus_dmamap_t.  A DMA map will be allocated and
pointed to by 
d266 2
a267 2
Frees all resources associated with a given DMA handle.  Arguments are
as follows:
d276 2
a277 2
In the event that the DMA handle contains a valid mapping,
the mapping will be unloaded via the same mechanism used by 
d287 2
a288 2
Loads a DMA handle with mappings for a DMA transfer.  It assumes that
all pages involved in a DMA transfer are wired.
d301 2
a302 1
Used to indicate the address space in which the buffer is located.  If
d304 2
a305 2
the buffer is assumed to be in kernel space.  Otherwise, the
buffer is assumed to be in process
d316 2
a317 2
These flags are placeholders, and may be used by busses to
provide bus-dependent functionality.
d326 1
a326 1
If a call to 
d328 3
a330 4
fails, the mapping in
the DMA handle will be invalid.  It is the responsibility
of the caller to clean up any inconsistent device state
resulting from incomplete iteration through the uio.
d337 1
a337 1
This is a variation of 
d339 2
a340 3
which maps mbuf chains
for DMA transfers.  Mbuf chains are assumed to be in kernel
virtual address space.
d346 2
a347 1
for DMA transfers.  The value of
d349 2
a350 2
will
determine if the buffers are in user or kernel virtual address space.
d358 1
a358 2
which maps buffers
allocated by
d360 2
a361 1
(see below).  The
d363 1
a363 2
argument is an array of bus_dma_segment_t's filled in
by
d367 2
a368 1
argument is the number of segments in the array.  The
d372 2
a373 1
Deletes the mappings for a given DMA handle.  Arguments are as follows:
d385 1
a385 2
will not free the corresponding
resources which were allocated by
d389 1
a389 2
will never block
on resources if the handle was created with
d398 1
a398 1
.It Fn bus_dmamap_sync "tag" "dmam" "offset" "len" "ops"
a406 6
.It Fa offset
The offset into the DMA mapping to synchronize.
.It Fa len
The length of the mapping from
.Fa offset
to synchronize.
d408 2
a409 2
One or more synchronization operation to perform.  The following DMA
synchronization operations are defined:
d429 2
a430 2
Synchronization operations are expressed from the perspective of
the host RAM, e.g. a
a438 3
.Fn bus_dmamp_sync
may consult state kept within the DMA map to determine if the memory
is mapped in a DMA coherent fashion.  If so,
d440 7
a446 2
may elect to skip certain expensive operations, such as flushing
of the data cache.  See
d457 1
a457 1
.Nm 
d504 18
a521 8
given tag.  The mapping of this memory is machine-dependent (or
"opaque"); machine-independent code is not to assume that the
addresses returned are valid in kernel virtual address space, or that
the addresses returned are system physical addresses.
.Pp
Allocations will always be rounded to the hardware page size.  Callers
may wish to take advantage of this, and cluster allocation of small
data structures.
d530 4
a533 3
Each segment in the allocated memory will be aligned to this value.  If
the alignment is less than a hardware page size, it will be rounded up
to the hardware page size.  This value must be a power of two.
d536 3
a538 2
(relative to zero).  This value must be a power of two.  A boundary
value less than the size of the allocation is invalid.
d545 2
a546 2
and this is the maximum number
of segments that the allocated memory may contain.
d564 1
a564 2
will be wired down
until they are freed by
d572 1
a572 1
Frees memory previously allocated by 
d574 2
a575 2
Any mappings
will be invalidated.  Arguments are as follows:
d591 1
a591 1
If given valid arguments, 
d597 2
a598 1
into kernel virtual address space.  Arguments are as follows:
d613 2
a614 1
Filled in to specify the kernel virtual address where the memory is mapped.
d628 6
a633 5
to machine-dependent code.  If possible, map the memory in such a way
as it will be DMA coherent.  This may include mapping the pages into
uncached address space or setting the cache-inhibit bits in page table
entries.  If implementation of DMA coherent mappings is impossible, this
is ignored.
d637 6
a642 5
mapped in a DMA coherent fashion.  This may include checking if the
kernel virtual address lies within uncached address space or if the
cache-inhibit bits are set in page table entries.  If it is determined
that the mapping is DMA coherent, state may be placed into the DMA map
for use by later calls to
d654 2
a655 3
freeing the
kernel virtual address space used by the mapping.  The arguments are as
follows:
d669 1
a669 1
If given valid arguments, 
d675 4
a678 3
of DMA-safe memory.  This function is to be called by a device
driver's (*d_mmap)() entry point, which is called by the
device pager for each page to be mapped.  The arguments are
d718 3
a720 2
Returns -1 to indicate failure.  Otherwise, returns an opaque
value to be interpreted by the device pager.
@


1.1
log
@

Add/update some man9 pages from NetBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: bus_dma.9,v 1.11 1999/03/16 00:40:47 garbled Exp $
@

