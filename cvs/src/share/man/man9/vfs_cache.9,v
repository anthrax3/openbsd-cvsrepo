head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.38
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.34
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.36
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.28
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.32
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.30
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.26
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.24
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.22
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.20
	OPENBSD_5_0:1.3.0.18
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.16
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.14
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.12
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.8
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@.\" @;


1.3
date	2007.05.31.19.20.01;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.20.15.48.52;	author jaredy;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.18.55;	author jaredy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@convert to new .Dd format;
@
text
@.\"	$OpenBSD: vfs_cache.9,v 1.2 2005/06/20 15:48:52 jaredy Exp $
.\" Written by Jared Yanovich <jaredy@@openbsd.org>
.\" Public domain, 2005/6/17
.Dd $Mdocdate$
.Dt VFS_CACHE 9
.Os
.Sh NAME
.Nm vfs_cache ,
.Nm cache_enter ,
.Nm cache_lookup ,
.Nm cache_purge ,
.Nm cache_purgevfs ,
.Nm cache_revlookup
.Nd name lookup cache
.Sh SYNOPSIS
.In sys/vnode.h
.In sys/namei.h
.Pp
.Ft int
.Fn cache_lookup "struct vnode *dvp" "struct vnode **vpp" \
    "struct componentname *cnp"
.Ft void
.Fn cache_enter "struct vnode *dvp" "struct vnode *vp" \
    "struct componentname *cnp"
.Ft void
.Fn cache_purge "struct vnode *vp"
.Ft void
.Fn cache_purgevfs "struct mount *mp"
.Ft int
.Fn cache_revlookup "struct vnode *vp" "struct vnode **dvpp" \
    "char **bpp" "char *bufp"
.Sh DESCRIPTION
In order to speed up file name look-up operations (see
.Xr VOP_LOOKUP 9 ) ,
the kernel provides an interface for maintaining a cache of the most
recently looked-up file name translations.
Entries in this cache have the following definition:
.Bd -literal
struct	namecache {
	LIST_ENTRY(namecache) nc_hash;	/* hash chain */
	LIST_ENTRY(namecache) nc_vhash;	/* (reverse) dir hash chain */
	TAILQ_ENTRY(namecache) nc_lru;	/* LRU chain */
	struct	vnode *nc_dvp;		/* vnode of parent of name */
	u_long	nc_dvpid;		/* capability number of nc_dvp */
	struct	vnode *nc_vp;		/* vnode the name refers to */
	u_long	nc_vpid;		/* capability number of nc_vp */
	char	nc_nlen;		/* length of name */
	char	nc_name[NCHNAMLEN];	/* segment name */
};
.Ed
.Pp
The cache is indexed by a hash value based on the file's base name and
its encompassing directory's vnode generation number.
Negative caching is also performed so that frequently accessed path
names of files that do not exist do not result in expensive lookups.
.Pp
File names with length longer than
.Dv NCHNAMLEN
are not cached to simplify lookups and to save space.
Such names are rare and are generally not worth caching.
.Pp
The
.Nm vfs_cache
API contains the following routines:
.Bl -tag -width Ds
.It Fn cache_lookup dvp vpp cnp
Look up the given name in the cache.
.Fa dvp
points to the directory to search,
.Fa vpp
points to a pointer where the vnode of the name being sought will be
stored, and
.Fa cnp
contains the last component of the path name.
.Fa cnp
must have the
.Va cn_nameptr ,
.Va cn_namelen ,
and
.Va cn_hash
fields filled in.
If no entry is found for the given name, a new one will be created,
even if the path name fails (i.e. it will be negative cached), unless
the
.Xr namei 9
lookup operation was
.Dv DELETE
or the
.Dv NOCACHE
flag was set for the call to
.Xr namei 9 .
.Pp
Upon success, a pointer to a locked vnode is stored in
.Fa vpp
and a zero value is returned.
If locking the vnode fails, the vnode will remain unlocked,
.Fa *vpp
will be set to
.Dv NULL ,
and the corresponding error will be returned.
If the cache entry is negative cached, meaning the name is no longer
valid,
.Er ENOENT
is returned.
Otherwise, the cache lookup has failed and a \-1 value is returned.
.It Fn cache_enter dvp vp cnp
Add a new entry for the translation in the directory
.Fa dvp
for the vnode
.Fa vp
with name
.Fa cnp
to the cache.
.Fa cnp
must have the
.Va cn_nameptr ,
.Va cn_namelen ,
and
.Va cn_hash
fields filled in.
.It Fn cache_purge vp
Flush all cache entries corresponding with the given vnode
.Fa vp .
This is called after rename operations to hide entries that would no
longer be valid.
.It Fn cache_purgevfs mp
Flush all cache entries for name translations associated with the file
system mount described by
.Fa mp .
This is called when unmounting file systems, which would make all name
translations pertaining to the mount invalid.
.It Fn cache_revlookup vp dvpp bpp bufp
Scan the cache for the name of the directory entry that points to
.Fa vp .
.Fa dvpp
points to where a pointer to the encompassing directory will be stored.
If
.Fa bufp
is not
.Dv NULL ,
the name will be written to the end of the space between this pointer
and the value in
.Fa bpp ,
and
.Fa bpp
will be updated on return to point to the start of the copied name.
.Pp
On success,
.Fa *dvpp
will be set to point to the encompassing directory and zero will be
returned.
If the cache misses,
.Fa dvpp
will be set to
.Dv NULL
and \-1 will be returned.
Otherwise, failure has occurred,
.Fa dvpp
will be set to
.Dv NULL ,
and an appropriate error code will be returned.
.El
.Sh CODE REFERENCES
The
.Nm
API is implemented in the file
.Pa sys/kern/vfs_cache.c .
.Sh SEE ALSO
.Xr vmstat 8 ,
.Xr namei 9 ,
.Xr vfs 9 ,
.Xr vnode 9
.Sh HISTORY
The
.Nm
API first appeared in
.Bx 4.2 .
@


1.2
log
@actually, this is an original work, no need for the vfs_cache.c copyright
@
text
@d1 1
a1 1
.\"	$OpenBSD: vfs_cache.9,v 1.1 2005/06/17 15:18:55 jaredy Exp $
d4 1
a4 1
.Dd June 17, 2005
@


1.1
log
@document the VFS name cache.

lots of parts/help from and ok pedro joris jmc
@
text
@d1 3
a3 27
.\"	$OpenBSD$
.\" Copyright (c) 1989, 1993
.\"      The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"   notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"   notice, this list of conditions and the following disclaimer in the
.\"   documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"   may be used to endorse or promote products derived from this software
.\"   without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
d57 1
a57 2
For simplicity and economy of storage, names longer than the maximum
length
d59 2
a60 2
are not cached; they occur infrequently in any case, and are almost
never of interest.
@

