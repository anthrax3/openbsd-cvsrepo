head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.12
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.18
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.12
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.8
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.14
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.12
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.8
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.10
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.6
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@.\" @;


1.5
date	2014.09.08.01.27.55;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	cPoapLAXYNe1fcgV;

1.4
date	2010.09.20.07.09.55;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.09.21.49.47;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.22.00.45;	author jaredy;	state Exp;
branches;
next	;


desc
@@


1.5
log
@obvious cases of missing .An;
found with the new mandoc(1) MANDOCERR_AN_MISSING warning;
no text changes
@
text
@.\"	$OpenBSD: evcount.9,v 1.4 2010/09/20 07:09:55 matthew Exp $
.\" Written by Jared Yanovich
.\" This file belongs to the public domain, 11/02/2004.
.Dd $Mdocdate: September 20 2010 $
.Dt EVCOUNT 9
.Os
.Sh NAME
.Nm evcount ,
.Nm evcount_attach ,
.Nm evcount_detach
.Nd generic interrupt and event counter kernel API
.Sh SYNOPSIS
.In sys/evcount.h
.Ft void
.Fn evcount_attach "struct evcount *ec" "const char *name" "void *data"
.Ft void
.Fn evcount_detach "struct evcount *ec"
.Sh DESCRIPTION
The
.Nm
API provides an interface for generic event and interrupt counting,
whose statistics are made available to machine-independent
.Xr sysctl 3
nodes.
.Ss Overview
With
.Nm ,
an architecture can collect interrupt counting for any device.
All registered counters will be made available under the
.Va kern.evcount
.Xr sysctl 3
node as a flat list.
The following is a sample list of counters provided by some
common architectures:
.Pp
.Bl -tag -width 8n -offset indent -compact
.It clock
Interrupt counter for the system clock
.It stat
Second-level interrupt decrementer counter
.It rtc
Real-time clock counter
.It prof
System profiler counter
.It pciide0
PCI IDE controller counter (see
.Xr pciide 4 )
.It uhci0
USB 1.0 controller counter (see
.Xr usb 4 )
.El
.Pp
See
.Xr intro 4
for a list of devices for any of which
.Nm
may track interrupt counting.
.Pp
The
.Xr systat 1
and
.Xr vmstat 8
utilities can be used to view interrupts collected by
.Nm .
.Ss The API
The
.Vt evcount
structure has the following definition:
.Bd -literal -offset indent
struct evcount {
	u_int64_t		ec_count;	/* main counter */
	int			ec_id;		/* counter ID */
	const char		*ec_name;	/* counter name */
	void			*ec_data;	/* user data */

	TAILQ_ENTRY(evcount)	next;
};
.Ed
.Pp
The
.Fn evcount_attach ec name data
function adds the given event counter to the system's counter list.
.Fa name
provides the counter name, which is modeled after a
device, such as
.Dq clock
or
.Dq pciide0 .
.Fa data
provides a chunk of data that will be made available through the
.Xr sysctl 3
call.
.Pp
The
.Fn evcount_detach ec
function removes the given event counter
.Fa ec
from the counter list.
.Sh EXAMPLES
The following is an outline of code that provides routines to register
and de-register interrupt handlers for devices, plugging the counting of
interrupts generated by them during system operation into the
.Nm
framework.
.Bd -literal
#include <sys/evcount.h>
#include <machine/intr.h>

/*
 * machine/intr.h provides a structure, intrhand, which is
 * machine-dependent but is usually similar to this:
 *
 *	struct intrhand {
 *		int		(*ih_fun)(void *);
 *		void		 *ih_arg;
 *		int		  ih_level;
 *		struct intrhand  *ih_next;
 *		int		  ih_irq;
 *		struct evcount    ih_count;
 *	}
 */

/*
 * Register an interrupt handler.
 */
void *
intr_establish(void *lcv, int irq, int type, int level,
	       int (*ih_fun)(void *), void *ih_arg, char *name)
{
	struct intrhand *ih, **p;

	/*
	 * Allocate memory for the handler, sanity-check incoming
	 * values (IRQ#, etc.), and link the handler into
	 * machine-dependent data structures.
	 */

	/*
	 * Fill out the handler.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;

	/*
	 * Attach it.
	 */
	evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
intr_disestablish(void *lcp, void *arg)
{
	struct intrhand *ih = arg;

	/*
	 * Sanity-check incoming values (IRQ, etc.) and remove
	 * the interrupt handler from machine-dependent data
	 * structures.
	 */

	evcount_detach(&ih->ih_count);

	/*
	 * Free up memory and install a null interrupt handler.
	 */
}
.Ed
.Pp
An interrupt handler for a device will be registered during
.Xr autoconf 9
with a call to the above
.Fn intr_establish .
.Pp
The main external interrupt handler, which handles all system
interrupts, will select the appropriate handler for the device
that created the interrupt when an interrupt is generated.
In this case, the handler is the routine assigned to
.Va ih_fun ,
and
.Nm
will be made aware of interrupt occurrence.
.Sh SEE ALSO
.Xr systat 1 ,
.Xr queue 3 ,
.Xr sysctl 3 ,
.Xr intro 4 ,
.Xr vmstat 8 ,
.Xr autoconf 9
.Sh AUTHORS
.An -nosplit
The
.Nm
API was written by
.An Artur Grabowski
and
.An Aaron Campbell
for
.Ox 3.6 .
@


1.4
log
@Update evcount(9) documentation to reflect simplifications.

"yes, that's fine" jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: evcount.9,v 1.3 2007/05/31 19:20:00 jmc Exp $
d4 1
a4 1
.Dd $Mdocdate: May 31 2007 $
d198 1
d201 5
a205 1
API was written by Artur Grabowski and Aaron Campbell for
@


1.3
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: evcount.9,v 1.2 2004/11/09 21:49:47 jmc Exp $
d4 1
a4 1
.Dd $Mdocdate$
d15 1
a15 2
.Fn evcount_attach "struct evcount *ec" "const char *name" "void *data" \
    "struct evcount *parent"
d28 1
a28 2
an architecture can collect interrupt counting for any device and
organize the counting hierarchy however it wants.
d33 1
a33 1
The following is a sample hierarchy for counters provided by some
a52 5
Event counters may be organized hierarchically, so a parent
.Nm
node that represents a bus may contain child nodes that represent
devices attached to that bus.
.Pp
a73 1
	struct evcount		*ec_parent;	/* parent */
d81 2
a82 6
.Fn evcount_attach ec name data parent
function inserts the given event counter
.Fa ec
into the given
.Fa parent Ns 's
list of counters.
d98 1
a98 1
from its parent.
d148 1
a148 1
	 * Attach it under the root event counter, evcount_intr.
d150 1
a150 2
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
	    &evcount_intr);
@


1.2
log
@tweaks;
ok jaredy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: evcount.9,v 1.1 2004/11/02 22:00:45 jaredy Exp $
d4 1
a4 1
.Dd November 2, 2004
@


1.1
log
@add initial manpage for the evcount API
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d22 1
a22 1
API provides a interface for generic event and interrupt counting,
d62 1
a62 1
for a list of devices for any of which may
d64 1
a64 1
track interrupt counting.
@

