head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.2
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.64.0.8
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.4
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.8
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.6
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.8
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.6
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5;
locks; strict;
comment	@.\" @;


1.65
date	2017.04.30.20.09.28;	author mpi;	state Exp;
branches;
next	1.64;
commitid	IhgofW1vEaLl0nkz;

1.64
date	2015.11.25.16.20.36;	author jmc;	state Exp;
branches;
next	1.63;
commitid	UZ19XAAKY96LqIsc;

1.63
date	2015.11.23.17.53.57;	author jmc;	state Exp;
branches;
next	1.62;
commitid	GVTTSAMZ93Lz4hmE;

1.62
date	2015.11.11.15.59.33;	author mmcc;	state Exp;
branches;
next	1.61;
commitid	lKxbFcynv6SZSYfh;

1.61
date	2015.10.30.04.21.42;	author mmcc;	state Exp;
branches;
next	1.60;
commitid	xBbh4VJYpYuj3ETa;

1.60
date	2015.01.15.21.19.22;	author guenther;	state Exp;
branches;
next	1.59;
commitid	FswgCuzKpnneVyE8;

1.59
date	2014.11.16.12.31.01;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	yv0ECmCdICvq576h;

1.58
date	2014.07.03.06.55.59;	author matthew;	state Exp;
branches;
next	1.57;
commitid	pH4dx0tR1GVVkn2I;

1.57
date	2014.07.02.23.46.52;	author matthew;	state Exp;
branches;
next	1.56;
commitid	bMPlbhKhu8mBqOHI;

1.56
date	2014.07.02.06.09.49;	author matthew;	state Exp;
branches;
next	1.55;
commitid	mswsoyQHeu5M87iU;

1.55
date	2014.06.30.21.48.09;	author matthew;	state Exp;
branches;
next	1.54;
commitid	Uz0MCSOuSUI2le6I;

1.54
date	2014.06.30.17.57.15;	author matthew;	state Exp;
branches;
next	1.53;
commitid	XSYJg0JsiyopoUS8;

1.53
date	2014.05.29.07.25.49;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.29.06.17.08;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.21.03.15.46;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2013.07.20.06.25.33;	author jmc;	state Exp;
branches;
next	1.49;

1.49
date	2013.07.17.20.21.55;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.04.19.27.15;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.30.16.53.22;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.22.06.44.58;	author jmc;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.20.19.42.14;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.17.21.54.18;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2010.12.24.14.12.51;	author grange;	state Exp;
branches;
next	1.42;

1.42
date	2010.11.09.16.03.38;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.15.07.34.58;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.20.00.44.48;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2009.04.14.17.07.08;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.19.20.09.00;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.04.21.37.07;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.16.16.22.10;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.09.20.30.22;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.06.16.26.07;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.10.18.49.42;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.31.19.20.01;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.26.16.03.20;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.26.08.28.09;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.25.13.14.41;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.16.13.36.38;	author dim;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.30.20.34.25;	author jaredy;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.22.14.33.08;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.24.06.45.58;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.30.21.54.06;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.10.21.57.25;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.03.19.59.40;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.01.09.29.02;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.28.10.16.29;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.10.19.56.29;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.20.19.27.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.19.01.20.30;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.08.08.08.47;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.02.04.12.04;	author wcobb;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.27.23.56.44;	author wcobb;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.27.16.24.26;	author wcobb;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.24.03.36.30;	author wcobb;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.29.17.36.41;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.29.17.33.45;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.05.14.45.54;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.15.21.17;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.28.22.14.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.22.00.13.34;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.10.20.02.20;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.09.16.17.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.22.09.54.38;	author espie;	state dead;
branches;
next	1.1;

1.1
date	99.09.22.03.16.47;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Remove KGDB references.
@
text
@.\"	$OpenBSD: uvm.9,v 1.64 2015/11/25 16:20:36 jmc Exp $
.\"	$NetBSD: uvm.9,v 1.14 2000/06/29 06:08:44 mrg Exp $
.\"
.\" Copyright (c) 1998 Matthew R. Green
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
.\" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
.\" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
.\" AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
.\" OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" XXX this manual sets nS to 1 or 0 in the description, to obtain
.\" synopsis-like function prototypes.  any better way?
.\"
.Dd $Mdocdate: November 25 2015 $
.Dt UVM_INIT 9
.Os
.Sh NAME
.Nm uvm_init ,
.Nm uvm_init_limits ,
.Nm uvm_setpagesize ,
.Nm uvm_swap_init ,
.Nm uvm_map ,
.Nm uvm_map_pageable ,
.Nm uvm_map_pageable_all ,
.Nm uvm_map_checkprot ,
.Nm uvm_map_protect ,
.Nm uvm_deallocate ,
.Nm uvmspace_alloc ,
.Nm uvmspace_exec ,
.Nm uvmspace_fork ,
.Nm uvmspace_free ,
.Nm uvmspace_share ,
.Nm uvm_uarea_alloc ,
.Nm uvm_uarea_free ,
.Nm UVM_MAPFLAG ,
.Nm uvm_fault ,
.Nm uvn_attach ,
.Nm uvm_vnp_setsize ,
.Nm uvm_vnp_sync ,
.Nm uvm_vnp_terminate ,
.Nm uvm_vnp_uncache ,
.Nm uvm_io ,
.Nm uvm_km_alloc ,
.Nm uvm_km_zalloc ,
.Nm uvm_km_alloc1 ,
.Nm uvm_km_kmemalloc ,
.Nm uvm_km_valloc ,
.Nm uvm_km_valloc_wait ,
.Nm uvm_km_suballoc ,
.Nm uvm_km_free ,
.Nm uvm_km_free_wakeup ,
.Nm uvm_pagealloc ,
.Nm uvm_pagerealloc ,
.Nm uvm_pagefree ,
.Nm uvm_pglistalloc ,
.Nm uvm_pglistfree ,
.Nm uvm_page_physload ,
.Nm uvm_pageout ,
.Nm uao_create ,
.Nm uao_detach ,
.Nm uao_reference ,
.Nm uvm_chgkprot ,
.Nm uvm_kernacc ,
.Nm uvm_vslock ,
.Nm uvm_vsunlock ,
.Nm uvm_meter ,
.Nm uvm_sysctl ,
.Nm uvm_grow ,
.Nm uvm_coredump
.Nd virtual memory system external interface
.Sh SYNOPSIS
.In sys/param.h
.In uvm/uvm.h
.Sh DESCRIPTION
The UVM virtual memory system manages access to the computer's memory
resources.
User processes and the kernel access these resources through
UVM's external interface.
UVM's external interface includes functions that:
.Pp
.Bl -hyphen -compact
.It
initialise UVM subsystems
.It
manage virtual address spaces
.It
resolve page faults
.It
memory map files and devices
.It
perform uio-based I/O to virtual memory
.It
allocate and free kernel virtual memory
.It
allocate and free physical memory
.El
.Pp
In addition to exporting these services, UVM has two kernel-level processes:
pagedaemon and swapper.
The pagedaemon process sleeps until physical memory becomes scarce.
When that happens, pagedaemon is awoken.
It scans physical memory, paging out and freeing memory that has not been
recently used.
The swapper process swaps in runnable processes that are currently swapped out,
if there is room.
.Pp
UVM has a machine independent and a machine dependent layer.
See
.Xr pmap 9
for the machine dependent layer.
.Sh INITIALISATION
.nr nS 1
.Ft void
.Fn uvm_init "void"
.Ft void
.Fn uvm_init_limits "struct proc *p"
.Ft void
.Fn uvm_setpagesize "void"
.Ft void
.Fn uvm_swap_init "void"
.nr nS 0
.Pp
The
.Fn uvm_init
function sets up the UVM system at system boot time, after the
copyright has been printed.
It initialises global state, the page, map, kernel virtual memory state,
machine-dependent physical map, kernel memory allocator,
pager and anonymous memory subsystems, and then enables
paging of kernel objects.
.Fn uvm_init
must be called after machine-dependent code has registered some free RAM
with the
.Fn uvm_page_physload
function.
.Pp
The
.Fn uvm_init_limits
function initialises process limits for the named process.
This is for use by the system startup for process zero, before any other
processes are created.
.Pp
The
.Fn uvm_setpagesize
function initialises the uvmexp members pagesize (if not already done by
machine-dependent code), pageshift and pagemask.
It should be called by machine-dependent code early in the
.Xr pmap_init 9
call.
.Pp
The
.Fn uvm_swap_init
function initialises the swap subsystem.
.Sh VIRTUAL ADDRESS SPACE MANAGEMENT
.nr nS 1
.Ft int
.Fn uvm_map "vm_map_t map" "vaddr_t *startp" "vsize_t size" "struct uvm_object *uobj" "voff_t uoffset" "vsize_t alignment" "unsigned int flags"
.Ft int
.Fn uvm_map_pageable "vm_map_t map" "vaddr_t start" "vaddr_t end" "boolean_t new_pageable" "int lockflags"
.Ft int
.Fn uvm_map_pageable_all "vm_map_t map" "int flags" "vsize_t limit"
.Ft boolean_t
.Fn uvm_map_checkprot "vm_map_t map" "vaddr_t start" "vaddr_t end" "vm_prot_t protection"
.Ft int
.Fn uvm_map_protect "vm_map_t map" "vaddr_t start" "vaddr_t end" "vm_prot_t new_prot" "boolean_t set_max"
.Ft void
.Fn uvm_deallocate "vm_map_t map" "vaddr_t start" "vsize_t size"
.Ft struct vmspace *
.Fn uvmspace_alloc "vaddr_t min" "vaddr_t max" "boolean_t pageable" "boolean_t remove_holes"
.Ft void
.Fn uvmspace_exec "struct proc *p" "vaddr_t start" "vaddr_t end"
.Ft struct vmspace *
.Fn uvmspace_fork "struct process *pr"
.Ft void
.Fn uvmspace_free "struct vmspace *vm"
.Ft struct vmspace *
.Fn uvmspace_share "struct process *pr"
.Ft vaddr_t
.Fn uvm_uarea_alloc "void"
.Ft void
.Fn uvm_uarea_free "struct proc *p"
.Ft unsigned int
.Fn UVM_MAPFLAG "vm_prot_t prot" "vm_prot_t maxprot" "vm_inherit_t inh" "int advice" "int flags"
.nr nS 0
.Pp
The
.Fn uvm_map
function establishes a valid mapping in map
.Fa map ,
which must be unlocked.
The new mapping has size
.Fa size ,
which must be in
.Dv PAGE_SIZE
units.
If
.Fa alignment
is non-zero, it describes the required alignment of the list, in
power-of-two notation.
The
.Fa uobj
and
.Fa uoffset
arguments can have four meanings.
When
.Fa uobj
is
.Dv NULL
and
.Fa uoffset
is
.Dv UVM_UNKNOWN_OFFSET ,
.Fn uvm_map
does not use the machine-dependent
.Dv PMAP_PREFER
function.
If
.Fa uoffset
is any other value, it is used as the hint to
.Dv PMAP_PREFER .
When
.Fa uobj
is not
.Dv NULL
and
.Fa uoffset
is
.Dv UVM_UNKNOWN_OFFSET ,
.Fn uvm_map
finds the offset based upon the virtual address, passed as
.Fa startp .
If
.Fa uoffset
is any other value, we are doing a normal mapping at this offset.
The start address of the map will be returned in
.Fa startp .
.Pp
.Fa flags
passed to
.Fn uvm_map
are typically created using the
.Fn UVM_MAPFLAG
macro, which uses the following values.
The
.Fa prot
and
.Fa maxprot
can take a mix of the following values:
.Bd -literal
#define PROT_MASK   0x07    /* protection mask */
#define PROT_NONE   0x00    /* protection none */
#define PROT_READ   0x01    /* read */
#define PROT_WRITE  0x02    /* write */
#define PROT_EXEC   0x04    /* exec */
.Ed
.Pp
The values that
.Fa inh
can take are:
.Bd -literal
#define MAP_INHERIT_MASK    0x30    /* inherit mask */
#define MAP_INHERIT_SHARE   0x00    /* "share" */
#define MAP_INHERIT_COPY    0x10    /* "copy" */
#define MAP_INHERIT_NONE    0x20    /* "none" */
#define MAP_INHERIT_ZERO    0x30    /* "zero" */
.Ed
.Pp
The values that
.Fa advice
can take are:
.Bd -literal
#define MADV_NORMAL  0x0     /* 'normal' */
#define MADV_RANDOM  0x1     /* 'random' */
#define MADV_SEQUENTIAL 0x2  /* 'sequential' */
#define MADV_MASK    0x7     /* mask */
.Ed
.Pp
The values that
.Fa flags
can take are:
.Bd -literal
#define UVM_FLAG_FIXED   0x010000 /* find space */
#define UVM_FLAG_OVERLAY 0x020000 /* establish overlay */
#define UVM_FLAG_NOMERGE 0x040000 /* don't merge map entries */
#define UVM_FLAG_COPYONW 0x080000 /* set copy_on_write flag */
#define UVM_FLAG_AMAPPAD 0x100000 /* bss: pad amap to reduce malloc() */
#define UVM_FLAG_TRYLOCK 0x200000 /* fail if we can not lock map */
#define UVM_FLAG_HOLE    0x400000 /* no backend */
.Ed
.Pp
The
.Dv UVM_MAPFLAG
macro arguments can be combined with an or operator.
There are also some additional macros to extract bits from the flags.
The
.Dv UVM_PROTECTION ,
.Dv UVM_INHERIT ,
.Dv UVM_MAXPROTECTION
and
.Dv UVM_ADVICE
macros return the protection, inheritance, maximum protection and advice,
respectively.
.Fn uvm_map
returns a standard errno.
.Pp
The
.Fn uvm_map_pageable
function changes the pageability of the pages in the range from
.Fa start
to
.Fa end
in map
.Fa map
to
.Fa new_pageable .
The
.Fn uvm_map_pageable_all
function changes the pageability of all mapped regions.
If
.Fa limit
is non-zero and
.Fn pmap_wired_count
is implemented,
.Dv ENOMEM
is returned if the amount of wired pages exceed
.Fa limit .
The map is locked on entry if
.Fa lockflags
contain
.Dv UVM_LK_ENTER ,
and locked on exit if
.Fa lockflags
contain
.Dv UVM_LK_EXIT .
.Fn uvm_map_pageable
and
.Fn uvm_map_pageable_all
return a standard errno.
.Pp
The
.Fn uvm_map_checkprot
function checks the protection of the range from
.Fa start
to
.Fa end
in map
.Fa map
against
.Fa protection .
This returns either
.Dv TRUE
or
.Dv FALSE .
.Pp
The
.Fn uvm_map_protect
function changes the protection
.Fa start
to
.Fa end
in map
.Fa map
to
.Fa new_prot ,
also setting the maximum protection to the region to
.Fa new_prot
if
.Fa set_max
is non-zero.
This function returns a standard errno.
.Pp
The
.Fn uvm_deallocate
function deallocates kernel memory in map
.Fa map
from address
.Fa start
to
.Fa start + size .
.Pp
The
.Fn uvmspace_alloc
function allocates and returns a new address space, with ranges from
.Fa min
to
.Fa max ,
setting the pageability of the address space to
.Fa pageable .
If
.Fa remove_holes
is non-zero, hardware
.Sq holes
in the virtual address space will be removed from the newly allocated
address space.
.Pp
The
.Fn uvmspace_exec
function either reuses the address space of process
.Fa p
if there are no other references to it, or creates
a new one with
.Fn uvmspace_alloc .
The range of valid addresses in the address space is reset to
.Fa start
through
.Fa end .
.Pp
The
.Fn uvmspace_fork
function creates and returns a new address space based upon the
address space of process
.Fa pr
and is typically used when allocating an address space for a
child process.
.Pp
The
.Fn uvmspace_free
function lowers the reference count on the address space
.Fa vm ,
freeing the data structures if there are no other references.
.Pp
The
.Fn uvmspace_share
function returns a reference to the address space of process
.Fa pr ,
increasing its reference count.
.Pp
The
.Fn uvm_uarea_alloc
function allocates a thread's
.Sq uarea ,
the memory where its kernel stack and PCB are stored.
The
.Fn uvm_uarea_free
function frees the uarea for
thread
.Fa p ,
which must no longer be running.
.Sh PAGE FAULT HANDLING
.nr nS 1
.Ft int
.Fn uvm_fault "vm_map_t orig_map" "vaddr_t vaddr" "vm_fault_t fault_type" "vm_prot_t access_type"
.nr nS 0
.Pp
The
.Fn uvm_fault
function is the main entry point for faults.
It takes
.Fa orig_map
as the map the fault originated in, a
.Fa vaddr
offset into the map the fault occurred,
.Fa fault_type
describing the type of fault, and
.Fa access_type
describing the type of access requested.
.Fn uvm_fault
returns a standard errno.
.Sh MEMORY MAPPING FILES AND DEVICES
.nr nS 1
.Ft struct uvm_object *
.Fn uvn_attach "struct vnode *vp" "vm_prot_t accessprot"
.Ft void
.Fn uvm_vnp_setsize "struct vnode *vp" "voff_t newsize"
.Ft void
.Fn uvm_vnp_sync "struct mount *mp"
.Ft void
.Fn uvm_vnp_terminate "struct vnode *vp"
.Ft boolean_t
.Fn uvm_vnp_uncache "struct vnode *vp"
.nr nS 0
.Pp
The
.Fn uvn_attach
function attaches a UVM object to vnode
.Fa vp ,
creating the object if necessary.
The object is returned.
.Pp
The
.Fn uvm_vnp_setsize
function sets the size of vnode
.Fa vp
to
.Fa newsize .
Caller must hold a reference to the vnode.
If the vnode shrinks, pages no longer used are discarded.
This function will be removed when the file system and VM buffer caches
are merged.
.Pp
The
.Fn uvm_vnp_sync
function flushes dirty vnodes from either the mount point passed in
.Fa mp ,
or all dirty vnodes if
.Fa mp
is
.Dv NULL .
This function will be removed when the file system and VM buffer caches
are merged.
.Pp
The
.Fn uvm_vnp_terminate
function frees all VM resources allocated to vnode
.Fa vp .
If the vnode still has references, it will not be destroyed; however
all future operations using this vnode will fail.
This function will be removed when the file system and VM buffer caches
are merged.
.Pp
The
.Fn uvm_vnp_uncache
function disables vnode
.Fa vp
from persisting when all references are freed.
This function will be removed when the file system and UVM caches
are unified.
Returns true if there is no active vnode.
.Sh VIRTUAL MEMORY I/O
.nr nS 1
.Ft int
.Fn uvm_io "vm_map_t map" "struct uio *uio"
.nr nS 0
.Pp
The
.Fn uvm_io
function performs the I/O described in
.Fa uio
on the memory described in
.Fa map .
.Sh ALLOCATION OF KERNEL MEMORY
.nr nS 1
.Ft vaddr_t
.Fn uvm_km_alloc "vm_map_t map" "vsize_t size"
.Ft vaddr_t
.Fn uvm_km_zalloc "vm_map_t map" "vsize_t size"
.Ft vaddr_t
.Fn uvm_km_alloc1 "vm_map_t map" "vsize_t size" "vsize_t align" "boolean_t zeroit"
.Ft vaddr_t
.Fn uvm_km_kmemalloc "vm_map_t map" "struct uvm_object *obj" "vsize_t size" "int flags"
.Ft vaddr_t
.Fn uvm_km_valloc "vm_map_t map" "vsize_t size"
.Ft vaddr_t
.Fn uvm_km_valloc_wait "vm_map_t map" "vsize_t size"
.Ft struct vm_map *
.Fn uvm_km_suballoc "vm_map_t map" "vaddr_t *min" "vaddr_t *max " "vsize_t size" "int flags" "boolean_t fixed" "vm_map_t submap"
.Ft void
.Fn uvm_km_free "vm_map_t map" "vaddr_t addr" "vsize_t size"
.Ft void
.Fn uvm_km_free_wakeup "vm_map_t map" "vaddr_t addr" "vsize_t size"
.nr nS 0
.Pp
The
.Fn uvm_km_alloc
and
.Fn uvm_km_zalloc
functions allocate
.Fa size
bytes of wired kernel memory in map
.Fa map .
In addition to allocation,
.Fn uvm_km_zalloc
zeros the memory.
Both of these functions are defined as macros in terms of
.Fn uvm_km_alloc1 ,
and should almost always be used in preference to
.Fn uvm_km_alloc1 .
.Pp
The
.Fn uvm_km_alloc1
function allocates and returns
.Fa size
bytes of wired memory in the kernel map aligned to the
.Fa align
boundary, zeroing the memory if the
.Fa zeroit
argument is non-zero.
.Pp
The
.Fn uvm_km_kmemalloc
function allocates and returns
.Fa size
bytes of wired kernel memory into
.Fa obj .
The flags can be any of:
.Bd -literal
#define UVM_KMF_NOWAIT  0x1                     /* matches M_NOWAIT */
#define UVM_KMF_VALLOC  0x2                     /* allocate VA only */
#define UVM_KMF_TRYLOCK UVM_FLAG_TRYLOCK        /* try locking only */
.Ed
.Pp
The
.Dv UVM_KMF_NOWAIT
flag causes
.Fn uvm_km_kmemalloc
to return immediately if no memory is available.
.Dv UVM_KMF_VALLOC
causes no pages to be allocated, only a virtual address.
.Dv UVM_KMF_TRYLOCK
causes
.Fn uvm_km_kmemalloc
to only try and not sleep when locking maps.
.Pp
The
.Fn uvm_km_valloc
and
.Fn uvm_km_valloc_wait
functions return a newly allocated zero-filled address in the kernel map of size
.Fa size .
.Fn uvm_km_valloc_wait
will also wait for kernel memory to become available, if there is a
memory shortage.
.Pp
The
.Fn uvm_km_suballoc
function allocates submap (with the specified
.Fa flags ,
as described above) from
.Fa map ,
creating a new map if
.Fa submap
is
.Dv NULL .
The addresses of the submap can be specified exactly by setting the
.Fa fixed
argument to non-zero, which causes the
.Fa min
argument to specify the beginning of the address in the submap.
If
.Fa fixed
is zero, any address of size
.Fa size
will be allocated from
.Fa map
and the start and end addresses returned in
.Fa min
and
.Fa max .
.Pp
The
.Fn uvm_km_free
and
.Fn uvm_km_free_wakeup
functions free
.Fa size
bytes of memory in the kernel map, starting at address
.Fa addr .
.Fn uvm_km_free_wakeup
calls
.Fn wakeup
on the map before unlocking the map.
.Sh ALLOCATION OF PHYSICAL MEMORY
.nr nS 1
.Ft struct vm_page *
.Fn uvm_pagealloc "struct uvm_object *uobj" "voff_t off" "struct vm_anon *anon" "int flags"
.Ft void
.Fn uvm_pagerealloc "struct vm_page *pg" "struct uvm_object *newobj" "voff_t newoff"
.Ft void
.Fn uvm_pagefree "struct vm_page *pg"
.Ft int
.Fn uvm_pglistalloc "psize_t size" "paddr_t low" "paddr_t high" "paddr_t alignment" "paddr_t boundary" "struct pglist *rlist" "int nsegs" "int flags"
.Ft void
.Fn uvm_pglistfree "struct pglist *list"
.Ft void
.Fn uvm_page_physload "paddr_t start" "paddr_t end" "paddr_t avail_start" "paddr_t avail_end" "int free_list"
.nr nS 0
.Pp
The
.Fn uvm_pagealloc
function allocates a page of memory at virtual address
.Fa off
in either the object
.Fa uobj
or the anonymous memory
.Fa anon ,
or returns
.Dv NULL
if no pages are free.
Only one of
.Fa anon
and
.Fa uobj
can be non
.Dv NULL .
The
.Fa flags
can be any of:
.Bd -literal
#define UVM_PGA_USERESERVE      0x0001  /* ok to use reserve pages */
#define UVM_PGA_ZERO            0x0002  /* returned page must be zeroed */
.Ed
.Pp
The
.Dv UVM_PGA_USERESERVE
flag means to allocate a page even if that will result in the number of
free pages being lower than
.Dv uvmexp.reserve_pagedaemon
(if the current thread is the pagedaemon) or
.Dv uvmexp.reserve_kernel
(if the current thread is not the pagedaemon).
The
.Dv UVM_PGA_ZERO
flag causes the returned page to be filled with zeroes, either by allocating it
from a pool of pre-zeroed pages or by zeroing it in-line as necessary.
.Pp
The
.Fn uvm_pagerealloc
function reallocates page
.Fa pg
to a new object
.Fa newobj ,
at a new offset
.Fa newoff .
.Pp
The
.Fn uvm_pagefree
function frees the physical page
.Fa pg .
.Pp
The
.Fn uvm_pglistalloc
function allocates a list of pages for size
.Fa size
byte under various constraints.
.Fa low
and
.Fa high
describe the lowest and highest addresses acceptable for the list.
If
.Fa alignment
is non-zero, it describes the required alignment of the list, in
power-of-two notation.
If
.Fa boundary
is non-zero, no segment of the list may cross this power-of-two
boundary, relative to zero.
.Fa nsegs
is the maximum number of physically contiguous segments.
The allocated memory is returned in the
.Fa rlist
list.
The
.Fa flags
can be any of:
.Bd -literal
#define UVM_PLA_WAITOK	0x0001	/* may sleep */
#define UVM_PLA_NOWAIT	0x0002	/* can't sleep */
#define UVM_PLA_ZERO	0x0004	/* zero all pages before returning */
.Ed
.Pp
The
.Dv UVM_PLA_WAITOK
flag means that the function may sleep while trying to allocate the list of
pages (this is currently ignored).
Conversely, the
.Dv UVM_PLA_NOWAIT
flag signifies that the function may not sleep while allocating.
It is an error not to provide one of the above flags.
Optionally, one may also specify the
.Dv UVM_PLA_ZERO
flag to receive zeroed memory in the page list.
.Pp
The
.Fn uvm_pglistfree
function frees the list of pages pointed to by
.Fa list .
.Pp
The
.Fn uvm_page_physload
function loads physical memory segments into VM space on the specified
.Fa free_list .
.Fn uvm_page_physload
must be called at system boot time to set up physical memory management pages.
The arguments describe the
.Fa start
and
.Fa end
of the physical addresses of the segment, and the available start and end
addresses of pages not already in use.
.\" XXX expand on "system boot time"!
.Sh PROCESSES
.nr nS 1
.Ft void
.Fn uvm_pageout "void *arg"
.nr nS 0
.Pp
The
.Fn uvm_pageout
function is the main loop for the page daemon.
The
.Fa arg
argument is ignored.
.Sh MISCELLANEOUS FUNCTIONS
.nr nS 1
.Ft struct uvm_object *
.Fn uao_create "vsize_t size" "int flags"
.Ft void
.Fn uao_detach "struct uvm_object *uobj"
.Ft void
.Fn uao_reference "struct uvm_object *uobj"
.Ft boolean_t
.Fn uvm_chgkprot "caddr_t addr" "size_t len" "int rw"
.Ft void
.Fn uvm_kernacc "caddr_t addr" "size_t len" "int rw"
.Ft void
.Fn uvm_vslock "struct proc *p" "caddr_t addr" "size_t len" \
               "vm_prot_t access_type"
.Ft void
.Fn uvm_vsunlock "struct proc *p" "caddr_t addr" "size_t len"
.Ft void
.Fn uvm_meter
.Ft int
.Fn uvm_sysctl "int *name" "u_int namelen" "void *oldp" "size_t *oldlenp" "void *newp " "size_t newlen" "struct proc *p"
.Ft int
.Fn uvm_grow "struct proc *p" "vaddr_t sp"
.Ft int
.Fn uvm_coredump "struct proc *p" "struct vnode *vp" "struct ucred *cred" "struct core *chdr"
.nr nS 0
.Pp
The
.Fn uao_create ,
.Fn uao_detach
and
.Fn uao_reference
functions operate on anonymous memory objects, such as those used to support
System V shared memory.
.Fn uao_create
returns an object of size
.Fa size
with flags:
.Bd -literal
#define UAO_FLAG_KERNOBJ        0x1     /* create kernel object */
#define UAO_FLAG_KERNSWAP       0x2     /* enable kernel swap */
.Pp
.Ed
which can only be used once each at system boot time.
.Fn uao_reference
creates an additional reference to the named anonymous memory object.
.Fn uao_detach
removes a reference from the named anonymous memory object, destroying
it if removing the last reference.
.Pp
The
.Fn uvm_kernacc
function checks the access at address
.Fa addr
to
.Fa addr + len
for
.Fa rw
access, in the kernel address space.
.Pp
The
.Fn uvm_vslock
and
.Fn uvm_vsunlock
functions control the wiring and unwiring of pages for process
.Fa p
from
.Fa addr
to
.Fa addr + len .
The
.Fa access_type
argument of
.Fn uvm_vslock
is passed to
.Fn uvm_fault .
These functions are normally used to wire memory for I/O.
.Pp
The
.Fn uvm_meter
function calculates the load average and wakes up the swapper if necessary.
.Pp
The
.Fn uvm_sysctl
function provides support for the
.Dv CTL_VM
domain of the
.Xr sysctl 3
hierarchy.
.Fn uvm_sysctl
handles the
.Dv VM_LOADAVG ,
.Dv VM_METER
and
.Dv VM_UVMEXP
calls, which return the current load averages, calculates current VM
totals, and returns the uvmexp structure respectively.
The load averages are accessed from userland using the
.Xr getloadavg 3
function.
The uvmexp structure has all global state of the UVM system, and has
the following members:
.Bd -literal
/* vm_page constants */
int pagesize;   /* size of a page (PAGE_SIZE): must be power of 2 */
int pagemask;   /* page mask */
int pageshift;  /* page shift */

/* vm_page counters */
int npages;     /* number of pages we manage */
int free;       /* number of free pages */
int active;     /* number of active pages */
int inactive;   /* number of pages that we free'd but may want back */
int paging;	/* number of pages in the process of being paged out */
int wired;      /* number of wired pages */

int zeropages;		/* number of zero'd pages */
int reserve_pagedaemon; /* number of pages reserved for pagedaemon */
int reserve_kernel;	/* number of pages reserved for kernel */
int anonpages;		/* number of pages used by anon pagers */
int vnodepages;		/* number of pages used by vnode page cache */
int vtextpages;		/* number of pages used by vtext vnodes */

/* pageout params */
int freemin;    /* min number of free pages */
int freetarg;   /* target number of free pages */
int inactarg;   /* target number of inactive pages */
int wiredmax;   /* max number of wired pages */
int anonmin;	/* min threshold for anon pages */
int vtextmin;	/* min threshold for vtext pages */
int vnodemin;	/* min threshold for vnode pages */
int anonminpct;	/* min percent anon pages */
int vtextminpct;/* min percent vtext pages */
int vnodeminpct;/* min percent vnode pages */

/* swap */
int nswapdev;	/* number of configured swap devices in system */
int swpages;	/* number of PAGE_SIZE'ed swap pages */
int swpginuse;	/* number of swap pages in use */
int swpgonly;	/* number of swap pages in use, not also in RAM */
int nswget;	/* number of times fault calls uvm_swap_get() */
int nanon;	/* number total of anon's in system */
int nanonneeded;/* number of anons currently needed */
int nfreeanon;	/* number of free anon's */

/* stat counters */
int faults;		/* page fault count */
int traps;		/* trap count */
int intrs;		/* interrupt count */
int swtch;		/* context switch count */
int softs;		/* software interrupt count */
int syscalls;		/* system calls */
int pageins;		/* pagein operation count */
			/* pageouts are in pdpageouts below */
int swapins;		/* swapins */
int swapouts;		/* swapouts */
int pgswapin;		/* pages swapped in */
int pgswapout;		/* pages swapped out */
int forks;		/* forks */
int forks_ppwait;	/* forks where parent waits */
int forks_sharevm;	/* forks where vmspace is shared */
int pga_zerohit;	/* pagealloc where zero wanted and zero
			   was available */
int pga_zeromiss;	/* pagealloc where zero wanted and zero
			   not available */
int zeroaborts;		/* number of times page zeroing was
			   aborted */

/* fault subcounters */
int fltnoram;	/* number of times fault was out of ram */
int fltnoanon;	/* number of times fault was out of anons */
int fltpgwait;	/* number of times fault had to wait on a page */
int fltpgrele;	/* number of times fault found a released page */
int fltrelck;	/* number of times fault relock called */
int fltrelckok;	/* number of times fault relock is a success */
int fltanget;	/* number of times fault gets anon page */
int fltanretry;	/* number of times fault retrys an anon get */
int fltamcopy;	/* number of times fault clears "needs copy" */
int fltnamap;	/* number of times fault maps a neighbor anon page */
int fltnomap;	/* number of times fault maps a neighbor obj page */
int fltlget;	/* number of times fault does a locked pgo_get */
int fltget;	/* number of times fault does an unlocked get */
int flt_anon;	/* number of times fault anon (case 1a) */
int flt_acow;	/* number of times fault anon cow (case 1b) */
int flt_obj;	/* number of times fault is on object page (2a) */
int flt_prcopy;	/* number of times fault promotes with copy (2b) */
int flt_przero;	/* number of times fault promotes with zerofill (2b) */

/* daemon counters */
int pdwoke;	/* number of times daemon woke up */
int pdrevs;	/* number of times daemon rev'd clock hand */
int pdswout;	/* number of times daemon called for swapout */
int pdfreed;	/* number of pages daemon freed since boot */
int pdscans;	/* number of pages daemon scanned since boot */
int pdanscan;	/* number of anonymous pages scanned by daemon */
int pdobscan;	/* number of object pages scanned by daemon */
int pdreact;	/* number of pages daemon reactivated since boot */
int pdbusy;	/* number of times daemon found a busy page */
int pdpageouts;	/* number of times daemon started a pageout */
int pdpending;	/* number of times daemon got a pending pagout */
int pddeact;	/* number of pages daemon deactivates */
int pdreanon;	/* anon pages reactivated due to min threshold */
int pdrevnode;	/* vnode pages reactivated due to min threshold */
int pdrevtext;	/* vtext pages reactivated due to min threshold */

int fpswtch;	/* FPU context switches */
int kmapent;	/* number of kernel map entries */
.Ed
.Pp
The
.Fn uvm_grow
function increases the stack segment of process
.Fa p
to include
.Fa sp .
.Pp
The
.Fn uvm_coredump
function generates a coredump on vnode
.Fa vp
for process
.Fa p
with credentials
.Fa cred
and core header description in
.Fa chdr .
.Sh NOTES
The structure and types whose names begin with
.Dq vm_
were named so UVM could coexist with BSD VM during the early
development stages.
.Sh SEE ALSO
.Xr getloadavg 3 ,
.Xr kvm 3 ,
.Xr sysctl 3 ,
.Xr ddb 4 ,
.Xr options 4 ,
.Xr pmap 9
.Rs
.%A Charles D. Cranor
.%D August 1998
.%C St. Louis, Missouri
.%Q Department of Computer Science, Sever Institute of Technology, Washington University
.%T Design and Implementation of the UVM Virtual Memory System, D.Sc. dissertation
.Re
.Sh HISTORY
The UVM virtual memory system was developed at Washington University in St. Louis.
UVM's roots lie partly in the Mach-based
.Bx 4.4
VM system, the
.Fx
VM system, and the SunOS4 VM system.
UVM's basic structure is based on the
.Bx 4.4
VM system.
UVM's new anonymous memory system is based on the
anonymous memory system found in the SunOS4 VM (as described in papers
published by Sun Microsystems, Inc.).
UVM also includes a number of features
new to
.Bx
including page loanout, map entry passing, simplified
copy-on-write, and clustered anonymous memory pageout.
.Pp
UVM appeared in
.Ox 2.9 .
.Sh AUTHORS
.An -nosplit
.An Charles D. Cranor Aq Mt chuck@@ccrc.wustl.edu
designed and implemented UVM.
.Pp
.An Matthew Green Aq Mt mrg@@eterna.com.au
wrote the swap-space management code.
.Pp
.An Chuck Silvers Aq Mt chuq@@chuq.com
implemented the aobj pager, thus allowing
UVM to support System V shared memory and process swapping.
.Pp
.An Artur Grabowski Aq Mt art@@openbsd.org
handled the logistical issues involved with merging UVM into the
.Ox
source tree.
@


1.64
log
@add uvm_uarea_{alloc,free} to NAME and MLINKS;
found by schwarze;

ok schwarze guenther
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.63 2015/11/23 17:53:57 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: November 23 2015 $
a860 12
.Pp
The
.Fn uvm_chgkprot
function changes the protection of kernel memory from
.Fa addr
to
.Fa addr + len
to the value of
.Fa rw .
This is primarily useful for debuggers, for setting breakpoints.
This function is only available with options
.Dv KGDB .
@


1.63
log
@add missing NAME entries;
feedback/ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.62 2015/11/11 15:59:33 mmcc Exp $
d33 1
a33 1
.Dd $Mdocdate: November 11 2015 $
d52 2
@


1.62
log
@Remove the superfluous typedef uvm_flag_t (unsigned int). Also, fix an
associated mistake in the uvm manpage.

Suggested by and ok tedu@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.61 2015/10/30 04:21:42 mmcc Exp $
d33 2
a34 2
.Dd $Mdocdate: October 30 2015 $
.Dt UVM 9
d37 50
a86 1
.Nm uvm
@


1.61
log
@uvm_deallocate()'s return type is void, not int. This has apparently
been out of sync for 13 years.

ok daniel@@, millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.60 2015/01/15 21:19:22 guenther Exp $
d33 1
a33 1
.Dd $Mdocdate: January 15 2015 $
d125 1
a125 1
.Fn uvm_map "vm_map_t map" "vaddr_t *startp" "vsize_t size" "struct uvm_object *uobj" "voff_t uoffset" "vsize_t alignment" "uvm_flag_t flags"
d150 1
a150 1
.Ft int
@


1.60
log
@UVM_INH_* and UVM_ADV_* are gone; use MAP_INHERIT_* and MADV_*
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.59 2014/11/16 12:31:01 deraadt Exp $
d33 1
a33 1
.Dd $Mdocdate: November 16 2014 $
d134 1
a134 1
.Ft int
@


1.59
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.58 2014/07/03 06:55:59 matthew Exp $
d33 1
a33 1
.Dd $Mdocdate: July 3 2014 $
d229 5
a233 5
#define UVM_INH_MASK    0x30    /* inherit mask */
#define UVM_INH_SHARE   0x00    /* "share" */
#define UVM_INH_COPY    0x10    /* "copy" */
#define UVM_INH_NONE    0x20    /* "none" */
#define UVM_INH_ZERO    0x30    /* "zero" */
d240 4
a243 4
#define UVM_ADV_NORMAL  0x0     /* 'normal' */
#define UVM_ADV_RANDOM  0x1     /* 'random' */
#define UVM_ADV_SEQUENTIAL 0x2  /* 'sequential' */
#define UVM_ADV_MASK    0x7     /* mask */
@


1.58
log
@Move failure case text from uvm_pagerealloc() to uvm_pagealloc()

uvm_pagerealloc() is a void function and it doesn't attempt to find
any pages, so it doesn't make sense that it might "return NULL when no
page can be found".
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.57 2014/07/02 23:46:52 matthew Exp $
d33 1
a33 1
.Dd $Mdocdate: July 2 2014 $
d216 1
a216 1
can take the following values:
d218 5
a222 13
#define UVM_PROT_MASK   0x07    /* protection mask */
#define UVM_PROT_NONE   0x00    /* protection none */
#define UVM_PROT_ALL    0x07    /* everything */
#define UVM_PROT_READ   0x01    /* read */
#define UVM_PROT_WRITE  0x02    /* write */
#define UVM_PROT_EXEC   0x04    /* exec */
#define UVM_PROT_R      0x01    /* read */
#define UVM_PROT_W      0x02    /* write */
#define UVM_PROT_RW     0x03    /* read-write */
#define UVM_PROT_X      0x04    /* exec */
#define UVM_PROT_RX     0x05    /* read-exec */
#define UVM_PROT_WX     0x06    /* write-exec */
#define UVM_PROT_RWX    0x07    /* read-write-exec */
a261 4
There are several special purpose macros for checking protection combinations,
e.g., the
.Dv UVM_PROT_WX
macro.
@


1.57
log
@Sync uvm_page_physload()'s parameter types with reality

uvm_page.c r1.19 (July 25, 2001) changed them from vaddr_t to paddr_t
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.56 2014/07/02 06:09:49 matthew Exp $
d655 4
a658 1
.Fa anon .
d693 1
a693 4
.Fa newoff ,
and returns
.Dv NULL
when no page can be found.
@


1.56
log
@Use real parameter types for u{dv,vn}_attach() instead of void *

ok guenther
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.55 2014/06/30 21:48:09 matthew Exp $
d33 1
a33 1
.Dd $Mdocdate: June 30 2014 $
d645 1
a645 1
.Fn uvm_page_physload "vaddr_t start" "vaddr_t end" "vaddr_t avail_start" "vaddr_t avail_end" "int free_list"
@


1.55
log
@Remove some dead functions from uvm.9:

uvm_fork() was removed by uvm_glue.c r1.65 (2014-05-15)

uvm_scheduler() was removed by uvm_glue.c r1.50 (2009-08-11)

uvm_swapin() was removed by uvm_glue.c r1.45 (2006-11-29)

RIP
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.54 2014/06/30 17:57:15 matthew Exp $
d442 1
a442 1
.Fn uvn_attach "void *arg" "vm_prot_t accessprot"
d456 1
a456 1
.Fa arg ,
@


1.54
log
@Update to reflect that UVM_INH_ZERO has replaced UVM_INH_DONATE.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.53 2014/05/29 07:25:49 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: May 29 2014 $
a764 4
.Ft void
.Fn uvm_scheduler "void"
.Ft void
.Fn uvm_swapin "struct proc *p"
a772 12
.Pp
The
.Fn uvm_scheduler
function is the process zero main loop, which is to be called after the
system has finished starting other processes.
.Fn uvm_scheduler
handles the swapping in of runnable, swapped out processes in priority
order.
.Pp
The
.Fn uvm_swapin
function swaps in the named process.
a793 4
.Ft void
.Fn uvm_fork "struct proc *p1" "struct proc *p2" "boolean_t shared" \
             "void *stack" "size_t stacksize" "void (*func)(void *arg)" \
             "void *arg"
a994 23
.Fn uvm_fork
function forks a virtual address space for process' (old)
.Fa p1
and (new)
.Fa p2 .
If the
.Fa shared
argument is non zero, p1 shares its address space with p2,
otherwise a new address space is created.
The
.Fa stack ,
.Fa stacksize ,
.Fa func
and
.Fa arg
arguments are passed to the machine-dependent
.Fn cpu_fork
function.
The
.Fn uvm_fork
function currently has no return value, and thus cannot fail.
.Pp
The
a1066 4
.Sh BUGS
The
.Fn uvm_fork
function should be able to fail in low memory conditions.
@


1.53
log
@zap double word;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.52 2014/05/29 06:17:08 guenther Exp $
d241 1
a241 1
#define UVM_INH_DONATE  0x30    /* "donate" << not used */
@


1.52
log
@Update to match recent changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.51 2014/01/21 03:15:46 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: January 21 2014 $
d415 1
a415 1
function frees the the uarea for
@


1.51
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.50 2013/07/20 06:25:33 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: July 20 2013 $
d141 1
a141 1
.Fn uvmspace_fork "struct vmspace *vm"
d143 5
a147 1
.Fn uvmspace_free "struct vmspace *vm1"
d149 1
a149 1
.Fn uvmspace_share "struct proc *p1" "struct proc *p2"
d391 3
a393 2
.Fa vm1
address space, typically used when allocating an address space for a
d404 15
a418 4
function causes process
.Fa p2
to share the address space of
.Fa p1 .
@


1.50
log
@- remove redundant sentence about misc functions
- note that pmap(9) is the MD portion of UVM.
- Convert reference to Chuck's dissertation to .Rs/.Re section
- uvm is no longer "new".
- Remove "(Missouri)". St. Louis should be enough to remove any confusion
  between wustl.edu and washington.edu.

From: Daniel Dickman
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.49 2013/07/17 20:21:55 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: July 17 2013 $
d400 1
a400 1
.Pa p2
@


1.49
log
@use .Mt for AUTHORS email; from Jan Stary <hans at stare dot cz>; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.48 2013/06/04 19:27:15 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: June 4 2013 $
d75 4
a78 1
There are also several miscellaneous functions.
d947 1
a947 1
int forks;  		/* forks */
d1050 7
d1058 1
a1058 2
UVM is a new VM system developed at Washington University in St. Louis
(Missouri).
a1074 2
UVM is also further documented in an August 1998 dissertation
by Charles D. Cranor.
@


1.48
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.47 2013/05/30 16:53:22 tedu Exp $
d33 1
a33 1
.Dd $Mdocdate: May 30 2013 $
d1073 1
a1073 1
.An Charles D. Cranor Aq chuck@@ccrc.wustl.edu
d1076 1
a1076 1
.An Matthew Green Aq mrg@@eterna.com.au
d1079 1
a1079 1
.An Chuck Silvers Aq chuq@@chuq.com
d1083 1
a1083 1
.An Artur Grabowski Aq art@@openbsd.org
@


1.47
log
@correct some lies
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.46 2013/05/22 06:44:58 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: May 22 2013 $
d40 2
a41 2
.Fd #include <sys/param.h>
.Fd #include <uvm/uvm.h>
@


1.46
log
@fix formatting here too; from ingo
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.45 2013/05/20 19:42:14 kettenis Exp $
d33 1
a33 1
.Dd $Mdocdate: May 20 2013 $
d563 1
a563 3
to use
.Fn simple_lock_try
when locking maps.
d611 1
a611 1
.Fn thread_wakeup
d636 1
a636 2
.Fa anon ,
which must be locked by the caller.
a1039 2
They will be renamed to
.Dq uvm_ .
@


1.45
log
@Wrap list of prototypes in a .nr nS 1/0 pair just like all the others.  No
cluse what this is supposed to do, but it is consistent with what happens
elsewhere in this man page and fixes the obvious formatting problems.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.44 2013/01/17 21:54:18 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: January 17 2013 $
d77 1
d86 1
@


1.44
log
@various macro fixes;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.43 2010/12/24 14:12:51 grange Exp $
d33 1
a33 1
.Dd $Mdocdate: December 24 2010 $
d772 1
d800 1
@


1.43
log
@Sync uvm_km_alloc1() prototype with reality.

ok miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.42 2010/11/09 16:03:38 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: November 9 2010 $
a76 2
.nr nS 1
.Pp
a84 1
.nr nS 0
a771 2
.nr nS 1
.Pp
a798 1
.nr nS 0
@


1.42
log
@update struct uvmexp, and fix some spacing issues while here;
ok tedu
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.41 2009/12/15 07:34:58 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: December 15 2009 $
d500 1
a500 1
.Fn uvm_km_alloc1 "vm_map_t map" "vsize_t size" "boolean_t zeroit"
d535 3
a537 1
bytes of wired memory in the kernel map, zeroing the memory if the
@


1.41
log
@spelling fixes, from Brad Tilley;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.40 2009/04/20 00:44:48 oga Exp $
d33 1
a33 1
.Dd $Mdocdate: April 20 2009 $
d709 3
a711 3
#define UVM_PLA_WAITOK		0x0001	/* may sleep */
#define UVM_PLA_NOWAIT		0x0002	/* can't sleep */
#define UVM_PLA_ZERO		0x0004	/* zero all pages before returning */
d797 1
a797 1
	     "void *arg"
d902 1
a902 1
int paging;     /* number of pages in the process of being paged out */
d904 2
d907 4
a910 1
int reserve_kernel; /* number of pages reserved for kernel */
d917 6
d925 8
a932 6
int nswapdev;   /* number of configured swap devices in system */
int swpages;    /* number of PAGE_SIZE'ed swap pages */
int swpginuse;  /* number of swap pages in use */
int nswget;     /* number of times fault calls uvm_swap_get() */
int nanon;      /* number total of anons in system */
int nfreeanon;  /* number of free anons */
d935 21
a955 15
int faults;             /* page fault count */
int traps;              /* trap count */
int intrs;              /* interrupt count */
int swtch;              /* context switch count */
int softs;              /* software interrupt count */
int syscalls;           /* system calls */
int pageins;            /* pagein operation count */
                        /* pageouts are in pdpageouts below */
int swapins;            /* swapins */
int swapouts;           /* swapouts */
int pgswapin;           /* pages swapped in */
int pgswapout;          /* pages swapped out */
int forks;              /* forks */
int forks_ppwait;       /* forks where parent waits */
int forks_sharevm;      /* forks where vmspace is shared */
d958 18
a975 18
int fltnoram;   /* number of times fault was out of ram */
int fltnoanon;  /* number of times fault was out of anons */
int fltpgwait;  /* number of times fault had to wait on a page */
int fltpgrele;  /* number of times fault found a released page */
int fltrelck;   /* number of times fault relock called */
int fltrelckok; /* number of times fault relock is a success */
int fltanget;   /* number of times fault gets anon page */
int fltanretry; /* number of times fault retrys an anon get */
int fltamcopy;  /* number of times fault clears "needs copy" */
int fltnamap;   /* number of times fault maps a neighbor anon page */
int fltnomap;   /* number of times fault maps a neighbor obj page */
int fltlget;    /* number of times fault does a locked pgo_get */
int fltget;     /* number of times fault does an unlocked get */
int flt_anon;   /* number of times fault anon (case 1a) */
int flt_acow;   /* number of times fault anon cow (case 1b) */
int flt_obj;    /* number of times fault is on object page (2a) */
int flt_prcopy; /* number of times fault promotes with copy (2b) */
int flt_przero; /* number of times fault promotes with zerofill (2b) */
d978 18
a995 12
int pdwoke;     /* number of times daemon woke up */
int pdrevs;     /* number of times daemon rev'd clock hand */
int pdswout;    /* number of times daemon called for swapout */
int pdfreed;    /* number of pages daemon freed since boot */
int pdscans;    /* number of pages daemon scanned since boot */
int pdanscan;   /* number of anonymous pages scanned by daemon */
int pdobscan;   /* number of object pages scanned by daemon */
int pdreact;    /* number of pages daemon reactivated since boot */
int pdbusy;     /* number of times daemon found a busy page */
int pdpageouts; /* number of times daemon started a pageout */
int pdpending;  /* number of times daemon got a pending pagout */
int pddeact;    /* number of pages daemon deactivates */
@


1.40
log
@Man bits for UVM_PLA_ZERO.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.39 2009/04/14 17:07:08 oga Exp $
d33 1
a33 1
.Dd $Mdocdate: April 14 2009 $
d701 1
a701 1
is the maximum number of physically contigous segments.
@


1.39
log
@manpage bits for uvm_pglistalloc() changes.

Couple of tweaks from jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.38 2009/03/19 20:09:00 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: March 19 2009 $
d711 1
d722 3
@


1.38
log
@no .Pp before or after sections;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.37 2008/11/04 21:37:07 deraadt Exp $
d33 1
a33 1
.Dd $Mdocdate: November 4 2008 $
d623 1
a623 1
.Fn uvm_pglistalloc "psize_t size" "paddr_t low" "paddr_t high" "paddr_t alignment" "paddr_t boundary" "struct pglist *rlist" "int nsegs" "int waitok"
a701 3
The
.Fa waitok
argument is currently ignored.
d705 16
@


1.37
log
@uvmspace_unshare() is never used; ok miod
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.36 2008/10/16 16:22:10 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: October 16 2008 $
a400 1
.Pp
@


1.36
log
@sub-system -> subsystem, for consistency withour other pages;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.35 2008/06/09 20:30:22 miod Exp $
d33 1
a33 1
.Dd $Mdocdate: June 9 2008 $
a143 2
.Ft void
.Fn uvmspace_unshare "struct proc *p"
a401 7
The
.Fn uvmspace_unshare
function ensures that process
.Fa p
has its own, unshared address space, by creating a new one if
necessary by calling
.Fn uvmspace_fork .
@


1.35
log
@Define a new flag, UVM_FLAG_HOLE, for uvm_map to create a vm_map_entry of
a new etype, UVM_ET_HOLE, meaning it has no backend.

UVM_ET_HOLE entries (which should be created as UVM_PROT_NONE and with
UVM_FLAG_NOMERGE and UVM_FLAG_HOLE) are skipped in uvm_unmap_remove(), so
that pmap_{k,}remove() is not called on the entry.

This is intended to save time, and behave better, on pmaps with MMU holes
at process exit time.

ok art@@, kettenis@@ provided feedback as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.34 2008/05/06 16:26:07 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: May 6 2008 $
d51 1
a51 1
initialise UVM sub-systems
d95 1
a95 1
pager and anonymous memory sub-systems, and then enables
d119 1
a119 1
function initialises the swap sub-system.
@


1.34
log
@typo fix; from tanner
ok art
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.33 2007/09/10 18:49:42 miod Exp $
d33 1
a33 1
.Dd $Mdocdate: September 10 2007 $
d260 1
@


1.33
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.32 2007/05/31 19:20:01 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: May 31 2007 $
d649 1
a649 1
.Fa off
@


1.32
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.31 2007/03/26 16:03:20 art Exp $
d33 1
a33 1
.Dd $Mdocdate$
d135 1
a135 1
.Fn uvmspace_alloc "vaddr_t min" "vaddr_t max" "int pageable"
d364 6
@


1.31
log
@Change some return value descriptions from "standard UVM return value"
to "standard errno", since that is what it is now.
noted by jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.30 2007/03/26 08:28:09 art Exp $
d33 1
a33 1
.Dd March 26, 2000
@


1.30
log
@Rip out all the KERN_ return values, since they will go
away sooner than later.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.29 2007/03/25 13:14:41 pedro Exp $
d279 1
a279 1
returns a standard UVM return value.
d313 1
a313 1
return a standard UVM return value.
d345 1
a345 1
This function returns a standard UVM return value.
d423 1
a423 1
returns a standard UVM return value.
@


1.29
log
@Remove references to KERN_SUCCESS, okay miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.28 2007/01/16 13:36:38 dim Exp $
d299 1
a299 1
.Dv KERN_NO_SPACE
a998 22
.Sh STANDARD UVM RETURN VALUES
This section documents the standard return values that callers of UVM
functions can expect.
They are derived from the Mach VM values of the same function.
The full list of values can be seen below.
.Bd -literal
#define KERN_INVALID_ADDRESS    1
#define KERN_PROTECTION_FAILURE 2
#define KERN_NO_SPACE           3
#define KERN_INVALID_ARGUMENT   4
#define KERN_FAILURE            5
#define KERN_RESOURCE_SHORTAGE  6
#define KERN_NOT_RECEIVER       7
#define KERN_NO_ACCESS          8
#define KERN_PAGES_LOCKED       9
.Ed
.Pp
Note that
.Dv KERN_NOT_RECEIVER
and
.Dv KERN_PAGES_LOCKED
values are not actually returned by the UVM code.
@


1.28
log
@Implement multiple segment allocation for uvm_pglistalloc, which fixes
most agp_generic_bind_memory failures when memory is limited and very
fragmented.

In effect, this should fix a lot of X startup crashes after
activities that exercise memory a lot (e.g. make builds, building big
ports, etc).

ok mickey, miod
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.27 2005/09/30 20:34:25 jaredy Exp $
a1004 1
#define KERN_SUCCESS            0
@


1.27
log
@deploy .An -nosplit; ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.26 2005/09/22 14:33:08 jmc Exp $
d703 2
a705 2
.Fa nsegs
and
d707 4
a710 1
arguments are currently ignored.
@


1.26
log
@remove one `file-system' example, and make another at least consistent
with section 9;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.25 2004/01/24 06:45:58 jmc Exp $
d1058 1
@


1.25
log
@typo from Jared Yanovich;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.24 2003/08/30 21:54:06 miod Exp $
d481 1
a481 1
This function will be removed when the file-system and UVM caches
@


1.24
log
@Remove uvm_useracc() description here as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.23 2003/06/06 20:56:32 jmc Exp $
d1047 1
a1047 1
UVM also includes a number of feature
@


1.23
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.22 2003/05/10 21:57:25 jmc Exp $
a767 2
.Ft boolean_t
.Fn uvm_useracc "caddr_t addr" "size_t len" "int rw"
d824 1
a824 3
and
.Fn uvm_useracc
functions check the access at address
d830 1
a830 2
access, in the kernel address space, and the current process'
address space respectively.
@


1.22
log
@typo;
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.21 2003/05/03 19:59:40 jmc Exp $
d363 1
a363 1
.Fa pageable.
d583 1
a583 3
as described in
.Xr uvm 9 )
from
d1031 7
a1080 7
.Sh SEE ALSO
.Xr getloadavg 3 ,
.Xr kvm 3 ,
.Xr sysctl 3 ,
.Xr ddb 4 ,
.Xr options 4 ,
.Xr pmap 9
@


1.21
log
@removed typo introduced by myself;
spotted by wiz@@netbsd.
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.20 2003/05/01 09:29:02 jmc Exp $
d721 1
a721 1
must be called at system boot time to setup physical memory management pages.
@


1.20
log
@typos;
ok art@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.19 2003/03/28 10:16:29 jmc Exp $
d111 1
a111 1
function initialises the uvmexp members' pagesize (if not already done by
@


1.19
log
@zero'd -> zeroed;

ok art@@, miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.18 2003/03/10 19:56:29 tedu Exp $
d111 1
a111 1
function initialises the uvmexp members pagesize (if not already done by
d194 1
a194 1
finds the offset based upon the virtual address, passed as 
d295 1
a295 1
.Fa limit 
d332 1
a332 1
function changes the protection 
d595 1
a595 1
argument specify the beginning of the address in thes submap.
d793 1
a793 1
.Fn uao_detach 
d876 1
a876 1
The load averages are access from userland using the
d953 1
a953 1
int pdscans;    /* number of pages daemon scaned since boot */
d1027 1
a1027 1
The structure and types whose names begin with 
d1029 1
a1029 1
were named so uvm could coexist with BSD VM during the early
d1052 1
a1052 1
UVM is also further documented in a August 1998 dissertation
@


1.18
log
@filesystem -> file system for section 9

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.17 2002/12/20 19:27:07 millert Exp $
d655 1
a655 1
#define UVM_PGA_ZERO            0x0002  /* returned page must be zero'd */
@


1.17
log
@fix two typos; Dave Steinberg
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.16 2002/12/19 01:20:30 millert Exp $
d453 1
a453 1
This function will be removed when the filesystem and VM buffer caches
d464 1
a464 1
This function will be removed when the filesystem and VM buffer caches
d473 1
a473 1
This function will be removed when the filesystem and VM buffer caches
@


1.16
log
@"papers by published" -> "papers published by"; Dave Steinberg
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.15 2002/11/08 08:08:47 mpech Exp $
d850 1
a850 1
.Fa access_tpe
@


1.15
log
@Time to cleanup:
o) start new sentence on a new line;
o) wrap long lines;
o) don't use .Pp before/after .Sh, .Ss;
o) OpenBSD -> .Ox;
o) typos;
o) close .Rs;
o) use space between arguments in tag, for example:
   .Xr blabla ) .

miod@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.14 2002/09/02 04:12:04 wcobb Exp $
d1045 2
a1046 2
anonymous memory system found in the SunOS4 VM (as described in papers by
published Sun Microsystems, Inc.).
@


1.14
log
@xrefs to pmap(9); ok art@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.13 2002/08/27 23:56:44 wcobb Exp $
a1032 1
.Pp
@


1.13
log
@no more .Pp before/after .Sh; from mpech@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.12 2002/08/27 16:24:26 wcobb Exp $
a1033 3
The
.Xr pmap 9
manual page is not yet written.
d1082 2
a1083 1
.Xr options 4
@


1.12
log
@- sync uvm_map(), uvm_map_pageable(), uvmspace_exec(), uvm_vnp_setsize(),
  uvm_km_suballoc(), uvm_pagealloc(), uvm_page_phsload(), uvm_pageout(),
  uvm_vslock() and uvm_fork() with reality.
- move the descriptions of uvm_km_suballoc(), uvm_km_free() and
  uvm_km_free_wakeup() to the correct section.
- describe uvm_map_pageable_all().
- complete sentences.
- add a BUGS section.
ok art@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.11 2002/08/24 03:36:30 wcobb Exp $
a728 1
.Pp
@


1.11
log
@- Mention that MD code must register some free RAM with uvm_page_physload()
  before uvm_init() is called.
- Remove some empty lines.
ok art@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.10 2001/12/29 17:36:41 mickey Exp $
d80 1
a80 1
.Fn uvm_init
d84 1
a84 1
.Fn uvm_setpagesize
d86 1
a86 1
.Fn uvm_swap_init
d89 1
d91 1
a91 1
sets up the UVM system at system boot time, after the
d103 1
d105 1
a105 1
initialises process limits for the named process.
d109 1
d111 1
a111 1
initialises the uvmexp members pagesize (if not already done by
d117 1
d119 1
a119 1
initialises the swap sub-system.
d123 3
a125 1
.Fn uvm_map "vm_map_t map" "vaddr_t *startp" "vsize_t size" "struct uvm_object *uobj" "voff_t uoffset" "uvm_flag_t flags"
d127 1
a127 1
.Fn uvm_map_pageable "vm_map_t map" "vaddr_t start" "vaddr_t end" "boolean_t new_pageable"
d137 1
a137 1
.Fn uvmspace_exec "struct proc *p"
d146 2
d150 1
d152 1
a152 1
establishes a valid mapping in map
d160 4
d206 1
a206 1
.Fn UVM_MAPFLAG "vm_prot_t prot" "vm_prot_t maxprot" "vm_inherit_t inh" "int advice" "int flags"
d212 1
a212 1
can take are:
d258 1
a258 1
#define UVM_FLAG_AMAPPAD 0x100000 /* for bss: pad amap to reduce malloc() */
d281 1
d283 1
a283 1
changes the pageability of the pages in the range from
d291 19
d311 3
a313 1
returns a standard UVM return value.
d315 1
d317 1
a317 1
checks the protection of the range from
d330 1
d332 1
a332 1
changes the protection 
d347 1
d349 1
a349 1
deallocates kernel memory in map
d356 1
d358 1
a358 1
allocates and returns a new address space, with ranges from
d365 1
d367 1
a367 1
either reuses the address space of process
d372 4
d377 1
d379 1
a379 1
creates and returns a new address space based upon the
d384 1
d386 1
a386 1
lowers the reference count on the address space
d390 1
d392 1
a392 1
causes process
d397 1
d399 1
a399 1
ensures that process
d410 1
d412 1
a412 1
is the main entry point for faults.
d429 1
a429 1
.Fn uvm_vnp_setsize "struct vnode *vp" "u_quad_t newsize"
d438 1
d440 1
a440 1
attaches a UVM object to vnode
d445 1
d447 1
a447 1
sets the size of vnode
d456 1
d458 1
a458 1
flushes dirty vnodes from either the mount point passed in
d467 1
d469 1
a469 1
frees all VM resources allocated to vnode
d476 1
d478 1
a478 1
disables vnode
d490 1
d492 1
a492 1
performs the I/O described in
d511 1
a511 1
.Fn uvm_km_suballoc "vm_map_t map" "vaddr_t *min" "vaddr_t *max " "vsize_t size" "boolean_t pageable" "boolean_t fixed" "vm_map_t submap"
d518 1
d522 1
a522 1
allocate
d534 1
d536 1
a536 1
allocates and returns
d542 1
d544 1
a544 1
allocates and returns
d555 1
d557 1
a557 1
causes
d569 1
d573 1
a573 1
return a newly allocated zero-filled address in the kernel map of size
d578 41
d622 1
a622 1
.Fn uvm_pagealloc "struct uvm_object *uobj" "voff_t off" "struct vm_anon *anon"
d632 1
a632 1
.Fn uvm_page_physload "vaddr_t start" "vaddr_t end" "vaddr_t avail_start" "vaddr_t avail_end"
d635 1
d637 1
a637 1
allocates a page of memory at virtual address
d650 20
a669 3
Returns
.Dv NULL
when no page can be found.
d671 1
d673 1
a673 1
reallocates page
d678 4
a681 1
.Fa newoff .
d683 1
d685 1
a685 1
frees the physical page
d688 1
d690 1
a690 1
allocates a list of pages for size
d711 1
d713 1
a713 1
frees the list of pages pointed to by
d716 1
d718 4
a721 3
loads physical memory segments into VM space.
It must be called at system boot time to setup physical memory management
pages.
a729 37
.Fn uvm_km_suballoc
allocates submap from
.Fa map ,
creating a new map if
.Fa submap
is
.Dv NULL .
The addresses of the submap can be specified exactly by setting the
.Fa fixed
argument to non-zero, which causes the
.Fa min
argument specify the beginning of the address in thes submap.
If
.Fa fixed
is zero, any address of size
.Fa size
will be allocated from
.Fa map
and the start and end addresses returned in
.Fa min
and
.Fa max .
If
.Fa pageable
is non-zero, entries in the map may be paged out.
.Pp
.Fn uvm_km_free
and
.Fn uvm_km_free_wakeup
free
.Fa size
bytes of memory in the kernel map, starting at address
.Fa addr .
.Fn uvm_km_free_wakeup
calls
.Fn thread_wakeup
on the map before unlocking the map.
d733 1
a733 1
.Fn uvm_pageout
d735 1
a735 1
.Fn uvm_scheduler
d740 1
d742 4
a745 1
is the main loop for the page daemon.
d747 1
d749 1
a749 1
is the process zero main loop, which is to be called after the
d751 2
a752 1
It handles the swapping in of runnable, swapped out processes in priority
d755 1
d757 1
a757 1
swaps in the named process.
d774 2
a775 1
.Fn uvm_vslock "struct proc *p" "caddr_t addr" "size_t len"
d783 3
a785 1
.Fn uvm_fork "struct proc *p1" "struct proc *p2" "boolean_t shared"
d815 1
d817 1
a817 1
changes the protection of kernel memory from
d827 1
d831 1
a831 1
check the access at address
d840 1
d844 1
a844 1
control the wiring and unwiring of pages for process
d850 6
d858 1
d860 1
a860 1
calculates the load average and wakes up the swapper if necessary.
d862 1
d864 1
a864 1
provides support for the
d964 1
d966 1
a966 1
forks a virtual address space for process' (old)
d974 12
a985 3
This function currently has no return value, and thus cannot fail.
In the future, this function will changed to allowed it to
fail in low memory conditions.
d987 1
d989 1
a989 1
increases the stack segment of process
d994 1
d996 1
a996 1
generates a coredump on vnode
d1028 1
a1028 5
.Fn uvm_chgkprot
is only available if the kernel has been compiled with options
.Dv KGDB .
.Pp
All structure and types whose names begin with 
d1030 3
a1032 1
will be renamed to
d1077 4
@


1.10
log
@missd one pair of angles
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.9 2001/12/29 17:33:45 mickey Exp $
d96 5
a127 1

a668 1

a674 1

a678 1

a682 1

@


1.9
log
@fix the history and tag the names proper
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.8 2001/10/05 14:45:54 mpech Exp $
d947 1
a947 1
.An Chuck Silvers Aq <chuq@@chuq.com>
@


1.8
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.7 2001/08/03 15:21:17 mpech Exp $
d939 1
a939 1
.Nx 1.4 .
d941 2
a942 1
Charles D. Cranor <chuck@@ccrc.wustl.edu> designed and implemented UVM.
d944 2
a945 4
Matthew Green <mrg@@eterna.com.au> wrote the swap-space management code
and handled the logistical issues involved with merging UVM into the
.Nx
source tree.
d947 2
a948 1
Chuck Silvers <chuq@@chuq.com> implemented the aobj pager, thus allowing
d950 5
@


1.7
log
@o) We don't like .Pp before/after .Sh;
o) .Nm always has argument in .Sh SYNOPSIS;
o) We always closes .Bl and .Bd tags;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.6 2001/06/28 22:14:23 millert Exp $
d44 4
a47 2
resources.  User processes and the kernel access these resources through
UVM's external interface.  UVM's external interface includes functions that:
d67 6
a72 4
pagedaemon and swapper.   The pagedaemon process sleeps until physical memory
becomes scarce.  When that happens, pagedaemon is awoken.   It scans physical
memory, paging out and freeing memory that has not been recently used.  The
swapper process swaps in runnable processes that are currently swapped out,
d91 2
a92 2
copyright has been printed.  It initialises
global state, the page, map, kernel virtual memory state,
d98 3
a100 3
initialises process limits for the named process.  This is for use by
the system startup for process zero, before any other processes are
created.
d104 2
a105 2
machine-dependent code), pageshift and pagemask.  It should be called by
machine-dependent code early in the
d141 2
a142 1
which must be unlocked.  The new mapping has size
d146 2
a147 1
units.  The
d151 2
a152 1
arguments can have four meanings.  When
d163 2
a164 1
function.  If
d181 2
a182 2
is any other value, we are doing a normal mapping at this offset.  The
start address of the map will be returned in
d247 3
a249 2
macro arguments can be combined with an or operator.  There are
several special purpose macros for checking protection combinations, e.g. the
d251 3
a253 2
macro.  There are also some additional macros to extract bits from
the flags.  The
d303 2
a304 1
is non-zero.  This function returns a standard UVM return value.
d359 2
a360 1
is the main entry point for faults.  It takes
d388 2
a389 1
creating the object if necessary.  The object is returned.
d396 4
a399 3
Caller must hold a reference to the vnode.  If the vnode shrinks, pages
no longer used are discarded.  This function will be removed when the
filesystem and VM buffer caches are merged.
d415 3
a417 2
all future operations using this vnode will fail.  This function will be
removed when the filesystem and VM buffer caches are merged.
d422 4
a425 3
from persisting when all references are freed.  This function will be
removed when the file-system and UVM caches are unified.  Returns
true if there is no active vnode.
d468 2
a469 2
zeros the memory.  Both of these functions are defined as macros in
terms of
d537 2
a538 1
which must be locked by the caller.  Only one of
d567 2
a568 1
describe the lowest and highest addresses acceptable for the list.  If
d571 2
a572 1
power-of-two notation.  If
d587 4
a590 3
loads physical memory segments into VM space.  It must be called at system
boot time to setup physical memory management pages.  The arguments describe
the
d609 2
a610 1
argument specify the beginning of the address in thes submap.  If
d650 2
a651 2
system has finished starting other processes.  It handles the
swapping in of runnable, swapped out processes in priority
d764 2
a765 2
totals, and returns the uvmexp structure respectively.  The load averages
are access from userland using the
d767 3
a769 2
function.  The uvmexp structure has all global state of the UVM system,
and has the following members:
d860 3
a862 3
otherwise a new address space is created.  This function
currently has no return value, and thus cannot fail.  In
the future, this function will changed to allowed it to
d882 3
a884 2
functions can expect.  They are derived from the Mach VM values
of the same function.  The full list of values can be seen below.
d918 2
a919 1
(Missouri).  UVM's roots lie partly in the Mach-based
d923 2
a924 1
VM system, and the SunOS4 VM system.  UVM's basic structure is based on the
d926 2
a927 1
VM system.  UVM's new anonymous memory system is based on the
d929 2
a930 1
published Sun Microsystems, Inc.).  UVM also includes a number of feature
d934 3
a936 2
copy-on-write, and clustered anonymous memory pageout.  UVM is also
further documented in a August 1998 dissertation by Charles D. Cranor.
@


1.6
log
@speling; jsyn@@nthought.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.5 2000/12/22 00:13:34 avsm Exp $
a107 1
.Pp
a341 1
.Pp
a359 1
.Pp
a410 1
.Pp
a421 1
.Pp
a498 1
.Pp
a614 1
.Pp
@


1.5
log
@more typo fixes; aaron@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.4 2000/11/10 20:02:20 todd Exp $
d155 1
a155 1
does not use the machine-dependant
d546 1
a546 1
free's the physical page
d782 2
a783 2
int nanon;      /* number total of anon's in system */
int nfreeanon;  /* number of free anon's */
@


1.4
log
@.Sh AUTHOR -> AUTHORS, ok aaron@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.3 2000/11/09 16:17:00 mickey Exp $
d354 1
a354 1
offset into the map the fault occured,
d614 1
a614 1
bytes of memory in the kernal map, starting at address
d923 1
a923 1
and handled the logistical issues involed with merging UVM into the
@


1.3
log
@add uvm(9) from netbsd; as a side effect increase art's guilt factor ;)
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d919 1
a919 1
.Sh AUTHOR
@


1.2
log
@REVERT TO PREVIOUS STATE OF AFFAIR.

If those pages are different from the NetBSD version, maybe there's a
reason ?

Like, possibly, I just read our source code, which just happens to do
things in DIFFERENT ways than NetBSD does ?

As far as the added pages go, they obviously haven't been checked against
actual code as well, hence they're worse than useless, since a large part
of the information is definitely misleading.
@
text
@d1 2
a2 2
.\"	$OpenBSD: uvm.9,v 1.1 1999/09/22 03:16:47 csapuntz Exp $
.\"	$NetBSD: uvm.9,v 1.7 1999/05/06 12:04:50 hwr Exp $
d33 1
a33 1
.Dd April 10, 1998
d37 2
a38 2
.Nm UVM virtual memory system
.Nd external interface
a40 1
.Fd #include <vm/vm.h>
d45 1
a45 1
UVM's exteral interface.  UVM's external interface includes functions that:
a71 2

.Pp
a72 1

a83 1

a91 1

a96 1

a103 1

a106 2

.Pp
a107 1

d111 1
a111 1
.Fn uvm_map "vm_map_t map" "vaddr_t *startp" "vsize_t size" "struct uvm_object *uobj" "vaddr_t uoffset" "uvm_flag_t flags"
a133 1

a253 1

a265 1

a279 1

a294 1

a302 1

a310 1

a317 1

a323 1

a328 1

a334 1

a341 2

.Pp
a342 1

a360 2

.Pp
a361 1

a374 1

a379 1

a388 1

a398 1

a405 1

a412 2

.Pp
a413 1

a418 1

a424 2

.Pp
a425 1

a446 1

a461 1

a468 1

a493 1

a502 2

.Pp
a503 1

d507 1
a507 1
.Fn uvm_pagealloc "struct uvm_object *uobj" "vaddr_t off" "struct vm_anon *anon"
d509 1
a509 1
.Fn uvm_pagerealloc "struct vm_page *pg" "struct uvm_object *newobj" "vaddr_t newoff"
a518 1

a535 1

a543 1

a547 1

a567 1

a571 1

a582 1

a607 1

a619 2

.Pp
a620 1

d629 1
a629 2
.Ft void

a632 1

a638 1

a641 2

.Pp
a642 1

a675 1

a698 1

a709 1

a721 1

a732 1

a735 1

a835 1

a848 1

a854 1

a864 1

a886 1

a887 3
These functions are only available with options
.Dv UVM .
.Pp
d892 4
a895 4
The include file
.Pa <vm/vm.h>
will be deprecated when then Mach VM system is obsoleted.  All structure
and types whose names begin with ``vm_'' will be renamed to ``uvm_''.
a899 1

d904 3
a906 2
VM system, the FreeBSD VM system, and the SunOS4 VM system.  UVM's basic
structure is based on the
d908 2
a909 3
VM system.  UVM's new i386 machine-depenent layer includes several ideas
from FreeBSD.  UVM's new anonymous memory system is based on the
anonymous memory system found in SunOS4 VM (as described in papers by
d911 5
a915 3
new to BSD including page loanout, map entry passing, simplified
copy-on-write, and clustered anonymous memory pageout.  UVM will be
further documented in August 1998 in a dissertation by Charles D. Cranor.
a918 1

d922 1
a922 1
Matthew Green <mrg@@eterna.com.au> wrote the swap-space managemnt code
d924 2
a925 1
NetBSD source tree.
a928 1

@


1.1
log
@

Add/update some man9 pages from NetBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: uvm.9,v 1.7 1999/05/06 12:04:50 hwr Exp $
@

