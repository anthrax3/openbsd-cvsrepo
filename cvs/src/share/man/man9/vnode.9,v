head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.24
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.26
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.22
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.18
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.20
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.12
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.16
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.14
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.10
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.12
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.10
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@.\" @;


1.28
date	2011.07.18.12.03.45;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.12.10.18.01;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.31.19.20.01;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.23.16.19.38;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.11.13.32.28;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.02.19.39.31;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.19.16.52.19;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.19.16.50.46;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.22.14.33.08;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.22.21.54.17;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.20.20.46.14;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.02.19.00.26;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.08.23.17.18;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.26.15.05.07;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.27.09.19.30;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.20.06.21.09;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.20.06.19.39;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.08.08.08.47;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.26.20.18.07;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.28.09.07.07;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.28.19.22.05;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.15.00.05.55;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.05.14.45.54;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.28.22.14.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.16.02.27.44;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.26.18.34.21;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.24.02.07.34;	author csapuntz;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Wording fixes and remove refrences to vnode_if.src as it's gone;

From Benny Lvfgren (benny -at- internetlabbet.se)
@
text
@.\"     $OpenBSD: vnode.9,v 1.27 2008/04/12 10:18:01 jmc Exp $
.\"
.\" Copyright (c) 2001 Constantine Sapuntzakis
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
.\" INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
.\" THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
.\" EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
.\" PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
.\" OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\" WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
.\" OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
.\" ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: April 12 2008 $
.Dt VNODE 9
.Os
.Sh NAME
.Nm vnode
.Nd an overview of vnodes
.Sh DESCRIPTION
A
.Em vnode
is an object in kernel memory that speaks the
.Ux
file interface (open, read, write, close, readdir, etc.).
Vnodes can represent files, directories, FIFOs, domain sockets, block devices,
character devices.
.Pp
Each vnode has a set of methods which start with the string
.Dq VOP_ .
These methods include
.Fn VOP_OPEN ,
.Fn VOP_READ ,
.Fn VOP_WRITE ,
.Fn VOP_RENAME ,
.Fn VOP_CLOSE ,
and
.Fn VOP_MKDIR .
Many of these methods correspond closely to the equivalent
file system call \-
.Xr open 2 ,
.Xr read 2 ,
.Xr write 2 ,
.Xr rename 2 ,
etc.
Each file system (FFS, NFS, etc.) provides implementations for these methods.
.Pp
The Virtual File System library (see
.Xr vfs 9 )
maintains a pool of vnodes.
File systems cannot allocate their own vnodes; they must use the functions
provided by the VFS to create and manage vnodes.
.Pp
The definition of a vnode is as follows:
.Bd -literal
struct vnode {
	struct uvm_vnode v_uvm;		/* uvm(9) data */
	int	(**v_op)(void *);	/* vnode operations vector */
	enum	vtype v_type;		/* vnode type */
	u_int	v_flag;			/* vnode flags (see below) */
	u_int	v_usecount;		/* reference count of users */
	u_int	v_writecount;		/* reference count of writers */
	/* Flags that can be read/written in interrupts */
	u_int	v_bioflag;		/* flags used by intr handlers */
	u_int	v_holdcnt;		/* buffer references */
	u_int	v_id;			/* capability identifier */
	struct	mount *v_mount;		/* ptr to vfs we are in */
	TAILQ_ENTRY(vnode) v_freelist;	/* vnode freelist */
	LIST_ENTRY(vnode) v_mntvnodes;	/* vnodes for mount point */
	struct	buflists v_cleanblkhd;	/* clean blocklist head */
	struct	buflists v_dirtyblkhd;	/* dirty blocklist head */
	u_int	v_numoutput;		/* num of writes in progress */
	LIST_ENTRY(vnode) v_synclist;	/* vnode with dirty buffers */
	union {
	  struct mount    *vu_mountedhere;/* ptr to mounted vfs (VDIR) */
	  struct socket   *vu_socket;	/* UNIX IPC (VSOCK) */
	  struct specinfo *vu_specinfo;	/* device (VCHR, VBLK) */
	  struct fifoinfo *vu_fifoinfo;	/* fifo (VFIFO) */
	} v_un;

	enum	vtagtype v_tag;		/* type of underlying data */
	void	*v_data;		/* private data for fs */
	struct {
	  struct simplelock vsi_lock;	/* lock to protect below */
	  struct selinfo vsi_selinfo;	/* identity of poller(s) */
	} v_selectinfo;
};
#define v_mountedhere	v_un.vu_mountedhere
#define v_socket	v_un.vu_socket
#define v_specinfo	v_un.vu_specinfo
#define v_fifoinfo	v_un.vu_fifoinfo
.Ed
.Ss Vnode life cycle
When a client of the VFS requests a new vnode, the vnode allocation
code can reuse an old vnode object that is no longer in use.
Whether a vnode is in use is tracked by the vnode reference count
.Pq Va v_usecount .
By convention, each open file handle holds a reference
as do VM objects backed by files.
A vnode with a reference count of 1 or more will not be deallocated or
reused to point to a different file.
So, if you want to ensure that your vnode doesn't become a different
file under you, you better be sure you have a reference to it.
A vnode that points to a valid file and has a reference count of 1 or more
is called
.Em active .
.Pp
When a vnode's reference count drops to zero, it becomes
.Em inactive ,
that is, a candidate for reuse.
An inactive vnode still refers to a valid file and one can try to
reactivate it using
.Xr vget 9
(this is used a lot by caches).
.Pp
Before the VFS can reuse an inactive vnode to refer to another file,
it must clean all information pertaining to the old file.
A cleaned out vnode is called a
.Em reclaimed
vnode.
.Pp
To support forceable unmounts and the
.Xr revoke 2
system call, the VFS may reclaim a vnode with a positive reference
count.
The reclaimed vnode is given to the dead file system, which
returns errors for most operations.
The reclaimed vnode will not be
reused for another file until its reference count hits zero.
.Ss Vnode pool
The
.Xr getnewvnode 9
call allocates a vnode from the pool, possibly reusing an
inactive vnode, and returns it to the caller.
The vnode returned has a reference count
.Pq Va v_usecount
of 1.
.Pp
The
.Xr vref 9
call increments the reference count on the vnode.
It may only be on a vnode with reference count of 1 or greater.
The
.Xr vrele 9
and
.Xr vput 9
calls decrement the reference count.
In addition, the
.Xr vput 9
call also releases the vnode lock.
.Pp
The
.Xr vget 9
call, when used on an inactive vnode, will make the vnode active
by bumping the reference count to one.
When called on an active vnode,
.Fn vget
increases the reference count by one.
However, if the vnode is being reclaimed concurrently, then
.Fn vget
will fail and return an error.
.Pp
The
.Xr vgone 9
and
.Xr vgonel 9
calls
orchestrate the reclamation of a vnode.
They can be called on both active and inactive vnodes.
.Pp
When transitioning a vnode to the reclaimed state, the VFS will call the
.Xr VOP_RECLAIM 9
method.
File systems use this method to free any file-system-specific data
they attached to the vnode.
.Ss Vnode locks
The vnode actually has two different types of locks: the vnode lock
and the vnode reclamation lock
.Pq Dv VXLOCK .
.Ss The vnode lock
The vnode lock and its consistent use accomplishes the following:
.Bl -bullet
.It
It keeps a locked vnode from changing across certain pairs of VOP_ calls,
thus preserving cached data.
For example, it keeps the directory from
changing between a
.Xr VOP_LOOKUP 9
call and a
.Xr VOP_CREATE 9 .
The
.Fn VOP_LOOKUP
call makes sure the name doesn't already exist in the
directory and finds free room in the directory for the new entry.
The
.Fn VOP_CREATE
call can then go ahead and create the file without checking if
it already exists or looking for free space.
.It
Some file systems rely on it to ensure that only one
.Dq thread
at a time
is calling VOP_ vnode operations on a given file or directory.
Otherwise, the file system's behavior is undefined.
.It
On rare occasions, code will hold the vnode lock so that a series of
VOP_ operations occurs as an atomic unit.
(Of course, this doesn't work with network file systems like NFSv2 that don't
have any notion of bundling a bunch of operations into an atomic unit.)
.It
While the vnode lock is held, the vnode will not be reclaimed.
.El
.Pp
There is a discipline to using the vnode lock.
Some VOP_ operations require that the vnode lock is held before being called.
.Pp
The vnode lock is acquired by calling
.Xr vn_lock 9
and released by calling
.Xr VOP_UNLOCK 9 .
.Pp
A process is allowed to sleep while holding the vnode lock.
.Pp
The implementation of the vnode lock is the responsibility of the individual
file systems.
Not all file systems implement it.
.Pp
To prevent deadlocks, when acquiring locks on multiple vnodes, the lock
of parent directory must be acquired before the lock on the child directory.
.Ss Other vnode synchronization
The vnode reclamation lock
.Pq Dv VXLOCK
is used to prevent multiple
processes from entering the vnode reclamation code.
It is also used as a flag to indicate that reclamation is in progress.
The
.Dv VXWANT
flag is set by processes that wish to be woken up when reclamation
is finished.
.Pp
The
.Xr vwaitforio 9
call is used to wait for all outstanding write I/Os associated with a
vnode to complete.
.Ss Version number/capability
The vnode capability,
.Va v_id ,
is a 32-bit version number on the vnode.
Every time a vnode is reassigned to a new file, the vnode capability
is changed.
This is used by code that wishes to keep pointers to vnodes but doesn't want
to hold a reference (e.g., caches).
The code keeps both a vnode pointer and a copy of the capability.
The code can later compare the vnode's capability to its copy and see
if the vnode still points to the same file.
.Pp
Note: for this to work, memory assigned to hold a
.Vt struct vnode
can
only be used for another purpose when all pointers to it have disappeared.
Since the vnode pool has no way of knowing when all pointers have
disappeared, it never frees memory it has allocated for vnodes.
.Ss Vnode fields
Most of the fields of the vnode structure should be treated as opaque
and only manipulated through the proper APIs.
This section describes the fields that are manipulated directly.
.Pp
The
.Va v_flag
attribute contains random flags related to various functions.
They are summarized in the following table:
.Pp
.Bl -tag -width 10n -compact -offset indent
.It Dv VROOT
This vnode is the root of its file system.
.It Dv VTEXT
This vnode is a pure text prototype.
.It Dv VSYSTEM
This vnode is being used by kernel.
.It Dv VISTTY
This vnode represents a
.Xr tty 4 .
.It Dv VXLOCK
This vnode is locked to change its underlying type.
.It Dv VXWANT
A process is waiting for this vnode.
.It Dv VALIASED
This vnode has an alias.
.It Dv VLOCKSWORK
This vnode's underlying file system supports locking discipline.
.El
.Pp
The
.Va v_tag
attribute indicates what file system the vnode belongs to.
Very little code actually uses this attribute and its use is deprecated.
Programmers should seriously consider using more object-oriented approaches
(e.g. function tables).
There is no safe way of defining new
.Va v_tag Ns 's
for loadable file systems.
The
.Va v_tag
attribute is read-only.
.Pp
The
.Va v_type
attribute indicates what type of file (e.g. directory,
regular, FIFO) this vnode is.
This is used by the generic code for various checks.
For example, the
.Xr read 2
system call returns zero when a read is attempted on a directory.
.Pp
Possible types are:
.Pp
.Bl -tag -width 10n -offset indent -compact
.It Dv VNON
This vnode has no type.
.It Dv VREG
This vnode represents a regular file.
.It Dv VDIR
This vnode represents a directory.
.It Dv VBLK
This vnode represents a block device.
.It Dv VCHR
This vnode represents a character device.
.It Dv VLNK
This vnode represents a symbolic link.
.It Dv VSOCK
This vnode represents a socket.
.It Dv VFIFO
This vnode represents a named pipe.
.It Dv VBAD
This vnode represents a bad or dead file.
.El
.Pp
The
.Va v_data
attribute allows a file system to attach a piece of file
system specific memory to the vnode.
This contains information about the file that is specific to
the file system (such as an inode pointer in the case of FFS).
.Pp
The
.Va v_numoutput
attribute indicates the number of pending synchronous
and asynchronous writes on the vnode.
It does not track the number of dirty buffers attached to the vnode.
The attribute is used by code like
.Xr fsync 2
to wait for all writes
to complete before returning to the user.
This attribute must be manipulated at
.Xr splbio 9 .
.Pp
The
.Va v_writecount
attribute tracks the number of write calls pending
on the vnode.
.Ss Rules
The vast majority of vnode functions may not be called from interrupt
context.
The exceptions are
.Fn bgetvp
and
.Fn brelvp .
The following fields of the vnode are manipulated at interrupt level:
.Va v_numoutput , v_holdcnt , v_dirtyblkhd ,
.Va v_cleanblkhd , v_bioflag , v_freelist ,
and
.Va v_synclist .
Any access to these fields should be protected by
.Xr splbio 9 .
.Sh SEE ALSO
.Xr uvm 9 ,
.Xr vaccess 9 ,
.Xr vclean 9 ,
.Xr vcount 9 ,
.Xr vdevgone 9 ,
.Xr vfinddev 9 ,
.Xr vflush 9 ,
.Xr vflushbuf 9 ,
.Xr vfs 9 ,
.Xr vget 9 ,
.Xr vgone 9 ,
.Xr vhold 9 ,
.Xr vinvalbuf 9 ,
.Xr vn_lock 9 ,
.Xr VOP_LOOKUP 9 ,
.Xr vput 9 ,
.Xr vrecycle 9 ,
.Xr vref 9 ,
.Xr vrele 9 ,
.Xr vwaitforio 9 ,
.Xr vwakeup 9
.Sh HISTORY
This document first appeared in
.Ox 2.9 .
@


1.27
log
@getnewvnode() is not a system call; fix from Iruata Souza, though i
chose to refer to it as a "call", rather than function, in keeping
with the rest of the section;

ok dlg
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.26 2007/05/31 19:20:01 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: May 31 2007 $
d183 1
a183 1
When transitioning a vnode to the reclaimed state, the VFS will call
a227 2
A description of this rather arcane locking discipline is in
.Pa sys/kern/vnode_if.src .
@


1.26
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.25 2007/03/23 16:19:38 thib Exp $
d26 1
a26 1
.Dd $Mdocdate$
d145 1
a145 1
system call allocates a vnode from the pool, possibly reusing an
@


1.25
log
@remove blather about the v_interlock; Since its now gone.

suggestions and ok jmc@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.24 2007/02/11 13:32:28 bluhm Exp $
d26 1
a26 1
.Dd September 16, 2004
@


1.24
log
@Correct return value in read(2) syscall example.  ok pedro
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.23 2007/02/02 19:39:31 thib Exp $
a92 1
	struct	simplelock v_interlock;	/* lock on usecount and flag */
d189 2
a190 2
The vnode actually has three different types of lock: the vnode lock,
the vnode interlock, and the vnode reclamation lock
a243 20
.Ss Vnode interlock
The vnode interlock
.Pq Va v_interlock
is a simplelock (see
.Xr simple_lock 9 ) .
It is useful on multi-processor systems for acquiring a quick exclusive
lock on the contents of the vnode.
It MUST NOT be held while sleeping.
.Pp
This field protects the
.Va v_flag , v_writecount , v_usecount ,
and
.Va v_holdcnt
fields from concurrent access.
See
.Xr lock 9
for more details on lock synchronization in interrupt context.
.\" Other splbio/interrupt issues?
.Pp
Operations on this lock are a no-op on uniprocessor systems.
@


1.23
log
@Remove refrence to VLAYER, its gone.
Diff from Iruata Souza, thanks!

ok pedro@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.22 2005/10/19 16:52:19 pedro Exp $
d348 1
a348 1
system call returns an error when a read is attempted on a directory.
@


1.22
log
@v_lock is also gone, noted by tedu@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.21 2005/10/19 16:50:46 pedro Exp $
a323 2
.It Dv VLAYER
This vnode is on a layered file system.
@


1.21
log
@Remove v_vnlock from struct vnode, okay krw@@ tedu@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.20 2005/09/22 14:33:08 jmc Exp $
a93 1
	struct	lock v_lock;		/* used for non-locking fs's */
@


1.20
log
@remove one `file-system' example, and make another at least consistent
with section 9;
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.19 2004/09/22 21:54:17 jaredy Exp $
a94 1
	struct	lock *v_vnlock;		/* pointer to vnode lock */
@


1.19
log
@many xrefs added
use more/better macros where appropriate
show structure of vnode
tables for vnode flags and types
other minor clarifications, grammar & typos fixes, etc.

ok and lots of help from jmc and pedro
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.18 2003/06/06 20:56:32 jmc Exp $
d189 1
a189 1
File systems use this method to free any file-system specific data
@


1.18
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.17 2003/04/20 20:46:14 jmc Exp $
d26 1
a26 1
.Dd February 22, 2001
d33 5
a37 2
A vnode is an object in kernel memory that speaks the UNIX file
interface (open, read, write, close, readdir, etc.).
d41 10
a50 3
Each vnode has a set of methods which start with string 'VOP_'.
These methods include VOP_OPEN, VOP_READ, VOP_WRITE, VOP_RENAME, VOP_CLOSE,
VOP_MKDIR.
d52 6
a57 1
file system call - open, read, write, rename, etc.
d60 3
a62 1
The Virtual File System (VFS) library maintains a pool of vnodes.
d65 43
d112 1
a112 1
(v_usecount).
d115 2
a116 2
A vnode with a reference count of 1 or more will not be de-allocated or
re-used to point to a different file.
d120 2
a121 1
is called "active".
d123 2
a124 1
When a vnode's reference count drops to zero, it becomes "inactive",
d126 1
a126 1
An "inactive" vnode still refers to a valid file and one can try to
d133 3
a135 1
A cleaned out vnode is called a "reclaimed" vnode.
d139 1
a139 1
system call, the VFS may "reclaim" a vnode with a positive reference
d141 1
a141 1
The "reclaimed" vnode is given to the dead file system, which
d144 1
a144 1
re-used for another file until its reference count hits zero.
d149 4
a152 2
"inactive" vnode, and returns it to the caller.
The vnode returned has a reference count (v_usecount) of 1.
d169 1
a169 1
call, when used on an inactive vnode, will make the vnode "active"
d171 6
a176 3
When called on an active vnode, vget increases the reference count by one.
However, if the vnode is being reclaimed concurrently, then vget will fail
and return an error.
d182 1
d186 1
a186 1
When transitioning a vnode to the "reclaimed" state, the VFS will call
d193 2
a194 1
the vnode interlock, and the vnode reclamation lock (VXLOCK).
d202 7
a208 2
changing between a VOP_LOOKUP call and a VOP_CREATE.
The VOP_LOOKUP call makes sure the name doesn't already exist in the
d210 3
a212 1
The VOP_CREATE can then go ahead and create the file without checking if
d215 3
a217 1
Some file systems rely on it to ensure that only one "thread" at a time
d248 4
a251 1
The vnode interlock (vp->v_interlock) is a spinlock.
d255 10
a264 1
(What fields does it cover? What about splbio/interrupt issues?)
d267 4
a270 2
.Ss Other Vnode synchronization
The vnode reclamation lock (VXLOCK) is used to prevent multiple
d273 3
a275 1
The VXWANT flag is set by processes that wish to be woken up when reclamation
d283 3
a285 1
The vnode capability, v_id, is a 32-bit version number on the vnode.
d290 1
a290 1
The code keeps both a vnode * and a copy of the capability.
d294 3
a296 1
Note: for this to work, memory assigned to hold a struct vnode can
d305 26
a330 2
The v_flag attribute contains random flags related to various functions.
They are summarized in table ...
d332 3
a334 1
The v_tag attribute indicates what file system the vnode belongs to.
d338 6
a343 2
There is no safe way of defining new v_tags for loadable file systems.
The v_tag attribute is read-only.
d345 3
a347 1
The v_type attribute indicates what type of file (e.g. directory,
d354 26
a379 1
The v_data attribute allows a file system to attach a piece of file
d382 1
a382 1
the file system.
d384 3
a386 1
The v_numoutput attribute indicates the number of pending synchronous
d389 3
a391 1
The attribute is used by code like fsync to wait for all writes
d393 2
a394 1
This attribute must be manipulated at splbio().
d396 3
a398 1
The v_writecount attribute tracks the number of write calls pending
d400 1
a400 1
.Ss RULES
d403 4
a406 1
The exceptions are bgetvp and brelvp.
d408 28
a435 3
v_numoutput, v_holdcnt, v_dirtyblkhd, v_cleanblkhd, v_bioflag, v_freelist,
and v_synclist.
Any access to these fields should be protected by splbio.
@


1.17
log
@typos, and 1 from tedu;

ok tedu@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.16 2003/04/02 19:00:26 jmc Exp $
d27 2
a28 2
.Dt vnode 9
.Os OpenBSD 2.9
a246 1

@


1.16
log
@fifo -> FIFO

ok millert@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.15 2003/03/08 23:17:18 jmc Exp $
d42 1
a42 1
file system call--open, read, write, rename, etc.
d65 3
a67 1
reactivate it using vget (this is used a lot by caches).
d73 1
a73 1
To support forceable unmounts and the 
d83 2
a84 2
.Xr getnewvnode 9 
system call allocates a vnode from the pool, possible reusing an
d88 2
a89 2
The 
.Xr vref 9 
d94 3
a96 3
and 
.Xr vput 9 
calls decrement the reference count. 
d110 3
a112 3
.Xr vgone 9 
and 
.Xr vgonel 9 
d117 1
a117 1
.Xr VOP_RECLAIM 9 
d121 1
a121 1
.Ss Vnode locks 
d144 1
a144 1
have any notion of bundling a bunch of operations into an atomic unit)
d152 1
a152 1
sys/kern/vnode_if.src.
d154 3
a156 3
The vnode lock is acquired by calling 
.Xr vn_lock 9 
and released by calling 
d179 1
a179 1
The VXWANT flag is set by processes that wish to woken up when reclamation
d182 1
a182 1
The 
d184 2
a185 2
call is used for to wait for all outstanding write I/Os associated with a 
vnode to complete. 
d190 1
a190 1
This is used by code that wish to keep pointers to vnodes but doesn't want
d217 1
a217 1
This is used by the generic code to ensure for various checks.
d219 1
a219 1
.Xr read 2 
d222 1
a222 1
The v_data attribute allows a file system to attach piece of file
d243 1
a243 1
Any accesses to these fields should be protected by splbio.
@


1.15
log
@.Xr's for section9:

- MLINKS for uvm stuff
- MLINK vgone.9 vgonel.9
- typos
- fixed SYNOPSIS of extattr(9)

lots of help from miod and art
ok miod@@ art@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.14 2003/02/26 15:05:07 david Exp $
d214 1
a214 1
regular, fifo) this vnode is.
@


1.14
log
@start new sentence on a new line
ok mpech@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.13 2003/01/27 09:19:30 art Exp $
d115 1
a115 1
.Xr vop_reclaim 9 
d155 1
a155 1
.Xr vn_unlock 9 .
@


1.13
log
@Update. from csapuntz@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.12 2002/12/20 06:21:09 art Exp $
d34 2
a35 2
interface (open, read, write, close, readdir, etc.). Vnodes can
represent files, directories, FIFOs, domain sockets, block devices,
d50 11
a60 9
code can reuse an old vnode object that is no longer in use.  Whether
a vnode is in use is tracked by the vnode reference count
(v_usecount). By convention, each open file handle holds a reference
as do VM objects backed by files. A vnode with a reference count of 1
or more will not be de-allocated or re-used to point to a different
file. So, if you want to ensure that your vnode doesn't become a different
file under you, you better be sure you have a reference to it. A vnode
that points to a valid file and has a reference count of 1 or more is called
"active".
d63 3
a65 3
that is, a candidate for reuse. An "inactive" vnode still refers to a
valid file and one can try to reactivate it using vget (this is used a
lot by caches).
d68 2
a69 2
it must clean all information pertaining to the old file. A cleaned
out vnode is called a "reclaimed" vnode.
d74 4
a77 2
count. The "reclaimed" vnode is given to the dead file system, which
returns errors for most operations.  The reclaimed vnode will not be
d83 2
a84 2
"inactive" vnode, and returns it to the caller. The vnode returned has
a reference count (v_usecount) of 1.
d127 7
a133 6
thus preserving cached data. For example, it keeps the directory from
changing between a VOP_LOOKUP call and a VOP_CREATE. The VOP_LOOKUP
call makes sure the name doesn't already exist in the directory and
finds free room in the directory for the new entry. The VOP_CREATE can
then go ahead and create the file without checking if it already
exists or looking for free space.
d136 2
a137 2
is calling VOP_ vnode operations on a given file or directory. Otherwise,
the file system's behavior is undefined.
d140 3
a142 3
VOP_ operations occurs as an atomic unit. (Of course, this doesn't
work with network file systems like NFSv2 that don't have any notion
of bundling a bunch of operations into an atomic unit)
d147 4
a150 3
There is a discipline to using the vnode lock. Some VOP_ operations
require that the vnode lock is held before being called. A description
of this rather arcane locking discipline is in sys/kern/vnode_if.src.
d160 2
a161 1
file systems. Not all file systems implement it.
@


1.12
log
@Don't give people ideas. It's really hard to know when stuff won't
be accessed from interrupt context.
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.11 2002/12/20 06:19:39 art Exp $
d33 4
a36 3
A vnode is an object that speaks the UNIX file interface (open,
read, write, close, readdir, etc.). Vnodes can represent files, 
directories, FIFOs, domain sockets, block devices, character devices.
d48 27
a74 28
.Ss Vnode state
Vnodes have a reference count which corresponds to the number of kernel
objects that hold references to the vnode.
A positive reference count keeps
the vnode off of the free list, which prevents the vnode from being recycled
to refer to a different file.
.Pp
Vnodes that refer to a valid file and have a reference count of 1 or
greater are "active".
When a vnodes reference count drops to zero, it
is "inactivated" and becomes "inactive".
Inactive vnodes are placed on the
free list, to be re-used to represent other files.
.Pp
Before a struct vnode can be re-used to refer to another file, it must
be cleaned out of all information pertaining to the old file.
A vnode that doesn't refer to any file is called a "reclaimed" vnode.
.Pp
The VFS may "reclaim" a vnode with a positive reference count.
This is done when the underlying file is revoked, as happens with the
revoke system call or through a forceable unmount.
Such a vnode is given
to the dead file system, which returns errors for most operations.
The vnode will not be re-used for another file until its reference count
hits zero.
.Pp
There are three states then for a vnode: active, inactive, and reclaimed.
All transitions are meaningful except reclaimed to inactive.
d78 3
a80 3
system call returns a fresh active vnode from the vnode
pool assigned to the file system specified in its arguments.
The vnode returned has a reference count (v_usecount) of 1.
d110 1
a110 1
While transitioning a vnode to the "reclaimed" state, the VFS will call
d119 28
a146 2
The most general lock is the vnode lock.
This lock is acquired by calling 
d150 2
a151 17
The vnode lock is used to serialize operations through the file system for
a given file when there are multiple concurrent requests on the same file. 
Many file system functions require that the vnode lock is held on entry.
The vnode lock may be held when sleeping.
.Pp
A vnode will not be reclaimed as long as the vnode lock is held by some 
other process.
.Pp
The vnode lock is a multiple-reader or single-writer lock.
An exclusive vnode lock may be acquired multiple times by the same
process.
.Pp
The vnode lock is somewhat messy because it is used for many purposes.
Some clients of the vnode interface use it to try to bundle a series
of VOP_ method calls into an atomic group.
Many file systems rely on it to prevent race conditions in updating file
system specific data structures (as opposed to having their own locks). 
d154 1
a154 2
file systems.
Not all file system implement it.
d238 1
@


1.11
log
@More rewording.
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.10 2002/11/08 08:08:47 mpech Exp $
d224 1
a224 3
Any accesses to these fields should be protected by splbio,
unless you are certain that there is no chance an interrupt handler
will modify them.
@


1.10
log
@Time to cleanup:
o) start new sentence on a new line;
o) wrap long lines;
o) don't use .Pp before/after .Sh, .Ss;
o) OpenBSD -> .Ox;
o) typos;
o) close .Rs;
o) use space between arguments in tag, for example:
   .Xr blabla ) .

miod@@ ok
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.9 2002/08/26 20:18:07 art Exp $
d126 1
a126 1
Many file system functions require that you hold the vnode lock on entry.
d224 1
a224 1
Any accesses to these field should be protected by splbio,
@


1.9
log
@Add licenses to man pages written by Costa.
Licenses sent to me from him in mail, but he can't commit right now.
@
text
@d1 1
a1 1
.\"     $OpenBSD: vnode.9,v 1.8 2002/05/28 09:07:07 mpech Exp $
d39 2
a40 1
VOP_MKDIR. Many of these methods correspond closely to the equivalent
d49 2
a50 1
objects that hold references to the vnode. A positive reference count keeps
d112 2
a113 1
method. File systems use this method to free any file-system specific data
d143 2
a144 1
file systems. Not all file system implement it.
@


1.8
log
@	man9/:
o) Start new sentence on a new line;
o) FreeBSD -> .Fx;
o) OpenBSD -> .Ox;
o) Close .Bl/Bd lists;

millert@@ ok
@
text
@d1 25
a25 1
.\"     $OpenBSD: vnode.9,v 1.7 2002/02/28 19:22:05 csapuntz Exp $
@


1.7
log
@Check in some new vnode man page from FreeBSD. Thanks to Peter Werner
@
text
@d1 1
a1 1
.\"     $OpenBSD: $
d13 2
a14 2
Each vnode has a set of methods which start with string 'VOP_'. These
methods include VOP_OPEN, VOP_READ, VOP_WRITE, VOP_RENAME, VOP_CLOSE,
d16 2
a17 2
file system call--open, read, write, rename, etc. Each file system (FFS,
NFS, etc.) provides implementations for these methods.
d19 3
a21 3
The Virtual File System (VFS) library maintains a pool of vnodes. File systems
cannot allocate their own vnodes; they must use the functions provided
by the VFS to create and manage vnodes.
a22 1
.Pp
d29 4
a32 2
greater are "active". When a vnodes reference count drops to zero, it
is "inactivated" and becomes "inactive". Inactive vnodes are placed on the
d36 2
a37 2
be cleaned out of all information pertaining to the old file. A vnode that
doesn't refer to any file is called a "reclaimed" vnode.
d41 2
a42 1
revoke system call or through a forceable unmount. Such a vnode is given
d58 3
a60 2
call increments the reference count on the vnode. It may only be
on a vnode with reference count of 1 or greater. The
d72 4
a75 3
by bumping the reference count to one. When called on an active vnode,
vget increases the reference count by one. However, if the vnode
is being reclaimed concurrently, then vget will fail and return an error.
d81 2
a82 2
orchestrate the reclamation of a vnode. They can be called on both
active and inactive vnodes.
@


1.6
log
@Clarify description of the vnode life cycle and locks
@
text
@d1 1
@


1.5
log
@Powered by @@mantoya:
o) start new sentence on a new line;
o) minor mdoc fixes;
millert@@ ok

Tip of the day:   www.mpechismazohist.com
@
text
@d8 35
a42 2
The vnode is the kernel object that corresponds to a file (actually,
a file, a directory, a fifo, a domain socket, a symlink, or a device).
d44 2
a45 16
Each vnode has a set of methods corresponding to file operations
(vop_open, vop_read, vop_write, vop_rename, vop_mkdir, vop_close).
These methods are implemented by the individual file systems and
are dispatched through function pointers.
.Pp
In addition, the VFS has functions for maintaining a pool of vnodes,
associating vnodes with mount points, and associating vnodes with buffers.
The individual file systems cannot override these functions.
As such, individual file systems cannot allocate their own vnodes.
.Pp
In general, the contents of a struct vnode should not be examined or
modified by the users of vnode methods.
There are some rather common exceptions detailed later in this document.
.Pp
The vast majority of the vnode functions CANNOT be called from interrupt
context.
a46 1
All the vnodes in the kernel are allocated out of a shared pool.
d49 2
a50 2
system call returns a fresh vnode from the vnode
pool.
d55 2
a56 2
call increments the reference count on the vnode.
The
d65 6
a70 15
When a vnode's reference count becomes zero, the vnode pool places it
a pool of free vnodes, eligible to be assigned to a different file. 
The vnode pool calls the 
.Xr vop_inactive 9 
method to inform the file system that the reference count has reached zero.
.Pp
When placed in the pool of free vnodes, the vnode is not otherwise altered.
In fact, it can often be retrieved before it is reassigned to a different file.
This is useful when the system closes a file and opens it again in rapid
succession.
The 
.Xr vget 9 
call is used to revive the vnode.
Note, callers should ensure the vnode
they get back has not been reassigned to a different file.
a71 11
When the vnode pool decides to reclaim the vnode to satisfy a getnewvnode
request, it calls the 
.Xr vop_reclaim 9 
method.
File systems often use this method to free any file-system specific data they
attach to the vnode.
.Pp
A file system can force a vnode with a reference count of zero 
to be reclaimed earlier by calling the
.Xr vrecycle 9
call.
a72 4
.Xr vrecycle 9
call is a null operation if the reference count is greater than zero.
.Pp
The 
d76 7
a82 5
calls will force the pool to reclaim
the vnode even if it has a non-zero reference count.
If the vnode had a non-zero reference count, the vnode is then assigned
an operations vector corresponding to the "dead" file system.
In this operations vector, most operations return errors.
a83 10
Note to beginners: locks don't actually prevent memory from being read
or overwritten.
Instead, they are an object that, where used, allows only one piece of code
to proceed through the locked section.
If you do not surround a stretch of code with a lock, it can and probably
will eventually be executed simultaneously with other stretches of code
(including stretches ).
Chances are the results will be unexpected and disappointing to both the
user and you.
.Pp
d97 2
a98 7
The 
.Xr revoke 2 
and forcible unmount features in BSD UNIX allows a
user to invalidate files and their associated vnodes at almost any
time, even if there are active open files on it.
While in a region of code protected by the vnode lock, the process is
guaranteed that the vnode will not be reclaimed or invalidated.
d111 1
a111 2
file systems.
Not all file system implement it.
a114 2
.Pp
Interrupt handlers must not acquire vnode locks.
a193 9
.Pp
A vnode will only be reassigned to another file when its reference count
reaches zero and the vnode lock is freed.
.Pp
A vnode will not be reclaimed as long as the vnode lock is held.
If the vnode reference count drops to zero while a process is holding
the vnode lock, the vnode MAY be queued for reclamation.
Increasing the reference count from 0 to 1 while holding the lock will
most likely cause intermittent kernel panics.
@


1.4
log
@speling; jsyn@@nthought.com
@
text
@d18 2
a19 2
The individual file systems cannot override these functions. As such,
individual file systems cannot allocate their own vnodes.
d22 2
a23 2
modified by the users of vnode methods. There are some rather common
exceptions detailed later in this document.
d32 2
a33 1
pool. The vnode returned has a reference count (v_usecount) of 1.
d37 2
a38 1
call increments the reference count on the vnode. The
d56 2
a57 1
succession. The 
d59 2
a60 1
call is used to revive the vnode. Note, callers should ensure the vnode
d66 2
a67 2
method. File systems
often use this method to free any file-system specific data they
d73 2
a74 1
call. The
d83 4
a86 4
the vnode even if it has a non-zero reference count. If the vnode had
a non-zero reference count, the vnode is then assigned an operations
vector corresponding to the "dead" file system. In this operations
vector, most operations return errors.
d89 4
a92 3
or overwritten. Instead, they are an object that, where used, allows
only one piece of code to proceed through the locked section.  If you
do not surround a stretch of code with a lock, it can and probably
d94 3
a96 2
(including stretches ). Chances are the results will be unexpected and
disappointing to both the user and you.
d101 2
a102 2
The most general lock is the vnode lock. This lock is acquired by
calling 
d105 2
a106 2
.Xr vn_unlock 9 
. The vnode lock is used to serialize operations through the file system for
d115 3
a117 3
time, even if there are active open files on it. While in a region of code
protected by the vnode lock, the process is guaranteed that the vnode
will not be reclaimed or invalidated.
d119 2
a120 2
The vnode lock is a multiple-reader or single-writer lock. An
exclusive vnode lock may be acquired multiple times by the same
d125 3
a127 3
of VOP_ method calls into an atomic group. Many file systems rely on
it to prevent race conditions in updating file system specific data
structures (as opposed to having their own locks). 
d130 2
a131 1
file systems.  Not all file system implement it.
d138 5
a142 4
The vnode interlock (vp->v_interlock) is a spinlock. It is useful on
multi-processor systems for acquiring a quick exclusive lock on the
contents of the vnode. It MUST NOT be held while sleeping. (What
fields does it cover? What about splbio/interrupt issues?)
d147 4
a150 3
processes from entering the vnode reclamation code. It is also used as
a flag to indicate that reclamation is in progress. The VXWANT flag is
set by processes that wish to woken up when reclamation is finished.
d159 6
a164 5
is changed. This is used by code that wish to keep pointers to vnodes
but doesn't want to hold a reference (e.g. caches). The code keeps
both a vnode * and a copy of the capability. The code can later compare
the vnode's capability to its copy and see if the vnode still
points to the same file.
d172 2
a173 2
and only manipulated through the proper APIs. This section describes
the fields that are manipulated directly.
d181 3
a183 2
(e.g. function tables). There is no safe way of defining new v_tags
for loadable file systems. The v_tag attribute is read-only.
d186 3
a188 2
regular, fifo) this vnode is. This is used by the generic code to
ensure for various checks. For example, the 
d193 3
a195 2
system specific memory to the vnode. This contains information about
the file that is specific to the file system.
d198 5
a202 4
and asynchronous writes on the vnode. It does not track the number of
dirty buffers attached to the vnode.  The attribute is used by code
like fsync to wait for all writes to complete before returning to the
user. This attribute must be manipulated at splbio().
d208 6
a213 4
context. The exceptions are bgetvp and brelvp. The following
fields of the vnode are manipulated at interrupt level: v_numoutput,
v_holdcnt, v_dirtyblkhd, v_cleanblkhd, v_bioflag, v_freelist, and
v_synclist. Any accesses to these field should be protected by splbio,
d222 3
a224 5
the vnode lock, the vnode MAY be queued for reclamation. Increasing
the reference count from 0 to 1 while holding the lock will most likely
cause intermittent kernel panics.
.Sh SEE ALSO

d227 1
a227 4
.Ox 2.9
.


@


1.3
log
@

cleanup
@
text
@d106 1
a106 1
and forceable unmount features in BSD UNIX allows a
@


1.2
log
@

Better vnode man page
@
text
@a7 1

d10 1
a10 1

d15 1
a15 1

d20 1
a20 1

d24 1
a24 1

a26 1

a27 1

d33 1
a33 1

d44 1
a44 1

d50 1
a50 1

d58 1
a58 1

d65 1
a65 1

d72 1
a72 1

a81 1

a82 1

d90 1
a90 1

a92 1

a93 1

d103 1
a103 1

d111 1
a111 1

d115 1
a115 1

d121 1
a121 1

d124 1
a124 1

d127 1
a127 1

a128 1

a129 1

d134 1
a134 1

a135 1

a136 1

d141 1
a141 1

a145 1

a146 1

d154 1
a154 1

a158 2


a159 1

d163 1
a163 1

d166 1
a166 1

d172 1
a172 1

d178 1
a178 1

d182 1
a182 1

d188 1
a188 1

a190 1

a191 1

d199 1
a199 1

d202 1
a202 1

a207 1

a210 1

@


1.1
log
@Add a vnode man page
@
text
@a94 3
 
The vnode has a robust set of locks, reference counts, and even a
version number.
d96 4
a99 1
.Ss THE vnode lock
d144 2
d148 4
a151 4
The VXLOCK is used to prevent multiple processes from entering the
vnode reclamation code. It is also used as a flag to indicate
that reclamation is in progress. The VXWANT flag is set by
processes 
d155 2
a156 18
call be called to wait for all outstanding writes associated with a 
vnode to complete. The
.Xr vwakeup 9
call is used at interrupt level to wakeup the waiting processes.

.Ss Reference Counts

The kernel differentiates references to a vnode: references by buffers
(v_holdcnt) and vnode pool reference count (v_usecount).

The v_holdcnt is maintained transparently as buffers are added and
removed from vnodes using bgetvp and brelvp.  Code that uses the
buffer cache for allocating and managing buffers will never see this
reference count.

The v_usecount alone does not prevent a vnode from being
reclaimed. However, holding a reference to a vnode guarantees that the
vnode will not be assigned to a different file.
d199 10
a208 1
.Ss REVIEW
d211 1
a211 1
context. The exceptions are bgetvp, brelvp, and vwakeup. The following
d222 4
a225 1

@

