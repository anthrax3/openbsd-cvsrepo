head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@.\" @;


1.14
date	2016.11.21.07.11.13;	author dlg;	state Exp;
branches;
next	1.13;
commitid	SHoilFYH8iwiZ5UT;

1.13
date	2016.11.21.01.58.55;	author dlg;	state Exp;
branches;
next	1.12;
commitid	bbs71QdF8e9aqbvA;

1.12
date	2016.11.20.12.05.25;	author mpi;	state Exp;
branches;
next	1.11;
commitid	mLBbAi8k6YFbpxxI;

1.11
date	2016.11.20.11.40.58;	author mpi;	state Exp;
branches;
next	1.10;
commitid	3UWH2O8lhF8HTUbi;

1.10
date	2016.05.18.03.46.03;	author dlg;	state Exp;
branches;
next	1.9;
commitid	q5zkugIMulsP5tHa;

1.9
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.8;
commitid	wK6td35Fr7xdNzh3;

1.8
date	2015.11.26.13.08.18;	author jmc;	state Exp;
branches;
next	1.7;
commitid	qIzzdv4TKUpLAxno;

1.7
date	2015.11.26.12.17.19;	author mpi;	state Exp;
branches;
next	1.6;
commitid	DyrVkgzpNqiGgH3X;

1.6
date	2015.09.18.17.09.11;	author jmc;	state Exp;
branches;
next	1.5;
commitid	arFM5hsvrbI1m5pm;

1.5
date	2015.09.18.08.30.23;	author dlg;	state Exp;
branches;
next	1.4;
commitid	gVrgkfO910C8RmZI;

1.4
date	2015.09.13.08.58.07;	author dlg;	state Exp;
branches;
next	1.3;
commitid	4TOW7rrjoF9RZJrM;

1.3
date	2015.09.09.13.29.12;	author jmc;	state Exp;
branches;
next	1.2;
commitid	0I2M3uzQfrPbvamH;

1.2
date	2015.09.09.11.47.47;	author dlg;	state Exp;
branches;
next	1.1;
commitid	p94pmSEBIvkIv1Cs;

1.1
date	2015.09.09.11.21.51;	author dlg;	state Exp;
branches;
next	;
commitid	ro0JXFZlprcZI1rg;


desc
@@


1.14
log
@jmc@@ pointed out i forgot to fix the missing SRPL_LEAVE in the synopsis.

sprinkle some .Ft on the things that act like functions while here.
@
text
@.\"	$OpenBSD: srpl_rc_init.9,v 1.13 2016/11/21 01:58:55 dlg Exp $
.\"
.\" Copyright (c) 2015 David Gwynne <dlg@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: November 21 2016 $
.Dt SRPL_RC_INIT 9
.Os
.Sh NAME
.Nm srpl_rc_init ,
.Nm SRPL_HEAD ,
.Nm SRPL_ENTRY ,
.Nm SRPL_INIT ,
.Nm SRPL_FIRST ,
.Nm SRPL_NEXT ,
.Nm SRPL_FOLLOW ,
.Nm SRPL_FOREACH ,
.Nm SRPL_LEAVE ,
.Nm SRPL_RC_INITIALIZER
.Nd singly-linked shared reference pointer list
.Sh SYNOPSIS
.In sys/srp.h
.Vt struct srpl_rc;
.Ft void
.Fo "srpl_rc_init"
.Fa "struct srpl_rc *rc"
.Fa "void (*ref)(void *, void *)"
.Fa "void (*unref)(void *, void *)"
.Fa "void *ctx"
.Fc
.Fn SRPL_HEAD "HEADNAME" "TYPE"
.Fn SRPL_ENTRY "TYPE"
.Ft void
.Fn "SRPL_INIT" "SRPL_HEAD *sl"
.Ft void *
.Fn "SRPL_FIRST" "struct srp_ref *sr" "SRPL_HEAD *sl"
.Ft void *
.Fn "SRPL_NEXT" "struct srp_ref *sr" "struct TYPE *listelm" "FIELDNAME"
.Ft void *
.Fn "SRPL_FOLLOW" "struct srp_ref *sr" "struct TYPE *listelm" "FIELDNAME"
.Fo "SRPL_FOREACH"
.Fa "VARNAME"
.Fa "struct srp_ref *sr"
.Fa "SRPL_HEAD *sl"
.Fa "FIELDNAME"
.Fc
.Ft void
.Fn "SRPL_LEAVE" "struct srp_ref *sr"
.Fo "SRPL_RC_INITIALIZER"
.Fa "void (*ref)(void *, void *)"
.Fa "void (*unref)(void *, void *)"
.Fa "void *ctx"
.Fc
.Sh DESCRIPTION
The SRPL list
macros build a linked list on top of shared reference pointers.
This allows concurrent traversal of a linked list and access to the
items on the list.
.Pp
SRP lists are a generic type represented by a
.Vt SRPL_HEAD .
The elements inserted into the list must be structures that contain a
.Vt SRPL_ENTRY
field.
Further, the elements must also support reference counting as
insertion and removal operations can cause items to be temporarily
referenced by multiple SRPs within the list at the same time.
.Pp
.Fn srpl_rc_init
initialises the SRP list refcounts
.Fa rc
structure so it can be used to manage the reference counts on
elements in the list.
The insertion or removal of an element in an SRP list will increment
the reference counts on elements within the list via calls to
.Fa ref .
As these references are released by the SRP infrastructure, the
reference counts will be decremented by calls to
.Fa unref .
.Fa unref
is also responsible for freeing the element when the reference count
reaches 0.
Both
.Fa ref
and
.Fa unref
will be called with
.Fa ctx
as their first argument and a pointer to the element as their second
argument.
.Pp
.Fn SRPL_INIT
initialises the SRP list
.Fa sl
to an empty state.
.Pp
.Fn SRPL_FIRST
accesses the first element in the SRP list
.Fa sl
and holds its reference via
.Fa sr .
.Pp
.Fn SRPL_NEXT
accesses the element in the SRP list after
.Fa listelm
and holds its reference via
.Fa sr .
.\".Pp
.\"Every call to
.\".Fn SRPL_FIRST
.\"must have a corresponding call to
.\".Fn SRPL_LEAVE
.\"to release references to the list and its elements.
.Pp
.Fn SRPL_FOLLOW
accesses the element in the SRP list after
.Fa listelm
and swaps the previous reference held via
.Fa sr
for the reference of the newly accessed item.
.Pp
.Fn SRPL_FOREACH
creates a loop for traversing the list.
Every call to
.Fn SRPL_FOREACH
must have a corresponding call to
.Fn SRPL_LEAVE
to release references to the list and its elements.
.Pp
.Fn SRPL_LEAVE
releases references to the list and its elements held by previous
calls to
.Fn SRPL_FIRST ,
.Fn SRPL_NEXT ,
.Fn SRPL_FOLLOW ,
or
.Fn SRPL_FOREACH .
.Pp
An srpl_rc declaration can be initialised with the
.Fn SRPL_RC_INITIALIZER
macro.
.Sh CONTEXT
.Fn SRPL_INIT ,
.Fn SRPL_FIRST ,
.Fn SRPL_NEXT ,
.Fn SRPL_FOLLOW ,
.Fn SRPL_FOREACH ,
and
.Fn SRPL_LEAVE
may be called during autoconf, from process context, or from interrupt
context.
.Pp
.Fn srpl_rc_init ,
may be called during autoconf or from process context.
.Sh RETURN VALUES
.Fn SRPL_FIRST ,
.Fn SRPL_NEXT ,
and
.Fn SRPL_FOLLOW
return a pointer to elements in the SRP list, or
.Dv NULL
if there are no more elements.
.Sh SEE ALSO
.Xr SRPL_FIRST_LOCKED 9
.Sh HISTORY
The srp API was originally written by
.An Jonathan Matthew Aq Mt jmatthew@@openbsd.org
and
.An David Gwynne Aq Mt dlg@@openbsd.org .
The SRP list API first appeared in
.Ox 5.9 .
@


1.13
log
@tweak the pages based on feedback from jmc@@

they could do with some examples too.
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.12 2016/11/20 12:05:25 mpi Exp $
d17 1
a17 1
.Dd $Mdocdate: November 20 2016 $
d44 1
d58 2
@


1.12
log
@Move LOCKED macros to teir own manual.

This will allow us to better document them and add examples.

Disccussed with dlg@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.11 2016/11/20 11:40:58 mpi Exp $
d25 1
a25 1
.Nm SRPL_FIRST,
d126 1
a126 1
and swap the previous reference held via
d146 1
d171 2
@


1.11
log
@Rename SRPL_ENTER() to SRPL_FIRST() and SRPL_NEXT() to SRPL_FOLLOW().

This allows us to introduce SRPL_NEXT() that can be used to start
iterating on an arbitrary member of an srp list, hence without calling
SRPL_ENTER().

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.10 2016/05/18 03:46:03 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: May 18 2016 $
a29 8
.Nm SRPL_EMPTY_LOCKED ,
.Nm SRPL_FIRST_LOCKED ,
.Nm SRPL_NEXT_LOCKED ,
.Nm SRPL_FOREACH_LOCKED ,
.Nm SRPL_FOREACH_SAFE_LOCKED ,
.Nm SRPL_INSERT_HEAD_LOCKED ,
.Nm SRPL_INSERT_AFTER_LOCKED ,
.Nm SRPL_REMOVE_LOCKED ,
a56 27
.Fn "SRPL_LEAVE" "struct srp_ref *sr"
.Fn "SRPL_EMPTY_LOCKED" "SRPL_HEAD *sl"
.Ft void *
.Fn "SRPL_FIRST_LOCKED" "SRPL_HEAD *sl"
.Ft void *
.Fn "SRPL_NEXT_LOCKED" "struct TYPE *listelm" "FIELDNAME"
.Fn "SRPL_FOREACH_LOCKED" "VARNAME" "SRPL_HEAD *sl" "FIELDNAME"
.Fn "SRPL_FOREACH_SAFE_LOCKED" "VARNAME" "SRPL_HEAD *sl" "FIELDNAME" "TEMP_VARNAME"
.Fo "SRPL_INSERT_HEAD_LOCKED"
.Fa "struct srpl_rc *rc"
.Fa "SRPL_HEAD *sl"
.Fa "struct TYPE *elm"
.Fa "FIELDNAME"
.Fc
.Fo "SRPL_INSERT_AFTER_LOCKED"
.Fa "struct srpl_rc *rc"
.Fa "struct TYPE *listelm"
.Fa "struct TYPE *elm"
.Fa "FIELDNAME"
.Fc
.Fo "SRPL_REMOVE_LOCKED"
.Fa "struct srpl_rc *rc"
.Fa "SRPL_HEAD *sl"
.Fa "struct TYPE *listelm"
.Fa "TYPE"
.Fa "FIELDNAME"
.Fc
d63 1
a63 2
The
srpl
d141 1
a141 1
.Fn SRPL_FIRST,
a145 54
.Pp
.Fn SRPL_EMPTY_LOCKED
tests whether the SRP list
.Fa sl
is empty.
.Pp
.Fn SRPL_FIRST_LOCKED
accesses the first element in the SRP list
.Fa sl .
.Pp
.Fn SRPL_NEXT_LOCKED
accesses the next element in the SRP list after
.Fa listelm .
.Pp
.Fn SRPL_FOREACH_LOCKED
creates a loop for traversing the elements in the SRP list
.Fa sl .
.Pp
.Fn SRPL_FOREACH_SAFE_LOCKED
creates a loop for traversing the elements in the SRP list
.Fa sl ,
permitting it to remove
.Fa VARNAME
as well as freeing it from within the loop safely without interfering with the
traversal.
.Pp
.Fn SRPL_INSERT_HEAD_LOCKED
inserts
.Fa elm
into the SRP list
.Fa sl .
Reference counts are adjusted on the list items using the functions
specified by
.Fa rc .
.Pp
.Fn SRPL_INSERT_AFTER_LOCKED
inserts
.Fa elm
into an SRP list after the element
.Fa listelm .
Reference counts are adjusted on the list items using the functions
specified by
.Fa rc .
.Pp
.Fn SRPL_REMOVE_LOCKED
iterates over the SRP list
.Fa sl
until it finds
.Fa listelm
and then removes it.
Reference counts are adjusted on the list items using the functions
specified by
.Fa rc .
.Pp
d151 1
a151 1
.Fn SRPL_FIRST,
a160 8
.Fn SRPL_EMPTY_LOCKED ,
.Fn SRPL_FIRST_LOCKED ,
.Fn SRPL_NEXT_LOCKED ,
.Fn SRPL_FOREACH_LOCKED ,
.Fn SRPL_INSERT_HEAD_LOCKED ,
.Fn SRPL_INSERT_AFTER_LOCKED ,
and
.Fn SRPL_REMOVE_LOCKED
a161 2
An appropriate lock must be held that prevents concurrent modifications
to the list.
a164 2
.Fn SRPL_FOLLOW ,
.Fn SRPL_FIRST_LOCKED ,
d166 1
a166 1
.Fn SRPL_NEXT_LOCKED
a169 3
.Pp
.Fn SRPL_EMPTY_LOCKED
returns non-zero when the list is empty, otherwise 0.
@


1.10
log
@rework the srp api so it takes an srp_ref struct that the caller provides.

the srp_ref struct is used to track the location of the callers
hazard pointer so later calls to srp_follow and srp_enter already
know what to clear. this in turn means most of the caveats around
using srps go away. specifically, you can now:

- switch cpus while holding an srp ref
  - ie, you can sleep while holding an srp ref
- you can take and release srp refs in any order

the original intent was to simplify use of the api when dealing
with complicated data structures. the caller now no longer has to
track the location of the srp a value was fetched from, the srp_ref
effectively does that for you.

srp lists have been refactored to use srp_refs instead of srpl_iter
structs.

this is in preparation of using srps inside the ART code. ART is a
complicated data structure, and lookups require overlapping holds
of srp references.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.9 2015/12/03 16:27:32 mpi Exp $
d17 1
a17 1
.Dd $Mdocdate: December 3 2015 $
d25 1
a25 1
.Nm SRPL_ENTER ,
d27 1
d54 1
a54 1
.Fn "SRPL_ENTER" "struct srp_ref *sr" "SRPL_HEAD *sl"
d57 2
d141 4
a144 4
.Fn SRPL_ENTER
begins iterating over elements in the SRP list
.Fa sl .
The reference to the list item is held via
a145 5
Every call to
.Fn SRPL_ENTER
must have a corresponding call to
.Fn SRPL_LEAVE
to release references to the list and its elements.
d149 16
a164 1
.Fa listelm .
d177 1
a177 1
.Fn SRPL_ENTER ,
d179 1
d241 1
a241 1
.Fn SRPL_ENTER ,
d243 1
d263 1
a263 1
.Fn SRPL_ENTER ,
d265 1
@


1.9
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.8 2015/11/26 13:08:18 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: November 26 2015 $
a40 1
.Vt struct srpl_iter;
d53 1
a53 1
.Fn "SRPL_ENTER" "SRPL_HEAD *sl" "struct srpl_iter *si"
d55 1
a55 1
.Fn "SRPL_NEXT" "struct srpl_iter *si" "struct TYPE *listelm" "FIELDNAME"
d58 1
a59 1
.Fa "struct srpl_iter *si"
d62 1
a62 1
.Fn "SRPL_LEAVE" "struct srpl_iter *si" "struct TYPE *listelm"
d141 2
a142 3
Local state necessary for iterating over the list is stored in the
SRP list iterator structure
.Fa si .
d164 2
a165 1
.Fn SRPL_ENTER
@


1.8
log
@mlink for SRPL_FOREACH_SAFE_LOCKED and tweak its description;
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.7 2015/11/26 12:17:19 mpi Exp $
d22 2
a40 2
.Vt struct srpl;
.Vt struct srpl_entry;
d50 3
a52 1
.Fn "SRPL_INIT" "struct srpl_head *sl"
d54 1
a54 1
.Fn "SRPL_ENTER" "struct srpl *sl" "struct srpl_iter *si"
d59 1
a59 1
.Fa "struct srpl *sl"
d64 1
a64 1
.Fn "SRPL_EMPTY_LOCKED" "struct srpl *sl"
d66 1
a66 1
.Fn "SRPL_FIRST_LOCKED" "struct srpl *sl"
d69 2
a70 2
.Fn "SRPL_FOREACH_LOCKED" "VARNAME" "struct srpl *sl" "FIELDNAME"
.Fn "SRPL_FOREACH_SAFE_LOCKED" "VARNAME" "struct srpl *sl" "FIELDNAME" "TEMP_VARNAME"
d73 1
a73 1
.Fa "struct srpl *sl"
d85 1
a85 1
.Fa "struct srpl *sl"
d103 1
a103 1
.Vt struct srpl .
d105 1
a105 1
.Vt struct srpl_entry
@


1.7
log
@Add SRPL_FOREACH_SAFE_LOCKED(9), needed to turn the single list of
multipath route entries mpsafe.

ok dlg@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.6 2015/09/18 17:09:11 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: September 18 2015 $
d187 2
a188 2
.Fa sl
permitting to remove
@


1.6
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.5 2015/09/18 08:30:23 dlg Exp $
d31 1
d68 1
d184 8
@


1.5
log
@implement SRPL_INSERT_AFTER_LOCKED.

i thought id committed this at l2k15. sorry for the delay.
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.4 2015/09/13 08:58:07 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: September 13 2015 $
d195 1
a195 1
into a SRP list after the element
@


1.4
log
@forgot to prototope SRPL_RC_INITIALIZER
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.3 2015/09/09 13:29:12 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: September 9 2015 $
d32 1
d73 6
d191 10
d230 1
@


1.3
log
@no comma after last entry in NAME;
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.2 2015/09/09 11:47:47 dlg Exp $
d78 5
@


1.2
log
@millert@@ noticed an extra period.
@
text
@d1 1
a1 1
.\"	$OpenBSD: srpl_rc_init.9,v 1.1 2015/09/09 11:21:51 dlg Exp $
d33 1
a33 1
.Nm SRPL_RC_INITIALIZER ,
@


1.1
log
@implement a singly linked list built with SRPs.

this allows us to build lists of things that can be followed by
multiple cpus.

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
a102 1
.
@

