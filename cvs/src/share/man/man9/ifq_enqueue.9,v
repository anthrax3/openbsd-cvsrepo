head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@.\" @;


1.9
date	2015.12.10.06.58.56;	author jmc;	state Exp;
branches;
next	1.8;
commitid	OmZ5FWqeWhbo5Zdq;

1.8
date	2015.12.10.00.42.51;	author dlg;	state Exp;
branches;
next	1.7;
commitid	bWMPw7s8rraBG5Y3;

1.7
date	2015.12.10.00.41.46;	author dlg;	state Exp;
branches;
next	1.6;
commitid	CQ9iOTB6BPn4bdPp;

1.6
date	2015.12.09.07.28.17;	author jmc;	state Exp;
branches;
next	1.5;
commitid	t6jQLrnLrAdrLzjh;

1.5
date	2015.12.09.06.29.02;	author dlg;	state Exp;
branches;
next	1.4;
commitid	7ODY37VLiIHq9TRR;

1.4
date	2015.11.25.03.09.57;	author dlg;	state Exp;
branches;
next	1.3;
commitid	B0kwmVGiD5DVx4kv;

1.3
date	2015.11.23.11.07.58;	author jmc;	state Exp;
branches;
next	1.2;
commitid	k3eJG00F3T4FcSW4;

1.2
date	2015.11.23.10.45.26;	author mpi;	state Exp;
branches;
next	1.1;
commitid	cR58Mw0vQFfXz7V5;

1.1
date	2015.11.20.11.15.07;	author dlg;	state Exp;
branches;
next	;
commitid	DSo9cWHeceL3peeU;


desc
@@


1.9
log
@tweak;
@
text
@.\"     $OpenBSD: ifq_enqueue.9,v 1.8 2015/12/10 00:42:51 dlg Exp $
.\"
.\"  Copyright (c) 2015 David Gwynne <dlg@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: December 10 2015 $
.Dt IFQ_ENQUEUE 9
.Os
.Sh NAME
.Nm ifq_enqueue ,
.Nm ifq_dequeue ,
.Nm ifq_purge ,
.Nm ifq_len ,
.Nm ifq_empty ,
.Nm ifq_set_oactive ,
.Nm ifq_clr_oactive ,
.Nm ifq_is_oactive ,
.Nm ifq_restart ,
.Nm ifq_barrier
.Nd interface send queue API
.Sh SYNOPSIS
.In net/if_var.h
.Ft int
.Fn ifq_enqueue "struct ifqueue *ifq" "struct mbuf *m"
.Ft struft mbuf *
.Fn ifq_dequeue "struct ifqueue *ifq"
.Ft unsigned int
.Fn ifq_purge "struct ifqueue *ifq"
.Ft unsigned int
.Fn ifq_len "struct ifqueue *ifq"
.Ft unsigned int
.Fn ifq_empty "struct ifqueue *ifq"
.Ft void
.Fn ifq_set_oactive "struct ifqueue *ifq"
.Ft void
.Fn ifq_clr_oactive "struct ifqueue *ifq"
.Ft unsigned int
.Fn ifq_is_oactive "struct ifqueue *ifq"
.Ft void
.Fn ifq_restart "struct ifqueue *ifq"
.Ft void
.Fn ifq_barrier "struct ifqueue *ifq"
.Sh DESCRIPTION
The ifqueue API provides implementions of data structures and
operations for the network stack to queue mbufs for a network driver
to dequeue from its start routine for transmission.
.Bl -tag -width Ds
.It Fn ifq_enqueue "struct ifqueue *ifq" "struct mbuf *m"
Enqueue mbuf
.Fa m
on the
.Fa ifq
interface send queue.
If the queue rejects the packet it will be freed with
.Xr m_freem 9
and counted as a drop.
.It Fn ifq_dequeue "struct ifqueue *ifq"
Dequeue the next mbuf to be transmitted from the
.Fa ifq
interface send queue.
.It Fn ifq_purge "struct ifqueue *ifq"
Free all the mbufs on the interface send queue
.Fa ifq .
Freed mbufs will be accounted as drops.
.It Fn ifq_len "struct ifqueue *ifq"
Return the number of mbufs on the interface send queue
.Fa ifq .
Note that while
.Fn ifq_len
may report that mbufs are on the queue, the current queue
discipline may not make them available for dequeueing with
.Fn ifq_dequeue
or
.Fn ifq_deq_begin .
.It Fn ifq_empty "struct ifqueue *ifq"
Return if the interface send queue
.Fa ifq
is empty.
.It Fn ifq_set_oactive "struct ifqueue *ifq"
.Fn ifq_set_oactive
is called by the relevant driver to mark the hardware associated
with the interface send queue
.Fa ifq
as unable to transmit more packets.
.It Fn ifq_clr_oactive "struct ifqueue *ifq"
.Fn ifq_clr_oactive
is called by the relevant driver to clear the "active" mark on the
hardware associated with the interface send queue
.Fa ifq ,
meaning it is now able to transmit packets.
.It Fn ifq_is_oactive "struct ifqueue *ifq"
Return if the hardware associated with the interface send queue
.Fa ifq
is unable to transmit more packets.
.It Fn ifq_restart "struct ifqueue *ifq"
Dispatch a call to
.Fn ifq_clr_oactive
and the interface's start routine.
This call is serialised with other calls to the start routine via
.Fn if_start
and therefore provides race free modification of the "active" mark.
.It Fn ifq_barrier "struct ifqueue *ifq"
.Fn ifq_barrier
guarantees that any work currently running in the interface queue
serialiser (e.g. work dispatched by
.Fn ifq_restart
or the interface's start routine) has finished before
.Fn ifq_barrier
returns.
.El
.Sh CONTEXT
.Fn ifq_enqueue ,
.Fn ifq_dequeue ,
.Fn ifq_purge ,
.Fn ifq_len ,
.Fn ifq_empty ,
.Fn ifq_set_oactive ,
.Fn ifq_clr_oactive ,
.Fn ifq_is_oactive ,
and
.Fn ifq_restart
can be called during autoconf, from process context, or from interrupt context.
.Pp
.Fn ifq_barrier
can be called from process context.
.Sh RETURN VALUES
.Fn ifq_enqueue
returns 0 if the mbuf was successfully queued, or non-zero if mbuf was freed.
.Pp
.Fn ifq_dequeue
returns the next mbuf to be transmitted by the interface.
If no packet is available for transmission,
.Dv NULL
is returned.
.Pp
.Fn ifq_purge
returns the number of mbufs that were removed from the queue and freed.
.Pp
.Fn ifq_len
returns the number of mbufs on the queue.
.Pp
.Fn ifq_empty
returns a non-zero value if the queue is empty, otherwise 0.
.Pp
.Fn ifq_is_oactive
returns a non-zero value if the hardware associated with the interface
send queue is unable to transmit more packets, otherwise 0.
.Sh SEE ALSO
.Xr ifq_deq_begin 9 ,
.Xr m_freem 9
@


1.8
log
@ifq_restart can be called from autoconf, process context, and interrupts.
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.7 2015/12/10 00:41:46 dlg Exp $
d115 2
a116 2
guarantees that any work currently running in the interface queues
serialiser (eg, work dispatched by
d118 1
a118 1
or the interfaces start routine) has finished before
@


1.7
log
@document ifq_barrier()
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.6 2015/12/09 07:28:17 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: December 9 2015 $
d130 1
d132 1
a132 1
.Fn ifq_is_oactive
@


1.6
log
@missing apostrophe;
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.5 2015/12/09 06:29:02 dlg Exp $
d29 2
a30 1
.Nm ifq_restart
d52 2
d113 8
d133 3
@


1.5
log
@document ifq_restart. or try to.
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.4 2015/11/25 03:09:57 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: November 25 2015 $
d106 1
a106 1
and the interfaces start routine.
@


1.4
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.3 2015/11/23 11:07:58 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: November 23 2015 $
d28 2
a29 1
.Nm ifq_is_oactive
d49 2
d103 7
@


1.3
log
@tweaks;
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.2 2015/11/23 10:45:26 mpi Exp $
d25 4
a28 1
.Nm ifq_empty
d42 6
d84 16
d106 3
d110 1
a110 1
.Fn ifq_empty
d130 4
@


1.2
log
@Move ifq_deq_{begin,commit,rollback} appart to keep man pages short,
readable and to emphasis that they are not the prefered API for your
drivers.

ok dlg@@
@
text
@d1 1
a1 1
.\"     $OpenBSD: ifq_enqueue.9,v 1.1 2015/11/20 11:15:07 dlg Exp $
d17 1
a17 1
.Dd $Mdocdate: November 20 2015 $
d89 1
a89 1
return the next mbuf to be transmitted by the interface.
@


1.1
log
@i made a mistake. rename ifq_enq and ifq_deq to ifq_enqueue and ifq_dequeue

fixing it now before i regret it more.
@
text
@d1 1
a1 1
.\"     $OpenBSD$
a22 3
.Nm ifq_deq_begin ,
.Nm ifq_deq_commit ,
.Nm ifq_deq_rollback ,
a32 6
.Ft struft mbuf *
.Fn ifq_deq_begin "struct ifqueue *ifq"
.Ft void
.Fn ifq_deq_commit "struct ifqueue *ifq" "struct mbuf *m"
.Ft void
.Fn ifq_deq_rollback "struct ifqueue *ifq" "struct mbuf *m"
a56 23
.It Fn ifq_deq_begin "struct ifqueue *ifq"
Get a reference to the next mbuf to be transmitted from the
.Fa ifq
interface send queue.
If an mbuf is to be transmitted, also acquire a lock on the send queue
to exclude modification or freeing of the referenced mbuf.
The mbuf must not be freed, or have its length (m_pkthdr.len) or
cookie (m_pkthdr.ph_cookie) modified until it has been dequeued
completely with
.Fn ifq_deq_commit .
.It Fn ifq_deq_commit "struct ifqueue *ifq" "struct mbuf *m"
Dequeue the mbuf
.Fa m
that was referenced by a previous call to
.Fn ifq_deq_begin
and release the lock on
.Fa ifq .
.It Fn ifq_deq_rollback "struct ifqueue *ifq" "struct mbuf *m"
Release the lock on the interface send queue
.Fa ifq
that was acquired while a reference to
.Fa m
was being held.
a78 3
.Fn ifq_deq_begin ,
.Fn ifq_deq_commit ,
.Fn ifq_deq_rollback ,
a88 2
and
.Fn ifq_deq_begin
d103 1
@

