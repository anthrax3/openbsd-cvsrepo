head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.22
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.20
	OPENBSD_5_0:1.14.0.18
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.16
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.14
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@.\" @;


1.17
date	2014.04.19.11.38.13;	author henning;	state dead;
branches;
next	1.16;

1.16
date	2013.06.04.19.27.03;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.15.13.26.26;	author gsoares;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.01.14.46.52;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.14.11.45.05;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.24.12.04.09;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.14.18.11.32;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.02.15.05.23;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.25.13.18.08;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.09.52.58;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.13.05.00.14;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.12.13.09.27;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.12.12.41.42;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.12.12.38.29;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.12.12.33.28;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.12.12.15.02;	author kjc;	state Exp;
branches;
next	;


desc
@@


1.17
log
@bye bye
@
text
@.\"	$OpenBSD: altq.9,v 1.16 2013/06/04 19:27:03 schwarze Exp $
.\"
.\" Copyright (C) 2001
.\" Sony Computer Science Laboratories Inc.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd $Mdocdate: June 4 2013 $
.Dt ALTQ 9
.Os
.\"
.Sh NAME
.Nm altq
.Nd kernel interfaces for manipulating output queues on network interfaces
.Sh SYNOPSIS
.In sys/types.h
.In sys/socket.h
.In net/if.h
.Ft void \"macro
.Fn IFQ_ENQUEUE "struct ifaltq *ifq" "struct mbuf *m" "struct altq_pktattr *pa" "int err"
.Ft void \"macro
.Fn IFQ_DEQUEUE "struct ifaltq *ifq" "struct mbuf *m"
.Ft void \"macro
.Fn IFQ_POLL "struct ifaltq *ifq" "struct mbuf *m"
.Ft void \"macro
.Fn IFQ_PURGE "struct ifaltq *ifq"
.Ft void \"macro
.Fn IFQ_CLASSIFY "struct ifaltq *ifq" "struct mbuf *m" "int af" "struct altq_pktattr *pktattr"
.Ft void \"macro
.Fn IFQ_IS_EMPTY "struct ifaltq *ifq"
.Ft void \"macro
.Fn IFQ_SET_MAXLEN "struct ifaltq *ifq" "int len"
.Ft void \"macro
.Fn IFQ_INC_LEN "struct ifaltq *ifq"
.Ft void \"macro
.Fn IFQ_DEC_LEN "struct ifaltq *ifq"
.Ft void \"macro
.Fn IFQ_INC_DROPS "struct ifaltq *ifq"
.Ft void \"macro
.Fn IFQ_SET_READY "struct ifaltq *ifq"
.Sh DESCRIPTION
The
.Nm
system is a framework to manage queuing disciplines on network
interfaces.
.Nm
introduces new macros to manipulate output queues.
The output queue macros are used to abstract queue operations and not to
touch the internal fields of the output queue structure.
The macros are independent from the
.Nm
implementation, and compatible with the traditional
.Dv ifqueue
macros for ease of transition.
.Pp
.Fn IFQ_ENQUEUE
enqueues a packet
.Fa m
to the queue
.Fa ifq .
The underlying queuing discipline may discard the packet.
.Fa err
is set to 0 on success, or
.Dv ENOBUFS
if the packet is discarded.
.Fa m
will be freed by the device driver on success or by the queuing discipline on
failure, so the caller should not touch
.Fa m
after calling
.Fn IFQ_ENQUEUE .
.Pp
.Fn IFQ_DEQUEUE
dequeues a packet from the queue.
The dequeued packet is returned in
.Fa m ,
or
.Fa m
is set to
.Dv NULL
if no packet is dequeued.
The caller must always check
.Fa m
since a non-empty queue could return
.Dv NULL
under rate-limiting.
.Pp
.Fn IFQ_POLL
returns the next packet without removing it from the queue.
It is guaranteed by the underlying queuing discipline that
.Fn IFQ_DEQUEUE
immediately after
.Fn IFQ_POLL
returns the same packet.
.Pp
.Fn IFQ_PURGE
discards all the packets in the queue.
The purge operation is needed since a non-work conserving queue cannot be
emptied by a dequeue loop.
.Pp
.Fn IFQ_CLASSIFY
classifies a packet to a scheduling class, and returns the result in
.Fa pktattr .
.Pp
.Fn IFQ_IS_EMPTY
can be used to check if the queue is empty.
Note that
.Fn IFQ_DEQUEUE
could still return
.Dv NULL
if the queuing discipline is non-work conserving.
.Pp
.Fn IFQ_SET_MAXLEN
sets the queue length limit to the default FIFO queue.
.Pp
.Fn IFQ_INC_LEN
and
.Fn IFQ_DEC_LEN
increment or decrement the current queue length in packets.
.Pp
.Fn IFQ_INC_DROPS
increments the drop counter and is equal to
.Fn IF_DROP .
It is defined for naming consistency.
.Pp
.Fn IFQ_SET_READY
sets a flag to indicate this driver is converted to use the new macros.
.Nm
can be enabled only on interfaces with this flag.
.Sh COMPATIBILITY
.Ss ifaltq structure
In order to keep compatibility with the existing code, the new
output queue structure
.Dv ifaltq
has the same fields.
The traditional
.Fn IF_XXX
macros and the code directly referencing the fields within
.Dv if_snd
still work with
.Dv ifaltq .
(Once we finish conversions of all the drivers, we no longer need
these fields.)
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 struct ifqueue {                      | struct ifaltq {
    struct mbuf *ifq_head;             |    struct mbuf *ifq_head;
    struct mbuf *ifq_tail;             |    struct mbuf *ifq_tail;
    int          ifq_len;              |    int          ifq_len;
    int          ifq_maxlen;           |    int          ifq_maxlen;
    int          ifq_drops;            |    int          ifq_drops;
 };                                    |    /* altq related fields */
                                       |    ......
                                       | };
                                       |
.Ed
The new structure replaces
.Dv struct ifqueue
in
.Dv struct ifnet .
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 struct ifnet {                        | struct ifnet {
     ....                              |     ....
                                       |
     struct ifqueue if_snd;            |     struct ifaltq if_snd;
                                       |
     ....                              |     ....
 };                                    | };
                                       |
.Ed
The (simplified) new
.Fn IFQ_XXX
macros looks like:
.Bd -literal
	#ifdef ALTQ
	#define IFQ_DEQUEUE(ifq, m)			\e
		if (ALTQ_IS_ENABLED((ifq))		\e
			ALTQ_DEQUEUE((ifq), (m));	\e
		else					\e
			IF_DEQUEUE((ifq), (m));
	#else
	#define IFQ_DEQUEUE(ifq, m)	IF_DEQUEUE((ifq), (m));
	#endif
.Ed
.Ss Enqueue operation
The semantics of the enqueue operation are changed.
In the new style,
enqueue and packet drop are combined since they cannot be easily
separated in many queuing disciplines.
The new enqueue operation corresponds to the following macro that is
written with the old macros.
.Bd -literal
#define	IFQ_ENQUEUE(ifq, m, pattr, err)                   \e
do {                                                      \e
        if (ALTQ_IS_ENABLED((ifq)))                       \e
                ALTQ_ENQUEUE((ifq), (m), (pattr), (err)); \e
        else {                                            \e
                if (IF_QFULL((ifq))) {                    \e
                        m_freem((m));                     \e
                        (err) = ENOBUFS;                  \e
                 } else {                                 \e
                        IF_ENQUEUE((ifq), (m));           \e
                        (err) = 0;                        \e
                 }                                        \e
         }                                                \e
	 if ((err))                                       \e
	        (ifq)->ifq_drops++;                       \e
} while (0)
.Ed
.Pp
.Fn IFQ_ENQUEUE
does the following:
.Bl -hyphen -compact
.It
queue a packet
.It
drop (and free) a packet if the enqueue operation fails
.El
If the enqueue operation fails,
.Fa err
is set to
.Dv ENOBUFS .
.Fa m
is freed by the queuing discipline.
The caller should not touch
.Fa m
after calling
.Fn IFQ_ENQUEUE ,
so the caller may need to copy the
.Fa m_pkthdr.len
or
.Fa m_flags
fields beforehand for statistics.
The caller should not use
.Fn senderr
since
.Fa m
was already freed.
.Pp
The new style
.Fn if_output
looks as follows:
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 int                                   | int
 ether_output(ifp, m0, dst, rt0)       | ether_output(ifp, m0, dst, rt0)
 {                                     | {
     ......                            |     ......
                                       |
                                       |     mflags = m->m_flags;
                                       |     len = m->m_pkthdr.len;
     s = splnet();                     |     s = splnet();
     if (IF_QFULL(&ifp->if_snd)) {     |     IFQ_ENQUEUE(&ifp->if_snd, m,
                                       |         NULL, error);
         IF_DROP(&ifp->if_snd);        |     if (error != 0) {
         splx(s);                      |         splx(s);
         senderr(ENOBUFS);             |         return (error);
     }                                 |     }
     IF_ENQUEUE(&ifp->if_snd, m);      |
     ifp->if_obytes +=                 |     ifp->if_obytes += len;
                    m->m_pkthdr.len;   |
     if (m->m_flags & M_MCAST)         |     if (mflags & M_MCAST)
         ifp->if_omcasts++;            |         ifp->if_omcasts++;
                                       |
     if ((ifp->if_flags & IFF_OACTIVE) |     if ((ifp->if_flags & IFF_OACTIVE)
         == 0)                         |         == 0)
         (*ifp->if_start)(ifp);        |         (*ifp->if_start)(ifp);
     splx(s);                          |     splx(s);
     return (error);                   |     return (error);
                                       |
 bad:                                  | bad:
     if (m)                            |     if (m)
         m_freem(m);                   |         m_freem(m);
     return (error);                   |     return (error);
 }                                     | }
                                       |
.Ed
.Ss Classifier
The classifier mechanism is currently implemented in
.Fn if_output .
.Dv struct altq_pktattr
is used to store the classifier result, and it is passed to the enqueue
function.
(We will change the method to tag the classifier result to mbuf in the future.)
.Bd -literal
int
ether_output(ifp, m0, dst, rt0)
{
	......
	struct altq_pktattr pktattr;

	......

	/* classify the packet before prepending link-headers */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

	/* prepend link-level headers */
	......

	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);

	......
}
.Ed
.Sh HOW TO CONVERT THE EXISTING DRIVERS
First, make sure the corresponding
.Fn if_output
is already converted to the new style.
.Pp
Look for
.Fa if_snd
in the driver.
You will probably need to make changes to the lines that include
.Fa if_snd .
.Ss Empty check operation
If the code checks
.Fa ifq_head
to see whether the queue is empty or not, use
.Fn IFQ_IS_EMPTY .
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 if (ifp->if_snd.ifq_head != NULL)     | if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
                                       |
.Ed
Note that
.Fn IFQ_POLL
can be used for the same purpose, but
.Fn IFQ_POLL
could be costly for a complex scheduling algorithm since
.Fn IFQ_POLL
needs to run the scheduling algorithm to select the next packet.
On the other hand,
.Fn IFQ_IS_EMPTY
checks only if there is any packet stored in the queue.
Another difference is that even when
.Fn IFQ_IS_EMPTY
is
.Dv FALSE ,
.Fn IFQ_DEQUEUE
could still return
.Dv NULL
if the queue is under rate-limiting.
.Ss Dequeue operation
Replace
.Fn IF_DEQUEUE
by
.Fn IFQ_DEQUEUE .
Always check whether the dequeued mbuf is
.Dv NULL
or not.
Note that even when
.Fn IFQ_IS_EMPTY
is
.Dv FALSE ,
.Fn IFQ_DEQUEUE
could return
.Dv NULL
due to rate-limiting.
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 IF_DEQUEUE(&ifp->if_snd, m);          | IFQ_DEQUEUE(&ifp->if_snd, m);
                                       | if (m == NULL)
                                       |     return;
                                       |
.Ed
A driver is supposed to call
.Fn if_start
from transmission complete interrupts in order to trigger the next dequeue.
.Ss Poll-and-dequeue operation
If the code polls the packet at the head of the queue and actually uses
the packet before dequeuing it, use
.Fn IFQ_POLL
and
.Fn IFQ_DEQUEUE .
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 m = ifp->if_snd.ifq_head;             | IFQ_POLL(&ifp->if_snd, m);
 if (m != NULL) {                      | if (m != NULL) {
                                       |
     /* use m to get resources */      |     /* use m to get resources */
     if (something goes wrong)         |     if (something goes wrong)
         return;                       |         return;
                                       |
     IF_DEQUEUE(&ifp->if_snd, m);      |     IFQ_DEQUEUE(&ifp->if_snd, m);
                                       |
     /* kick the hardware */           |     /* kick the hardware */
 }                                     | }
                                       |
.Ed
It is guaranteed that
.Fn IFQ_DEQUEUE
immediately after
.Fn IFQ_POLL
returns the same packet.
Note that they need to be guarded by
.Xr splnet 9
if called from outside of
.Fn if_start .
.Ss Eliminating IF_PREPEND
If the code uses
.Fn IF_PREPEND ,
you have to eliminate it since the prepend operation is not possible for many
queuing disciplines.
A common use of
.Fn IF_PREPEND
is to cancel the previous dequeue operation.
You have to convert the logic into poll-and-dequeue.
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 IF_DEQUEUE(&ifp->if_snd, m);          | IFQ_POLL(&ifp->if_snd, m);
 if (m != NULL) {                      | if (m != NULL) {
                                       |
     if (something_goes_wrong) {       |     if (something_goes_wrong) {
         IF_PREPEND(&ifp->if_snd, m);  |
         return;                       |         return;
     }                                 |     }
                                       |
                                       |     /* at this point, the driver
                                       |      * is committed to send this
                                       |      * packet.
                                       |      */
                                       |     IFQ_DEQUEUE(&ifp->if_snd, m);
                                       |
     /* kick the hardware */           |     /* kick the hardware */
 }                                     | }
                                       |
.Ed
.Ss Purge operation
Use
.Fn IFQ_PURGE
to empty the queue.
Note that a non-work conserving queue cannot be emptied by a dequeue loop.
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 while (ifp->if_snd.ifq_head != NULL) {|  IFQ_PURGE(&ifp->if_snd);
     IF_DEQUEUE(&ifp->if_snd, m);      |
     m_freem(m);                       |
 }                                     |
                                       |
.Ed
.Ss Attach routine
Use
.Fn IFQ_SET_MAXLEN
to set
.Fa ifq_maxlen
to
.Fa len .
Add
.Fn IFQ_SET_READY
to show this driver is converted to the new style.
(This is used to distinguish new-style drivers.)
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 ifp->if_snd.ifq_maxlen = qsize;       | IFQ_SET_MAXLEN(&ifp->if_snd, qsize);
                                       | IFQ_SET_READY(&ifp->if_snd);
 if_attach(ifp);                       | if_attach(ifp);
                                       |
.Ed
.Ss Other issues
The new macros for statistics:
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 IF_DROP(&ifp->if_snd);                | IFQ_INC_DROPS(&ifp->if_snd);
                                       |
 ifp->if_snd.ifq_len++;                | IFQ_INC_LEN(&ifp->if_snd);
                                       |
 ifp->if_snd.ifq_len--;                | IFQ_DEC_LEN(&ifp->if_snd);
                                       |
.Ed
Some drivers instruct the hardware to invoke transmission complete
interrupts only when it thinks necessary.
Rate-limiting breaks its assumption.
.Ss How to convert drivers using multiple ifqueues
Some (pseudo) devices (such as slip) have another
.Dv ifqueue
to prioritize packets.
It is possible to eliminate the second queue
since
.Nm
provides more flexible mechanisms but the following shows
how to keep the original behavior.
.Bd -literal
struct sl_softc {
	struct	ifnet sc_if;		/* network-visible interface */
	...
	struct	ifqueue sc_fastq;	/* interactive output queue */
	...
};
.Ed
The driver doesn't compile in the new model since it has the following
line
.Po
.Fa if_snd
is no longer a type of
.Dv struct ifqueue
.Pc .
.Bd -literal
	struct ifqueue *ifq = &ifp->if_snd;
.Ed
A simple way is to use the original
.Fn IF_XXX
macros for
.Fa sc_fastq
and use the new
.Fn IFQ_XXX
macros for
.Fa if_snd .
The enqueue operation looks like:
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 struct ifqueue *ifq = &ifp->if_snd;   | struct ifqueue *ifq = NULL;
                                       |
 if (ip->ip_tos & IPTOS_LOWDELAY)      | if ((ip->ip_tos & IPTOS_LOWDELAY) &&
     ifq = &sc->sc_fastq;              | !ALTQ_IS_ENABLED(&sc->sc_if.if_snd)) {
                                       |     ifq = &sc->sc_fastq;
 if (IF_QFULL(ifq)) {                  |     if (IF_QFULL(ifq)) {
     IF_DROP(ifq);                     |         IF_DROP(ifq);
     m_freem(m);                       |         m_freem(m);
     splx(s);                          |         error = ENOBUFS;
     sc->sc_if.if_oerrors++;           |     } else {
     return (ENOBUFS);                 |         IF_ENQUEUE(ifq, m);
 }                                     |         error = 0;
 IF_ENQUEUE(ifq, m);                   |     }
                                       | } else
                                       |     IFQ_ENQUEUE(&sc->sc_if.if_snd,
                                       |         NULL, m, error);
                                       |
                                       | if (error) {
                                       |     splx(s);
                                       |     sc->sc_if.if_oerrors++;
                                       |     return (error);
                                       | }
 if ((sc->sc_oqlen =                   | if ((sc->sc_oqlen =
      sc->sc_ttyp->t_outq.c_cc) == 0)  |      sc->sc_ttyp->t_outq.c_cc) == 0)
     slstart(sc->sc_ttyp);             |     slstart(sc->sc_ttyp);
 splx(s);                              | splx(s);
                                       |
.Ed
The dequeue operations looks like:
.Bd -literal
            ##old-style##                           ##new-style##
                                       |
 s = splnet();                         | s = splnet();
 IF_DEQUEUE(&sc->sc_fastq, m);         | IF_DEQUEUE(&sc->sc_fastq, m);
 if (m == NULL)                        | if (m == NULL)
     IF_DEQUEUE(&sc->sc_if.if_snd, m); |     IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
 splx(s);                              | splx(s);
                                       |
.Ed
.Sh QUEUEING DISCIPLINES
Queuing disciplines need to maintain
.Fa ifq_len
.Po
used by
.Fn IFQ_IS_EMPTY
.Pc .
Queuing disciplines also need to guarantee the same mbuf is returned if
.Fn IFQ_DEQUEUE
is called immediately after
.Fn IFQ_POLL .
.Sh SEE ALSO
.Xr pf.conf 5 ,
.Xr pfctl 8
.Sh HISTORY
The
.Nm
system first appeared in March 1997.
@


1.16
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.15 2012/11/15 13:26:26 gsoares Exp $
d27 1
a27 1
.Dd $Mdocdate: November 15 2012 $
@


1.15
log
@splimp -> splnet; OK jmc@@ claudio@@ miod@@

while here switch to .Xr splnet 9; pointed out by jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.14 2007/05/31 19:20:00 jmc Exp $
d27 1
a27 1
.Dd $Mdocdate: May 31 2007 $
d35 3
a37 3
.Fd #include <sys/types.h>
.Fd #include <sys/socket.h>
.Fd #include <net/if.h>
@


1.14
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.13 2006/05/01 14:46:52 jmc Exp $
d27 1
a27 1
.Dd $Mdocdate$
d275 1
a275 1
     s = splimp();                     |     s = splimp();
d422 1
a422 1
.Fn splimp
d574 1
a574 1
 s = splimp();                         | s = splimp();
@


1.13
log
@make .Nm match the page name;
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.12 2004/02/14 11:45:05 henning Exp $
d27 1
a27 1
.Dd July 10, 2001
@


1.12
log
@better wording, from jared
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.11 2004/01/24 12:04:09 jmc Exp $
d32 1
a32 1
.Nm ALTQ
@


1.11
log
@some fixes from Jared Yanovich, and a couple from myself;
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.10 2003/04/14 18:11:32 tedu Exp $
d336 1
a336 1
Probably, you need to make changes to the lines that include
@


1.10
log
@correct IFQ_ENQUEUE definition.  some grammar.
also sort .Xr from jmc@@
ok kjc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.9 2002/12/02 15:05:23 mickey Exp $
d81 1
a81 1
.Fa error
d87 1
a87 1
failure so that the caller should not touch
d245 1
a245 1
.Fa mbuf
d247 5
a251 3
The caller should not touch mbuf after calling
.Fn IFQ_ENQUEUE
so that the caller may need to copy
d255 1
a255 1
field beforehand for statistics.
d258 3
a260 1
since mbuf was already freed.
@


1.9
log
@dead e ellimination
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.8 2002/11/25 13:18:08 henning Exp $
d39 1
a39 1
.Fn IFQ_ENQUEUE "struct ifaltq *ifq" "struct mbuf *m" "int error"
d208 1
a208 1
The semantics of the enqueue operation is changed.
d215 15
a229 10
#define	IFQ_ENQUEUE(ifq, m, error)                      \e
do {                                                    \e
        if (IF_QFULL((ifq))) {                          \e
                m_freem((m));                           \e
                (error) = ENOBUFS;                      \e
                IF_DROP(ifq);                           \e
         } else {                                       \e
                IF_ENQUEUE((ifq), (m));                 \e
                (error) = 0;                            \e
         }                                              \e
d234 1
a234 1
does the followings:
d242 1
a242 1
.Fa error
d273 1
a273 1
                                       |                 error);
d553 1
a553 1
                                       |                 m, error);
d589 2
a590 2
.Xr pfctl 8 ,
.Xr pf.conf 5
@


1.8
log
@.Xr pfctl/pf.conf, not altqd/altq.conf; partitially from David Krause; Thanks!
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.7 2002/05/31 09:52:58 kjc Exp $
d63 1
a63 1
system is a framework to manage queueing disciplines on network
d80 1
a80 1
The underlying queueing discipline may discard the packet.
d86 1
a86 1
will be freed by the device driver on success or by the queueing discipline on
d109 1
a109 1
It is guaranteed by the underlying queueing discipline that
d130 1
a130 1
if the queueing discipline is non-work conserving.
d211 1
a211 1
separated in many queueing disciplines.
d241 1
a241 1
is freed by the queueing discipline.
d387 1
a387 1
the packet before dequeueing it, use
d420 1
a420 1
queueing disciplines.
d573 1
a573 1
Queueing disciplines need to maintain
d579 1
a579 1
Queueing disciplines also need to guarantee the same mbuf is returned if
@


1.7
log
@sync with KAME.
- remove space at EOL
- typo: retuen -> return
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.6 2001/07/13 05:00:14 kjc Exp $
d584 2
a585 3
.Xr altq.conf 5 ,
.Xr altqd 8 ,
.Xr tbrconfig 8
@


1.6
log
@sync with NetBSD r1.3.
grammer, whitespace and typo fixes by Thomas Klausner <wiz@@netbsd.org>.
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.5 2001/07/12 13:09:27 itojun Exp $
d65 1
a65 1
.Nm 
d237 1
a237 1
.Fa error 
d271 1
a271 1
         senderr(ENOBUFS);             |         retuen (error);
@


1.5
log
@more mdoc fixes.
From: Mike Pechkin <mpech@@prosoft.org.lv>
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.4 2001/07/12 12:41:42 itojun Exp $
d77 2
a78 2
.Fa m ,
to the queue 
a80 1
0 is set to
d82 1
a82 1
on success and 
d84 1
a84 1
is set if the packet is discarded.
d94 1
a94 1
The dequeued packet is set to
d97 2
d100 1
a100 1
is set if no packet is dequeued.
d121 1
a121 1
classifies a packet to a scheduling class, and set the result to
d157 1
a157 1
macros and the code directly referencing to the fields within
d210 1
a210 1
the enqueue and packet drop are combined since they cannot be easily
d236 2
a237 2
If the enqueue operation fails, an error
.Dv ENOBUFS
d239 2
a240 2
.Dv error .
.Dv mbuf
d259 1
a259 1
 int                                   | int 
d358 1
a358 1
.Ss Dequeue operaion
d463 4
a466 2
to set a value to
.Fa ifq_maxlen .
d470 1
a470 1
(this is used to distinguish new-style drivers.)
d488 1
a488 1
 ifp->if_snd.ifq_len--;                | IFQ_INC_LEN(&ifp->if_snd);
d547 1
a547 1
                                       |     IFQ_ENQUEUE(&sc->sc_if.if_snd, 
d574 1
a574 1
.Fa ifq_len .
@


1.4
log
@more typo
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.3 2001/07/12 12:38:29 itojun Exp $
d61 6
a66 2
The ALTQ system is a framework to manage queueing disciplines on network
interfaces.  ALTQ introduces new macros to manipulate output queues.
d69 3
a71 2
The macros are independent from the ALTQ implementation, and compatible with the
traditional
d94 2
a95 1
dequeues a packet from the queue.  The dequeued packet is set to
d146 2
a147 1
ALTQ can be enabled only on interfaces with this flag.
d153 2
a154 1
has the same fields.  The traditional
d207 2
a208 1
The semantics of the enqueue operation is changed.  In the new style,
d325 2
a326 1
in the driver.  Probably, you need to make changes to the lines that include
d419 2
a420 1
queueing disciplines.  A common use of
d489 2
a490 1
interruts only when it thinks necessary.  Rate-limiting breaks its assumption.
d494 5
a498 2
to prioritize packets.  It is possible to eliminate the second queue
since ALTQ provides more flexible mechanisms but the following shows
@


1.3
log
@typo; s/IFQ_EMPTY/IFQ_IS_EMPTY/
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.2 2001/07/12 12:33:28 itojun Exp $
d379 1
a379 1
IFQ_DEQUEUE .
d401 1
a401 2
.Po
They need to be guarded by 
d404 1
a404 2
.Fn if_start
.Pc .
@


1.2
log
@a couple of mdoc fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: altq.9,v 1.1 2001/07/12 12:15:02 kjc Exp $
d337 1
a337 1
.Fn IFQ_EMPTY
d340 1
a340 1
.Fn IFQ_EMPTY
@


1.1
log
@add altq.9 that describes ALTQ queue macros.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d29 1
a29 1
.Os KAME
d401 2
a402 1
(They need to be guarded by 
d405 2
a406 2
.Fn if_start .
)
d496 2
a497 1
line (
d500 2
a501 2
.Dv struct ifqueue .
)
d559 2
a560 1
(used by
d562 1
a562 1
).
@

