head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.6
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6;
locks; strict;
comment	@.\" @;


1.36
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.35;
commitid	wHLNY5GFNXJSFYaC;

1.35
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.34;
commitid	wckQrShbScIX7TCE;

1.34
date	2016.03.19.15.03.55;	author jmc;	state Exp;
branches;
next	1.33;
commitid	LXAMkyHjhYV5Oz41;

1.33
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.32;
commitid	gAjwyca5TfuoJAhn;

1.32
date	2015.12.02.11.03.40;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	np8gDjHEI7vjxdFF;

1.31
date	2015.12.02.10.20.46;	author jmc;	state Exp;
branches;
next	1.30;
commitid	GzJ1JjyYkLW1a8H4;

1.30
date	2015.12.02.09.46.29;	author tedu;	state Exp;
branches;
next	1.29;
commitid	EHQ7Xke8JXWdyiLP;

1.29
date	2015.11.23.17.53.57;	author jmc;	state Exp;
branches;
next	1.28;
commitid	GVTTSAMZ93Lz4hmE;

1.28
date	2015.11.15.14.55.22;	author jmc;	state Exp;
branches;
next	1.27;
commitid	Ba9tYIt7cW1KXdar;

1.27
date	2015.07.05.18.24.50;	author millert;	state Exp;
branches;
next	1.26;
commitid	emJyeCNiPwD46wtr;

1.26
date	2014.09.08.01.27.55;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	cPoapLAXYNe1fcgV;

1.25
date	2013.10.07.01.50.26;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.04.19.27.03;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.07.00.10.12;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.21.12.24.22;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.31.19.20.00;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.16.17.52.58;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.16.11.27.52;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.04.14.04.06;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.17.21.36.20;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.09.02.59.12;	author jaredy;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.01.10.20.25;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.05.14.25.52;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.23.18.31.34;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.25.02.27.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.24.20.15.45;	author mickey;	state dead;
branches;
next	1.9;

1.9
date	2003.06.06.20.56.32;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.30.04.53.18;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.15.04.14.29;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.18.12.48.31;	author david;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.12.13.12.27;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.12.13.06.18;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.12.09.41.14;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.11.20.28.33;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.10.20.20.29;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@.\" $OpenBSD: VOP_LOOKUP.9,v 1.35 2016/05/23 09:31:28 natano Exp $
.\"
.\" Copyright (c) 2003 Ted Unangst
.\" Copyright (c) 2000, 2001 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: May 23 2016 $
.Dt VOP_LOOKUP 9
.Os
.Sh NAME
.Nm VOP_LOOKUP ,
.Nm VOP_ABORTOP ,
.Nm VOP_ACCESS ,
.Nm VOP_ADVLOCK ,
.Nm VOP_BMAP ,
.Nm VOP_BWRITE ,
.Nm VOP_CLOSE ,
.Nm VOP_CREATE ,
.Nm VOP_FSYNC ,
.Nm VOP_GETATTR ,
.Nm VOP_INACTIVE ,
.Nm VOP_IOCTL ,
.Nm VOP_ISLOCKED ,
.Nm VOP_KQFILTER ,
.Nm VOP_LINK ,
.Nm VOP_LOCK ,
.Nm VOP_MKDIR ,
.Nm VOP_MKNOD ,
.Nm VOP_OPEN ,
.Nm VOP_PATHCONF ,
.Nm VOP_POLL ,
.Nm VOP_PRINT ,
.Nm VOP_READ ,
.Nm VOP_READDIR ,
.Nm VOP_READLINK ,
.Nm VOP_RECLAIM ,
.Nm VOP_REMOVE ,
.Nm VOP_RENAME ,
.Nm VOP_REVOKE ,
.Nm VOP_RMDIR ,
.Nm VOP_SETATTR ,
.Nm VOP_STRATEGY ,
.Nm VOP_SYMLINK ,
.Nm VOP_UNLOCK ,
.Nm VOP_WRITE
.Nd vnode operations
.Sh SYNOPSIS
.In sys/vnode.h
.Ft int
.Fo VOP_ABORTOP
.Fa "struct vnode *dvp"
.Fa "struct componentname *cnp"
.Fc
.Ft int
.Fo VOP_ACCESS
.Fa "struct vnode *vp"
.Fa "int mode"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_ADVLOCK
.Fa "struct vnode *vp"
.Fa "void *id"
.Fa "int op"
.Fa "struct flock *fl"
.Fa "int flags"
.Fc
.Ft int
.Fo VOP_BMAP
.Fa "struct vnode *vp"
.Fa "daddr_t bn"
.Fa "struct vnode **vpp"
.Fa "daddr_t *bnp"
.Fa "int *runp"
.Fc
.Ft int
.Fo VOP_BWRITE
.Fa "struct buf *bp"
.Fc
.Ft int
.Fo VOP_CLOSE
.Fa "struct vnode *vp"
.Fa "int fflag"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_CREATE
.Fa "struct vnode *dvp"
.Fa "struct vnode **vpp"
.Fa "struct componentname *cnp"
.Fa "struct vattr *vap"
.Fc
.Ft int
.Fo VOP_FSYNC
.Fa "struct vnode *vp"
.Fa "struct ucred *cred"
.Fa "int waitfor"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_GETATTR
.Fa "struct vnode *vp"
.Fa "struct vattr *vap"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_INACTIVE
.Fa "struct vnode *vp"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_IOCTL
.Fa "struct vnode *vp"
.Fa "u_long command"
.Fa "void *data"
.Fa "int fflag"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_ISLOCKED
.Fa "struct vnode *vp"
.Fc
.Ft int
.Fo VOP_KQFILTER
.Fa "struct vnode *vp"
.Fa "struct knote *kn"
.Fc
.Ft int
.Fo VOP_LINK
.Fa "struct vnode *dvp"
.Fa "struct vnode *vp"
.Fa "struct componentname *cnp"
.Fc
.Ft int
.Fo VOP_LOCK
.Fa "struct vnode *vp"
.Fa "int flags"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_LOOKUP
.Fa "struct vnode *dvp"
.Fa "struct vnode **vpp"
.Fa "struct componentname *cnp"
.Fc
.Ft int
.Fo VOP_MKDIR
.Fa "struct vnode *dvp"
.Fa "struct vnode **vpp"
.Fa "struct componentname *cnp"
.Fa "struct vattr *vap"
.Fc
.Ft int
.Fo VOP_MKNOD
.Fa "struct vnode *dvp"
.Fa "struct vnode **vpp"
.Fa "struct componentname *cnp"
.Fa "struct vattr *vap"
.Fc
.Ft int
.Fo VOP_OPEN
.Fa "struct vnode *vp"
.Fa "int mode"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_PATHCONF
.Fa "struct vnode *vp"
.Fa "int name"
.Fa "register_t *retval"
.Fc
.Ft int
.Fo VOP_POLL
.Fa "struct vnode *vp"
.Fa "int fflag"
.Fa "int events"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_PRINT
.Fa "struct vnode *vp"
.Fc
.Ft int
.Fo VOP_READ
.Fa "struct vnode *vp"
.Fa "struct uio *uio"
.Fa "int ioflag"
.Fa "struct ucred *cred"
.Fc
.Ft int
.Fo VOP_READDIR
.Fa "struct vnode *vp"
.Fa "struct uio *uio"
.Fa "struct ucred *cred"
.Fa "int *eofflag"
.Fc
.Ft int
.Fo VOP_READLINK
.Fa "struct vnode *vp"
.Fa "struct uio *uio"
.Fa "struct ucred *cred"
.Fc
.Ft int
.Fo VOP_RECLAIM
.Fa "struct vnode *vp"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_REMOVE
.Fa "struct vnode *dvp"
.Fa "struct vnode *vp"
.Fa "struct componentname *cnp"
.Fc
.Ft int
.Fo VOP_RENAME
.Fa "struct vnode *fdvp"
.Fa "struct vnode *fvp"
.Fa "struct componentname *fcnp"
.Fa "struct vnode *tdvp"
.Fa "struct vnode *tvp"
.Fa "struct componentname *tcnp"
.Fc
.Ft int
.Fo VOP_REVOKE
.Fa "struct vnode *vp"
.Fa "int flags"
.Fc
.Ft int
.Fo VOP_RMDIR
.Fa "struct vnode *dvp"
.Fa "struct vnode *vp"
.Fa "struct componentname *cnp"
.Fc
.Ft int
.Fo VOP_SETATTR
.Fa "struct vnode *vp"
.Fa "struct vattr *vap"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_STRATEGY
.Fa "struct buf *bp"
.Fc
.Ft int
.Fo VOP_SYMLINK
.Fa "struct vnode *dvp"
.Fa "struct vnode **vpp"
.Fa "struct componentname *cnp"
.Fa "struct vattr *vap"
.Fa "char *target"
.Fc
.Ft int
.Fo VOP_UNLOCK
.Fa "struct vnode *vp"
.Fa "struct proc *p"
.Fc
.Ft int
.Fo VOP_WRITE
.Fa "struct vnode *vp"
.Fa "struct uio *uio"
.Fa "int ioflag"
.Fa "struct ucred *cred"
.Fc
.Sh DESCRIPTION
The
.Nm VOP
functions implement a generic way to perform operations on vnodes.
The VOP function called passes the arguments to the correct file system
specific function.
Not all file systems implement all operations, in which case a generic
method will be used.
These functions exist to provide an abstract method to invoke vnode
operations without needing to know anything about the underlying file system.
Many system calls map directly to a specific VOP function.
.Pp
The arguments for each VOP
function consist of one or more vnode pointers along with other data
needed to perform the operation.
Care must be taken to obey the vnode locking discipline when using
VOP functions.
Many VOP calls take a
.Vt struct proc *p
argument.
This should be the current process.
VOP calls are not safe to call in an interrupt context.
.Pp
The
.Vt vattr
structure used by
.Fn VOP_CREATE ,
.Fn VOP_GETATTR ,
.Fn VOP_MKDIR ,
.Fn VOP_MKNOD ,
.Fn VOP_SETATTR ,
and
.Fn VOP_SYMLINK
is:
.Bd -literal
struct vattr {
	enum vtype      va_type;      /* vnode type */
	mode_t          va_mode;      /* files access mode and type */
	nlink_t         va_nlink;     /* number of references */
	uid_t           va_uid;       /* owner user id */
	gid_t           va_gid;       /* owner group id */
	long            va_fsid;      /* file system id */
	long            va_fileid;    /* file id */
	u_quad_t        va_size;      /* file size in bytes */
	long            va_blocksize; /* blocksize preferred for i/o */
	struct timespec va_atime;     /* time of last access */
	struct timespec va_mtime;     /* time of last modification */
	struct timespec va_ctime;     /* time file changed */
	u_long          va_gen;       /* generation number of file */
	u_long          va_flags;     /* flags defined for file */
	dev_t           va_rdev;      /* device the vnode represents */
	u_quad_t        va_bytes;     /* bytes of held disk space */
	u_quad_t        va_filerev;   /* file modification number */
	u_int           va_vaflags;   /* operations flags */
	long            va_spare;     /* remain quad aligned */
};
.Ed
.Pp
The following sections comment on the VOP functions from the consumer's
perspective.
.Pp
.Bl -tag -width Ds -compact
.It Fn VOP_ABORTOP dvp cnp
Abort any asynchronous operations pending on the vnode
.Fa dvp
associated with the path name
.Fa cnp .
This is mostly used by internal VFS code and should not be needed by
file system implementors.
.Pp
.It Fn VOP_ACCESS vp mode cred p
Determine if the locked vnode
.Fa vp
can be accessed by the calling process
.Fa p
with credentials
.Fa cred
for the given access
.Fa mode .
.Pp
.Fa mode
may contain any of the following values:
.Pp
.Bl -tag -width Ds -compact -offset indent
.It Dv VWRITE
check writeability
.It Dv VREAD
check readability
.It Dv VEXEC
check executability
.El
.Pp
If the access check succeeds, zero is returned; otherwise, an
appropriate error code is returned.
.Pp
.It Fn VOP_ADVLOCK vp id op fl flags
Perform advisory locking on the vnode
.Fa vp
according to the operation
.Fa op
and lock specification
.Fa fl .
.Fa id
identifies the resource holding the lock
(typically a pointer to the holding process).
.Pp
.Fa op
may be one of the following operations:
.Pp
.Bl -tag -width F_GETLK -compact -offset indent
.It Dv F_GETLK
Get the first lock that would block a lock request.
.It Dv F_SETLK
Set a lock.
.It Dv F_UNLCK
Release a lock.
.El
.Pp
.Fa flags
may contain the following flags:
.Pp
.Bl -tag -width F_POSIX -compact -offset indent
.It Dv F_WAIT
If required, block waiting to obtain an exclusive lock.
.It Dv F_POSIX
Follow
.Tn POSIX
locking semantics; see
.Xr fcntl 2 .
.It Dv F_FLOCK
Follow
.Xr flock 2
locking semantics.
.El
.Pp
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_BMAP vp bn vpp bnp runp
Convert the logical block number
.Fa bn
of the file the locked vnode
.Fa vp
is associated with its physical number on-disk.
The physical block number is stored in
.Fa *bnp
on return.
.Fa vpp ,
if
.No non- Ns Dv NULL ,
will be updated to point to the vnode of the block device of which
.Fa vp
is associated.
.Fa runp ,
if
.No non- Ns Dv NULL ,
will be updated to the number of contiguous disk blocks following
.Fa *bnp .
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_BWRITE bp
Write a file system buffer to disk.
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_CLOSE vp fflag cred p
Close the file associated with the locked vnode
.Fa vp
with file flags
.Fa fflag
by the calling process
.Fa p
with credentials
.Fa cred .
This operation should be performed only when the file is no longer being
used.
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_CREATE dvp vpp cnp vap
Create a new directory entry for a regular file in the directory
.Fa dvp
and return a locked, referenced vnode in
.Fa vpp .
The file name is in
.Fa cnp
and its permissions will be
.Fa vap .
.Pp
.It Fn VOP_FSYNC vp cred waitfor p
Flush any dirty buffers associated with
.Fa vp
to disk.
The vnode is locked on entry and exit.
.Fa waitfor
can be set to
.Dv MNT_WAIT
to indicate that
.Fn VOP_FSYNC
should not return until all data is written.
.Pp
.It Fn VOP_GETATTR vp vap cred p
.It Fn VOP_SETATTR vp vap cred p
Access the vnode attributes
.Fa vap
of the vnode
.Fa vp
by the calling process
.Fa p
with credentials
.Fa cred .
.Fn VOP_SETATTR
requires that
.Fa vp
be locked.
A field value for any member of
.Fa vap
of
.Dv VNOVAL
represents that the information could not be obtained by
.Fn VOP_GETATTR
or should not be changed by
.Fn VOP_SETATTR .
Upon success of obtaining or changing the attributes, zero is returned;
otherwise, an appropriate error code is returned.
All attributes are held in the
.Vt vattr
structure shown above.
.Pp
.It Fn VOP_INACTIVE vp p
Notify the underlying file system that the locked vnode
.Fa vp
is no longer in use.
The vnode will be unlocked upon return.
.Fa p
specifies the calling process.
This may happen when the vnode reference count reaches zero or
when the underlying file system has disappeared or has been forcibly
unmounted.
.Pp
Typically, the underlying file system will write any buffers associated
with
.Fa vp
to disk or delete the file entry, if need be.
The underlying file system may not necessarily release any buffers
associated with
.Fa vp
so that it can be immediately reactivated in case the file is used again.
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_IOCTL vp command data fflag cred p
Perform the control operation
.Fa command
with additional information
.Fa data
on the vnode
.Fa vp ,
normally associated with a device,
with file flags
.Fa fflag
by the calling process
.Fa p
with credentials
.Fa cred .
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_ISLOCKED vp
.It Fn VOP_LOCK vp flags p
.It Fn VOP_UNLOCK vp p
.Fn VOP_LOCK
is used internally by
.Xr vn_lock 9
to lock a vnode.
It should not be used by other file system code.
.Fn VOP_UNLOCK
unlocks a vnode.
Note the asymmetry between
.Xr vn_lock 9
and
.Fn VOP_UNLOCK .
.Pp
.Fa flags
may contain the following flags:
.Pp
.Bl -tag -width LK_RECURSEFAIL -compact -offset indent
.It Dv LK_EXCLUSIVE
Acquire an exclusive lock.
.It Dv LK_SHARED
Acquire a shared lock.
.It Dv LK_NOWAIT
Don't wait if the vnode lock is held by someone else
(may still wait on reclamation lock).
.It Dv LK_RECURSEFAIL
Attempt at recursive lock fails.
.It Dv LK_DRAIN
Wait for all activity on the lock to end, then mark it decommissioned.
This feature is used to ensure that no other activity can occur while the
underlying object of a vnode is being cleaned out.
Must be used in combination with
.Dv LK_EXCLUSIVE .
.El
.Pp
.Fn VOP_ISLOCKED
returns one of the following values:
.Pp
.Bl -tag -width LK_EXCLUSIVE -compact -offset indent
.It Dv LK_EXCLUSIVE
.Fa vp
is locked for exclusive access by the calling thread.
.It Dv LK_EXCLOTHER
.Fa vp
is locked for exclusive access by a different thread.
.It Dv LK_SHARED
.Fa vp
is locked for shared access.
The current thread may be one of the threads that have it locked.
.It 0
.Fa vp
is not locked.
.El
.Pp
.Fn VOP_ISLOCKED
should be used cautiously, as not all file systems implement locks
effectively.
.Pp
.It Fn VOP_KQFILTER vp kn
Register the
.Xr knote 9
filtering information
.Fa kn
for the vnode
.Fa vp .
Only filters for
.Dv EVFILT_READ ,
.Dv EVFILT_WRITE ,
and
.Dv EVFILT_VNODE
will invoke this operation.
Upon success, zero is returned; otherwise, a non-zero value is returned.
.Pp
.It Fn VOP_LINK dvp vp cnp
Increase the link count for the vnode
.Fa vp .
A new entry with name
.Fa cnp
should be added to the directory
.Fa dvp .
.Fa dvp
is locked on entry and unlocked on exit.
.Pp
.It Fn VOP_LOOKUP dvp vpp cnp
Find the file corresponding to the name
.Fa cnp
in the directory
.Fa dvp
and return a vnode in
.Fa vpp .
.Fa dvp
is locked on entry and exit, and
.Fa vpp
is locked upon a successful return.
.Fa vpp
will be
.Dv NULL
on error, and
.Fa cnp->cn_flags
will be set to
.Dv PDIRUNLOCK
if
.Fa dvp
has been unlocked for an unsuccessful return.
.Pp
.It Fn VOP_MKDIR dvp vpp cnp vap
Create a new directory named by
.Fa cnp
with permissions
.Fa vattr
in the directory
.Fa dvp .
On success, the new vnode is returned locked in
.Fa vpp .
.Fa dvp
must be locked on entry and is unlocked on exit.
.Pp
.It Fn VOP_MKNOD dvp vpp cnp vap
Create a device special file with name
.Fa cnp
and attributes
.Fa vap
in the directory associated with the locked vnode
.Fa dvp .
.Fa dvp
will be unlocked on return (see
.Xr vput 9 ) .
A pointer to the new, locked vnode will be returned in
.Fa *vpp
if
.Fa vpp
is not
.Dv NULL .
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_OPEN vp mode cred p
Open the file associated with the vnode
.Fa vp
with the access modes
.Fa mode
by the calling process
.Fa p
with credentials
.Fa cred .
.Fa mode
takes the flags described in
.Xr open 2 .
.Pp
For some underlying file systems, access permissions for the file by the
process are checked; for others, this is a no-op.
In any case, this must be called before a process can access the file.
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_PATHCONF vp name retval
Obtain the value of the applicable
.Tn POSIX
configurable pathname variable (see
.Xr pathconf 2 )
specified by
.Fa name
from the locked vnode
.Fa vp .
The result is placed in
.Fa *retval .
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_POLL vp fflag events p
Determine whether the vnode
.Fa vp
is ready to perform the operations specified by
.Fa events
(see
.Xr poll 2 )
with file flags
.Fa fflag
for the calling process
.Fa p .
The
.Fn selrecord
routine may be used to detect selection collisions for multiple
processes sleeping on the same file, waiting for
.Tn I/O
to become possible, although all file systems currently assume that
.Tn I/O
is always possible.
The return value specifies which operations from
.Fa events
were found to be ready, which may be performed without the need for
blocking.
.Pp
.It Fn VOP_PRINT vp
Print information about the vnode to the kernel message buffer.
It is not used normally, but exists only for debugging purposes.
.Pp
.It Fn VOP_READ vp uio ioflag cred
Copy data from the locked vnode
.Fa vp
to the buffers specified by
.Fa uio
with calling process credentials
.Fa cred .
.Pp
.Fa ioflag
may contain the following flags:
.Pp
.Bl -tag -width IO_APPEND -offset indent -compact
.It Dv IO_NDELAY
Non-blocking I/O.
.It Dv IO_UNIT
Do I/O as an atomic unit.
.El
.Pp
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_READDIR vp uio cred eofflag
Read the contents of the directory associated with the locked vnode
.Fa vp ,
usually via
.Fn VOP_READ ,
and convert its file-system-specific format to that expected by the
.Xr getdents 2
system call, storing the result into the buffers specified by
.Fa uio .
.Fa cred
specifies the credentials of the calling process.
.Fa *eofflag
is set to a non-zero value on return once successful end-of-file for the
directory contents has been reached.
.Pp
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_READLINK vp uio cred
Read a symbolic link and return the target's name in
.Fa uio .
.Fa vp
is locked on entry and exit and must be a symlink.
.Pp
.It Fn VOP_RECLAIM vp p
Used by
.Xr vclean 9
so that the file system has an opportunity to free memory
and perform any other cleanup activity related to
.Fa vp .
.Fa vp
is unlocked on entry and exit.
.Fn VOP_RECLAIM
should not be used by generic code.
.Pp
.It Fn VOP_REMOVE dvp vp cnp
Remove the link named
.Fa cnp
from the directory
.Fa dvp .
This file corresponds to the vnode
.Fa vp .
Both
.Fa dvp
and
.Fa vp
are locked on entry and unlocked on exit, and
each has its reference count decremented by one.
.Fn VOP_REMOVE
does not delete the file from disk unless its link count
becomes zero (for file systems which support multiple links).
.Pp
.It Fn VOP_RENAME fdvp fvp fcnp tdvp tvp tcnp
Remove the link to the file with associated vnode
.Fa fvp
and name
.Fa fcnp
in the directory with associated vnode
.Fa fdvp ,
and create a new link to the file with name
.Fa tcnp
(and associated locked vnode
.Fa tvp ,
if the file already exists) residing in the directory with the
associated locked vnode
.Fa tdvp .
.Fa fdvp ,
.Fa fvp ,
and
.Fa tvp
(if not
.Dv NULL )
will be released (see
.Xr vrele 9 )
and
.Fa tdvp
will have its reference count decremented (see
.Xr vput 9 )
on return.
If not
.Dv NULL ,
.Fa tvp
will be locked on return as well.
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.Pp
.It Fn VOP_REVOKE vp flags
Used by the
.Xr revoke 2
system call to prevent any further access to a vnode.
The vnode ops will be changed to those of deadfs, which returns only
errors.
.Ar vp
must be unlocked.
.Pp
.It Fn VOP_RMDIR dvp vp cnp
Remove the directory
.Fa vp
from the directory
.Fa dvp .
Both are locked on entry and unlocked on exit.
The name of the directory for removal is additionally contained in
.Fa cnp .
.Pp
.It Fn VOP_STRATEGY bp
Call the appropriate strategy function for the device backing the
buffer's vnode.
.Pp
.It Fn VOP_SYMLINK dvp vpp cnp vap target
Create a symbolic link with name
.Fa cnp
in the directory
.Fa dvp
with mode
.Fa vap .
The link will point to
.Fa target
and a vnode for it is returned in
.Fa vpp .
The directory vnode is locked on entry and unlocked on exit.
Note that unlike most VOP calls returning a vnode,
.Fn VOP_SYMLINK
does not lock or reference
.Fa vpp .
.Pp
.It Fn VOP_WRITE vp uio ioflag cred
Copy data from the buffers specified by
.Fa uio
to the locked vnode
.Fa vp
with calling process credentials
.Fa cred .
.Pp
.Fa ioflag
may contain the following flags:
.Pp
.Bl -tag -width IO_APPEND -offset indent -compact
.It Dv IO_APPEND
Perform write at the end of file.
.It Dv IO_NDELAY
Non-blocking I/O.
.It Dv IO_SYNC
Wait for I/O to complete.
.It Dv IO_UNIT
Do I/O as an atomic unit.
.El
.Pp
Upon success, zero is returned; otherwise, an appropriate error code is
returned.
.El
.Sh RETURN VALUES
The
.Nm VOP
functions return 0 to indicate success and a non-zero error code
to indicate failure.
.Sh SEE ALSO
.Xr errno 2 ,
.Xr uiomove 9 ,
.Xr vfs 9 ,
.Xr vn_lock 9 ,
.Xr vnode 9
.Sh AUTHORS
This man page was written by
.An Ted Unangst
for
.Ox .
.Sh BUGS
The locking discipline is too complex.
Refer to
.Xr vn_lock 9 .
@


1.35
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.34 2016/03/19 15:03:55 jmc Exp $
d4 1
d27 1
a27 1
.Dd $Mdocdate: March 19 2016 $
a568 6
.Fn VOP_ISLOCKED
returns 1 if
.Fa vp
is locked and 0 if not.
It should be used cautiously, as not all file systems implement locks
effectively.
d573 44
@


1.34
log
@uio -> uiomove;
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.33 2016/03/19 12:04:15 natano Exp $
a54 1
.Nm VOP_REALLOCBLKS ,
a227 5
.Fo VOP_REALLOCBLKS
.Fa "struct vnode *vp"
.Fa "struct cluster_save *buflist"
.Fc
.Ft int
a761 10
.Pp
.It Fn VOP_REALLOCBLKS vp buflist
Called by the VFS write clustering code.
It gives the file system an opportunity to rearrange the on-disk blocks
for a file to reduce fragmentation.
.Fa vp
is the locked vnode for the file, and
.Fa buflist
is a cluster of the outstanding buffers about to be written.
Currently, only FFS implements this call.
@


1.33
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.32 2015/12/02 11:03:40 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: December 2 2015 $
d912 1
a912 1
.Xr uio 9 ,
@


1.32
log
@Tweak previous:  Move struct vattr out of the function table, it's used
by more than two functions, and use .Vt for the struct name.
OK jmc@@ tedu@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.31 2015/12/02 10:20:46 jmc Exp $
a285 1
.Fa "int flags"
d566 1
a566 1
.It Fn VOP_UNLOCK vp flags p
a573 2
.Fa flags
should be zero in most cases.
@


1.31
log
@add VOP_{GET,SET}ATTR to NAME too;
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.30 2015/12/02 09:46:29 tedu Exp $
d319 35
d523 2
a524 25
.Fa vattr
structure described below.
.Bd -literal
struct vattr {
        enum vtype      va_type;        /* vnode type */
        mode_t          va_mode;        /* files access mode and type */
        nlink_t         va_nlink;       /* number of references */
        uid_t           va_uid;         /* owner user id */
        gid_t           va_gid;         /* owner group id */
        long            va_fsid;        /* file system id */
        long            va_fileid;      /* file id */
        u_quad_t        va_size;        /* file size in bytes */
        long            va_blocksize;   /* blocksize preferred for i/o */
        struct timespec va_atime;       /* time of last access */
        struct timespec va_mtime;       /* time of last modification */
        struct timespec va_ctime;       /* time file changed */
        u_long          va_gen;         /* generation number of file */
        u_long          va_flags;       /* flags defined for file */
        dev_t           va_rdev;        /* device the vnode represents */
        u_quad_t        va_bytes;       /* bytes of held disk space */
        u_quad_t        va_filerev;     /* file modification number */
        u_int           va_vaflags;     /* operations flags */
        long            va_spare;       /* remain quad aligned */
};
.Ed
@


1.30
log
@merge important bits of GETATTR into VOP_LOOKUP.
provoked by jmc (and reminded that i failed to commit by ingo)
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.29 2015/11/23 17:53:57 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: November 23 2015 $
d39 1
d61 1
@


1.29
log
@add missing NAME entries;
feedback/ok schwarze
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.28 2015/11/15 14:55:22 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: November 15 2015 $
d485 26
@


1.28
log
@word fix;
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.27 2015/07/05 18:24:50 millert Exp $
d26 1
a26 1
.Dd $Mdocdate: July 5 2015 $
d30 34
a63 1
.Nm VOP_LOOKUP
@


1.27
log
@Document the new 'fflag' argument to VOP_POLL().
From Martin Natano
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.26 2014/09/08 01:27:55 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: September 8 2014 $
d369 1
a369 1
is associated with to its physical number on-disk.
@


1.26
log
@obvious cases of missing .An;
found with the new mandoc(1) MANDOCERR_AN_MISSING warning;
no text changes
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.25 2013/10/07 01:50:26 guenther Exp $
d26 1
a26 1
.Dd $Mdocdate: October 7 2013 $
d165 1
d626 1
a626 1
.It Fn VOP_POLL vp events p
d633 2
@


1.25
log
@getdirentries(2) is dead; long live getdents(2)!

confirmation that getdirentries(2) is unused by ports from sthen@@ and naddy@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.24 2013/06/11 16:42:05 deraadt Exp $
d26 1
a26 1
.Dd $Mdocdate: June 11 2013 $
d844 3
a846 1
This man page was written by Ted Unangst for
@


1.24
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.23 2013/06/04 19:27:03 schwarze Exp $
d26 1
a26 1
.Dd $Mdocdate: June 4 2013 $
a184 2
.Fa "int *ncookies"
.Fa "u_long **cookies"
d672 1
a672 1
.It Fn VOP_READDIR vp uio cred eofflag ncookies cookies
d678 1
a678 1
.Xr getdirentries 2
a685 10
.Pp
.Fa ncookies
and
.Fa cookies ,
if not
.Dv NULL ,
are used for keeping track of directory seeking.
This is used by some file systems, such as
.Tn NFS ,
to allow sequential chunks of the directory contents to be obtained.
@


1.23
log
@Replace old-fashioned .Fd by new-fangled .In for #include lines.
Diff from Jan Klemkow <j dot klemkow at wemelug dot de> on tech@@.
No objection from jmc@@ against this type of change.
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.22 2010/09/07 00:10:12 thib Exp $
d26 1
a26 1
.Dd $Mdocdate: September 7 2010 $
d57 1
a57 1
.Fa "daddr64_t bn"
d59 1
a59 1
.Fa "daddr64_t *bnp"
@


1.22
log
@Update the documentation reflecting the latest churn in the vop layer.
By updating I mean remove two sections (that where made wrong and where wrong
before the churn) and tweak a few sentances.

ok deraadt
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.21 2009/05/21 12:24:22 thib Exp $
d26 1
a26 1
.Dd $Mdocdate: May 21 2009 $
d33 1
a33 1
.Fd #include <sys/vnode.h>
@


1.21
log
@IO_METASYNC has been a noop since around 4.4BSD-Lite, the
idea never really caught on anywhere so retire it.

"gank this shizzle", blambert@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.19 2007/01/16 17:52:58 thib Exp $
d26 1
a26 1
.Dd $Mdocdate: May 31 2007 $
a278 3
The locking discipline for all currently defined VOP
functions is described in the file
.Pa sys/kern/vnode_if.src .
a286 1
Some notes for file system implementors follow.
a843 29
.Sh IMPLEMENTATION NOTES
The
.Nm VOP
functions are stubs which redirect their arguments to the
appropriate function for each file system.
In order to allow for layered file systems and generic bypass methods,
all vnode operation implementing functions take only a single
.Vt void *
pointer as an argument.
This points to a structure containing the real arguments.
Additionally, this structure contains a
.Vt struct vnodeop_desc * ,
or
.Em vnodeop description .
The description is typically used by the abstract VOP code, but can
be useful to the lower implementation as well.
Every file system defines an array of
.Vt struct vnodeopv_entry_desc
that contains one entry for each implemented vnode op.
Unimplemented vnode operations match the default description,
.Va vop_default_desc .
Most non-layer file systems should assign the default error handler,
.Fn vn_default_error ,
to the generic description.
.Pp
All lower level implementations should conform to the interfaces described
above.
The rules for locking and referencing vnodes are enforced by each
file system implementation, not the VOP stubs.
a848 11
.Sh FILES
.Bl -tag -width sys/kern/vnode_if.src -compact
.It Pa sys/kern/vnode_if.src
source file containing
.Nm VOP
definitions
.It Pa sys/kern/vnode_if.c
C file with implementations of each
.Nm VOP
stub call
.El
@


1.20
log
@convert to new .Dd format;
@
text
@d26 1
a26 1
.Dd $Mdocdate$
a836 2
.\" .It Dv IO_METASYNC
.\" Ensure all metadata is written synchronously.
@


1.19
log
@Remove commented out references to VOP_LEASE();

ok jmc@@ (who pointed this out to me)
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.18 2006/10/16 11:27:52 pedro Exp $
d26 1
a26 1
.Dd March 9, 2003
@


1.18
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.17 2006/10/04 14:04:06 pedro Exp $
a116 7
.\" .Ft int
.\" .Fo VOP_LEASE
.\" .Fa "struct vnode *vp"
.\" .Fa "struct proc *p"
.\" .Fa "struct ucred *cred"
.\" .Fa "int flag"
.\" .Fc
a534 2
.\" .It Fn VOP_LEASE vp p cred flag
.\" .Pp
@


1.17
log
@Match reality when describing VOP_BMAP(), bad pedro
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.16 2005/06/17 21:36:20 drahn Exp $
d57 1
a57 1
.Fa "daddr_t bn"
@


1.16
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless to maintain. go ahead jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.15 2005/06/09 02:59:12 jaredy Exp $
d59 1
a59 1
.Fa "daddr_t *bnp"
@


1.15
log
@- add documentation for remaining vnode operations
- improve page layout
- add MLINKS to, sort, and fix some typos in the Makefile

help & ok marius, tedu, pedro, jmc
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.14 2005/06/01 10:20:25 pedro Exp $
a94 10
.Fo VOP_GETEXTATTR
.Fa "struct vnode *vp"
.Fa "int attrnamespace"
.Fa "const char *name"
.Fa "struct uio *uio"
.Fa "size_t *size"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
a244 9
.Fo VOP_SETEXTATTR
.Fa "struct vnode *vp"
.Fa "int attrnamespace"
.Fa "const char *name"
.Fa "struct uio *uio"
.Fa "struct ucred *cred"
.Fa "struct proc *p"
.Fc
.Ft int
a463 27
.Pp
.It Fn VOP_GETEXTATTR vp attrnamespace name uio size cred p
.It Fn VOP_SETEXTATTR vp attrnamespace name uio cred p
.Fn VOP_GETEXTATTR
and
.Fn VOP_SETEXTATTR
are called to get and set named extended file attributes (see
.Xr extattr 9 ) .
.Fa vp
is the vnode for which to get or set the attribute.
It must be locked.
.Fa attrnamespace
is an integer describing whether the attribute belongs in the
user or system namespace.
.Fa name
is the extended attribute to get or set.
.Fa uio
is a
.Xr uio 9
structure with the userland address containing the userland data.
.Fn VOP_GETEXTATTR
will return the actual length of the attribute in
.Fa size
if it is
.No non- Ns Dv NULL .
.Fa cred
is a pointer to the credentials used to access the file.
@


1.14
log
@VOP_WHITEOUT() is gone, okay jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.13 2004/02/05 14:25:52 jmc Exp $
d35 39
d88 7
d105 14
d120 6
a125 1
.Fa "struct vnode *"
d127 7
d160 26
d190 16
d228 9
d248 7
d270 1
a270 1
.Fa "struct vnode *vpp"
d281 7
a287 1
.\" and many more
d298 1
a298 1
Many syscalls map directly to a specific VOP function.
d308 3
a310 1
Many VOP calls take a struct proc *p argument.
d317 125
a441 6
.Sh VOP_CREATE
.Fn VOP_CREATE
creates a new directory entry for a regular file in the directory
.Ar dvp
and returns a locked, referenced vnode in
.Ar vpp .
d443 1
a443 1
.Ar cnp
d445 5
a449 5
.Ar vap .
.Sh VOP_FSYNC
.Fn VOP_FSYNC
flushes any dirty buffers associated with
.Ar vp
d452 34
a485 4
.Ar waitfor
can be set to MNT_WAIT to indicate VOP_FSYNC should not return
until all data is written.
.Sh VOP_GETEXTATTR
d491 1
a491 1
.Ar vp
d494 1
a494 1
.Ar attrnamespace
d497 1
a497 1
.Ar name
d499 1
a499 1
.Ar uio
d503 6
a508 5
VOP_GETEXTATTR will return the actual length of the attribute
in
.Ar size
if it is non-NULL.
.Ar cred
d510 83
a592 4
.Sh VOP_LINK
.Fn VOP_LINK
increases the link count for the vnode
.Ar vp .
d594 1
a594 1
.Ar cnp
d596 2
a597 2
.Ar dvp .
.Ar dvp
d599 4
a602 4
.Sh VOP_LOOKUP
.Fn VOP_LOOKUP
finds the file corresponding to the name
.Ar cnp
d604 4
a607 4
.Ar dvp
and returns a vnode in
.Ar vpp .
.Ar dvp
d609 1
a609 1
.Ar vpp
d611 7
a617 2
.Ar vpp
will be NULL on error, and cnp->cn_flags will be set to PDIRUNLOCK
d619 1
a619 1
.Ar dvp
d621 8
a628 11
.Sh VOP_MKDIR
.Fn VOP_MKDIR
implements the
.Xr mkdir 2
syscall.
A new directory with name matching that in
.Ar cnp
and with permissions
.Ar vattr
will be created in the directory
.Ar dvp .
d630 2
a631 2
.Ar vpp .
.Ar dvp
d633 77
a709 3
.Sh VOP_PRINT
.Fn VOP_PRINT
prints information about the vnode to the kernel message buffer.
d711 54
a764 5
.Sh VOP_READLINK
.Fn VOP_READLINK
reads a symbolic link and returns the target's name in
.Ar uio .
.Ar vp
d766 4
a769 4
.Sh VOP_REALLOCBLKS
.Fn VOP_REALLOCBLKS
is called by the vfs write clustering code.
It gives the file system an opportunity to rearrange the on disk blocks
d771 1
a771 1
.Ar vp
d773 2
a774 2
.Ar buflist
is a cluster of the outstanding buffers about to written.
d776 3
a778 3
.Sh VOP_RECLAIM
.Fn VOP_RECLAIM
is used by
d782 2
a783 2
.Ar vp .
.Ar vp
d785 6
a790 5
VOP_RECLAIM should not be used by generic code.
.Sh VOP_REMOVE
.Fn VOP_REMOVE
removes the link named
.Ar cnp
d792 1
a792 1
.Ar dvp .
d794 6
a799 2
.Ar vp .
Both dvp and vp are locked on entry and unlocked on exit, and
d801 2
a802 1
VOP_REMOVE does not delete the file from disk unless its link count
d804 37
a840 3
.Sh VOP_REVOKE
.Fn VOP_REVOKE
is used by the
d842 1
a842 1
syscall to prevent any further access to a vnode.
d847 6
a852 9
.Sh VOP_RMDIR
.Fn VOP_RMDIR
implements the
.Xr rmdir 2
syscall.
The directory
.Ar vp
will be removed from the directory
.Ar dvp .
d855 4
a858 5
.Ar cnp .
.Sh VOP_STRATEGY
.Fn VOP_STRATEGY
is the only VOP call not taking a vnode argument.
It calls the appropriate strategy function for the device backing the
d860 4
a863 4
.Sh VOP_SYMLINK
.Fn VOP_SYMLINK
creates a symbolic link with name
.Ar cnp
d865 1
a865 1
.Ar dvp
d867 1
a867 1
.Ar vap .
d869 1
a869 1
.Ar target
d871 1
a871 1
.Ar vpp .
d873 2
a874 1
Note that unlike most VOP calls returning a vnode, VOP_SYMLINK
d876 29
a904 18
.Ar vpp .
.Sh VOP_LOCK
.Fn VOP_LOCK
is used internally by
.Xr vn_lock 9
to lock a vnode.
It should not be used by other file system code.
.Fn VOP_UNLOCK
unlocks a vnode.
.Ar flags
should be zero in most cases.
.Fn VOP_ISLOCKED
returns 1 if
.Ar vp
is locked and 0 if not.
It should be used cautiously, as not all file systems implement locks
effectively.
Note the asymmetry between vn_lock and VOP_UNLOCK.
d911 2
a912 1
all vnode operation implementing functions take only a single void *
d915 4
a918 2
Additionally, this structure contains a struct vnodeop_desc *,
or vnodeop description.
d921 2
a922 1
Every file system defines an array of struct vnodeopv_entry_desc
d925 1
a925 1
.Em vop_default_desc .
d927 1
a927 1
.Em vn_default_error ,
d952 2
@


1.13
log
@make .Nm match .Dt to avoid screwy apropos(1) output;
found by pb@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.12 2003/10/23 18:31:34 jmc Exp $
a150 6
.Ft int
.Fo VOP_WHITEOUT
.Fa "struct vnode *dvp"
.Fa "struct componentname *cnp"
.Fa "int flags"
.Fc
a364 13
.Sh VOP_WHITEOUT
.Fn VOP_WHITEOUT
manipulates whiteout entries in a directory.
.Ar dvp
is the directory containing, or to contain, the whiteout.
It is locked on entry and exit.
.Ar cnp
contains the name of the whiteout.
.Ar flags
is used to indicate the operation.
Whiteouts may be created or deleted.
A whiteout entry is normally used to indicate the absence of a file on a
translucent file system.
@


1.12
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.11 2003/07/25 02:27:33 deraadt Exp $
d30 1
a30 1
.Nm VOP functions
d160 1
a160 1
.Nm
d411 1
a411 1
.Nm
d418 1
a418 1
.Nm
d422 1
a422 1
.Nm
@


1.11
log
@change things back.  (another note: with this change, suddenly there was
no VOP_LOOKUP(9) page at all.. geez)
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.9 2003/06/06 20:56:32 jmc Exp $
d283 1
a283 1
It gives the file system an opporunity to rearrange the on disk blocks
@


1.10
log
@rename VOP_LOOKUP.9 into vnodeops.9 for nicer xreffing.
a few pages i wrote being high on acetyl salicylic acid.
vfs(9) from netbsd.
@
text
@d27 1
a27 1
.Dt VOP 9
@


1.9
log
@- section reorder
- macro fixes
- kill whitespace at EOL
- use .Ox for OpenBSD, .Fx for FreeBSD
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.8 2003/04/30 04:53:18 tedu Exp $
@


1.8
log
@some notes about VOP_PRINT, VOP_STRATEGY, VOP_REALLOCBLKS, and VOP_WHITEOUT
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.7 2003/04/15 04:14:29 jmc Exp $
d430 2
a431 1
This man page was written by Ted Unangst for OpenBSD.
@


1.7
log
@typos;

VOP, crypto and disklabel ok tedu@@
audio(9) ok naddy@@
@
text
@d1 1
a1 1
.\" $OpenBSD: VOP_LOOKUP.9,v 1.6 2003/03/18 12:48:31 david Exp $
d88 4
d98 5
d134 4
d151 6
d270 4
d280 10
d333 5
d371 13
@


1.6
log
@add missing rcs id and start new sentence on a new line.
ok tedu@@
@
text
@d1 1
a1 1
.\" $OpenBSD$
d167 1
a167 1
.Nm VOP_CREATE
d177 1
a177 1
.Nm VOP_FSYNC
d186 1
a186 1
.Nm VOP_GETEXTATTR
d188 1
a188 1
.Nm VOP_SETEXTATTR
d210 1
a210 1
.Nm VOP_LINK
d220 1
a220 1
.Nm VOP_LOOKUP
d237 4
a240 2
.Nm VOP_MKDIR
implements the mkdir syscall.
d252 1
a252 1
.Nm VOP_READLINK
d258 1
a258 1
.Nm VOP_RECLAIM
d268 1
a268 1
.Nm VOP_REMOVE
d280 1
a280 1
.Nm VOP_REVOKE
d289 4
a292 2
.Nm VOP_RMDIR
implements the rmdir syscall.
d301 1
a301 1
.Nm VOP_SYMLINK
d316 2
a317 2
.Sh VOP_UNLOCK
.Nm VOP_LOCK
d322 1
a322 1
.Nm VOP_UNLOCK
d326 1
a326 1
.Nm VOP_ISLOCKED
d364 1
a364 1
.Bl -tag -width sys/kern/vnode_if.src
@


1.5
log
@should -> must when discussing locking.  it's not optional.
@
text
@d1 1
d377 2
a378 1
The locking discipline is too complex.  Refer to
@


1.4
log
@add VOP_CREATE, VOP_LINK, VOP_READLINK, VOP_SYMLINK

add some implementation notes for file system authors

ok jmc@@
@
text
@d158 1
a158 1
Most VOP calls take a struct proc *p argument.
d192 1
a192 1
It should be locked.
d207 1
a207 1
should be a pointer to the credentials used to access the file.
a251 2
VOP_READLINK should only be called on symlinks,
and
d253 1
a253 1
is locked on entry and exit.
d331 1
a331 1
functions are mostly stubs which redirect their arguments to the
@


1.3
log
@add VOP_FSYNC, VOP_ISLOCKED, and VOP_REMOVE
only 28 more to go!

ok jmc@@
@
text
@d34 7
d62 6
d87 6
d124 8
d146 1
a146 1
These functions exist to provide an abstract method to invoke vnode 
d161 14
d208 10
d248 8
d297 16
d330 25
@


1.2
log
@VOP_LOCK, VOP_UNLOCK, VOP_RMDIR, VOP_MKDIR, VOP_SETEXTATTR, VOP_GETEXTATTR,
VOP_REVOKE, VOP_RECLAIM

looked over and input from art@@ david@@ jmc@@
@
text
@d34 7
d51 4
d79 6
d134 9
d207 12
d248 6
d275 2
@


1.1
log
@add a man page for the VOP functions.  currently only describes the
general idea and VOP_LOOKUP.

ok costa@@ deraadt@@ jmc@@
@
text
@d34 16
d55 38
d104 1
d114 27
d152 1
a152 1
is locked upon a succesful return.
d158 53
d214 1
a214 1
functions return 0 to indicate success and a non zero error code
@

