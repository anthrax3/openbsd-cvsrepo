head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.12
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.44
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.42
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.40
	OPENBSD_5_0:1.10.0.38
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.36
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.34
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.30
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.32
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.28
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.26
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.24
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.22
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.20
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.18
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.16
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.14
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.12
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.10
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9;
locks; strict;
comment	@# @;


1.13
date	2014.07.19.18.15.53;	author miod;	state Exp;
branches;
next	1.12;
commitid	OGSfM7iSPZcNFY83;

1.12
date	2013.08.01.20.43.07;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.14.22.38.50;	author halex;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.02.19.56.55;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.01.10.15;	author marc;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.03.16.54.38;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.03.02.20.29;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.01.47.23;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.01.46.43;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.03.01.01.51;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.03.00.28.28;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.02.03.27.54;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.01.22.54.28;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Explicitely check the value of REGRESS_SKIP_SLOW rather than its emptyness,
for it defaults to a non-empty value; Doug Hogan
@
text
@# $OpenBSD: bsd.regress.mk,v 1.12 2013/08/01 20:43:07 kettenis Exp $
# Documented in bsd.regress.mk(5)

# No man pages for regression tests.
NOMAN=

# No installation.
install:

# If REGRESS_TARGETS is defined and PROG is not defined, set NOPROG
.if defined(REGRESS_TARGETS) && !defined(PROG)
NOPROG=
.endif

.include <bsd.prog.mk>

.MAIN: all
all: regress

# Check for deprecated REGRESS* variables and assign them to the
# new versions if the new version is not already defined. 
_REGRESS_DEPRECATED=LOG:LOG SKIPTARGETS:SKIP_TARGETS SKIPSLOW:SKIP_SLOW \
	SKIP:SKIP TARGETS:TARGETS MAXTIME:MAXTIME ROOTTARGETS:ROOT_TARGETS

.for _I in ${_REGRESS_DEPRECATED}
_REGRESS_OLD=REGRESS${_I:C/\:.*//}
_REGRESS_NEW=REGRESS_${_I:C/.*\://}
.  if defined(${_REGRESS_OLD})
ERRORS:= ${ERRORS} "Warning: ${_REGRESS_OLD} is deprecated, use ${_REGRESS_NEW} instead."
.    if !defined(${_REGRESS_NEW})
${_REGRESS_NEW}:=${${_REGRESS_OLD}}
.    endif
.  endif
.endfor

# XXX - Need full path to REGRESS_LOG, otherwise there will be much pain.
REGRESS_LOG?=/dev/null
REGRESS_SKIP_TARGETS?=
REGRESS_SKIP_SLOW?=no
REGRESS_FAIL_EARLY?=no

_REGRESS_NAME=${.CURDIR:S/${BSDSRCDIR}\/regress\///}
_REGRESS_TMP?=/dev/null
_REGRESS_OUT= | tee -a ${REGRESS_LOG} ${_REGRESS_TMP} 2>&1 > /dev/null

.if defined(PROG) && !empty(PROG)
run-regress-${PROG}: ${PROG}
	./${PROG}
.endif

.if defined(PROG) && !defined(REGRESS_TARGETS)
REGRESS_TARGETS=run-regress-${PROG}
.  if defined(REGRESS_SKIP)
REGRESS_SKIP_TARGETS=run-regress-${PROG}
.  endif
.endif

.if defined(REGRESS_SLOW_TARGETS) && ${REGRESS_SKIP_SLOW} != no
REGRESS_SKIP_TARGETS+=${REGRESS_SLOW_TARGETS}
.endif

.if ${REGRESS_FAIL_EARLY} != no
_SKIP_FAIL=
.else
_SKIP_FAIL=-
.endif

.if defined(REGRESS_ROOT_TARGETS)
_ROOTUSER!=id -g
SUDO?=
.  if (${_ROOTUSER} != 0) && empty(SUDO)
REGRESS_SKIP_TARGETS+=${REGRESS_ROOT_TARGETS}
.  endif
.endif

.if defined(ERRORS)
.BEGIN:
.  for _m in ${ERRORS}
	@@echo 1>&2 ${_m}
.  endfor
.  if !empty(ERRORS:M"Fatal\:*") || !empty(ERRORS:M'Fatal\:*')
	@@exit 1
.  endif
.endif 

regress: .SILENT
.if ! ${REGRESS_LOG:M/*}
	echo =========================================================
	echo REGRESS_LOG must contain an absolute path to the log-file.
	echo It currently points to: ${REGRESS_LOG}
	echo =========================================================
	exit 1
.endif
.for RT in ${REGRESS_TARGETS} 
.  if ${REGRESS_SKIP_TARGETS:M${RT}}
	@@echo -n "SKIP " ${_REGRESS_OUT}
.  else
# XXX - we need a better method to see if a test fails due to timeout or just
#       normal failure.
.   if !defined(REGRESS_MAXTIME)
	${_SKIP_FAIL}if cd ${.CURDIR} && ${MAKE} ${RT}; then \
	    echo -n "SUCCESS " ${_REGRESS_OUT} ; \
	else \
	    echo -n "FAIL " ${_REGRESS_OUT} ; \
	    echo FAILED ; \
	    false; \
	fi
.   else
	${_SKIP_FAIL}if cd ${.CURDIR} && \
	    (ulimit -t ${REGRESS_MAXTIME} ; ${MAKE} ${RT}); then \
	    echo -n "SUCCESS " ${_REGRESS_OUT} ; \
	else \
	    echo -n "FAIL (possible timeout) " ${_REGRESS_OUT} ; \
	    echo FAILED ; \
	    false; \
	fi
.   endif
.  endif
	@@echo ${_REGRESS_NAME}/${RT:S/^run-regress-//} ${_REGRESS_OUT}
.endfor

.PHONY: regress
@


1.12
log
@Don't error out if there are no regression for a particular architecture in
a subdirectory.
@
text
@d1 1
a1 1
# $OpenBSD: bsd.regress.mk,v 1.11 2013/06/14 22:38:50 halex Exp $
d58 1
a58 1
.if defined(REGRESS_SLOW_TARGETS) && !empty(REGRESS_SKIP_SLOW)
@


1.11
log
@introduce REGRESS_FAIL_EARLY to stop regression tests at first
encountered failure

ok phessler@@ bluhm@@
@
text
@d1 1
a1 1
# $OpenBSD: bsd.regress.mk,v 1.10 2002/09/02 19:56:55 avsm Exp $
d51 1
a51 1
.if !defined(REGRESS_TARGETS)
@


1.10
log
@- Precede internal bsd.regress.mk variables with a _
- Rename old variables to be easier to read, and deprecate old
variables.  The old variables will still work, but emit warnings.
- REGRESS_SKIP_SLOW only needs to be non-empty now, not explicitly
set to 'yes'
- REGRESS_LOG can contain more than one file to append results to
- ERRORS variable can be set in Makefile to emit warnings or indicate
fatal errors.
- Add REGRESS_MAIL variable which can be set to an email address to
send results to.  Currently this only works for a full regression
run, since art doesnt want partial run results
- sync bsd.regress.mk(5) with these changes

ok art@@ , also looked over by miod@@
@
text
@d1 1
a1 1
# $OpenBSD: bsd.regress.mk,v 1.9 2002/02/17 01:10:15 marc Exp $
d40 1
d62 6
d101 1
a101 1
	-if cd ${.CURDIR} && ${MAKE} ${RT}; then \
d106 1
d109 2
a110 1
	-if cd ${.CURDIR} && (ulimit -t ${REGRESS_MAXTIME} ; ${MAKE} ${RT}); then \
d115 1
@


1.9
log
@skip tests that require root (REGRESSROOTTARGETS) unless
the user is root or SUDO is not empty.  OK art@@
@
text
@d1 3
a3 1
#	$OpenBSD: bsd.regress.mk,v 1.8 2002/01/03 16:54:38 brad Exp $
d10 2
a11 2
# If REGRESSTARGETS is defined and PROG is not defined, set NOPROG
.if defined(REGRESSTARGETS) && !defined(PROG)
d20 15
a34 1
# XXX - Need full path to REGRESSLOG, otherwise there will be much pain.
d36 8
a43 2
REGRESSLOG?=/dev/null
REGRESSNAME=${.CURDIR:S/${BSDSRCDIR}\/regress\///}
d50 4
a53 4
.if !defined(REGRESSTARGETS)
REGRESSTARGETS=run-regress-${PROG}
.  if defined(REGRESSSKIP)
REGRESSSKIPTARGETS=run-regress-${PROG}
d57 2
a58 4
REGRESSSKIPSLOW?=no

.if (${REGRESSSKIPSLOW:L} == "yes") && defined(REGRESSSLOWTARGETS)
REGRESSSKIPTARGETS+=${REGRESSSLOWTARGETS}
d61 2
a62 2
.if defined(REGRESSROOTTARGETS)
ROOTUSER!=id -g
d64 3
a66 3
. if (${ROOTUSER} != 0) && empty(SUDO)
REGRESSSKIPTARGETS+=${REGRESSROOTTARGETS}
. endif
d69 9
a77 1
REGRESSSKIPTARGETS?=
d79 11
a89 4
regress:
.for RT in ${REGRESSTARGETS} 
.  if ${REGRESSSKIPTARGETS:M${RT}}
	@@echo -n "SKIP " >> ${REGRESSLOG}
d93 3
a95 3
.   if !defined(REGRESSMAXTIME)
	@@if cd ${.CURDIR} && ${MAKE} ${RT}; then \
	    echo -n "SUCCESS " >> ${REGRESSLOG} ; \
d97 1
a97 1
	    echo -n "FAIL " >> ${REGRESSLOG} ; \
d101 2
a102 2
	@@if cd ${.CURDIR} && (ulimit -t ${REGRESSMAXTIME} ; ${MAKE} ${RT}); then \
	    echo -n "SUCCESS " >> ${REGRESSLOG} ; \
d104 1
a104 1
	    echo -n "FAIL (possible timeout) " >> ${REGRESSLOG} ; \
d109 1
a109 1
	@@echo ${REGRESSNAME}/${RT:S/^run-regress-//} >> ${REGRESSLOG}
@


1.8
log
@use :L variable modifier
@
text
@d1 1
a1 1
#	$OpenBSD: bsd.regress.mk,v 1.7 2002/01/03 02:20:29 art Exp $
d39 8
@


1.7
log
@make regress the main target
(now that dependencies are correct)
@
text
@d1 1
a1 1
#	$OpenBSD: bsd.regress.mk,v 1.6 2002/01/03 01:47:23 art Exp $
d37 1
a37 1
.if (${REGRESSSKIPSLOW} == "yes") && defined(REGRESSSLOWTARGETS)
@


1.6
log
@OpenBSD tag
@
text
@d1 1
a1 1
#	$OpenBSD$
d14 3
@


1.5
log
@s/timeout/possible timeout/ the test could simply fail.
@
text
@d1 1
@


1.4
log
@Two new variables.
 REGRESSSLOWTARGETS, contains a list of all regress targets that are slow.
 REGRESSSKIPSLOW, settable to "yes"/"no" (default is "no") when running
  regress. Skips slow tests.

(*for some arbitrary and very subjective value of "slow")
@
text
@d57 1
a57 1
	    echo -n "FAIL (timeout) " >> ${REGRESSLOG} ; \
@


1.3
log
@Support for a new variable REGRESSMAXTIME that sets the cpu time
ulimit for tests. Needed for libc_r tests.
With some help from marc@@
@
text
@d31 6
@


1.2
log
@Eh? Why could I finish a make build with this 6 hours ago?
@
text
@d20 1
a20 1
run-regress-${PROG}: ./${PROG}
d38 3
d43 1
a43 1
    	else \
d47 8
@


1.1
log
@Start for a framework for regression tests. Simplifies the most common
regress test targets, provides logging of success/failure and various
minor features.

Much Makefile magic from espie@@ who thinks that my shell programming skills
are "atrocious" (and I agree).
@
text
@d7 1
a7 2
# If REGRESSTARGETS is defined and PROG is not defined, set a dummy
# PROG
d9 1
a9 1
PROG=
@

