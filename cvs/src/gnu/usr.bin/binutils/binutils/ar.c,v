head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.8;
commitid	dbwlUkpK0xDlII16;

1.8
date	2004.11.02.20.45.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.22.45.16;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.28;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.33.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.02.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.41;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.41;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.49.23;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.13.18;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.15.31;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.00;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.14.04;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* ar.c - Archive modify and extract.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
   Bugs: should use getopt the way tar does (complete w/optional -) and
   should have long options too. GNU ar used to check file against filesystem
   in quick_update and replace operations (would check mtime). Doesn't warn
   when name truncated. No way to specify pos_end. Error messages should be
   more consistent.  */

#include "bfd.h"
#include "libiberty.h"
#include "progress.h"
#include "bucomm.h"
#include "aout/ar.h"
#include "libbfd.h"
#include "arsup.h"
#include "filenames.h"
#include "binemul.h"
#include <sys/stat.h>

#ifdef __GO32___
#define EXT_NAME_LEN 3		/* bufflen of addition to name if it's MS-DOS */
#else
#define EXT_NAME_LEN 6		/* ditto for *NIX */
#endif

/* We need to open files in binary modes on system where that makes a
   difference.  */
#ifndef O_BINARY
#define O_BINARY 0
#endif

#define BUFSIZE 8192

/* Kludge declaration from BFD!  This is ugly!  FIXME!  XXX */

struct ar_hdr *
  bfd_special_undocumented_glue (bfd * abfd, const char *filename);

/* Static declarations */

static void mri_emul (void);
static const char *normalize (const char *, bfd *);
static void remove_output (void);
static void map_over_members (bfd *, void (*)(bfd *), char **, int);
static void print_contents (bfd * member);
static void delete_members (bfd *, char **files_to_delete);

#if 0
static void do_quick_append
  (const char *archive_filename, char **files_to_append);
#endif

static void move_members (bfd *, char **files_to_move);
static void replace_members
  (bfd *, char **files_to_replace, bfd_boolean quick);
static void print_descr (bfd * abfd);
static void write_archive (bfd *);
static void ranlib_only (const char *archname);
static void ranlib_touch (const char *archname);
static void usage (int);

/** Globals and flags */

int mri_mode;

/* This flag distinguishes between ar and ranlib:
   1 means this is 'ranlib'; 0 means this is 'ar'.
   -1 means if we should use argv[0] to decide.  */
extern int is_ranlib;

/* Nonzero means don't warn about creating the archive file if necessary.  */
int silent_create = 0;

/* Nonzero means describe each action performed.  */
int verbose = 0;

/* Nonzero means preserve dates of members when extracting them.  */
int preserve_dates = 0;

/* Nonzero means don't replace existing members whose dates are more recent
   than the corresponding files.  */
int newer_only = 0;

/* Controls the writing of an archive symbol table (in BSD: a __.SYMDEF
   member).  -1 means we've been explicitly asked to not write a symbol table;
   +1 means we've been explicitly asked to write it;
   0 is the default.
   Traditionally, the default in BSD has been to not write the table.
   However, for POSIX.2 compliance the default is now to write a symbol table
   if any of the members are object files.  */
int write_armap = 0;

/* Nonzero means it's the name of an existing member; position new or moved
   files with respect to this one.  */
char *posname = NULL;

/* Sez how to use `posname': pos_before means position before that member.
   pos_after means position after that member. pos_end means always at end.
   pos_default means default appropriately. For the latter two, `posname'
   should also be zero.  */
enum pos
  {
    pos_default, pos_before, pos_after, pos_end
  } postype = pos_default;

static bfd **
get_pos_bfd (bfd **, enum pos, const char *);

/* For extract/delete only.  If COUNTED_NAME_MODE is TRUE, we only
   extract the COUNTED_NAME_COUNTER instance of that name.  */
static bfd_boolean counted_name_mode = 0;
static int counted_name_counter = 0;

/* Whether to truncate names of files stored in the archive.  */
static bfd_boolean ar_truncate = FALSE;

/* Whether to use a full file name match when searching an archive.
   This is convenient for archives created by the Microsoft lib
   program.  */
static bfd_boolean full_pathname = FALSE;

int interactive = 0;

static void
mri_emul (void)
{
  interactive = isatty (fileno (stdin));
  yyparse ();
}

/* If COUNT is 0, then FUNCTION is called once on each entry.  If nonzero,
   COUNT is the length of the FILES chain; FUNCTION is called on each entry
   whose name matches one in FILES.  */

static void
map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)
{
  bfd *head;
  int match_count;

  if (count == 0)
    {
      for (head = arch->next; head; head = head->next)
	{
	  PROGRESS (1);
	  function (head);
	}
      return;
    }

  /* This may appear to be a baroque way of accomplishing what we want.
     However we have to iterate over the filenames in order to notice where
     a filename is requested but does not exist in the archive.  Ditto
     mapping over each file each time -- we want to hack multiple
     references.  */

  for (; count > 0; files++, count--)
    {
      bfd_boolean found = FALSE;

      match_count = 0;
      for (head = arch->next; head; head = head->next)
	{
	  PROGRESS (1);
	  if (head->filename == NULL)
	    {
	      /* Some archive formats don't get the filenames filled in
		 until the elements are opened.  */
	      struct stat buf;
	      bfd_stat_arch_elt (head, &buf);
	    }
	  if ((head->filename != NULL) &&
	      (!FILENAME_CMP (normalize (*files, arch), head->filename)))
	    {
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter)
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		  continue;
		}

	      found = TRUE;
	      function (head);
	    }
	}
      if (!found)
	/* xgettext:c-format */
	fprintf (stderr, _("no entry %s in archive\n"), *files);
    }
}

bfd_boolean operation_alters_arch = FALSE;

static void
usage (int help)
{
  FILE *s;

  s = help ? stdout : stderr;

  if (! is_ranlib)
    {
      /* xgettext:c-format */
      fprintf (s, _("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
	       program_name);
      /* xgettext:c-format */
      fprintf (s, _("       %s -M [<mri-script]\n"), program_name);
      fprintf (s, _(" commands:\n"));
      fprintf (s, _("  d            - delete file(s) from the archive\n"));
      fprintf (s, _("  m[ab]        - move file(s) in the archive\n"));
      fprintf (s, _("  p            - print file(s) found in the archive\n"));
      fprintf (s, _("  q[f]         - quick append file(s) to the archive\n"));
      fprintf (s, _("  r[ab][f][u]  - replace existing or insert new file(s) into the archive\n"));
      fprintf (s, _("  t            - display contents of archive\n"));
      fprintf (s, _("  x[o]         - extract file(s) from the archive\n"));
      fprintf (s, _(" command specific modifiers:\n"));
      fprintf (s, _("  [a]          - put file(s) after [member-name]\n"));
      fprintf (s, _("  [b]          - put file(s) before [member-name] (same as [i])\n"));
      fprintf (s, _("  [N]          - use instance [count] of name\n"));
      fprintf (s, _("  [f]          - truncate inserted file names\n"));
      fprintf (s, _("  [P]          - use full path names when matching\n"));
      fprintf (s, _("  [o]          - preserve original dates\n"));
      fprintf (s, _("  [u]          - only replace files that are newer than current archive contents\n"));
      fprintf (s, _(" generic modifiers:\n"));
      fprintf (s, _("  [c]          - do not warn if the library had to be created\n"));
      fprintf (s, _("  [s]          - create an archive index (cf. ranlib)\n"));
      fprintf (s, _("  [S]          - do not build a symbol table\n"));
      fprintf (s, _("  [v]          - be verbose\n"));
      fprintf (s, _("  [V]          - display the version number\n"));

      ar_emul_usage (s);
    }
  else
    {
      /* xgettext:c-format */
      fprintf (s, _("Usage: %s [options] archive\n"), program_name);
      fprintf (s, _(" Generate an index to speed access to archives\n"));
      fprintf (s, _(" The options are:\n\
  -h --help                    Print this help message\n\
  -V --version                 Print version information\n"));
    }

  list_supported_targets (program_name, stderr);

  if (help)
    fprintf (s, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  xexit (help ? 0 : 1);
}

/* Normalize a file name specified on the command line into a file
   name which we will use in an archive.  */

static const char *
normalize (const char *file, bfd *abfd)
{
  const char *filename;

  if (full_pathname)
    return file;

  filename = strrchr (file, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
  if (filename != (char *) NULL)
    filename++;
  else
    filename = file;

  if (ar_truncate
      && abfd != NULL
      && strlen (filename) > abfd->xvec->ar_max_namelen)
    {
      char *s;

      /* Space leak.  */
      s = (char *) xmalloc (abfd->xvec->ar_max_namelen + 1);
      memcpy (s, filename, abfd->xvec->ar_max_namelen);
      s[abfd->xvec->ar_max_namelen] = '\0';
      filename = s;
    }

  return filename;
}

/* Remove any output file.  This is only called via xatexit.  */

static const char *output_filename = NULL;
static FILE *output_file = NULL;
static bfd *output_bfd = NULL;

static void
remove_output (void)
{
  if (output_filename != NULL)
    {
      if (output_bfd != NULL)
	bfd_cache_close (output_bfd);
      if (output_file != NULL)
	fclose (output_file);
      unlink (output_filename);
    }
}

/* The option parsing should be in its own function.
   It will be when I have getopt working.  */

int main (int, char **);

int
main (int argc, char **argv)
{
  char *arg_ptr;
  char c;
  enum
    {
      none = 0, delete, replace, print_table,
      print_files, extract, move, quick_append
    } operation = none;
  int arg_index;
  char **files;
  int file_count;
  char *inarch_filename;
  int show_version;
  int i;
  int do_posix = 0;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  expandargv (&argc, &argv);

  if (is_ranlib < 0)
    {
      char *temp;

      temp = strrchr (program_name, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      {
	/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	char *bslash = strrchr (program_name, '\\');
	if (temp == NULL || (bslash != NULL && bslash > temp))
	  temp = bslash;
	if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	  temp = program_name + 1;
      }
#endif
      if (temp == NULL)
	temp = program_name;
      else
	++temp;
      if (strlen (temp) >= 6
	  && FILENAME_CMP (temp + strlen (temp) - 6, "ranlib") == 0)
	is_ranlib = 1;
      else
	is_ranlib = 0;
    }

  if (argc > 1 && argv[1][0] == '-')
    {
      if (strcmp (argv[1], "--help") == 0)
	usage (1);
      else if (strcmp (argv[1], "--version") == 0)
	{
	  if (is_ranlib)
	    print_version ("ranlib");
	  else
	    print_version ("ar");
	}
    }

  START_PROGRESS (program_name, 0);

  bfd_init ();
  set_default_bfd_target ();

  show_version = 0;

  xatexit (remove_output);

  for (i = 1; i < argc; i++)
    if (! ar_emul_parse_arg (argv[i]))
      break;
  argv += (i - 1);
  argc -= (i - 1);

  if (is_ranlib)
    {
      bfd_boolean touch = FALSE;

      if (argc < 2
	  || strcmp (argv[1], "--help") == 0
	  || strcmp (argv[1], "-h") == 0
	  || strcmp (argv[1], "-H") == 0)
	usage (0);
      if (strcmp (argv[1], "-V") == 0
	  || strcmp (argv[1], "-v") == 0
	  || strncmp (argv[1], "--v", 3) == 0)
	print_version ("ranlib");
      arg_index = 1;
      if (strcmp (argv[1], "-t") == 0)
	{
	  ++arg_index;
	  touch = TRUE;
	}
      while (arg_index < argc)
	{
	  if (! touch)
	    ranlib_only (argv[arg_index]);
	  else
	    ranlib_touch (argv[arg_index]);
	  ++arg_index;
	}
      xexit (0);
    }

  if (argc == 2 && strcmp (argv[1], "-M") == 0)
    {
      mri_emul ();
      xexit (0);
    }

  if (argc < 2)
    usage (0);

  arg_index = 1;
  arg_ptr = argv[arg_index];

  if (*arg_ptr == '-')
    {
      /* When the first option starts with '-' we support POSIX-compatible
	 option parsing.  */
      do_posix = 1;
      ++arg_ptr;			/* compatibility */
    }

  do
    {
      while ((c = *arg_ptr++) != '\0')
	{
	  switch (c)
	    {
	    case 'd':
	    case 'm':
	    case 'p':
	    case 'q':
	    case 'r':
	    case 't':
	    case 'x':
	      if (operation != none)
		fatal (_("two different operation options specified"));
	      switch (c)
		{
		case 'd':
		  operation = delete;
		  operation_alters_arch = TRUE;
		  break;
		case 'm':
		  operation = move;
		  operation_alters_arch = TRUE;
		  break;
		case 'p':
		  operation = print_files;
		  break;
		case 'q':
		  operation = quick_append;
		  operation_alters_arch = TRUE;
		  break;
		case 'r':
		  operation = replace;
		  operation_alters_arch = TRUE;
		  break;
		case 't':
		  operation = print_table;
		  break;
		case 'x':
		  operation = extract;
		  break;
		}
	    case 'l':
	      break;
	    case 'c':
	      silent_create = 1;
	      break;
	    case 'o':
	      preserve_dates = 1;
	      break;
	    case 'V':
	      show_version = TRUE;
	      break;
	    case 's':
	      write_armap = 1;
	      break;
	    case 'S':
	      write_armap = -1;
	      break;
	    case 'u':
	      newer_only = 1;
	      break;
	    case 'v':
	      verbose = 1;
	      break;
	    case 'a':
	      postype = pos_after;
	      break;
	    case 'b':
	      postype = pos_before;
	      break;
	    case 'i':
	      postype = pos_before;
	      break;
	    case 'M':
	      mri_mode = 1;
	      break;
	    case 'N':
	      counted_name_mode = TRUE;
	      break;
	    case 'f':
	      ar_truncate = TRUE;
	      break;
	    case 'P':
	      full_pathname = TRUE;
	      break;
	    default:
	      /* xgettext:c-format */
	      non_fatal (_("illegal option -- %c"), c);
	      usage (0);
	    }
	}

      /* With POSIX-compatible option parsing continue with the next
	 argument if it starts with '-'.  */
      if (do_posix && arg_index + 1 < argc && argv[arg_index + 1][0] == '-')
	arg_ptr = argv[++arg_index] + 1;
      else
	do_posix = 0;
    }
  while (do_posix);

  if (show_version)
    print_version ("ar");

  ++arg_index;
  if (arg_index >= argc)
    usage (0);

  if (mri_mode)
    {
      mri_emul ();
    }
  else
    {
      bfd *arch;

      /* We can't write an armap when using ar q, so just do ar r
         instead.  */
      if (operation == quick_append && write_armap)
	operation = replace;

      if ((operation == none || operation == print_table)
	  && write_armap == 1)
	{
	  ranlib_only (argv[arg_index]);
	  xexit (0);
	}

      if (operation == none)
	fatal (_("no operation specified"));

      if (newer_only && operation != replace)
	fatal (_("`u' is only meaningful with the `r' option."));

      if (postype != pos_default)
	posname = argv[arg_index++];

      if (counted_name_mode)
	{
	  if (operation != extract && operation != delete)
	     fatal (_("`N' is only meaningful with the `x' and `d' options."));
	  counted_name_counter = atoi (argv[arg_index++]);
	  if (counted_name_counter <= 0)
	    fatal (_("Value for `N' must be positive."));
	}

      inarch_filename = argv[arg_index++];

      files = arg_index < argc ? argv + arg_index : NULL;
      file_count = argc - arg_index;

#if 0
      /* We don't use do_quick_append any more.  Too many systems
         expect ar to always rebuild the symbol table even when q is
         used.  */

      /* We can't do a quick append if we need to construct an
	 extended name table, because do_quick_append won't be able to
	 rebuild the name table.  Unfortunately, at this point we
	 don't actually know the maximum name length permitted by this
	 object file format.  So, we guess.  FIXME.  */
      if (operation == quick_append && ! ar_truncate)
	{
	  char **chk;

	  for (chk = files; chk != NULL && *chk != '\0'; chk++)
	    {
	      if (strlen (normalize (*chk, (bfd *) NULL)) > 14)
		{
		  operation = replace;
		  break;
		}
	    }
	}

      if (operation == quick_append)
	{
	  /* Note that quick appending to a non-existent archive creates it,
	     even if there are no files to append.  */
	  do_quick_append (inarch_filename, files);
	  xexit (0);
	}
#endif

      arch = open_inarch (inarch_filename,
			  files == NULL ? (char *) NULL : files[0]);

      switch (operation)
	{
	case print_table:
	  map_over_members (arch, print_descr, files, file_count);
	  break;

	case print_files:
	  map_over_members (arch, print_contents, files, file_count);
	  break;

	case extract:
	  map_over_members (arch, extract_file, files, file_count);
	  break;

	case delete:
	  if (files != NULL)
	    delete_members (arch, files);
	  else
	    output_filename = NULL;
	  break;

	case move:
	  if (files != NULL)
	    move_members (arch, files);
	  else
	    output_filename = NULL;
	  break;

	case replace:
	case quick_append:
	  if (files != NULL || write_armap > 0)
	    replace_members (arch, files, operation == quick_append);
	  else
	    output_filename = NULL;
	  break;

	  /* Shouldn't happen! */
	default:
	  /* xgettext:c-format */
	  fatal (_("internal error -- this option not implemented"));
	}
    }

  END_PROGRESS (program_name);

  xexit (0);
  return 0;
}

bfd *
open_inarch (const char *archive_filename, const char *file)
{
  const char *target;
  bfd **last_one;
  bfd *next_one;
  struct stat sbuf;
  bfd *arch;
  char **matching;

  bfd_set_error (bfd_error_no_error);

  target = NULL;

  if (stat (archive_filename, &sbuf) != 0)
    {
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2. -- EZ.  */

/* KLUDGE ALERT! Temporary fix until I figger why
   stat() is wrong ... think it's buried in GO32's IDT - Jax */
      if (errno != ENOENT)
	bfd_fatal (archive_filename);
#endif

      if (!operation_alters_arch)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (archive_filename);
	  maybequit ();
	  return NULL;
	}

      /* Try to figure out the target to use for the archive from the
         first object on the list.  */
      if (file != NULL)
	{
	  bfd *obj;

	  obj = bfd_openr (file, NULL);
	  if (obj != NULL)
	    {
	      if (bfd_check_format (obj, bfd_object))
		target = bfd_get_target (obj);
	      (void) bfd_close (obj);
	    }
	}

      /* Create an empty archive.  */
      arch = bfd_openw (archive_filename, target);
      if (arch == NULL
	  || ! bfd_set_format (arch, bfd_archive)
	  || ! bfd_close (arch))
	bfd_fatal (archive_filename);
      else if (!silent_create)
        non_fatal (_("creating %s"), archive_filename);

      /* If we die creating a new archive, don't leave it around.  */
      output_filename = archive_filename;
    }

  arch = bfd_openr (archive_filename, target);
  if (arch == NULL)
    {
    bloser:
      bfd_fatal (archive_filename);
    }

  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archive_filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

  last_one = &(arch->next);
  /* Read all the contents right away, regardless.  */
  for (next_one = bfd_openr_next_archived_file (arch, NULL);
       next_one;
       next_one = bfd_openr_next_archived_file (arch, next_one))
    {
      PROGRESS (1);
      *last_one = next_one;
      last_one = &next_one->next;
    }
  *last_one = (bfd *) NULL;
  if (bfd_get_error () != bfd_error_no_more_archived_files)
    goto bloser;
  return arch;
}

static void
print_contents (bfd *abfd)
{
  int ncopied = 0;
  char *cbuf = xmalloc (BUFSIZE);
  struct stat buf;
  long size;
  if (bfd_stat_arch_elt (abfd, &buf) != 0)
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));

  if (verbose)
    /* xgettext:c-format */
    printf (_("\n<%s>\n\n"), bfd_get_filename (abfd));

  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);

  size = buf.st_size;
  while (ncopied < size)
    {

      int nread;
      int tocopy = size - ncopied;
      if (tocopy > BUFSIZE)
	tocopy = BUFSIZE;

      nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
      if (nread != tocopy)
	/* xgettext:c-format */
	fatal (_("%s is not a valid archive"),
	       bfd_get_filename (bfd_my_archive (abfd)));
      fwrite (cbuf, 1, nread, stdout);
      ncopied += tocopy;
    }
  free (cbuf);
}

/* Extract a member of the archive into its own file.

   We defer opening the new file until after we have read a BUFSIZ chunk of the
   old one, since we know we have just read the archive header for the old
   one.  Since most members are shorter than BUFSIZ, this means we will read
   the old header, read the old data, write a new inode for the new file, and
   write the new data, and be done. This 'optimization' is what comes from
   sitting next to a bare disk and hearing it every time it seeks.  -- Gnu
   Gilmore  */

void
extract_file (bfd *abfd)
{
  FILE *ostream;
  char *cbuf = xmalloc (BUFSIZE);
  int nread, tocopy;
  long ncopied = 0;
  long size;
  struct stat buf;

  if (bfd_stat_arch_elt (abfd, &buf) != 0)
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
  size = buf.st_size;

  if (size < 0)
    /* xgettext:c-format */
    fatal (_("stat returns negative size for %s"), bfd_get_filename (abfd));

  if (verbose)
    printf ("x - %s\n", bfd_get_filename (abfd));

  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);

  ostream = NULL;
  if (size == 0)
    {
      /* Seems like an abstraction violation, eh?  Well it's OK! */
      output_filename = bfd_get_filename (abfd);

      ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
      if (ostream == NULL)
	{
	  perror (bfd_get_filename (abfd));
	  xexit (1);
	}

      output_file = ostream;
    }
  else
    while (ncopied < size)
      {
	tocopy = size - ncopied;
	if (tocopy > BUFSIZE)
	  tocopy = BUFSIZE;

	nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
	if (nread != tocopy)
	  /* xgettext:c-format */
	  fatal (_("%s is not a valid archive"),
		 bfd_get_filename (bfd_my_archive (abfd)));

	/* See comment above; this saves disk arm motion */
	if (ostream == NULL)
	  {
	    /* Seems like an abstraction violation, eh?  Well it's OK! */
	    output_filename = bfd_get_filename (abfd);

	    ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
	    if (ostream == NULL)
	      {
		perror (bfd_get_filename (abfd));
		xexit (1);
	      }

	    output_file = ostream;
	  }
	fwrite (cbuf, 1, nread, ostream);
	ncopied += tocopy;
      }

  if (ostream != NULL)
    fclose (ostream);

  output_file = NULL;
  output_filename = NULL;

  chmod (bfd_get_filename (abfd), buf.st_mode);

  if (preserve_dates)
    set_times (bfd_get_filename (abfd), &buf);

  free (cbuf);
}

#if 0

/* We don't use this anymore.  Too many systems expect ar to rebuild
   the symbol table even when q is used.  */

/* Just do it quickly; don't worry about dups, armap, or anything like that */

static void
do_quick_append (const char *archive_filename, char **files_to_append)
{
  FILE *ofile, *ifile;
  char *buf = xmalloc (BUFSIZE);
  long tocopy, thistime;
  bfd *temp;
  struct stat sbuf;
  bfd_boolean newfile = FALSE;
  bfd_set_error (bfd_error_no_error);

  if (stat (archive_filename, &sbuf) != 0)
    {

#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2.

	 (And yes, I know this is all unused, but somebody, someday,
	 might wish to resurrect this again... -- EZ.  */

/* KLUDGE ALERT! Temporary fix until I figger why
   stat() is wrong ... think it's buried in GO32's IDT - Jax  */

      if (errno != ENOENT)
	bfd_fatal (archive_filename);
#endif

      newfile = TRUE;
    }

  ofile = fopen (archive_filename, FOPEN_AUB);
  if (ofile == NULL)
    {
      perror (program_name);
      xexit (1);
    }

  temp = bfd_openr (archive_filename, NULL);
  if (temp == NULL)
    {
      bfd_fatal (archive_filename);
    }
  if (!newfile)
    {
      if (!bfd_check_format (temp, bfd_archive))
	/* xgettext:c-format */
	fatal (_("%s is not an archive"), archive_filename);
    }
  else
    {
      fwrite (ARMAG, 1, SARMAG, ofile);
      if (!silent_create)
	/* xgettext:c-format */
	non_fatal (_("creating %s"), archive_filename);
    }

  if (ar_truncate)
    temp->flags |= BFD_TRADITIONAL_FORMAT;

  /* assume it's an archive, go straight to the end, sans $200 */
  fseek (ofile, 0, 2);

  for (; files_to_append && *files_to_append; ++files_to_append)
    {
      struct ar_hdr *hdr = bfd_special_undocumented_glue (temp, *files_to_append);
      if (hdr == NULL)
	{
	  bfd_fatal (*files_to_append);
	}

      BFD_SEND (temp, _bfd_truncate_arname, (temp, *files_to_append, (char *) hdr));

      ifile = fopen (*files_to_append, FOPEN_RB);
      if (ifile == NULL)
	{
	  bfd_nonfatal (*files_to_append);
	}

      if (stat (*files_to_append, &sbuf) != 0)
	{
	  bfd_nonfatal (*files_to_append);
	}

      tocopy = sbuf.st_size;

      /* XXX should do error-checking! */
      fwrite (hdr, 1, sizeof (struct ar_hdr), ofile);

      while (tocopy > 0)
	{
	  thistime = tocopy;
	  if (thistime > BUFSIZE)
	    thistime = BUFSIZE;
	  fread (buf, 1, thistime, ifile);
	  fwrite (buf, 1, thistime, ofile);
	  tocopy -= thistime;
	}
      fclose (ifile);
      if ((sbuf.st_size % 2) == 1)
	putc ('\012', ofile);
    }
  fclose (ofile);
  bfd_close (temp);
  free (buf);
}

#endif /* 0 */

static void
write_archive (bfd *iarch)
{
  bfd *obfd;
  char *old_name, *new_name;
  bfd *contents_head = iarch->next;

  old_name = xmalloc (strlen (bfd_get_filename (iarch)) + 1);
  strcpy (old_name, bfd_get_filename (iarch));
  new_name = make_tempname (old_name, 0);

  output_filename = new_name;

  obfd = bfd_openw (new_name, bfd_get_target (iarch));

  if (obfd == NULL)
    bfd_fatal (old_name);

  output_bfd = obfd;

  bfd_set_format (obfd, bfd_archive);

  /* Request writing the archive symbol table unless we've
     been explicitly requested not to.  */
  obfd->has_armap = write_armap >= 0;

  if (ar_truncate)
    {
      /* This should really use bfd_set_file_flags, but that rejects
         archives.  */
      obfd->flags |= BFD_TRADITIONAL_FORMAT;
    }

  if (!bfd_set_archive_head (obfd, contents_head))
    bfd_fatal (old_name);

  if (!bfd_close (obfd))
    bfd_fatal (old_name);

  output_bfd = NULL;
  output_filename = NULL;

  /* We don't care if this fails; we might be creating the archive.  */
  bfd_close (iarch);

  if (smart_rename (new_name, old_name, 0) != 0)
    xexit (1);
}

/* Return a pointer to the pointer to the entry which should be rplacd'd
   into when altering.  DEFAULT_POS should be how to interpret pos_default,
   and should be a pos value.  */

static bfd **
get_pos_bfd (bfd **contents, enum pos default_pos, const char *default_posname)
{
  bfd **after_bfd = contents;
  enum pos realpos;
  const char *realposname;

  if (postype == pos_default)
    {
      realpos = default_pos;
      realposname = default_posname;
    }
  else
    {
      realpos = postype;
      realposname = posname;
    }

  if (realpos == pos_end)
    {
      while (*after_bfd)
	after_bfd = &((*after_bfd)->next);
    }
  else
    {
      for (; *after_bfd; after_bfd = &(*after_bfd)->next)
	if (FILENAME_CMP ((*after_bfd)->filename, realposname) == 0)
	  {
	    if (realpos == pos_after)
	      after_bfd = &(*after_bfd)->next;
	    break;
	  }
    }
  return after_bfd;
}

static void
delete_members (bfd *arch, char **files_to_delete)
{
  bfd **current_ptr_ptr;
  bfd_boolean found;
  bfd_boolean something_changed = FALSE;
  int match_count;

  for (; *files_to_delete != NULL; ++files_to_delete)
    {
      /* In a.out systems, the armap is optional.  It's also called
	 __.SYMDEF.  So if the user asked to delete it, we should remember
	 that fact. This isn't quite right for COFF systems (where
	 __.SYMDEF might be regular member), but it's very unlikely
	 to be a problem.  FIXME */

      if (!strcmp (*files_to_delete, "__.SYMDEF"))
	{
	  arch->has_armap = FALSE;
	  write_armap = -1;
	  continue;
	}

      found = FALSE;
      match_count = 0;
      current_ptr_ptr = &(arch->next);
      while (*current_ptr_ptr)
	{
	  if (FILENAME_CMP (normalize (*files_to_delete, arch),
			    (*current_ptr_ptr)->filename) == 0)
	    {
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter)
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		}
	      else
		{
		  found = TRUE;
		  something_changed = TRUE;
		  if (verbose)
		    printf ("d - %s\n",
			    *files_to_delete);
		  *current_ptr_ptr = ((*current_ptr_ptr)->next);
		  goto next_file;
		}
	    }

	  current_ptr_ptr = &((*current_ptr_ptr)->next);
	}

      if (verbose && !found)
	{
	  /* xgettext:c-format */
	  printf (_("No member named `%s'\n"), *files_to_delete);
	}
    next_file:
      ;
    }

  if (something_changed)
    write_archive (arch);
  else
    output_filename = NULL;
}


/* Reposition existing members within an archive */

static void
move_members (bfd *arch, char **files_to_move)
{
  bfd **after_bfd;		/* New entries go after this one */
  bfd **current_ptr_ptr;	/* cdr pointer into contents */

  for (; *files_to_move; ++files_to_move)
    {
      current_ptr_ptr = &(arch->next);
      while (*current_ptr_ptr)
	{
	  bfd *current_ptr = *current_ptr_ptr;
	  if (FILENAME_CMP (normalize (*files_to_move, arch),
			    current_ptr->filename) == 0)
	    {
	      /* Move this file to the end of the list - first cut from
		 where it is.  */
	      bfd *link;
	      *current_ptr_ptr = current_ptr->next;

	      /* Now glue to end */
	      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);
	      link = *after_bfd;
	      *after_bfd = current_ptr;
	      current_ptr->next = link;

	      if (verbose)
		printf ("m - %s\n", *files_to_move);

	      goto next_file;
	    }

	  current_ptr_ptr = &((*current_ptr_ptr)->next);
	}
      /* xgettext:c-format */
      fatal (_("no entry %s in archive %s!"), *files_to_move, arch->filename);

    next_file:;
    }

  write_archive (arch);
}

/* Ought to default to replacing in place, but this is existing practice!  */

static void
replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)
{
  bfd_boolean changed = FALSE;
  bfd **after_bfd;		/* New entries go after this one */
  bfd *current;
  bfd **current_ptr;

  while (files_to_move && *files_to_move)
    {
      if (! quick)
	{
	  current_ptr = &arch->next;
	  while (*current_ptr)
	    {
	      current = *current_ptr;

	      /* For compatibility with existing ar programs, we
		 permit the same file to be added multiple times.  */
	      if (FILENAME_CMP (normalize (*files_to_move, arch),
				normalize (current->filename, arch)) == 0
		  && current->arelt_data != NULL)
		{
		  if (newer_only)
		    {
		      struct stat fsbuf, asbuf;

		      if (stat (*files_to_move, &fsbuf) != 0)
			{
			  if (errno != ENOENT)
			    bfd_fatal (*files_to_move);
			  goto next_file;
			}
		      if (bfd_stat_arch_elt (current, &asbuf) != 0)
			/* xgettext:c-format */
			fatal (_("internal stat error on %s"),
			       current->filename);

		      if (fsbuf.st_mtime <= asbuf.st_mtime)
			goto next_file;
		    }

		  after_bfd = get_pos_bfd (&arch->next, pos_after,
					   current->filename);
		  if (ar_emul_replace (after_bfd, *files_to_move,
				       verbose))
		    {
		      /* Snip out this entry from the chain.  */
		      *current_ptr = (*current_ptr)->next;
		      changed = TRUE;
		    }

		  goto next_file;
		}
	      current_ptr = &(current->next);
	    }
	}

      /* Add to the end of the archive.  */
      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);

      if (get_file_size (* files_to_move) > 0
	  && ar_emul_append (after_bfd, *files_to_move, verbose))
	changed = TRUE;

    next_file:;

      files_to_move++;
    }

  if (changed)
    write_archive (arch);
  else
    output_filename = NULL;
}

static void
ranlib_only (const char *archname)
{
  bfd *arch;

  if (get_file_size (archname) < 1)
    return;
  write_armap = 1;
  arch = open_inarch (archname, (char *) NULL);
  if (arch == NULL)
    xexit (1);
  write_archive (arch);
}

/* Update the timestamp of the symbol map of an archive.  */

static void
ranlib_touch (const char *archname)
{
#ifdef __GO32__
  /* I don't think updating works on go32.  */
  ranlib_only (archname);
#else
  int f;
  bfd *arch;
  char **matching;

  if (get_file_size (archname) < 1)
    return;
  f = open (archname, O_RDWR | O_BINARY, 0);
  if (f < 0)
    {
      bfd_set_error (bfd_error_system_call);
      bfd_fatal (archname);
    }

  arch = bfd_fdopenr (archname, (const char *) NULL, f);
  if (arch == NULL)
    bfd_fatal (archname);
  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archname);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

  if (! bfd_has_map (arch))
    /* xgettext:c-format */
    fatal (_("%s: no archive map to update"), archname);

  bfd_update_armap_timestamp (arch);

  if (! bfd_close (arch))
    bfd_fatal (archname);
#endif
}

/* Things which are interesting to map over all or some of the files: */

static void
print_descr (bfd *abfd)
{
  print_arelt_descr (stdout, abfd, verbose);
}
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d370 2
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002
d27 1
a27 1
   more consistant.  */
d57 1
a57 1
  bfd_special_undocumented_glue PARAMS ((bfd * abfd, const char *filename));
d61 6
a66 17
static void
mri_emul PARAMS ((void));

static const char *
normalize PARAMS ((const char *, bfd *));

static void
remove_output PARAMS ((void));

static void
map_over_members PARAMS ((bfd *, void (*)(bfd *), char **, int));

static void
print_contents PARAMS ((bfd * member));

static void
delete_members PARAMS ((bfd *, char **files_to_delete));
d69 2
a70 3
static void
do_quick_append PARAMS ((const char *archive_filename,
			 char **files_to_append));
d73 8
a80 20
static void
move_members PARAMS ((bfd *, char **files_to_move));

static void
replace_members PARAMS ((bfd *, char **files_to_replace, bfd_boolean quick));

static void
print_descr PARAMS ((bfd * abfd));

static void
write_archive PARAMS ((bfd *));

static void
ranlib_only PARAMS ((const char *archname));

static void
ranlib_touch PARAMS ((const char *archname));

static void
usage PARAMS ((int));
d106 1
a106 1
   +1 means we've been explictly asked to write it;
d127 1
a127 1
get_pos_bfd PARAMS ((bfd **, enum pos, const char *));
d145 1
a145 1
mri_emul ()
d156 1
a156 5
map_over_members (arch, function, files, count)
     bfd *arch;
     void (*function) PARAMS ((bfd *));
     char **files;
     int count;
d217 1
a217 2
usage (help)
     int help;
d277 1
a277 3
normalize (file, abfd)
     const char *file;
     bfd *abfd;
d323 1
a323 1
remove_output ()
d327 2
a328 2
      if (output_bfd != NULL && output_bfd->iostream != NULL)
	fclose ((FILE *) (output_bfd->iostream));
d338 1
a338 1
int main PARAMS ((int, char **));
d341 1
a341 3
main (argc, argv)
     int argc;
     char **argv;
d356 1
d463 2
a464 1
  arg_ptr = argv[1];
d467 6
a472 1
    ++arg_ptr;			/* compatibility */
d474 1
a474 1
  while ((c = *arg_ptr++) != '\0')
d476 1
a476 1
      switch (c)
a477 9
	case 'd':
	case 'm':
	case 'p':
	case 'q':
	case 'r':
	case 't':
	case 'x':
	  if (operation != none)
	    fatal (_("two different operation options specified"));
d481 58
a538 2
	      operation = delete;
	      operation_alters_arch = TRUE;
d540 5
a544 3
	    case 'm':
	      operation = move;
	      operation_alters_arch = TRUE;
d546 2
a547 2
	    case 'p':
	      operation = print_files;
d549 2
a550 3
	    case 'q':
	      operation = quick_append;
	      operation_alters_arch = TRUE;
d552 2
a553 3
	    case 'r':
	      operation = replace;
	      operation_alters_arch = TRUE;
d555 2
a556 2
	    case 't':
	      operation = print_table;
d558 2
a559 2
	    case 'x':
	      operation = extract;
d561 4
a565 48
	case 'l':
	  break;
	case 'c':
	  silent_create = 1;
	  break;
	case 'o':
	  preserve_dates = 1;
	  break;
	case 'V':
	  show_version = TRUE;
	  break;
	case 's':
	  write_armap = 1;
	  break;
	case 'S':
	  write_armap = -1;
	  break;
	case 'u':
	  newer_only = 1;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case 'a':
	  postype = pos_after;
	  break;
	case 'b':
	  postype = pos_before;
	  break;
	case 'i':
	  postype = pos_before;
	  break;
	case 'M':
	  mri_mode = 1;
	  break;
	case 'N':
	  counted_name_mode = TRUE;
	  break;
	case 'f':
	  ar_truncate = TRUE;
	  break;
	case 'P':
	  full_pathname = TRUE;
	  break;
	default:
	  /* xgettext:c-format */
	  non_fatal (_("illegal option -- %c"), c);
	  usage (0);
d567 7
d575 1
d580 2
a581 1
  if (argc < 3)
d600 1
a600 1
	  ranlib_only (argv[2]);
a609 2
      arg_index = 2;

d713 1
a713 3
open_inarch (archive_filename, file)
     const char *archive_filename;
     const char *file;
d770 2
d812 1
a812 2
print_contents (abfd)
     bfd *abfd;
d824 1
a824 1
    printf (_("\n<member %s>\n\n"), bfd_get_filename (abfd));
d859 1
a859 2
extract_file (abfd)
     bfd *abfd;
d951 1
a951 3
do_quick_append (archive_filename, files_to_append)
     const char *archive_filename;
     char **files_to_append;
d1013 1
a1013 1
  /* assume it's an achive, go straight to the end, sans $200 */
d1063 1
a1063 2
write_archive (iarch)
     bfd *iarch;
d1116 1
a1116 4
get_pos_bfd (contents, default_pos, default_posname)
     bfd **contents;
     enum pos default_pos;
     const char *default_posname;
d1152 1
a1152 3
delete_members (arch, files_to_delete)
     bfd *arch;
     char **files_to_delete;
d1223 1
a1223 3
move_members (arch, files_to_move)
     bfd *arch;
     char **files_to_move;
d1268 1
a1268 4
replace_members (arch, files_to_move, quick)
     bfd *arch;
     char **files_to_move;
     bfd_boolean quick;
d1327 3
a1329 1
      if (ar_emul_append (after_bfd, *files_to_move, verbose))
d1344 1
a1344 2
ranlib_only (archname)
     const char *archname;
d1348 2
d1360 1
a1360 2
ranlib_touch (archname)
     const char *archname;
d1370 2
d1407 1
a1407 2
print_descr (abfd)
     bfd *abfd;
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 2
a28 2
   more consistant.
*/
d37 1
d89 1
a89 1
replace_members PARAMS ((bfd *, char **files_to_replace, boolean quick));
d153 1
a153 1
/* For extract/delete only.  If COUNTED_NAME_MODE is true, we only
d155 1
a155 1
static boolean counted_name_mode = 0;
d159 1
a159 1
static boolean ar_truncate = false;
d164 1
a164 1
static boolean full_pathname = false;
d207 1
a207 1
      boolean found = false;
d225 1
a225 1
		  && match_count != counted_name_counter) 
d232 1
a232 1
	      found = true;
d242 1
a242 1
boolean operation_alters_arch = false;
d251 1
a251 1
  
d255 1
a255 1
      fprintf (s, _("Usage: %s [-X32_64] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
d281 2
a282 1
      fprintf (s, _("  [-X32_64]    - (ignored)\n"));
d285 8
a292 2
    /* xgettext:c-format */
    fprintf (s, _("Usage: %s [-vV] archive\n"), program_name);
d369 2
d388 1
d393 3
d408 8
a415 8
	{
	  /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	  char *bslash = strrchr (program_name, '\\');
	  if (temp == NULL || (bslash != NULL && bslash > temp))
	    temp = bslash;
	  if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	    temp = program_name + 1;
	}
d450 5
a454 10
  /* Ignored for (partial) AIX compatibility.  On AIX,
     the -X option can be used to ignore certain kinds
     of object files in the archive (the 64-bit objects
     or the 32-bit objects).  GNU ar always looks at all
     kinds of objects in an archive.  */
  while (argc > 1 && strcmp (argv[1], "-X32_64") == 0)
    {
      argv++;
      argc--;
    }
d458 1
a458 1
      boolean touch = false;
d460 4
a463 1
      if (argc < 2 || strcmp (argv[1], "--help") == 0)
d473 1
a473 1
	  touch = true;
d517 1
a517 1
	      operation_alters_arch = true;
d521 1
a521 1
	      operation_alters_arch = true;
d528 1
a528 1
	      operation_alters_arch = true;
d532 1
a532 1
	      operation_alters_arch = true;
d550 1
a550 1
	  show_version = true;
d577 1
a577 1
	  counted_name_mode = true;
d580 1
a580 1
	  ar_truncate = true;
d583 1
a583 1
	  full_pathname = true;
d629 1
a629 1
      if (counted_name_mode) 
d631 1
a631 1
          if (operation != extract && operation != delete) 
d634 1
a634 1
          if (counted_name_counter <= 0)
d670 1
a670 1
	     even if there are no files to append. */
d843 1
a843 1
  bfd_seek (abfd, 0, SEEK_SET);
d854 1
a854 2
      nread = bfd_read (cbuf, 1, tocopy, abfd);	/* oops -- broke
							   abstraction!  */
d885 1
a885 1
  
d894 1
a894 1
  
d898 1
a898 1
  bfd_seek (abfd, 0, SEEK_SET);
d922 1
a922 1
	nread = bfd_read (cbuf, 1, tocopy, abfd);
d978 1
a978 1
  boolean newfile = false;
d1001 1
a1001 1
      newfile = true;
d1016 1
a1016 1
  if (newfile == false)
d1018 1
a1018 1
      if (bfd_check_format (temp, bfd_archive) != true)
d1116 1
a1116 1
  if (bfd_set_archive_head (obfd, contents_head) != true)
d1181 2
a1182 2
  boolean found;
  boolean something_changed = false;
d1195 1
a1195 1
	  arch->has_armap = false;
d1200 1
a1200 1
      found = false;
d1206 1
a1206 1
		      (*current_ptr_ptr)->filename) == 0)
d1210 1
a1210 1
		  && match_count != counted_name_counter) 
d1217 2
a1218 2
		  found = true;
		  something_changed = true;
d1230 1
a1230 1
      if (verbose && found == false)
d1239 1
a1239 1
  if (something_changed == true)
d1299 1
a1299 1
     boolean quick;
d1301 1
a1301 1
  boolean changed = false;
a1304 1
  bfd *temp;
d1333 2
a1334 1
			fatal (_("internal stat error on %s"), current->filename);
d1342 2
a1343 13
		  temp = *after_bfd;

		  *after_bfd = bfd_openr (*files_to_move, NULL);
		  if (*after_bfd == (bfd *) NULL)
		    {
		      bfd_fatal (*files_to_move);
		    }
		  (*after_bfd)->next = temp;

		  /* snip out this entry from the chain */
		  *current_ptr = (*current_ptr)->next;

		  if (verbose)
d1345 3
a1347 1
		      printf ("r - %s\n", *files_to_move);
a1349 2
		  changed = true;

a1356 1

d1358 2
a1359 14
      temp = *after_bfd;
      *after_bfd = bfd_openr (*files_to_move, NULL);
      if (*after_bfd == (bfd *) NULL)
	{
	  bfd_fatal (*files_to_move);
	}
      if (verbose)
	{
	  printf ("a - %s\n", *files_to_move);
	}

      (*after_bfd)->next = temp;

      changed = true;
@


1.5
log
@Change make_tempname() interface to create file or directory when needed.
Use the new interface to call safe mkstemp or mkdtemp when available.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d253 1
a253 1
      fprintf (s, _("Usage: %s [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
d279 1
d311 1
a311 1
    if (bslash > filename)
d314 1
a314 1
	filename = file + 1;
d396 1
a396 1
	  if (bslash > temp)
d435 11
d827 2
a828 1
    printf ("\n<%s>\n\n", bfd_get_filename (abfd));
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1067 1
a1067 1
  new_name = make_tempname (old_name);
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d35 1
a37 8
#ifdef HAVE_GOOD_UTIME_H
#include <utime.h>
#else /* ! HAVE_GOOD_UTIME_H */
#ifdef HAVE_UTIMES
#include <sys/time.h>
#endif /* HAVE_UTIMES */
#endif /* ! HAVE_GOOD_UTIME_H */

d44 6
d55 1
a55 1
  bfd_special_undocumented_glue PARAMS ((bfd * abfd, char *filename));
d57 4
a60 1
/* Forward declarations */
d148 8
d159 5
d166 1
a166 1
void
d185 1
d196 1
d207 1
d219 1
a219 1
	      (!strcmp (*files, head->filename)))
d221 9
d235 2
a236 1
	fprintf (stderr, "no entry %s in archive\n", *files);
d249 1
d251 29
a279 4
    fprintf (s, "\
Usage: %s [-]{dmpqrtx}[abcilosuvV] [member-name] archive-file file...\n\
       %s -M [<mri-script]\n",
	     program_name, program_name);
d281 2
a282 2
    fprintf (s, "\
Usage: %s [-vV] archive\n", program_name);
d287 1
a287 1
    fprintf (s, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d302 3
d306 10
d339 1
a339 1
static char *output_filename = NULL;
d373 1
d377 6
d391 10
d406 1
a406 1
	  && strcmp (temp + strlen (temp) - 6, "ranlib") == 0)
d428 2
d487 1
a487 1
	    fatal ("two different operation options specified");
d530 3
d551 3
d557 3
d561 2
a562 1
	  fprintf (stderr, "%s: illegal option -- %c\n", program_name, c);
d594 1
a594 1
	fatal ("no operation specified");
d597 1
a597 1
	fatal ("`u' is only meaningful with the `r' option.");
d604 9
d616 1
d657 1
a657 1
	  map_over_members (arch, print_descr, files, argc - 3);
d661 1
a661 1
	  map_over_members (arch, print_contents, files, argc - 3);
d665 1
a665 1
	  map_over_members (arch, extract_file, files, argc - 3);
d671 2
d678 2
d686 2
d692 2
a693 3
	  fprintf (stderr, "%s: internal error -- this option not implemented\n",
		   program_name);
	  xexit (1);
d721 1
a721 1
      bfd *obj;
d723 4
a726 1
#ifndef __GO32__
d729 1
a729 3
 * stat() is wrong ... think it's buried in GO32's IDT
 * - Jax
 */
d744 1
a744 2
      obj = bfd_openr (file, NULL);
      if (obj != NULL)
d746 9
a754 3
	  if (bfd_check_format (obj, bfd_object))
	    target = bfd_get_target (obj);
	  (void) bfd_close (obj);
d763 3
d811 2
a812 1
    fatal ("internal stat error on %s", bfd_get_filename (abfd));
d815 1
a815 1
    printf ("\n<member %s>\n\n", bfd_get_filename (abfd));
d831 2
a832 1
	fatal ("%s is not a valid archive",
d857 1
a857 1
  int ncopied = 0;
d860 1
d862 2
a863 1
    fatal ("internal stat error on %s", bfd_get_filename (abfd));
d866 4
d875 1
a875 1
  ostream = 0;
d882 1
a882 1
      if (!ostream)
d899 2
a900 1
	  fatal ("%s is not a valid archive",
d904 1
a904 1
	if (!ostream)
d910 1
a910 1
	    if (!ostream)
d922 2
a923 1
  fclose (ostream);
d931 3
a933 23
    {
#ifdef HAVE_GOOD_UTIME_H
      struct utimbuf tb;
      tb.actime = buf.st_mtime;
      tb.modtime = buf.st_mtime;
      utime (bfd_get_filename (abfd), &tb);	/* FIXME check result */
#else /* ! HAVE_GOOD_UTIME_H */
#ifndef HAVE_UTIMES
      long tb[2];
      tb[0] = buf.st_mtime;
      tb[1] = buf.st_mtime;
      utime (bfd_get_filename (abfd), tb);	/* FIXME check result */
#else /* HAVE_UTIMES */
      struct timeval tv[2];
      tv[0].tv_sec = buf.st_mtime;
      tv[0].tv_usec = 0;
      tv[1].tv_sec = buf.st_mtime;
      tv[1].tv_usec = 0;
      utimes (bfd_get_filename (abfd), tv);	/* FIXME check result */
#endif /* HAVE_UTIMES */
#endif /* ! HAVE_GOOD_UTIME_H */
    }
free (cbuf);
d959 9
a967 1
#ifndef __GO32__
d970 1
a970 3
 * stat() is wrong ... think it's buried in GO32's IDT
 * - Jax
 */
d994 2
a995 1
	fatal ("%s is not an archive", archive_filename);
d1001 2
a1002 2
	fprintf (stderr, "%s: creating %s\n",
		 program_name, archive_filename);
a1101 1
  unlink (old_name);
d1103 2
a1104 2
  if (rename (new_name, old_name) != 0)
    bfd_fatal (old_name);
d1111 2
a1112 2
bfd **
get_pos_bfd (contents, default_pos)
d1115 1
d1118 13
a1130 1
  enum pos realpos = (postype == pos_default ? default_pos : postype);
d1140 1
a1140 1
	if (!strcmp ((*after_bfd)->filename, posname))
d1158 2
d1176 1
d1180 2
a1181 1
	  if (strcmp (*files_to_delete, (*current_ptr_ptr)->filename) == 0)
d1183 17
a1199 11
	      found = true;
	      something_changed = true;
	      if (verbose)
		printf ("d - %s\n",
			*files_to_delete);
	      *current_ptr_ptr = ((*current_ptr_ptr)->next);
	      goto next_file;
	    }
	  else
	    {
	      current_ptr_ptr = &((*current_ptr_ptr)->next);
d1201 2
d1207 2
a1208 1
	  printf ("No member named `%s'\n", *files_to_delete);
d1215 3
a1217 3
    {
      write_archive (arch);
    }
d1237 2
a1238 2
	  if (strcmp (normalize (*files_to_move, arch),
		      current_ptr->filename) == 0)
d1246 1
a1246 1
	      after_bfd = get_pos_bfd (&arch->next, pos_end);
d1259 3
a1261 3
      fprintf (stderr, "%s: no entry %s in archive %s!\n",
	       program_name, *files_to_move, arch->filename);
      xexit (1);
d1293 2
a1294 2
	      if (strcmp (normalize (*files_to_move, arch),
			  normalize (current->filename, arch)) == 0
d1308 2
a1309 1
			fatal ("internal stat error on %s", current->filename);
d1315 3
a1317 2
		  /* snip out this entry from the chain */
		  *current_ptr = current->next;
a1318 2
		  after_bfd = get_pos_bfd (&arch->next, pos_end);
		  temp = *after_bfd;
d1326 3
d1344 1
a1344 1
      after_bfd = get_pos_bfd (&arch->next, pos_end);
d1367 2
d1398 1
a1398 1
  f = open (archname, O_RDWR, 0);
d1420 2
a1421 1
    fatal ("%s: no archive map to update", archname);
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94 Free Software Foundation, Inc.
d97 3
d213 3
a215 4
extern char *program_version;

void
do_show_version ()
d217 1
a217 3
  printf ("GNU %s version %s\n", program_name, program_version);
  xexit (0);
}
d219 3
a221 5
void
usage ()
{
  if (is_ranlib == 0)
    fprintf (stderr, "\
d226 1
a226 1
    fprintf (stderr, "\
d228 1
d230 5
a234 1
  xexit (1);
a305 1
  char *temp;
d311 29
d347 1
a347 6
  temp = strrchr (program_name, '/');
  if (temp == (char *) NULL)
    temp = program_name;	/* shouldn't happen, but... */
  else
    ++temp;
  if (is_ranlib > 0 || (is_ranlib < 0 && strcmp (temp, "ranlib") == 0))
d351 2
a352 3
      is_ranlib = 1;
      if (argc < 2)
	usage ();
d356 1
a356 1
	do_show_version ();
a372 2
  else
    is_ranlib = 0;
d381 1
a381 1
    usage ();
d466 1
a466 1
	  usage ();
d471 1
a471 1
    do_show_version ();
d474 1
a474 1
    usage ();
@


1.1
log
@Initial revision
@
text
@d521 2
a522 1
      arch = open_inarch (inarch_filename);
d569 1
a569 1
open_inarch (archive_filename)
d571 1
d573 1
d578 1
d582 2
d586 1
d606 10
d617 1
a617 1
      arch = bfd_openw (archive_filename, NULL);
d624 1
a624 1
  arch = bfd_openr (archive_filename, NULL);
d631 11
a641 2
  if (bfd_check_format (arch, bfd_archive) != true)
    fatal ("%s is not an archive", archive_filename);
d1207 1
a1207 1
  arch = open_inarch (archname);
d1225 1
d1235 1
a1235 2
  if (arch == NULL
      || ! bfd_check_format (arch, bfd_archive))
d1237 10
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d521 1
a521 2
      arch = open_inarch (inarch_filename,
			  files == NULL ? (char *) NULL : files[0]);
d568 1
a568 1
open_inarch (archive_filename, file)
a569 1
     const char *file;
a570 1
  const char *target;
a574 1
  char **matching;
a577 2
  target = NULL;

a579 1
      bfd *obj;
a598 10
      /* Try to figure out the target to use for the archive from the
         first object on the list.  */
      obj = bfd_openr (file, NULL);
      if (obj != NULL)
	{
	  if (bfd_check_format (obj, bfd_object))
	    target = bfd_get_target (obj);
	  (void) bfd_close (obj);
	}

d600 1
a600 1
      arch = bfd_openw (archive_filename, target);
d607 1
a607 1
  arch = bfd_openr (archive_filename, target);
d614 2
a615 11
  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archive_filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

d1181 1
a1181 1
  arch = open_inarch (archname, (char *) NULL);
a1198 1
  char **matching;
d1208 2
a1209 1
  if (arch == NULL)
a1210 10
  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archname);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a96 3

static void
usage PARAMS ((int));
d210 4
a213 3
static void
usage (help)
     int help;
d215 3
a217 1
  FILE *s;
d219 5
a223 3
  s = help ? stdout : stderr;
  if (! is_ranlib)
    fprintf (s, "\
d228 1
a228 1
    fprintf (s, "\
a229 1

d231 1
a231 5

  if (help)
    fprintf (s, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");

  xexit (help ? 0 : 1);
d303 1
a308 29
  if (is_ranlib < 0)
    {
      char *temp;

      temp = strrchr (program_name, '/');
      if (temp == NULL)
	temp = program_name;
      else
	++temp;
      if (strlen (temp) >= 6
	  && strcmp (temp + strlen (temp) - 6, "ranlib") == 0)
	is_ranlib = 1;
      else
	is_ranlib = 0;
    }

  if (argc > 1 && argv[1][0] == '-')
    {
      if (strcmp (argv[1], "--help") == 0)
	usage (1);
      else if (strcmp (argv[1], "--version") == 0)
	{
	  if (is_ranlib)
	    print_version ("ranlib");
	  else
	    print_version ("ar");
	}
    }

d316 6
a321 1
  if (is_ranlib)
d325 3
a327 2
      if (argc < 2 || strcmp (argv[1], "--help") == 0)
	usage (0);
d331 1
a331 1
	print_version ("ranlib");
d348 2
d358 1
a358 1
    usage (0);
d443 1
a443 1
	  usage (0);
d448 1
a448 1
    print_version ("ar");
d451 1
a451 1
    usage (0);
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d57 1
a57 4
/* Static declarations */

static void
mri_emul PARAMS ((void));
a144 3
static bfd **
get_pos_bfd PARAMS ((bfd **, enum pos));

d150 1
a150 1
static void
a342 2
  set_default_bfd_target ();

d609 2
d631 2
a632 1
      if (file != NULL)
d634 3
a636 9
	  bfd *obj;

	  obj = bfd_openr (file, NULL);
	  if (obj != NULL)
	    {
	      if (bfd_check_format (obj, bfd_object))
		target = bfd_get_target (obj);
	      (void) bfd_close (obj);
	    }
d994 1
a994 1
static bfd **
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a33 1
#include "filenames.h"
d36 8
a49 6
/* We need to open files in binary modes on system where that makes a
   difference.  */
#ifndef O_BINARY
#define O_BINARY 0
#endif

d55 1
a55 1
  bfd_special_undocumented_glue PARAMS ((bfd * abfd, const char *filename));
d149 1
a149 6
get_pos_bfd PARAMS ((bfd **, enum pos, const char *));

/* For extract/delete only.  If COUNTED_NAME_MODE is true, we only
   extract the COUNTED_NAME_COUNTER instance of that name.  */
static boolean counted_name_mode = 0;
static int counted_name_counter = 0;
a153 5
/* Whether to use a full file name match when searching an archive.
   This is convenient for archives created by the Microsoft lib
   program.  */
static boolean full_pathname = false;

a174 1
  int match_count;
a184 1

a194 1
      match_count = 0;
d206 1
a206 1
	      (!FILENAME_CMP (normalize (*files, arch), head->filename)))
a207 9
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter) 
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		  continue;
		}

d213 1
a213 2
	/* xgettext:c-format */
	fprintf (stderr, _("no entry %s in archive\n"), *files);
a225 1
  
d227 4
a230 29
    {
      /* xgettext:c-format */
      fprintf (s, _("Usage: %s [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
	       program_name);
      /* xgettext:c-format */
      fprintf (s, _("       %s -M [<mri-script]\n"), program_name);
      fprintf (s, _(" commands:\n"));
      fprintf (s, _("  d            - delete file(s) from the archive\n"));
      fprintf (s, _("  m[ab]        - move file(s) in the archive\n"));
      fprintf (s, _("  p            - print file(s) found in the archive\n"));
      fprintf (s, _("  q[f]         - quick append file(s) to the archive\n"));
      fprintf (s, _("  r[ab][f][u]  - replace existing or insert new file(s) into the archive\n"));
      fprintf (s, _("  t            - display contents of archive\n"));
      fprintf (s, _("  x[o]         - extract file(s) from the archive\n"));
      fprintf (s, _(" command specific modifiers:\n"));
      fprintf (s, _("  [a]          - put file(s) after [member-name]\n"));
      fprintf (s, _("  [b]          - put file(s) before [member-name] (same as [i])\n"));
      fprintf (s, _("  [N]          - use instance [count] of name\n"));
      fprintf (s, _("  [f]          - truncate inserted file names\n"));
      fprintf (s, _("  [P]          - use full path names when matching\n"));
      fprintf (s, _("  [o]          - preserve original dates\n"));
      fprintf (s, _("  [u]          - only replace files that are newer than current archive contents\n"));
      fprintf (s, _(" generic modifiers:\n"));
      fprintf (s, _("  [c]          - do not warn if the library had to be created\n"));
      fprintf (s, _("  [s]          - create an archive index (cf. ranlib)\n"));
      fprintf (s, _("  [S]          - do not build a symbol table\n"));
      fprintf (s, _("  [v]          - be verbose\n"));
      fprintf (s, _("  [V]          - display the version number\n"));
    }
d232 2
a233 2
    /* xgettext:c-format */
    fprintf (s, _("Usage: %s [-vV] archive\n"), program_name);
d238 1
a238 1
    fprintf (s, _("Report bugs to %s\n"), REPORT_BUGS_TO);
a252 3
  if (full_pathname)
    return file;

a253 10
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
	filename = file + 1;
  }
#endif
d277 1
a277 1
static const char *output_filename = NULL;
a310 1
  int file_count;
a313 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

a321 10
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	{
	  /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	  char *bslash = strrchr (program_name, '\\');
	  if (bslash > temp)
	    temp = bslash;
	  if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	    temp = program_name + 1;
	}
#endif
d327 1
a327 1
	  && FILENAME_CMP (temp + strlen (temp) - 6, "ranlib") == 0)
d408 1
a408 1
	    fatal (_("two different operation options specified"));
a450 3
	case 'S':
	  write_armap = -1;
	  break;
a468 3
	case 'N':
	  counted_name_mode = true;
	  break;
a471 3
	case 'P':
	  full_pathname = true;
	  break;
d473 1
a473 2
	  /* xgettext:c-format */
	  non_fatal (_("illegal option -- %c"), c);
d505 1
a505 1
	fatal (_("no operation specified"));
d508 1
a508 1
	fatal (_("`u' is only meaningful with the `r' option."));
a514 9
      if (counted_name_mode) 
	{
          if (operation != extract && operation != delete) 
	     fatal (_("`N' is only meaningful with the `x' and `d' options."));
	  counted_name_counter = atoi (argv[arg_index++]);
          if (counted_name_counter <= 0)
	    fatal (_("Value for `N' must be positive."));
	}

a517 1
      file_count = argc - arg_index;
d558 1
a558 1
	  map_over_members (arch, print_descr, files, file_count);
d562 1
a562 1
	  map_over_members (arch, print_contents, files, file_count);
d566 1
a566 1
	  map_over_members (arch, extract_file, files, file_count);
a571 2
	  else
	    output_filename = NULL;
a576 2
	  else
	    output_filename = NULL;
a582 2
	  else
	    output_filename = NULL;
d587 3
a589 2
	  /* xgettext:c-format */
	  fatal (_("internal error -- this option not implemented"));
d617 1
a617 6
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2. -- EZ.  */
d620 3
a622 1
   stat() is wrong ... think it's buried in GO32's IDT - Jax */
a655 3

      /* If we die creating a new archive, don't leave it around.  */
      output_filename = archive_filename;
d701 1
a701 2
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
d704 1
a704 1
    printf ("\n<%s>\n\n", bfd_get_filename (abfd));
d720 1
a720 2
	/* xgettext:c-format */
	fatal (_("%s is not a valid archive"),
d745 1
a745 1
  long ncopied = 0;
a747 1
  
d749 1
a749 2
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
a751 4
  if (size < 0)
    /* xgettext:c-format */
    fatal (_("stat returns negative size for %s"), bfd_get_filename (abfd));
  
d757 1
a757 1
  ostream = NULL;
d764 1
a764 1
      if (ostream == NULL)
d781 1
a781 2
	  /* xgettext:c-format */
	  fatal (_("%s is not a valid archive"),
d785 1
a785 1
	if (ostream == NULL)
d791 1
a791 1
	    if (ostream == NULL)
d803 1
a803 2
  if (ostream != NULL)
    fclose (ostream);
d811 23
a833 3
    set_times (bfd_get_filename (abfd), &buf);

  free (cbuf);
d859 1
a859 9
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2.

	 (And yes, I know this is all unused, but somebody, someday,
	 might wish to resurrect this again... -- EZ.  */
d862 3
a864 1
   stat() is wrong ... think it's buried in GO32's IDT - Jax  */
d888 1
a888 2
	/* xgettext:c-format */
	fatal (_("%s is not an archive"), archive_filename);
d894 2
a895 2
	/* xgettext:c-format */
	non_fatal (_("creating %s"), archive_filename);
d995 1
d997 2
a998 2
  if (smart_rename (new_name, old_name, 0) != 0)
    xexit (1);
d1006 1
a1006 1
get_pos_bfd (contents, default_pos, default_posname)
a1008 1
     const char *default_posname;
d1011 1
a1011 13
  enum pos realpos;
  const char *realposname;

  if (postype == pos_default)
    {
      realpos = default_pos;
      realposname = default_posname;
    }
  else
    {
      realpos = postype;
      realposname = posname;
    }
d1021 1
a1021 1
	if (FILENAME_CMP ((*after_bfd)->filename, realposname) == 0)
a1038 2
  int match_count;

a1054 1
      match_count = 0;
d1058 1
a1058 2
	  if (FILENAME_CMP (normalize (*files_to_delete, arch),
		      (*current_ptr_ptr)->filename) == 0)
d1060 11
a1070 17
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter) 
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		}
	      else
		{
		  found = true;
		  something_changed = true;
		  if (verbose)
		    printf ("d - %s\n",
			    *files_to_delete);
		  *current_ptr_ptr = ((*current_ptr_ptr)->next);
		  goto next_file;
		}
a1071 2

	  current_ptr_ptr = &((*current_ptr_ptr)->next);
d1076 1
a1076 2
	  /* xgettext:c-format */
	  printf (_("No member named `%s'\n"), *files_to_delete);
d1083 3
a1085 3
    write_archive (arch);
  else
    output_filename = NULL;
d1105 2
a1106 2
	  if (FILENAME_CMP (normalize (*files_to_move, arch),
			    current_ptr->filename) == 0)
d1114 1
a1114 1
	      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);
d1127 3
a1129 3
      /* xgettext:c-format */
      fatal (_("no entry %s in archive %s!"), *files_to_move, arch->filename);

d1161 2
a1162 2
	      if (FILENAME_CMP (normalize (*files_to_move, arch),
				normalize (current->filename, arch)) == 0
d1176 1
a1176 2
			/* xgettext:c-format */
			fatal (_("internal stat error on %s"), current->filename);
d1182 4
a1185 2
		  after_bfd = get_pos_bfd (&arch->next, pos_after,
					   current->filename);
a1186 1

a1193 3
		  /* snip out this entry from the chain */
		  *current_ptr = (*current_ptr)->next;

d1209 1
a1209 1
      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);
a1231 2
  else
    output_filename = NULL;
d1261 1
a1261 1
  f = open (archname, O_RDWR | O_BINARY, 0);
d1283 1
a1283 2
    /* xgettext:c-format */
    fatal (_("%s: no archive map to update"), archname);
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d253 1
a253 1
      fprintf (s, _("Usage: %s [-X32_64] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
a278 1
      fprintf (s, _("  [-X32_64]    - (ignored)\n"));
d310 1
a310 1
    if (filename == NULL || (bslash != NULL && bslash > filename))
d313 1
a313 1
      filename = file + 1;
d395 1
a395 1
	  if (temp == NULL || (bslash != NULL && bslash > temp))
a433 11
  /* Ignored for (partial) AIX compatibility.  On AIX,
     the -X option can be used to ignore certain kinds
     of object files in the archive (the 64-bit objects
     or the 32-bit objects).  GNU ar always looks at all
     kinds of objects in an archive.  */
  while (argc > 1 && strcmp (argv[1], "-X32_64") == 0)
    {
      argv++;
      argc--;
    }

d815 1
a815 2
    /* xgettext:c-format */
    printf (_("\n<member %s>\n\n"), bfd_get_filename (abfd));
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002
d5 1
a5 1
   This file is part of GNU Binutils.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 2
a27 2
   more consistant.  */

a35 1
#include "binemul.h"
d87 1
a87 1
replace_members PARAMS ((bfd *, char **files_to_replace, bfd_boolean quick));
d151 1
a151 1
/* For extract/delete only.  If COUNTED_NAME_MODE is TRUE, we only
d153 1
a153 1
static bfd_boolean counted_name_mode = 0;
d157 1
a157 1
static bfd_boolean ar_truncate = FALSE;
d162 1
a162 1
static bfd_boolean full_pathname = FALSE;
d205 1
a205 1
      bfd_boolean found = FALSE;
d223 1
a223 1
		  && match_count != counted_name_counter)
d230 1
a230 1
	      found = TRUE;
d240 1
a240 1
bfd_boolean operation_alters_arch = FALSE;
d249 1
a249 1

d253 1
a253 1
      fprintf (s, _("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
d279 1
a279 2

      ar_emul_usage (s);
d282 2
a283 8
    {
      /* xgettext:c-format */
      fprintf (s, _("Usage: %s [options] archive\n"), program_name);
      fprintf (s, _(" Generate an index to speed access to archives\n"));
      fprintf (s, _(" The options are:\n\
  -h --help                    Print this help message\n\
  -V --version                 Print version information\n"));
    }
a359 2
int main PARAMS ((int, char **));

a376 1
  int i;
a380 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d393 8
a400 8
      {
	/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	char *bslash = strrchr (program_name, '\\');
	if (temp == NULL || (bslash != NULL && bslash > temp))
	  temp = bslash;
	if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	  temp = program_name + 1;
      }
d435 10
a444 5
  for (i = 1; i < argc; i++)
    if (! ar_emul_parse_arg (argv[i]))
      break;
  argv += (i - 1);
  argc -= (i - 1);
d448 1
a448 1
      bfd_boolean touch = FALSE;
d450 1
a450 4
      if (argc < 2
	  || strcmp (argv[1], "--help") == 0
	  || strcmp (argv[1], "-h") == 0
	  || strcmp (argv[1], "-H") == 0)
d460 1
a460 1
	  touch = TRUE;
d504 1
a504 1
	      operation_alters_arch = TRUE;
d508 1
a508 1
	      operation_alters_arch = TRUE;
d515 1
a515 1
	      operation_alters_arch = TRUE;
d519 1
a519 1
	      operation_alters_arch = TRUE;
d537 1
a537 1
	  show_version = TRUE;
d564 1
a564 1
	  counted_name_mode = TRUE;
d567 1
a567 1
	  ar_truncate = TRUE;
d570 1
a570 1
	  full_pathname = TRUE;
d616 1
a616 1
      if (counted_name_mode)
d618 1
a618 1
	  if (operation != extract && operation != delete)
d621 1
a621 1
	  if (counted_name_counter <= 0)
d657 1
a657 1
	     even if there are no files to append.  */
d830 1
a830 1
  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);
d841 2
a842 1
      nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
d873 1
a873 1

d882 1
a882 1

d886 1
a886 1
  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);
d910 1
a910 1
	nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
d966 1
a966 1
  bfd_boolean newfile = FALSE;
d989 1
a989 1
      newfile = TRUE;
d1004 1
a1004 1
  if (!newfile)
d1006 1
a1006 1
      if (!bfd_check_format (temp, bfd_archive))
d1104 1
a1104 1
  if (!bfd_set_archive_head (obfd, contents_head))
d1169 2
a1170 2
  bfd_boolean found;
  bfd_boolean something_changed = FALSE;
d1183 1
a1183 1
	  arch->has_armap = FALSE;
d1188 1
a1188 1
      found = FALSE;
d1194 1
a1194 1
			    (*current_ptr_ptr)->filename) == 0)
d1198 1
a1198 1
		  && match_count != counted_name_counter)
d1205 2
a1206 2
		  found = TRUE;
		  something_changed = TRUE;
d1218 1
a1218 1
      if (verbose && !found)
d1227 1
a1227 1
  if (something_changed)
d1287 1
a1287 1
     bfd_boolean quick;
d1289 1
a1289 1
  bfd_boolean changed = FALSE;
d1293 1
d1322 1
a1322 2
			fatal (_("internal stat error on %s"),
			       current->filename);
d1330 13
a1342 2
		  if (ar_emul_replace (after_bfd, *files_to_move,
				       verbose))
d1344 1
a1344 3
		      /* Snip out this entry from the chain.  */
		      *current_ptr = (*current_ptr)->next;
		      changed = TRUE;
d1347 2
d1356 1
d1358 14
a1371 2
      if (ar_emul_append (after_bfd, *files_to_move, verbose))
	changed = TRUE;
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d27 1
a27 1
   more consistent.  */
d57 1
a57 1
  bfd_special_undocumented_glue (bfd * abfd, const char *filename);
d61 17
a77 6
static void mri_emul (void);
static const char *normalize (const char *, bfd *);
static void remove_output (void);
static void map_over_members (bfd *, void (*)(bfd *), char **, int);
static void print_contents (bfd * member);
static void delete_members (bfd *, char **files_to_delete);
d80 3
a82 2
static void do_quick_append
  (const char *archive_filename, char **files_to_append);
d85 20
a104 8
static void move_members (bfd *, char **files_to_move);
static void replace_members
  (bfd *, char **files_to_replace, bfd_boolean quick);
static void print_descr (bfd * abfd);
static void write_archive (bfd *);
static void ranlib_only (const char *archname);
static void ranlib_touch (const char *archname);
static void usage (int);
d130 1
a130 1
   +1 means we've been explicitly asked to write it;
d151 1
a151 1
get_pos_bfd (bfd **, enum pos, const char *);
d169 1
a169 1
mri_emul (void)
d180 5
a184 1
map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)
d245 2
a246 1
usage (int help)
d306 3
a308 1
normalize (const char *file, bfd *abfd)
d354 1
a354 1
remove_output (void)
d358 2
a359 2
      if (output_bfd != NULL)
	bfd_cache_close (output_bfd);
d369 1
a369 1
int main (int, char **);
d372 3
a374 1
main (int argc, char **argv)
a388 1
  int do_posix = 0;
d495 1
a495 2
  arg_index = 1;
  arg_ptr = argv[arg_index];
d498 1
a498 6
    {
      /* When the first option starts with '-' we support POSIX-compatible
	 option parsing.  */
      do_posix = 1;
      ++arg_ptr;			/* compatibility */
    }
d500 1
a500 1
  do
d502 1
a502 1
      while ((c = *arg_ptr++) != '\0')
d504 9
d516 3
d520 3
d524 2
d527 3
d531 3
d535 2
d538 1
a538 52
	      if (operation != none)
		fatal (_("two different operation options specified"));
	      switch (c)
		{
		case 'd':
		  operation = delete;
		  operation_alters_arch = TRUE;
		  break;
		case 'm':
		  operation = move;
		  operation_alters_arch = TRUE;
		  break;
		case 'p':
		  operation = print_files;
		  break;
		case 'q':
		  operation = quick_append;
		  operation_alters_arch = TRUE;
		  break;
		case 'r':
		  operation = replace;
		  operation_alters_arch = TRUE;
		  break;
		case 't':
		  operation = print_table;
		  break;
		case 'x':
		  operation = extract;
		  break;
		}
	    case 'l':
	      break;
	    case 'c':
	      silent_create = 1;
	      break;
	    case 'o':
	      preserve_dates = 1;
	      break;
	    case 'V':
	      show_version = TRUE;
	      break;
	    case 's':
	      write_armap = 1;
	      break;
	    case 'S':
	      write_armap = -1;
	      break;
	    case 'u':
	      newer_only = 1;
	      break;
	    case 'v':
	      verbose = 1;
a539 25
	    case 'a':
	      postype = pos_after;
	      break;
	    case 'b':
	      postype = pos_before;
	      break;
	    case 'i':
	      postype = pos_before;
	      break;
	    case 'M':
	      mri_mode = 1;
	      break;
	    case 'N':
	      counted_name_mode = TRUE;
	      break;
	    case 'f':
	      ar_truncate = TRUE;
	      break;
	    case 'P':
	      full_pathname = TRUE;
	      break;
	    default:
	      /* xgettext:c-format */
	      non_fatal (_("illegal option -- %c"), c);
	      usage (0);
d541 48
a589 7

      /* With POSIX-compatible option parsing continue with the next
	 argument if it starts with '-'.  */
      if (do_posix && arg_index + 1 < argc && argv[arg_index + 1][0] == '-')
	arg_ptr = argv[++arg_index] + 1;
      else
	do_posix = 0;
a590 1
  while (do_posix);
d595 1
a595 2
  ++arg_index;
  if (arg_index >= argc)
d614 1
a614 1
	  ranlib_only (argv[arg_index]);
d624 2
d729 3
a731 1
open_inarch (const char *archive_filename, const char *file)
a787 2
      else if (!silent_create)
        non_fatal (_("creating %s"), archive_filename);
d828 2
a829 1
print_contents (bfd *abfd)
d841 1
a841 1
    printf (_("\n<%s>\n\n"), bfd_get_filename (abfd));
d876 2
a877 1
extract_file (bfd *abfd)
d969 3
a971 1
do_quick_append (const char *archive_filename, char **files_to_append)
d1033 1
a1033 1
  /* assume it's an archive, go straight to the end, sans $200 */
d1083 2
a1084 1
write_archive (bfd *iarch)
d1137 4
a1140 1
get_pos_bfd (bfd **contents, enum pos default_pos, const char *default_posname)
d1176 3
a1178 1
delete_members (bfd *arch, char **files_to_delete)
d1249 3
a1251 1
move_members (bfd *arch, char **files_to_move)
d1296 4
a1299 1
replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)
d1358 1
a1358 3

      if (get_file_size (* files_to_move) > 0
	  && ar_emul_append (after_bfd, *files_to_move, verbose))
d1373 2
a1374 1
ranlib_only (const char *archname)
a1377 2
  if (get_file_size (archname) < 1)
    return;
d1388 2
a1389 1
ranlib_touch (const char *archname)
a1398 2
  if (get_file_size (archname) < 1)
    return;
d1434 2
a1435 1
print_descr (bfd *abfd)
@


