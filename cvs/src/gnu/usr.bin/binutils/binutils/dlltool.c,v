head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.9;
commitid	dbwlUkpK0xDlII16;

1.9
date	2004.11.02.20.45.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.22.41.57;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.30;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.49;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.02.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.48.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.46;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.46;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.43;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.49.38;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.22;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.15.59;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.04;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.15.00;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.02;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* dlltool.c -- tool to generate stuff for PE style DLLs
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */


/* This program allows you to build the files necessary to create
   DLLs to run on a system which understands PE format image files.
   (eg, Windows NT)

   See "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9 for more information.
   Also see "Microsoft Portable Executable and Common Object File Format,
   Specification 4.1" for more information.

   A DLL contains an export table which contains the information
   which the runtime loader needs to tie up references from a
   referencing program.

   The export table is generated by this program by reading
   in a .DEF file or scanning the .a and .o files which will be in the
   DLL.  A .o file can contain information in special  ".drectve" sections
   with export information.

   A DEF file contains any number of the following commands:


   NAME <name> [ , <base> ]
   The result is going to be <name>.EXE

   LIBRARY <name> [ , <base> ]
   The result is going to be <name>.DLL

   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] [PRIVATE] ) *
   Declares name1 as an exported symbol from the
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.

   IMPORTS  (  (   <internal-name> =   <module-name> . <integer> )
             | ( [ <internal-name> = ] <module-name> . <external-name> )) *
   Declares that <external-name> or the exported function whoes ordinal number
   is <integer> is to be imported from the file <module-name>.  If
   <internal-name> is specified then this is the name that the imported
   function will be refereed to in the body of the DLL.

   DESCRIPTION <string>
   Puts <string> into output .exp file in the .rdata section

   [STACKSIZE|HEAPSIZE] <number-reserve> [ , <number-commit> ]
   Generates --stack|--heap <number-reserve>,<number-commit>
   in the output .drectve section.  The linker will
   see this and act upon it.

   [CODE|DATA] <attr>+
   SECTIONS ( <sectionname> <attr>+ )*
   <attr> = READ | WRITE | EXECUTE | SHARED
   Generates --attr <sectionname> <attr> in the output
   .drectve section.  The linker will see this and act
   upon it.


   A -export:<name> in a .drectve section in an input .o or .a
   file to this program is equivalent to a EXPORTS <name>
   in a .DEF file.



   The program generates output files with the prefix supplied
   on the command line, or in the def file, or taken from the first
   supplied argument.

   The .exp.s file contains the information necessary to export
   the routines in the DLL.  The .lib.s file contains the information
   necessary to use the DLL's routines from a referencing program.



   Example:

 file1.c:
   asm (".section .drectve");
   asm (".ascii \"-export:adef\"");

   void adef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void bdef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

 file2.c:
   asm (".section .drectve");
   asm (".ascii \"-export:cdef\"");
   asm (".ascii \"-export:ddef\"");

   void cdef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void ddef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

   int printf (void)
   {
     return 9;
   }

 themain.c:
   int main (void)
   {
     cdef ();
     return 0;
   }

 thedll.def

   LIBRARY thedll
   HEAPSIZE 0x40000, 0x2000
   EXPORTS bdef @@ 20
           cdef @@ 30 NONAME

   SECTIONS donkey READ WRITE
   aardvark EXECUTE

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Optional: put the dll objects into a library
 # (you don't have to, you could name all the object
 # files on the dlltool line)

   ar  qcv thedll.in file1.o file2.o
   ranlib thedll.in

 # Run this tool over the DLL's .def file and generate an exports
 # file (thedll.o) and an imports file (thedll.a).
 # (You may have to use -S to tell dlltool where to find the assembler).

   dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a

 # Build the dll with the library and the export table

   ld -o thedll.dll thedll.o thedll.in

 # Link the executable with the import library

   gcc -o themain.exe themain.o thedll.a

 This example can be extended if relocations are needed in the DLL:

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Run this tool over the DLL's .def file and generate an imports file.

   dlltool --def thedll.def --output-lib thedll.lib

 # Link the executable with the import library and generate a base file
 # at the same time

   gcc -o themain.exe themain.o thedll.lib -Wl,--base-file -Wl,themain.base

 # Run this tool over the DLL's .def file and generate an exports file
 # which includes the relocations from the base file.

   dlltool --def thedll.def --base-file themain.base --output-exp thedll.exp

 # Build the dll with file1.o, file2.o and the export table

   ld -o thedll.dll thedll.exp file1.o file2.o  */

/* .idata section description

   The .idata section is the import table.  It is a collection of several
   subsections used to keep the pieces for each dll together: .idata$[234567].
   IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.

   .idata$2 = Import Directory Table
   = array of IMAGE_IMPORT_DESCRIPTOR's.

	DWORD   Import Lookup Table;  - pointer to .idata$4
	DWORD   TimeDateStamp;        - currently always 0
	DWORD   ForwarderChain;       - currently always 0
	DWORD   Name;                 - pointer to dll's name
	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5

   .idata$3 = null terminating entry for .idata$2.

   .idata$4 = Import Lookup Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.

   .idata$5 = Import Address Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.
   Initially, this table is identical to the Import Lookup Table.  However,
   at load time, the loader overwrites the entries with the address of the
   function.

   .idata$6 = Hint Name Table
   = Array of { short, asciz } entries, one for each imported function.
   The `short' is the function's ordinal number.

   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#define show_allnames 0

#define PAGE_SIZE 4096
#define PAGE_MASK (-PAGE_SIZE)
#include "bfd.h"
#include "libiberty.h"
#include "bucomm.h"
#include "getopt.h"
#include "demangle.h"
#include "dyn-string.h"
#include "dlltool.h"
#include "safe-ctype.h"

#include <time.h>
#include <sys/stat.h>

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#ifdef DLLTOOL_ARM
#include "coff/arm.h"
#include "coff/internal.h"
#endif

/* Forward references.  */
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);

#ifdef DLLTOOL_MCORE_ELF
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN32__)
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0377) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0177)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) >> 8) & 0377)
#endif
#else /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#endif /* ! HAVE_SYS_WAIT_H */

/* ifunc and ihead data structures: ttk@@cygnus.com 1997

   When IMPORT declarations are encountered in a .def file the
   function import information is stored in a structure referenced by
   the global variable IMPORT_LIST.  The structure is a linked list
   containing the names of the dll files each function is imported
   from and a linked list of functions being imported from that dll
   file.  This roughly parallels the structure of the .idata section
   in the PE object file.

   The contents of .def file are interpreted from within the
   process_def_file function.  Every time an IMPORT declaration is
   encountered, it is broken up into its component parts and passed to
   def_import.  IMPORT_LIST is initialized to NULL in function main.  */

typedef struct ifunct
{
  char *         name;   /* Name of function being imported.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
  struct ifunct *next;
} ifunctype;

typedef struct iheadt
{
  char          *dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
} iheadtype;

/* Structure containing all import information as defined in .def file
   (qv "ihead structure").  */

static iheadtype *import_list = NULL;

static char *as_name = NULL;
static char * as_flags = "";

static char *tmp_prefix;

static int no_idata4;
static int no_idata5;
static char *exp_name;
static char *imp_name;
static char *head_label;
static char *imp_name_lab;
static char *dll_name;

static int add_indirect = 0;
static int add_underscore = 0;
static int dontdeltemps = 0;

/* TRUE if we should export all symbols.  Otherwise, we only export
   symbols listed in .drectve sections or in the def file.  */
static bfd_boolean export_all_symbols;

/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
   exporting all symbols.  */
static bfd_boolean do_default_excludes = TRUE;

/* Default symbols to exclude when exporting all the symbols.  */
static const char *default_excludes = "DllMain@@12,DllEntryPoint@@0,impure_ptr";

/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
   compatibility to old Cygwin releases.  */
static bfd_boolean create_compat_implib;

static char *def_file;

extern char * program_name;

static int machine;
static int killat;
static int add_stdcall_alias;
static int verbose;
static FILE *output_def;
static FILE *base_file;

#ifdef DLLTOOL_ARM
#ifdef DLLTOOL_ARM_EPOC
static const char *mname = "arm-epoc";
#else
static const char *mname = "arm";
#endif
#endif

#ifdef DLLTOOL_I386
static const char *mname = "i386";
#endif

#ifdef DLLTOOL_PPC
static const char *mname = "ppc";
#endif

#ifdef DLLTOOL_SH
static const char *mname = "sh";
#endif

#ifdef DLLTOOL_MIPS
static const char *mname = "mips";
#endif

#ifdef DLLTOOL_MCORE
static const char * mname = "mcore-le";
#endif

#ifdef DLLTOOL_MCORE_ELF
static const char * mname = "mcore-elf";
static char * mcore_elf_out_file = NULL;
static char * mcore_elf_linker   = NULL;
static char * mcore_elf_linker_flags = NULL;

#define DRECTVE_SECTION_NAME ((machine == MMCORE_ELF || machine == MMCORE_ELF_LE) ? ".exports" : ".drectve")
#endif

#ifndef DRECTVE_SECTION_NAME
#define DRECTVE_SECTION_NAME ".drectve"
#endif

#define PATHMAX 250		/* What's the right name for this ?  */

char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (&tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (&tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (&tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (&tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (&tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (&tmp_stub_buf, "%ss")

/* This bit of assembly does jmp * ....  */
static const unsigned char i386_jtab[] =
{
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90
};

static const unsigned char arm_jtab[] =
{
  0x00, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr  pc, [ip] */
  0,    0,    0,    0
};

static const unsigned char arm_interwork_jtab[] =
{
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xc0, 0x9c, 0xe5,	/* ldr  ip, [ip] */
  0x1c, 0xff, 0x2f, 0xe1,	/* bx   ip       */
  0,    0,    0,    0
};

static const unsigned char thumb_jtab[] =
{
  0x40, 0xb4,           /* push {r6}         */
  0x02, 0x4e,           /* ldr  r6, [pc, #8] */
  0x36, 0x68,           /* ldr  r6, [r6]     */
  0xb4, 0x46,           /* mov  ip, r6       */
  0x40, 0xbc,           /* pop  {r6}         */
  0x60, 0x47,           /* bx   ip           */
  0,    0,    0,    0
};

static const unsigned char mcore_be_jtab[] =
{
  0x71, 0x02,            /* lrw r1,2       */
  0x81, 0x01,            /* ld.w r1,(r1,0) */
  0x00, 0xC1,            /* jmp r1         */
  0x12, 0x00,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

static const unsigned char mcore_le_jtab[] =
{
  0x02, 0x71,            /* lrw r1,2       */
  0x01, 0x81,            /* ld.w r1,(r1,0) */
  0xC1, 0x00,            /* jmp r1         */
  0x00, 0x12,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
static const unsigned char ppc_jtab[] =
{
  0x00, 0x00, 0x62, 0x81, /* lwz r11,0(r2)               */
                          /*   Reloc TOCREL16 __imp_xxx  */
  0x00, 0x00, 0x8B, 0x81, /* lwz r12,0(r11)              */
  0x04, 0x00, 0x41, 0x90, /* stw r2,4(r1)                */
  0xA6, 0x03, 0x89, 0x7D, /* mtctr r12                   */
  0x04, 0x00, 0x4B, 0x80, /* lwz r2,4(r11)               */
  0x20, 0x04, 0x80, 0x4E  /* bctr                        */
};

#ifdef DLLTOOL_PPC
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
static bfd_vma ppc_glue_insn = 0x80410004;
#endif

struct mac
  {
    const char *type;
    const char *how_byte;
    const char *how_short;
    const char *how_long;
    const char *how_asciz;
    const char *how_comment;
    const char *how_jump;
    const char *how_global;
    const char *how_space;
    const char *how_align_short;
    const char *how_align_long;
    const char *how_default_as_switches;
    const char *how_bfd_target;
    enum bfd_architecture how_bfd_arch;
    const unsigned char *how_jtab;
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
  };

static const struct mac
mtable[] =
{
  {
#define MARM 0
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-32",
    "pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
  }
  ,
  {
#define M386 1
    "i386", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-i386",bfd_arch_i386,
    i386_jtab, sizeof (i386_jtab), 2
  }
  ,
  {
#define MPPC 2
    "ppc", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-powerpcle",bfd_arch_powerpc,
    ppc_jtab, sizeof (ppc_jtab), 0
  }
  ,
  {
#define MTHUMB 3
    "thumb", ".byte", ".short", ".long", ".asciz", "@@",
    "push\t{r6}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tmov\tip, r6\n\tpop\t{r6}\n\tbx\tip",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    thumb_jtab, sizeof (thumb_jtab), 12
  }
  ,
#define MARM_INTERWORK 4
  {
    "arm_interwork", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tip,[ip]\n\tbx\tip\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    arm_interwork_jtab, sizeof (arm_interwork_jtab), 12
  }
  ,
  {
#define MMCORE_BE 5
    "mcore-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "pe-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
  }
  ,
  {
#define MMCORE_LE 6
    "mcore-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "pe-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MMCORE_ELF 7
    "mcore-elf-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "elf32-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
  }
  ,
  {
#define MMCORE_ELF_LE 8
    "mcore-elf-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "elf32-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MARM_EPOC 9
    "arm-epoc", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "epoc-pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
  }
  ,
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

typedef struct dlist
{
  char *text;
  struct dlist *next;
}
dlist_type;

typedef struct export
  {
    const char *name;
    const char *internal_name;
    int ordinal;
    int constant;
    int noname;		/* Don't put name in image file.  */
    int private;	/* Don't put reference in import lib.  */
    int data;
    int hint;
    int forward;	/* Number of forward label, 0 means no forward.  */
    struct export *next;
  }
export_type;

/* A list of symbols which we should not export.  */

struct string_list
{
  struct string_list *next;
  char *string;
};

static struct string_list *excludes;

static const char *rvaafter (int);
static const char *rvabefore (int);
static const char *asm_prefix (int);
static void process_def_file (const char *);
static void new_directive (char *);
static void append_import (const char *, const char *, int);
static void run (const char *, char *);
static void scan_drectve_symbols (bfd *);
static void scan_filtered_symbols (bfd *, void *, long, unsigned int);
static void add_excludes (const char *);
static bfd_boolean match_exclude (const char *);
static void set_default_excludes (void);
static long filter_symbols (bfd *, void *, long, unsigned int);
static void scan_all_symbols (bfd *);
static void scan_open_obj_file (bfd *);
static void scan_obj_file (const char *);
static void dump_def_info (FILE *);
static int sfunc (const void *, const void *);
static void flush_page (FILE *, long *, int, int);
static void gen_def_file (void);
static void generate_idata_ofile (FILE *);
static void assemble_file (const char *, const char *);
static void gen_exp_file (void);
static const char *xlate (const char *);
#if 0
static void dump_iat (FILE *, export_type *);
#endif
static char *make_label (const char *, const char *);
static char *make_imp_label (const char *, const char *);
static bfd *make_one_lib_file (export_type *, int);
static bfd *make_head (void);
static bfd *make_tail (void);
static void gen_lib_file (void);
static int pfunc (const void *, const void *);
static int nfunc (const void *, const void *);
static void remove_null_names (export_type **);
static void dtab (export_type **);
static void process_duplicates (export_type **);
static void fill_ordinals (export_type **);
static int alphafunc (const void *, const void *);
static void mangle_defs (void);
static void usage (FILE *, int);
static void inform (const char *, ...);

static char *
prefix_encode (char *start, unsigned code)
{
  static char alpha[26] = "abcdefghijklmnopqrstuvwxyz";
  static char buf[32];
  char *p;
  strcpy (buf, start);
  p = strchr (buf, '\0');
  do
    *p++ = alpha[code % sizeof (alpha)];
  while ((code /= sizeof (alpha)) != 0);
  *p = '\0';
  return buf;
}

static char *
dlltmp (char **buf, const char *fmt)
{
  if (!*buf)
    {
      *buf = malloc (strlen (tmp_prefix) + 64);
      sprintf (*buf, fmt, tmp_prefix);
    }
  return *buf;
}

static void
inform VPARAMS ((const char * message, ...))
{
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

  if (!verbose)
    return;

  report (message, args);

  VA_CLOSE (args);
}

static const char *
rvaafter (int machine)
{
  switch (machine)
    {
    case MARM:
    case M386:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      break;
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

static const char *
rvabefore (int machine)
{
  switch (machine)
    {
    case MARM:
    case M386:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      return ".rva\t";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

static const char *
asm_prefix (int machine)
{
  switch (machine)
    {
    case MARM:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
      break;
    case M386:
      return "_";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
    }
  return "";
}

#define ASM_BYTE	mtable[machine].how_byte
#define ASM_SHORT	mtable[machine].how_short
#define ASM_LONG	mtable[machine].how_long
#define ASM_TEXT	mtable[machine].how_asciz
#define ASM_C		mtable[machine].how_comment
#define ASM_JUMP	mtable[machine].how_jump
#define ASM_GLOBAL	mtable[machine].how_global
#define ASM_SPACE	mtable[machine].how_space
#define ASM_ALIGN_SHORT mtable[machine].how_align_short
#define ASM_RVA_BEFORE	rvabefore(machine)
#define ASM_RVA_AFTER	rvaafter(machine)
#define ASM_PREFIX	asm_prefix(machine)
#define ASM_ALIGN_LONG  mtable[machine].how_align_long
#define HOW_BFD_READ_TARGET  0  /* always default*/
#define HOW_BFD_WRITE_TARGET mtable[machine].how_bfd_target
#define HOW_BFD_ARCH    mtable[machine].how_bfd_arch
#define HOW_JTAB        mtable[machine].how_jtab
#define HOW_JTAB_SIZE   mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF   mtable[machine].how_jtab_roff
#define ASM_SWITCHES    mtable[machine].how_default_as_switches

static char **oav;

static void
process_def_file (const char *name)
{
  FILE *f = fopen (name, FOPEN_RT);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Can't open def file: %s"), name);

  yyin = f;

  /* xgettext:c-format */
  inform (_("Processing def file: %s"), name);

  yyparse ();

  inform (_("Processed def file"));
}

/**********************************************************************/

/* Communications with the parser.  */

static const char *d_name;	/* Arg to NAME or LIBRARY.  */
static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */

static int d_is_dll;
static int d_is_exe;

int
yyerror (const char * err ATTRIBUTE_UNUSED)
{
  /* xgettext:c-format */
  non_fatal (_("Syntax error in def file %s:%d"), def_file, linenumber);

  return 0;
}

void
def_exports (const char *name, const char *internal_name, int ordinal,
	     int noname, int constant, int data, int private)
{
  struct export *p = (struct export *) xmalloc (sizeof (*p));

  p->name = name;
  p->internal_name = internal_name ? internal_name : name;
  p->ordinal = ordinal;
  p->constant = constant;
  p->noname = noname;
  p->private = private;
  p->data = data;
  p->next = d_exports;
  d_exports = p;
  d_nfuncs++;

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
}

void
def_name (const char *name, int base)
{
  /* xgettext:c-format */
  inform (_("NAME: %s base: %x"), name, base);

  if (d_is_dll)
    non_fatal (_("Can't have LIBRARY and NAME"));

  d_name = name;
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
  if (! dll_name)
    dll_name = xstrdup (name);
  d_is_exe = 1;
}

void
def_library (const char *name, int base)
{
  /* xgettext:c-format */
  inform (_("LIBRARY: %s base: %x"), name, base);

  if (d_is_exe)
    non_fatal (_("Can't have LIBRARY and NAME"));

  d_name = name;
  /* If --dllname not provided, use the one in the DEF file.  */
  if (! dll_name)
    dll_name = xstrdup (name);
  d_is_dll = 1;
}

void
def_description (const char *desc)
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (desc);
  d->next = d_list;
  d_list = d;
}

static void
new_directive (char *dir)
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (dir);
  d->next = a_list;
  a_list = d;
}

void
def_heapsize (int reserve, int commit)
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-heap 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-heap 0x%x ", reserve);
  new_directive (xstrdup (b));
}

void
def_stacksize (int reserve, int commit)
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-stack 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-stack 0x%x ", reserve);
  new_directive (xstrdup (b));
}

/* append_import simply adds the given import definition to the global
   import_list.  It is used by def_import.  */

static void
append_import (const char *symbol_name, const char *dll_name, int func_ordinal)
{
  iheadtype **pq;
  iheadtype *q;

  for (pq = &import_list; *pq != NULL; pq = &(*pq)->next)
    {
      if (strcmp ((*pq)->dllname, dll_name) == 0)
	{
	  q = *pq;
	  q->functail->next = xmalloc (sizeof (ifunctype));
	  q->functail = q->functail->next;
	  q->functail->ord  = func_ordinal;
	  q->functail->name = xstrdup (symbol_name);
	  q->functail->next = NULL;
	  q->nfuncs++;
	  return;
	}
    }

  q = xmalloc (sizeof (iheadtype));
  q->dllname = xstrdup (dll_name);
  q->nfuncs = 1;
  q->funchead = xmalloc (sizeof (ifunctype));
  q->functail = q->funchead;
  q->next = NULL;
  q->functail->name = xstrdup (symbol_name);
  q->functail->ord  = func_ordinal;
  q->functail->next = NULL;

  *pq = q;
}

/* def_import is called from within defparse.y when an IMPORT
   declaration is encountered.  Depending on the form of the
   declaration, the module name may or may not need ".dll" to be
   appended to it, the name of the function may be stored in internal
   or entry, and there may or may not be an ordinal value associated
   with it.  */

/* A note regarding the parse modes:
   In defparse.y we have to accept import declarations which follow
   any one of the following forms:
     <func_name_in_app> = <dll_name>.<func_name_in_dll>
     <func_name_in_app> = <dll_name>.<number>
     <dll_name>.<func_name_in_dll>
     <dll_name>.<number>
   Furthermore, the dll's name may or may not end with ".dll", which
   complicates the parsing a little.  Normally the dll's name is
   passed to def_import() in the "module" parameter, but when it ends
   with ".dll" it gets passed in "module" sans ".dll" and that needs
   to be reappended.

  def_import gets five parameters:
  APP_NAME - the name of the function in the application, if
             present, or NULL if not present.
  MODULE   - the name of the dll, possibly sans extension (ie, '.dll').
  DLLEXT   - the extension of the dll, if present, NULL if not present.
  ENTRY    - the name of the function in the dll, if present, or NULL.
  ORD_VAL  - the numerical tag of the function in the dll, if present,
             or NULL.  Exactly one of <entry> or <ord_val> must be
             present (i.e., not NULL).  */

void
def_import (const char *app_name, const char *module, const char *dllext,
	    const char *entry, int ord_val)
{
  const char *application_name;
  char *buf;

  if (entry != NULL)
    application_name = entry;
  else
    {
      if (app_name != NULL)
	application_name = app_name;
      else
	application_name = "";
    }

  if (dllext != NULL)
    {
      buf = (char *) alloca (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }

  append_import (application_name, module, ord_val);
}

void
def_version (int major, int minor)
{
  printf ("VERSION %d.%d\n", major, minor);
}

void
def_section (const char *name, int attr)
{
  char buf[200];
  char atts[5];
  char *d = atts;
  if (attr & 1)
    *d++ = 'R';

  if (attr & 2)
    *d++ = 'W';
  if (attr & 4)
    *d++ = 'X';
  if (attr & 8)
    *d++ = 'S';
  *d++ = 0;
  sprintf (buf, "-attr %s %s", name, atts);
  new_directive (xstrdup (buf));
}

void
def_code (int attr)
{

  def_section ("CODE", attr);
}

void
def_data (int attr)
{
  def_section ("DATA", attr);
}

/**********************************************************************/

static void
run (const char *what, char *args)
{
  char *s;
  int pid, wait_status;
  int i;
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
#if defined(__MSDOS__) && !defined(__GO32__)
  char *temp_base = choose_temp_base ();
#else
  char *temp_base = NULL;
#endif

  inform ("run: %s %s", what, args);

  /* Count the args */
  i = 0;
  for (s = args; *s; s++)
    if (*s == ' ')
      i++;
  i++;
  argv = alloca (sizeof (char *) * (i + 3));
  i = 0;
  argv[i++] = what;
  s = args;
  while (1)
    {
      while (*s == ' ')
	++s;
      argv[i++] = s;
      while (*s != ' ' && *s != 0)
	s++;
      if (*s == 0)
	break;
      *s++ = 0;
    }
  argv[i++] = NULL;

  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);

  if (pid == -1)
    {
      inform (strerror (errno));

      fatal (errmsg_fmt, errmsg_arg);
    }

  pid = pwait (pid, & wait_status, 0);

  if (pid == -1)
    {
      /* xgettext:c-format */
      fatal (_("wait: %s"), strerror (errno));
    }
  else if (WIFSIGNALED (wait_status))
    {
      /* xgettext:c-format */
      fatal (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
    }
  else if (WIFEXITED (wait_status))
    {
      if (WEXITSTATUS (wait_status) != 0)
	/* xgettext:c-format */
	non_fatal (_("%s exited with status %d"),
		   what, WEXITSTATUS (wait_status));
    }
  else
    abort ();
}

/* Look for a list of symbols to export in the .drectve section of
   ABFD.  Pass each one to def_exports.  */

static void
scan_drectve_symbols (bfd *abfd)
{
  asection * s;
  int        size;
  char *     buf;
  char *     p;
  char *     e;

  /* Look for .drectve's */
  s = bfd_get_section_by_name (abfd, DRECTVE_SECTION_NAME);

  if (s == NULL)
    return;

  size = bfd_get_section_size_before_reloc (s);
  buf  = xmalloc (size);

  bfd_get_section_contents (abfd, s, buf, 0, size);

  /* xgettext:c-format */
  inform (_("Sucking in info from %s section in %s"),
	  DRECTVE_SECTION_NAME, bfd_get_filename (abfd));

  /* Search for -export: strings. The exported symbols can optionally
     have type tags (eg., -export:foo,data), so handle those as well.
     Currently only data tag is supported.  */
  p = buf;
  e = buf + size;
  while (p < e)
    {
      if (p[0] == '-'
	  && strncmp (p, "-export:", 8) == 0)
	{
	  char * name;
	  char * c;
	  flagword flags = BSF_FUNCTION;

	  p += 8;
	  name = p;
	  while (p < e && *p != ',' && *p != ' ' && *p != '-')
	    p++;
	  c = xmalloc (p - name + 1);
	  memcpy (c, name, p - name);
	  c[p - name] = 0;
	  if (p < e && *p == ',')       /* found type tag.  */
	    {
	      char *tag_start = ++p;
	      while (p < e && *p != ' ' && *p != '-')
		p++;
	      if (strncmp (tag_start, "data", 4) == 0)
		flags &= ~BSF_FUNCTION;
	    }

	  /* FIXME: The 5th arg is for the `constant' field.
	     What should it be?  Not that it matters since it's not
	     currently useful.  */
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0);

	  if (add_stdcall_alias && strchr (c, '@@'))
	    {
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
	      char *atsym = strchr (exported_name, '@@');
	      *atsym = '\0';
	      /* Note: stdcall alias symbols can never be data.  */
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0);
	    }
	}
      else
	p++;
    }
  free (buf);
}

/* Look through the symbols in MINISYMS, and add each one to list of
   symbols to export.  */

static void
scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,
		       unsigned int size)
{
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;
      const char *symbol_name;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      symbol_name = bfd_asymbol_name (sym);
      if (bfd_get_symbol_leading_char (abfd) == symbol_name[0])
	++symbol_name;

      def_exports (xstrdup (symbol_name) , 0, -1, 0, 0,
		   ! (sym->flags & BSF_FUNCTION), 0);

      if (add_stdcall_alias && strchr (symbol_name, '@@'))
        {
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
	  char *atsym = strchr (exported_name, '@@');
	  *atsym = '\0';
	  /* Note: stdcall alias symbols can never be data.  */
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0);
	}
    }
}

/* Add a list of symbols to exclude.  */

static void
add_excludes (const char *new_excludes)
{
  char *local_copy;
  char *exclude_string;

  local_copy = xstrdup (new_excludes);

  exclude_string = strtok (local_copy, ",:");
  for (; exclude_string; exclude_string = strtok (NULL, ",:"))
    {
      struct string_list *new_exclude;

      new_exclude = ((struct string_list *)
		     xmalloc (sizeof (struct string_list)));
      new_exclude->string = (char *) xmalloc (strlen (exclude_string) + 2);
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "_%s", exclude_string);
      new_exclude->next = excludes;
      excludes = new_exclude;

      /* xgettext:c-format */
      inform (_("Excluding symbol: %s"), exclude_string);
    }

  free (local_copy);
}

/* See if STRING is on the list of symbols to exclude.  */

static bfd_boolean
match_exclude (const char *string)
{
  struct string_list *excl_item;

  for (excl_item = excludes; excl_item; excl_item = excl_item->next)
    if (strcmp (string, excl_item->string) == 0)
      return TRUE;
  return FALSE;
}

/* Add the default list of symbols to exclude.  */

static void
set_default_excludes (void)
{
  add_excludes (default_excludes);
}

/* Choose which symbols to export.  */

static long
filter_symbols (bfd *abfd, void *minisyms, long symcount, unsigned int size)
{
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
    {
      int keep = 0;
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const void *) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      /* Check for external and defined only symbols.  */
      keep = (((sym->flags & BSF_GLOBAL) != 0
	       || (sym->flags & BSF_WEAK) != 0
	       || bfd_is_com_section (sym->section))
	      && ! bfd_is_und_section (sym->section));

      keep = keep && ! match_exclude (sym->name);

      if (keep)
	{
	  memcpy (to, from, size);
	  to += size;
	}
    }

  return (to - (bfd_byte *) minisyms) / size;
}

/* Export all symbols in ABFD, except for ones we were told not to
   export.  */

static void
scan_all_symbols (bfd *abfd)
{
  long symcount;
  void *minisyms;
  unsigned int size;

  /* Ignore bfds with an import descriptor table.  We assume that any
     such BFD contains symbols which are exported from another DLL,
     and we don't want to reexport them from here.  */
  if (bfd_get_section_by_name (abfd, ".idata$4"))
    return;

  if (! (bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  /* Discard the symbols we don't want to export.  It's OK to do this
     in place; we'll free the storage anyway.  */

  symcount = filter_symbols (abfd, minisyms, symcount, size);
  scan_filtered_symbols (abfd, minisyms, symcount, size);

  free (minisyms);
}

/* Look at the object file to decide which symbols to export.  */

static void
scan_open_obj_file (bfd *abfd)
{
  if (export_all_symbols)
    scan_all_symbols (abfd);
  else
    scan_drectve_symbols (abfd);

  /* FIXME: we ought to read in and block out the base relocations.  */

  /* xgettext:c-format */
  inform (_("Done reading %s"), bfd_get_filename (abfd));
}

static void
scan_obj_file (const char *filename)
{
  bfd * f = bfd_openr (filename, 0);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open object file: %s"), filename);

  /* xgettext:c-format */
  inform (_("Scanning object file %s"), filename);

  if (bfd_check_format (f, bfd_archive))
    {
      bfd *arfile = bfd_openr_next_archived_file (f, 0);
      while (arfile)
	{
	  if (bfd_check_format (arfile, bfd_object))
	    scan_open_obj_file (arfile);
	  bfd_close (arfile);
	  arfile = bfd_openr_next_archived_file (f, arfile);
	}

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	inform (_("Cannot produce mcore-elf dll from archive file: %s"), filename);
#endif
    }
  else if (bfd_check_format (f, bfd_object))
    {
      scan_open_obj_file (f);

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	mcore_elf_cache_filename ((char *) filename);
#endif
    }

  bfd_close (f);
}

/**********************************************************************/

static void
dump_def_info (FILE *f)
{
  int i;
  export_type *exp;
  fprintf (f, "%s ", ASM_C);
  for (i = 0; oav[i]; i++)
    fprintf (f, "%s ", oav[i]);
  fprintf (f, "\n");
  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s\n",
	       ASM_C,
	       i,
	       exp->name,
	       exp->internal_name,
	       exp->ordinal,
	       exp->noname ? "NONAME " : "",
	       exp->private ? "PRIVATE " : "",
	       exp->constant ? "CONSTANT" : "",
	       exp->data ? "DATA" : "");
    }
}

/* Generate the .exp file.  */

static int
sfunc (const void *a, const void *b)
{
  return *(const long *) a - *(const long *) b;
}

static void
flush_page (FILE *f, long *need, int page_addr, int on_page)
{
  int i;

  /* Flush this page.  */
  fprintf (f, "\t%s\t0x%08x\t%s Starting RVA for chunk\n",
	   ASM_LONG,
	   page_addr,
	   ASM_C);
  fprintf (f, "\t%s\t0x%x\t%s Size of block\n",
	   ASM_LONG,
	   (on_page * 2) + (on_page & 1) * 2 + 8,
	   ASM_C);

  for (i = 0; i < on_page; i++)
    {
      long needed = need[i];

      if (needed)
	needed = ((needed - page_addr) | 0x3000) & 0xffff;

      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, needed);
    }

  /* And padding */
  if (on_page & 1)
    fprintf (f, "\t%s\t0x%x\n", ASM_SHORT, 0 | 0x0000);
}

static void
gen_def_file (void)
{
  int i;
  export_type *exp;

  inform (_("Adding exports to output file"));

  fprintf (output_def, ";");
  for (i = 0; oav[i]; i++)
    fprintf (output_def, " %s", oav[i]);

  fprintf (output_def, "\nEXPORTS\n");

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      char *quote = strchr (exp->name, '.') ? "\"" : "";
      char *res = cplus_demangle (exp->internal_name, DMGL_ANSI | DMGL_PARAMS);

      if (res)
	{
	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

      if (strcmp (exp->name, exp->internal_name) == 0)
	{
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->private ? "PRIVATE " : "",
		   exp->data ? " DATA" : "");
	}
      else
	{
	  char * quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
	  /* char *alias =  */
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   quote1,
		   exp->internal_name,
		   quote1,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->private ? "PRIVATE " : "",
		   exp->data ? " DATA" : "");
	}
    }

  inform (_("Added exports to output file"));
}

/* generate_idata_ofile generates the portable assembly source code
   for the idata sections.  It appends the source code to the end of
   the file.  */

static void
generate_idata_ofile (FILE *filvar)
{
  iheadtype *headptr;
  ifunctype *funcptr;
  int        headindex;
  int        funcindex;
  int	     nheads;

  if (import_list == NULL)
    return;

  fprintf (filvar, "%s Import data sections\n", ASM_C);
  fprintf (filvar, "\n\t.section\t.idata$2\n");
  fprintf (filvar, "\t%s\tdoi_idata\n", ASM_GLOBAL);
  fprintf (filvar, "doi_idata:\n");

  nheads = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "\t%slistone%d%s\t%s %s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER,
	       ASM_C, headptr->dllname);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%sdllname%d%s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      fprintf (filvar, "\t%slisttwo%d%s\n\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      nheads++;
    }

  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL record at */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* end of idata$2 */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* section        */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);

  fprintf (filvar, "\n\t.section\t.idata$4\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listone%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar,"\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$5\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listtwo%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$6\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      funcindex = 0;
      for (funcptr = headptr->funchead; funcptr != NULL;
	   funcptr = funcptr->next)
	{
	  fprintf (filvar,"funcptr%d_%d:\n", headindex, funcindex);
	  fprintf (filvar,"\t%s\t%d\n", ASM_SHORT,
		   ((funcptr->ord) & 0xFFFF));
	  fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, funcptr->name);
	  fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
	  funcindex++;
	}
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$7\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar,"dllname%d:\n", headindex);
      fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, headptr->dllname);
      fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
      headindex++;
    }
}

/* Assemble the specified file.  */
static void
assemble_file (const char * source, const char * dest)
{
  char * cmd;

  cmd = (char *) alloca (strlen (ASM_SWITCHES) + strlen (as_flags)
			 + strlen (source) + strlen (dest) + 50);

  sprintf (cmd, "%s %s -o %s %s", ASM_SWITCHES, as_flags, dest, source);

  run (as_name, cmd);
}

static void
gen_exp_file (void)
{
  FILE *f;
  int i;
  export_type *exp;
  dlist_type *dl;

  /* xgettext:c-format */
  inform (_("Generating export file: %s"), exp_name);

  f = fopen (TMP_ASM, FOPEN_WT);
  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open temporary assembler file: %s"), TMP_ASM);

  /* xgettext:c-format */
  inform (_("Opened temporary file: %s"), TMP_ASM);

  dump_def_info (f);

  if (d_exports)
    {
      fprintf (f, "\t.section	.edata\n\n");
      fprintf (f, "\t%s	0	%s Allways 0\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%s	0x%lx	%s Time and date\n", ASM_LONG, (long) time(0),
	       ASM_C);
      fprintf (f, "\t%s	0	%s Major and Minor version\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%sname%s	%s Ptr to name of dll\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);
      fprintf (f, "\t%s	%d	%s Starting ordinal of exports\n", ASM_LONG, d_low_ord, ASM_C);


      fprintf (f, "\t%s	%d	%s Number of functions\n", ASM_LONG, d_high_ord - d_low_ord + 1, ASM_C);
      fprintf(f,"\t%s named funcs %d, low ord %d, high ord %d\n",
	      ASM_C,
	      d_named_nfuncs, d_low_ord, d_high_ord);
      fprintf (f, "\t%s	%d	%s Number of names\n", ASM_LONG,
	       show_allnames ? d_high_ord - d_low_ord + 1 : d_named_nfuncs, ASM_C);
      fprintf (f, "\t%safuncs%s  %s Address of functions\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanames%s	%s Address of Name Pointer Table\n",
	       ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanords%s	%s Address of ordinals\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "name:	%s	\"%s\"\n", ASM_TEXT, dll_name);


      fprintf(f,"%s Export address Table\n", ASM_C);
      fprintf(f,"\t%s\n", ASM_ALIGN_LONG);
      fprintf (f, "afuncs:\n");
      i = d_low_ord;

      for (exp = d_exports; exp; exp = exp->next)
	{
	  if (exp->ordinal != i)
	    {
#if 0
	      fprintf (f, "\t%s\t%d\t%s %d..%d missing\n",
		       ASM_SPACE,
		       (exp->ordinal - i) * 4,
		       ASM_C,
		       i, exp->ordinal - 1);
	      i = exp->ordinal;
#endif
	      while (i < exp->ordinal)
		{
		  fprintf(f,"\t%s\t0\n", ASM_LONG);
		  i++;
		}
	    }

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	  i++;
	}

      fprintf (f,"%s Export Name Pointer Table\n", ASM_C);
      fprintf (f, "anames:\n");

      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%sn%d%s\n",
		     ASM_RVA_BEFORE, exp->ordinal, ASM_RVA_AFTER);
	}

      fprintf (f,"%s Export Oridinal Table\n", ASM_C);
      fprintf (f, "anords:\n");
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%s	%d\n", ASM_SHORT, exp->ordinal - d_low_ord);
	}

      fprintf(f,"%s Export Name Table\n", ASM_C);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
	  if (exp->forward != 0)
	    fprintf (f, "f%d:	%s	\"%s\"\n",
		     exp->forward, ASM_TEXT, exp->internal_name);
	}

      if (a_list)
	{
	  fprintf (f, "\t.section %s\n", DRECTVE_SECTION_NAME);
	  for (dl = a_list; dl; dl = dl->next)
	    {
	      fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, dl->text);
	    }
	}

      if (d_list)
	{
	  fprintf (f, "\t.section .rdata\n");
	  for (dl = d_list; dl; dl = dl->next)
	    {
	      char *p;
	      int l;

	      /* We don't output as ascii because there can
	         be quote characters in the string.  */
	      l = 0;
	      for (p = dl->text; *p; p++)
		{
		  if (l == 0)
		    fprintf (f, "\t%s\t", ASM_BYTE);
		  else
		    fprintf (f, ",");
		  fprintf (f, "%d", *p);
		  if (p[1] == 0)
		    {
		      fprintf (f, ",0\n");
		      break;
		    }
		  if (++l == 10)
		    {
		      fprintf (f, "\n");
		      l = 0;
		    }
		}
	    }
	}
    }


  /* Add to the output file a way of getting to the exported names
     without using the import library.  */
  if (add_indirect)
    {
      fprintf (f, "\t.section\t.rdata\n");
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
	if (!exp->noname || show_allnames)
	  {
	    /* We use a single underscore for MS compatibility, and a
               double underscore for backward compatibility with old
               cygwin releases.  */
	    if (create_compat_implib)
	      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
	    fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
	    if (create_compat_implib)
	      fprintf (f, "__imp_%s:\n", exp->name);
	    fprintf (f, "_imp__%s:\n", exp->name);
	    fprintf (f, "\t%s\t%s\n", ASM_LONG, exp->name);
	  }
    }

  /* Dump the reloc section if a base file is provided.  */
  if (base_file)
    {
      int addr;
      long need[PAGE_SIZE];
      long page_addr;
      int numbytes;
      int num_entries;
      long *copy;
      int j;
      int on_page;
      fprintf (f, "\t.section\t.init\n");
      fprintf (f, "lab:\n");

      fseek (base_file, 0, SEEK_END);
      numbytes = ftell (base_file);
      fseek (base_file, 0, SEEK_SET);
      copy = xmalloc (numbytes);
      fread (copy, 1, numbytes, base_file);
      num_entries = numbytes / sizeof (long);


      fprintf (f, "\t.section\t.reloc\n");
      if (num_entries)
	{
	  int src;
	  int dst = 0;
	  int last = -1;
	  qsort (copy, num_entries, sizeof (long), sfunc);
	  /* Delete duplicates */
	  for (src = 0; src < num_entries; src++)
	    {
	      if (last != copy[src])
		last = copy[dst++] = copy[src];
	    }
	  num_entries = dst;
	  addr = copy[0];
	  page_addr = addr & PAGE_MASK;		/* work out the page addr */
	  on_page = 0;
	  for (j = 0; j < num_entries; j++)
	    {
	      addr = copy[j];
	      if ((addr & PAGE_MASK) != page_addr)
		{
		  flush_page (f, need, page_addr, on_page);
		  on_page = 0;
		  page_addr = addr & PAGE_MASK;
		}
	      need[on_page++] = addr;
	    }
	  flush_page (f, need, page_addr, on_page);

/*	  fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
	}
    }

  generate_idata_ofile (f);

  fclose (f);

  /* Assemble the file.  */
  assemble_file (TMP_ASM, exp_name);

  if (dontdeltemps == 0)
    unlink (TMP_ASM);

  inform (_("Generated exports file"));
}

static const char *
xlate (const char *name)
{
  int lead_at = (*name == '@@');

  if (add_underscore &&  !lead_at)
    {
      char *copy = xmalloc (strlen (name) + 2);

      copy[0] = '_';
      strcpy (copy + 1, name);
      name = copy;
    }

  if (killat)
    {
      char *p;

      name += lead_at;
      p = strchr (name, '@@');
      if (p)
	*p = 0;
    }
  return name;
}

/**********************************************************************/

#if 0

static void
dump_iat (FILE *f, export_type *exp)
{
  if (exp->noname && !show_allnames )
    {
      fprintf (f, "\t%s\t0x%08x\n",
	       ASM_LONG,
	       exp->ordinal | 0x80000000); /* hint or orindal ?? */
    }
  else
    {
      fprintf (f, "\t%sID%d%s\n", ASM_RVA_BEFORE,
	       exp->ordinal,
	       ASM_RVA_AFTER);
    }
}

#endif

typedef struct
{
  int id;
  const char *name;
  int flags;
  int align;
  asection *sec;
  asymbol *sym;
  asymbol **sympp;
  int size;
  unsigned char *data;
} sinfo;

#ifndef DLLTOOL_PPC

#define TEXT 0
#define DATA 1
#define BSS 2
#define IDATA7 3
#define IDATA5 4
#define IDATA4 5
#define IDATA6 6

#define NSECS 7

#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
static sinfo secdata[NSECS] =
{
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
};

#else

/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
#define TEXT   0
#define PDATA  1
#define RDATA  2
#define IDATA5 3
#define IDATA4 4
#define IDATA6 5
#define IDATA7 6
#define DATA   7
#define BSS    8

#define NSECS 9

static sinfo secdata[NSECS] =
{
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
  { PDATA,  ".pdata",   SEC_HAS_CONTENTS,            2},
  { RDATA,  ".reldata", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2}
};

#endif

/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.

	.text
	.global	_GetFileVersionInfoSizeW@@8
	.global	__imp_GetFileVersionInfoSizeW@@8
_GetFileVersionInfoSizeW@@8:
	jmp *	__imp_GetFileVersionInfoSizeW@@8
	.section	.idata$7	# To force loading of head
	.long	__version_a_head
# Import Address Table
	.section	.idata$5
__imp_GetFileVersionInfoSizeW@@8:
	.rva	ID2

# Import Lookup Table
	.section	.idata$4
	.rva	ID2
# Hint/Name table
	.section	.idata$6
ID2:	.short	2
	.asciz	"GetFileVersionInfoSizeW"


   For the PowerPC, here's the variation on the above scheme:

# Rather than a simple "jmp *", the code to get to the dll function
# looks like:
         .text
         lwz	r11,[tocv]__imp_function_name(r2)
#		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name
         lwz	r12,0(r11)
	 stw	r2,4(r1)
	 mtctr	r12
	 lwz	r2,4(r11)
	 bctr  */

static char *
make_label (const char *prefix, const char *name)
{
  int len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
  char *copy = xmalloc (len +1 );

  strcpy (copy, ASM_PREFIX);
  strcat (copy, prefix);
  strcat (copy, name);
  return copy;
}

static char *
make_imp_label (const char *prefix, const char *name)
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX);
      strcat (copy, name);
    }
  return copy;
}

static bfd *
make_one_lib_file (export_type *exp, int i)
{
#if 0
    {
      char *name;
      FILE *f;
      const char *prefix = "d";
      char *dest;

      name = (char *) alloca (strlen (prefix) + 10);
      sprintf (name, "%ss%05d.s", prefix, i);
      f = fopen (name, FOPEN_WT);
      fprintf (f, "\t.text\n");
      fprintf (f, "\t%s\t%s%s\n", ASM_GLOBAL, ASM_PREFIX, exp->name);
      if (create_compat_implib)
	fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
      fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
      if (create_compat_implib)
	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
		 exp->name, ASM_JUMP, exp->name);

      fprintf (f, "\t.section\t.idata$7\t%s To force loading of head\n", ASM_C);
      fprintf (f, "\t%s\t%s\n", ASM_LONG, head_label);


      fprintf (f,"%s Import Address Table\n", ASM_C);

      fprintf (f, "\t.section	.idata$5\n");
      if (create_compat_implib)
	fprintf (f, "__imp_%s:\n", exp->name);
      fprintf (f, "_imp__%s:\n", exp->name);

      dump_iat (f, exp);

      fprintf (f, "\n%s Import Lookup Table\n", ASM_C);
      fprintf (f, "\t.section	.idata$4\n");

      dump_iat (f, exp);

      if(!exp->noname || show_allnames)
	{
	  fprintf (f, "%s Hint/Name table\n", ASM_C);
	  fprintf (f, "\t.section	.idata$6\n");
	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint);
	  fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, xlate (exp->name));
	}

      fclose (f);

      dest = (char *) alloca (strlen (prefix) + 10);
      sprintf (dest, "%ss%05d.o", prefix, i);
      assemble_file (name, dest);
    }
#else /* if 0 */
    {
      bfd *      abfd;
      asymbol *  exp_label;
      asymbol *  iname = 0;
      asymbol *  iname2;
      asymbol *  iname_lab;
      asymbol ** iname_lab_pp;
      asymbol ** iname_pp;
#ifdef DLLTOOL_PPC
      asymbol ** fn_pp;
      asymbol ** toc_pp;
#define EXTRA	 2
#endif
#ifndef EXTRA
#define EXTRA    0
#endif
      asymbol *  ptrs[NSECS + 4 + EXTRA + 1];
      flagword   applicable;

      char *     outname = xmalloc (strlen (TMP_STUB) + 10);
      int        oidx = 0;


      sprintf (outname, "%s%05d.o", TMP_STUB, i);

      abfd = bfd_openw (outname, HOW_BFD_WRITE_TARGET);

      if (!abfd)
	/* xgettext:c-format */
	fatal (_("bfd_open failed open stub file: %s"), outname);

      /* xgettext:c-format */
      inform (_("Creating stub file: %s"), outname);

      bfd_set_format (abfd, bfd_object);
      bfd_set_arch_mach (abfd, HOW_BFD_ARCH, 0);

#ifdef DLLTOOL_ARM
      if (machine == MARM_INTERWORK || machine == MTHUMB)
	bfd_set_private_flags (abfd, F_INTERWORK);
#endif

      applicable = bfd_applicable_section_flags (abfd);

      /* First make symbols for the sections.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
	  if (si->id != i)
	    abort();
	  si->sec = bfd_make_section_old_way (abfd, si->name);
	  bfd_set_section_flags (abfd,
				 si->sec,
				 si->flags & applicable);

	  bfd_set_section_alignment(abfd, si->sec, si->align);
	  si->sec->output_section = si->sec;
	  si->sym = bfd_make_empty_symbol(abfd);
	  si->sym->name = si->sec->name;
	  si->sym->section = si->sec;
	  si->sym->flags = BSF_LOCAL;
	  si->sym->value = 0;
	  ptrs[oidx] = si->sym;
	  si->sympp = ptrs + oidx;
	  si->size = 0;
	  si->data = NULL;

	  oidx++;
	}

      if (! exp->data)
	{
	  exp_label = bfd_make_empty_symbol (abfd);
	  exp_label->name = make_imp_label ("", exp->name);

	  /* On PowerPC, the function name points to a descriptor in
	     the rdata section, the first element of which is a
	     pointer to the code (..function_name), and the second
	     points to the .toc.  */
#ifdef DLLTOOL_PPC
	  if (machine == MPPC)
	    exp_label->section = secdata[RDATA].sec;
	  else
#endif
	    exp_label->section = secdata[TEXT].sec;

	  exp_label->flags = BSF_GLOBAL;
	  exp_label->value = 0;

#ifdef DLLTOOL_ARM
	  if (machine == MTHUMB)
	    bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
#endif
	  ptrs[oidx++] = exp_label;
	}

      /* Generate imp symbols with one underscore for Microsoft
         compatibility, and with two underscores for backward
         compatibility with old versions of cygwin.  */
      if (create_compat_implib)
	{
	  iname = bfd_make_empty_symbol (abfd);
	  iname->name = make_imp_label ("___imp", exp->name);
	  iname->section = secdata[IDATA5].sec;
	  iname->flags = BSF_GLOBAL;
	  iname->value = 0;
	}

      iname2 = bfd_make_empty_symbol (abfd);
      iname2->name = make_imp_label ("__imp_", exp->name);
      iname2->section = secdata[IDATA5].sec;
      iname2->flags = BSF_GLOBAL;
      iname2->value = 0;

      iname_lab = bfd_make_empty_symbol(abfd);

      iname_lab->name = head_label;
      iname_lab->section = (asection *)&bfd_und_section;
      iname_lab->flags = 0;
      iname_lab->value = 0;

      iname_pp = ptrs + oidx;
      if (create_compat_implib)
	ptrs[oidx++] = iname;
      ptrs[oidx++] = iname2;

      iname_lab_pp = ptrs + oidx;
      ptrs[oidx++] = iname_lab;

#ifdef DLLTOOL_PPC
      /* The symbol referring to the code (.text).  */
      {
	asymbol *function_name;

	function_name = bfd_make_empty_symbol(abfd);
	function_name->name = make_label ("..", exp->name);
	function_name->section = secdata[TEXT].sec;
	function_name->flags = BSF_GLOBAL;
	function_name->value = 0;

	fn_pp = ptrs + oidx;
	ptrs[oidx++] = function_name;
      }

      /* The .toc symbol.  */
      {
	asymbol *toc_symbol;

	toc_symbol = bfd_make_empty_symbol (abfd);
	toc_symbol->name = make_label (".", "toc");
	toc_symbol->section = (asection *)&bfd_und_section;
	toc_symbol->flags = BSF_GLOBAL;
	toc_symbol->value = 0;

	toc_pp = ptrs + oidx;
	ptrs[oidx++] = toc_symbol;
      }
#endif

      ptrs[oidx] = 0;

      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
	  asection *sec = si->sec;
	  arelent *rel;
	  arelent **rpp;

	  switch (i)
	    {
	    case TEXT:
	      if (! exp->data)
		{
		  si->size = HOW_JTAB_SIZE;
		  si->data = xmalloc (HOW_JTAB_SIZE);
		  memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);

		  /* add the reloc into idata$5 */
		  rel = xmalloc (sizeof (arelent));

		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;

		  rel->address = HOW_JTAB_ROFF;
		  rel->addend = 0;

		  if (machine == MPPC)
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd,
							  BFD_RELOC_16_GOTOFF);
		      rel->sym_ptr_ptr = iname_pp;
		    }
		  else
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		      rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		    }
		  sec->orelocation = rpp;
		  sec->reloc_count = 1;
		}
	      break;
	    case IDATA4:
	    case IDATA5:
	      /* An idata$4 or idata$5 is one word long, and has an
		 rva to idata$6.  */

	      si->data = xmalloc (4);
	      si->size = 4;

	      if (exp->noname)
		{
		  si->data[0] = exp->ordinal ;
		  si->data[1] = exp->ordinal >> 8;
		  si->data[2] = exp->ordinal >> 16;
		  si->data[3] = 0x80;
		}
	      else
		{
		  sec->reloc_count = 1;
		  memset (si->data, 0, si->size);
		  rel = xmalloc (sizeof (arelent));
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  rel->address = 0;
		  rel->addend = 0;
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
		  rel->sym_ptr_ptr = secdata[IDATA6].sympp;
		  sec->orelocation = rpp;
		}

	      break;

	    case IDATA6:
	      if (!exp->noname)
		{
		  /* This used to add 1 to exp->hint.  I don't know
                     why it did that, and it does not match what I see
                     in programs compiled with the MS tools.  */
		  int idx = exp->hint;
		  si->size = strlen (xlate (exp->name)) + 3;
		  si->data = xmalloc (si->size);
		  si->data[0] = idx & 0xff;
		  si->data[1] = idx >> 8;
		  strcpy (si->data + 2, xlate (exp->name));
		}
	      break;
	    case IDATA7:
	      si->size = 4;
	      si->data =xmalloc (4);
	      memset (si->data, 0, si->size);
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
	      rel->sym_ptr_ptr = iname_lab_pp;
	      sec->orelocation = rpp;
	      sec->reloc_count = 1;
	      break;

#ifdef DLLTOOL_PPC
	    case PDATA:
	      {
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */

		/* So this pdata section setups up this as a glue linkage to
		   a dll routine. There are a number of house keeping things
		   we need to do:

		   1. In the name of glue trickery, the ADDR32 relocs for 0,
		      4, and 0x10 are set to point to the same place:
		      "..function_name".
		   2. There is one more reloc needed in the pdata section.
		      The actual glue instruction to restore the toc on
		      return is saved as the offset in an IMGLUE reloc.
		      So we need a total of four relocs for this section.

		   3. Lastly, the HandlerData field is set to 0x03, to indicate
		      that this is a glue routine.  */
		arelent *imglue, *ba_rel, *ea_rel, *pea_rel;

		/* Alignment must be set to 2**2 or you get extra stuff.  */
		bfd_set_section_alignment(abfd, sec, 2);

		si->size = 4 * 5;
		si->data = xmalloc (si->size);
		memset (si->data, 0, si->size);
		rpp = xmalloc (sizeof (arelent *) * 5);
		rpp[0] = imglue  = xmalloc (sizeof (arelent));
		rpp[1] = ba_rel  = xmalloc (sizeof (arelent));
		rpp[2] = ea_rel  = xmalloc (sizeof (arelent));
		rpp[3] = pea_rel = xmalloc (sizeof (arelent));
		rpp[4] = 0;

		/* Stick the toc reload instruction in the glue reloc.  */
		bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);

		imglue->addend = 0;
		imglue->howto = bfd_reloc_type_lookup (abfd,
						       BFD_RELOC_32_GOTOFF);
		imglue->sym_ptr_ptr = fn_pp;

		ba_rel->address = 0;
		ba_rel->addend = 0;
		ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ba_rel->sym_ptr_ptr = fn_pp;

		bfd_put_32 (abfd, 0x18, si->data + 0x04);
		ea_rel->address = 4;
		ea_rel->addend = 0;
		ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ea_rel->sym_ptr_ptr = fn_pp;

		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);

		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
		pea_rel->address = 0x10;
		pea_rel->addend = 0;
		pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		pea_rel->sym_ptr_ptr = fn_pp;

		sec->orelocation = rpp;
		sec->reloc_count = 4;
		break;
	      }
	    case RDATA:
	      /* Each external function in a PowerPC PE file has a two word
		 descriptor consisting of:
		 1. The address of the code.
		 2. The address of the appropriate .toc
	         We use relocs to build this.  */
	      si->size = 8;
	      si->data = xmalloc (8);
	      memset (si->data, 0, si->size);

	      rpp = xmalloc (sizeof (arelent *) * 3);
	      rpp[0] = rel = xmalloc (sizeof (arelent));
	      rpp[1] = xmalloc (sizeof (arelent));
	      rpp[2] = 0;

	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = fn_pp;

	      rel = rpp[1];

	      rel->address = 4;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = toc_pp;

	      sec->orelocation = rpp;
	      sec->reloc_count = 2;
	      break;
#endif /* DLLTOOL_PPC */
	    }
	}

      {
	bfd_vma vma = 0;
	/* Size up all the sections.  */
	for (i = 0; i < NSECS; i++)
	  {
	    sinfo *si = secdata + i;

	    bfd_set_section_size (abfd, si->sec, si->size);
	    bfd_set_section_vma (abfd, si->sec, vma);

/*	    vma += si->size;*/
	  }
      }
      /* Write them out.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;

	  if (i == IDATA5 && no_idata5)
	    continue;

	  if (i == IDATA4 && no_idata4)
	    continue;

	  bfd_set_section_contents (abfd, si->sec,
				    si->data, 0,
				    si->size);
	}

      bfd_set_symtab (abfd, ptrs, oidx);
      bfd_close (abfd);
      abfd = bfd_openr (outname, HOW_BFD_READ_TARGET);
      return abfd;
    }
#endif
}

static bfd *
make_head (void)
{
  FILE *f = fopen (TMP_HEAD_S, FOPEN_WT);

  if (f == NULL)
    {
      fatal (_("failed to open temporary head file: %s"), TMP_HEAD_S);
      return NULL;
    }

  fprintf (f, "%s IMAGE_IMPORT_DESCRIPTOR\n", ASM_C);
  fprintf (f, "\t.section	.idata$2\n");

  fprintf(f,"\t%s\t%s\n", ASM_GLOBAL,head_label);

  fprintf (f, "%s:\n", head_label);

  fprintf (f, "\t%shname%s\t%sPtr to image import by name list\n",
	   ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

  fprintf (f, "\t%sthis should be the timestamp, but NT sometimes\n", ASM_C);
  fprintf (f, "\t%sdoesn't load DLLs when this is set.\n", ASM_C);
  fprintf (f, "\t%s\t0\t%s loaded time\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s\t0\t%s Forwarder chain\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s__%s_iname%s\t%s imported dll's name\n",
	   ASM_RVA_BEFORE,
	   imp_name_lab,
	   ASM_RVA_AFTER,
	   ASM_C);
  fprintf (f, "\t%sfthunk%s\t%s pointer to firstthunk\n",
	   ASM_RVA_BEFORE,
	   ASM_RVA_AFTER, ASM_C);

  fprintf (f, "%sStuff for compatibility\n", ASM_C);

  if (!no_idata5)
    {
      fprintf (f, "\t.section\t.idata$5\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "fthunk:\n");
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section\t.idata$4\n");

      fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "\t.section	.idata$4\n");
      fprintf (f, "hname:\n");
    }

  fclose (f);

  assemble_file (TMP_HEAD_S, TMP_HEAD_O);

  return bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
}

static bfd *
make_tail (void)
{
  FILE *f = fopen (TMP_TAIL_S, FOPEN_WT);

  if (f == NULL)
    {
      fatal (_("failed to open temporary tail file: %s"), TMP_TAIL_S);
      return NULL;
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section	.idata$4\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
    }

  if (!no_idata5)
    {
      fprintf (f, "\t.section	.idata$5\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
    }

#ifdef DLLTOOL_PPC
  /* Normally, we need to see a null descriptor built in idata$3 to
     act as the terminator for the list. The ideal way, I suppose,
     would be to mark this section as a comdat type 2 section, so
     only one would appear in the final .exe (if our linker supported
     comdat, that is) or cause it to be inserted by something else (say
     crt0).  */

  fprintf (f, "\t.section	.idata$3\n");
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
#endif

#ifdef DLLTOOL_PPC
  /* Other PowerPC NT compilers use idata$6 for the dllname, so I
     do too. Original, huh?  */
  fprintf (f, "\t.section	.idata$6\n");
#else
  fprintf (f, "\t.section	.idata$7\n");
#endif

  fprintf (f, "\t%s\t__%s_iname\n", ASM_GLOBAL, imp_name_lab);
  fprintf (f, "__%s_iname:\t%s\t\"%s\"\n",
	   imp_name_lab, ASM_TEXT, dll_name);

  fclose (f);

  assemble_file (TMP_TAIL_S, TMP_TAIL_O);

  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
}

static void
gen_lib_file (void)
{
  int i;
  export_type *exp;
  bfd *ar_head;
  bfd *ar_tail;
  bfd *outarch;
  bfd * head  = 0;

  unlink (imp_name);

  outarch = bfd_openw (imp_name, HOW_BFD_WRITE_TARGET);

  if (!outarch)
    /* xgettext:c-format */
    fatal (_("Can't open .lib file: %s"), imp_name);

  /* xgettext:c-format */
  inform (_("Creating library file: %s"), imp_name);

  bfd_set_format (outarch, bfd_archive);
  outarch->has_armap = 1;

  /* Work out a reasonable size of things to put onto one line.  */
  ar_head = make_head ();
  ar_tail = make_tail();

  if (ar_head == NULL || ar_tail == NULL)
    return;

  for (i = 0; (exp = d_exports_lexically[i]); i++)
    {
      bfd *n;
      /* Don't add PRIVATE entries to import lib.  */
      if (exp->private)
	continue;
      n = make_one_lib_file (exp, i);
      n->next = head;
      head = n;
    }

  /* Now stick them all into the archive.  */
  ar_head->next = head;
  ar_tail->next = ar_head;
  head = ar_tail;

  if (! bfd_set_archive_head (outarch, head))
    bfd_fatal ("bfd_set_archive_head");

  if (! bfd_close (outarch))
    bfd_fatal (imp_name);

  while (head != NULL)
    {
      bfd *n = head->next;
      bfd_close (head);
      head = n;
    }

  /* Delete all the temp files.  */
  if (dontdeltemps == 0)
    {
      unlink (TMP_HEAD_O);
      unlink (TMP_HEAD_S);
      unlink (TMP_TAIL_O);
      unlink (TMP_TAIL_S);
    }

  if (dontdeltemps < 2)
    {
      char *name;

      name = (char *) alloca (strlen (TMP_STUB) + 10);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  /* Don't delete non-existent stubs for PRIVATE entries.  */
          if (exp->private)
	    continue;
	  sprintf (name, "%s%05d.o", TMP_STUB, i);
	  if (unlink (name) < 0)
	    /* xgettext:c-format */
	    non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
	}
    }

  inform (_("Created lib file"));
}

/* Run through the information gathered from the .o files and the
   .def file and work out the best stuff.  */

static int
pfunc (const void *a, const void *b)
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;
  if (ap->ordinal == bp->ordinal)
    return 0;

  /* Unset ordinals go to the bottom.  */
  if (ap->ordinal == -1)
    return 1;
  if (bp->ordinal == -1)
    return -1;
  return (ap->ordinal - bp->ordinal);
}

static int
nfunc (const void *a, const void *b)
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;

  return (strcmp (ap->name, bp->name));
}

static void
remove_null_names (export_type **ptr)
{
  int src;
  int dst;

  for (dst = src = 0; src < d_nfuncs; src++)
    {
      if (ptr[src])
	{
	  ptr[dst] = ptr[src];
	  dst++;
	}
    }
  d_nfuncs = dst;
}

static void
dtab (export_type **ptr ATTRIBUTE_UNUSED)
{
#ifdef SACDEBUG
  int i;
  for (i = 0; i < d_nfuncs; i++)
    {
      if (ptr[i])
	{
	  printf ("%d %s @@ %d %s%s%s\n",
		  i, ptr[i]->name, ptr[i]->ordinal,
		  ptr[i]->noname ? "NONAME " : "",
		  ptr[i]->constant ? "CONSTANT" : "",
		  ptr[i]->data ? "DATA" : "");
	}
      else
	printf ("empty\n");
    }
#endif
}

static void
process_duplicates (export_type **d_export_vec)
{
  int more = 1;
  int i;

  while (more)
    {
      more = 0;
      /* Remove duplicates.  */
      qsort (d_export_vec, d_nfuncs, sizeof (export_type *), nfunc);

      dtab (d_export_vec);
      for (i = 0; i < d_nfuncs - 1; i++)
	{
	  if (strcmp (d_export_vec[i]->name,
		      d_export_vec[i + 1]->name) == 0)
	    {
	      export_type *a = d_export_vec[i];
	      export_type *b = d_export_vec[i + 1];

	      more = 1;

	      /* xgettext:c-format */
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d"),
		      a->name, a->ordinal, b->ordinal);

	      if (a->ordinal != -1
		  && b->ordinal != -1)
		/* xgettext:c-format */
		fatal (_("Error, duplicate EXPORT with oridinals: %s"),
		      a->name);

	      /* Merge attributes.  */
	      b->ordinal = a->ordinal > 0 ? a->ordinal : b->ordinal;
	      b->constant |= a->constant;
	      b->noname |= a->noname;
	      b->data |= a->data;
	      d_export_vec[i] = 0;
	    }

	  dtab (d_export_vec);
	  remove_null_names (d_export_vec);
	  dtab (d_export_vec);
	}
    }

  /* Count the names.  */
  for (i = 0; i < d_nfuncs; i++)
    if (!d_export_vec[i]->noname)
      d_named_nfuncs++;
}

static void
fill_ordinals (export_type **d_export_vec)
{
  int lowest = -1;
  int i;
  char *ptr;
  int size = 65536;

  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Fill in the unset ordinals with ones from our range.  */
  ptr = (char *) xmalloc (size);

  memset (ptr, 0, size);

  /* Mark in our large vector all the numbers that are taken.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal != -1)
	{
	  ptr[d_export_vec[i]->ordinal] = 1;

	  if (lowest == -1 || d_export_vec[i]->ordinal < lowest)
	    lowest = d_export_vec[i]->ordinal;
	}
    }

  /* Start at 1 for compatibility with MS toolchain.  */
  if (lowest == -1)
    lowest = 1;

  /* Now fill in ordinals where the user wants us to choose.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal == -1)
	{
	  int j;

	  /* First try within or after any user supplied range.  */
	  for (j = lowest; j < size; j++)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }

	  /* Then try before the range.  */
	  for (j = lowest; j >0; j--)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }
	done:;
	}
    }

  free (ptr);

  /* And resort.  */
  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Work out the lowest and highest ordinal numbers.  */
  if (d_nfuncs)
    {
      if (d_export_vec[0])
	d_low_ord = d_export_vec[0]->ordinal;
      if (d_export_vec[d_nfuncs-1])
	d_high_ord = d_export_vec[d_nfuncs-1]->ordinal;
    }
}

static int
alphafunc (const void *av, const void *bv)
{
  const export_type **a = (const export_type **) av;
  const export_type **b = (const export_type **) bv;

  return strcmp ((*a)->name, (*b)->name);
}

static void
mangle_defs (void)
{
  /* First work out the minimum ordinal chosen.  */
  export_type *exp;

  int i;
  int hint = 0;
  export_type **d_export_vec = xmalloc (sizeof (export_type *) * d_nfuncs);

  inform (_("Processing definitions"));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_export_vec[i] = exp;

  process_duplicates (d_export_vec);
  fill_ordinals (d_export_vec);

  /* Put back the list in the new order.  */
  d_exports = 0;
  for (i = d_nfuncs - 1; i >= 0; i--)
    {
      d_export_vec[i]->next = d_exports;
      d_exports = d_export_vec[i];
    }

  /* Build list in alpha order.  */
  d_exports_lexically = (export_type **)
    xmalloc (sizeof (export_type *) * (d_nfuncs + 1));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_exports_lexically[i] = exp;

  d_exports_lexically[i] = 0;

  qsort (d_exports_lexically, i, sizeof (export_type *), alphafunc);

  /* Fill exp entries with their hint values.  */
  for (i = 0; i < d_nfuncs; i++)
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

  inform (_("Processed definitions"));
}

static void
usage (FILE *file, int status)
{
  /* xgetext:c-format */
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
  /* xgetext:c-format */
  fprintf (file, _("   -m --machine <machine>    Create as DLL for <machine>.  [default: %s]\n"), mname);
  fprintf (file, _("        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\n"));
  fprintf (file, _("   -e --output-exp <outname> Generate an export file.\n"));
  fprintf (file, _("   -l --output-lib <outname> Generate an interface library.\n"));
  fprintf (file, _("   -a --add-indirect         Add dll indirects to export file.\n"));
  fprintf (file, _("   -D --dllname <name>       Name of input dll to put into interface lib.\n"));
  fprintf (file, _("   -d --input-def <deffile>  Name of .def file to be read in.\n"));
  fprintf (file, _("   -z --output-def <deffile> Name of .def file to be created.\n"));
  fprintf (file, _("      --export-all-symbols   Export all symbols to .def\n"));
  fprintf (file, _("      --no-export-all-symbols  Only export listed symbols\n"));
  fprintf (file, _("      --exclude-symbols <list> Don't export <list>\n"));
  fprintf (file, _("      --no-default-excludes  Clear default exclude symbols\n"));
  fprintf (file, _("   -b --base-file <basefile> Read linker generated base file.\n"));
  fprintf (file, _("   -x --no-idata4            Don't generate idata$4 section.\n"));
  fprintf (file, _("   -c --no-idata5            Don't generate idata$5 section.\n"));
  fprintf (file, _("   -U --add-underscore       Add underscores to symbols in interface library.\n"));
  fprintf (file, _("   -k --kill-at              Kill @@<n> from exported names.\n"));
  fprintf (file, _("   -A --add-stdcall-alias    Add aliases without @@<n>.\n"));
  fprintf (file, _("   -S --as <name>            Use <name> for assembler.\n"));
  fprintf (file, _("   -f --as-flags <flags>     Pass <flags> to the assembler.\n"));
  fprintf (file, _("   -C --compat-implib        Create backward compatible import library.\n"));
  fprintf (file, _("   -n --no-delete            Keep temp files (repeat for extra preservation).\n"));
  fprintf (file, _("   -t --temp-prefix <prefix> Use <prefix> to construct temp file names.\n"));
  fprintf (file, _("   -v --verbose              Be verbose.\n"));
  fprintf (file, _("   -V --version              Display the program version.\n"));
  fprintf (file, _("   -h --help                 Display this information.\n"));
#ifdef DLLTOOL_MCORE_ELF
  fprintf (file, _("   -M --mcore-elf <outname>  Process mcore-elf object files into <outname>.\n"));
  fprintf (file, _("   -L --linker <name>        Use <name> as the linker.\n"));
  fprintf (file, _("   -F --linker-flags <flags> Pass <flags> to the linker.\n"));
#endif
  exit (status);
}

#define OPTION_EXPORT_ALL_SYMS		150
#define OPTION_NO_EXPORT_ALL_SYMS	(OPTION_EXPORT_ALL_SYMS + 1)
#define OPTION_EXCLUDE_SYMS		(OPTION_NO_EXPORT_ALL_SYMS + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_EXCLUDE_SYMS + 1)

static const struct option long_options[] =
{
  {"no-delete", no_argument, NULL, 'n'},
  {"dllname", required_argument, NULL, 'D'},
  {"no-idata4", no_argument, NULL, 'x'},
  {"no-idata5", no_argument, NULL, 'c'},
  {"output-exp", required_argument, NULL, 'e'},
  {"output-def", required_argument, NULL, 'z'},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL_SYMS},
  {"no-export-all-symbols", no_argument, NULL, OPTION_NO_EXPORT_ALL_SYMS},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMS},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
  {"output-lib", required_argument, NULL, 'l'},
  {"def", required_argument, NULL, 'd'}, /* for compatibility with older versions */
  {"input-def", required_argument, NULL, 'd'},
  {"add-underscore", no_argument, NULL, 'U'},
  {"kill-at", no_argument, NULL, 'k'},
  {"add-stdcall-alias", no_argument, NULL, 'A'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
  {"help", no_argument, NULL, 'h'},
  {"machine", required_argument, NULL, 'm'},
  {"add-indirect", no_argument, NULL, 'a'},
  {"base-file", required_argument, NULL, 'b'},
  {"as", required_argument, NULL, 'S'},
  {"as-flags", required_argument, NULL, 'f'},
  {"mcore-elf", required_argument, NULL, 'M'},
  {"compat-implib", no_argument, NULL, 'C'},
  {"temp-prefix", required_argument, NULL, 't'},
  {NULL,0,NULL,0}
};

int main (int, char **);

int
main (int ac, char **av)
{
  int c;
  int i;
  char *firstarg = 0;
  program_name = av[0];
  oav = av;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  expandargv (&ac, &av);

  while ((c = getopt_long (ac, av,
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
#else
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
#endif
			   long_options, 0))
	 != EOF)
    {
      switch (c)
	{
	case OPTION_EXPORT_ALL_SYMS:
	  export_all_symbols = TRUE;
	  break;
	case OPTION_NO_EXPORT_ALL_SYMS:
	  export_all_symbols = FALSE;
	  break;
	case OPTION_EXCLUDE_SYMS:
	  add_excludes (optarg);
	  break;
	case OPTION_NO_DEFAULT_EXCLUDES:
	  do_default_excludes = FALSE;
	  break;
	case 'x':
	  no_idata4 = 1;
	  break;
	case 'c':
	  no_idata5 = 1;
	  break;
	case 'S':
	  as_name = optarg;
	  break;
	case 't':
	  tmp_prefix = optarg;
	  break;
	case 'f':
	  as_flags = optarg;
	  break;

	  /* Ignored for compatibility.  */
	case 'u':
	  break;
	case 'a':
	  add_indirect = 1;
	  break;
	case 'z':
	  output_def = fopen (optarg, FOPEN_WT);
	  break;
	case 'D':
	  dll_name = optarg;
	  break;
	case 'l':
	  imp_name = optarg;
	  break;
	case 'e':
	  exp_name = optarg;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	  break;
	case 'm':
	  mname = optarg;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case 'V':
	  print_version (program_name);
	  break;
	case 'U':
	  add_underscore = 1;
	  break;
	case 'k':
	  killat = 1;
	  break;
	case 'A':
	  add_stdcall_alias = 1;
	  break;
	case 'd':
	  def_file = optarg;
	  break;
	case 'n':
	  dontdeltemps++;
	  break;
	case 'b':
	  base_file = fopen (optarg, FOPEN_RB);

	  if (!base_file)
	    /* xgettext:c-format */
	    fatal (_("Unable to open base-file: %s"), optarg);

	  break;
#ifdef DLLTOOL_MCORE_ELF
	case 'M':
	  mcore_elf_out_file = optarg;
	  break;
	case 'L':
	  mcore_elf_linker = optarg;
	  break;
	case 'F':
	  mcore_elf_linker_flags = optarg;
	  break;
#endif
	case 'C':
	  create_compat_implib = 1;
	  break;
	default:
	  usage (stderr, 1);
	  break;
	}
    }

  if (!tmp_prefix)
    tmp_prefix = prefix_encode ("d", getpid ());

  for (i = 0; mtable[i].type; i++)
    if (strcmp (mtable[i].type, mname) == 0)
      break;

  if (!mtable[i].type)
    /* xgettext:c-format */
    fatal (_("Machine '%s' not supported"), mname);

  machine = i;

  if (!dll_name && exp_name)
    {
      int len = strlen (exp_name) + 5;
      dll_name = xmalloc (len);
      strcpy (dll_name, exp_name);
      strcat (dll_name, ".dll");
    }

  if (as_name == NULL)
    as_name = deduce_name ("as");

  /* Don't use the default exclude list if we're reading only the
     symbols in the .drectve section.  The default excludes are meant
     to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */
  if (! export_all_symbols)
    do_default_excludes = FALSE;

  if (do_default_excludes)
    set_default_excludes ();

  if (def_file)
    process_def_file (def_file);

  while (optind < ac)
    {
      if (!firstarg)
	firstarg = av[optind];
      scan_obj_file (av[optind]);
      optind++;
    }

  mangle_defs ();

  if (exp_name)
    gen_exp_file ();

  if (imp_name)
    {
      /* Make imp_name safe for use as a label.  */
      char *p;

      imp_name_lab = xstrdup (imp_name);
      for (p = imp_name_lab; *p; p++)
	{
	  if (!ISALNUM (*p))
	    *p = '_';
	}
      head_label = make_label("_head_", imp_name_lab);
      gen_lib_file ();
    }

  if (output_def)
    gen_def_file ();

#ifdef DLLTOOL_MCORE_ELF
  if (mcore_elf_out_file)
    mcore_elf_gen_out_file ();
#endif

  return 0;
}

/* Look for the program formed by concatenating PROG_NAME and the
   string running from PREFIX to END_PREFIX.  If the concatenated
   string contains a '/', try appending EXECUTABLE_SUFFIX if it is
   appropriate.  */

static char *
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
{
  struct stat s;
  char *cmd;

  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
#ifdef HAVE_EXECUTABLE_SUFFIX
		 + strlen (EXECUTABLE_SUFFIX)
#endif
		 + 10);
  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", prog_name);

  if (strchr (cmd, '/') != NULL)
    {
      int found;

      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
	{
	  /* xgettext:c-format */
	  inform (_("Tried file: %s"), cmd);
	  free (cmd);
	  return NULL;
	}
    }

  /* xgettext:c-format */
  inform (_("Using file: %s"), cmd);

  return cmd;
}

/* Deduce the name of the program we are want to invoke.
   PROG_NAME is the basic name of the program we want to run,
   eg "as" or "ld".  The catch is that we might want actually
   run "i386-pe-as" or "ppc-pe-ld".

   If argv[0] contains the full path, then try to find the program
   in the same place, with and then without a target-like prefix.

   Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,
   deduce_name("as") uses the following search order:

     /usr/local/bin/i586-cygwin32-as
     /usr/local/bin/as
     as

   If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each
   name, it'll try without and then with EXECUTABLE_SUFFIX.

   Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"
   as the fallback, but rather return i586-cygwin32-as.

   Oh, and given, argv[0] = dlltool, it'll return "as".

   Returns a dynamically allocated string.  */

static char *
deduce_name (const char *prog_name)
{
  char *cmd;
  char *dash, *slash, *cp;

  dash = NULL;
  slash = NULL;
  for (cp = program_name; *cp != '\0'; ++cp)
    {
      if (*cp == '-')
	dash = cp;
      if (
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
	  *cp == ':' || *cp == '\\' ||
#endif
	  *cp == '/')
	{
	  slash = cp;
	  dash = NULL;
	}
    }

  cmd = NULL;

  if (dash != NULL)
    {
      /* First, try looking for a prefixed PROG_NAME in the
         PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
      cmd = look_for_prog (prog_name, program_name, dash - program_name + 1);
    }

  if (slash != NULL && cmd == NULL)
    {
      /* Next, try looking for a PROG_NAME in the same directory as
         that of this program.  */
      cmd = look_for_prog (prog_name, program_name, slash - program_name + 1);
    }

  if (cmd == NULL)
    {
      /* Just return PROG_NAME as is.  */
      cmd = xstrdup (prog_name);
    }

  return cmd;
}

#ifdef DLLTOOL_MCORE_ELF
typedef struct fname_cache
{
  char *               filename;
  struct fname_cache * next;
}
fname_cache;

static fname_cache fnames;

static void
mcore_elf_cache_filename (char * filename)
{
  fname_cache * ptr;

  ptr = & fnames;

  while (ptr->next != NULL)
    ptr = ptr->next;

  ptr->filename = filename;
  ptr->next     = (fname_cache *) malloc (sizeof (fname_cache));
  if (ptr->next != NULL)
    ptr->next->next = NULL;
}

#define MCORE_ELF_TMP_OBJ "mcoreelf.o"
#define MCORE_ELF_TMP_EXP "mcoreelf.exp"
#define MCORE_ELF_TMP_LIB "mcoreelf.lib"

static void
mcore_elf_gen_out_file (void)
{
  fname_cache * ptr;
  dyn_string_t ds;

  /* Step one.  Run 'ld -r' on the input object files in order to resolve
     any internal references and to generate a single .exports section.  */
  ptr = & fnames;

  ds = dyn_string_new (100);
  dyn_string_append_cstr (ds, "-r ");

  if (mcore_elf_linker_flags != NULL)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  while (ptr->next != NULL)
    {
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");

      ptr = ptr->next;
    }

  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (mcore_elf_linker == NULL)
    mcore_elf_linker = deduce_name ("ld");

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (verbose)
    dyn_string_append_cstr (ds, " -v");

  if (dontdeltemps)
    {
      dyn_string_append_cstr (ds, " -n");

      if (dontdeltemps > 1)
	dyn_string_append_cstr (ds, " -n");
    }

  /* XXX - FIME: ought to check/copy other command line options as well.  */
  run (program_name, ds->s);

  dyn_string_delete (ds);

  /* Step four. Feed the .exp and object files to ld -shared to create the dll.  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-shared ");

  if (mcore_elf_linker_flags)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  if (dontdeltemps == 0)
    unlink (MCORE_ELF_TMP_EXP);

  if (dontdeltemps < 2)
    unlink (MCORE_ELF_TMP_OBJ);
}
#endif /* DLLTOOL_MCORE_ELF */
@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d3205 2
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d52 1
a52 1
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d63 1
a63 1
   function will be refered to in the body of the DLL.
d270 2
a271 4
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));
d274 2
a275 4
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
d349 1
a349 1
static char *tmp_prefix = "d";
d439 6
a444 6
#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")
d446 1
a446 1
/* This bit of assemly does jmp * ....  */
d646 2
a647 1
    int noname;
d665 24
a688 48
static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
d690 1
a690 2
static void dump_iat
  PARAMS ((FILE *, export_type *));
d692 16
a707 32
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));
d710 1
a710 1
dlltmp PARAMS ((char *buf, const char *fmt))
d712 9
a720 3
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
d724 11
d750 1
a750 2
rvaafter (machine)
     int machine;
d774 1
a774 2
rvabefore (machine)
     int machine;
d798 1
a798 2
asm_prefix (machine)
     int machine;
d822 2
a823 2
#define ASM_BYTE 	mtable[machine].how_byte
#define ASM_SHORT 	mtable[machine].how_short
d826 2
a827 2
#define ASM_C 		mtable[machine].how_comment
#define ASM_JUMP 	mtable[machine].how_jump
d831 2
a832 2
#define ASM_RVA_BEFORE 	rvabefore(machine)
#define ASM_RVA_AFTER  	rvaafter(machine)
d846 1
a846 2
process_def_file (name)
     const char *name;
d883 1
a883 2
yyerror (err)
     const char * err ATTRIBUTE_UNUSED;
d892 2
a893 7
def_exports (name, internal_name, ordinal, noname, constant, data)
     const char *name;
     const char *internal_name;
     int ordinal;
     int noname;
     int constant;
     int data;
d902 1
d916 1
a916 3
def_name (name, base)
     const char *name;
     int base;
d933 1
a933 3
def_library (name, base)
     const char *name;
     int base;
d949 1
a949 2
def_description (desc)
     const char *desc;
d958 1
a958 2
new_directive (dir)
     char *dir;
d967 1
a967 3
def_heapsize (reserve, commit)
     int reserve;
     int commit;
d978 1
a978 3
def_stacksize (reserve, commit)
     int reserve;
     int commit;
d992 1
a992 4
append_import (symbol_name, dll_name, func_ordinal)
     const char *symbol_name;
     const char *dll_name;
     int func_ordinal;
d1056 2
a1057 6
def_import (app_name, module, dllext, entry, ord_val)
     const char *app_name;
     const char *module;
     const char *dllext;
     const char *entry;
     int ord_val;
d1083 1
a1083 3
def_version (major, minor)
     int major;
     int minor;
d1089 1
a1089 3
def_section (name, attr)
     const char *name;
     int attr;
d1109 1
a1109 2
def_code (attr)
     int attr;
d1116 1
a1116 2
def_data (attr)
     int attr;
d1124 1
a1124 3
run (what, args)
     const char *what;
     char *args;
d1199 1
a1199 2
scan_drectve_symbols (abfd)
     bfd *abfd;
d1255 1
a1255 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION));
d1264 1
a1264 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0);
d1277 2
a1278 5
scan_filtered_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1303 1
a1303 1
		   ! (sym->flags & BSF_FUNCTION));
d1312 1
a1312 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0);
d1320 1
a1320 2
add_excludes (new_excludes)
     const char *new_excludes;
d1353 1
a1353 2
match_exclude (string)
     const char *string;
d1374 1
a1374 5
filter_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1392 1
a1392 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
d1418 1
a1418 2
scan_all_symbols (abfd)
     bfd *abfd;
d1421 1
a1421 1
  PTR minisyms;
d1460 1
a1460 2
scan_open_obj_file (abfd)
     bfd *abfd;
d1474 1
a1474 2
scan_obj_file (filename)
     const char *filename;
d1517 1
a1517 2
dump_def_info (f)
     FILE *f;
d1527 1
a1527 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s\n",
d1534 1
d1543 1
a1543 3
sfunc (a, b)
     const void *a;
     const void *b;
d1549 1
a1549 5
flush_page (f, need, page_addr, on_page)
     FILE *f;
     long *need;
     int page_addr;
     int on_page;
d1579 1
a1579 1
gen_def_file ()
d1599 1
a1599 1
 	  fprintf (output_def,";\t%s\n", res);
d1605 1
a1605 2

	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
d1611 1
d1616 1
a1616 1
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1618 1
a1618 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
d1627 1
d1640 1
a1640 2
generate_idata_ofile (filvar)
     FILE *filvar;
d1732 1
a1732 3
assemble_file (source, dest)
     const char * source;
     const char * dest;
d1745 1
a1745 1
gen_exp_file ()
d1852 2
a1853 2
	if (!exp->noname || show_allnames)
	  {
d1856 4
a1859 4
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }
d1954 1
a1954 1
	  /* Delete duplcates */
d1995 1
a1995 2
xlate (name)
     const char *name;
d2025 1
a2025 3
dump_iat (f, exp)
     FILE *f;
     export_type *exp;
d2155 1
a2155 3
make_label (prefix, name)
     const char *prefix;
     const char *name;
d2167 1
a2167 3
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
d2191 1
a2191 3
make_one_lib_file (exp, i)
     export_type *exp;
     int i;
d2264 1
a2264 1
      char *     outname = xmalloc (10);
d2375 1
a2375 1
      /* The symbol refering to the code (.text).  */
d2656 1
a2656 1
make_head ()
d2715 1
a2715 1
make_tail ()
d2773 1
a2773 1
gen_lib_file ()
d2805 5
a2809 1
      bfd *n = make_one_lib_file (exp, i);
d2845 2
a2846 2
      name = (char *) alloca (sizeof TMP_STUB + 10);
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
d2848 3
a2860 2
/**********************************************************************/

d2863 1
d2865 1
a2865 3
pfunc (a, b)
     const void *a;
     const void *b;
d2881 1
a2881 3
nfunc (a, b)
     const void *a;
     const void *b;
d2890 1
a2890 2
remove_null_names (ptr)
     export_type **ptr;
d2907 1
a2907 6
dtab (ptr)
     export_type ** ptr
#ifndef SACDEBUG
ATTRIBUTE_UNUSED
#endif
     ;
d2928 1
a2928 2
process_duplicates (d_export_vec)
     export_type **d_export_vec;
a2934 1

a2944 1

a2973 1

d2976 2
a2977 4
    {
      if (!d_export_vec[i]->noname)
	d_named_nfuncs++;
    }
d2981 1
a2981 2
fill_ordinals (d_export_vec)
     export_type **d_export_vec;
d3016 1
a3016 1
	  register int j;
d3055 1
a3055 3
alphafunc (av,bv)
     const void *av;
     const void *bv;
d3064 1
a3064 1
mangle_defs ()
d3071 1
a3071 2
  export_type **d_export_vec
  = (export_type **) xmalloc (sizeof (export_type *) * d_nfuncs);
a3107 2
/**********************************************************************/

d3109 1
a3109 3
usage (file, status)
     FILE *file;
     int status;
d3136 1
d3166 1
a3166 1
  {"def", required_argument, NULL, 'd'}, /* for compatiblity with older versions */
d3185 1
a3185 1
int main PARAMS ((int, char **));
d3188 1
a3188 3
main (ac, av)
     int ac;
     char **av;
d3244 1
a3244 1
	  /* ignored for compatibility */
d3318 3
d3399 1
a3399 4
look_for_prog (prog_name, prefix, end_prefix)
     const char *prog_name;
     const char *prefix;
     int end_prefix;
d3465 1
a3465 2
deduce_name (prog_name)
     const char *prog_name;
@


1.7
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d23 1
a23 2
/*
   This program allows you to build the files necessary to create
d50 3
a52 1
   EXPORTS  ( <name1> [ = <name2> ] [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d54 3
a56 1
   DLL, with optional ordinal number <integer>
d117 1
a117 1
   
d164 1
a164 1
 
d168 1
a168 1
 
d172 1
a172 1
 
d182 1
a182 1
 
d187 1
a187 1
 
d192 1
a192 1
 
d196 2
a197 3
 
   ld -o thedll.dll thedll.exp file1.o file2.o
 */
d233 1
a233 2
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc)
*/
d253 1
a254 1
#include <ctype.h>
d270 4
a273 2
static char *look_for_prog PARAMS ((const char *, const char *, int));
static char *deduce_name PARAMS ((const char *));
d276 4
a279 2
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
d281 1
a281 1
     
d287 1
a287 1
#define WIFEXITED(w)	(((w)&0377) == 0)
d290 1
a290 1
#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
d331 2
a332 2
  char          *name;   /* name of function being imported */
  int            ord;    /* two-byte ordinal value associated with function */
d338 5
a342 5
  char          *dllname;  /* name of dll file imported from */
  long           nfuncs;   /* number of functions in list */
  struct ifunct *funchead; /* first function in list */
  struct ifunct *functail; /* last  function in list */
  struct iheadt *next;     /* next dll file in list */
d353 2
d367 1
a367 1
/* True if we should export all symbols.  Otherwise, we only export
d369 1
a369 1
static boolean export_all_symbols;
d371 1
a371 1
/* True if we should exclude the symbols in DEFAULT_EXCLUDES when
d373 1
a373 1
static boolean do_default_excludes;
d378 1
a378 1
/* True if we should add __imp_<SYMBOL> to import libraries for backward 
d380 1
a380 1
static boolean create_compat_implib;
d434 1
a434 1
#define PATHMAX 250		/* What's the right name for this ? */
d436 13
a448 6
#define TMP_ASM		"dc.s"
#define TMP_HEAD_S	"dh.s"
#define TMP_HEAD_O	"dh.o"
#define TMP_TAIL_S	"dt.s"
#define TMP_TAIL_O	"dt.o"
#define TMP_STUB	"ds"
d450 1
a450 1
/* This bit of assemly does jmp * .... */
d485 1
a485 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */  
d488 1
a488 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d494 1
a494 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */  
d497 1
a497 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d500 5
a504 5
/* This is the glue sequence for PowerPC PE. There is a  */
/* tocrel16-tocdefn reloc against the first instruction. */
/* We also need a IMGLUE reloc against the glue function */
/* to restore the toc saved by the third instruction in  */
/* the glue. */
d517 2
a518 2
/* the glue instruction, picks up the toc from the stw in */
/* the above code: "lwz r2,4(r1)"                         */
d539 2
a540 2
    int how_jtab_size; /* size of the jtab entry */
    int how_jtab_roff; /* offset into it for the ind 32 reloc into idata 5 */
d653 1
d659 1
a659 1
 
d668 48
a715 21
static const char *rvaafter PARAMS ((int));
static const char *rvabefore PARAMS ((int));
static const char *asm_prefix PARAMS ((int));
static void append_import PARAMS ((const char *, const char *, int));
static void run PARAMS ((const char *, char *));
static void scan_drectve_symbols PARAMS ((bfd *));
static void scan_filtered_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes PARAMS ((const char *));
static boolean match_exclude PARAMS ((const char *));
static void set_default_excludes PARAMS ((void));
static long filter_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols PARAMS ((bfd *));
static void scan_open_obj_file PARAMS ((bfd *));
static void scan_obj_file PARAMS ((const char *));
static void dump_def_info PARAMS ((FILE *));
static int sfunc PARAMS ((const void *, const void *));
static void flush_page PARAMS ((FILE *, long *, int, int));
static void gen_def_file PARAMS ((void));
static void generate_idata_ofile PARAMS ((FILE *));
static void gen_exp_file PARAMS ((void));
static const char *xlate PARAMS ((const char *));
d717 2
a718 1
static void dump_iat PARAMS ((FILE *, export_type *));
d720 32
a751 15
static char *make_label PARAMS ((const char *, const char *));
static bfd *make_one_lib_file PARAMS ((export_type *, int));
static bfd *make_head PARAMS ((void));
static bfd *make_tail PARAMS ((void));
static void gen_lib_file PARAMS ((void));
static int pfunc PARAMS ((const void *, const void *));
static int nfunc PARAMS ((const void *, const void *));
static void remove_null_names PARAMS ((export_type **));
static void dtab PARAMS ((export_type **));
static void process_duplicates PARAMS ((export_type **));
static void fill_ordinals PARAMS ((export_type **));
static int alphafunc PARAMS ((const void *, const void *));
static void mangle_defs PARAMS ((void));
static void usage PARAMS ((FILE *, int));
static void inform PARAMS ((const char *, ...));
d753 8
d763 1
a763 7
#ifdef __STDC__
inform (const char * message, ...)
#else
inform (message, va_alist)
     const char * message;
     va_dcl
#endif
d765 3
a767 2
  va_list args;
  
d771 1
a771 5
#ifdef __STDC__
  va_start (args, message);
#else
  va_start (args);
#endif
d773 1
a773 3
  report (message, args);
  
  va_end (args);
d875 1
a875 1
void
d880 1
a880 1
  
d889 1
a889 1
  
d897 1
a897 1
/* Communications with the parser */
d899 10
a908 9
static const char *d_name;	/* Arg to NAME or LIBRARY */
static int d_nfuncs;		/* Number of functions exported */
static int d_named_nfuncs;	/* Number of named functions exported */
static int d_low_ord;		/* Lowest ordinal index */
static int d_high_ord;		/* Highest ordinal index */
static export_type *d_exports;	/*list of exported functions */
static export_type **d_exports_lexically;	/* vector of exported functions in alpha order */
static dlist_type *d_list;	/* Descriptions */
static dlist_type *a_list;	/* Stuff to go in directives */
d919 1
a919 1
  
d943 6
d958 1
a958 1
  
d961 1
a961 1
  
d963 2
a964 2
  /* if --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables? */
d977 1
a977 1
  
d980 1
a980 1
  
d982 1
a982 1
  /* if --dllname not provided, use the one in the DEF file. */
d998 1
a998 1
void
d1124 1
a1124 1
  
d1229 1
a1229 1
      
d1234 1
a1234 1
  
d1271 1
a1271 1
  
d1274 1
a1274 1
      
d1279 1
a1279 1
      
d1297 1
a1297 1
	  
d1305 1
a1305 1
	  if (p < e && *p == ',')       /* found type tag. */
d1321 2
a1322 1
	      char *exported_name = xstrdup (c);
d1359 1
a1359 1
      sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
d1372 2
a1373 1
	  char *exported_name = xstrdup (symbol_name);
d1376 1
a1376 1
	  /* Note: stdcall alias symbols can never be data. */
d1397 1
a1397 1
      
d1401 5
a1405 2
      /* FIXME: Is it always right to add a leading underscore?  */
      sprintf (new_exclude->string, "_%s", exclude_string);
d1418 1
a1418 1
static boolean
d1426 2
a1427 2
      return true;
  return false;
d1463 1
a1463 1
      sym = bfd_minisymbol_to_symbol (abfd, false, (const PTR) from, store);
d1472 1
a1472 1
      
d1509 1
a1509 1
  symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);
d1539 2
a1540 2
 
  /* FIXME: we ought to read in and block out the base relocations */
d1558 1
a1558 1
  
d1569 1
a1569 1
      
d1614 1
a1614 1
/* Generate the .exp file */
d1633 1
a1633 1
  /* Flush this page */
d1642 1
a1642 1
  
d1646 1
a1646 1
      
d1649 1
a1649 1
  
d1652 1
a1652 1
  
d1665 1
a1665 1
  
d1677 6
d1684 1
a1684 1
        {
d1686 1
a1686 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s ; %s\n",
d1692 1
a1692 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
d1694 3
a1696 3
      else 
        {
          char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1698 1
a1698 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s ; %s\n",
d1707 1
a1707 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
a1708 2
      if (res)
        free (res);
d1710 1
a1710 1
  
d1810 1
a1810 1
/* Assemble the specified file. */
d1817 1
a1817 1
  
d1836 1
a1836 1
  
d1841 1
a1841 1
  
d1846 1
a1846 1
  
d1897 14
a1910 3
	  fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
                   ASM_PREFIX,
                   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1935 7
a1941 2
	  fprintf (f, "n%d:	%s	\"%s\"\n",
		   exp->ordinal, ASM_TEXT, exp->name);
d1951 1
a1951 1
      
d1959 1
a1959 1
	      
d2007 1
a2007 1
  /* Dump the reloc section if a base file is provided */
d2067 1
a2067 1
  /* assemble the file */
d2072 1
a2072 1
  
d2080 3
a2082 1
  if (add_underscore)
d2085 1
d2094 2
d2138 1
a2138 1
  unsigned   char *data;
d2153 7
a2159 1
#define INIT_SEC_DATA(id, name, flags, align) { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2162 7
a2168 7
  INIT_SEC_DATA (TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (DATA,   ".data",    SEC_DATA,                    2),
  INIT_SEC_DATA (BSS,    ".bss",     0,                           2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1)
d2173 2
a2174 2
/* Sections numbered to make the order the same as other PowerPC NT    */
/* compilers. This also keeps funny alignment thingies from happening. */
d2202 2
a2203 3
/*
This is what we're trying to make.  We generate the imp symbols with
both single and double underscores, for compatibility.
d2226 1
a2226 1
For the PowerPC, here's the variation on the above scheme:
d2237 1
a2237 2
	 bctr
*/
d2246 1
d2253 26
d2339 1
a2339 1
      asymbol *  iname;
d2353 1
d2358 1
a2358 1
      
d2360 1
a2360 1
      
d2362 1
a2362 1
      
d2369 1
a2369 1
      
d2377 4
a2380 2
      
      /* First make symbols for the sections */
d2389 1
a2389 1
				 si->flags);
d2409 1
a2409 1
	  exp_label->name = make_label ("", exp->name);
d2414 1
a2414 1
	     points to the .toc */
d2438 1
a2438 1
	  iname->name = make_label ("__imp_", exp->name);
d2445 1
a2445 1
      iname2->name = make_label ("_imp__", exp->name);
a2456 1

d2466 1
a2466 1
      /* The symbol refering to the code (.text) */
d2480 1
a2480 1
      /* The .toc symbol */
d2482 1
a2482 1
	asymbol *toc_symbol;    /* The .toc symbol */
d2494 1
a2494 1
      
d2515 1
a2515 1
		  
d2519 1
a2519 1
		  
d2541 1
a2541 1
		 rva to idata$6 */
d2586 1
a2586 1
	      si->data =xmalloc(4);
d2602 10
a2611 10
		/* The .pdata section is 5 words long. */
		/* Think of it as:                     */
		/* struct                              */
		/* {                                   */
		/*   bfd_vma BeginAddress,     [0x00]  */
		/*           EndAddress,       [0x04]  */
		/*	     ExceptionHandler, [0x08]  */
		/*	     HandlerData,      [0x0c]  */
		/*	     PrologEndAddress; [0x10]  */
		/* };                                  */
d2626 1
a2626 2
		      that this is a glue routine.
		*/
d2629 1
a2629 1
		/* alignment must be set to 2**2 or you get extra stuff */
d2633 1
a2633 1
		si->data =xmalloc(4 * 5);
d2642 1
a2642 1
		/* stick the toc reload instruction in the glue reloc */
d2655 1
a2655 1
		bfd_put_32(abfd, 0x18, si->data + 0x04);
d2661 2
a2662 2
		/* mark it as glue */
		bfd_put_32(abfd, 0x03, si->data + 0x0c);
d2664 2
a2665 2
		/* mark the prolog end address */
		bfd_put_32(abfd, 0x0D, si->data + 0x10);
d2680 1
a2680 3
	         We use relocs to build this.
	      */

d2711 1
a2711 1
	/* Size up all the sections */
d2722 1
a2722 1
      /* Write them out */
d2756 1
a2756 1
  
d2788 1
a2788 1
  
d2797 1
a2797 1
  
d2815 1
a2815 1
  
d2821 1
a2821 1
  
d2834 1
a2834 2
     crt0)
  */
d2846 1
a2846 1
     do too. Original, huh? */
d2859 2
a2860 2
  
  return  bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d2883 1
a2883 1
  
d2887 1
a2887 2
  /* Work out a reasonable size of things to put onto one line. */

d2893 1
a2893 1
  
d2901 1
a2901 2
  /* Now stick them all into the archive */

d2908 1
a2908 1
  
d2919 1
a2919 2
  /* Delete all the temp files */

d2941 1
a2941 1
  
d2948 1
a2948 1
   .def file and work out the best stuff */
d2959 1
a2959 1
  /* unset ordinals go to the bottom */
d2984 1
d3028 1
d3033 1
a3033 1
      /* Remove duplicates */
d3047 1
a3047 1
	      
d3051 1
a3051 1
	      
d3058 1
a3058 1
	      /* Merge attributes */
d3073 1
a3073 1
  /* Count the names */
d3092 1
a3092 2
  /* fill in the unset ordinals with ones from our range */

d3097 1
a3097 1
  /* Mark in our large vector all the numbers that are taken */
d3103 1
d3105 1
a3105 3
	    {
	      lowest = d_export_vec[i]->ordinal;
	    }
d3113 1
a3113 1
  /* Now fill in ordinals where the user wants us to choose. */
d3120 1
a3120 1
	  /* First try within or after any user supplied range. */
d3129 1
a3129 1
	  /* Then try before the range. */
d3143 1
a3143 2
  /* And resort */

d3170 1
a3170 2
  /* First work out the minimum ordinal chosen */

d3179 1
a3179 1
  
d3181 1
a3181 3
    {
      d_export_vec[i] = exp;
    }
d3186 1
a3186 1
  /* Put back the list in the new order */
d3194 1
a3194 1
  /* Build list in alpha order */
d3199 2
a3200 3
    {
      d_exports_lexically[i] = exp;
    }
d3205 4
a3208 1
  /* Fill exp entries with their hint values */
a3209 6
  for (i = 0; i < d_nfuncs; i++)
    {
      if (!d_exports_lexically[i]->noname || show_allnames)
	d_exports_lexically[i]->hint = hint++;
    }
  
d3221 1
a3221 1
  fprintf (file, _("Usage %s <options> <object-files>\n"), program_name);
d3289 1
d3293 2
d3309 3
d3316 2
a3317 2
#ifdef DLLTOOL_MCORE_ELF			   
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVhM:L:F:",
d3319 1
a3319 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVh",
d3327 1
a3327 1
	  export_all_symbols = true;
d3330 1
a3330 1
	  export_all_symbols = false;
d3336 1
a3336 1
	  do_default_excludes = false;
d3347 3
d3372 1
d3402 1
a3402 1
	  
d3448 1
a3448 1
  
d3453 2
a3454 2
    do_default_excludes = false;
  
d3473 1
a3473 1
  
d3476 1
a3476 1
      /* Make imp_name safe for use as a label. */
d3482 1
a3482 1
	  if (!isalpha ((unsigned char) *p) && !isdigit ((unsigned char) *p))
d3488 1
a3488 1
  
d3491 1
a3491 1
  
d3496 1
a3496 1
  
d3514 2
a3515 2
  cmd = xmalloc (strlen (prefix) 
                 + strlen (prog_name) 
d3517 1
a3517 1
                 + strlen (EXECUTABLE_SUFFIX) 
d3530 1
a3530 1
               || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3535 1
a3535 1
        {
d3552 1
a3552 1
   run "i386-pe-as" or "ppc-pe-ld".  
d3558 1
a3558 1
   deduce_name("as") uses the following search order: 
d3563 1
a3563 1
   
d3569 1
a3569 1
     
d3664 1
a3664 1
  dyn_string_append (ds, "-r ");
d3667 2
a3668 2
    dyn_string_append (ds, mcore_elf_linker_flags);
  
d3671 2
a3672 2
      dyn_string_append (ds, ptr->filename);
      dyn_string_append (ds, " ");
d3677 2
a3678 2
  dyn_string_append (ds, "-o ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3682 1
a3682 1
  
d3687 2
a3688 2
  /* Step two. Create a .exp file and a .lib file from the temporary file. 
     Do this by recursively invoking dlltool....*/
d3691 9
a3699 9
  dyn_string_append (ds, "-S ");
  dyn_string_append (ds, as_name);
  
  dyn_string_append (ds, " -e ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " -l ");
  dyn_string_append (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append (ds, " " );
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3702 2
a3703 2
    dyn_string_append (ds, " -v");
  
d3706 2
a3707 2
      dyn_string_append (ds, " -n");
  
d3709 1
a3709 1
	dyn_string_append (ds, " -n");
a3712 1
  
d3720 1
a3720 1
  dyn_string_append (ds, "-shared ");
d3723 1
a3723 1
    dyn_string_append (ds, mcore_elf_linker_flags);
d3725 6
a3730 6
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append (ds, " -o ");
  dyn_string_append (ds, mcore_elf_out_file);
@


1.6
log
@Avoid calls to insecure choose_temp_base
@
text
@d2 2
a3 1
   Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d387 3
d392 1
d613 1
a613 1
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
d734 1
d759 1
d783 1
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1120 1
d1122 3
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 4
#define show_allnames 0

/* dlltool.c -- tool to generate stuff for PE style DLLs 
   Copyright (C) 1995 Free Software Foundation, Inc.
d18 2
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 1
a34 1
   referencing program. 
d39 1
a39 1
   with export information.  
d44 1
a44 1
   NAME <name> [ , <base> ] 
d47 1
a47 1
   LIBRARY <name> [ , <base> ]    
d50 1
a50 1
   EXPORTS  ( <name1> [ = <name2> ] [ @@ <integer> ] [ NONAME ] [CONSTANT] ) *
d54 6
a59 2
   IMPORTS  ( [ <name> = ] <name> . <name> ) *
   Ignored for compatibility
d84 1
a84 1
   on the command line, or in the def file, or taken from the first 
d95 2
a96 2
   file1.c: 
   asm (".section .drectve");  
d99 1
a99 1
   adef(char *s)
d101 1
a101 1
   printf("hello from the dll %s\n",s);
d104 1
a104 1
   bdef(char *s)
d106 1
a106 1
   printf("hello from the dll and the other entry point %s\n",s);
d109 1
a109 1
   file2.c:
d113 2
a114 1
   cdef(char *s)
d116 1
a116 1
   printf("hello from the dll %s\n",s);
d119 1
a119 1
   ddef(char *s)
d121 1
a121 1
   printf("hello from the dll and the other entry point %s\n",s);
d124 1
a124 1
   printf()
d126 1
a126 1
   return 9;
d129 2
a130 3
   main.c

   main()
d132 2
a133 1
   cdef();
d136 1
a136 1
   thedll.def
d141 1
a141 1
   cdef @@ 30 NONAME 
d146 1
d148 1
a148 1
   # compile up the parts of the dll
d150 3
a152 5
   gcc -c file1.c       
   gcc -c file2.c

   # put them in a library (you don't have to, you
   # could name all the .os on the dlltool line)
d157 5
a161 2
   # run this tool over the library and the def file
   ./dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a
d163 2
a164 1
   # build the dll with the library with file1.o, file2.o and the export table
d167 7
a173 2
   # build the mainline
   gcc -c themain.c 
d175 1
a175 2
   # link the executable with the import library
   ld -e main -Tthemain.ld -o themain.exe themain.o thedll.a
d177 17
d205 1
a205 1
	DWORD   Characteristics;      - pointer to .idata$4
d233 9
d249 3
d253 23
d278 2
a279 1
#else
d292 12
d305 33
d339 4
a342 3
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
d344 2
a345 1
char *as_name = "as";
d359 15
a373 2
int yyparse();
int yydebug;
d376 1
a376 3
static char *program_name;
char *strrchr ();
char *strdup ();
d379 2
a380 1
int killat;
d382 2
a383 2
FILE *output_def;
FILE *base_file;
d386 1
a386 1
static char *mname = "arm";
d390 1
a390 1
static char *mname = "i386";
d394 26
a419 1
static char *mname = "ppc";
d424 12
a435 3
/* This bit of assemly does jmp * ....
s set how_jtab_roff to mark where the 32bit abs branch should go */
unsigned char i386_jtab[] = { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90};
d437 6
d444 36
a479 3
unsigned char arm_jtab[] = { 0x00, 0xc0, 0x9f, 0xe5,
                             0x00, 0xf0, 0x9c, 0xe5,
			        0,     0,   0,    0};
d486 2
a487 2
unsigned char ppc_jtab[] = 
{ 
d497 1
d500 2
a501 2
bfd_vma ppc_glue_insn = 0x80410004;

a502 1
char outfile[PATHMAX];
d505 13
a517 12
    char *type;
    char *how_byte;
    char *how_short;
    char *how_long;
    char *how_asciz;
    char *how_comment;
    char *how_jump;
    char *how_global;
    char *how_space;
    char *how_align_short;
    char *how_align_long;
    char *how_bfd_target;
d519 1
a519 1
    unsigned char *how_jtab;
d522 4
a525 3
  }
mtable[]
=
d529 1
a529 1
    "arm", ".byte", ".short", ".long", ".asciz", "@@", 
d531 3
a533 2
    ".global", ".space", ".align\t2",".align\t4","pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof(arm_jtab),8
d538 4
a541 2
    "i386", ".byte", ".short", ".long", ".asciz", "#", "jmp *", ".global", ".space", ".align\t2",".align\t4","pe-i386",bfd_arch_i386,
   i386_jtab,sizeof(i386_jtab),2,
d546 13
a558 2
    "ppc", ".byte", ".short", ".long", ".asciz", "#", "jmp *", ".global", ".space", ".align\t2",".align\t4","pe-powerpcle",bfd_arch_powerpc,
   ppc_jtab,sizeof(ppc_jtab),0,
d561 83
a643 1
{    0}
d646 56
d703 12
a714 1
char *
a720 1
      return "";
a721 1
      return "";
d723 11
a733 1
      return "";
d735 1
a735 1
return "";
d738 1
a738 1
char *
a744 1
      return ".rva\t";
a745 1
      return ".rva\t";
d747 6
d754 4
d759 1
a759 1
return "";
d762 1
a762 1
char *
d764 1
a764 1
int machine;
d769 8
a776 1
      return "";
d779 4
a782 2
    case MPPC:
      return "";
d784 1
a784 1
return "";
d786 1
d799 9
a807 6
#define ASM_ALIGN_LONG mtable[machine].how_align_long
#define HOW_BFD_TARGET  0  /* always default*/
#define HOW_BFD_ARCH   mtable[machine].how_bfd_arch
#define HOW_JTAB       mtable[machine].how_jtab
#define HOW_JTAB_SIZE      mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF      mtable[machine].how_jtab_roff
a809 3

FILE *yyin;			/* communications with flex */
extern int linenumber;
d812 1
a812 1
     char *name;
d815 1
d817 2
a818 4
    {
      fprintf (stderr, "%s: Can't open def file %s\n", program_name, name);
      exit (1);
    }
d822 3
d826 2
d834 1
a834 21

typedef struct dlist
{
  char *text;
  struct dlist *next;
}
dlist_type;

typedef struct export
  {
    char *name;
    char *internal_name;
    int ordinal;
    int constant;
    int noname;
    int hint;
    struct export *next;
  }
export_type;

static char *d_name;		/* Arg to NAME or LIBRARY */
d847 3
a849 2
int 
yyerror ()
d851 3
a853 2
  fprintf (stderr, "%s: Syntax error in def file %s:%d\n",
	   program_name, def_file, linenumber);
d858 3
a860 3
def_exports (name, internal_name, ordinal, noname, constant)
     char *name;
     char *internal_name;
d864 1
d873 1
a878 1

d881 1
a881 1
     char *name;
d884 3
a886 2
  if (verbose)
    fprintf (stderr, "%s NAME %s base %x\n", program_name, name, base);
d888 2
a889 3
    {
      fprintf (stderr, "Can't have LIBRARY and NAME\n");
    }
d891 4
d900 1
a900 1
     char *name;
d903 3
a905 2
  if (verbose)
    printf ("%s: LIBRARY %s base %x\n", program_name, name, base);
d907 2
a908 3
    {
      fprintf (stderr, "%s: Can't have LIBRARY and NAME\n", program_name);
    }
d910 3
d918 1
a918 1
     char *desc;
d921 1
a921 1
  d->text = strdup (desc);
d931 1
a931 1
  d->text = strdup (dir);
d937 1
a937 1
def_stacksize (reserve, commit)
d943 1
a943 1
    sprintf (b, "-stack 0x%x,0x%x ", reserve, commit);
d945 2
a946 2
    sprintf (b, "-stack 0x%x ", reserve);
  new_directive (strdup (b));
d950 1
a950 1
def_heapsize (reserve, commit)
d956 1
a956 1
    sprintf (b, "-heap 0x%x,0x%x ", reserve, commit);
d958 2
a959 2
    sprintf (b, "-heap 0x%x ", reserve);
  new_directive (strdup (b));
d962 2
d965 74
a1038 5
void
def_import (internal, module, entry)
     char *internal;
     char *module;
     char *entry;
d1040 21
a1060 2
  if (verbose)
    fprintf (stderr, "%s: IMPORTS are ignored", program_name);
d1065 2
a1066 2
int major;
int minor;
a1070 1

d1073 1
a1073 1
     char *name;
d1090 1
a1090 1
  new_directive (strdup (buf));
d1092 1
a1107 1

d1110 1
a1110 1
void
d1112 1
a1112 1
     char *what;
d1116 1
a1116 1
  int pid;
d1118 5
a1122 4
  char **argv;
  extern char **environ;
  if (verbose)
    fprintf (stderr, "%s %s\n", what, args);
d1136 2
d1145 1
a1145 1
  argv[i++] = 0;
d1147 2
d1150 6
a1155 1
  pid = vfork ();
d1157 8
a1164 1
  if (pid == 0)
d1166 2
a1167 3
      execvp (what, argv);
      fprintf (stderr, "%s: can't exec %s\n", program_name, what);
      exit (1);
d1169 1
a1169 1
  else if (pid == -1)
d1171 4
a1174 3
      extern int errno;
      fprintf (stderr, "%s: vfork failed, %d\n", program_name, errno);
      exit (1);
d1177 53
a1229 6
    {
      int status;
      waitpid (pid, &status, 0);
      if (status)
	{
	  if (WIFSIGNALED (status))
d1231 5
a1235 3
	      fprintf (stderr, "%s: %s %s terminated with signal %d\n",
		       program_name, what, args, WTERMSIG (status));
	      exit (1);
d1238 6
a1243 1
	  if (WIFEXITED (status))
d1245 5
a1249 3
	      fprintf (stderr, "%s: %s %s terminated with exit status %d\n",
		       program_name, what, args, WEXITSTATUS (status));
	      exit (1);
d1252 2
d1255 1
d1258 3
a1260 1
/* read in and block out the base relocations */
d1262 1
a1262 1
basenames (abfd)
d1264 45
d1310 4
d1315 16
d1332 2
d1335 1
d1337 10
d1349 12
a1360 2
void
scan_open_obj_file (abfd)
d1362 3
d1366 12
a1377 3
  /* Look for .drectve's */
  asection *s = bfd_get_section_by_name (abfd, ".drectve");
  if (s)
d1379 16
a1394 14
      int size = bfd_get_section_size_before_reloc (s);
      char *buf = xmalloc (size);
      char *p;
      char *e;
      bfd_get_section_contents (abfd, s, buf, 0, size);
      if (verbose)
	fprintf (stderr, "%s: Sucking in info from %s\n",
		 program_name,
		 bfd_get_filename (abfd));

      /* Search for -export: strings */
      p = buf;
      e = buf + size;
      while (p < e)
d1396 2
a1397 19
	  if (p[0] == '-'
	      && strncmp (p, "-export:", 8) == 0)
	    {
	      char *name;
	      char *c;
	      p += 8;
	      name = p;
	      while (p < e && *p != ' ' && *p != '-')
		p++;
	      c = xmalloc (p - name + 1);
	      memcpy (c, name, p - name);
	      c[p - name] = 0;
	      /* FIXME: The 5th arg is for the `constant' field.
		 What should it be?  Not that it matters since it's not
		 currently useful.  */
	      def_exports (c, 0, -1, 0, 0);
	    }
	  else
	    p++;
a1398 1
      free (buf);
d1401 40
a1440 1
  basenames (abfd);
d1442 4
a1445 3
  if (verbose)
    fprintf (stderr, "%s: Done readin\n",
	     program_name);
d1448 1
d1450 16
a1465 1
void
d1467 1
a1467 1
     char *filename;
d1469 1
a1469 1
  bfd *f = bfd_openr (filename, 0);
d1472 6
a1477 6
    {
      fprintf (stderr, "%s: Unable to open object file %s\n",
	       program_name,
	       filename);
      exit (1);
    }
d1488 5
d1497 5
d1509 1
a1509 3


void
d1521 1
a1521 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s\n",
d1528 2
a1529 1
	       exp->constant ? "CONSTANT" : "");
d1532 1
d1535 1
a1535 1
int
d1537 2
a1538 2
     long *a;
     long *b;
d1540 1
a1540 1
  return *a - *b;
a1542 2


d1546 1
a1546 1
     int *need;
d1561 1
d1564 6
a1569 1
      fprintf (f, "\t%s\t0x%x\n", ASM_SHORT, (need[i] - page_addr) | 0x3000);
d1571 1
a1574 1

d1577 1
a1577 2

void
d1583 2
d1594 130
a1723 7
      fprintf (output_def, "\t%s%s%s @@ %d%s ; %s\n",
	       quote,
	       exp->name,
	       quote,
	       exp->ordinal,
	       exp->noname ? " NONAME" : "",
	       cplus_demangle (exp->internal_name, DMGL_ANSI | DMGL_PARAMS));
d1726 18
a1743 1
void
d1751 4
a1754 8

  sprintf (outfile, "t%s", exp_name);

  if (verbose)
    fprintf (stderr, "%s: Generate exp file %s\n",
	     program_name, exp_name);

  f = fopen (outfile, FOPEN_WT);
d1756 5
a1760 9
    {
      fprintf (stderr, "%s: Unable to open output file %s\n", program_name, outfile);
      exit (1);
    }
  if (verbose)
    {
      fprintf (stderr, "%s: Opened file %s\n",
	       program_name, outfile);
    }
d1763 1
d1768 2
a1769 1
      fprintf (f, "\t%s	0x%x	%s Time and date\n", ASM_LONG, time(0),ASM_C);
d1783 1
a1783 1
      fprintf (f, "\t%sanames%s	%s Address of Name Pointer Table\n", 
d1800 1
a1800 1
#if 0	      
d1815 2
a1816 2
		   ASM_PREFIX,
		   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1826 2
a1827 1
	    fprintf (f, "\t%sn%d%s\n", ASM_RVA_BEFORE, exp->ordinal, ASM_RVA_AFTER);
d1841 2
a1842 1
	  fprintf (f, "n%d:	%s	\"%s\"\n", exp->ordinal, ASM_TEXT, exp->name);
d1846 1
a1846 1
	  fprintf (f, "\t.section .drectve\n");
d1852 1
d1860 3
a1862 3
	      /* We dont output as ascii 'cause there can
	         be quote characters in the string */

d1888 1
a1888 1
     without using the import library. */
d1895 9
a1903 2
	    fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
	    fprintf (f, "__imp_%s:\n", exp->name);
d1925 1
a1925 1
      copy = malloc (numbytes);
a1932 1

d1940 1
a1940 1
	      if (last != copy[src]) 
d1964 2
d1969 2
a1970 2
  sprintf (outfile, "-o %s t%s", exp_name, exp_name);
  run (as_name, outfile);
d1972 3
a1974 4
    {
      sprintf (outfile, "t%s", exp_name);
      unlink (outfile);
    }
d1977 3
a1979 2
static char *
xlate (char *name)
d1983 1
a1983 1
      char *copy = malloc (strlen (name) + 2);
d2001 6
a2006 3
static void dump_iat (f, exp)
FILE *f;
export_type *exp;
d2008 1
a2008 1
  if (exp->noname && !show_allnames ) 
d2022 1
d2024 1
a2024 2

typedef struct 
a2036 1

a2045 2
#define PDATA 7
#define RDATA 8
d2049 2
a2050 2

static sinfo secdata[NSECS] = 
d2052 7
a2058 7
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1}
d2061 1
a2061 1
#else 
d2077 1
a2077 1
static sinfo secdata[NSECS] = 
d2093 2
a2094 1
This is what we're trying to make
d2119 1
a2119 1
# Rather than a simple "jmp *", the code to get to the dll function 
d2149 1
a2149 1
  if (0)
d2151 1
d2153 6
a2158 3
      char *prefix="d";
      sprintf (outfile, "%ss%d.s", prefix, i);
      f = fopen (outfile, FOPEN_WT);
d2161 6
a2166 3
      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
      fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
	       exp->name, ASM_JUMP, exp->name);
d2175 3
a2177 1
      fprintf (f, "__imp_%s:\n", exp->name);
d2186 1
a2186 1
      if(!exp->noname || show_allnames) 
d2190 1
a2190 1
	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint);      
d2194 1
a2194 18
      fclose (f);


      sprintf (outfile, "-o %ss%d.o %ss%d.s", prefix, i, prefix, i);

      run (as_name, outfile);

    }
  else
    {

      bfd *abfd;

      asymbol *exp_label;
      asymbol *iname;
      asymbol *iname_lab;
      asymbol **iname_lab_pp;
      asymbol **iname_pp;
d2196 13
a2208 1
      /* Extra Symbols for PPC */
d2210 6
a2215 3
#define EXTRA 2     
#else
#define EXTRA 0
d2217 1
d2219 2
a2220 7
      asymbol *function_name; /* ".." functionName */
      asymbol **fn_pp;
      asymbol *toc_symbol;    /* The .toc symbol */
      asymbol **toc_pp;

      /* one symbol for each section, 2 extra + a null */
      asymbol *ptrs[NSECS+3+EXTRA+1];
d2222 5
a2226 4
      char *outname = xmalloc (10);
      int oidx = 0;
      sprintf (outname, "ds%d.o",  i);
      abfd = bfd_openw (outname, HOW_BFD_TARGET);
d2228 2
a2229 5
	{
	  fprintf (stderr, "%s: bfd_open failed open output file %s\n", 
		   program_name, outname);
	  exit (1);
	}
d2231 3
d2237 5
a2241 1

d2249 1
a2249 1
	  bfd_set_section_flags (abfd, 
d2252 1
a2252 1
	  
d2262 2
d2268 4
a2271 2
      exp_label = bfd_make_empty_symbol(abfd);
      exp_label->name = make_label ("",exp->name);
d2273 10
a2282 8
      /* On PowerPC, the function name points to a descriptor in the
	 rdata section, the first element of which is a pointer to the
	 code (..function_name), and the second points to the .toc
      */
      if (machine == MPPC)
	exp_label->section = secdata[RDATA].sec;
      else
	exp_label->section = secdata[TEXT].sec;
d2284 2
a2285 2
      exp_label->flags = BSF_GLOBAL;
      exp_label->value = 0;
d2287 6
a2292 7
      ptrs[oidx++] = exp_label;

      iname = bfd_make_empty_symbol(abfd);
      iname->name = make_label ("__imp_", exp->name);
      iname->section = secdata[IDATA5].sec;
      iname->flags = BSF_GLOBAL;
      iname->value = 0;
d2294 17
d2321 3
a2323 1
      ptrs[oidx++] = iname;
d2330 8
a2337 5
      function_name = bfd_make_empty_symbol(abfd);
      function_name->name = make_label ("..", exp->name);
      function_name->section = secdata[TEXT].sec;
      function_name->flags = BSF_GLOBAL;
      function_name->value = 0;
d2339 3
a2341 2
      fn_pp = ptrs + oidx;
      ptrs[oidx++] = function_name;
d2344 2
a2345 5
      toc_symbol = bfd_make_empty_symbol(abfd);
      toc_symbol->name = make_label (".", "toc");
      toc_symbol->section = (asection *)&bfd_und_section;
      toc_symbol->flags = BSF_GLOBAL;
      toc_symbol->value = 0;
d2347 9
a2355 2
      toc_pp = ptrs + oidx;
      ptrs[oidx++] = toc_symbol;
d2357 1
a2357 1

d2367 1
a2367 1
	  switch (i) 
d2370 15
a2384 11
	      si->size = HOW_JTAB_SIZE;
	      si->data = xmalloc (HOW_JTAB_SIZE);
	      memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);
	      
	      /* add the reloc into idata$5 */
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rpp[1] = 0;
	      rel->address = HOW_JTAB_ROFF;
	      rel->addend = 0;
d2386 13
a2398 10
	      if (machine == MPPC)
		{
		  rel->howto = bfd_reloc_type_lookup (abfd, 
						      BFD_RELOC_16_GOTOFF);
		  rel->sym_ptr_ptr = iname_pp;
		}
	      else
		{
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		  rel->sym_ptr_ptr = secdata[IDATA5].sympp;
a2399 2
	      sec->orelocation = rpp;
	      sec->reloc_count = 1;
d2405 1
a2405 1
	  
d2416 1
a2416 1
	      else 
d2434 1
a2434 1
	      if (!exp->noname) 
d2436 4
a2439 1
		  int idx = exp->hint + 1;
d2462 1
d2480 5
a2484 5
		   1. In the name of glue trickery, the ADDR32 relocs for 0, 
		      4, and 0x10 are set to point to the same place: 
		      "..function_name". 
		   2. There is one more reloc needed in the pdata section. 
		      The actual glue instruction to restore the toc on 
d2510 1
a2510 1
		imglue->howto = bfd_reloc_type_lookup (abfd, 
d2548 1
a2548 1
	      si->data =xmalloc(8);
d2571 1
d2599 1
a2599 1
	  bfd_set_section_contents (abfd, si->sec, 
d2606 1
a2606 1
      abfd = bfd_openr (outname, HOW_BFD_TARGET);
d2609 1
a2609 1

a2611 1

d2613 1
a2613 1
make_head()
d2615 1
a2615 1
  FILE *  f = fopen ("dh.s", FOPEN_WT);
d2617 6
d2648 1
a2648 1
  if (!no_idata5) 
d2654 2
a2655 1
  if (!no_idata4) 
d2663 1
d2666 1
a2666 2
  sprintf (outfile, "-o dh.o dh.s");
  run (as_name, outfile);
d2668 1
a2668 1
  return  bfd_openr ("dh.o", HOW_BFD_TARGET);  
d2671 2
a2672 2
static bfd * 
make_tail()
d2674 1
a2674 1
  FILE *  f = fopen ("dt.s", FOPEN_WT);
d2676 7
a2682 1
  if (!no_idata4) 
d2687 2
a2688 1
  if (!no_idata5) 
d2725 3
a2727 3
  sprintf (outfile, "-o dt.o dt.s");
  run (as_name, outfile);
  return  bfd_openr ("dt.o", HOW_BFD_TARGET);  
d2742 1
a2742 1
  outarch = bfd_openw (imp_name, HOW_BFD_TARGET);
d2745 6
a2750 4
    {
      fprintf (stderr, "%s: Can't open .lib file %s\n", program_name, imp_name);
      exit (1);
    }
a2755 2


d2759 3
a2768 1

d2775 12
a2786 2
  bfd_set_archive_head (outarch, head);
  bfd_close (outarch);
d2792 4
a2795 8
      sprintf (outfile, "dh.o");
      unlink (outfile);
      sprintf (outfile, "dh.s");
      unlink (outfile);
      sprintf (outfile, "dt.o");
      unlink (outfile);
      sprintf (outfile, "dt.s");
      unlink (outfile);
d2799 2
a2800 5
    for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
      {
	sprintf (outfile, "ds%d.o",i);
	unlink (outfile);
      }
d2802 11
d2814 1
d2819 1
a2819 1
int
d2821 2
a2822 2
     void *a;
     void *b;
d2837 1
a2837 2

int
d2839 2
a2840 2
     void *a;
     void *b;
d2848 1
a2848 2
static
void
d2867 5
a2871 1
     export_type **ptr;
d2879 1
a2879 1
	  printf ("%d %s @@ %d %s%s\n",
d2882 2
a2883 1
		  ptr[i]->constant ? "CONSTANT" : "");
d2896 1
a2896 1
  int i;  
d2915 5
a2919 5
	      if (verbose)
		fprintf (stderr, "Warning, ignoring duplicate EXPORT %s %d,%d\n",
			 a->name,
			 a->ordinal,
			 b->ordinal);
d2922 3
a2924 1
		{
a2925 4
		  fprintf (stderr, "Error, duplicate EXPORT with oridinals %s\n",
			   a->name);
		  exit (1);
		}
d2930 1
d2962 1
a2962 1
  ptr = (char *) malloc (size);
d3018 1
a3018 1
  if (d_nfuncs) 
d3027 4
a3030 3
int alphafunc(av,bv)
void *av;
void *bv;
d3032 2
a3033 2
  export_type **a = av;
  export_type **b = bv;
d3038 1
a3038 1
void
d3050 2
d3069 2
a3070 1
  d_exports_lexically = (export_type **)xmalloc (sizeof(export_type *)*(d_nfuncs+1));
d3081 1
a3081 1
  
d3087 2
a3088 1

a3090 5





d3093 1
a3093 1
void
d3098 33
a3130 16
  fprintf (file, "Usage %s <options> <object-files>\n", program_name);
  fprintf (file, "   --machine <machine>\n");
  fprintf (file, "   --output-exp <outname> Generate export file.\n");
  fprintf (file, "   --output-lib <outname> Generate input library.\n");
  fprintf (file, "   --add-indirect         Add dll indirects to export file.\n");
  fprintf (file, "   --dllname <name>       Name of input dll to put into output lib.\n");
  fprintf (file, "   --def <deffile>        Name input .def file\n");
  fprintf (file, "   --output-def <deffile> Name output .def file\n");
  fprintf (file, "   --base-file <basefile> Read linker generated base file\n");
  fprintf (file, "   --no-idata4           Don't generate idata$4 section\n");
  fprintf (file, "   --no-idata5           Don't generate idata$5 section\n");
  fprintf (file, "   -v                     Verbose\n");
  fprintf (file, "   -U                     Add underscores to .lib\n");
  fprintf (file, "   -k                     Kill @@<n> from exported names\n");
  fprintf (file, "   --as <name>            Use <name> for assembler\n");
  fprintf (file, "   --nodelete             Keep temp files.\n");
d3134 6
a3139 3
#define OPTION_NO_IDATA4 'x'
#define OPTION_NO_IDATA5 'c'
static struct option long_options[] =
d3141 1
a3141 1
  {"nodelete", no_argument, NULL, 'n'},
d3143 2
a3144 2
  {"no-idata4", no_argument, NULL, OPTION_NO_IDATA4},
  {"no-idata5", no_argument, NULL, OPTION_NO_IDATA5},
d3147 4
d3152 2
a3153 1
  {"def", required_argument, NULL, 'd'},
d3155 4
a3158 1
  {"killat", no_argument, NULL, 'k'},
d3164 4
a3167 1
  {0}
a3169 2


d3181 13
a3193 1
  while ((c = getopt_long (ac, av, "xcz:S:R:A:puaD:l:e:nkvbUh?m:yd:", long_options, 0)) 
d3198 13
a3210 1
	case OPTION_NO_IDATA4:
d3213 1
a3213 1
	case OPTION_NO_IDATA5:
d3219 3
d3242 1
a3242 2
	case '?':
	  usage (stderr, 0);
d3250 2
a3251 2
	case 'y':
	  yydebug = 1;
d3259 3
d3270 1
d3272 17
a3288 6
	    {
	      fprintf (stderr, "%s: Unable to open base-file %s\n",
		       av[0],
		       optarg);
	      exit (1);
	    }
d3292 1
a3295 1

d3297 2
a3298 4
    {
      if (strcmp (mtable[i].type, mname) == 0)
	break;
    }
d3301 3
a3303 4
    {
      fprintf (stderr, "Machine not supported\n");
      exit (1);
    }
a3305 1

d3308 1
a3308 1
      char len = strlen (exp_name) + 5;
d3314 12
d3327 2
a3328 3
    {
      process_def_file (def_file);
    }
d3341 1
d3346 3
a3348 2
      imp_name_lab = strdup (imp_name);
      for (p = imp_name_lab; *p; *p++)
d3350 1
a3350 1
	  if (!isalpha (*p) && !isdigit (*p))
d3356 1
d3359 171
d3531 79
a3609 1
  return 0;
d3611 1
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d753 1
a753 1
	      while (*p != ' ' && *p != '-' && p < e)
d758 4
a761 1
	      def_exports (c, 0, -1, 0);
a773 1

a2327 1

@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d28 5
d1202 1
a1202 1
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
d1231 1
a1231 1
  { RDATA,  ".rdata",   SEC_HAS_CONTENTS,            2},
a1492 1
#if 1
a1494 4
#else
		  rel->howto = bfd_reloc_type_lookup (abfd, 
						      BFD_RELOC_PPC_TOC16);
#endif
d1557 1
a1557 1
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
@


1.1
log
@Initial revision
@
text
@d163 37
d225 3
a227 1

a278 2
/* If I understand what is going on here, this will need more for ppc
   support, but this lets the program start. Kim Knuttila (krk@@cygnus.com) */
d280 20
a299 1
unsigned char ppc_jtab[] = { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90};
d341 1
a341 1
   ppc_jtab,sizeof(ppc_jtab),2,
d1171 1
d1180 2
d1189 3
d1194 1
d1197 8
a1204 7
  { TEXT, ".text", SEC_CODE | SEC_HAS_CONTENTS},
  { DATA, ".data", SEC_DATA},
  { BSS,".bss" },
  { IDATA7, ".idata$7",SEC_HAS_CONTENTS},
  { IDATA5, ".idata$5",  SEC_HAS_CONTENTS},
  { IDATA4, ".idata$4",  SEC_HAS_CONTENTS},
  { IDATA6,".idata$6",  SEC_HAS_CONTENTS}
d1206 1
d1208 25
d1234 3
d1260 13
d1275 4
a1278 3
static char *make_label (prefix, name)
const char *prefix;
const char *name;
d1287 1
d1290 2
a1291 2
export_type *exp;
int i;
d1346 16
a1361 1
      asymbol *ptrs[NSECS+3+1]; /* one symbol for each section, 2 extra + a null */
d1369 2
a1370 1
	  fprintf (stderr, "%s: bfd_open failed open output file %s\n", program_name, outname);
d1378 1
d1388 2
d1391 1
a1391 1
	  si->sym =  bfd_make_empty_symbol(abfd);
d1404 10
a1413 1
      exp_label->section = secdata[TEXT].sec;
a1419 1

a1420 1

d1434 1
d1436 1
d1439 23
d1485 17
a1501 2
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = secdata[IDATA5].sympp;
a1509 1

d1562 109
d1680 1
d1683 1
d1691 1
d1712 1
a1712 2
static 
bfd *
d1764 2
a1765 2
static 
bfd * make_tail()
a1767 4
  fprintf (f, "\t.section	.idata$7\n");
  fprintf (f, "\t%s\t__%s_iname\n", ASM_GLOBAL, imp_name_lab);
  fprintf (f, "__%s_iname:\t%s\t\"%s\"\n",
	   imp_name_lab, ASM_TEXT, dll_name);
d1779 30
d2020 1
a2020 2
  int lowest = 0;

d2023 2
d2029 1
a2029 1
  ptr = (char *) malloc (65536);
d2031 1
a2031 1
  memset (ptr, 0, 65536);
d2039 4
a2042 2
	  if (lowest == 0)
	    lowest = d_export_vec[i]->ordinal;
d2046 5
d2055 4
a2058 2
	  int j;
	  for (j = lowest; j < 65536; j++)
d2066 2
a2067 1
	  for (j = 1; j < lowest; j++)
a2074 1

d2084 1
a2084 4

  /* Work out the lowest ordinal number */
  if (d_export_vec[0])
    d_low_ord = d_export_vec[0]->ordinal;
d2087 2
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a162 37
/* .idata section description

   The .idata section is the import table.  It is a collection of several
   subsections used to keep the pieces for each dll together: .idata$[234567].
   IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.

   .idata$2 = Import Directory Table
   = array of IMAGE_IMPORT_DESCRIPTOR's.

	DWORD   Characteristics;      - pointer to .idata$4
	DWORD   TimeDateStamp;        - currently always 0
	DWORD   ForwarderChain;       - currently always 0
	DWORD   Name;                 - pointer to dll's name
	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5

   .idata$3 = null terminating entry for .idata$2.

   .idata$4 = Import Lookup Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.

   .idata$5 = Import Address Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.
   Initially, this table is identical to the Import Lookup Table.  However,
   at load time, the loader overwrites the entries with the address of the
   function.

   .idata$6 = Hint Name Table
   = Array of { short, asciz } entries, one for each imported function.
   The `short' is the function's ordinal number.

   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc)
*/

d188 1
a188 3
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
d240 2
d243 1
a243 20
/* This is the glue sequence for PowerPC PE. There is a  */
/* tocrel16-tocdefn reloc against the first instruction. */
/* We also need a IMGLUE reloc against the glue function */
/* to restore the toc saved by the third instruction in  */
/* the glue. */
unsigned char ppc_jtab[] = 
{ 
  0x00, 0x00, 0x62, 0x81, /* lwz r11,0(r2)               */
                          /*   Reloc TOCREL16 __imp_xxx  */
  0x00, 0x00, 0x8B, 0x81, /* lwz r12,0(r11)              */
  0x04, 0x00, 0x41, 0x90, /* stw r2,4(r1)                */
  0xA6, 0x03, 0x89, 0x7D, /* mtctr r12                   */
  0x04, 0x00, 0x4B, 0x80, /* lwz r2,4(r11)               */
  0x20, 0x04, 0x80, 0x4E  /* bctr                        */
};

/* the glue instruction, picks up the toc from the stw in */
/* the above code: "lwz r2,4(r1)"                         */
bfd_vma ppc_glue_insn = 0x80410004;

d285 1
a285 1
   ppc_jtab,sizeof(ppc_jtab),0,
a1114 1
  int align;
a1122 2
#ifndef DLLTOOL_PPC

a1129 3
#define PDATA 7
#define RDATA 8

a1131 1

d1134 7
a1140 8
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1}
};
a1141 1
#else 
a1142 25
/* Sections numbered to make the order the same as other PowerPC NT    */
/* compilers. This also keeps funny alignment thingies from happening. */
#define TEXT   0
#define PDATA  1
#define RDATA  2
#define IDATA5 3
#define IDATA4 4
#define IDATA6 5
#define IDATA7 6
#define DATA   7
#define BSS    8

#define NSECS 9

static sinfo secdata[NSECS] = 
{
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
  { PDATA,  ".pdata",   SEC_HAS_CONTENTS,            2},
  { RDATA,  ".rdata",   SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2}
a1143 3

#endif

a1166 13

For the PowerPC, here's the variation on the above scheme:

# Rather than a simple "jmp *", the code to get to the dll function 
# looks like:
         .text
         lwz	r11,[tocv]__imp_function_name(r2)
#		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name
         lwz	r12,0(r11)
	 stw	r2,4(r1)
	 mtctr	r12
	 lwz	r2,4(r11)
	 bctr
d1169 3
a1171 4
static char *
make_label (prefix, name)
     const char *prefix;
     const char *name;
a1179 1

d1182 2
a1183 2
     export_type *exp;
     int i;
d1238 1
a1238 16
      asymbol **iname_pp;

      /* Extra Symbols for PPC */
#ifdef DLLTOOL_PPC
#define EXTRA 2     
#else
#define EXTRA 0
#endif

      asymbol *function_name; /* ".." functionName */
      asymbol **fn_pp;
      asymbol *toc_symbol;    /* The .toc symbol */
      asymbol **toc_pp;

      /* one symbol for each section, 2 extra + a null */
      asymbol *ptrs[NSECS+3+EXTRA+1];
d1246 1
a1246 2
	  fprintf (stderr, "%s: bfd_open failed open output file %s\n", 
		   program_name, outname);
a1253 1
      /* First make symbols for the sections */
a1262 2
	  
	  bfd_set_section_alignment(abfd, si->sec, si->align);
d1264 1
a1264 1
	  si->sym = bfd_make_empty_symbol(abfd);
d1277 1
a1277 10

      /* On PowerPC, the function name points to a descriptor in the
	 rdata section, the first element of which is a pointer to the
	 code (..function_name), and the second points to the .toc
      */
      if (machine == MPPC)
	exp_label->section = secdata[RDATA].sec;
      else
	exp_label->section = secdata[TEXT].sec;

d1284 1
d1286 1
a1299 1
      iname_pp = ptrs + oidx;
a1300 1

a1302 23

#ifdef DLLTOOL_PPC
      /* The symbol refering to the code (.text) */
      function_name = bfd_make_empty_symbol(abfd);
      function_name->name = make_label ("..", exp->name);
      function_name->section = secdata[TEXT].sec;
      function_name->flags = BSF_GLOBAL;
      function_name->value = 0;

      fn_pp = ptrs + oidx;
      ptrs[oidx++] = function_name;

      /* The .toc symbol */
      toc_symbol = bfd_make_empty_symbol(abfd);
      toc_symbol->name = make_label (".", "toc");
      toc_symbol->section = (asection *)&bfd_und_section;
      toc_symbol->flags = BSF_GLOBAL;
      toc_symbol->value = 0;

      toc_pp = ptrs + oidx;
      ptrs[oidx++] = toc_symbol;
#endif

d1326 2
a1327 17

	      if (machine == MPPC)
		{
#if 1
		  rel->howto = bfd_reloc_type_lookup (abfd, 
						      BFD_RELOC_16_GOTOFF);
#else
		  rel->howto = bfd_reloc_type_lookup (abfd, 
						      BFD_RELOC_PPC_TOC16);
#endif
		  rel->sym_ptr_ptr = iname_pp;
		}
	      else
		{
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		  rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		}
d1336 1
a1388 109

	    case PDATA:
	      {
		/* The .pdata section is 5 words long. */
		/* Think of it as:                     */
		/* struct                              */
		/* {                                   */
		/*   bfd_vma BeginAddress,     [0x00]  */
		/*           EndAddress,       [0x04]  */
		/*	     ExceptionHandler, [0x08]  */
		/*	     HandlerData,      [0x0c]  */
		/*	     PrologEndAddress; [0x10]  */
		/* };                                  */

		/* So this pdata section setups up this as a glue linkage to
		   a dll routine. There are a number of house keeping things
		   we need to do:

		   1. In the name of glue trickery, the ADDR32 relocs for 0, 
		      4, and 0x10 are set to point to the same place: 
		      "..function_name". 
		   2. There is one more reloc needed in the pdata section. 
		      The actual glue instruction to restore the toc on 
		      return is saved as the offset in an IMGLUE reloc.
		      So we need a total of four relocs for this section.

		   3. Lastly, the HandlerData field is set to 0x03, to indicate
		      that this is a glue routine.
		*/
		arelent *imglue, *ba_rel, *ea_rel, *pea_rel;

		/* alignment must be set to 2**2 or you get extra stuff */
		bfd_set_section_alignment(abfd, sec, 2);

		si->size = 4 * 5;
		si->data =xmalloc(4 * 5);
		memset (si->data, 0, si->size);
		rpp = xmalloc (sizeof (arelent *) * 5);
		rpp[0] = imglue  = xmalloc (sizeof (arelent));
		rpp[1] = ba_rel  = xmalloc (sizeof (arelent));
		rpp[2] = ea_rel  = xmalloc (sizeof (arelent));
		rpp[3] = pea_rel = xmalloc (sizeof (arelent));
		rpp[4] = 0;

		/* stick the toc reload instruction in the glue reloc */
		bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);

		imglue->addend = 0;
		imglue->howto = bfd_reloc_type_lookup (abfd, 
						       BFD_RELOC_32_GOTOFF);
		imglue->sym_ptr_ptr = fn_pp;

		ba_rel->address = 0;
		ba_rel->addend = 0;
		ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ba_rel->sym_ptr_ptr = fn_pp;

		bfd_put_32(abfd, 0x18, si->data + 0x04);
		ea_rel->address = 4;
		ea_rel->addend = 0;
		ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ea_rel->sym_ptr_ptr = fn_pp;

		/* mark it as glue */
		bfd_put_32(abfd, 0x03, si->data + 0x0c);

		/* mark the prolog end address */
		bfd_put_32(abfd, 0x0D, si->data + 0x10);
		pea_rel->address = 0x10;
		pea_rel->addend = 0;
		pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		pea_rel->sym_ptr_ptr = fn_pp;

		sec->orelocation = rpp;
		sec->reloc_count = 4;
		break;
	      }
	    case RDATA:
	      /* Each external function in a PowerPC PE file has a two word
		 descriptor consisting of:
		 1. The address of the code.
		 2. The address of the appropriate .toc
	         We use relocs to build this.
	      */

	      si->size = 8;
	      si->data =xmalloc(8);
	      memset (si->data, 0, si->size);

	      rpp = xmalloc (sizeof (arelent *) * 3);
	      rpp[0] = rel = xmalloc (sizeof (arelent));
	      rpp[1] = xmalloc (sizeof (arelent));
	      rpp[2] = 0;

	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = fn_pp;

	      rel = rpp[1];

	      rel->address = 4;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = toc_pp;

	      sec->orelocation = rpp;
	      sec->reloc_count = 2;
	      break;
a1397 1

a1399 1

a1406 1

d1427 2
a1428 1
static bfd *
d1480 2
a1481 2
static bfd * 
make_tail()
d1484 4
a1498 30

#ifdef DLLTOOL_PPC
  /* Normally, we need to see a null descriptor built in idata$3 to
     act as the terminator for the list. The ideal way, I suppose,
     would be to mark this section as a comdat type 2 section, so
     only one would appear in the final .exe (if our linker supported
     comdat, that is) or cause it to be inserted by something else (say
     crt0)
  */

  fprintf (f, "\t.section	.idata$3\n");
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
#endif

#ifdef DLLTOOL_PPC
  /* Other PowerPC NT compilers use idata$6 for the dllname, so I
     do too. Original, huh? */
  fprintf (f, "\t.section	.idata$6\n");
#else
  fprintf (f, "\t.section	.idata$7\n");
#endif

  fprintf (f, "\t%s\t__%s_iname\n", ASM_GLOBAL, imp_name_lab);
  fprintf (f, "__%s_iname:\t%s\t\"%s\"\n",
	   imp_name_lab, ASM_TEXT, dll_name);

d1710 2
a1711 1
  int lowest = -1;
a1713 2
  int size = 65536;

d1718 1
a1718 1
  ptr = (char *) malloc (size);
d1720 1
a1720 1
  memset (ptr, 0, size);
d1728 2
a1729 4
	  if (lowest == -1 || d_export_vec[i]->ordinal < lowest)
	    {
	      lowest = d_export_vec[i]->ordinal;
	    }
a1732 5
  /* Start at 1 for compatibility with MS toolchain.  */
  if (lowest == -1)
    lowest = 1;

  /* Now fill in ordinals where the user wants us to choose. */
d1737 2
a1738 4
	  register int j;

	  /* First try within or after any user supplied range. */
	  for (j = lowest; j < size; j++)
d1746 1
a1746 2
	  /* Then try before the range. */
	  for (j = lowest; j >0; j--)
d1754 1
d1764 4
a1767 1
  /* Work out the lowest and highest ordinal numbers.  */
a1769 2
      if (d_export_vec[0])
	d_low_ord = d_export_vec[0]->ordinal;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a27 5
   See "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9 for more information.
   Also see "Microsoft Portable Executable and Common Object File Format,
   Specification 4.1" for more information.

d1197 1
a1197 1
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2},
d1226 1
a1226 1
  { RDATA,  ".reldata", SEC_HAS_CONTENTS,            2},
d1488 1
d1491 4
d1557 1
a1557 1
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d753 1
a753 1
	      while (p < e && *p != ' ' && *p != '-')
d758 1
a758 4
	      /* FIXME: The 5th arg is for the `constant' field.
		 What should it be?  Not that it matters since it's not
		 currently useful.  */
	      def_exports (c, 0, -1, 0, 0);
d771 1
d2326 1
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1 2
d4 1
a4 1
   Copyright (C) 1995, 96, 1997 Free Software Foundation, Inc.
a204 10
/* AIX requires this to be the first thing in the file.  */
/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#define show_allnames 0

d1078 1
a1078 1
      copy = xmalloc (numbytes);
d1135 1
a1135 1
      char *copy = xmalloc (strlen (name) + 2);
d2031 1
a2031 1
  ptr = (char *) xmalloc (size);
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 2
a2 2
/* dlltool.c -- tool to generate stuff for PE style DLLs
   Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d33 1
a33 1
   referencing program.
d38 1
a38 1
   with export information.
d43 1
a43 1
   NAME <name> [ , <base> ]
d46 1
a46 1
   LIBRARY <name> [ , <base> ]
d49 1
a49 1
   EXPORTS  ( <name1> [ = <name2> ] [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d53 2
a54 6
   IMPORTS  (  (   <internal-name> =   <module-name> . <integer> )
             | ( [ <internal-name> = ] <module-name> . <external-name> )) *
   Declares that <external-name> or the exported function whoes ordinal number
   is <integer> is to be imported from the file <module-name>.  If
   <internal-name> is specified then this is the name that the imported
   function will be refered to in the body of the DLL.
d79 1
a79 1
   on the command line, or in the def file, or taken from the first
d90 2
a91 2
 file1.c:
   asm (".section .drectve");
d94 1
a94 1
   void adef (char * s)
d96 1
a96 1
     printf ("hello from the dll %s\n", s);
d99 1
a99 1
   void bdef (char * s)
d101 1
a101 1
     printf ("hello from the dll and the other entry point %s\n", s);
d104 1
a104 1
 file2.c:
d108 1
a108 2
   
   void cdef (char * s)
d110 1
a110 1
     printf ("hello from the dll %s\n", s);
d113 1
a113 1
   void ddef (char * s)
d115 1
a115 1
     printf ("hello from the dll and the other entry point %s\n", s);
d118 1
a118 1
   int printf (void)
d120 1
a120 1
     return 9;
d123 3
a125 2
 themain.c:
   int main (void)
d127 1
a127 2
     cdef ();
     return 0;
d130 1
a130 1
 thedll.def
d135 1
a135 1
           cdef @@ 30 NONAME
a139 1
 # Compile up the parts of the dll and the program
d141 1
a141 1
   gcc -c file1.c file2.c themain.c
d143 5
a147 3
 # Optional: put the dll objects into a library
 # (you don't have to, you could name all the object
 # files on the dlltool line)
d152 2
a153 5
 # Run this tool over the DLL's .def file and generate an exports
 # file (thedll.o) and an imports file (thedll.a).
 # (You may have to use -S to tell dlltool where to find the assembler).
 
   dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a
d155 1
a155 2
 # Build the dll with the library and the export table
 
d158 2
a159 13
 # Link the executable with the import library
 
   gcc -o themain.exe themain.o thedll.a

 This example can be extended if relocations are needed in the DLL:

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Run this tool over the DLL's .def file and generate an imports file.
 
   dlltool --def thedll.def --output-lib thedll.lib
d161 2
a162 4
 # Link the executable with the import library and generate a base file
 # at the same time
 
   gcc -o themain.exe themain.o thedll.lib -Wl,--base-file -Wl,themain.base
a163 8
 # Run this tool over the DLL's .def file and generate an exports file
 # which includes the relocations from the base file.
 
   dlltool --def thedll.def --base-file themain.base --output-exp thedll.exp

 # Build the dll with file1.o, file2.o and the export table
 
   ld -o thedll.dll thedll.exp file1.o file2.o
d175 1
a175 1
	DWORD   Import Lookup Table;  - pointer to .idata$4
d204 1
a219 3
#include "dyn-string.h"
#include "dlltool.h"

a220 23
#include <time.h>
#include <sys/stat.h>

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#ifdef DLLTOOL_ARM
#include "coff/arm.h"
#include "coff/internal.h"
#endif

/* Forward references.  */
static char *look_for_prog PARAMS ((const char *, const char *, int));
static char *deduce_name PARAMS ((const char *));

#ifdef DLLTOOL_MCORE_ELF
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
#endif
     
d223 1
a223 2
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN32__)
a235 3
#else /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
d237 3
a239 2
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
a240 39
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#endif /* ! HAVE_SYS_WAIT_H */

/* ifunc and ihead data structures: ttk@@cygnus.com 1997

   When IMPORT declarations are encountered in a .def file the
   function import information is stored in a structure referenced by
   the global variable IMPORT_LIST.  The structure is a linked list
   containing the names of the dll files each function is imported
   from and a linked list of functions being imported from that dll
   file.  This roughly parallels the structure of the .idata section
   in the PE object file.

   The contents of .def file are interpreted from within the
   process_def_file function.  Every time an IMPORT declaration is
   encountered, it is broken up into its component parts and passed to
   def_import.  IMPORT_LIST is initialized to NULL in function main.  */

typedef struct ifunct
{
  char          *name;   /* name of function being imported */
  int            ord;    /* two-byte ordinal value associated with function */
  struct ifunct *next;
} ifunctype;

typedef struct iheadt
{
  char          *dllname;  /* name of dll file imported from */
  long           nfuncs;   /* number of functions in list */
  struct ifunct *funchead; /* first function in list */
  struct ifunct *functail; /* last  function in list */
  struct iheadt *next;     /* next dll file in list */
} iheadtype;
d242 1
a242 7
/* Structure containing all import information as defined in .def file
   (qv "ihead structure").  */

static iheadtype *import_list = NULL;

static char *as_name = NULL;
static char * as_flags = "";
d256 2
a257 15
/* True if we should export all symbols.  Otherwise, we only export
   symbols listed in .drectve sections or in the def file.  */
static boolean export_all_symbols;

/* True if we should exclude the symbols in DEFAULT_EXCLUDES when
   exporting all symbols.  */
static boolean do_default_excludes;

/* Default symbols to exclude when exporting all the symbols.  */
static const char *default_excludes = "DllMain@@12,DllEntryPoint@@0,impure_ptr";

/* True if we should add __imp_<SYMBOL> to import libraries for backward 
   compatibility to old Cygwin releases.  */
static boolean create_compat_implib;

d260 3
a262 1
extern char * program_name;
d265 1
a265 2
static int killat;
static int add_stdcall_alias;
d267 2
a268 2
static FILE *output_def;
static FILE *base_file;
d271 1
a271 1
static const char *mname = "arm";
d275 1
a275 1
static const char *mname = "i386";
d279 1
a279 26
static const char *mname = "ppc";
#endif

#ifdef DLLTOOL_SH
static const char *mname = "sh";
#endif

#ifdef DLLTOOL_MIPS
static const char *mname = "mips";
#endif

#ifdef DLLTOOL_MCORE
static const char * mname = "mcore-le";
#endif

#ifdef DLLTOOL_MCORE_ELF
static const char * mname = "mcore-elf";
static char * mcore_elf_out_file = NULL;
static char * mcore_elf_linker   = NULL;
static char * mcore_elf_linker_flags = NULL;

#define DRECTVE_SECTION_NAME ((machine == MMCORE_ELF || machine == MMCORE_ELF_LE) ? ".exports" : ".drectve")
#endif

#ifndef DRECTVE_SECTION_NAME
#define DRECTVE_SECTION_NAME ".drectve"
d284 3
a286 12
#define TMP_ASM		"dc.s"
#define TMP_HEAD_S	"dh.s"
#define TMP_HEAD_O	"dh.o"
#define TMP_TAIL_S	"dt.s"
#define TMP_TAIL_O	"dt.o"
#define TMP_STUB	"ds"

/* This bit of assemly does jmp * .... */
static const unsigned char i386_jtab[] =
{
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90
};
a287 6
static const unsigned char arm_jtab[] =
{
  0x00, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr  pc, [ip] */
  0,    0,    0,    0
};
d289 3
a291 36
static const unsigned char arm_interwork_jtab[] =
{
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xc0, 0x9c, 0xe5,	/* ldr  ip, [ip] */
  0x1c, 0xff, 0x2f, 0xe1,	/* bx   ip       */
  0,    0,    0,    0
};

static const unsigned char thumb_jtab[] =
{
  0x40, 0xb4,           /* push {r6}         */
  0x02, 0x4e,           /* ldr  r6, [pc, #8] */
  0x36, 0x68,           /* ldr  r6, [r6]     */
  0xb4, 0x46,           /* mov  ip, r6       */
  0x40, 0xbc,           /* pop  {r6}         */
  0x60, 0x47,           /* bx   ip           */
  0,    0,    0,    0
};

static const unsigned char mcore_be_jtab[] =
{
  0x71, 0x02,            /* lrw r1,2       */
  0x81, 0x01,            /* ld.w r1,(r1,0) */  
  0x00, 0xC1,            /* jmp r1         */
  0x12, 0x00,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
};

static const unsigned char mcore_le_jtab[] =
{
  0x02, 0x71,            /* lrw r1,2       */
  0x01, 0x81,            /* ld.w r1,(r1,0) */  
  0xC1, 0x00,            /* jmp r1         */
  0x00, 0x12,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
};
d298 2
a299 2
static const unsigned char ppc_jtab[] =
{
a308 1
#ifdef DLLTOOL_PPC
d311 2
a312 2
static bfd_vma ppc_glue_insn = 0x80410004;
#endif
d314 1
d317 12
a328 13
    const char *type;
    const char *how_byte;
    const char *how_short;
    const char *how_long;
    const char *how_asciz;
    const char *how_comment;
    const char *how_jump;
    const char *how_global;
    const char *how_space;
    const char *how_align_short;
    const char *how_align_long;
    const char *how_default_as_switches;
    const char *how_bfd_target;
d330 1
a330 1
    const unsigned char *how_jtab;
d333 3
a335 4
  };

static const struct mac
mtable[] =
d339 1
a339 1
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
d341 2
a342 3
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-32",
    "pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
d347 2
a348 4
    "i386", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-i386",bfd_arch_i386,
    i386_jtab, sizeof (i386_jtab), 2
d353 2
a354 31
    "ppc", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-powerpcle",bfd_arch_powerpc,
    ppc_jtab, sizeof (ppc_jtab), 0
  }
  ,
  {
#define MTHUMB 3
    "thumb", ".byte", ".short", ".long", ".asciz", "@@",
    "push\t{r6}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tmov\tip, r6\n\tpop\t{r6}\n\tbx\tip",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    thumb_jtab, sizeof (thumb_jtab), 12
  }
  ,
#define MARM_INTERWORK 4
  {
    "arm_interwork", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tip,[ip]\n\tbx\tip\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    arm_interwork_jtab, sizeof (arm_interwork_jtab), 12
  }
  ,
  {
#define MMCORE_BE 5
    "mcore-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "pe-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
d357 1
a357 37
  {
#define MMCORE_LE 6
    "mcore-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "pe-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MMCORE_ELF 7
    "mcore-elf-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "elf32-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
  }
  ,
  {
#define MMCORE_ELF_LE 8
    "mcore-elf-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "elf32-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
  }
  ,
  {
#define MARM_EPOC 9
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "epoc-pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8
  }
  ,
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
a359 6
typedef struct dlist
{
  char *text;
  struct dlist *next;
}
dlist_type;
d361 1
a361 90
typedef struct export
  {
    const char *name;
    const char *internal_name;
    int ordinal;
    int constant;
    int noname;
    int data;
    int hint;
    struct export *next;
  }
export_type;

/* A list of symbols which we should not export.  */
 
struct string_list
{
  struct string_list *next;
  char *string;
};

static struct string_list *excludes;

static const char *rvaafter PARAMS ((int));
static const char *rvabefore PARAMS ((int));
static const char *asm_prefix PARAMS ((int));
static void append_import PARAMS ((const char *, const char *, int));
static void run PARAMS ((const char *, char *));
static void scan_drectve_symbols PARAMS ((bfd *));
static void scan_filtered_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes PARAMS ((const char *));
static boolean match_exclude PARAMS ((const char *));
static void set_default_excludes PARAMS ((void));
static long filter_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols PARAMS ((bfd *));
static void scan_open_obj_file PARAMS ((bfd *));
static void scan_obj_file PARAMS ((const char *));
static void dump_def_info PARAMS ((FILE *));
static int sfunc PARAMS ((const void *, const void *));
static void flush_page PARAMS ((FILE *, long *, int, int));
static void gen_def_file PARAMS ((void));
static void generate_idata_ofile PARAMS ((FILE *));
static void gen_exp_file PARAMS ((void));
static const char *xlate PARAMS ((const char *));
#if 0
static void dump_iat PARAMS ((FILE *, export_type *));
#endif
static char *make_label PARAMS ((const char *, const char *));
static bfd *make_one_lib_file PARAMS ((export_type *, int));
static bfd *make_head PARAMS ((void));
static bfd *make_tail PARAMS ((void));
static void gen_lib_file PARAMS ((void));
static int pfunc PARAMS ((const void *, const void *));
static int nfunc PARAMS ((const void *, const void *));
static void remove_null_names PARAMS ((export_type **));
static void dtab PARAMS ((export_type **));
static void process_duplicates PARAMS ((export_type **));
static void fill_ordinals PARAMS ((export_type **));
static int alphafunc PARAMS ((const void *, const void *));
static void mangle_defs PARAMS ((void));
static void usage PARAMS ((FILE *, int));
static void inform PARAMS ((const char *, ...));


static void
#ifdef __STDC__
inform (const char * message, ...)
#else
inform (message, va_alist)
     const char * message;
     va_dcl
#endif
{
  va_list args;
  
  if (!verbose)
    return;

#ifdef __STDC__
  va_start (args, message);
#else
  va_start (args);
#endif

  report (message, args);
  
  va_end (args);
}

static const char *
d368 1
d370 1
d372 1
a372 11
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
      break;
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
d374 1
a374 1
  return "";
d377 1
a377 1
static const char *
d384 1
d386 1
a387 6
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
a388 4
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
d390 1
a390 1
  return "";
d393 1
a393 1
static const char *
d395 1
a395 1
     int machine;
d400 1
a400 8
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
      break;
d403 2
a404 4
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), machine);
      break;
d406 1
a406 1
  return "";
a407 1

d420 7
a426 8
#define ASM_ALIGN_LONG  mtable[machine].how_align_long
#define HOW_BFD_READ_TARGET  0  /* always default*/
#define HOW_BFD_WRITE_TARGET mtable[machine].how_bfd_target
#define HOW_BFD_ARCH    mtable[machine].how_bfd_arch
#define HOW_JTAB        mtable[machine].how_jtab
#define HOW_JTAB_SIZE   mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF   mtable[machine].how_jtab_roff
#define ASM_SWITCHES    mtable[machine].how_default_as_switches
a427 1
static char **oav;
d429 2
d433 1
a433 1
     const char *name;
a435 1
  
d437 4
a440 2
    /* xgettext:c-format */
    fatal (_("Can't open def file: %s"), name);
a443 3
  /* xgettext:c-format */
  inform (_("Processing def file: %s"), name);
  
a444 2

  inform (_("Processed def file"));
d451 21
a471 1
static const char *d_name;	/* Arg to NAME or LIBRARY */
d484 2
a485 3
int
yyerror (err)
     const char * err ATTRIBUTE_UNUSED;
d487 2
a488 3
  /* xgettext:c-format */
  non_fatal (_("Syntax error in def file %s:%d"), def_file, linenumber);
  
d493 3
a495 3
def_exports (name, internal_name, ordinal, noname, constant, data)
     const char *name;
     const char *internal_name;
a498 1
     int data;
a506 1
  p->data = data;
d512 1
d515 1
a515 1
     const char *name;
d518 2
a519 3
  /* xgettext:c-format */
  inform (_("NAME: %s base: %x"), name, base);
  
d521 3
a523 2
    non_fatal (_("Can't have LIBRARY and NAME"));
  
a524 4
  /* if --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables? */
  if (! dll_name)
    dll_name = xstrdup (name);
d530 1
a530 1
     const char *name;
d533 2
a534 3
  /* xgettext:c-format */
  inform (_("LIBRARY: %s base: %x"), name, base);
  
d536 3
a538 2
    non_fatal (_("Can't have LIBRARY and NAME"));
  
a539 3
  /* if --dllname not provided, use the one in the DEF file. */
  if (! dll_name)
    dll_name = xstrdup (name);
d545 1
a545 1
     const char *desc;
d548 1
a548 1
  d->text = xstrdup (desc);
d558 1
a558 1
  d->text = xstrdup (dir);
d564 1
a564 1
def_heapsize (reserve, commit)
d570 1
a570 1
    sprintf (b, "-heap 0x%x,0x%x ", reserve, commit);
d572 2
a573 2
    sprintf (b, "-heap 0x%x ", reserve);
  new_directive (xstrdup (b));
d577 1
a577 1
def_stacksize (reserve, commit)
d583 1
a583 1
    sprintf (b, "-stack 0x%x,0x%x ", reserve, commit);
d585 2
a586 2
    sprintf (b, "-stack 0x%x ", reserve);
  new_directive (xstrdup (b));
a588 2
/* append_import simply adds the given import definition to the global
   import_list.  It is used by def_import.  */
d590 5
a594 74
static void
append_import (symbol_name, dll_name, func_ordinal)
     const char *symbol_name;
     const char *dll_name;
     int func_ordinal;
{
  iheadtype **pq;
  iheadtype *q;

  for (pq = &import_list; *pq != NULL; pq = &(*pq)->next)
    {
      if (strcmp ((*pq)->dllname, dll_name) == 0)
	{
	  q = *pq;
	  q->functail->next = xmalloc (sizeof (ifunctype));
	  q->functail = q->functail->next;
	  q->functail->ord  = func_ordinal;
	  q->functail->name = xstrdup (symbol_name);
	  q->functail->next = NULL;
	  q->nfuncs++;
	  return;
	}
    }

  q = xmalloc (sizeof (iheadtype));
  q->dllname = xstrdup (dll_name);
  q->nfuncs = 1;
  q->funchead = xmalloc (sizeof (ifunctype));
  q->functail = q->funchead;
  q->next = NULL;
  q->functail->name = xstrdup (symbol_name);
  q->functail->ord  = func_ordinal;
  q->functail->next = NULL;

  *pq = q;
}

/* def_import is called from within defparse.y when an IMPORT
   declaration is encountered.  Depending on the form of the
   declaration, the module name may or may not need ".dll" to be
   appended to it, the name of the function may be stored in internal
   or entry, and there may or may not be an ordinal value associated
   with it.  */

/* A note regarding the parse modes:
   In defparse.y we have to accept import declarations which follow
   any one of the following forms:
     <func_name_in_app> = <dll_name>.<func_name_in_dll>
     <func_name_in_app> = <dll_name>.<number>
     <dll_name>.<func_name_in_dll>
     <dll_name>.<number>
   Furthermore, the dll's name may or may not end with ".dll", which
   complicates the parsing a little.  Normally the dll's name is
   passed to def_import() in the "module" parameter, but when it ends
   with ".dll" it gets passed in "module" sans ".dll" and that needs
   to be reappended.

  def_import gets five parameters:
  APP_NAME - the name of the function in the application, if
             present, or NULL if not present.
  MODULE   - the name of the dll, possibly sans extension (ie, '.dll').
  DLLEXT   - the extension of the dll, if present, NULL if not present.
  ENTRY    - the name of the function in the dll, if present, or NULL.
  ORD_VAL  - the numerical tag of the function in the dll, if present,
             or NULL.  Exactly one of <entry> or <ord_val> must be
             present (i.e., not NULL).  */

void
def_import (app_name, module, dllext, entry, ord_val)
     const char *app_name;
     const char *module;
     const char *dllext;
     const char *entry;
     int ord_val;
d596 2
a597 21
  const char *application_name;
  char *buf;

  if (entry != NULL)
    application_name = entry;
  else
    {
      if (app_name != NULL)
	application_name = app_name;
      else
	application_name = "";
    }
  
  if (dllext != NULL)
    {
      buf = (char *) alloca (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }

  append_import (application_name, module, ord_val);
d602 2
a603 2
     int major;
     int minor;
d608 1
d611 1
a611 1
     const char *name;
d628 1
a628 1
  new_directive (xstrdup (buf));
a629 1

d645 1
d648 1
a648 1
static void
d650 1
a650 1
     const char *what;
d654 1
a654 1
  int pid, wait_status;
d656 4
a659 5
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
  char *temp_base = choose_temp_base ();

  inform ("run: %s %s", what, args);
a672 2
      while (*s == ' ')
	++s;
d680 1
a680 1
  argv[i++] = NULL;
a681 2
  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);
d683 1
a683 6
  if (pid == -1)
    {
      inform (strerror (errno));
      
      fatal (errmsg_fmt, errmsg_arg);
    }
d685 1
a685 3
  pid = pwait (pid, & wait_status, 0);
  
  if (pid == -1)
d687 3
a689 2
      /* xgettext:c-format */
      fatal (_("wait: %s"), strerror (errno));
d691 1
a691 1
  else if (WIFSIGNALED (wait_status))
d693 3
a695 2
      /* xgettext:c-format */
      fatal (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
d697 1
a697 1
  else if (WIFEXITED (wait_status))
d699 5
a703 59
      if (WEXITSTATUS (wait_status) != 0)
	/* xgettext:c-format */
	non_fatal (_("%s exited with status %d"),
		   what, WEXITSTATUS (wait_status));
    }
  else
    abort ();
}

/* Look for a list of symbols to export in the .drectve section of
   ABFD.  Pass each one to def_exports.  */

static void
scan_drectve_symbols (abfd)
     bfd *abfd;
{
  asection * s;
  int        size;
  char *     buf;
  char *     p;
  char *     e;

  /* Look for .drectve's */
  s = bfd_get_section_by_name (abfd, DRECTVE_SECTION_NAME);
  
  if (s == NULL)
    return;
      
  size = bfd_get_section_size_before_reloc (s);
  buf  = xmalloc (size);

  bfd_get_section_contents (abfd, s, buf, 0, size);
      
  /* xgettext:c-format */
  inform (_("Sucking in info from %s section in %s"),
	  DRECTVE_SECTION_NAME, bfd_get_filename (abfd));

  /* Search for -export: strings. The exported symbols can optionally
     have type tags (eg., -export:foo,data), so handle those as well.
     Currently only data tag is supported.  */
  p = buf;
  e = buf + size;
  while (p < e)
    {
      if (p[0] == '-'
	  && strncmp (p, "-export:", 8) == 0)
	{
	  char * name;
	  char * c;
	  flagword flags = BSF_FUNCTION;
	  
	  p += 8;
	  name = p;
	  while (p < e && *p != ',' && *p != ' ' && *p != '-')
	    p++;
	  c = xmalloc (p - name + 1);
	  memcpy (c, name, p - name);
	  c[p - name] = 0;
	  if (p < e && *p == ',')       /* found type tag. */
d705 3
a707 5
	      char *tag_start = ++p;
	      while (p < e && *p != ' ' && *p != '-')
		p++;
	      if (strncmp (tag_start, "data", 4) == 0)
		flags &= ~BSF_FUNCTION;
d710 1
a710 6
	  /* FIXME: The 5th arg is for the `constant' field.
	     What should it be?  Not that it matters since it's not
	     currently useful.  */
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION));

	  if (add_stdcall_alias && strchr (c, '@@'))
d712 3
a714 5
	      char *exported_name = xstrdup (c);
	      char *atsym = strchr (exported_name, '@@');
	      *atsym = '\0';
	      /* Note: stdcall alias symbols can never be data.  */
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0);
a716 2
      else
	p++;
a717 1
  free (buf);
d720 1
a720 3
/* Look through the symbols in MINISYMS, and add each one to list of
   symbols to export.  */

d722 1
a722 1
scan_filtered_symbols (abfd, minisyms, symcount, size)
a723 3
     PTR minisyms;
     long symcount;
     unsigned int size;
a724 13
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;
      const char *symbol_name;
a725 3
      sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));
a726 3
      symbol_name = bfd_asymbol_name (sym);
      if (bfd_get_symbol_leading_char (abfd) == symbol_name[0])
	++symbol_name;
a727 2
      def_exports (xstrdup (symbol_name) , 0, -1, 0, 0,
		   ! (sym->flags & BSF_FUNCTION));
a728 9
      if (add_stdcall_alias && strchr (symbol_name, '@@'))
        {
	  char *exported_name = xstrdup (symbol_name);
	  char *atsym = strchr (exported_name, '@@');
	  *atsym = '\0';
	  /* Note: stdcall alias symbols can never be data. */
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0);
	}
    }
d731 2
a732 57
/* Add a list of symbols to exclude.  */

static void
add_excludes (new_excludes)
     const char *new_excludes;
{
  char *local_copy;
  char *exclude_string;

  local_copy = xstrdup (new_excludes);

  exclude_string = strtok (local_copy, ",:");
  for (; exclude_string; exclude_string = strtok (NULL, ",:"))
    {
      struct string_list *new_exclude;
      
      new_exclude = ((struct string_list *)
		     xmalloc (sizeof (struct string_list)));
      new_exclude->string = (char *) xmalloc (strlen (exclude_string) + 2);
      /* FIXME: Is it always right to add a leading underscore?  */
      sprintf (new_exclude->string, "_%s", exclude_string);
      new_exclude->next = excludes;
      excludes = new_exclude;

      /* xgettext:c-format */
      inform (_("Excluding symbol: %s"), exclude_string);
    }

  free (local_copy);
}

/* See if STRING is on the list of symbols to exclude.  */

static boolean
match_exclude (string)
     const char *string;
{
  struct string_list *excl_item;

  for (excl_item = excludes; excl_item; excl_item = excl_item->next)
    if (strcmp (string, excl_item->string) == 0)
      return true;
  return false;
}

/* Add the default list of symbols to exclude.  */

static void
set_default_excludes (void)
{
  add_excludes (default_excludes);
}

/* Choose which symbols to export.  */

static long
filter_symbols (abfd, minisyms, symcount, size)
a733 3
     PTR minisyms;
     long symcount;
     unsigned int size;
d735 3
a737 12
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
d739 14
a752 16
      int keep = 0;
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, false, (const PTR) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      /* Check for external and defined only symbols.  */
      keep = (((sym->flags & BSF_GLOBAL) != 0
	       || (sym->flags & BSF_WEAK) != 0
	       || bfd_is_com_section (sym->section))
	      && ! bfd_is_und_section (sym->section));
      
      keep = keep && ! match_exclude (sym->name);

      if (keep)
d754 19
a772 2
	  memcpy (to, from, size);
	  to += size;
d774 1
d777 1
a777 5
  return (to - (bfd_byte *) minisyms) / size;
}

/* Export all symbols in ABFD, except for ones we were told not to
   export.  */
d779 3
a781 39
static void
scan_all_symbols (abfd)
     bfd *abfd;
{
  long symcount;
  PTR minisyms;
  unsigned int size;

  /* Ignore bfds with an import descriptor table.  We assume that any
     such BFD contains symbols which are exported from another DLL,
     and we don't want to reexport them from here.  */
  if (bfd_get_section_by_name (abfd, ".idata$4"))
    return;

  if (! (bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  /* Discard the symbols we don't want to export.  It's OK to do this
     in place; we'll free the storage anyway.  */

  symcount = filter_symbols (abfd, minisyms, symcount, size);
  scan_filtered_symbols (abfd, minisyms, symcount, size);

  free (minisyms);
a783 1
/* Look at the object file to decide which symbols to export.  */
d785 1
a785 16
static void
scan_open_obj_file (abfd)
     bfd *abfd;
{
  if (export_all_symbols)
    scan_all_symbols (abfd);
  else
    scan_drectve_symbols (abfd);
 
  /* FIXME: we ought to read in and block out the base relocations */

  /* xgettext:c-format */
  inform (_("Done reading %s"), bfd_get_filename (abfd));
}

static void
d787 1
a787 1
     const char *filename;
d789 1
a789 1
  bfd * f = bfd_openr (filename, 0);
d792 6
a797 6
    /* xgettext:c-format */
    fatal (_("Unable to open object file: %s"), filename);

  /* xgettext:c-format */
  inform (_("Scanning object file %s"), filename);
  
a807 5
      
#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	inform (_("Cannot produce mcore-elf dll from archive file: %s"), filename);
#endif
a811 5

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	mcore_elf_cache_filename ((char *) filename);
#endif
d819 3
a821 1
static void
d833 1
a833 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s\n",
d840 1
a840 2
	       exp->constant ? "CONSTANT" : "",
	       exp->data ? "DATA" : "");
a842 1

d845 1
a845 1
static int
d847 2
a848 2
     const void *a;
     const void *b;
d850 1
a850 1
  return *(const long *) a - *(const long *) b;
d853 2
d858 1
a858 1
     long *need;
a872 1
  
d875 1
a875 6
      long needed = need[i];
      
      if (needed)
	needed = ((needed - page_addr) | 0x3000) & 0xffff;
  
      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, needed);
a876 1
  
d880 1
d883 2
a884 1
static void
a889 2
  inform (_("Adding exports to output file"));
  
d899 7
a905 32
      char *res = cplus_demangle (exp->internal_name, DMGL_ANSI | DMGL_PARAMS);

      if (strcmp (exp->name, exp->internal_name) == 0)
        {

	  fprintf (output_def, "\t%s%s%s @@ %d%s%s ; %s\n",
		   quote,
		   exp->name,
		   quote,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->data ? " DATA" : "",
		   res ? res : "");
	}
      else 
        {
          char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
	  /* char *alias =  */
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s ; %s\n",
		   quote,
		   exp->name,
		   quote,
		   quote1,
		   exp->internal_name,
		   quote1,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->data ? " DATA" : "",
		   res ? res : "");
	}
      if (res)
        free (res);
a906 2
  
  inform (_("Added exports to output file"));
d908 1
a908 114

/* generate_idata_ofile generates the portable assembly source code
   for the idata sections.  It appends the source code to the end of
   the file.  */

static void
generate_idata_ofile (filvar)
     FILE *filvar;
{
  iheadtype *headptr;
  ifunctype *funcptr;
  int        headindex;
  int        funcindex;
  int	     nheads;

  if (import_list == NULL)
    return;

  fprintf (filvar, "%s Import data sections\n", ASM_C);
  fprintf (filvar, "\n\t.section\t.idata$2\n");
  fprintf (filvar, "\t%s\tdoi_idata\n", ASM_GLOBAL);
  fprintf (filvar, "doi_idata:\n");

  nheads = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "\t%slistone%d%s\t%s %s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER,
	       ASM_C, headptr->dllname);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%sdllname%d%s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      fprintf (filvar, "\t%slisttwo%d%s\n\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      nheads++;
    }

  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL record at */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* end of idata$2 */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* section        */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);

  fprintf (filvar, "\n\t.section\t.idata$4\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listone%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar,"\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$5\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listtwo%d:\n", headindex);
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$6\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      funcindex = 0;
      for (funcptr = headptr->funchead; funcptr != NULL;
	   funcptr = funcptr->next)
	{
	  fprintf (filvar,"funcptr%d_%d:\n", headindex, funcindex);
	  fprintf (filvar,"\t%s\t%d\n", ASM_SHORT,
		   ((funcptr->ord) & 0xFFFF));
	  fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, funcptr->name);
	  fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
	  funcindex++;
	}
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$7\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar,"dllname%d:\n", headindex);
      fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, headptr->dllname);
      fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
      headindex++;
    }
}

/* Assemble the specified file. */
static void
assemble_file (source, dest)
     const char * source;
     const char * dest;
{
  char * cmd;
  
  cmd = (char *) alloca (strlen (ASM_SWITCHES) + strlen (as_flags)
			 + strlen (source) + strlen (dest) + 50);

  sprintf (cmd, "%s %s -o %s %s", ASM_SWITCHES, as_flags, dest, source);

  run (as_name, cmd);
}

static void
d916 8
a923 4
  /* xgettext:c-format */
  inform (_("Generating export file: %s"), exp_name);
  
  f = fopen (TMP_ASM, FOPEN_WT);
d925 9
a933 5
    /* xgettext:c-format */
    fatal (_("Unable to open temporary assembler file: %s"), TMP_ASM);
  
  /* xgettext:c-format */
  inform (_("Opened temporary file: %s"), TMP_ASM);
a935 1
  
d940 1
a940 2
      fprintf (f, "\t%s	0x%lx	%s Time and date\n", ASM_LONG, (long) time(0),
	       ASM_C);
d954 1
a954 1
      fprintf (f, "\t%sanames%s	%s Address of Name Pointer Table\n",
d971 1
a971 1
#if 0
d986 2
a987 2
                   ASM_PREFIX,
                   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d997 1
a997 2
	    fprintf (f, "\t%sn%d%s\n",
		     ASM_RVA_BEFORE, exp->ordinal, ASM_RVA_AFTER);
d1011 1
a1011 2
	  fprintf (f, "n%d:	%s	\"%s\"\n",
		   exp->ordinal, ASM_TEXT, exp->name);
d1015 1
a1015 1
	  fprintf (f, "\t.section %s\n", DRECTVE_SECTION_NAME);
a1020 1
      
d1028 3
a1030 3
	      
	      /* We don't output as ascii because there can
	         be quote characters in the string.  */
d1056 1
a1056 1
     without using the import library.  */
d1063 2
a1064 9
	    /* We use a single underscore for MS compatibility, and a
               double underscore for backward compatibility with old
               cygwin releases.  */
	    if (create_compat_implib)
	      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
	    fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
	    if (create_compat_implib)
	      fprintf (f, "__imp_%s:\n", exp->name);
	    fprintf (f, "_imp__%s:\n", exp->name);
d1094 1
d1102 1
a1102 1
	      if (last != copy[src])
a1125 2
  generate_idata_ofile (f);

d1129 2
a1130 2
  assemble_file (TMP_ASM, exp_name);

d1132 4
a1135 3
    unlink (TMP_ASM);
  
  inform (_("Generated exports file"));
d1138 2
a1139 3
static const char *
xlate (name)
     const char *name;
d1161 3
a1163 6
#if 0

static void
dump_iat (f, exp)
     FILE *f;
     export_type *exp;
d1165 1
a1165 1
  if (exp->noname && !show_allnames )
a1178 1
#endif
d1180 2
a1181 1
typedef struct
d1194 1
d1204 2
d1209 2
a1210 2
#define INIT_SEC_DATA(id, name, flags, align) { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
static sinfo secdata[NSECS] =
d1212 7
a1218 7
  INIT_SEC_DATA (TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (DATA,   ".data",    SEC_DATA,                    2),
  INIT_SEC_DATA (BSS,    ".bss",     0,                           2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1)
d1221 1
a1221 1
#else
d1237 1
a1237 1
static sinfo secdata[NSECS] =
d1253 1
a1253 2
This is what we're trying to make.  We generate the imp symbols with
both single and double underscores, for compatibility.
d1278 1
a1278 1
# Rather than a simple "jmp *", the code to get to the dll function
d1308 1
a1308 1
#if 0
a1309 1
      char *name;
d1311 3
a1313 6
      const char *prefix = "d";
      char *dest;

      name = (char *) alloca (strlen (prefix) + 10);
      sprintf (name, "%ss%05d.s", prefix, i);
      f = fopen (name, FOPEN_WT);
d1316 3
a1318 6
      if (create_compat_implib)
	fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
      fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
      if (create_compat_implib)
	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
		 exp->name, ASM_JUMP, exp->name);
d1327 1
a1327 3
      if (create_compat_implib)
	fprintf (f, "__imp_%s:\n", exp->name);
      fprintf (f, "_imp__%s:\n", exp->name);
d1336 1
a1336 1
      if(!exp->noname || show_allnames)
d1340 1
a1340 1
	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint);
d1344 18
a1361 1
      fclose (f);
d1363 1
a1363 13
      dest = (char *) alloca (strlen (prefix) + 10);
      sprintf (dest, "%ss%05d.o", prefix, i);
      assemble_file (name, dest);
    }
#else /* if 0 */
    {
      bfd *      abfd;
      asymbol *  exp_label;
      asymbol *  iname;
      asymbol *  iname2;
      asymbol *  iname_lab;
      asymbol ** iname_lab_pp;
      asymbol ** iname_pp;
d1365 3
a1367 3
      asymbol ** fn_pp;
      asymbol ** toc_pp;
#define EXTRA	 2
a1368 4
#ifndef EXTRA
#define EXTRA    0
#endif
      asymbol *  ptrs[NSECS + 4 + EXTRA + 1];
d1370 7
a1376 2
      char *     outname = xmalloc (10);
      int        oidx = 0;
d1378 4
a1381 5
      
      sprintf (outname, "%s%05d.o", TMP_STUB, i);
      
      abfd = bfd_openw (outname, HOW_BFD_WRITE_TARGET);
      
d1383 5
a1387 2
	/* xgettext:c-format */
	fatal (_("bfd_open failed open stub file: %s"), outname);
a1388 3
      /* xgettext:c-format */
      inform (_("Creating stub file: %s"), outname);
      
d1392 1
a1392 5
#ifdef DLLTOOL_ARM
      if (machine == MARM_INTERWORK || machine == MTHUMB)
	bfd_set_private_flags (abfd, F_INTERWORK);
#endif
      
d1400 1
a1400 1
	  bfd_set_section_flags (abfd,
d1403 1
a1403 1

a1412 2
	  si->size = 0;
	  si->data = NULL;
d1417 11
a1427 4
      if (! exp->data)
	{
	  exp_label = bfd_make_empty_symbol (abfd);
	  exp_label->name = make_label ("", exp->name);
d1429 2
a1430 10
	  /* On PowerPC, the function name points to a descriptor in
	     the rdata section, the first element of which is a
	     pointer to the code (..function_name), and the second
	     points to the .toc */
#ifdef DLLTOOL_PPC
	  if (machine == MPPC)
	    exp_label->section = secdata[RDATA].sec;
	  else
#endif
	    exp_label->section = secdata[TEXT].sec;
d1432 1
a1432 2
	  exp_label->flags = BSF_GLOBAL;
	  exp_label->value = 0;
d1434 5
a1438 6
#ifdef DLLTOOL_ARM
	  if (machine == MTHUMB)
	    bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
#endif
	  ptrs[oidx++] = exp_label;
	}
a1439 17
      /* Generate imp symbols with one underscore for Microsoft
         compatibility, and with two underscores for backward
         compatibility with old versions of cygwin.  */
      if (create_compat_implib)
	{
	  iname = bfd_make_empty_symbol (abfd);
	  iname->name = make_label ("__imp_", exp->name);
	  iname->section = secdata[IDATA5].sec;
	  iname->flags = BSF_GLOBAL;
	  iname->value = 0;
	}

      iname2 = bfd_make_empty_symbol (abfd);
      iname2->name = make_label ("_imp__", exp->name);
      iname2->section = secdata[IDATA5].sec;
      iname2->flags = BSF_GLOBAL;
      iname2->value = 0;
d1450 1
a1450 3
      if (create_compat_implib)
	ptrs[oidx++] = iname;
      ptrs[oidx++] = iname2;
d1457 5
a1461 8
      {
	asymbol *function_name;

	function_name = bfd_make_empty_symbol(abfd);
	function_name->name = make_label ("..", exp->name);
	function_name->section = secdata[TEXT].sec;
	function_name->flags = BSF_GLOBAL;
	function_name->value = 0;
d1463 2
a1464 3
	fn_pp = ptrs + oidx;
	ptrs[oidx++] = function_name;
      }
d1467 5
a1471 2
      {
	asymbol *toc_symbol;    /* The .toc symbol */
d1473 3
a1475 5
	toc_symbol = bfd_make_empty_symbol (abfd);
	toc_symbol->name = make_label (".", "toc");
	toc_symbol->section = (asection *)&bfd_und_section;
	toc_symbol->flags = BSF_GLOBAL;
	toc_symbol->value = 0;
a1476 5
	toc_pp = ptrs + oidx;
	ptrs[oidx++] = toc_symbol;
      }
#endif
      
d1486 1
a1486 1
	  switch (i)
d1489 19
a1507 1
	      if (! exp->data)
d1509 2
a1510 27
		  si->size = HOW_JTAB_SIZE;
		  si->data = xmalloc (HOW_JTAB_SIZE);
		  memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);

		  /* add the reloc into idata$5 */
		  rel = xmalloc (sizeof (arelent));
		  
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  
		  rel->address = HOW_JTAB_ROFF;
		  rel->addend = 0;

		  if (machine == MPPC)
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd,
							  BFD_RELOC_16_GOTOFF);
		      rel->sym_ptr_ptr = iname_pp;
		    }
		  else
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		      rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		    }
		  sec->orelocation = rpp;
		  sec->reloc_count = 1;
d1512 2
d1519 1
a1519 1

d1530 1
a1530 1
	      else
d1548 1
a1548 1
	      if (!exp->noname)
d1550 1
a1550 4
		  /* This used to add 1 to exp->hint.  I don't know
                     why it did that, and it does not match what I see
                     in programs compiled with the MS tools.  */
		  int idx = exp->hint;
a1572 1
#ifdef DLLTOOL_PPC
d1590 5
a1594 5
		   1. In the name of glue trickery, the ADDR32 relocs for 0,
		      4, and 0x10 are set to point to the same place:
		      "..function_name".
		   2. There is one more reloc needed in the pdata section.
		      The actual glue instruction to restore the toc on
d1620 1
a1620 1
		imglue->howto = bfd_reloc_type_lookup (abfd,
d1658 1
a1658 1
	      si->data = xmalloc (8);
a1680 1
#endif /* DLLTOOL_PPC */
d1708 1
a1708 1
	  bfd_set_section_contents (abfd, si->sec,
d1715 1
a1715 1
      abfd = bfd_openr (outname, HOW_BFD_READ_TARGET);
d1718 1
a1718 1
#endif
d1721 1
d1723 1
a1723 1
make_head ()
d1725 1
a1725 1
  FILE *f = fopen (TMP_HEAD_S, FOPEN_WT);
a1726 6
  if (f == NULL)
    {
      fatal (_("failed to open temporary head file: %s"), TMP_HEAD_S);
      return NULL;
    }
  
d1752 1
a1752 1
  if (!no_idata5)
d1758 1
a1758 2
  
  if (!no_idata4)
a1765 1
  
d1768 2
a1769 1
  assemble_file (TMP_HEAD_S, TMP_HEAD_O);
d1771 1
a1771 1
  return bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
d1774 2
a1775 2
static bfd *
make_tail ()
d1777 1
a1777 1
  FILE *f = fopen (TMP_TAIL_S, FOPEN_WT);
d1779 1
a1779 7
  if (f == NULL)
    {
      fatal (_("failed to open temporary tail file: %s"), TMP_TAIL_S);
      return NULL;
    }
  
  if (!no_idata4)
d1784 1
a1784 2
  
  if (!no_idata5)
d1821 3
a1823 3
  assemble_file (TMP_TAIL_S, TMP_TAIL_O);
  
  return  bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d1838 1
a1838 1
  outarch = bfd_openw (imp_name, HOW_BFD_WRITE_TARGET);
d1841 4
a1844 6
    /* xgettext:c-format */
    fatal (_("Can't open .lib file: %s"), imp_name);

  /* xgettext:c-format */
  inform (_("Creating library file: %s"), imp_name);
  
d1850 2
a1854 3
  if (ar_head == NULL || ar_tail == NULL)
    return;
  
d1862 1
d1869 2
a1870 12
  if (! bfd_set_archive_head (outarch, head))
    bfd_fatal ("bfd_set_archive_head");
  
  if (! bfd_close (outarch))
    bfd_fatal (imp_name);

  while (head != NULL)
    {
      bfd *n = head->next;
      bfd_close (head);
      head = n;
    }
d1876 8
a1883 4
      unlink (TMP_HEAD_O);
      unlink (TMP_HEAD_S);
      unlink (TMP_TAIL_O);
      unlink (TMP_TAIL_S);
d1887 5
a1891 2
    {
      char *name;
a1892 11
      name = (char *) alloca (sizeof TMP_STUB + 10);
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
	{
	  sprintf (name, "%s%05d.o", TMP_STUB, i);
	  if (unlink (name) < 0)
	    /* xgettext:c-format */
	    non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
	}
    }
  
  inform (_("Created lib file"));
a1893 1

d1898 1
a1898 1
static int
d1900 2
a1901 2
     const void *a;
     const void *b;
d1916 2
a1917 1
static int
d1919 2
a1920 2
     const void *a;
     const void *b;
d1928 2
a1929 1
static void
d1948 1
a1948 5
     export_type ** ptr
#ifndef SACDEBUG
ATTRIBUTE_UNUSED
#endif
     ;
d1956 1
a1956 1
	  printf ("%d %s @@ %d %s%s%s\n",
d1959 1
a1959 2
		  ptr[i]->constant ? "CONSTANT" : "",
		  ptr[i]->data ? "DATA" : "");
d1972 1
a1972 1
  int i;
d1991 5
a1995 5
	      
	      /* xgettext:c-format */
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d"),
		      a->name, a->ordinal, b->ordinal);
	      
d1998 1
a1998 3
		/* xgettext:c-format */
		fatal (_("Error, duplicate EXPORT with oridinals: %s"),
		      a->name);
d2000 4
a2007 1
	      b->data |= a->data;
d2095 1
a2095 1
  if (d_nfuncs)
d2104 3
a2106 4
static int
alphafunc (av,bv)
     const void *av;
     const void *bv;
d2108 2
a2109 2
  const export_type **a = (const export_type **) av;
  const export_type **b = (const export_type **) bv;
d2114 1
a2114 1
static void
a2125 2
  inform (_("Processing definitions"));
  
d2143 1
a2143 2
  d_exports_lexically = (export_type **)
    xmalloc (sizeof (export_type *) * (d_nfuncs + 1));
d2154 1
a2154 1

d2160 1
a2160 2
  
  inform (_("Processed definitions"));
d2163 5
d2170 1
a2170 1
static void
d2175 16
a2190 33
  /* xgetext:c-format */
  fprintf (file, _("Usage %s <options> <object-files>\n"), program_name);
  /* xgetext:c-format */
  fprintf (file, _("   -m --machine <machine>    Create as DLL for <machine>.  [default: %s]\n"), mname);
  fprintf (file, _("        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\n"));
  fprintf (file, _("   -e --output-exp <outname> Generate an export file.\n"));
  fprintf (file, _("   -l --output-lib <outname> Generate an interface library.\n"));
  fprintf (file, _("   -a --add-indirect         Add dll indirects to export file.\n"));
  fprintf (file, _("   -D --dllname <name>       Name of input dll to put into interface lib.\n"));
  fprintf (file, _("   -d --input-def <deffile>  Name of .def file to be read in.\n"));
  fprintf (file, _("   -z --output-def <deffile> Name of .def file to be created.\n"));
  fprintf (file, _("      --export-all-symbols   Export all symbols to .def\n"));
  fprintf (file, _("      --no-export-all-symbols  Only export listed symbols\n"));
  fprintf (file, _("      --exclude-symbols <list> Don't export <list>\n"));
  fprintf (file, _("      --no-default-excludes  Clear default exclude symbols\n"));
  fprintf (file, _("   -b --base-file <basefile> Read linker generated base file.\n"));
  fprintf (file, _("   -x --no-idata4            Don't generate idata$4 section.\n"));
  fprintf (file, _("   -c --no-idata5            Don't generate idata$5 section.\n"));
  fprintf (file, _("   -U --add-underscore       Add underscores to symbols in interface library.\n"));
  fprintf (file, _("   -k --kill-at              Kill @@<n> from exported names.\n"));
  fprintf (file, _("   -A --add-stdcall-alias    Add aliases without @@<n>.\n"));
  fprintf (file, _("   -S --as <name>            Use <name> for assembler.\n"));
  fprintf (file, _("   -f --as-flags <flags>     Pass <flags> to the assembler.\n"));
  fprintf (file, _("   -C --compat-implib        Create backward compatible import library.\n"));
  fprintf (file, _("   -n --no-delete            Keep temp files (repeat for extra preservation).\n"));
  fprintf (file, _("   -v --verbose              Be verbose.\n"));
  fprintf (file, _("   -V --version              Display the program version.\n"));
  fprintf (file, _("   -h --help                 Display this information.\n"));
#ifdef DLLTOOL_MCORE_ELF
  fprintf (file, _("   -M --mcore-elf <outname>  Process mcore-elf object files into <outname>.\n"));
  fprintf (file, _("   -L --linker <name>        Use <name> as the linker.\n"));
  fprintf (file, _("   -F --linker-flags <flags> Pass <flags> to the linker.\n"));
#endif
d2194 3
a2196 6
#define OPTION_EXPORT_ALL_SYMS		150
#define OPTION_NO_EXPORT_ALL_SYMS	(OPTION_EXPORT_ALL_SYMS + 1)
#define OPTION_EXCLUDE_SYMS		(OPTION_NO_EXPORT_ALL_SYMS + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_EXCLUDE_SYMS + 1)

static const struct option long_options[] =
d2198 1
a2198 1
  {"no-delete", no_argument, NULL, 'n'},
d2200 2
a2201 2
  {"no-idata4", no_argument, NULL, 'x'},
  {"no-idata5", no_argument, NULL, 'c'},
a2203 4
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL_SYMS},
  {"no-export-all-symbols", no_argument, NULL, OPTION_NO_EXPORT_ALL_SYMS},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMS},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
d2205 1
a2205 2
  {"def", required_argument, NULL, 'd'}, /* for compatiblity with older versions */
  {"input-def", required_argument, NULL, 'd'},
d2207 1
a2207 4
  {"kill-at", no_argument, NULL, 'k'},
  {"add-stdcall-alias", no_argument, NULL, 'A'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
d2213 1
a2213 4
  {"as-flags", required_argument, NULL, 'f'},
  {"mcore-elf", required_argument, NULL, 'M'},
  {"compat-implib", no_argument, NULL, 'C'},
  {NULL,0,NULL,0}
d2216 2
d2229 1
a2229 13
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  while ((c = getopt_long (ac, av,
#ifdef DLLTOOL_MCORE_ELF			   
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVhM:L:F:",
#else
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVh",
#endif
			   long_options, 0))
d2234 1
a2234 13
	case OPTION_EXPORT_ALL_SYMS:
	  export_all_symbols = true;
	  break;
	case OPTION_NO_EXPORT_ALL_SYMS:
	  export_all_symbols = false;
	  break;
	case OPTION_EXCLUDE_SYMS:
	  add_excludes (optarg);
	  break;
	case OPTION_NO_DEFAULT_EXCLUDES:
	  do_default_excludes = false;
	  break;
	case 'x':
d2237 1
a2237 1
	case 'c':
a2242 3
	case 'f':
	  as_flags = optarg;
	  break;
d2263 2
a2264 1
	  usage (stdout, 0);
d2272 2
a2273 2
	case 'V':
	  print_version (program_name);
a2280 3
	case 'A':
	  add_stdcall_alias = 1;
	  break;
a2288 1
	  
d2290 6
a2295 17
	    /* xgettext:c-format */
	    fatal (_("Unable to open base-file: %s"), optarg);

	  break;
#ifdef DLLTOOL_MCORE_ELF
	case 'M':
	  mcore_elf_out_file = optarg;
	  break;
	case 'L':
	  mcore_elf_linker = optarg;
	  break;
	case 'F':
	  mcore_elf_linker_flags = optarg;
	  break;
#endif
	case 'C':
	  create_compat_implib = 1;
a2298 1
	  break;
d2302 1
d2304 4
a2307 2
    if (strcmp (mtable[i].type, mname) == 0)
      break;
d2310 5
a2314 2
    /* xgettext:c-format */
    fatal (_("Machine '%s' not supported"), mname);
a2315 1
  machine = i;
d2319 1
a2319 1
      int len = strlen (exp_name) + 5;
a2324 12
  if (as_name == NULL)
    as_name = deduce_name ("as");
  
  /* Don't use the default exclude list if we're reading only the
     symbols in the .drectve section.  The default excludes are meant
     to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */
  if (! export_all_symbols)
    do_default_excludes = false;
  
  if (do_default_excludes)
    set_default_excludes ();

d2326 3
a2328 2
    process_def_file (def_file);

a2340 1
  
d2345 2
a2346 3

      imp_name_lab = xstrdup (imp_name);
      for (p = imp_name_lab; *p; p++)
d2348 1
a2348 1
	  if (!isalpha ((unsigned char) *p) && !isdigit ((unsigned char) *p))
a2353 1
  
d2356 1
a2356 6
  
#ifdef DLLTOOL_MCORE_ELF
  if (mcore_elf_out_file)
    mcore_elf_gen_out_file ();
#endif
  
a2358 245

/* Look for the program formed by concatenating PROG_NAME and the
   string running from PREFIX to END_PREFIX.  If the concatenated
   string contains a '/', try appending EXECUTABLE_SUFFIX if it is
   appropriate.  */

static char *
look_for_prog (prog_name, prefix, end_prefix)
     const char *prog_name;
     const char *prefix;
     int end_prefix;
{
  struct stat s;
  char *cmd;

  cmd = xmalloc (strlen (prefix) 
                 + strlen (prog_name) 
#ifdef HAVE_EXECUTABLE_SUFFIX
                 + strlen (EXECUTABLE_SUFFIX) 
#endif
		 + 10);
  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", prog_name);

  if (strchr (cmd, '/') != NULL)
    {
      int found;

      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
               || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
        {
	  /* xgettext:c-format */
	  inform (_("Tried file: %s"), cmd);
	  free (cmd);
	  return NULL;
	}
    }

  /* xgettext:c-format */
  inform (_("Using file: %s"), cmd);

  return cmd;
}

/* Deduce the name of the program we are want to invoke.
   PROG_NAME is the basic name of the program we want to run,
   eg "as" or "ld".  The catch is that we might want actually
   run "i386-pe-as" or "ppc-pe-ld".  

   If argv[0] contains the full path, then try to find the program
   in the same place, with and then without a target-like prefix.

   Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,
   deduce_name("as") uses the following search order: 

     /usr/local/bin/i586-cygwin32-as
     /usr/local/bin/as
     as
   
   If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each
   name, it'll try without and then with EXECUTABLE_SUFFIX.

   Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"
   as the fallback, but rather return i586-cygwin32-as.
     
   Oh, and given, argv[0] = dlltool, it'll return "as".

   Returns a dynamically allocated string.  */

static char *
deduce_name (prog_name)
     const char *prog_name;
{
  char *cmd;
  char *dash, *slash, *cp;

  dash = NULL;
  slash = NULL;
  for (cp = program_name; *cp != '\0'; ++cp)
    {
      if (*cp == '-')
	dash = cp;
      if (
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
	  *cp == ':' || *cp == '\\' ||
#endif
	  *cp == '/')
	{
	  slash = cp;
	  dash = NULL;
	}
    }

  cmd = NULL;

  if (dash != NULL)
    {
      /* First, try looking for a prefixed PROG_NAME in the
         PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
      cmd = look_for_prog (prog_name, program_name, dash - program_name + 1);
    }

  if (slash != NULL && cmd == NULL)
    {
      /* Next, try looking for a PROG_NAME in the same directory as
         that of this program.  */
      cmd = look_for_prog (prog_name, program_name, slash - program_name + 1);
    }

  if (cmd == NULL)
    {
      /* Just return PROG_NAME as is.  */
      cmd = xstrdup (prog_name);
    }

  return cmd;
}

#ifdef DLLTOOL_MCORE_ELF
typedef struct fname_cache
{
  char *               filename;
  struct fname_cache * next;
}
fname_cache;

static fname_cache fnames;

static void
mcore_elf_cache_filename (char * filename)
{
  fname_cache * ptr;

  ptr = & fnames;

  while (ptr->next != NULL)
    ptr = ptr->next;

  ptr->filename = filename;
  ptr->next     = (fname_cache *) malloc (sizeof (fname_cache));
  if (ptr->next != NULL)
    ptr->next->next = NULL;
}

#define MCORE_ELF_TMP_OBJ "mcoreelf.o"
#define MCORE_ELF_TMP_EXP "mcoreelf.exp"
#define MCORE_ELF_TMP_LIB "mcoreelf.lib"

static void
mcore_elf_gen_out_file (void)
{
  fname_cache * ptr;
  dyn_string_t ds;

  /* Step one.  Run 'ld -r' on the input object files in order to resolve
     any internal references and to generate a single .exports section.  */
  ptr = & fnames;

  ds = dyn_string_new (100);
  dyn_string_append (ds, "-r ");

  if (mcore_elf_linker_flags != NULL)
    dyn_string_append (ds, mcore_elf_linker_flags);
  
  while (ptr->next != NULL)
    {
      dyn_string_append (ds, ptr->filename);
      dyn_string_append (ds, " ");

      ptr = ptr->next;
    }

  dyn_string_append (ds, "-o ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);

  if (mcore_elf_linker == NULL)
    mcore_elf_linker = deduce_name ("ld");
  
  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  /* Step two. Create a .exp file and a .lib file from the temporary file. 
     Do this by recursively invoking dlltool....*/
  ds = dyn_string_new (100);

  dyn_string_append (ds, "-S ");
  dyn_string_append (ds, as_name);
  
  dyn_string_append (ds, " -e ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " -l ");
  dyn_string_append (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append (ds, " " );
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);

  if (verbose)
    dyn_string_append (ds, " -v");
  
  if (dontdeltemps)
    {
      dyn_string_append (ds, " -n");
  
      if (dontdeltemps > 1)
	dyn_string_append (ds, " -n");
    }

  /* XXX - FIME: ought to check/copy other command line options as well.  */
  
  run (program_name, ds->s);

  dyn_string_delete (ds);

  /* Step four. Feed the .exp and object files to ld -shared to create the dll.  */
  ds = dyn_string_new (100);

  dyn_string_append (ds, "-shared ");

  if (mcore_elf_linker_flags)
    dyn_string_append (ds, mcore_elf_linker_flags);

  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append (ds, " -o ");
  dyn_string_append (ds, mcore_elf_out_file);

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  if (dontdeltemps == 0)
    unlink (MCORE_ELF_TMP_EXP);

  if (dontdeltemps < 2)
    unlink (MCORE_ELF_TMP_OBJ);
}
#endif /* DLLTOOL_MCORE_ELF */
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
a385 3
#ifdef DLLTOOL_ARM_EPOC
static const char *mname = "arm-epoc";
#else
a387 1
#endif
d608 1
a608 1
    "arm-epoc", ".byte", ".short", ".long", ".asciz", "@@",
a728 1
    case MARM_EPOC:
a752 1
    case MARM_EPOC:
a775 1
    case MARM_EPOC:
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d23 2
a24 1
/* This program allows you to build the files necessary to create
d51 1
a51 3
   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d53 1
a53 3
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.
d114 1
a114 1

d161 1
a161 1

d165 1
a165 1

d169 1
a169 1

d179 1
a179 1

d184 1
a184 1

d189 1
a189 1

d193 3
a195 2

   ld -o thedll.dll thedll.exp file1.o file2.o  */
d231 2
a232 1
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */
a251 1
#include "safe-ctype.h"
d253 1
d269 2
a270 4
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));
d273 2
a274 4
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
d276 1
a276 1

d282 1
a282 1
#define WIFEXITED(w)	(((w) & 0377) == 0)
d285 1
a285 1
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
d326 2
a327 2
  char *         name;   /* Name of function being imported.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
d333 5
a337 5
  char          *dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
a347 2
static char *tmp_prefix = "d";

d360 1
a360 1
/* TRUE if we should export all symbols.  Otherwise, we only export
d362 1
a362 1
static bfd_boolean export_all_symbols;
d364 1
a364 1
/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
d366 1
a366 1
static bfd_boolean do_default_excludes = TRUE;
d371 1
a371 1
/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
d373 1
a373 1
static bfd_boolean create_compat_implib;
d427 1
a427 1
#define PATHMAX 250		/* What's the right name for this ?  */
d429 6
a434 13
char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")
d436 1
a436 1
/* This bit of assemly does jmp * ....  */
d471 1
a471 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */
d474 1
a474 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d480 1
a480 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */
d483 1
a483 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */
d486 5
a490 5
/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
d503 2
a504 2
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
d525 2
a526 2
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
a638 1
    int forward;	/* Number of forward label, 0 means no forward.  */
d644 1
a644 1

d653 21
a673 48
static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
d675 1
a675 2
static void dump_iat
  PARAMS ((FILE *, export_type *));
d677 15
a691 32
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));
a692 8
static char *
dlltmp PARAMS ((char *buf, const char *fmt))
{
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
  return buf;
}
d695 7
a701 1
inform VPARAMS ((const char * message, ...))
d703 2
a704 3
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

d708 6
d715 2
a716 2

  VA_CLOSE (args);
d818 1
a818 1
static void
d823 1
a823 1

d832 1
a832 1

d840 1
a840 1
/* Communications with the parser.  */
d842 9
a850 10
static const char *d_name;	/* Arg to NAME or LIBRARY.  */
static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */
d861 1
a861 1

a884 6

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
d894 1
a894 1

d897 1
a897 1

d899 2
a900 2
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
d913 1
a913 1

d916 1
a916 1

d918 1
a918 1
  /* If --dllname not provided, use the one in the DEF file.  */
d934 1
a934 1
static void
d1060 1
a1060 1

d1161 1
a1161 1

d1166 1
a1166 1

d1203 1
a1203 1

d1206 1
a1206 1

d1211 1
a1211 1

d1229 1
a1229 1

d1237 1
a1237 1
	  if (p < e && *p == ',')       /* found type tag.  */
d1253 1
a1253 2
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
d1290 1
a1290 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
d1303 1
a1303 2
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
d1306 1
a1306 1
	  /* Note: stdcall alias symbols can never be data.  */
d1327 1
a1327 1

d1331 2
a1332 5
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "_%s", exclude_string);
d1345 1
a1345 1
static bfd_boolean
d1353 2
a1354 2
      return TRUE;
  return FALSE;
d1390 1
a1390 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
d1399 1
a1399 1

d1436 1
a1436 1
  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
d1466 2
a1467 2

  /* FIXME: we ought to read in and block out the base relocations.  */
d1485 1
a1485 1

d1496 1
a1496 1

d1541 1
a1541 1
/* Generate the .exp file.  */
d1560 1
a1560 1
  /* Flush this page.  */
d1569 1
a1569 1

d1573 1
a1573 1

d1576 1
a1576 1

d1579 1
a1579 1

d1592 1
a1592 1

a1603 6
      if (res)
	{
 	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

d1605 1
a1605 1
	{
d1607 1
a1607 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
d1613 2
a1614 1
		   exp->data ? " DATA" : "");
d1616 3
a1618 3
      else
	{
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1620 1
a1620 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
d1629 2
a1630 1
		   exp->data ? " DATA" : "");
d1632 2
d1635 1
a1635 1

d1735 1
a1735 1
/* Assemble the specified file.  */
d1742 1
a1742 1

d1761 1
a1761 1

d1766 1
a1766 1

d1771 1
a1771 1

d1822 3
a1824 14

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1849 2
a1850 7
	  {
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }
d1860 1
a1860 1

d1868 1
a1868 1

d1916 1
a1916 1
  /* Dump the reloc section if a base file is provided.  */
d1976 1
a1976 1
  /* Assemble the file.  */
d1981 1
a1981 1

d1989 1
a1989 3
  int lead_at = (*name == '@@');

  if (add_underscore &&  !lead_at)
a1991 1

a1999 2

      name += lead_at;
d2042 1
a2042 1
  unsigned char *data;
d2057 1
a2057 7
#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2060 7
a2066 7
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
d2071 2
a2072 2
/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
d2100 3
a2102 2
/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.
d2125 1
a2125 1
   For the PowerPC, here's the variation on the above scheme:
d2136 2
a2137 1
	 bctr  */
a2145 1

a2151 26
static char *
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX);
      strcat (copy, name);
    }
  return copy;
}

d2212 1
a2212 1
      asymbol *  iname = 0;
a2225 1
      flagword   applicable;
d2230 1
a2230 1

d2232 1
a2232 1

d2234 1
a2234 1

d2241 1
a2241 1

d2249 2
a2250 4

      applicable = bfd_applicable_section_flags (abfd);

      /* First make symbols for the sections.  */
d2259 1
a2259 1
				 si->flags & applicable);
d2279 1
a2279 1
	  exp_label->name = make_imp_label ("", exp->name);
d2284 1
a2284 1
	     points to the .toc.  */
d2308 1
a2308 1
	  iname->name = make_imp_label ("___imp", exp->name);
d2315 1
a2315 1
      iname2->name = make_imp_label ("__imp_", exp->name);
d2327 1
d2337 1
a2337 1
      /* The symbol refering to the code (.text).  */
d2351 1
a2351 1
      /* The .toc symbol.  */
d2353 1
a2353 1
	asymbol *toc_symbol;
d2365 1
a2365 1

d2386 1
a2386 1

d2390 1
a2390 1

d2412 1
a2412 1
		 rva to idata$6.  */
d2457 1
a2457 1
	      si->data =xmalloc (4);
d2473 10
a2482 10
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */
d2497 2
a2498 1
		      that this is a glue routine.  */
d2501 1
a2501 1
		/* Alignment must be set to 2**2 or you get extra stuff.  */
d2505 1
a2505 1
		si->data = xmalloc (si->size);
d2514 1
a2514 1
		/* Stick the toc reload instruction in the glue reloc.  */
d2527 1
a2527 1
		bfd_put_32 (abfd, 0x18, si->data + 0x04);
d2533 2
a2534 2
		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);
d2536 2
a2537 2
		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
d2552 3
a2554 1
	         We use relocs to build this.  */
d2585 1
a2585 1
	/* Size up all the sections.  */
d2596 1
a2596 1
      /* Write them out.  */
d2630 1
a2630 1

d2662 1
a2662 1

d2671 1
a2671 1

d2689 1
a2689 1

d2695 1
a2695 1

d2708 2
a2709 1
     crt0).  */
d2721 1
a2721 1
     do too. Original, huh?  */
d2734 2
a2735 2

  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d2758 1
a2758 1

d2762 2
a2763 1
  /* Work out a reasonable size of things to put onto one line.  */
d2769 1
a2769 1

d2777 2
a2778 1
  /* Now stick them all into the archive.  */
d2785 1
a2785 1

d2796 2
a2797 1
  /* Delete all the temp files.  */
d2819 1
a2819 1

d2826 1
a2826 1
   .def file and work out the best stuff.  */
d2837 1
a2837 1
  /* Unset ordinals go to the bottom.  */
a2861 1

a2904 1

d2909 1
a2909 1
      /* Remove duplicates.  */
d2923 1
a2923 1

d2927 1
a2927 1

d2934 1
a2934 1
	      /* Merge attributes.  */
d2949 1
a2949 1
  /* Count the names.  */
d2968 2
a2969 1
  /* Fill in the unset ordinals with ones from our range.  */
d2974 1
a2974 1
  /* Mark in our large vector all the numbers that are taken.  */
a2979 1

d2981 3
a2983 1
	    lowest = d_export_vec[i]->ordinal;
d2991 1
a2991 1
  /* Now fill in ordinals where the user wants us to choose.  */
d2998 1
a2998 1
	  /* First try within or after any user supplied range.  */
d3007 1
a3007 1
	  /* Then try before the range.  */
d3021 2
a3022 1
  /* And resort.  */
d3049 2
a3050 1
  /* First work out the minimum ordinal chosen.  */
d3059 1
a3059 1

d3061 3
a3063 1
    d_export_vec[i] = exp;
d3068 1
a3068 1
  /* Put back the list in the new order.  */
d3076 1
a3076 1
  /* Build list in alpha order.  */
d3081 3
a3083 2
    d_exports_lexically[i] = exp;

d3088 2
a3089 1
  /* Fill exp entries with their hint values.  */
d3091 5
a3095 3
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

d3107 1
a3107 1
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
a3174 1
  {"temp-prefix", required_argument, NULL, 't'},
a3177 2
int main PARAMS ((int, char **));

a3191 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d3196 2
a3197 2
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
d3199 1
a3199 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
d3207 1
a3207 1
	  export_all_symbols = TRUE;
d3210 1
a3210 1
	  export_all_symbols = FALSE;
d3216 1
a3216 1
	  do_default_excludes = FALSE;
a3226 3
	case 't':
	  tmp_prefix = optarg;
	  break;
a3248 1
	case 'H':
d3278 1
a3278 1

d3324 1
a3324 1

d3329 2
a3330 2
    do_default_excludes = FALSE;

d3349 1
a3349 1

d3352 1
a3352 1
      /* Make imp_name safe for use as a label.  */
d3358 1
a3358 1
	  if (!ISALNUM (*p))
d3364 1
a3364 1

d3367 1
a3367 1

d3372 1
a3372 1

d3390 2
a3391 2
  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
d3393 1
a3393 1
		 + strlen (EXECUTABLE_SUFFIX)
d3406 1
a3406 1
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3411 1
a3411 1
	{
d3428 1
a3428 1
   run "i386-pe-as" or "ppc-pe-ld".
d3434 1
a3434 1
   deduce_name("as") uses the following search order:
d3439 1
a3439 1

d3445 1
a3445 1

d3540 1
a3540 1
  dyn_string_append_cstr (ds, "-r ");
d3543 2
a3544 2
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

d3547 2
a3548 2
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");
d3553 2
a3554 2
  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3558 1
a3558 1

d3563 2
a3564 2
  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
d3567 9
a3575 9
  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
d3578 2
a3579 2
    dyn_string_append_cstr (ds, " -v");

d3582 2
a3583 2
      dyn_string_append_cstr (ds, " -n");

d3585 1
a3585 1
	dyn_string_append_cstr (ds, " -n");
d3589 1
d3597 1
a3597 1
  dyn_string_append_cstr (ds, "-shared ");
d3600 1
a3600 1
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);
d3602 6
a3607 6
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d52 1
a52 1
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] [PRIVATE] ) *
d63 1
a63 1
   function will be refereed to in the body of the DLL.
d270 4
a273 2
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);
d276 4
a279 2
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
d353 1
a353 1
static char *tmp_prefix;
d443 6
a448 6
#define TMP_ASM		dlltmp (&tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (&tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (&tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (&tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (&tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (&tmp_stub_buf, "%ss")
d450 1
a450 1
/* This bit of assembly does jmp * ....  */
d650 1
a650 2
    int noname;		/* Don't put name in image file.  */
    int private;	/* Don't put reference in import lib.  */
d668 48
a715 24
static const char *rvaafter (int);
static const char *rvabefore (int);
static const char *asm_prefix (int);
static void process_def_file (const char *);
static void new_directive (char *);
static void append_import (const char *, const char *, int);
static void run (const char *, char *);
static void scan_drectve_symbols (bfd *);
static void scan_filtered_symbols (bfd *, void *, long, unsigned int);
static void add_excludes (const char *);
static bfd_boolean match_exclude (const char *);
static void set_default_excludes (void);
static long filter_symbols (bfd *, void *, long, unsigned int);
static void scan_all_symbols (bfd *);
static void scan_open_obj_file (bfd *);
static void scan_obj_file (const char *);
static void dump_def_info (FILE *);
static int sfunc (const void *, const void *);
static void flush_page (FILE *, long *, int, int);
static void gen_def_file (void);
static void generate_idata_ofile (FILE *);
static void assemble_file (const char *, const char *);
static void gen_exp_file (void);
static const char *xlate (const char *);
d717 2
a718 1
static void dump_iat (FILE *, export_type *);
d720 32
a751 16
static char *make_label (const char *, const char *);
static char *make_imp_label (const char *, const char *);
static bfd *make_one_lib_file (export_type *, int);
static bfd *make_head (void);
static bfd *make_tail (void);
static void gen_lib_file (void);
static int pfunc (const void *, const void *);
static int nfunc (const void *, const void *);
static void remove_null_names (export_type **);
static void dtab (export_type **);
static void process_duplicates (export_type **);
static void fill_ordinals (export_type **);
static int alphafunc (const void *, const void *);
static void mangle_defs (void);
static void usage (FILE *, int);
static void inform (const char *, ...);
d754 1
a754 1
prefix_encode (char *start, unsigned code)
d756 3
a758 9
  static char alpha[26] = "abcdefghijklmnopqrstuvwxyz";
  static char buf[32];
  char *p;
  strcpy (buf, start);
  p = strchr (buf, '\0');
  do
    *p++ = alpha[code % sizeof (alpha)];
  while ((code /= sizeof (alpha)) != 0);
  *p = '\0';
a761 11
static char *
dlltmp (char **buf, const char *fmt)
{
  if (!*buf)
    {
      *buf = malloc (strlen (tmp_prefix) + 64);
      sprintf (*buf, fmt, tmp_prefix);
    }
  return *buf;
}

d777 2
a778 1
rvaafter (int machine)
d802 2
a803 1
rvabefore (int machine)
d827 2
a828 1
asm_prefix (int machine)
d852 2
a853 2
#define ASM_BYTE	mtable[machine].how_byte
#define ASM_SHORT	mtable[machine].how_short
d856 2
a857 2
#define ASM_C		mtable[machine].how_comment
#define ASM_JUMP	mtable[machine].how_jump
d861 2
a862 2
#define ASM_RVA_BEFORE	rvabefore(machine)
#define ASM_RVA_AFTER	rvaafter(machine)
d876 2
a877 1
process_def_file (const char *name)
d914 2
a915 1
yyerror (const char * err ATTRIBUTE_UNUSED)
d924 7
a930 2
def_exports (const char *name, const char *internal_name, int ordinal,
	     int noname, int constant, int data, int private)
a938 1
  p->private = private;
d952 3
a954 1
def_name (const char *name, int base)
d971 3
a973 1
def_library (const char *name, int base)
d989 2
a990 1
def_description (const char *desc)
d999 2
a1000 1
new_directive (char *dir)
d1009 3
a1011 1
def_heapsize (int reserve, int commit)
d1022 3
a1024 1
def_stacksize (int reserve, int commit)
d1038 4
a1041 1
append_import (const char *symbol_name, const char *dll_name, int func_ordinal)
d1105 6
a1110 2
def_import (const char *app_name, const char *module, const char *dllext,
	    const char *entry, int ord_val)
d1136 3
a1138 1
def_version (int major, int minor)
d1144 3
a1146 1
def_section (const char *name, int attr)
d1166 2
a1167 1
def_code (int attr)
d1174 2
a1175 1
def_data (int attr)
d1183 3
a1185 1
run (const char *what, char *args)
d1256 2
a1257 1
scan_drectve_symbols (bfd *abfd)
d1313 1
a1313 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0);
d1322 1
a1322 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0);
d1335 5
a1339 2
scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,
		       unsigned int size)
d1364 1
a1364 1
		   ! (sym->flags & BSF_FUNCTION), 0);
d1373 1
a1373 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0);
d1381 2
a1382 1
add_excludes (const char *new_excludes)
d1415 2
a1416 1
match_exclude (const char *string)
d1437 5
a1441 1
filter_symbols (bfd *abfd, void *minisyms, long symcount, unsigned int size)
d1459 1
a1459 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const void *) from, store);
d1485 2
a1486 1
scan_all_symbols (bfd *abfd)
d1489 1
a1489 1
  void *minisyms;
d1528 2
a1529 1
scan_open_obj_file (bfd *abfd)
d1543 2
a1544 1
scan_obj_file (const char *filename)
d1587 2
a1588 1
dump_def_info (FILE *f)
d1598 1
a1598 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s\n",
a1604 1
	       exp->private ? "PRIVATE " : "",
d1613 3
a1615 1
sfunc (const void *a, const void *b)
d1621 5
a1625 1
flush_page (FILE *f, long *need, int page_addr, int on_page)
d1655 1
a1655 1
gen_def_file (void)
d1675 1
a1675 1
	  fprintf (output_def,";\t%s\n", res);
d1681 2
a1682 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s\n",
a1687 1
		   exp->private ? "PRIVATE " : "",
d1692 1
a1692 1
	  char * quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1694 1
a1694 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s\n",
a1702 1
		   exp->private ? "PRIVATE " : "",
d1715 2
a1716 1
generate_idata_ofile (FILE *filvar)
d1808 3
a1810 1
assemble_file (const char * source, const char * dest)
d1823 1
a1823 1
gen_exp_file (void)
d1930 2
a1931 2
	{
	  if (!exp->noname || show_allnames)
d1934 4
a1937 4
	  if (exp->forward != 0)
	    fprintf (f, "f%d:	%s	\"%s\"\n",
		     exp->forward, ASM_TEXT, exp->internal_name);
	}
d2032 1
a2032 1
	  /* Delete duplicates */
d2073 2
a2074 1
xlate (const char *name)
d2104 3
a2106 1
dump_iat (FILE *f, export_type *exp)
d2236 3
a2238 1
make_label (const char *prefix, const char *name)
d2250 3
a2252 1
make_imp_label (const char *prefix, const char *name)
d2276 3
a2278 1
make_one_lib_file (export_type *exp, int i)
d2351 1
a2351 1
      char *     outname = xmalloc (strlen (TMP_STUB) + 10);
d2462 1
a2462 1
      /* The symbol referring to the code (.text).  */
d2743 1
a2743 1
make_head (void)
d2802 1
a2802 1
make_tail (void)
d2860 1
a2860 1
gen_lib_file (void)
d2892 1
a2892 5
      bfd *n;
      /* Don't add PRIVATE entries to import lib.  */
      if (exp->private)
	continue;
      n = make_one_lib_file (exp, i);
d2928 2
a2929 2
      name = (char *) alloca (strlen (TMP_STUB) + 10);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
a2930 3
	  /* Don't delete non-existent stubs for PRIVATE entries.  */
          if (exp->private)
	    continue;
d2941 2
a2944 1

d2946 3
a2948 1
pfunc (const void *a, const void *b)
d2964 3
a2966 1
nfunc (const void *a, const void *b)
d2975 2
a2976 1
remove_null_names (export_type **ptr)
d2993 6
a2998 1
dtab (export_type **ptr ATTRIBUTE_UNUSED)
d3019 2
a3020 1
process_duplicates (export_type **d_export_vec)
d3027 1
d3038 1
d3068 1
d3071 4
a3074 2
    if (!d_export_vec[i]->noname)
      d_named_nfuncs++;
d3078 2
a3079 1
fill_ordinals (export_type **d_export_vec)
d3114 1
a3114 1
	  int j;
d3153 3
a3155 1
alphafunc (const void *av, const void *bv)
d3164 1
a3164 1
mangle_defs (void)
d3171 2
a3172 1
  export_type **d_export_vec = xmalloc (sizeof (export_type *) * d_nfuncs);
d3209 2
d3212 3
a3214 1
usage (FILE *file, int status)
a3240 1
  fprintf (file, _("   -t --temp-prefix <prefix> Use <prefix> to construct temp file names.\n"));
d3270 1
a3270 1
  {"def", required_argument, NULL, 'd'}, /* for compatibility with older versions */
d3289 1
a3289 1
int main (int, char **);
d3292 3
a3294 1
main (int ac, char **av)
d3350 1
a3350 1
	  /* Ignored for compatibility.  */
a3423 3
  if (!tmp_prefix)
    tmp_prefix = prefix_encode ("d", getpid ());

d3502 4
a3505 1
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
d3571 2
a3572 1
deduce_name (const char *prog_name)
@


