head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.14
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.42
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.40
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.36
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.34
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.32
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.30
	OPENBSD_5_0:1.11.0.28
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	new-binutils:1.5.0.4
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.11;
commitid	dbwlUkpK0xDlII16;

1.11
date	2004.11.02.20.45.18;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.09.22.29.30;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.12.22.41.58;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.19.11.32;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.09.14.14.20.11;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.03.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.48.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.52;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.52;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.54;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.49.53;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.31;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.16.19;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.07;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.06.18;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.15.49;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.04;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* objdump.c -- dump information about an object file.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Objdump overview.

   Objdump displays information about one or more object files, either on
   their own, or inside libraries.  It is commonly used as a disassembler,
   but it can also display information about file headers, symbol tables,
   relocations, debugging directives and more.

   The flow of execution is as follows:
 
   1. Command line arguments are checked for control switches and the
      information to be displayed is selected.
      
   2. Any remaining arguments are assumed to be object files, and they are
      processed in order by display_bfd().  If the file is an archive each
      of its elements is processed in turn.
      
   3. The file's target architecture and binary file format are determined
      by bfd_check_format().  If they are recognised, then dump_bfd() is
      called.

   4. dump_bfd() in turn calls separate functions to display the requested
      item(s) of information(s).  For example disassemble_data() is called if
      a disassembly has been requested.

   When disassembling the code loops through blocks of instructions bounded
   by symbols, calling disassemble_bytes() on each block.  The actual
   disassembling is done by the libopcodes library, via a function pointer
   supplied by the disassembler() function.  */

#include "bfd.h"
#include "bfdver.h"
#include "progress.h"
#include "bucomm.h"
#include "budemang.h"
#include "getopt.h"
#include "safe-ctype.h"
#include "dis-asm.h"
#include "libiberty.h"
#include "demangle.h"
#include "debug.h"
#include "budbg.h"

/* Internal headers for the ELF .stab-dump code - sorry.  */
#define	BYTES_IN_WORD	32
#include "aout/aout64.h"

#ifdef NEED_DECLARATION_FPRINTF
/* This is needed by init_disassemble_info().  */
extern int fprintf (FILE *, const char *, ...);
#endif

/* Exit status.  */
static int exit_status = 0;

static char *default_target = NULL;	/* Default at runtime.  */

/* The following variables are set based on arguments passed on the
   command line.  */
static int show_version = 0;		/* Show the version number.  */
static int dump_section_contents;	/* -s */
static int dump_section_headers;	/* -h */
static bfd_boolean dump_file_header;	/* -f */
static int dump_symtab;			/* -t */
static int dump_dynamic_symtab;		/* -T */
static int dump_reloc_info;		/* -r */
static int dump_dynamic_reloc_info;	/* -R */
static int dump_ar_hdrs;		/* -a */
static int dump_private_headers;	/* -p */
static int prefix_addresses;		/* --prefix-addresses */
static int with_line_numbers;		/* -l */
static bfd_boolean with_source_code;	/* -S */
static int show_raw_insn;		/* --show-raw-insn */
static int dump_stab_section_info;	/* --stabs */
static int do_demangle;			/* -C, --demangle */
static bfd_boolean disassemble;		/* -d */
static bfd_boolean disassemble_all;	/* -D */
static int disassemble_zeroes;		/* --disassemble-zeroes */
static bfd_boolean formats_info;	/* -i */
static int wide_output;			/* -w */
static bfd_vma start_address = (bfd_vma) -1; /* --start-address */
static bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
static int dump_debugging;		/* --debugging */
static int dump_debugging_tags;		/* --debugging-tags */
static bfd_vma adjust_section_vma = 0;	/* --adjust-vma */
static int file_start_context = 0;      /* --file-start-context */

/* Pointer to an array of section names provided by
   one or more "-j secname" command line options.  */
static char **only;
/* The total number of slots in the only[] array.  */
static size_t only_size = 0;
/* The number of occupied slots in the only[] array.  */
static size_t only_used = 0;

/* Variables for handling include file path table.  */
static const char **include_paths;
static int include_path_count;

/* Extra info to pass to the section disassembler and address printing
   function.  */
struct objdump_disasm_info
{
  bfd *              abfd;
  asection *         sec;
  bfd_boolean        require_sec;
  arelent **         dynrelbuf;
  long               dynrelcount;
  disassembler_ftype disassemble_fn;
};

/* Architecture to disassemble for, or default if NULL.  */
static char *machine = NULL;

/* Target specific options to the disassembler.  */
static char *disassembler_options = NULL;

/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
static enum bfd_endian endian = BFD_ENDIAN_UNKNOWN;

/* The symbol table.  */
static asymbol **syms;

/* Number of symbols in `syms'.  */
static long symcount = 0;

/* The sorted symbol table.  */
static asymbol **sorted_syms;

/* Number of symbols in `sorted_syms'.  */
static long sorted_symcount = 0;

/* The dynamic symbol table.  */
static asymbol **dynsyms;

/* Number of symbols in `dynsyms'.  */
static long dynsymcount = 0;

static bfd_byte *stabs;
static bfd_size_type stab_size;

static char *strtab;
static bfd_size_type stabstr_size;

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s <option(s)> <file(s)>\n"), program_name);
  fprintf (stream, _(" Display information from object <file(s)>.\n"));
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
  fprintf (stream, _("\
  -a, --archive-headers    Display archive header information\n\
  -f, --file-headers       Display the contents of the overall file header\n\
  -p, --private-headers    Display object format specific file header contents\n\
  -h, --[section-]headers  Display the contents of the section headers\n\
  -x, --all-headers        Display the contents of all headers\n\
  -d, --disassemble        Display assembler contents of executable sections\n\
  -D, --disassemble-all    Display assembler contents of all sections\n\
  -S, --source             Intermix source code with disassembly\n\
  -s, --full-contents      Display the full contents of all sections requested\n\
  -g, --debugging          Display debug information in object file\n\
  -e, --debugging-tags     Display debug information using ctags style\n\
  -G, --stabs              Display (in raw form) any STABS info in the file\n\
  -t, --syms               Display the contents of the symbol table(s)\n\
  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r, --reloc              Display the relocation entries in the file\n\
  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -v, --version            Display this program's version number\n\
  -i, --info               List object formats and architectures supported\n\
  -H, --help               Display this information\n\
"));
  if (status != 2)
    {
      fprintf (stream, _("\n The following switches are optional:\n"));
      fprintf (stream, _("\
  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\
  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\
  -j, --section=NAME             Only display information for section NAME\n\
  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\
  -EB --endian=big               Assume big endian format when disassembling\n\
  -EL --endian=little            Assume little endian format when disassembling\n\
      --file-start-context       Include context from start of file (with -S)\n\
  -I, --include=DIR              Add DIR to search list for source files\n\
  -l, --line-numbers             Include line numbers and filenames in output\n\
  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\
                                  The STYLE, if specified, can be `auto', `gnu',\n\
                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                                  or `gnat'\n\
  -w, --wide                     Format output for more than 80 columns\n\
  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address=ADDR       Only process data whose address is >= ADDR\n\
      --stop-address=ADDR        Only process data whose address is <= ADDR\n\
      --prefix-addresses         Print complete address alongside disassembly\n\
      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n\
      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\
\n"));
      list_supported_targets (program_name, stream);
      list_supported_architectures (program_name, stream);

      disassembler_usage (stream);
    }
  if (status == 0)
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
  exit (status);
}

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
enum option_values
  {
    OPTION_ENDIAN=150,
    OPTION_START_ADDRESS,
    OPTION_STOP_ADDRESS,
    OPTION_ADJUST_VMA
  };

static struct option long_options[]=
{
  {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
  {"all-headers", no_argument, NULL, 'x'},
  {"private-headers", no_argument, NULL, 'p'},
  {"architecture", required_argument, NULL, 'm'},
  {"archive-headers", no_argument, NULL, 'a'},
  {"debugging", no_argument, NULL, 'g'},
  {"debugging-tags", no_argument, NULL, 'e'},
  {"demangle", optional_argument, NULL, 'C'},
  {"disassemble", no_argument, NULL, 'd'},
  {"disassemble-all", no_argument, NULL, 'D'},
  {"disassembler-options", required_argument, NULL, 'M'},
  {"disassemble-zeroes", no_argument, NULL, 'z'},
  {"dynamic-reloc", no_argument, NULL, 'R'},
  {"dynamic-syms", no_argument, NULL, 'T'},
  {"endian", required_argument, NULL, OPTION_ENDIAN},
  {"file-headers", no_argument, NULL, 'f'},
  {"file-start-context", no_argument, &file_start_context, 1},
  {"full-contents", no_argument, NULL, 's'},
  {"headers", no_argument, NULL, 'h'},
  {"help", no_argument, NULL, 'H'},
  {"info", no_argument, NULL, 'i'},
  {"line-numbers", no_argument, NULL, 'l'},
  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
  {"prefix-addresses", no_argument, &prefix_addresses, 1},
  {"reloc", no_argument, NULL, 'r'},
  {"section", required_argument, NULL, 'j'},
  {"section-headers", no_argument, NULL, 'h'},
  {"show-raw-insn", no_argument, &show_raw_insn, 1},
  {"source", no_argument, NULL, 'S'},
  {"include", required_argument, NULL, 'I'},
  {"stabs", no_argument, NULL, 'G'},
  {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
  {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
  {"syms", no_argument, NULL, 't'},
  {"target", required_argument, NULL, 'b'},
  {"version", no_argument, NULL, 'V'},
  {"wide", no_argument, NULL, 'w'},
  {0, no_argument, 0, 0}
};

static void
nonfatal (const char *msg)
{
  bfd_nonfatal (msg);
  exit_status = 1;
}

static void
dump_section_header (bfd *abfd ATTRIBUTE_UNUSED, asection *section,
		     void *ignored ATTRIBUTE_UNUSED)
{
  char *comma = "";
  unsigned int opb = bfd_octets_per_byte (abfd);

  printf ("%3d %-13s %08lx  ", section->index,
	  bfd_get_section_name (abfd, section),
	  (unsigned long) bfd_section_size (abfd, section) / opb);
  bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));
  printf ("  ");
  bfd_printf_vma (abfd, section->lma);
  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
	  bfd_get_section_alignment (abfd, section));
  if (! wide_output)
    printf ("\n                ");
  printf ("  ");

#define PF(x, y) \
  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }

  PF (SEC_HAS_CONTENTS, "CONTENTS");
  PF (SEC_ALLOC, "ALLOC");
  PF (SEC_CONSTRUCTOR, "CONSTRUCTOR");
  PF (SEC_LOAD, "LOAD");
  PF (SEC_RELOC, "RELOC");
  PF (SEC_READONLY, "READONLY");
  PF (SEC_CODE, "CODE");
  PF (SEC_DATA, "DATA");
  PF (SEC_ROM, "ROM");
  PF (SEC_DEBUGGING, "DEBUGGING");
  PF (SEC_NEVER_LOAD, "NEVER_LOAD");
  PF (SEC_EXCLUDE, "EXCLUDE");
  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");
  PF (SEC_BLOCK, "BLOCK");
  PF (SEC_CLINK, "CLINK");
  PF (SEC_SMALL_DATA, "SMALL_DATA");
  PF (SEC_SHARED, "SHARED");
  PF (SEC_ARCH_BIT_0, "ARCH_BIT_0");
  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");

  if ((section->flags & SEC_LINK_ONCE) != 0)
    {
      const char *ls;

      switch (section->flags & SEC_LINK_DUPLICATES)
	{
	default:
	  abort ();
	case SEC_LINK_DUPLICATES_DISCARD:
	  ls = "LINK_ONCE_DISCARD";
	  break;
	case SEC_LINK_DUPLICATES_ONE_ONLY:
	  ls = "LINK_ONCE_ONE_ONLY";
	  break;
	case SEC_LINK_DUPLICATES_SAME_SIZE:
	  ls = "LINK_ONCE_SAME_SIZE";
	  break;
	case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	  ls = "LINK_ONCE_SAME_CONTENTS";
	  break;
	}
      printf ("%s%s", comma, ls);

      if (section->comdat != NULL)
	printf (" (COMDAT %s %ld)", section->comdat->name,
		section->comdat->symbol);

      comma = ", ";
    }

  printf ("\n");
#undef PF
}

static void
dump_headers (bfd *abfd)
{
  printf (_("Sections:\n"));

#ifndef BFD64
  printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
#else
  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
  if (bfd_get_arch_size (abfd) == 32)
    printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
  else
    printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
#endif

  if (wide_output)
    printf (_("  Flags"));
  if (abfd->flags & HAS_LOAD_PAGE)
    printf (_("  Pg"));
  printf ("\n");

  bfd_map_over_sections (abfd, dump_section_header, NULL);
}

static asymbol **
slurp_symtab (bfd *abfd)
{
  asymbol **sy = NULL;
  long storage;

  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      symcount = 0;
      return NULL;
    }

  storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    bfd_fatal (bfd_get_filename (abfd));
  if (storage)
    sy = xmalloc (storage);

  symcount = bfd_canonicalize_symtab (abfd, sy);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  return sy;
}

/* Read in the dynamic symbols.  */

static asymbol **
slurp_dynamic_symtab (bfd *abfd)
{
  asymbol **sy = NULL;
  long storage;

  storage = bfd_get_dynamic_symtab_upper_bound (abfd);
  if (storage < 0)
    {
      if (!(bfd_get_file_flags (abfd) & DYNAMIC))
	{
	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
	  dynsymcount = 0;
	  return NULL;
	}

      bfd_fatal (bfd_get_filename (abfd));
    }
  if (storage)
    sy = xmalloc (storage);

  dynsymcount = bfd_canonicalize_dynamic_symtab (abfd, sy);
  if (dynsymcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  return sy;
}

/* Filter out (in place) symbols that are useless for disassembly.
   COUNT is the number of elements in SYMBOLS.
   Return the number of useful symbols.  */

static long
remove_useless_symbols (asymbol **symbols, long count)
{
  asymbol **in_ptr = symbols, **out_ptr = symbols;

  while (--count >= 0)
    {
      asymbol *sym = *in_ptr++;

      if (sym->name == NULL || sym->name[0] == '\0')
	continue;
      if (sym->flags & (BSF_DEBUGGING))
	continue;
      if (bfd_is_und_section (sym->section)
	  || bfd_is_com_section (sym->section))
	continue;

      *out_ptr++ = sym;
    }
  return out_ptr - symbols;
}

/* Sort symbols into value order.  */

static int
compare_symbols (const void *ap, const void *bp)
{
  const asymbol *a = * (const asymbol **) ap;
  const asymbol *b = * (const asymbol **) bp;
  const char *an;
  const char *bn;
  size_t anl;
  size_t bnl;
  bfd_boolean af;
  bfd_boolean bf;
  flagword aflags;
  flagword bflags;

  if (bfd_asymbol_value (a) > bfd_asymbol_value (b))
    return 1;
  else if (bfd_asymbol_value (a) < bfd_asymbol_value (b))
    return -1;

  if (a->section > b->section)
    return 1;
  else if (a->section < b->section)
    return -1;

  an = bfd_asymbol_name (a);
  bn = bfd_asymbol_name (b);
  anl = strlen (an);
  bnl = strlen (bn);

  /* The symbols gnu_compiled and gcc2_compiled convey no real
     information, so put them after other symbols with the same value.  */
  af = (strstr (an, "gnu_compiled") != NULL
	|| strstr (an, "gcc2_compiled") != NULL);
  bf = (strstr (bn, "gnu_compiled") != NULL
	|| strstr (bn, "gcc2_compiled") != NULL);

  if (af && ! bf)
    return 1;
  if (! af && bf)
    return -1;

  /* We use a heuristic for the file name, to try to sort it after
     more useful symbols.  It may not work on non Unix systems, but it
     doesn't really matter; the only difference is precisely which
     symbol names get printed.  */

#define file_symbol(s, sn, snl)			\
  (((s)->flags & BSF_FILE) != 0			\
   || ((sn)[(snl) - 2] == '.'			\
       && ((sn)[(snl) - 1] == 'o'		\
	   || (sn)[(snl) - 1] == 'a')))

  af = file_symbol (a, an, anl);
  bf = file_symbol (b, bn, bnl);

  if (af && ! bf)
    return 1;
  if (! af && bf)
    return -1;

  /* Try to sort global symbols before local symbols before function
     symbols before debugging symbols.  */

  aflags = a->flags;
  bflags = b->flags;

  if ((aflags & BSF_DEBUGGING) != (bflags & BSF_DEBUGGING))
    {
      if ((aflags & BSF_DEBUGGING) != 0)
	return 1;
      else
	return -1;
    }
  if ((aflags & BSF_FUNCTION) != (bflags & BSF_FUNCTION))
    {
      if ((aflags & BSF_FUNCTION) != 0)
	return -1;
      else
	return 1;
    }
  if ((aflags & BSF_LOCAL) != (bflags & BSF_LOCAL))
    {
      if ((aflags & BSF_LOCAL) != 0)
	return 1;
      else
	return -1;
    }
  if ((aflags & BSF_GLOBAL) != (bflags & BSF_GLOBAL))
    {
      if ((aflags & BSF_GLOBAL) != 0)
	return -1;
      else
	return 1;
    }

  /* Symbols that start with '.' might be section names, so sort them
     after symbols that don't start with '.'.  */
  if (an[0] == '.' && bn[0] != '.')
    return 1;
  if (an[0] != '.' && bn[0] == '.')
    return -1;

  /* Finally, if we can't distinguish them in any other way, try to
     get consistent results by sorting the symbols by name.  */
  return strcmp (an, bn);
}

/* Sort relocs into address order.  */

static int
compare_relocs (const void *ap, const void *bp)
{
  const arelent *a = * (const arelent **) ap;
  const arelent *b = * (const arelent **) bp;

  if (a->address > b->address)
    return 1;
  else if (a->address < b->address)
    return -1;

  /* So that associated relocations tied to the same address show up
     in the correct order, we don't do any further sorting.  */
  if (a > b)
    return 1;
  else if (a < b)
    return -1;
  else
    return 0;
}

/* Print an address (VMA) to the output stream in INFO.
   If SKIP_ZEROES is TRUE, omit leading zeroes.  */

static void
objdump_print_value (bfd_vma vma, struct disassemble_info *info,
		     bfd_boolean skip_zeroes)
{
  char buf[30];
  char *p;
  struct objdump_disasm_info *aux;

  aux = (struct objdump_disasm_info *) info->application_data;
  bfd_sprintf_vma (aux->abfd, buf, vma);
  if (! skip_zeroes)
    p = buf;
  else
    {
      for (p = buf; *p == '0'; ++p)
	;
      if (*p == '\0')
	--p;
    }
  (*info->fprintf_func) (info->stream, "%s", p);
}

/* Print the name of a symbol.  */

static void
objdump_print_symname (bfd *abfd, struct disassemble_info *info,
		       asymbol *sym)
{
  char *alloc;
  const char *name;

  alloc = NULL;
  name = bfd_asymbol_name (sym);
  if (do_demangle && name[0] != '\0')
    {
      /* Demangle the name.  */
      alloc = demangle (abfd, name);
      name = alloc;
    }

  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", name);
  else
    printf ("%s", name);

  if (alloc != NULL)
    free (alloc);
}

/* Locate a symbol given a bfd and a section (from INFO->application_data),
   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
   require the symbol to be in the section.  Returns NULL if there is no
   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
   of the symbol in sorted_syms.  */

static asymbol *
find_symbol_for_address (bfd_vma vma,
			 struct disassemble_info *info,
			 long *place)
{
  /* @@@@ Would it speed things up to cache the last two symbols returned,
     and maybe their address ranges?  For many processors, only one memory
     operand can be present at a time, so the 2-entry cache wouldn't be
     constantly churned by code doing heavy memory accesses.  */

  /* Indices in `sorted_syms'.  */
  long min = 0;
  long max = sorted_symcount;
  long thisplace;
  struct objdump_disasm_info *aux;
  bfd *abfd;
  asection *sec;
  unsigned int opb;

  if (sorted_symcount < 1)
    return NULL;

  aux = (struct objdump_disasm_info *) info->application_data;
  abfd = aux->abfd;
  sec = aux->sec;
  opb = bfd_octets_per_byte (abfd);

  /* Perform a binary search looking for the closest symbol to the
     required value.  We are searching the range (min, max].  */
  while (min + 1 < max)
    {
      asymbol *sym;

      thisplace = (max + min) / 2;
      sym = sorted_syms[thisplace];

      if (bfd_asymbol_value (sym) > vma)
	max = thisplace;
      else if (bfd_asymbol_value (sym) < vma)
	min = thisplace;
      else
	{
	  min = thisplace;
	  break;
	}
    }

  /* The symbol we want is now in min, the low end of the range we
     were searching.  If there are several symbols with the same
     value, we want the first one.  */
  thisplace = min;
  while (thisplace > 0
	 && (bfd_asymbol_value (sorted_syms[thisplace])
	     == bfd_asymbol_value (sorted_syms[thisplace - 1])))
    --thisplace;

  /* If the file is relocatable, and the symbol could be from this
     section, prefer a symbol from this section over symbols from
     others, even if the other symbol's value might be closer.

     Note that this may be wrong for some symbol references if the
     sections have overlapping memory ranges, but in that case there's
     no way to tell what's desired without looking at the relocation
     table.  */
  if (sorted_syms[thisplace]->section != sec
      && (aux->require_sec
	  || ((abfd->flags & HAS_RELOC) != 0
	      && vma >= bfd_get_section_vma (abfd, sec)
	      && vma < (bfd_get_section_vma (abfd, sec)
			+ bfd_section_size (abfd, sec) / opb))))
    {
      long i;

      for (i = thisplace + 1; i < sorted_symcount; i++)
	{
	  if (bfd_asymbol_value (sorted_syms[i])
	      != bfd_asymbol_value (sorted_syms[thisplace]))
	    break;
	}

      --i;

      for (; i >= 0; i--)
	{
	  if (sorted_syms[i]->section == sec
	      && (i == 0
		  || sorted_syms[i - 1]->section != sec
		  || (bfd_asymbol_value (sorted_syms[i])
		      != bfd_asymbol_value (sorted_syms[i - 1]))))
	    {
	      thisplace = i;
	      break;
	    }
	}

      if (sorted_syms[thisplace]->section != sec)
	{
	  /* We didn't find a good symbol with a smaller value.
	     Look for one with a larger value.  */
	  for (i = thisplace + 1; i < sorted_symcount; i++)
	    {
	      if (sorted_syms[i]->section == sec)
		{
		  thisplace = i;
		  break;
		}
	    }
	}

      if (sorted_syms[thisplace]->section != sec
	  && (aux->require_sec
	      || ((abfd->flags & HAS_RELOC) != 0
		  && vma >= bfd_get_section_vma (abfd, sec)
		  && vma < (bfd_get_section_vma (abfd, sec)
			    + bfd_section_size (abfd, sec)))))
	/* There is no suitable symbol.  */
	return NULL;
    }

  /* Give the target a chance to reject the symbol.  */
  while (! info->symbol_is_valid (sorted_syms [thisplace], info))
    {
      ++ thisplace;
      if (thisplace >= sorted_symcount
	  || bfd_asymbol_value (sorted_syms [thisplace]) > vma)
	return NULL;
    }

  if (place != NULL)
    *place = thisplace;

  return sorted_syms[thisplace];
}

/* Print an address and the offset to the nearest symbol.  */

static void
objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,
			     bfd_vma vma, struct disassemble_info *info,
			     bfd_boolean skip_zeroes)
{
  objdump_print_value (vma, info, skip_zeroes);

  if (sym == NULL)
    {
      bfd_vma secaddr;

      (*info->fprintf_func) (info->stream, " <%s",
			     bfd_get_section_name (abfd, sec));
      secaddr = bfd_get_section_vma (abfd, sec);
      if (vma < secaddr)
	{
	  (*info->fprintf_func) (info->stream, "-0x");
	  objdump_print_value (secaddr - vma, info, TRUE);
	}
      else if (vma > secaddr)
	{
	  (*info->fprintf_func) (info->stream, "+0x");
	  objdump_print_value (vma - secaddr, info, TRUE);
	}
      (*info->fprintf_func) (info->stream, ">");
    }
  else
    {
      (*info->fprintf_func) (info->stream, " <");
      objdump_print_symname (abfd, info, sym);
      if (bfd_asymbol_value (sym) > vma)
	{
	  (*info->fprintf_func) (info->stream, "-0x");
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, TRUE);
	}
      else if (vma > bfd_asymbol_value (sym))
	{
	  (*info->fprintf_func) (info->stream, "+0x");
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, TRUE);
	}
      (*info->fprintf_func) (info->stream, ">");
    }
}

/* Print an address (VMA), symbolically if possible.
   If SKIP_ZEROES is TRUE, don't output leading zeroes.  */

static void
objdump_print_addr (bfd_vma vma,
		    struct disassemble_info *info,
		    bfd_boolean skip_zeroes)
{
  struct objdump_disasm_info *aux;
  asymbol *sym;

  if (sorted_symcount < 1)
    {
      (*info->fprintf_func) (info->stream, "0x");
      objdump_print_value (vma, info, skip_zeroes);
      return;
    }

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (vma, info, NULL);
  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, info,
			       skip_zeroes);
}

/* Print VMA to INFO.  This function is passed to the disassembler
   routine.  */

static void
objdump_print_address (bfd_vma vma, struct disassemble_info *info)
{
  objdump_print_addr (vma, info, ! prefix_addresses);
}

/* Determine of the given address has a symbol associated with it.  */

static int
objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * info)
{
  asymbol * sym;

  sym = find_symbol_for_address (vma, info, NULL);

  return (sym != NULL && (bfd_asymbol_value (sym) == vma));
}

/* Hold the last function name and the last line number we displayed
   in a disassembly.  */

static char *prev_functionname;
static unsigned int prev_line;

/* We keep a list of all files that we have seen when doing a
   disassembly with source, so that we know how much of the file to
   display.  This can be important for inlined functions.  */

struct print_file_list
{
  struct print_file_list *next;
  const char *filename;
  const char *modname;
  unsigned int line;
  FILE *f;
};

static struct print_file_list *print_files;

/* The number of preceding context lines to show when we start
   displaying a file for the first time.  */

#define SHOW_PRECEDING_CONTEXT_LINES (5)

/* Tries to open MODNAME, and if successful adds a node to print_files
   linked list and returns that node.  Returns NULL on failure.  */

static struct print_file_list *
try_print_file_open (const char *origname, const char *modname)
{
  struct print_file_list *p;
  FILE *f;

  f = fopen (modname, "r");
  if (f == NULL)
    return NULL;

  if (print_files != NULL && print_files->f != NULL)
    {
      fclose (print_files->f);
      print_files->f = NULL;
    }

  p = xmalloc (sizeof (struct print_file_list));
  p->filename = origname;
  p->modname = modname;
  p->line = 0;
  p->f = f;
  p->next = print_files;
  print_files = p;
  return p;
}

/* If the the source file, as described in the symtab, is not found
   try to locate it in one of the paths specified with -I
   If found, add location to print_files linked list.  */

static struct print_file_list *
update_source_path (const char *filename)
{
  struct print_file_list *p;
  const char *fname;
  int i;

  if (filename == NULL)
    return NULL;

  p = try_print_file_open (filename, filename);
  if (p != NULL)
    return p;

  if (include_path_count == 0)
    return NULL;

  /* Get the name of the file.  */
  fname = strrchr (filename, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have a mixed forward/back slash case.  */
    char *backslash = strrchr (filename, '\\');
    if (fname == NULL || (backslash != NULL && backslash > fname))
      fname = backslash;
    if (fname == NULL && filename[0] != '\0' && filename[1] == ':')
      fname = filename + 1;
  }
#endif
  if (fname == NULL)
    fname = filename;
  else
    ++fname;

  /* If file exists under a new path, we need to add it to the list
     so that show_line knows about it.  */
  for (i = 0; i < include_path_count; i++)
    {
      char *modname = concat (include_paths[i], "/", fname, (const char *) 0);

      p = try_print_file_open (filename, modname);
      if (p)
	return p;

      free (modname);
    }

  return NULL;
}

/* Skip ahead to a given line in a file, optionally printing each
   line.  */

static void
skip_to_line (struct print_file_list *p, unsigned int line,
	      bfd_boolean show)
{
  while (p->line < line)
    {
      char buf[100];

      if (fgets (buf, sizeof buf, p->f) == NULL)
	{
	  fclose (p->f);
	  p->f = NULL;
	  break;
	}

      if (show)
	printf ("%s", buf);

      if (strchr (buf, '\n') != NULL)
	++p->line;
    }
}

/* Show the line number, or the source line, in a disassembly
   listing.  */

static void
show_line (bfd *abfd, asection *section, bfd_vma addr_offset)
{
  const char *filename;
  const char *functionname;
  unsigned int line;

  if (! with_line_numbers && ! with_source_code)
    return;

  if (! bfd_find_nearest_line (abfd, section, syms, addr_offset, &filename,
			       &functionname, &line))
    return;

  if (filename != NULL && *filename == '\0')
    filename = NULL;
  if (functionname != NULL && *functionname == '\0')
    functionname = NULL;

  if (with_line_numbers)
    {
      if (functionname != NULL
	  && (prev_functionname == NULL
	      || strcmp (functionname, prev_functionname) != 0))
	printf ("%s():\n", functionname);
      if (line > 0 && line != prev_line)
	printf ("%s:%u\n", filename == NULL ? "???" : filename, line);
    }

  if (with_source_code
      && filename != NULL
      && line > 0)
    {
      struct print_file_list **pp, *p;

      for (pp = &print_files; *pp != NULL; pp = &(*pp)->next)
	if (strcmp ((*pp)->filename, filename) == 0)
	  break;
      p = *pp;

      if (p != NULL)
	{
	  if (p != print_files)
	    {
	      int l;

	      /* We have reencountered a file name which we saw
		 earlier.  This implies that either we are dumping out
		 code from an included file, or the same file was
		 linked in more than once.  There are two common cases
		 of an included file: inline functions in a header
		 file, and a bison or flex skeleton file.  In the
		 former case we want to just start printing (but we
		 back up a few lines to give context); in the latter
		 case we want to continue from where we left off.  I
		 can't think of a good way to distinguish the cases,
		 so I used a heuristic based on the file name.  */
	      if (strcmp (p->filename + strlen (p->filename) - 2, ".h") != 0)
		l = p->line;
	      else
		{
		  l = line - SHOW_PRECEDING_CONTEXT_LINES;
		  if (l < 0)
		    l = 0;
		}

	      if (p->f == NULL)
		{
		  p->f = fopen (p->modname, "r");
		  p->line = 0;
		}
	      if (p->f != NULL)
		skip_to_line (p, l, FALSE);

	      if (print_files->f != NULL)
		{
		  fclose (print_files->f);
		  print_files->f = NULL;
		}
	    }

	  if (p->f != NULL)
	    {
	      skip_to_line (p, line, TRUE);
	      *pp = p->next;
	      p->next = print_files;
	      print_files = p;
	    }
	}
      else
	{
	  p = update_source_path (filename);

	  if (p != NULL)
	    {
	      int l;

	      if (file_start_context)
		l = 0;
	      else
		l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l < 0)
		l = 0;
	      skip_to_line (p, l, FALSE);
	      if (p->f != NULL)
		skip_to_line (p, line, TRUE);
	    }
	}
    }

  if (functionname != NULL
      && (prev_functionname == NULL
	  || strcmp (functionname, prev_functionname) != 0))
    {
      if (prev_functionname != NULL)
	free (prev_functionname);
      prev_functionname = xmalloc (strlen (functionname) + 1);
      strcpy (prev_functionname, functionname);
    }

  if (line > 0 && line != prev_line)
    prev_line = line;
}

/* Pseudo FILE object for strings.  */
typedef struct
{
  char *buffer;
  size_t size;
  char *current;
} SFILE;

/* sprintf to a "stream".  */

static int
objdump_sprintf (SFILE *f, const char *format, ...)
{
  char *buf;
  size_t n;
  va_list args;

  va_start (args, format);

  vasprintf (&buf, format, args);

  if (buf == NULL)
    {
      va_end (args);
      fatal (_("Out of virtual memory"));
    }

  n = strlen (buf);

  while ((size_t) ((f->buffer + f->size) - f->current) < n + 1)
    {
      size_t curroff;

      curroff = f->current - f->buffer;
      f->size *= 2;
      f->buffer = xrealloc (f->buffer, f->size);
      f->current = f->buffer + curroff;
    }

  memcpy (f->current, buf, n);
  f->current += n;
  f->current[0] = '\0';

  free (buf);

  va_end (args);
  return n;
}

/* Returns TRUE if the specified section should be dumped.  */

static bfd_boolean
process_section_p (asection * section)
{
  size_t i;

  if (only == NULL)
    return TRUE;

  for (i = 0; i < only_used; i++)
    if (strcmp (only [i], section->name) == 0)
      return TRUE;

  return FALSE;
}


/* The number of zeroes we want to see before we start skipping them.
   The number is arbitrarily chosen.  */

#ifndef SKIP_ZEROES
#define SKIP_ZEROES (8)
#endif

/* The number of zeroes to skip at the end of a section.  If the
   number of zeroes at the end is between SKIP_ZEROES_AT_END and
   SKIP_ZEROES, they will be disassembled.  If there are fewer than
   SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic
   attempt to avoid disassembling zeroes inserted by section
   alignment.  */

#ifndef SKIP_ZEROES_AT_END
#define SKIP_ZEROES_AT_END (3)
#endif

/* Disassemble some data in memory between given values.  */

static void
disassemble_bytes (struct disassemble_info * info,
		   disassembler_ftype        disassemble_fn,
		   bfd_boolean               insns,
		   bfd_byte *                data,
		   bfd_vma                   start_offset,
		   bfd_vma                   stop_offset,
		   bfd_vma		     rel_offset,
		   arelent ***               relppp,
		   arelent **                relppend)
{
  struct objdump_disasm_info *aux;
  asection *section;
  int octets_per_line;
  bfd_boolean done_dot;
  int skip_addr_chars;
  bfd_vma addr_offset;
  int opb = info->octets_per_byte;

  aux = (struct objdump_disasm_info *) info->application_data;
  section = aux->sec;

  if (insns)
    octets_per_line = 4;
  else
    octets_per_line = 16;

  /* Figure out how many characters to skip at the start of an
     address, to make the disassembly look nicer.  We discard leading
     zeroes in chunks of 4, ensuring that there is always a leading
     zero remaining.  */
  skip_addr_chars = 0;
  if (! prefix_addresses)
    {
      char buf[30];
      char *s;

      bfd_sprintf_vma
	(aux->abfd, buf,
	 (section->vma
	  + bfd_section_size (section->owner, section) / opb));
      s = buf;
      while (s[0] == '0' && s[1] == '0' && s[2] == '0' && s[3] == '0'
	     && s[4] == '0')
	{
	  skip_addr_chars += 4;
	  s += 4;
	}
    }

  info->insn_info_valid = 0;

  done_dot = FALSE;
  addr_offset = start_offset;
  while (addr_offset < stop_offset)
    {
      bfd_vma z;
      int octets = 0;
      bfd_boolean need_nl = FALSE;

      /* If we see more than SKIP_ZEROES octets of zeroes, we just
	 print `...'.  */
      for (z = addr_offset * opb; z < stop_offset * opb; z++)
	if (data[z] != 0)
	  break;
      if (! disassemble_zeroes
	  && (info->insn_info_valid == 0
	      || info->branch_delay_insns == 0)
	  && (z - addr_offset * opb >= SKIP_ZEROES
	      || (z == stop_offset * opb &&
		  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
	{
	  printf ("\t...\n");

	  /* If there are more nonzero octets to follow, we only skip
	     zeroes in multiples of 4, to try to avoid running over
	     the start of an instruction which happens to start with
	     zero.  */
	  if (z != stop_offset * opb)
	    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);

	  octets = z - addr_offset * opb;
	}
      else
	{
	  char buf[50];
	  SFILE sfile;
	  int bpc = 0;
	  int pb = 0;

	  done_dot = FALSE;

	  if (with_line_numbers || with_source_code)
	    /* The line number tables will refer to unadjusted
	       section VMAs, so we must undo any VMA modifications
	       when calling show_line.  */
	    show_line (aux->abfd, section, addr_offset - adjust_section_vma);

	  if (! prefix_addresses)
	    {
	      char *s;

	      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);
	      for (s = buf + skip_addr_chars; *s == '0'; s++)
		*s = ' ';
	      if (*s == '\0')
		*--s = '0';
	      printf ("%s:\t", buf + skip_addr_chars);
	    }
	  else
	    {
	      aux->require_sec = TRUE;
	      objdump_print_address (section->vma + addr_offset, info);
	      aux->require_sec = FALSE;
	      putchar (' ');
	    }

	  if (insns)
	    {
	      sfile.size = 120;
	      sfile.buffer = xmalloc (sfile.size);
	      sfile.current = sfile.buffer;
	      info->fprintf_func = (fprintf_ftype) objdump_sprintf;
	      info->stream = (FILE *) &sfile;
	      info->bytes_per_line = 0;
	      info->bytes_per_chunk = 0;

#ifdef DISASSEMBLER_NEEDS_RELOCS
	      /* FIXME: This is wrong.  It tests the number of octets
		 in the last instruction, not the current one.  */
	      if (*relppp < relppend
		  && (**relppp)->address >= rel_offset + addr_offset
		  && ((**relppp)->address
		      < rel_offset + addr_offset + octets / opb))
		info->flags = INSN_HAS_RELOC;
	      else
#endif
		info->flags = 0;

	      octets = (*disassemble_fn) (section->vma + addr_offset, info);
	      info->fprintf_func = (fprintf_ftype) fprintf;
	      info->stream = stdout;
	      if (info->bytes_per_line != 0)
		octets_per_line = info->bytes_per_line;
	      if (octets < 0)
		{
		  if (sfile.current != sfile.buffer)
		    printf ("%s\n", sfile.buffer);
		  free (sfile.buffer);
		  break;
		}
	    }
	  else
	    {
	      bfd_vma j;

	      octets = octets_per_line;
	      if (addr_offset + octets / opb > stop_offset)
		octets = (stop_offset - addr_offset) * opb;

	      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)
		{
		  if (ISPRINT (data[j]))
		    buf[j - addr_offset * opb] = data[j];
		  else
		    buf[j - addr_offset * opb] = '.';
		}
	      buf[j - addr_offset * opb] = '\0';
	    }

	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
	    {
	      bfd_vma j;

	      /* If ! prefix_addresses and ! wide_output, we print
		 octets_per_line octets per line.  */
	      pb = octets;
	      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)
		pb = octets_per_line;

	      if (info->bytes_per_chunk)
		bpc = info->bytes_per_chunk;
	      else
		bpc = 1;

	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
		{
		  int k;
		  if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
		    {
		      for (k = bpc - 1; k >= 0; k--)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
		  else
		    {
		      for (k = 0; k < bpc; k++)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
		}

	      for (; pb < octets_per_line; pb += bpc)
		{
		  int k;

		  for (k = 0; k < bpc; k++)
		    printf ("  ");
		  putchar (' ');
		}

	      /* Separate raw data from instruction by extra space.  */
	      if (insns)
		putchar ('\t');
	      else
		printf ("    ");
	    }

	  if (! insns)
	    printf ("%s", buf);
	  else
	    {
	      printf ("%s", sfile.buffer);
	      free (sfile.buffer);
	    }

	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
	    {
	      while (pb < octets)
		{
		  bfd_vma j;
		  char *s;

		  putchar ('\n');
		  j = addr_offset * opb + pb;

		  bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);
		  for (s = buf + skip_addr_chars; *s == '0'; s++)
		    *s = ' ';
		  if (*s == '\0')
		    *--s = '0';
		  printf ("%s:\t", buf + skip_addr_chars);

		  pb += octets_per_line;
		  if (pb > octets)
		    pb = octets;
		  for (; j < addr_offset * opb + pb; j += bpc)
		    {
		      int k;

		      if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
			{
			  for (k = bpc - 1; k >= 0; k--)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
		      else
			{
			  for (k = 0; k < bpc; k++)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
		    }
		}
	    }

	  if (!wide_output)
	    putchar ('\n');
	  else
	    need_nl = TRUE;
	}

      while ((*relppp) < relppend
	     && (**relppp)->address < rel_offset + addr_offset + octets / opb)
	{
	  if (dump_reloc_info || dump_dynamic_reloc_info)
	    {
	      arelent *q;

	      q = **relppp;

	      if (wide_output)
		putchar ('\t');
	      else
		printf ("\t\t\t");

	      objdump_print_value (section->vma - rel_offset + q->address,
				   info, TRUE);

	      printf (": %s\t", q->howto->name);

	      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)
		printf ("*unknown*");
	      else
		{
		  const char *sym_name;

		  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
		  if (sym_name != NULL && *sym_name != '\0')
		    objdump_print_symname (aux->abfd, info, *q->sym_ptr_ptr);
		  else
		    {
		      asection *sym_sec;

		      sym_sec = bfd_get_section (*q->sym_ptr_ptr);
		      sym_name = bfd_get_section_name (aux->abfd, sym_sec);
		      if (sym_name == NULL || *sym_name == '\0')
			sym_name = "*unknown*";
		      printf ("%s", sym_name);
		    }
		}

	      if (q->addend)
		{
		  printf ("+0x");
		  objdump_print_value (q->addend, info, TRUE);
		}

	      printf ("\n");
	      need_nl = FALSE;
	    }
	  ++(*relppp);
	}

      if (need_nl)
	printf ("\n");

      addr_offset += octets / opb;
    }
}

static void
disassemble_section (bfd *abfd, asection *section, void *info)
{
  struct disassemble_info *    pinfo = (struct disassemble_info *) info;
  struct objdump_disasm_info * paux;
  unsigned int                 opb = pinfo->octets_per_byte;
  bfd_byte *                   data = NULL;
  bfd_size_type                datasize = 0;
  arelent **                   rel_pp = NULL;
  arelent **                   rel_ppstart = NULL;
  arelent **                   rel_ppend;
  unsigned long                stop_offset;
  asymbol *                    sym = NULL;
  long                         place = 0;
  long                         rel_count;
  bfd_vma                      rel_offset;
  unsigned long                addr_offset;

  /* Sections that do not contain machine
     code are not normally disassembled.  */
  if (! disassemble_all
      && only == NULL
      && (section->flags & SEC_CODE) == 0)
    return;

  if (! process_section_p (section))
    return;

  datasize = bfd_get_section_size_before_reloc (section);
  if (datasize == 0)
    return;

  /* Decide which set of relocs to use.  Load them if necessary.  */
  paux = (struct objdump_disasm_info *) pinfo->application_data;
  if (paux->dynrelbuf)
    {
      rel_pp = paux->dynrelbuf;
      rel_count = paux->dynrelcount;
      /* Dynamic reloc addresses are absolute, non-dynamic are section
	 relative.  REL_OFFSET specifies the reloc address corresponding
	 to the start of this section.  */
      rel_offset = section->vma;
    }
  else
    {
      rel_count = 0;
      rel_pp = NULL;
      rel_offset = 0;

      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
	{
	  long relsize;

	  relsize = bfd_get_reloc_upper_bound (abfd, section);
	  if (relsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  if (relsize > 0)
	    {
	      rel_ppstart = rel_pp = xmalloc (relsize);
	      rel_count = bfd_canonicalize_reloc (abfd, section, rel_pp, syms);
	      if (rel_count < 0)
		bfd_fatal (bfd_get_filename (abfd));

	      /* Sort the relocs by address.  */
	      qsort (rel_pp, rel_count, sizeof (arelent *), compare_relocs);
	    }
	}

    }
  rel_ppend = rel_pp + rel_count;

  data = xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);

  paux->sec = section;
  pinfo->buffer = data;
  pinfo->buffer_vma = section->vma;
  pinfo->buffer_length = datasize;
  pinfo->section = section;

  if (start_address == (bfd_vma) -1
      || start_address < pinfo->buffer_vma)
    addr_offset = 0;
  else
    addr_offset = start_address - pinfo->buffer_vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < pinfo->buffer_vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - pinfo->buffer_vma;
      if (stop_offset > pinfo->buffer_length / opb)
	stop_offset = pinfo->buffer_length / opb;
    }

  /* Skip over the relocs belonging to addresses below the
     start address.  */
  while (rel_pp < rel_ppend
	 && (*rel_pp)->address < rel_offset + addr_offset)
    ++rel_pp;

  printf (_("Disassembly of section %s:\n"), section->name);

  /* Find the nearest symbol forwards from our current position.  */
  paux->require_sec = TRUE;
  sym = find_symbol_for_address (section->vma + addr_offset, info, &place);
  paux->require_sec = FALSE;

  /* Disassemble a block of instructions up to the address associated with
     the symbol we have just found.  Then print the symbol and find the
     next symbol on.  Repeat until we have disassembled the entire section
     or we have reached the end of the address range we are interested in.  */
  while (addr_offset < stop_offset)
    {
      bfd_vma addr;
      asymbol *nextsym;
      unsigned long nextstop_offset;
      bfd_boolean insns;

      addr = section->vma + addr_offset;

      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
	{
	  int x;

	  for (x = place;
	       (x < sorted_symcount
		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
	       ++x)
	    continue;

	  pinfo->symbols = sorted_syms + place;
	  pinfo->num_symbols = x - place;
	}
      else
	{
	  pinfo->symbols = NULL;
	  pinfo->num_symbols = 0;
	}

      if (! prefix_addresses)
	{
	  pinfo->fprintf_func (pinfo->stream, "\n");
	  objdump_print_addr_with_sym (abfd, section, sym, addr,
				       pinfo, FALSE);
	  pinfo->fprintf_func (pinfo->stream, ":\n");
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextsym = sym;
      else if (sym == NULL)
	nextsym = NULL;
      else
	{
#define is_valid_next_sym(SYM) \
  ((SYM)->section == section \
   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
   && pinfo->symbol_is_valid (SYM, pinfo))
	    
	  /* Search forward for the next appropriate symbol in
	     SECTION.  Note that all the symbols are sorted
	     together into one big array, and that some sections
	     may have overlapping addresses.  */
	  while (place < sorted_symcount
		 && ! is_valid_next_sym (sorted_syms [place]))
	    ++place;

	  if (place >= sorted_symcount)
	    nextsym = NULL;
	  else
	    nextsym = sorted_syms[place];
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
      else if (nextsym == NULL)
	nextstop_offset = stop_offset;
      else
	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;

      if (nextstop_offset > stop_offset)
	nextstop_offset = stop_offset;

      /* If a symbol is explicitly marked as being an object
	 rather than a function, just dump the bytes without
	 disassembling them.  */
      if (disassemble_all
	  || sym == NULL
	  || bfd_asymbol_value (sym) > addr
	  || ((sym->flags & BSF_OBJECT) == 0
	      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		  == NULL)
	      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		  == NULL))
	  || (sym->flags & BSF_FUNCTION) != 0)
	insns = TRUE;
      else
	insns = FALSE;

      disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,
			 addr_offset, nextstop_offset,
			 rel_offset, &rel_pp, rel_ppend);

      addr_offset = nextstop_offset;
      sym = nextsym;
    }

  free (data);

  if (rel_ppstart != NULL)
    free (rel_ppstart);
}

/* Disassemble the contents of an object file.  */

static void
disassemble_data (bfd *abfd)
{
  struct disassemble_info disasm_info;
  struct objdump_disasm_info aux;

  print_files = NULL;
  prev_functionname = NULL;
  prev_line = -1;

  /* We make a copy of syms to sort.  We don't want to sort syms
     because that will screw up the relocs.  */
  sorted_syms = xmalloc (symcount * sizeof (asymbol *));
  memcpy (sorted_syms, syms, symcount * sizeof (asymbol *));

  sorted_symcount = remove_useless_symbols (sorted_syms, symcount);

  /* Sort the symbols into section and symbol order.  */
  qsort (sorted_syms, sorted_symcount, sizeof (asymbol *), compare_symbols);

  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf);

  disasm_info.application_data = (void *) &aux;
  aux.abfd = abfd;
  aux.require_sec = FALSE;
  aux.dynrelbuf = NULL;
  aux.dynrelcount = 0;

  disasm_info.print_address_func = objdump_print_address;
  disasm_info.symbol_at_address_func = objdump_symbol_at_address;

  if (machine != NULL)
    {
      const bfd_arch_info_type *info = bfd_scan_arch (machine);

      if (info == NULL)
	fatal (_("Can't use supplied machine %s"), machine);

      abfd->arch_info = info;
    }

  if (endian != BFD_ENDIAN_UNKNOWN)
    {
      struct bfd_target *xvec;

      xvec = xmalloc (sizeof (struct bfd_target));
      memcpy (xvec, abfd->xvec, sizeof (struct bfd_target));
      xvec->byteorder = endian;
      abfd->xvec = xvec;
    }

  /* Use libopcodes to locate a suitable disassembler.  */
  aux.disassemble_fn = disassembler (abfd);
  if (!aux.disassemble_fn)
    {
      non_fatal (_("Can't disassemble for architecture %s\n"),
		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
      exit_status = 1;
      return;
    }

  disasm_info.flavour = bfd_get_flavour (abfd);
  disasm_info.arch = bfd_get_arch (abfd);
  disasm_info.mach = bfd_get_mach (abfd);
  disasm_info.disassembler_options = disassembler_options;
  disasm_info.octets_per_byte = bfd_octets_per_byte (abfd);

  if (bfd_big_endian (abfd))
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;
  else if (bfd_little_endian (abfd))
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_LITTLE;
  else
    /* ??? Aborting here seems too drastic.  We could default to big or little
       instead.  */
    disasm_info.endian = BFD_ENDIAN_UNKNOWN;

  /* Allow the target to customize the info structure.  */
  disassemble_init_for_target (& disasm_info);

  /* Pre-load the dynamic relocs if we are going
     to be dumping them along with the disassembly.  */
  if (dump_dynamic_reloc_info)
    {
      long relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      if (relsize > 0)
	{
	  aux.dynrelbuf = xmalloc (relsize);
	  aux.dynrelcount = bfd_canonicalize_dynamic_reloc (abfd,
							    aux.dynrelbuf,
							    dynsyms);
	  if (aux.dynrelcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  /* Sort the relocs by address.  */
	  qsort (aux.dynrelbuf, aux.dynrelcount, sizeof (arelent *),
		 compare_relocs);
	}
    }

  bfd_map_over_sections (abfd, disassemble_section, & disasm_info);

  if (aux.dynrelbuf != NULL)
    free (aux.dynrelbuf);
  free (sorted_syms);
}

/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to
   it.  Return NULL on failure.   */

static char *
read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr)
{
  asection *stabsect;
  bfd_size_type size;
  char *contents;

  stabsect = bfd_get_section_by_name (abfd, sect_name);
  if (stabsect == NULL)
    {
      printf (_("No %s section present\n\n"), sect_name);
      return FALSE;
    }

  size = bfd_section_size (abfd, stabsect);
  contents  = xmalloc (size);

  if (! bfd_get_section_contents (abfd, stabsect, contents, 0, size))
    {
      non_fatal (_("Reading %s section of %s failed: %s"),
		 sect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
      free (contents);
      exit_status = 1;
      return NULL;
    }

  *size_ptr = size;

  return contents;
}

/* Stabs entries use a 12 byte format:
     4 byte string table index
     1 byte stab type
     1 byte stab other field
     2 byte stab desc field
     4 byte stab value
   FIXME: This will have to change for a 64 bit object format.  */

#define STRDXOFF  (0)
#define TYPEOFF   (4)
#define OTHEROFF  (5)
#define DESCOFF   (6)
#define VALOFF    (8)
#define STABSIZE (12)

/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),
   using string table section STRSECT_NAME (in `strtab').  */

static void
print_section_stabs (bfd *abfd,
		     const char *stabsect_name,
		     unsigned *string_offset_ptr)
{
  int i;
  unsigned file_string_table_offset = 0;
  unsigned next_file_string_table_offset = *string_offset_ptr;
  bfd_byte *stabp, *stabs_end;

  stabp = stabs;
  stabs_end = stabp + stab_size;

  printf (_("Contents of %s section:\n\n"), stabsect_name);
  printf ("Symnum n_type n_othr n_desc n_value  n_strx String\n");

  /* Loop through all symbols and print them.

     We start the index at -1 because there is a dummy symbol on
     the front of stabs-in-{coff,elf} sections that supplies sizes.  */
  for (i = -1; stabp < stabs_end; stabp += STABSIZE, i++)
    {
      const char *name;
      unsigned long strx;
      unsigned char type, other;
      unsigned short desc;
      bfd_vma value;

      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
      value = bfd_h_get_32 (abfd, stabp + VALOFF);

      printf ("\n%-6d ", i);
      /* Either print the stab name, or, if unnamed, print its number
	 again (makes consistent formatting for tools like awk).  */
      name = bfd_get_stab_name (type);
      if (name != NULL)
	printf ("%-6s", name);
      else if (type == N_UNDF)
	printf ("HdrSym");
      else
	printf ("%-6d", type);
      printf (" %-6d %-6d ", other, desc);
      bfd_printf_vma (abfd, value);
      printf (" %-6lu", strx);

      /* Symbols with type == 0 (N_UNDF) specify the length of the
	 string table associated with this file.  We use that info
	 to know how to relocate the *next* file's string table indices.  */
      if (type == N_UNDF)
	{
	  file_string_table_offset = next_file_string_table_offset;
	  next_file_string_table_offset += value;
	}
      else
	{
	  /* Using the (possibly updated) string table offset, print the
	     string (if any) associated with this symbol.  */
	  if ((strx + file_string_table_offset) < stabstr_size)
	    printf (" %s", &strtab[strx + file_string_table_offset]);
	  else
	    printf (" *");
	}
    }
  printf ("\n\n");
  *string_offset_ptr = next_file_string_table_offset;
}

typedef struct
{
  const char * section_name;
  const char * string_section_name;
  unsigned string_offset;
}
stab_section_names;

static void
find_stabs_section (bfd *abfd, asection *section, void *names)
{
  int len;
  stab_section_names * sought = (stab_section_names *) names;

  /* Check for section names for which stabsect_name is a prefix, to
     handle .stab.N, etc.  */
  len = strlen (sought->section_name);

  /* If the prefix matches, and the files section name ends with a
     nul or a digit, then we match.  I.e., we want either an exact
     match or a section followed by a number.  */
  if (strncmp (sought->section_name, section->name, len) == 0
      && (section->name[len] == 0
	  || (section->name[len] == '.' && ISDIGIT (section->name[len + 1]))))
    {
      if (strtab == NULL)
	strtab = read_section_stabs (abfd, sought->string_section_name,
				     &stabstr_size);
      
      if (strtab)
	{
	  stabs = read_section_stabs (abfd, section->name, &stab_size);
	  if (stabs)
	    print_section_stabs (abfd, section->name, &sought->string_offset);
	}
    }
}

static void
dump_stabs_section (bfd *abfd, char *stabsect_name, char *strsect_name)
{
  stab_section_names s;

  s.section_name = stabsect_name;
  s.string_section_name = strsect_name;
  s.string_offset = 0;

  bfd_map_over_sections (abfd, find_stabs_section, & s);

  free (strtab);
  strtab = NULL;
}

/* Dump the any sections containing stabs debugging information.  */

static void
dump_stabs (bfd *abfd)
{
  dump_stabs_section (abfd, ".stab", ".stabstr");
  dump_stabs_section (abfd, ".stab.excl", ".stab.exclstr");
  dump_stabs_section (abfd, ".stab.index", ".stab.indexstr");
  dump_stabs_section (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
}

static void
dump_bfd_header (bfd *abfd)
{
  char *comma = "";

  printf (_("architecture: %s, "),
	  bfd_printable_arch_mach (bfd_get_arch (abfd),
				   bfd_get_mach (abfd)));
  printf (_("flags 0x%08x:\n"), abfd->flags);

#define PF(x, y)    if (abfd->flags & x) {printf("%s%s", comma, y); comma=", ";}
  PF (HAS_RELOC, "HAS_RELOC");
  PF (EXEC_P, "EXEC_P");
  PF (HAS_LINENO, "HAS_LINENO");
  PF (HAS_DEBUG, "HAS_DEBUG");
  PF (HAS_SYMS, "HAS_SYMS");
  PF (HAS_LOCALS, "HAS_LOCALS");
  PF (DYNAMIC, "DYNAMIC");
  PF (WP_TEXT, "WP_TEXT");
  PF (D_PAGED, "D_PAGED");
  PF (BFD_IS_RELAXABLE, "BFD_IS_RELAXABLE");
  PF (HAS_LOAD_PAGE, "HAS_LOAD_PAGE");
  printf (_("\nstart address 0x"));
  bfd_printf_vma (abfd, abfd->start_address);
  printf ("\n");
}


static void
dump_bfd_private_header (bfd *abfd)
{
  bfd_print_private_bfd_data (abfd, stdout);
}


/* Display a section in hexadecimal format with associated characters.
   Each line prefixed by the zero padded address.  */

static void
dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
{
  bfd_byte *data = 0;
  bfd_size_type datasize;
  bfd_size_type addr_offset;
  bfd_size_type start_offset;
  bfd_size_type stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);
  /* Bytes per line.  */
  const int onaline = 16;
  char buf[64];
  int count;
  int width;

  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    return;

  if (! process_section_p (section))
    return;
  
  if ((datasize = bfd_section_size (abfd, section)) == 0)
    return;

  printf (_("Contents of section %s:\n"), section->name);

  data = xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);

  /* Compute the address range to display.  */
  if (start_address == (bfd_vma) -1
      || start_address < section->vma)
    start_offset = 0;
  else
    start_offset = start_address - section->vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < section->vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - section->vma;

      if (stop_offset > datasize / opb)
	stop_offset = datasize / opb;
    }

  width = 4;

  bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  for (addr_offset = start_offset;
       addr_offset < stop_offset; addr_offset += onaline / opb)
    {
      bfd_size_type j;

      bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
      count = strlen (buf);
      if ((size_t) count >= sizeof (buf))
	abort ();

      putchar (' ');
      while (count < width)
	{
	  putchar ('0');
	  count++;
	}
      fputs (buf + count - width, stdout);
      putchar (' ');

      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
	{
	  if (j < stop_offset * opb)
	    printf ("%02x", (unsigned) (data[j]));
	  else
	    printf ("  ");
	  if ((j & 3) == 3)
	    printf (" ");
	}

      printf (" ");
      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
	{
	  if (j >= stop_offset * opb)
	    printf (" ");
	  else
	    printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
	}
      putchar ('\n');
    }
  free (data);
}

/* Actually display the various requested regions.  */

static void
dump_data (bfd *abfd)
{
  bfd_map_over_sections (abfd, dump_section, NULL);
}

/* Should perhaps share code and display with nm?  */

static void
dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean dynamic)
{
  asymbol **current;
  long max;
  long count;

  if (dynamic)
    {
      current = dynsyms;
      max = dynsymcount;
      printf ("DYNAMIC SYMBOL TABLE:\n");
    }
  else
    {
      current = syms;
      max = symcount;
      printf ("SYMBOL TABLE:\n");
    }

  if (max == 0)
    printf (_("no symbols\n"));

  for (count = 0; count < max; count++)
    {
      bfd *cur_bfd;

      if (*current == NULL)
	printf (_("no information for the %ld'th symbol"), count);

      else if ((cur_bfd = bfd_asymbol_bfd (*current)) == NULL)
	printf (_("could not determine the type of the %ld'th symbol"),
		count);

      else
	{
	  const char *name = (*current)->name;

	  if (do_demangle && name != NULL && *name != '\0')
	    {
	      char *alloc;

	      /* If we want to demangle the name, we demangle it
		 here, and temporarily clobber it while calling
		 bfd_print_symbol.  FIXME: This is a gross hack.  */
	      alloc = demangle (cur_bfd, name);
	      (*current)->name = alloc;
	      bfd_print_symbol (cur_bfd, stdout, *current,
				bfd_print_symbol_all);
	      (*current)->name = name;
	      free (alloc);
	    }
	  else
	    bfd_print_symbol (cur_bfd, stdout, *current,
			      bfd_print_symbol_all);
	}

      printf ("\n");
      current++;
    }
  printf ("\n\n");
}

static void
dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)
{
  arelent **p;
  char *last_filename, *last_functionname;
  unsigned int last_line;

  /* Get column headers lined up reasonably.  */
  {
    static int width;

    if (width == 0)
      {
	char buf[30];

	bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
	width = strlen (buf) - 7;
      }
    printf ("OFFSET %*s TYPE %*s VALUE \n", width, "", 12, "");
  }

  last_filename = NULL;
  last_functionname = NULL;
  last_line = 0;

  for (p = relpp; relcount && *p != NULL; p++, relcount--)
    {
      arelent *q = *p;
      const char *filename, *functionname;
      unsigned int line;
      const char *sym_name;
      const char *section_name;

      if (start_address != (bfd_vma) -1
	  && q->address < start_address)
	continue;
      if (stop_address != (bfd_vma) -1
	  && q->address > stop_address)
	continue;

      if (with_line_numbers
	  && sec != NULL
	  && bfd_find_nearest_line (abfd, sec, syms, q->address,
				    &filename, &functionname, &line))
	{
	  if (functionname != NULL
	      && (last_functionname == NULL
		  || strcmp (functionname, last_functionname) != 0))
	    {
	      printf ("%s():\n", functionname);
	      if (last_functionname != NULL)
		free (last_functionname);
	      last_functionname = xstrdup (functionname);
	    }

	  if (line > 0
	      && (line != last_line
		  || (filename != NULL
		      && last_filename != NULL
		      && strcmp (filename, last_filename) != 0)))
	    {
	      printf ("%s:%u\n", filename == NULL ? "???" : filename, line);
	      last_line = line;
	      if (last_filename != NULL)
		free (last_filename);
	      if (filename == NULL)
		last_filename = NULL;
	      else
		last_filename = xstrdup (filename);
	    }
	}

      if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
	{
	  sym_name = (*(q->sym_ptr_ptr))->name;
	  section_name = (*(q->sym_ptr_ptr))->section->name;
	}
      else
	{
	  sym_name = NULL;
	  section_name = NULL;
	}

      if (sym_name)
	{
	  bfd_printf_vma (abfd, q->address);
	  if (q->howto->name)
	    printf (" %-16s  ", q->howto->name);
	  else
	    printf (" %-16d  ", q->howto->type);
	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
	}
      else
	{
	  if (section_name == NULL)
	    section_name = "*unknown*";
	  bfd_printf_vma (abfd, q->address);
	  printf (" %-16s  [%s]",
		  q->howto->name,
		  section_name);
	}

      if (q->addend)
	{
	  printf ("+0x");
	  bfd_printf_vma (abfd, q->addend);
	}

      printf ("\n");
    }
}

static void
dump_relocs_in_section (bfd *abfd,
			asection *section,
			void *dummy ATTRIBUTE_UNUSED)
{
  arelent **relpp;
  long relcount;
  long relsize;

  if (   bfd_is_abs_section (section)
      || bfd_is_und_section (section)
      || bfd_is_com_section (section)
      || (! process_section_p (section))
      || ((section->flags & SEC_RELOC) == 0))
    return;

  relsize = bfd_get_reloc_upper_bound (abfd, section);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("RELOCATION RECORDS FOR [%s]:", section->name);

  if (relsize == 0)
    {
      printf (" (none)\n\n");
      return;
    }

  relpp = xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);

  if (relcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  else if (relcount == 0)
    printf (" (none)\n\n");
  else
    {
      printf ("\n");
      dump_reloc_set (abfd, section, relpp, relcount);
      printf ("\n\n");
    }
  free (relpp);
}

static void
dump_relocs (bfd *abfd)
{
  bfd_map_over_sections (abfd, dump_relocs_in_section, NULL);
}

static void
dump_dynamic_relocs (bfd *abfd)
{
  long relsize;
  arelent **relpp;
  long relcount;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("DYNAMIC RELOCATION RECORDS");

  if (relsize == 0)
    printf (" (none)\n\n");
  else
    {
      relpp = xmalloc (relsize);
      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);

      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
      else if (relcount == 0)
	printf (" (none)\n\n");
      else
	{
	  printf ("\n");
	  dump_reloc_set (abfd, NULL, relpp, relcount);
	  printf ("\n\n");
	}
      free (relpp);
    }
}

/* Creates a table of paths, to search for source files.  */

static void
add_include_path (const char *path)
{
  if (path[0] == 0)
    return;
  include_path_count++;
  include_paths = xrealloc (include_paths,
			    include_path_count * sizeof (*include_paths));
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (path[1] == ':' && path[2] == 0)
    path = concat (path, ".", (const char *) 0);
#endif
  include_paths[include_path_count - 1] = path;
}

static void
adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,
		  asection *section,
		  void *dummy ATTRIBUTE_UNUSED)
{
  section->vma += adjust_section_vma;
  section->lma += adjust_section_vma;
}

/* Dump selected contents of ABFD.  */

static void
dump_bfd (bfd *abfd)
{
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
    bfd_map_over_sections (abfd, adjust_addresses, NULL);

  if (! dump_debugging_tags)
    printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	    abfd->xvec->name);
  if (dump_ar_hdrs)
    print_arelt_descr (stdout, abfd, TRUE);
  if (dump_file_header)
    dump_bfd_header (abfd);
  if (dump_private_headers)
    dump_bfd_private_header (abfd);
  if (! dump_debugging_tags)
    putchar ('\n');
  if (dump_section_headers)
    dump_headers (abfd);

  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
    syms = slurp_symtab (abfd);
  if (dump_dynamic_symtab || dump_dynamic_reloc_info)
    dynsyms = slurp_dynamic_symtab (abfd);

  if (dump_symtab)
    dump_symbols (abfd, FALSE);
  if (dump_dynamic_symtab)
    dump_symbols (abfd, TRUE);
  if (dump_stab_section_info)
    dump_stabs (abfd);
  if (dump_reloc_info && ! disassemble)
    dump_relocs (abfd);
  if (dump_dynamic_reloc_info && ! disassemble)
    dump_dynamic_relocs (abfd);
  if (dump_section_contents)
    dump_data (abfd);
  if (disassemble)
    disassemble_data (abfd);

  if (dump_debugging)
    {
      void *dhandle;

      dhandle = read_debugging_info (abfd, syms, symcount);
      if (dhandle != NULL)
	{
	  if (! print_debugging_info (stdout, dhandle, abfd, syms, demangle,
	      dump_debugging_tags ? TRUE : FALSE))
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
	}
    }

  if (syms)
    {
      free (syms);
      syms = NULL;
    }

  if (dynsyms)
    {
      free (dynsyms);
      dynsyms = NULL;
    }
}

static void
display_bfd (bfd *abfd)
{
  char **matching;

  if (bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
    }

  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }

  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
display_file (char *filename, char *target)
{
  bfd *file;
  bfd *arfile = NULL;

  if (get_file_size (filename) < 1)
    return;

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

  /* If the file is an archive, process all of its elements.  */
  if (bfd_check_format (file, bfd_archive))
    {
      bfd *last_arfile = NULL;

      printf (_("In archive %s:\n"), bfd_get_filename (file));
      for (;;)
	{
	  bfd_set_error (bfd_error_no_error);

	  arfile = bfd_openr_next_archived_file (file, arfile);
	  if (arfile == NULL)
	    {
	      if (bfd_get_error () != bfd_error_no_more_archived_files)
		nonfatal (bfd_get_filename (file));
	      break;
	    }

	  display_bfd (arfile);

	  if (last_arfile != NULL)
	    bfd_close (last_arfile);
	  last_arfile = arfile;
	}

      if (last_arfile != NULL)
	bfd_close (last_arfile);
    }
  else
    display_bfd (file);

  bfd_close (file);
}

int
main (int argc, char **argv)
{
  int c;
  char *target = default_target;
  bfd_boolean seenflag = FALSE;

#if defined (HAVE_SETLOCALE)
#if defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  setlocale (LC_CTYPE, "");
#endif

  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSI:j:wE:zgeG",
			   long_options, (int *) 0))
	 != EOF)
    {
      switch (c)
	{
	case 0:
	  break;		/* We've been given a long option.  */
	case 'm':
	  machine = optarg;
	  break;
	case 'M':
	  if (disassembler_options)
	    /* Ignore potential memory leak for now.  */
	    disassembler_options = concat (disassembler_options, ",",
					   optarg, NULL);
	  else
	    disassembler_options = optarg;
	  break;
	case 'j':
	  if (only_used == only_size)
	    {
	      only_size += 8;
	      only = xrealloc (only, only_size * sizeof (char *));
	    }
	  only [only_used++] = optarg;
	  break;
	case 'l':
	  with_line_numbers = TRUE;
	  break;
	case 'b':
	  target = optarg;
	  break;
	case 'C':
	  do_demangle = TRUE;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'w':
	  wide_output = TRUE;
	  break;
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
	  break;
	case OPTION_START_ADDRESS:
	  start_address = parse_vma (optarg, "--start-address");
	  break;
	case OPTION_STOP_ADDRESS:
	  stop_address = parse_vma (optarg, "--stop-address");
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      non_fatal (_("unrecognized -E option"));
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
	      usage (stderr, 1);
	    }
	  break;

	case 'f':
	  dump_file_header = TRUE;
	  seenflag = TRUE;
	  break;
	case 'i':
	  formats_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'I':
	  add_include_path (optarg);
	  break;
	case 'p':
	  dump_private_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 'x':
	  dump_private_headers = TRUE;
	  dump_symtab = TRUE;
	  dump_reloc_info = TRUE;
	  dump_file_header = TRUE;
	  dump_ar_hdrs = TRUE;
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 't':
	  dump_symtab = TRUE;
	  seenflag = TRUE;
	  break;
	case 'T':
	  dump_dynamic_symtab = TRUE;
	  seenflag = TRUE;
	  break;
	case 'd':
	  disassemble = TRUE;
	  seenflag = TRUE;
	  break;
	case 'z':
	  disassemble_zeroes = TRUE;
	  break;
	case 'D':
	  disassemble = TRUE;
	  disassemble_all = TRUE;
	  seenflag = TRUE;
	  break;
	case 'S':
	  disassemble = TRUE;
	  with_source_code = TRUE;
	  seenflag = TRUE;
	  break;
	case 'g':
	  dump_debugging = 1;
	  seenflag = TRUE;
	  break;
	case 'e':
	  dump_debugging = 1;
	  dump_debugging_tags = 1;
	  do_demangle = TRUE;
	  seenflag = TRUE;
	  break;
	case 'G':
	  dump_stab_section_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 's':
	  dump_section_contents = TRUE;
	  seenflag = TRUE;
	  break;
	case 'r':
	  dump_reloc_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'R':
	  dump_dynamic_reloc_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'a':
	  dump_ar_hdrs = TRUE;
	  seenflag = TRUE;
	  break;
	case 'h':
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 'H':
	  usage (stdout, 0);
	  seenflag = TRUE;
	case 'v':
	case 'V':
	  show_version = TRUE;
	  seenflag = TRUE;
	  break;

	default:
	  usage (stderr, 1);
	}
    }

  if (show_version)
    print_version ("objdump");

  if (!seenflag)
    usage (stderr, 2);

  if (formats_info)
    exit_status = display_info ();
  else
    {
      if (optind == argc)
	display_file ("a.out", target);
      else
	for (; optind < argc;)
	  display_file (argv[optind++], target);
    }

  END_PROGRESS (program_name);

  return exit_status;
}
@


1.11
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d2722 2
@


1.10
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d22 29
d69 2
a70 3
/* This is needed by INIT_DISASSEMBLE_INFO.  */
extern int fprintf
  PARAMS ((FILE *, const char *, ...));
d78 2
a99 1
static char *only;			/* -j secname */
d104 1
d108 14
a121 1
/* Extra info to pass to the disassembler address printing function.  */
d124 6
a129 3
  bfd *abfd;
  asection *sec;
  bfd_boolean require_sec;
d133 1
a133 1
static char *machine = (char *) NULL;
d136 1
a136 1
static char *disassembler_options = (char *) NULL;
a163 71

/* Static declarations.  */

static void usage
  PARAMS ((FILE *, int));
static void nonfatal
  PARAMS ((const char *));
static void display_file
  PARAMS ((char *, char *));
static void dump_section_header
  PARAMS ((bfd *, asection *, PTR));
static void dump_headers
  PARAMS ((bfd *));
static void dump_data
  PARAMS ((bfd *));
static void dump_relocs
  PARAMS ((bfd *));
static void dump_dynamic_relocs
  PARAMS ((bfd *));
static void dump_reloc_set
  PARAMS ((bfd *, asection *, arelent **, long));
static void dump_symbols
  PARAMS ((bfd *, bfd_boolean));
static void dump_bfd_header
  PARAMS ((bfd *));
static void dump_bfd_private_header
  PARAMS ((bfd *));
static void dump_bfd
  PARAMS ((bfd *));
static void display_bfd
  PARAMS ((bfd *));
static void objdump_print_value
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static void objdump_print_symname
  PARAMS ((bfd *, struct disassemble_info *, asymbol *));
static asymbol *find_symbol_for_address
  PARAMS ((bfd *, asection *, bfd_vma, bfd_boolean, long *));
static void objdump_print_addr_with_sym
  PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
	   struct disassemble_info *, bfd_boolean));
static void objdump_print_addr
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static void objdump_print_address
  PARAMS ((bfd_vma, struct disassemble_info *));
static int objdump_symbol_at_address
  PARAMS ((bfd_vma, struct disassemble_info *));
static void show_line
  PARAMS ((bfd *, asection *, bfd_vma));
static void disassemble_bytes
  PARAMS ((struct disassemble_info *, disassembler_ftype, bfd_boolean,
	   bfd_byte *, bfd_vma, bfd_vma, arelent ***, arelent **));
static void disassemble_data
  PARAMS ((bfd *));
static asymbol ** slurp_symtab
  PARAMS ((bfd *));
static asymbol ** slurp_dynamic_symtab
  PARAMS ((bfd *));
static long remove_useless_symbols
  PARAMS ((asymbol **, long));
static int compare_symbols
  PARAMS ((const PTR, const PTR));
static int compare_relocs
  PARAMS ((const PTR, const PTR));
static void dump_stabs
  PARAMS ((bfd *));
static bfd_boolean read_section_stabs
  PARAMS ((bfd *, const char *, const char *));
static void print_section_stabs
  PARAMS ((bfd *, const char *, const char *));
static void dump_section_stabs
  PARAMS ((bfd *, char *, char *));
d166 1
a166 3
usage (stream, status)
     FILE *stream;
     int status;
d182 1
d203 1
d228 7
a234 5

#define OPTION_ENDIAN (150)
#define OPTION_START_ADDRESS (OPTION_ENDIAN + 1)
#define OPTION_STOP_ADDRESS (OPTION_START_ADDRESS + 1)
#define OPTION_ADJUST_VMA (OPTION_STOP_ADDRESS + 1)
d244 1
d267 1
d279 1
a279 2
nonfatal (msg)
     const char *msg;
d286 2
a287 4
dump_section_header (abfd, section, ignored)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR ignored ATTRIBUTE_UNUSED;
d362 1
a362 2
dump_headers (abfd)
     bfd *abfd;
d382 1
a382 1
  bfd_map_over_sections (abfd, dump_section_header, (PTR) NULL);
d386 1
a386 2
slurp_symtab (abfd)
     bfd *abfd;
d388 1
a388 1
  asymbol **sy = (asymbol **) NULL;
d401 1
a401 1
    sy = (asymbol **) xmalloc (storage);
d412 1
a412 2
slurp_dynamic_symtab (abfd)
     bfd *abfd;
d414 1
a414 1
  asymbol **sy = (asymbol **) NULL;
d430 1
a430 1
    sy = (asymbol **) xmalloc (storage);
d443 1
a443 3
remove_useless_symbols (symbols, count)
     asymbol **symbols;
     long count;
d445 1
a445 1
  register asymbol **in_ptr = symbols, **out_ptr = symbols;
d467 12
a478 10
compare_symbols (ap, bp)
     const PTR ap;
     const PTR bp;
{
  const asymbol *a = *(const asymbol **)ap;
  const asymbol *b = *(const asymbol **)bp;
  const char *an, *bn;
  size_t anl, bnl;
  bfd_boolean af, bf;
  flagword aflags, bflags;
d576 1
a576 3
compare_relocs (ap, bp)
     const PTR ap;
     const PTR bp;
d578 2
a579 2
  const arelent *a = *(const arelent **)ap;
  const arelent *b = *(const arelent **)bp;
d596 2
a597 1
/* Print VMA to STREAM.  If SKIP_ZEROES is TRUE, omit leading zeroes.  */
d600 2
a601 4
objdump_print_value (vma, info, skip_zeroes)
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d605 1
a605 2
  struct objdump_disasm_info *aux
    = (struct objdump_disasm_info *) info->application_data;
d607 1
d624 2
a625 4
objdump_print_symname (abfd, info, sym)
     bfd *abfd;
     struct disassemble_info *info;
     asymbol *sym;
d648 5
a652 4
/* Locate a symbol given a bfd, a section, and a VMA.  If REQUIRE_SEC
   is TRUE, then always require the symbol to be in the section.  This
   returns NULL if there is no suitable symbol.  If PLACE is not NULL,
   then *PLACE is set to the index of the symbol in sorted_syms.  */
d655 3
a657 6
find_symbol_for_address (abfd, sec, vma, require_sec, place)
     bfd *abfd;
     asection *sec;
     bfd_vma vma;
     bfd_boolean require_sec;
     long *place;
d668 4
a671 1
  unsigned int opb = bfd_octets_per_byte (abfd);
d676 5
d710 1
a710 1
  /* If the file is relocateable, and the symbol could be from this
d719 1
a719 1
      && (require_sec
d764 1
a764 1
	  && (require_sec
d769 11
a779 4
	{
	  /* There is no suitable symbol.  */
	  return NULL;
	}
d788 1
a788 1
/* Print an address to INFO symbolically.  */
d791 3
a793 7
objdump_print_addr_with_sym (abfd, sec, sym, vma, info, skip_zeroes)
     bfd *abfd;
     asection *sec;
     asymbol *sym;
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d834 2
a835 2
/* Print VMA to INFO, symbolically if possible.  If SKIP_ZEROES is
   TRUE, don't output leading zeroes.  */
d838 3
a840 4
objdump_print_addr (vma, info, skip_zeroes)
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d853 1
a853 2
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 (long *) NULL);
d862 1
a862 3
objdump_print_address (vma, info)
     bfd_vma vma;
     struct disassemble_info *info;
d870 1
a870 3
objdump_symbol_at_address (vma, info)
     bfd_vma vma;
     struct disassemble_info * info;
a871 1
  struct objdump_disasm_info * aux;
d874 1
a874 7
  /* No symbols - do not bother checking.  */
  if (sorted_symcount < 1)
    return 0;

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 (long *) NULL);
d886 1
a886 1
   dissassembly with source, so that we know how much of the file to
d892 2
a893 1
  char *filename;
d905 83
a990 3
static void skip_to_line
  PARAMS ((struct print_file_list *, unsigned int, bfd_boolean));

d992 2
a993 4
skip_to_line (p, line, show)
     struct print_file_list *p;
     unsigned int line;
     bfd_boolean show;
d1014 1
a1014 1
/* Show the line number, or the source line, in a dissassembly
d1018 1
a1018 4
show_line (abfd, section, addr_offset)
     bfd *abfd;
     asection *section;
     bfd_vma addr_offset;
d1085 1
a1085 1
		  p->f = fopen (p->filename, "r");
d1108 1
a1108 1
	  FILE *f;
d1110 1
a1110 2
	  f = fopen (filename, "r");
	  if (f != NULL)
a1113 15
	      p = ((struct print_file_list *)
		   xmalloc (sizeof (struct print_file_list)));
	      p->filename = xmalloc (strlen (filename) + 1);
	      strcpy (p->filename, filename);
	      p->line = 0;
	      p->f = f;

	      if (print_files != NULL && print_files->f != NULL)
		{
		  fclose (print_files->f);
		  print_files->f = NULL;
		}
	      p->next = print_files;
	      print_files = p;

d1149 1
a1149 1
/* sprintf to a "stream" */
d1152 1
a1152 1
objdump_sprintf VPARAMS ((SFILE *f, const char *format, ...))
d1156 1
d1158 1
a1158 3
  VA_OPEN (args, format);
  VA_FIXEDARG (args, SFILE *, f);
  VA_FIXEDARG (args, const char *, format);
d1186 1
a1186 1
  VA_CLOSE (args);
d1190 18
d1229 9
a1237 11
disassemble_bytes (info, disassemble_fn, insns, data,
		   start_offset, stop_offset, relppp,
		   relppend)
     struct disassemble_info *info;
     disassembler_ftype disassemble_fn;
     bfd_boolean insns;
     bfd_byte *data;
     bfd_vma start_offset;
     bfd_vma stop_offset;
     arelent ***relppp;
     arelent **relppend;
d1289 1
a1289 1
         print `...'.  */
d1303 3
a1305 3
             zeroes in multiples of 4, to try to avoid running over
             the start of an instruction which happens to start with
             zero.  */
d1357 1
a1357 1
                 in the last instruction, not the current one.  */
d1359 3
a1361 2
		  && (**relppp)->address >= addr_offset
		  && (**relppp)->address <= addr_offset + octets / opb)
d1405 1
a1405 1
                 octets_per_line octets per line.  */
d1504 2
a1505 5
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
d1507 1
a1507 8
	  while ((*relppp) < relppend
		 && ((**relppp)->address >= (bfd_vma) addr_offset
		     && (**relppp)->address < (bfd_vma) addr_offset + octets / opb))
#ifdef DISASSEMBLER_NEEDS_RELOCS
	    if (! dump_reloc_info)
	      ++(*relppp);
	    else
#endif
d1518 2
a1519 1
	      objdump_print_value (section->vma + q->address, info, TRUE);
a1551 1
	      ++(*relppp);
d1553 1
d1563 222
d1788 1
a1788 2
disassemble_data (abfd)
     bfd *abfd;
a1789 2
  unsigned long addr_offset;
  disassembler_ftype disassemble_fn;
a1791 2
  asection *section;
  unsigned int opb;
d1799 1
a1799 1
  sorted_syms = (asymbol **) xmalloc (symcount * sizeof (asymbol *));
d1807 1
a1807 1
  INIT_DISASSEMBLE_INFO (disasm_info, stdout, fprintf);
d1809 1
a1809 1
  disasm_info.application_data = (PTR) &aux;
d1812 3
d1818 1
a1818 1
  if (machine != (char *) NULL)
d1832 1
a1832 1
      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
d1838 3
a1840 2
  disassemble_fn = disassembler (abfd);
  if (!disassemble_fn)
a1847 2
  opb = bfd_octets_per_byte (abfd);

d1852 1
a1852 1
  disasm_info.octets_per_byte = opb;
d1863 11
a1873 20
  for (section = abfd->sections;
       section != (asection *) NULL;
       section = section->next)
    {
      bfd_byte *data = NULL;
      bfd_size_type datasize = 0;
      arelent **relbuf = NULL;
      arelent **relpp = NULL;
      arelent **relppend = NULL;
      unsigned long stop_offset;
      asymbol *sym = NULL;
      long place = 0;

      if ((section->flags & SEC_LOAD) == 0
	  || (! disassemble_all
	      && only == NULL
	      && (section->flags & SEC_CODE) == 0))
	continue;
      if (only != (char *) NULL && strcmp (only, section->name) != 0)
	continue;
d1875 1
a1875 5
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
d1877 5
a1881 4
	  long relsize;

	  relsize = bfd_get_reloc_upper_bound (abfd, section);
	  if (relsize < 0)
d1884 3
a1886 22
	  if (relsize > 0)
	    {
	      long relcount;

	      relbuf = (arelent **) xmalloc (relsize);
	      relcount = bfd_canonicalize_reloc (abfd, section, relbuf, syms);
	      if (relcount < 0)
		bfd_fatal (bfd_get_filename (abfd));

	      /* Sort the relocs by address.  */
	      qsort (relbuf, relcount, sizeof (arelent *), compare_relocs);

	      relpp = relbuf;
	      relppend = relpp + relcount;

	      /* Skip over the relocs belonging to addresses below the
		 start address.  */
	      if (start_address != (bfd_vma) -1)
		while (relpp < relppend
		       && (*relpp)->address < start_address)
		  ++relpp;
	    }
d1888 1
d1890 1
a1890 129
      printf (_("Disassembly of section %s:\n"), section->name);

      datasize = bfd_get_section_size_before_reloc (section);
      if (datasize == 0)
	continue;

      data = (bfd_byte *) xmalloc ((size_t) datasize);

      bfd_get_section_contents (abfd, section, data, 0, datasize);

      aux.sec = section;
      disasm_info.buffer = data;
      disasm_info.buffer_vma = section->vma;
      disasm_info.buffer_length = datasize;
      disasm_info.section = section;

      if (start_address == (bfd_vma) -1
	  || start_address < disasm_info.buffer_vma)
	addr_offset = 0;
      else
	addr_offset = start_address - disasm_info.buffer_vma;

      if (stop_address == (bfd_vma) -1)
	stop_offset = datasize / opb;
      else
	{
	  if (stop_address < disasm_info.buffer_vma)
	    stop_offset = 0;
	  else
	    stop_offset = stop_address - disasm_info.buffer_vma;
	  if (stop_offset > disasm_info.buffer_length / opb)
	    stop_offset = disasm_info.buffer_length / opb;
	}

      sym = find_symbol_for_address (abfd, section, section->vma + addr_offset,
				     TRUE, &place);

      while (addr_offset < stop_offset)
	{
	  asymbol *nextsym;
	  unsigned long nextstop_offset;
	  bfd_boolean insns;

	  if (sym != NULL && bfd_asymbol_value (sym) <= section->vma + addr_offset)
	    {
	      int x;

	      for (x = place;
		   (x < sorted_symcount
		    && bfd_asymbol_value (sorted_syms[x]) <= section->vma + addr_offset);
		   ++x)
		continue;

	      disasm_info.symbols = & sorted_syms[place];
	      disasm_info.num_symbols = x - place;
	    }
	  else
	    disasm_info.symbols = NULL;

	  if (! prefix_addresses)
	    {
	      (* disasm_info.fprintf_func) (disasm_info.stream, "\n");
	      objdump_print_addr_with_sym (abfd, section, sym,
					   section->vma + addr_offset,
					   &disasm_info,
					   FALSE);
	      (* disasm_info.fprintf_func) (disasm_info.stream, ":\n");
	    }

	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    nextsym = sym;
	  else if (sym == NULL)
	    nextsym = NULL;
	  else
	    {
	      /* Search forward for the next appropriate symbol in
                 SECTION.  Note that all the symbols are sorted
                 together into one big array, and that some sections
                 may have overlapping addresses.  */
	      while (place < sorted_symcount
		     && (sorted_syms[place]->section != section
			 || (bfd_asymbol_value (sorted_syms[place])
			     <= bfd_asymbol_value (sym))))
		++place;
	      if (place >= sorted_symcount)
		nextsym = NULL;
	      else
		nextsym = sorted_syms[place];
	    }

	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    {
	      nextstop_offset = bfd_asymbol_value (sym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
	    }
	  else if (nextsym == NULL)
	    nextstop_offset = stop_offset;
	  else
	    {
	      nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
	    }

	  /* If a symbol is explicitly marked as being an object
	     rather than a function, just dump the bytes without
	     disassembling them.  */
	  if (disassemble_all
	      || sym == NULL
	      || bfd_asymbol_value (sym) > section->vma + addr_offset
	      || ((sym->flags & BSF_OBJECT) == 0
		  && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		      == NULL)
		  && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		      == NULL))
	      || (sym->flags & BSF_FUNCTION) != 0)
	    insns = TRUE;
	  else
	    insns = FALSE;

	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data,
			     addr_offset, nextstop_offset, &relpp, relppend);

	  addr_offset = nextstop_offset;
	  sym = nextsym;
	}

      free (data);
d1892 2
a1893 3
      if (relbuf != NULL)
	free (relbuf);
    }
d1897 2
a1898 17
/* Dump the stabs sections from an object file that has a section that
   uses Sun stabs encoding.  */

static void
dump_stabs (abfd)
     bfd *abfd;
{
  dump_section_stabs (abfd, ".stab", ".stabstr");
  dump_section_stabs (abfd, ".stab.excl", ".stab.exclstr");
  dump_section_stabs (abfd, ".stab.index", ".stab.indexstr");
  dump_section_stabs (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
}

/* Read ABFD's stabs section STABSECT_NAME into `stabs'
   and string table section STRSECT_NAME into `strtab'.
   If the section exists and was read, allocate the space and return TRUE.
   Otherwise return FALSE.  */
d1900 2
a1901 5
static bfd_boolean
read_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     const char *stabsect_name;
     const char *strsect_name;
d1903 3
a1905 8
  asection *stabsect, *stabstrsect;

  stabsect = bfd_get_section_by_name (abfd, stabsect_name);
  if (0 == stabsect)
    {
      printf (_("No %s section present\n\n"), stabsect_name);
      return FALSE;
    }
d1907 2
a1908 2
  stabstrsect = bfd_get_section_by_name (abfd, strsect_name);
  if (0 == stabstrsect)
d1910 1
a1910 3
      non_fatal (_("%s has no %s section"),
		 bfd_get_filename (abfd), strsect_name);
      exit_status = 1;
d1914 2
a1915 2
  stab_size    = bfd_section_size (abfd, stabsect);
  stabstr_size = bfd_section_size (abfd, stabstrsect);
d1917 1
a1917 4
  stabs  = (bfd_byte *) xmalloc (stab_size);
  strtab = (char *) xmalloc (stabstr_size);

  if (! bfd_get_section_contents (abfd, stabsect, (PTR) stabs, 0, stab_size))
d1920 1
a1920 1
		 stabsect_name, bfd_get_filename (abfd),
d1922 1
a1922 2
      free (stabs);
      free (strtab);
d1924 1
a1924 1
      return FALSE;
d1927 5
a1931 15
  if (! bfd_get_section_contents (abfd, stabstrsect, (PTR) strtab, 0,
				  stabstr_size))
    {
      non_fatal (_("Reading %s section of %s failed: %s\n"),
		 strsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
      free (stabs);
      free (strtab);
      exit_status = 1;
      return FALSE;
    }

  return TRUE;
}

d1940 5
a1944 5
#define STRDXOFF (0)
#define TYPEOFF (4)
#define OTHEROFF (5)
#define DESCOFF (6)
#define VALOFF (8)
d1951 3
a1953 4
print_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     const char *stabsect_name;
     const char *strsect_name ATTRIBUTE_UNUSED;
d1956 2
a1957 1
  unsigned file_string_table_offset = 0, next_file_string_table_offset = 0;
d2017 8
d2026 1
d2029 1
a2029 4
dump_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     char *stabsect_name;
     char *strsect_name;
d2031 2
a2032 1
  asection *s;
d2035 19
a2053 22
     handle .stab0, etc.  */
  for (s = abfd->sections;
       s != NULL;
       s = s->next)
    {
      int len;

      len = strlen (stabsect_name);

      /* If the prefix matches, and the files section name ends with a
	 nul or a digit, then we match.  I.e., we want either an exact
	 match or a section followed by a number.  */
      if (strncmp (stabsect_name, s->name, len) == 0
	  && (s->name[len] == '\000'
	      || ISDIGIT (s->name[len])))
	{
	  if (read_section_stabs (abfd, s->name, strsect_name))
	    {
	      print_section_stabs (abfd, s->name, strsect_name);
	      free (stabs);
	      free (strtab);
	    }
d2058 25
d2085 1
a2085 2
dump_bfd_header (abfd)
     bfd *abfd;
d2113 1
a2113 2
dump_bfd_private_header (abfd)
bfd *abfd;
d2118 3
a2120 1
/* Dump selected contents of ABFD.  */
d2123 1
a2123 2
dump_bfd (abfd)
     bfd *abfd;
d2125 11
a2135 6
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
    {
      asection *s;
d2137 2
a2138 6
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  s->vma += adjust_section_vma;
	  s->lma += adjust_section_vma;
	}
    }
d2140 5
a2144 34
  printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	  abfd->xvec->name);
  if (dump_ar_hdrs)
    print_arelt_descr (stdout, abfd, TRUE);
  if (dump_file_header)
    dump_bfd_header (abfd);
  if (dump_private_headers)
    dump_bfd_private_header (abfd);
  putchar ('\n');
  if (dump_section_headers)
    dump_headers (abfd);

  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
    syms = slurp_symtab (abfd);
  if (dump_dynamic_symtab || dump_dynamic_reloc_info)
    dynsyms = slurp_dynamic_symtab (abfd);

  if (dump_symtab)
    dump_symbols (abfd, FALSE);
  if (dump_dynamic_symtab)
    dump_symbols (abfd, TRUE);
  if (dump_stab_section_info)
    dump_stabs (abfd);
  if (dump_reloc_info && ! disassemble)
    dump_relocs (abfd);
  if (dump_dynamic_reloc_info)
    dump_dynamic_relocs (abfd);
  if (dump_section_contents)
    dump_data (abfd);
  if (disassemble)
    disassemble_data (abfd);
  if (dump_debugging)
    {
      PTR dhandle;
d2146 1
a2146 11
      dhandle = read_debugging_info (abfd, syms, symcount);
      if (dhandle != NULL)
	{
	  if (! print_debugging_info (stdout, dhandle))
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
	}
    }
d2148 1
a2148 5
  if (syms)
    {
      free (syms);
      syms = NULL;
    }
d2150 1
a2150 6
  if (dynsyms)
    {
      free (dynsyms);
      dynsyms = NULL;
    }
}
d2152 6
a2157 5
static void
display_bfd (abfd)
     bfd *abfd;
{
  char **matching;
d2159 3
a2161 1
  if (bfd_check_format_matches (abfd, bfd_object, &matching))
d2163 4
a2166 3
      dump_bfd (abfd);
      return;
    }
d2168 2
a2169 6
  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
d2172 1
a2172 5
  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }
d2174 40
a2213 5
  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }
d2215 10
a2224 26
  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
display_file (filename, target)
     char *filename;
     char *target;
{
  bfd *file, *arfile = (bfd *) NULL;

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

  if (bfd_check_format (file, bfd_archive))
    {
      bfd *last_arfile = NULL;
d2226 3
a2228 2
      printf (_("In archive %s:\n"), bfd_get_filename (file));
      for (;;)
d2230 4
a2233 15
	  bfd_set_error (bfd_error_no_error);

	  arfile = bfd_openr_next_archived_file (file, arfile);
	  if (arfile == NULL)
	    {
	      if (bfd_get_error () != bfd_error_no_more_archived_files)
		nonfatal (bfd_get_filename (file));
	      break;
	    }

	  display_bfd (arfile);

	  if (last_arfile != NULL)
	    bfd_close (last_arfile);
	  last_arfile = arfile;
d2235 1
a2235 3

      if (last_arfile != NULL)
	bfd_close (last_arfile);
d2237 2
a2238 2
  else
    display_bfd (file);
a2239 3
  bfd_close (file);
}

d2243 1
a2243 2
dump_data (abfd)
     bfd *abfd;
d2245 1
a2245 113
  asection *section;
  bfd_byte *data = 0;
  bfd_size_type datasize = 0;
  bfd_size_type addr_offset;
  bfd_size_type start_offset, stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);

  for (section = abfd->sections; section != NULL; section =
       section->next)
    {
      int onaline = 16;

      if (only == (char *) NULL ||
	  strcmp (only, section->name) == 0)
	{
	  if (section->flags & SEC_HAS_CONTENTS)
	    {
	      char buf[64];
	      int count, width;
	      
	      printf (_("Contents of section %s:\n"), section->name);

	      if (bfd_section_size (abfd, section) == 0)
		continue;
	      data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, section));
	      datasize = bfd_section_size (abfd, section);


	      bfd_get_section_contents (abfd, section, (PTR) data, 0, bfd_section_size (abfd, section));

	      if (start_address == (bfd_vma) -1
		  || start_address < section->vma)
		start_offset = 0;
	      else
		start_offset = start_address - section->vma;
	      if (stop_address == (bfd_vma) -1)
		stop_offset = bfd_section_size (abfd, section) / opb;
	      else
		{
		  if (stop_address < section->vma)
		    stop_offset = 0;
		  else
		    stop_offset = stop_address - section->vma;
		  if (stop_offset > bfd_section_size (abfd, section) / opb)
		    stop_offset = bfd_section_size (abfd, section) / opb;
		}

	      width = 4;

	      bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      for (addr_offset = start_offset;
		   addr_offset < stop_offset; addr_offset += onaline / opb)
		{
		  bfd_size_type j;

		  bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
		  count = strlen (buf);
		  if (count >= sizeof (buf))
		    abort ();
		  putchar (' ');
		  while (count < width)
		    {
		      putchar ('0');
		      count++;
		    }
		  fputs (buf + count - width, stdout);
		  putchar (' ');

		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
		    {
		      if (j < stop_offset * opb)
			printf ("%02x", (unsigned) (data[j]));
		      else
			printf ("  ");
		      if ((j & 3) == 3)
			printf (" ");
		    }

		  printf (" ");
		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
		    {
		      if (j >= stop_offset * opb)
			printf (" ");
		      else
			printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
		    }
		  putchar ('\n');
		}
	      free (data);
	    }
	}
    }
d2251 1
a2251 3
dump_symbols (abfd, dynamic)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean dynamic;
d2275 1
a2275 47
      if (*current)
	{
	  bfd *cur_bfd = bfd_asymbol_bfd (*current);

	  if (cur_bfd != NULL)
	    {
	      const char *name;
	      char *alloc;

	      name = (*current)->name;
	      alloc = NULL;
	      if (do_demangle && name != NULL && *name != '\0')
		{
		  /* If we want to demangle the name, we demangle it
                     here, and temporarily clobber it while calling
                     bfd_print_symbol.  FIXME: This is a gross hack.  */
		  alloc = demangle (cur_bfd, name);
		  (*current)->name = alloc;
		}

	      bfd_print_symbol (cur_bfd, stdout, *current,
				bfd_print_symbol_all);

	      (*current)->name = name;
	      if (alloc != NULL)
		free (alloc);

	      printf ("\n");
	    }
	}
      current++;
    }
  printf ("\n");
  printf ("\n");
}

static void
dump_relocs (abfd)
     bfd *abfd;
{
  arelent **relpp;
  long relcount;
  asection *a;

  for (a = abfd->sections; a != (asection *) NULL; a = a->next)
    {
      long relsize;
d2277 2
a2278 6
      if (bfd_is_abs_section (a))
	continue;
      if (bfd_is_und_section (a))
	continue;
      if (bfd_is_com_section (a))
	continue;
d2280 3
a2282 58
      if (only)
	{
	  if (strcmp (only, a->name))
	    continue;
	}
      else if ((a->flags & SEC_RELOC) == 0)
	continue;

      relsize = bfd_get_reloc_upper_bound (abfd, a);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      printf ("RELOCATION RECORDS FOR [%s]:", a->name);

      if (relsize == 0)
	{
	  printf (" (none)\n\n");
	}
      else
	{
	  relpp = (arelent **) xmalloc (relsize);
	  relcount = bfd_canonicalize_reloc (abfd, a, relpp, syms);

	  if (relcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  else if (relcount == 0)
	    printf (" (none)\n\n");
	  else
	    {
	      printf ("\n");
	      dump_reloc_set (abfd, a, relpp, relcount);
	      printf ("\n\n");
	    }
	  free (relpp);
	}
    }
}

static void
dump_dynamic_relocs (abfd)
     bfd *abfd;
{
  long relsize;
  arelent **relpp;
  long relcount;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("DYNAMIC RELOCATION RECORDS");

  if (relsize == 0)
    printf (" (none)\n\n");
  else
    {
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);
a2283 4
      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
      else if (relcount == 0)
	printf (" (none)\n\n");
d2286 19
a2304 3
	  printf ("\n");
	  dump_reloc_set (abfd, (asection *) NULL, relpp, relcount);
	  printf ("\n\n");
d2306 3
a2308 1
      free (relpp);
d2310 1
d2312 1
a2312 1

d2314 1
a2314 5
dump_reloc_set (abfd, sec, relpp, relcount)
     bfd *abfd;
     asection *sec;
     arelent **relpp;
     long relcount;
d2327 1
d2338 1
a2338 1
  for (p = relpp; relcount && *p != (arelent *) NULL; p++, relcount--)
d2403 1
a2403 2
	  objdump_print_symname (abfd, (struct disassemble_info *) NULL,
				 *q->sym_ptr_ptr);
d2407 1
a2407 1
	  if (section_name == (const char *) NULL)
d2424 275
a2699 2
int main PARAMS ((int, char **));

d2701 1
a2701 3
main (argc, argv)
     int argc;
     char **argv;
d2707 2
a2708 1
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
a2710 1
#if defined (HAVE_SETLOCALE)
d2713 1
d2725 1
a2725 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSj:wE:zgG",
d2737 6
a2742 1
	  disassembler_options = optarg;
d2745 6
a2750 1
	  only = optarg;
d2815 3
d2858 6
@


1.9
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
#include "getopt.h"
d26 3
a28 1
#include <ctype.h>
d41 2
a42 1
extern int fprintf PARAMS ((FILE *, const char *, ...));
d48 1
a48 1
static char *default_target = NULL;	/* default at runtime */
d50 1
a50 1
static int show_version = 0;		/* show the version number */
d53 1
a53 1
static boolean dump_file_header;	/* -f */
d62 1
a62 1
static boolean with_source_code;	/* -S */
d66 2
a67 2
static boolean disassemble;		/* -d */
static boolean disassemble_all;		/* -D */
d69 1
a69 1
static boolean formats_info;		/* -i */
d79 2
a80 1
struct objdump_disasm_info {
d83 1
a83 1
  boolean require_sec;
d113 2
a114 1
/* Static declarations.  */
d116 2
a117 2
static void
usage PARAMS ((FILE *, int));
d119 1
a119 80
static void
nonfatal PARAMS ((const char *));

static void
display_file PARAMS ((char *filename, char *target));

static void
dump_section_header PARAMS ((bfd *, asection *, PTR));

static void
dump_headers PARAMS ((bfd *));

static void
dump_data PARAMS ((bfd *abfd));

static void
dump_relocs PARAMS ((bfd *abfd));

static void
dump_dynamic_relocs PARAMS ((bfd * abfd));

static void
dump_reloc_set PARAMS ((bfd *, asection *, arelent **, long));

static void
dump_symbols PARAMS ((bfd *abfd, boolean dynamic));

static void
dump_bfd_header PARAMS ((bfd *));

static void
dump_bfd_private_header PARAMS ((bfd *));

static void
display_bfd PARAMS ((bfd *abfd));

static void
display_target_list PARAMS ((void));

static void
display_info_table PARAMS ((int, int));

static void
display_target_tables PARAMS ((void));

static void
display_info PARAMS ((void));

static void
objdump_print_value PARAMS ((bfd_vma, struct disassemble_info *, boolean));

static void
objdump_print_symname PARAMS ((bfd *, struct disassemble_info *, asymbol *));

static asymbol *
find_symbol_for_address PARAMS ((bfd *, asection *, bfd_vma, boolean, long *));

static void
objdump_print_addr_with_sym PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
				     struct disassemble_info *, boolean));

static void
objdump_print_addr PARAMS ((bfd_vma, struct disassemble_info *, boolean));

static void
objdump_print_address PARAMS ((bfd_vma, struct disassemble_info *));

static void
show_line PARAMS ((bfd *, asection *, bfd_vma));

static void
disassemble_bytes PARAMS ((struct disassemble_info *, disassembler_ftype,
			   boolean, bfd_byte *, bfd_vma, bfd_vma,
			   arelent ***, arelent **));

static void
disassemble_data PARAMS ((bfd *));

static const char *
endian_string PARAMS ((enum bfd_endian));
d121 68
a188 23
static asymbol **
slurp_symtab PARAMS ((bfd *));

static asymbol **
slurp_dynamic_symtab PARAMS ((bfd *));

static long
remove_useless_symbols PARAMS ((asymbol **, long));

static int
compare_symbols PARAMS ((const PTR, const PTR));

static int
compare_relocs PARAMS ((const PTR, const PTR));

static void
dump_stabs PARAMS ((bfd *));

static boolean
read_section_stabs PARAMS ((bfd *, const char *, const char *));

static void
print_section_stabs PARAMS ((bfd *, const char *, const char *));
d195 3
a197 3
  fprintf (stream, _("Usage: %s OPTION... FILE...\n"), program_name);
  fprintf (stream, _("Display information from object FILE.\n"));
  fprintf (stream, _("\n At least one of the following switches must be given:\n"));
d214 1
a214 1
  -V, --version            Display this program's version number\n\
d231 3
a233 2
                                  The STYLE, if specified, can be `auto', 'gnu',\n\
                                  'lucid', 'arm', 'hp', 'edg', or 'gnu-new-abi'\n\
d236 2
a237 2
      --start-address=ADDR       Only process data whoes address is >= ADDR\n\
      --stop-address=ADDR        Only process data whoes address is <= ADDR\n\
d243 1
d319 1
a319 1
  printf_vma (bfd_get_section_vma (abfd, section));
d321 2
a322 2
  printf_vma (section->lma);
  printf ("  %08lx  2**%u", section->filepos,
a333 3
  PF (SEC_CONSTRUCTOR_TEXT, "CONSTRUCTOR TEXT");
  PF (SEC_CONSTRUCTOR_DATA, "CONSTRUCTOR DATA");
  PF (SEC_CONSTRUCTOR_BSS, "CONSTRUCTOR BSS");
a335 3
#ifdef SEC_BALIGN
  PF (SEC_BALIGN, "BALIGN");
#endif
d348 2
d394 5
a398 1
  printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
d403 2
a418 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d426 2
a428 4
  if (storage)
    {
      sy = (asymbol **) xmalloc (storage);
    }
a431 2
  if (symcount == 0)
    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d456 2
a458 4
  if (storage)
    {
      sy = (asymbol **) xmalloc (storage);
    }
a461 2
  if (dynsymcount == 0)
    non_fatal (_("%s: No dynamic symbols"), bfd_get_filename (abfd));
d467 1
a467 1
   Return the number of useful symbols. */
d495 1
a495 1
static int 
d504 1
a504 1
  boolean af, bf;
a523 1

d625 1
a625 1
/* Print VMA to STREAM.  If SKIP_ZEROES is true, omit leading zeroes.  */
d631 1
a631 1
     boolean skip_zeroes;
d635 2
d638 1
a638 1
  sprintf_vma (buf, vma);
a660 1
  const char *print;
d664 1
a664 3
  if (! do_demangle || name[0] == '\0')
    print = name;
  else
d667 2
a668 8
      if (bfd_get_symbol_leading_char (abfd) == name[0])
	++name;

      alloc = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (alloc == NULL)
	print = name;
      else
	print = alloc;
d672 1
a672 1
    (*info->fprintf_func) (info->stream, "%s", print);
d674 1
a674 1
    printf ("%s", print);
d681 1
a681 1
   is true, then always require the symbol to be in the section.  This
d690 1
a690 1
     boolean require_sec;
d702 1
a702 1
  unsigned int opb = bfd_octets_per_byte (abfd); 
d739 1
a739 1
       
a743 1

d759 1
d761 1
d816 1
a816 1
     boolean skip_zeroes;
d830 1
a830 1
	  objdump_print_value (secaddr - vma, info, true);
d835 1
a835 1
	  objdump_print_value (vma - secaddr, info, true);
d846 1
a846 1
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, true);
d851 1
a851 1
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, true);
d858 1
a858 1
   true, don't output leading zeroes.  */
d864 1
a864 1
     boolean skip_zeroes;
d943 2
a944 2
static void
skip_to_line PARAMS ((struct print_file_list *, unsigned int, boolean));
d950 1
a950 1
     boolean show;
d969 1
a969 1
}  
d980 2
a981 2
  CONST char *filename;
  CONST char *functionname;
d1049 1
a1049 1
		skip_to_line (p, l, false);
d1060 1
a1060 1
	      skip_to_line (p, line, true);
d1090 4
a1093 4
              if (file_start_context)
                l = 0;
              else
                l = line - SHOW_PRECEDING_CONTEXT_LINES;
d1096 1
a1096 1
	      skip_to_line (p, l, false);
d1098 1
a1098 1
		skip_to_line (p, line, true);
d1128 1
a1128 6
#ifdef ANSI_PROTOTYPES
objdump_sprintf (SFILE *f, const char *format, ...)
#else
objdump_sprintf (va_alist)
     va_dcl
#endif
a1129 4
#ifndef ANSI_PROTOTYPES
  SFILE *f;
  const char *format;
#endif
a1130 1
  va_list args;
d1133 3
a1135 7
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
  va_start (args);
  f = va_arg (args, SFILE *);
  format = va_arg (args, const char *);
#endif
a1138 2
  va_end (args);

d1141 1
d1163 1
d1170 1
d1172 1
d1181 1
d1183 1
d1188 2
a1189 2
disassemble_bytes (info, disassemble_fn, insns, data, 
                   start_offset, stop_offset, relppp,
d1193 1
a1193 1
     boolean insns;
d1203 1
a1203 1
  boolean done_dot;
d1226 4
a1229 2
      sprintf_vma (buf, section->vma + 
                   bfd_section_size (section->owner, section) / opb);
d1241 1
a1241 1
  done_dot = false;
d1247 1
a1247 1
      boolean need_nl = false;
d1258 2
a1259 2
	      || (z == stop_offset * opb && 
                  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
d1279 1
a1279 1
	  done_dot = false;
d1282 4
a1285 1
	    show_line (aux->abfd, section, addr_offset);
d1291 1
a1291 1
	      sprintf_vma (buf, section->vma + addr_offset);
d1300 1
a1300 1
	      aux->require_sec = true;
d1302 1
a1302 1
	      aux->require_sec = false;
d1350 1
a1350 1
		  if (isprint (data[j]))
d1428 1
a1428 1
		  sprintf_vma (buf, section->vma + j / opb);
d1461 1
a1461 1
	    need_nl = true;
d1465 2
a1466 2
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
  	  && dump_reloc_info
d1488 1
a1488 1
	      objdump_print_value (section->vma + q->address, info, true);
d1516 1
a1516 1
		  objdump_print_value (q->addend, info, true);
d1520 1
a1520 1
	      need_nl = false;
d1556 1
a1556 1
  /* Sort the symbols into section and symbol order */
d1559 2
a1560 1
  INIT_DISASSEMBLE_INFO(disasm_info, stdout, fprintf);
d1563 1
a1563 1
  aux.require_sec = false;
d1570 1
d1572 2
a1573 3
	{
	  fatal (_("Can't use supplied machine %s"), machine);
	}
d1603 1
a1603 1
  
d1635 1
a1635 1
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
d1638 1
a1638 1
	  ) 
d1664 3
a1666 5
		{
		  while (relpp < relppend
			 && (*relpp)->address < start_address)
		    ++relpp;
		}
d1684 2
d1691 1
d1705 1
a1705 1
				     true, &place);
d1711 2
a1712 2
	  boolean insns;
	  
d1722 1
d1731 1
a1731 1
	      printf ("\n");
d1735 2
a1736 2
					   false);
	      printf (":\n");
d1738 1
a1738 1
	  
d1759 1
a1759 1
	  
d1774 1
a1774 1
	  
d1787 1
a1787 1
	    insns = true;
d1789 5
a1793 5
	    insns = false;
	  
	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data, 
                             addr_offset, nextstop_offset, &relpp, relppend);
	  
d1797 1
a1797 1
      
d1799 1
a1805 8

/* Define a table of stab values and print-strings.  We wish the initializer
   could be a direct-mapped table, but instead we build one the first
   time we need it.  */

static void dump_section_stabs PARAMS ((bfd *abfd, char *stabsect_name,
					char *strsect_name));

a1818 6
static bfd_byte *stabs;
static bfd_size_type stab_size;

static char *strtab;
static bfd_size_type stabstr_size;

d1821 2
a1822 2
   If the section exists and was read, allocate the space and return true.
   Otherwise return false.  */
d1824 1
a1824 1
static boolean
d1836 1
a1836 1
      return false;
d1845 1
a1845 1
      return false;
d1847 1
a1847 1
 
d1853 1
a1853 1
  
d1862 1
a1862 1
      return false;
d1874 1
a1874 1
      return false;
d1877 1
a1877 1
  return true;
a1917 1

d1934 1
a1934 1
	 again (makes consistent formatting for tools like awk). */
d1943 1
a1943 1
      printf_vma (value);
a1948 1

a1957 1

d1990 1
a1990 1
	      || isdigit ((unsigned char) s->name[len])))
d2001 1
d2025 1
d2027 1
a2027 1
  printf_vma (abfd->start_address);
d2030 1
d2039 1
a2039 1
/* Dump selected contents of ABFD */
d2062 1
a2062 1
    print_arelt_descr (stdout, abfd, true);
d2070 1
d2072 1
a2072 3
    {
      syms = slurp_symtab (abfd);
    }
d2074 2
a2075 3
    {
      dynsyms = slurp_dynamic_symtab (abfd);
    }
d2077 1
a2077 1
    dump_symbols (abfd, false);
d2079 1
a2079 1
    dump_symbols (abfd, true);
d2105 1
d2111 1
d2174 1
a2174 1
  if (bfd_check_format (file, bfd_archive) == true)
d2207 1
a2207 1
/* Actually display the various requested regions */
d2230 3
d2259 25
a2283 2
	      for (addr_offset = start_offset; 
                   addr_offset < stop_offset; addr_offset += onaline)
d2287 15
a2301 4
		  printf (" %04lx ", (unsigned long int) 
                          (addr_offset + section->vma));
		  for (j = addr_offset * opb; 
                       j < addr_offset * opb + onaline; j++)
d2312 2
a2313 1
		  for (j = addr_offset; j < addr_offset * opb + onaline; j++)
d2318 1
a2318 1
			printf ("%c", isprint (data[j]) ? data[j] : '.');
d2328 2
a2329 1
/* Should perhaps share code and display with nm? */
d2333 1
a2333 1
     boolean dynamic;
a2342 2
      if (max == 0)
	return;
a2348 2
      if (max == 0)
	return;
d2352 3
d2366 1
a2366 1
	      name = bfd_asymbol_name (*current);
a2369 2
		  const char *n;

d2373 2
a2374 9

		  n = name;
		  if (bfd_get_symbol_leading_char (cur_bfd) == *n)
		    ++n;
		  alloc = cplus_demangle (n, DMGL_ANSI | DMGL_PARAMS);
		  if (alloc != NULL)
		    (*current)->name = alloc;
		  else
		    (*current)->name = n;
d2434 1
d2438 1
a2438 3
	    {
	      printf (" (none)\n\n");
	    }
d2465 1
a2465 3
    {
      printf (" (none)\n\n");
    }
d2470 1
d2474 1
a2474 3
	{
	  printf (" (none)\n\n");
	}
d2499 1
d2503 1
a2503 1
	sprintf_vma (buf, (bfd_vma) -1);
d2542 1
d2570 1
d2573 1
a2573 1
	  printf_vma (q->address);
d2583 1
a2583 1
	  if (section_name == (CONST char *) NULL)
d2585 1
a2585 1
	  printf_vma (q->address);
d2590 1
d2594 1
a2594 1
	  printf_vma (q->addend);
d2596 1
d2601 1
a2601 176
/* The length of the longest architecture name + 1.  */
#define LONGEST_ARCH sizeof("powerpc:common")

static const char *
endian_string (endian)
     enum bfd_endian endian;
{
  if (endian == BFD_ENDIAN_BIG)
    return "big endian";
  else if (endian == BFD_ENDIAN_LITTLE)
    return "little endian";
  else
    return "endianness unknown";
}

/* List the targets that BFD is configured to support, each followed
   by its endianness and the architectures it supports.  */

static void
display_target_list ()
{
  extern const bfd_target *const *bfd_target_vector;
  char *dummy_name;
  int t;

  dummy_name = make_temp_file (NULL);
  for (t = 0; bfd_target_vector[t]; t++)
    {
      const bfd_target *p = bfd_target_vector[t];
      bfd *abfd = bfd_openw (dummy_name, p->name);
      int a;

      printf ("%s\n (header %s, data %s)\n", p->name,
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));

      if (abfd == NULL)
	{
	  nonfatal (dummy_name);
	  continue;
	}

      if (! bfd_set_format (abfd, bfd_object))
	{
	  if (bfd_get_error () != bfd_error_invalid_operation)
	    nonfatal (p->name);
	  bfd_close_all_done (abfd);
	  continue;
	}

      for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
	if (bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
	  printf ("  %s\n",
		  bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
      bfd_close_all_done (abfd);
    }
  unlink (dummy_name);
  free (dummy_name);
}

/* Print a table showing which architectures are supported for entries
   FIRST through LAST-1 of bfd_target_vector (targets across,
   architectures down).  */

static void
display_info_table (first, last)
     int first;
     int last;
{
  extern const bfd_target *const *bfd_target_vector;
  int t, a;
  char *dummy_name;

  /* Print heading of target names.  */
  printf ("\n%*s", (int) LONGEST_ARCH, " ");
  for (t = first; t < last && bfd_target_vector[t]; t++)
    printf ("%s ", bfd_target_vector[t]->name);
  putchar ('\n');

  dummy_name = make_temp_file (NULL);
  for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
    if (strcmp (bfd_printable_arch_mach (a, 0), "UNKNOWN!") != 0)
      {
	printf ("%*s ", (int) LONGEST_ARCH - 1,
		bfd_printable_arch_mach (a, 0));
	for (t = first; t < last && bfd_target_vector[t]; t++)
	  {
	    const bfd_target *p = bfd_target_vector[t];
	    boolean ok = true;
	    bfd *abfd = bfd_openw (dummy_name, p->name);

	    if (abfd == NULL)
	      {
		nonfatal (p->name);
		ok = false;
	      }

	    if (ok)
	      {
		if (! bfd_set_format (abfd, bfd_object))
		  {
		    if (bfd_get_error () != bfd_error_invalid_operation)
		      nonfatal (p->name);
		    ok = false;
		  }
	      }

	    if (ok)
	      {
		if (! bfd_set_arch_mach (abfd, a, 0))
		  ok = false;
	      }

	    if (ok)
	      printf ("%s ", p->name);
	    else
	      {
		int l = strlen (p->name);
		while (l--)
		  putchar ('-');
		putchar (' ');
	      }
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
	  }
	putchar ('\n');
      }
  unlink (dummy_name);
  free (dummy_name);
}

/* Print tables of all the target-architecture combinations that
   BFD has been configured to support.  */

static void
display_target_tables ()
{
  int t, columns;
  extern const bfd_target *const *bfd_target_vector;
  char *colum;

  columns = 0;
  colum = getenv ("COLUMNS");
  if (colum != NULL)
    columns = atoi (colum);
  if (columns == 0)
    columns = 80;

  t = 0;
  while (bfd_target_vector[t] != NULL)
    {
      int oldt = t, wid;

      wid = LONGEST_ARCH + strlen (bfd_target_vector[t]->name) + 1;
      ++t;
      while (wid < columns && bfd_target_vector[t] != NULL)
	{
	  int newwid;

	  newwid = wid + strlen (bfd_target_vector[t]->name) + 1;
	  if (newwid >= columns)
	    break;
	  wid = newwid;
	  ++t;
	}
      display_info_table (oldt, t);
    }
}

static void
display_info ()
{
  printf (_("BFD header file version %s\n"), BFD_VERSION);
  display_target_list ();
  display_target_tables ();
}
d2610 1
a2610 1
  boolean seenflag = false;
d2615 3
d2629 1
a2629 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VCdDlfahHrRtTxsSj:wE:zgG",
d2636 1
a2636 1
	  break;		/* we've been given a long option */
d2647 1
a2647 1
	  with_line_numbers = true;
d2653 1
a2653 1
	  do_demangle = true;
d2657 1
a2657 1
	      
d2659 1
a2659 1
	      if (style == unknown_demangling) 
d2662 1
a2662 1
	      
d2664 1
a2664 1
           }
d2667 1
a2667 1
	  wide_output = true;
d2700 1
a2700 1
	  
d2702 2
a2703 2
	  dump_file_header = true;
	  seenflag = true;
d2706 2
a2707 2
	  formats_info = true;
	  seenflag = true;
d2710 2
a2711 2
	  dump_private_headers = true;
	  seenflag = true;
d2714 7
a2720 7
	  dump_private_headers = true;
	  dump_symtab = true;
	  dump_reloc_info = true;
	  dump_file_header = true;
	  dump_ar_hdrs = true;
	  dump_section_headers = true;
	  seenflag = true;
d2723 2
a2724 2
	  dump_symtab = true;
	  seenflag = true;
d2727 2
a2728 2
	  dump_dynamic_symtab = true;
	  seenflag = true;
d2731 2
a2732 2
	  disassemble = true;
	  seenflag = true;
d2735 1
a2735 1
	  disassemble_zeroes = true;
d2738 3
a2740 3
	  disassemble = true;
	  disassemble_all = true;
	  seenflag = true;
d2743 3
a2745 3
	  disassemble = true;
	  with_source_code = true;
	  seenflag = true;
d2749 1
a2749 1
	  seenflag = true;
d2752 2
a2753 2
	  dump_stab_section_info = true;
	  seenflag = true;
d2756 2
a2757 2
	  dump_section_contents = true;
	  seenflag = true;
d2760 2
a2761 2
	  dump_reloc_info = true;
	  seenflag = true;
d2764 2
a2765 2
	  dump_dynamic_reloc_info = true;
	  seenflag = true;
d2768 2
a2769 2
	  dump_ar_hdrs = true;
	  seenflag = true;
d2772 2
a2773 2
	  dump_section_headers = true;
	  seenflag = true;
d2777 2
a2778 1
	  seenflag = true;
d2780 2
a2781 2
	  show_version = true;
	  seenflag = true;
d2783 1
a2783 1
	  
d2792 1
a2792 1
  if (seenflag == false)
d2796 1
a2796 1
    display_info ();
@


1.8
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d259 3
a261 1
  -C, --demangle                 Decode mangled/processed symbol names\n\
d294 1
a294 1
  {"demangle", no_argument, NULL, 'C'},
d377 2
d1362 1
d1367 1
a1367 1
		  && (**relppp)->address < addr_offset + octets / opb)
d1370 1
d1510 5
a1514 2
      if (dump_reloc_info
	  && (section->flags & SEC_RELOC) != 0)
d1519 5
d1679 5
a1683 2
      if (dump_reloc_info
	  && (section->flags & SEC_RELOC) != 0)
d2648 1
a2648 1
  extern bfd_target *bfd_target_vector[];
d2655 1
a2655 1
      bfd_target *p = bfd_target_vector[t];
d2696 1
a2696 1
  extern bfd_target *bfd_target_vector[];
d2714 1
a2714 1
	    bfd_target *p = bfd_target_vector[t];
d2765 1
a2765 1
  extern bfd_target *bfd_target_vector[];
d2852 11
@


1.7
log
@Avoid calls to insecure choose_temp_base
@
text
@d223 3
a225 2
  fprintf (stream, _("Usage: %s <switches> file(s)\n"), program_name);
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
d227 18
a244 18
  -a  --archive-headers    Display archive header information\n\
  -f  --file-headers       Display the contents of the overall file header\n\
  -p  --private-headers    Display object format specific file header contents\n\
  -h  --[section-]headers  Display the contents of the section headers\n\
  -x  --all-headers        Display the contents of all headers\n\
  -d  --disassemble        Display assembler contents of executable sections\n\
  -D  --disassemble-all    Display assembler contents of all sections\n\
  -S  --source             Intermix source code with disassembly\n\
  -s  --full-contents      Display the full contents of all sections requested\n\
  -g  --debugging          Display debug information in object file\n\
  -G  --stabs              Display the STABS contents of an ELF format file\n\
  -t  --syms               Display the contents of the symbol table(s)\n\
  -T  --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r  --reloc              Display the relocation entries in the file\n\
  -R  --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -V  --version            Display this program's version number\n\
  -i  --info               List object formats and architectures supported\n\
  -H  --help               Display this information\n\
d250 4
a253 4
  -b  --target <bfdname>         Specify the target object format as <bfdname>\n\
  -m  --architecture <machine>   Specify the target architecture as <machine>\n\
  -j  --section <name>           Only display information for section <name>\n\
  -M  --disassembler-options <o> Pass text <o> on to the disassembler\n\
d257 6
a262 6
  -l  --line-numbers             Include line numbers and filenames in output\n\
  -C  --demangle                 Decode mangled/processed symbol names\n\
  -w  --wide                     Format output for more than 80 columns\n\
  -z  --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address <addr>     Only process data whoes address is >= <addr>\n\
      --stop-address <addr>      Only process data whoes address is <= <addr>\n\
d265 1
a265 1
      --adjust-vma <offset>      Add <offset> to all displayed section addresses\n\
d268 1
a268 1
      
d272 1
a272 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d2610 1
a2610 1
#define LONGEST_ARCH sizeof("rs6000:6000")
@


1.6
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2633 1
a2633 1
  dummy_name = choose_temp_base ();
d2687 1
a2687 1
  dummy_name = choose_temp_base ();
@


1.5
log
@Kill remaining instances of mktemp, direct and indirect.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d28 1
a31 6
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

d41 3
d61 1
d64 1
d71 2
d84 3
d108 7
a114 1
/* Forward declarations.  */
d120 6
d141 6
d150 16
a165 1
objdump_print_value PARAMS ((bfd_vma, struct disassemble_info *));
d172 4
a175 1
				     struct disassemble_info *));
d185 2
a186 2
			   boolean, bfd_byte *, long, long, arelent ***,
			   arelent **));
d193 24
d223 47
a269 15
  fprintf (stream, "\
Usage: %s [-ahifdDprRtTxsSlw] [-b bfdname] [-m machine] [-j section-name]\n\
       [--archive-headers] [--target=bfdname] [--debugging] [--disassemble]\n\
       [--disassemble-all] [--file-headers] [--section-headers] [--headers]\n\
       [--info] [--section=section-name] [--line-numbers] [--source]\n",
	   program_name);
  fprintf (stream, "\
       [--architecture=machine] [--reloc] [--full-contents] [--stabs]\n\
       [--syms] [--all-headers] [--dynamic-syms] [--dynamic-reloc]\n\
       [--wide] [--version] [--help] [--private-headers]\n\
       [--start-address=addr] [--stop-address=addr]\n\
       [--prefix-addresses] [--show-raw-insn]\n\
       [-EB|-EL] [--endian={big|little}] objfile...\n\
at least one option besides -l (--line-numbers) must be given\n");
  list_supported_targets (program_name, stream);
d271 1
a271 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d280 1
d284 1
d289 2
a290 1
  {"debugging", no_argument, &dump_debugging, 1},
d293 2
d299 1
d305 1
d312 1
a312 1
  {"stabs", no_argument, &dump_stab_section_info, 1},
d317 2
a318 2
  {"version", no_argument, &show_version, 1},
  {"wide", no_argument, &wide_output, 'w'},
d323 8
d332 1
a332 1
     bfd *abfd;
d334 1
a334 1
     PTR ignored;
d337 1
d341 1
a341 1
	  (unsigned long) bfd_section_size (abfd, section));
d373 2
d398 5
d414 2
a415 1
  printf ("Sections:\n");
d417 1
a417 1
  printf ("Idx Name          Size      VMA       LMA       File off  Algn\n");
d419 1
a419 1
  printf ("Idx Name          Size      VMA               LMA               File off  Algn\n");
d421 5
d438 1
a438 1
      printf ("No symbols in \"%s\".\n", bfd_get_filename (abfd));
d455 1
a455 2
    fprintf (stderr, "%s: %s: No symbols\n",
	     program_name, bfd_get_filename (abfd));
d473 1
a473 2
	  fprintf (stderr, "%s: %s: not a dynamic object\n",
		   program_name, bfd_get_filename (abfd));
d489 1
a489 2
    fprintf (stderr, "%s: %s: No dynamic symbols\n",
	     program_name, bfd_get_filename (abfd));
d654 1
a654 1
/* Print VMA to STREAM with no leading zeroes.  */
d657 1
a657 1
objdump_print_value (vma, info)
d660 1
d666 9
a674 4
  for (p = buf; *p == '0'; ++p)
    ;
  if (*p == '\0')
    --p;
d678 38
d738 1
d786 1
a786 1
			+ bfd_section_size (abfd, sec)))))
d845 1
a845 1
objdump_print_addr_with_sym (abfd, sec, sym, vma, info)
d851 1
d853 1
a853 4
  char buf[30];

  sprintf_vma (buf, vma);
  (*info->fprintf_func) (info->stream, "%s", buf);
d864 2
a865 2
	  (*info->fprintf_func) (info->stream, "-");
	  objdump_print_value (secaddr - vma, info);
d869 2
a870 2
	  (*info->fprintf_func) (info->stream, "+");
	  objdump_print_value (vma - secaddr, info);
d876 2
a877 1
      (*info->fprintf_func) (info->stream, " <%s", sym->name);
d880 2
a881 2
	  (*info->fprintf_func) (info->stream, "-");
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info);
d885 2
a886 2
	  (*info->fprintf_func) (info->stream, "+");
	  objdump_print_value (vma - bfd_asymbol_value (sym), info);
d892 2
a893 1
/* Print VMA symbolically to INFO if possible.  */
d896 1
a896 1
objdump_print_address (vma, info)
d899 1
d906 2
a907 4
      char buf[30];

      sprintf_vma (buf, vma);
      (*info->fprintf_func) (info->stream, "%s", buf);
d914 34
a947 1
  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, info);
d1010 1
a1010 1
show_line (abfd, section, off)
d1013 1
a1013 1
     bfd_vma off;
d1022 1
a1022 1
  if (! bfd_find_nearest_line (abfd, section, syms, off, &filename,
d1074 2
a1075 2
		  if (l <= 0)
		    l = 1;
d1125 6
a1130 3
	      l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l <= 0)
		l = 1;
d1153 2
a1154 1
typedef struct {
d1156 1
d1162 1
a1163 1
static int
a1164 10
{
  int n;
  va_list args;

  va_start (args, format);
  vsprintf (f->current, format, args);
  f->current += n = strlen (f->current);
  va_end (args);
  return n;
}
a1165 1
static int
d1168 1
d1170 1
a1170 1
  int n;
d1173 2
d1176 1
d1178 3
d1184 4
a1187 2
  vsprintf (f->current, format, args);
  f->current += n = strlen (f->current);
d1189 24
a1214 1
#endif
d1233 2
a1234 1
disassemble_bytes (info, disassemble_fn, insns, data, start, stop, relppp,
d1240 2
a1241 2
     long start;
     long stop;
d1247 1
a1247 1
  int bytes_per_line;
d1249 3
a1251 1
  long i;
d1257 1
a1257 1
    bytes_per_line = 4;
d1259 24
a1282 1
    bytes_per_line = 16;
d1285 2
a1286 2
  i = start;
  while (i < stop)
d1288 2
a1289 2
      long z;
      int bytes;
d1292 1
a1292 1
      /* If we see more than SKIP_ZEROES bytes of zeroes, we just
d1294 1
a1294 1
      for (z = i; z < stop; z++)
d1297 6
a1302 2
      if (z - i >= SKIP_ZEROES
	  || (z == stop && z - i < SKIP_ZEROES_AT_END))
d1306 1
a1306 1
	  /* If there are more nonzero bytes to follow, we only skip
d1310 2
a1311 2
	  if (z != stop)
	    z = i + ((z - i) &~ 3);
d1313 1
a1313 1
	  bytes = z - i;
d1317 1
a1317 1
	  char buf[1000];
d1319 1
d1325 1
a1325 1
	    show_line (aux->abfd, section, i);
d1328 10
a1337 1
	    printf ("%6lx:\t", (unsigned long) (i - start));
d1341 1
a1341 1
	      objdump_print_address (section->vma + i, info);
d1348 3
a1350 1
	      sfile.buffer = sfile.current = buf;
d1354 12
a1365 1
	      bytes = (*disassemble_fn) (section->vma + i, info);
d1369 8
a1376 3
		bytes_per_line = info->bytes_per_line;
	      if (bytes < 0)
		break;
d1380 1
a1380 1
	      long j;
d1382 3
a1384 3
	      bytes = bytes_per_line;
	      if (i + bytes > stop)
		bytes = stop - i;
d1386 1
a1386 1
	      for (j = i; j < i + bytes; ++j)
d1389 1
a1389 1
		    buf[j - i] = data[j];
d1391 1
a1391 1
		    buf[j - i] = '.';
d1393 1
a1393 1
	      buf[j - i] = '\0';
d1396 3
a1398 1
	  if (! prefix_addresses || show_raw_insn)
d1400 1
a1400 1
	      long j;
d1403 26
a1428 4
                 four bytes per line.  */
	      pb = bytes;
	      if (pb > bytes_per_line && ! prefix_addresses && ! wide_output)
		pb = bytes_per_line;
d1430 1
a1430 1
	      for (j = i; j < i + pb; ++j)
d1432 4
a1435 1
		  printf ("%02x", (unsigned) data[j]);
a1438 3
	      for (; pb < bytes_per_line; ++pb)
		printf ("   ");

d1446 7
a1452 1
	  printf ("%s", buf);
d1454 3
a1456 1
	  if (! prefix_addresses || show_raw_insn)
d1458 1
a1458 1
	      while (pb < bytes)
d1460 2
a1461 1
		  long j;
d1464 13
a1476 6
		  j = i + pb;
		  printf ("%6lx:\t", (unsigned long) (j - start));
		  pb += bytes_per_line;
		  if (pb > bytes)
		    pb = bytes;
		  for (; j < i + pb; ++j)
d1478 14
a1491 2
		      printf ("%02x", (unsigned) data[j]);
		      putchar (' ');
d1506 2
a1507 2
		 && ((**relppp)->address >= (bfd_vma) i
		     && (**relppp)->address < (bfd_vma) i + bytes))
a1509 1
	      const char *sym_name;
d1518 1
a1518 1
	      objdump_print_value (section->vma + q->address - start, info);
d1522 3
a1524 2
	      if (q->sym_ptr_ptr != NULL
		  && *q->sym_ptr_ptr != NULL)
d1526 2
d1529 3
a1531 1
		  if (sym_name == NULL || *sym_name == '\0')
d1536 1
a1536 1
		      sym_name = bfd_get_section_name (abfd, sym_sec);
d1539 1
a1541 4
	      else
		sym_name = "*unknown*";

	      printf ("%s", sym_name);
d1546 1
a1546 1
		  objdump_print_value (q->addend, info);
d1558 1
a1558 1
      i += bytes;
d1568 1
a1568 1
  long i;
d1573 1
d1592 1
d1594 1
d1601 1
a1601 4
	  fprintf (stderr, "%s: Can't use supplied machine %s\n",
		   program_name,
		   machine);
	  exit (1);
d1619 4
a1622 4
      fprintf (stderr, "%s: Can't disassemble for architecture %s\n",
	       program_name,
	       bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
      exit (1);
d1625 2
d1630 3
d1634 1
a1634 1
    disasm_info.endian = BFD_ENDIAN_BIG;
d1636 1
a1636 1
    disasm_info.endian = BFD_ENDIAN_LITTLE;
d1651 3
a1653 1
      long stop;
d1686 9
d1698 1
a1698 1
      printf ("Disassembly of section %s:\n", section->name);
d1714 1
a1714 1
	i = 0;
d1716 1
a1716 1
	i = start_address - disasm_info.buffer_vma;
d1718 1
a1718 1
	stop = datasize;
d1722 1
a1722 1
	    stop = 0;
d1724 3
a1726 3
	    stop = stop_address - disasm_info.buffer_vma;
	  if (stop > disasm_info.buffer_length)
	    stop = disasm_info.buffer_length;
d1729 4
a1732 4
      if (prefix_addresses)
	disassemble_bytes (&disasm_info, disassemble_fn, true, data, i, stop,
			   &relpp, relppend);
      else
d1734 7
a1740 2
	  asymbol *sym;
	  long place;
d1742 10
a1751 9
	  sym = find_symbol_for_address (abfd, section, i, true, &place);
	  ++place;
	  while (i < stop)
	    {
	      asymbol *nextsym;
	      long nextstop;
	      boolean insns;

	      disasm_info.symbol = sym;
d1753 2
d1757 3
a1759 2
					   section->vma + i,
					   &disasm_info);
d1761 18
a1778 2

	      if (sym == NULL)
d1781 8
a1788 40
		{
		  while (place < sorted_symcount
			 && (sorted_syms[place]->section != section
			     || (bfd_asymbol_value (sorted_syms[place])
				 <= bfd_asymbol_value (sym))))
		    ++place;
		  if (place >= sorted_symcount)
		    nextsym = NULL;
		  else
		    nextsym = sorted_syms[place];
		}

	      if (nextsym == NULL)
		nextstop = stop;
	      else
		{
		  nextstop = bfd_asymbol_value (nextsym) - section->vma;
		  if (nextstop > stop)
		    nextstop = stop;
		}

	      /* If a symbol is explicitly marked as being an object
                 rather than a function, just dump the bytes without
                 disassembling them.  */
	      if (disassemble_all
		  || ((sym->flags & BSF_OBJECT) == 0
		      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
			  == NULL)
		      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
			  == NULL))
		  || (sym->flags & BSF_FUNCTION) != 0)
		insns = true;
	      else
		insns = false;

	      disassemble_bytes (&disasm_info, disassemble_fn, insns, data, i,
				 nextstop, &relpp, relppend);

	      i = nextstop;
	      sym = nextsym;
d1790 30
d1821 1
a1821 1

d1864 2
a1865 2
     char *stabsect_name;
     char *strsect_name;
d1872 1
a1872 1
      printf ("No %s section present\n\n", stabsect_name);
d1879 3
a1881 2
      fprintf (stderr, "%s: %s has no %s section\n", program_name,
	       bfd_get_filename (abfd), strsect_name);
d1893 3
a1895 3
      fprintf (stderr, "%s: Reading %s section of %s failed: %s\n",
	       program_name, stabsect_name, bfd_get_filename (abfd),
	       bfd_errmsg (bfd_get_error ()));
d1898 1
d1905 3
a1907 3
      fprintf (stderr, "%s: Reading %s section of %s failed: %s\n",
	       program_name, strsect_name, bfd_get_filename (abfd),
	       bfd_errmsg (bfd_get_error ()));
d1910 1
d1938 2
a1939 2
     char *stabsect_name;
     char *strsect_name;
d1948 1
a1948 1
  printf ("Contents of %s section:\n\n", stabsect_name);
d2025 3
a2027 3
/* If the prefix matches, and the files section name ends with a nul or a digit,
   then we match.  Ie: we want either an exact match or a a section followed by 
   a number.  */
d2029 2
a2030 1
	  && (s->name[len] == '\000' || isdigit (s->name[len])))
d2048 1
a2048 1
  printf ("architecture: %s, ",
d2051 1
a2051 1
  printf ("flags 0x%08x:\n", abfd->flags);
d2064 1
a2064 1
  printf ("\nstart address 0x");
d2076 2
d2079 1
a2079 1
display_bfd (abfd)
d2082 6
a2087 1
  char **matching;
d2089 1
a2089 4
  if (!bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (bfd_get_filename (abfd));
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
d2091 2
a2092 2
	  list_matching_formats (matching);
	  free (matching);
a2093 1
      return;
d2096 1
a2096 1
  printf ("\n%s:     file format %s\n", bfd_get_filename (abfd),
d2137 5
a2141 2
	    fprintf (stderr, "%s: printing debugging information failed\n",
		     bfd_get_filename (abfd));
d2157 41
d2207 1
a2207 1
      bfd_nonfatal (filename);
d2215 1
a2215 1
      printf ("In archive %s:\n", bfd_get_filename (file));
d2224 1
a2224 3
		{
		  bfd_nonfatal (bfd_get_filename (file));
		}
d2253 3
a2255 2
  bfd_size_type i;
  bfd_size_type start, stop;
d2267 1
a2267 1
	      printf ("Contents of section %s:\n", section->name);
d2279 1
a2279 1
		start = 0;
d2281 1
a2281 1
		start = start_address - section->vma;
d2283 1
a2283 1
		stop = bfd_section_size (abfd, section);
d2287 1
a2287 1
		    stop = 0;
d2289 3
a2291 3
		    stop = stop_address - section->vma;
		  if (stop > bfd_section_size (abfd, section))
		    stop = bfd_section_size (abfd, section);
d2293 2
a2294 1
	      for (i = start; i < stop; i += onaline)
d2298 4
a2301 2
		  printf (" %04lx ", (unsigned long int) (i + section->vma));
		  for (j = i; j < i + onaline; j++)
d2303 1
a2303 1
		      if (j < stop)
d2312 1
a2312 1
		  for (j = i; j < i + onaline; j++)
d2314 1
a2314 1
		      if (j >= stop)
d2330 1
a2330 1
     bfd *abfd;
d2358 3
a2360 2
	  bfd *cur_bfd = bfd_asymbol_bfd(*current);
	  if (cur_bfd)
d2362 30
a2391 3
	      bfd_print_symbol (cur_bfd,
				stdout,
				*current, bfd_print_symbol_all);
d2583 6
a2588 3
	  printf (" %-16s  %s",
		  q->howto->name,
		  sym_name);
d2633 1
a2633 1
  dummy_name = make_temp_file (NULL);
d2646 1
a2646 1
	  bfd_nonfatal (dummy_name);
d2653 2
a2654 1
	    bfd_nonfatal (p->name);
d2662 1
d2687 1
a2687 1
  dummy_name = make_temp_file (NULL);
d2701 1
a2701 1
		bfd_nonfatal (p->name);
d2710 1
a2710 1
		      bfd_nonfatal (p->name);
d2730 2
a2747 1
  extern char *getenv ();
d2780 1
a2780 1
  printf ("BFD header file version %s\n", BFD_VERSION);
d2794 6
d2806 1
d2808 1
a2808 1
  while ((c = getopt_long (argc, argv, "pib:m:VdDlfahrRtTxsSj:wE:",
a2811 2
      if (c != 'l' && c != OPTION_START_ADDRESS && c != OPTION_STOP_ADDRESS)
	seenflag = true;
d2819 3
d2826 1
a2826 1
	  with_line_numbers = 1;
d2831 38
d2871 1
d2875 1
d2878 2
a2879 1
	  dump_private_headers = 1;
d2882 3
a2884 3
	  dump_private_headers = 1;
	  dump_symtab = 1;
	  dump_reloc_info = 1;
d2886 3
a2888 2
	  dump_ar_hdrs = 1;
	  dump_section_headers = 1;
d2891 2
a2892 1
	  dump_symtab = 1;
d2895 2
a2896 1
	  dump_dynamic_symtab = 1;
d2900 4
d2906 3
a2908 1
	  disassemble = disassemble_all = true;
d2913 9
d2924 2
a2925 1
	  dump_section_contents = 1;
d2928 2
a2929 1
	  dump_reloc_info = 1;
d2932 2
a2933 1
	  dump_dynamic_reloc_info = 1;
d2936 2
a2937 1
	  dump_ar_hdrs = 1;
d2940 2
a2941 1
	  dump_section_headers = 1;
d2945 1
d2947 2
a2948 33
	  show_version = 1;
	  break;
	case 'w':
	  wide_output = 1;
	  break;
	case OPTION_START_ADDRESS:
	  start_address = parse_vma (optarg, "--start-address");
	  break;
	case OPTION_STOP_ADDRESS:
	  stop_address = parse_vma (optarg, "--stop-address");
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, "%s: unrecognized -E option\n", program_name);
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, "%s: unrecognized --endian type `%s'\n",
		      program_name, optarg);
	      usage (stderr, 1);
	    }
d2950 1
d2960 1
a2960 1
    usage (stderr, 1);
d2963 1
a2963 3
    {
      display_info ();
    }
d2975 1
a2975 1
  return 0;
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2172 1
a2172 1
  dummy_name = choose_temp_base ();
d2224 1
a2224 1
  dummy_name = choose_temp_base ();
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a46 2
extern char *program_version;

d57 1
d128 7
d141 8
d168 2
a169 1
       [--show-raw-insn] [-EB|-EL] [--endian={big|little}] objfile...\n\
d172 2
d201 1
d458 2
a459 2
  /* Try to sort global symbols before local symbols before debugging
     symbols.  */
d471 7
d543 2
d548 4
a551 1
/* Print VMA symbolically to INFO if possible.  */
d553 4
a556 2
static void
objdump_print_address (vma, info)
d558 2
a559 1
     struct disassemble_info *info;
a560 2
  char buf[30];

a570 3
  sprintf_vma (buf, vma);
  (*info->fprintf_func) (info->stream, "%s", buf);

d572 1
a572 1
    return;
d603 3
a605 4
  {
    /* If the file is relocateable, and the symbol could be from this
       section, prefer a symbol from this section over symbols from
       others, even if the other symbol's value might be closer.
d607 30
a636 19
       Note that this may be wrong for some symbol references if the
       sections have overlapping memory ranges, but in that case there's
       no way to tell what's desired without looking at the relocation
       table.  */
    struct objdump_disasm_info *aux;
    long i;

    aux = (struct objdump_disasm_info *) info->application_data;
    if (sorted_syms[thisplace]->section != aux->sec
	&& (aux->require_sec
	    || ((aux->abfd->flags & HAS_RELOC) != 0
		&& vma >= bfd_get_section_vma (aux->abfd, aux->sec)
		&& vma < (bfd_get_section_vma (aux->abfd, aux->sec)
			  + bfd_section_size (aux->abfd, aux->sec)))))
      {
	for (i = thisplace + 1; i < sorted_symcount; i++)
	  {
	    if (bfd_asymbol_value (sorted_syms[i])
		!= bfd_asymbol_value (sorted_syms[thisplace]))
d638 36
a673 14
	  }
	--i;
	for (; i >= 0; i--)
	  {
	    if (sorted_syms[i]->section == aux->sec
		&& (i == 0
		    || sorted_syms[i - 1]->section != aux->sec
		    || (bfd_asymbol_value (sorted_syms[i])
			!= bfd_asymbol_value (sorted_syms[i - 1]))))
	      {
		thisplace = i;
		break;
	      }
	  }
d675 9
a683 13
	if (sorted_syms[thisplace]->section != aux->sec)
	  {
	    /* We didn't find a good symbol with a smaller value.
               Look for one with a larger value.  */
	    for (i = thisplace + 1; i < sorted_symcount; i++)
	      {
		if (sorted_syms[i]->section == aux->sec)
		  {
		    thisplace = i;
		    break;
		  }
	      }
	  }
d685 2
a686 8
	if (sorted_syms[thisplace]->section != aux->sec
	    && (aux->require_sec
		|| ((aux->abfd->flags & HAS_RELOC) != 0
		    && vma >= bfd_get_section_vma (aux->abfd, aux->sec)
		    && vma < (bfd_get_section_vma (aux->abfd, aux->sec)
			      + bfd_section_size (aux->abfd, aux->sec)))))
	  {
	    bfd_vma secaddr;
d688 3
a690 18
	    (*info->fprintf_func) (info->stream, " <%s",
				   bfd_get_section_name (aux->abfd, aux->sec));
	    secaddr = bfd_get_section_vma (aux->abfd, aux->sec);
	    if (vma < secaddr)
	      {
		(*info->fprintf_func) (info->stream, "-");
		objdump_print_value (secaddr - vma, info);
	      }
	    else if (vma > secaddr)
	      {
		(*info->fprintf_func) (info->stream, "+");
		objdump_print_value (vma - secaddr, info);
	      }
	    (*info->fprintf_func) (info->stream, ">");
	    return;
	  }
      }
  }
d692 16
a707 2
  (*info->fprintf_func) (info->stream, " <%s", sorted_syms[thisplace]->name);
  if (bfd_asymbol_value (sorted_syms[thisplace]) > vma)
d709 12
a720 3
      (*info->fprintf_func) (info->stream, "-");
      objdump_print_value (bfd_asymbol_value (sorted_syms[thisplace]) - vma,
			   info);
d722 13
a734 1
  else if (vma > bfd_asymbol_value (sorted_syms[thisplace]))
d736 5
a740 3
      (*info->fprintf_func) (info->stream, "+");
      objdump_print_value (vma - bfd_asymbol_value (sorted_syms[thisplace]),
			   info);
d742 5
a746 1
  (*info->fprintf_func) (info->stream, ">");
d989 237
d1231 1
a1231 1
  disassembler_ftype disassemble_fn = 0; /* New style */
a1234 3
  boolean done_dot = false;
  char buf[200];
  SFILE sfile;
d1374 5
a1378 1
      while (i < stop)
d1380 2
a1381 2
	  int bytes;
	  boolean need_nl = false;
d1383 3
a1385 7
	  if (data[i] == 0
	      && (i + 1 >= stop
		  || (data[i + 1] == 0
		      && (i + 2 >= stop
			  || (data[i + 2] == 0
			      && (i + 3 >= stop
				  || data[i + 3] == 0))))))
d1387 5
a1391 16
	      if (done_dot == false)
		{
		  printf ("...\n");
		  done_dot = true;
		}
	      bytes = 4;
	    }
	  else
	    {
	      done_dot = false;
	      if (with_line_numbers || with_source_code)
		show_line (abfd, section, i);
	      aux.require_sec = true;
	      objdump_print_address (section->vma + i, &disasm_info);
	      aux.require_sec = false;
	      putchar (' ');
d1393 5
a1397 8
	      sfile.buffer = sfile.current = buf;
	      disasm_info.fprintf_func = (fprintf_ftype) objdump_sprintf;
	      disasm_info.stream = (FILE *) &sfile;
	      bytes = (*disassemble_fn) (section->vma + i, &disasm_info);
	      disasm_info.fprintf_func = (fprintf_ftype) fprintf;
	      disasm_info.stream = stdout;
	      if (bytes < 0)
		break;
d1399 3
a1401 1
	      if (show_raw_insn)
d1403 9
a1411 8
		  long j;
		  for (j = i; j < i + bytes; ++j)
		    {
		      printf ("%02x", (unsigned) data[j]);
		      putchar (' ');
		    }
		  /* Separate raw data from instruction by extra space.  */
		  putchar (' ');
d1414 2
a1415 4
	      printf ("%s", sfile.buffer);

	      if (!wide_output)
		putchar ('\n');
a1416 9
		need_nl = true;
	    }

	  if (dump_reloc_info
	      && (section->flags & SEC_RELOC) != 0)
	    {
	      while (relpp < relppend
		     && ((*relpp)->address >= (bfd_vma) i
			 && (*relpp)->address < (bfd_vma) i + bytes))
d1418 4
a1421 2
		  arelent *q;
		  const char *sym_name;
d1423 13
a1435 5
		  q = *relpp;

		  printf ("\t\tRELOC: ");

		  printf_vma (section->vma + q->address);
d1437 2
a1438 1
		  printf (" %s ", q->howto->name);
d1440 2
a1441 29
		  if (q->sym_ptr_ptr != NULL
		      && *q->sym_ptr_ptr != NULL)
		    {
		      sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
		      if (sym_name == NULL || *sym_name == '\0')
			{
			  asection *sym_sec;

			  sym_sec = bfd_get_section (*q->sym_ptr_ptr);
			  sym_name = bfd_get_section_name (abfd, sym_sec);
			  if (sym_name == NULL || *sym_name == '\0')
			    sym_name = "*unknown*";
			}
		    }
		  else
		    sym_name = "*unknown*";

		  printf ("%s", sym_name);

		  if (q->addend)
		    {
		      printf ("+0x");
		      printf_vma (q->addend);
		    }

		  printf ("\n");
		  need_nl = false;
		  ++relpp;
		}
a1442 5

	  if (need_nl)
	    printf ("\n");

	  i += bytes;
d2450 1
a2450 4
    {
      printf ("GNU %s version %s\n", program_name, program_version);
      exit (0);
    }
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d45 1
a45 1
char *default_target = NULL;	/* default at runtime */
d49 22
a70 22
int show_version = 0;		/* show the version number */
int dump_section_contents;	/* -s */
int dump_section_headers;	/* -h */
boolean dump_file_header;	/* -f */
int dump_symtab;		/* -t */
int dump_dynamic_symtab;	/* -T */
int dump_reloc_info;		/* -r */
int dump_dynamic_reloc_info;	/* -R */
int dump_ar_hdrs;		/* -a */
int dump_private_headers;	/* -p */
int with_line_numbers;		/* -l */
boolean with_source_code;	/* -S */
int show_raw_insn;		/* --show-raw-insn */
int dump_stab_section_info;	/* --stabs */
boolean disassemble;		/* -d */
boolean disassemble_all;	/* -D */
boolean formats_info;		/* -i */
char *only;			/* -j secname */
int wide_output;		/* -w */
bfd_vma start_address = (bfd_vma) -1; /* --start-address */
bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
int dump_debugging;		/* --debugging */
d80 4
a83 1
char *machine = (char *) NULL;
d86 1
a86 1
asymbol **syms;
d89 1
a89 1
long symcount = 0;
d92 1
a92 1
asymbol **sorted_syms;
d95 1
a95 1
long sorted_symcount = 0;
d98 1
a98 1
asymbol **dynsyms;
d101 1
a101 1
long dynsymcount = 0;
d118 1
a118 1
dump_reloc_set PARAMS ((bfd *, arelent **, long));
d138 1
a138 1
void
d154 1
a154 1
       [--show-raw-insn] objfile...\n\
d162 2
a163 1
#define OPTION_START_ADDRESS (150)
d177 1
d355 1
a355 1
long
d913 1
a913 1
void
d958 10
d977 1
d1190 2
a1191 2
void dump_section_stabs PARAMS ((bfd *abfd, char *stabsect_name,
				 char *strsect_name));
d1194 1
a1194 2
   uses Sun stabs encoding.  It has to use some hooks into BFD because
   string table sections are not normally visible to BFD callers.  */
d1196 1
a1196 1
void
d1206 1
a1206 1
static struct internal_nlist *stabs;
d1217 1
a1217 1
boolean
d1243 1
a1243 1
  stabs  = (struct internal_nlist *) xmalloc (stab_size);
d1270 14
a1283 9
#define SWAP_SYMBOL(symp, abfd) \
{ \
    (symp)->n_strx = bfd_h_get_32(abfd,			\
				  (unsigned char *)&(symp)->n_strx);	\
    (symp)->n_desc = bfd_h_get_16 (abfd,			\
				   (unsigned char *)&(symp)->n_desc);  	\
    (symp)->n_value = bfd_h_get_32 (abfd,			\
				    (unsigned char *)&(symp)->n_value);	\
}
d1288 1
a1288 1
void
d1296 4
a1299 2
  struct internal_nlist *stabp = stabs,
  *stabs_end = (struct internal_nlist *) (stab_size + (char *) stabs);
d1309 1
a1309 1
  for (i = -1; stabp < stabs_end; stabp++, i++)
d1312 10
a1322 1
      SWAP_SYMBOL (stabp, abfd);
d1326 1
a1326 1
      name = bfd_get_stab_name (stabp->n_type);
d1329 1
a1329 1
      else if (stabp->n_type == N_UNDF)
d1332 4
a1335 4
	printf ("%-6d", stabp->n_type);
      printf (" %-6d %-6d ", stabp->n_other, stabp->n_desc);
      printf_vma (stabp->n_value);
      printf (" %-6lu", stabp->n_strx);
d1341 1
a1341 1
      if (stabp->n_type == N_UNDF)
d1344 1
a1344 1
	  next_file_string_table_offset += stabp->n_value;
d1351 2
a1352 2
	  if ((stabp->n_strx + file_string_table_offset) < stabstr_size)
	    printf (" %s", &strtab[stabp->n_strx + file_string_table_offset]);
d1360 1
a1360 1
void
d1374 9
a1382 2
      if (strncmp (stabsect_name, s->name, strlen (stabsect_name)) == 0
	  && strncmp (strsect_name, s->name, strlen (strsect_name)) != 0)
d1427 1
d1726 1
a1726 1
	      dump_reloc_set (abfd, relpp, relcount);
d1765 1
a1765 1
	  dump_reloc_set (abfd, relpp, relcount);
d1773 1
a1773 1
dump_reloc_set (abfd, relpp, relcount)
d1775 1
d1780 2
d1795 4
d1802 4
a1805 2
      CONST char *sym_name;
      CONST char *section_name;
d1814 31
a1882 4
#ifndef L_tmpnam
#define L_tmpnam 25
#endif

a1900 1
  extern char *tmpnam ();
a1901 1
  char tmparg[L_tmpnam];
d1905 1
a1905 1
  dummy_name = tmpnam (tmparg);
d1935 1
a1947 2
  extern char *tmpnam ();
  char tmparg[L_tmpnam];
d1957 1
a1957 1
  dummy_name = tmpnam (tmparg);
d2004 1
d2070 2
a2071 2
  while ((c = getopt_long (argc, argv, "pib:m:VdDlfahrRtTxsSj:w", long_options,
			   (int *) 0))
d2153 23
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d27 8
d42 1
a42 1
extern int fprintf ();
d61 1
d70 1
d124 1
a124 1
objdump_print_value PARAMS ((bfd_vma, FILE *));
d131 3
d142 1
a142 1
       [--archive-headers] [--target=bfdname] [--disassemble]\n\
d150 2
a151 1
       [--start-address=addr] [--stop-address=addr] objfile...\n\
d168 1
d182 1
d202 11
a212 2
#define PF(x,y) \
  if (section->flags & x) {  printf("%s%s",comma,y); comma = ", "; }
d214 2
d217 1
a217 10
  printf ("SECTION %d [%s]\t: size %08x",
	  section->index,
	  section->name,
	  (unsigned) bfd_get_section_size_before_reloc (section));
  printf (" vma ");
  printf_vma (section->vma);
  printf (" lma ");
  printf_vma (section->lma);
  printf (" align 2**%u%s ",
	  section->alignment_power, (wide_output) ? "" : "\n");
d234 28
d270 6
d435 2
a436 2
  /* Finally, try to sort global symbols before local symbols before
     debugging symbols.  */
d455 7
d463 10
a472 1
  return 0;
d503 1
a503 1
objdump_print_value (vma, stream)
d505 1
a505 1
     FILE *stream;
d513 1
a513 1
  fprintf (stream, "%s", p);
d523 2
d535 2
a536 1
  fprintf_vma (info->stream, vma);
d633 2
a634 2
	    fprintf (info->stream, " <%s",
		     bfd_get_section_name (aux->abfd, aux->sec));
d638 2
a639 2
		fprintf (info->stream, "-");
		objdump_print_value (secaddr - vma, info->stream);
d643 2
a644 2
		fprintf (info->stream, "+");
		objdump_print_value (vma - secaddr, info->stream);
d646 1
a646 1
	    fprintf (info->stream, ">");
d652 1
a652 1
  fprintf (info->stream, " <%s", sorted_syms[thisplace]->name);
d655 1
a655 1
      fprintf (info->stream, "-");
d657 1
a657 1
			   info->stream);
d661 1
a661 1
      fprintf (info->stream, "+");
d663 1
a663 1
			   info->stream);
d665 1
a665 1
  fprintf (info->stream, ">");
d867 41
d918 2
d935 1
a935 1
  INIT_DISASSEMBLE_INFO(disasm_info, stdout);
d962 11
d1053 7
a1059 2
	  if (data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 0 &&
	      data[i + 3] == 0)
d1078 3
d1082 2
d1087 14
d1139 2
a1173 14
char **stab_name;

struct stab_print {
  int value;
  char *string;
};

struct stab_print stab_print[] = {
#define __define_stab(NAME, CODE, STRING) {CODE, STRING},
#include "aout/stab.def"
#undef __define_stab
  {0, ""}
};

a1184 14
  /* Allocate and initialize stab name array if first time.  */
  if (stab_name == NULL) 
    {
      int i;

      stab_name = (char **) xmalloc (256 * sizeof(char *));
      /* Clear the array. */
      for (i = 0; i < 256; i++)
	stab_name[i] = NULL;
      /* Fill in the defined stabs. */
      for (i = 0; *stab_print[i].string; i++)
	stab_name[stab_print[i].value] = stab_print[i].string;
    }

d1289 2
d1295 3
a1297 2
      if (stab_name[stabp->n_type])
	printf ("%-6s", stab_name[stabp->n_type]);
d1380 1
d1417 1
a1417 1
  if (dump_symtab || dump_reloc_info || disassemble)
d1439 12
d1808 12
d1840 2
a1841 2
	      p->header_byteorder_big_p ? "big endian" : "little endian",
	      p->byteorder_big_p ? "big endian" : "little endian");
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a26 8
#include "debug.h"
#include "budbg.h"

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d34 1
a34 1
extern int fprintf PARAMS ((FILE *, const char *, ...));
a52 1
int show_raw_insn;		/* --show-raw-insn */
a60 1
int dump_debugging;		/* --debugging */
d114 1
a114 1
objdump_print_value PARAMS ((bfd_vma, struct disassemble_info *));
a120 3

static const char *
endian_string PARAMS ((enum bfd_endian));
d129 1
a129 1
       [--archive-headers] [--target=bfdname] [--debugging] [--disassemble]\n\
d137 1
a137 2
       [--start-address=addr] [--stop-address=addr]\n\
       [--show-raw-insn] objfile...\n\
a153 1
  {"debugging", no_argument, &dump_debugging, 1},
a166 1
  {"show-raw-insn", no_argument, &show_raw_insn, 1},
d186 2
a187 11
  printf ("%3d %-13s %08lx  ", section->index,
	  bfd_get_section_name (abfd, section),
	  (unsigned long) bfd_section_size (abfd, section));
  printf_vma (bfd_get_section_vma (abfd, section));
  printf ("  ");
  printf_vma (section->lma);
  printf ("  %08lx  2**%u", section->filepos,
	  bfd_get_section_alignment (abfd, section));
  if (! wide_output)
    printf ("\n                ");
  printf ("  ");
a188 2
#define PF(x, y) \
  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }
d190 10
a199 1
  PF (SEC_HAS_CONTENTS, "CONTENTS");
a215 28
  PF (SEC_EXCLUDE, "EXCLUDE");
  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");

  if ((section->flags & SEC_LINK_ONCE) != 0)
    {
      const char *ls;

      switch (section->flags & SEC_LINK_DUPLICATES)
	{
	default:
	  abort ();
	case SEC_LINK_DUPLICATES_DISCARD:
	  ls = "LINK_ONCE_DISCARD";
	  break;
	case SEC_LINK_DUPLICATES_ONE_ONLY:
	  ls = "LINK_ONCE_ONE_ONLY";
	  break;
	case SEC_LINK_DUPLICATES_SAME_SIZE:
	  ls = "LINK_ONCE_SAME_SIZE";
	  break;
	case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	  ls = "LINK_ONCE_SAME_CONTENTS";
	  break;
	}
      printf ("%s%s", comma, ls);
      comma = ", ";
    }

a223 6
  printf ("Sections:\n");
#ifndef BFD64
  printf ("Idx Name          Size      VMA       LMA       File off  Algn\n");
#else
  printf ("Idx Name          Size      VMA               LMA               File off  Algn\n");
#endif
d383 2
a384 2
  /* Try to sort global symbols before local symbols before debugging
     symbols.  */
a402 7
  if ((aflags & BSF_GLOBAL) != (bflags & BSF_GLOBAL))
    {
      if ((aflags & BSF_GLOBAL) != 0)
	return -1;
      else
	return 1;
    }
d404 1
a404 10
  /* Symbols that start with '.' might be section names, so sort them
     after symbols that don't start with '.'.  */
  if (an[0] == '.' && bn[0] != '.')
    return 1;
  if (an[0] != '.' && bn[0] == '.')
    return -1;

  /* Finally, if we can't distinguish them in any other way, try to
     get consistent results by sorting the symbols by name.  */
  return strcmp (an, bn);
d435 1
a435 1
objdump_print_value (vma, info)
d437 1
a437 1
     struct disassemble_info *info;
d445 1
a445 1
  (*info->fprintf_func) (info->stream, "%s", p);
a454 2
  char buf[30];

d465 1
a465 2
  sprintf_vma (buf, vma);
  (*info->fprintf_func) (info->stream, "%s", buf);
d562 2
a563 2
	    (*info->fprintf_func) (info->stream, " <%s",
				   bfd_get_section_name (aux->abfd, aux->sec));
d567 2
a568 2
		(*info->fprintf_func) (info->stream, "-");
		objdump_print_value (secaddr - vma, info);
d572 2
a573 2
		(*info->fprintf_func) (info->stream, "+");
		objdump_print_value (vma - secaddr, info);
d575 1
a575 1
	    (*info->fprintf_func) (info->stream, ">");
d581 1
a581 1
  (*info->fprintf_func) (info->stream, " <%s", sorted_syms[thisplace]->name);
d584 1
a584 1
      (*info->fprintf_func) (info->stream, "-");
d586 1
a586 1
			   info);
d590 1
a590 1
      (*info->fprintf_func) (info->stream, "+");
d592 1
a592 1
			   info);
d594 1
a594 1
  (*info->fprintf_func) (info->stream, ">");
a795 41
/* Pseudo FILE object for strings.  */
typedef struct {
  char *buffer;
  char *current;
} SFILE;

/* sprintf to a "stream" */

#ifdef ANSI_PROTOTYPES
static int
objdump_sprintf (SFILE *f, const char *format, ...)
{
  int n;
  va_list args;

  va_start (args, format);
  vsprintf (f->current, format, args);
  f->current += n = strlen (f->current);
  va_end (args);
  return n;
}
#else
static int
objdump_sprintf (va_alist)
     va_dcl
{
  int n;
  SFILE *f;
  const char *format;
  va_list args;

  va_start (args);
  f = va_arg (args, SFILE *);
  format = va_arg (args, const char *);
  vsprintf (f->current, format, args);
  f->current += n = strlen (f->current);
  va_end (args);
  return n;
}
#endif

a805 2
  char buf[200];
  SFILE sfile;
d821 1
a821 1
  INIT_DISASSEMBLE_INFO(disasm_info, stdout, fprintf);
a847 11
  disasm_info.arch = bfd_get_arch (abfd);
  disasm_info.mach = bfd_get_mach (abfd);
  if (bfd_big_endian (abfd))
    disasm_info.endian = BFD_ENDIAN_BIG;
  else if (bfd_little_endian (abfd))
    disasm_info.endian = BFD_ENDIAN_LITTLE;
  else
    /* ??? Aborting here seems too drastic.  We could default to big or little
       instead.  */
    disasm_info.endian = BFD_ENDIAN_UNKNOWN;

d928 2
a929 7
	  if (data[i] == 0
	      && (i + 1 >= stop
		  || (data[i + 1] == 0
		      && (i + 2 >= stop
			  || (data[i + 2] == 0
			      && (i + 3 >= stop
				  || data[i + 3] == 0))))))
a947 3
	      sfile.buffer = sfile.current = buf;
	      disasm_info.fprintf_func = (fprintf_ftype) objdump_sprintf;
	      disasm_info.stream = (FILE *) &sfile;
a948 2
	      disasm_info.fprintf_func = (fprintf_ftype) fprintf;
	      disasm_info.stream = stdout;
a951 14
	      if (show_raw_insn)
		{
		  long j;
		  for (j = i; j < i + bytes; ++j)
		    {
		      printf ("%02x", (unsigned) data[j]);
		      putchar (' ');
		    }
		  /* Separate raw data from instruction by extra space.  */
		  putchar (' ');
		}

	      printf ("%s", sfile.buffer);

a989 2
		  else
		    sym_name = "*unknown*";
d1023 14
d1048 14
a1165 2
      const char *name;

d1170 2
a1171 3
      name = bfd_get_stab_name (stabp->n_type);
      if (name != NULL)
	printf ("%-6s", name);
a1253 1
  printf ("\n");
d1290 1
a1290 1
  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
a1311 12
  if (dump_debugging)
    {
      PTR dhandle;

      dhandle = read_debugging_info (abfd, syms, symcount);
      if (dhandle != NULL)
	{
	  if (! print_debugging_info (stdout, dhandle))
	    fprintf (stderr, "%s: printing debugging information failed\n",
		     bfd_get_filename (abfd));
	}
    }
a1668 12
static const char *
endian_string (endian)
     enum bfd_endian endian;
{
  if (endian == BFD_ENDIAN_BIG)
    return "big endian";
  else if (endian == BFD_ENDIAN_LITTLE)
    return "little endian";
  else
    return "endianness unknown";
}

d1689 2
a1690 2
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d45 1
a45 1
static char *default_target = NULL;	/* default at runtime */
d49 22
a70 22
static int show_version = 0;		/* show the version number */
static int dump_section_contents;	/* -s */
static int dump_section_headers;	/* -h */
static boolean dump_file_header;	/* -f */
static int dump_symtab;			/* -t */
static int dump_dynamic_symtab;		/* -T */
static int dump_reloc_info;		/* -r */
static int dump_dynamic_reloc_info;	/* -R */
static int dump_ar_hdrs;		/* -a */
static int dump_private_headers;	/* -p */
static int with_line_numbers;		/* -l */
static boolean with_source_code;	/* -S */
static int show_raw_insn;		/* --show-raw-insn */
static int dump_stab_section_info;	/* --stabs */
static boolean disassemble;		/* -d */
static boolean disassemble_all;		/* -D */
static boolean formats_info;		/* -i */
static char *only;			/* -j secname */
static int wide_output;			/* -w */
static bfd_vma start_address = (bfd_vma) -1; /* --start-address */
static bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
static int dump_debugging;		/* --debugging */
d80 1
a80 4
static char *machine = (char *) NULL;

/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
static enum bfd_endian endian = BFD_ENDIAN_UNKNOWN;
d83 1
a83 1
static asymbol **syms;
d86 1
a86 1
static long symcount = 0;
d89 1
a89 1
static asymbol **sorted_syms;
d92 1
a92 1
static long sorted_symcount = 0;
d95 1
a95 1
static asymbol **dynsyms;
d98 1
a98 1
static long dynsymcount = 0;
d115 1
a115 1
dump_reloc_set PARAMS ((bfd *, asection *, arelent **, long));
d135 1
a135 1
static void
d151 1
a151 1
       [--show-raw-insn] [-EB|-EL] [--endian={big|little}] objfile...\n\
d159 1
a159 2
#define OPTION_ENDIAN (150)
#define OPTION_START_ADDRESS (OPTION_ENDIAN + 1)
a172 1
  {"endian", required_argument, NULL, OPTION_ENDIAN},
d350 1
a350 1
static long
d908 1
a908 1
static void
a952 10
  if (endian != BFD_ENDIAN_UNKNOWN)
    {
      struct bfd_target *xvec;

      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
      memcpy (xvec, abfd->xvec, sizeof (struct bfd_target));
      xvec->byteorder = endian;
      abfd->xvec = xvec;
    }

a961 1
  disasm_info.flavour = bfd_get_flavour (abfd);
d1174 2
a1175 2
static void dump_section_stabs PARAMS ((bfd *abfd, char *stabsect_name,
					char *strsect_name));
d1178 2
a1179 1
   uses Sun stabs encoding.  */
d1181 1
a1181 1
static void
d1191 1
a1191 1
static bfd_byte *stabs;
d1202 1
a1202 1
static boolean
d1228 1
a1228 1
  stabs  = (bfd_byte *) xmalloc (stab_size);
d1255 9
a1263 14
/* Stabs entries use a 12 byte format:
     4 byte string table index
     1 byte stab type
     1 byte stab other field
     2 byte stab desc field
     4 byte stab value
   FIXME: This will have to change for a 64 bit object format.  */

#define STRDXOFF (0)
#define TYPEOFF (4)
#define OTHEROFF (5)
#define DESCOFF (6)
#define VALOFF (8)
#define STABSIZE (12)
d1268 1
a1268 1
static void
d1276 2
a1277 4
  bfd_byte *stabp, *stabs_end;

  stabp = stabs;
  stabs_end = stabp + stab_size;
d1287 1
a1287 1
  for (i = -1; stabp < stabs_end; stabp += STABSIZE, i++)
a1289 10
      unsigned long strx;
      unsigned char type, other;
      unsigned short desc;
      bfd_vma value;

      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
      value = bfd_h_get_32 (abfd, stabp + VALOFF);
d1291 1
d1295 1
a1295 1
      name = bfd_get_stab_name (type);
d1298 1
a1298 1
      else if (type == N_UNDF)
d1301 4
a1304 4
	printf ("%-6d", type);
      printf (" %-6d %-6d ", other, desc);
      printf_vma (value);
      printf (" %-6lu", strx);
d1310 1
a1310 1
      if (type == N_UNDF)
d1313 1
a1313 1
	  next_file_string_table_offset += value;
d1320 2
a1321 2
	  if ((strx + file_string_table_offset) < stabstr_size)
	    printf (" %s", &strtab[strx + file_string_table_offset]);
d1329 1
a1329 1
static void
d1343 2
a1344 9
      int len;

      len = strlen (stabsect_name);

/* If the prefix matches, and the files section name ends with a nul or a digit,
   then we match.  Ie: we want either an exact match or a a section followed by 
   a number.  */
      if (strncmp (stabsect_name, s->name, len) == 0
	  && (s->name[len] == '\000' || isdigit (s->name[len])))
a1388 1

d1687 1
a1687 1
	      dump_reloc_set (abfd, a, relpp, relcount);
d1726 1
a1726 1
	  dump_reloc_set (abfd, (asection *) NULL, relpp, relcount);
d1734 1
a1734 1
dump_reloc_set (abfd, sec, relpp, relcount)
a1735 1
     asection *sec;
a1739 2
  char *last_filename, *last_functionname;
  unsigned int last_line;
a1752 4
  last_filename = NULL;
  last_functionname = NULL;
  last_line = 0;

d1756 2
a1757 4
      const char *filename, *functionname;
      unsigned int line;
      const char *sym_name;
      const char *section_name;
a1765 31
      if (with_line_numbers
	  && sec != NULL
	  && bfd_find_nearest_line (abfd, sec, syms, q->address,
				    &filename, &functionname, &line))
	{
	  if (functionname != NULL
	      && (last_functionname == NULL
		  || strcmp (functionname, last_functionname) != 0))
	    {
	      printf ("%s():\n", functionname);
	      if (last_functionname != NULL)
		free (last_functionname);
	      last_functionname = xstrdup (functionname);
	    }
	  if (line > 0
	      && (line != last_line
		  || (filename != NULL
		      && last_filename != NULL
		      && strcmp (filename, last_filename) != 0)))
	    {
	      printf ("%s:%u\n", filename == NULL ? "???" : filename, line);
	      last_line = line;
	      if (last_filename != NULL)
		free (last_filename);
	      if (filename == NULL)
		last_filename = NULL;
	      else
		last_filename = xstrdup (filename);
	    }
	}

d1804 4
d1826 1
d1828 1
d1832 1
a1832 1
  dummy_name = choose_temp_base ();
a1861 1
  free (dummy_name);
d1874 2
d1885 1
a1885 1
  dummy_name = choose_temp_base ();
a1931 1
  free (dummy_name);
d1997 2
a1998 2
  while ((c = getopt_long (argc, argv, "pib:m:VdDlfahrRtTxsSj:wE:",
			   long_options, (int *) 0))
a2079 23
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, "%s: unrecognized -E option\n", program_name);
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, "%s: unrecognized --endian type `%s'\n",
		      program_name, optarg);
	      usage (stderr, 1);
	    }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d47 2
a58 1
static int prefix_addresses;		/* --prefix-addresses */
a128 7
static asymbol *
find_symbol_for_address PARAMS ((bfd *, asection *, bfd_vma, boolean, long *));

static void
objdump_print_addr_with_sym PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
				     struct disassemble_info *));

a134 8
static void
disassemble_bytes PARAMS ((struct disassemble_info *, disassembler_ftype,
			   boolean, bfd_byte *, long, long, arelent ***,
			   arelent **));

static void
disassemble_data PARAMS ((bfd *));

d154 1
a154 2
       [--prefix-addresses] [--show-raw-insn]\n\
       [-EB|-EL] [--endian={big|little}] objfile...\n\
a156 2
  if (status == 0)
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
a183 1
  {"prefix-addresses", no_argument, &prefix_addresses, 1},
d440 2
a441 2
  /* Try to sort global symbols before local symbols before function
     symbols before debugging symbols.  */
a452 7
  if ((aflags & BSF_FUNCTION) != (bflags & BSF_FUNCTION))
    {
      if ((aflags & BSF_FUNCTION) != 0)
	return -1;
      else
	return 1;
    }
a517 2
  if (*p == '\0')
    --p;
d521 1
a521 4
/* Locate a symbol given a bfd, a section, and a VMA.  If REQUIRE_SEC
   is true, then always require the symbol to be in the section.  This
   returns NULL if there is no suitable symbol.  If PLACE is not NULL,
   then *PLACE is set to the index of the symbol in sorted_syms.  */
d523 2
a524 4
static asymbol *
find_symbol_for_address (abfd, sec, vma, require_sec, place)
     bfd *abfd;
     asection *sec;
d526 1
a526 2
     boolean require_sec;
     long *place;
d528 2
d540 3
d544 1
a544 1
    return NULL;
d575 4
a578 3
  /* If the file is relocateable, and the symbol could be from this
     section, prefer a symbol from this section over symbols from
     others, even if the other symbol's value might be closer.
d580 19
a598 30
     Note that this may be wrong for some symbol references if the
     sections have overlapping memory ranges, but in that case there's
     no way to tell what's desired without looking at the relocation
     table.  */

  if (sorted_syms[thisplace]->section != sec
      && (require_sec
	  || ((abfd->flags & HAS_RELOC) != 0
	      && vma >= bfd_get_section_vma (abfd, sec)
	      && vma < (bfd_get_section_vma (abfd, sec)
			+ bfd_section_size (abfd, sec)))))
    {
      long i;

      for (i = thisplace + 1; i < sorted_symcount; i++)
	{
	  if (bfd_asymbol_value (sorted_syms[i])
	      != bfd_asymbol_value (sorted_syms[thisplace]))
	    break;
	}
      --i;
      for (; i >= 0; i--)
	{
	  if (sorted_syms[i]->section == sec
	      && (i == 0
		  || sorted_syms[i - 1]->section != sec
		  || (bfd_asymbol_value (sorted_syms[i])
		      != bfd_asymbol_value (sorted_syms[i - 1]))))
	    {
	      thisplace = i;
d600 14
a613 2
	    }
	}
d615 13
a627 13
      if (sorted_syms[thisplace]->section != sec)
	{
	  /* We didn't find a good symbol with a smaller value.
	     Look for one with a larger value.  */
	  for (i = thisplace + 1; i < sorted_symcount; i++)
	    {
	      if (sorted_syms[i]->section == sec)
		{
		  thisplace = i;
		  break;
		}
	    }
	}
d629 8
a636 11
      if (sorted_syms[thisplace]->section != sec
	  && (require_sec
	      || ((abfd->flags & HAS_RELOC) != 0
		  && vma >= bfd_get_section_vma (abfd, sec)
		  && vma < (bfd_get_section_vma (abfd, sec)
			    + bfd_section_size (abfd, sec)))))
	{
	  /* There is no suitable symbol.  */
	  return NULL;
	}
    }
d638 18
a655 17
  if (place != NULL)
    *place = thisplace;

  return sorted_syms[thisplace];
}

/* Print an address to INFO symbolically.  */

static void
objdump_print_addr_with_sym (abfd, sec, sym, vma, info)
     bfd *abfd;
     asection *sec;
     asymbol *sym;
     bfd_vma vma;
     struct disassemble_info *info;
{
  char buf[30];
d657 2
a658 4
  sprintf_vma (buf, vma);
  (*info->fprintf_func) (info->stream, "%s", buf);

  if (sym == NULL)
d660 3
a662 31
      bfd_vma secaddr;

      (*info->fprintf_func) (info->stream, " <%s",
			     bfd_get_section_name (abfd, sec));
      secaddr = bfd_get_section_vma (abfd, sec);
      if (vma < secaddr)
	{
	  (*info->fprintf_func) (info->stream, "-");
	  objdump_print_value (secaddr - vma, info);
	}
      else if (vma > secaddr)
	{
	  (*info->fprintf_func) (info->stream, "+");
	  objdump_print_value (vma - secaddr, info);
	}
      (*info->fprintf_func) (info->stream, ">");
    }
  else
    {
      (*info->fprintf_func) (info->stream, " <%s", sym->name);
      if (bfd_asymbol_value (sym) > vma)
	{
	  (*info->fprintf_func) (info->stream, "-");
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info);
	}
      else if (vma > bfd_asymbol_value (sym))
	{
	  (*info->fprintf_func) (info->stream, "+");
	  objdump_print_value (vma - bfd_asymbol_value (sym), info);
	}
      (*info->fprintf_func) (info->stream, ">");
d664 1
a664 13
}

/* Print VMA symbolically to INFO if possible.  */

static void
objdump_print_address (vma, info)
     bfd_vma vma;
     struct disassemble_info *info;
{
  struct objdump_disasm_info *aux;
  asymbol *sym;

  if (sorted_symcount < 1)
d666 3
a668 5
      char buf[30];

      sprintf_vma (buf, vma);
      (*info->fprintf_func) (info->stream, "%s", buf);
      return;
d670 1
a670 5

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 (long *) NULL);
  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, info);
a912 237
/* The number of zeroes we want to see before we start skipping them.
   The number is arbitrarily chosen.  */

#define SKIP_ZEROES (8)

/* The number of zeroes to skip at the end of a section.  If the
   number of zeroes at the end is between SKIP_ZEROES_AT_END and
   SKIP_ZEROES, they will be disassembled.  If there are fewer than
   SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic
   attempt to avoid disassembling zeroes inserted by section
   alignment.  */

#define SKIP_ZEROES_AT_END (3)

/* Disassemble some data in memory between given values.  */

static void
disassemble_bytes (info, disassemble_fn, insns, data, start, stop, relppp,
		   relppend)
     struct disassemble_info *info;
     disassembler_ftype disassemble_fn;
     boolean insns;
     bfd_byte *data;
     long start;
     long stop;
     arelent ***relppp;
     arelent **relppend;
{
  struct objdump_disasm_info *aux;
  asection *section;
  int bytes_per_line;
  boolean done_dot;
  long i;

  aux = (struct objdump_disasm_info *) info->application_data;
  section = aux->sec;

  if (insns)
    bytes_per_line = 4;
  else
    bytes_per_line = 16;

  done_dot = false;
  i = start;
  while (i < stop)
    {
      long z;
      int bytes;
      boolean need_nl = false;

      /* If we see more than SKIP_ZEROES bytes of zeroes, we just
         print `...'.  */
      for (z = i; z < stop; z++)
	if (data[z] != 0)
	  break;
      if (z - i >= SKIP_ZEROES
	  || (z == stop && z - i < SKIP_ZEROES_AT_END))
	{
	  printf ("\t...\n");

	  /* If there are more nonzero bytes to follow, we only skip
             zeroes in multiples of 4, to try to avoid running over
             the start of an instruction which happens to start with
             zero.  */
	  if (z != stop)
	    z = i + ((z - i) &~ 3);

	  bytes = z - i;
	}
      else
	{
	  char buf[1000];
	  SFILE sfile;
	  int pb = 0;

	  done_dot = false;

	  if (with_line_numbers || with_source_code)
	    show_line (aux->abfd, section, i);

	  if (! prefix_addresses)
	    printf ("%6lx:\t", (unsigned long) (i - start));
	  else
	    {
	      aux->require_sec = true;
	      objdump_print_address (section->vma + i, info);
	      aux->require_sec = false;
	      putchar (' ');
	    }

	  if (insns)
	    {
	      sfile.buffer = sfile.current = buf;
	      info->fprintf_func = (fprintf_ftype) objdump_sprintf;
	      info->stream = (FILE *) &sfile;
	      info->bytes_per_line = 0;
	      bytes = (*disassemble_fn) (section->vma + i, info);
	      info->fprintf_func = (fprintf_ftype) fprintf;
	      info->stream = stdout;
	      if (info->bytes_per_line != 0)
		bytes_per_line = info->bytes_per_line;
	      if (bytes < 0)
		break;
	    }
	  else
	    {
	      long j;

	      bytes = bytes_per_line;
	      if (i + bytes > stop)
		bytes = stop - i;

	      for (j = i; j < i + bytes; ++j)
		{
		  if (isprint (data[j]))
		    buf[j - i] = data[j];
		  else
		    buf[j - i] = '.';
		}
	      buf[j - i] = '\0';
	    }

	  if (! prefix_addresses || show_raw_insn)
	    {
	      long j;

	      /* If ! prefix_addresses and ! wide_output, we print
                 four bytes per line.  */
	      pb = bytes;
	      if (pb > bytes_per_line && ! prefix_addresses && ! wide_output)
		pb = bytes_per_line;

	      for (j = i; j < i + pb; ++j)
		{
		  printf ("%02x", (unsigned) data[j]);
		  putchar (' ');
		}

	      for (; pb < bytes_per_line; ++pb)
		printf ("   ");

	      /* Separate raw data from instruction by extra space.  */
	      if (insns)
		putchar ('\t');
	      else
		printf ("    ");
	    }

	  printf ("%s", buf);

	  if (! prefix_addresses || show_raw_insn)
	    {
	      while (pb < bytes)
		{
		  long j;

		  putchar ('\n');
		  j = i + pb;
		  printf ("%6lx:\t", (unsigned long) (j - start));
		  pb += bytes_per_line;
		  if (pb > bytes)
		    pb = bytes;
		  for (; j < i + pb; ++j)
		    {
		      printf ("%02x", (unsigned) data[j]);
		      putchar (' ');
		    }
		}
	    }

	  if (!wide_output)
	    putchar ('\n');
	  else
	    need_nl = true;
	}

      if (dump_reloc_info
	  && (section->flags & SEC_RELOC) != 0)
	{
	  while ((*relppp) < relppend
		 && ((**relppp)->address >= (bfd_vma) i
		     && (**relppp)->address < (bfd_vma) i + bytes))
	    {
	      arelent *q;
	      const char *sym_name;

	      q = **relppp;

	      if (wide_output)
		putchar ('\t');
	      else
		printf ("\t\t\t");

	      objdump_print_value (section->vma + q->address - start, info);

	      printf (": %s\t", q->howto->name);

	      if (q->sym_ptr_ptr != NULL
		  && *q->sym_ptr_ptr != NULL)
		{
		  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
		  if (sym_name == NULL || *sym_name == '\0')
		    {
		      asection *sym_sec;

		      sym_sec = bfd_get_section (*q->sym_ptr_ptr);
		      sym_name = bfd_get_section_name (abfd, sym_sec);
		      if (sym_name == NULL || *sym_name == '\0')
			sym_name = "*unknown*";
		    }
		}
	      else
		sym_name = "*unknown*";

	      printf ("%s", sym_name);

	      if (q->addend)
		{
		  printf ("+0x");
		  objdump_print_value (q->addend, info);
		}

	      printf ("\n");
	      need_nl = false;
	      ++(*relppp);
	    }
	}

      if (need_nl)
	printf ("\n");

      i += bytes;
    }
}

/* Disassemble the contents of an object file.  */

d918 1
a918 1
  disassembler_ftype disassemble_fn;
d922 3
d1064 1
a1064 5

      if (prefix_addresses)
	disassemble_bytes (&disasm_info, disassemble_fn, true, data, i, stop,
			   &relpp, relppend);
      else
d1066 2
a1067 2
	  asymbol *sym;
	  long place;
d1069 7
a1075 3
	  sym = find_symbol_for_address (abfd, section, i, true, &place);
	  ++place;
	  while (i < stop)
d1077 16
a1092 3
	      asymbol *nextsym;
	      long nextstop;
	      boolean insns;
d1094 8
a1101 7
	      disasm_info.symbol = sym;

	      printf ("\n");
	      objdump_print_addr_with_sym (abfd, section, sym,
					   section->vma + i,
					   &disasm_info);
	      printf (":\n");
d1103 1
a1103 3
	      if (sym == NULL)
		nextsym = NULL;
	      else
d1105 8
a1112 9
		  while (place < sorted_symcount
			 && (sorted_syms[place]->section != section
			     || (bfd_asymbol_value (sorted_syms[place])
				 <= bfd_asymbol_value (sym))))
		    ++place;
		  if (place >= sorted_symcount)
		    nextsym = NULL;
		  else
		    nextsym = sorted_syms[place];
d1115 4
a1118 2
	      if (nextsym == NULL)
		nextstop = stop;
d1120 9
d1130 18
a1147 4
		  nextstop = bfd_asymbol_value (nextsym) - section->vma;
		  if (nextstop > stop)
		    nextstop = stop;
		}
d1149 8
a1156 13
	      /* If a symbol is explicitly marked as being an object
                 rather than a function, just dump the bytes without
                 disassembling them.  */
	      if (disassemble_all
		  || ((sym->flags & BSF_OBJECT) == 0
		      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
			  == NULL)
		      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
			  == NULL))
		  || (sym->flags & BSF_FUNCTION) != 0)
		insns = true;
	      else
		insns = false;
d1158 1
a1158 2
	      disassemble_bytes (&disasm_info, disassemble_fn, insns, data, i,
				 nextstop, &relpp, relppend);
d1160 10
a1169 2
	      i = nextstop;
	      sym = nextsym;
d1171 5
d2183 4
a2186 1
    print_version ("objdump");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a26 1
#include "demangle.h"
a61 1
static int do_demangle;			/* -C, --demangle */
a63 1
static int disassemble_zeroes;		/* --disassemble-zeroes */
a69 1
static bfd_vma adjust_section_vma = 0;	/* --adjust-vma */
d102 1
a102 4
/* Static declarations.  */

static void
usage PARAMS ((FILE *, int));
a107 6
dump_section_header PARAMS ((bfd *, asection *, PTR));

static void
dump_headers PARAMS ((bfd *));

static void
a122 6
dump_bfd_header PARAMS ((bfd *));

static void
dump_bfd_private_header PARAMS ((bfd *));

static void
d126 1
a126 16
display_target_list PARAMS ((void));

static void
display_info_table PARAMS ((int, int));

static void
display_target_tables PARAMS ((void));

static void
display_info PARAMS ((void));

static void
objdump_print_value PARAMS ((bfd_vma, struct disassemble_info *, boolean));

static void
objdump_print_symname PARAMS ((bfd *, struct disassemble_info *, asymbol *));
d133 1
a133 4
				     struct disassemble_info *, boolean));

static void
objdump_print_addr PARAMS ((bfd_vma, struct disassemble_info *, boolean));
a150 24

static asymbol **
slurp_symtab PARAMS ((bfd *));

static asymbol **
slurp_dynamic_symtab PARAMS ((bfd *));

static long
remove_useless_symbols PARAMS ((asymbol **, long));

static int
compare_symbols PARAMS ((const PTR, const PTR));

static int
compare_relocs PARAMS ((const PTR, const PTR));

static void
dump_stabs PARAMS ((bfd *));

static boolean
read_section_stabs PARAMS ((bfd *, const char *, const char *));

static void
print_section_stabs PARAMS ((bfd *, const char *, const char *));
d158 1
a158 1
Usage: %s [-ahifCdDprRtTxsSlw] [-b bfdname] [-m machine] [-j section-name]\n\
d160 1
a160 2
       [--disassemble-all] [--disassemble-zeroes] [--file-headers]\n\
       [--section-headers] [--headers]\n\
d168 2
a169 2
       [--prefix-addresses] [--[no-]show-raw-insn] [--demangle]\n\
       [--adjust-vma=offset] [-EB|-EL] [--endian={big|little}] objfile...\n\
a181 1
#define OPTION_ADJUST_VMA (OPTION_STOP_ADDRESS + 1)
a184 1
  {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
a189 1
  {"demangle", no_argument, &do_demangle, 1},
a191 1
  {"disassemble-zeroes", no_argument, &disassemble_zeroes, 1},
a200 1
  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
d530 1
a530 1
/* Print VMA to STREAM.  If SKIP_ZEROES is true, omit leading zeroes.  */
d533 1
a533 1
objdump_print_value (vma, info, skip_zeroes)
a535 1
     boolean skip_zeroes;
d541 4
a544 9
  if (! skip_zeroes)
    p = buf;
  else
    {
      for (p = buf; *p == '0'; ++p)
	;
      if (*p == '\0')
	--p;
    }
a547 38
/* Print the name of a symbol.  */

static void
objdump_print_symname (abfd, info, sym)
     bfd *abfd;
     struct disassemble_info *info;
     asymbol *sym;
{
  char *alloc;
  const char *name;
  const char *print;

  alloc = NULL;
  name = bfd_asymbol_name (sym);
  if (! do_demangle || name[0] == '\0')
    print = name;
  else
    {
      /* Demangle the name.  */
      if (bfd_get_symbol_leading_char (abfd) == name[0])
	++name;

      alloc = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (alloc == NULL)
	print = name;
      else
	print = alloc;
    }

  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", print);
  else
    printf ("%s", print);

  if (alloc != NULL)
    free (alloc);
}

d676 1
a676 1
objdump_print_addr_with_sym (abfd, sec, sym, vma, info, skip_zeroes)
a681 1
     boolean skip_zeroes;
d683 4
a686 1
  objdump_print_value (vma, info, skip_zeroes);
d698 1
a698 1
	  objdump_print_value (secaddr - vma, info, true);
d703 1
a703 1
	  objdump_print_value (vma - secaddr, info, true);
d709 1
a709 2
      (*info->fprintf_func) (info->stream, " <");
      objdump_print_symname (abfd, info, sym);
d713 1
a713 1
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, true);
d718 1
a718 1
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, true);
d724 1
a724 2
/* Print VMA to INFO, symbolically if possible.  If SKIP_ZEROES is
   true, don't output leading zeroes.  */
d727 1
a727 1
objdump_print_addr (vma, info, skip_zeroes)
a729 1
     boolean skip_zeroes;
d736 4
a739 1
      objdump_print_value (vma, info, skip_zeroes);
d746 1
a746 13
  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, info,
			       skip_zeroes);
}

/* Print VMA to INFO.  This function is passed to the disassembler
   routine.  */

static void
objdump_print_address (vma, info)
     bfd_vma vma;
     struct disassemble_info *info;
{
  objdump_print_addr (vma, info, ! prefix_addresses);
a1020 1
  int skip_addr_chars;
a1030 23
  /* Figure out how many characters to skip at the start of an
     address, to make the disassembly look nicer.  We discard leading
     zeroes in chunks of 4, ensuring that there is always a leading
     zero remaining.  */
  skip_addr_chars = 0;
  if (! prefix_addresses)
    {
      char buf[30];
      char *s;

      sprintf_vma (buf,
		   section->vma + bfd_section_size (section->owner, section));
      s = buf;
      while (s[0] == '0' && s[1] == '0' && s[2] == '0' && s[3] == '0'
	     && s[4] == '0')
	{
	  skip_addr_chars += 4;
	  s += 4;
	}
    }

  info->insn_info_valid = 0;

d1044 2
a1045 5
      if (! disassemble_zeroes
	  && (info->insn_info_valid == 0
	      || info->branch_delay_insns == 0)
	  && (z - i >= SKIP_ZEROES
	      || (z == stop && z - i < SKIP_ZEROES_AT_END)))
d1062 1
a1062 1
	  int bpc, pb = 0;
d1070 1
a1070 10
	    {
	      char *s;

	      sprintf_vma (buf, section->vma + i);
	      for (s = buf + skip_addr_chars; *s == '0'; s++)
		*s = ' ';
	      if (*s == '\0')
		*--s = '0';
	      printf ("%s:\t", buf + skip_addr_chars);
	    }
a1084 1
	      info->bytes_per_chunk = 0;
d1111 1
a1111 3
	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
d1116 1
a1116 1
                 bytes_per_line bytes per line.  */
d1121 1
a1121 6
	      if (info->bytes_per_chunk)
		bpc = info->bytes_per_chunk;
	      else
		bpc = 1;

	      for (j = i; j < i + pb; j += bpc)
d1123 2
a1124 13
		  int k;
		  if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
		    {
		      for (k = bpc - 1; k >= 0; k--)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
		  else
		    {
		      for (k = 0; k < bpc; k++)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
d1127 2
a1128 8
	      for (; pb < bytes_per_line; pb += bpc)
		{
		  int k;

		  for (k = 0; k < bpc; k++)
		    printf ("  ");
		  putchar (' ');
		}
d1139 1
a1139 3
	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
a1143 1
		  char *s;
d1147 1
a1147 8

		  sprintf_vma (buf, section->vma + j);
		  for (s = buf + skip_addr_chars; *s == '0'; s++)
		    *s = ' ';
		  if (*s == '\0')
		    *--s = '0';
		  printf ("%s:\t", buf + skip_addr_chars);

d1151 1
a1151 1
		  for (; j < i + pb; j += bpc)
d1153 2
a1154 14
		      int k;

		      if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
			{
			  for (k = bpc - 1; k >= 0; k--)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
		      else
			{
			  for (k = 0; k < bpc; k++)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
d1173 1
d1182 1
a1182 1
	      objdump_print_value (section->vma + q->address, info, true);
d1186 2
a1187 3
	      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)
		printf ("*unknown*");
	      else
a1188 2
		  const char *sym_name;

d1190 1
a1190 3
		  if (sym_name != NULL && *sym_name != '\0')
		    objdump_print_symname (aux->abfd, info, *q->sym_ptr_ptr);
		  else
d1195 1
a1195 1
		      sym_name = bfd_get_section_name (aux->abfd, sym_sec);
a1197 1
		      printf ("%s", sym_name);
d1200 4
d1208 1
a1208 1
		  objdump_print_value (q->addend, info, true);
a1252 1
  aux.require_sec = false;
d1284 1
a1284 1
      return;
d1383 1
a1383 2
	  sym = find_symbol_for_address (abfd, section, section->vma + i,
					 true, &place);
d1391 1
a1391 4
	      if (sym != NULL && bfd_asymbol_value (sym) <= section->vma + i)
		disasm_info.symbol = sym;
	      else
		disasm_info.symbol = NULL;
d1396 1
a1396 2
					   &disasm_info,
					   false);
d1399 1
a1399 3
	      if (sym != NULL && bfd_asymbol_value (sym) > section->vma + i)
		nextsym = sym;
	      else if (sym == NULL)
d1414 1
a1414 7
	      if (sym != NULL && bfd_asymbol_value (sym) > section->vma + i)
		{
		  nextstop = bfd_asymbol_value (sym) - section->vma;
		  if (nextstop > stop)
		    nextstop = stop;
		}
	      else if (nextsym == NULL)
a1426 2
		  || sym == NULL
		  || bfd_asymbol_value (sym) > section->vma + i
d1487 2
a1488 2
     const char *stabsect_name;
     const char *strsect_name;
d1558 2
a1559 2
     const char *stabsect_name;
     const char *strsect_name;
a1711 14
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  s->vma += adjust_section_vma;
	  s->lma += adjust_section_vma;
	}
    }

d1928 2
a1929 3
	  bfd *cur_bfd = bfd_asymbol_bfd (*current);

	  if (cur_bfd != NULL)
d1931 3
a1933 30
	      const char *name;
	      char *alloc;

	      name = bfd_asymbol_name (*current);
	      alloc = NULL;
	      if (do_demangle && name != NULL && *name != '\0')
		{
		  const char *n;

		  /* If we want to demangle the name, we demangle it
                     here, and temporarily clobber it while calling
                     bfd_print_symbol.  FIXME: This is a gross hack.  */

		  n = name;
		  if (bfd_get_symbol_leading_char (cur_bfd) == *n)
		    ++n;
		  alloc = cplus_demangle (n, DMGL_ANSI | DMGL_PARAMS);
		  if (alloc != NULL)
		    (*current)->name = alloc;
		  else
		    (*current)->name = n;
		}

	      bfd_print_symbol (cur_bfd, stdout, *current,
				bfd_print_symbol_all);

	      (*current)->name = name;
	      if (alloc != NULL)
		free (alloc);

d2125 3
a2127 3
	  printf (" %-16s  ", q->howto->name);
	  objdump_print_symname (abfd, (struct disassemble_info *) NULL,
				 *q->sym_ptr_ptr);
d2283 1
a2335 1
  set_default_bfd_target ();
d2337 1
a2337 1
  while ((c = getopt_long (argc, argv, "pib:m:VCdDlfahrRtTxsSj:wE:",
a2381 3
	case 'C':
	  do_demangle = 1;
	  break;
a2413 3
	  break;
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d31 6
a45 3
/* Exit status.  */
static int exit_status = 0;

a73 1
static int file_start_context = 0;      /* --file-start-context */
a84 3
/* Target specific options to the disassembler.  */
static char *disassembler_options = (char *) NULL;

a111 3
nonfatal PARAMS ((const char *));

static void
d180 2
a181 2
			   boolean, bfd_byte *, bfd_vma, bfd_vma,
			   arelent ***, arelent **));
d218 16
a233 47
  fprintf (stream, _("Usage: %s <switches> file(s)\n"), program_name);
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
  fprintf (stream, _("\
  -a  --archive-headers    Display archive header information\n\
  -f  --file-headers       Display the contents of the overall file header\n\
  -p  --private-headers    Display object format specific file header contents\n\
  -h  --[section-]headers  Display the contents of the section headers\n\
  -x  --all-headers        Display the contents of all headers\n\
  -d  --disassemble        Display assembler contents of executable sections\n\
  -D  --disassemble-all    Display assembler contents of all sections\n\
  -S  --source             Intermix source code with disassembly\n\
  -s  --full-contents      Display the full contents of all sections requested\n\
  -g  --debugging          Display debug information in object file\n\
  -G  --stabs              Display the STABS contents of an ELF format file\n\
  -t  --syms               Display the contents of the symbol table(s)\n\
  -T  --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r  --reloc              Display the relocation entries in the file\n\
  -R  --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -V  --version            Display this program's version number\n\
  -i  --info               List object formats and architectures supported\n\
  -H  --help               Display this information\n\
"));
  if (status != 2)
    {
      fprintf (stream, _("\n The following switches are optional:\n"));
      fprintf (stream, _("\
  -b  --target <bfdname>         Specify the target object format as <bfdname>\n\
  -m  --architecture <machine>   Specify the target architecture as <machine>\n\
  -j  --section <name>           Only display information for section <name>\n\
  -M  --disassembler-options <o> Pass text <o> on to the disassembler\n\
  -EB --endian=big               Assume big endian format when disassembling\n\
  -EL --endian=little            Assume little endian format when disassembling\n\
      --file-start-context       Include context from start of file (with -S)\n\
  -l  --line-numbers             Include line numbers and filenames in output\n\
  -C  --demangle                 Decode mangled/processed symbol names\n\
  -w  --wide                     Format output for more than 80 columns\n\
  -z  --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address <addr>     Only process data whoes address is >= <addr>\n\
      --stop-address <addr>      Only process data whoes address is <= <addr>\n\
      --prefix-addresses         Print complete address alongside disassembly\n\
      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n\
      --adjust-vma <offset>      Add <offset> to all displayed section addresses\n\
\n"));
      list_supported_targets (program_name, stream);
      
      disassembler_usage (stream);
    }
d235 1
a235 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d253 2
a254 2
  {"debugging", no_argument, NULL, 'g'},
  {"demangle", no_argument, NULL, 'C'},
d257 1
a257 2
  {"disassembler-options", required_argument, NULL, 'M'},
  {"disassemble-zeroes", no_argument, NULL, 'z'},
a261 1
  {"file-start-context", no_argument, &file_start_context, 1},
d274 1
a274 1
  {"stabs", no_argument, NULL, 'G'},
d279 2
a280 2
  {"version", no_argument, NULL, 'V'},
  {"wide", no_argument, NULL, 'w'},
a284 8
nonfatal (msg)
     const char *msg;
{
  bfd_nonfatal (msg);
  exit_status = 1;
}

static void
d286 1
a286 1
     bfd *abfd ATTRIBUTE_UNUSED;
d288 1
a288 1
     PTR ignored ATTRIBUTE_UNUSED;
a290 1
  unsigned int opb = bfd_octets_per_byte (abfd);
d294 1
a294 1
	  (unsigned long) bfd_section_size (abfd, section) / opb);
a325 2
  PF (SEC_SMALL_DATA, "SMALL_DATA");
  PF (SEC_SHARED, "SHARED");
a348 5

      if (section->comdat != NULL)
	printf (" (COMDAT %s %ld)", section->comdat->name,
		section->comdat->symbol);

d360 1
a360 2
  printf (_("Sections:\n"));

d362 1
a362 1
  printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
d364 1
a364 1
  printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
a365 5

  if (wide_output)
    printf (_("  Flags"));
  printf ("\n");

d378 1
a378 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d395 2
a396 1
    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d414 2
a415 1
	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
d431 2
a432 1
    non_fatal (_("%s: No dynamic symbols"), bfd_get_filename (abfd));
a680 1
  unsigned int opb = bfd_octets_per_byte (abfd); 
d728 1
a728 1
			+ bfd_section_size (abfd, sec) / opb))))
d806 1
a806 1
	  (*info->fprintf_func) (info->stream, "-0x");
d811 1
a811 1
	  (*info->fprintf_func) (info->stream, "+0x");
d822 1
a822 1
	  (*info->fprintf_func) (info->stream, "-0x");
d827 1
a827 1
	  (*info->fprintf_func) (info->stream, "+0x");
a847 1
      (*info->fprintf_func) (info->stream, "0x");
a869 21
/* Determine of the given address has a symbol associated with it.  */

static int
objdump_symbol_at_address (vma, info)
     bfd_vma vma;
     struct disassemble_info * info;
{
  struct objdump_disasm_info * aux;
  asymbol * sym;

  /* No symbols - do not bother checking.  */
  if (sorted_symcount < 1)
    return 0;

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 (long *) NULL);

  return (sym != NULL && (bfd_asymbol_value (sym) == vma));
}

d930 1
a930 1
show_line (abfd, section, addr_offset)
d933 1
a933 1
     bfd_vma addr_offset;
d942 1
a942 1
  if (! bfd_find_nearest_line (abfd, section, syms, addr_offset, &filename,
d994 2
a995 2
		  if (l < 0)
		    l = 0;
d1045 3
a1047 6
              if (file_start_context)
                l = 0;
              else
                l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l < 0)
		l = 0;
d1070 1
a1070 2
typedef struct
{
a1071 1
  size_t size;
d1077 1
a1078 1
#ifdef ANSI_PROTOTYPES
d1080 10
d1091 1
a1093 1
#endif
d1095 1
a1095 1
#ifndef ANSI_PROTOTYPES
a1097 2
#endif
  char *buf;
a1098 1
  size_t n;
a1099 3
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
d1103 2
a1104 4
#endif

  vasprintf (&buf, format, args);

a1105 24

  if (buf == NULL)
    {
      fatal (_("Out of virtual memory"));
    }

  n = strlen (buf);

  while ((size_t) ((f->buffer + f->size) - f->current) < n + 1)
    {
      size_t curroff;

      curroff = f->current - f->buffer;
      f->size *= 2;
      f->buffer = xrealloc (f->buffer, f->size);
      f->current = f->buffer + curroff;
    }

  memcpy (f->current, buf, n);
  f->current += n;
  f->current[0] = '\0';

  free (buf);

d1108 1
d1127 1
a1127 2
disassemble_bytes (info, disassemble_fn, insns, data, 
                   start_offset, stop_offset, relppp,
d1133 2
a1134 2
     bfd_vma start_offset;
     bfd_vma stop_offset;
d1140 1
a1140 1
  int octets_per_line;
d1143 1
a1143 2
  bfd_vma addr_offset;
  int opb = info->octets_per_byte;
d1149 1
a1149 1
    octets_per_line = 4;
d1151 1
a1151 1
    octets_per_line = 16;
d1163 2
a1164 2
      sprintf_vma (buf, section->vma + 
                   bfd_section_size (section->owner, section) / opb);
d1177 2
a1178 2
  addr_offset = start_offset;
  while (addr_offset < stop_offset)
d1180 2
a1181 2
      bfd_vma z;
      int octets = 0;
d1184 1
a1184 1
      /* If we see more than SKIP_ZEROES octets of zeroes, we just
d1186 1
a1186 1
      for (z = addr_offset * opb; z < stop_offset * opb; z++)
d1192 2
a1193 3
	  && (z - addr_offset * opb >= SKIP_ZEROES
	      || (z == stop_offset * opb && 
                  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
d1197 1
a1197 1
	  /* If there are more nonzero octets to follow, we only skip
d1201 2
a1202 2
	  if (z != stop_offset * opb)
	    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);
d1204 1
a1204 1
	  octets = z - addr_offset * opb;
d1208 1
a1208 1
	  char buf[50];
d1210 1
a1210 2
	  int bpc = 0;
	  int pb = 0;
d1215 1
a1215 1
	    show_line (aux->abfd, section, addr_offset);
d1221 1
a1221 1
	      sprintf_vma (buf, section->vma + addr_offset);
d1231 1
a1231 1
	      objdump_print_address (section->vma + addr_offset, info);
d1238 1
a1238 3
	      sfile.size = 120;
	      sfile.buffer = xmalloc (sfile.size);
	      sfile.current = sfile.buffer;
d1243 1
a1243 11

	      /* FIXME: This is wrong.  It tests the number of octets
                 in the last instruction, not the current one.  */
	      if (*relppp < relppend
		  && (**relppp)->address >= addr_offset
		  && (**relppp)->address < addr_offset + octets / opb)
		info->flags = INSN_HAS_RELOC;
	      else
		info->flags = 0;

	      octets = (*disassemble_fn) (section->vma + addr_offset, info);
d1247 3
a1249 8
		octets_per_line = info->bytes_per_line;
	      if (octets < 0)
		{
		  if (sfile.current != sfile.buffer)
		    printf ("%s\n", sfile.buffer);
		  free (sfile.buffer);
		  break;
		}
d1253 1
a1253 1
	      bfd_vma j;
d1255 3
a1257 3
	      octets = octets_per_line;
	      if (addr_offset + octets / opb > stop_offset)
		octets = (stop_offset - addr_offset) * opb;
d1259 1
a1259 1
	      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)
d1262 1
a1262 1
		    buf[j - addr_offset * opb] = data[j];
d1264 1
a1264 1
		    buf[j - addr_offset * opb] = '.';
d1266 1
a1266 1
	      buf[j - addr_offset * opb] = '\0';
d1273 1
a1273 1
	      bfd_vma j;
d1276 4
a1279 4
                 octets_per_line octets per line.  */
	      pb = octets;
	      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)
		pb = octets_per_line;
d1286 1
a1286 1
	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
d1303 1
a1303 1
	      for (; pb < octets_per_line; pb += bpc)
d1319 1
a1319 7
	  if (! insns)
	    printf ("%s", buf);
	  else
	    {
	      printf ("%s", sfile.buffer);
	      free (sfile.buffer);
	    }
d1325 1
a1325 1
	      while (pb < octets)
d1327 1
a1327 1
		  bfd_vma j;
d1331 1
a1331 1
		  j = addr_offset * opb + pb;
d1333 1
a1333 1
		  sprintf_vma (buf, section->vma + j / opb);
d1340 4
a1343 4
		  pb += octets_per_line;
		  if (pb > octets)
		    pb = octets;
		  for (; j < addr_offset * opb + pb; j += bpc)
d1373 2
a1374 2
		 && ((**relppp)->address >= (bfd_vma) addr_offset
		     && (**relppp)->address < (bfd_vma) addr_offset + octets / opb))
d1425 1
a1425 1
      addr_offset += octets / opb;
d1435 1
a1435 1
  unsigned long addr_offset;
a1439 1
  unsigned int opb;
a1459 1
  disasm_info.symbol_at_address_func = objdump_symbol_at_address;
d1466 4
a1469 1
	  fatal (_("Can't use supplied machine %s"), machine);
d1487 3
a1489 3
      non_fatal (_("Can't disassemble for architecture %s\n"),
		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
      exit_status = 1;
a1492 2
  opb = bfd_octets_per_byte (abfd);

a1495 3
  disasm_info.disassembler_options = disassembler_options;
  disasm_info.octets_per_byte = opb;
  
d1497 1
a1497 1
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;
d1499 1
a1499 1
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_LITTLE;
d1514 1
a1514 3
      unsigned long stop_offset;
      asymbol *sym = NULL;
      long place = 0;
a1546 9

	      /* Skip over the relocs belonging to addresses below the
		 start address.  */
	      if (start_address != (bfd_vma) -1)
		{
		  while (relpp < relppend
			 && (*relpp)->address < start_address)
		    ++relpp;
		}
d1550 1
a1550 1
      printf (_("Disassembly of section %s:\n"), section->name);
d1566 1
a1566 1
	addr_offset = 0;
d1568 1
a1568 1
	addr_offset = start_address - disasm_info.buffer_vma;
d1570 1
a1570 1
	stop_offset = datasize / opb;
d1574 1
a1574 1
	    stop_offset = 0;
d1576 3
a1578 3
	    stop_offset = stop_address - disasm_info.buffer_vma;
	  if (stop_offset > disasm_info.buffer_length / opb)
	    stop_offset = disasm_info.buffer_length / opb;
d1581 7
a1587 2
      sym = find_symbol_for_address (abfd, section, section->vma + addr_offset,
				     true, &place);
d1589 8
a1596 9
      while (addr_offset < stop_offset)
	{
	  asymbol *nextsym;
	  unsigned long nextstop_offset;
	  boolean insns;
	  
	  if (sym != NULL && bfd_asymbol_value (sym) <= section->vma + addr_offset)
	    {
	      int x;
d1598 4
a1601 10
	      for (x = place;
		   (x < sorted_symcount
		    && bfd_asymbol_value (sorted_syms[x]) <= section->vma + addr_offset);
		   ++x)
		continue;
	      disasm_info.symbols = & sorted_syms[place];
	      disasm_info.num_symbols = x - place;
	    }
	  else
	    disasm_info.symbols = NULL;
a1602 2
	  if (! prefix_addresses)
	    {
d1605 1
a1605 1
					   section->vma + addr_offset,
d1609 4
a1612 18
	    }
	  
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    nextsym = sym;
	  else if (sym == NULL)
	    nextsym = NULL;
	  else
	    {
	      /* Search forward for the next appropriate symbol in
                 SECTION.  Note that all the symbols are sorted
                 together into one big array, and that some sections
                 may have overlapping addresses.  */
	      while (place < sorted_symcount
		     && (sorted_syms[place]->section != section
			 || (bfd_asymbol_value (sorted_syms[place])
			     <= bfd_asymbol_value (sym))))
		++place;
	      if (place >= sorted_symcount)
d1615 48
a1662 8
		nextsym = sorted_syms[place];
	    }
	  
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    {
	      nextstop_offset = bfd_asymbol_value (sym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
a1663 30
	  else if (nextsym == NULL)
	    nextstop_offset = stop_offset;
	  else
	    {
	      nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
	    }
	  
	  /* If a symbol is explicitly marked as being an object
	     rather than a function, just dump the bytes without
	     disassembling them.  */
	  if (disassemble_all
	      || sym == NULL
	      || bfd_asymbol_value (sym) > section->vma + addr_offset
	      || ((sym->flags & BSF_OBJECT) == 0
		  && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		      == NULL)
		  && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		      == NULL))
	      || (sym->flags & BSF_FUNCTION) != 0)
	    insns = true;
	  else
	    insns = false;
	  
	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data, 
                             addr_offset, nextstop_offset, &relpp, relppend);
	  
	  addr_offset = nextstop_offset;
	  sym = nextsym;
d1665 1
a1665 1
      
d1716 1
a1716 1
      printf (_("No %s section present\n\n"), stabsect_name);
d1723 2
a1724 3
      non_fatal (_("%s has no %s section"),
		 bfd_get_filename (abfd), strsect_name);
      exit_status = 1;
d1736 3
a1738 3
      non_fatal (_("Reading %s section of %s failed: %s"),
		 stabsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
a1740 1
      exit_status = 1;
d1747 3
a1749 3
      non_fatal (_("Reading %s section of %s failed: %s\n"),
		 strsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
a1751 1
      exit_status = 1;
d1780 1
a1780 1
     const char *strsect_name ATTRIBUTE_UNUSED;
d1789 1
a1789 1
  printf (_("Contents of %s section:\n\n"), stabsect_name);
d1866 3
a1868 3
      /* If the prefix matches, and the files section name ends with a
	 nul or a digit, then we match.  I.e., we want either an exact
	 match or a section followed by a number.  */
d1870 1
a1870 2
	  && (s->name[len] == '\000'
	      || isdigit ((unsigned char) s->name[len])))
d1888 1
a1888 1
  printf (_("architecture: %s, "),
d1891 1
a1891 1
  printf (_("flags 0x%08x:\n"), abfd->flags);
d1904 1
a1904 1
  printf (_("\nstart address 0x"));
a1915 2
/* Dump selected contents of ABFD */

d1917 1
a1917 1
dump_bfd (abfd)
d1920 13
d1947 1
a1947 1
  printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
d1988 2
a1989 5
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
a2004 41
display_bfd (abfd)
     bfd *abfd;
{
  char **matching;

  if (bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
    }

  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }

  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
d2014 1
a2014 1
      nonfatal (filename);
d2022 1
a2022 1
      printf (_("In archive %s:\n"), bfd_get_filename (file));
d2031 3
a2033 1
		nonfatal (bfd_get_filename (file));
d2062 2
a2063 3
  bfd_size_type addr_offset;
  bfd_size_type start_offset, stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);
d2075 1
a2075 1
	      printf (_("Contents of section %s:\n"), section->name);
d2087 1
a2087 1
		start_offset = 0;
d2089 1
a2089 1
		start_offset = start_address - section->vma;
d2091 1
a2091 1
		stop_offset = bfd_section_size (abfd, section) / opb;
d2095 1
a2095 1
		    stop_offset = 0;
d2097 3
a2099 3
		    stop_offset = stop_address - section->vma;
		  if (stop_offset > bfd_section_size (abfd, section) / opb)
		    stop_offset = bfd_section_size (abfd, section) / opb;
d2101 1
a2101 2
	      for (addr_offset = start_offset; 
                   addr_offset < stop_offset; addr_offset += onaline)
d2105 2
a2106 4
		  printf (" %04lx ", (unsigned long int) 
                          (addr_offset + section->vma));
		  for (j = addr_offset * opb; 
                       j < addr_offset * opb + onaline; j++)
d2108 1
a2108 1
		      if (j < stop_offset * opb)
d2117 1
a2117 1
		  for (j = addr_offset; j < addr_offset * opb + onaline; j++)
d2119 1
a2119 1
		      if (j >= stop_offset * opb)
d2135 1
a2135 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2388 1
a2388 4
	  if (q->howto->name)
	    printf (" %-16s  ", q->howto->name);
	  else
	    printf (" %-16d  ", q->howto->type);
d2448 1
a2448 1
	  nonfatal (dummy_name);
d2455 1
a2455 2
	    nonfatal (p->name);
	  bfd_close_all_done (abfd);
a2462 1
      bfd_close_all_done (abfd);
d2501 1
a2501 1
		nonfatal (p->name);
d2510 1
a2510 1
		      nonfatal (p->name);
a2529 2
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
d2578 1
a2578 1
  printf (_("BFD header file version %s\n"), BFD_VERSION);
a2591 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d2600 1
a2600 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VCdDlfahHrRtTxsSj:wE:zgG",
d2604 2
a2612 3
	case 'M':
	  disassembler_options = optarg;
	  break;
d2617 1
a2617 1
	  with_line_numbers = true;
a2621 38
	case 'C':
	  do_demangle = true;
	  break;
	case 'w':
	  wide_output = true;
	  break;
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
	  break;
	case OPTION_START_ADDRESS:
	  start_address = parse_vma (optarg, "--start-address");
	  break;
	case OPTION_STOP_ADDRESS:
	  stop_address = parse_vma (optarg, "--stop-address");
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      non_fatal (_("unrecognized -E option"));
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
	      usage (stderr, 1);
	    }
	  break;
	  
a2623 1
	  seenflag = true;
a2626 1
	  seenflag = true;
d2629 1
a2629 2
	  dump_private_headers = true;
	  seenflag = true;
d2632 3
a2634 3
	  dump_private_headers = true;
	  dump_symtab = true;
	  dump_reloc_info = true;
d2636 2
a2637 3
	  dump_ar_hdrs = true;
	  dump_section_headers = true;
	  seenflag = true;
d2640 1
a2640 2
	  dump_symtab = true;
	  seenflag = true;
d2643 4
a2646 2
	  dump_dynamic_symtab = true;
	  seenflag = true;
a2649 4
	  seenflag = true;
	  break;
	case 'z':
	  disassemble_zeroes = true;
d2652 1
a2652 3
	  disassemble = true;
	  disassemble_all = true;
	  seenflag = true;
a2656 9
	  seenflag = true;
	  break;
	case 'g':
	  dump_debugging = 1;
	  seenflag = true;
	  break;
	case 'G':
	  dump_stab_section_info = true;
	  seenflag = true;
d2659 1
a2659 2
	  dump_section_contents = true;
	  seenflag = true;
d2662 1
a2662 2
	  dump_reloc_info = true;
	  seenflag = true;
d2665 1
a2665 2
	  dump_dynamic_reloc_info = true;
	  seenflag = true;
d2668 1
a2668 2
	  dump_ar_hdrs = true;
	  seenflag = true;
d2671 1
a2671 2
	  dump_section_headers = true;
	  seenflag = true;
a2674 1
	  seenflag = true;
d2676 36
a2711 2
	  show_version = true;
	  seenflag = true;
a2712 1
	  
d2722 1
a2722 1
    usage (stderr, 2);
d2725 3
a2727 1
    display_info ();
d2739 1
a2739 1
  return exit_status;
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d223 2
a224 3
  fprintf (stream, _("Usage: %s OPTION... FILE...\n"), program_name);
  fprintf (stream, _("Display information from object FILE.\n"));
  fprintf (stream, _("\n At least one of the following switches must be given:\n"));
d226 18
a243 18
  -a, --archive-headers    Display archive header information\n\
  -f, --file-headers       Display the contents of the overall file header\n\
  -p, --private-headers    Display object format specific file header contents\n\
  -h, --[section-]headers  Display the contents of the section headers\n\
  -x, --all-headers        Display the contents of all headers\n\
  -d, --disassemble        Display assembler contents of executable sections\n\
  -D, --disassemble-all    Display assembler contents of all sections\n\
  -S, --source             Intermix source code with disassembly\n\
  -s, --full-contents      Display the full contents of all sections requested\n\
  -g, --debugging          Display debug information in object file\n\
  -G, --stabs              Display (in raw form) any STABS info in the file\n\
  -t, --syms               Display the contents of the symbol table(s)\n\
  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r, --reloc              Display the relocation entries in the file\n\
  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -V, --version            Display this program's version number\n\
  -i, --info               List object formats and architectures supported\n\
  -H, --help               Display this information\n\
d249 4
a252 4
  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\
  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\
  -j, --section=NAME             Only display information for section NAME\n\
  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\
d256 6
a261 6
  -l, --line-numbers             Include line numbers and filenames in output\n\
  -C, --demangle                 Decode mangled/processed symbol names\n\
  -w, --wide                     Format output for more than 80 columns\n\
  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address=ADDR       Only process data whoes address is >= ADDR\n\
      --stop-address=ADDR        Only process data whoes address is <= ADDR\n\
d264 1
a264 1
      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\
d267 1
a267 1

d271 1
a271 1
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
d2609 1
a2609 1
#define LONGEST_ARCH sizeof("powerpc:common")
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d258 1
a258 3
  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\
                                  The STYLE, if specified, can be `auto', 'gnu',\n\
                                  'lucid', 'arm', 'hp', 'edg', or 'gnu-new-abi'\n\
d291 1
a291 1
  {"demangle", optional_argument, NULL, 'C'},
a373 2
  PF (SEC_BLOCK, "BLOCK");
  PF (SEC_CLINK, "CLINK");
a1356 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
d1361 1
a1361 1
		  && (**relppp)->address <= addr_offset + octets / opb)
a1363 1
#endif
d1503 2
a1504 5
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
  	  && dump_reloc_info
#endif
	  )
a1508 5
#ifdef DISASSEMBLER_NEEDS_RELOCS
	    if (! dump_reloc_info)
	      ++(*relppp);
	    else
#endif
d1664 2
a1665 5
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
	  && dump_reloc_info
#endif
	  ) 
d2630 1
a2630 1
  extern const bfd_target *const *bfd_target_vector;
d2634 1
a2634 1
  dummy_name = make_temp_file (NULL);
d2637 1
a2637 1
      const bfd_target *p = bfd_target_vector[t];
d2678 1
a2678 1
  extern const bfd_target *const *bfd_target_vector;
d2688 1
a2688 1
  dummy_name = make_temp_file (NULL);
d2696 1
a2696 1
	    const bfd_target *p = bfd_target_vector[t];
d2747 1
a2747 1
  extern const bfd_target *const *bfd_target_vector;
a2833 11
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;
	      
	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling) 
		fatal (_("unknown demangling style `%s'"),
		       optarg);
	      
	      cplus_demangle_set_style (style);
           }
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of GNU Binutils.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
#include "bfdver.h"
d26 1
a26 3
#include "budemang.h"
#include "getopt.h"
#include "safe-ctype.h"
d39 1
a39 2
extern int fprintf
  PARAMS ((FILE *, const char *, ...));
d45 1
a45 1
static char *default_target = NULL;	/* Default at runtime.  */
d47 1
a47 1
static int show_version = 0;		/* Show the version number.  */
d50 1
a50 1
static bfd_boolean dump_file_header;	/* -f */
d59 1
a59 1
static bfd_boolean with_source_code;	/* -S */
d63 2
a64 2
static bfd_boolean disassemble;		/* -d */
static bfd_boolean disassemble_all;	/* -D */
d66 1
a66 1
static bfd_boolean formats_info;	/* -i */
d76 1
a76 2
struct objdump_disasm_info
{
d79 1
a79 1
  bfd_boolean require_sec;
d109 100
a208 2
static bfd_byte *stabs;
static bfd_size_type stab_size;
d210 2
a211 2
static char *strtab;
static bfd_size_type stabstr_size;
d213 2
a214 1
/* Static declarations.  */
d216 2
a217 68
static void usage
  PARAMS ((FILE *, int));
static void nonfatal
  PARAMS ((const char *));
static void display_file
  PARAMS ((char *, char *));
static void dump_section_header
  PARAMS ((bfd *, asection *, PTR));
static void dump_headers
  PARAMS ((bfd *));
static void dump_data
  PARAMS ((bfd *));
static void dump_relocs
  PARAMS ((bfd *));
static void dump_dynamic_relocs
  PARAMS ((bfd *));
static void dump_reloc_set
  PARAMS ((bfd *, asection *, arelent **, long));
static void dump_symbols
  PARAMS ((bfd *, bfd_boolean));
static void dump_bfd_header
  PARAMS ((bfd *));
static void dump_bfd_private_header
  PARAMS ((bfd *));
static void dump_bfd
  PARAMS ((bfd *));
static void display_bfd
  PARAMS ((bfd *));
static void objdump_print_value
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static void objdump_print_symname
  PARAMS ((bfd *, struct disassemble_info *, asymbol *));
static asymbol *find_symbol_for_address
  PARAMS ((bfd *, asection *, bfd_vma, bfd_boolean, long *));
static void objdump_print_addr_with_sym
  PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
	   struct disassemble_info *, bfd_boolean));
static void objdump_print_addr
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static void objdump_print_address
  PARAMS ((bfd_vma, struct disassemble_info *));
static int objdump_symbol_at_address
  PARAMS ((bfd_vma, struct disassemble_info *));
static void show_line
  PARAMS ((bfd *, asection *, bfd_vma));
static void disassemble_bytes
  PARAMS ((struct disassemble_info *, disassembler_ftype, bfd_boolean,
	   bfd_byte *, bfd_vma, bfd_vma, arelent ***, arelent **));
static void disassemble_data
  PARAMS ((bfd *));
static asymbol ** slurp_symtab
  PARAMS ((bfd *));
static asymbol ** slurp_dynamic_symtab
  PARAMS ((bfd *));
static long remove_useless_symbols
  PARAMS ((asymbol **, long));
static int compare_symbols
  PARAMS ((const PTR, const PTR));
static int compare_relocs
  PARAMS ((const PTR, const PTR));
static void dump_stabs
  PARAMS ((bfd *));
static bfd_boolean read_section_stabs
  PARAMS ((bfd *, const char *, const char *));
static void print_section_stabs
  PARAMS ((bfd *, const char *, const char *));
static void dump_section_stabs
  PARAMS ((bfd *, char *, char *));
d224 3
a226 3
  fprintf (stream, _("Usage: %s <option(s)> <file(s)>\n"), program_name);
  fprintf (stream, _(" Display information from object <file(s)>.\n"));
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
d243 1
a243 1
  -v, --version            Display this program's version number\n\
d260 2
a261 3
                                  The STYLE, if specified, can be `auto', `gnu',\n\
                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                                  or `gnat'\n\
d264 2
a265 2
      --start-address=ADDR       Only process data whose address is >= ADDR\n\
      --stop-address=ADDR        Only process data whose address is <= ADDR\n\
a270 1
      list_supported_architectures (program_name, stream);
d346 1
a346 1
  bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));
d348 2
a349 2
  bfd_printf_vma (abfd, section->lma);
  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
d361 3
d366 3
a380 2
  PF (SEC_ARCH_BIT_0, "ARCH_BIT_0");
  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");
d425 1
a425 5
  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
  if (bfd_get_arch_size (abfd) == 32)
    printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
  else
    printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
a429 2
  if (abfd->flags & HAS_LOAD_PAGE)
    printf (_("  Pg"));
d444 1
d452 1
d454 3
a456 2
    sy = (asymbol **) xmalloc (storage);

d460 2
d486 1
d488 3
a490 2
    sy = (asymbol **) xmalloc (storage);

d494 2
d501 1
a501 1
   Return the number of useful symbols.  */
d529 1
a529 1
static int
d538 1
a538 1
  bfd_boolean af, bf;
d558 1
d660 1
a660 1
/* Print VMA to STREAM.  If SKIP_ZEROES is TRUE, omit leading zeroes.  */
d666 1
a666 1
     bfd_boolean skip_zeroes;
a669 2
  struct objdump_disasm_info *aux
    = (struct objdump_disasm_info *) info->application_data;
d671 1
a671 1
  bfd_sprintf_vma (aux->abfd, buf, vma);
d694 1
d698 3
a700 1
  if (do_demangle && name[0] != '\0')
d703 8
a710 2
      alloc = demangle (abfd, name);
      name = alloc;
d714 1
a714 1
    (*info->fprintf_func) (info->stream, "%s", name);
d716 1
a716 1
    printf ("%s", name);
d723 1
a723 1
   is TRUE, then always require the symbol to be in the section.  This
d732 1
a732 1
     bfd_boolean require_sec;
d744 1
a744 1
  unsigned int opb = bfd_octets_per_byte (abfd);
d781 1
a781 1

d786 1
a801 1

a802 1

d857 1
a857 1
     bfd_boolean skip_zeroes;
d871 1
a871 1
	  objdump_print_value (secaddr - vma, info, TRUE);
d876 1
a876 1
	  objdump_print_value (vma - secaddr, info, TRUE);
d887 1
a887 1
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, TRUE);
d892 1
a892 1
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, TRUE);
d899 1
a899 1
   TRUE, don't output leading zeroes.  */
d905 1
a905 1
     bfd_boolean skip_zeroes;
d984 2
a985 2
static void skip_to_line
  PARAMS ((struct print_file_list *, unsigned int, bfd_boolean));
d991 1
a991 1
     bfd_boolean show;
d1010 1
a1010 1
}
d1021 2
a1022 2
  const char *filename;
  const char *functionname;
d1090 1
a1090 1
		skip_to_line (p, l, FALSE);
d1101 1
a1101 1
	      skip_to_line (p, line, TRUE);
d1131 4
a1134 4
	      if (file_start_context)
		l = 0;
	      else
		l = line - SHOW_PRECEDING_CONTEXT_LINES;
d1137 1
a1137 1
	      skip_to_line (p, l, FALSE);
d1139 1
a1139 1
		skip_to_line (p, line, TRUE);
d1169 6
a1174 1
objdump_sprintf VPARAMS ((SFILE *f, const char *format, ...))
d1176 4
d1181 1
d1184 7
a1190 3
  VA_OPEN (args, format);
  VA_FIXEDARG (args, SFILE *, f);
  VA_FIXEDARG (args, const char *, format);
d1194 2
a1197 1
      va_end (args);
a1218 1
  VA_CLOSE (args);
a1224 1
#ifndef SKIP_ZEROES
a1225 1
#endif
a1233 1
#ifndef SKIP_ZEROES_AT_END
a1234 1
#endif
d1239 2
a1240 2
disassemble_bytes (info, disassemble_fn, insns, data,
		   start_offset, stop_offset, relppp,
d1244 1
a1244 1
     bfd_boolean insns;
d1254 1
a1254 1
  bfd_boolean done_dot;
d1277 2
a1278 4
      bfd_sprintf_vma
	(aux->abfd, buf,
	 (section->vma
	  + bfd_section_size (section->owner, section) / opb));
d1290 1
a1290 1
  done_dot = FALSE;
d1296 1
a1296 1
      bfd_boolean need_nl = FALSE;
d1307 2
a1308 2
	      || (z == stop_offset * opb &&
		  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
d1328 1
a1328 1
	  done_dot = FALSE;
d1331 1
a1331 4
	    /* The line number tables will refer to unadjusted
	       section VMAs, so we must undo any VMA modifications
	       when calling show_line.  */
	    show_line (aux->abfd, section, addr_offset - adjust_section_vma);
d1337 1
a1337 1
	      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);
d1346 1
a1346 1
	      aux->require_sec = TRUE;
d1348 1
a1348 1
	      aux->require_sec = FALSE;
d1396 1
a1396 1
		  if (ISPRINT (data[j]))
d1474 1
a1474 1
		  bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);
d1507 1
a1507 1
	    need_nl = TRUE;
d1511 2
a1512 2
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
d1534 1
a1534 1
	      objdump_print_value (section->vma + q->address, info, TRUE);
d1562 1
a1562 1
		  objdump_print_value (q->addend, info, TRUE);
d1566 1
a1566 1
	      need_nl = FALSE;
d1602 1
a1602 1
  /* Sort the symbols into section and symbol order.  */
d1605 1
a1605 2
  INIT_DISASSEMBLE_INFO (disasm_info, stdout, fprintf);

d1608 1
a1608 1
  aux.require_sec = FALSE;
a1614 1

d1616 3
a1618 2
	fatal (_("Can't use supplied machine %s"), machine);

d1648 1
a1648 1

d1680 1
a1680 1
#ifndef DISASSEMBLER_NEEDS_RELOCS
d1683 1
a1683 1
	  )
d1709 5
a1713 3
		while (relpp < relppend
		       && (*relpp)->address < start_address)
		  ++relpp;
a1730 2
      disasm_info.section = section;

a1735 1

d1749 1
a1749 1
				     TRUE, &place);
d1755 2
a1756 2
	  bfd_boolean insns;

a1765 1

d1774 1
a1774 1
	      (* disasm_info.fprintf_func) (disasm_info.stream, "\n");
d1778 2
a1779 2
					   FALSE);
	      (* disasm_info.fprintf_func) (disasm_info.stream, ":\n");
d1781 1
a1781 1

d1802 1
a1802 1

d1817 1
a1817 1

d1830 1
a1830 1
	    insns = TRUE;
d1832 5
a1836 5
	    insns = FALSE;

	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data,
			     addr_offset, nextstop_offset, &relpp, relppend);

d1840 1
a1840 1

a1841 1

d1848 8
d1869 6
d1877 2
a1878 2
   If the section exists and was read, allocate the space and return TRUE.
   Otherwise return FALSE.  */
d1880 1
a1880 1
static bfd_boolean
d1892 1
a1892 1
      return FALSE;
d1901 1
a1901 1
      return FALSE;
d1903 1
a1903 1

d1909 1
a1909 1

d1918 1
a1918 1
      return FALSE;
d1930 1
a1930 1
      return FALSE;
d1933 1
a1933 1
  return TRUE;
d1974 1
d1991 1
a1991 1
	 again (makes consistent formatting for tools like awk).  */
d2000 1
a2000 1
      bfd_printf_vma (abfd, value);
d2006 1
d2016 1
d2049 1
a2049 1
	      || ISDIGIT (s->name[len])))
a2059 1

a2082 1
  PF (HAS_LOAD_PAGE, "HAS_LOAD_PAGE");
d2084 1
a2084 1
  bfd_printf_vma (abfd, abfd->start_address);
a2086 1

d2095 1
a2095 1
/* Dump selected contents of ABFD.  */
d2118 1
a2118 1
    print_arelt_descr (stdout, abfd, TRUE);
a2125 1

d2127 3
a2129 1
    syms = slurp_symtab (abfd);
d2131 3
a2133 2
    dynsyms = slurp_dynamic_symtab (abfd);

d2135 1
a2135 1
    dump_symbols (abfd, FALSE);
d2137 1
a2137 1
    dump_symbols (abfd, TRUE);
a2162 1

a2167 1

d2230 1
a2230 1
  if (bfd_check_format (file, bfd_archive))
d2263 1
a2263 1
/* Actually display the various requested regions.  */
a2285 3
	      char buf[64];
	      int count, width;
	      
d2312 2
a2313 25

	      width = 4;

	      bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      for (addr_offset = start_offset;
		   addr_offset < stop_offset; addr_offset += onaline / opb)
d2317 4
a2320 15
		  bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
		  count = strlen (buf);
		  if (count >= sizeof (buf))
		    abort ();
		  putchar (' ');
		  while (count < width)
		    {
		      putchar ('0');
		      count++;
		    }
		  fputs (buf + count - width, stdout);
		  putchar (' ');

		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
d2331 1
a2331 2
		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
d2336 1
a2336 1
			printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
d2346 1
a2346 2
/* Should perhaps share code and display with nm?  */

d2350 1
a2350 1
     bfd_boolean dynamic;
d2360 2
d2368 2
a2372 3
  if (max == 0)
    printf (_("no symbols\n"));

d2384 1
a2384 1
	      name = (*current)->name;
d2388 2
d2393 9
a2401 2
		  alloc = demangle (cur_bfd, name);
		  (*current)->name = alloc;
a2460 1

d2464 3
a2466 1
	    printf (" (none)\n\n");
d2493 3
a2495 1
    printf (" (none)\n\n");
a2499 1

d2503 3
a2505 1
	printf (" (none)\n\n");
a2529 1

d2533 1
a2533 1
	bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
a2571 1

a2598 1

d2601 1
a2601 1
	  bfd_printf_vma (abfd, q->address);
d2611 1
a2611 1
	  if (section_name == (const char *) NULL)
d2613 1
a2613 1
	  bfd_printf_vma (abfd, q->address);
a2617 1

d2621 1
a2621 1
	  bfd_printf_vma (abfd, q->addend);
a2622 1

d2627 176
a2802 1
int main PARAMS ((int, char **));
d2811 1
a2811 1
  bfd_boolean seenflag = FALSE;
a2815 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d2827 1
a2827 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSj:wE:zgG",
d2834 1
a2834 1
	  break;		/* We've been given a long option.  */
d2845 1
a2845 1
	  with_line_numbers = TRUE;
d2851 1
a2851 1
	  do_demangle = TRUE;
d2855 1
a2855 1

d2857 1
a2857 1
	      if (style == unknown_demangling)
d2860 1
a2860 1

d2862 1
a2862 1
	    }
d2865 1
a2865 1
	  wide_output = TRUE;
d2898 1
a2898 1

d2900 2
a2901 2
	  dump_file_header = TRUE;
	  seenflag = TRUE;
d2904 2
a2905 2
	  formats_info = TRUE;
	  seenflag = TRUE;
d2908 2
a2909 2
	  dump_private_headers = TRUE;
	  seenflag = TRUE;
d2912 7
a2918 7
	  dump_private_headers = TRUE;
	  dump_symtab = TRUE;
	  dump_reloc_info = TRUE;
	  dump_file_header = TRUE;
	  dump_ar_hdrs = TRUE;
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
d2921 2
a2922 2
	  dump_symtab = TRUE;
	  seenflag = TRUE;
d2925 2
a2926 2
	  dump_dynamic_symtab = TRUE;
	  seenflag = TRUE;
d2929 2
a2930 2
	  disassemble = TRUE;
	  seenflag = TRUE;
d2933 1
a2933 1
	  disassemble_zeroes = TRUE;
d2936 3
a2938 3
	  disassemble = TRUE;
	  disassemble_all = TRUE;
	  seenflag = TRUE;
d2941 3
a2943 3
	  disassemble = TRUE;
	  with_source_code = TRUE;
	  seenflag = TRUE;
d2947 1
a2947 1
	  seenflag = TRUE;
d2950 2
a2951 2
	  dump_stab_section_info = TRUE;
	  seenflag = TRUE;
d2954 2
a2955 2
	  dump_section_contents = TRUE;
	  seenflag = TRUE;
d2958 2
a2959 2
	  dump_reloc_info = TRUE;
	  seenflag = TRUE;
d2962 2
a2963 2
	  dump_dynamic_reloc_info = TRUE;
	  seenflag = TRUE;
d2966 2
a2967 2
	  dump_ar_hdrs = TRUE;
	  seenflag = TRUE;
d2970 2
a2971 2
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
d2975 1
a2975 2
	  seenflag = TRUE;
	case 'v':
d2977 2
a2978 2
	  show_version = TRUE;
	  seenflag = TRUE;
d2980 1
a2980 1

d2989 1
a2989 1
  if (!seenflag)
d2993 1
a2993 1
    exit_status = display_info ();
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a21 29
/* Objdump overview.

   Objdump displays information about one or more object files, either on
   their own, or inside libraries.  It is commonly used as a disassembler,
   but it can also display information about file headers, symbol tables,
   relocations, debugging directives and more.

   The flow of execution is as follows:
 
   1. Command line arguments are checked for control switches and the
      information to be displayed is selected.
      
   2. Any remaining arguments are assumed to be object files, and they are
      processed in order by display_bfd().  If the file is an archive each
      of its elements is processed in turn.
      
   3. The file's target architecture and binary file format are determined
      by bfd_check_format().  If they are recognised, then dump_bfd() is
      called.

   4. dump_bfd() in turn calls separate functions to display the requested
      item(s) of information(s).  For example disassemble_data() is called if
      a disassembly has been requested.

   When disassembling the code loops through blocks of instructions bounded
   by symbols, calling disassemble_bytes() on each block.  The actual
   disassembling is done by the libopcodes library, via a function pointer
   supplied by the disassembler() function.  */

d40 3
a42 2
/* This is needed by init_disassemble_info().  */
extern int fprintf (FILE *, const char *, ...);
a49 2
/* The following variables are set based on arguments passed on the
   command line.  */
d70 1
a74 1
static int dump_debugging_tags;		/* --debugging-tags */
d78 1
a78 14
/* Pointer to an array of section names provided by
   one or more "-j secname" command line options.  */
static char **only;
/* The total number of slots in the only[] array.  */
static size_t only_size = 0;
/* The number of occupied slots in the only[] array.  */
static size_t only_used = 0;

/* Variables for handling include file path table.  */
static const char **include_paths;
static int include_path_count;

/* Extra info to pass to the section disassembler and address printing
   function.  */
d81 3
a83 6
  bfd *              abfd;
  asection *         sec;
  bfd_boolean        require_sec;
  arelent **         dynrelbuf;
  long               dynrelcount;
  disassembler_ftype disassemble_fn;
d87 1
a87 1
static char *machine = NULL;
d90 1
a90 1
static char *disassembler_options = NULL;
d118 71
d191 3
a193 1
usage (FILE *stream, int status)
a208 1
  -e, --debugging-tags     Display debug information using ctags style\n\
a228 1
  -I, --include=DIR              Add DIR to search list for source files\n\
d253 5
a257 7
enum option_values
  {
    OPTION_ENDIAN=150,
    OPTION_START_ADDRESS,
    OPTION_STOP_ADDRESS,
    OPTION_ADJUST_VMA
  };
a266 1
  {"debugging-tags", no_argument, NULL, 'e'},
a288 1
  {"include", required_argument, NULL, 'I'},
d300 2
a301 1
nonfatal (const char *msg)
d308 4
a311 2
dump_section_header (bfd *abfd ATTRIBUTE_UNUSED, asection *section,
		     void *ignored ATTRIBUTE_UNUSED)
d386 2
a387 1
dump_headers (bfd *abfd)
d407 1
a407 1
  bfd_map_over_sections (abfd, dump_section_header, NULL);
d411 2
a412 1
slurp_symtab (bfd *abfd)
d414 1
a414 1
  asymbol **sy = NULL;
d427 1
a427 1
    sy = xmalloc (storage);
d438 2
a439 1
slurp_dynamic_symtab (bfd *abfd)
d441 1
a441 1
  asymbol **sy = NULL;
d457 1
a457 1
    sy = xmalloc (storage);
d470 3
a472 1
remove_useless_symbols (asymbol **symbols, long count)
d474 1
a474 1
  asymbol **in_ptr = symbols, **out_ptr = symbols;
d496 10
a505 12
compare_symbols (const void *ap, const void *bp)
{
  const asymbol *a = * (const asymbol **) ap;
  const asymbol *b = * (const asymbol **) bp;
  const char *an;
  const char *bn;
  size_t anl;
  size_t bnl;
  bfd_boolean af;
  bfd_boolean bf;
  flagword aflags;
  flagword bflags;
d603 3
a605 1
compare_relocs (const void *ap, const void *bp)
d607 2
a608 2
  const arelent *a = * (const arelent **) ap;
  const arelent *b = * (const arelent **) bp;
d625 1
a625 2
/* Print an address (VMA) to the output stream in INFO.
   If SKIP_ZEROES is TRUE, omit leading zeroes.  */
d628 4
a631 2
objdump_print_value (bfd_vma vma, struct disassemble_info *info,
		     bfd_boolean skip_zeroes)
d635 2
a636 1
  struct objdump_disasm_info *aux;
a637 1
  aux = (struct objdump_disasm_info *) info->application_data;
d654 4
a657 2
objdump_print_symname (bfd *abfd, struct disassemble_info *info,
		       asymbol *sym)
d680 4
a683 5
/* Locate a symbol given a bfd and a section (from INFO->application_data),
   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
   require the symbol to be in the section.  Returns NULL if there is no
   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
   of the symbol in sorted_syms.  */
d686 6
a691 3
find_symbol_for_address (bfd_vma vma,
			 struct disassemble_info *info,
			 long *place)
d702 1
a702 4
  struct objdump_disasm_info *aux;
  bfd *abfd;
  asection *sec;
  unsigned int opb;
a706 5
  aux = (struct objdump_disasm_info *) info->application_data;
  abfd = aux->abfd;
  sec = aux->sec;
  opb = bfd_octets_per_byte (abfd);

d736 1
a736 1
  /* If the file is relocatable, and the symbol could be from this
d745 1
a745 1
      && (aux->require_sec
d790 1
a790 1
	  && (aux->require_sec
d795 4
a798 11
	/* There is no suitable symbol.  */
	return NULL;
    }

  /* Give the target a chance to reject the symbol.  */
  while (! info->symbol_is_valid (sorted_syms [thisplace], info))
    {
      ++ thisplace;
      if (thisplace >= sorted_symcount
	  || bfd_asymbol_value (sorted_syms [thisplace]) > vma)
	return NULL;
d807 1
a807 1
/* Print an address and the offset to the nearest symbol.  */
d810 7
a816 3
objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,
			     bfd_vma vma, struct disassemble_info *info,
			     bfd_boolean skip_zeroes)
d857 2
a858 2
/* Print an address (VMA), symbolically if possible.
   If SKIP_ZEROES is TRUE, don't output leading zeroes.  */
d861 4
a864 3
objdump_print_addr (bfd_vma vma,
		    struct disassemble_info *info,
		    bfd_boolean skip_zeroes)
d877 2
a878 1
  sym = find_symbol_for_address (vma, info, NULL);
d887 3
a889 1
objdump_print_address (bfd_vma vma, struct disassemble_info *info)
d897 3
a899 1
objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * info)
d901 1
d904 7
a910 1
  sym = find_symbol_for_address (vma, info, NULL);
d922 1
a922 1
   disassembly with source, so that we know how much of the file to
d928 1
a928 2
  const char *filename;
  const char *modname;
a939 83
/* Tries to open MODNAME, and if successful adds a node to print_files
   linked list and returns that node.  Returns NULL on failure.  */

static struct print_file_list *
try_print_file_open (const char *origname, const char *modname)
{
  struct print_file_list *p;
  FILE *f;

  f = fopen (modname, "r");
  if (f == NULL)
    return NULL;

  if (print_files != NULL && print_files->f != NULL)
    {
      fclose (print_files->f);
      print_files->f = NULL;
    }

  p = xmalloc (sizeof (struct print_file_list));
  p->filename = origname;
  p->modname = modname;
  p->line = 0;
  p->f = f;
  p->next = print_files;
  print_files = p;
  return p;
}

/* If the the source file, as described in the symtab, is not found
   try to locate it in one of the paths specified with -I
   If found, add location to print_files linked list.  */

static struct print_file_list *
update_source_path (const char *filename)
{
  struct print_file_list *p;
  const char *fname;
  int i;

  if (filename == NULL)
    return NULL;

  p = try_print_file_open (filename, filename);
  if (p != NULL)
    return p;

  if (include_path_count == 0)
    return NULL;

  /* Get the name of the file.  */
  fname = strrchr (filename, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have a mixed forward/back slash case.  */
    char *backslash = strrchr (filename, '\\');
    if (fname == NULL || (backslash != NULL && backslash > fname))
      fname = backslash;
    if (fname == NULL && filename[0] != '\0' && filename[1] == ':')
      fname = filename + 1;
  }
#endif
  if (fname == NULL)
    fname = filename;
  else
    ++fname;

  /* If file exists under a new path, we need to add it to the list
     so that show_line knows about it.  */
  for (i = 0; i < include_path_count; i++)
    {
      char *modname = concat (include_paths[i], "/", fname, (const char *) 0);

      p = try_print_file_open (filename, modname);
      if (p)
	return p;

      free (modname);
    }

  return NULL;
}

d943 3
d947 4
a950 2
skip_to_line (struct print_file_list *p, unsigned int line,
	      bfd_boolean show)
d971 1
a971 1
/* Show the line number, or the source line, in a disassembly
d975 4
a978 1
show_line (bfd *abfd, asection *section, bfd_vma addr_offset)
d1045 1
a1045 1
		  p->f = fopen (p->modname, "r");
d1068 1
a1068 1
	  p = update_source_path (filename);
d1070 2
a1071 1
	  if (p != NULL)
d1075 15
d1125 1
a1125 1
/* sprintf to a "stream".  */
d1128 1
a1128 1
objdump_sprintf (SFILE *f, const char *format, ...)
a1131 1
  va_list args;
d1133 3
a1135 1
  va_start (args, format);
d1163 1
a1163 1
  va_end (args);
a1166 18
/* Returns TRUE if the specified section should be dumped.  */

static bfd_boolean
process_section_p (asection * section)
{
  size_t i;

  if (only == NULL)
    return TRUE;

  for (i = 0; i < only_used; i++)
    if (strcmp (only [i], section->name) == 0)
      return TRUE;

  return FALSE;
}


d1188 11
a1198 9
disassemble_bytes (struct disassemble_info * info,
		   disassembler_ftype        disassemble_fn,
		   bfd_boolean               insns,
		   bfd_byte *                data,
		   bfd_vma                   start_offset,
		   bfd_vma                   stop_offset,
		   bfd_vma		     rel_offset,
		   arelent ***               relppp,
		   arelent **                relppend)
d1250 1
a1250 1
	 print `...'.  */
d1264 3
a1266 3
	     zeroes in multiples of 4, to try to avoid running over
	     the start of an instruction which happens to start with
	     zero.  */
d1318 1
a1318 1
		 in the last instruction, not the current one.  */
d1320 2
a1321 3
		  && (**relppp)->address >= rel_offset + addr_offset
		  && ((**relppp)->address
		      < rel_offset + addr_offset + octets / opb))
d1365 1
a1365 1
		 octets_per_line octets per line.  */
d1464 5
a1468 2
      while ((*relppp) < relppend
	     && (**relppp)->address < rel_offset + addr_offset + octets / opb)
d1470 8
a1477 1
	  if (dump_reloc_info || dump_dynamic_reloc_info)
d1488 1
a1488 2
	      objdump_print_value (section->vma - rel_offset + q->address,
				   info, TRUE);
d1521 1
a1522 1
	  ++(*relppp);
a1531 222
static void
disassemble_section (bfd *abfd, asection *section, void *info)
{
  struct disassemble_info *    pinfo = (struct disassemble_info *) info;
  struct objdump_disasm_info * paux;
  unsigned int                 opb = pinfo->octets_per_byte;
  bfd_byte *                   data = NULL;
  bfd_size_type                datasize = 0;
  arelent **                   rel_pp = NULL;
  arelent **                   rel_ppstart = NULL;
  arelent **                   rel_ppend;
  unsigned long                stop_offset;
  asymbol *                    sym = NULL;
  long                         place = 0;
  long                         rel_count;
  bfd_vma                      rel_offset;
  unsigned long                addr_offset;

  /* Sections that do not contain machine
     code are not normally disassembled.  */
  if (! disassemble_all
      && only == NULL
      && (section->flags & SEC_CODE) == 0)
    return;

  if (! process_section_p (section))
    return;

  datasize = bfd_get_section_size_before_reloc (section);
  if (datasize == 0)
    return;

  /* Decide which set of relocs to use.  Load them if necessary.  */
  paux = (struct objdump_disasm_info *) pinfo->application_data;
  if (paux->dynrelbuf)
    {
      rel_pp = paux->dynrelbuf;
      rel_count = paux->dynrelcount;
      /* Dynamic reloc addresses are absolute, non-dynamic are section
	 relative.  REL_OFFSET specifies the reloc address corresponding
	 to the start of this section.  */
      rel_offset = section->vma;
    }
  else
    {
      rel_count = 0;
      rel_pp = NULL;
      rel_offset = 0;

      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
	{
	  long relsize;

	  relsize = bfd_get_reloc_upper_bound (abfd, section);
	  if (relsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  if (relsize > 0)
	    {
	      rel_ppstart = rel_pp = xmalloc (relsize);
	      rel_count = bfd_canonicalize_reloc (abfd, section, rel_pp, syms);
	      if (rel_count < 0)
		bfd_fatal (bfd_get_filename (abfd));

	      /* Sort the relocs by address.  */
	      qsort (rel_pp, rel_count, sizeof (arelent *), compare_relocs);
	    }
	}

    }
  rel_ppend = rel_pp + rel_count;

  data = xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);

  paux->sec = section;
  pinfo->buffer = data;
  pinfo->buffer_vma = section->vma;
  pinfo->buffer_length = datasize;
  pinfo->section = section;

  if (start_address == (bfd_vma) -1
      || start_address < pinfo->buffer_vma)
    addr_offset = 0;
  else
    addr_offset = start_address - pinfo->buffer_vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < pinfo->buffer_vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - pinfo->buffer_vma;
      if (stop_offset > pinfo->buffer_length / opb)
	stop_offset = pinfo->buffer_length / opb;
    }

  /* Skip over the relocs belonging to addresses below the
     start address.  */
  while (rel_pp < rel_ppend
	 && (*rel_pp)->address < rel_offset + addr_offset)
    ++rel_pp;

  printf (_("Disassembly of section %s:\n"), section->name);

  /* Find the nearest symbol forwards from our current position.  */
  paux->require_sec = TRUE;
  sym = find_symbol_for_address (section->vma + addr_offset, info, &place);
  paux->require_sec = FALSE;

  /* Disassemble a block of instructions up to the address associated with
     the symbol we have just found.  Then print the symbol and find the
     next symbol on.  Repeat until we have disassembled the entire section
     or we have reached the end of the address range we are interested in.  */
  while (addr_offset < stop_offset)
    {
      bfd_vma addr;
      asymbol *nextsym;
      unsigned long nextstop_offset;
      bfd_boolean insns;

      addr = section->vma + addr_offset;

      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
	{
	  int x;

	  for (x = place;
	       (x < sorted_symcount
		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
	       ++x)
	    continue;

	  pinfo->symbols = sorted_syms + place;
	  pinfo->num_symbols = x - place;
	}
      else
	{
	  pinfo->symbols = NULL;
	  pinfo->num_symbols = 0;
	}

      if (! prefix_addresses)
	{
	  pinfo->fprintf_func (pinfo->stream, "\n");
	  objdump_print_addr_with_sym (abfd, section, sym, addr,
				       pinfo, FALSE);
	  pinfo->fprintf_func (pinfo->stream, ":\n");
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextsym = sym;
      else if (sym == NULL)
	nextsym = NULL;
      else
	{
#define is_valid_next_sym(SYM) \
  ((SYM)->section == section \
   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
   && pinfo->symbol_is_valid (SYM, pinfo))
	    
	  /* Search forward for the next appropriate symbol in
	     SECTION.  Note that all the symbols are sorted
	     together into one big array, and that some sections
	     may have overlapping addresses.  */
	  while (place < sorted_symcount
		 && ! is_valid_next_sym (sorted_syms [place]))
	    ++place;

	  if (place >= sorted_symcount)
	    nextsym = NULL;
	  else
	    nextsym = sorted_syms[place];
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
      else if (nextsym == NULL)
	nextstop_offset = stop_offset;
      else
	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;

      if (nextstop_offset > stop_offset)
	nextstop_offset = stop_offset;

      /* If a symbol is explicitly marked as being an object
	 rather than a function, just dump the bytes without
	 disassembling them.  */
      if (disassemble_all
	  || sym == NULL
	  || bfd_asymbol_value (sym) > addr
	  || ((sym->flags & BSF_OBJECT) == 0
	      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		  == NULL)
	      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		  == NULL))
	  || (sym->flags & BSF_FUNCTION) != 0)
	insns = TRUE;
      else
	insns = FALSE;

      disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,
			 addr_offset, nextstop_offset,
			 rel_offset, &rel_pp, rel_ppend);

      addr_offset = nextstop_offset;
      sym = nextsym;
    }

  free (data);

  if (rel_ppstart != NULL)
    free (rel_ppstart);
}

d1535 2
a1536 1
disassemble_data (bfd *abfd)
d1538 2
d1542 2
d1551 1
a1551 1
  sorted_syms = xmalloc (symcount * sizeof (asymbol *));
d1559 1
a1559 1
  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf);
d1561 1
a1561 1
  disasm_info.application_data = (void *) &aux;
a1563 3
  aux.dynrelbuf = NULL;
  aux.dynrelcount = 0;

d1567 1
a1567 1
  if (machine != NULL)
d1581 1
a1581 1
      xvec = xmalloc (sizeof (struct bfd_target));
d1587 2
a1588 3
  /* Use libopcodes to locate a suitable disassembler.  */
  aux.disassemble_fn = disassembler (abfd);
  if (!aux.disassemble_fn)
d1596 2
d1602 1
a1602 1
  disasm_info.octets_per_byte = bfd_octets_per_byte (abfd);
d1613 90
a1702 2
  /* Allow the target to customize the info structure.  */
  disassemble_init_for_target (& disasm_info);
d1704 2
a1705 8
  /* Pre-load the dynamic relocs if we are going
     to be dumping them along with the disassembly.  */
  if (dump_dynamic_reloc_info)
    {
      long relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));
d1707 1
a1707 1
      if (relsize > 0)
d1709 84
a1792 6
	  aux.dynrelbuf = xmalloc (relsize);
	  aux.dynrelcount = bfd_canonicalize_dynamic_reloc (abfd,
							    aux.dynrelbuf,
							    dynsyms);
	  if (aux.dynrelcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
d1794 2
a1795 3
	  /* Sort the relocs by address.  */
	  qsort (aux.dynrelbuf, aux.dynrelcount, sizeof (arelent *),
		 compare_relocs);
a1796 1
    }
d1798 1
a1798 1
  bfd_map_over_sections (abfd, disassemble_section, & disasm_info);
d1800 3
a1802 2
  if (aux.dynrelbuf != NULL)
    free (aux.dynrelbuf);
d1806 17
a1822 2
/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to
   it.  Return NULL on failure.   */
d1824 5
a1828 2
static char *
read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr)
d1830 8
a1837 3
  asection *stabsect;
  bfd_size_type size;
  char *contents;
d1839 2
a1840 2
  stabsect = bfd_get_section_by_name (abfd, sect_name);
  if (stabsect == NULL)
d1842 3
a1844 1
      printf (_("No %s section present\n\n"), sect_name);
d1848 2
a1849 2
  size = bfd_section_size (abfd, stabsect);
  contents  = xmalloc (size);
d1851 4
a1854 1
  if (! bfd_get_section_contents (abfd, stabsect, contents, 0, size))
d1857 1
a1857 1
		 sect_name, bfd_get_filename (abfd),
d1859 2
a1860 1
      free (contents);
d1862 1
a1862 1
      return NULL;
d1865 11
a1875 1
  *size_ptr = size;
d1877 1
a1877 1
  return contents;
d1888 5
a1892 5
#define STRDXOFF  (0)
#define TYPEOFF   (4)
#define OTHEROFF  (5)
#define DESCOFF   (6)
#define VALOFF    (8)
d1899 4
a1902 3
print_section_stabs (bfd *abfd,
		     const char *stabsect_name,
		     unsigned *string_offset_ptr)
d1905 1
a1905 2
  unsigned file_string_table_offset = 0;
  unsigned next_file_string_table_offset = *string_offset_ptr;
a1964 1
  *string_offset_ptr = next_file_string_table_offset;
a1966 8
typedef struct
{
  const char * section_name;
  const char * string_section_name;
  unsigned string_offset;
}
stab_section_names;

d1968 4
a1971 1
find_stabs_section (bfd *abfd, asection *section, void *names)
d1973 1
a1973 2
  int len;
  stab_section_names * sought = (stab_section_names *) names;
d1976 22
a1997 19
     handle .stab.N, etc.  */
  len = strlen (sought->section_name);

  /* If the prefix matches, and the files section name ends with a
     nul or a digit, then we match.  I.e., we want either an exact
     match or a section followed by a number.  */
  if (strncmp (sought->section_name, section->name, len) == 0
      && (section->name[len] == 0
	  || (section->name[len] == '.' && ISDIGIT (section->name[len + 1]))))
    {
      if (strtab == NULL)
	strtab = read_section_stabs (abfd, sought->string_section_name,
				     &stabstr_size);
      
      if (strtab)
	{
	  stabs = read_section_stabs (abfd, section->name, &stab_size);
	  if (stabs)
	    print_section_stabs (abfd, section->name, &sought->string_offset);
a2001 25
static void
dump_stabs_section (bfd *abfd, char *stabsect_name, char *strsect_name)
{
  stab_section_names s;

  s.section_name = stabsect_name;
  s.string_section_name = strsect_name;
  s.string_offset = 0;

  bfd_map_over_sections (abfd, find_stabs_section, & s);

  free (strtab);
  strtab = NULL;
}

/* Dump the any sections containing stabs debugging information.  */

static void
dump_stabs (bfd *abfd)
{
  dump_stabs_section (abfd, ".stab", ".stabstr");
  dump_stabs_section (abfd, ".stab.excl", ".stab.exclstr");
  dump_stabs_section (abfd, ".stab.index", ".stab.indexstr");
  dump_stabs_section (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
}
d2004 2
a2005 1
dump_bfd_header (bfd *abfd)
d2033 2
a2034 1
dump_bfd_private_header (bfd *abfd)
d2039 1
a2039 3

/* Display a section in hexadecimal format with associated characters.
   Each line prefixed by the zero padded address.  */
d2042 2
a2043 1
dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
d2045 60
a2104 11
  bfd_byte *data = 0;
  bfd_size_type datasize;
  bfd_size_type addr_offset;
  bfd_size_type start_offset;
  bfd_size_type stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);
  /* Bytes per line.  */
  const int onaline = 16;
  char buf[64];
  int count;
  int width;
d2106 5
a2110 2
  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    return;
d2112 6
a2117 5
  if (! process_section_p (section))
    return;
  
  if ((datasize = bfd_section_size (abfd, section)) == 0)
    return;
d2119 5
a2123 1
  printf (_("Contents of section %s:\n"), section->name);
d2125 5
a2129 1
  data = xmalloc (datasize);
d2131 7
a2137 1
  bfd_get_section_contents (abfd, section, data, 0, datasize);
d2139 5
a2143 6
  /* Compute the address range to display.  */
  if (start_address == (bfd_vma) -1
      || start_address < section->vma)
    start_offset = 0;
  else
    start_offset = start_address - section->vma;
d2145 1
a2145 3
  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
d2147 5
a2151 4
      if (stop_address < section->vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - section->vma;
d2153 4
a2156 2
      if (stop_offset > datasize / opb)
	stop_offset = datasize / opb;
d2158 1
d2160 6
a2165 1
  width = 4;
d2167 10
a2176 40
  bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  for (addr_offset = start_offset;
       addr_offset < stop_offset; addr_offset += onaline / opb)
    {
      bfd_size_type j;

      bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
      count = strlen (buf);
      if ((size_t) count >= sizeof (buf))
	abort ();

      putchar (' ');
      while (count < width)
	{
	  putchar ('0');
	  count++;
	}
      fputs (buf + count - width, stdout);
      putchar (' ');
d2178 2
a2179 2
      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
d2181 15
a2195 6
	  if (j < stop_offset * opb)
	    printf ("%02x", (unsigned) (data[j]));
	  else
	    printf ("  ");
	  if ((j & 3) == 3)
	    printf (" ");
d2198 2
a2199 10
      printf (" ");
      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
	{
	  if (j >= stop_offset * opb)
	    printf (" ");
	  else
	    printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
	}
      putchar ('\n');
d2201 4
a2204 1
  free (data);
d2206 1
a2206 1

d2210 2
a2211 1
dump_data (bfd *abfd)
d2213 113
a2325 1
  bfd_map_over_sections (abfd, dump_section, NULL);
d2331 3
a2333 1
dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean dynamic)
d2357 62
a2418 1
      bfd *cur_bfd;
d2420 50
a2469 6
      if (*current == NULL)
	printf (_("no information for the %ld'th symbol"), count);

      else if ((cur_bfd = bfd_asymbol_bfd (*current)) == NULL)
	printf (_("could not determine the type of the %ld'th symbol"),
		count);
d2471 4
d2477 3
a2479 19
	  const char *name = (*current)->name;

	  if (do_demangle && name != NULL && *name != '\0')
	    {
	      char *alloc;

	      /* If we want to demangle the name, we demangle it
		 here, and temporarily clobber it while calling
		 bfd_print_symbol.  FIXME: This is a gross hack.  */
	      alloc = demangle (cur_bfd, name);
	      (*current)->name = alloc;
	      bfd_print_symbol (cur_bfd, stdout, *current,
				bfd_print_symbol_all);
	      (*current)->name = name;
	      free (alloc);
	    }
	  else
	    bfd_print_symbol (cur_bfd, stdout, *current,
			      bfd_print_symbol_all);
d2481 1
a2481 3

      printf ("\n");
      current++;
a2482 1
  printf ("\n\n");
d2484 1
a2484 1

d2486 5
a2490 1
dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)
a2502 1

d2513 1
a2513 1
  for (p = relpp; relcount && *p != NULL; p++, relcount--)
d2578 2
a2579 1
	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
d2583 1
a2583 1
	  if (section_name == NULL)
d2600 2
a2602 275
static void
dump_relocs_in_section (bfd *abfd,
			asection *section,
			void *dummy ATTRIBUTE_UNUSED)
{
  arelent **relpp;
  long relcount;
  long relsize;

  if (   bfd_is_abs_section (section)
      || bfd_is_und_section (section)
      || bfd_is_com_section (section)
      || (! process_section_p (section))
      || ((section->flags & SEC_RELOC) == 0))
    return;

  relsize = bfd_get_reloc_upper_bound (abfd, section);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("RELOCATION RECORDS FOR [%s]:", section->name);

  if (relsize == 0)
    {
      printf (" (none)\n\n");
      return;
    }

  relpp = xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);

  if (relcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  else if (relcount == 0)
    printf (" (none)\n\n");
  else
    {
      printf ("\n");
      dump_reloc_set (abfd, section, relpp, relcount);
      printf ("\n\n");
    }
  free (relpp);
}

static void
dump_relocs (bfd *abfd)
{
  bfd_map_over_sections (abfd, dump_relocs_in_section, NULL);
}

static void
dump_dynamic_relocs (bfd *abfd)
{
  long relsize;
  arelent **relpp;
  long relcount;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("DYNAMIC RELOCATION RECORDS");

  if (relsize == 0)
    printf (" (none)\n\n");
  else
    {
      relpp = xmalloc (relsize);
      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);

      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
      else if (relcount == 0)
	printf (" (none)\n\n");
      else
	{
	  printf ("\n");
	  dump_reloc_set (abfd, NULL, relpp, relcount);
	  printf ("\n\n");
	}
      free (relpp);
    }
}

/* Creates a table of paths, to search for source files.  */

static void
add_include_path (const char *path)
{
  if (path[0] == 0)
    return;
  include_path_count++;
  include_paths = xrealloc (include_paths,
			    include_path_count * sizeof (*include_paths));
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (path[1] == ':' && path[2] == 0)
    path = concat (path, ".", (const char *) 0);
#endif
  include_paths[include_path_count - 1] = path;
}

static void
adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,
		  asection *section,
		  void *dummy ATTRIBUTE_UNUSED)
{
  section->vma += adjust_section_vma;
  section->lma += adjust_section_vma;
}

/* Dump selected contents of ABFD.  */

static void
dump_bfd (bfd *abfd)
{
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
    bfd_map_over_sections (abfd, adjust_addresses, NULL);

  if (! dump_debugging_tags)
    printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	    abfd->xvec->name);
  if (dump_ar_hdrs)
    print_arelt_descr (stdout, abfd, TRUE);
  if (dump_file_header)
    dump_bfd_header (abfd);
  if (dump_private_headers)
    dump_bfd_private_header (abfd);
  if (! dump_debugging_tags)
    putchar ('\n');
  if (dump_section_headers)
    dump_headers (abfd);

  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
    syms = slurp_symtab (abfd);
  if (dump_dynamic_symtab || dump_dynamic_reloc_info)
    dynsyms = slurp_dynamic_symtab (abfd);

  if (dump_symtab)
    dump_symbols (abfd, FALSE);
  if (dump_dynamic_symtab)
    dump_symbols (abfd, TRUE);
  if (dump_stab_section_info)
    dump_stabs (abfd);
  if (dump_reloc_info && ! disassemble)
    dump_relocs (abfd);
  if (dump_dynamic_reloc_info && ! disassemble)
    dump_dynamic_relocs (abfd);
  if (dump_section_contents)
    dump_data (abfd);
  if (disassemble)
    disassemble_data (abfd);

  if (dump_debugging)
    {
      void *dhandle;

      dhandle = read_debugging_info (abfd, syms, symcount);
      if (dhandle != NULL)
	{
	  if (! print_debugging_info (stdout, dhandle, abfd, syms, demangle,
	      dump_debugging_tags ? TRUE : FALSE))
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
	}
    }

  if (syms)
    {
      free (syms);
      syms = NULL;
    }

  if (dynsyms)
    {
      free (dynsyms);
      dynsyms = NULL;
    }
}

static void
display_bfd (bfd *abfd)
{
  char **matching;

  if (bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
    }

  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }

  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
display_file (char *filename, char *target)
{
  bfd *file;
  bfd *arfile = NULL;

  if (get_file_size (filename) < 1)
    return;

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

  /* If the file is an archive, process all of its elements.  */
  if (bfd_check_format (file, bfd_archive))
    {
      bfd *last_arfile = NULL;

      printf (_("In archive %s:\n"), bfd_get_filename (file));
      for (;;)
	{
	  bfd_set_error (bfd_error_no_error);

	  arfile = bfd_openr_next_archived_file (file, arfile);
	  if (arfile == NULL)
	    {
	      if (bfd_get_error () != bfd_error_no_more_archived_files)
		nonfatal (bfd_get_filename (file));
	      break;
	    }

	  display_bfd (arfile);

	  if (last_arfile != NULL)
	    bfd_close (last_arfile);
	  last_arfile = arfile;
	}

      if (last_arfile != NULL)
	bfd_close (last_arfile);
    }
  else
    display_bfd (file);

  bfd_close (file);
}

d2604 3
a2606 1
main (int argc, char **argv)
d2612 1
a2612 2
#if defined (HAVE_SETLOCALE)
#if defined (HAVE_LC_MESSAGES)
d2615 1
a2617 1

d2629 1
a2629 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSI:j:wE:zgeG",
d2641 1
a2641 6
	  if (disassembler_options)
	    /* Ignore potential memory leak for now.  */
	    disassembler_options = concat (disassembler_options, ",",
					   optarg, NULL);
	  else
	    disassembler_options = optarg;
d2644 1
a2644 6
	  if (only_used == only_size)
	    {
	      only_size += 8;
	      only = xrealloc (only, only_size * sizeof (char *));
	    }
	  only [only_used++] = optarg;
a2708 3
	case 'I':
	  add_include_path (optarg);
	  break;
a2748 6
	  seenflag = TRUE;
	  break;
	case 'e':
	  dump_debugging = 1;
	  dump_debugging_tags = 1;
	  do_demangle = TRUE;
@


