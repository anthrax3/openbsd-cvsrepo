head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.9;
commitid	dbwlUkpK0xDlII16;

1.9
date	2004.11.02.20.45.17;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.22.29.30;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.53;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.03.05;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.48.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.50;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.49.48;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.27;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.16.13;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.07;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.06.17;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.15.35;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.04;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* nm.c -- Describe symbol table of a rel file.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "progress.h"
#include "bucomm.h"
#include "budemang.h"
#include "getopt.h"
#include "aout/stab_gnu.h"
#include "aout/ranlib.h"
#include "demangle.h"
#include "libiberty.h"
#include "elf-bfd.h"
#include "elf/common.h"

/* When sorting by size, we use this structure to hold the size and a
   pointer to the minisymbol.  */

struct size_sym
{
  const void *minisym;
  bfd_vma size;
};

/* When fetching relocs, we use this structure to pass information to
   get_relocs.  */

struct get_relocs_info
{
  asection **secs;
  arelent ***relocs;
  long *relcount;
  asymbol **syms;
};

struct extended_symbol_info
{
  symbol_info *sinfo;
  bfd_vma ssize;
  elf_symbol_type *elfinfo;
  /* FIXME: We should add more fields for Type, Line, Section.  */
};
#define SYM_NAME(sym)        (sym->sinfo->name)
#define SYM_VALUE(sym)       (sym->sinfo->value)
#define SYM_TYPE(sym)        (sym->sinfo->type)
#define SYM_STAB_NAME(sym)   (sym->sinfo->stab_name)
#define SYM_STAB_DESC(sym)   (sym->sinfo->stab_desc)
#define SYM_STAB_OTHER(sym)  (sym->sinfo->stab_other)
#define SYM_SIZE(sym) \
  (sym->elfinfo ? sym->elfinfo->internal_elf_sym.st_size: sym->ssize)

static void usage (FILE *, int);
static void set_print_radix (char *);
static void set_output_format (char *);
static void display_archive (bfd *);
static bfd_boolean display_file (char *);
static void display_rel_file (bfd *, bfd *);
static long filter_symbols (bfd *, bfd_boolean, void *, long, unsigned int);
static long sort_symbols_by_size
  (bfd *, bfd_boolean, void *, long, unsigned int, struct size_sym **);
static void print_symbols
  (bfd *, bfd_boolean, void *, long, unsigned int, bfd *);
static void print_size_symbols
  (bfd *, bfd_boolean, struct size_sym *, long, bfd *);
static void print_symname (const char *, const char *, bfd *);
static void print_symbol (bfd *, asymbol *, bfd_vma ssize, bfd *);
static void print_symdef_entry (bfd *);

/* The sorting functions.  */
static int numeric_forward (const void *, const void *);
static int numeric_reverse (const void *, const void *);
static int non_numeric_forward (const void *, const void *);
static int non_numeric_reverse (const void *, const void *);
static int size_forward1 (const void *, const void *);
static int size_forward2 (const void *, const void *);

/* The output formatting functions.  */
static void print_object_filename_bsd (char *);
static void print_object_filename_sysv (char *);
static void print_object_filename_posix (char *);
static void print_archive_filename_bsd (char *);
static void print_archive_filename_sysv (char *);
static void print_archive_filename_posix (char *);
static void print_archive_member_bsd (char *, const char *);
static void print_archive_member_sysv (char *, const char *);
static void print_archive_member_posix (char *, const char *);
static void print_symbol_filename_bsd (bfd *, bfd *);
static void print_symbol_filename_sysv (bfd *, bfd *);
static void print_symbol_filename_posix (bfd *, bfd *);
static void print_value (bfd *, bfd_vma);
static void print_symbol_info_bsd (struct extended_symbol_info *, bfd *);
static void print_symbol_info_sysv (struct extended_symbol_info *, bfd *);
static void print_symbol_info_posix (struct extended_symbol_info *, bfd *);
static void get_relocs (bfd *, asection *, void *);
static const char * get_symbol_type (unsigned int);

/* Support for different output formats.  */
struct output_fns
  {
    /* Print the name of an object file given on the command line.  */
    void (*print_object_filename) (char *);

    /* Print the name of an archive file given on the command line.  */
    void (*print_archive_filename) (char *);

    /* Print the name of an archive member file.  */
    void (*print_archive_member) (char *, const char *);

    /* Print the name of the file (and archive, if there is one)
       containing a symbol.  */
    void (*print_symbol_filename) (bfd *, bfd *);

    /* Print a line of information about a symbol.  */
    void (*print_symbol_info) (struct extended_symbol_info *, bfd *);
  };

static struct output_fns formats[] =
{
  {print_object_filename_bsd,
   print_archive_filename_bsd,
   print_archive_member_bsd,
   print_symbol_filename_bsd,
   print_symbol_info_bsd},
  {print_object_filename_sysv,
   print_archive_filename_sysv,
   print_archive_member_sysv,
   print_symbol_filename_sysv,
   print_symbol_info_sysv},
  {print_object_filename_posix,
   print_archive_filename_posix,
   print_archive_member_posix,
   print_symbol_filename_posix,
   print_symbol_info_posix}
};

/* Indices in `formats'.  */
#define FORMAT_BSD 0
#define FORMAT_SYSV 1
#define FORMAT_POSIX 2
#define FORMAT_DEFAULT FORMAT_BSD

/* The output format to use.  */
static struct output_fns *format = &formats[FORMAT_DEFAULT];

/* Command options.  */

static int do_demangle = 0;	/* Pretty print C++ symbol names.  */
static int external_only = 0;	/* Print external symbols only.  */
static int defined_only = 0;	/* Print defined symbols only.  */
static int no_sort = 0;		/* Don't sort; print syms in order found.  */
static int print_debug_syms = 0;/* Print debugger-only symbols too.  */
static int print_armap = 0;	/* Describe __.SYMDEF data in archive files.  */
static int print_size = 0;	/* Print size of defined symbols.  */
static int reverse_sort = 0;	/* Sort in downward(alpha or numeric) order.  */
static int sort_numerically = 0;/* Sort in numeric rather than alpha order.  */
static int sort_by_size = 0;	/* Sort by size of symbol.  */
static int undefined_only = 0;	/* Print undefined symbols only.  */
static int dynamic = 0;		/* Print dynamic symbols.  */
static int show_version = 0;	/* Show the version number.  */
static int show_stats = 0;	/* Show statistics.  */
static int line_numbers = 0;	/* Print line numbers for symbols.  */

/* When to print the names of files.  Not mutually exclusive in SYSV format.  */
static int filename_per_file = 0;	/* Once per file, on its own line.  */
static int filename_per_symbol = 0;	/* Once per symbol, at start of line.  */

/* Print formats for printing a symbol value.  */
#ifndef BFD64
static char value_format[] = "%08lx";
#else
#if BFD_HOST_64BIT_LONG
static char value_format[] = "%016lx";
#else
/* We don't use value_format for this case.  */
#endif
#endif
#ifdef BFD64
static int print_width = 16;
#else
static int print_width = 8;
#endif
static int print_radix = 16;
/* Print formats for printing stab info.  */
static char other_format[] = "%02x";
static char desc_format[] = "%04x";

static char *target = NULL;

/* Used to cache the line numbers for a BFD.  */
static bfd *lineno_cache_bfd;
static bfd *lineno_cache_rel_bfd;

#define OPTION_TARGET 200

static struct option long_options[] =
{
  {"debug-syms", no_argument, &print_debug_syms, 1},
  {"demangle", optional_argument, 0, 'C'},
  {"dynamic", no_argument, &dynamic, 1},
  {"extern-only", no_argument, &external_only, 1},
  {"format", required_argument, 0, 'f'},
  {"help", no_argument, 0, 'h'},
  {"line-numbers", no_argument, 0, 'l'},
  {"no-cplus", no_argument, &do_demangle, 0},  /* Linux compatibility.  */
  {"no-demangle", no_argument, &do_demangle, 0},
  {"no-sort", no_argument, &no_sort, 1},
  {"numeric-sort", no_argument, &sort_numerically, 1},
  {"portability", no_argument, 0, 'P'},
  {"print-armap", no_argument, &print_armap, 1},
  {"print-file-name", no_argument, 0, 'o'},
  {"print-size", no_argument, 0, 'S'},
  {"radix", required_argument, 0, 't'},
  {"reverse-sort", no_argument, &reverse_sort, 1},
  {"size-sort", no_argument, &sort_by_size, 1},
  {"stats", no_argument, &show_stats, 1},
  {"target", required_argument, 0, OPTION_TARGET},
  {"defined-only", no_argument, &defined_only, 1},
  {"undefined-only", no_argument, &undefined_only, 1},
  {"version", no_argument, &show_version, 1},
  {0, no_argument, 0, 0}
};

/* Some error-reporting functions.  */

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" List symbols in [file(s)] (a.out by default).\n"));
  fprintf (stream, _(" The options are:\n\
  -a, --debug-syms       Display debugger-only symbols\n\
  -A, --print-file-name  Print name of the input file before every symbol\n\
  -B                     Same as --format=bsd\n\
  -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n\
                          The STYLE, if specified, can be `auto' (the default),\n\
                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                          or `gnat'\n\
      --no-demangle      Do not demangle low-level symbol names\n\
  -D, --dynamic          Display dynamic symbols instead of normal symbols\n\
      --defined-only     Display only defined symbols\n\
  -e                     (ignored)\n\
  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\
                           `sysv' or `posix'.  The default is `bsd'\n\
  -g, --extern-only      Display only external symbols\n\
  -l, --line-numbers     Use debugging information to find a filename and\n\
                           line number for each symbol\n\
  -n, --numeric-sort     Sort symbols numerically by address\n\
  -o                     Same as -A\n\
  -p, --no-sort          Do not sort the symbols\n\
  -P, --portability      Same as --format=posix\n\
  -r, --reverse-sort     Reverse the sense of the sort\n\
  -S, --print-size       Print size of defined symbols\n\
  -s, --print-armap      Include index for symbols from archive members\n\
      --size-sort        Sort symbols by size\n\
  -t, --radix=RADIX      Use RADIX for printing symbol values\n\
      --target=BFDNAME   Specify the target object format as BFDNAME\n\
  -u, --undefined-only   Display only undefined symbols\n\
  -X 32_64               (ignored)\n\
  -h, --help             Display this information\n\
  -V, --version          Display this program's version number\n\
\n"));
  list_supported_targets (program_name, stream);
  if (status == 0)
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
  exit (status);
}

/* Set the radix for the symbol value and size according to RADIX.  */

static void
set_print_radix (char *radix)
{
  switch (*radix)
    {
    case 'x':
      break;
    case 'd':
    case 'o':
      if (*radix == 'd')
	print_radix = 10;
      else
	print_radix = 8;
#ifndef BFD64
      value_format[4] = *radix;
#else
#if BFD_HOST_64BIT_LONG
      value_format[5] = *radix;
#else
      /* This case requires special handling for octal and decimal
         printing.  */
#endif
#endif
      other_format[3] = desc_format[3] = *radix;
      break;
    default:
      fatal (_("%s: invalid radix"), radix);
    }
}

static void
set_output_format (char *f)
{
  int i;

  switch (*f)
    {
    case 'b':
    case 'B':
      i = FORMAT_BSD;
      break;
    case 'p':
    case 'P':
      i = FORMAT_POSIX;
      break;
    case 's':
    case 'S':
      i = FORMAT_SYSV;
      break;
    default:
      fatal (_("%s: invalid output format"), f);
    }
  format = &formats[i];
}

int main (int, char **);

int
main (int argc, char **argv)
{
  int c;
  int retval;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
			   long_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'a':
	  print_debug_syms = 1;
	  break;
	case 'A':
	case 'o':
	  filename_per_symbol = 1;
	  break;
	case 'B':		/* For MIPS compatibility.  */
	  set_output_format ("bsd");
	  break;
	case 'C':
	  do_demangle = 1;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'D':
	  dynamic = 1;
	  break;
	case 'e':
	  /* Ignored for HP/UX compatibility.  */
	  break;
	case 'f':
	  set_output_format (optarg);
	  break;
	case 'g':
	  external_only = 1;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	case 'l':
	  line_numbers = 1;
	  break;
	case 'n':
	case 'v':
	  sort_numerically = 1;
	  break;
	case 'p':
	  no_sort = 1;
	  break;
	case 'P':
	  set_output_format ("posix");
	  break;
	case 'r':
	  reverse_sort = 1;
	  break;
	case 's':
	  print_armap = 1;
	  break;
	case 'S':
	  print_size = 1;
	  break;
	case 't':
	  set_print_radix (optarg);
	  break;
	case 'u':
	  undefined_only = 1;
	  break;
	case 'V':
	  show_version = 1;
	  break;
	case 'X':
	  /* Ignored for (partial) AIX compatibility.  On AIX, the
	     argument has values 32, 64, or 32_64, and specifies that
	     only 32-bit, only 64-bit, or both kinds of objects should
	     be examined.  The default is 32.  So plain AIX nm on a
	     library archive with both kinds of objects will ignore
	     the 64-bit ones.  For GNU nm, the default is and always
	     has been -X 32_64, and other options are not supported.  */
	  if (strcmp (optarg, "32_64") != 0)
	    fatal (_("Only -X 32_64 is supported"));
	  break;

	case OPTION_TARGET:	/* --target */
	  target = optarg;
	  break;

	case 0:		/* A long option that just sets a flag.  */
	  break;

	default:
	  usage (stderr, 1);
	}
    }

  if (show_version)
    print_version ("nm");

  if (sort_by_size && undefined_only)
    {
      non_fatal (_("Using the --size-sort and --undefined-only options together"));
      non_fatal (_("will produce no output, since undefined symbols have no size."));
      return 0;
    }

  /* OK, all options now parsed.  If no filename specified, do a.out.  */
  if (optind == argc)
    return !display_file ("a.out");

  retval = 0;

  if (argc - optind > 1)
    filename_per_file = 1;

  /* We were given several filenames to do.  */
  while (optind < argc)
    {
      PROGRESS (1);
      if (!display_file (argv[optind++]))
	retval++;
    }

  END_PROGRESS (program_name);

#ifdef HAVE_SBRK
  if (show_stats)
    {
      char *lim = (char *) sbrk (0);

      non_fatal (_("data size %ld"), (long) (lim - (char *) &environ));
    }
#endif

  exit (retval);
  return retval;
}

static const char *
get_symbol_type (unsigned int type)
{
  static char buff [32];

  switch (type)
    {
    case STT_NOTYPE:   return "NOTYPE";
    case STT_OBJECT:   return "OBJECT";
    case STT_FUNC:     return "FUNC";
    case STT_SECTION:  return "SECTION";
    case STT_FILE:     return "FILE";
    case STT_COMMON:   return "COMMON";
    case STT_TLS:      return "TLS";
    default:
      if (type >= STT_LOPROC && type <= STT_HIPROC)
	sprintf (buff, _("<processor specific>: %d"), type);
      else if (type >= STT_LOOS && type <= STT_HIOS)
	sprintf (buff, _("<OS specific>: %d"), type);
      else
	sprintf (buff, _("<unknown>: %d"), type);
      return buff;
    }
}

static void
display_archive (bfd *file)
{
  bfd *arfile = NULL;
  bfd *last_arfile = NULL;
  char **matching;

  (*format->print_archive_filename) (bfd_get_filename (file));

  if (print_armap)
    print_symdef_entry (file);

  for (;;)
    {
      PROGRESS (1);

      arfile = bfd_openr_next_archived_file (file, arfile);

      if (arfile == NULL)
	{
	  if (bfd_get_error () != bfd_error_no_more_archived_files)
	    bfd_fatal (bfd_get_filename (file));
	  break;
	}

      if (bfd_check_format_matches (arfile, bfd_object, &matching))
	{
	  char buf[30];

	  bfd_sprintf_vma (arfile, buf, (bfd_vma) -1);
	  print_width = strlen (buf);
	  (*format->print_archive_member) (bfd_get_filename (file),
					   bfd_get_filename (arfile));
	  display_rel_file (arfile, file);
	}
      else
	{
	  bfd_nonfatal (bfd_get_filename (arfile));
	  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	    {
	      list_matching_formats (matching);
	      free (matching);
	    }
	}

      if (last_arfile != NULL)
	{
	  bfd_close (last_arfile);
	  lineno_cache_bfd = NULL;
	  lineno_cache_rel_bfd = NULL;
	}
      last_arfile = arfile;
    }

  if (last_arfile != NULL)
    {
      bfd_close (last_arfile);
      lineno_cache_bfd = NULL;
      lineno_cache_rel_bfd = NULL;
    }
}

static bfd_boolean
display_file (char *filename)
{
  bfd_boolean retval = TRUE;
  bfd *file;
  char **matching;

  if (get_file_size (filename) < 1)
    return FALSE;

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      bfd_nonfatal (filename);
      return FALSE;
    }

  if (bfd_check_format (file, bfd_archive))
    {
      display_archive (file);
    }
  else if (bfd_check_format_matches (file, bfd_object, &matching))
    {
      char buf[30];

      bfd_sprintf_vma (file, buf, (bfd_vma) -1);
      print_width = strlen (buf);
      (*format->print_object_filename) (filename);
      display_rel_file (file, NULL);
    }
  else
    {
      bfd_nonfatal (filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      retval = FALSE;
    }

  if (!bfd_close (file))
    bfd_fatal (filename);

  lineno_cache_bfd = NULL;
  lineno_cache_rel_bfd = NULL;

  return retval;
}

/* These globals are used to pass information into the sorting
   routines.  */
static bfd *sort_bfd;
static bfd_boolean sort_dynamic;
static asymbol *sort_x;
static asymbol *sort_y;

/* Symbol-sorting predicates */
#define valueof(x) ((x)->section->vma + (x)->value)

/* Numeric sorts.  Undefined symbols are always considered "less than"
   defined symbols with zero values.  Common symbols are not treated
   specially -- i.e., their sizes are used as their "values".  */

static int
numeric_forward (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  asection *xs, *ys;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y =  bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xs = bfd_get_section (x);
  ys = bfd_get_section (y);

  if (bfd_is_und_section (xs))
    {
      if (! bfd_is_und_section (ys))
	return -1;
    }
  else if (bfd_is_und_section (ys))
    return 1;
  else if (valueof (x) != valueof (y))
    return valueof (x) < valueof (y) ? -1 : 1;

  return non_numeric_forward (P_x, P_y);
}

static int
numeric_reverse (const void *x, const void *y)
{
  return - numeric_forward (x, y);
}

static int
non_numeric_forward (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  const char *xn, *yn;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xn = bfd_asymbol_name (x);
  yn = bfd_asymbol_name (y);

  if (yn == NULL)
    return xn != NULL;
  if (xn == NULL)
    return -1;

#ifdef HAVE_STRCOLL
  /* Solaris 2.5 has a bug in strcoll.
     strcoll returns invalid values when confronted with empty strings.  */
  if (*yn == '\0')
    return *xn != '\0';
  if (*xn == '\0')
    return -1;

  return strcoll (xn, yn);
#else
  return strcmp (xn, yn);
#endif
}

static int
non_numeric_reverse (const void *x, const void *y)
{
  return - non_numeric_forward (x, y);
}

static int (*(sorters[2][2])) (const void *, const void *) =
{
  { non_numeric_forward, non_numeric_reverse },
  { numeric_forward, numeric_reverse }
};

/* This sort routine is used by sort_symbols_by_size.  It is similar
   to numeric_forward, but when symbols have the same value it sorts
   by section VMA.  This simplifies the sort_symbols_by_size code
   which handles symbols at the end of sections.  Also, this routine
   tries to sort file names before other symbols with the same value.
   That will make the file name have a zero size, which will make
   sort_symbols_by_size choose the non file name symbol, leading to
   more meaningful output.  For similar reasons, this code sorts
   gnu_compiled_* and gcc2_compiled before other symbols with the same
   value.  */

static int
size_forward1 (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  asection *xs, *ys;
  const char *xn, *yn;
  size_t xnl, ynl;
  int xf, yf;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xs = bfd_get_section (x);
  ys = bfd_get_section (y);

  if (bfd_is_und_section (xs))
    abort ();
  if (bfd_is_und_section (ys))
    abort ();

  if (valueof (x) != valueof (y))
    return valueof (x) < valueof (y) ? -1 : 1;

  if (xs->vma != ys->vma)
    return xs->vma < ys->vma ? -1 : 1;

  xn = bfd_asymbol_name (x);
  yn = bfd_asymbol_name (y);
  xnl = strlen (xn);
  ynl = strlen (yn);

  /* The symbols gnu_compiled and gcc2_compiled convey even less
     information than the file name, so sort them out first.  */

  xf = (strstr (xn, "gnu_compiled") != NULL
	|| strstr (xn, "gcc2_compiled") != NULL);
  yf = (strstr (yn, "gnu_compiled") != NULL
	|| strstr (yn, "gcc2_compiled") != NULL);

  if (xf && ! yf)
    return -1;
  if (! xf && yf)
    return 1;

  /* We use a heuristic for the file name.  It may not work on non
     Unix systems, but it doesn't really matter; the only difference
     is precisely which symbol names get printed.  */

#define file_symbol(s, sn, snl)			\
  (((s)->flags & BSF_FILE) != 0			\
   || ((sn)[(snl) - 2] == '.'			\
       && ((sn)[(snl) - 1] == 'o'		\
	   || (sn)[(snl) - 1] == 'a')))

  xf = file_symbol (x, xn, xnl);
  yf = file_symbol (y, yn, ynl);

  if (xf && ! yf)
    return -1;
  if (! xf && yf)
    return 1;

  return non_numeric_forward (P_x, P_y);
}

/* This sort routine is used by sort_symbols_by_size.  It is sorting
   an array of size_sym structures into size order.  */

static int
size_forward2 (const void *P_x, const void *P_y)
{
  const struct size_sym *x = (const struct size_sym *) P_x;
  const struct size_sym *y = (const struct size_sym *) P_y;

  if (x->size < y->size)
    return reverse_sort ? 1 : -1;
  else if (x->size > y->size)
    return reverse_sort ? -1 : 1;
  else
    return sorters[0][reverse_sort] (x->minisym, y->minisym);
}

/* Sort the symbols by size.  ELF provides a size but for other formats
   we have to make a guess by assuming that the difference between the
   address of a symbol and the address of the next higher symbol is the
   size.  */

static long
sort_symbols_by_size (bfd *abfd, bfd_boolean dynamic, void *minisyms,
		      long symcount, unsigned int size,
		      struct size_sym **symsizesp)
{
  struct size_sym *symsizes;
  bfd_byte *from, *fromend;
  asymbol *sym = NULL;
  asymbol *store_sym, *store_next;

  qsort (minisyms, symcount, size, size_forward1);

  /* We are going to return a special set of symbols and sizes to
     print.  */
  symsizes = (struct size_sym *) xmalloc (symcount * sizeof (struct size_sym));
  *symsizesp = symsizes;

  /* Note that filter_symbols has already removed all absolute and
     undefined symbols.  Here we remove all symbols whose size winds
     up as zero.  */
  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;

  store_sym = sort_x;
  store_next = sort_y;

  if (from < fromend)
    {
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from,
				      store_sym);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));
    }

  for (; from < fromend; from += size)
    {
      asymbol *next;
      asection *sec;
      bfd_vma sz;
      asymbol *temp;

      if (from + size < fromend)
	{
	  next = bfd_minisymbol_to_symbol (abfd,
					   dynamic,
					   (const void *) (from + size),
					   store_next);
	  if (next == NULL)
	    bfd_fatal (bfd_get_filename (abfd));
	}
      else
	next = NULL;

      sec = bfd_get_section (sym);

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	sz = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
      else if (bfd_is_com_section (sec))
	sz = sym->value;
      else
	{
	  if (from + size < fromend
	      && sec == bfd_get_section (next))
	    sz = valueof (next) - valueof (sym);
	  else
	    sz = (bfd_get_section_vma (abfd, sec)
		  + bfd_section_size (abfd, sec)
		  - valueof (sym));
	}

      if (sz != 0)
	{
	  symsizes->minisym = (const void *) from;
	  symsizes->size = sz;
	  ++symsizes;
	}

      sym = next;

      temp = store_sym;
      store_sym = store_next;
      store_next = temp;
    }

  symcount = symsizes - *symsizesp;

  /* We must now sort again by size.  */
  qsort ((void *) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);

  return symcount;
}

/* If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.  */

static void
display_rel_file (bfd *abfd, bfd *archive_bfd)
{
  long symcount;
  void *minisyms;
  unsigned int size;
  struct size_sym *symsizes;

  if (! dynamic)
    {
      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
	{
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
	  return;
	}
    }

  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  /* Discard the symbols we don't want to print.
     It's OK to do this in place; we'll free the storage anyway
     (after printing).  */

  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);

  symsizes = NULL;
  if (! no_sort)
    {
      sort_bfd = abfd;
      sort_dynamic = dynamic;
      sort_x = bfd_make_empty_symbol (abfd);
      sort_y = bfd_make_empty_symbol (abfd);
      if (sort_x == NULL || sort_y == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      if (! sort_by_size)
	qsort (minisyms, symcount, size,
	       sorters[sort_numerically][reverse_sort]);
      else
	symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
					 size, &symsizes);
    }

  if (! sort_by_size)
    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
  else
    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);

  free (minisyms);
}

/* Choose which symbol entries to print;
   compact them downward to get rid of the rest.
   Return the number of symbols to be printed.  */

static long
filter_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms,
		long symcount, unsigned int size)
{
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
    {
      int keep = 0;
      asymbol *sym;

      PROGRESS (1);

      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      if (undefined_only)
	keep = bfd_is_und_section (sym->section);
      else if (external_only)
	keep = ((sym->flags & BSF_GLOBAL) != 0
		|| (sym->flags & BSF_WEAK) != 0
		|| bfd_is_und_section (sym->section)
		|| bfd_is_com_section (sym->section));
      else
	keep = 1;

      if (keep
	  && ! print_debug_syms
	  && (sym->flags & BSF_DEBUGGING) != 0)
	keep = 0;

      if (keep
	  && sort_by_size
	  && (bfd_is_abs_section (sym->section)
	      || bfd_is_und_section (sym->section)))
	keep = 0;

      if (keep
	  && defined_only)
	{
	  if (bfd_is_und_section (sym->section))
	    keep = 0;
	}

      if (keep)
	{
	  memcpy (to, from, size);
	  to += size;
	}
    }

  return (to - (bfd_byte *) minisyms) / size;
}

/* Print symbol name NAME, read from ABFD, with printf format FORMAT,
   demangling it if requested.  */

static void
print_symname (const char *format, const char *name, bfd *abfd)
{
  if (do_demangle && *name)
    {
      char *res = demangle (abfd, name);

      printf (format, res);
      free (res);
      return;
    }

  printf (format, name);
}

/* Print the symbols.  If ARCHIVE_BFD is non-NULL, it is the archive
   containing ABFD.  */

static void
print_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms, long symcount,
	       unsigned int size, bfd *archive_bfd)
{
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, dynamic, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      print_symbol (abfd, sym, (bfd_vma) 0, archive_bfd);
    }
}

/* Print the symbols when sorting by size.  */

static void
print_size_symbols (bfd *abfd, bfd_boolean dynamic,
		    struct size_sym *symsizes, long symcount,
		    bfd *archive_bfd)
{
  asymbol *store;
  struct size_sym *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = symsizes;
  fromend = from + symcount;
  for (; from < fromend; from++)
    {
      asymbol *sym;
      bfd_vma ssize;

      sym = bfd_minisymbol_to_symbol (abfd, dynamic, from->minisym, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      /* For elf we have already computed the correct symbol size.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	ssize = from->size;
      else
	ssize = from->size - bfd_section_vma (abfd, bfd_get_section (sym));

      print_symbol (abfd, sym, ssize, archive_bfd);
    }
}

/* Print a single symbol.  */

static void
print_symbol (bfd *abfd, asymbol *sym, bfd_vma ssize, bfd *archive_bfd)
{
  symbol_info syminfo;
  struct extended_symbol_info info;

  PROGRESS (1);

  (*format->print_symbol_filename) (archive_bfd, abfd);

  bfd_get_symbol_info (abfd, sym, &syminfo);
  info.sinfo = &syminfo;
  info.ssize = ssize;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    info.elfinfo = (elf_symbol_type *) sym;
  else
    info.elfinfo = NULL;
  (*format->print_symbol_info) (&info, abfd);

  if (line_numbers)
    {
      static asymbol **syms;
      static long symcount;
      const char *filename, *functionname;
      unsigned int lineno;

      /* We need to get the canonical symbols in order to call
         bfd_find_nearest_line.  This is inefficient, but, then, you
         don't have to use --line-numbers.  */
      if (abfd != lineno_cache_bfd && syms != NULL)
	{
	  free (syms);
	  syms = NULL;
	}
      if (syms == NULL)
	{
	  long symsize;

	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  syms = (asymbol **) xmalloc (symsize);
	  symcount = bfd_canonicalize_symtab (abfd, syms);
	  if (symcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  lineno_cache_bfd = abfd;
	}

      if (bfd_is_und_section (bfd_get_section (sym)))
	{
	  static asection **secs;
	  static arelent ***relocs;
	  static long *relcount;
	  static unsigned int seccount;
	  unsigned int i;
	  const char *symname;

	  /* For an undefined symbol, we try to find a reloc for the
             symbol, and print the line number of the reloc.  */
	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
	    {
	      for (i = 0; i < seccount; i++)
		if (relocs[i] != NULL)
		  free (relocs[i]);
	      free (secs);
	      free (relocs);
	      free (relcount);
	      secs = NULL;
	      relocs = NULL;
	      relcount = NULL;
	    }

	  if (relocs == NULL)
	    {
	      struct get_relocs_info info;

	      seccount = bfd_count_sections (abfd);

	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);

	      info.secs = secs;
	      info.relocs = relocs;
	      info.relcount = relcount;
	      info.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (void *) &info);
	      lineno_cache_rel_bfd = abfd;
	    }

	  symname = bfd_asymbol_name (sym);
	  for (i = 0; i < seccount; i++)
	    {
	      long j;

	      for (j = 0; j < relcount[i]; j++)
		{
		  arelent *r;

		  r = relocs[i][j];
		  if (r->sym_ptr_ptr != NULL
		      && (*r->sym_ptr_ptr)->section == sym->section
		      && (*r->sym_ptr_ptr)->value == sym->value
		      && strcmp (symname,
				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
		      && bfd_find_nearest_line (abfd, secs[i], syms,
						r->address, &filename,
						&functionname, &lineno)
		      && filename != NULL)
		    {
		      /* We only print the first one we find.  */
		      printf ("\t%s:%u", filename, lineno);
		      i = seccount;
		      break;
		    }
		}
	    }
	}
      else if (bfd_get_section (sym)->owner == abfd)
	{
	  if (bfd_find_nearest_line (abfd, bfd_get_section (sym), syms,
				     sym->value, &filename, &functionname,
				     &lineno)
	      && filename != NULL
	      && lineno != 0)
	    {
	      printf ("\t%s:%u", filename, lineno);
	    }
	}
    }

  putchar ('\n');
}

/* The following 3 groups of functions are called unconditionally,
   once at the start of processing each file of the appropriate type.
   They should check `filename_per_file' and `filename_per_symbol',
   as appropriate for their output format, to determine whether to
   print anything.  */

/* Print the name of an object file given on the command line.  */

static void
print_object_filename_bsd (char *filename)
{
  if (filename_per_file && !filename_per_symbol)
    printf ("\n%s:\n", filename);
}

static void
print_object_filename_sysv (char *filename)
{
  if (undefined_only)
    printf (_("\n\nUndefined symbols from %s:\n\n"), filename);
  else
    printf (_("\n\nSymbols from %s:\n\n"), filename);
  if (print_width == 8)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
}

static void
print_object_filename_posix (char *filename)
{
  if (filename_per_file && !filename_per_symbol)
    printf ("%s:\n", filename);
}

/* Print the name of an archive file given on the command line.  */

static void
print_archive_filename_bsd (char *filename)
{
  if (filename_per_file)
    printf ("\n%s:\n", filename);
}

static void
print_archive_filename_sysv (char *filename ATTRIBUTE_UNUSED)
{
}

static void
print_archive_filename_posix (char *filename ATTRIBUTE_UNUSED)
{
}

/* Print the name of an archive member file.  */

static void
print_archive_member_bsd (char *archive ATTRIBUTE_UNUSED,
			  const char *filename)
{
  if (!filename_per_symbol)
    printf ("\n%s:\n", filename);
}

static void
print_archive_member_sysv (char *archive, const char *filename)
{
  if (undefined_only)
    printf (_("\n\nUndefined symbols from %s[%s]:\n\n"), archive, filename);
  else
    printf (_("\n\nSymbols from %s[%s]:\n\n"), archive, filename);
  if (print_width == 8)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
}

static void
print_archive_member_posix (char *archive, const char *filename)
{
  if (!filename_per_symbol)
    printf ("%s[%s]:\n", archive, filename);
}

/* Print the name of the file (and archive, if there is one)
   containing a symbol.  */

static void
print_symbol_filename_bsd (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s:", bfd_get_filename (archive_bfd));
      printf ("%s:", bfd_get_filename (abfd));
    }
}

static void
print_symbol_filename_sysv (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s:", bfd_get_filename (archive_bfd));
      printf ("%s:", bfd_get_filename (abfd));
    }
}

static void
print_symbol_filename_posix (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s[%s]: ", bfd_get_filename (archive_bfd),
		bfd_get_filename (abfd));
      else
	printf ("%s: ", bfd_get_filename (abfd));
    }
}

/* Print a symbol value.  */

static void
print_value (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma val)
{
#if ! defined (BFD64) || BFD_HOST_64BIT_LONG
  printf (value_format, val);
#else
  /* We have a 64 bit value to print, but the host is only 32 bit.  */
  if (print_radix == 16)
    bfd_fprintf_vma (abfd, stdout, val);
  else
    {
      char buf[30];
      char *s;

      s = buf + sizeof buf;
      *--s = '\0';
      while (val > 0)
	{
	  *--s = (val % print_radix) + '0';
	  val /= print_radix;
	}
      while ((buf + sizeof buf - 1) - s < 16)
	*--s = '0';
      printf ("%s", s);
    }
#endif
}

/* Print a line of information about a symbol.  */

static void
print_symbol_info_bsd (struct extended_symbol_info *info, bfd *abfd)
{
  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    {
      if (print_width == 16)
	printf ("        ");
      printf ("        ");
    }
  else
    {
      /* Normally we print the value of the symbol.  If we are printing the
	 size or sorting by size then we print its size, except for the
	 (weird) special case where both flags are defined, in which case we
	 print both values.  This conforms to documented behaviour.  */
      if (sort_by_size && !print_size)
	print_value (abfd, SYM_SIZE (info));
      else
	print_value (abfd, SYM_VALUE (info));

      if (print_size && SYM_SIZE (info))
	{
	  printf (" ");
	  print_value (abfd, SYM_SIZE (info));
	}
    }

  printf (" %c", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
    {
      /* A stab.  */
      printf (" ");
      printf (other_format, SYM_STAB_OTHER (info));
      printf (" ");
      printf (desc_format, SYM_STAB_DESC (info));
      printf (" %5s", SYM_STAB_NAME (info));
    }
  print_symname (" %s", SYM_NAME (info), abfd);
}

static void
print_symbol_info_sysv (struct extended_symbol_info *info, bfd *abfd)
{
  print_symname ("%-20s|", SYM_NAME (info), abfd);

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    {
      if (print_width == 8)
	printf ("        ");
      else
	printf ("                ");
    }
  else
    print_value (abfd, SYM_VALUE (info));

  printf ("|   %c  |", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
    {
      /* A stab.  */
      printf ("%18s|  ", SYM_STAB_NAME (info));		/* (C) Type.  */
      printf (desc_format, SYM_STAB_DESC (info));	/* Size.  */
      printf ("|     |");				/* Line, Section.  */
    }
  else
    {
      /* Type, Size, Line, Section */
      if (info->elfinfo)
	printf ("%18s|",
		get_symbol_type (ELF_ST_TYPE (info->elfinfo->internal_elf_sym.st_info)));
      else
	printf ("                  |");

      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
      else
	{
	  if (print_width == 8)
	    printf ("        ");
	  else
	    printf ("                ");
	}

      if (info->elfinfo)
	printf("|     |%s", info->elfinfo->symbol.section->name);
      else
	printf("|     |");
    }
}

static void
print_symbol_info_posix (struct extended_symbol_info *info, bfd *abfd)
{
  print_symname ("%s ", SYM_NAME (info), abfd);
  printf ("%c ", SYM_TYPE (info));

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    printf ("        ");
  else
    {
      print_value (abfd, SYM_VALUE (info));
      printf (" ");
      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
    }
}

static void
print_symdef_entry (bfd *abfd)
{
  symindex idx = BFD_NO_MORE_SYMBOLS;
  carsym *thesym;
  bfd_boolean everprinted = FALSE;

  for (idx = bfd_get_next_mapent (abfd, idx, &thesym);
       idx != BFD_NO_MORE_SYMBOLS;
       idx = bfd_get_next_mapent (abfd, idx, &thesym))
    {
      bfd *elt;
      if (!everprinted)
	{
	  printf (_("\nArchive index:\n"));
	  everprinted = TRUE;
	}
      elt = bfd_get_elt_at_index (abfd, idx);
      if (elt == NULL)
	bfd_fatal ("bfd_get_elt_at_index");
      if (thesym->name != (char *) NULL)
	{
	  print_symname ("%s", thesym->name, abfd);
	  printf (" in %s\n", bfd_get_filename (elt));
	}
    }
}

/* This function is used to get the relocs for a particular section.
   It is called via bfd_map_over_sections.  */

static void
get_relocs (bfd *abfd, asection *sec, void *dataarg)
{
  struct get_relocs_info *data = (struct get_relocs_info *) dataarg;

  *data->secs = sec;

  if ((sec->flags & SEC_RELOC) == 0)
    {
      *data->relocs = NULL;
      *data->relcount = 0;
    }
  else
    {
      long relsize;

      relsize = bfd_get_reloc_upper_bound (abfd, sec);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      *data->relocs = (arelent **) xmalloc (relsize);
      *data->relcount = bfd_canonicalize_reloc (abfd, sec, *data->relocs,
						data->syms);
      if (*data->relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
    }

  ++data->secs;
  ++data->relocs;
  ++data->relcount;
}
@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d367 2
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d40 1
a40 1
  const PTR minisym;
d71 7
a77 14
static void usage
  PARAMS ((FILE *, int));
static void set_print_radix
  PARAMS ((char *));
static void set_output_format
  PARAMS ((char *));
static void display_archive
  PARAMS ((bfd *));
static bfd_boolean display_file
  PARAMS ((char *));
static void display_rel_file
  PARAMS ((bfd *, bfd *));
static long filter_symbols
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int));
d79 1
a79 1
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, struct size_sym **));
d81 1
a81 1
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, bfd *));
d83 4
a86 7
  PARAMS ((bfd *, bfd_boolean, struct size_sym *, long, bfd *));
static void print_symname
  PARAMS ((const char *, const char *, bfd *));
static void print_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma ssize, bfd *));
static void print_symdef_entry
  PARAMS ((bfd *));
d89 6
a94 12
static int numeric_forward
  PARAMS ((const PTR, const PTR));
static int numeric_reverse
  PARAMS ((const PTR, const PTR));
static int non_numeric_forward
  PARAMS ((const PTR, const PTR));
static int non_numeric_reverse
  PARAMS ((const PTR, const PTR));
static int size_forward1
  PARAMS ((const PTR, const PTR));
static int size_forward2
  PARAMS ((const PTR, const PTR));
d97 18
a114 36
static void print_object_filename_bsd
  PARAMS ((char *));
static void print_object_filename_sysv
  PARAMS ((char *));
static void print_object_filename_posix
  PARAMS ((char *));
static void print_archive_filename_bsd
  PARAMS ((char *));
static void print_archive_filename_sysv
  PARAMS ((char *));
static void print_archive_filename_posix
  PARAMS ((char *));
static void print_archive_member_bsd
  PARAMS ((char *, const char *));
static void print_archive_member_sysv
  PARAMS ((char *, const char *));
static void print_archive_member_posix
  PARAMS ((char *, const char *));
static void print_symbol_filename_bsd
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_sysv
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_posix
  PARAMS ((bfd *, bfd *));
static void print_value
  PARAMS ((bfd *, bfd_vma));
static void print_symbol_info_bsd
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_sysv
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_posix
  PARAMS ((struct extended_symbol_info *, bfd *));
static void get_relocs
  PARAMS ((bfd *, asection *, PTR));
static const char * get_symbol_type
  PARAMS ((unsigned int));
d120 1
a120 1
    void (*print_object_filename) PARAMS ((char *));
d123 1
a123 1
    void (*print_archive_filename) PARAMS ((char *));
d126 1
a126 1
    void (*print_archive_member) PARAMS ((char *, const char *));
d130 1
a130 1
    void (*print_symbol_filename) PARAMS ((bfd *, bfd *));
d133 1
a133 1
    void (*print_symbol_info) PARAMS ((struct extended_symbol_info *, bfd *));
d245 1
a245 3
usage (stream, status)
     FILE *stream;
     int status;
d290 1
a290 2
set_print_radix (radix)
     char *radix;
d320 1
a320 2
set_output_format (f)
     char *f;
d344 1
a344 1
int main PARAMS ((int, char **));
d347 1
a347 3
main (argc, argv)
     int argc;
     char **argv;
d447 1
a447 1
	     argument has values 32, 64, or 32_64, and specfies that
d512 1
a512 2
get_symbol_type (type)
     unsigned int type;
d537 1
a537 2
display_archive (file)
     bfd *file;
d599 1
a599 2
display_file (filename)
     char *filename;
d605 3
d663 1
a663 3
numeric_forward (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d690 1
a690 3
numeric_reverse (x, y)
     const PTR x;
     const PTR y;
d696 1
a696 3
non_numeric_forward (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d729 1
a729 3
non_numeric_reverse (x, y)
     const PTR x;
     const PTR y;
d734 1
a734 1
static int (*(sorters[2][2])) PARAMS ((const PTR, const PTR)) =
d752 1
a752 3
size_forward1 (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d822 1
a822 3
size_forward2 (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d841 3
a843 7
sort_symbols_by_size (abfd, dynamic, minisyms, symcount, size, symsizesp)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
     struct size_sym **symsizesp;
d868 1
a868 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const PTR) from,
d885 1
a885 1
					   (const PTR) (from + size),
d912 1
a912 1
	  symsizes->minisym = (const PTR) from;
d927 1
a927 1
  qsort ((PTR) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);
d935 1
a935 3
display_rel_file (abfd, archive_bfd)
     bfd *abfd;
     bfd *archive_bfd;
d938 1
a938 1
  PTR minisyms;
d998 2
a999 6
filter_symbols (abfd, dynamic, minisyms, symcount, size)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1019 1
a1019 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const PTR) from, store);
d1065 1
a1065 4
print_symname (format, name, abfd)
     const char *format;
     const char *name;
     bfd *abfd;
d1083 2
a1084 7
print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
     bfd *archive_bfd;
d1110 3
a1112 6
print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd)
     bfd *abfd;
     bfd_boolean dynamic;
     struct size_sym *symsizes;
     long symcount;
     bfd *archive_bfd;
d1145 1
a1145 5
print_symbol (abfd, sym, ssize, archive_bfd)
     bfd *abfd;
     asymbol *sym;
     bfd_vma ssize;
     bfd *archive_bfd;
d1149 1
a1149 1
   
d1230 1
a1230 1
	      bfd_map_over_sections (abfd, get_relocs, (PTR) &info);
d1287 1
a1287 2
print_object_filename_bsd (filename)
     char *filename;
d1294 1
a1294 2
print_object_filename_sysv (filename)
     char *filename;
d1309 1
a1309 2
print_object_filename_posix (filename)
     char *filename;
d1318 1
a1318 2
print_archive_filename_bsd (filename)
     char *filename;
d1325 1
a1325 2
print_archive_filename_sysv (filename)
     char *filename ATTRIBUTE_UNUSED;
d1330 1
a1330 2
print_archive_filename_posix (filename)
     char *filename ATTRIBUTE_UNUSED;
d1337 2
a1338 3
print_archive_member_bsd (archive, filename)
     char *archive ATTRIBUTE_UNUSED;
     const char *filename;
d1345 1
a1345 3
print_archive_member_sysv (archive, filename)
     char *archive;
     const char *filename;
d1360 1
a1360 3
print_archive_member_posix (archive, filename)
     char *archive;
     const char *filename;
d1370 1
a1370 2
print_symbol_filename_bsd (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1381 1
a1381 2
print_symbol_filename_sysv (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1392 1
a1392 2
print_symbol_filename_posix (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1407 1
a1407 3
print_value (abfd, val)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_vma val;
d1437 1
a1437 3
print_symbol_info_bsd (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1448 1
a1448 1
	 size or sorting by size then we print its size, execpt for the
d1478 1
a1478 3
print_symbol_info_sysv (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1528 1
a1528 3
print_symbol_info_posix (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1545 1
a1545 2
print_symdef_entry (abfd)
     bfd *abfd;
d1576 1
a1576 4
get_relocs (abfd, sec, dataarg)
     bfd *abfd;
     asection *sec;
     PTR dataarg;
@


1.7
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
d26 1
d32 2
d55 42
a96 39
static void
usage PARAMS ((FILE *, int));

static void
set_print_radix PARAMS ((char *));

static void
set_output_format PARAMS ((char *));

static void
display_archive PARAMS ((bfd *));

static boolean
display_file PARAMS ((char *filename));

static void
display_rel_file PARAMS ((bfd * file, bfd * archive));

static long
filter_symbols PARAMS ((bfd *, boolean, PTR, long, unsigned int));

static long
sort_symbols_by_size PARAMS ((bfd *, boolean, PTR, long, unsigned int,
			      struct size_sym **));

static void
print_symbols PARAMS ((bfd *, boolean, PTR, long, unsigned int, bfd *));

static void
print_size_symbols PARAMS ((bfd *, boolean, struct size_sym *, long, bfd *));

static void
print_symname PARAMS ((const char *, const char *, bfd *));

static void
print_symbol PARAMS ((bfd *, asymbol *, bfd *));

static void
print_symdef_entry PARAMS ((bfd * abfd));
d99 12
a110 18

static int
numeric_forward PARAMS ((const PTR, const PTR));

static int
numeric_reverse PARAMS ((const PTR, const PTR));

static int
non_numeric_forward PARAMS ((const PTR, const PTR));

static int
non_numeric_reverse PARAMS ((const PTR, const PTR));

static int
size_forward1 PARAMS ((const PTR, const PTR));

static int
size_forward2 PARAMS ((const PTR, const PTR));
d113 36
a148 55

static void
print_object_filename_bsd PARAMS ((char *filename));

static void
print_object_filename_sysv PARAMS ((char *filename));

static void
print_object_filename_posix PARAMS ((char *filename));


static void
print_archive_filename_bsd PARAMS ((char *filename));

static void
print_archive_filename_sysv PARAMS ((char *filename));

static void
print_archive_filename_posix PARAMS ((char *filename));


static void
print_archive_member_bsd PARAMS ((char *archive, CONST char *filename));

static void
print_archive_member_sysv PARAMS ((char *archive, CONST char *filename));

static void
print_archive_member_posix PARAMS ((char *archive, CONST char *filename));


static void
print_symbol_filename_bsd PARAMS ((bfd * archive_bfd, bfd * abfd));

static void
print_symbol_filename_sysv PARAMS ((bfd * archive_bfd, bfd * abfd));

static void
print_symbol_filename_posix PARAMS ((bfd * archive_bfd, bfd * abfd));


static void
print_value PARAMS ((bfd_vma));

static void
print_symbol_info_bsd PARAMS ((symbol_info * info, bfd * abfd));

static void
print_symbol_info_sysv PARAMS ((symbol_info * info, bfd * abfd));

static void
print_symbol_info_posix PARAMS ((symbol_info * info, bfd * abfd));

static void
get_relocs PARAMS ((bfd *, asection *, PTR));
d154 1
a154 1
    void (*print_object_filename) PARAMS ((char *filename));
d157 1
a157 1
    void (*print_archive_filename) PARAMS ((char *filename));
d160 1
a160 1
    void (*print_archive_member) PARAMS ((char *archive, CONST char *filename));
d164 1
a164 1
    void (*print_symbol_filename) PARAMS ((bfd * archive_bfd, bfd * abfd));
d167 1
a167 1
    void (*print_symbol_info) PARAMS ((symbol_info * info, bfd * abfd));
d169 1
a197 1

d201 14
a214 13
static int external_only = 0;	/* print external symbols only */
static int defined_only = 0;	/* Print defined symbols only */
static int no_sort = 0;		/* don't sort; print syms in order found */
static int print_debug_syms = 0;	/* print debugger-only symbols too */
static int print_armap = 0;	/* describe __.SYMDEF data in archive files.  */
static int reverse_sort = 0;	/* sort in downward(alpha or numeric) order */
static int sort_numerically = 0;	/* sort in numeric rather than alpha order */
static int sort_by_size = 0;	/* sort by size of symbol */
static int undefined_only = 0;	/* print undefined symbols only */
static int dynamic = 0;		/* print dynamic symbols.  */
static int show_version = 0;	/* show the version number */
static int show_stats = 0;	/* show statistics */
static int line_numbers = 0;	/* print line numbers for symbols */
d230 5
d264 1
d276 1
a276 1
/* Some error-reporting functions */
d283 3
a285 3
  fprintf (stream, _("Usage: %s [OPTION]... [FILE]...\n"), program_name);
  fprintf (stream, _("List symbols from FILEs (a.out by default).\n"));
  fprintf (stream, _("\n\
d291 2
a292 1
                          `gnu', 'lucid', 'arm', 'hp', 'edg' or 'gnu-new-abi'\n\
a299 1
  -h, --help             Display this information\n\
d307 1
d313 2
a315 1
  -X 32_64               (ignored)\n\
d382 2
d395 4
d410 1
a410 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvVX:",
d430 1
a430 1
	      
d432 1
a432 1
	      if (style == unknown_demangling) 
d435 1
a435 1
	      
d437 1
a437 1
           }
d451 1
d473 3
d512 7
d551 26
d605 4
d640 1
a640 1
static boolean
d644 1
a644 1
  boolean retval = true;
d652 1
a652 1
      return false;
d661 4
d676 1
a676 1
      retval = false;
d679 1
a679 1
  if (bfd_close (file) == false)
d691 1
a691 1
static boolean sort_dynamic;
d755 17
a771 2
  return ((xn == NULL) ? ((yn == NULL) ? 0 : -1) :
	  ((yn == NULL) ? 1 : strcmp (xn, yn)));
d887 4
a890 4
/* Sort the symbols by size.  We guess the size by assuming that the
   difference between the address of a symbol and the address of the
   next higher symbol is the size.  FIXME: ELF actually stores a size
   with each symbol.  We should use it.  */
d895 1
a895 1
     boolean dynamic;
a915 1

d951 3
a953 1
      if (bfd_is_com_section (sec))
d1058 1
a1058 1
     boolean dynamic;
d1080 1
a1080 1
      
d1134 1
a1134 1
      char *res;
d1136 3
a1138 13
      /* In this mode, give a user-level view of the symbol name
	 even if it's not mangled; strip off any leading
	 underscore.  */
      if (bfd_get_symbol_leading_char (abfd) == name[0])
	name++;

      res = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (res)
	{
	  printf (format, res);
	  free (res);
	  return;
	}
d1150 1
a1150 1
     boolean dynamic;
d1173 1
a1173 1
      print_symbol (abfd, sym, archive_bfd);
d1179 1
a1179 1
static void 
d1182 1
a1182 1
     boolean dynamic;
d1199 1
d1205 5
a1209 3
      /* Set the symbol value so that we actually display the symbol
         size.  */
      sym->value = from->size - bfd_section_vma (abfd, bfd_get_section (sym));
d1211 1
a1211 1
      print_symbol (abfd, sym, archive_bfd);
d1218 1
a1218 1
print_symbol (abfd, sym, archive_bfd)
d1221 1
d1224 3
d1231 5
a1235 5
  if (undefined_only)
    {
      if (bfd_is_und_section (bfd_get_section (sym)))
	print_symname ("%s", bfd_asymbol_name (sym), abfd);
    }
d1237 2
a1238 6
    {
      symbol_info syminfo;

      bfd_get_symbol_info (abfd, sym, &syminfo);
      (*format->print_symbol_info) (&syminfo, abfd);
    }
a1279 1

d1328 2
a1329 1
						&functionname, &lineno))
d1379 6
a1384 2
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1422 1
a1422 1
     CONST char *filename;
d1431 1
a1431 1
     CONST char *filename;
d1437 6
a1442 2
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1448 1
a1448 1
     CONST char *filename;
d1498 2
a1499 1
print_value (val)
d1507 1
a1507 1
    fprintf_vma (stdout, val);
d1531 1
a1531 1
     symbol_info *info;
d1534 1
a1534 1
  if (bfd_is_undefined_symclass (info->type))
d1536 2
a1537 3
#ifdef BFD64
      printf ("        ");
#endif
d1541 20
a1560 3
    print_value (info->value);
  printf (" %c", info->type);
  if (info->type == '-')
d1564 1
a1564 1
      printf (other_format, info->stab_other);
d1566 2
a1567 2
      printf (desc_format, info->stab_desc);
      printf (" %5s", info->stab_name);
d1569 1
a1569 1
  print_symname (" %s", info->name, abfd);
d1574 1
a1574 1
     symbol_info *info;
d1577 9
a1585 3
  print_symname ("%-20s|", info->name, abfd);	/* Name */
  if (bfd_is_undefined_symclass (info->type))
    printf ("        ");	/* Value */
d1587 5
a1591 3
    print_value (info->value);
  printf ("|   %c  |", info->type);	/* Class */
  if (info->type == '-')
d1594 3
a1596 3
      printf ("%18s|  ", info->stab_name);	/* (C) Type */
      printf (desc_format, info->stab_desc);	/* Size */
      printf ("|     |");	/* Line, Section */
d1599 23
a1621 1
    printf ("                  |      |     |");	/* Type, Size, Line, Section */
d1626 1
a1626 1
     symbol_info *info;
d1629 4
a1632 3
  print_symname ("%s ", info->name, abfd);
  printf ("%c ", info->type);
  if (bfd_is_undefined_symclass (info->type))
d1635 6
a1640 4
    print_value (info->value);
  /* POSIX.2 wants the symbol size printed here, when applicable;
     BFD currently doesn't provide it, so we take the easy way out by
     considering it to never be applicable.  */
d1649 1
a1649 1
  boolean everprinted = false;
d1659 1
a1659 1
	  everprinted = true;
@


1.6
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d264 1
a264 1
  {"demangle", no_argument, &do_demangle, 1},
d301 3
a303 1
  -C, --demangle         Decode low-level symbol names into user-level names\n\
d325 1
d414 2
a415 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvV", long_options, (int *) 0)) != EOF)
d431 11
d485 11
a1476 1
      printf ("%*s",
d1478 1
a1478 3
	      16,
#else
	      8,
d1480 1
a1480 1
	      "");
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d294 29
a322 10
  fprintf (stream, _("\
Usage: %s [-aABCDglnopPrsuvV] [-t radix] [--radix=radix] [--target=bfdname]\n\
       [--debug-syms] [--extern-only] [--print-armap] [--print-file-name]\n\
       [--numeric-sort] [--no-sort] [--reverse-sort] [--size-sort]\n\
       [--undefined-only] [--portability] [-f {bsd,sysv,posix}]\n\
       [--format={bsd,sysv,posix}] [--demangle] [--no-demangle] [--dynamic]\n\
       [--defined-only] [--line-numbers]\n\
       [--version] [--help]\n\
       [file...]\n"),
	   program_name);
d325 1
a325 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 12
d83 3
d252 7
a258 3
/* IMPORT */
extern char *program_name;
extern char *target;
d280 1
a280 1
  {"target", required_argument, 0, 200},
d289 1
a289 1
void
d294 1
a294 1
  fprintf (stream, "\
d302 1
a302 1
       [file...]\n",
d306 1
a306 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d312 1
a312 1
void
d339 1
a339 2
      fprintf (stderr, "%s: %s: invalid radix\n", program_name, radix);
      exit (1);
d343 1
a343 1
void
d364 1
a364 2
      fprintf (stderr, "%s: %s: invalid output format\n", program_name, f);
      exit (1);
d377 6
d389 1
d451 1
a451 1
	case 200:		/* --target */
a487 1
      extern char **environ;
d490 1
a490 2
      fprintf (stderr, "%s: data size %ld\n", program_name,
	       (long) (lim - (char *) &environ));
d541 5
a545 1
	bfd_close (last_arfile);
d550 5
a554 1
    bfd_close (last_arfile);
d595 3
d801 1
a801 1
  asymbol *sym;
d901 1
a901 1
	  printf ("No symbols in \"%s\".\n", bfd_get_filename (abfd));
d912 1
a912 1
      fprintf (stderr, "%s: no symbols\n", bfd_get_filename (abfd));
d1025 2
a1026 1
     char *format, *name;
d1154 5
d1170 1
d1178 2
a1179 1
	  unsigned int seccount, i;
d1185 12
a1196 1
	  seccount = bfd_count_sections (abfd);
d1202 2
d1213 1
d1219 1
a1219 1
	      unsigned int j;
d1280 1
a1280 1
    printf ("\n\nUndefined symbols from %s:\n\n", filename);
d1282 3
a1284 3
    printf ("\n\nSymbols from %s:\n\n", filename);
  printf ("\
Name                  Value   Class        Type         Size   Line  Section\n\n");
d1307 1
a1307 1
     char *filename;
d1313 1
a1313 1
     char *filename;
d1321 1
a1321 1
     char *archive;
d1334 1
a1334 1
    printf ("\n\nUndefined symbols from %s[%s]:\n\n", archive, filename);
d1336 3
a1338 3
    printf ("\n\nSymbols from %s[%s]:\n\n", archive, filename);
  printf ("\
Name                  Value   Class        Type         Size   Line  Section\n\n");
d1429 1
a1429 1
  if (info->type == 'U')
d1460 1
a1460 1
  if (info->type == 'U')
d1483 1
a1483 1
  if (info->type == 'U')
d1507 1
a1507 1
	  printf ("\nArchive index:\n");
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a236 1
extern char *program_version;
a237 1
extern int print_version;
d284 2
d438 1
a438 4
    {
      printf ("GNU %s version %s\n", program_name, program_version);
      exit (0);
    }
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94 Free Software Foundation, Inc.
d38 11
d148 2
d214 1
d249 1
d276 1
a276 1
Usage: %s [-aABCDgnopPrsuvV] [-t radix] [--radix=radix] [--target=bfdname]\n\
d281 1
a281 1
       [--defined-only]\n\
d365 1
a365 1
  while ((c = getopt_long (argc, argv, "aABCDef:gnopPrst:uvV", long_options, (int *) 0)) != EOF)
d396 3
d813 2
d1101 1
a1101 1
	print_symname ("%s\n", bfd_asymbol_name (sym), abfd);
a1108 1
      putchar ('\n');
d1110 93
d1465 38
@


1.1
log
@Initial revision
@
text
@d190 1
d247 1
d266 1
d934 1
d951 7
d1345 2
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a189 1
static int defined_only = 0;	/* Print defined symbols only */
a245 1
  {"defined-only", no_argument, &defined_only, 1},
a263 1
       [--defined-only]\n\
a930 1
		|| (sym->flags & BSF_WEAK) != 0
a946 7
      if (keep
	  && defined_only)
	{
	  if (bfd_is_und_section (sym->section))
	    keep = 0;
	}

a1333 2
      if (elt == NULL)
	bfd_fatal ("bfd_get_elt_at_index");
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a37 11
/* When fetching relocs, we use this structure to pass information to
   get_relocs.  */

struct get_relocs_info
{
  asection **secs;
  arelent ***relocs;
  long *relcount;
  asymbol **syms;
};

a136 2
static void
get_relocs PARAMS ((bfd *, asection *, PTR));
a200 1
static int line_numbers = 0;	/* print line numbers for symbols */
a234 1
  {"line-numbers", no_argument, 0, 'l'},
d261 1
a261 1
Usage: %s [-aABCDglnopPrsuvV] [-t radix] [--radix=radix] [--target=bfdname]\n\
d266 1
a266 1
       [--defined-only] [--line-numbers]\n\
d350 1
a350 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvV", long_options, (int *) 0)) != EOF)
a380 3
	case 'l':
	  line_numbers = 1;
	  break;
a794 2
      else
	next = NULL;
d1081 1
a1081 1
	print_symname ("%s", bfd_asymbol_name (sym), abfd);
d1089 1
a1090 93

  if (line_numbers)
    {
      static asymbol **syms;
      static long symcount;
      const char *filename, *functionname;
      unsigned int lineno;

      /* We need to get the canonical symbols in order to call
         bfd_find_nearest_line.  This is inefficient, but, then, you
         don't have to use --line-numbers.  */
      if (syms == NULL)
	{
	  long symsize;

	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  syms = (asymbol **) xmalloc (symsize);
	  symcount = bfd_canonicalize_symtab (abfd, syms);
	  if (symcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	}

      if (bfd_is_und_section (bfd_get_section (sym)))
	{
	  static asection **secs;
	  static arelent ***relocs;
	  static long *relcount;
	  unsigned int seccount, i;
	  const char *symname;

	  /* For an undefined symbol, we try to find a reloc for the
             symbol, and print the line number of the reloc.  */

	  seccount = bfd_count_sections (abfd);

	  if (relocs == NULL)
	    {
	      struct get_relocs_info info;

	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);

	      info.secs = secs;
	      info.relocs = relocs;
	      info.relcount = relcount;
	      info.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (PTR) &info);
	    }

	  symname = bfd_asymbol_name (sym);
	  for (i = 0; i < seccount; i++)
	    {
	      unsigned int j;

	      for (j = 0; j < relcount[i]; j++)
		{
		  arelent *r;

		  r = relocs[i][j];
		  if (r->sym_ptr_ptr != NULL
		      && (*r->sym_ptr_ptr)->section == sym->section
		      && (*r->sym_ptr_ptr)->value == sym->value
		      && strcmp (symname,
				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
		      && bfd_find_nearest_line (abfd, secs[i], syms,
						r->address, &filename,
						&functionname, &lineno))
		    {
		      /* We only print the first one we find.  */
		      printf ("\t%s:%u", filename, lineno);
		      i = seccount;
		      break;
		    }
		}
	    }
	}
      else if (bfd_get_section (sym)->owner == abfd)
	{
	  if (bfd_find_nearest_line (abfd, bfd_get_section (sym), syms,
				     sym->value, &filename, &functionname,
				     &lineno)
	      && filename != NULL
	      && lineno != 0)
	    {
	      printf ("\t%s:%u", filename, lineno);
	    }
	}
    }

  putchar ('\n');
a1352 38
}

/* This function is used to get the relocs for a particular section.
   It is called via bfd_map_over_sections.  */

static void
get_relocs (abfd, sec, dataarg)
     bfd *abfd;
     asection *sec;
     PTR dataarg;
{
  struct get_relocs_info *data = (struct get_relocs_info *) dataarg;

  *data->secs = sec;

  if ((sec->flags & SEC_RELOC) == 0)
    {
      *data->relocs = NULL;
      *data->relcount = 0;
    }
  else
    {
      long relsize;

      relsize = bfd_get_reloc_upper_bound (abfd, sec);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      *data->relocs = (arelent **) xmalloc (relsize);
      *data->relcount = bfd_canonicalize_reloc (abfd, sec, *data->relocs,
						data->syms);
      if (*data->relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
    }

  ++data->secs;
  ++data->relocs;
  ++data->relcount;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d237 1
d239 1
a285 2
  if (status == 0)
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d438 4
a441 1
    print_version ("nm");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a48 12
static void
usage PARAMS ((FILE *, int));

static void
set_print_radix PARAMS ((char *));

static void
set_output_format PARAMS ((char *));

static void
display_archive PARAMS ((bfd *));

a68 3
print_symname PARAMS ((const char *, const char *, bfd *));

static void
d268 1
a268 1
static void
d291 1
a291 1
static void
d323 1
a323 1
static void
a363 1
  set_default_bfd_target ();
d990 1
a990 2
     const char *format;
     const char *name;
a1109 1
      static bfd *cache_bfd;
a1117 5
      if (abfd != cache_bfd && syms != NULL)
	{
	  free (syms);
	  syms = NULL;
	}
a1128 1
	  cache_bfd = abfd;
a1132 1
	  static bfd *cache_rel_bfd;
a1143 13
	  if (abfd != cache_rel_bfd && relocs != NULL)
	    {
	      for (i = 0; i < seccount; i++)
		if (relocs[i] != NULL)
		  free (relocs[i]);
	      free (secs);
	      free (relocs);
	      free (relcount);
	      secs = NULL;
	      relocs = NULL;
	      relcount = NULL;
	    }

a1156 1
	      cache_rel_bfd = abfd;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d250 3
a252 7
static char *target = NULL;

/* Used to cache the line numbers for a BFD.  */
static bfd *lineno_cache_bfd;
static bfd *lineno_cache_rel_bfd;

#define OPTION_TARGET 200
d274 1
a274 1
  {"target", required_argument, 0, OPTION_TARGET},
d288 1
a288 1
  fprintf (stream, _("\
d296 1
a296 1
       [file...]\n"),
d300 1
a300 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d333 2
a334 1
      fatal (_("%s: invalid radix"), radix);
d359 2
a360 1
      fatal (_("%s: invalid output format"), f);
a372 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d441 1
a441 1
	case OPTION_TARGET:	/* --target */
d478 1
d481 2
a482 1
      non_fatal (_("data size %ld"), (long) (lim - (char *) &environ));
d533 1
a533 5
	{
	  bfd_close (last_arfile);
	  lineno_cache_bfd = NULL;
	  lineno_cache_rel_bfd = NULL;
	}
d538 1
a538 5
    {
      bfd_close (last_arfile);
      lineno_cache_bfd = NULL;
      lineno_cache_rel_bfd = NULL;
    }
a578 3
  lineno_cache_bfd = NULL;
  lineno_cache_rel_bfd = NULL;

d782 1
a782 1
  asymbol *sym = NULL;
d882 1
a882 1
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d893 1
a893 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d1127 1
d1136 1
a1136 1
      if (abfd != lineno_cache_bfd && syms != NULL)
d1152 1
a1152 1
	  lineno_cache_bfd = abfd;
d1157 1
d1161 1
a1161 2
	  static unsigned int seccount;
	  unsigned int i;
d1167 3
a1169 1
	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
a1185 2
	      seccount = bfd_count_sections (abfd);

d1195 1
a1195 1
	      lineno_cache_rel_bfd = abfd;
d1201 1
a1201 1
	      long j;
d1262 1
a1262 1
    printf (_("\n\nUndefined symbols from %s:\n\n"), filename);
d1264 3
a1266 3
    printf (_("\n\nSymbols from %s:\n\n"), filename);
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1289 1
a1289 1
     char *filename ATTRIBUTE_UNUSED;
d1295 1
a1295 1
     char *filename ATTRIBUTE_UNUSED;
d1303 1
a1303 1
     char *archive ATTRIBUTE_UNUSED;
d1316 1
a1316 1
    printf (_("\n\nUndefined symbols from %s[%s]:\n\n"), archive, filename);
d1318 3
a1320 3
    printf (_("\n\nSymbols from %s[%s]:\n\n"), archive, filename);
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1411 1
a1411 1
  if (bfd_is_undefined_symclass (info->type))
d1442 1
a1442 1
  if (bfd_is_undefined_symclass (info->type))
d1465 1
a1465 1
  if (bfd_is_undefined_symclass (info->type))
d1489 1
a1489 1
	  printf (_("\nArchive index:\n"));
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d294 10
a303 29
  fprintf (stream, _("Usage: %s [OPTION]... [FILE]...\n"), program_name);
  fprintf (stream, _("List symbols from FILEs (a.out by default).\n"));
  fprintf (stream, _("\n\
  -a, --debug-syms       Display debugger-only symbols\n\
  -A, --print-file-name  Print name of the input file before every symbol\n\
  -B                     Same as --format=bsd\n\
  -C, --demangle         Decode low-level symbol names into user-level names\n\
      --no-demangle      Do not demangle low-level symbol names\n\
  -D, --dynamic          Display dynamic symbols instead of normal symbols\n\
      --defined-only     Display only defined symbols\n\
  -e                     (ignored)\n\
  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\
                           `sysv' or `posix'.  The default is `bsd'\n\
  -g, --extern-only      Display only external symbols\n\
  -h, --help             Display this information\n\
  -l, --line-numbers     Use debugging information to find a filename and\n\
                           line number for each symbol\n\
  -n, --numeric-sort     Sort symbols numerically by address\n\
  -o                     Same as -A\n\
  -p, --no-sort          Do not sort the symbols\n\
  -P, --portability      Same as --format=posix\n\
  -r, --reverse-sort     Reverse the sense of the sort\n\
  -s, --print-armap      Include index for symbols from archive members\n\
      --size-sort        Sort symbols by size\n\
  -t, --radix=RADIX      Use RADIX for printing symbol values\n\
      --target=BFDNAME   Specify the target object format as BFDNAME\n\
  -u, --undefined-only   Display only undefined symbols\n\
  -V, --version          Display this program's version number\n\
\n"));
d306 1
a306 1
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d263 1
a263 1
  {"demangle", optional_argument, 0, 'C'},
d300 1
a300 3
  -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n\
                          The STYLE, if specified, can be `auto' (the default),\n\
                          `gnu', 'lucid', 'arm', 'hp', 'edg' or 'gnu-new-abi'\n\
a321 1
  -X 32_64               (ignored)\n\
d410 1
a410 2
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvVX:",
			   long_options, (int *) 0)) != EOF)
a425 11
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;
	      
	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling) 
		fatal (_("unknown demangling style `%s'"),
		       optarg);
	      
	      cplus_demangle_set_style (style);
           }
a468 11
	case 'X':
	  /* Ignored for (partial) AIX compatibility.  On AIX, the
	     argument has values 32, 64, or 32_64, and specfies that
	     only 32-bit, only 64-bit, or both kinds of objects should
	     be examined.  The default is 32.  So plain AIX nm on a
	     library archive with both kinds of objects will ignore
	     the 64-bit ones.  For GNU nm, the default is and always
	     has been -X 32_64, and other options are not supported.  */
	  if (strcmp (optarg, "32_64") != 0)
	    fatal (_("Only -X 32_64 is supported"));
	  break;
d1450 1
d1452 3
a1454 1
      printf ("        ");
d1456 1
a1456 1
      printf ("        ");
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
a25 1
#include "budemang.h"
a30 2
#include "elf-bfd.h"
#include "elf/common.h"
d52 39
a90 42
struct extended_symbol_info
{
  symbol_info *sinfo;
  bfd_vma ssize;
  elf_symbol_type *elfinfo;
  /* FIXME: We should add more fields for Type, Line, Section.  */
};
#define SYM_NAME(sym)        (sym->sinfo->name)
#define SYM_VALUE(sym)       (sym->sinfo->value)
#define SYM_TYPE(sym)        (sym->sinfo->type)
#define SYM_STAB_NAME(sym)   (sym->sinfo->stab_name)
#define SYM_STAB_DESC(sym)   (sym->sinfo->stab_desc)
#define SYM_STAB_OTHER(sym)  (sym->sinfo->stab_other)
#define SYM_SIZE(sym) \
  (sym->elfinfo ? sym->elfinfo->internal_elf_sym.st_size: sym->ssize)

static void usage
  PARAMS ((FILE *, int));
static void set_print_radix
  PARAMS ((char *));
static void set_output_format
  PARAMS ((char *));
static void display_archive
  PARAMS ((bfd *));
static bfd_boolean display_file
  PARAMS ((char *));
static void display_rel_file
  PARAMS ((bfd *, bfd *));
static long filter_symbols
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int));
static long sort_symbols_by_size
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, struct size_sym **));
static void print_symbols
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, bfd *));
static void print_size_symbols
  PARAMS ((bfd *, bfd_boolean, struct size_sym *, long, bfd *));
static void print_symname
  PARAMS ((const char *, const char *, bfd *));
static void print_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma ssize, bfd *));
static void print_symdef_entry
  PARAMS ((bfd *));
d93 18
a110 12
static int numeric_forward
  PARAMS ((const PTR, const PTR));
static int numeric_reverse
  PARAMS ((const PTR, const PTR));
static int non_numeric_forward
  PARAMS ((const PTR, const PTR));
static int non_numeric_reverse
  PARAMS ((const PTR, const PTR));
static int size_forward1
  PARAMS ((const PTR, const PTR));
static int size_forward2
  PARAMS ((const PTR, const PTR));
d113 55
a167 36
static void print_object_filename_bsd
  PARAMS ((char *));
static void print_object_filename_sysv
  PARAMS ((char *));
static void print_object_filename_posix
  PARAMS ((char *));
static void print_archive_filename_bsd
  PARAMS ((char *));
static void print_archive_filename_sysv
  PARAMS ((char *));
static void print_archive_filename_posix
  PARAMS ((char *));
static void print_archive_member_bsd
  PARAMS ((char *, const char *));
static void print_archive_member_sysv
  PARAMS ((char *, const char *));
static void print_archive_member_posix
  PARAMS ((char *, const char *));
static void print_symbol_filename_bsd
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_sysv
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_posix
  PARAMS ((bfd *, bfd *));
static void print_value
  PARAMS ((bfd *, bfd_vma));
static void print_symbol_info_bsd
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_sysv
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_posix
  PARAMS ((struct extended_symbol_info *, bfd *));
static void get_relocs
  PARAMS ((bfd *, asection *, PTR));
static const char * get_symbol_type
  PARAMS ((unsigned int));
d173 1
a173 1
    void (*print_object_filename) PARAMS ((char *));
d176 1
a176 1
    void (*print_archive_filename) PARAMS ((char *));
d179 1
a179 1
    void (*print_archive_member) PARAMS ((char *, const char *));
d183 1
a183 1
    void (*print_symbol_filename) PARAMS ((bfd *, bfd *));
d186 1
a186 1
    void (*print_symbol_info) PARAMS ((struct extended_symbol_info *, bfd *));
a187 1

d216 1
d220 13
a232 14
static int external_only = 0;	/* Print external symbols only.  */
static int defined_only = 0;	/* Print defined symbols only.  */
static int no_sort = 0;		/* Don't sort; print syms in order found.  */
static int print_debug_syms = 0;/* Print debugger-only symbols too.  */
static int print_armap = 0;	/* Describe __.SYMDEF data in archive files.  */
static int print_size = 0;	/* Print size of defined symbols.  */
static int reverse_sort = 0;	/* Sort in downward(alpha or numeric) order.  */
static int sort_numerically = 0;/* Sort in numeric rather than alpha order.  */
static int sort_by_size = 0;	/* Sort by size of symbol.  */
static int undefined_only = 0;	/* Print undefined symbols only.  */
static int dynamic = 0;		/* Print dynamic symbols.  */
static int show_version = 0;	/* Show the version number.  */
static int show_stats = 0;	/* Show statistics.  */
static int line_numbers = 0;	/* Print line numbers for symbols.  */
a247 5
#ifdef BFD64
static int print_width = 16;
#else
static int print_width = 8;
#endif
a276 1
  {"print-size", no_argument, 0, 'S'},
d288 1
a288 1
/* Some error-reporting functions.  */
d295 3
a297 3
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" List symbols in [file(s)] (a.out by default).\n"));
  fprintf (stream, _(" The options are:\n\
d303 1
a303 2
                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                          or `gnat'\n\
d311 1
a318 1
  -S, --print-size       Print size of defined symbols\n\
d324 1
a325 2
  -h, --help             Display this information\n\
  -V, --version          Display this program's version number\n\
a391 2
int main PARAMS ((int, char **));

a402 4
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
#endif
d414 1
a414 1
  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
d434 1
a434 1

d436 1
a436 1
	      if (style == unknown_demangling)
d439 1
a439 1

d441 1
a441 1
	    }
a454 1
	case 'H':
a475 3
	case 'S':
	  print_size = 1;
	  break;
a511 7
  if (sort_by_size && undefined_only)
    {
      non_fatal (_("Using the --size-sort and --undefined-only options together"));
      non_fatal (_("will produce no output, since undefined symbols have no size."));
      return 0;
    }

a543 26
static const char *
get_symbol_type (type)
     unsigned int type;
{
  static char buff [32];

  switch (type)
    {
    case STT_NOTYPE:   return "NOTYPE";
    case STT_OBJECT:   return "OBJECT";
    case STT_FUNC:     return "FUNC";
    case STT_SECTION:  return "SECTION";
    case STT_FILE:     return "FILE";
    case STT_COMMON:   return "COMMON";
    case STT_TLS:      return "TLS";
    default:
      if (type >= STT_LOPROC && type <= STT_HIPROC)
	sprintf (buff, _("<processor specific>: %d"), type);
      else if (type >= STT_LOOS && type <= STT_HIOS)
	sprintf (buff, _("<OS specific>: %d"), type);
      else
	sprintf (buff, _("<unknown>: %d"), type);
      return buff;
    }
}

a571 4
	  char buf[30];

	  bfd_sprintf_vma (arfile, buf, (bfd_vma) -1);
	  print_width = strlen (buf);
d603 1
a603 1
static bfd_boolean
d607 1
a607 1
  bfd_boolean retval = TRUE;
d615 1
a615 1
      return FALSE;
a623 4
      char buf[30];

      bfd_sprintf_vma (file, buf, (bfd_vma) -1);
      print_width = strlen (buf);
d635 1
a635 1
      retval = FALSE;
d638 1
a638 1
  if (!bfd_close (file))
d650 1
a650 1
static bfd_boolean sort_dynamic;
d714 2
a715 17
  if (yn == NULL)
    return xn != NULL;
  if (xn == NULL)
    return -1;

#ifdef HAVE_STRCOLL
  /* Solaris 2.5 has a bug in strcoll.
     strcoll returns invalid values when confronted with empty strings.  */
  if (*yn == '\0')
    return *xn != '\0';
  if (*xn == '\0')
    return -1;

  return strcoll (xn, yn);
#else
  return strcmp (xn, yn);
#endif
d831 4
a834 4
/* Sort the symbols by size.  ELF provides a size but for other formats
   we have to make a guess by assuming that the difference between the
   address of a symbol and the address of the next higher symbol is the
   size.  */
d839 1
a839 1
     bfd_boolean dynamic;
d860 1
d896 1
a896 3
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	sz = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
      else if (bfd_is_com_section (sec))
d1001 1
a1001 1
     bfd_boolean dynamic;
d1023 1
a1023 1

d1077 7
a1083 1
      char *res = demangle (abfd, name);
d1085 7
a1091 3
      printf (format, res);
      free (res);
      return;
d1103 1
a1103 1
     bfd_boolean dynamic;
d1126 1
a1126 1
      print_symbol (abfd, sym, (bfd_vma) 0, archive_bfd);
d1132 1
a1132 1
static void
d1135 1
a1135 1
     bfd_boolean dynamic;
a1151 1
      bfd_vma ssize;
d1157 3
a1159 5
      /* For elf we have already computed the correct symbol size.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	ssize = from->size;
      else
	ssize = from->size - bfd_section_vma (abfd, bfd_get_section (sym));
d1161 1
a1161 1
      print_symbol (abfd, sym, ssize, archive_bfd);
d1168 1
a1168 1
print_symbol (abfd, sym, ssize, archive_bfd)
a1170 1
     bfd_vma ssize;
a1172 3
  symbol_info syminfo;
  struct extended_symbol_info info;
   
d1177 5
a1181 5
  bfd_get_symbol_info (abfd, sym, &syminfo);
  info.sinfo = &syminfo;
  info.ssize = ssize;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    info.elfinfo = (elf_symbol_type *) sym;
d1183 6
a1188 2
    info.elfinfo = NULL;
  (*format->print_symbol_info) (&info, abfd);
d1230 1
d1279 1
a1279 2
						&functionname, &lineno)
		      && filename != NULL)
d1329 2
a1330 6
  if (print_width == 8)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
d1368 1
a1368 1
     const char *filename;
d1377 1
a1377 1
     const char *filename;
d1383 2
a1384 6
  if (print_width == 8)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
d1390 1
a1390 1
     const char *filename;
d1440 1
a1440 2
print_value (abfd, val)
     bfd *abfd ATTRIBUTE_UNUSED;
d1448 1
a1448 1
    bfd_fprintf_vma (abfd, stdout, val);
d1472 1
a1472 1
     struct extended_symbol_info *info;
d1475 1
a1475 1
  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
d1477 3
a1479 2
      if (print_width == 16)
	printf ("        ");
d1483 3
a1485 20
    {
      /* Normally we print the value of the symbol.  If we are printing the
	 size or sorting by size then we print its size, execpt for the
	 (weird) special case where both flags are defined, in which case we
	 print both values.  This conforms to documented behaviour.  */
      if (sort_by_size && !print_size)
	print_value (abfd, SYM_SIZE (info));
      else
	print_value (abfd, SYM_VALUE (info));

      if (print_size && SYM_SIZE (info))
	{
	  printf (" ");
	  print_value (abfd, SYM_SIZE (info));
	}
    }

  printf (" %c", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
d1489 1
a1489 1
      printf (other_format, SYM_STAB_OTHER (info));
d1491 2
a1492 2
      printf (desc_format, SYM_STAB_DESC (info));
      printf (" %5s", SYM_STAB_NAME (info));
d1494 1
a1494 1
  print_symname (" %s", SYM_NAME (info), abfd);
d1499 1
a1499 1
     struct extended_symbol_info *info;
d1502 3
a1504 9
  print_symname ("%-20s|", SYM_NAME (info), abfd);

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    {
      if (print_width == 8)
	printf ("        ");
      else
	printf ("                ");
    }
d1506 3
a1508 5
    print_value (abfd, SYM_VALUE (info));

  printf ("|   %c  |", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
d1511 3
a1513 3
      printf ("%18s|  ", SYM_STAB_NAME (info));		/* (C) Type.  */
      printf (desc_format, SYM_STAB_DESC (info));	/* Size.  */
      printf ("|     |");				/* Line, Section.  */
d1516 1
a1516 23
    {
      /* Type, Size, Line, Section */
      if (info->elfinfo)
	printf ("%18s|",
		get_symbol_type (ELF_ST_TYPE (info->elfinfo->internal_elf_sym.st_info)));
      else
	printf ("                  |");

      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
      else
	{
	  if (print_width == 8)
	    printf ("        ");
	  else
	    printf ("                ");
	}

      if (info->elfinfo)
	printf("|     |%s", info->elfinfo->symbol.section->name);
      else
	printf("|     |");
    }
d1521 1
a1521 1
     struct extended_symbol_info *info;
d1524 3
a1526 4
  print_symname ("%s ", SYM_NAME (info), abfd);
  printf ("%c ", SYM_TYPE (info));

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
d1529 4
a1532 6
    {
      print_value (abfd, SYM_VALUE (info));
      printf (" ");
      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
    }
d1541 1
a1541 1
  bfd_boolean everprinted = FALSE;
d1551 1
a1551 1
	  everprinted = TRUE;
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d40 1
a40 1
  const void *minisym;
d71 14
a84 7
static void usage (FILE *, int);
static void set_print_radix (char *);
static void set_output_format (char *);
static void display_archive (bfd *);
static bfd_boolean display_file (char *);
static void display_rel_file (bfd *, bfd *);
static long filter_symbols (bfd *, bfd_boolean, void *, long, unsigned int);
d86 1
a86 1
  (bfd *, bfd_boolean, void *, long, unsigned int, struct size_sym **);
d88 1
a88 1
  (bfd *, bfd_boolean, void *, long, unsigned int, bfd *);
d90 7
a96 4
  (bfd *, bfd_boolean, struct size_sym *, long, bfd *);
static void print_symname (const char *, const char *, bfd *);
static void print_symbol (bfd *, asymbol *, bfd_vma ssize, bfd *);
static void print_symdef_entry (bfd *);
d99 12
a110 6
static int numeric_forward (const void *, const void *);
static int numeric_reverse (const void *, const void *);
static int non_numeric_forward (const void *, const void *);
static int non_numeric_reverse (const void *, const void *);
static int size_forward1 (const void *, const void *);
static int size_forward2 (const void *, const void *);
d113 36
a148 18
static void print_object_filename_bsd (char *);
static void print_object_filename_sysv (char *);
static void print_object_filename_posix (char *);
static void print_archive_filename_bsd (char *);
static void print_archive_filename_sysv (char *);
static void print_archive_filename_posix (char *);
static void print_archive_member_bsd (char *, const char *);
static void print_archive_member_sysv (char *, const char *);
static void print_archive_member_posix (char *, const char *);
static void print_symbol_filename_bsd (bfd *, bfd *);
static void print_symbol_filename_sysv (bfd *, bfd *);
static void print_symbol_filename_posix (bfd *, bfd *);
static void print_value (bfd *, bfd_vma);
static void print_symbol_info_bsd (struct extended_symbol_info *, bfd *);
static void print_symbol_info_sysv (struct extended_symbol_info *, bfd *);
static void print_symbol_info_posix (struct extended_symbol_info *, bfd *);
static void get_relocs (bfd *, asection *, void *);
static const char * get_symbol_type (unsigned int);
d154 1
a154 1
    void (*print_object_filename) (char *);
d157 1
a157 1
    void (*print_archive_filename) (char *);
d160 1
a160 1
    void (*print_archive_member) (char *, const char *);
d164 1
a164 1
    void (*print_symbol_filename) (bfd *, bfd *);
d167 1
a167 1
    void (*print_symbol_info) (struct extended_symbol_info *, bfd *);
d279 3
a281 1
usage (FILE *stream, int status)
d326 2
a327 1
set_print_radix (char *radix)
d357 2
a358 1
set_output_format (char *f)
d382 1
a382 1
int main (int, char **);
d385 3
a387 1
main (int argc, char **argv)
d487 1
a487 1
	     argument has values 32, 64, or 32_64, and specifies that
d552 2
a553 1
get_symbol_type (unsigned int type)
d578 2
a579 1
display_archive (bfd *file)
d641 2
a642 1
display_file (char *filename)
a647 3
  if (get_file_size (filename) < 1)
    return FALSE;

d703 3
a705 1
numeric_forward (const void *P_x, const void *P_y)
d732 3
a734 1
numeric_reverse (const void *x, const void *y)
d740 3
a742 1
non_numeric_forward (const void *P_x, const void *P_y)
d775 3
a777 1
non_numeric_reverse (const void *x, const void *y)
d782 1
a782 1
static int (*(sorters[2][2])) (const void *, const void *) =
d800 3
a802 1
size_forward1 (const void *P_x, const void *P_y)
d872 3
a874 1
size_forward2 (const void *P_x, const void *P_y)
d893 7
a899 3
sort_symbols_by_size (bfd *abfd, bfd_boolean dynamic, void *minisyms,
		      long symcount, unsigned int size,
		      struct size_sym **symsizesp)
d924 1
a924 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from,
d941 1
a941 1
					   (const void *) (from + size),
d968 1
a968 1
	  symsizes->minisym = (const void *) from;
d983 1
a983 1
  qsort ((void *) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);
d991 3
a993 1
display_rel_file (bfd *abfd, bfd *archive_bfd)
d996 1
a996 1
  void *minisyms;
d1056 6
a1061 2
filter_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms,
		long symcount, unsigned int size)
d1081 1
a1081 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from, store);
d1127 4
a1130 1
print_symname (const char *format, const char *name, bfd *abfd)
d1148 7
a1154 2
print_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms, long symcount,
	       unsigned int size, bfd *archive_bfd)
d1180 6
a1185 3
print_size_symbols (bfd *abfd, bfd_boolean dynamic,
		    struct size_sym *symsizes, long symcount,
		    bfd *archive_bfd)
d1218 5
a1222 1
print_symbol (bfd *abfd, asymbol *sym, bfd_vma ssize, bfd *archive_bfd)
d1226 1
a1226 1

d1307 1
a1307 1
	      bfd_map_over_sections (abfd, get_relocs, (void *) &info);
d1364 2
a1365 1
print_object_filename_bsd (char *filename)
d1372 2
a1373 1
print_object_filename_sysv (char *filename)
d1388 2
a1389 1
print_object_filename_posix (char *filename)
d1398 2
a1399 1
print_archive_filename_bsd (char *filename)
d1406 2
a1407 1
print_archive_filename_sysv (char *filename ATTRIBUTE_UNUSED)
d1412 2
a1413 1
print_archive_filename_posix (char *filename ATTRIBUTE_UNUSED)
d1420 3
a1422 2
print_archive_member_bsd (char *archive ATTRIBUTE_UNUSED,
			  const char *filename)
d1429 3
a1431 1
print_archive_member_sysv (char *archive, const char *filename)
d1446 3
a1448 1
print_archive_member_posix (char *archive, const char *filename)
d1458 2
a1459 1
print_symbol_filename_bsd (bfd *archive_bfd, bfd *abfd)
d1470 2
a1471 1
print_symbol_filename_sysv (bfd *archive_bfd, bfd *abfd)
d1482 2
a1483 1
print_symbol_filename_posix (bfd *archive_bfd, bfd *abfd)
d1498 3
a1500 1
print_value (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma val)
d1530 3
a1532 1
print_symbol_info_bsd (struct extended_symbol_info *info, bfd *abfd)
d1543 1
a1543 1
	 size or sorting by size then we print its size, except for the
d1573 3
a1575 1
print_symbol_info_sysv (struct extended_symbol_info *info, bfd *abfd)
d1625 3
a1627 1
print_symbol_info_posix (struct extended_symbol_info *info, bfd *abfd)
d1644 2
a1645 1
print_symdef_entry (bfd *abfd)
d1676 4
a1679 1
get_relocs (bfd *abfd, asection *sec, void *dataarg)
@


