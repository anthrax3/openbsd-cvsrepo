head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.5;
commitid	dbwlUkpK0xDlII16;

1.5
date	2004.11.02.20.45.19;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.33;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.54;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.54;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.45.10;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.17.00;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.05;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* Sysroff object format dumper.
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */


/* Written by Steve Chamberlain <sac@@cygnus.com>.

 This program reads a SYSROFF object file and prints it in an
 almost human readable form to stdout.  */

#include "bfd.h"
#include "bucomm.h"
#include "safe-ctype.h"

#include <stdio.h>
#include "libiberty.h"
#include "getopt.h"
#include "sysroff.h"

static int dump = 1;
static int segmented_p;
static int code;
static int addrsize = 4;
static FILE *file;

static void dh (unsigned char *, int);
static void itheader (char *, int);
static void p (void);
static void tabout (void);
static void pbarray (barray *);
static int getone (int);
static int opt (int);
static void must (int);
static void tab (int, char *);
static void dump_symbol_info (void);
static void derived_type (void);
static void module (void);
static void show_usage (FILE *, int);

extern char *getCHARS (unsigned char *, int *, int, int);
extern int fillup (char *);
extern barray getBARRAY (unsigned char *, int *, int, int);
extern int getINT (unsigned char *, int *, int, int);
extern int getBITS (char *, int *, int, int);
extern void sysroff_swap_tr_in (void);
extern void sysroff_print_tr_out (void);
extern int main (int, char **);

char *
getCHARS (unsigned char *ptr, int *idx, int size, int max)
{
  int oc = *idx / 8;
  char *r;
  int b = size;

  if (b >= max)
    return "*undefined*";

  if (b == 0)
    {
      /* Got to work out the length of the string from self.  */
      b = ptr[oc++];
      (*idx) += 8;
    }

  *idx += b * 8;
  r = xcalloc (b + 1, 1);
  memcpy (r, ptr + oc, b);
  r[b] = 0;

  return r;
}

static void
dh (unsigned char *ptr, int size)
{
  int i;
  int j;
  int span = 16;

  printf ("\n************************************************************\n");

  for (i = 0; i < size; i += span)
    {
      for (j = 0; j < span; j++)
	{
	  if (j + i < size)
	    printf ("%02x ", ptr[i + j]);
	  else
	    printf ("   ");
	}

      for (j = 0; j < span && j + i < size; j++)
	{
	  int c = ptr[i + j];

	  if (c < 32 || c > 127)
	    c = '.';
	  printf ("%c", c);
	}

      printf ("\n");
    }
}

int
fillup (char *ptr)
{
  int size;
  int sum;
  int i;

  size = getc (file) - 2;
  fread (ptr, 1, size, file);
  sum = code + size + 2;

  for (i = 0; i < size; i++)
    sum += ptr[i];

  if ((sum & 0xff) != 0xff)
    printf ("SUM IS %x\n", sum);

  if (dump)
    dh (ptr, size);

  return size - 1;
}

barray
getBARRAY (unsigned char *ptr, int *idx, int dsize ATTRIBUTE_UNUSED,
	   int max ATTRIBUTE_UNUSED)
{
  barray res;
  int i;
  int byte = *idx / 8;
  int size = ptr[byte++];

  res.len = size;
  res.data = (unsigned char *) xmalloc (size);

  for (i = 0; i < size; i++)
    res.data[i] = ptr[byte++];

  return res;
}

int
getINT (unsigned char *ptr, int *idx, int size, int max)
{
  int n = 0;
  int byte = *idx / 8;

  if (byte >= max)
    return 0;

  if (size == -2)
    size = addrsize;

  if (size == -1)
    size = 0;

  switch (size)
    {
    case 0:
      return 0;
    case 1:
      n = (ptr[byte]);
      break;
    case 2:
      n = (ptr[byte + 0] << 8) + ptr[byte + 1];
      break;
    case 4:
      n = (ptr[byte + 0] << 24) + (ptr[byte + 1] << 16) + (ptr[byte + 2] << 8) + (ptr[byte + 3]);
      break;
    default:
      abort ();
    }

  *idx += size * 8;
  return n;
}

int
getBITS (char *ptr, int *idx, int size, int max)
{
  int byte = *idx / 8;
  int bit = *idx % 8;

  if (byte >= max)
    return 0;

  *idx += size;

  return (ptr[byte] >> (8 - bit - size)) & ((1 << size) - 1);
}

static void
itheader (char *name, int code)
{
  printf ("\n%s 0x%02x\n", name, code);
}

static int indent;

static void
p (void)
{
  int i;

  for (i = 0; i < indent; i++)
    printf ("| ");

  printf ("> ");
}

static void
tabout (void)
{
  p ();
}

static void
pbarray (barray *y)
{
  int x;

  printf ("%d (", y->len);

  for (x = 0; x < y->len; x++)
    printf ("(%02x %c)", y->data[x],
	    ISPRINT (y->data[x]) ? y->data[x] : '.');

  printf (")\n");
}

#define SYSROFF_PRINT
#define SYSROFF_SWAP_IN

#include "sysroff.c"

/* FIXME: sysinfo, which generates sysroff.[ch] from sysroff.info, can't
   hack the special case of the tr block, which has no contents.  So we
   implement our own functions for reading in and printing out the tr
   block.  */

#define IT_tr_CODE	0x7f

void
sysroff_swap_tr_in (void)
{
  char raw[255];

  memset (raw, 0, 255);
  fillup (raw);
}

void
sysroff_print_tr_out (void)
{
  itheader ("tr", IT_tr_CODE);
}

static int
getone (int type)
{
  int c = getc (file);

  code = c;

  if ((c & 0x7f) != type)
    {
      ungetc (c, file);
      return 0;
    }

  switch (c & 0x7f)
    {
    case IT_cs_CODE:
      {
	struct IT_cs dummy;
	sysroff_swap_cs_in (&dummy);
	sysroff_print_cs_out (&dummy);
      }
      break;

    case IT_dln_CODE:
      {
	struct IT_dln dummy;
	sysroff_swap_dln_in (&dummy);
	sysroff_print_dln_out (&dummy);
      }
      break;

    case IT_hd_CODE:
      {
	struct IT_hd dummy;
	sysroff_swap_hd_in (&dummy);
	addrsize = dummy.afl;
	sysroff_print_hd_out (&dummy);
      }
      break;

    case IT_dar_CODE:
      {
	struct IT_dar dummy;
	sysroff_swap_dar_in (&dummy);
	sysroff_print_dar_out (&dummy);
      }
      break;

    case IT_dsy_CODE:
      {
	struct IT_dsy dummy;
	sysroff_swap_dsy_in (&dummy);
	sysroff_print_dsy_out (&dummy);
      }
      break;

    case IT_dfp_CODE:
      {
	struct IT_dfp dummy;
	sysroff_swap_dfp_in (&dummy);
	sysroff_print_dfp_out (&dummy);
      }
      break;

    case IT_dso_CODE:
      {
	struct IT_dso dummy;
	sysroff_swap_dso_in (&dummy);
	sysroff_print_dso_out (&dummy);
      }
      break;

    case IT_dpt_CODE:
      {
	struct IT_dpt dummy;
	sysroff_swap_dpt_in (&dummy);
	sysroff_print_dpt_out (&dummy);
      }
      break;

    case IT_den_CODE:
      {
	struct IT_den dummy;
	sysroff_swap_den_in (&dummy);
	sysroff_print_den_out (&dummy);
      }
      break;

    case IT_dbt_CODE:
      {
	struct IT_dbt dummy;
	sysroff_swap_dbt_in (&dummy);
	sysroff_print_dbt_out (&dummy);
      }
      break;

    case IT_dty_CODE:
      {
	struct IT_dty dummy;
	sysroff_swap_dty_in (&dummy);
	sysroff_print_dty_out (&dummy);
      }
      break;

    case IT_un_CODE:
      {
	struct IT_un dummy;
	sysroff_swap_un_in (&dummy);
	sysroff_print_un_out (&dummy);
      }
      break;

    case IT_sc_CODE:
      {
	struct IT_sc dummy;
	sysroff_swap_sc_in (&dummy);
	sysroff_print_sc_out (&dummy);
      }
      break;

    case IT_er_CODE:
      {
	struct IT_er dummy;
	sysroff_swap_er_in (&dummy);
	sysroff_print_er_out (&dummy);
      }
      break;

    case IT_ed_CODE:
      {
	struct IT_ed dummy;
	sysroff_swap_ed_in (&dummy);
	sysroff_print_ed_out (&dummy);
      }
      break;

    case IT_sh_CODE:
      {
	struct IT_sh dummy;
	sysroff_swap_sh_in (&dummy);
	sysroff_print_sh_out (&dummy);
      }
      break;

    case IT_ob_CODE:
      {
	struct IT_ob dummy;
	sysroff_swap_ob_in (&dummy);
	sysroff_print_ob_out (&dummy);
      }
      break;

    case IT_rl_CODE:
      {
	struct IT_rl dummy;
	sysroff_swap_rl_in (&dummy);
	sysroff_print_rl_out (&dummy);
      }
      break;

    case IT_du_CODE:
      {
	struct IT_du dummy;
	sysroff_swap_du_in (&dummy);

	sysroff_print_du_out (&dummy);
      }
      break;

    case IT_dus_CODE:
      {
	struct IT_dus dummy;
	sysroff_swap_dus_in (&dummy);
	sysroff_print_dus_out (&dummy);
      }
      break;

    case IT_dul_CODE:
      {
	struct IT_dul dummy;
	sysroff_swap_dul_in (&dummy);
	sysroff_print_dul_out (&dummy);
      }
      break;

    case IT_dss_CODE:
      {
	struct IT_dss dummy;
	sysroff_swap_dss_in (&dummy);
	sysroff_print_dss_out (&dummy);
      }
      break;

    case IT_hs_CODE:
      {
	struct IT_hs dummy;
	sysroff_swap_hs_in (&dummy);
	sysroff_print_hs_out (&dummy);
      }
      break;

    case IT_dps_CODE:
      {
	struct IT_dps dummy;
	sysroff_swap_dps_in (&dummy);
	sysroff_print_dps_out (&dummy);
      }
      break;

    case IT_tr_CODE:
      sysroff_swap_tr_in ();
      sysroff_print_tr_out ();
      break;

    case IT_dds_CODE:
      {
	struct IT_dds dummy;

	sysroff_swap_dds_in (&dummy);
	sysroff_print_dds_out (&dummy);
      }
      break;

    default:
      printf ("GOT A %x\n", c);
      return 0;
      break;
    }

  return 1;
}

static int
opt (int x)
{
  return getone (x);
}

#if 0

/* This is no longer used.  */

static void
unit_info_list (void)
{
  while (opt (IT_un_CODE))
    {
      getone (IT_us_CODE);

      while (getone (IT_sc_CODE))
	getone (IT_ss_CODE);

      while (getone (IT_er_CODE))
	;

      while (getone (IT_ed_CODE))
	;
    }
}

#endif

#if 0

/* This is no longer used.  */

static void
object_body_list (void)
{
  while (getone (IT_sh_CODE))
    {
      while (getone (IT_ob_CODE))
	;
      while (getone (IT_rl_CODE))
	;
    }
}

#endif

static void
must (int x)
{
  if (!getone (x))
    printf ("WANTED %x!!\n", x);
}

static void
tab (int i, char *s)
{
  indent += i;

  if (s)
    {
      p ();
      printf (s);
      printf ("\n");
    }
}

static void
dump_symbol_info (void)
{
  tab (1, "SYMBOL INFO");

  while (opt (IT_dsy_CODE))
    {
      if (opt (IT_dty_CODE))
	{
	  must (IT_dbt_CODE);
	  derived_type ();
	  must (IT_dty_CODE);
	}
    }

  tab (-1, "");
}

static void
derived_type (void)
{
  tab (1, "DERIVED TYPE");

  while (1)
    {
      if (opt (IT_dpp_CODE))
	{
	  dump_symbol_info ();
	  must (IT_dpp_CODE);
	}
      else if (opt (IT_dfp_CODE))
	{
	  dump_symbol_info ();
	  must (IT_dfp_CODE);
	}
      else if (opt (IT_den_CODE))
	{
	  dump_symbol_info ();
	  must (IT_den_CODE);
	}
      else if (opt (IT_den_CODE))
	{
	  dump_symbol_info ();
	  must (IT_den_CODE);
	}
      else if (opt (IT_dds_CODE))
	{
	  dump_symbol_info ();
	  must (IT_dds_CODE);
	}
      else if (opt (IT_dar_CODE))
	{
	}
      else if (opt (IT_dpt_CODE))
	{
	}
      else if (opt (IT_dul_CODE))
	{
	}
      else if (opt (IT_dse_CODE))
	{
	}
      else if (opt (IT_dot_CODE))
	{
	}
      else
	break;
    }

  tab (-1, "");
}

#if 0

/* This is no longer used.  */

static void
program_structure (void)
{
  tab (1, "PROGRAM STRUCTURE");
  while (opt (IT_dps_CODE))
    {
      must (IT_dso_CODE);
      opt (IT_dss_CODE);
      dump_symbol_info ();
      must (IT_dps_CODE);
    }
  tab (-1, "");
}

#endif

#if 0

/* This is no longer used.  */

static void
debug_list (void)
{
  tab (1, "DEBUG LIST");

  must (IT_du_CODE);
  opt (IT_dus_CODE);
  program_structure ();
  must (IT_dln_CODE);

  tab (-1, "");
}

#endif

static void
module (void)
{
  int c = 0;
  int l = 0;

  tab (1, "MODULE***\n");

  do
    {
      c = getc (file);
      ungetc (c, file);

      c &= 0x7f;
    }
  while (getone (c) && c != IT_tr_CODE);

#if 0
  must (IT_cs_CODE);
  must (IT_hd_CODE);
  opt (IT_hs_CODE);

  unit_info_list ();
  object_body_list ();
  debug_list ();

  must (IT_tr_CODE);
#endif
  tab (-1, "");

  c = getc (file);
  while (c != EOF)
    {
      printf ("%02x ", c);
      l++;
      if (l == 32)
	{
	  printf ("\n");
	  l = 0;
	}
      c = getc (file);
    }
}

char *program_name;

static void
show_usage (FILE *file, int status)
{
  fprintf (file, _("Usage: %s [option(s)] in-file\n"), program_name);
  fprintf (file, _("Print a human readable interpretation of a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -h --help        Display this information\n\
  -v --version     Print the program's version number\n"));

  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

int
main (int ac, char **av)
{
  char *input_file = NULL;
  int opt;
  static struct option long_options[] =
  {
    {"help", no_argument, 0, 'h'},
    {"version", no_argument, 0, 'V'},
    {NULL, no_argument, 0, 0}
  };

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = av[0];
  xmalloc_set_program_name (program_name);

  expandargv (&ac, &av);

  while ((opt = getopt_long (ac, av, "HhVv", long_options, (int *) NULL)) != EOF)
    {
      switch (opt)
	{
	case 'H':
	case 'h':
	  show_usage (stdout, 0);
	  /*NOTREACHED*/
	case 'v':
	case 'V':
	  print_version ("sysdump");
	  exit (0);
	  /*NOTREACHED*/
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  /*NOTREACHED*/
	}
    }

  /* The input and output files may be named on the command line.  */

  if (optind < ac)
    input_file = av[optind];

  if (!input_file)
    fatal (_("no input file specified"));

  file = fopen (input_file, FOPEN_RB);

  if (!file)
    fatal (_("cannot open input file %s"), input_file);

  module ();
  return 0;
}
@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d775 2
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002
d43 22
a64 22
static void dh PARAMS ((unsigned char *, int));
static void itheader PARAMS ((char *, int));
static void p PARAMS ((void));
static void tabout PARAMS ((void));
static void pbarray PARAMS ((barray *));
static int getone PARAMS ((int));
static int opt PARAMS ((int));
static void must PARAMS ((int));
static void tab PARAMS ((int, char *));
static void dump_symbol_info PARAMS ((void));
static void derived_type PARAMS ((void));
static void module PARAMS ((void));
static void show_usage PARAMS ((FILE *, int));

extern char *getCHARS PARAMS ((unsigned char *, int *, int, int));
extern int fillup PARAMS ((char *));
extern barray getBARRAY PARAMS ((unsigned char *, int *, int, int));
extern int getINT PARAMS ((unsigned char *, int *, int, int));
extern int getBITS PARAMS ((char *, int *, int, int));
extern void sysroff_swap_tr_in PARAMS ((void));
extern void sysroff_print_tr_out PARAMS ((void));
extern int main PARAMS ((int, char **));
d67 1
a67 5
getCHARS (ptr, idx, size, max)
     unsigned char *ptr;
     int *idx;
     int size;
     int max;
d92 1
a92 3
dh (ptr, size)
     unsigned char *ptr;
     int size;
d124 1
a124 2
fillup (ptr)
     char *ptr;
d147 2
a148 5
getBARRAY (ptr, idx, dsize, max)
     unsigned char *ptr;
     int *idx;
     int dsize ATTRIBUTE_UNUSED;
     int max ATTRIBUTE_UNUSED;
d165 1
a165 5
getINT (ptr, idx, size, max)
     unsigned char *ptr;
     int *idx;
     int size;
     int max;
d201 1
a201 4
getBITS (ptr, idx, size, max)
     char *ptr;
     int *idx;
     int size, max;
d215 1
a215 3
itheader (name, code)
     char *name;
     int code;
d223 1
a223 1
p ()
d234 1
a234 1
tabout ()
d240 1
a240 2
pbarray (y)
     barray *y;
d266 1
a266 1
sysroff_swap_tr_in()
d275 1
a275 1
sysroff_print_tr_out()
d281 1
a281 2
getone (type)
     int type;
d513 1
a513 2
opt (x)
     int x;
d523 1
a523 1
unit_info_list ()
d547 1
a547 1
object_body_list ()
d561 1
a561 2
must (x)
     int x;
d568 1
a568 3
tab (i, s)
     int i;
     char *s;
d581 1
a581 1
dump_symbol_info ()
d599 1
a599 1
derived_type ()
d657 1
a657 1
program_structure ()
d677 1
a677 1
debug_list ()
d692 1
a692 1
module ()
d738 1
a738 3
show_usage (file, status)
     FILE *file;
     int status;
d752 1
a752 3
main (ac, av)
     int ac;
     char **av;
@


1.3
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1998, 1999, 2000 Free Software Foundation, Inc.
d26 1
a26 1
 almost human readable form to stdout. */
d30 1
d33 2
a34 3
#include <ctype.h>
#include <libiberty.h>
#include <getopt.h>
a36 2
#define PROGRAM_VERSION "1.0"

d43 23
d76 1
d78 1
a78 3
    {
      return "*undefined*";
    }
d82 1
a82 1
      /* Got to work out the length of the string from self */
d91 1
d110 1
a110 1
	  if (j + i < size) 
d112 2
a113 2
          else
            printf ("   ");
d119 1
d124 1
d136 1
d140 1
d142 1
a142 3
    {
      sum += ptr[i];
    }
d145 2
a146 3
    {
      printf ("SUM IS %x\n", sum);
    }
d164 1
d167 1
d169 2
a170 3
    {
      res.data[i] = ptr[byte++];
    }
d185 2
a186 3
    {
      return 0;
    }
d189 1
d192 1
d209 1
d240 1
d245 1
d247 2
a248 3
    {
      printf ("| ");
    }
d263 1
d265 1
d267 3
a269 3
    {
      printf ("(%02x %c)", y->data[x], isprint (y->data[x]) ? y->data[x] : '.');
    }
d278 4
a281 6
/* 
 * FIXME: sysinfo, which generates sysroff.[ch] from sysroff.info, can't
 * hack the special case of the tr block, which has no contents.  So we
 * implement our own functions for reading in and printing out the tr
 * block.
 */
d284 1
d288 1
a288 1
	char raw[255];
d290 2
a291 2
	memset(raw, 0, 255);
	fillup(raw);
d297 1
a297 1
	itheader("tr", IT_tr_CODE);
d305 1
d323 1
d331 1
d340 1
d348 1
d356 1
d364 1
d372 1
d380 1
d388 1
d396 1
d404 1
d412 1
d420 1
d428 1
d436 1
d444 1
d452 1
d460 1
d469 1
d477 1
d485 1
d493 1
d501 1
d509 1
d511 2
a512 4
      {
	sysroff_swap_tr_in ();
	sysroff_print_tr_out ();
      }
d514 1
d518 1
d523 1
d529 1
d587 1
a587 3
    {
      printf ("WANTED %x!!\n", x);
    }
d596 1
a604 2
static void derived_type ();

d609 1
d619 1
d627 1
d767 8
a774 1
  fprintf (file, _("Usage: %s [-hV] in-file\n"), program_name);
a777 8
static void
show_help ()
{
  printf (_("%s: Print a human readable interpretation of a SYSROFF object file\n"),
	  program_name);
  show_usage (stdout, 0);
}

d795 3
d804 1
a804 1
  while ((opt = getopt_long (ac, av, "hV", long_options, (int *) NULL)) != EOF)
d808 1
d810 1
a810 1
	  show_help ();
d812 1
d814 1
a814 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
d828 1
a828 3
    {
      input_file = av[optind];
    }
d831 1
a831 3
    {
      fatal (_("no input file specified"));
    }
d834 1
d836 1
a836 3
    {
      fatal (_("cannot open input file %s"), input_file);
    }
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 98, 99, 2000 Free Software Foundation, Inc.
d134 2
a135 2
     int dsize;
     int max;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 Copyright (C) 1994 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GNU Binutils.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 1
a37 2
static int h8300;
static int sh;
d41 1
a43 10
static char *
xcalloc (a, b)
     int a;
     int b;
{
  char *r = xmalloc (a * b);
  memset (r, 0, a * b);
  return r;
}

d165 1
a165 1
    size = 4;
d189 1
a189 1
getBITS (ptr, idx, size)
d192 1
a192 1
     int size;
d197 3
d305 1
d485 4
d507 6
d525 2
d622 4
d640 6
d659 2
d712 1
a712 1
  fprintf (file, "Usage: %s [-hV] in-file\n", program_name);
d719 1
a719 1
  printf ("%s: Print a human readable interpretation of a SYSROFF object file\n",
d738 6
d755 1
a755 1
	  printf ("GNU %s version %s\n", program_name, PROGRAM_VERSION);
d775 1
a775 3
      fprintf (stderr, "%s: no input file specified\n",
	       program_name);
      exit (1);
d781 1
a781 3
      fprintf (stderr, "%s: cannot open input file %s\n",
	       program_name, input_file);
      exit (1);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 98, 99, 2000 Free Software Foundation, Inc.
d4 1
a4 1
   This file is part of GNU Binutils.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d36 2
a37 1

a40 1
static int addrsize = 4;
d43 10
d174 1
a174 1
    size = addrsize;
d198 1
a198 1
getBITS (ptr, idx, size, max)
d201 1
a201 1
     int size, max;
a205 3
  if (byte >= max)
    return 0;

a310 1
	addrsize = dummy.afl;
a489 4
#if 0

/* This is no longer used.  */

a507 6
#endif

#if 0

/* This is no longer used.  */

a519 2
#endif

a614 4
#if 0

/* This is no longer used.  */

a628 6
#endif

#if 0

/* This is no longer used.  */

a641 2
#endif

d693 1
a693 1
  fprintf (file, _("Usage: %s [-hV] in-file\n"), program_name);
d700 1
a700 1
  printf (_("%s: Print a human readable interpretation of a SYSROFF object file\n"),
a718 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d730 1
a730 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
d750 3
a752 1
      fatal (_("no input file specified"));
d758 3
a760 1
      fatal (_("cannot open input file %s"), input_file);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1998, 1999, 2000 Free Software Foundation, Inc.
d134 2
a135 2
     int dsize ATTRIBUTE_UNUSED;
     int max ATTRIBUTE_UNUSED;
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d25 1
a25 1
 almost human readable form to stdout.  */
a28 1
#include "safe-ctype.h"
d31 3
a33 2
#include "libiberty.h"
#include "getopt.h"
d36 2
a43 23
static void dh PARAMS ((unsigned char *, int));
static void itheader PARAMS ((char *, int));
static void p PARAMS ((void));
static void tabout PARAMS ((void));
static void pbarray PARAMS ((barray *));
static int getone PARAMS ((int));
static int opt PARAMS ((int));
static void must PARAMS ((int));
static void tab PARAMS ((int, char *));
static void dump_symbol_info PARAMS ((void));
static void derived_type PARAMS ((void));
static void module PARAMS ((void));
static void show_usage PARAMS ((FILE *, int));

extern char *getCHARS PARAMS ((unsigned char *, int *, int, int));
extern int fillup PARAMS ((char *));
extern barray getBARRAY PARAMS ((unsigned char *, int *, int, int));
extern int getINT PARAMS ((unsigned char *, int *, int, int));
extern int getBITS PARAMS ((char *, int *, int, int));
extern void sysroff_swap_tr_in PARAMS ((void));
extern void sysroff_print_tr_out PARAMS ((void));
extern int main PARAMS ((int, char **));

a53 1

d55 3
a57 1
    return "*undefined*";
d61 1
a61 1
      /* Got to work out the length of the string from self.  */
a69 1

d88 1
a88 1
	  if (j + i < size)
d90 2
a91 2
	  else
	    printf ("   ");
a96 1

a100 1

a111 1

a114 1

d116 3
a118 1
    sum += ptr[i];
d121 3
a123 2
    printf ("SUM IS %x\n", sum);

a140 1

a142 1

d144 3
a146 2
    res.data[i] = ptr[byte++];

d161 3
a163 2
    return 0;

a165 1

a167 1

a183 1

a213 1

a217 1

d219 3
a221 2
    printf ("| ");

a235 1

a236 1

d238 3
a240 3
    printf ("(%02x %c)", y->data[x],
	    ISPRINT (y->data[x]) ? y->data[x] : '.');

d249 6
a254 4
/* FIXME: sysinfo, which generates sysroff.[ch] from sysroff.info, can't
   hack the special case of the tr block, which has no contents.  So we
   implement our own functions for reading in and printing out the tr
   block.  */
a256 1

d260 1
a260 1
  char raw[255];
d262 2
a263 2
  memset (raw, 0, 255);
  fillup (raw);
d269 1
a269 1
  itheader ("tr", IT_tr_CODE);
a276 1

a293 1

a300 1

a308 1

a315 1

a322 1

a329 1

a336 1

a343 1

a350 1

a357 1

a364 1

a371 1

a378 1

a385 1

a392 1

a399 1

a406 1

a413 1

a421 1

a428 1

a435 1

a442 1

a449 1

a456 1

d458 4
a461 2
      sysroff_swap_tr_in ();
      sysroff_print_tr_out ();
a462 1

a465 1

a469 1

a474 1

d532 3
a534 1
    printf ("WANTED %x!!\n", x);
a542 1

d551 2
a556 1

a565 1

a572 1

d712 3
a714 5
  fprintf (file, _("Usage: %s [option(s)] in-file\n"), program_name);
  fprintf (file, _("Print a human readable interpretation of a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -h --help        Display this information\n\
  -v --version     Print the program's version number\n"));
d716 6
a721 3
  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
a740 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d747 1
a747 1
  while ((opt = getopt_long (ac, av, "HhVv", long_options, (int *) NULL)) != EOF)
a750 1
	case 'H':
d752 1
a752 1
	  show_usage (stdout, 0);
a753 1
	case 'v':
d755 1
a755 1
	  print_version ("sysdump");
d769 3
a771 1
    input_file = av[optind];
d774 3
a776 1
    fatal (_("no input file specified"));
a778 1

d780 3
a782 1
    fatal (_("cannot open input file %s"), input_file);
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
d43 22
a64 22
static void dh (unsigned char *, int);
static void itheader (char *, int);
static void p (void);
static void tabout (void);
static void pbarray (barray *);
static int getone (int);
static int opt (int);
static void must (int);
static void tab (int, char *);
static void dump_symbol_info (void);
static void derived_type (void);
static void module (void);
static void show_usage (FILE *, int);

extern char *getCHARS (unsigned char *, int *, int, int);
extern int fillup (char *);
extern barray getBARRAY (unsigned char *, int *, int, int);
extern int getINT (unsigned char *, int *, int, int);
extern int getBITS (char *, int *, int, int);
extern void sysroff_swap_tr_in (void);
extern void sysroff_print_tr_out (void);
extern int main (int, char **);
d67 5
a71 1
getCHARS (unsigned char *ptr, int *idx, int size, int max)
d96 3
a98 1
dh (unsigned char *ptr, int size)
d130 2
a131 1
fillup (char *ptr)
d154 5
a158 2
getBARRAY (unsigned char *ptr, int *idx, int dsize ATTRIBUTE_UNUSED,
	   int max ATTRIBUTE_UNUSED)
d175 5
a179 1
getINT (unsigned char *ptr, int *idx, int size, int max)
d215 4
a218 1
getBITS (char *ptr, int *idx, int size, int max)
d232 3
a234 1
itheader (char *name, int code)
d242 1
a242 1
p (void)
d253 1
a253 1
tabout (void)
d259 2
a260 1
pbarray (barray *y)
d286 1
a286 1
sysroff_swap_tr_in (void)
d295 1
a295 1
sysroff_print_tr_out (void)
d301 2
a302 1
getone (int type)
d534 2
a535 1
opt (int x)
d545 1
a545 1
unit_info_list (void)
d569 1
a569 1
object_body_list (void)
d583 2
a584 1
must (int x)
d591 3
a593 1
tab (int i, char *s)
d606 1
a606 1
dump_symbol_info (void)
d624 1
a624 1
derived_type (void)
d682 1
a682 1
program_structure (void)
d702 1
a702 1
debug_list (void)
d717 1
a717 1
module (void)
d763 3
a765 1
show_usage (FILE *file, int status)
d779 3
a781 1
main (int ac, char **av)
@


