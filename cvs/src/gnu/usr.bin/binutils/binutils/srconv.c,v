head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.12
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.6;
commitid	dbwlUkpK0xDlII16;

1.6
date	2004.11.02.20.45.19;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.32;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.49.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.53;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.53;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.56;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.09;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.16.46;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.05;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* srconv.c -- Sysroff conversion program
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written by Steve Chamberlain (sac@@cygnus.com)

   This program can be used to convert a coff object file
   into a Hitachi OM/LM (Sysroff) format.

   All debugging information is preserved */

#include "bfd.h"
#include "bucomm.h"
#include "sysroff.h"
#include "coffgrok.h"
#include "libiberty.h"
#include "getopt.h"

#include "coff/internal.h"
#include "../bfd/libcoff.h"

/*#define FOOP1 1 */

static int addrsize;
static char *toolname;
static char **rnames;

static int get_member_id (int);
static int get_ordinary_id (int);
static char *section_translate (char *);
static char *strip_suffix (char *);
static void checksum (FILE *, char *, int, int);
static void writeINT (int, char *, int *, int, FILE *);
static void writeBITS (int, char *, int *, int);
static void writeBARRAY (barray, char *, int *, int, FILE *);
static void writeCHARS (char *, char *, int *, int, FILE *);
static void wr_tr (void);
static void wr_un (struct coff_ofile *, struct coff_sfile *, int, int);
static void wr_hd (struct coff_ofile *);
static void wr_sh (struct coff_ofile *, struct coff_section *);
static void wr_ob (struct coff_ofile *, struct coff_section *);
static void wr_rl (struct coff_ofile *, struct coff_section *);
static void wr_object_body (struct coff_ofile *);
static void wr_dps_start
  (struct coff_sfile *, struct coff_section *, struct coff_scope *, int, int);
static void wr_dps_end (struct coff_section *, struct coff_scope *, int);
static int *nints (int);
static void walk_tree_type_1
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
static void walk_tree_type
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
static void walk_tree_symbol
  (struct coff_sfile *, struct coff_section *, struct coff_symbol *, int);
static void walk_tree_scope
  (struct coff_section *, struct coff_sfile *, struct coff_scope *, int, int);
static void walk_tree_sfile (struct coff_section *, struct coff_sfile *);
static void wr_program_structure (struct coff_ofile *, struct coff_sfile *);
static void wr_du (struct coff_ofile *, struct coff_sfile *, int);
static void wr_dus (struct coff_ofile *, struct coff_sfile *);
static int find_base (struct coff_sfile *, struct coff_section *);
static void wr_dln (struct coff_ofile *, struct coff_sfile *, int);
static void wr_globals (struct coff_ofile *, struct coff_sfile *, int);
static void wr_debug (struct coff_ofile *);
static void wr_cs (void);
static int wr_sc (struct coff_ofile *, struct coff_sfile *);
static void wr_er (struct coff_ofile *, struct coff_sfile *, int);
static void wr_ed (struct coff_ofile *, struct coff_sfile *, int);
static void wr_unit_info (struct coff_ofile *);
static void wr_module (struct coff_ofile *);
static int align (int);
static void prescan (struct coff_ofile *);
static void show_usage (FILE *, int);
extern int main (int, char **);

static FILE *file;
static bfd *abfd;
static int debug = 0;
static int quick = 0;
static int noprescan = 0;
static struct coff_ofile *tree;
/* Obsolete ??
   static int absolute_p;
 */

static int segmented_p;
static int code;

static int ids1[20000];
static int ids2[20000];

static int base1 = 0x18;
static int base2 = 0x2018;

static int
get_member_id (int x)
{
  if (ids2[x])
    return ids2[x];

  ids2[x] = base2++;
  return ids2[x];
}

static int
get_ordinary_id (int x)
{
  if (ids1[x])
    return ids1[x];

  ids1[x] = base1++;
  return ids1[x];
}
static char *
section_translate (char *n)
{
  if (strcmp (n, ".text") == 0)
    return "P";
  if (strcmp (n, ".data") == 0)
    return "D";
  if (strcmp (n, ".bss") == 0)
    return "B";
  return n;
}

#define DATE "940201073000";	/* Just a time on my birthday */

static
char *
strip_suffix (char *name)
{
  int i;
  char *res;

  for (i = 0; name[i] != 0 && name[i] != '.'; i++)
    ;
  res = (char *) xmalloc (i + 1);
  memcpy (res, name, i);
  res[i] = 0;
  return res;
}

/* IT LEN stuff CS */
static void
checksum (FILE *file, char *ptr, int size, int code)
{
  int j;
  int last;
  int sum = 0;
  int bytes = size / 8;

  last = !(code & 0xff00);
  if (size & 0x7)
    abort ();
  ptr[0] = code | (last ? 0x80 : 0);
  ptr[1] = bytes + 1;

  for (j = 0; j < bytes; j++)
    sum += ptr[j];

  /* Glue on a checksum too.  */
  ptr[bytes] = ~sum;
  fwrite (ptr, bytes + 1, 1, file);
}


static void
writeINT (int n, char *ptr, int *idx, int size, FILE *file)
{
  int byte = *idx / 8;

  if (size == -2)
    size = addrsize;
  else if (size == -1)
    size = 0;

  if (byte > 240)
    {
      /* Lets write out that record and do another one.  */
      checksum (file, ptr, *idx, code | 0x1000);
      *idx = 16;
      byte = *idx / 8;
    }

  switch (size)
    {
    case 0:
      break;
    case 1:
      ptr[byte] = n;
      break;
    case 2:
      ptr[byte + 0] = n >> 8;
      ptr[byte + 1] = n;
      break;
    case 4:
      ptr[byte + 0] = n >> 24;
      ptr[byte + 1] = n >> 16;
      ptr[byte + 2] = n >> 8;
      ptr[byte + 3] = n >> 0;
      break;
    default:
      abort ();
    }
  *idx += size * 8;
}

static void
writeBITS (int val, char *ptr, int *idx, int size)
{
  int byte = *idx / 8;
  int bit = *idx % 8;
  int old;

  *idx += size;

  old = ptr[byte];
  /* Turn off all about to change bits.  */
  old &= ~((~0 >> (8 - bit - size)) & ((1 << size) - 1));
  /* Turn on the bits we want.  */
  old |= (val & ((1 << size) - 1)) << (8 - bit - size);
  ptr[byte] = old;
}

static void
writeBARRAY (barray data, char *ptr, int *idx, int size ATTRIBUTE_UNUSED,
	     FILE *file)
{
  int i;

  writeINT (data.len, ptr, idx, 1, file);
  for (i = 0; i < data.len; i++)
    writeINT (data.data[i], ptr, idx, 1, file);
}

static void
writeCHARS (char *string, char *ptr, int *idx, int size, FILE *file)
{
  int i = *idx / 8;

  if (i > 240)
    {
      /* Lets write out that record and do another one.  */
      checksum (file, ptr, *idx, code | 0x1000);
      *idx = 16;
      i = *idx / 8;
    }

  if (size == 0)
    {
      /* Variable length string.  */
      size = strlen (string);
      ptr[i++] = size;
    }

  /* BUG WAITING TO HAPPEN.  */
  memcpy (ptr + i, string, size);
  i += size;
  *idx = i * 8;
}

#define SYSROFF_SWAP_OUT
#include "sysroff.c"

static char *rname_sh[] =
{
  "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"
};

static char *rname_h8300[] =
{
  "ER0", "ER1", "ER2", "ER3", "ER4", "ER5", "ER6", "ER7", "PC", "CCR"
};

static void
wr_tr (void)
{
  /* The TR block is not normal - it doesn't have any contents.  */

  static char b[] =
    {
      0xff,			/* IT */
      0x03,			/* RL */
      0xfd,			/* CS */
    };
  fwrite (b, 1, sizeof (b), file);
}

static void
wr_un (struct coff_ofile *ptr, struct coff_sfile *sfile, int first,
       int nsecs ATTRIBUTE_UNUSED)
{
  struct IT_un un;
  struct coff_symbol *s;

  un.spare1 = 0;

  if (bfd_get_file_flags (abfd) & EXEC_P)
    un.format = FORMAT_LM;
  else
    un.format = FORMAT_OM;
  un.spare1 = 0;

#if 1
  un.nsections = ptr->nsections - 1;	/*  Don't count the abs section.  */
#else
  /*NEW - only count sections with size.  */
  un.nsections = nsecs;
#endif

  un.nextdefs = 0;
  un.nextrefs = 0;
  /* Count all the undefined and defined variables with global scope.  */

  if (first)
    {
      for (s = ptr->symbol_list_head; s; s = s->next_in_ofile_list)
	{
	  if (s->visible->type == coff_vis_ext_def
	      || s->visible->type == coff_vis_common)
	    un.nextdefs++;

	  if (s->visible->type == coff_vis_ext_ref)
	    un.nextrefs++;
	}
    }
  un.tool = toolname;
  un.tcd = DATE;
  un.linker = "L_GX00";
  un.lcd = DATE;
  un.name = sfile->name;
  sysroff_swap_un_out (file, &un);
}

static void
wr_hd (struct coff_ofile *p)
{
  struct IT_hd hd;

  hd.spare1 = 0;
  if (bfd_get_file_flags (abfd) & EXEC_P)
    hd.mt = MTYPE_ABS_LM;
  else
    hd.mt = MTYPE_OMS_OR_LMS;

  hd.cd = DATE;

  hd.nu = p->nsources;		/* Always one unit */
  hd.code = 0;			/* Always ASCII */
  hd.ver = "0200";		/* Version 2.00 */

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_h8300:
      hd.au = 8;
      hd.si = 0;
      hd.spcsz = 32;
      hd.segsz = 0;
      hd.segsh = 0;
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_h8300:
	  hd.cpu = "H8300";
	  hd.afl = 2;
	  addrsize = 2;
	  toolname = "C_H8/300";
	  break;
	case bfd_mach_h8300h:
	  hd.cpu = "H8300H";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300H";
	  break;
	case bfd_mach_h8300s:
	  hd.cpu = "H8300S";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300S";
	  break;
	default:
	  abort();
	}
      rnames = rname_h8300;
      break;
    case bfd_arch_sh:
      hd.au = 8;
      hd.si = 0;
      hd.afl = 4;
      hd.spcsz = 32;
      hd.segsz = 0;
      hd.segsh = 0;
      hd.cpu = "SH";
      addrsize = 4;
      toolname = "C_SH";
      rnames = rname_sh;
      break;
    default:
      abort ();
    }

  if (! bfd_get_file_flags(abfd) & EXEC_P)
    {
      hd.ep = 0;
    }
  else
    {
      hd.ep = 1;
      hd.uan = 0;
      hd.sa = 0;
      hd.sad = 0;
      hd.address = bfd_get_start_address (abfd);
    }

  hd.os = "";
  hd.sys = "";
  hd.mn = strip_suffix (bfd_get_filename (abfd));

  sysroff_swap_hd_out (file, &hd);
}


static void
wr_sh (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *sec)
{
  struct IT_sh sh;
  sh.unit = 0;
  sh.section = sec->number;
#ifdef FOOP1
  sh.section = 0;
#endif
  sysroff_swap_sh_out (file, &sh);
}


static void
wr_ob (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *section)
{
  bfd_size_type i;
  int first = 1;
  unsigned char stuff[200];

  i = 0;
  while (i < section->bfd_section->_raw_size)
    {
      struct IT_ob ob;
      int todo = 200;		/* Copy in 200 byte lumps.  */

      ob.spare = 0;
      if (i + todo > section->bfd_section->_raw_size)
	todo = section->bfd_section->_raw_size - i;

      if (first)
	{
	  ob.saf = 1;
	  if (bfd_get_file_flags (abfd) & EXEC_P)
	    ob.address = section->address;
	  else
	    ob.address = 0;

	  first = 0;
	}
      else
	{
	  ob.saf = 0;
	}

      ob.cpf = 0;		/* Never compress.  */
      ob.data.len = todo;
      bfd_get_section_contents (abfd, section->bfd_section, stuff, i, todo);
      ob.data.data = stuff;
      sysroff_swap_ob_out (file, &ob /*, i + todo < section->size */ );
      i += todo;
    }

  /* Now fill the rest with blanks.  */
  while (i < (bfd_size_type) section->size)
    {
      struct IT_ob ob;
      int todo = 200;		/* Copy in 200 byte lumps.  */

      ob.spare = 0;
      if (i + todo > (bfd_size_type) section->size)
	todo = section->size - i;
      ob.saf = 0;

      ob.cpf = 0;		/* Never compress.  */
      ob.data.len = todo;
      memset (stuff, 0, todo);
      ob.data.data = stuff;
      sysroff_swap_ob_out (file, &ob);
      i += todo;
    }
  /* Now fill the rest with blanks.  */
}

static void
wr_rl (struct coff_ofile *ptr ATTRIBUTE_UNUSED, struct coff_section *sec)
{
  int nr = sec->nrelocs;
  int i;

  for (i = 0; i < nr; i++)
    {
      struct coff_reloc *r = sec->relocs + i;
      struct coff_symbol *ref;
      struct IT_rl rl;

      rl.apol = 0;
      rl.boundary = 0;
      rl.segment = 1;
      rl.sign = 0;
      rl.check = 0;
      rl.addr = r->offset;
      rl.bitloc = 0;
      rl.flen = 32;		/* SH Specific.  */

      /* What sort of reloc ? Look in the section to find out.  */
      ref = r->symbol;
      if (ref->visible->type == coff_vis_ext_ref)
	{
	  rl.bcount = 4;	/* Always 4 for us.  */
	  rl.op = OP_EXT_REF;
	  rl.symn = ref->er_number;
	}
      else if (ref->visible->type == coff_vis_common)
	{
	  rl.bcount = 11;	/* Always 11 for us.  */
	  rl.op = OP_SEC_REF;
	  rl.secn = ref->where->section->number;
	  rl.copcode_is_3 = 3;
	  rl.alength_is_4 = 4;
	  rl.addend = ref->where->offset - ref->where->section->address;
	  rl.aopcode_is_0x20 = 0x20;
	}
      else
	{
	  rl.bcount = 11;	/* Always 11 for us.  */
	  rl.op = OP_SEC_REF;
	  rl.secn = ref->where->section->number;
	  rl.copcode_is_3 = 3;
	  rl.alength_is_4 = 4;
	  rl.addend = -ref->where->section->address;
	  rl.aopcode_is_0x20 = 0x20;
	}

      rl.end = 0xff;

      if (   rl.op == OP_SEC_REF
	  || rl.op == OP_EXT_REF)
	sysroff_swap_rl_out (file, &rl);
    }
}

static void
wr_object_body (struct coff_ofile *p)
{
  int i;

  for (i = 1; i < p->nsections; i++)
    {
      wr_sh (p, p->sections + i);
      wr_ob (p, p->sections + i);
      wr_rl (p, p->sections + i);
    }
}

static void
wr_dps_start (struct coff_sfile *sfile,
	      struct coff_section *section ATTRIBUTE_UNUSED,
	      struct coff_scope *scope, int type, int nest)
{
  struct IT_dps dps;

  dps.end = 0;
  dps.opt = 0;
  dps.type = type;

  if (scope->sec)
    {
      dps.san = scope->sec->number;
      dps.address = scope->offset - find_base (sfile, scope->sec);
      dps.block_size = scope->size;

      if (debug)
	{
	  printf ("DPS %s %d %x\n",
		  sfile->name,
		  nest,
		  dps.address);
	}
    }
  else
    {
      dps.san = 0;
      dps.address = 0;
      dps.block_size = 0;
    }

  dps.nesting = nest;
  dps.neg = 0x1001;
  sysroff_swap_dps_out (file, &dps);
}

static void
wr_dps_end (struct coff_section *section ATTRIBUTE_UNUSED,
	    struct coff_scope *scope ATTRIBUTE_UNUSED, int type)
{
  struct IT_dps dps;

  dps.end = 1;
  dps.type = type;
  sysroff_swap_dps_out (file, &dps);
}

static int *
nints (int x)
{
  return (int *) (xcalloc (sizeof (int), x));
}

static void
walk_tree_type_1 (struct coff_sfile *sfile, struct coff_symbol *symbol,
		  struct coff_type *type, int nest)
{
  switch (type->type)
    {
    case coff_secdef_type:
    case coff_basic_type:
      {
	struct IT_dbt dbt;

	switch (type->u.basic)
	  {
	  case T_NULL:
	  case T_VOID:
	    dbt.btype = BTYPE_VOID;
	    dbt.sign = BTYPE_UNSPEC;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_CHAR:
	    dbt.btype = BTYPE_CHAR;
	    dbt.sign = BTYPE_UNSPEC;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_SHORT:
	  case T_INT:
	  case T_LONG:
	    dbt.btype = BTYPE_INT;
	    dbt.sign = SIGN_SIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_FLOAT:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_SINGLE;
	    break;

	  case T_DOUBLE:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_DOUBLE;
	    break;

	  case T_LNGDBL:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_EXTENDED;
	    break;

	  case T_UCHAR:
	    dbt.btype = BTYPE_CHAR;
	    dbt.sign = SIGN_UNSIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_USHORT:
	  case T_UINT:
	  case T_ULONG:
	    dbt.btype = BTYPE_INT;
	    dbt.sign = SIGN_UNSIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;
	  }

	dbt.bitsize = type->size;
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
	break;
      }

    case coff_pointer_type:
      {
	struct IT_dpt dpt;

	walk_tree_type_1 (sfile, symbol, type->u.pointer.points_to, nest + 1);
	dpt.neg = 0x1001;
	sysroff_swap_dpt_out (file, &dpt);
	break;
      }

    case coff_function_type:
      {
	struct IT_dfp dfp;
	struct coff_symbol *param;

	dfp.end = 0;
	dfp.spare = 0;
	dfp.nparams = type->u.function.parameters->nvars;
	dfp.neg = 0x1001;

	walk_tree_type_1 (sfile, symbol, type->u.function.function_returns, nest + 1);

	sysroff_swap_dfp_out (file, &dfp);

	for (param = type->u.function.parameters->vars_head;
	     param;
	     param = param->next)
	  walk_tree_symbol (sfile, 0, param, nest);

	dfp.end = 1;
	sysroff_swap_dfp_out (file, &dfp);
	break;
      }

    case coff_structdef_type:
      {
	struct IT_dbt dbt;
	struct IT_dds dds;
	struct coff_symbol *member;

	dds.spare = 0;
	dbt.btype = BTYPE_STRUCT;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.astructdef.idx);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
	dds.end = 0;
	dds.neg = 0x1001;
	sysroff_swap_dds_out (file, &dds);

	for (member = type->u.astructdef.elements->vars_head;
	     member;
	     member = member->next)
	  walk_tree_symbol (sfile, 0, member, nest + 1);

	dds.end = 1;
	sysroff_swap_dds_out (file, &dds);

      }
      break;

    case coff_structref_type:
      {
	struct IT_dbt dbt;

	dbt.btype = BTYPE_TAG;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;

	if (type->u.astructref.ref)
	  dbt.sid = get_member_id (type->u.astructref.ref->number);
	else
	  dbt.sid = 0;

	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
      }
      break;

    case coff_array_type:
      {
	struct IT_dar dar;
	int j;
	int dims = 1;		/* Only output one dimension at a time.  */

	dar.dims = dims;
	dar.variable = nints (dims);
	dar.subtype = nints (dims);
	dar.spare = nints (dims);
	dar.max_variable = nints (dims);
	dar.maxspare = nints (dims);
	dar.max = nints (dims);
	dar.min_variable = nints (dims);
	dar.min = nints (dims);
	dar.minspare = nints (dims);
	dar.neg = 0x1001;
	dar.length = type->size / type->u.array.dim;

	for (j = 0; j < dims; j++)
	  {
	    dar.variable[j] = VARIABLE_FIXED;
	    dar.subtype[j] = SUB_INTEGER;
	    dar.spare[j] = 0;
	    dar.max_variable[j] = 0;
	    dar.max[j] = type->u.array.dim;
	    dar.min_variable[j] = 0;
	    dar.min[j] = 1;	/* Why isn't this 0 ? */
	  }
	walk_tree_type_1 (sfile, symbol, type->u.array.array_of, nest + 1);
	sysroff_swap_dar_out (file, &dar);
      }
      break;

    case coff_enumdef_type:
      {
	struct IT_dbt dbt;
	struct IT_den den;
	struct coff_symbol *member;

	dbt.btype = BTYPE_ENUM;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.aenumdef.idx);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);

	den.end = 0;
	den.neg = 0x1001;
	den.spare = 0;
	sysroff_swap_den_out (file, &den);

	for (member = type->u.aenumdef.elements->vars_head;
	     member;
	     member = member->next)
	  walk_tree_symbol (sfile, 0, member, nest + 1);

	den.end = 1;
	sysroff_swap_den_out (file, &den);
      }
      break;

    case coff_enumref_type:
      {
	struct IT_dbt dbt;

	dbt.btype = BTYPE_TAG;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.aenumref.ref->number);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
      }
      break;

    default:
      abort ();
    }
}

/* Obsolete ?
   static void
   dty_start ()
   {
   struct IT_dty dty;
   dty.end = 0;
   dty.neg = 0x1001;
   dty.spare = 0;
   sysroff_swap_dty_out (file, &dty);
   }

   static void
   dty_stop ()
   {
   struct IT_dty dty;
   dty.end = 0;
   dty.neg = 0x1001;
   dty.end = 1;
   sysroff_swap_dty_out (file, &dty);
   }


   static void
   dump_tree_structure (sfile, symbol, type, nest)
   struct coff_sfile *sfile;
   struct coff_symbol *symbol;
   struct coff_type *type;
   int nest;
   {
   if (symbol->type->type == coff_function_type)
   {


   }

   }
 */

static void
walk_tree_type (struct coff_sfile *sfile, struct coff_symbol *symbol,
		struct coff_type *type, int nest)
{
  if (symbol->type->type == coff_function_type)
    {
      struct IT_dty dty;

      dty.end = 0;
      dty.neg = 0x1001;

      sysroff_swap_dty_out (file, &dty);
      walk_tree_type_1 (sfile, symbol, type, nest);
      dty.end = 1;
      sysroff_swap_dty_out (file, &dty);

      wr_dps_start (sfile,
		    symbol->where->section,
		    symbol->type->u.function.code,
		    BLOCK_TYPE_FUNCTION, nest);
      wr_dps_start (sfile, symbol->where->section,
		    symbol->type->u.function.code,
		    BLOCK_TYPE_BLOCK, nest);
      walk_tree_scope (symbol->where->section,
		       sfile,
		       symbol->type->u.function.code,
		       nest + 1, BLOCK_TYPE_BLOCK);

      wr_dps_end (symbol->where->section,
		  symbol->type->u.function.code,
		  BLOCK_TYPE_BLOCK);
      wr_dps_end (symbol->where->section,
		  symbol->type->u.function.code, BLOCK_TYPE_FUNCTION);
    }
  else
    {
      struct IT_dty dty;

      dty.end = 0;
      dty.neg = 0x1001;
      sysroff_swap_dty_out (file, &dty);
      walk_tree_type_1 (sfile, symbol, type, nest);
      dty.end = 1;
      sysroff_swap_dty_out (file, &dty);
    }
}

static void
walk_tree_symbol (struct coff_sfile *sfile, struct coff_section *section ATTRIBUTE_UNUSED, struct coff_symbol *symbol, int nest)
{
  struct IT_dsy dsy;

  memset (&dsy, 0, sizeof(dsy));
  dsy.nesting = nest;

  switch (symbol->type->type)
    {
    case coff_function_type:
      dsy.type = STYPE_FUNC;
      dsy.assign = 1;
      break;

    case coff_structref_type:
    case coff_pointer_type:
    case coff_array_type:
    case coff_basic_type:
    case coff_enumref_type:
      dsy.type = STYPE_VAR;
      dsy.assign = 1;
      break;

    case coff_enumdef_type:
      dsy.type = STYPE_TAG;
      dsy.assign = 0;
      dsy.magic = 2;
      break;

    case coff_structdef_type:
      dsy.type = STYPE_TAG;
      dsy.assign = 0;
      dsy.magic = symbol->type->u.astructdef.isstruct ? 0 : 1;
      break;

    case coff_secdef_type:
      return;

    default:
      abort ();
    }

  if (symbol->where->where == coff_where_member_of_struct)
    {
      dsy.assign = 0;
      dsy.type = STYPE_MEMBER;
    }

  if (symbol->where->where == coff_where_member_of_enum)
    {
      dsy.type = STYPE_ENUM;
      dsy.assign = 0;
      dsy.evallen = 4;
      dsy.evalue = symbol->where->offset;
    }

  if (symbol->type->type == coff_structdef_type
      || symbol->where->where == coff_where_entag
      || symbol->where->where == coff_where_strtag)
    {
      dsy.snumber = get_member_id (symbol->number);
    }
  else
    {
      dsy.snumber = get_ordinary_id (symbol->number);
    }

  dsy.sname = symbol->name[0] == '_' ? symbol->name + 1 : symbol->name;

  switch (symbol->visible->type)
    {
    case coff_vis_common:
    case coff_vis_ext_def:
      dsy.ainfo = AINFO_STATIC_EXT_DEF;
      break;

    case coff_vis_ext_ref:
      dsy.ainfo = AINFO_STATIC_EXT_REF;
      break;

    case coff_vis_int_def:
      dsy.ainfo = AINFO_STATIC_INT;
      break;

    case coff_vis_auto:
    case coff_vis_autoparam:
      dsy.ainfo = AINFO_AUTO;
      break;

    case coff_vis_register:
    case coff_vis_regparam:
      dsy.ainfo = AINFO_REG;
      break;
      break;

    case coff_vis_tag:
    case coff_vis_member_of_struct:
    case coff_vis_member_of_enum:
      break;

    default:
      abort ();
    }

  dsy.dlength = symbol->type->size;

  switch (symbol->where->where)
    {
    case coff_where_memory:

      dsy.section = symbol->where->section->number;
#ifdef FOOP
      dsy.section = 0;
#endif
      break;

    case coff_where_member_of_struct:
    case coff_where_member_of_enum:
    case coff_where_stack:
    case coff_where_register:
    case coff_where_unknown:
    case coff_where_strtag:
    case coff_where_entag:
    case coff_where_typedef:
      break;

    default:
      abort ();
    }

  switch (symbol->where->where)
    {
    case coff_where_memory:
      dsy.address = symbol->where->offset - find_base (sfile, symbol->where->section);
      break;

    case coff_where_stack:
      dsy.address = symbol->where->offset;
      break;

    case coff_where_member_of_struct:
      if (symbol->where->bitsize)
	{
	  int bits = (symbol->where->offset * 8 + symbol->where->bitoffset);
	  dsy.bitunit = 1;
	  dsy.field_len = symbol->where->bitsize;
	  dsy.field_off = (bits / 32) * 4;
	  dsy.field_bitoff = bits % 32;
	}
      else
	{
	  dsy.bitunit = 0;

	  dsy.field_len = symbol->type->size;
	  dsy.field_off = symbol->where->offset;
	}
      break;

    case coff_where_member_of_enum:
      /*      dsy.bitunit = 0;
         dsy.field_len  = symbol->type->size;
         dsy.field_off = symbol->where->offset; */
      break;

    case coff_where_register:
    case coff_where_unknown:
    case coff_where_strtag:
    case coff_where_entag:
    case coff_where_typedef:
      break;

    default:
      abort ();
    }

  if (symbol->where->where == coff_where_register)
    dsy.reg = rnames[symbol->where->offset];

  switch (symbol->visible->type)
    {
    case coff_vis_common:
      /* We do this 'cause common C symbols are treated as extdefs.  */
    case coff_vis_ext_def:
    case coff_vis_ext_ref:
      dsy.ename = symbol->name;
      break;

    case coff_vis_regparam:
    case coff_vis_autoparam:
      dsy.type = STYPE_PARAMETER;
      break;

    case coff_vis_int_def:
    case coff_vis_auto:
    case coff_vis_register:
    case coff_vis_tag:
    case coff_vis_member_of_struct:
    case coff_vis_member_of_enum:
      break;

    default:
      abort ();
    }

  dsy.sfn = 0;
  dsy.sln = 2;
  dsy.neg = 0x1001;

  sysroff_swap_dsy_out (file, &dsy);

  walk_tree_type (sfile, symbol, symbol->type, nest);
}

static void
walk_tree_scope (struct coff_section *section, struct coff_sfile *sfile, struct coff_scope *scope, int nest, int type)
{
  struct coff_symbol *vars;
  struct coff_scope *child;

  if (scope->vars_head
      || (scope->list_head && scope->list_head->vars_head))
    {
      wr_dps_start (sfile, section, scope, type, nest);

      if (nest == 0)
	wr_globals (tree, sfile, nest + 1);

      for (vars = scope->vars_head; vars; vars = vars->next)
	walk_tree_symbol (sfile, section, vars, nest);

      for (child = scope->list_head; child; child = child->next)
	walk_tree_scope (section, sfile, child, nest + 1, BLOCK_TYPE_BLOCK);

      wr_dps_end (section, scope, type);
    }
}

static void
walk_tree_sfile (struct coff_section *section, struct coff_sfile *sfile)
{
  walk_tree_scope (section, sfile, sfile->scope, 0, BLOCK_TYPE_COMPUNIT);
}

static void
wr_program_structure (struct coff_ofile *p, struct coff_sfile *sfile)
{
  walk_tree_sfile (p->sections + 4, sfile);
}

static void
wr_du (struct coff_ofile *p, struct coff_sfile *sfile, int n)
{
  struct IT_du du;
  int lim;
#if 0
  struct coff_symbol *symbol;
  static int incit = 0x500000;
  int used = 0;
#endif
  int i;
  int j;
  unsigned int *lowest = (unsigned *) nints (p->nsections);
  unsigned int *highest = (unsigned *) nints (p->nsections);

  du.format = bfd_get_file_flags (abfd) & EXEC_P ? 0 : 1;
  du.optimized = 0;
  du.stackfrmt = 0;
  du.spare = 0;
  du.unit = n;
  du.sections = p->nsections - 1;
  du.san = (int *) xcalloc (sizeof (int), du.sections);
  du.address = nints (du.sections);
  du.length = nints (du.sections);

  for (i = 0; i < du.sections; i++)
    {
      lowest[i] = ~0;
      highest[i] = 0;
    }

  /* Look through all the symbols and try and work out the extents in this
     source file.  */
#if 0
  for (symbol = sfile->scope->vars_head;
       symbol;
       symbol = symbol->next)
    {
      if (symbol->type->type == coff_secdef_type)
	{
	  unsigned int low = symbol->where->offset;
	  unsigned int high = symbol->where->offset + symbol->type->size - 1;
	  struct coff_section *section = symbol->where->section;

	  int sn = section->number;
	  if (low < lowest[sn])
	    lowest[sn] = low;
	  if (high > highest[sn])
	    highest[sn] = high;
	}
    }

  for (i = 0; i < du.sections; i++)
    {
      if (highest[i] == 0)
	lowest[i] = highest[i] = incit;

      du.san[used] = i;
      du.length[used] = highest[i] - lowest[i];
      du.address[used] = bfd_get_file_flags (abfd) & EXEC_P ? lowest[i] : 0;

      if (debug)
	{
	  printf (" section %6s 0x%08x..0x%08x\n",
		  p->sections[i + 1].name,
		  lowest[i],
		  highest[i]);
	}
      used++;
    }
#endif

  lim = du.sections;
  for (j = 0; j < lim; j++)
    {
      int src = j;
      int dst = j;

      du.san[dst] = dst;

      if (sfile->section[src].init)
	{
	  du.length[dst]
	    = sfile->section[src].high - sfile->section[src].low + 1;
	  du.address[dst]
	    = sfile->section[src].low;
	}
      else
	{
	  du.length[dst] = 0;
	  du.address[dst] = 0;
	}

      if (debug)
	{
	  if (sfile->section[src].parent)
	    {
	      printf (" section %6s 0x%08x..0x%08x\n",
		      sfile->section[src].parent->name,
		      du.address[dst],
		      du.address[dst] + du.length[dst] - 1);
	    }
	}

      du.sections = dst + 1;
    }

  du.tool = "c_gcc";
  du.date = DATE;

  sysroff_swap_du_out (file, &du);
}

static void
wr_dus (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile)
{
  struct IT_dus dus;

  dus.efn = 0x1001;
  dus.ns = 1;			/* p->nsources; sac 14 jul 94 */
  dus.drb = nints (dus.ns);
  dus.fname = (char **) xcalloc (sizeof (char *), dus.ns);
  dus.spare = nints (dus.ns);
  dus.ndir = 0;
  /* Find the filenames.  */
#if 0
  i = 0;

  for (sfile = p->source_head;
       sfile;
       sfile = sfile->next)
    {
      dus.drb[i] = 0;
      dus.spare[i] = 0;
      dus.fname[i] = sfile->name;
      i++;
    }
#else
  dus.drb[0] = 0;
  dus.fname[0] = sfile->name;
#endif

  sysroff_swap_dus_out (file, &dus);

}

/* Find the offset of the .text section for this sfile in the
   .text section for the output file.  */

static int
find_base (struct coff_sfile *sfile, struct coff_section *section)
{
  return sfile->section[section->number].low;
}

static void
wr_dln (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile,
	int n ATTRIBUTE_UNUSED)
{
#if 0
  if (n == 0)
    {
      /* Count up all the linenumbers */
      struct coff_symbol *sy;
      int lc = 0;
      struct IT_dln dln;

      int idx;

      for (sy = p->symbol_list_head;
	   sy;
	   sy = sy->next_in_ofile_list)
	{
	  struct coff_type *t = sy->type;
	  if (t->type == coff_function_type)
	    {
	      struct coff_line *l = t->u.function.lines;
	      lc += l->nlines;
	    }
	}

      dln.sfn = nints (lc);
      dln.sln = nints (lc);
      dln.lln = nints (lc);
      dln.section = nints (lc);

      dln.from_address = nints (lc);
      dln.to_address = nints (lc);


      dln.neg = 0x1001;

      dln.nln = lc;

      /* Run through once more and fill up the structure */
      idx = 0;
      for (sy = p->symbol_list_head;
	   sy;
	   sy = sy->next_in_ofile_list)
	{
	  if (sy->type->type == coff_function_type)
	    {
	      int i;
	      struct coff_line *l = sy->type->u.function.lines;
	      for (i = 0; i < l->nlines; i++)
		{
		  dln.section[idx] = sy->where->section->number;
		  dln.sfn[idx] = n;
		  dln.sln[idx] = l->lines[i];
		  dln.from_address[idx] = l->addresses[i];
		  if (idx)
		    dln.to_address[idx - 1] = dln.from_address[idx];
		  idx++;
		}
	    }
	  n++;
	}
      sysroff_swap_dln_out (file, &dln);
    }

#endif
#if 1
  /* Count up all the linenumbers */

  struct coff_symbol *sy;
  int lc = 0;
  struct IT_dln dln;

  int idx;

  for (sy = sfile->scope->vars_head;
       sy;
       sy = sy->next)
    {
      struct coff_type *t = sy->type;
      if (t->type == coff_function_type)
	{
	  struct coff_line *l = t->u.function.lines;
	  if (l)
	    lc += l->nlines;
	}
    }

  dln.sfn = nints (lc);
  dln.sln = nints (lc);
  dln.cc = nints (lc);
  dln.section = nints (lc);

  dln.from_address = nints (lc);
  dln.to_address = nints (lc);


  dln.neg = 0x1001;

  dln.nln = lc;

  /* Run through once more and fill up the structure */
  idx = 0;
  for (sy = sfile->scope->vars_head;
       sy;
       sy = sy->next)
    {
      if (sy->type->type == coff_function_type)
	{
	  int i;
	  struct coff_line *l = sy->type->u.function.lines;
	  if (l)
	    {
	      int base = find_base (sfile, sy->where->section);
	      for (i = 0; i < l->nlines; i++)
		{
		  dln.section[idx] = sy->where->section->number;
		  dln.sfn[idx] = 0;
		  dln.sln[idx] = l->lines[i];
		  dln.from_address[idx] =
		    l->addresses[i] + sy->where->section->address - base;
		  dln.cc[idx] = 0;
		  if (idx)
		    dln.to_address[idx - 1] = dln.from_address[idx];
		  idx++;

		}
	      dln.to_address[idx - 1] = dln.from_address[idx - 1] + 2;
	    }
	}
    }
  if (lc)
    sysroff_swap_dln_out (file, &dln);
#endif
}

/* Write the global symbols out to the debug info.  */

static void
wr_globals (struct coff_ofile *p, struct coff_sfile *sfile,
	    int n ATTRIBUTE_UNUSED)
{
  struct coff_symbol *sy;

  for (sy = p->symbol_list_head;
       sy;
       sy = sy->next_in_ofile_list)
    {
      if (sy->visible->type == coff_vis_ext_def
	  || sy->visible->type == coff_vis_ext_ref)
	{
	  /* Only write out symbols if they belong to
	     the current source file.  */
	  if (sy->sfile == sfile)
	    walk_tree_symbol (sfile, 0, sy, 0);
	}
    }
}

static void
wr_debug (struct coff_ofile *p)
{
  struct coff_sfile *sfile;
  int n = 0;

  for (sfile = p->source_head;
       sfile;
       sfile = sfile->next)
    {
      if (debug)
	printf ("%s\n", sfile->name);

      wr_du (p, sfile, n);
      wr_dus (p, sfile);
      wr_program_structure (p, sfile);
      wr_dln (p, sfile, n);
      n++;
    }
}

static void
wr_cs (void)
{
  /* It seems that the CS struct is not normal - the size is wrong
     heres one I prepared earlier.  */
  static char b[] =
    {
    0x80,			/* IT */
    0x21,			/* RL */
    0x00,			/* number of chars in variable length part */
    0x80,			/* hd */
    0x00,			/* hs */
    0x80,			/* un */
    0x00,			/* us */
    0x80,			/* sc */
    0x00,			/* ss */
    0x80,			/* er */
    0x80,			/* ed */
    0x80,			/* sh */
    0x80,			/* ob */
    0x80,			/* rl */
    0x80,			/* du */
    0x80,			/* dps */
    0x80,			/* dsy */
    0x80,			/* dty */
    0x80,			/* dln */
    0x80,			/* dso */
    0x80,			/* dus */
    0x00,			/* dss */
    0x80,			/* dbt */
    0x00,			/* dpp */
    0x80,			/* dfp */
    0x80,			/* den */
    0x80,			/* dds */
    0x80,			/* dar */
    0x80,			/* dpt */
    0x00,			/* dul */
    0x00,			/* dse */
    0x00,			/* dot */
    0xDE			/* CS */
  };
  fwrite (b, 1, sizeof (b), file);
}

/* Write out the SC records for a unit.  Create an SC
   for all the sections which appear in the output file, even
   if there isn't an equivalent one on the input.  */

static int
wr_sc (struct coff_ofile *ptr, struct coff_sfile *sfile)
{
  int i;
  int scount = 0;
  /* First work out the total number of sections.  */
  int total_sec = ptr->nsections;
  struct myinfo
    {
      struct coff_section *sec;
      struct coff_symbol *symbol;
    };
  struct coff_symbol *symbol;
  struct myinfo *info
    = (struct myinfo *) calloc (total_sec, sizeof (struct myinfo));


  for (i = 0; i < total_sec; i++)
    {
      info[i].sec = ptr->sections + i;
      info[i].symbol = 0;
    }

  for (symbol = sfile->scope->vars_head;
       symbol;
       symbol = symbol->next)
    {

      if (symbol->type->type == coff_secdef_type)
	{
	  for (i = 0; i < total_sec; i++)
	    {
	      if (symbol->where->section == info[i].sec)
		{
		  info[i].symbol = symbol;
		  break;
		}
	    }
	}
    }

  /* Now output all the section info, and fake up some stuff for sections
     we don't have.  */
  for (i = 1; i < total_sec; i++)
    {
      struct IT_sc sc;
      char *name;

      symbol = info[i].symbol;
      sc.spare = 0;
      sc.spare1 = 0;

      if (!symbol)
	{
	  /* Don't have a symbol set aside for this section, which means
	     that nothing in this file does anything for the section.  */
	  sc.format = !(bfd_get_file_flags (abfd) & EXEC_P);
	  sc.addr = 0;
	  sc.length = 0;
	  name = info[i].sec->name;
	}
      else
	{
	  if (bfd_get_file_flags (abfd) & EXEC_P)
	    {
	      sc.format = 0;
	      sc.addr = symbol->where->offset;
	    }
	  else
	    {
	      sc.format = 1;
	      sc.addr = 0;
	    }
	  sc.length = symbol->type->size;
	  name = symbol->name;
	}

      sc.align = 4;
      sc.concat = CONCAT_SIMPLE;
      sc.read = 3;
      sc.write = 3;
      sc.exec = 3;
      sc.init = 3;
      sc.mode = 3;
      sc.spare = 0;
      sc.segadd = 0;
      sc.spare1 = 0;		/* If not zero, then it doesn't work.  */
      sc.name = section_translate (name);

      if (strlen (sc.name) == 1)
	{
	  switch (sc.name[0])
	    {
	    case 'D':
	    case 'B':
	      sc.contents = CONTENTS_DATA;
	      break;

	    default:
	      sc.contents = CONTENTS_CODE;
	    }
	}
      else
	{
	  sc.contents = CONTENTS_CODE;
	}
#if 0
      /* NEW */
      if (sc.length)
	{
#endif
	  sysroff_swap_sc_out (file, &sc);
	  scount++;
#if 0
	}
#endif
    }
  return scount;
}

/* Write out the ER records for a unit.  */

static void
wr_er (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
{
  int idx = 0;
  struct coff_symbol *sym;

  if (first)
    {
      for (sym = ptr->symbol_list_head; sym; sym = sym->next_in_ofile_list)
	{
	  if (sym->visible->type == coff_vis_ext_ref)
	    {
	      struct IT_er er;

	      er.spare = 0;
	      er.type = ER_NOTSPEC;
	      er.name = sym->name;
	      sysroff_swap_er_out (file, &er);
	      sym->er_number = idx++;
	    }
	}
    }
}

/* Write out the ED records for a unit.  */

static void
wr_ed (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
{
  struct coff_symbol *s;

  if (first)
    {
      for (s = ptr->symbol_list_head; s; s = s->next_in_ofile_list)
	{
	  if (s->visible->type == coff_vis_ext_def
	      || s->visible->type == coff_vis_common)
	    {
	      struct IT_ed ed;

	      ed.section = s->where->section->number;
	      ed.spare = 0;

	      if (s->where->section->data)
		{
		  ed.type = ED_TYPE_DATA;
		}
	      else if (s->where->section->code & SEC_CODE)
		{
		  ed.type = ED_TYPE_ENTRY;
		}
	      else
		{
		  ed.type = ED_TYPE_NOTSPEC;
		  ed.type = ED_TYPE_DATA;
		}

	      ed.address = s->where->offset - s->where->section->address;
	      ed.name = s->name;
	      sysroff_swap_ed_out (file, &ed);
	    }
	}
    }
}

static void
wr_unit_info (struct coff_ofile *ptr)
{
  struct coff_sfile *sfile;
  int first = 1;

  for (sfile = ptr->source_head;
       sfile;
       sfile = sfile->next)
    {
      long p1;
      long p2;
      int nsecs;

      p1 = ftell (file);
      wr_un (ptr, sfile, first, 0);
      nsecs = wr_sc (ptr, sfile);
      p2 = ftell (file);
      fseek (file, p1, SEEK_SET);
      wr_un (ptr, sfile, first, nsecs);
      fseek (file, p2, SEEK_SET);
      wr_er (ptr, sfile, first);
      wr_ed (ptr, sfile, first);
      first = 0;
    }
}

static void
wr_module (struct coff_ofile *p)
{
  wr_cs ();
  wr_hd (p);
  wr_unit_info (p);
  wr_object_body (p);
  wr_debug (p);
  wr_tr ();
}

static int
align (int x)
{
  return (x + 3) & ~3;
}

/* Find all the common variables and turn them into
   ordinary defs - dunno why, but thats what hitachi does with 'em.  */

static void
prescan (struct coff_ofile *tree)
{
  struct coff_symbol *s;
  struct coff_section *common_section;

  /* Find the common section - always section 3.  */
  common_section = tree->sections + 3;

  for (s = tree->symbol_list_head;
       s;
       s = s->next_in_ofile_list)
    {
      if (s->visible->type == coff_vis_common)
	{
	  struct coff_where *w = s->where;
	  /*      s->visible->type = coff_vis_ext_def; leave it as common */
	  common_section->size = align (common_section->size);
	  w->offset = common_section->size + common_section->address;
	  w->section = common_section;
	  common_section->size += s->type->size;
	  common_section->size = align (common_section->size);
	}
    }
}

char *program_name;

static void
show_usage (FILE *file, int status)
{
  fprintf (file, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (file, _("Convert a COFF object file into a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -q --quick       (Obsolete - ignoerd)\n\
  -n --noprescan   Do not perform a scan to convert commons into defs\n\
  -d --debug       Display information about what is being done\n\
  -h --help        Display this information\n\
  -v --version     Print the program's version number\n"));

  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

int
main (int ac, char **av)
{
  int opt;
  static struct option long_options[] =
  {
    {"debug", no_argument, 0, 'd'},
    {"quick", no_argument, 0, 'q'},
    {"noprescan", no_argument, 0, 'n'},
    {"help", no_argument, 0, 'h'},
    {"version", no_argument, 0, 'V'},
    {NULL, no_argument, 0, 0}
  };
  char **matching;
  char *input_file;
  char *output_file;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = av[0];
  xmalloc_set_program_name (program_name);

  expandargv (&ac, &av);

  while ((opt = getopt_long (ac, av, "dHhVvqn", long_options,
			     (int *) NULL))
	 != EOF)
    {
      switch (opt)
	{
	case 'q':
	  quick = 1;
	  break;
	case 'n':
	  noprescan = 1;
	  break;
	case 'd':
	  debug = 1;
	  break;
	case 'H':
	case 'h':
	  show_usage (stdout, 0);
	  /*NOTREACHED */
	case 'v':
	case 'V':
	  print_version ("srconv");
	  exit (0);
	  /*NOTREACHED */
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  /*NOTREACHED */
	}
    }

  /* The input and output files may be named on the command line.  */
  output_file = NULL;
  if (optind < ac)
    {
      input_file = av[optind];
      ++optind;
      if (optind < ac)
	{
	  output_file = av[optind];
	  ++optind;
	  if (optind < ac)
	    show_usage (stderr, 1);
	  if (strcmp (input_file, output_file) == 0)
	    {
	      fatal (_("input and output files must be different"));
	    }
	}
    }
  else
    input_file = 0;

  if (!input_file)
    {
      fatal (_("no input file specified"));
    }

  if (!output_file)
    {
      /* Take a .o off the input file and stick on a .obj.  If
         it doesn't end in .o, then stick a .obj on anyway */

      int len = strlen (input_file);

      output_file = xmalloc (len + 5);
      strcpy (output_file, input_file);

      if (len > 3
	  && output_file[len - 2] == '.'
	  && output_file[len - 1] == 'o')
	{
	  output_file[len] = 'b';
	  output_file[len + 1] = 'j';
	  output_file[len + 2] = 0;
	}
      else
	{
	  strcat (output_file, ".obj");
	}
    }

  abfd = bfd_openr (input_file, 0);

  if (!abfd)
    bfd_fatal (input_file);

  if (!bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (input_file);

      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      exit (1);
    }

  file = fopen (output_file, FOPEN_WB);

  if (!file)
    fatal (_("unable to open output file %s"), output_file);

  if (debug)
    printf ("ids %d %d\n", base1, base2);

  tree = coff_grok (abfd);

  if (!noprescan)
    prescan (tree);

  wr_module (tree);
  return 0;
}
@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1899 2
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
d45 16
a60 16
static int get_member_id PARAMS ((int));
static int get_ordinary_id PARAMS ((int));
static char *section_translate PARAMS ((char *));
static char *strip_suffix PARAMS ((char *));
static void checksum PARAMS ((FILE *, char *, int, int));
static void writeINT PARAMS ((int, char *, int *, int, FILE *));
static void writeBITS PARAMS ((int, char *, int *, int));
static void writeBARRAY PARAMS ((barray, char *, int *, int, FILE *));
static void writeCHARS PARAMS ((char *, char *, int *, int, FILE *));
static void wr_tr PARAMS ((void));
static void wr_un PARAMS ((struct coff_ofile *, struct coff_sfile *, int, int));
static void wr_hd PARAMS ((struct coff_ofile *));
static void wr_sh PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_ob PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_rl PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_object_body PARAMS ((struct coff_ofile *));
d62 3
a64 5
  PARAMS ((struct coff_sfile *, struct coff_section *, struct coff_scope *,
	   int, int));
static void wr_dps_end
  PARAMS ((struct coff_section *, struct coff_scope *, int));
static int *nints PARAMS ((int));
d66 1
a66 2
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
d68 1
a68 2
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
d70 1
a70 2
  PARAMS ((struct coff_sfile *, struct coff_section *,
	   struct coff_symbol *, int));
d72 19
a90 23
  PARAMS ((struct coff_section *, struct coff_sfile *, struct coff_scope *,
	   int, int));
static void walk_tree_sfile
  PARAMS ((struct coff_section *, struct coff_sfile *));
static void wr_program_structure
  PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_du PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_dus PARAMS ((struct coff_ofile *, struct coff_sfile *));
static int find_base PARAMS ((struct coff_sfile *, struct coff_section *));
static void wr_dln PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_globals
  PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_debug PARAMS ((struct coff_ofile *));
static void wr_cs PARAMS ((void));
static int wr_sc PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_er PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_ed PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_unit_info PARAMS ((struct coff_ofile *));
static void wr_module PARAMS ((struct coff_ofile *));
static int align PARAMS ((int));
static void prescan PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));
d112 1
a112 2
get_member_id (x)
     int x;
d122 1
a122 2
get_ordinary_id (x)
     int x;
d131 1
a131 2
section_translate (n)
     char *n;
d146 1
a146 2
strip_suffix (name)
     char *name;
d161 1
a161 5
checksum (file, ptr, size, code)
     FILE *file;
     char *ptr;
     int size;
     int code;
d184 1
a184 6
writeINT (n, ptr, idx, size, file)
     int n;
     char *ptr;
     int *idx;
     int size;
     FILE *file;
d225 1
a225 5
writeBITS (val, ptr, idx, size)
     int val;
     char *ptr;
     int *idx;
     int size;
d242 2
a243 6
writeBARRAY (data, ptr, idx, size, file)
     barray data;
     char *ptr;
     int *idx;
     int size ATTRIBUTE_UNUSED;
     FILE *file;
d253 1
a253 6
writeCHARS (string, ptr, idx, size, file)
     char *string;
     char *ptr;
     int *idx;
     int size;
     FILE *file;
d292 1
a292 1
wr_tr ()
d306 2
a307 5
wr_un (ptr, sfile, first, nsecs)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile;
     int first;
     int nsecs ATTRIBUTE_UNUSED;
d352 1
a352 2
wr_hd (p)
     struct coff_ofile *p;
d439 1
a439 3
wr_sh (p, sec)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_section *sec;
d452 1
a452 3
wr_ob (p, section)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_section *section;
d513 1
a513 3
wr_rl (ptr, sec)
     struct coff_ofile *ptr ATTRIBUTE_UNUSED;
     struct coff_section *sec;
d571 1
a571 2
wr_object_body (p)
     struct coff_ofile *p;
d584 3
a586 6
wr_dps_start (sfile, section, scope, type, nest)
     struct coff_sfile *sfile;
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_scope *scope;
     int type;
     int nest;
d621 2
a622 4
wr_dps_end (section, scope, type)
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_scope *scope ATTRIBUTE_UNUSED;
     int type;
d632 1
a632 2
nints (x)
     int x;
d638 2
a639 5
walk_tree_type_1 (sfile, symbol, type, nest)
     struct coff_sfile *sfile;
     struct coff_symbol *symbol;
     struct coff_type *type;
     int nest;
d910 2
a911 5
walk_tree_type (sfile, symbol, type, nest)
     struct coff_sfile *sfile;
     struct coff_symbol *symbol;
     struct coff_type *type;
     int nest;
d957 1
a957 5
walk_tree_symbol (sfile, section, symbol, nest)
     struct coff_sfile *sfile;
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_symbol *symbol;
     int nest;
d1171 1
a1171 6
walk_tree_scope (section, sfile, scope, nest, type)
     struct coff_section *section;
     struct coff_sfile *sfile;
     struct coff_scope *scope;
     int nest;
     int type;
d1195 1
a1195 3
walk_tree_sfile (section, sfile)
     struct coff_section *section;
     struct coff_sfile *sfile;
d1201 1
a1201 3
wr_program_structure (p, sfile)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
d1207 1
a1207 4
wr_du (p, sfile, n)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
     int n;
d1320 1
a1320 3
wr_dus (p, sfile)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_sfile *sfile;
d1356 1
a1356 3
find_base (sfile, section)
     struct coff_sfile *sfile;
     struct coff_section *section;
d1362 2
a1363 5
wr_dln (p, sfile, n)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_sfile *sfile;
     int n ATTRIBUTE_UNUSED;

d1500 2
a1501 4
wr_globals (p, sfile, n)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
     int n ATTRIBUTE_UNUSED;
d1521 1
a1521 2
wr_debug (p)
     struct coff_ofile *p;
d1542 1
a1542 1
wr_cs ()
d1590 1
a1590 3
wr_sc (ptr, sfile)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile;
d1712 2
a1713 4
wr_er (ptr, sfile, first)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
     int first;
d1739 2
a1740 4
wr_ed (ptr, sfile, first)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
     int first;
d1779 1
a1779 2
wr_unit_info (ptr)
     struct coff_ofile *ptr;
d1806 1
a1806 2
wr_module (p)
     struct coff_ofile *p;
d1817 1
a1817 2
align (x)
     int x;
d1826 1
a1826 2
prescan (tree)
     struct coff_ofile *tree;
d1854 1
a1854 3
show_usage (file, status)
     FILE *file;
     int status;
d1871 1
a1871 3
main (ac, av)
     int ac;
     char *av[];
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000
d29 1
a29 1
#include <bfd.h>
d33 2
a34 2
#include <libiberty.h>
#include <getopt.h>
a38 1
#define PROGRAM_VERSION "1.5"
d45 55
a99 4
static void wr_cs ();
static void walk_tree_scope ();
static void wr_globals ();
static int find_base ();
d107 1
a107 1
/* Obsolete ?? 
d125 2
a126 3
    {
      return ids2[x];
    }
d136 2
a137 3
    {
      return ids1[x];
    }
a153 2


a155 1

d163 1
a171 1

d184 1
d192 3
a194 4
    {
      sum += ptr[j];
    }
  /* Glue on a checksum too */
a199 2


d217 1
a217 1
      /* Lets write out that record and do another one */
d222 1
a245 1

d256 1
d260 1
a260 1
  /* Turn off all about to change bits */
d262 1
a262 1
  /* Turn on the bits we want */
d276 1
d279 1
a279 3
    {
      writeINT (data.data[i], ptr, idx, 1, file);
    }
a281 1

d294 1
a294 1
      /* Lets write out that record and do another one */
d302 1
a302 1
      /* Variable length string */
d307 1
a307 1
  /* BUG WAITING TO HAPPEN */
a315 1

d329 1
a329 1
  /* The TR block is not normal - it doesn't have any contents. */
d331 6
a336 5
  static char b[] = {
    0xff,			/* IT */
    0x03,			/* RL */
    0xfd,			/* CS */
  };
a347 1

a357 1

d359 1
a359 1
  un.nsections = ptr->nsections - 1;	/*  Don't count the abs section */
d361 1
a361 1
  /*NEW - only count sections with size */
d367 1
a367 1
  /* Count all the undefined and defined variables with global scope */
a388 1

d397 1
a397 3
    {
      hd.mt = MTYPE_ABS_LM;
    }
d399 2
a400 3
    {
      hd.mt = MTYPE_OMS_OR_LMS;
    }
d406 1
d505 2
a506 1
      int todo = 200;		/* Copy in 200 byte lumps */
d526 1
a526 1
      ob.cpf = 0;		/* Never compress */
d533 2
a534 1
  /* Now fill the rest with blanks */
d538 2
a539 1
      int todo = 200;		/* Copy in 200 byte lumps */
d545 1
a545 1
      ob.cpf = 0;		/* Never compress */
d552 1
a552 2
  /* Now fill the rest with blanks */

d562 1
d568 1
d576 3
a578 2
      rl.flen = 32;		/* SH Specific */
      /* What sort of reloc ? Look in the section to find out */
d582 1
a582 1
	  rl.bcount = 4;	/* Always 4 for us */
d588 1
a588 1
	  rl.bcount = 11;	/* Always 11 for us */
a595 1

d598 1
a598 1
	  rl.bcount = 11;	/* Always 11 for us */
d606 1
d608 2
a609 1
      if (rl.op == OP_SEC_REF
d611 1
a611 3
	{
	  sysroff_swap_rl_out (file, &rl);
	}
d620 1
d638 1
d642 1
d648 1
a654 1

d676 1
a688 1
static void walk_tree_symbol ();
d711 1
d717 1
d725 1
d730 1
d735 1
d740 1
d746 1
d755 1
d761 1
d765 1
d776 1
d789 2
a790 3
	  {
	    walk_tree_symbol (sfile, 0, param, nest);
	  }
d801 1
d813 1
d817 1
a817 3
	  {
	    walk_tree_symbol (sfile, 0, member, nest + 1);
	  }
d824 1
d828 1
d833 1
d835 1
a835 3
	  {
	    dbt.sid = get_member_id (type->u.astructref.ref->number);
	  }
d837 1
a837 3
	  {
	    dbt.sid = 0;
	  }
d843 1
d848 2
a849 1
	int dims = 1;		/* Only output one dimension at a time */
d862 1
d877 1
d883 1
d896 1
d900 1
a900 3
	  {
	    walk_tree_symbol (sfile, 0, member, nest + 1);
	  }
a906 1
      break;
d910 1
d920 1
d926 1
a926 1
/* Obsolete ? 
d966 1
a966 3

     struct
     coff_sfile *sfile;
d973 1
a974 1
      struct IT_dty dty;
a999 1

d1004 1
a1011 1

a1013 2


d1023 1
a1023 1
  memset(&dsy, 0, sizeof(dsy));
d1032 1
d1041 1
d1047 1
d1053 1
d1056 1
d1066 1
a1085 1

d1094 1
d1098 1
d1102 1
d1107 1
d1113 1
d1118 1
d1124 1
d1134 1
a1140 1

d1144 1
d1154 1
d1158 1
a1159 2


d1176 1
d1182 1
a1185 1

d1189 1
d1200 1
a1200 1
      /* We do this 'cause common C symbols are treated as extdefs */
a1202 1

a1211 1

d1218 1
a1224 1

a1226 1

a1231 1

d1252 1
a1252 3
	{
	  walk_tree_symbol (sfile, section, vars, nest);
	}
d1255 1
a1255 3
	{
	  walk_tree_scope (section, sfile, child, nest + 1, BLOCK_TYPE_BLOCK);
	}
d1260 1
a1266 1

a1273 1

a1274 1

d1294 1
d1312 1
a1312 1
     source file */
a1331 1

d1335 2
a1336 3
	{
	  lowest[i] = highest[i] = incit;
	}
d1340 1
d1350 1
a1351 1
#endif
d1357 1
d1359 1
d1372 1
d1383 1
a1397 1

d1406 1
a1406 1
  /* Find the filenames */
d1429 1
a1429 1
   .text section for the output file */
d1578 2
a1579 1
/* Write the global symbols out to the debug info */
d1587 1
d1596 1
a1596 1
	     the current source file */
a1598 1

d1609 1
a1612 1

d1615 2
a1616 3
	{
	  printf ("%s\n", sfile->name);
	}
d1629 3
a1631 2
     heres one I prepared earlier.. */
  static char b[] = {
d1635 11
a1645 11
    0x80,			/* hd */ 
    0x00,			/* hs */ 
    0x80,			/* un */ 
    0x00,			/* us */ 
    0x80,			/* sc */ 
    0x00,			/* ss */ 
    0x80,			/* er */ 
    0x80,			/* ed */ 
    0x80,			/* sh */ 
    0x80,			/* ob */ 
    0x80,			/* rl */ 
d1671 1
a1671 1
   if there isn't an equivalent one on the input */
d1679 2
a1680 3
int scount = 0;
  /* First work out the total number of sections */

a1681 1

a1687 1

a1691 1

d1717 1
a1717 2
     we don't have */

d1722 1
d1726 1
d1729 2
a1730 2
	  /* Don't have a symbol set aside for this section, which means that nothing
	     in this file does anything for the section. */
a1752 1

d1761 1
a1761 1
      sc.spare1 = 0;		/* If not zero, then it doesn't work */
d1763 1
d1772 1
d1783 2
a1784 1
      if (sc.length) {
d1786 2
a1787 2
	sysroff_swap_sc_out (file, &sc);
	scount++;
d1789 1
a1789 1
      }
d1792 1
a1792 1
return scount;
d1795 1
a1796 1
/* Write out the ER records for a unit. */
d1805 1
d1813 1
d1824 2
a1825 1
/* Write out the ED records for a unit. */
d1833 1
d1845 1
d1859 1
d1874 1
d1882 1
d1889 1
a1889 1
      fseek (file, p2, SEEK_SET); 
d1916 1
a1916 1
   ordinary defs - dunno why, but thats what hitachi does with 'em */
d1924 2
a1925 1
  /* Find the common section - always section 3 */
d1927 1
d1952 11
a1962 1
  fprintf (file, _("Usage: %s [-dhVq] in-file [out-file]\n"), program_name);
a1965 10
static void
show_help ()
{
  printf (_("%s: Convert a COFF object file into a SYSROFF object file\n"),
	  program_name);
  show_usage (stdout, 0);
}



d1988 3
d1997 1
a1997 1
  while ((opt = getopt_long (ac, av, "dhVqn", long_options,
d2012 1
d2014 1
a2014 1
	  show_help ();
d2016 1
d2018 1
a2018 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
d2061 1
d2064 1
d2087 1
d2099 1
a2099 3
    {
      fatal (_("unable to open output file %s"), output_file);
    }
d2103 1
d2105 1
d2108 1
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 98, 99, 2000 Free Software Foundation, Inc.
d228 1
a228 1
     int size;
d303 1
a303 1
     int nsecs;
d442 1
a442 1
     struct coff_ofile *p;
d457 1
a457 1
     struct coff_ofile *p;
d518 1
a518 1
     struct coff_ofile *ptr;
d590 1
a590 1
     struct coff_section *section;
d627 2
a628 2
     struct coff_section *section;
     struct coff_scope *scope;
d964 1
a964 1
     struct coff_section *section;
d1333 1
a1333 1
     struct coff_ofile *p;
d1377 1
d1380 1
a1380 1
     struct coff_ofile *p;
d1382 1
a1382 1
     int n;
d1522 1
a1522 1
     int n;
d1739 1
a1739 1
     struct coff_sfile *sfile;
d1765 1
a1765 1
     struct coff_sfile *sfile;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1994 Free Software Foundation, Inc.
d18 2
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d41 4
a44 2
static int sh;
static int h8300;
a68 10
char *
xcalloc (a, b)
     int a;
     int b;
{
  char *r = xmalloc (a * b);
  memset (r, 0, a * b);
  return r;
}

d167 1
a167 6
    {
      if (sh)	
	size = 4;
      else if (h8300)
	size = 2;
    }
d310 1
a310 1
  if (abfd->flags & EXEC_P)
d340 1
a340 4
  if (sh)
    un.tool = "C_SH";
  else if (h8300)
    un.tool = "C_H8/300H";
d356 1
a356 1
  if (abfd->flags & EXEC_P)
d369 1
a369 1
  switch (abfd->arch_info->arch)
a373 1
      hd.afl = 2;
d377 24
a400 2
      hd.cpu = "H8300H";
      h8300 = 1;
d410 3
a412 1
      sh = 1;
d418 1
a418 1
  if (!abfd->flags & EXEC_P)
d433 1
a433 2
  hd.mn = strip_suffix (abfd->filename);

d459 1
a459 1
  int i;
d475 1
a475 1
	  if (abfd->flags & EXEC_P)
d495 1
a495 1
  while (i < section->size)
d500 1
a500 1
      if (i + todo > section->size)
d969 1
a969 1
  dsy.spare2 = 0;
d1126 1
a1126 6
    {
      if (sh)
	dsy.reg = rname_sh[symbol->where->offset];
      else if (h8300)
	dsy.reg = rname_h8300[symbol->where->offset];
    }
d1235 1
a1235 1
  du.format = abfd->flags & EXEC_P ? 0 : 1;
d1281 1
a1281 1
      du.address[used] = abfd->flags & EXEC_P ? lowest[i] : 0;
d1670 1
a1670 1
	  sc.format = !(abfd->flags & EXEC_P);
d1677 1
a1677 1
	  if (abfd->flags & EXEC_P)
d1879 1
a1879 1
  fprintf (file, "Usage: %s [-dhVq] in-file [out-file]\n", program_name);
d1886 1
a1886 1
  printf ("%s: Convert a COFF object file into a SYSROFF object file\n",
d1910 7
a1917 1
  char *output_file;
d1940 1
a1940 1
	  printf ("GNU %s version %s\n", program_name, PROGRAM_VERSION);
d1965 1
a1965 4
	      fprintf (stderr,
		       "%s: input and output files must be different\n",
		       program_name);
	      exit (1);
d1974 1
a1974 3
      fprintf (stderr, "%s: no input file specified\n",
	       program_name);
      exit (1);
d2019 1
a2019 3
      fprintf (stderr, "%s: unable to open output file %s\n",
	       program_name, output_file);
      exit (1);
@


1.1
log
@Initial revision
@
text
@d329 1
a329 1
#if 0
d388 1
a388 1
      hd.si = 32;
d390 1
a390 1
      hd.spcsz = 0;
d398 1
a398 1
      hd.si = 32;
d400 1
a400 1
      hd.spcsz = 0;
a1232 1
  du.spare = 0;
d1235 2
d1717 1
d1720 1
d1723 1
d1725 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d329 1
a329 1
#if 1
d388 1
a388 1
      hd.si = 0;
d390 1
a390 1
      hd.spcsz = 32;
d398 1
a398 1
      hd.si = 0;
d400 1
a400 1
      hd.spcsz = 32;
d1233 1
a1235 2
  du.stackfrmt = 0;
  du.spare = 0;
a1715 1
#if 0
a1717 1
#endif
a1719 1
#if 0
a1720 1
#endif
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 98, 99, 2000 Free Software Foundation, Inc.
d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d40 2
a41 4
static int addrsize;
static char *toolname;
static char **rnames;

d66 10
d174 6
a179 1
    size = addrsize;
d322 1
a322 1
  if (bfd_get_file_flags (abfd) & EXEC_P)
d352 4
a355 1
  un.tool = toolname;
d371 1
a371 1
  if (bfd_get_file_flags (abfd) & EXEC_P)
d384 1
a384 1
  switch (bfd_get_arch (abfd))
d389 1
d393 2
a394 24
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_h8300:
	  hd.cpu = "H8300";
	  hd.afl = 2;
	  addrsize = 2;
	  toolname = "C_H8/300";
	  break;
	case bfd_mach_h8300h:
	  hd.cpu = "H8300H";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300H";
	  break;
	case bfd_mach_h8300s:
	  hd.cpu = "H8300S";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300S";
	  break;
	default:
	  abort();
	}
      rnames = rname_h8300;
d404 1
a404 3
      addrsize = 4;
      toolname = "C_SH";
      rnames = rname_sh;
d410 1
a410 1
  if (! bfd_get_file_flags(abfd) & EXEC_P)
d425 2
a426 1
  hd.mn = strip_suffix (bfd_get_filename (abfd));
d452 1
a452 1
  bfd_size_type i;
d468 1
a468 1
	  if (bfd_get_file_flags (abfd) & EXEC_P)
d488 1
a488 1
  while (i < (bfd_size_type) section->size)
d493 1
a493 1
      if (i + todo > (bfd_size_type) section->size)
d962 1
a962 1
  memset(&dsy, 0, sizeof(dsy));
d1119 6
a1124 1
    dsy.reg = rnames[symbol->where->offset];
d1233 1
a1233 1
  du.format = bfd_get_file_flags (abfd) & EXEC_P ? 0 : 1;
d1279 1
a1279 1
      du.address[used] = bfd_get_file_flags (abfd) & EXEC_P ? lowest[i] : 0;
d1668 1
a1668 1
	  sc.format = !(bfd_get_file_flags (abfd) & EXEC_P);
d1675 1
a1675 1
	  if (bfd_get_file_flags (abfd) & EXEC_P)
d1877 1
a1877 1
  fprintf (file, _("Usage: %s [-dhVq] in-file [out-file]\n"), program_name);
d1884 1
a1884 1
  printf (_("%s: Convert a COFF object file into a SYSROFF object file\n"),
d1908 1
a1909 7

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d1932 1
a1932 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
d1957 4
a1960 1
	      fatal (_("input and output files must be different"));
d1969 3
a1971 1
      fatal (_("no input file specified"));
d2016 3
a2018 1
      fatal (_("unable to open output file %s"), output_file);
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1998, 1999, 2000
   Free Software Foundation, Inc.
d227 1
a227 1
     int size ATTRIBUTE_UNUSED;
d302 1
a302 1
     int nsecs ATTRIBUTE_UNUSED;
d441 1
a441 1
     struct coff_ofile *p ATTRIBUTE_UNUSED;
d456 1
a456 1
     struct coff_ofile *p ATTRIBUTE_UNUSED;
d517 1
a517 1
     struct coff_ofile *ptr ATTRIBUTE_UNUSED;
d589 1
a589 1
     struct coff_section *section ATTRIBUTE_UNUSED;
d626 2
a627 2
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_scope *scope ATTRIBUTE_UNUSED;
d963 1
a963 1
     struct coff_section *section ATTRIBUTE_UNUSED;
d1332 1
a1332 1
     struct coff_ofile *p ATTRIBUTE_UNUSED;
a1375 1

d1378 1
a1378 1
     struct coff_ofile *p ATTRIBUTE_UNUSED;
d1380 1
a1380 1
     int n ATTRIBUTE_UNUSED;
d1520 1
a1520 1
     int n ATTRIBUTE_UNUSED;
d1737 1
a1737 1
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
d1763 1
a1763 1
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
d29 1
a29 1
#include "bfd.h"
d33 2
a34 2
#include "libiberty.h"
#include "getopt.h"
d39 1
d46 4
a49 55
static int get_member_id PARAMS ((int));
static int get_ordinary_id PARAMS ((int));
static char *section_translate PARAMS ((char *));
static char *strip_suffix PARAMS ((char *));
static void checksum PARAMS ((FILE *, char *, int, int));
static void writeINT PARAMS ((int, char *, int *, int, FILE *));
static void writeBITS PARAMS ((int, char *, int *, int));
static void writeBARRAY PARAMS ((barray, char *, int *, int, FILE *));
static void writeCHARS PARAMS ((char *, char *, int *, int, FILE *));
static void wr_tr PARAMS ((void));
static void wr_un PARAMS ((struct coff_ofile *, struct coff_sfile *, int, int));
static void wr_hd PARAMS ((struct coff_ofile *));
static void wr_sh PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_ob PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_rl PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_object_body PARAMS ((struct coff_ofile *));
static void wr_dps_start
  PARAMS ((struct coff_sfile *, struct coff_section *, struct coff_scope *,
	   int, int));
static void wr_dps_end
  PARAMS ((struct coff_section *, struct coff_scope *, int));
static int *nints PARAMS ((int));
static void walk_tree_type_1
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
static void walk_tree_type
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
static void walk_tree_symbol
  PARAMS ((struct coff_sfile *, struct coff_section *,
	   struct coff_symbol *, int));
static void walk_tree_scope
  PARAMS ((struct coff_section *, struct coff_sfile *, struct coff_scope *,
	   int, int));
static void walk_tree_sfile
  PARAMS ((struct coff_section *, struct coff_sfile *));
static void wr_program_structure
  PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_du PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_dus PARAMS ((struct coff_ofile *, struct coff_sfile *));
static int find_base PARAMS ((struct coff_sfile *, struct coff_section *));
static void wr_dln PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_globals
  PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_debug PARAMS ((struct coff_ofile *));
static void wr_cs PARAMS ((void));
static int wr_sc PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_er PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_ed PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_unit_info PARAMS ((struct coff_ofile *));
static void wr_module PARAMS ((struct coff_ofile *));
static int align PARAMS ((int));
static void prescan PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));
d57 1
a57 1
/* Obsolete ??
d75 3
a77 2
    return ids2[x];

d87 3
a89 2
    return ids1[x];

d106 2
d110 1
a117 1

d126 1
a138 1

d146 4
a149 3
    sum += ptr[j];

  /* Glue on a checksum too.  */
d155 2
d174 1
a174 1
      /* Lets write out that record and do another one.  */
a178 1

d202 1
a212 1

d216 1
a216 1
  /* Turn off all about to change bits.  */
d218 1
a218 1
  /* Turn on the bits we want.  */
a231 1

d234 3
a236 1
    writeINT (data.data[i], ptr, idx, 1, file);
d239 1
d252 1
a252 1
      /* Lets write out that record and do another one.  */
d260 1
a260 1
      /* Variable length string.  */
d265 1
a265 1
  /* BUG WAITING TO HAPPEN.  */
d274 1
d288 1
a288 1
  /* The TR block is not normal - it doesn't have any contents.  */
d290 5
a294 6
  static char b[] =
    {
      0xff,			/* IT */
      0x03,			/* RL */
      0xfd,			/* CS */
    };
d306 1
d317 1
d319 1
a319 1
  un.nsections = ptr->nsections - 1;	/*  Don't count the abs section.  */
d321 1
a321 1
  /*NEW - only count sections with size.  */
d327 1
a327 1
  /* Count all the undefined and defined variables with global scope.  */
d349 1
d358 3
a360 1
    hd.mt = MTYPE_ABS_LM;
d362 3
a364 2
    hd.mt = MTYPE_OMS_OR_LMS;

a369 1

d468 1
a468 2
      int todo = 200;		/* Copy in 200 byte lumps.  */

d488 1
a488 1
      ob.cpf = 0;		/* Never compress.  */
d495 1
a495 2

  /* Now fill the rest with blanks.  */
d499 1
a499 2
      int todo = 200;		/* Copy in 200 byte lumps.  */

d505 1
a505 1
      ob.cpf = 0;		/* Never compress.  */
d512 2
a513 1
  /* Now fill the rest with blanks.  */
a522 1

a527 1

d535 2
a536 3
      rl.flen = 32;		/* SH Specific.  */

      /* What sort of reloc ? Look in the section to find out.  */
d540 1
a540 1
	  rl.bcount = 4;	/* Always 4 for us.  */
d546 1
a546 1
	  rl.bcount = 11;	/* Always 11 for us.  */
d554 1
d557 1
a557 1
	  rl.bcount = 11;	/* Always 11 for us.  */
a564 1

d566 1
a566 2

      if (   rl.op == OP_SEC_REF
d568 3
a570 1
	sysroff_swap_rl_out (file, &rl);
a578 1

a595 1

a598 1

a603 1

d610 1
a631 1

d644 1
a666 1

a671 1

a678 1

a682 1

a686 1

a690 1

a695 1

a703 1

a708 1

a711 1

a721 1

d734 3
a736 2
	  walk_tree_symbol (sfile, 0, param, nest);

a746 1

a757 1

d761 3
a763 1
	  walk_tree_symbol (sfile, 0, member, nest + 1);
a769 1

a772 1

a776 1

d778 3
a780 1
	  dbt.sid = get_member_id (type->u.astructref.ref->number);
d782 3
a784 1
	  dbt.sid = 0;
a789 1

d794 1
a794 2
	int dims = 1;		/* Only output one dimension at a time.  */

a806 1

a820 1

a825 1

a837 1

d841 3
a843 1
	  walk_tree_symbol (sfile, 0, member, nest + 1);
d850 1
a853 1

a862 1

d868 1
a868 1
/* Obsolete ?
d908 3
a910 1
     struct coff_sfile *sfile;
d917 1
a918 1

d944 1
a948 1

d956 1
d959 2
d970 1
a970 1
  memset (&dsy, 0, sizeof(dsy));
a978 1

a986 1

a991 1

a996 1

a998 1

a1007 1

d1027 1
a1035 1

a1038 1

a1041 1

a1045 1

a1050 1

a1054 1

a1059 1

a1068 1

d1075 1
a1078 1

a1087 1

d1091 2
a1093 1
    case coff_where_member_of_struct:
a1109 1

a1114 1

d1118 1
a1121 1

d1132 1
a1132 1
      /* We do this 'cause common C symbols are treated as extdefs.  */
d1135 1
d1145 1
a1151 1

d1158 1
d1161 1
d1167 1
d1188 3
a1190 1
	walk_tree_symbol (sfile, section, vars, nest);
d1193 3
a1195 1
	walk_tree_scope (section, sfile, child, nest + 1, BLOCK_TYPE_BLOCK);
a1199 1

d1206 1
d1214 1
d1216 1
a1235 1

d1253 1
a1253 1
     source file.  */
d1273 1
d1277 3
a1279 2
	lowest[i] = highest[i] = incit;

a1282 1

d1292 1
a1293 1

a1298 1

a1299 1

a1311 1

a1321 1

d1336 1
d1345 1
a1345 1
  /* Find the filenames.  */
d1368 1
a1368 1
   .text section for the output file.  */
d1517 1
a1517 2
/* Write the global symbols out to the debug info.  */

a1524 1

d1533 1
a1533 1
	     the current source file.  */
d1536 1
a1546 1

d1550 1
d1553 3
a1555 2
	printf ("%s\n", sfile->name);

d1568 2
a1569 3
     heres one I prepared earlier.  */
  static char b[] =
    {
d1573 11
a1583 11
    0x80,			/* hd */
    0x00,			/* hs */
    0x80,			/* un */
    0x00,			/* us */
    0x80,			/* sc */
    0x00,			/* ss */
    0x80,			/* er */
    0x80,			/* ed */
    0x80,			/* sh */
    0x80,			/* ob */
    0x80,			/* rl */
d1609 1
a1609 1
   if there isn't an equivalent one on the input.  */
d1617 3
a1619 2
  int scount = 0;
  /* First work out the total number of sections.  */
d1621 1
d1628 1
d1633 1
d1659 2
a1660 1
     we don't have.  */
a1664 1

a1667 1

d1670 2
a1671 2
	  /* Don't have a symbol set aside for this section, which means
	     that nothing in this file does anything for the section.  */
d1694 1
d1703 1
a1703 1
      sc.spare1 = 0;		/* If not zero, then it doesn't work.  */
a1704 1

a1712 1

d1723 1
a1723 2
      if (sc.length)
	{
d1725 2
a1726 2
	  sysroff_swap_sc_out (file, &sc);
	  scount++;
d1728 1
a1728 1
	}
d1731 1
a1731 1
  return scount;
a1733 1
/* Write out the ER records for a unit.  */
d1735 1
a1743 1

a1750 1

d1761 1
a1761 2
/* Write out the ED records for a unit.  */

a1768 1

a1779 1

a1792 1

a1806 1

a1813 1

d1820 1
a1820 1
      fseek (file, p2, SEEK_SET);
d1847 1
a1847 1
   ordinary defs - dunno why, but thats what hitachi does with 'em.  */
d1855 1
a1855 2

  /* Find the common section - always section 3.  */
a1856 1

d1881 3
a1883 8
  fprintf (file, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (file, _("Convert a COFF object file into a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
  -q --quick       (Obsolete - ignoerd)\n\
  -n --noprescan   Do not perform a scan to convert commons into defs\n\
  -d --debug       Display information about what is being done\n\
  -h --help        Display this information\n\
  -v --version     Print the program's version number\n"));
d1885 6
a1890 3
  if (status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
d1893 2
a1916 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d1923 1
a1923 1
  while ((opt = getopt_long (ac, av, "dHhVvqn", long_options,
a1937 1
	case 'H':
d1939 1
a1939 1
	  show_usage (stdout, 0);
a1940 1
	case 'v':
d1942 1
a1942 1
	  print_version ("srconv");
a1984 1

a1986 1

a2008 1

d2020 3
a2022 1
    fatal (_("unable to open output file %s"), output_file);
a2025 1

a2026 1

a2028 1

@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003
d45 16
a60 16
static int get_member_id (int);
static int get_ordinary_id (int);
static char *section_translate (char *);
static char *strip_suffix (char *);
static void checksum (FILE *, char *, int, int);
static void writeINT (int, char *, int *, int, FILE *);
static void writeBITS (int, char *, int *, int);
static void writeBARRAY (barray, char *, int *, int, FILE *);
static void writeCHARS (char *, char *, int *, int, FILE *);
static void wr_tr (void);
static void wr_un (struct coff_ofile *, struct coff_sfile *, int, int);
static void wr_hd (struct coff_ofile *);
static void wr_sh (struct coff_ofile *, struct coff_section *);
static void wr_ob (struct coff_ofile *, struct coff_section *);
static void wr_rl (struct coff_ofile *, struct coff_section *);
static void wr_object_body (struct coff_ofile *);
d62 5
a66 3
  (struct coff_sfile *, struct coff_section *, struct coff_scope *, int, int);
static void wr_dps_end (struct coff_section *, struct coff_scope *, int);
static int *nints (int);
d68 2
a69 1
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
d71 2
a72 1
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
d74 2
a75 1
  (struct coff_sfile *, struct coff_section *, struct coff_symbol *, int);
d77 23
a99 19
  (struct coff_section *, struct coff_sfile *, struct coff_scope *, int, int);
static void walk_tree_sfile (struct coff_section *, struct coff_sfile *);
static void wr_program_structure (struct coff_ofile *, struct coff_sfile *);
static void wr_du (struct coff_ofile *, struct coff_sfile *, int);
static void wr_dus (struct coff_ofile *, struct coff_sfile *);
static int find_base (struct coff_sfile *, struct coff_section *);
static void wr_dln (struct coff_ofile *, struct coff_sfile *, int);
static void wr_globals (struct coff_ofile *, struct coff_sfile *, int);
static void wr_debug (struct coff_ofile *);
static void wr_cs (void);
static int wr_sc (struct coff_ofile *, struct coff_sfile *);
static void wr_er (struct coff_ofile *, struct coff_sfile *, int);
static void wr_ed (struct coff_ofile *, struct coff_sfile *, int);
static void wr_unit_info (struct coff_ofile *);
static void wr_module (struct coff_ofile *);
static int align (int);
static void prescan (struct coff_ofile *);
static void show_usage (FILE *, int);
extern int main (int, char **);
d121 2
a122 1
get_member_id (int x)
d132 2
a133 1
get_ordinary_id (int x)
d142 2
a143 1
section_translate (char *n)
d158 2
a159 1
strip_suffix (char *name)
d174 5
a178 1
checksum (FILE *file, char *ptr, int size, int code)
d201 6
a206 1
writeINT (int n, char *ptr, int *idx, int size, FILE *file)
d247 5
a251 1
writeBITS (int val, char *ptr, int *idx, int size)
d268 6
a273 2
writeBARRAY (barray data, char *ptr, int *idx, int size ATTRIBUTE_UNUSED,
	     FILE *file)
d283 6
a288 1
writeCHARS (char *string, char *ptr, int *idx, int size, FILE *file)
d327 1
a327 1
wr_tr (void)
d341 5
a345 2
wr_un (struct coff_ofile *ptr, struct coff_sfile *sfile, int first,
       int nsecs ATTRIBUTE_UNUSED)
d390 2
a391 1
wr_hd (struct coff_ofile *p)
d478 3
a480 1
wr_sh (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *sec)
d493 3
a495 1
wr_ob (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *section)
d556 3
a558 1
wr_rl (struct coff_ofile *ptr ATTRIBUTE_UNUSED, struct coff_section *sec)
d616 2
a617 1
wr_object_body (struct coff_ofile *p)
d630 6
a635 3
wr_dps_start (struct coff_sfile *sfile,
	      struct coff_section *section ATTRIBUTE_UNUSED,
	      struct coff_scope *scope, int type, int nest)
d670 4
a673 2
wr_dps_end (struct coff_section *section ATTRIBUTE_UNUSED,
	    struct coff_scope *scope ATTRIBUTE_UNUSED, int type)
d683 2
a684 1
nints (int x)
d690 5
a694 2
walk_tree_type_1 (struct coff_sfile *sfile, struct coff_symbol *symbol,
		  struct coff_type *type, int nest)
d965 5
a969 2
walk_tree_type (struct coff_sfile *sfile, struct coff_symbol *symbol,
		struct coff_type *type, int nest)
d1015 5
a1019 1
walk_tree_symbol (struct coff_sfile *sfile, struct coff_section *section ATTRIBUTE_UNUSED, struct coff_symbol *symbol, int nest)
d1233 6
a1238 1
walk_tree_scope (struct coff_section *section, struct coff_sfile *sfile, struct coff_scope *scope, int nest, int type)
d1262 3
a1264 1
walk_tree_sfile (struct coff_section *section, struct coff_sfile *sfile)
d1270 3
a1272 1
wr_program_structure (struct coff_ofile *p, struct coff_sfile *sfile)
d1278 4
a1281 1
wr_du (struct coff_ofile *p, struct coff_sfile *sfile, int n)
d1394 3
a1396 1
wr_dus (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile)
d1432 3
a1434 1
find_base (struct coff_sfile *sfile, struct coff_section *section)
d1440 5
a1444 2
wr_dln (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile,
	int n ATTRIBUTE_UNUSED)
d1581 4
a1584 2
wr_globals (struct coff_ofile *p, struct coff_sfile *sfile,
	    int n ATTRIBUTE_UNUSED)
d1604 2
a1605 1
wr_debug (struct coff_ofile *p)
d1626 1
a1626 1
wr_cs (void)
d1674 3
a1676 1
wr_sc (struct coff_ofile *ptr, struct coff_sfile *sfile)
d1798 4
a1801 2
wr_er (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
d1827 4
a1830 2
wr_ed (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
d1869 2
a1870 1
wr_unit_info (struct coff_ofile *ptr)
d1897 2
a1898 1
wr_module (struct coff_ofile *p)
d1909 2
a1910 1
align (int x)
d1919 2
a1920 1
prescan (struct coff_ofile *tree)
d1948 3
a1950 1
show_usage (FILE *file, int status)
d1967 3
a1969 1
main (int ac, char **av)
@


