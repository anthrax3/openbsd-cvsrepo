head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.11.02.20.45.16;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.03.43;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.03.43;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.14.47;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.01;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* debug.h -- Describe generic debugging information.
   Copyright 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifndef DEBUG_H
#define DEBUG_H

/* This header file describes a generic debugging information format.
   We may eventually have readers which convert different formats into
   this generic format, and writers which write it out.  The initial
   impetus for this was writing a converter from stabs to HP IEEE-695
   debugging format.  */

/* Different kinds of types.  */

enum debug_type_kind
{
  /* Not used.  */
  DEBUG_KIND_ILLEGAL,
  /* Indirect via a pointer.  */
  DEBUG_KIND_INDIRECT,
  /* Void.  */
  DEBUG_KIND_VOID,
  /* Integer.  */
  DEBUG_KIND_INT,
  /* Floating point.  */
  DEBUG_KIND_FLOAT,
  /* Complex.  */
  DEBUG_KIND_COMPLEX,
  /* Boolean.  */
  DEBUG_KIND_BOOL,
  /* Struct.  */
  DEBUG_KIND_STRUCT,
  /* Union.  */
  DEBUG_KIND_UNION,
  /* Class.  */
  DEBUG_KIND_CLASS,
  /* Union class (can this really happen?).  */
  DEBUG_KIND_UNION_CLASS,
  /* Enumeration type.  */
  DEBUG_KIND_ENUM,
  /* Pointer.  */
  DEBUG_KIND_POINTER,
  /* Function.  */
  DEBUG_KIND_FUNCTION,
  /* Reference.  */
  DEBUG_KIND_REFERENCE,
  /* Range.  */
  DEBUG_KIND_RANGE,
  /* Array.  */
  DEBUG_KIND_ARRAY,
  /* Set.  */
  DEBUG_KIND_SET,
  /* Based pointer.  */
  DEBUG_KIND_OFFSET,
  /* Method.  */
  DEBUG_KIND_METHOD,
  /* Const qualified type.  */
  DEBUG_KIND_CONST,
  /* Volatile qualified type.  */
  DEBUG_KIND_VOLATILE,
  /* Named type.  */
  DEBUG_KIND_NAMED,
  /* Tagged type.  */
  DEBUG_KIND_TAGGED
};

/* Different kinds of variables.  */

enum debug_var_kind
{
  /* Not used.  */
  DEBUG_VAR_ILLEGAL,
  /* A global variable.  */
  DEBUG_GLOBAL,
  /* A static variable.  */
  DEBUG_STATIC,
  /* A local static variable.  */
  DEBUG_LOCAL_STATIC,
  /* A local variable.  */
  DEBUG_LOCAL,
  /* A register variable.  */
  DEBUG_REGISTER
};

/* Different kinds of function parameters.  */

enum debug_parm_kind
{
  /* Not used.  */
  DEBUG_PARM_ILLEGAL,
  /* A stack based parameter.  */
  DEBUG_PARM_STACK,
  /* A register parameter.  */
  DEBUG_PARM_REG,
  /* A stack based reference parameter.  */
  DEBUG_PARM_REFERENCE,
  /* A register reference parameter.  */
  DEBUG_PARM_REF_REG
};

/* Different kinds of visibility.  */

enum debug_visibility
{
  /* A public field (e.g., a field in a C struct).  */
  DEBUG_VISIBILITY_PUBLIC,
  /* A protected field.  */
  DEBUG_VISIBILITY_PROTECTED,
  /* A private field.  */
  DEBUG_VISIBILITY_PRIVATE,
  /* A field which should be ignored.  */
  DEBUG_VISIBILITY_IGNORE
};

/* A type.  */

typedef struct debug_type *debug_type;

#define DEBUG_TYPE_NULL ((debug_type) NULL)

/* A field in a struct or union.  */

typedef struct debug_field *debug_field;

#define DEBUG_FIELD_NULL ((debug_field) NULL)

/* A base class for an object.  */

typedef struct debug_baseclass *debug_baseclass;

#define DEBUG_BASECLASS_NULL ((debug_baseclass) NULL)

/* A method of an object.  */

typedef struct debug_method *debug_method;

#define DEBUG_METHOD_NULL ((debug_method) NULL)

/* The arguments to a method function of an object.  These indicate
   which method to run.  */

typedef struct debug_method_variant *debug_method_variant;

#define DEBUG_METHOD_VARIANT_NULL ((debug_method_variant) NULL)

/* This structure is passed to debug_write.  It holds function
   pointers that debug_write will call based on the accumulated
   debugging information.  */

struct debug_write_fns
{
  /* This is called at the start of each new compilation unit with the
     name of the main file in the new unit.  */
  bfd_boolean (*start_compilation_unit) (void *, const char *);

  /* This is called at the start of each source file within a
     compilation unit, before outputting any global information for
     that file.  The argument is the name of the file.  */
  bfd_boolean (*start_source) (void *, const char *);

  /* Each writer must keep a stack of types.  */

  /* Push an empty type onto the type stack.  This type can appear if
     there is a reference to a type which is never defined.  */
  bfd_boolean (*empty_type) (void *);

  /* Push a void type onto the type stack.  */
  bfd_boolean (*void_type) (void *);

  /* Push an integer type onto the type stack, given the size and
     whether it is unsigned.  */
  bfd_boolean (*int_type) (void *, unsigned int, bfd_boolean);

  /* Push a floating type onto the type stack, given the size.  */
  bfd_boolean (*float_type) (void *, unsigned int);

  /* Push a complex type onto the type stack, given the size.  */
  bfd_boolean (*complex_type) (void *, unsigned int);

  /* Push a bfd_boolean type onto the type stack, given the size.  */
  bfd_boolean (*bool_type) (void *, unsigned int);

  /* Push an enum type onto the type stack, given the tag, a NULL
     terminated array of names and the associated values.  If there is
     no tag, the tag argument will be NULL.  If this is an undefined
     enum, the names and values arguments will be NULL.  */
  bfd_boolean (*enum_type)
    (void *, const char *, const char **, bfd_signed_vma *);

  /* Pop the top type on the type stack, and push a pointer to that
     type onto the type stack.  */
  bfd_boolean (*pointer_type) (void *);

  /* Push a function type onto the type stack.  The second argument
     indicates the number of argument types that have been pushed onto
     the stack.  If the number of argument types is passed as -1, then
     the argument types of the function are unknown, and no types have
     been pushed onto the stack.  The third argument is TRUE if the
     function takes a variable number of arguments.  The return type
     of the function is pushed onto the type stack below the argument
     types, if any.  */
  bfd_boolean (*function_type) (void *, int, bfd_boolean);

  /* Pop the top type on the type stack, and push a reference to that
     type onto the type stack.  */
  bfd_boolean (*reference_type) (void *);

  /* Pop the top type on the type stack, and push a range of that type
     with the given lower and upper bounds onto the type stack.  */
  bfd_boolean (*range_type) (void *, bfd_signed_vma, bfd_signed_vma);

  /* Push an array type onto the type stack.  The top type on the type
     stack is the range, and the next type on the type stack is the
     element type.  These should be popped before the array type is
     pushed.  The arguments are the lower bound, the upper bound, and
     whether the array is a string.  */
  bfd_boolean (*array_type)
    (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);

  /* Pop the top type on the type stack, and push a set of that type
     onto the type stack.  The argument indicates whether this set is
     a bitstring.  */
  bfd_boolean (*set_type) (void *, bfd_boolean);

  /* Push an offset type onto the type stack.  The top type on the
     type stack is the target type, and the next type on the type
     stack is the base type.  These should be popped before the offset
     type is pushed.  */
  bfd_boolean (*offset_type) (void *);

  /* Push a method type onto the type stack.  If the second argument
     is TRUE, the top type on the stack is the class to which the
     method belongs; otherwise, the class must be determined by the
     class to which the method is attached.  The third argument is the
     number of argument types; these are pushed onto the type stack in
     reverse order (the first type popped is the last argument to the
     method).  A value of -1 for the third argument means that no
     argument information is available.  The fourth argument is TRUE
     if the function takes a variable number of arguments.  The next
     type on the type stack below the domain and the argument types is
     the return type of the method.  All these types must be popped,
     and then the method type must be pushed.  */
  bfd_boolean (*method_type) (void *, bfd_boolean, int, bfd_boolean);

  /* Pop the top type off the type stack, and push a const qualified
     version of that type onto the type stack.  */
  bfd_boolean (*const_type) (void *);

  /* Pop the top type off the type stack, and push a volatile
     qualified version of that type onto the type stack.  */
  bfd_boolean (*volatile_type) (void *);

  /* Start building a struct.  This is followed by calls to the
     struct_field function, and finished by a call to the
     end_struct_type function.  The second argument is the tag; this
     will be NULL if there isn't one.  If the second argument is NULL,
     the third argument is a constant identifying this struct for use
     with tag_type.  The fourth argument is TRUE for a struct, FALSE
     for a union.  The fifth argument is the size.  If this is an
     undefined struct or union, the size will be 0 and struct_field
     will not be called before end_struct_type is called.  */
  bfd_boolean (*start_struct_type)
    (void *, const char *, unsigned int, bfd_boolean, unsigned int);

  /* Add a field to the struct type currently being built.  The type
     of the field should be popped off the type stack.  The arguments
     are the name, the bit position, the bit size (may be zero if the
     field is not packed), and the visibility.  */
  bfd_boolean (*struct_field)
    (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);

  /* Finish building a struct, and push it onto the type stack.  */
  bfd_boolean (*end_struct_type) (void *);

  /* Start building a class.  This is followed by calls to several
     functions: struct_field, class_static_member, class_baseclass,
     class_start_method, class_method_variant,
     class_static_method_variant, and class_end_method.  The class is
     finished by a call to end_class_type.  The first five arguments
     are the same as for start_struct_type.  The sixth argument is
     TRUE if there is a virtual function table; if there is, the
     seventh argument is TRUE if the virtual function table can be
     found in the type itself, and is FALSE if the type of the object
     holding the virtual function table should be popped from the type
     stack.  */
  bfd_boolean (*start_class_type)
    (void *, const char *, unsigned int, bfd_boolean, unsigned int,
     bfd_boolean, bfd_boolean);

  /* Add a static member to the class currently being built.  The
     arguments are the field name, the physical name, and the
     visibility.  The type must be popped off the type stack.  */
  bfd_boolean (*class_static_member)
    (void *, const char *, const char *, enum debug_visibility);

  /* Add a baseclass to the class currently being built.  The type of
     the baseclass must be popped off the type stack.  The arguments
     are the bit position, whether the class is virtual, and the
     visibility.  */
  bfd_boolean (*class_baseclass)
    (void *, bfd_vma, bfd_boolean, enum debug_visibility);

  /* Start adding a method to the class currently being built.  This
     is followed by calls to class_method_variant and
     class_static_method_variant to describe different variants of the
     method which take different arguments.  The method is finished
     with a call to class_end_method.  The argument is the method
     name.  */
  bfd_boolean (*class_start_method) (void *, const char *);

  /* Describe a variant to the class method currently being built.
     The type of the variant must be popped off the type stack.  The
     second argument is the physical name of the function.  The
     following arguments are the visibility, whether the variant is
     const, whether the variant is volatile, the offset in the virtual
     function table, and whether the context is on the type stack
     (below the variant type).  */
  bfd_boolean (*class_method_variant)
    (void *, const char *, enum debug_visibility, bfd_boolean,
     bfd_boolean, bfd_vma, bfd_boolean);

  /* Describe a static variant to the class method currently being
     built.  The arguments are the same as for class_method_variant,
     except that the last two arguments are omitted.  The type of the
     variant must be popped off the type stack.  */
  bfd_boolean (*class_static_method_variant)
    (void *, const char *, enum debug_visibility, bfd_boolean,
     bfd_boolean);

  /* Finish describing a class method.  */
  bfd_boolean (*class_end_method) (void *);

  /* Finish describing a class, and push it onto the type stack.  */
  bfd_boolean (*end_class_type) (void *);

  /* Push a type on the stack which was given a name by an earlier
     call to typdef.  */
  bfd_boolean (*typedef_type) (void *, const char *);

  /* Push a tagged type on the stack which was defined earlier.  If
     the second argument is not NULL, the type was defined by a call
     to tag.  If the second argument is NULL, the type was defined by
     a call to start_struct_type or start_class_type with a tag of
     NULL and the number of the third argument.  Either way, the
     fourth argument is the tag kind.  Note that this may be called
     for a struct (class) being defined, in between the call to
     start_struct_type (start_class_type) and the call to
     end_struct_type (end_class_type).  */
  bfd_boolean (*tag_type)
    (void *, const char *, unsigned int, enum debug_type_kind);

  /* Pop the type stack, and typedef it to the given name.  */
  bfd_boolean (*typdef) (void *, const char *);

  /* Pop the type stack, and declare it as a tagged struct or union or
     enum or whatever.  The tag passed down here is redundant, since
     was also passed when enum_type, start_struct_type, or
     start_class_type was called.  */
  bfd_boolean (*tag) (void *, const char *);

  /* This is called to record a named integer constant.  */
  bfd_boolean (*int_constant) (void *, const char *, bfd_vma);

  /* This is called to record a named floating point constant.  */
  bfd_boolean (*float_constant) (void *, const char *, double);

  /* This is called to record a typed integer constant.  The type is
     popped off the type stack.  */
  bfd_boolean (*typed_constant) (void *, const char *, bfd_vma);

  /* This is called to record a variable.  The type is popped off the
     type stack.  */
  bfd_boolean (*variable)
    (void *, const char *, enum debug_var_kind, bfd_vma);

  /* Start writing out a function.  The return type must be popped off
     the stack.  The bfd_boolean is TRUE if the function is global.  This
     is followed by calls to function_parameter, followed by block
     information.  */
  bfd_boolean (*start_function) (void *, const char *, bfd_boolean);

  /* Record a function parameter for the current function.  The type
     must be popped off the stack.  */
  bfd_boolean (*function_parameter)
    (void *, const char *, enum debug_parm_kind, bfd_vma);

  /* Start writing out a block.  There is at least one top level block
     per function.  Blocks may be nested.  The argument is the
     starting address of the block.  */
  bfd_boolean (*start_block) (void *, bfd_vma);

  /* Finish writing out a block.  The argument is the ending address
     of the block.  */
  bfd_boolean (*end_block) (void *, bfd_vma);

  /* Finish writing out a function.  */
  bfd_boolean (*end_function) (void *);

  /* Record line number information for the current compilation unit.  */
  bfd_boolean (*lineno) (void *, const char *, unsigned long, bfd_vma);
};

/* Exported functions.  */

/* The first argument to most of these functions is a handle.  This
   handle is returned by the debug_init function.  The purpose of the
   handle is to permit the debugging routines to not use static
   variables, and hence to be reentrant.  This would be useful for a
   program which wanted to handle two executables simultaneously.  */

/* Return a debugging handle.  */

extern void *debug_init (void);

/* Set the source filename.  This implicitly starts a new compilation
   unit.  */

extern bfd_boolean debug_set_filename (void *, const char *);

/* Change source files to the given file name.  This is used for
   include files in a single compilation unit.  */

extern bfd_boolean debug_start_source (void *, const char *);

/* Record a function definition.  This implicitly starts a function
   block.  The debug_type argument is the type of the return value.
   The bfd_boolean indicates whether the function is globally visible.
   The bfd_vma is the address of the start of the function.  Currently
   the parameter types are specified by calls to
   debug_record_parameter.  */

extern bfd_boolean debug_record_function
  (void *, const char *, debug_type, bfd_boolean, bfd_vma);

/* Record a parameter for the current function.  */

extern bfd_boolean debug_record_parameter
  (void *, const char *, debug_type, enum debug_parm_kind, bfd_vma);

/* End a function definition.  The argument is the address where the
   function ends.  */

extern bfd_boolean debug_end_function (void *, bfd_vma);

/* Start a block in a function.  All local information will be
   recorded in this block, until the matching call to debug_end_block.
   debug_start_block and debug_end_block may be nested.  The argument
   is the address at which this block starts.  */

extern bfd_boolean debug_start_block (void *, bfd_vma);

/* Finish a block in a function.  This matches the call to
   debug_start_block.  The argument is the address at which this block
   ends.  */

extern bfd_boolean debug_end_block (void *, bfd_vma);

/* Associate a line number in the current source file with a given
   address.  */

extern bfd_boolean debug_record_line (void *, unsigned long, bfd_vma);

/* Start a named common block.  This is a block of variables that may
   move in memory.  */

extern bfd_boolean debug_start_common_block (void *, const char *);

/* End a named common block.  */

extern bfd_boolean debug_end_common_block (void *, const char *);

/* Record a named integer constant.  */

extern bfd_boolean debug_record_int_const (void *, const char *, bfd_vma);

/* Record a named floating point constant.  */

extern bfd_boolean debug_record_float_const (void *, const char *, double);

/* Record a typed constant with an integral value.  */

extern bfd_boolean debug_record_typed_const
  (void *, const char *, debug_type, bfd_vma);

/* Record a label.  */

extern bfd_boolean debug_record_label
  (void *, const char *, debug_type, bfd_vma);

/* Record a variable.  */

extern bfd_boolean debug_record_variable
  (void *, const char *, debug_type, enum debug_var_kind, bfd_vma);

/* Make an indirect type.  The first argument is a pointer to the
   location where the real type will be placed.  The second argument
   is the type tag, if there is one; this may be NULL; the only
   purpose of this argument is so that debug_get_type_name can return
   something useful.  This function may be used when a type is
   referenced before it is defined.  */

extern debug_type debug_make_indirect_type
  (void *, debug_type *, const char *);

/* Make a void type.  */

extern debug_type debug_make_void_type (void *);

/* Make an integer type of a given size.  The bfd_boolean argument is TRUE
   if the integer is unsigned.  */

extern debug_type debug_make_int_type (void *, unsigned int, bfd_boolean);

/* Make a floating point type of a given size.  FIXME: On some
   platforms, like an Alpha, you probably need to be able to specify
   the format.  */

extern debug_type debug_make_float_type (void *, unsigned int);

/* Make a boolean type of a given size.  */

extern debug_type debug_make_bool_type (void *, unsigned int);

/* Make a complex type of a given size.  */

extern debug_type debug_make_complex_type (void *, unsigned int);

/* Make a structure type.  The second argument is TRUE for a struct,
   FALSE for a union.  The third argument is the size of the struct.
   The fourth argument is a NULL terminated array of fields.  */

extern debug_type debug_make_struct_type
  (void *, bfd_boolean, bfd_vma, debug_field *);

/* Make an object type.  The first three arguments after the handle
   are the same as for debug_make_struct_type.  The next arguments are
   a NULL terminated array of base classes, a NULL terminated array of
   methods, the type of the object holding the virtual function table
   if it is not this object, and a bfd_boolean which is TRUE if this
   object has its own virtual function table.  */

extern debug_type debug_make_object_type
  (void *, bfd_boolean, bfd_vma, debug_field *, debug_baseclass *,
   debug_method *, debug_type, bfd_boolean);

/* Make an enumeration type.  The arguments are a null terminated
   array of strings, and an array of corresponding values.  */

extern debug_type debug_make_enum_type
  (void *, const char **, bfd_signed_vma *);

/* Make a pointer to a given type.  */

extern debug_type debug_make_pointer_type (void *, debug_type);

/* Make a function type.  The second argument is the return type.  The
   third argument is a NULL terminated array of argument types.  The
   fourth argument is TRUE if the function takes a variable number of
   arguments.  If the third argument is NULL, then the argument types
   are unknown.  */

extern debug_type debug_make_function_type
  (void *, debug_type, debug_type *, bfd_boolean);

/* Make a reference to a given type.  */

extern debug_type debug_make_reference_type (void *, debug_type);

/* Make a range of a given type from a lower to an upper bound.  */

extern debug_type debug_make_range_type
  (void *, debug_type, bfd_signed_vma, bfd_signed_vma);

/* Make an array type.  The second argument is the type of an element
   of the array.  The third argument is the type of a range of the
   array.  The fourth and fifth argument are the lower and upper
   bounds, respectively (if the bounds are not known, lower should be
   0 and upper should be -1).  The sixth argument is TRUE if this
   array is actually a string, as in C.  */

extern debug_type debug_make_array_type
  (void *, debug_type, debug_type, bfd_signed_vma, bfd_signed_vma,
   bfd_boolean);

/* Make a set of a given type.  For example, a Pascal set type.  The
   bfd_boolean argument is TRUE if this set is actually a bitstring, as in
   CHILL.  */

extern debug_type debug_make_set_type (void *, debug_type, bfd_boolean);

/* Make a type for a pointer which is relative to an object.  The
   second argument is the type of the object to which the pointer is
   relative.  The third argument is the type that the pointer points
   to.  */

extern debug_type debug_make_offset_type (void *, debug_type, debug_type);

/* Make a type for a method function.  The second argument is the
   return type.  The third argument is the domain.  The fourth
   argument is a NULL terminated array of argument types.  The fifth
   argument is TRUE if the function takes a variable number of
   arguments, in which case the array of argument types indicates the
   types of the first arguments.  The domain and the argument array
   may be NULL, in which case this is a stub method and that
   information is not available.  Stabs debugging uses this, and gets
   the argument types from the mangled name.  */

extern debug_type debug_make_method_type
  (void *, debug_type, debug_type, debug_type *, bfd_boolean);

/* Make a const qualified version of a given type.  */

extern debug_type debug_make_const_type (void *, debug_type);

/* Make a volatile qualified version of a given type.  */

extern debug_type debug_make_volatile_type (void *, debug_type);

/* Make an undefined tagged type.  For example, a struct which has
   been mentioned, but not defined.  */

extern debug_type debug_make_undefined_tagged_type
  (void *, const char *, enum debug_type_kind);

/* Make a base class for an object.  The second argument is the base
   class type.  The third argument is the bit position of this base
   class in the object.  The fourth argument is whether this is a
   virtual class.  The fifth argument is the visibility of the base
   class.  */

extern debug_baseclass debug_make_baseclass
  (void *, debug_type, bfd_vma, bfd_boolean, enum debug_visibility);

/* Make a field for a struct.  The second argument is the name.  The
   third argument is the type of the field.  The fourth argument is
   the bit position of the field.  The fifth argument is the size of
   the field (it may be zero).  The sixth argument is the visibility
   of the field.  */

extern debug_field debug_make_field
  (void *, const char *, debug_type, bfd_vma, bfd_vma, enum debug_visibility);

/* Make a static member of an object.  The second argument is the
   name.  The third argument is the type of the member.  The fourth
   argument is the physical name of the member (i.e., the name as a
   global variable).  The fifth argument is the visibility of the
   member.  */

extern debug_field debug_make_static_member
  (void *, const char *, debug_type, const char *, enum debug_visibility);

/* Make a method.  The second argument is the name, and the third
   argument is a NULL terminated array of method variants.  Each
   method variant is a method with this name but with different
   argument types.  */

extern debug_method debug_make_method
  (void *, const char *, debug_method_variant *);

/* Make a method variant.  The second argument is the physical name of
   the function.  The third argument is the type of the function,
   probably constructed by debug_make_method_type.  The fourth
   argument is the visibility.  The fifth argument is whether this is
   a const function.  The sixth argument is whether this is a volatile
   function.  The seventh argument is the index in the virtual
   function table, if any.  The eighth argument is the virtual
   function context.  */

extern debug_method_variant debug_make_method_variant
  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,
   bfd_boolean, bfd_vma, debug_type);

/* Make a static method argument.  The arguments are the same as for
   debug_make_method_variant, except that the last two are omitted
   since a static method can not also be virtual.  */

extern debug_method_variant debug_make_static_method_variant
  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,
   bfd_boolean);

/* Name a type.  This returns a new type with an attached name.  */

extern debug_type debug_name_type (void *, const char *, debug_type);

/* Give a tag to a type, such as a struct or union.  This returns a
   new type with an attached tag.  */

extern debug_type debug_tag_type (void *, const char *, debug_type);

/* Record the size of a given type.  */

extern bfd_boolean debug_record_type_size (void *, debug_type, unsigned int);

/* Find a named type.  */

extern debug_type debug_find_named_type (void *, const char *);

/* Find a tagged type.  */

extern debug_type debug_find_tagged_type
  (void *, const char *, enum debug_type_kind);

/* Get the kind of a type.  */

extern enum debug_type_kind debug_get_type_kind (void *, debug_type);

/* Get the name of a type.  */

extern const char *debug_get_type_name (void *, debug_type);

/* Get the size of a type.  */

extern bfd_vma debug_get_type_size (void *, debug_type);

/* Get the return type of a function or method type.  */

extern debug_type debug_get_return_type (void *, debug_type);

/* Get the NULL terminated array of parameter types for a function or
   method type (actually, parameter types are not currently stored for
   function types).  This may be used to determine whether a method
   type is a stub method or not.  The last argument points to a
   bfd_boolean which is set to TRUE if the function takes a variable
   number of arguments.  */

extern const debug_type *debug_get_parameter_types
  (void *, debug_type, bfd_boolean *);

/* Get the target type of a pointer or reference or const or volatile
   type.  */

extern debug_type debug_get_target_type (void *, debug_type);

/* Get the NULL terminated array of fields for a struct, union, or
   class.  */

extern const debug_field *debug_get_fields (void *, debug_type);

/* Get the type of a field.  */

extern debug_type debug_get_field_type (void *, debug_field);

/* Get the name of a field.  */

extern const char *debug_get_field_name (void *, debug_field);

/* Get the bit position of a field within the containing structure.
   If the field is a static member, this will return (bfd_vma) -1.  */

extern bfd_vma debug_get_field_bitpos (void *, debug_field);

/* Get the bit size of a field.  If the field is a static member, this
   will return (bfd_vma) -1.  */

extern bfd_vma debug_get_field_bitsize (void *, debug_field);

/* Get the visibility of a field.  */

extern enum debug_visibility debug_get_field_visibility (void *, debug_field);

/* Get the physical name of a field, if it is a static member.  If the
   field is not a static member, this will return NULL.  */

extern const char *debug_get_field_physname (void *, debug_field);

/* Write out the recorded debugging information.  This takes a set of
   function pointers which are called to do the actual writing.  The
   first void * is the debugging handle.  The second void * is a handle
   which is passed to the functions.  */

extern bfd_boolean debug_write
  (void *, const struct debug_write_fns *, void *);

#endif /* DEBUG_H */
@


1.3
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002 Free Software Foundation, Inc.
d28 1
a28 1
   impetus for this was writing a convertor from stabs to HP IEEE-695
d172 1
a172 1
  bfd_boolean (*start_compilation_unit) PARAMS ((PTR, const char *));
d177 1
a177 1
  bfd_boolean (*start_source) PARAMS ((PTR, const char *));
d183 1
a183 1
  bfd_boolean (*empty_type) PARAMS ((PTR));
d186 1
a186 1
  bfd_boolean (*void_type) PARAMS ((PTR));
d190 1
a190 1
  bfd_boolean (*int_type) PARAMS ((PTR, unsigned int, bfd_boolean));
d193 1
a193 1
  bfd_boolean (*float_type) PARAMS ((PTR, unsigned int));
d196 1
a196 1
  bfd_boolean (*complex_type) PARAMS ((PTR, unsigned int));
d199 1
a199 1
  bfd_boolean (*bool_type) PARAMS ((PTR, unsigned int));
d206 1
a206 1
    PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
d210 1
a210 1
  bfd_boolean (*pointer_type) PARAMS ((PTR));
d220 1
a220 1
  bfd_boolean (*function_type) PARAMS ((PTR, int, bfd_boolean));
d224 1
a224 1
  bfd_boolean (*reference_type) PARAMS ((PTR));
d228 1
a228 1
  bfd_boolean (*range_type) PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d236 1
a236 1
    PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
d241 1
a241 1
  bfd_boolean (*set_type) PARAMS ((PTR, bfd_boolean));
d247 1
a247 1
  bfd_boolean (*offset_type) PARAMS ((PTR));
d261 1
a261 1
  bfd_boolean (*method_type) PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
d265 1
a265 1
  bfd_boolean (*const_type) PARAMS ((PTR));
d269 1
a269 1
  bfd_boolean (*volatile_type) PARAMS ((PTR));
d281 1
a281 1
    PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d288 1
a288 1
    PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
d291 1
a291 1
  bfd_boolean (*end_struct_type) PARAMS ((PTR));
d305 2
a306 2
    PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	     bfd_boolean, bfd_boolean));
d312 1
a312 1
    PARAMS ((PTR, const char *, const char *, enum debug_visibility));
d319 1
a319 1
    PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
d327 1
a327 1
  bfd_boolean (*class_start_method) PARAMS ((PTR, const char *));
d337 2
a338 2
    PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	     bfd_boolean, bfd_vma, bfd_boolean));
d345 2
a346 2
    PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	     bfd_boolean));
d349 1
a349 1
  bfd_boolean (*class_end_method) PARAMS ((PTR));
d352 1
a352 1
  bfd_boolean (*end_class_type) PARAMS ((PTR));
d356 1
a356 1
  bfd_boolean (*typedef_type) PARAMS ((PTR, const char *));
d368 1
a368 1
    PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
d371 1
a371 1
  bfd_boolean (*typdef) PARAMS ((PTR, const char *));
d377 1
a377 1
  bfd_boolean (*tag) PARAMS ((PTR, const char *));
d380 1
a380 1
  bfd_boolean (*int_constant) PARAMS ((PTR, const char *, bfd_vma));
d383 1
a383 1
  bfd_boolean (*float_constant) PARAMS ((PTR, const char *, double));
d387 1
a387 1
  bfd_boolean (*typed_constant) PARAMS ((PTR, const char *, bfd_vma));
d392 1
a392 1
    PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
d398 1
a398 1
  bfd_boolean (*start_function) PARAMS ((PTR, const char *, bfd_boolean));
d403 1
a403 1
    PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
d408 1
a408 1
  bfd_boolean (*start_block) PARAMS ((PTR, bfd_vma));
d412 1
a412 1
  bfd_boolean (*end_block) PARAMS ((PTR, bfd_vma));
d415 1
a415 1
  bfd_boolean (*end_function) PARAMS ((PTR));
d418 1
a418 1
  bfd_boolean (*lineno) PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d431 1
a431 1
extern PTR debug_init PARAMS ((void));
d436 1
a436 1
extern bfd_boolean debug_set_filename PARAMS ((PTR, const char *));
d441 1
a441 1
extern bfd_boolean debug_start_source PARAMS ((PTR, const char *));
d451 1
a451 1
  PARAMS ((PTR, const char *, debug_type, bfd_boolean, bfd_vma));
d456 1
a456 1
  PARAMS ((PTR, const char *, debug_type, enum debug_parm_kind, bfd_vma));
d461 1
a461 1
extern bfd_boolean debug_end_function PARAMS ((PTR, bfd_vma));
d468 1
a468 1
extern bfd_boolean debug_start_block PARAMS ((PTR, bfd_vma));
d474 1
a474 1
extern bfd_boolean debug_end_block PARAMS ((PTR, bfd_vma));
d479 1
a479 1
extern bfd_boolean debug_record_line PARAMS ((PTR, unsigned long, bfd_vma));
d484 1
a484 1
extern bfd_boolean debug_start_common_block PARAMS ((PTR, const char *));
d488 1
a488 1
extern bfd_boolean debug_end_common_block PARAMS ((PTR, const char *));
d492 1
a492 2
extern bfd_boolean debug_record_int_const
  PARAMS ((PTR, const char *, bfd_vma));
d496 1
a496 2
extern bfd_boolean debug_record_float_const
  PARAMS ((PTR, const char *, double));
d501 1
a501 1
  PARAMS ((PTR, const char *, debug_type, bfd_vma));
d506 1
a506 1
  PARAMS ((PTR, const char *, debug_type, bfd_vma));
d511 1
a511 1
  PARAMS ((PTR, const char *, debug_type, enum debug_var_kind, bfd_vma));
d521 1
a521 1
  PARAMS ((PTR, debug_type *, const char *));
d525 1
a525 1
extern debug_type debug_make_void_type PARAMS ((PTR));
d530 1
a530 2
extern debug_type debug_make_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
d536 1
a536 1
extern debug_type debug_make_float_type PARAMS ((PTR, unsigned int));
d540 1
a540 1
extern debug_type debug_make_bool_type PARAMS ((PTR, unsigned int));
d544 1
a544 1
extern debug_type debug_make_complex_type PARAMS ((PTR, unsigned int));
d551 1
a551 1
  PARAMS ((PTR, bfd_boolean, bfd_vma, debug_field *));
d561 2
a562 2
  PARAMS ((PTR, bfd_boolean, bfd_vma, debug_field *, debug_baseclass *,
	   debug_method *, debug_type, bfd_boolean));
d568 1
a568 1
  PARAMS ((PTR, const char **, bfd_signed_vma *));
d572 1
a572 2
extern debug_type debug_make_pointer_type
  PARAMS ((PTR, debug_type));
d581 1
a581 1
  PARAMS ((PTR, debug_type, debug_type *, bfd_boolean));
d585 1
a585 1
extern debug_type debug_make_reference_type PARAMS ((PTR, debug_type));
d590 1
a590 1
  PARAMS ((PTR, debug_type, bfd_signed_vma, bfd_signed_vma));
d600 2
a601 2
  PARAMS ((PTR, debug_type, debug_type, bfd_signed_vma, bfd_signed_vma,
	   bfd_boolean));
d607 1
a607 1
extern debug_type debug_make_set_type PARAMS ((PTR, debug_type, bfd_boolean));
d614 1
a614 2
extern debug_type debug_make_offset_type
  PARAMS ((PTR, debug_type, debug_type));
d627 1
a627 1
  PARAMS ((PTR, debug_type, debug_type, debug_type *, bfd_boolean));
d631 1
a631 1
extern debug_type debug_make_const_type PARAMS ((PTR, debug_type));
d635 1
a635 1
extern debug_type debug_make_volatile_type PARAMS ((PTR, debug_type));
d641 1
a641 1
  PARAMS ((PTR, const char *, enum debug_type_kind));
d650 1
a650 1
  PARAMS ((PTR, debug_type, bfd_vma, bfd_boolean, enum debug_visibility));
d659 1
a659 2
  PARAMS ((PTR, const char *, debug_type, bfd_vma, bfd_vma,
	   enum debug_visibility));
d668 1
a668 2
  PARAMS ((PTR, const char *, debug_type, const char *,
	   enum debug_visibility));
d676 1
a676 1
  PARAMS ((PTR, const char *, debug_method_variant *));
d688 2
a689 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, bfd_boolean,
	   bfd_boolean, bfd_vma, debug_type));
d696 2
a697 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
d701 1
a701 1
extern debug_type debug_name_type PARAMS ((PTR, const char *, debug_type));
d706 1
a706 1
extern debug_type debug_tag_type PARAMS ((PTR, const char *, debug_type));
d710 1
a710 2
extern bfd_boolean debug_record_type_size
  PARAMS ((PTR, debug_type, unsigned int));
d714 1
a714 1
extern debug_type debug_find_named_type PARAMS ((PTR, const char *));
d719 1
a719 1
  PARAMS ((PTR, const char *, enum debug_type_kind));
d723 1
a723 1
extern enum debug_type_kind debug_get_type_kind PARAMS ((PTR, debug_type));
d727 1
a727 1
extern const char *debug_get_type_name PARAMS ((PTR, debug_type));
d731 1
a731 1
extern bfd_vma debug_get_type_size PARAMS ((PTR, debug_type));
d735 1
a735 1
extern debug_type debug_get_return_type PARAMS ((PTR, debug_type));
d745 1
a745 1
  PARAMS ((PTR, debug_type, bfd_boolean *));
d750 1
a750 1
extern debug_type debug_get_target_type PARAMS ((PTR, debug_type));
d755 1
a755 1
extern const debug_field *debug_get_fields PARAMS ((PTR, debug_type));
d759 1
a759 1
extern debug_type debug_get_field_type PARAMS ((PTR, debug_field));
d763 1
a763 1
extern const char *debug_get_field_name PARAMS ((PTR, debug_field));
d768 1
a768 1
extern bfd_vma debug_get_field_bitpos PARAMS ((PTR, debug_field));
d773 1
a773 1
extern bfd_vma debug_get_field_bitsize PARAMS ((PTR, debug_field));
d777 1
a777 2
extern enum debug_visibility debug_get_field_visibility
  PARAMS ((PTR, debug_field));
d782 1
a782 1
extern const char *debug_get_field_physname PARAMS ((PTR, debug_field));
d786 1
a786 1
   first PTR is the debugging handle.  The second PTR is a handle
d790 1
a790 1
  PARAMS ((PTR, const struct debug_write_fns *, PTR));
@


1.2
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d172 1
a172 1
  boolean (*start_compilation_unit) PARAMS ((PTR, const char *));
d177 1
a177 1
  boolean (*start_source) PARAMS ((PTR, const char *));
d183 1
a183 1
  boolean (*empty_type) PARAMS ((PTR));
d186 1
a186 1
  boolean (*void_type) PARAMS ((PTR));
d190 1
a190 1
  boolean (*int_type) PARAMS ((PTR, unsigned int, boolean));
d193 1
a193 1
  boolean (*float_type) PARAMS ((PTR, unsigned int));
d196 1
a196 1
  boolean (*complex_type) PARAMS ((PTR, unsigned int));
d198 2
a199 2
  /* Push a boolean type onto the type stack, given the size.  */
  boolean (*bool_type) PARAMS ((PTR, unsigned int));
d205 2
a206 2
  boolean (*enum_type) PARAMS ((PTR, const char *, const char **,
				bfd_signed_vma *));
d210 1
a210 1
  boolean (*pointer_type) PARAMS ((PTR));
d216 1
a216 1
     been pushed onto the stack.  The third argument is true if the
d220 1
a220 1
  boolean (*function_type) PARAMS ((PTR, int, boolean));
d224 1
a224 1
  boolean (*reference_type) PARAMS ((PTR));
d228 1
a228 1
  boolean (*range_type) PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d235 2
a236 2
  boolean (*array_type) PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma,
				 boolean));
d241 1
a241 1
  boolean (*set_type) PARAMS ((PTR, boolean));
d247 1
a247 1
  boolean (*offset_type) PARAMS ((PTR));
d250 1
a250 1
     is true, the top type on the stack is the class to which the
d256 1
a256 1
     argument information is available.  The fourth argument is true
d261 1
a261 1
  boolean (*method_type) PARAMS ((PTR, boolean, int, boolean));
d265 1
a265 1
  boolean (*const_type) PARAMS ((PTR));
d269 1
a269 1
  boolean (*volatile_type) PARAMS ((PTR));
d276 1
a276 1
     with tag_type.  The fourth argument is true for a struct, false
d280 2
a281 2
  boolean (*start_struct_type) PARAMS ((PTR, const char *, unsigned int,
					boolean, unsigned int));
d287 2
a288 2
  boolean (*struct_field) PARAMS ((PTR, const char *, bfd_vma, bfd_vma,
				   enum debug_visibility));
d291 1
a291 1
  boolean (*end_struct_type) PARAMS ((PTR));
d299 3
a301 3
     true if there is a virtual function table; if there is, the
     seventh argument is true if the virtual function table can be
     found in the type itself, and is false if the type of the object
d304 3
a306 3
  boolean (*start_class_type) PARAMS ((PTR, const char *, unsigned int,
				       boolean, unsigned int, boolean,
				       boolean));
d311 3
a313 3
  boolean (*class_static_member) PARAMS ((PTR, const char *, const char *,
					  enum debug_visibility));
  
d318 2
a319 2
  boolean (*class_baseclass) PARAMS ((PTR, bfd_vma, boolean,
				      enum debug_visibility));
d327 1
a327 1
  boolean (*class_start_method) PARAMS ((PTR, const char *));
d336 3
a338 4
  boolean (*class_method_variant) PARAMS ((PTR, const char *,
					   enum debug_visibility,
					   boolean, boolean,
					   bfd_vma, boolean));
d344 3
a346 3
  boolean (*class_static_method_variant) PARAMS ((PTR, const char *,
						  enum debug_visibility,
						  boolean, boolean));
d349 1
a349 1
  boolean (*class_end_method) PARAMS ((PTR));
d352 1
a352 1
  boolean (*end_class_type) PARAMS ((PTR));
d356 1
a356 1
  boolean (*typedef_type) PARAMS ((PTR, const char *));
d367 2
a368 2
  boolean (*tag_type) PARAMS ((PTR, const char *, unsigned int,
			       enum debug_type_kind));
d371 1
a371 1
  boolean (*typdef) PARAMS ((PTR, const char *));
d377 1
a377 1
  boolean (*tag) PARAMS ((PTR, const char *));
d380 1
a380 1
  boolean (*int_constant) PARAMS ((PTR, const char *, bfd_vma));
d383 1
a383 1
  boolean (*float_constant) PARAMS ((PTR, const char *, double));
d387 1
a387 1
  boolean (*typed_constant) PARAMS ((PTR, const char *, bfd_vma));
d391 2
a392 2
  boolean (*variable) PARAMS ((PTR, const char *, enum debug_var_kind,
			       bfd_vma));
d395 1
a395 1
     the stack.  The boolean is true if the function is global.  This
d398 1
a398 1
  boolean (*start_function) PARAMS ((PTR, const char *, boolean));
d402 2
a403 2
  boolean (*function_parameter) PARAMS ((PTR, const char *,
					 enum debug_parm_kind, bfd_vma));
d408 1
a408 1
  boolean (*start_block) PARAMS ((PTR, bfd_vma));
d412 1
a412 1
  boolean (*end_block) PARAMS ((PTR, bfd_vma));
d415 1
a415 1
  boolean (*end_function) PARAMS ((PTR));
d418 1
a418 1
  boolean (*lineno) PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d436 1
a436 1
extern boolean debug_set_filename PARAMS ((PTR, const char *));
d441 1
a441 1
extern boolean debug_start_source PARAMS ((PTR, const char *));
d445 1
a445 1
   The boolean indicates whether the function is globally visible.
d450 2
a451 2
extern boolean debug_record_function
  PARAMS ((PTR, const char *, debug_type, boolean, bfd_vma));
d455 1
a455 1
extern boolean debug_record_parameter
d461 1
a461 1
extern boolean debug_end_function PARAMS ((PTR, bfd_vma));
d468 1
a468 1
extern boolean debug_start_block PARAMS ((PTR, bfd_vma));
d474 1
a474 1
extern boolean debug_end_block PARAMS ((PTR, bfd_vma));
d479 1
a479 1
extern boolean debug_record_line PARAMS ((PTR, unsigned long, bfd_vma));
d484 1
a484 1
extern boolean debug_start_common_block PARAMS ((PTR, const char *));
d488 1
a488 1
extern boolean debug_end_common_block PARAMS ((PTR, const char *));
d492 2
a493 1
extern boolean debug_record_int_const PARAMS ((PTR, const char *, bfd_vma));
d497 2
a498 1
extern boolean debug_record_float_const PARAMS ((PTR, const char *, double));
d502 1
a502 1
extern boolean debug_record_typed_const
d507 1
a507 1
extern boolean debug_record_label
d512 1
a512 1
extern boolean debug_record_variable
d529 1
a529 1
/* Make an integer type of a given size.  The boolean argument is true
d532 2
a533 1
extern debug_type debug_make_int_type PARAMS ((PTR, unsigned int, boolean));
d549 2
a550 2
/* Make a structure type.  The second argument is true for a struct,
   false for a union.  The third argument is the size of the struct.
d554 1
a554 1
  PARAMS ((PTR, boolean, bfd_vma, debug_field *));
d560 1
a560 1
   if it is not this object, and a boolean which is true if this
d564 2
a565 2
  PARAMS ((PTR, boolean, bfd_vma, debug_field *, debug_baseclass *,
	   debug_method *, debug_type, boolean));
d580 1
a580 1
   fourth argument is true if the function takes a variable number of
d585 1
a585 1
  PARAMS ((PTR, debug_type, debug_type *, boolean));
d600 1
a600 1
   0 and upper should be -1).  The sixth argument is true if this
d605 1
a605 1
	   boolean));
d608 1
a608 1
   boolean argument is true if this set is actually a bitstring, as in
d611 1
a611 1
extern debug_type debug_make_set_type PARAMS ((PTR, debug_type, boolean));
d624 1
a624 1
   argument is true if the function takes a variable number of
d632 1
a632 1
  PARAMS ((PTR, debug_type, debug_type, debug_type *, boolean));
d655 1
a655 1
  PARAMS ((PTR, debug_type, bfd_vma, boolean, enum debug_visibility));
d695 2
a696 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, boolean,
	   boolean, bfd_vma, debug_type));
d703 2
a704 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, boolean,
	   boolean));
d717 2
a718 1
extern boolean debug_record_type_size PARAMS ((PTR, debug_type, unsigned int));
d749 1
a749 1
   boolean which is set to true if the function takes a variable
d752 2
a753 3
extern const debug_type *debug_get_parameter_types PARAMS ((PTR,
							    debug_type,
							    boolean *));
d798 2
a799 1
extern boolean debug_write PARAMS ((PTR, const struct debug_write_fns *, PTR));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002 Free Software Foundation, Inc.
d172 1
a172 1
  bfd_boolean (*start_compilation_unit) PARAMS ((PTR, const char *));
d177 1
a177 1
  bfd_boolean (*start_source) PARAMS ((PTR, const char *));
d183 1
a183 1
  bfd_boolean (*empty_type) PARAMS ((PTR));
d186 1
a186 1
  bfd_boolean (*void_type) PARAMS ((PTR));
d190 1
a190 1
  bfd_boolean (*int_type) PARAMS ((PTR, unsigned int, bfd_boolean));
d193 1
a193 1
  bfd_boolean (*float_type) PARAMS ((PTR, unsigned int));
d196 1
a196 1
  bfd_boolean (*complex_type) PARAMS ((PTR, unsigned int));
d198 2
a199 2
  /* Push a bfd_boolean type onto the type stack, given the size.  */
  bfd_boolean (*bool_type) PARAMS ((PTR, unsigned int));
d205 2
a206 2
  bfd_boolean (*enum_type)
    PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
d210 1
a210 1
  bfd_boolean (*pointer_type) PARAMS ((PTR));
d216 1
a216 1
     been pushed onto the stack.  The third argument is TRUE if the
d220 1
a220 1
  bfd_boolean (*function_type) PARAMS ((PTR, int, bfd_boolean));
d224 1
a224 1
  bfd_boolean (*reference_type) PARAMS ((PTR));
d228 1
a228 1
  bfd_boolean (*range_type) PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d235 2
a236 2
  bfd_boolean (*array_type)
    PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
d241 1
a241 1
  bfd_boolean (*set_type) PARAMS ((PTR, bfd_boolean));
d247 1
a247 1
  bfd_boolean (*offset_type) PARAMS ((PTR));
d250 1
a250 1
     is TRUE, the top type on the stack is the class to which the
d256 1
a256 1
     argument information is available.  The fourth argument is TRUE
d261 1
a261 1
  bfd_boolean (*method_type) PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
d265 1
a265 1
  bfd_boolean (*const_type) PARAMS ((PTR));
d269 1
a269 1
  bfd_boolean (*volatile_type) PARAMS ((PTR));
d276 1
a276 1
     with tag_type.  The fourth argument is TRUE for a struct, FALSE
d280 2
a281 2
  bfd_boolean (*start_struct_type)
    PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d287 2
a288 2
  bfd_boolean (*struct_field)
    PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
d291 1
a291 1
  bfd_boolean (*end_struct_type) PARAMS ((PTR));
d299 3
a301 3
     TRUE if there is a virtual function table; if there is, the
     seventh argument is TRUE if the virtual function table can be
     found in the type itself, and is FALSE if the type of the object
d304 3
a306 3
  bfd_boolean (*start_class_type)
    PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	     bfd_boolean, bfd_boolean));
d311 3
a313 3
  bfd_boolean (*class_static_member)
    PARAMS ((PTR, const char *, const char *, enum debug_visibility));

d318 2
a319 2
  bfd_boolean (*class_baseclass)
    PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
d327 1
a327 1
  bfd_boolean (*class_start_method) PARAMS ((PTR, const char *));
d336 4
a339 3
  bfd_boolean (*class_method_variant)
    PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	     bfd_boolean, bfd_vma, bfd_boolean));
d345 3
a347 3
  bfd_boolean (*class_static_method_variant)
    PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	     bfd_boolean));
d350 1
a350 1
  bfd_boolean (*class_end_method) PARAMS ((PTR));
d353 1
a353 1
  bfd_boolean (*end_class_type) PARAMS ((PTR));
d357 1
a357 1
  bfd_boolean (*typedef_type) PARAMS ((PTR, const char *));
d368 2
a369 2
  bfd_boolean (*tag_type)
    PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
d372 1
a372 1
  bfd_boolean (*typdef) PARAMS ((PTR, const char *));
d378 1
a378 1
  bfd_boolean (*tag) PARAMS ((PTR, const char *));
d381 1
a381 1
  bfd_boolean (*int_constant) PARAMS ((PTR, const char *, bfd_vma));
d384 1
a384 1
  bfd_boolean (*float_constant) PARAMS ((PTR, const char *, double));
d388 1
a388 1
  bfd_boolean (*typed_constant) PARAMS ((PTR, const char *, bfd_vma));
d392 2
a393 2
  bfd_boolean (*variable)
    PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
d396 1
a396 1
     the stack.  The bfd_boolean is TRUE if the function is global.  This
d399 1
a399 1
  bfd_boolean (*start_function) PARAMS ((PTR, const char *, bfd_boolean));
d403 2
a404 2
  bfd_boolean (*function_parameter)
    PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
d409 1
a409 1
  bfd_boolean (*start_block) PARAMS ((PTR, bfd_vma));
d413 1
a413 1
  bfd_boolean (*end_block) PARAMS ((PTR, bfd_vma));
d416 1
a416 1
  bfd_boolean (*end_function) PARAMS ((PTR));
d419 1
a419 1
  bfd_boolean (*lineno) PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d437 1
a437 1
extern bfd_boolean debug_set_filename PARAMS ((PTR, const char *));
d442 1
a442 1
extern bfd_boolean debug_start_source PARAMS ((PTR, const char *));
d446 1
a446 1
   The bfd_boolean indicates whether the function is globally visible.
d451 2
a452 2
extern bfd_boolean debug_record_function
  PARAMS ((PTR, const char *, debug_type, bfd_boolean, bfd_vma));
d456 1
a456 1
extern bfd_boolean debug_record_parameter
d462 1
a462 1
extern bfd_boolean debug_end_function PARAMS ((PTR, bfd_vma));
d469 1
a469 1
extern bfd_boolean debug_start_block PARAMS ((PTR, bfd_vma));
d475 1
a475 1
extern bfd_boolean debug_end_block PARAMS ((PTR, bfd_vma));
d480 1
a480 1
extern bfd_boolean debug_record_line PARAMS ((PTR, unsigned long, bfd_vma));
d485 1
a485 1
extern bfd_boolean debug_start_common_block PARAMS ((PTR, const char *));
d489 1
a489 1
extern bfd_boolean debug_end_common_block PARAMS ((PTR, const char *));
d493 1
a493 2
extern bfd_boolean debug_record_int_const
  PARAMS ((PTR, const char *, bfd_vma));
d497 1
a497 2
extern bfd_boolean debug_record_float_const
  PARAMS ((PTR, const char *, double));
d501 1
a501 1
extern bfd_boolean debug_record_typed_const
d506 1
a506 1
extern bfd_boolean debug_record_label
d511 1
a511 1
extern bfd_boolean debug_record_variable
d528 1
a528 1
/* Make an integer type of a given size.  The bfd_boolean argument is TRUE
d531 1
a531 2
extern debug_type debug_make_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
d547 2
a548 2
/* Make a structure type.  The second argument is TRUE for a struct,
   FALSE for a union.  The third argument is the size of the struct.
d552 1
a552 1
  PARAMS ((PTR, bfd_boolean, bfd_vma, debug_field *));
d558 1
a558 1
   if it is not this object, and a bfd_boolean which is TRUE if this
d562 2
a563 2
  PARAMS ((PTR, bfd_boolean, bfd_vma, debug_field *, debug_baseclass *,
	   debug_method *, debug_type, bfd_boolean));
d578 1
a578 1
   fourth argument is TRUE if the function takes a variable number of
d583 1
a583 1
  PARAMS ((PTR, debug_type, debug_type *, bfd_boolean));
d598 1
a598 1
   0 and upper should be -1).  The sixth argument is TRUE if this
d603 1
a603 1
	   bfd_boolean));
d606 1
a606 1
   bfd_boolean argument is TRUE if this set is actually a bitstring, as in
d609 1
a609 1
extern debug_type debug_make_set_type PARAMS ((PTR, debug_type, bfd_boolean));
d622 1
a622 1
   argument is TRUE if the function takes a variable number of
d630 1
a630 1
  PARAMS ((PTR, debug_type, debug_type, debug_type *, bfd_boolean));
d653 1
a653 1
  PARAMS ((PTR, debug_type, bfd_vma, bfd_boolean, enum debug_visibility));
d693 2
a694 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, bfd_boolean,
	   bfd_boolean, bfd_vma, debug_type));
d701 2
a702 2
  PARAMS ((PTR, const char *, debug_type, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
d715 1
a715 2
extern bfd_boolean debug_record_type_size
  PARAMS ((PTR, debug_type, unsigned int));
d746 1
a746 1
   bfd_boolean which is set to TRUE if the function takes a variable
d749 3
a751 2
extern const debug_type *debug_get_parameter_types
  PARAMS ((PTR, debug_type, bfd_boolean *));
d796 1
a796 2
extern bfd_boolean debug_write
  PARAMS ((PTR, const struct debug_write_fns *, PTR));
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
d28 1
a28 1
   impetus for this was writing a converter from stabs to HP IEEE-695
d172 1
a172 1
  bfd_boolean (*start_compilation_unit) (void *, const char *);
d177 1
a177 1
  bfd_boolean (*start_source) (void *, const char *);
d183 1
a183 1
  bfd_boolean (*empty_type) (void *);
d186 1
a186 1
  bfd_boolean (*void_type) (void *);
d190 1
a190 1
  bfd_boolean (*int_type) (void *, unsigned int, bfd_boolean);
d193 1
a193 1
  bfd_boolean (*float_type) (void *, unsigned int);
d196 1
a196 1
  bfd_boolean (*complex_type) (void *, unsigned int);
d199 1
a199 1
  bfd_boolean (*bool_type) (void *, unsigned int);
d206 1
a206 1
    (void *, const char *, const char **, bfd_signed_vma *);
d210 1
a210 1
  bfd_boolean (*pointer_type) (void *);
d220 1
a220 1
  bfd_boolean (*function_type) (void *, int, bfd_boolean);
d224 1
a224 1
  bfd_boolean (*reference_type) (void *);
d228 1
a228 1
  bfd_boolean (*range_type) (void *, bfd_signed_vma, bfd_signed_vma);
d236 1
a236 1
    (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
d241 1
a241 1
  bfd_boolean (*set_type) (void *, bfd_boolean);
d247 1
a247 1
  bfd_boolean (*offset_type) (void *);
d261 1
a261 1
  bfd_boolean (*method_type) (void *, bfd_boolean, int, bfd_boolean);
d265 1
a265 1
  bfd_boolean (*const_type) (void *);
d269 1
a269 1
  bfd_boolean (*volatile_type) (void *);
d281 1
a281 1
    (void *, const char *, unsigned int, bfd_boolean, unsigned int);
d288 1
a288 1
    (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
d291 1
a291 1
  bfd_boolean (*end_struct_type) (void *);
d305 2
a306 2
    (void *, const char *, unsigned int, bfd_boolean, unsigned int,
     bfd_boolean, bfd_boolean);
d312 1
a312 1
    (void *, const char *, const char *, enum debug_visibility);
d319 1
a319 1
    (void *, bfd_vma, bfd_boolean, enum debug_visibility);
d327 1
a327 1
  bfd_boolean (*class_start_method) (void *, const char *);
d337 2
a338 2
    (void *, const char *, enum debug_visibility, bfd_boolean,
     bfd_boolean, bfd_vma, bfd_boolean);
d345 2
a346 2
    (void *, const char *, enum debug_visibility, bfd_boolean,
     bfd_boolean);
d349 1
a349 1
  bfd_boolean (*class_end_method) (void *);
d352 1
a352 1
  bfd_boolean (*end_class_type) (void *);
d356 1
a356 1
  bfd_boolean (*typedef_type) (void *, const char *);
d368 1
a368 1
    (void *, const char *, unsigned int, enum debug_type_kind);
d371 1
a371 1
  bfd_boolean (*typdef) (void *, const char *);
d377 1
a377 1
  bfd_boolean (*tag) (void *, const char *);
d380 1
a380 1
  bfd_boolean (*int_constant) (void *, const char *, bfd_vma);
d383 1
a383 1
  bfd_boolean (*float_constant) (void *, const char *, double);
d387 1
a387 1
  bfd_boolean (*typed_constant) (void *, const char *, bfd_vma);
d392 1
a392 1
    (void *, const char *, enum debug_var_kind, bfd_vma);
d398 1
a398 1
  bfd_boolean (*start_function) (void *, const char *, bfd_boolean);
d403 1
a403 1
    (void *, const char *, enum debug_parm_kind, bfd_vma);
d408 1
a408 1
  bfd_boolean (*start_block) (void *, bfd_vma);
d412 1
a412 1
  bfd_boolean (*end_block) (void *, bfd_vma);
d415 1
a415 1
  bfd_boolean (*end_function) (void *);
d418 1
a418 1
  bfd_boolean (*lineno) (void *, const char *, unsigned long, bfd_vma);
d431 1
a431 1
extern void *debug_init (void);
d436 1
a436 1
extern bfd_boolean debug_set_filename (void *, const char *);
d441 1
a441 1
extern bfd_boolean debug_start_source (void *, const char *);
d451 1
a451 1
  (void *, const char *, debug_type, bfd_boolean, bfd_vma);
d456 1
a456 1
  (void *, const char *, debug_type, enum debug_parm_kind, bfd_vma);
d461 1
a461 1
extern bfd_boolean debug_end_function (void *, bfd_vma);
d468 1
a468 1
extern bfd_boolean debug_start_block (void *, bfd_vma);
d474 1
a474 1
extern bfd_boolean debug_end_block (void *, bfd_vma);
d479 1
a479 1
extern bfd_boolean debug_record_line (void *, unsigned long, bfd_vma);
d484 1
a484 1
extern bfd_boolean debug_start_common_block (void *, const char *);
d488 1
a488 1
extern bfd_boolean debug_end_common_block (void *, const char *);
d492 2
a493 1
extern bfd_boolean debug_record_int_const (void *, const char *, bfd_vma);
d497 2
a498 1
extern bfd_boolean debug_record_float_const (void *, const char *, double);
d503 1
a503 1
  (void *, const char *, debug_type, bfd_vma);
d508 1
a508 1
  (void *, const char *, debug_type, bfd_vma);
d513 1
a513 1
  (void *, const char *, debug_type, enum debug_var_kind, bfd_vma);
d523 1
a523 1
  (void *, debug_type *, const char *);
d527 1
a527 1
extern debug_type debug_make_void_type (void *);
d532 2
a533 1
extern debug_type debug_make_int_type (void *, unsigned int, bfd_boolean);
d539 1
a539 1
extern debug_type debug_make_float_type (void *, unsigned int);
d543 1
a543 1
extern debug_type debug_make_bool_type (void *, unsigned int);
d547 1
a547 1
extern debug_type debug_make_complex_type (void *, unsigned int);
d554 1
a554 1
  (void *, bfd_boolean, bfd_vma, debug_field *);
d564 2
a565 2
  (void *, bfd_boolean, bfd_vma, debug_field *, debug_baseclass *,
   debug_method *, debug_type, bfd_boolean);
d571 1
a571 1
  (void *, const char **, bfd_signed_vma *);
d575 2
a576 1
extern debug_type debug_make_pointer_type (void *, debug_type);
d585 1
a585 1
  (void *, debug_type, debug_type *, bfd_boolean);
d589 1
a589 1
extern debug_type debug_make_reference_type (void *, debug_type);
d594 1
a594 1
  (void *, debug_type, bfd_signed_vma, bfd_signed_vma);
d604 2
a605 2
  (void *, debug_type, debug_type, bfd_signed_vma, bfd_signed_vma,
   bfd_boolean);
d611 1
a611 1
extern debug_type debug_make_set_type (void *, debug_type, bfd_boolean);
d618 2
a619 1
extern debug_type debug_make_offset_type (void *, debug_type, debug_type);
d632 1
a632 1
  (void *, debug_type, debug_type, debug_type *, bfd_boolean);
d636 1
a636 1
extern debug_type debug_make_const_type (void *, debug_type);
d640 1
a640 1
extern debug_type debug_make_volatile_type (void *, debug_type);
d646 1
a646 1
  (void *, const char *, enum debug_type_kind);
d655 1
a655 1
  (void *, debug_type, bfd_vma, bfd_boolean, enum debug_visibility);
d664 2
a665 1
  (void *, const char *, debug_type, bfd_vma, bfd_vma, enum debug_visibility);
d674 2
a675 1
  (void *, const char *, debug_type, const char *, enum debug_visibility);
d683 1
a683 1
  (void *, const char *, debug_method_variant *);
d695 2
a696 2
  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,
   bfd_boolean, bfd_vma, debug_type);
d703 2
a704 2
  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,
   bfd_boolean);
d708 1
a708 1
extern debug_type debug_name_type (void *, const char *, debug_type);
d713 1
a713 1
extern debug_type debug_tag_type (void *, const char *, debug_type);
d717 2
a718 1
extern bfd_boolean debug_record_type_size (void *, debug_type, unsigned int);
d722 1
a722 1
extern debug_type debug_find_named_type (void *, const char *);
d727 1
a727 1
  (void *, const char *, enum debug_type_kind);
d731 1
a731 1
extern enum debug_type_kind debug_get_type_kind (void *, debug_type);
d735 1
a735 1
extern const char *debug_get_type_name (void *, debug_type);
d739 1
a739 1
extern bfd_vma debug_get_type_size (void *, debug_type);
d743 1
a743 1
extern debug_type debug_get_return_type (void *, debug_type);
d753 1
a753 1
  (void *, debug_type, bfd_boolean *);
d758 1
a758 1
extern debug_type debug_get_target_type (void *, debug_type);
d763 1
a763 1
extern const debug_field *debug_get_fields (void *, debug_type);
d767 1
a767 1
extern debug_type debug_get_field_type (void *, debug_field);
d771 1
a771 1
extern const char *debug_get_field_name (void *, debug_field);
d776 1
a776 1
extern bfd_vma debug_get_field_bitpos (void *, debug_field);
d781 1
a781 1
extern bfd_vma debug_get_field_bitsize (void *, debug_field);
d785 2
a786 1
extern enum debug_visibility debug_get_field_visibility (void *, debug_field);
d791 1
a791 1
extern const char *debug_get_field_physname (void *, debug_field);
d795 1
a795 1
   first void * is the debugging handle.  The second void * is a handle
d799 1
a799 1
  (void *, const struct debug_write_fns *, void *);
@


