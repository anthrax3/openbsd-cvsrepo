head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.20
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.18
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.14
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	new-binutils:1.5.0.4
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.13;
commitid	dbwlUkpK0xDlII16;

1.13
date	2010.07.16.21.44.06;	author mpf;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.02.20.45.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.03.07.16.25;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2001.06.09.22.29.30;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.12.22.45.17;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.19.11.31;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.09.14.14.20.11;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.55;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.03.08;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.48.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.51;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.51;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.52;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.49.51;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.29;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.16.16;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.07;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.06.18;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.15.42;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.04;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.03;	author miod;	state Exp;
branches;
next	;

1.9.4.1
date	2004.02.07.22.05.29;	author brad;	state Exp;
branches;
next	;

1.9.6.1
date	2004.02.07.22.04.05;	author brad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* objcopy.c -- copy object file from input to output, optionally massaging it.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "progress.h"
#include "bucomm.h"
#include "getopt.h"
#include "libiberty.h"
#include "budbg.h"
#include "filenames.h"
#include "fnmatch.h"
#include "elf-bfd.h"
#include <sys/stat.h>

/* A list of symbols to explicitly strip out, or to keep.  A linked
   list is good enough for a small number from the command line, but
   this will slow things down a lot if many symbols are being
   deleted.  */

struct symlist
{
  const char *name;
  struct symlist *next;
};

/* A list to support redefine_sym.  */
struct redefine_node
{
  char *source;
  char *target;
  struct redefine_node *next;
};

typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename *section_rename_list;

#define RETURN_NONFATAL(s) {bfd_nonfatal (s); status = 1; return;}

static asymbol **isympp = NULL;	/* Input symbols.  */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping.  */

/* If `copy_byte' >= 0, copy only that byte of every `interleave' bytes.  */
static int copy_byte = -1;
static int interleave = 4;

static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
static int status = 0;		/* Exit status.  */

enum strip_action
  {
    STRIP_UNDEF,
    STRIP_NONE,			/* Don't strip.  */
    STRIP_DEBUG,		/* Strip all debugger symbols.  */
    STRIP_UNNEEDED,		/* Strip unnecessary symbols.  */
    STRIP_NONDEBUG,		/* Strip everything but debug info.  */
    STRIP_ALL			/* Strip all symbols.  */
  };

/* Which symbols to remove.  */
static enum strip_action strip_symbols;

enum locals_action
  {
    LOCALS_UNDEF,
    LOCALS_START_L,		/* Discard locals starting with L.  */
    LOCALS_ALL			/* Discard all locals.  */
  };

/* Which local symbols to remove.  Overrides STRIP_ALL.  */
static enum locals_action discard_locals;

/* What kind of change to perform.  */
enum change_action
{
  CHANGE_IGNORE,
  CHANGE_MODIFY,
  CHANGE_SET
};

/* Structure used to hold lists of sections and actions to take.  */
struct section_list
{
  struct section_list * next;	   /* Next section to change.  */
  const char *		name;	   /* Section name.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  enum change_action	change_lma;/* Whether to change or set LMA.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
  flagword		flags;	   /* What to set the section flags to.	 */
};

static struct section_list *change_sections;

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;

/* Changes to the start address.  */
static bfd_vma change_start = 0;
static bfd_boolean set_start_set = FALSE;
static bfd_vma set_start;

/* Changes to section addresses.  */
static bfd_vma change_section_address = 0;

/* Filling gaps between sections.  */
static bfd_boolean gap_fill_set = FALSE;
static bfd_byte gap_fill = 0;

/* Pad to a given address.  */
static bfd_boolean pad_to_set = FALSE;
static bfd_vma pad_to;

/* Use alternate machine code?  */
static int use_alt_mach_code = 0;

/* Output BFD flags user wants to set or clear */
static flagword bfd_flags_to_set;
static flagword bfd_flags_to_clear;

/* List of sections to add.  */
struct section_add
{
  /* Next section to add.  */
  struct section_add *next;
  /* Name of section to add.  */
  const char *name;
  /* Name of file holding section contents.  */
  const char *filename;
  /* Size of file.  */
  size_t size;
  /* Contents of file.  */
  bfd_byte *contents;
  /* BFD section, after it has been added.  */
  asection *section;
};

/* List of sections to add to the output BFD.  */
static struct section_add *add_sections;

/* If non-NULL the argument to --add-gnu-debuglink.
   This should be the filename to store in the .gnu_debuglink section.  */
static const char * gnu_debuglink_filename = NULL;

/* Whether to convert debugging information.  */
static bfd_boolean convert_debugging = FALSE;

/* Whether to change the leading character in symbol names.  */
static bfd_boolean change_leading_char = FALSE;

/* Whether to remove the leading character from global symbol names.  */
static bfd_boolean remove_leading_char = FALSE;

/* Whether to permit wildcard in symbol comparison.  */
static bfd_boolean wildcard = FALSE;

/* List of symbols to strip, keep, localize, keep-global, weaken,
   or redefine.  */
static struct symlist *strip_specific_list = NULL;
static struct symlist *keep_specific_list = NULL;
static struct symlist *localize_specific_list = NULL;
static struct symlist *keepglobal_specific_list = NULL;
static struct symlist *weaken_specific_list = NULL;
static struct redefine_node *redefine_sym_list = NULL;

/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;

/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
enum command_line_switch
  {
    OPTION_ADD_SECTION=150,
    OPTION_CHANGE_ADDRESSES,
    OPTION_CHANGE_LEADING_CHAR,
    OPTION_CHANGE_START,
    OPTION_CHANGE_SECTION_ADDRESS,
    OPTION_CHANGE_SECTION_LMA,
    OPTION_CHANGE_SECTION_VMA,
    OPTION_CHANGE_WARNINGS,
    OPTION_DEBUGGING,
    OPTION_GAP_FILL,
    OPTION_NO_CHANGE_WARNINGS,
    OPTION_PAD_TO,
    OPTION_REMOVE_LEADING_CHAR,
    OPTION_SET_SECTION_FLAGS,
    OPTION_SET_START,
    OPTION_STRIP_UNNEEDED,
    OPTION_WEAKEN,
    OPTION_REDEFINE_SYM,
    OPTION_REDEFINE_SYMS,
    OPTION_SREC_LEN,
    OPTION_SREC_FORCES3,
    OPTION_STRIP_SYMBOLS,
    OPTION_KEEP_SYMBOLS,
    OPTION_LOCALIZE_SYMBOLS,
    OPTION_KEEPGLOBAL_SYMBOLS,
    OPTION_WEAKEN_SYMBOLS,
    OPTION_RENAME_SECTION,
    OPTION_ALT_MACH_CODE,
    OPTION_PREFIX_SYMBOLS,
    OPTION_PREFIX_SECTIONS,
    OPTION_PREFIX_ALLOC_SECTIONS,
    OPTION_FORMATS_INFO,
    OPTION_ADD_GNU_DEBUGLINK,
    OPTION_ONLY_KEEP_DEBUG,
    OPTION_READONLY_TEXT,
    OPTION_WRITABLE_TEXT,
    OPTION_PURE,
    OPTION_IMPURE
  };

/* Options to handle if running as "strip".  */

static struct option strip_options[] =
{
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"help", no_argument, 0, 'h'},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"keep-symbol", required_argument, 0, 'K'},
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"output-file", required_argument, 0, 'o'},
  {"preserve-dates", no_argument, 0, 'p'},
  {"remove-section", required_argument, 0, 'R'},
  {"strip-all", no_argument, 0, 's'},
  {"strip-debug", no_argument, 0, 'S'},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-symbol", required_argument, 0, 'N'},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"wildcard", no_argument, 0, 'w'},
  {0, no_argument, 0, 0}
};

/* Options to handle if running as "objcopy".  */

static struct option copy_options[] =
{
  {"add-gnu-debuglink", required_argument, 0, OPTION_ADD_GNU_DEBUGLINK},
  {"add-section", required_argument, 0, OPTION_ADD_SECTION},
  {"adjust-start", required_argument, 0, OPTION_CHANGE_START},
  {"adjust-vma", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"adjust-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"adjust-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
  {"byte", required_argument, 0, 'b'},
  {"change-addresses", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"change-leading-char", no_argument, 0, OPTION_CHANGE_LEADING_CHAR},
  {"change-section-address", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"change-section-lma", required_argument, 0, OPTION_CHANGE_SECTION_LMA},
  {"change-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_VMA},
  {"change-start", required_argument, 0, OPTION_CHANGE_START},
  {"change-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"debugging", no_argument, 0, OPTION_DEBUGGING},
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"gap-fill", required_argument, 0, OPTION_GAP_FILL},
  {"help", no_argument, 0, 'h'},
  {"impure", no_argument, 0, OPTION_IMPURE},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"interleave", required_argument, 0, 'i'},
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"keep-symbol", required_argument, 0, 'K'},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
  {"no-adjust-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"no-change-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
  {"only-section", required_argument, 0, 'j'},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"pad-to", required_argument, 0, OPTION_PAD_TO},
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
  {"preserve-dates", no_argument, 0, 'p'},
  {"pure", no_argument, 0, OPTION_PURE},
  {"readonly-text", no_argument, 0, OPTION_READONLY_TEXT},
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"redefine-syms", required_argument, 0, OPTION_REDEFINE_SYMS},
  {"remove-leading-char", no_argument, 0, OPTION_REMOVE_LEADING_CHAR},
  {"remove-section", required_argument, 0, 'R'},
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
  {"set-section-flags", required_argument, 0, OPTION_SET_SECTION_FLAGS},
  {"set-start", required_argument, 0, OPTION_SET_START},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"strip-all", no_argument, 0, 'S'},
  {"strip-debug", no_argument, 0, 'g'},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-symbol", required_argument, 0, 'N'},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"weaken", no_argument, 0, OPTION_WEAKEN},
  {"weaken-symbol", required_argument, 0, 'W'},
  {"weaken-symbols", required_argument, 0, OPTION_WEAKEN_SYMBOLS},
  {"wildcard", no_argument, 0, 'w'},
  {"writable-text", no_argument, 0, OPTION_WRITABLE_TEXT},
  {0, no_argument, 0, 0}
};

/* IMPORTS */
extern char *program_name;

/* This flag distinguishes between strip and objcopy:
   1 means this is 'strip'; 0 means this is 'objcopy'.
   -1 means if we should use argv[0] to decide.  */
extern int is_strip;

/* The maximum length of an S record.  This variable is declared in srec.c
   and can be modified by the --srec-len parameter.  */
extern unsigned int Chunk;

/* Restrict the generation of Srecords to type S3 only.
   This variable is declare in bfd/srec.c and can be toggled
   on by the --srec-forceS3 command line switch.  */
extern bfd_boolean S3Forced;

/* Defined in bfd/binary.c.  Used to set architecture and machine of input
   binary files.  */
extern enum bfd_architecture  bfd_external_binary_architecture;
extern unsigned long          bfd_external_machine;

/* Forward declarations.  */
static void setup_section (bfd *, asection *, void *);
static void copy_section (bfd *, asection *, void *);
static void get_sections (bfd *, asection *, void *);
static int compare_section_lma (const void *, const void *);
static void mark_symbols_used_in_relocations (bfd *, asection *, void *);
static bfd_boolean write_debugging_info (bfd *, void *, long *, asymbol ***);
static const char *lookup_sym_redefinition (const char *);

static void
copy_usage (FILE *stream, int exit_status)
{
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
     --debugging                   Convert debugging information, if possible\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -j --only-section <name>         Only copy section <name> into the output\n\
     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\n\
  -R --remove-section <name>       Remove section <name> from the output\n\
  -S --strip-all                   Remove all symbol and relocation information\n\
  -g --strip-debug                 Remove all debugging symbols & sections\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
     --only-keep-debug             Strip everything but the debug information\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\n\
  -G --keep-global-symbol <name>   Localize all symbols except <name>\n\
  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\n\
     --weaken                      Force all global symbols to be marked as weak\n\
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -i --interleave <number>         Only copy one out of every <number> bytes\n\
  -b --byte <num>                  Select byte <num> in every interleaved block\n\
     --gap-fill <val>              Fill gaps between sections with <val>\n\
     --pad-to <addr>               Pad the last section up to address <addr>\n\
     --set-start <addr>            Set the start address to <addr>\n\
    {--change-start|--adjust-start} <incr>\n\
                                   Add <incr> to the start address\n\
    {--change-addresses|--adjust-vma} <incr>\n\
                                   Add <incr> to LMA, VMA and start addresses\n\
    {--change-section-address|--adjust-section-vma} <name>{=|+|-}<val>\n\
                                   Change LMA and VMA of section <name> by <val>\n\
     --change-section-lma <name>{=|+|-}<val>\n\
                                   Change the LMA of section <name> by <val>\n\
     --change-section-vma <name>{=|+|-}<val>\n\
                                   Change the VMA of section <name> by <val>\n\
    {--[no-]change-warnings|--[no-]adjust-warnings}\n\
                                   Warn if a named section does not exist\n\
     --set-section-flags <name>=<flags>\n\
                                   Set section <name>'s properties to <flags>\n\
     --add-section <name>=<file>   Add section <name> found in <file> to output\n\
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
     --change-leading-char         Force output format's leading character style\n\
     --remove-leading-char         Remove leading character from global symbols\n\
     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n\
     --redefine-syms <file>        --redefine-sym for all symbol pairs \n\
                                     listed in <file>\n\
     --srec-len <number>           Restrict the length of generated Srecords\n\
     --srec-forceS3                Restrict the type of generated Srecords to S3\n\
     --strip-symbols <file>        -N for all symbols listed in <file>\n\
     --keep-symbols <file>         -K for all symbols listed in <file>\n\
     --localize-symbols <file>     -L for all symbols listed in <file>\n\
     --keep-global-symbols <file>  -G for all symbols listed in <file>\n\
     --weaken-symbols <file>       -W for all symbols listed in <file>\n\
     --alt-machine-code <index>    Use alternate machine code for output\n\
     --writable-text               Mark the output text as writable\n\
     --readonly-text               Make the output text write protected\n\
     --pure                        Mark the output file as demand paged\n\
     --impure                      Mark the output file as impure\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
"));
  list_supported_targets (program_name, stream);
  if (exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

static void
strip_usage (FILE *stream, int exit_status)
{
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -R --remove-section=<name>       Remove section <name> from the output\n\
  -s --strip-all                   Remove all symbol and relocation information\n\
  -g -S -d --strip-debug           Remove all debugging symbols & sections\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
     --only-keep-debug             Strip everything but the debug information\n\
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
  -o <file>                        Place stripped output into <file>\n\
"));

  list_supported_targets (program_name, stream);
  if (exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

/* Parse section flags into a flagword, with a fatal error if the
   string can't be parsed.  */

static flagword
parse_flags (const char *s)
{
  flagword ret;
  const char *snext;
  int len;

  ret = SEC_NO_FLAGS;

  do
    {
      snext = strchr (s, ',');
      if (snext == NULL)
	len = strlen (s);
      else
	{
	  len = snext - s;
	  ++snext;
	}

      if (0) ;
#define PARSE_FLAG(fname,fval) \
  else if (strncasecmp (fname, s, len) == 0) ret |= fval
      PARSE_FLAG ("alloc", SEC_ALLOC);
      PARSE_FLAG ("load", SEC_LOAD);
      PARSE_FLAG ("noload", SEC_NEVER_LOAD);
      PARSE_FLAG ("readonly", SEC_READONLY);
      PARSE_FLAG ("debug", SEC_DEBUGGING);
      PARSE_FLAG ("code", SEC_CODE);
      PARSE_FLAG ("data", SEC_DATA);
      PARSE_FLAG ("rom", SEC_ROM);
      PARSE_FLAG ("share", SEC_SHARED);
      PARSE_FLAG ("contents", SEC_HAS_CONTENTS);
#undef PARSE_FLAG
      else
	{
	  char *copy;

	  copy = xmalloc (len + 1);
	  strncpy (copy, s, len);
	  copy[len] = '\0';
	  non_fatal (_("unrecognized section flag `%s'"), copy);
	  fatal (_("supported flags: %s"),
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents");
	}

      s = snext;
    }
  while (s != NULL);

  return ret;
}

/* Find and optionally add an entry in the change_sections list.  */

static struct section_list *
find_section_list (const char *name, bfd_boolean add)
{
  struct section_list *p;

  for (p = change_sections; p != NULL; p = p->next)
    if (strcmp (p->name, name) == 0)
      return p;

  if (! add)
    return NULL;

  p = xmalloc (sizeof (struct section_list));
  p->name = name;
  p->used = FALSE;
  p->remove = FALSE;
  p->copy = FALSE;
  p->change_vma = CHANGE_IGNORE;
  p->change_lma = CHANGE_IGNORE;
  p->vma_val = 0;
  p->lma_val = 0;
  p->set_flags = FALSE;
  p->flags = 0;

  p->next = change_sections;
  change_sections = p;

  return p;
}

/* Add a symbol to strip_specific_list.  */

static void
add_specific_symbol (const char *name, struct symlist **list)
{
  struct symlist *tmp_list;

  tmp_list = xmalloc (sizeof (struct symlist));
  tmp_list->name = name;
  tmp_list->next = *list;
  *list = tmp_list;
}

/* Add symbols listed in `filename' to strip_specific_list.  */

#define IS_WHITESPACE(c)      ((c) == ' ' || (c) == '\t')
#define IS_LINE_TERMINATOR(c) ((c) == '\n' || (c) == '\r' || (c) == '\0')

static void
add_specific_symbols (const char *filename, struct symlist **list)
{
  off_t  size;
  FILE * f;
  char * line;
  char * buffer;
  unsigned int line_count;

  size = get_file_size (filename);
  if (size == 0)
    return;

  buffer = xmalloc (size + 2);
  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    fatal (_("cannot open '%s': %s"), filename, strerror (errno));

  if (fread (buffer, 1, size, f) == 0 || ferror (f))
    fatal (_("%s: fread failed"), filename);

  fclose (f);
  buffer [size] = '\n';
  buffer [size + 1] = '\0';

  line_count = 1;

  for (line = buffer; * line != '\0'; line ++)
    {
      char * eol;
      char * name;
      char * name_end;
      int finished = FALSE;

      for (eol = line;; eol ++)
	{
	  switch (* eol)
	    {
	    case '\n':
	      * eol = '\0';
	      /* Cope with \n\r.  */
	      if (eol[1] == '\r')
		++ eol;
	      finished = TRUE;
	      break;

	    case '\r':
	      * eol = '\0';
	      /* Cope with \r\n.  */
	      if (eol[1] == '\n')
		++ eol;
	      finished = TRUE;
	      break;

	    case 0:
	      finished = TRUE;
	      break;

	    case '#':
	      /* Line comment, Terminate the line here, in case a
		 name is present and then allow the rest of the
		 loop to find the real end of the line.  */
	      * eol = '\0';
	      break;

	    default:
	      break;
	    }

	  if (finished)
	    break;
	}

      /* A name may now exist somewhere between 'line' and 'eol'.
	 Strip off leading whitespace and trailing whitespace,
	 then add it to the list.  */
      for (name = line; IS_WHITESPACE (* name); name ++)
	;
      for (name_end = name;
	   (! IS_WHITESPACE (* name_end))
	   && (! IS_LINE_TERMINATOR (* name_end));
	   name_end ++)
	;

      if (! IS_LINE_TERMINATOR (* name_end))
	{
	  char * extra;

	  for (extra = name_end + 1; IS_WHITESPACE (* extra); extra ++)
	    ;

	  if (! IS_LINE_TERMINATOR (* extra))
	    non_fatal (_("Ignoring rubbish found on line %d of %s"),
		       line_count, filename);
	}

      * name_end = '\0';

      if (name_end > name)
	add_specific_symbol (name, list);

      /* Advance line pointer to end of line.  The 'eol ++' in the for
	 loop above will then advance us to the start of the next line.  */
      line = eol;
      line_count ++;
    }
}

/* See whether a symbol should be stripped or kept based on
   strip_specific_list and keep_symbols.  */

static bfd_boolean
is_specified_symbol (const char *name, struct symlist *list)
{
  struct symlist *tmp_list;

  if (wildcard)
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (*(tmp_list->name) != '!')
	  {
	    if (!fnmatch (tmp_list->name, name, 0))
	      return TRUE;
	  }
	else
	  {
	    if (fnmatch (tmp_list->name + 1, name, 0))
	      return TRUE;
	  }
    }
  else
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (strcmp (name, tmp_list->name) == 0)
	  return TRUE;
    }

  return FALSE;
}

/* See if a section is being removed.  */

static bfd_boolean
is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  if (sections_removed || sections_copied)
    {
      struct section_list *p;

      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);

      if (sections_removed && p != NULL && p->remove)
	return TRUE;
      if (sections_copied && (p == NULL || ! p->copy))
	return TRUE;
    }

  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0)
    {
      if (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging)
	return TRUE;

      if (strip_symbols == STRIP_NONDEBUG)
	return FALSE;
    }

  return FALSE;
}

/* Choose which symbol entries to copy; put the result in OSYMS.
   We don't copy in place, because that confuses the relocs.
   Return the number of symbols to print.  */

static unsigned int
filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
		asymbol **isyms, long symcount)
{
  asymbol **from = isyms, **to = osyms;
  long src_count = 0, dst_count = 0;
  int relocatable = (abfd->flags & (HAS_RELOC | EXEC_P | DYNAMIC))
		    == HAS_RELOC;

  for (; src_count < symcount; src_count++)
    {
      asymbol *sym = from[src_count];
      flagword flags = sym->flags;
      char *name = (char *) bfd_asymbol_name (sym);
      int keep;
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;

      undefined = bfd_is_und_section (bfd_get_section (sym));

      if (redefine_sym_list)
	{
	  char *old_name, *new_name;

	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = xmalloc (1 + strlen (prefix_symbols_string)
			     + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
	}

      if (strip_symbols == STRIP_ALL)
	keep = 0;
      else if ((flags & BSF_KEEP) != 0		/* Used in relocation.  */
	       || ((flags & BSF_SECTION_SYM) != 0
		   && ((*bfd_get_section (sym)->symbol_ptr_ptr)->flags
		       & BSF_KEEP) != 0))
	keep = 1;
      else if (relocatable			/* Relocatable file.  */
	       && (flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
	keep = 1;
      else if (bfd_decode_symclass (sym) == 'I')
	/* Global symbols in $idata sections need to be retained
	   even if relocatable is FALSE.  External users of the
	   library containing the $idata section may reference these
	   symbols.  */
	keep = 1;
      else if ((flags & BSF_GLOBAL) != 0	/* Global symbol.  */
	       || (flags & BSF_WEAK) != 0
	       || undefined
	       || bfd_is_com_section (bfd_get_section (sym)))
	keep = strip_symbols != STRIP_UNNEEDED;
      else if ((flags & BSF_DEBUGGING) != 0)	/* Debugging symbol.  */
	keep = (strip_symbols != STRIP_DEBUG
		&& strip_symbols != STRIP_UNNEEDED
		&& ! convert_debugging);
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
      else			/* Local symbol.  */
	keep = (strip_symbols != STRIP_UNNEEDED
		&& (discard_locals != LOCALS_ALL
		    && (discard_locals != LOCALS_START_L
			|| ! bfd_is_local_label (abfd, sym))));

      if (keep && is_specified_symbol (name, strip_specific_list))
	keep = 0;
      if (!keep && is_specified_symbol (name, keep_specific_list))
	keep = 1;
      if (keep && is_strip_section (abfd, bfd_get_section (sym)))
	keep = 0;

      if (keep && (flags & BSF_GLOBAL) != 0
	  && (weaken || is_specified_symbol (name, weaken_specific_list)))
	{
	  sym->flags &=~ BSF_GLOBAL;
	  sym->flags |= BSF_WEAK;
	}
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
	  && (is_specified_symbol (name, localize_specific_list)
	      || (keepglobal_specific_list != NULL
		  && ! is_specified_symbol (name, keepglobal_specific_list))))
	{
	  sym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
	  sym->flags |= BSF_LOCAL;
	}

      if (keep)
	to[dst_count++] = sym;
    }

  to[dst_count] = NULL;

  return dst_count;
}

/* Find the redefined name of symbol SOURCE.  */

static const char *
lookup_sym_redefinition (const char *source)
{
  struct redefine_node *list;

  for (list = redefine_sym_list; list != NULL; list = list->next)
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
}

/* Add a node to a symbol redefine list.  */

static void
redefine_list_append (const char *cause, const char *source, const char *target)
{
  struct redefine_node **p;
  struct redefine_node *list;
  struct redefine_node *new_node;

  for (p = &redefine_sym_list; (list = *p) != NULL; p = &list->next)
    {
      if (strcmp (source, list->source) == 0)
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       cause, source);

      if (strcmp (target, list->target) == 0)
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       cause, target);
    }

  new_node = xmalloc (sizeof (struct redefine_node));

  new_node->source = strdup (source);
  new_node->target = strdup (target);
  new_node->next = NULL;

  *p = new_node;
}

/* Handle the --redefine-syms option.  Read lines containing "old new"
   from the file, and add them to the symbol redefine list.  */

static void
add_redefine_syms_file (const char *filename)
{
  FILE *file;
  char *buf;
  size_t bufsize;
  size_t len;
  size_t outsym_off;
  int c, lineno;

  file = fopen (filename, "r");
  if (file == NULL)
    fatal (_("couldn't open symbol redefinition file %s (error: %s)"),
	   filename, strerror (errno));

  bufsize = 100;
  buf = xmalloc (bufsize);

  lineno = 1;
  c = getc (file);
  len = 0;
  outsym_off = 0;
  while (c != EOF)
    {
      /* Collect the input symbol name.  */
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space between the symbol names.  */
      while (IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#' || IS_LINE_TERMINATOR (c))
	goto comment;
      if (c == EOF)
	break;

      /* Collect the output symbol name.  */
      outsym_off = len;
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space at end of line.  */
      while (! IS_LINE_TERMINATOR(c) && c != EOF && IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#')
	goto comment;
      /* Handle \r\n.  */
      if ((c == '\r' && (c = getc (file)) == '\n')
	  || c == '\n' || c == EOF)
	{
 end_of_line:
	  /* Append the redefinition to the list.  */
	  if (buf[0] != '\0')
	    redefine_list_append (filename, &buf[0], &buf[outsym_off]);

	  lineno++;	
	  len = 0;
	  outsym_off = 0;
	  if (c == EOF)
	    break;
	  c = getc (file);
	  continue;
	}
      else
	fatal (_("%s: garbage at end of line %d"), filename, lineno);
 comment:
      if (len != 0 && (outsym_off == 0 || outsym_off == len))
	fatal (_("%s: missing new symbol name at line %d"), filename, lineno);
      buf[len++] = '\0';

      /* Eat the rest of the line and finish it.  */
      while (c != '\n' && c != EOF)
	c = getc (file);
      goto end_of_line;
    }

  if (len != 0)
    fatal (_("%s: premature end of file at line %d"), filename, lineno);

  free (buf);
}

/* Copy object file IBFD onto OBFD.
   Returns TRUE upon success, FALSE otherwise.  */

static bfd_boolean
copy_object (bfd *ibfd, bfd *obfd)
{
  bfd_vma start;
  long symcount;
  asection **osections = NULL;
  asection *gnu_debuglink_section = NULL;
  bfd_size_type *gaps = NULL;
  bfd_size_type max_gap = 0;
  long symsize;
  void *dhandle;
  enum bfd_architecture iarch;
  unsigned int imach;

  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    fatal (_("Unable to change endianness of input file(s)"));

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    {
      bfd_nonfatal (bfd_get_filename (obfd));
      return FALSE;
    }

  if (verbose)
    printf (_("copy from %s(%s) to %s(%s)\n"),
	    bfd_get_filename (ibfd), bfd_get_target (ibfd),
	    bfd_get_filename (obfd), bfd_get_target (obfd));

  if (set_start_set)
    start = set_start;
  else
    start = bfd_get_start_address (ibfd);
  start += change_start;

  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      flagword flags;

      flags = bfd_get_file_flags (ibfd);
      flags |= bfd_flags_to_set;
      flags &= ~bfd_flags_to_clear;
      flags &= bfd_applicable_file_flags (obfd);

      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd, flags))
	{
	  bfd_nonfatal (bfd_get_filename (ibfd));
	  return FALSE;
	}
    }

  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
    {
      if (bfd_get_arch (ibfd) == bfd_arch_unknown)
	fatal (_("Unable to recognise the format of the input file %s"),
	       bfd_get_filename (ibfd));
      else
	{
	  non_fatal (_("Warning: Output file cannot represent architecture %s"),
		     bfd_printable_arch_mach (bfd_get_arch (ibfd),
					      bfd_get_mach (ibfd)));
	  return FALSE;
	}
    }

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }

  if (isympp)
    free (isympp);

  if (osympp != isympp)
    free (osympp);

  /* BFD mandates that all output sections be created and sizes set before
     any output is done.  Thus, we traverse all sections multiple times.  */
  bfd_map_over_sections (ibfd, setup_section, obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;
      struct section_list *pset;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  flagword flags;

	  padd->section = bfd_make_section (obfd, padd->name);
	  if (padd->section == NULL)
	    {
	      non_fatal (_("can't create section `%s': %s"),
		       padd->name, bfd_errmsg (bfd_get_error ()));
	      return FALSE;
	    }

	  if (! bfd_set_section_size (obfd, padd->section, padd->size))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }

	  pset = find_section_list (padd->name, FALSE);
	  if (pset != NULL)
	    pset->used = TRUE;

	  if (pset != NULL && pset->set_flags)
	    flags = pset->flags | SEC_HAS_CONTENTS;
	  else
	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;

	  if (! bfd_set_section_flags (obfd, padd->section, flags))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }

	  if (pset != NULL)
	    {
	      if (pset->change_vma != CHANGE_IGNORE)
		if (! bfd_set_section_vma (obfd, padd->section,
					   pset->vma_val))
		  {
		    bfd_nonfatal (bfd_get_filename (obfd));
		    return FALSE;
		  }

	      if (pset->change_lma != CHANGE_IGNORE)
		{
		  padd->section->lma = pset->lma_val;

		  if (! bfd_set_section_alignment
		      (obfd, padd->section,
		       bfd_section_alignment (obfd, padd->section)))
		    {
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
		    }
		}
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      gnu_debuglink_section = bfd_create_gnu_debuglink_section
	(obfd, gnu_debuglink_filename);

      if (gnu_debuglink_section == NULL)
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
	}
    }

  if (bfd_count_sections (obfd) == 0)
    {
      non_fatal (_("there are no sections to be copied!"));
      return FALSE;
    }

  if (gap_fill_set || pad_to_set)
    {
      asection **set;
      unsigned int c, i;

      /* We must fill in gaps between the sections and/or we must pad
	 the last section to a specified address.  We do this by
	 grabbing a list of the sections, sorting them by VMA, and
	 increasing the section sizes as required to fill the gaps.
	 We write out the gap contents below.  */

      c = bfd_count_sections (obfd);
      osections = xmalloc (c * sizeof (asection *));
      set = osections;
      bfd_map_over_sections (obfd, get_sections, &set);

      qsort (osections, c, sizeof (asection *), compare_section_lma);

      gaps = xmalloc (c * sizeof (bfd_size_type));
      memset (gaps, 0, c * sizeof (bfd_size_type));

      if (gap_fill_set)
	{
	  for (i = 0; i < c - 1; i++)
	    {
	      flagword flags;
	      bfd_size_type size;
	      bfd_vma gap_start, gap_stop;

	      flags = bfd_get_section_flags (obfd, osections[i]);
	      if ((flags & SEC_HAS_CONTENTS) == 0
		  || (flags & SEC_LOAD) == 0)
		continue;

	      size = bfd_section_size (obfd, osections[i]);
	      gap_start = bfd_section_lma (obfd, osections[i]) + size;
	      gap_stop = bfd_section_lma (obfd, osections[i + 1]);
	      if (gap_start < gap_stop)
		{
		  if (! bfd_set_section_size (obfd, osections[i],
					      size + (gap_stop - gap_start)))
		    {
		      non_fatal (_("Can't fill gap after %s: %s"),
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
		      status = 1;
		      break;
		    }
		  gaps[i] = gap_stop - gap_start;
		  if (max_gap < gap_stop - gap_start)
		    max_gap = gap_stop - gap_start;
		}
	    }
	}

      if (pad_to_set)
	{
	  bfd_vma lma;
	  bfd_size_type size;

	  lma = bfd_section_lma (obfd, osections[c - 1]);
	  size = bfd_section_size (obfd, osections[c - 1]);
	  if (lma + size < pad_to)
	    {
	      if (! bfd_set_section_size (obfd, osections[c - 1],
					  pad_to - lma))
		{
		  non_fatal (_("Can't add padding to %s: %s"),
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
		  status = 1;
		}
	      else
		{
		  gaps[c - 1] = pad_to - (lma + size);
		  if (max_gap < pad_to - (lma + size))
		    max_gap = pad_to - (lma + size);
		}
	    }
	}
    }

  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
  dhandle = NULL;
  symsize = bfd_get_symtab_upper_bound (ibfd);
  if (symsize < 0)
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }

  osympp = isympp = xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (ibfd, isympp);
  if (symcount < 0)
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }

  if (convert_debugging)
    dhandle = read_debugging_info (ibfd, isympp, symcount);

  if (strip_symbols == STRIP_DEBUG
      || strip_symbols == STRIP_ALL
      || strip_symbols == STRIP_UNNEEDED
      || strip_symbols == STRIP_NONDEBUG
      || discard_locals != LOCALS_UNDEF
      || strip_specific_list != NULL
      || keep_specific_list != NULL
      || localize_specific_list != NULL
      || keepglobal_specific_list != NULL
      || weaken_specific_list != NULL
      || prefix_symbols_string
      || sections_removed
      || sections_copied
      || convert_debugging
      || change_leading_char
      || remove_leading_char
      || redefine_sym_list
      || weaken)
    {
      /* Mark symbols used in output relocations so that they
	 are kept, even if they are local labels or static symbols.

	 Note we iterate over the input sections examining their
	 relocations since the relocations for the output sections
	 haven't been set yet.  mark_symbols_used_in_relocations will
	 ignore input sections which have no corresponding output
	 section.  */
      if (strip_symbols != STRIP_ALL)
	bfd_map_over_sections (ibfd,
			       mark_symbols_used_in_relocations,
			       isympp);
      osympp = xmalloc ((symcount + 1) * sizeof (asymbol *));
      symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
    }

  if (convert_debugging && dhandle != NULL)
    {
      if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
	{
	  status = 1;
	  return FALSE;
	}
    }

  bfd_set_symtab (obfd, osympp, symcount);

  /* This has to happen after the symbol table has been set.  */
  bfd_map_over_sections (ibfd, copy_section, obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  if (! bfd_set_section_contents (obfd, padd->section, padd->contents,
					  0, padd->size))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      if (! bfd_fill_in_gnu_debuglink_section
	  (obfd, gnu_debuglink_section, gnu_debuglink_filename))
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
	}
    }

  if (gap_fill_set || pad_to_set)
    {
      bfd_byte *buf;
      int c, i;

      /* Fill in the gaps.  */
      if (max_gap > 8192)
	max_gap = 8192;
      buf = xmalloc (max_gap);
      memset (buf, gap_fill, max_gap);

      c = bfd_count_sections (obfd);
      for (i = 0; i < c; i++)
	{
	  if (gaps[i] != 0)
	    {
	      bfd_size_type left;
	      file_ptr off;

	      left = gaps[i];
	      off = bfd_section_size (obfd, osections[i]) - left;

	      while (left > 0)
		{
		  bfd_size_type now;

		  if (left > 8192)
		    now = 8192;
		  else
		    now = left;

		  if (! bfd_set_section_contents (obfd, osections[i], buf,
						  off, now))
		    {
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
		    }

		  left -= now;
		  off += now;
		}
	    }
	}
    }

  /* Allow the BFD backend to copy any private data it understands
     from the input BFD to the output BFD.  This is done last to
     permit the routine to look at the filtered symbol table, which is
     important for the ECOFF code at least.  */
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (! bfd_copy_private_bfd_data (ibfd, obfd))
    {
      non_fatal (_("%s: error copying private BFD data: %s"),
		 bfd_get_filename (obfd),
		 bfd_errmsg (bfd_get_error ()));
      return FALSE;
    }

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0
      && ! bfd_alt_mach_code (obfd, use_alt_mach_code))
    non_fatal (_("unknown alternate machine code, ignored"));

  return TRUE;
}

/* Read each archive element in turn from IBFD, copy the
   contents to temp file, and keep the temp file handle.  */

static void
copy_archive (bfd *ibfd, bfd *obfd, const char *output_target)
{
  struct name_list
    {
      struct name_list *next;
      const char *name;
      bfd *obfd;
    } *list, *l;
  bfd **ptr = &obfd->archive_head;
  bfd *this_element;
  char *dir = make_tempname (bfd_get_filename (obfd), 1);

  /* Make a temp directory to hold the contents.  */
  if (dir == (char *) NULL)
    fatal (_("cannot make temp directory for archive copying (error: %s)"),
	  strerror (errno));

  obfd->has_armap = ibfd->has_armap;

  list = NULL;

  this_element = bfd_openr_next_archived_file (ibfd, NULL);

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

  while (!status && this_element != NULL)
    {
      char *output_name;
      bfd *output_bfd;
      bfd *last_element;
      struct stat buf;
      int stat_status = 0;
      bfd_boolean delete = TRUE;

      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
         output_name = make_tempname (output_name, 1);
         if (output_name == (char *) NULL)
             fatal (_("cannot make temp directory for archive copying (error: %s)"),
                    strerror (errno));

	  l = xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
      if (preserve_dates)
	{
	  stat_status = bfd_stat_arch_elt (this_element, &buf);

	  if (stat_status != 0)
	    non_fatal (_("internal stat error on %s"),
		       bfd_get_filename (this_element));
	}

      l = xmalloc (sizeof (struct name_list));
      l->name = output_name;
      l->next = list;
      list = l;

      if (output_bfd == NULL)
	RETURN_NONFATAL (output_name);

      if (bfd_check_format (this_element, bfd_object))
	delete = ! copy_object (this_element, output_bfd);

      if (!bfd_close (output_bfd))
	{
	  bfd_nonfatal (bfd_get_filename (output_bfd));
	  /* Error in new object file. Don't change archive.  */
	  status = 1;
	}

      if (delete)
	{
	  unlink (output_name);
	  status = 1;
	}
      else
	{
	  if (preserve_dates && stat_status == 0)
	    set_times (output_name, &buf);

	  /* Open the newly output file and attach to our list.  */
	  output_bfd = bfd_openr (output_name, output_target);

	  l->obfd = output_bfd;

	  *ptr = output_bfd;
	  ptr = &output_bfd->next;

	  last_element = this_element;

	  this_element = bfd_openr_next_archived_file (ibfd, last_element);

	  bfd_close (last_element);
	}
    }
  *ptr = NULL;

  if (!bfd_close (obfd))
    RETURN_NONFATAL (bfd_get_filename (obfd));

  if (!bfd_close (ibfd))
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  /* Delete all the files that we opened.  */
  for (l = list; l != NULL; l = l->next)
    {
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
    }
  rmdir (dir);
}

/* The top-level control.  */

static void
copy_file (const char *input_filename, const char *output_filename,
	   const char *input_target,   const char *output_target)
{
  bfd *ibfd;
  char **obj_matching;
  char **core_matching;

  if (get_file_size (input_filename) < 1)
    {
      status = 1;
      return;
    }

  /* To allow us to do "strip *" without dying on the first
     non-object file, failures are nonfatal.  */
  ibfd = bfd_openr (input_filename, input_target);
  if (ibfd == NULL)
    RETURN_NONFATAL (input_filename);

  if (bfd_check_format (ibfd, bfd_archive))
    {
      bfd *obfd;

      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	output_target = bfd_get_target (ibfd);

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
	RETURN_NONFATAL (output_filename);

      copy_archive (ibfd, obfd, output_target);
    }
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
    {
      bfd *obfd;
      bfd_boolean delete;
    do_copy:

      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	output_target = bfd_get_target (ibfd);

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
	RETURN_NONFATAL (output_filename);

      delete = ! copy_object (ibfd, obfd);

      if (!bfd_close (obfd))
	RETURN_NONFATAL (output_filename);

      if (!bfd_close (ibfd))
	RETURN_NONFATAL (input_filename);

      if (delete)
	{
	  unlink (output_filename);
	  status = 1;
	}
    }
  else
    {
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

      bfd_nonfatal (input_filename);

      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (core_matching);
	  free (core_matching);
	}

      status = 1;
    }
}

/* Add a name to the section renaming list.  */

static void
add_section_rename (const char * old_name, const char * new_name,
		    flagword flags)
{
  section_rename * rename;

  /* Check for conflicts first.  */
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  rename = xmalloc (sizeof (* rename));

  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;

  section_rename_list = rename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (bfd * ibfd ATTRIBUTE_UNUSED, sec_ptr isection,
		     flagword * returned_flags)
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * rename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;

	return rename->new_name;
      }

  return old_name;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */

static void
setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
{
  bfd *obfd = obfdarg;
  struct section_list *p;
  sec_ptr osection;
  bfd_size_type size;
  bfd_vma vma;
  bfd_vma lma;
  flagword flags;
  const char *err;
  const char * name;
  char *prefix = NULL;

  if (is_strip_section (ibfd, isection))
    return;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
  if (p != NULL)
    p->used = TRUE;

  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string)
      && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  osection = bfd_make_section_anyway (obfd, name);

  if (osection == NULL)
    {
      err = _("making");
      goto loser;
    }

  size = bfd_section_size (ibfd, isection);
  if (copy_byte >= 0)
    size = (size + interleave - 1) / interleave;
  if (! bfd_set_section_size (obfd, osection, size))
    {
      err = _("size");
      goto loser;
    }

  vma = bfd_section_vma (ibfd, isection);
  if (p != NULL && p->change_vma == CHANGE_MODIFY)
    vma += p->vma_val;
  else if (p != NULL && p->change_vma == CHANGE_SET)
    vma = p->vma_val;
  else
    vma += change_section_address;

  if (! bfd_set_section_vma (obfd, osection, vma))
    {
      err = _("vma");
      goto loser;
    }

  lma = isection->lma;
  if ((p != NULL) && p->change_lma != CHANGE_IGNORE)
    {
      if (p->change_lma == CHANGE_MODIFY)
	lma += p->lma_val;
      else if (p->change_lma == CHANGE_SET)
	lma = p->lma_val;
      else
	abort ();
    }
  else
    lma += change_section_address;

  osection->lma = lma;

  /* FIXME: This is probably not enough.  If we change the LMA we
     may have to recompute the header for the file as well.  */
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
    {
      err = _("alignment");
      goto loser;
    }

  if (p != NULL && p->set_flags)
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
  else if (strip_symbols == STRIP_NONDEBUG && (flags & SEC_ALLOC) != 0)
    {
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
      if (obfd->xvec->flavour == bfd_target_elf_flavour)
	elf_section_type (osection) = SHT_NOBITS;
    }

  if (!bfd_set_section_flags (obfd, osection, flags))
    {
      err = _("flags");
      goto loser;
    }

  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

  /* This used to be mangle_section; we do here to avoid using
     bfd_get_section_by_name since some formats allow multiple
     sections with the same name.  */
  isection->output_section = osection;
  isection->output_offset = 0;

  /* Allow the BFD backend to copy any private data it understands
     from the input section to the output section.  */
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
    {
      err = _("private data");
      goto loser;
    }

  /* All went well.  */
  return;

loser:
  non_fatal (_("%s: section `%s': error in %s: %s"),
	     bfd_get_filename (ibfd),
	     bfd_section_name (ibfd, isection),
	     err, bfd_errmsg (bfd_get_error ()));
  status = 1;
}

/* Copy the data of input section ISECTION of IBFD
   to an output section with the same name in OBFD.
   If stripping then don't copy any relocation info.  */

static void
copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
{
  bfd *obfd = obfdarg;
  struct section_list *p;
  arelent **relpp;
  long relcount;
  sec_ptr osection;
  bfd_size_type size;
  long relsize;
  flagword flags;

  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
  if (status != 0)
    return;

  if (is_strip_section (ibfd, isection))
    return;

  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_GROUP) != 0)
    return;

  osection = isection->output_section;
  size = bfd_get_section_size_before_reloc (isection);

  if (size == 0 || osection == 0)
    return;

  p = find_section_list (bfd_get_section_name (ibfd, isection), FALSE);

  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
    relsize = 0;
  else
    {
      relsize = bfd_get_reloc_upper_bound (ibfd, isection);

      if (relsize < 0)
	{
	  /* Do not complain if the target does not support relocations.  */
	  if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	    relsize = 0;
	  else
	    RETURN_NONFATAL (bfd_get_filename (ibfd));
	}
    }

  if (relsize == 0)
    bfd_set_reloc (obfd, osection, NULL, 0);
  else
    {
      relpp = xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
      if (relcount < 0)
	RETURN_NONFATAL (bfd_get_filename (ibfd));

      if (strip_symbols == STRIP_ALL)
	{
	  /* Remove relocations which are not in
	     keep_strip_specific_list.  */
	  arelent **temp_relpp;
	  long temp_relcount = 0;
	  long i;

	  temp_relpp = xmalloc (relsize);
	  for (i = 0; i < relcount; i++)
	    if (is_specified_symbol (bfd_asymbol_name (*relpp[i]->sym_ptr_ptr),
				     keep_specific_list))
	      temp_relpp [temp_relcount++] = relpp [i];
	  relcount = temp_relcount;
	  free (relpp);
	  relpp = temp_relpp;
	}

      bfd_set_reloc (obfd, osection, relcount == 0 ? NULL : relpp, relcount);
      if (relcount == 0)
	free (relpp);
    }

  isection->_cooked_size = isection->_raw_size;
  isection->reloc_done = TRUE;

  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
    {
      void *memhunk = xmalloc (size);

      if (!bfd_get_section_contents (ibfd, isection, memhunk, 0, size))
	RETURN_NONFATAL (bfd_get_filename (ibfd));

      if (copy_byte >= 0)
	{
	  /* Keep only every `copy_byte'th byte in MEMHUNK.  */
	  char *from = (char *) memhunk + copy_byte;
	  char *to = memhunk;
	  char *end = (char *) memhunk + size;

	  for (; from < end; from += interleave)
	    *to++ = *from;

	  size = (size + interleave - 1 - copy_byte) / interleave;
	  osection->lma /= interleave;
	}

      if (!bfd_set_section_contents (obfd, osection, memhunk, 0, size))
	RETURN_NONFATAL (bfd_get_filename (obfd));

      free (memhunk);
    }
  else if (p != NULL && p->set_flags && (p->flags & SEC_HAS_CONTENTS) != 0)
    {
      void *memhunk = xmalloc (size);

      /* We don't permit the user to turn off the SEC_HAS_CONTENTS
	 flag--they can just remove the section entirely and add it
	 back again.  However, we do permit them to turn on the
	 SEC_HAS_CONTENTS flag, and take it to mean that the section
	 contents should be zeroed out.  */

      memset (memhunk, 0, size);
      if (! bfd_set_section_contents (obfd, osection, memhunk, 0, size))
	RETURN_NONFATAL (bfd_get_filename (obfd));
      free (memhunk);
    }
}

/* Get all the sections.  This is used when --gap-fill or --pad-to is
   used.  */

static void
get_sections (bfd *obfd ATTRIBUTE_UNUSED, asection *osection, void *secppparg)
{
  asection ***secppp = secppparg;

  **secppp = osection;
  ++(*secppp);
}

/* Sort sections by VMA.  This is called via qsort, and is used when
   --gap-fill or --pad-to is used.  We force non loadable or empty
   sections to the front, where they are easier to ignore.  */

static int
compare_section_lma (const void *arg1, const void *arg2)
{
  const asection *const *sec1 = arg1;
  const asection *const *sec2 = arg2;
  flagword flags1, flags2;

  /* Sort non loadable sections to the front.  */
  flags1 = (*sec1)->flags;
  flags2 = (*sec2)->flags;
  if ((flags1 & SEC_HAS_CONTENTS) == 0
      || (flags1 & SEC_LOAD) == 0)
    {
      if ((flags2 & SEC_HAS_CONTENTS) != 0
	  && (flags2 & SEC_LOAD) != 0)
	return -1;
    }
  else
    {
      if ((flags2 & SEC_HAS_CONTENTS) == 0
	  || (flags2 & SEC_LOAD) == 0)
	return 1;
    }

  /* Sort sections by LMA.  */
  if ((*sec1)->lma > (*sec2)->lma)
    return 1;
  else if ((*sec1)->lma < (*sec2)->lma)
    return -1;

  /* Sort sections with the same LMA by size.  */
  if ((*sec1)->_raw_size > (*sec2)->_raw_size)
    return 1;
  else if ((*sec1)->_raw_size < (*sec2)->_raw_size)
    return -1;

  return 0;
}

/* Mark all the symbols which will be used in output relocations with
   the BSF_KEEP flag so that those symbols will not be stripped.

   Ignore relocations which will not appear in the output file.  */

static void
mark_symbols_used_in_relocations (bfd *ibfd, sec_ptr isection, void *symbolsarg)
{
  asymbol **symbols = symbolsarg;
  long relsize;
  arelent **relpp;
  long relcount, i;

  /* Ignore an input section with no corresponding output section.  */
  if (isection->output_section == NULL)
    return;

  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
  if (relsize < 0)
    {
      /* Do not complain if the target does not support relocations.  */
      if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	return;
      bfd_fatal (bfd_get_filename (ibfd));
    }

  if (relsize == 0)
    return;

  relpp = xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, symbols);
  if (relcount < 0)
    bfd_fatal (bfd_get_filename (ibfd));

  /* Examine each symbol used in a relocation.  If it's not one of the
     special bfd section symbols, then mark it with BSF_KEEP.  */
  for (i = 0; i < relcount; i++)
    {
      if (*relpp[i]->sym_ptr_ptr != bfd_com_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_abs_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_und_section_ptr->symbol)
	(*relpp[i]->sym_ptr_ptr)->flags |= BSF_KEEP;
    }

  if (relpp != NULL)
    free (relpp);
}

/* Write out debugging information.  */

static bfd_boolean
write_debugging_info (bfd *obfd, void *dhandle,
		      long *symcountp ATTRIBUTE_UNUSED,
		      asymbol ***symppp ATTRIBUTE_UNUSED)
{
  if (bfd_get_flavour (obfd) == bfd_target_ieee_flavour)
    return write_ieee_debugging_info (obfd, dhandle);

  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
      || bfd_get_flavour (obfd) == bfd_target_elf_flavour)
    {
      bfd_byte *syms, *strings;
      bfd_size_type symsize, stringsize;
      asection *stabsec, *stabstrsec;

      if (! write_stabs_in_sections_debugging_info (obfd, dhandle, &syms,
						    &symsize, &strings,
						    &stringsize))
	return FALSE;

      stabsec = bfd_make_section (obfd, ".stab");
      stabstrsec = bfd_make_section (obfd, ".stabstr");
      if (stabsec == NULL
	  || stabstrsec == NULL
	  || ! bfd_set_section_size (obfd, stabsec, symsize)
	  || ! bfd_set_section_size (obfd, stabstrsec, stringsize)
	  || ! bfd_set_section_alignment (obfd, stabsec, 2)
	  || ! bfd_set_section_alignment (obfd, stabstrsec, 0)
	  || ! bfd_set_section_flags (obfd, stabsec,
				   (SEC_HAS_CONTENTS
				    | SEC_READONLY
				    | SEC_DEBUGGING))
	  || ! bfd_set_section_flags (obfd, stabstrsec,
				      (SEC_HAS_CONTENTS
				       | SEC_READONLY
				       | SEC_DEBUGGING)))
	{
	  non_fatal (_("%s: can't create debugging section: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}

      /* We can get away with setting the section contents now because
         the next thing the caller is going to do is copy over the
         real sections.  We may someday have to split the contents
         setting out of this function.  */
      if (! bfd_set_section_contents (obfd, stabsec, syms, 0, symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings, 0,
					 stringsize))
	{
	  non_fatal (_("%s: can't set debugging section contents: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}

      return TRUE;
    }

  non_fatal (_("%s: don't know how to write debugging information for %s"),
	     bfd_get_filename (obfd), bfd_get_target (obfd));
  return FALSE;
}

static int
strip_main (int argc, char *argv[])
{
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
  struct section_list *p;
  char *output_file = NULL;

  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVvw",
			   strip_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'I':
	  input_target = optarg;
	  break;
	case 'O':
	  output_target = optarg;
	  break;
	case 'F':
	  input_target = output_target = optarg;
	  break;
	case 'R':
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
	  sections_removed = TRUE;
	  break;
	case 's':
	  strip_symbols = STRIP_ALL;
	  break;
	case 'S':
	case 'g':
	case 'd':	/* Historic BSD alias for -g.  Used by early NetBSD.  */
	  strip_symbols = STRIP_DEBUG;
	  break;
	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;
	case 'K':
	  add_specific_symbol (optarg, &keep_specific_list);
	  break;
	case 'N':
	  add_specific_symbol (optarg, &strip_specific_list);
	  break;
	case 'o':
	  output_file = optarg;
	  break;
	case 'p':
	  preserve_dates = TRUE;
	  break;
	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;
	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;
	case 'v':
	  verbose = TRUE;
	  break;
	case 'V':
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;
	case 0:
	  /* We've been given a long option.  */
	  break;
	case 'w':
	  wildcard = TRUE;
	  break;
	case 'H':
	case 'h':
	  strip_usage (stdout, 0);
	default:
	  strip_usage (stderr, 1);
	}
    }

  if (formats_info)
    {
      display_info ();
      return 0;
    }
 
  if (show_version)
    print_version ("strip");

  /* Default is to strip all symbols.  */
  if (strip_symbols == STRIP_UNDEF
      && discard_locals == LOCALS_UNDEF
      && strip_specific_list == NULL)
    strip_symbols = STRIP_ALL;

  if (output_target == NULL)
    output_target = input_target;

  i = optind;
  if (i == argc
      || (output_file != NULL && (i + 1) < argc))
    strip_usage (stderr, 1);

  for (; i < argc; i++)
    {
      int hold_status = status;
      struct stat statbuf;
      char *tmpname;

      if (get_file_size (argv[i]) < 1)
        {
          status = 1;
          continue;
        }

      if (preserve_dates)
	/* No need to check the return value of stat().
	   It has already been checked in get_file_size().  */
	stat (argv[i], &statbuf);

      if (output_file != NULL)
	tmpname = output_file;
      else
	tmpname = make_tempname (argv[i], 0);
      status = 0;

      copy_file (argv[i], tmpname, input_target, output_target);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  if (output_file == NULL)
	    smart_rename (tmpname, argv[i], preserve_dates);
	  status = hold_status;
	}
      else
	unlink (tmpname);
      if (output_file == NULL)
	free (tmpname);
    }

  return 0;
}

static int
copy_main (int argc, char *argv[])
{
  char * binary_architecture = NULL;
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
  int c;
  struct section_list *p;
  struct stat statbuf;

  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:w",
			   copy_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'b':
	  copy_byte = atoi (optarg);
	  if (copy_byte < 0)
	    fatal (_("byte number must be non-negative"));
	  break;

	case 'B':
	  binary_architecture = optarg;
	  break;

	case 'i':
	  interleave = atoi (optarg);
	  if (interleave < 1)
	    fatal (_("interleave must be positive"));
	  break;

	case 'I':
	case 's':		/* "source" - 'I' is preferred */
	  input_target = optarg;
	  break;

	case 'O':
	case 'd':		/* "destination" - 'O' is preferred */
	  output_target = optarg;
	  break;

	case 'F':
	  input_target = output_target = optarg;
	  break;

	case 'j':
	  p = find_section_list (optarg, TRUE);
	  if (p->remove)
	    fatal (_("%s both copied and removed"), optarg);
	  p->copy = TRUE;
	  sections_copied = TRUE;
	  break;

	case 'R':
	  p = find_section_list (optarg, TRUE);
	  if (p->copy)
	    fatal (_("%s both copied and removed"), optarg);
	  p->remove = TRUE;
	  sections_removed = TRUE;
	  break;

	case 'S':
	  strip_symbols = STRIP_ALL;
	  break;

	case 'g':
	  strip_symbols = STRIP_DEBUG;
	  break;

	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;

	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;

	case OPTION_ADD_GNU_DEBUGLINK:
	  gnu_debuglink_filename = optarg;
	  break;

	case 'K':
	  add_specific_symbol (optarg, &keep_specific_list);
	  break;

	case 'N':
	  add_specific_symbol (optarg, &strip_specific_list);
	  break;

	case 'L':
	  add_specific_symbol (optarg, &localize_specific_list);
	  break;

	case 'G':
	  add_specific_symbol (optarg, &keepglobal_specific_list);
	  break;

	case 'W':
	  add_specific_symbol (optarg, &weaken_specific_list);
	  break;

	case 'p':
	  preserve_dates = TRUE;
	  break;

	case 'w':
	  wildcard = TRUE;
	  break;

	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;

	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;

	case 'v':
	  verbose = TRUE;
	  break;

	case 'V':
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;

	case OPTION_WEAKEN:
	  weaken = TRUE;
	  break;

	case OPTION_ADD_SECTION:
	  {
	    const char *s;
	    off_t size;
	    struct section_add *pa;
	    int len;
	    char *name;
	    FILE *f;

	    s = strchr (optarg, '=');

	    if (s == NULL)
	      fatal (_("bad format for %s"), "--add-section");

	    size = get_file_size (s + 1);
	    if (size < 1)
	      break;

	    pa = xmalloc (sizeof (struct section_add));

	    len = s - optarg;
	    name = xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';
	    pa->name = name;

	    pa->filename = s + 1;
	    pa->size = size;
	    pa->contents = xmalloc (size);

	    f = fopen (pa->filename, FOPEN_RB);

	    if (f == NULL)
	      fatal (_("cannot open: %s: %s"),
		     pa->filename, strerror (errno));

	    if (fread (pa->contents, 1, pa->size, f) == 0
		|| ferror (f))
	      fatal (_("%s: fread failed"), pa->filename);

	    fclose (f);

	    pa->next = add_sections;
	    add_sections = pa;
	  }
	  break;

	case OPTION_CHANGE_START:
	  change_start = parse_vma (optarg, "--change-start");
	  break;

	case OPTION_CHANGE_SECTION_ADDRESS:
	case OPTION_CHANGE_SECTION_LMA:
	case OPTION_CHANGE_SECTION_VMA:
	  {
	    const char *s;
	    int len;
	    char *name;
	    char *option = NULL;
	    bfd_vma val;
	    enum change_action what = CHANGE_IGNORE;

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		option = "--change-section-address";
		break;
	      case OPTION_CHANGE_SECTION_LMA:
		option = "--change-section-lma";
		break;
	      case OPTION_CHANGE_SECTION_VMA:
		option = "--change-section-vma";
		break;
	      }

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      {
		s = strchr (optarg, '+');
		if (s == NULL)
		  {
		    s = strchr (optarg, '-');
		    if (s == NULL)
		      fatal (_("bad format for %s"), option);
		  }
	      }

	    len = s - optarg;
	    name = xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE);

	    val = parse_vma (s + 1, option);

	    switch (*s)
	      {
	      case '=': what = CHANGE_SET; break;
	      case '-': val  = - val; /* Drop through.  */
	      case '+': what = CHANGE_MODIFY; break;
	      }

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		p->change_vma = what;
		p->vma_val    = val;
		/* Drop through.  */

	      case OPTION_CHANGE_SECTION_LMA:
		p->change_lma = what;
		p->lma_val    = val;
		break;

	      case OPTION_CHANGE_SECTION_VMA:
		p->change_vma = what;
		p->vma_val    = val;
		break;
	      }
	  }
	  break;

	case OPTION_CHANGE_ADDRESSES:
	  change_section_address = parse_vma (optarg, "--change-addresses");
	  change_start = change_section_address;
	  break;

	case OPTION_CHANGE_WARNINGS:
	  change_warn = TRUE;
	  break;

	case OPTION_CHANGE_LEADING_CHAR:
	  change_leading_char = TRUE;
	  break;

	case OPTION_DEBUGGING:
	  convert_debugging = TRUE;
	  break;

	case OPTION_GAP_FILL:
	  {
	    bfd_vma gap_fill_vma;

	    gap_fill_vma = parse_vma (optarg, "--gap-fill");
	    gap_fill = (bfd_byte) gap_fill_vma;
	    if ((bfd_vma) gap_fill != gap_fill_vma)
	      {
		char buff[20];

		sprintf_vma (buff, gap_fill_vma);

		non_fatal (_("Warning: truncating gap-fill from 0x%s to 0x%x"),
			   buff, gap_fill);
	      }
	    gap_fill_set = TRUE;
	  }
	  break;

	case OPTION_NO_CHANGE_WARNINGS:
	  change_warn = FALSE;
	  break;

	case OPTION_PAD_TO:
	  pad_to = parse_vma (optarg, "--pad-to");
	  pad_to_set = TRUE;
	  break;

	case OPTION_REMOVE_LEADING_CHAR:
	  remove_leading_char = TRUE;
	  break;

	case OPTION_REDEFINE_SYM:
	  {
	    /* Push this redefinition onto redefine_symbol_list.  */

	    int len;
	    const char *s;
	    const char *nextarg;
	    char *source, *target;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--redefine-sym");

	    len = s - optarg;
	    source = xmalloc (len + 1);
	    strncpy (source, optarg, len);
	    source[len] = '\0';

	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = xmalloc (len + 1);
	    strcpy (target, nextarg);

	    redefine_list_append ("--redefine-sym", source, target);

	    free (source);
	    free (target);
	  }
	  break;

	case OPTION_REDEFINE_SYMS:
	  add_redefine_syms_file (optarg);
	  break;

	case OPTION_SET_SECTION_FLAGS:
	  {
	    const char *s;
	    int len;
	    char *name;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--set-section-flags");

	    len = s - optarg;
	    name = xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE);

	    p->set_flags = TRUE;
	    p->flags = parse_flags (s + 1);
	  }
	  break;

	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

	case OPTION_SET_START:
	  set_start = parse_vma (optarg, "--set-start");
	  set_start_set = TRUE;
	  break;

	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;

	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;

	case OPTION_STRIP_SYMBOLS:
	  add_specific_symbols (optarg, &strip_specific_list);
	  break;

	case OPTION_KEEP_SYMBOLS:
	  add_specific_symbols (optarg, &keep_specific_list);
	  break;

	case OPTION_LOCALIZE_SYMBOLS:
	  add_specific_symbols (optarg, &localize_specific_list);
	  break;

	case OPTION_KEEPGLOBAL_SYMBOLS:
	  add_specific_symbols (optarg, &keepglobal_specific_list);
	  break;

	case OPTION_WEAKEN_SYMBOLS:
	  add_specific_symbols (optarg, &weaken_specific_list);
	  break;

	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

	case OPTION_READONLY_TEXT:
	  bfd_flags_to_set |= WP_TEXT;
	  bfd_flags_to_clear &= ~WP_TEXT;
	  break;

	case OPTION_WRITABLE_TEXT:
	  bfd_flags_to_clear |= WP_TEXT;
	  bfd_flags_to_set &= ~WP_TEXT;
	  break;

	case OPTION_PURE:
	  bfd_flags_to_set |= D_PAGED;
	  bfd_flags_to_clear &= ~D_PAGED;
	  break;

	case OPTION_IMPURE:
	  bfd_flags_to_clear |= D_PAGED;
	  bfd_flags_to_set &= ~D_PAGED;
	  break;

	case 0:
	  /* We've been given a long option.  */
	  break;

	case 'H':
	case 'h':
	  copy_usage (stdout, 0);

	default:
	  copy_usage (stderr, 1);
	}
    }

  if (formats_info)
    {
      display_info ();
      return 0;
    }
 
  if (show_version)
    print_version ("objcopy");

  if (copy_byte >= interleave)
    fatal (_("byte number must be less than interleave"));

  if (optind == argc || optind + 2 < argc)
    copy_usage (stderr, 1);

  input_filename = argv[optind];
  if (optind + 1 < argc)
    output_filename = argv[optind + 1];

  /* Default is to strip no symbols.  */
  if (strip_symbols == STRIP_UNDEF && discard_locals == LOCALS_UNDEF)
    strip_symbols = STRIP_NONE;

  if (output_target == NULL)
    output_target = input_target;

  if (binary_architecture != NULL)
    {
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    {
	      bfd_external_binary_architecture = temp_arch_info->arch;
	      bfd_external_machine             = temp_arch_info->mach;
	    }
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
    }

  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("warning: could not locate '%s'.  System error message: %s"),
	     input_filename, strerror (errno));

  /* If there is no destination file, or the source and destination files
     are the same, then create a temp and rename the result into the input.  */
  if (output_filename == NULL || strcmp (input_filename, output_filename) == 0)
    {
      char *tmpname = make_tempname (input_filename, 0);

      copy_file (input_filename, tmpname, input_target, output_target);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  smart_rename (tmpname, input_filename, preserve_dates);
	}
      else
	unlink (tmpname);
    }
  else
    {
      copy_file (input_filename, output_filename, input_target, output_target);

      if (status == 0 && preserve_dates)
	set_times (output_filename, &statbuf);
    }

  if (change_warn)
    {
      for (p = change_sections; p != NULL; p = p->next)
	{
	  if (! p->used)
	    {
	      if (p->change_vma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->vma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-vma",
			     p->name,
			     p->change_vma == CHANGE_SET ? '=' : '+',
			     buff);
		}

	      if (p->change_lma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->lma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-lma",
			     p->name,
			     p->change_lma == CHANGE_SET ? '=' : '+',
			     buff);
		}
	    }
	}
    }

  return 0;
}

int
main (int argc, char *argv[])
{
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  strip_symbols = STRIP_UNDEF;
  discard_locals = LOCALS_UNDEF;

  bfd_init ();
  set_default_bfd_target ();

  if (is_strip < 0)
    {
      int i = strlen (program_name);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* Drop the .exe suffix, if any.  */
      if (i > 4 && FILENAME_CMP (program_name + i - 4, ".exe") == 0)
	{
	  i -= 4;
	  program_name[i] = '\0';
	}
#endif
      is_strip = (i >= 5 && FILENAME_CMP (program_name + i - 5, "strip") == 0);
    }

  if (is_strip)
    strip_main (argc, argv);
  else
    copy_main (argc, argv);

  END_PROGRESS (program_name);

  return status;
}
@


1.13
log
@Exit strip(1) with an error, if an objfile could not be read.
Input and OK millert@@
@
text
@d3033 2
@


1.12
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d2370 4
a2373 1
	continue;
@


1.11
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002, 2003
d30 2
d63 1
a63 52
static section_rename * section_rename_list;

static void copy_usage
  PARAMS ((FILE *, int));
static void strip_usage
  PARAMS ((FILE *, int));
static flagword parse_flags
  PARAMS ((const char *));
static struct section_list *find_section_list
  PARAMS ((const char *, bfd_boolean));
static void setup_section
  PARAMS ((bfd *, asection *, PTR));
static void copy_section
  PARAMS ((bfd *, asection *, PTR));
static void get_sections
  PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma
  PARAMS ((const PTR, const PTR));
static void add_specific_symbol
  PARAMS ((const char *, struct symlist **));
static void add_specific_symbols
  PARAMS ((const char *, struct symlist **));
static bfd_boolean is_specified_symbol
  PARAMS ((const char *, struct symlist *));
static bfd_boolean is_strip_section
  PARAMS ((bfd *, asection *));
static unsigned int filter_symbols
  PARAMS ((bfd *, bfd *, asymbol **, asymbol **, long));
static void mark_symbols_used_in_relocations
  PARAMS ((bfd *, asection *, PTR));
static void filter_bytes
  PARAMS ((char *, bfd_size_type *));
static bfd_boolean write_debugging_info
  PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object
  PARAMS ((bfd *, bfd *));
static void copy_archive
  PARAMS ((bfd *, bfd *, const char *));
static void copy_file
  PARAMS ((const char *, const char *, const char *, const char *));
static int strip_main
  PARAMS ((int, char **));
static int copy_main
  PARAMS ((int, char **));
static const char *lookup_sym_redefinition
  PARAMS((const char *));
static void redefine_list_append
  PARAMS ((const char *, const char *));
static const char * find_section_rename
  PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename
  PARAMS ((const char *, const char *, flagword));
d67 2
a68 2
static asymbol **isympp = NULL;	/* Input symbols */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping */
d81 5
a85 4
    STRIP_NONE,			/* don't strip */
    STRIP_DEBUG,		/* strip all debugger symbols */
    STRIP_UNNEEDED,		/* strip unnecessary symbols */
    STRIP_ALL			/* strip all symbols */
d94 2
a95 2
    LOCALS_START_L,		/* discard locals starting with L */
    LOCALS_ALL			/* discard all locals */
d152 4
d176 4
d189 3
d210 41
a250 32

#define OPTION_ADD_SECTION 150
#define OPTION_CHANGE_ADDRESSES (OPTION_ADD_SECTION + 1)
#define OPTION_CHANGE_LEADING_CHAR (OPTION_CHANGE_ADDRESSES + 1)
#define OPTION_CHANGE_START (OPTION_CHANGE_LEADING_CHAR + 1)
#define OPTION_CHANGE_SECTION_ADDRESS (OPTION_CHANGE_START + 1)
#define OPTION_CHANGE_SECTION_LMA (OPTION_CHANGE_SECTION_ADDRESS + 1)
#define OPTION_CHANGE_SECTION_VMA (OPTION_CHANGE_SECTION_LMA + 1)
#define OPTION_CHANGE_WARNINGS (OPTION_CHANGE_SECTION_VMA + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_WARNINGS + 1)
#define OPTION_GAP_FILL (OPTION_DEBUGGING + 1)
#define OPTION_NO_CHANGE_WARNINGS (OPTION_GAP_FILL + 1)
#define OPTION_PAD_TO (OPTION_NO_CHANGE_WARNINGS + 1)
#define OPTION_REMOVE_LEADING_CHAR (OPTION_PAD_TO + 1)
#define OPTION_SET_SECTION_FLAGS (OPTION_REMOVE_LEADING_CHAR + 1)
#define OPTION_SET_START (OPTION_SET_SECTION_FLAGS + 1)
#define OPTION_STRIP_UNNEEDED (OPTION_SET_START + 1)
#define OPTION_WEAKEN (OPTION_STRIP_UNNEEDED + 1)
#define OPTION_REDEFINE_SYM (OPTION_WEAKEN + 1)
#define OPTION_SREC_LEN (OPTION_REDEFINE_SYM + 1)
#define OPTION_SREC_FORCES3 (OPTION_SREC_LEN + 1)
#define OPTION_STRIP_SYMBOLS (OPTION_SREC_FORCES3 + 1)
#define OPTION_KEEP_SYMBOLS (OPTION_STRIP_SYMBOLS + 1)
#define OPTION_LOCALIZE_SYMBOLS (OPTION_KEEP_SYMBOLS + 1)
#define OPTION_KEEPGLOBAL_SYMBOLS (OPTION_LOCALIZE_SYMBOLS + 1)
#define OPTION_WEAKEN_SYMBOLS (OPTION_KEEPGLOBAL_SYMBOLS + 1)
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)
d264 1
d277 1
d285 1
d307 1
d320 1
d329 2
d332 1
d351 2
d373 13
a385 3
/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;

d388 1
a388 3
copy_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
d401 1
d404 1
a404 1
  -g --strip-debug                 Remove all debugging symbols\n\
d407 1
d413 1
d440 2
d450 4
d471 1
a471 3
strip_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
d483 1
a483 1
  -g -S -d --strip-debug           Remove all debugging symbols\n\
d485 1
d488 1
d508 1
a508 2
parse_flags (s)
     const char *s;
d563 1
a563 3
find_section_list (name, add)
     const char *name;
     bfd_boolean add;
d565 1
a565 1
  register struct section_list *p;
d574 1
a574 1
  p = (struct section_list *) xmalloc (sizeof (struct section_list));
d595 1
a595 3
add_specific_symbol (name, list)
     const char *name;
     struct symlist **list;
d599 1
a599 1
  tmp_list = (struct symlist *) xmalloc (sizeof (struct symlist));
d611 1
a611 3
add_specific_symbols (filename, list)
     const char *filename;
     struct symlist **list;
d613 1
a613 1
  struct stat st;
d619 2
a620 3
  if (stat (filename, & st) < 0)
    fatal (_("cannot stat: %s: %s"), filename, strerror (errno));
  if (st.st_size == 0)
d623 1
a623 1
  buffer = (char *) xmalloc (st.st_size + 2);
d626 1
a626 1
    fatal (_("cannot open: %s: %s"), filename, strerror (errno));
d628 1
a628 1
  if (fread (buffer, 1, st.st_size, f) == 0 || ferror (f))
d632 2
a633 2
  buffer [st.st_size] = '\n';
  buffer [st.st_size + 1] = '\0';
d722 1
a722 3
is_specified_symbol (name, list)
     const char *name;
     struct symlist *list;
d726 20
a745 3
  for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;
d753 1
a753 3
is_strip_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d755 11
a765 1
  struct section_list *p;
d767 3
a769 2
  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
d773 2
a774 2
	  || convert_debugging))
    return TRUE;
d776 3
a778 2
  if (! sections_removed && ! sections_copied)
    return FALSE;
a779 5
  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
  if (sections_removed && p != NULL && p->remove)
    return TRUE;
  if (sections_copied && (p == NULL || ! p->copy))
    return TRUE;
d788 2
a789 5
filter_symbols (abfd, obfd, osyms, isyms, symcount)
     bfd *abfd;
     bfd *obfd;
     asymbol **osyms, **isyms;
     long symcount;
d791 1
a791 1
  register asymbol **from = isyms, **to = osyms;
d852 2
a853 1
          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
d937 1
a937 2
lookup_sym_redefinition (source)
     const char *source;
d951 1
a951 3
redefine_list_append (source, target)
     const char *source;
     const char *target;
d961 1
a961 2
	       "--redefine-sym",
	       source);
d965 1
a965 2
	       "--redefine-sym",
	       target);
d968 1
a968 1
  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));
d977 2
a978 2
/* Keep only every `copy_byte'th byte in MEMHUNK, which is *SIZE bytes long.
   Adjust *SIZE.  */
d981 1
a981 3
filter_bytes (memhunk, size)
     char *memhunk;
     bfd_size_type *size;
d983 98
a1080 1
  char *from = memhunk + copy_byte, *to = memhunk, *end = memhunk + *size;
d1082 2
a1083 2
  for (; from < end; from += interleave)
    *to++ = *from;
d1085 1
a1085 4
  if (*size % interleave > (bfd_size_type) copy_byte)
    *size = (*size / interleave) + 1;
  else
    *size /= interleave;
d1088 2
a1089 1
/* Copy object file IBFD onto OBFD.  */
d1091 2
a1092 4
static void
copy_object (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d1097 1
d1101 1
a1101 1
  PTR dhandle;
d1108 3
d1112 2
a1113 2
      fatal (_("Unable to change endianness of input file(s)"));
      return;
a1115 3
  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

d1131 7
d1139 5
a1143 4
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
	RETURN_NONFATAL (bfd_get_filename (ibfd));
d1152 12
a1163 3
    non_fatal (_("Warning: Output file cannot represent architecture %s"),
	       bfd_printable_arch_mach (bfd_get_arch (ibfd),
					bfd_get_mach (ibfd)));
d1166 4
a1169 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1179 1
a1179 1
  bfd_map_over_sections (ibfd, setup_section, (void *) obfd);
d1188 2
d1195 1
a1195 2
	      status = 1;
	      return;
d1197 2
a1198 1
	  else
d1200 3
a1202 1
	      flagword flags;
d1204 3
a1206 2
	      if (! bfd_set_section_size (obfd, padd->section, padd->size))
		RETURN_NONFATAL (bfd_get_filename (obfd));
d1208 4
a1211 3
	      pset = find_section_list (padd->name, FALSE);
	      if (pset != NULL)
		pset->used = TRUE;
d1213 5
a1217 4
	      if (pset != NULL && pset->set_flags)
		flags = pset->flags | SEC_HAS_CONTENTS;
	      else
		flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
d1219 9
a1227 2
	      if (! bfd_set_section_flags (obfd, padd->section, flags))
		RETURN_NONFATAL (bfd_get_filename (obfd));
d1229 1
a1229 1
	      if (pset != NULL)
d1231 1
a1231 3
		  if (pset->change_vma != CHANGE_IGNORE)
		    if (! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
		      RETURN_NONFATAL (bfd_get_filename (obfd));
d1233 3
a1235 1
		  if (pset->change_lma != CHANGE_IGNORE)
d1237 2
a1238 6
		      padd->section->lma = pset->lma_val;

		      if (! bfd_set_section_alignment
			  (obfd, padd->section,
			   bfd_section_alignment (obfd, padd->section)))
			RETURN_NONFATAL (bfd_get_filename (obfd));
d1245 18
d1275 1
a1275 1
      osections = (asection **) xmalloc (c * sizeof (asection *));
d1277 1
a1277 1
      bfd_map_over_sections (obfd, get_sections, (void *) &set);
d1281 1
a1281 1
      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));
d1350 4
a1353 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1355 1
a1355 1
  osympp = isympp = (asymbol **) xmalloc (symsize);
d1358 4
a1361 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1369 1
d1396 2
a1397 2
			       (PTR)isympp);
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
d1406 1
a1406 1
	  return;
d1413 1
a1413 1
  bfd_map_over_sections (ibfd, copy_section, (void *) obfd);
d1421 16
a1436 5
	  if (! bfd_set_section_contents (obfd, padd->section,
					  (PTR) padd->contents,
					  (file_ptr) 0,
					  (bfd_size_type) padd->size))
	    RETURN_NONFATAL (bfd_get_filename (obfd));
d1448 2
a1449 2
      buf = (bfd_byte *) xmalloc (max_gap);
      memset (buf, gap_fill, (size_t) max_gap);
d1473 4
a1476 1
		    RETURN_NONFATAL (bfd_get_filename (obfd));
d1489 6
a1494 1
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
d1499 1
a1499 2
      status = 1;
      return;
d1505 5
a1509 5
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
d1516 1
a1516 4
copy_archive (ibfd, obfd, output_target)
     bfd *ibfd;
     bfd *obfd;
     const char *output_target;
d1530 3
a1532 4
    {
      fatal (_("cannot make temp directory for archive copying (error: %s)"),
	     strerror (errno));
    }
d1542 1
a1542 1
  while (!status && this_element != (bfd *) NULL)
d1549 1
d1558 6
a1563 7
	  output_name = make_tempname (output_name, 1);
	  if (output_name == (char *) NULL)
	    {
	      fatal (_("cannot make temp directory for archive copying (error: %s)"),
		     strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
d1582 1
a1582 1
      l = (struct name_list *) xmalloc (sizeof (struct name_list));
d1587 1
a1587 1
      if (output_bfd == (bfd *) NULL)
d1591 1
a1591 1
	copy_object (this_element, output_bfd);
d1600 9
a1608 2
      if (preserve_dates && stat_status == 0)
	set_times (output_name, &buf);
d1610 2
a1611 2
      /* Open the newly output file and attach to our list.  */
      output_bfd = bfd_openr (output_name, output_target);
d1613 1
a1613 1
      l->obfd = output_bfd;
d1615 2
a1616 2
      *ptr = output_bfd;
      ptr = &output_bfd->next;
d1618 1
a1618 1
      last_element = this_element;
d1620 1
a1620 1
      this_element = bfd_openr_next_archived_file (ibfd, last_element);
d1622 2
a1623 1
      bfd_close (last_element);
d1625 1
a1625 1
  *ptr = (bfd *) NULL;
d1650 2
a1651 5
copy_file (input_filename, output_filename, input_target, output_target)
     const char *input_filename;
     const char *output_filename;
     const char *input_target;
     const char *output_target;
d1657 6
d1687 1
d1689 1
d1699 1
a1699 1
      copy_object (ibfd, obfd);
d1706 6
d1751 2
a1752 4
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
d1768 1
a1768 1
  rename = (section_rename *) xmalloc (sizeof (* rename));
d1783 2
a1784 4
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
d1808 1
a1808 4
setup_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
d1810 1
a1810 1
  bfd *obfd = (bfd *) obfdarg;
d1821 1
a1821 6
  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
a1827 5
  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

d1832 2
a1833 1
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
d1906 7
d1930 6
a1935 1
  if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
d1957 1
a1957 4
copy_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
d1959 1
a1959 1
  bfd *obfd = (bfd *) obfdarg;
d1973 1
a1973 7
  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
d1976 1
a1979 7
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);

  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

d1986 2
d1992 2
a1993 1
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1995 9
a2003 2
  if (relsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d2006 1
a2006 1
    bfd_set_reloc (obfd, osection, (arelent **) NULL, 0);
d2009 1
a2009 1
      relpp = (arelent **) xmalloc (relsize);
d2022 1
a2022 1
	  temp_relpp = (arelent **) xmalloc (relsize);
d2024 2
a2025 3
	    if (is_specified_symbol
		(bfd_asymbol_name (*relpp [i]->sym_ptr_ptr),
		 keep_specific_list))
d2032 3
a2034 2
      bfd_set_reloc (obfd, osection,
		     (relcount == 0 ? (arelent **) NULL : relpp), relcount);
d2043 1
a2043 1
      PTR memhunk = (PTR) xmalloc ((unsigned) size);
d2045 1
a2045 2
      if (!bfd_get_section_contents (ibfd, isection, memhunk, (file_ptr) 0,
				     size))
d2049 12
a2060 1
	filter_bytes (memhunk, &size);
d2062 1
a2062 2
      if (!bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				     size))
d2069 1
a2069 1
      PTR memhunk = (PTR) xmalloc ((unsigned) size);
d2078 1
a2078 2
      if (! bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				      size))
d2088 1
a2088 4
get_sections (obfd, osection, secppparg)
     bfd *obfd ATTRIBUTE_UNUSED;
     asection *osection;
     PTR secppparg;
d2090 1
a2090 1
  asection ***secppp = (asection ***) secppparg;
d2101 1
a2101 3
compare_section_lma (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d2103 2
a2104 2
  const asection **sec1 = (const asection **) arg1;
  const asection **sec2 = (const asection **) arg2;
d2145 1
a2145 4
mark_symbols_used_in_relocations (ibfd, isection, symbolsarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR symbolsarg;
d2147 1
a2147 1
  asymbol **symbols = (asymbol **) symbolsarg;
d2158 6
a2163 1
    bfd_fatal (bfd_get_filename (ibfd));
d2168 1
a2168 1
  relpp = (arelent **) xmalloc (relsize);
d2190 3
a2192 5
write_debugging_info (obfd, dhandle, symcountp, symppp)
     bfd *obfd;
     PTR dhandle;
     long *symcountp ATTRIBUTE_UNUSED;
     asymbol ***symppp ATTRIBUTE_UNUSED;
d2236 3
a2238 4
      if (! bfd_set_section_contents (obfd, stabsec, syms, (file_ptr) 0,
				      symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings,
					 (file_ptr) 0, stringsize))
d2255 1
a2255 3
strip_main (argc, argv)
     int argc;
     char *argv[];
d2266 1
a2266 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
d2323 3
d2329 3
d2340 5
a2344 5
 if (formats_info)
   {
     display_info ();
     return 0;
   }
d2355 1
a2355 1
  if (output_target == (char *) NULL)
d2369 3
d2373 3
a2375 7
	{
	  if (stat (argv[i], &statbuf) < 0)
	    {
	      non_fatal (_("%s: cannot stat: %s"), argv[i], strerror (errno));
	      continue;
	    }
	}
d2402 1
a2402 3
copy_main (argc, argv)
     int argc;
     char *argv[];
d2416 1
a2416 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
d2479 8
d2511 4
d2542 1
a2542 1
	    struct stat st;
d2553 3
a2555 2
	    if (stat (s + 1, & st) < 0)
	      fatal (_("cannot stat: %s: %s"), s + 1, strerror (errno));
d2557 1
a2557 1
	    pa = (struct section_add *) xmalloc (sizeof (struct section_add));
d2560 1
a2560 1
	    name = (char *) xmalloc (len + 1);
d2566 2
a2568 3
	    pa->size = st.st_size;

	    pa->contents = (bfd_byte *) xmalloc (pa->size);
d2572 2
a2573 1
	      fatal (_("cannot open: %s: %s"), pa->filename, strerror (errno));
d2627 1
a2627 1
	    name = (char *) xmalloc (len + 1);
d2725 1
a2725 1
	    source = (char *) xmalloc (len + 1);
d2731 1
a2731 1
	    target = (char *) xmalloc (len + 1);
d2734 1
a2734 1
	    redefine_list_append (source, target);
d2741 4
d2756 1
a2756 1
	    name = (char *) xmalloc (len + 1);
d2783 1
a2783 1
	    old_name = (char *) xmalloc (len + 1);
d2803 1
a2803 1
	    new_name = (char *) xmalloc (len + 1);
d2862 20
d2883 2
a2884 1
	  break;		/* we've been given a long option */
d2918 1
a2918 1
  if (output_target == (char *) NULL)
d2921 1
a2921 1
  if (binary_architecture != (char *) NULL)
d2930 4
a2933 1
	    bfd_external_binary_architecture = temp_arch_info->arch;
d2946 2
a2947 1
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2950 2
a2951 3
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
a3012 2
int main PARAMS ((int, char **));

d3014 1
a3014 3
main (argc, argv)
     int argc;
     char *argv[];
@


1.10
log
@sync the list of acceptable getopt_long options with reality.
Fixes PR 3623

From: binutils CVS 2.11 branch, based on rev 1.15.2.3

ok otto@@
@
text
@d3 1
a3 1
   2001
d35 1
a35 1
   deleted. */
d51 36
a86 12
static void copy_usage PARAMS ((FILE *, int));
static void strip_usage PARAMS ((FILE *, int));
static flagword parse_flags PARAMS ((const char *));
static struct section_list *find_section_list PARAMS ((const char *, boolean));
static void setup_section PARAMS ((bfd *, asection *, PTR));
static void copy_section PARAMS ((bfd *, asection *, PTR));
static void get_sections PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma PARAMS ((const PTR, const PTR));
static void add_specific_symbol PARAMS ((const char *, struct symlist **));
static void add_specific_symbols PARAMS ((const char *, struct symlist **));
static boolean is_specified_symbol PARAMS ((const char *, struct symlist *));
static boolean is_strip_section PARAMS ((bfd *, asection *));
d89 10
a98 5
static void mark_symbols_used_in_relocations PARAMS ((bfd *, asection *, PTR));
static void filter_bytes PARAMS ((char *, bfd_size_type *));
static boolean write_debugging_info PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object PARAMS ((bfd *, bfd *));
static void copy_archive PARAMS ((bfd *, bfd *, const char *));
d101 12
a112 4
static int strip_main PARAMS ((int, char **));
static int copy_main PARAMS ((int, char **));
static const char *lookup_sym_redefinition PARAMS((const char *));
static void redefine_list_append PARAMS ((const char *, const char *));
d123 2
a124 2
static boolean verbose;		/* Print file and target names. */
static boolean preserve_dates;	/* Preserve input file timestamp.  */
d136 1
a136 1
/* Which symbols to remove. */
d160 11
a170 11
  struct section_list * next;      /* Next section to change.  */
  const char *          name;      /* Section name.  */
  boolean               used;      /* Whether this entry was used.  */
  boolean               remove;    /* Whether to remove this section.  */
  boolean		copy;      /* Whether to copy this section.  */
  enum change_action    change_vma;/* Whether to change or set VMA.  */
  bfd_vma 		vma_val;   /* Amount to change by or set to.  */
  enum change_action    change_lma;/* Whether to change or set LMA.  */
  bfd_vma 		lma_val;   /* Amount to change by or set to.  */
  boolean 		set_flags; /* Whether to set the section flags.  */
  flagword 		flags;     /* What to set the section flags to.  */
d174 6
a179 2
static boolean sections_removed;
static boolean sections_copied;
d183 1
a183 1
static boolean set_start_set = false;
d190 1
a190 1
static boolean gap_fill_set = false;
d194 1
a194 1
static boolean pad_to_set = false;
d197 3
a200 1

d217 1
d221 1
a221 2

static boolean convert_debugging = false;
d224 1
a224 2

static boolean change_leading_char = false;
d227 1
a227 2

static boolean remove_leading_char = false;
a230 1

d238 2
a239 1
/* If this is true, we weaken global symbols (set BSF_WEAK).  */
d241 4
a244 1
static boolean weaken = false;
d273 6
d288 1
d294 1
d316 2
a328 1
  {"only-section", required_argument, 0, 'j'},
d332 1
d336 2
d339 3
d344 1
d348 3
d352 1
a352 2
  {"localize-symbol", required_argument, 0, 'L'},
  {"keep-global-symbol", required_argument, 0, 'G'},
d355 1
d358 2
d364 1
a369 7
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
d379 1
a379 1
   -1 means if we should use argv[0] to decide. */
d389 4
a392 1
extern boolean S3Forced;
d394 1
d400 3
a402 2
  fprintf (stream, _("Usage: %s <switches> in-file [out-file]\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
d406 1
d443 1
d454 6
d463 1
d476 3
a478 2
  fprintf (stream, _("Usage: %s <switches> in-file(s)\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
d480 3
a482 3
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
d484 1
a484 1
  -R --remove-section <name>       Remove section <name> from the output\n\
d486 1
a486 1
  -g -S --strip-debug              Remove all debugging symbols\n\
d488 2
a489 2
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
d495 1
d567 1
a567 1
     boolean add;
d580 3
a582 3
  p->used = false;
  p->remove = false;
  p->copy = false;
d587 1
a587 1
  p->set_flags = false;
d611 1
a611 1
/* Add symbols listed in `filename' to strip_specific_list. */
d626 1
a626 1
  
d645 1
a645 1
  
d651 1
a651 1
      int finished = false;
d662 1
a662 1
	      finished = true;
d664 1
a664 1
	      
d670 1
a670 1
	      finished = true;
d672 1
a672 1
	      
d674 1
a674 1
	      finished = true;
d676 1
a676 1
	      
d683 1
a683 1
	      
d700 2
a701 2
           name_end ++)
        ;
d714 1
a714 1
  
d730 1
a730 1
static boolean
d738 4
a741 5
    {
      if (strcmp (name, tmp_list->name) == 0)
	return true;
    }
  return false;
d746 1
a746 1
static boolean
d759 1
a759 1
    return true;
d762 1
a762 1
    return false;
d764 1
a764 1
  p = find_section_list (bfd_get_section_name (abfd, sec), false);
d766 1
a766 1
    return true;
d768 2
a769 2
    return true;
  return false;
d792 1
a792 1
      const char *name = bfd_asymbol_name (sym);
d794 5
d802 1
a802 1
	  const char *old_name, *new_name;
d804 53
a856 3
	  old_name = bfd_asymbol_name (sym);
	  new_name = lookup_sym_redefinition (old_name);
	  name = bfd_asymbol_name (sym) = new_name;
a858 30
      if (change_leading_char
	  && (bfd_get_symbol_leading_char (abfd)
	      != bfd_get_symbol_leading_char (obfd))
	  && (bfd_get_symbol_leading_char (abfd) == '\0'
	      || (name[0] == bfd_get_symbol_leading_char (abfd))))
	{
	  if (bfd_get_symbol_leading_char (obfd) == '\0')
	    name = bfd_asymbol_name (sym) = name + 1;
	  else
	    {
	      char *n;

	      n = xmalloc (strlen (name) + 2);
	      n[0] = bfd_get_symbol_leading_char (obfd);
	      if (bfd_get_symbol_leading_char (abfd) == '\0')
		strcpy (n + 1, name);
	      else
		strcpy (n + 1, name + 1);
	      name = bfd_asymbol_name (sym) = n;
	    }
	}

      if (remove_leading_char
	  && ((flags & BSF_GLOBAL) != 0
	      || (flags & BSF_WEAK) != 0
	      || bfd_is_und_section (bfd_get_section (sym))
	      || bfd_is_com_section (bfd_get_section (sym)))
	  && name[0] == bfd_get_symbol_leading_char (abfd))
	name = bfd_asymbol_name (sym) = name + 1;

d866 1
a866 1
      else if (relocatable			/* Relocatable file. */
d871 1
a871 1
	   even if relocatable is false.  External users of the
d874 1
a874 1
	  keep = 1;
d877 1
a877 1
	       || bfd_is_und_section (bfd_get_section (sym))
d884 4
d907 1
a907 1
      if (keep && (flags & (BSF_GLOBAL | BSF_WEAK))
d925 2
a930 1
  const char *result;
d933 3
a935 1
  result = source;
d937 1
a937 9
  for (list = redefine_sym_list; list != NULL; list = list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  result = list->target;
	  break;
	}
    }
  return result;
d940 1
a940 1
/* Add a node to a symbol redefine list */
d954 3
a956 5
	{
	  fatal (_("%s: Multiple redefinition of symbol \"%s\""),
		 "--redefine-sym",
		  source);
	}
d959 3
a961 5
	{
	  fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
		 "--redefine-sym",
		  target);
	}
a972 1

d985 1
d1006 2
d1031 10
a1040 5
  if (!bfd_set_start_address (obfd, start)
      || !bfd_set_file_flags (obfd,
			      (bfd_get_file_flags (ibfd)
			       & bfd_applicable_file_flags (obfd))))
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1042 6
a1047 3
  /* Copy architecture of input file to output file */
  if (!bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
			  bfd_get_mach (ibfd)))
d1087 1
a1087 1
	      pset = find_section_list (padd->name, false);
d1089 1
a1089 1
		pset->used = true;
d1162 2
a1163 2
			       bfd_get_section_name (obfd, osections[i]),
			       bfd_errmsg (bfd_get_error ()));
d1187 2
a1188 2
			   bfd_get_section_name (obfd, osections[c - 1]),
			   bfd_errmsg (bfd_get_error ()));
d1201 2
a1202 2
  /* Symbol filtering must happen after the output sections have
     been created, but before their contents are set.  */
d1225 1
a1283 1

d1299 1
d1324 1
a1324 1
  if (!bfd_copy_private_bfd_data (ibfd, obfd))
d1332 9
d1355 1
a1355 1
      char *name;
d1373 4
d1379 2
a1380 4
      /* Create an output file for this member.  */
      char *output_name = concat (dir, "/", bfd_get_filename (this_element),
				  (char *) NULL);
      bfd *output_bfd = bfd_openw (output_name, output_target);
d1385 23
d1411 1
d1425 1
a1425 4
      if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
	RETURN_NONFATAL (bfd_get_filename (obfd));

      if (bfd_check_format (this_element, bfd_object) == true)
d1431 1
a1431 1
	  /* Error in new object file. Don't change archive. */
d1463 7
a1469 2
      bfd_close (l->obfd);
      unlink (l->name);
d1484 2
a1485 1
  char **matching;
a1488 1

d1508 1
a1508 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &matching))
d1511 1
a1511 1

d1531 16
d1549 6
a1554 1
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
d1556 2
a1557 2
	  list_matching_formats (matching);
	  free (matching);
d1564 62
a1625 2
/* Create a section in OBFD with the same name and attributes
   as ISECTION in IBFD.  */
d1641 2
d1652 1
a1652 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1654 1
a1654 1
    p->used = true;
d1661 20
a1680 1
  osection = bfd_make_section_anyway (obfd, bfd_section_name (ibfd, isection));
d1728 3
a1730 4
  if (bfd_set_section_alignment (obfd,
				 osection,
				 bfd_section_alignment (ibfd, isection))
      == false)
a1735 1
  flags = bfd_get_section_flags (ibfd, isection);
d1737 1
a1737 1
    flags = p->flags | (flags & SEC_HAS_CONTENTS);
d1744 3
d1761 1
a1761 1
  /* All went well */
d1789 1
d1791 2
a1792 2
  /* If we have already failed earlier on, do not keep on generating
     complaints now.  */
d1796 2
a1797 1
  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
d1803 4
a1806 3
    {
      return;
    }
d1808 1
a1808 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1821 5
a1826 1
  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1842 1
a1842 1
	     keep_strip_specific_list. */
d1857 1
d1863 1
a1863 1
  isection->reloc_done = true;
d1865 2
a1866 1
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS)
d2009 1
a2009 1
static boolean
d2029 1
a2029 1
	return false;
d2051 1
a2051 1
	  return false;
d2066 1
a2066 1
	  return false;
d2069 1
a2069 1
      return true;
d2074 1
a2074 1
  return false;
d2082 6
a2087 3
  char *input_target = NULL, *output_target = NULL;
  boolean show_version = false;
  int c, i;
d2091 1
a2091 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXhVv",
d2106 3
a2108 3
	  p = find_section_list (optarg, true);
	  p->remove = true;
	  sections_removed = true;
d2131 1
a2131 1
	  preserve_dates = true;
d2140 1
a2140 1
	  verbose = true;
d2143 4
a2146 1
	  show_version = true;
d2149 3
a2151 1
	  break;		/* we've been given a long option */
d2159 6
d2226 8
a2233 4
  char *input_filename = NULL, *output_filename = NULL;
  char *input_target = NULL, *output_target = NULL;
  boolean show_version = false;
  boolean change_warn = true;
d2238 1
a2238 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXhVvW:",
d2249 4
d2274 1
a2274 1
	  p = find_section_list (optarg, true);
d2277 2
a2278 2
	  p->copy = true;
	  sections_copied = true;
d2282 1
a2282 1
	  p = find_section_list (optarg, true);
d2285 2
a2286 2
	  p->remove = true;
	  sections_removed = true;
d2322 1
a2322 1
	  preserve_dates = true;
d2334 1
a2334 1
	  verbose = true;
d2338 5
a2342 1
	  show_version = true;
d2346 1
a2346 1
	  weaken = true;
d2440 1
a2440 1
	    p = find_section_list (name, true);
d2477 1
a2477 1
	  change_warn = true;
d2481 1
a2481 1
	  change_leading_char = true;
d2485 1
a2485 1
	  convert_debugging = true;
d2503 1
a2503 1
	    gap_fill_set = true;
d2508 1
a2508 1
	  change_warn = false;
d2513 1
a2513 1
	  pad_to_set = true;
d2517 1
a2517 1
	  remove_leading_char = true;
d2531 1
a2531 3
	      {
		fatal (_("bad format for %s"), "--redefine-sym");
	      }
d2565 1
a2565 1
	    p = find_section_list (name, true);
d2567 1
a2567 1
	    p->set_flags = true;
d2572 44
d2618 1
a2618 1
	  set_start_set = true;
d2621 3
a2623 3
        case OPTION_SREC_LEN:
          Chunk = parse_vma (optarg, "--srec-len");
          break;
d2625 3
a2627 3
        case OPTION_SREC_FORCES3:
	  S3Forced = true;
          break;
d2649 18
d2670 1
d2679 6
d2705 1
a2705 1
  if (preserve_dates)
d2707 16
a2722 2
      if (stat (input_filename, &statbuf) < 0)
	fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2725 3
a2727 2
  /* If there is no destination file then create a temp and rename
     the result into the input.  */
d2729 4
a2732 1
  if (output_filename == (char *) NULL)
d2749 1
d2794 2
d2803 3
@


1.9
log
@resolve conflicts.
@
text
@d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d1966 1
a1966 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:R:SpgxXVvW:",
@


1.9.4.1
log
@MFC:
Fix by brad@@

sync the list of acceptable getopt_long options with reality.
Fixes PR 3623

From: binutils CVS 2.11 branch, based on rev 1.15.2.3

ok deraadt@@
@
text
@d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXhVv",
d1966 1
a1966 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXhVvW:",
@


1.9.6.1
log
@MFC:
Fix by brad@@

sync the list of acceptable getopt_long options with reality.
Fixes PR 3623

From: binutils CVS 2.11 branch, based on rev 1.15.2.3

ok deraadt@@
@
text
@d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXhVv",
d1966 1
a1966 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXhVvW:",
@


1.8
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d60 1
d188 2
a189 1
/* List of symbols to strip, keep, localize, weaken, or redefine.  */
d194 1
d222 7
d290 1
d305 7
d323 8
d353 1
d381 7
d536 116
d711 2
d767 9
d805 3
a807 1
	  && is_specified_symbol (name, localize_specific_list))
d913 7
d1119 1
d1417 1
a1417 1
  char *err;
d1440 1
a1440 1
      err = "making";
d1449 1
a1449 1
      err = "size";
d1463 1
a1463 1
      err = "vma";
d1489 1
a1489 1
      err = "alignment";
d1498 1
a1498 1
      err = "flags";
d1512 1
a1512 1
      err = "private data";
d1834 1
a1834 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
d1858 1
a1858 1
	case 'd':	/* NetBSD, historic BSD strip */
d2037 4
d2297 28
@


1.7
log
@Change make_tempname() interface to create file or directory when needed.
Use the new interface to call safe mkstemp or mkdtemp when available.
@
text
@d1662 1
a1662 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpgxXVv",
d1686 1
@


1.6
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1074 1
a1074 1
  char *dir = make_tempname (bfd_get_filename (obfd));
d1077 1
a1077 5
#if defined (_WIN32) && !defined (__CYGWIN32__)
  if (mkdir (dir) != 0)
#else
  if (mkdir (dir, 0700) != 0)
#endif
d1079 2
a1080 2
      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	     dir, strerror (errno));
d1759 1
a1759 1
	tmpname = make_tempname (argv[i]);
d2164 1
a2164 1
      char *tmpname = make_tempname (input_filename);
@


1.5
log
@Kill remaining instances of mktemp, direct and indirect.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
d31 21
d57 3
a59 3
static int compare_section_vma PARAMS ((const PTR, const PTR));
static void add_strip_symbol PARAMS ((const char *));
static boolean is_strip_symbol PARAMS ((const char *));
d64 1
d66 8
d75 1
a75 1
#define nonfatal(s) {bfd_nonfatal(s); status = 1; return;}
d85 1
d90 5
a94 5
    strip_undef,
    strip_none,			/* don't strip */
    strip_debug,		/* strip all debugger symbols */
    strip_unneeded,		/* strip unnecessary symbols */
    strip_all			/* strip all symbols */
d102 3
a104 3
    locals_undef,
    locals_start_L,		/* discard locals starting with L */
    locals_all			/* discard all locals */
d107 1
a107 1
/* Which local symbols to remove.  Overrides strip_all.  */
d110 8
a118 1

d121 11
a131 16
  /* Next section to adjust.  */
  struct section_list *next;
  /* Section name.  */
  const char *name;
  /* Whether this entry was used.  */
  boolean used;
  /* Whether to remove this section.  */
  boolean remove;
  /* Whether to adjust or set VMA.  */
  enum { ignore_vma, adjust_vma, set_vma } adjust;
  /* Amount to adjust by or set to.  */
  bfd_vma val;
  /* Whether to set the section flags.  */
  boolean set_flags;
  /* What to set the section flags to.  */
  flagword flags;
d134 1
a134 1
static struct section_list *adjust_sections;
d136 1
d138 2
a139 2
/* Adjustments to the start address.  */
static bfd_vma adjust_start = 0;
d143 2
a144 2
/* Adjustments to section VMA's.  */
static bfd_vma adjust_section_vma = 0;
d186 12
d201 8
a208 6
#define OPTION_ADJUST_START (OPTION_ADD_SECTION + 1)
#define OPTION_ADJUST_VMA (OPTION_ADJUST_START + 1)
#define OPTION_ADJUST_SECTION_VMA (OPTION_ADJUST_VMA + 1)
#define OPTION_ADJUST_WARNINGS (OPTION_ADJUST_SECTION_VMA + 1)
#define OPTION_CHANGE_LEADING_CHAR (OPTION_ADJUST_WARNINGS + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_LEADING_CHAR + 1)
d210 2
a211 2
#define OPTION_NO_ADJUST_WARNINGS (OPTION_GAP_FILL + 1)
#define OPTION_PAD_TO (OPTION_NO_ADJUST_WARNINGS + 1)
d216 2
d232 1
d249 4
a252 4
  {"adjust-start", required_argument, 0, OPTION_ADJUST_START},
  {"adjust-vma", required_argument, 0, OPTION_ADJUST_VMA},
  {"adjust-section-vma", required_argument, 0, OPTION_ADJUST_SECTION_VMA},
  {"adjust-warnings", no_argument, 0, OPTION_ADJUST_WARNINGS},
d254 1
d256 5
d264 1
d272 2
a273 1
  {"no-adjust-warnings", no_argument, 0, OPTION_NO_ADJUST_WARNINGS},
d277 2
d290 3
d310 47
a356 16
  fprintf (stream, "\
Usage: %s [-vVSgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-b byte]\n\
       [-R section] [-i interleave] [--interleave=interleave] [--byte=byte]\n\
       [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\
       [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\
       [--discard-locals] [--debugging] [--remove-section=section]\n",
	   program_name);
  fprintf (stream, "\
       [--gap-fill=val] [--pad-to=address]\n\
       [--set-start=val] [--adjust-start=incr]\n\
       [--adjust-vma=incr] [--adjust-section-vma=section{=,+,-}val]\n\
       [--adjust-warnings] [--no-adjust-warnings]\n\
       [--set-section-flags=section=flags] [--add-section=sectionname=filename]\n\
       [--keep-symbol symbol] [-K symbol] [--strip-symbol symbol] [-N symbol]\n\
       [--change-leading-char] [--remove-leading-char] [--verbose]\n\
       [--version] [--help] in-file [out-file]\n");
d359 1
a359 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d368 21
a388 8
  fprintf (stream, "\
Usage: %s [-vVsSgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-R section]\n\
       [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\
       [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\
       [--discard-locals] [--keep-symbol symbol] [-K symbol]\n\
       [--strip-symbol symbol] [-N symbol] [--remove-section=section]\n\
       [-o file] [--verbose] [--version] [--help] file...\n",
	   program_name);
d391 1
a391 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d419 3
a421 1
#define PARSE_FLAG(fname,fval) if (strncmp (fname, s, len) == 0) ret |= fval;
d424 1
d426 1
d430 2
d433 11
d452 1
a452 1
/* Find and optionally add an entry in the adjust_sections list.  */
d461 1
a461 1
  for (p = adjust_sections; p != NULL; p = p->next)
d472 5
a476 2
  p->adjust = ignore_vma;
  p->val = 0;
d480 2
a481 2
  p->next = adjust_sections;
  adjust_sections = p;
a485 20
/* Make a list of symbols to explicitly strip out, or to keep.  A
   linked list is good enough for a small number from the command
   line, but this will slow things down a lot if many symbols are
   being deleted. */

struct symlist
{
  const char *name;
  struct symlist *next;
};

/* List of symbols to strip.  */

static struct symlist *strip_specific_list = NULL;

/* If this is false, we strip the symbols in strip_specific_list.
   Otherwise, we keep only the symbols in the list.  */

static boolean keep_symbols = false;

d488 2
a489 2
static void 
add_strip_symbol (name)
d491 1
d497 2
a498 2
  tmp_list->next = strip_specific_list;
  strip_specific_list = tmp_list;
d505 1
a505 1
is_strip_symbol (name)
d507 1
d511 1
a511 1
  for (tmp_list = strip_specific_list; tmp_list; tmp_list = tmp_list->next)
d514 1
a514 1
	return keep_symbols ? false : true;
d516 1
a516 1
  return keep_symbols;
d523 1
a523 1
     bfd *abfd;
d529 4
a532 4
      && (strip_symbols == strip_debug
	  || strip_symbols == strip_unneeded
	  || strip_symbols == strip_all
	  || discard_locals == locals_all
d536 1
a536 1
  if (! sections_removed)
d538 1
d540 5
a544 1
  return p != NULL && p->remove ? true : false;
d565 1
d568 9
d581 1
a581 2
	      || (bfd_asymbol_name (sym)[0]
		  == bfd_get_symbol_leading_char (abfd))))
d584 1
a584 1
	    bfd_asymbol_name (sym) = bfd_asymbol_name (sym) + 1;
d589 1
a589 1
	      n = xmalloc (strlen (bfd_asymbol_name (sym)) + 2);
d592 1
a592 1
		strcpy (n + 1, bfd_asymbol_name (sym));
d594 2
a595 2
		strcpy (n + 1, bfd_asymbol_name (sym) + 1);
	      bfd_asymbol_name (sym) = n;
d604 2
a605 2
	  && bfd_asymbol_name (sym)[0] == bfd_get_symbol_leading_char (abfd))
	bfd_asymbol_name (sym) = bfd_asymbol_name (sym) + 1;
d607 6
a612 1
      if ((flags & BSF_KEEP) != 0)		/* Used in relocation.  */
d618 1
a618 1
	keep = strip_symbols != strip_unneeded;
d620 2
a621 2
	keep = (strip_symbols != strip_debug
		&& strip_symbols != strip_unneeded
d624 3
a626 3
	keep = (strip_symbols != strip_unneeded
		&& (discard_locals != locals_all
		    && (discard_locals != locals_start_L
d629 1
a629 1
      if (keep && is_strip_symbol (bfd_asymbol_name (sym)))
d631 2
d636 13
d658 58
d719 1
a719 1
void
d728 4
a731 1
  *size /= interleave;
d746 3
d751 1
a751 3
    {
      nonfatal (bfd_get_filename (obfd));
    }
d754 3
a756 3
    printf ("copy from %s(%s) to %s(%s)\n",
	    bfd_get_filename(ibfd), bfd_get_target(ibfd),
	    bfd_get_filename(obfd), bfd_get_target(obfd));
d762 1
a762 1
  start += adjust_start;
d768 1
a768 3
    {
      nonfatal (bfd_get_filename (ibfd));
    }
d773 1
a773 3
    {
      fprintf (stderr,
	       "Warning: Output file cannot represent architecture %s\n",
d776 1
a776 1
    }
d778 1
a778 3
    {
      nonfatal (bfd_get_filename(ibfd));
    }
d782 1
d786 1
a786 1
  /* bfd mandates that all output sections be created and sizes set before
d800 2
a801 3
	      fprintf (stderr, "%s: can't create section `%s': %s\n",
		       program_name, padd->name,
		       bfd_errmsg (bfd_get_error ()));
d808 1
a808 1
	      
d810 1
a810 1
		nonfatal (bfd_get_filename (obfd));
d820 1
d822 1
a822 1
		nonfatal (bfd_get_filename (obfd));
d824 1
a824 3
	      if (pset != NULL
		  && (pset->adjust == adjust_vma
		      || pset->adjust == set_vma))
d826 13
a838 2
		  if (! bfd_set_section_vma (obfd, padd->section, pset->val))
		    nonfatal (bfd_get_filename (obfd));
d860 1
a860 1
      qsort (osections, c, sizeof (asection *), compare_section_vma);
d879 2
a880 2
	      gap_start = bfd_section_vma (obfd, osections[i]) + size;
	      gap_stop = bfd_section_vma (obfd, osections[i + 1]);
d886 1
a886 2
		      fprintf (stderr, "%s: Can't fill gap after %s: %s\n",
			       program_name,
d888 1
a888 1
			       bfd_errmsg (bfd_get_error()));
d901 1
a901 1
	  bfd_vma vma;
d904 1
a904 1
	  vma = bfd_section_vma (obfd, osections[c - 1]);
d906 1
a906 1
	  if (vma + size < pad_to)
d909 1
a909 1
					  pad_to - vma))
d911 1
a911 2
		  fprintf (stderr, "%s: Can't add padding to %s: %s\n",
			   program_name,
d918 3
a920 3
		  gaps[c - 1] = pad_to - (vma + size);
		  if (max_gap < pad_to - (vma + size))
		    max_gap = pad_to - (vma + size);
d923 1
a923 1
	}	      
d928 43
a970 4
  if (strip_symbols == strip_all)
    {
      osympp = isympp = NULL;
      symcount = 0;
d972 2
a973 1
  else
d975 1
a975 27
      long symsize;
      PTR dhandle = NULL;

      symsize = bfd_get_symtab_upper_bound (ibfd);
      if (symsize < 0)
	{
	  nonfatal (bfd_get_filename (ibfd));
	}

      osympp = isympp = (asymbol **) xmalloc (symsize);
      symcount = bfd_canonicalize_symtab (ibfd, isympp);
      if (symcount < 0)
	{
	  nonfatal (bfd_get_filename (ibfd));
	}

      if (convert_debugging)
	dhandle = read_debugging_info (ibfd, isympp, symcount);

      if (strip_symbols == strip_debug 
	  || strip_symbols == strip_unneeded
	  || discard_locals != locals_undef
	  || strip_specific_list != NULL
	  || sections_removed
	  || convert_debugging
	  || change_leading_char
	  || remove_leading_char)
d977 2
a978 22
	  /* Mark symbols used in output relocations so that they
	     are kept, even if they are local labels or static symbols.

	     Note we iterate over the input sections examining their
	     relocations since the relocations for the output sections
	     haven't been set yet.  mark_symbols_used_in_relocations will
	     ignore input sections which have no corresponding output
	     section.  */
	  bfd_map_over_sections (ibfd,
				 mark_symbols_used_in_relocations,
				 (PTR)isympp);
	  osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
	  symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
	}

      if (convert_debugging && dhandle != NULL)
	{
	  if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
	    {
	      status = 1;
	      return;
	    }
d997 1
a997 1
	    nonfatal (bfd_get_filename (obfd));
d1031 1
d1034 2
a1035 3
		    {
		      nonfatal (bfd_get_filename (obfd));
		    }
d1049 3
a1051 3
      fprintf (stderr, "%s: %s: error copying private BFD data: %s\n",
	       program_name, bfd_get_filename (obfd),
	       bfd_errmsg (bfd_get_error ()));
a1056 15
static char *
cat (a, b, c)
     char *a;
     char *b;
     char *c;
{
  size_t size = strlen (a) + strlen (b) + strlen (c);
  char *r = xmalloc (size + 1);

  strcpy (r, a);
  strcat (r, b);
  strcat (r, c);
  return r;
}

d1064 1
a1064 1
     char *output_target;
d1074 1
a1074 1
  char *dir = make_tempdir (bfd_get_filename (obfd));
d1077 5
a1081 1
  if (dir == 0)
d1083 2
a1084 2
      fatal ("cannot create tempdir for archive copying (error: %s)",
	     strerror (errno));
d1091 1
a1091 1
  while (this_element != (bfd *) NULL)
d1094 2
a1095 1
      char *output_name = cat (dir, "/", bfd_get_filename(this_element));
d1098 10
d1115 2
a1116 3
	{
	  nonfatal (output_name);
	}
d1118 1
a1118 3
	{
	  nonfatal (bfd_get_filename (obfd));
	}
d1121 3
d1125 3
a1127 1
	  copy_object (this_element, output_bfd);
d1130 2
a1131 1
      bfd_close (output_bfd);
d1150 1
a1150 3
    {
      nonfatal (bfd_get_filename (obfd));
    }
d1153 1
a1153 3
    {
      nonfatal (bfd_get_filename (ibfd));
    }
d1168 4
a1171 4
     char *input_filename;
     char *output_filename;
     char *input_target;
     char *output_target;
d1181 1
a1181 3
    {
      nonfatal (input_filename);
    }
d1194 2
a1195 3
	{
	  nonfatal (output_filename);
	}
d1209 1
a1209 3
	{
	  nonfatal (output_filename);
	}
d1214 1
a1214 3
	{
	  nonfatal (output_filename);
	}
d1217 1
a1217 3
	{
	  nonfatal (input_filename);
	}
d1222 1
d1228 1
d1245 1
d1252 4
a1255 4
      && (strip_symbols == strip_debug
	  || strip_symbols == strip_unneeded
	  || strip_symbols == strip_all
	  || discard_locals == locals_all
d1263 3
a1265 1
  if (p != NULL && p->remove)
d1269 1
d1276 4
a1279 3
  if (!bfd_set_section_size (obfd,
			     osection,
			     bfd_section_size (ibfd, isection)))
d1286 4
a1289 4
  if (p != NULL && p->adjust == adjust_vma)
    vma += p->val;
  else if (p != NULL && p->adjust == set_vma)
    vma = p->val;
d1291 2
a1292 1
    vma += adjust_section_vma;
d1300 9
a1308 4
  if (p != NULL && p->adjust == adjust_vma)
    lma += p->val;
  else if (p != NULL && p->adjust == set_vma)
    lma = p->val;
d1310 2
a1311 1
    lma += adjust_section_vma;
d1314 2
d1352 4
a1355 4
  fprintf (stderr, "%s: %s: section `%s': error in %s: %s\n",
	   program_name,
	   bfd_get_filename (ibfd), bfd_section_name (ibfd, isection),
	   err, bfd_errmsg (bfd_get_error ()));
d1375 6
d1383 4
a1386 4
      && (strip_symbols == strip_debug
	  || strip_symbols == strip_unneeded
	  || strip_symbols == strip_all
	  || discard_locals == locals_all
d1394 3
a1396 1
  if (p != NULL && p->remove)
d1405 6
a1410 1
  if (strip_symbols == strip_all)
d1414 22
a1435 18
      long relsize;

      relsize = bfd_get_reloc_upper_bound (ibfd, isection);
      if (relsize < 0)
	{
	  nonfatal (bfd_get_filename (ibfd));
	}
      if (relsize == 0)
	bfd_set_reloc (obfd, osection, (arelent **) NULL, 0);
      else
	{
	  relpp = (arelent **) xmalloc (relsize);
	  relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
	  if (relcount < 0)
	    {
	      nonfatal (bfd_get_filename (ibfd));
	    }
	  bfd_set_reloc (obfd, osection, relpp, relcount);
d1437 2
d1450 1
a1450 3
	{
	  nonfatal (bfd_get_filename (ibfd));
	}
d1452 2
a1453 7
      if (copy_byte >= 0) 
        {
	  filter_bytes (memhunk, &size);
              /* The section has gotten smaller. */
          if (!bfd_set_section_size (obfd, osection, size))
            nonfatal (bfd_get_filename (obfd));
        }
d1457 18
a1474 3
	{
	  nonfatal (bfd_get_filename (obfd));
	}
d1484 1
a1484 1
     bfd *obfd;
d1499 1
a1499 1
compare_section_vma (arg1, arg2)
d1524 2
a1525 2
  /* Sort sections by VMA.  */
  if ((*sec1)->vma > (*sec2)->vma)
d1527 1
a1527 1
  else if ((*sec1)->vma < (*sec2)->vma)
d1530 1
a1530 1
  /* Sort sections with the same VMA by size.  */
d1591 2
a1592 2
     long *symcountp;
     asymbol ***symppp;
d1626 3
a1628 2
	  fprintf (stderr, "%s: can't create debugging section: %s\n",
		   bfd_get_filename (obfd), bfd_errmsg (bfd_get_error ()));
d1641 3
a1643 2
	  fprintf (stderr, "%s: can't set debugging section contents: %s\n",
		   bfd_get_filename (obfd), bfd_errmsg (bfd_get_error ()));
d1650 2
a1651 3
  fprintf (stderr,
	   "%s: don't know how to write debugging information for %s\n",
	   bfd_get_filename (obfd), bfd_get_target (obfd));
a1654 117
/* The number of bytes to copy at once.  */
#define COPY_BUF 8192

/* Copy file FROM to file TO, performing no translations.
   Return 0 if ok, -1 if error.  */

static int
simple_copy (from, to)
     char *from, *to;
{
  int fromfd, tofd, nread;
  int saved;
  char buf[COPY_BUF];

  fromfd = open (from, O_RDONLY);
  if (fromfd < 0)
    return -1;
  tofd = creat (to, 0777);
  if (tofd < 0)
    {
      saved = errno;
      close (fromfd);
      errno = saved;
      return -1;
    }
  while ((nread = read (fromfd, buf, sizeof buf)) > 0)
    {
      if (write (tofd, buf, nread) != nread)
	{
	  saved = errno;
	  close (fromfd);
	  close (tofd);
	  errno = saved;
	  return -1;
	}
    }
  saved = errno;
  close (fromfd);
  close (tofd);
  if (nread < 0)
    {
      errno = saved;
      return -1;
    }
  return 0;
}

#ifndef S_ISLNK
#ifdef S_IFLNK
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#else
#define S_ISLNK(m) 0
#define lstat stat
#endif
#endif

/* Rename FROM to TO, copying if TO is a link.
   Assumes that TO already exists, because FROM is a temp file.
   Return 0 if ok, -1 if error.  */

static int
smart_rename (from, to)
     char *from, *to;
{
  struct stat s;
  int ret = 0;

  if (lstat (to, &s))
    return -1;

  /* Use rename only if TO is not a symbolic link and has
     only one hard link.  */
  if (!S_ISLNK (s.st_mode) && s.st_nlink == 1)
    {
      ret = rename (from, to);
      if (ret == 0)
	{
	  /* Try to preserve the permission bits and ownership of TO.
             First get the mode right except for the setuid bit.  Then
             change the ownership.  Then fix the setuid bit.  We do
             the chmod before the chown because if the chown succeeds,
             and we are a normal user, we won't be able to do the
             chmod afterward.  We don't bother to fix the setuid bit
             first because that might introduce a fleeting security
             problem, and because the chown will clear the setuid bit
             anyhow.  We only fix the setuid bit if the chown
             succeeds, because we don't want to introduce an
             unexpected setuid file owned by the user running objcopy.  */
	  chmod (to, s.st_mode & 0777);
	  if (chown (to, s.st_uid, s.st_gid) >= 0)
	    chmod (to, s.st_mode & 07777);
	}
      else
	{
	  /* We have to clean up here. */
	  int saved = errno;
	  fprintf (stderr, "%s: %s: ", program_name, to);
	  errno = saved;
	  perror ("rename");
	  unlink (from);
	}
    }
  else
    {
      ret = simple_copy (from, to);
      if (ret != 0)
	{
	  int saved = errno;
	  fprintf (stderr, "%s: %s: ", program_name, to);
	  errno = saved;
	  perror ("simple_copy");
	}
      unlink (from);
    }
  return ret;
}

d1666 1
a1666 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSgxXVv",
d1686 1
a1686 1
	  strip_symbols = strip_all;
d1690 1
a1690 1
	  strip_symbols = strip_debug;
d1693 1
a1693 1
	  strip_symbols = strip_unneeded;
d1696 1
a1696 8
	  if (! keep_symbols && strip_specific_list != NULL)
	    {
	      fprintf (stderr, "%s: Can not specify both -K and -N\n",
		       program_name);
	      strip_usage (stderr, 1);
	    }
	  keep_symbols = true;
	  add_strip_symbol (optarg);
d1699 1
a1699 7
	  if (keep_symbols)
	    {
	      fprintf (stderr, "%s: Can not specify both -K and -N\n",
		       program_name);
	      strip_usage (stderr, 1);
	    }
	  add_strip_symbol (optarg);
d1704 3
d1708 1
a1708 1
	  discard_locals = locals_all;
d1711 1
a1711 1
	  discard_locals = locals_start_L;
d1732 2
a1733 2
  if (strip_symbols == strip_undef
      && discard_locals == locals_undef
d1735 1
a1735 1
    strip_symbols = strip_all;
d1748 1
d1751 9
d1765 1
d1769 2
d1772 1
a1772 1
	    smart_rename (tmpname, argv[i]);
d1792 1
a1792 1
  boolean adjust_warn = true;
d1795 1
d1797 1
a1797 1
  while ((c = getopt_long (argc, argv, "b:i:I:K:N:s:O:d:F:R:SgxXVv",
d1803 1
a1803 1
	  copy_byte = atoi(optarg);
d1805 1
a1805 5
	    {
	      fprintf (stderr, "%s: byte number must be non-negative\n",
		       program_name);
	      exit (1);
	    }
d1807 1
d1809 1
a1809 1
	  interleave = atoi(optarg);
d1811 1
a1811 5
	    {
	      fprintf(stderr, "%s: interleave must be positive\n",
		      program_name);
	      exit (1);
	    }
d1813 1
d1818 1
d1823 1
d1827 9
d1838 2
d1843 1
d1845 1
a1845 1
	  strip_symbols = strip_all;
d1847 1
d1849 1
a1849 1
	  strip_symbols = strip_debug;
d1851 1
d1853 1
a1853 1
	  strip_symbols = strip_unneeded;
d1855 1
d1857 1
a1857 8
	  if (! keep_symbols && strip_specific_list != NULL)
	    {
	      fprintf (stderr, "%s: Can not specify both -K and -N\n",
		       program_name);
	      strip_usage (stderr, 1);
	    }
	  keep_symbols = true;
	  add_strip_symbol (optarg);
d1859 1
d1861 13
a1873 7
	  if (keep_symbols)
	    {
	      fprintf (stderr, "%s: Can not specify both -K and -N\n",
		       program_name);
	      strip_usage (stderr, 1);
	    }
	  add_strip_symbol (optarg);
d1875 1
d1877 1
a1877 1
	  discard_locals = locals_all;
d1879 1
d1881 1
a1881 1
	  discard_locals = locals_start_L;
d1883 1
d1887 1
d1891 5
d1906 1
d1908 1
a1908 6
	      {
		fprintf (stderr,
			 "%s: bad format for --add-section NAME=FILENAME\n",
			 program_name);
		exit (1);
	      }
d1910 2
a1911 6
	    if (stat (s + 1, &st) < 0)
	      {
		fprintf (stderr, "%s: ", program_name);
		perror (s + 1);
		exit (1);
	      }
d1927 1
d1929 2
a1930 5
	      {
		fprintf (stderr, "%s: ", program_name);
		perror (pa->filename);
		exit (1);
	      }
d1933 2
a1934 5
	      {
		fprintf (stderr, "%s: %s: fread failed\n",
			 program_name, pa->filename);
		exit (1);
	      }
d1941 3
a1943 2
	case OPTION_ADJUST_START:
	  adjust_start = parse_vma (optarg, "--adjust-start");
d1945 4
a1948 1
	case OPTION_ADJUST_SECTION_VMA:
d1953 16
d1978 1
a1978 6
		      {
			fprintf (stderr,
				 "%s: bad format for --adjust-section-vma\n",
				 program_name);
			exit (1);
		      }
d1989 8
a1996 1
	    p->val = parse_vma (s + 1, "--adjust-section-vma");
d1998 1
a1998 3
	    if (*s == '=')
	      p->adjust = set_vma;
	    else
d2000 14
a2013 3
		p->adjust = adjust_vma;
		if (*s == '-')
		  p->val = - p->val;
d2017 4
a2020 3
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
	  adjust_start = adjust_section_vma;
d2022 3
a2024 2
	case OPTION_ADJUST_WARNINGS:
	  adjust_warn = true;
d2026 1
d2030 1
d2034 1
d2043 6
a2048 4
		fprintf (stderr, "%s: warning: truncating gap-fill from 0x",
			 program_name);
		fprintf_vma (stderr, gap_fill_vma);
		fprintf (stderr, "to 0x%x\n", (unsigned int) gap_fill);
d2053 3
a2055 2
	case OPTION_NO_ADJUST_WARNINGS:
	  adjust_warn = false;
d2057 1
d2062 1
d2066 33
d2107 1
a2107 5
	      {
		fprintf (stderr, "%s: bad format for --set-section-flags\n",
			 program_name);
		exit (1);
	      }
d2120 1
d2125 1
d2128 1
d2131 1
d2141 1
a2141 5
    {
      fprintf (stderr, "%s: byte number must be less than interleave\n",
	       program_name);
      exit (1);
    }
d2151 2
a2152 2
  if (strip_symbols == strip_undef && discard_locals == locals_undef)
    strip_symbols = strip_none;
d2157 6
d2169 1
d2172 5
a2176 1
	smart_rename (tmpname, input_filename);
d2183 2
d2187 1
a2187 1
  if (adjust_warn)
d2189 1
a2189 1
      for (p = adjust_sections; p != NULL; p = p->next)
d2191 1
a2191 1
	  if (! p->used && p->adjust != ignore_vma)
d2193 27
a2219 5
	      fprintf (stderr, "%s: warning: --adjust-section-vma %s%c0x",
		       program_name, p->name,
		       p->adjust == set_vma ? '=' : '+');
	      fprintf_vma (stderr, p->val);
	      fprintf (stderr, " never used\n");
d2232 6
d2243 2
a2244 2
  strip_symbols = strip_undef;
  discard_locals = locals_undef;
d2247 1
d2252 9
a2260 1
      is_strip = (i >= 5 && strcmp (program_name + i - 5, "strip") == 0);
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d884 1
a884 1
  char *dir = make_tempname (bfd_get_filename (obfd));
d887 1
a887 1
  if (mkdir (dir, 0700) != 0)
d889 2
a890 2
      fatal ("cannot mkdir %s for archive copying (error: %s)",
	     dir, strerror (errno));
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d38 1
a38 1
  PARAMS ((bfd *, asymbol **, asymbol **, long));
d141 4
d156 2
a157 1
#define OPTION_DEBUGGING (OPTION_ADJUST_WARNINGS + 1)
d200 1
a230 1
extern char *program_version;
d257 2
a258 2
       [--remove-leading-char] [--verbose] [--version] [--help]\n\
       in-file [out-file]\n");
d260 2
d279 2
d434 1
a434 1
filter_symbols (abfd, osyms, isyms, symcount)
d436 1
d449 23
d749 1
d764 1
a764 1
	  symcount = filter_symbols (ibfd, osympp, isympp, symcount);
d1617 1
a1617 4
    {
      printf ("GNU %s version %s\n", program_name, program_version);
      exit (0);
    }
d1860 3
d1931 1
a1931 4
    {
      printf ("GNU %s version %s\n", program_name, program_version);
      exit (0);
    }
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d269 1
a269 1
       [--verbose] [--version] [--help] file...\n",
d1508 1
d1510 1
a1510 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:sSgxXVv",
d1558 3
d1598 2
a1599 1
  if (i == argc)
d1605 1
d1607 4
a1610 1
      char *tmpname = make_tempname (argv[i]);
d1615 2
a1616 1
	  smart_rename (tmpname, argv[i]);
d1621 2
a1622 1
      free (tmpname);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94 Free Software Foundation, Inc.
d23 1
a23 1
#include <getopt.h>
d25 1
d40 1
d137 8
d152 2
a153 1
#define OPTION_GAP_FILL (OPTION_ADJUST_WARNINGS + 1)
d156 2
a157 1
#define OPTION_SET_SECTION_FLAGS (OPTION_PAD_TO + 1)
d195 1
d209 1
d243 1
a243 1
       [--discard-locals] [--remove-section=section] [--gap-fill=val]\n",
d246 2
a247 1
       [--pad-to=address] [--set-start=val] [--adjust-start=incr]\n\
d252 1
a252 1
       [--verbose] [--version] [--help]\n\
d410 2
a411 1
	  || discard_locals == locals_all))
d439 8
d450 1
d456 2
a457 1
		&& strip_symbols != strip_unneeded);
d473 2
d534 2
a535 1
      fprintf (stderr, "Output file cannot represent architecture %s\n",
d692 1
d707 3
d714 3
a716 1
	  || sections_removed)
d729 1
a729 1
	  osympp = (asymbol **) xmalloc (symcount * sizeof (asymbol *));
d732 9
d1023 2
a1024 1
	  || discard_locals == locals_all))
d1135 2
a1136 1
	  || discard_locals == locals_all))
d1313 69
d1459 14
a1472 3
	  /* Try to preserve the permission bits and ownership of TO.  */
	  chmod (to, s.st_mode & 07777);
	  chown (to, s.st_uid, s.st_gid);
d1818 3
d1843 3
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d23 1
a23 1
#include "getopt.h"
a24 1
#include "budbg.h"
a38 1
static boolean write_debugging_info PARAMS ((bfd *, PTR, long *, asymbol ***));
a134 8
/* Whether to convert debugging information.  */

static boolean convert_debugging = false;

/* Whether to remove the leading character from global symbol names.  */

static boolean remove_leading_char = false;

d142 1
a142 2
#define OPTION_DEBUGGING (OPTION_ADJUST_WARNINGS + 1)
#define OPTION_GAP_FILL (OPTION_DEBUGGING + 1)
d145 1
a145 2
#define OPTION_REMOVE_LEADING_CHAR (OPTION_PAD_TO + 1)
#define OPTION_SET_SECTION_FLAGS (OPTION_REMOVE_LEADING_CHAR + 1)
a182 1
  {"debugging", no_argument, 0, OPTION_DEBUGGING},
a195 1
  {"remove-leading-char", no_argument, 0, OPTION_REMOVE_LEADING_CHAR},
d229 1
a229 1
       [--discard-locals] [--debugging] [--remove-section=section]\n",
d232 1
a232 2
       [--gap-fill=val] [--pad-to=address]\n\
       [--set-start=val] [--adjust-start=incr]\n\
d237 1
a237 1
       [--remove-leading-char] [--verbose] [--version] [--help]\n\
d395 1
a395 2
	  || discard_locals == locals_all
	  || convert_debugging))
a422 8
      if (remove_leading_char
	  && ((flags & BSF_GLOBAL) != 0
	      || (flags & BSF_WEAK) != 0
	      || bfd_is_und_section (bfd_get_section (sym))
	      || bfd_is_com_section (bfd_get_section (sym)))
	  && bfd_asymbol_name (sym)[0] == bfd_get_symbol_leading_char (abfd))
	bfd_asymbol_name (sym) = bfd_asymbol_name (sym) + 1;

a425 1
	       || (flags & BSF_WEAK) != 0
d431 1
a431 2
		&& strip_symbols != strip_unneeded
		&& ! convert_debugging);
a446 2
  to[dst_count] = NULL;

d506 1
a506 2
      fprintf (stderr,
	       "Warning: Output file cannot represent architecture %s\n",
a662 1
      PTR dhandle = NULL;
a676 3
      if (convert_debugging)
	dhandle = read_debugging_info (ibfd, isympp, symcount);

d681 1
a681 3
	  || sections_removed
	  || convert_debugging
	  || remove_leading_char)
d694 1
a694 1
	  osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
a696 9

      if (convert_debugging && dhandle != NULL)
	{
	  if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
	    {
	      status = 1;
	      return;
	    }
	}
d979 1
a979 2
	  || discard_locals == locals_all
	  || convert_debugging))
d1090 1
a1090 2
	  || discard_locals == locals_all
	  || convert_debugging))
a1266 69
/* Write out debugging information.  */

static boolean
write_debugging_info (obfd, dhandle, symcountp, symppp)
     bfd *obfd;
     PTR dhandle;
     long *symcountp;
     asymbol ***symppp;
{
  if (bfd_get_flavour (obfd) == bfd_target_ieee_flavour)
    return write_ieee_debugging_info (obfd, dhandle);

  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
      || bfd_get_flavour (obfd) == bfd_target_elf_flavour)
    {
      bfd_byte *syms, *strings;
      bfd_size_type symsize, stringsize;
      asection *stabsec, *stabstrsec;

      if (! write_stabs_in_sections_debugging_info (obfd, dhandle, &syms,
						    &symsize, &strings,
						    &stringsize))
	return false;

      stabsec = bfd_make_section (obfd, ".stab");
      stabstrsec = bfd_make_section (obfd, ".stabstr");
      if (stabsec == NULL
	  || stabstrsec == NULL
	  || ! bfd_set_section_size (obfd, stabsec, symsize)
	  || ! bfd_set_section_size (obfd, stabstrsec, stringsize)
	  || ! bfd_set_section_alignment (obfd, stabsec, 2)
	  || ! bfd_set_section_alignment (obfd, stabstrsec, 0)
	  || ! bfd_set_section_flags (obfd, stabsec,
				   (SEC_HAS_CONTENTS
				    | SEC_READONLY
				    | SEC_DEBUGGING))
	  || ! bfd_set_section_flags (obfd, stabstrsec,
				      (SEC_HAS_CONTENTS
				       | SEC_READONLY
				       | SEC_DEBUGGING)))
	{
	  fprintf (stderr, "%s: can't create debugging section: %s\n",
		   bfd_get_filename (obfd), bfd_errmsg (bfd_get_error ()));
	  return false;
	}

      /* We can get away with setting the section contents now because
         the next thing the caller is going to do is copy over the
         real sections.  We may someday have to split the contents
         setting out of this function.  */
      if (! bfd_set_section_contents (obfd, stabsec, syms, (file_ptr) 0,
				      symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings,
					 (file_ptr) 0, stringsize))
	{
	  fprintf (stderr, "%s: can't set debugging section contents: %s\n",
		   bfd_get_filename (obfd), bfd_errmsg (bfd_get_error ()));
	  return false;
	}

      return true;
    }

  fprintf (stderr,
	   "%s: don't know how to write debugging information for %s\n",
	   bfd_get_filename (obfd), bfd_get_target (obfd));
  return false;
}

d1344 3
a1346 14
	  /* Try to preserve the permission bits and ownership of TO.
             First get the mode right except for the setuid bit.  Then
             change the ownership.  Then fix the setuid bit.  We do
             the chmod before the chown because if the chown succeeds,
             and we are a normal user, we won't be able to do the
             chmod afterward.  We don't bother to fix the setuid bit
             first because that might introduce a fleeting security
             problem, and because the chown will clear the setuid bit
             anyhow.  We only fix the setuid bit if the chown
             succeeds, because we don't want to introduce an
             unexpected setuid file owned by the user running objcopy.  */
	  chmod (to, s.st_mode & 0777);
	  if (chown (to, s.st_uid, s.st_gid) >= 0)
	    chmod (to, s.st_mode & 07777);
a1691 3
	case OPTION_DEBUGGING:
	  convert_debugging = true;
	  break;
a1713 3
	  break;
	case OPTION_REMOVE_LEADING_CHAR:
	  remove_leading_char = true;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d269 1
a269 1
       [-o file] [--verbose] [--version] [--help] file...\n",
a1507 1
  char *output_file = NULL;
d1509 1
a1509 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSgxXVv",
a1556 3
	case 'o':
	  output_file = optarg;
	  break;
d1594 1
a1594 2
  if (i == argc
      || (output_file != NULL && (i + 1) < argc))
a1599 1
      char *tmpname;
d1601 1
a1601 4
      if (output_file != NULL)
	tmpname = output_file;
      else
	tmpname = make_tempname (argv[i]);
d1606 1
a1606 2
	  if (output_file == NULL)
	    smart_rename (tmpname, argv[i]);
d1611 1
a1611 2
      if (output_file == NULL)
	free (tmpname);
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d38 1
a38 1
  PARAMS ((bfd *, bfd *, asymbol **, asymbol **, long));
a140 4
/* Whether to change the leading character in symbol names.  */

static boolean change_leading_char = false;

d152 1
a152 2
#define OPTION_CHANGE_LEADING_CHAR (OPTION_ADJUST_WARNINGS + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_LEADING_CHAR + 1)
a194 1
  {"change-leading-char", no_argument, 0, OPTION_CHANGE_LEADING_CHAR},
d225 1
d252 2
a253 2
       [--change-leading-char] [--remove-leading-char] [--verbose]\n\
       [--version] [--help] in-file [out-file]\n");
a254 2
  if (exit_status == 0)
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
a271 2
  if (exit_status == 0)
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d425 1
a425 1
filter_symbols (abfd, obfd, osyms, isyms, symcount)
a426 1
     bfd *obfd;
a438 23
      if (change_leading_char
	  && (bfd_get_symbol_leading_char (abfd)
	      != bfd_get_symbol_leading_char (obfd))
	  && (bfd_get_symbol_leading_char (abfd) == '\0'
	      || (bfd_asymbol_name (sym)[0]
		  == bfd_get_symbol_leading_char (abfd))))
	{
	  if (bfd_get_symbol_leading_char (obfd) == '\0')
	    bfd_asymbol_name (sym) = bfd_asymbol_name (sym) + 1;
	  else
	    {
	      char *n;

	      n = xmalloc (strlen (bfd_asymbol_name (sym)) + 2);
	      n[0] = bfd_get_symbol_leading_char (obfd);
	      if (bfd_get_symbol_leading_char (abfd) == '\0')
		strcpy (n + 1, bfd_asymbol_name (sym));
	      else
		strcpy (n + 1, bfd_asymbol_name (sym) + 1);
	      bfd_asymbol_name (sym) = n;
	    }
	}

a715 1
	  || change_leading_char
d730 1
a730 1
	  symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
d1583 4
a1586 1
    print_version ("strip");
a1828 3
	case OPTION_CHANGE_LEADING_CHAR:
	  change_leading_char = true;
	  break;
d1897 4
a1900 1
    print_version ("objcopy");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a27 10
#ifdef HAVE_GOOD_UTIME_H
#include <utime.h>
#else /* ! HAVE_GOOD_UTIME_H */
#ifdef HAVE_UTIMES
#include <sys/time.h>
#endif /* HAVE_UTIMES */
#endif /* ! HAVE_GOOD_UTIME_H */

static void copy_usage PARAMS ((FILE *, int));
static void strip_usage PARAMS ((FILE *, int));
a39 1
static void filter_bytes PARAMS ((char *, bfd_size_type *));
a40 9
static void copy_object PARAMS ((bfd *, bfd *));
static void copy_archive PARAMS ((bfd *, bfd *, const char *));
static void copy_file
  PARAMS ((const char *, const char *, const char *, const char *));
static int simple_copy PARAMS ((const char *, const char *));
static int smart_rename PARAMS ((const char *, const char *));
static void make_same_dates PARAMS ((const char *, const char *));
static int strip_main PARAMS ((int, char **));
static int copy_main PARAMS ((int, char **));
a164 1
#define OPTION_WEAKEN (OPTION_STRIP_UNNEEDED + 1)
a178 1
  {"preserve-dates", no_argument, 0, 'p'},
a214 1
  {"preserve-dates", no_argument, 0, 'p'},
a225 1
  {"weaken", no_argument, 0, OPTION_WEAKEN},
d244 1
a244 1
Usage: %s [-vVSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-b byte]\n\
d251 1
a251 1
       [--gap-fill=val] [--pad-to=address] [--preserve-dates]\n\
d257 1
a257 1
       [--change-leading-char] [--remove-leading-char] [--weaken] [--verbose]\n\
d271 1
a271 1
Usage: %s [-vVsSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-R section]\n\
d276 1
a276 1
       [-o file] [--preserve-dates] [--verbose] [--version] [--help] file...\n",
a374 4
/* If this is true, we weaken global symbols (set BSF_WEAK).  */

static boolean weaken = false;

a501 6
      if (keep && weaken && (flags & BSF_GLOBAL) != 0)
	{
	  sym->flags &=~ BSF_GLOBAL;
	  sym->flags |= BSF_WEAK;
	}

d514 1
a514 1
static void
d750 1
a750 2
	  || remove_leading_char
	  || weaken)
d852 15
d874 1
a874 1
     const char *output_target;
d900 1
a900 2
      char *output_name = concat (dir, "/", bfd_get_filename(this_element),
				  (char *) NULL);
d964 4
a967 4
     const char *input_filename;
     const char *output_filename;
     const char *input_target;
     const char *output_target;
d1424 1
a1424 2
     const char *from;
     const char *to;
d1478 1
a1478 2
     const char *from;
     const char *to;
a1532 51
/* Set the date of the file DESTINATION to be the same as the date of
   the file SOURCE.  */

static void
make_same_dates (source, destination)
     const char *source;
     const char *destination;
{
  struct stat statbuf;
  int result;

  if (stat (source, &statbuf) < 0)
    {
      fprintf (stderr, "%s: ", source);
      perror ("cannot stat");
      return;
    }

  {
#ifdef HAVE_GOOD_UTIME_H
    struct utimbuf tb;

    tb.actime = statbuf.st_atime;
    tb.modtime = statbuf.st_mtime;
    result = utime (destination, &tb);
#else /* ! HAVE_GOOD_UTIME_H */
#ifndef HAVE_UTIMES
    long tb[2];

    tb[0] = statbuf.st_atime;
    tb[1] = statbuf.st_mtime;
    result = utime (destination, tb);
#else /* HAVE_UTIMES */
    struct timeval tv[2];

    tv[0].tv_sec = statbuf.st_atime;
    tv[0].tv_usec = 0;
    tv[1].tv_sec = statbuf.st_mtime;
    tv[1].tv_usec = 0;
    result = utimes (destination, tv);
#endif /* HAVE_UTIMES */
#endif /* ! HAVE_GOOD_UTIME_H */
  }

  if (result != 0)
    {
      fprintf (stderr, "%s: ", destination);
      perror ("can not set time");
    }
}

a1539 1
  boolean preserve_dates = false;
d1544 1
a1544 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpgxXVv",
a1594 3
	case 'p':
	  preserve_dates = true;
	  break;
a1645 2
	  if (preserve_dates)
	    make_same_dates (argv[i], tmpname);
a1667 1
  boolean preserve_dates = false;
d1671 1
a1671 1
  while ((c = getopt_long (argc, argv, "b:i:I:K:N:s:O:d:F:R:SpgxXVv",
a1737 3
	case 'p':
	  preserve_dates = true;
	  break;
a1749 3
	case OPTION_WEAKEN:
	  weaken = true;
	  break;
a1959 1

d1962 1
a1962 5
	{	
	  if (preserve_dates)
	    make_same_dates (input_filename, tmpname);
	  smart_rename (tmpname, input_filename);
	}
a1968 2
      if (status == 0 && preserve_dates)
	make_same_dates (input_filename, output_filename);
a2002 1
  set_default_bfd_target ();
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a25 1
#include "filenames.h"
d28 7
a34 18
/* A list of symbols to explicitly strip out, or to keep.  A linked
   list is good enough for a small number from the command line, but
   this will slow things down a lot if many symbols are being
   deleted. */

struct symlist
{
  const char *name;
  struct symlist *next;
};

/* A list to support redefine_sym.  */
struct redefine_node
{
  char *source;
  char *target;
  struct redefine_node *next;
};
d43 3
a45 3
static int compare_section_lma PARAMS ((const PTR, const PTR));
static void add_specific_symbol PARAMS ((const char *, struct symlist **));
static boolean is_specified_symbol PARAMS ((const char *, struct symlist *));
d56 3
a60 2
static const char *lookup_sym_redefinition PARAMS((const char *));
static void redefine_list_append PARAMS ((const char *, const char *));
d62 1
a62 1
#define RETURN_NONFATAL(s) {bfd_nonfatal (s); status = 1; return;}
a71 1
static boolean preserve_dates;	/* Preserve input file timestamp.  */
d76 5
a80 5
    STRIP_UNDEF,
    STRIP_NONE,			/* don't strip */
    STRIP_DEBUG,		/* strip all debugger symbols */
    STRIP_UNNEEDED,		/* strip unnecessary symbols */
    STRIP_ALL			/* strip all symbols */
d88 3
a90 3
    LOCALS_UNDEF,
    LOCALS_START_L,		/* discard locals starting with L */
    LOCALS_ALL			/* discard all locals */
d93 1
a93 1
/* Which local symbols to remove.  Overrides STRIP_ALL.  */
d96 1
a96 7
/* What kind of change to perform.  */
enum change_action
{
  CHANGE_IGNORE,
  CHANGE_MODIFY,
  CHANGE_SET
};
a97 1
/* Structure used to hold lists of sections and actions to take.  */
d100 16
a115 11
  struct section_list * next;      /* Next section to change.  */
  const char *          name;      /* Section name.  */
  boolean               used;      /* Whether this entry was used.  */
  boolean               remove;    /* Whether to remove this section.  */
  boolean		copy;      /* Whether to copy this section.  */
  enum change_action    change_vma;/* Whether to change or set VMA.  */
  bfd_vma 		vma_val;   /* Amount to change by or set to.  */
  enum change_action    change_lma;/* Whether to change or set LMA.  */
  bfd_vma 		lma_val;   /* Amount to change by or set to.  */
  boolean 		set_flags; /* Whether to set the section flags.  */
  flagword 		flags;     /* What to set the section flags to.  */
d118 1
a118 1
static struct section_list *change_sections;
a119 1
static boolean sections_copied;
d121 2
a122 2
/* Changes to the start address.  */
static bfd_vma change_start = 0;
d126 2
a127 2
/* Changes to section addresses.  */
static bfd_vma change_section_address = 0;
a168 12
/* List of symbols to strip, keep, localize, weaken, or redefine.  */

static struct symlist *strip_specific_list = NULL;
static struct symlist *keep_specific_list = NULL;
static struct symlist *localize_specific_list = NULL;
static struct symlist *weaken_specific_list = NULL;
static struct redefine_node *redefine_sym_list = NULL;

/* If this is true, we weaken global symbols (set BSF_WEAK).  */

static boolean weaken = false;

d172 6
a177 8
#define OPTION_CHANGE_ADDRESSES (OPTION_ADD_SECTION + 1)
#define OPTION_CHANGE_LEADING_CHAR (OPTION_CHANGE_ADDRESSES + 1)
#define OPTION_CHANGE_START (OPTION_CHANGE_LEADING_CHAR + 1)
#define OPTION_CHANGE_SECTION_ADDRESS (OPTION_CHANGE_START + 1)
#define OPTION_CHANGE_SECTION_LMA (OPTION_CHANGE_SECTION_ADDRESS + 1)
#define OPTION_CHANGE_SECTION_VMA (OPTION_CHANGE_SECTION_LMA + 1)
#define OPTION_CHANGE_WARNINGS (OPTION_CHANGE_SECTION_VMA + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_WARNINGS + 1)
d179 2
a180 2
#define OPTION_NO_CHANGE_WARNINGS (OPTION_GAP_FILL + 1)
#define OPTION_PAD_TO (OPTION_NO_CHANGE_WARNINGS + 1)
a185 1
#define OPTION_REDEFINE_SYM (OPTION_WEAKEN + 1)
d217 4
a220 4
  {"adjust-start", required_argument, 0, OPTION_CHANGE_START},
  {"adjust-vma", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"adjust-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"adjust-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
a221 1
  {"change-addresses", required_argument, 0, OPTION_CHANGE_ADDRESSES},
a222 5
  {"change-section-address", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"change-section-lma", required_argument, 0, OPTION_CHANGE_SECTION_LMA},
  {"change-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_VMA},
  {"change-start", required_argument, 0, OPTION_CHANGE_START},
  {"change-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
a225 1
  {"only-section", required_argument, 0, 'j'},
d233 1
a233 2
  {"no-adjust-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"no-change-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
a237 1
  {"localize-symbol", required_argument, 0, 'L'},
a249 2
  {"weaken-symbol", required_argument, 0, 'W'},
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
d267 16
a282 47
  fprintf (stream, _("Usage: %s <switches> in-file [out-file]\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
  fprintf (stream, _("\
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
     --debugging                   Convert debugging information, if possible\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -j --only-section <name>         Only copy section <name> into the output\n\
  -R --remove-section <name>       Remove section <name> from the output\n\
  -S --strip-all                   Remove all symbol and relocation information\n\
  -g --strip-debug                 Remove all debugging symbols\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\n\
  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\n\
     --weaken                      Force all global symbols to be marked as weak\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -i --interleave <number>         Only copy one out of every <number> bytes\n\
  -b --byte <num>                  Select byte <num> in every interleaved block\n\
     --gap-fill <val>              Fill gaps between sections with <val>\n\
     --pad-to <addr>               Pad the last section up to address <addr>\n\
     --set-start <addr>            Set the start address to <addr>\n\
    {--change-start|--adjust-start} <incr>\n\
                                   Add <incr> to the start address\n\
    {--change-addresses|--adjust-vma} <incr>\n\
                                   Add <incr> to LMA, VMA and start addresses\n\
    {--change-section-address|--adjust-section-vma} <name>{=|+|-}<val>\n\
                                   Change LMA and VMA of section <name> by <val>\n\
     --change-section-lma <name>{=|+|-}<val>\n\
                                   Change the LMA of section <name> by <val>\n\
     --change-section-vma <name>{=|+|-}<val>\n\
                                   Change the VMA of section <name> by <val>\n\
    {--[no-]change-warnings|--[no-]adjust-warnings}\n\
                                   Warn if a named section does not exist\n\
     --set-section-flags <name>=<flags>\n\
                                   Set section <name>'s properties to <flags>\n\
     --add-section <name>=<file>   Add section <name> found in <file> to output\n\
     --change-leading-char         Force output format's leading character style\n\
     --remove-leading-char         Remove leading character from global symbols\n\
     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
"));
d285 1
a285 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d294 8
a301 21
  fprintf (stream, _("Usage: %s <switches> in-file(s)\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
  fprintf (stream, _("\
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
  -R --remove-section <name>       Remove section <name> from the output\n\
  -s --strip-all                   Remove all symbol and relocation information\n\
  -g -S --strip-debug              Remove all debugging symbols\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
  -o <file>                        Place stripped output into <file>\n\
"));

d304 1
a304 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d332 1
a332 3
      if (0) ;
#define PARSE_FLAG(fname,fval) \
  else if (strncasecmp (fname, s, len) == 0) ret |= fval
a334 1
      PARSE_FLAG ("noload", SEC_NEVER_LOAD);
a335 1
      PARSE_FLAG ("debug", SEC_DEBUGGING);
a338 2
      PARSE_FLAG ("share", SEC_SHARED);
      PARSE_FLAG ("contents", SEC_HAS_CONTENTS);
a339 11
      else
	{
	  char *copy;

	  copy = xmalloc (len + 1);
	  strncpy (copy, s, len);
	  copy[len] = '\0';
	  non_fatal (_("unrecognized section flag `%s'"), copy);
	  fatal (_("supported flags: %s"),
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents");
	}
d348 1
a348 1
/* Find and optionally add an entry in the change_sections list.  */
d357 1
a357 1
  for (p = change_sections; p != NULL; p = p->next)
d368 2
a369 5
  p->copy = false;
  p->change_vma = CHANGE_IGNORE;
  p->change_lma = CHANGE_IGNORE;
  p->vma_val = 0;
  p->lma_val = 0;
d373 2
a374 2
  p->next = change_sections;
  change_sections = p;
d379 24
d405 2
a406 2
static void
add_specific_symbol (name, list)
a407 1
     struct symlist **list;
d413 2
a414 2
  tmp_list->next = *list;
  *list = tmp_list;
d421 1
a421 1
is_specified_symbol (name, list)
a422 1
     struct symlist *list;
d426 1
a426 1
  for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
d429 1
a429 1
	return true;
d431 1
a431 1
  return false;
d438 1
a438 1
     bfd *abfd ATTRIBUTE_UNUSED;
d444 4
a447 4
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
d451 1
a451 1
  if (! sections_removed && ! sections_copied)
a452 1

d454 1
a454 5
  if (sections_removed && p != NULL && p->remove)
    return true;
  if (sections_copied && (p == NULL || ! p->copy))
    return true;
  return false;
a474 1
      const char *name = bfd_asymbol_name (sym);
a476 9
      if (redefine_sym_list)
	{
	  const char *old_name, *new_name;

	  old_name = bfd_asymbol_name (sym);
	  new_name = lookup_sym_redefinition (old_name);
	  name = bfd_asymbol_name (sym) = new_name;
	}

d481 2
a482 1
	      || (name[0] == bfd_get_symbol_leading_char (abfd))))
d485 1
a485 1
	    name = bfd_asymbol_name (sym) = name + 1;
d490 1
a490 1
	      n = xmalloc (strlen (name) + 2);
d493 1
a493 1
		strcpy (n + 1, name);
d495 2
a496 2
		strcpy (n + 1, name + 1);
	      name = bfd_asymbol_name (sym) = n;
d505 2
a506 2
	  && name[0] == bfd_get_symbol_leading_char (abfd))
	name = bfd_asymbol_name (sym) = name + 1;
d508 1
a508 6
      if (strip_symbols == STRIP_ALL)
	keep = 0;
      else if ((flags & BSF_KEEP) != 0		/* Used in relocation.  */
	       || ((flags & BSF_SECTION_SYM) != 0
		   && ((*bfd_get_section (sym)->symbol_ptr_ptr)->flags
		       & BSF_KEEP) != 0))
d514 1
a514 1
	keep = strip_symbols != STRIP_UNNEEDED;
d516 2
a517 2
	keep = (strip_symbols != STRIP_DEBUG
		&& strip_symbols != STRIP_UNNEEDED
d520 3
a522 3
	keep = (strip_symbols != STRIP_UNNEEDED
		&& (discard_locals != LOCALS_ALL
		    && (discard_locals != LOCALS_START_L
d525 1
a525 1
      if (keep && is_specified_symbol (name, strip_specific_list))
a526 2
      if (!keep && is_specified_symbol (name, keep_specific_list))
	keep = 1;
d530 1
a530 2
      if (keep && (flags & BSF_GLOBAL) != 0
	  && (weaken || is_specified_symbol (name, weaken_specific_list)))
a534 6
      if (keep && (flags & (BSF_GLOBAL | BSF_WEAK))
	  && is_specified_symbol (name, localize_specific_list))
	{
	  sym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
	  sym->flags |= BSF_LOCAL;
	}
a544 58
static const char *
lookup_sym_redefinition (source)
     const char *source;
{
  const char *result;
  struct redefine_node *list;

  result = source;

  for (list = redefine_sym_list; list != NULL; list = list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  result = list->target;
	  break;
	}
    }
  return result;
}

/* Add a node to a symbol redefine list */

static void
redefine_list_append (source, target)
     const char *source;
     const char *target;
{
  struct redefine_node **p;
  struct redefine_node *list;
  struct redefine_node *new_node;

  for (p = &redefine_sym_list; (list = *p) != NULL; p = &list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  fatal (_("%s: Multiple redefinition of symbol \"%s\""),
		 "--redefine-sym",
		  source);
	}

      if (strcmp (target, list->target) == 0)
	{
	  fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
		 "--redefine-sym",
		  target);
	}
    }

  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));

  new_node->source = strdup (source);
  new_node->target = strdup (target);
  new_node->next = NULL;

  *p = new_node;
}


d557 1
a557 4
  if (*size % interleave > (bfd_size_type) copy_byte)
    *size = (*size / interleave) + 1;
  else
    *size /= interleave;
a571 3
  long symsize;
  PTR dhandle;

d574 3
a576 1
    RETURN_NONFATAL (bfd_get_filename (obfd));
d579 3
a581 3
    printf (_("copy from %s(%s) to %s(%s)\n"),
	    bfd_get_filename (ibfd), bfd_get_target (ibfd),
	    bfd_get_filename (obfd), bfd_get_target (obfd));
d587 1
a587 1
  start += change_start;
d593 3
a595 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d600 3
a602 1
    non_fatal (_("Warning: Output file cannot represent architecture %s"),
d605 1
a605 1

d607 3
a609 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
a612 1

d616 1
a616 1
  /* BFD mandates that all output sections be created and sizes set before
d630 3
a632 2
	      non_fatal (_("can't create section `%s': %s"),
		       padd->name, bfd_errmsg (bfd_get_error ()));
d639 1
a639 1

d641 1
a641 1
		RETURN_NONFATAL (bfd_get_filename (obfd));
a650 1

d652 1
a652 1
		RETURN_NONFATAL (bfd_get_filename (obfd));
d654 3
a656 1
	      if (pset != NULL)
d658 2
a659 13
		  if (pset->change_vma != CHANGE_IGNORE)
		    if (! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
		      RETURN_NONFATAL (bfd_get_filename (obfd));

		  if (pset->change_lma != CHANGE_IGNORE)
		    {
		      padd->section->lma = pset->lma_val;

		      if (! bfd_set_section_alignment
			  (obfd, padd->section,
			   bfd_section_alignment (obfd, padd->section)))
			RETURN_NONFATAL (bfd_get_filename (obfd));
		    }
d681 1
a681 1
      qsort (osections, c, sizeof (asection *), compare_section_lma);
d700 2
a701 2
	      gap_start = bfd_section_lma (obfd, osections[i]) + size;
	      gap_stop = bfd_section_lma (obfd, osections[i + 1]);
d707 2
a708 1
		      non_fatal (_("Can't fill gap after %s: %s"),
d710 1
a710 1
			       bfd_errmsg (bfd_get_error ()));
d723 1
a723 1
	  bfd_vma lma;
d726 1
a726 1
	  lma = bfd_section_lma (obfd, osections[c - 1]);
d728 1
a728 1
	  if (lma + size < pad_to)
d731 1
a731 1
					  pad_to - lma))
d733 2
a734 1
		  non_fatal (_("Can't add padding to %s: %s"),
d741 3
a743 3
		  gaps[c - 1] = pad_to - (lma + size);
		  if (max_gap < pad_to - (lma + size))
		    max_gap = pad_to - (lma + size);
d746 1
a746 1
	}
d751 4
a754 43
  dhandle = NULL;
  symsize = bfd_get_symtab_upper_bound (ibfd);
  if (symsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  osympp = isympp = (asymbol **) xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (ibfd, isympp);
  if (symcount < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  if (convert_debugging)
    dhandle = read_debugging_info (ibfd, isympp, symcount);

  if (strip_symbols == STRIP_DEBUG
      || strip_symbols == STRIP_ALL
      || strip_symbols == STRIP_UNNEEDED
      || discard_locals != LOCALS_UNDEF
      || strip_specific_list != NULL
      || keep_specific_list != NULL
      || localize_specific_list != NULL
      || weaken_specific_list != NULL
      || sections_removed
      || sections_copied
      || convert_debugging
      || change_leading_char
      || remove_leading_char
      || redefine_sym_list
      || weaken)
    {
      /* Mark symbols used in output relocations so that they
	 are kept, even if they are local labels or static symbols.

	 Note we iterate over the input sections examining their
	 relocations since the relocations for the output sections
	 haven't been set yet.  mark_symbols_used_in_relocations will
	 ignore input sections which have no corresponding output
	 section.  */
      if (strip_symbols != STRIP_ALL)
	bfd_map_over_sections (ibfd,
			       mark_symbols_used_in_relocations,
			       (PTR)isympp);
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
      symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
d756 45
d802 1
a802 3
  if (convert_debugging && dhandle != NULL)
    {
      if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
d804 5
a808 2
	  status = 1;
	  return;
d827 1
a827 1
	    RETURN_NONFATAL (bfd_get_filename (obfd));
a860 1

d863 3
a865 2
		    RETURN_NONFATAL (bfd_get_filename (obfd));

d879 3
a881 3
      non_fatal (_("%s: error copying private BFD data: %s"),
		 bfd_get_filename (obfd),
		 bfd_errmsg (bfd_get_error ()));
a906 3
#if defined (_WIN32) && !defined (__CYGWIN32__)
  if (mkdir (dir) != 0)
#else
a907 1
#endif
d909 1
a909 1
      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
d917 1
a917 1
  while (!status && this_element != (bfd *) NULL)
d920 1
a920 1
      char *output_name = concat (dir, "/", bfd_get_filename (this_element),
a923 10
      struct stat buf;
      int stat_status = 0;

      if (preserve_dates)
	{
	  stat_status = bfd_stat_arch_elt (this_element, &buf);
	  if (stat_status != 0)
	    non_fatal (_("internal stat error on %s"),
		       bfd_get_filename (this_element));
	}
d931 3
a933 2
	RETURN_NONFATAL (output_name);

d935 3
a937 1
	RETURN_NONFATAL (bfd_get_filename (obfd));
a939 3
	copy_object (this_element, output_bfd);

      if (!bfd_close (output_bfd))
d941 1
a941 3
	  bfd_nonfatal (bfd_get_filename (output_bfd));
	  /* Error in new object file. Don't change archive. */
	  status = 1;
d944 1
a944 2
      if (preserve_dates && stat_status == 0)
	set_times (output_name, &buf);
d963 3
a965 1
    RETURN_NONFATAL (bfd_get_filename (obfd));
d968 3
a970 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d998 3
a1000 1
    RETURN_NONFATAL (input_filename);
d1013 3
a1015 2
	RETURN_NONFATAL (output_filename);

d1029 3
a1031 1
	RETURN_NONFATAL (output_filename);
d1036 3
a1038 1
	RETURN_NONFATAL (output_filename);
d1041 3
a1043 1
	RETURN_NONFATAL (input_filename);
a1047 1

a1052 1

a1068 1
  bfd_size_type size;
d1075 4
a1078 4
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
d1086 1
a1086 3
  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
a1089 1

d1096 3
a1098 4
  size = bfd_section_size (ibfd, isection);
  if (copy_byte >= 0)
    size = (size + interleave - 1) / interleave;
  if (! bfd_set_section_size (obfd, osection, size))
d1105 4
a1108 4
  if (p != NULL && p->change_vma == CHANGE_MODIFY)
    vma += p->vma_val;
  else if (p != NULL && p->change_vma == CHANGE_SET)
    vma = p->vma_val;
d1110 1
a1110 2
    vma += change_section_address;

d1118 4
a1121 9
  if ((p != NULL) && p->change_lma != CHANGE_IGNORE)
    {
      if (p->change_lma == CHANGE_MODIFY)
	lma += p->lma_val;
      else if (p->change_lma == CHANGE_SET)
	lma = p->lma_val;
      else
	abort ();
    }
d1123 1
a1123 2
    lma += change_section_address;

a1125 2
  /* FIXME: This is probably not enough.  If we change the LMA we
     may have to recompute the header for the file as well.  */
d1162 4
a1165 4
  non_fatal (_("%s: section `%s': error in %s: %s"),
	     bfd_get_filename (ibfd),
	     bfd_section_name (ibfd, isection),
	     err, bfd_errmsg (bfd_get_error ()));
a1184 6
  long relsize;

  /* If we have already failed earlier on, do not keep on generating
     complaints now.  */
  if (status != 0)
    return;
d1187 4
a1190 4
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
d1198 1
a1198 3
  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
d1207 1
a1207 6

  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
  if (relsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));

  if (relsize == 0)
d1211 18
a1228 22
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
      if (relcount < 0)
	RETURN_NONFATAL (bfd_get_filename (ibfd));

      if (strip_symbols == STRIP_ALL)
	{
	  /* Remove relocations which are not in
	     keep_strip_specific_list. */
	  arelent **temp_relpp;
	  long temp_relcount = 0;
	  long i;

	  temp_relpp = (arelent **) xmalloc (relsize);
	  for (i = 0; i < relcount; i++)
	    if (is_specified_symbol
		(bfd_asymbol_name (*relpp [i]->sym_ptr_ptr),
		 keep_specific_list))
	      temp_relpp [temp_relcount++] = relpp [i];
	  relcount = temp_relcount;
	  free (relpp);
	  relpp = temp_relpp;
a1229 2
      bfd_set_reloc (obfd, osection,
		     (relcount == 0 ? (arelent **) NULL : relpp), relcount);
d1241 3
a1243 1
	RETURN_NONFATAL (bfd_get_filename (ibfd));
d1245 7
a1251 2
      if (copy_byte >= 0)
	filter_bytes (memhunk, &size);
d1255 3
a1257 18
	RETURN_NONFATAL (bfd_get_filename (obfd));

      free (memhunk);
    }
  else if (p != NULL && p->set_flags && (p->flags & SEC_HAS_CONTENTS) != 0)
    {
      PTR memhunk = (PTR) xmalloc ((unsigned) size);

      /* We don't permit the user to turn off the SEC_HAS_CONTENTS
	 flag--they can just remove the section entirely and add it
	 back again.  However, we do permit them to turn on the
	 SEC_HAS_CONTENTS flag, and take it to mean that the section
	 contents should be zeroed out.  */

      memset (memhunk, 0, size);
      if (! bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				      size))
	RETURN_NONFATAL (bfd_get_filename (obfd));
d1267 1
a1267 1
     bfd *obfd ATTRIBUTE_UNUSED;
d1282 1
a1282 1
compare_section_lma (arg1, arg2)
d1307 2
a1308 2
  /* Sort sections by LMA.  */
  if ((*sec1)->lma > (*sec2)->lma)
d1310 1
a1310 1
  else if ((*sec1)->lma < (*sec2)->lma)
d1313 1
a1313 1
  /* Sort sections with the same LMA by size.  */
d1374 2
a1375 2
     long *symcountp ATTRIBUTE_UNUSED;
     asymbol ***symppp ATTRIBUTE_UNUSED;
d1409 2
a1410 3
	  non_fatal (_("%s: can't create debugging section: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
d1423 2
a1424 3
	  non_fatal (_("%s: can't set debugging section contents: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
d1431 3
a1433 2
  non_fatal (_("%s: don't know how to write debugging information for %s"),
	     bfd_get_filename (obfd), bfd_get_target (obfd));
d1437 170
d1614 1
d1639 1
a1639 1
	  strip_symbols = STRIP_ALL;
d1643 1
a1643 1
	  strip_symbols = STRIP_DEBUG;
d1646 1
a1646 1
	  strip_symbols = STRIP_UNNEEDED;
d1649 8
a1656 1
	  add_specific_symbol (optarg, &keep_specific_list);
d1659 7
a1665 1
	  add_specific_symbol (optarg, &strip_specific_list);
d1674 1
a1674 1
	  discard_locals = LOCALS_ALL;
d1677 1
a1677 1
	  discard_locals = LOCALS_START_L;
d1698 2
a1699 2
  if (strip_symbols == STRIP_UNDEF
      && discard_locals == LOCALS_UNDEF
d1701 1
a1701 1
    strip_symbols = STRIP_ALL;
a1713 1
      struct stat statbuf;
a1715 9
      if (preserve_dates)
	{
	  if (stat (argv[i], &statbuf) < 0)
	    {
	      non_fatal (_("%s: cannot stat: %s"), argv[i], strerror (errno));
	      continue;
	    }
	}

a1720 1

d1725 1
a1725 1
	    set_times (tmpname, &statbuf);
d1727 1
a1727 1
	    smart_rename (tmpname, argv[i], preserve_dates);
d1747 2
a1748 1
  boolean change_warn = true;
a1750 1
  struct stat statbuf;
d1752 1
a1752 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:R:SpgxXVvW:",
d1758 1
a1758 1
	  copy_byte = atoi (optarg);
d1760 5
a1764 1
	    fatal (_("byte number must be non-negative"));
a1765 1

d1767 1
a1767 1
	  interleave = atoi (optarg);
d1769 5
a1773 1
	    fatal (_("interleave must be positive"));
a1774 1

a1778 1

a1782 1

a1785 9

	case 'j':
	  p = find_section_list (optarg, true);
	  if (p->remove)
	    fatal (_("%s both copied and removed"), optarg);
	  p->copy = true;
	  sections_copied = true;
	  break;

a1787 2
	  if (p->copy)
	    fatal (_("%s both copied and removed"), optarg);
a1790 1

d1792 1
a1792 1
	  strip_symbols = STRIP_ALL;
a1793 1

d1795 1
a1795 1
	  strip_symbols = STRIP_DEBUG;
a1796 1

d1798 1
a1798 1
	  strip_symbols = STRIP_UNNEEDED;
a1799 1

d1801 8
a1808 1
	  add_specific_symbol (optarg, &keep_specific_list);
a1809 1

d1811 7
a1817 5
	  add_specific_symbol (optarg, &strip_specific_list);
	  break;

	case 'L':
	  add_specific_symbol (optarg, &localize_specific_list);
a1818 5

	case 'W':
	  add_specific_symbol (optarg, &weaken_specific_list);
	  break;

a1821 1

d1823 1
a1823 1
	  discard_locals = LOCALS_ALL;
a1824 1

d1826 1
a1826 1
	  discard_locals = LOCALS_START_L;
a1827 1

a1830 1

a1833 1

a1836 1

a1846 1

d1848 6
a1853 1
	      fatal (_("bad format for %s"), "--add-section");
d1855 6
a1860 2
	    if (stat (s + 1, & st) < 0)
	      fatal (_("cannot stat: %s: %s"), s + 1, strerror (errno));
a1875 1

d1877 5
a1881 2
	      fatal (_("cannot open: %s: %s"), pa->filename, strerror (errno));

d1884 5
a1888 2
	      fatal (_("%s: fread failed"), pa->filename);

d1895 2
a1896 3

	case OPTION_CHANGE_START:
	  change_start = parse_vma (optarg, "--change-start");
d1898 1
a1898 4

	case OPTION_CHANGE_SECTION_ADDRESS:
	case OPTION_CHANGE_SECTION_LMA:
	case OPTION_CHANGE_SECTION_VMA:
a1902 16
	    char *option = NULL;
	    bfd_vma val;
	    enum change_action what = CHANGE_IGNORE;

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		option = "--change-section-address";
		break;
	      case OPTION_CHANGE_SECTION_LMA:
		option = "--change-section-lma";
		break;
	      case OPTION_CHANGE_SECTION_VMA:
		option = "--change-section-vma";
		break;
	      }
d1912 6
a1917 1
		      fatal (_("bad format for %s"), option);
d1928 1
a1928 1
	    val = parse_vma (s + 1, option);
d1930 3
a1932 1
	    switch (*s)
d1934 3
a1936 21
	      case '=': what = CHANGE_SET; break;
	      case '-': val  = - val; /* Drop through.  */
	      case '+': what = CHANGE_MODIFY; break;
	      }

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		p->change_vma = what;
		p->vma_val    = val;
		/* Drop through.  */

	      case OPTION_CHANGE_SECTION_LMA:
		p->change_lma = what;
		p->lma_val    = val;
		break;

	      case OPTION_CHANGE_SECTION_VMA:
		p->change_vma = what;
		p->vma_val    = val;
		break;
d1940 3
a1942 4

	case OPTION_CHANGE_ADDRESSES:
	  change_section_address = parse_vma (optarg, "--change-addresses");
	  change_start = change_section_address;
d1944 2
a1945 3

	case OPTION_CHANGE_WARNINGS:
	  change_warn = true;
a1946 1

a1949 1

a1952 1

d1961 4
a1964 6
		char buff[20];

		sprintf_vma (buff, gap_fill_vma);

		non_fatal (_("Warning: truncating gap-fill from 0x%s to 0x%x"),
			   buff, gap_fill);
d1969 2
a1970 3

	case OPTION_NO_CHANGE_WARNINGS:
	  change_warn = false;
a1971 1

a1975 1

a1978 33

	case OPTION_REDEFINE_SYM:
	  {
	    /* Push this redefinition onto redefine_symbol_list.  */

	    int len;
	    const char *s;
	    const char *nextarg;
	    char *source, *target;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      {
		fatal (_("bad format for %s"), "--redefine-sym");
	      }

	    len = s - optarg;
	    source = (char *) xmalloc (len + 1);
	    strncpy (source, optarg, len);
	    source[len] = '\0';

	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);

	    redefine_list_append (source, target);

	    free (source);
	    free (target);
	  }
	  break;

d1987 5
a1991 1
	      fatal (_("bad format for %s"), "--set-section-flags");
a2003 1

a2007 1

a2009 1

a2011 1

d2021 5
a2025 1
    fatal (_("byte number must be less than interleave"));
d2035 2
a2036 2
  if (strip_symbols == STRIP_UNDEF && discard_locals == LOCALS_UNDEF)
    strip_symbols = STRIP_NONE;
a2040 6
  if (preserve_dates)
    {
      if (stat (input_filename, &statbuf) < 0)
	fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
    }

d2050 1
a2050 1
	{
d2052 2
a2053 2
	    set_times (tmpname, &statbuf);
	  smart_rename (tmpname, input_filename, preserve_dates);
d2062 1
a2062 1
	set_times (output_filename, &statbuf);
d2065 1
a2065 1
  if (change_warn)
d2067 1
a2067 1
      for (p = change_sections; p != NULL; p = p->next)
d2069 1
a2069 1
	  if (! p->used)
d2071 5
a2075 27
	      if (p->change_vma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->vma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-vma",
			     p->name,
			     p->change_vma == CHANGE_SET ? '=' : '+',
			     buff);
		}

	      if (p->change_lma != CHANGE_IGNORE)
		{
		  char buff [20];

		  sprintf_vma (buff, p->lma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-lma",
			     p->name,
			     p->change_lma == CHANGE_SET ? '=' : '+',
			     buff);
		}
a2087 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d2093 2
a2094 2
  strip_symbols = STRIP_UNDEF;
  discard_locals = LOCALS_UNDEF;
d2102 1
a2102 9
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* Drop the .exe suffix, if any.  */
      if (i > 4 && FILENAME_CMP (program_name + i - 4, ".exe") == 0)
	{
	  i -= 4;
	  program_name[i] = '\0';
	}
#endif
      is_strip = (i >= 5 && FILENAME_CMP (program_name + i - 5, "strip") == 0);
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d1666 1
a1666 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
a1689 1
	case 'd':	/* NetBSD, historic BSD strip */
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
a58 1
static void add_specific_symbols PARAMS ((const char *, struct symlist **));
d186 1
a186 2
/* List of symbols to strip, keep, localize, keep-global, weaken,
   or redefine.  */
a190 1
static struct symlist *keepglobal_specific_list = NULL;
a217 7
#define OPTION_SREC_LEN (OPTION_REDEFINE_SYM + 1)
#define OPTION_SREC_FORCES3 (OPTION_SREC_LEN + 1)
#define OPTION_STRIP_SYMBOLS (OPTION_SREC_FORCES3 + 1)
#define OPTION_KEEP_SYMBOLS (OPTION_STRIP_SYMBOLS + 1)
#define OPTION_LOCALIZE_SYMBOLS (OPTION_KEEP_SYMBOLS + 1)
#define OPTION_KEEPGLOBAL_SYMBOLS (OPTION_LOCALIZE_SYMBOLS + 1)
#define OPTION_WEAKEN_SYMBOLS (OPTION_KEEPGLOBAL_SYMBOLS + 1)
a278 1
  {"keep-global-symbol", required_argument, 0, 'G'},
a292 7
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
  {"weaken-symbols", required_argument, 0, OPTION_WEAKEN_SYMBOLS},
a303 8
/* The maximum length of an S record.  This variable is declared in srec.c
   and can be modified by the --srec-len parameter.  */
extern unsigned int Chunk;

/* Restrict the generation of Srecords to type S3 only.
   This variable is declare in bfd/srec.c and can be toggled
   on by the --srec-forceS3 command line switch.  */
extern boolean S3Forced;
a325 1
  -G --keep-global-symbol <name>   Localize all symbols except <name>\n\
a352 7
     --srec-len <number>           Restrict the length of generated Srecords\n\
     --srec-forceS3                Restrict the type of generated Srecords to S3\n\
     --strip-symbols <file>        -N for all symbols listed in <file>\n\
     --keep-symbols <file>         -K for all symbols listed in <file>\n\
     --localize-symbols <file>     -L for all symbols listed in <file>\n\
     --keep-global-symbols <file>  -G for all symbols listed in <file>\n\
     --weaken-symbols <file>       -W for all symbols listed in <file>\n\
a500 116
/* Add symbols listed in `filename' to strip_specific_list. */

#define IS_WHITESPACE(c)      ((c) == ' ' || (c) == '\t')
#define IS_LINE_TERMINATOR(c) ((c) == '\n' || (c) == '\r' || (c) == '\0')

static void
add_specific_symbols (filename, list)
     const char *filename;
     struct symlist **list;
{
  struct stat st;
  FILE * f;
  char * line;
  char * buffer;
  unsigned int line_count;
  
  if (stat (filename, & st) < 0)
    fatal (_("cannot stat: %s: %s"), filename, strerror (errno));
  if (st.st_size == 0)
    return;

  buffer = (char *) xmalloc (st.st_size + 2);
  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    fatal (_("cannot open: %s: %s"), filename, strerror (errno));

  if (fread (buffer, 1, st.st_size, f) == 0 || ferror (f))
    fatal (_("%s: fread failed"), filename);

  fclose (f);
  buffer [st.st_size] = '\n';
  buffer [st.st_size + 1] = '\0';

  line_count = 1;
  
  for (line = buffer; * line != '\0'; line ++)
    {
      char * eol;
      char * name;
      char * name_end;
      int finished = false;

      for (eol = line;; eol ++)
	{
	  switch (* eol)
	    {
	    case '\n':
	      * eol = '\0';
	      /* Cope with \n\r.  */
	      if (eol[1] == '\r')
		++ eol;
	      finished = true;
	      break;
	      
	    case '\r':
	      * eol = '\0';
	      /* Cope with \r\n.  */
	      if (eol[1] == '\n')
		++ eol;
	      finished = true;
	      break;
	      
	    case 0:
	      finished = true;
	      break;
	      
	    case '#':
	      /* Line comment, Terminate the line here, in case a
		 name is present and then allow the rest of the
		 loop to find the real end of the line.  */
	      * eol = '\0';
	      break;
	      
	    default:
	      break;
	    }

	  if (finished)
	    break;
	}

      /* A name may now exist somewhere between 'line' and 'eol'.
	 Strip off leading whitespace and trailing whitespace,
	 then add it to the list.  */
      for (name = line; IS_WHITESPACE (* name); name ++)
	;
      for (name_end = name;
	   (! IS_WHITESPACE (* name_end))
	   && (! IS_LINE_TERMINATOR (* name_end));
           name_end ++)
        ;

      if (! IS_LINE_TERMINATOR (* name_end))
	{
	  char * extra;

	  for (extra = name_end + 1; IS_WHITESPACE (* extra); extra ++)
	    ;

	  if (! IS_LINE_TERMINATOR (* extra))
	    non_fatal (_("Ignoring rubbish found on line %d of %s"),
		       line_count, filename);
	}
  
      * name_end = '\0';

      if (name_end > name)
	add_specific_symbol (name, list);

      /* Advance line pointer to end of line.  The 'eol ++' in the for
	 loop above will then advance us to the start of the next line.  */
      line = eol;
      line_count ++;
    }
}

a559 2
  int relocatable = (abfd->flags & (HAS_RELOC | EXEC_P | DYNAMIC))
		    == HAS_RELOC;
a613 9
      else if (relocatable			/* Relocatable file. */
	       && (flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
	keep = 1;
      else if (bfd_decode_symclass (sym) == 'I')
	/* Global symbols in $idata sections need to be retained
	   even if relocatable is false.  External users of the
	   library containing the $idata section may reference these
	   symbols.  */
	  keep = 1;
d643 1
a643 3
	  && (is_specified_symbol (name, localize_specific_list)
	      || (keepglobal_specific_list != NULL
		  && ! is_specified_symbol (name, keepglobal_specific_list))))
a748 7
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      fatal (_("Unable to change endianness of input file(s)"));
      return;
    }
a947 1
      || keepglobal_specific_list != NULL
d1249 1
a1249 1
  const char *err;
d1272 1
a1272 1
      err = _("making");
d1281 1
a1281 1
      err = _("size");
d1295 1
a1295 1
      err = _("vma");
d1321 1
a1321 1
      err = _("alignment");
d1330 1
a1330 1
      err = _("flags");
d1344 1
a1344 1
      err = _("private data");
d1666 1
a1666 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d1690 1
a1690 1
	case 'd':	/* Historic BSD alias for -g.  Used by early NetBSD.  */
a1868 4
	case 'G':
	  add_specific_symbol (optarg, &keepglobal_specific_list);
	  break;

a2124 28
	  break;

        case OPTION_SREC_LEN:
          Chunk = parse_vma (optarg, "--srec-len");
          break;

        case OPTION_SREC_FORCES3:
	  S3Forced = true;
          break;

	case OPTION_STRIP_SYMBOLS:
	  add_specific_symbols (optarg, &strip_specific_list);
	  break;

	case OPTION_KEEP_SYMBOLS:
	  add_specific_symbols (optarg, &keep_specific_list);
	  break;

	case OPTION_LOCALIZE_SYMBOLS:
	  add_specific_symbols (optarg, &localize_specific_list);
	  break;

	case OPTION_KEEPGLOBAL_SYMBOLS:
	  add_specific_symbols (optarg, &keepglobal_specific_list);
	  break;

	case OPTION_WEAKEN_SYMBOLS:
	  add_specific_symbols (optarg, &weaken_specific_list);
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d35 1
a35 1
   deleted.  */
d51 12
a62 36
typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename * section_rename_list;

static void copy_usage
  PARAMS ((FILE *, int));
static void strip_usage
  PARAMS ((FILE *, int));
static flagword parse_flags
  PARAMS ((const char *));
static struct section_list *find_section_list
  PARAMS ((const char *, bfd_boolean));
static void setup_section
  PARAMS ((bfd *, asection *, PTR));
static void copy_section
  PARAMS ((bfd *, asection *, PTR));
static void get_sections
  PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma
  PARAMS ((const PTR, const PTR));
static void add_specific_symbol
  PARAMS ((const char *, struct symlist **));
static void add_specific_symbols
  PARAMS ((const char *, struct symlist **));
static bfd_boolean is_specified_symbol
  PARAMS ((const char *, struct symlist *));
static bfd_boolean is_strip_section
  PARAMS ((bfd *, asection *));
d65 5
a69 10
static void mark_symbols_used_in_relocations
  PARAMS ((bfd *, asection *, PTR));
static void filter_bytes
  PARAMS ((char *, bfd_size_type *));
static bfd_boolean write_debugging_info
  PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object
  PARAMS ((bfd *, bfd *));
static void copy_archive
  PARAMS ((bfd *, bfd *, const char *));
d72 4
a75 12
static int strip_main
  PARAMS ((int, char **));
static int copy_main
  PARAMS ((int, char **));
static const char *lookup_sym_redefinition
  PARAMS((const char *));
static void redefine_list_append
  PARAMS ((const char *, const char *));
static const char * find_section_rename
  PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename
  PARAMS ((const char *, const char *, flagword));
d86 2
a87 2
static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
d99 1
a99 1
/* Which symbols to remove.  */
d123 11
a133 11
  struct section_list * next;	   /* Next section to change.  */
  const char *		name;	   /* Section name.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  enum change_action	change_lma;/* Whether to change or set LMA.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
  flagword		flags;	   /* What to set the section flags to.	 */
d137 2
a138 6

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;
d142 1
a142 1
static bfd_boolean set_start_set = FALSE;
d149 1
a149 1
static bfd_boolean gap_fill_set = FALSE;
d153 1
a153 1
static bfd_boolean pad_to_set = FALSE;
d156 1
a156 2
/* Use alternate machine code?  */
static int use_alt_mach_code = 0;
a157 1
/* List of sections to add.  */
a173 1
/* List of sections to add to the output BFD.  */
d177 2
a178 1
static bfd_boolean convert_debugging = FALSE;
d181 2
a182 1
static bfd_boolean change_leading_char = FALSE;
d185 2
a186 1
static bfd_boolean remove_leading_char = FALSE;
d190 1
d198 1
a198 2
/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;
d200 1
a200 4
/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;
a228 6
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)
a237 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a242 1
  {"output-file", required_argument, 0, 'o'},
a263 2
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
d275 1
a278 1
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
a281 2
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
a282 3
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
a284 1
  {"only-section", required_argument, 0, 'j'},
a287 3
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
d289 2
a290 1
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
a292 1
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
a294 2
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
a298 1
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
d304 7
d320 1
a320 1
   -1 means if we should use argv[0] to decide.  */
d330 1
a330 4
extern bfd_boolean S3Forced;

/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;
a331 1

d337 2
a338 3
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
a341 1
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
a377 1
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
a387 6
     --alt-machine-code <index>    Use alternate machine code for output\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
a390 1
     --info                        List object formats & architectures supported\n\
d403 2
a404 3
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
d406 3
a408 3
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
d410 1
a410 1
  -R --remove-section=<name>       Remove section <name> from the output\n\
d412 1
a412 1
  -g -S -d --strip-debug           Remove all debugging symbols\n\
d414 2
a415 2
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
a420 1
     --info                        List object formats & architectures supported\n\
d492 1
a492 1
     bfd_boolean add;
d505 3
a507 3
  p->used = FALSE;
  p->remove = FALSE;
  p->copy = FALSE;
d512 1
a512 1
  p->set_flags = FALSE;
d536 1
a536 1
/* Add symbols listed in `filename' to strip_specific_list.  */
d551 1
a551 1

d570 1
a570 1

d576 1
a576 1
      int finished = FALSE;
d587 1
a587 1
	      finished = TRUE;
d589 1
a589 1

d595 1
a595 1
	      finished = TRUE;
d597 1
a597 1

d599 1
a599 1
	      finished = TRUE;
d601 1
a601 1

d608 1
a608 1

d625 2
a626 2
	   name_end ++)
	;
d639 1
a639 1

d655 1
a655 1
static bfd_boolean
d663 5
a667 4
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;

  return FALSE;
d672 1
a672 1
static bfd_boolean
d685 1
a685 1
    return TRUE;
d688 1
a688 1
    return FALSE;
d690 1
a690 1
  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d692 1
a692 1
    return TRUE;
d694 2
a695 2
    return TRUE;
  return FALSE;
d718 1
a718 1
      char *name = (char *) bfd_asymbol_name (sym);
a719 3
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;
d721 3
a723 1
      undefined = bfd_is_und_section (bfd_get_section (sym));
d725 10
a734 1
      if (redefine_sym_list)
d736 5
a740 1
	  char *old_name, *new_name;
d742 8
a749 53
	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
d752 8
d767 1
a767 1
      else if (relocatable			/* Relocatable file.  */
d772 1
a772 1
	   even if relocatable is FALSE.  External users of the
d775 1
a775 1
	keep = 1;
d778 1
a778 1
	       || undefined
a784 4
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
d804 1
a804 1
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
a821 2
/* Find the redefined name of symbol SOURCE.  */

d826 1
d829 2
d832 8
a839 4
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
d842 1
a842 1
/* Add a node to a symbol redefine list.  */
d856 5
a860 3
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       "--redefine-sym",
	       source);
d863 5
a867 3
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       "--redefine-sym",
	       target);
d879 1
a891 1

a911 2
  enum bfd_architecture iarch;
  unsigned int imach;
d935 5
a939 10
  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
	RETURN_NONFATAL (bfd_get_filename (ibfd));
    }
d941 3
a943 6
  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
d983 1
a983 1
	      pset = find_section_list (padd->name, FALSE);
d985 1
a985 1
		pset->used = TRUE;
d1058 2
a1059 2
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
d1083 2
a1084 2
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
d1097 2
a1098 2
  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
a1120 1
      || prefix_symbols_string
d1179 1
a1194 1

d1219 1
a1219 1
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
a1226 9

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
a1228 7
#undef MKDIR
#if defined (_WIN32) && !defined (__CYGWIN32__)
#define MKDIR(DIR, MODE) mkdir (DIR)
#else
#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
#endif

d1241 1
a1241 1
      const char *name;
d1249 5
a1253 1
  if (MKDIR (dir, 0700) != 0)
a1262 4

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

d1265 4
a1268 2
      char *output_name;
      bfd *output_bfd;
a1272 23
      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempname (output_name);
	  if (MKDIR (output_name, 0700) != 0)
	    {
	      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		     output_name, strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
a1275 1

d1289 4
a1292 1
      if (bfd_check_format (this_element, bfd_object))
d1298 1
a1298 1
	  /* Error in new object file. Don't change archive.  */
d1330 2
a1331 7
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
d1346 1
a1346 2
  char **obj_matching;
  char **core_matching;
d1350 1
d1370 1
a1370 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
d1373 1
a1373 1
    do_copy:
a1392 16
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

d1395 1
a1395 6
      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
d1397 2
a1398 2
	  list_matching_formats (core_matching);
	  free (core_matching);
d1405 2
a1406 62
/* Add a name to the section renaming list.  */

static void
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
{
  section_rename * rename;

  /* Check for conflicts first.  */
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  rename = (section_rename *) xmalloc (sizeof (* rename));

  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;

  section_rename_list = rename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * rename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
      {
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;

	return rename->new_name;
      }

  return old_name;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */
a1421 2
  const char * name;
  char *prefix = NULL;
d1431 1
a1431 1
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
d1433 1
a1433 1
    p->used = TRUE;
d1440 1
a1440 20
  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  osection = bfd_make_section_anyway (obfd, name);
d1488 4
a1491 3
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
d1497 1
d1499 1
a1499 1
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
a1505 3
  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

d1520 1
a1520 1
  /* All went well.  */
a1547 1
  flagword flags;
d1549 2
a1550 2
  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
d1554 1
a1554 2
  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
d1560 3
a1562 1
    return;
d1564 1
a1564 4
  if ((flags & SEC_GROUP) != 0)
    return;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
a1576 5
  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
    relsize = 0;
  else
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1578 1
d1594 1
a1594 1
	     keep_strip_specific_list.  */
a1608 1

d1614 1
a1614 1
  isection->reloc_done = TRUE;
d1616 1
a1616 2
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
d1759 1
a1759 1
static bfd_boolean
d1779 1
a1779 1
	return FALSE;
d1801 1
a1801 1
	  return FALSE;
d1816 1
a1816 1
	  return FALSE;
d1819 1
a1819 1
      return TRUE;
d1824 1
a1824 1
  return FALSE;
d1832 3
a1834 6
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
d1838 1
a1838 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
d1853 3
a1855 3
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
	  sections_removed = TRUE;
d1878 1
a1878 1
	  preserve_dates = TRUE;
d1887 1
a1887 1
	  verbose = TRUE;
d1890 1
a1890 4
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d1893 1
a1893 3
	  /* We've been given a long option.  */
	  break;
	case 'H':
a1900 6
 if (formats_info)
   {
     display_info ();
     return 0;
   }
 
d1962 4
a1965 8
  char * binary_architecture = NULL;
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
d1970 1
a1970 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
a1980 4
	case 'B':
	  binary_architecture = optarg;
	  break;

d2002 1
a2002 1
	  p = find_section_list (optarg, TRUE);
d2005 2
a2006 2
	  p->copy = TRUE;
	  sections_copied = TRUE;
d2010 1
a2010 1
	  p = find_section_list (optarg, TRUE);
d2013 2
a2014 2
	  p->remove = TRUE;
	  sections_removed = TRUE;
d2050 1
a2050 1
	  preserve_dates = TRUE;
d2062 1
a2062 1
	  verbose = TRUE;
d2066 1
a2066 5
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
d2070 1
a2070 1
	  weaken = TRUE;
d2164 1
a2164 1
	    p = find_section_list (name, TRUE);
d2201 1
a2201 1
	  change_warn = TRUE;
d2205 1
a2205 1
	  change_leading_char = TRUE;
d2209 1
a2209 1
	  convert_debugging = TRUE;
d2227 1
a2227 1
	    gap_fill_set = TRUE;
d2232 1
a2232 1
	  change_warn = FALSE;
d2237 1
a2237 1
	  pad_to_set = TRUE;
d2241 1
a2241 1
	  remove_leading_char = TRUE;
d2255 3
a2257 1
	      fatal (_("bad format for %s"), "--redefine-sym");
d2291 1
a2291 1
	    p = find_section_list (name, TRUE);
d2293 1
a2293 1
	    p->set_flags = TRUE;
a2297 44
	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = (char *) xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = (char *) xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

d2300 1
a2300 1
	  set_start_set = TRUE;
d2303 3
a2305 3
	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;
d2307 3
a2309 3
	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;
a2330 18
	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

a2333 1
	case 'H':
a2341 6
  if (formats_info)
    {
      display_info ();
      return 0;
    }
 
d2362 1
a2362 1
  if (binary_architecture != (char *) NULL)
d2364 2
a2365 16
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    bfd_external_binary_architecture = temp_arch_info->arch;
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
d2368 2
a2369 3
  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2371 1
a2371 4
  /* If there is no destination file, or the source and destination files
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
a2387 1

a2431 2
int main PARAMS ((int, char **));

a2438 3
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a29 2
#include "fnmatch.h"
#include "elf-bfd.h"
d61 52
a112 1
static section_rename *section_rename_list;
d116 2
a117 2
static asymbol **isympp = NULL;	/* Input symbols.  */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping.  */
d130 4
a133 5
    STRIP_NONE,			/* Don't strip.  */
    STRIP_DEBUG,		/* Strip all debugger symbols.  */
    STRIP_UNNEEDED,		/* Strip unnecessary symbols.  */
    STRIP_NONDEBUG,		/* Strip everything but debug info.  */
    STRIP_ALL			/* Strip all symbols.  */
d142 2
a143 2
    LOCALS_START_L,		/* Discard locals starting with L.  */
    LOCALS_ALL			/* Discard all locals.  */
a199 4
/* Output BFD flags user wants to set or clear */
static flagword bfd_flags_to_set;
static flagword bfd_flags_to_clear;

a219 4
/* If non-NULL the argument to --add-gnu-debuglink.
   This should be the filename to store in the .gnu_debuglink section.  */
static const char * gnu_debuglink_filename = NULL;

a228 3
/* Whether to permit wildcard in symbol comparison.  */
static bfd_boolean wildcard = FALSE;

d247 32
a278 41
enum command_line_switch
  {
    OPTION_ADD_SECTION=150,
    OPTION_CHANGE_ADDRESSES,
    OPTION_CHANGE_LEADING_CHAR,
    OPTION_CHANGE_START,
    OPTION_CHANGE_SECTION_ADDRESS,
    OPTION_CHANGE_SECTION_LMA,
    OPTION_CHANGE_SECTION_VMA,
    OPTION_CHANGE_WARNINGS,
    OPTION_DEBUGGING,
    OPTION_GAP_FILL,
    OPTION_NO_CHANGE_WARNINGS,
    OPTION_PAD_TO,
    OPTION_REMOVE_LEADING_CHAR,
    OPTION_SET_SECTION_FLAGS,
    OPTION_SET_START,
    OPTION_STRIP_UNNEEDED,
    OPTION_WEAKEN,
    OPTION_REDEFINE_SYM,
    OPTION_REDEFINE_SYMS,
    OPTION_SREC_LEN,
    OPTION_SREC_FORCES3,
    OPTION_STRIP_SYMBOLS,
    OPTION_KEEP_SYMBOLS,
    OPTION_LOCALIZE_SYMBOLS,
    OPTION_KEEPGLOBAL_SYMBOLS,
    OPTION_WEAKEN_SYMBOLS,
    OPTION_RENAME_SECTION,
    OPTION_ALT_MACH_CODE,
    OPTION_PREFIX_SYMBOLS,
    OPTION_PREFIX_SECTIONS,
    OPTION_PREFIX_ALLOC_SECTIONS,
    OPTION_FORMATS_INFO,
    OPTION_ADD_GNU_DEBUGLINK,
    OPTION_ONLY_KEEP_DEBUG,
    OPTION_READONLY_TEXT,
    OPTION_WRITABLE_TEXT,
    OPTION_PURE,
    OPTION_IMPURE
  };
a291 1
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
a303 1
  {"wildcard", no_argument, 0, 'w'},
a310 1
  {"add-gnu-debuglink", required_argument, 0, OPTION_ADD_GNU_DEBUGLINK},
a331 1
  {"impure", no_argument, 0, OPTION_IMPURE},
a343 1
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
a351 2
  {"pure", no_argument, 0, OPTION_PURE},
  {"readonly-text", no_argument, 0, OPTION_READONLY_TEXT},
a352 1
  {"redefine-syms", required_argument, 0, OPTION_REDEFINE_SYMS},
a370 2
  {"wildcard", no_argument, 0, 'w'},
  {"writable-text", no_argument, 0, OPTION_WRITABLE_TEXT},
d391 3
a393 13
/* Defined in bfd/binary.c.  Used to set architecture and machine of input
   binary files.  */
extern enum bfd_architecture  bfd_external_binary_architecture;
extern unsigned long          bfd_external_machine;

/* Forward declarations.  */
static void setup_section (bfd *, asection *, void *);
static void copy_section (bfd *, asection *, void *);
static void get_sections (bfd *, asection *, void *);
static int compare_section_lma (const void *, const void *);
static void mark_symbols_used_in_relocations (bfd *, asection *, void *);
static bfd_boolean write_debugging_info (bfd *, void *, long *, asymbol ***);
static const char *lookup_sym_redefinition (const char *);
d396 3
a398 1
copy_usage (FILE *stream, int exit_status)
a410 1
     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\n\
d413 1
a413 1
  -g --strip-debug                 Remove all debugging symbols & sections\n\
a415 1
     --only-keep-debug             Strip everything but the debug information\n\
a420 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
a446 2
     --redefine-syms <file>        --redefine-sym for all symbol pairs \n\
                                     listed in <file>\n\
a454 4
     --writable-text               Mark the output text as writable\n\
     --readonly-text               Make the output text write protected\n\
     --pure                        Mark the output file as demand paged\n\
     --impure                      Mark the output file as impure\n\
d472 3
a474 1
strip_usage (FILE *stream, int exit_status)
d486 1
a486 1
  -g -S -d --strip-debug           Remove all debugging symbols & sections\n\
a487 1
     --only-keep-debug             Strip everything but the debug information\n\
a489 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
d509 2
a510 1
parse_flags (const char *s)
d565 3
a567 1
find_section_list (const char *name, bfd_boolean add)
d569 1
a569 1
  struct section_list *p;
d578 1
a578 1
  p = xmalloc (sizeof (struct section_list));
d599 3
a601 1
add_specific_symbol (const char *name, struct symlist **list)
d605 1
a605 1
  tmp_list = xmalloc (sizeof (struct symlist));
d617 3
a619 1
add_specific_symbols (const char *filename, struct symlist **list)
d621 1
a621 1
  off_t  size;
d627 3
a629 2
  size = get_file_size (filename);
  if (size == 0)
d632 1
a632 1
  buffer = xmalloc (size + 2);
d635 1
a635 1
    fatal (_("cannot open '%s': %s"), filename, strerror (errno));
d637 1
a637 1
  if (fread (buffer, 1, size, f) == 0 || ferror (f))
d641 2
a642 2
  buffer [size] = '\n';
  buffer [size + 1] = '\0';
d731 3
a733 1
is_specified_symbol (const char *name, struct symlist *list)
d737 3
a739 20
  if (wildcard)
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (*(tmp_list->name) != '!')
	  {
	    if (!fnmatch (tmp_list->name, name, 0))
	      return TRUE;
	  }
	else
	  {
	    if (fnmatch (tmp_list->name + 1, name, 0))
	      return TRUE;
	  }
    }
  else
    {
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (strcmp (name, tmp_list->name) == 0)
	  return TRUE;
    }
d747 3
a749 1
is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d751 1
a751 5
  if (sections_removed || sections_copied)
    {
      struct section_list *p;

      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d753 2
a754 9
      if (sections_removed && p != NULL && p->remove)
	return TRUE;
      if (sections_copied && (p == NULL || ! p->copy))
	return TRUE;
    }

  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0)
    {
      if (strip_symbols == STRIP_DEBUG
d758 2
a759 2
	  || convert_debugging)
	return TRUE;
d761 2
a762 3
      if (strip_symbols == STRIP_NONDEBUG)
	return FALSE;
    }
d764 5
d777 5
a781 2
filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
		asymbol **isyms, long symcount)
d783 1
a783 1
  asymbol **from = isyms, **to = osyms;
d844 1
a844 2
          ptr = n = xmalloc (1 + strlen (prefix_symbols_string)
			     + strlen (name) + 1);
d928 2
a929 1
lookup_sym_redefinition (const char *source)
d943 3
a945 1
redefine_list_append (const char *cause, const char *source, const char *target)
d955 2
a956 1
	       cause, source);
d960 2
a961 1
	       cause, target);
d964 1
a964 1
  new_node = xmalloc (sizeof (struct redefine_node));
d973 2
a974 2
/* Handle the --redefine-syms option.  Read lines containing "old new"
   from the file, and add them to the symbol redefine list.  */
d977 3
a979 1
add_redefine_syms_file (const char *filename)
d981 1
a981 92
  FILE *file;
  char *buf;
  size_t bufsize;
  size_t len;
  size_t outsym_off;
  int c, lineno;

  file = fopen (filename, "r");
  if (file == NULL)
    fatal (_("couldn't open symbol redefinition file %s (error: %s)"),
	   filename, strerror (errno));

  bufsize = 100;
  buf = xmalloc (bufsize);

  lineno = 1;
  c = getc (file);
  len = 0;
  outsym_off = 0;
  while (c != EOF)
    {
      /* Collect the input symbol name.  */
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space between the symbol names.  */
      while (IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#' || IS_LINE_TERMINATOR (c))
	goto comment;
      if (c == EOF)
	break;

      /* Collect the output symbol name.  */
      outsym_off = len;
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = xrealloc (buf, bufsize);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space at end of line.  */
      while (! IS_LINE_TERMINATOR(c) && c != EOF && IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#')
	goto comment;
      /* Handle \r\n.  */
      if ((c == '\r' && (c = getc (file)) == '\n')
	  || c == '\n' || c == EOF)
	{
 end_of_line:
	  /* Append the redefinition to the list.  */
	  if (buf[0] != '\0')
	    redefine_list_append (filename, &buf[0], &buf[outsym_off]);

	  lineno++;	
	  len = 0;
	  outsym_off = 0;
	  if (c == EOF)
	    break;
	  c = getc (file);
	  continue;
	}
      else
	fatal (_("%s: garbage at end of line %d"), filename, lineno);
 comment:
      if (len != 0 && (outsym_off == 0 || outsym_off == len))
	fatal (_("%s: missing new symbol name at line %d"), filename, lineno);
      buf[len++] = '\0';
d983 2
a984 5
      /* Eat the rest of the line and finish it.  */
      while (c != '\n' && c != EOF)
	c = getc (file);
      goto end_of_line;
    }
d986 4
a989 4
  if (len != 0)
    fatal (_("%s: premature end of file at line %d"), filename, lineno);

  free (buf);
d992 1
a992 2
/* Copy object file IBFD onto OBFD.
   Returns TRUE upon success, FALSE otherwise.  */
d994 4
a997 2
static bfd_boolean
copy_object (bfd *ibfd, bfd *obfd)
a1001 1
  asection *gnu_debuglink_section = NULL;
d1005 1
a1005 1
  void *dhandle;
d1012 4
a1015 1
    fatal (_("Unable to change endianness of input file(s)"));
d1018 1
a1018 4
    {
      bfd_nonfatal (bfd_get_filename (obfd));
      return FALSE;
    }
a1034 7
      flagword flags;

      flags = bfd_get_file_flags (ibfd);
      flags |= bfd_flags_to_set;
      flags &= ~bfd_flags_to_clear;
      flags &= bfd_applicable_file_flags (obfd);

d1036 4
a1039 5
	  || !bfd_set_file_flags (obfd, flags))
	{
	  bfd_nonfatal (bfd_get_filename (ibfd));
	  return FALSE;
	}
d1048 3
a1050 12
    {
      if (bfd_get_arch (ibfd) == bfd_arch_unknown)
	fatal (_("Unable to recognise the format of the input file %s"),
	       bfd_get_filename (ibfd));
      else
	{
	  non_fatal (_("Warning: Output file cannot represent architecture %s"),
		     bfd_printable_arch_mach (bfd_get_arch (ibfd),
					      bfd_get_mach (ibfd)));
	  return FALSE;
	}
    }
d1053 1
a1053 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
d1063 1
a1063 1
  bfd_map_over_sections (ibfd, setup_section, obfd);
a1071 2
	  flagword flags;

d1077 2
a1078 1
	      return FALSE;
d1080 1
a1080 2

	  if (! bfd_set_section_size (obfd, padd->section, padd->size))
d1082 1
a1082 3
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
d1084 2
a1085 3
	  pset = find_section_list (padd->name, FALSE);
	  if (pset != NULL)
	    pset->used = TRUE;
d1087 3
a1089 4
	  if (pset != NULL && pset->set_flags)
	    flags = pset->flags | SEC_HAS_CONTENTS;
	  else
	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
d1091 4
a1094 5
	  if (! bfd_set_section_flags (obfd, padd->section, flags))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
d1096 2
a1097 9
	  if (pset != NULL)
	    {
	      if (pset->change_vma != CHANGE_IGNORE)
		if (! bfd_set_section_vma (obfd, padd->section,
					   pset->vma_val))
		  {
		    bfd_nonfatal (bfd_get_filename (obfd));
		    return FALSE;
		  }
d1099 1
a1099 1
	      if (pset->change_lma != CHANGE_IGNORE)
d1101 3
a1103 1
		  padd->section->lma = pset->lma_val;
d1105 1
a1105 3
		  if (! bfd_set_section_alignment
		      (obfd, padd->section,
		       bfd_section_alignment (obfd, padd->section)))
d1107 6
a1112 2
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
a1118 18
  if (gnu_debuglink_filename != NULL)
    {
      gnu_debuglink_section = bfd_create_gnu_debuglink_section
	(obfd, gnu_debuglink_filename);

      if (gnu_debuglink_section == NULL)
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
	}
    }

  if (bfd_count_sections (obfd) == 0)
    {
      non_fatal (_("there are no sections to be copied!"));
      return FALSE;
    }

d1131 1
a1131 1
      osections = xmalloc (c * sizeof (asection *));
d1133 1
a1133 1
      bfd_map_over_sections (obfd, get_sections, &set);
d1137 1
a1137 1
      gaps = xmalloc (c * sizeof (bfd_size_type));
d1206 1
a1206 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
d1208 1
a1208 1
  osympp = isympp = xmalloc (symsize);
d1211 1
a1211 4
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }
a1218 1
      || strip_symbols == STRIP_NONDEBUG
d1245 2
a1246 2
			       isympp);
      osympp = xmalloc ((symcount + 1) * sizeof (asymbol *));
d1255 1
a1255 1
	  return FALSE;
d1262 1
a1262 1
  bfd_map_over_sections (ibfd, copy_section, obfd);
d1270 5
a1274 16
	  if (! bfd_set_section_contents (obfd, padd->section, padd->contents,
					  0, padd->size))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      if (! bfd_fill_in_gnu_debuglink_section
	  (obfd, gnu_debuglink_section, gnu_debuglink_filename))
	{
	  bfd_nonfatal (gnu_debuglink_filename);
	  return FALSE;
d1286 2
a1287 2
      buf = xmalloc (max_gap);
      memset (buf, gap_fill, max_gap);
d1311 1
a1311 4
		    {
		      bfd_nonfatal (bfd_get_filename (obfd));
		      return FALSE;
		    }
d1324 1
a1324 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (! bfd_copy_private_bfd_data (ibfd, obfd))
d1329 2
a1330 1
      return FALSE;
d1336 5
a1340 5
  if (use_alt_mach_code != 0
      && ! bfd_alt_mach_code (obfd, use_alt_mach_code))
    non_fatal (_("unknown alternate machine code, ignored"));

  return TRUE;
d1354 4
a1357 1
copy_archive (bfd *ibfd, bfd *obfd, const char *output_target)
d1371 4
a1374 3
    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	   dir, strerror (errno));

d1384 1
a1384 1
  while (!status && this_element != NULL)
a1390 1
      bfd_boolean delete = TRUE;
d1401 5
a1405 4
	    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		   output_name, strerror (errno));

	  l = xmalloc (sizeof (struct name_list));
d1424 1
a1424 1
      l = xmalloc (sizeof (struct name_list));
d1429 1
a1429 1
      if (output_bfd == NULL)
d1433 1
a1433 1
	delete = ! copy_object (this_element, output_bfd);
d1442 2
a1443 9
      if (delete)
	{
	  unlink (output_name);
	  status = 1;
	}
      else
	{
	  if (preserve_dates && stat_status == 0)
	    set_times (output_name, &buf);
d1445 2
a1446 2
	  /* Open the newly output file and attach to our list.  */
	  output_bfd = bfd_openr (output_name, output_target);
d1448 1
a1448 1
	  l->obfd = output_bfd;
d1450 2
a1451 2
	  *ptr = output_bfd;
	  ptr = &output_bfd->next;
d1453 1
a1453 1
	  last_element = this_element;
d1455 1
a1455 1
	  this_element = bfd_openr_next_archived_file (ibfd, last_element);
d1457 1
a1457 2
	  bfd_close (last_element);
	}
d1459 1
a1459 1
  *ptr = NULL;
d1484 5
a1488 2
copy_file (const char *input_filename, const char *output_filename,
	   const char *input_target,   const char *output_target)
a1493 6
  if (get_file_size (input_filename) < 1)
    {
      status = 1;
      return;
    }

a1517 1
      bfd_boolean delete;
a1518 1

d1528 1
a1528 1
      delete = ! copy_object (ibfd, obfd);
a1534 6

      if (delete)
	{
	  unlink (output_filename);
	  status = 1;
	}
d1574 4
a1577 2
add_section_rename (const char * old_name, const char * new_name,
		    flagword flags)
d1593 1
a1593 1
  rename = xmalloc (sizeof (* rename));
d1608 4
a1611 2
find_section_rename (bfd * ibfd ATTRIBUTE_UNUSED, sec_ptr isection,
		     flagword * returned_flags)
d1635 4
a1638 1
setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
d1640 1
a1640 1
  bfd *obfd = obfdarg;
d1651 6
a1656 1
  if (is_strip_section (ibfd, isection))
d1663 5
d1672 1
a1672 2
  if ((prefix_alloc_sections_string)
      && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
a1744 7
  else if (strip_symbols == STRIP_NONDEBUG && (flags & SEC_ALLOC) != 0)
    {
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
      if (obfd->xvec->flavour == bfd_target_elf_flavour)
	elf_section_type (osection) = SHT_NOBITS;
    }

d1762 1
a1762 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
d1784 4
a1787 1
copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
d1789 1
a1789 1
  bfd *obfd = obfdarg;
d1803 7
a1809 1
  if (is_strip_section (ibfd, isection))
a1811 1
  flags = bfd_get_section_flags (ibfd, isection);
d1815 7
a1827 2
  p = find_section_list (bfd_get_section_name (ibfd, isection), FALSE);

d1832 1
a1832 2
    {
      relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1834 2
a1835 9
      if (relsize < 0)
	{
	  /* Do not complain if the target does not support relocations.  */
	  if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	    relsize = 0;
	  else
	    RETURN_NONFATAL (bfd_get_filename (ibfd));
	}
    }
d1838 1
a1838 1
    bfd_set_reloc (obfd, osection, NULL, 0);
d1841 1
a1841 1
      relpp = xmalloc (relsize);
d1854 1
a1854 1
	  temp_relpp = xmalloc (relsize);
d1856 3
a1858 2
	    if (is_specified_symbol (bfd_asymbol_name (*relpp[i]->sym_ptr_ptr),
				     keep_specific_list))
d1865 2
a1866 3
      bfd_set_reloc (obfd, osection, relcount == 0 ? NULL : relpp, relcount);
      if (relcount == 0)
	free (relpp);
d1875 1
a1875 1
      void *memhunk = xmalloc (size);
d1877 2
a1878 1
      if (!bfd_get_section_contents (ibfd, isection, memhunk, 0, size))
d1882 1
a1882 12
	{
	  /* Keep only every `copy_byte'th byte in MEMHUNK.  */
	  char *from = (char *) memhunk + copy_byte;
	  char *to = memhunk;
	  char *end = (char *) memhunk + size;

	  for (; from < end; from += interleave)
	    *to++ = *from;

	  size = (size + interleave - 1 - copy_byte) / interleave;
	  osection->lma /= interleave;
	}
d1884 2
a1885 1
      if (!bfd_set_section_contents (obfd, osection, memhunk, 0, size))
d1892 1
a1892 1
      void *memhunk = xmalloc (size);
d1901 2
a1902 1
      if (! bfd_set_section_contents (obfd, osection, memhunk, 0, size))
d1912 4
a1915 1
get_sections (bfd *obfd ATTRIBUTE_UNUSED, asection *osection, void *secppparg)
d1917 1
a1917 1
  asection ***secppp = secppparg;
d1928 3
a1930 1
compare_section_lma (const void *arg1, const void *arg2)
d1932 2
a1933 2
  const asection *const *sec1 = arg1;
  const asection *const *sec2 = arg2;
d1974 4
a1977 1
mark_symbols_used_in_relocations (bfd *ibfd, sec_ptr isection, void *symbolsarg)
d1979 1
a1979 1
  asymbol **symbols = symbolsarg;
d1990 1
a1990 6
    {
      /* Do not complain if the target does not support relocations.  */
      if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	return;
      bfd_fatal (bfd_get_filename (ibfd));
    }
d1995 1
a1995 1
  relpp = xmalloc (relsize);
d2017 5
a2021 3
write_debugging_info (bfd *obfd, void *dhandle,
		      long *symcountp ATTRIBUTE_UNUSED,
		      asymbol ***symppp ATTRIBUTE_UNUSED)
d2065 4
a2068 3
      if (! bfd_set_section_contents (obfd, stabsec, syms, 0, symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings, 0,
					 stringsize))
d2085 3
a2087 1
strip_main (int argc, char *argv[])
d2098 1
a2098 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVvw",
a2154 3
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;
a2157 3
	case 'w':
	  wildcard = TRUE;
	  break;
d2166 5
a2170 5
  if (formats_info)
    {
      display_info ();
      return 0;
    }
d2181 1
a2181 1
  if (output_target == NULL)
a2194 3
      if (get_file_size (argv[i]) < 1)
	continue;

d2196 7
a2202 3
	/* No need to check the return value of stat().
	   It has already been checked in get_file_size().  */
	stat (argv[i], &statbuf);
d2229 3
a2231 1
copy_main (int argc, char *argv[])
d2245 1
a2245 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:w",
a2307 8
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;

	case OPTION_ADD_GNU_DEBUGLINK:
	  gnu_debuglink_filename = optarg;
	  break;

a2331 4
	case 'w':
	  wildcard = TRUE;
	  break;

d2359 1
a2359 1
	    off_t size;
d2370 2
a2371 3
	    size = get_file_size (s + 1);
	    if (size < 1)
	      break;
d2373 1
a2373 1
	    pa = xmalloc (sizeof (struct section_add));
d2376 1
a2376 1
	    name = xmalloc (len + 1);
a2381 2
	    pa->size = size;
	    pa->contents = xmalloc (size);
d2383 3
d2389 1
a2389 2
	      fatal (_("cannot open: %s: %s"),
		     pa->filename, strerror (errno));
d2443 1
a2443 1
	    name = xmalloc (len + 1);
d2541 1
a2541 1
	    source = xmalloc (len + 1);
d2547 1
a2547 1
	    target = xmalloc (len + 1);
d2550 1
a2550 1
	    redefine_list_append ("--redefine-sym", source, target);
a2556 4
	case OPTION_REDEFINE_SYMS:
	  add_redefine_syms_file (optarg);
	  break;

d2568 1
a2568 1
	    name = xmalloc (len + 1);
d2595 1
a2595 1
	    old_name = xmalloc (len + 1);
d2615 1
a2615 1
	    new_name = xmalloc (len + 1);
a2673 20
	case OPTION_READONLY_TEXT:
	  bfd_flags_to_set |= WP_TEXT;
	  bfd_flags_to_clear &= ~WP_TEXT;
	  break;

	case OPTION_WRITABLE_TEXT:
	  bfd_flags_to_clear |= WP_TEXT;
	  bfd_flags_to_set &= ~WP_TEXT;
	  break;

	case OPTION_PURE:
	  bfd_flags_to_set |= D_PAGED;
	  bfd_flags_to_clear &= ~D_PAGED;
	  break;

	case OPTION_IMPURE:
	  bfd_flags_to_clear |= D_PAGED;
	  bfd_flags_to_set &= ~D_PAGED;
	  break;

d2675 1
a2675 2
	  /* We've been given a long option.  */
	  break;
d2709 1
a2709 1
  if (output_target == NULL)
d2712 1
a2712 1
  if (binary_architecture != NULL)
d2721 1
a2721 4
	    {
	      bfd_external_binary_architecture = temp_arch_info->arch;
	      bfd_external_machine             = temp_arch_info->mach;
	    }
d2734 1
a2734 2
      fatal (_("warning: could not locate '%s'.  System error message: %s"),
	     input_filename, strerror (errno));
d2737 3
a2739 2
     are the same, then create a temp and rename the result into the input.  */
  if (output_filename == NULL || strcmp (input_filename, output_filename) == 0)
d2801 2
d2804 3
a2806 1
main (int argc, char *argv[])
@


