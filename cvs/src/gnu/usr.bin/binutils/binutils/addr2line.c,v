head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.10
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.8
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.1;
commitid	dbwlUkpK0xDlII16;

1.1
date	97.05.29.09.15.30;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.15.30;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.45.00;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.13.59;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* addr2line.c -- convert addresses to line number and function name
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Contributed by Ulrich Lauther <Ulrich.Lauther@@mchp.siemens.de>

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Derived from objdump.c and nm.c by Ulrich.Lauther@@mchp.siemens.de

   Usage:
   addr2line [options] addr addr ...
   or
   addr2line [options]

   both forms write results to stdout, the second form reads addresses
   to be converted from stdin.  */

#include <string.h>

#include "bfd.h"
#include "getopt.h"
#include "libiberty.h"
#include "demangle.h"
#include "bucomm.h"
#include "budemang.h"

static bfd_boolean with_functions;	/* -f, show function names.  */
static bfd_boolean do_demangle;		/* -C, demangle names.  */
static bfd_boolean base_names;		/* -s, strip directory names.  */

static int naddr;		/* Number of addresses to process.  */
static char **addr;		/* Hex addresses to process.  */

static asymbol **syms;		/* Symbol table.  */

static struct option long_options[] =
{
  {"basenames", no_argument, NULL, 's'},
  {"demangle", optional_argument, NULL, 'C'},
  {"exe", required_argument, NULL, 'e'},
  {"functions", no_argument, NULL, 'f'},
  {"target", required_argument, NULL, 'b'},
  {"help", no_argument, NULL, 'H'},
  {"version", no_argument, NULL, 'V'},
  {0, no_argument, 0, 0}
};

static void usage (FILE *, int);
static void slurp_symtab (bfd *);
static void find_address_in_section (bfd *, asection *, void *);
static void translate_addresses (bfd *);
static void process_file (const char *, const char *);

/* Print a usage message to STREAM and exit with STATUS.  */

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s [option(s)] [addr(s)]\n"), program_name);
  fprintf (stream, _(" Convert addresses into line number/file name pairs.\n"));
  fprintf (stream, _(" If no addresses are specified on the command line, they will be read from stdin\n"));
  fprintf (stream, _(" The options are:\n\
  -b --target=<bfdname>  Set the binary file format\n\
  -e --exe=<executable>  Set the input file name (default is a.out)\n\
  -s --basenames         Strip directory names\n\
  -f --functions         Show function names\n\
  -C --demangle[=style]  Demangle function names\n\
  -h --help              Display this information\n\
  -v --version           Display the program's version\n\
\n"));

  list_supported_targets (program_name, stream);
  if (status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

/* Read in the symbol table.  */

static void
slurp_symtab (bfd *abfd)
{
  long symcount;
  unsigned int size;

  if ((bfd_get_file_flags (abfd) & HAS_SYMS) == 0)
    return;

  symcount = bfd_read_minisymbols (abfd, FALSE, (void *) &syms, &size);
  if (symcount == 0)
    symcount = bfd_read_minisymbols (abfd, TRUE /* dynamic */, (void *) &syms, &size);

  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
}

/* These global variables are used to pass information between
   translate_addresses and find_address_in_section.  */

static bfd_vma pc;
static const char *filename;
static const char *functionname;
static unsigned int line;
static bfd_boolean found;

/* Look for an address in a section.  This is called via
   bfd_map_over_sections.  */

static void
find_address_in_section (bfd *abfd, asection *section,
			 void *data ATTRIBUTE_UNUSED)
{
  bfd_vma vma;
  bfd_size_type size;

  if (found)
    return;

  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)
    return;

  vma = bfd_get_section_vma (abfd, section);
  if (pc < vma)
    return;

  size = bfd_get_section_size_before_reloc (section);
  if (pc >= vma + size)
    return;

  found = bfd_find_nearest_line (abfd, section, syms, pc - vma,
				 &filename, &functionname, &line);
}

/* Read hexadecimal addresses from stdin, translate into
   file_name:line_number and optionally function name.  */

static void
translate_addresses (bfd *abfd)
{
  int read_stdin = (naddr == 0);

  for (;;)
    {
      if (read_stdin)
	{
	  char addr_hex[100];

	  if (fgets (addr_hex, sizeof addr_hex, stdin) == NULL)
	    break;
	  pc = bfd_scan_vma (addr_hex, NULL, 16);
	}
      else
	{
	  if (naddr <= 0)
	    break;
	  --naddr;
	  pc = bfd_scan_vma (*addr++, NULL, 16);
	}

      found = FALSE;
      bfd_map_over_sections (abfd, find_address_in_section, NULL);

      if (! found)
	{
	  if (with_functions)
	    printf ("??\n");
	  printf ("??:0\n");
	}
      else
	{
	  if (with_functions)
	    {
	      const char *name;
	      char *alloc = NULL;

	      name = functionname;
	      if (name == NULL || *name == '\0')
		name = "??";
	      else if (do_demangle)
		{
		  alloc = demangle (abfd, name);
		  name = alloc;
		}

	      printf ("%s\n", name);

	      if (alloc != NULL)
		free (alloc);
	    }

	  if (base_names && filename != NULL)
	    {
	      char *h;

	      h = strrchr (filename, '/');
	      if (h != NULL)
		filename = h + 1;
	    }

	  printf ("%s:%u\n", filename ? filename : "??", line);
	}

      /* fflush() is essential for using this command as a server
         child process that reads addresses from a pipe and responds
         with line number information, processing one address at a
         time.  */
      fflush (stdout);
    }
}

/* Process a file.  */

static void
process_file (const char *file_name, const char *target)
{
  bfd *abfd;
  char **matching;

  if (get_file_size (file_name) < 1)
    return;

  abfd = bfd_openr (file_name, target);
  if (abfd == NULL)
    bfd_fatal (file_name);

  if (bfd_check_format (abfd, bfd_archive))
    fatal (_("%s: can not get addresses from archive"), file_name);

  if (! bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (bfd_get_filename (abfd));
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

  slurp_symtab (abfd);

  translate_addresses (abfd);

  if (syms != NULL)
    {
      free (syms);
      syms = NULL;
    }

  bfd_close (abfd);
}

int main (int, char **);

int
main (int argc, char **argv)
{
  const char *file_name;
  char *target;
  int c;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  file_name = NULL;
  target = NULL;
  while ((c = getopt_long (argc, argv, "b:Ce:sfHhVv", long_options, (int *) 0))
	 != EOF)
    {
      switch (c)
	{
	case 0:
	  break;		/* We've been given a long option.  */
	case 'b':
	  target = optarg;
	  break;
	case 'C':
	  do_demangle = TRUE;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'e':
	  file_name = optarg;
	  break;
	case 's':
	  base_names = TRUE;
	  break;
	case 'f':
	  with_functions = TRUE;
	  break;
	case 'v':
	case 'V':
	  print_version ("addr2line");
	  break;
	case 'h':
	case 'H':
	  usage (stdout, 0);
	  break;
	default:
	  usage (stderr, 1);
	  break;
	}
    }

  if (file_name == NULL)
    file_name = "a.out";

  addr = argv + optind;
  naddr = argc - optind;

  process_file (file_name, target);

  return 0;
}
@


1.1
log
@Initial revision
@
text
@d2 3
a4 2
   Copyright 1997 Free Software Foundation, Inc.
   Contributed by Ulrich Lauther <Ulrich.Lauther@@zfe.siemens.de>
d22 1
a22 1
/* Derived from objdump.c and nm.c by Ulrich.Lauther@@zfe.siemens.de
d24 1
a24 1
   Usage: 
d27 1
a27 1
   addr2line [options] 
a31 1
#include <ctype.h>
d39 1
d41 3
a43 5
extern char *program_version;

static boolean with_functions;	/* -f, show function names.  */
static boolean do_demangle;	/* -C, demangle names.  */
static boolean base_names;	/* -s, strip directory names.  */
d53 1
a53 1
  {"demangle", no_argument, NULL, 'C'},
d62 5
a66 5
static void usage PARAMS ((FILE *, int));
static void slurp_symtab PARAMS ((bfd *));
static void find_address_in_section PARAMS ((bfd *, asection *, PTR));
static void translate_addresses PARAMS ((bfd *));
static void process_file PARAMS ((const char *, const char *));
d71 1
a71 3
usage (stream, status)
     FILE *stream;
     int status;
d73 13
a85 5
  fprintf (stream, "\
Usage: %s [-CfsHV] [-b bfdname] [--target=bfdname]\n\
       [-e executable] [--exe=executable] [--demangle]\n\
       [--basenames] [--functions] [addr addr ...]\n",
	   program_name);
d88 1
a88 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d95 1
a95 2
slurp_symtab (abfd)
     bfd *abfd;
a96 1
  long storage;
d98 1
d103 3
a105 3
  storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    bfd_fatal (bfd_get_filename (abfd));
a106 3
  syms = (asymbol **) xmalloc (storage);

  symcount = bfd_canonicalize_symtab (abfd, syms);
d118 1
a118 1
static boolean found;
d124 2
a125 4
find_address_in_section (abfd, section, data)
     bfd *abfd;
     asection *section;
     PTR data;
d128 1
d140 4
d152 1
a152 2
translate_addresses (abfd)
     bfd *abfd;
d164 1
a164 1
	  pc = strtol (addr_hex, NULL, 16);
d171 1
a171 1
	  pc = strtol (*addr++, NULL, 16);
d174 2
a175 2
      found = false;
      bfd_map_over_sections (abfd, find_address_in_section, (PTR) NULL);
d187 7
a193 5
	      if (*functionname == '\0')
		printf ("??\n");
	      else if (! do_demangle)
		printf ("%s\n", functionname);
	      else
d195 3
a197 1
		  char *res;
d199 4
a202 9
		  res = cplus_demangle (functionname, DMGL_ANSI | DMGL_PARAMS);
		  if (res == NULL)
		    printf ("%s\n", functionname);
		  else
		    {
		      printf ("%s\n", res);
		      free (res);
		    }
		}
d205 1
a205 1
	  if (base_names)
d214 1
a214 1
	  printf ("%s:%u\n", filename, line);
d228 1
a228 3
process_file (filename, target)
     const char *filename;
     const char *target;
d233 4
a236 1
  abfd = bfd_openr (filename, target);
d238 1
a238 1
    bfd_fatal (filename);
d241 1
a241 1
    fatal ("%s: can not get addresses from archive", filename);
d267 2
d270 1
a270 3
main (argc, argv)
     int argc;
     char **argv;
d272 1
a272 1
  char *filename;
d276 9
d288 2
d293 1
a293 1
  filename = NULL;
d295 1
a295 1
  while ((c = getopt_long (argc, argv, "b:Ce:sfHV", long_options, (int *) 0))
d301 1
a301 1
	  break;		/* we've been given a long option */
d306 12
a317 1
	  do_demangle = true;
d320 1
a320 1
	  filename = optarg;
d323 1
a323 1
	  base_names = true;
d326 1
a326 1
	  with_functions = true;
d328 1
d332 1
d342 2
a343 2
  if (filename == NULL)
    filename = "a.out";
d348 1
a348 1
  process_file (filename, target);
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1997, 98, 99, 2000 Free Software Foundation, Inc.
d76 1
a76 1
  fprintf (stream, _("\
d79 1
a79 1
       [--basenames] [--functions] [addr addr ...]\n"),
d83 1
a83 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d126 1
a126 1
     PTR data ATTRIBUTE_UNUSED;
a128 1
  bfd_size_type size;
a139 4
  size = bfd_get_section_size_before_reloc (section);
  if (pc >= vma + size)
    return;

d161 1
a161 1
	  pc = bfd_scan_vma (addr_hex, NULL, 16);
d168 1
a168 1
	  pc = bfd_scan_vma (*addr++, NULL, 16);
d184 1
a184 1
	      if (functionname == NULL || *functionname == '\0')
d203 1
a203 1
	  if (base_names && filename != NULL)
d212 1
a212 1
	  printf ("%s:%u\n", filename ? filename : "??", line);
d238 1
a238 1
    fatal (_("%s: can not get addresses from archive"), filename);
a271 6

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 2
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   Contributed by Ulrich Lauther <Ulrich.Lauther@@mchp.siemens.de>
d21 1
a21 1
/* Derived from objdump.c and nm.c by Ulrich.Lauther@@mchp.siemens.de
d54 1
a54 1
  {"demangle", optional_argument, NULL, 'C'},
d78 1
a78 1
       [-e executable] [--exe=executable] [--demangle[=style]]\n\
d274 1
a274 1
  const char *filename;
a303 11
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;
	      
	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling) 
		fatal (_("unknown demangling style `%s'"),
		       optarg);
	      
	      cplus_demangle_set_style (style);
           }
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d23 1
a23 1
   Usage:
d26 1
a26 1
   addr2line [options]
d31 1
a38 1
#include "budemang.h"
d40 5
a44 3
static bfd_boolean with_functions;	/* -f, show function names.  */
static bfd_boolean do_demangle;		/* -C, demangle names.  */
static bfd_boolean base_names;		/* -s, strip directory names.  */
d76 5
a80 13
  fprintf (stream, _("Usage: %s [option(s)] [addr(s)]\n"), program_name);
  fprintf (stream, _(" Convert addresses into line number/file name pairs.\n"));
  fprintf (stream, _(" If no addresses are specified on the command line, they will be read from stdin\n"));
  fprintf (stream, _(" The options are:\n\
  -b --target=<bfdname>  Set the binary file format\n\
  -e --exe=<executable>  Set the input file name (default is a.out)\n\
  -s --basenames         Strip directory names\n\
  -f --functions         Show function names\n\
  -C --demangle[=style]  Demangle function names\n\
  -h --help              Display this information\n\
  -v --version           Display the program's version\n\
\n"));

d93 1
a94 1
  unsigned int size;
d99 5
a103 3
  symcount = bfd_read_minisymbols (abfd, FALSE, (PTR) &syms, &size);
  if (symcount == 0)
    symcount = bfd_read_minisymbols (abfd, TRUE /* dynamic */, (PTR) &syms, &size);
d105 1
d117 1
a117 1
static bfd_boolean found;
d176 1
a176 1
      found = FALSE;
d189 7
a195 2
	      const char *name;
	      char *alloc = NULL;
d197 8
a204 7
	      name = functionname;
	      if (name == NULL || *name == '\0')
		name = "??";
	      else if (do_demangle)
		{
		  alloc = demangle (abfd, name);
		  name = alloc;
a205 5

	      printf ("%s\n", name);

	      if (alloc != NULL)
		free (alloc);
d231 2
a232 2
process_file (file_name, target)
     const char *file_name;
d238 1
a238 1
  abfd = bfd_openr (file_name, target);
d240 1
a240 1
    bfd_fatal (file_name);
d243 1
a243 1
    fatal (_("%s: can not get addresses from archive"), file_name);
a268 2
int main PARAMS ((int, char **));

d274 1
a274 1
  const char *file_name;
a280 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d290 1
a290 1
  file_name = NULL;
d292 1
a292 1
  while ((c = getopt_long (argc, argv, "b:Ce:sfHhVv", long_options, (int *) 0))
d298 1
a298 1
	  break;		/* We've been given a long option.  */
d303 1
a303 1
	  do_demangle = TRUE;
d307 1
a307 1

d309 1
a309 1
	      if (style == unknown_demangling)
d312 1
a312 1

d314 1
a314 1
	    }
d317 1
a317 1
	  file_name = optarg;
d320 1
a320 1
	  base_names = TRUE;
d323 1
a323 1
	  with_functions = TRUE;
a324 1
	case 'v':
a327 1
	case 'h':
d337 2
a338 2
  if (file_name == NULL)
    file_name = "a.out";
d343 1
a343 1
  process_file (file_name, target);
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d61 5
a65 5
static void usage (FILE *, int);
static void slurp_symtab (bfd *);
static void find_address_in_section (bfd *, asection *, void *);
static void translate_addresses (bfd *);
static void process_file (const char *, const char *);
d70 3
a72 1
usage (FILE *stream, int status)
d96 2
a97 1
slurp_symtab (bfd *abfd)
d105 1
a105 1
  symcount = bfd_read_minisymbols (abfd, FALSE, (void *) &syms, &size);
d107 1
a107 1
    symcount = bfd_read_minisymbols (abfd, TRUE /* dynamic */, (void *) &syms, &size);
d126 4
a129 2
find_address_in_section (bfd *abfd, asection *section,
			 void *data ATTRIBUTE_UNUSED)
d156 2
a157 1
translate_addresses (bfd *abfd)
d180 1
a180 1
      bfd_map_over_sections (abfd, find_address_in_section, NULL);
d233 3
a235 1
process_file (const char *file_name, const char *target)
a239 3
  if (get_file_size (file_name) < 1)
    return;

d271 1
a271 1
int main (int, char **);
d274 3
a276 1
main (int argc, char **argv)
@


