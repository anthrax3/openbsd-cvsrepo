head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.07.23.53.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.22.45.16;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.29;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.09.14.14.20.11;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.42;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.42;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.15.46;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.01;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.14.21;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* bucomm.c -- Bin Utils COMmon code.
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* We might put this in a library someday so it could be dynamically
   loaded, but for now it's not necessary.  */

#include "bfd.h"
#include "bfdver.h"
#include "libiberty.h"
#include "bucomm.h"
#include "filenames.h"
#include "libbfd.h"

#include <sys/stat.h>
#include <time.h>		/* ctime, maybe time_t */

#ifndef HAVE_TIME_T_IN_TIME_H
#ifndef HAVE_TIME_T_IN_TYPES_H
typedef long time_t;
#endif
#endif

static const char * endian_string (enum bfd_endian);
static int display_target_list (void);
static int display_info_table (int, int);
static int display_target_tables (void);

/* Error reporting.  */

char *program_name;

void
bfd_nonfatal (const char *string)
{
  const char *errmsg = bfd_errmsg (bfd_get_error ());

  if (string)
    fprintf (stderr, "%s: %s: %s\n", program_name, string, errmsg);
  else
    fprintf (stderr, "%s: %s\n", program_name, errmsg);
}

void
bfd_fatal (const char *string)
{
  bfd_nonfatal (string);
  xexit (1);
}

void
report (const char * format, va_list args)
{
  fprintf (stderr, "%s: ", program_name);
  vfprintf (stderr, format, args);
  putc ('\n', stderr);
}

void
fatal VPARAMS ((const char *format, ...))
{
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);

  report (format, args);
  VA_CLOSE (args);
  xexit (1);
}

void
non_fatal VPARAMS ((const char *format, ...))
{
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);

  report (format, args);
  VA_CLOSE (args);
}

/* Set the default BFD target based on the configured target.  Doing
   this permits the binutils to be configured for a particular target,
   and linked against a shared BFD library which was configured for a
   different target.  */

void
set_default_bfd_target (void)
{
  /* The macro TARGET is defined by Makefile.  */
  const char *target = TARGET;

  if (! bfd_set_default_target (target))
    fatal (_("can't set BFD default target to `%s': %s"),
	   target, bfd_errmsg (bfd_get_error ()));
}

/* After a FALSE return from bfd_check_format_matches with
   bfd_get_error () == bfd_error_file_ambiguously_recognized, print
   the possible matching targets.  */

void
list_matching_formats (char **p)
{
  fprintf (stderr, _("%s: Matching formats:"), program_name);
  while (*p)
    fprintf (stderr, " %s", *p++);
  fputc ('\n', stderr);
}

/* List the supported targets.  */

void
list_supported_targets (const char *name, FILE *f)
{
  int t;
  const char **targ_names = bfd_target_list ();

  if (name == NULL)
    fprintf (f, _("Supported targets:"));
  else
    fprintf (f, _("%s: supported targets:"), name);

  for (t = 0; targ_names[t] != NULL; t++)
    fprintf (f, " %s", targ_names[t]);
  fprintf (f, "\n");
  free (targ_names);
}

/* List the supported architectures.  */

void
list_supported_architectures (const char *name, FILE *f)
{
  const char **arch;

  if (name == NULL)
    fprintf (f, _("Supported architectures:"));
  else
    fprintf (f, _("%s: supported architectures:"), name);

  for (arch = bfd_arch_list (); *arch; arch++)
    fprintf (f, " %s", *arch);
  fprintf (f, "\n");
}

/* The length of the longest architecture name + 1.  */
#define LONGEST_ARCH sizeof ("powerpc:common")

static const char *
endian_string (enum bfd_endian endian)
{
  switch (endian)
    {
    case BFD_ENDIAN_BIG: return "big endian";
    case BFD_ENDIAN_LITTLE: return "little endian";
    default: return "endianness unknown";
    }
}

/* List the targets that BFD is configured to support, each followed
   by its endianness and the architectures it supports.  */

static int
display_target_list (void)
{
  char *dummy_name;
  int t;
  int ret = 1;

  dummy_name = make_temp_file (NULL);
  for (t = 0; bfd_target_vector[t]; t++)
    {
      const bfd_target *p = bfd_target_vector[t];
      bfd *abfd = bfd_openw (dummy_name, p->name);
      int a;

      printf ("%s\n (header %s, data %s)\n", p->name,
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));

      if (abfd == NULL)
	{
          bfd_nonfatal (dummy_name);
          ret = 0;
	  continue;
	}

      if (! bfd_set_format (abfd, bfd_object))
	{
	  if (bfd_get_error () != bfd_error_invalid_operation)
            {
	      bfd_nonfatal (p->name);
              ret = 0;
            }
	  bfd_close_all_done (abfd);
	  continue;
	}

      for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
	if (bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
	  printf ("  %s\n",
		  bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
      bfd_close_all_done (abfd);
    }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print a table showing which architectures are supported for entries
   FIRST through LAST-1 of bfd_target_vector (targets across,
   architectures down).  */

static int
display_info_table (int first, int last)
{
  int t;
  int a;
  int ret = 1;
  char *dummy_name;

  /* Print heading of target names.  */
  printf ("\n%*s", (int) LONGEST_ARCH, " ");
  for (t = first; t < last && bfd_target_vector[t]; t++)
    printf ("%s ", bfd_target_vector[t]->name);
  putchar ('\n');

  dummy_name = make_temp_file (NULL);
  for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
    if (strcmp (bfd_printable_arch_mach (a, 0), "UNKNOWN!") != 0)
      {
	printf ("%*s ", (int) LONGEST_ARCH - 1,
		bfd_printable_arch_mach (a, 0));
	for (t = first; t < last && bfd_target_vector[t]; t++)
	  {
	    const bfd_target *p = bfd_target_vector[t];
	    bfd_boolean ok = TRUE;
	    bfd *abfd = bfd_openw (dummy_name, p->name);

	    if (abfd == NULL)
	      {
		bfd_nonfatal (p->name);
                ret = 0;
		ok = FALSE;
	      }

	    if (ok)
	      {
		if (! bfd_set_format (abfd, bfd_object))
		  {
		    if (bfd_get_error () != bfd_error_invalid_operation)
                      {
		        bfd_nonfatal (p->name);
                        ret = 0;
                      }
		    ok = FALSE;
		  }
	      }

	    if (ok)
	      {
		if (! bfd_set_arch_mach (abfd, a, 0))
		  ok = FALSE;
	      }

	    if (ok)
	      printf ("%s ", p->name);
	    else
	      {
		int l = strlen (p->name);
		while (l--)
		  putchar ('-');
		putchar (' ');
	      }
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
	  }
	putchar ('\n');
      }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print tables of all the target-architecture combinations that
   BFD has been configured to support.  */

static int
display_target_tables (void)
{
  int t;
  int columns;
  int ret = 1;
  char *colum;

  columns = 0;
  colum = getenv ("COLUMNS");
  if (colum != NULL)
    columns = atoi (colum);
  if (columns == 0)
    columns = 80;

  t = 0;
  while (bfd_target_vector[t] != NULL)
    {
      int oldt = t, wid;

      wid = LONGEST_ARCH + strlen (bfd_target_vector[t]->name) + 1;
      ++t;
      while (wid < columns && bfd_target_vector[t] != NULL)
	{
	  int newwid;

	  newwid = wid + strlen (bfd_target_vector[t]->name) + 1;
	  if (newwid >= columns)
	    break;
	  wid = newwid;
	  ++t;
	}
      if (! display_info_table (oldt, t))
        ret = 0;
    }

  return ret;
}

int
display_info (void)
{
  printf (_("BFD header file version %s\n"), BFD_VERSION_STRING);
  if (! display_target_list () || ! display_target_tables ())
    return 1;
  else
    return 0;
}

/* Display the archive header for an element as if it were an ls -l listing:

   Mode       User\tGroup\tSize\tDate               Name */

void
print_arelt_descr (FILE *file, bfd *abfd, bfd_boolean verbose)
{
  struct stat buf;

  if (verbose)
    {
      if (bfd_stat_arch_elt (abfd, &buf) == 0)
	{
	  char modebuf[11];
	  char timebuf[40];
	  time_t when = buf.st_mtime;
	  const char *ctime_result = (const char *) ctime (&when);

	  /* POSIX format:  skip weekday and seconds from ctime output.  */
	  sprintf (timebuf, "%.12s %.4s", ctime_result + 4, ctime_result + 20);

	  mode_string (buf.st_mode, modebuf);
	  modebuf[10] = '\0';
	  /* POSIX 1003.2/D11 says to skip first character (entry type).  */
	  fprintf (file, "%s %ld/%ld %6ld %s ", modebuf + 1,
		   (long) buf.st_uid, (long) buf.st_gid,
		   (long) buf.st_size, timebuf);
	}
    }

  fprintf (file, "%s\n", bfd_get_filename (abfd));
}

/* Return the name of a temporary file in the same directory as FILENAME.  */

char *
make_tempname (char *filename, int isdir)
{
  static char template[] = "stXXXXXX";
  char *tmpname;
  char *slash = strrchr (filename, '/');
  char c;

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (filename, '\\');
    if (slash == NULL || (bslash != NULL && bslash > slash))
      slash = bslash;
    if (slash == NULL && filename[0] != '\0' && filename[1] == ':')
      slash = filename + 1;
  }
#endif

  if (slash != (char *) NULL)
    {
      c = *slash;
      *slash = 0;
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 2);
      strcpy (tmpname, filename);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* If tmpname is "X:", appending a slash will make it a root
	 directory on drive X, which is NOT the same as the current
	 directory on drive X.  */
      if (tmpname[1] == ':' && tmpname[2] == '\0')
	strcat (tmpname, ".");
#endif
      strcat (tmpname, "/");
      strcat (tmpname, template);
    }
  else
    {
      tmpname = xmalloc (sizeof (template));
      strcpy (tmpname, template);
    }

  if (isdir)
    {
      if (mkdtemp (tmpname) == (char *) NULL)
      tmpname = NULL;
    }
  else
    {
      int fd;

      fd = mkstemp (tmpname);
      if (fd == -1)
      tmpname = NULL;
      else
      close (fd);
    }
  if (slash != (char *) NULL)
    *slash = c;

  return tmpname;
}

/* Parse a string into a VMA, with a fatal error if it can't be
   parsed.  */

bfd_vma
parse_vma (const char *s, const char *arg)
{
  bfd_vma ret;
  const char *end;

  ret = bfd_scan_vma (s, &end, 0);

  if (*end != '\0')
    fatal (_("%s: bad number: %s"), arg, s);

  return ret;
}

/* Returns the size of the named file.  If the file does not
   exist, or if it is not a real file, then a suitable non-fatal
   error message is printed and zero is returned.  */

off_t
get_file_size (const char * file_name)
{
  struct stat statbuf;
  
  if (stat (file_name, &statbuf) < 0)
    {
      if (errno == ENOENT)
	non_fatal (_("'%s': No such file"), file_name);
      else
	non_fatal (_("Warning: could not locate '%s'.  reason: %s"),
		   file_name, strerror (errno));
    }  
  else if (! S_ISREG (statbuf.st_mode))
    non_fatal (_("Warning: '%s' is not an ordinary file"), file_name);
  else
    return statbuf.st_size;

  return 0;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d41 4
a44 4
static const char * endian_string PARAMS ((enum bfd_endian));
static int display_target_list PARAMS ((void));
static int display_info_table PARAMS ((int, int));
static int display_target_tables PARAMS ((void));
d51 1
a51 2
bfd_nonfatal (string)
     const char *string;
d62 1
a62 2
bfd_fatal (string)
     const char *string;
d69 1
a69 3
report (format, args)
     const char * format;
     va_list args;
d103 1
a103 1
set_default_bfd_target ()
d118 1
a118 2
list_matching_formats (p)
     char **p;
d129 1
a129 3
list_supported_targets (name, f)
     const char *name;
     FILE *f;
d148 1
a148 3
list_supported_architectures (name, f)
     const char *name;
     FILE *f;
d166 1
a166 2
endian_string (endian)
     enum bfd_endian endian;
d180 1
a180 1
display_target_list ()
d232 1
a232 3
display_info_table (first, last)
     int first;
     int last;
d307 1
a307 1
display_target_tables ()
d346 1
a346 1
display_info ()
d360 1
a360 4
print_arelt_descr (file, abfd, verbose)
     FILE *file;
     bfd *abfd;
     bfd_boolean verbose;
d391 1
a391 3
make_tempname (filename, isdir)
     char *filename;
     int isdir;
d456 1
a456 3
parse_vma (s, arg)
     const char *s;
     const char *arg;
d467 25
@


1.6
log
@inverted test. problem reported by avsm@@.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001
d26 1
d30 1
d40 5
d46 1
a46 1
/* Error reporting */
d52 1
a52 1
     CONST char *string;
d54 1
a54 1
  CONST char *errmsg = bfd_errmsg (bfd_get_error ());
d64 1
a64 1
     CONST char *string;
a79 1
#ifdef ANSI_PROTOTYPES
d81 1
a81 1
fatal (const char *format, ...)
d83 2
a84 1
  va_list args;
a85 1
  va_start (args, format);
d87 1
a87 1
  va_end (args);
d92 1
a92 1
non_fatal (const char *format, ...)
d94 2
a95 1
  va_list args;
a96 1
  va_start (args, format);
d98 1
a98 15
  va_end (args);
}
#else
void 
fatal (va_alist)
     va_dcl
{
  char *Format;
  va_list args;

  va_start (args);
  Format = va_arg (args, char *);
  report (Format, args);
  va_end (args);
  xexit (1);
a100 14
void 
non_fatal (va_alist)
     va_dcl
{
  char *Format;
  va_list args;

  va_start (args);
  Format = va_arg (args, char *);
  report (Format, args);
  va_end (args);
}
#endif

d117 1
a117 1
/* After a false return from bfd_check_format_matches with
a137 1
  extern const bfd_target *const *bfd_target_vector;
d139 1
d145 23
a167 2
  for (t = 0; bfd_target_vector[t] != NULL; t++)
    fprintf (f, " %s", bfd_target_vector[t]->name);
d171 196
d375 1
a375 1
     boolean verbose;
d386 1
a386 1
	  CONST char *ctime_result = (CONST char *) ctime (&when);
a418 1

a449 1
#ifdef HAVE_MKDTEMP
d451 1
a451 9
#else
      mktemp (tmpname);
#if defined (_WIN32) && !defined (__CYGWIN32__)
      if (mkdir (tmpname) != 0)
#else
      if (mkdir (tmpname, 0700) != 0)
#endif
#endif
	tmpname = NULL;
a456 1
#ifdef HAVE_MKSTEMP
d459 1
a459 1
	tmpname = NULL;
d461 1
a461 4
	close (fd);
#else
      mktemp (tmpname);
#endif
d481 1
a481 1
  
@


1.5
log
@resolve conflicts.
@
text
@d257 1
a257 1
      if (mkdtemp (tmpname) != (char *) NULL)
@


1.4
log
@Change make_tempname() interface to create file or directory when needed.
Use the new interface to call safe mkstemp or mkdtemp when available.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 97, 98, 2000
d160 1
a160 1
  extern bfd_target *bfd_target_vector[];
d225 1
a225 1
    if (bslash > slash)
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d211 1
a211 1
make_tempname (filename)
d213 1
d218 1
d224 1
a233 2
      char c;

a246 2
      mktemp (tmpname);
      *slash = c;
d252 27
d280 1
d282 3
@


1.2
log
@Kill remaining instances of mktemp, direct and indirect.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94 Free Software Foundation, Inc.
d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a37 8

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

char *target = NULL;		/* default as late as possible */
d63 10
a78 1
  fprintf (stderr, "%s: ", program_name);
d80 1
a80 1
  vfprintf (stderr, format, args);
a81 1
  putc ('\n', stderr);
d84 10
a101 1
  fprintf (stderr, "%s: ", program_name);
d104 1
a104 1
  vfprintf (stderr, Format, args);
a105 1
  putc ('\n', stderr);
d108 13
d123 16
d140 2
a141 2
   bfd_get_error () == bfd_error_file_ambiguously_recognized, print the possible
   matching targets.  */
d147 1
a147 1
  fprintf(stderr, "%s: Matching formats:", program_name);
d149 2
a150 2
    fprintf(stderr, " %s", *p++);
  fprintf(stderr, "\n");
d164 1
a164 1
    fprintf (f, "Supported targets:");
d166 1
a166 1
    fprintf (f, "%s: supported targets:", name);
d208 1
a208 2
/* Return the name of a created temporary file in the same directory as 
 FILENAME.  */
d214 1
a214 2
  static char template[] = "stXXXXXXXXXX";
  int fd;
d218 11
d231 1
a231 23
      *slash = 0;
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 1);
      strcpy (tmpname, filename);
      strcat (tmpname, "/");
      strcat (tmpname, template);
      fd = mkstemp (tmpname);
      *slash = '/';
    }
  else
    {
      tmpname = xmalloc (sizeof (template));
      strcpy (tmpname, template);
      fd = mkstemp (tmpname);
    }
  if (fd == -1) 
    return NULL;
  else
    close(fd);
  return tmpname;
}

/* Return the name of a created temporary dir in the same directory as 
 FILENAME.  */
d233 1
a233 10
char *
make_tempdir (filename)
     char *filename;
{
  static char template[] = "stXXXXXXXXXX";
  char *tmpname;
  char *slash = strrchr (filename, '/');

  if (slash != (char *) NULL)
    {
d235 1
a235 1
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 1);
d237 7
d246 2
a247 2
      mkdtemp (tmpname);
      *slash = '/';
d253 1
a253 1
      mkdtemp (tmpname);
d270 1
d272 2
a273 4
    {
      fprintf (stderr, "%s: %s: bad number: %s\n", program_name, arg, s);
      exit (1);
    }
@


1.1
log
@Initial revision
@
text
@d168 2
a169 1
/* Return the name of a temporary file in the same directory as FILENAME.  */
d175 2
a176 1
  static char template[] = "stXXXXXX";
d187 1
a187 1
      mktemp (tmpname);
d194 35
a228 1
      mktemp (tmpname);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a98 21
/* Set the default BFD target based on the configured target.  Doing
   this permits the binutils to be configured for a particular target,
   and linked against a shared BFD library which was configured for a
   different target.  */

void
set_default_bfd_target ()
{
  /* The macro TARGET is defined by Makefile.  */
  const char *target = TARGET;

  if (! bfd_set_default_target (target))
    {
      char *errmsg;

      errmsg = (char *) xmalloc (100 + strlen (target));
      sprintf (errmsg, "can't set BFD default target to `%s'", target);
      bfd_fatal (errmsg);
    }
}

d100 2
a101 2
   bfd_get_error () == bfd_error_file_ambiguously_recognized, print
   the possible matching targets.  */
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 97, 98, 2000
   Free Software Foundation, Inc.
a26 1
#include "filenames.h"
d36 8
a68 10
void
report (format, args)
     const char * format;
     va_list args;
{
  fprintf (stderr, "%s: ", program_name);
  vfprintf (stderr, format, args);
  putc ('\n', stderr);
}

d75 1
d77 1
a77 1
  report (format, args);
d79 1
a81 10

void
non_fatal (const char *format, ...)
{
  va_list args;

  va_start (args, format);
  report (format, args);
  va_end (args);
}
d90 1
d93 1
a93 1
  report (Format, args);
d95 1
a97 13

void 
non_fatal (va_alist)
     va_dcl
{
  char *Format;
  va_list args;

  va_start (args);
  Format = va_arg (args, char *);
  report (Format, args);
  va_end (args);
}
d112 7
a118 2
    fatal (_("can't set BFD default target to `%s': %s"),
	   target, bfd_errmsg (bfd_get_error ()));
d129 1
a129 1
  fprintf (stderr, _("%s: Matching formats:"), program_name);
d131 2
a132 2
    fprintf (stderr, " %s", *p++);
  fputc ('\n', stderr);
d146 1
a146 1
    fprintf (f, _("Supported targets:"));
d148 1
a148 1
    fprintf (f, _("%s: supported targets:"), name);
a199 11
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (filename, '\\');
    if (bslash > slash)
      slash = bslash;
    if (slash == NULL && filename[0] != '\0' && filename[1] == ':')
      slash = filename + 1;
  }
#endif

a201 3
      char c;

      c = *slash;
d203 1
a203 1
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 2);
a204 7
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* If tmpname is "X:", appending a slash will make it a root
	 directory on drive X, which is NOT the same as the current
	 directory on drive X.  */
      if (tmpname[1] == ':' && tmpname[2] == '\0')
	strcat (tmpname, ".");
#endif
d208 1
a208 1
      *slash = c;
a230 1
  
d232 4
a235 2
    fatal (_("%s: bad number: %s"), arg, s);

@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001
d160 1
a160 1
  extern const bfd_target *const *bfd_target_vector;
d222 1
a222 1
    if (slash == NULL || (bslash != NULL && bslash > slash))
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
a25 1
#include "bfdver.h"
a28 1
#include "libbfd.h"
a37 5

static const char * endian_string PARAMS ((enum bfd_endian));
static int display_target_list PARAMS ((void));
static int display_info_table PARAMS ((int, int));
static int display_target_tables PARAMS ((void));
d39 1
a39 1
/* Error reporting.  */
d45 1
a45 1
     const char *string;
d47 1
a47 1
  const char *errmsg = bfd_errmsg (bfd_get_error ());
d57 1
a57 1
     const char *string;
d73 1
d75 1
a75 1
fatal VPARAMS ((const char *format, ...))
d77 1
a77 2
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);
d79 1
d81 1
a81 1
  VA_CLOSE (args);
d86 1
a86 1
non_fatal VPARAMS ((const char *format, ...))
d88 1
a88 2
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);
d90 1
d92 15
a106 1
  VA_CLOSE (args);
d109 14
d139 1
a139 1
/* After a FALSE return from bfd_check_format_matches with
d160 1
a161 1
  const char **targ_names = bfd_target_list ();
d167 2
a168 23

  for (t = 0; targ_names[t] != NULL; t++)
    fprintf (f, " %s", targ_names[t]);
  fprintf (f, "\n");
  free (targ_names);
}

/* List the supported architectures.  */

void
list_supported_architectures (name, f)
     const char *name;
     FILE *f;
{
  const char **arch;

  if (name == NULL)
    fprintf (f, _("Supported architectures:"));
  else
    fprintf (f, _("%s: supported architectures:"), name);

  for (arch = bfd_arch_list (); *arch; arch++)
    fprintf (f, " %s", *arch);
a171 196
/* The length of the longest architecture name + 1.  */
#define LONGEST_ARCH sizeof ("powerpc:common")

static const char *
endian_string (endian)
     enum bfd_endian endian;
{
  switch (endian)
    {
    case BFD_ENDIAN_BIG: return "big endian";
    case BFD_ENDIAN_LITTLE: return "little endian";
    default: return "endianness unknown";
    }
}

/* List the targets that BFD is configured to support, each followed
   by its endianness and the architectures it supports.  */

static int
display_target_list ()
{
  char *dummy_name;
  int t;
  int ret = 1;

  dummy_name = make_temp_file (NULL);
  for (t = 0; bfd_target_vector[t]; t++)
    {
      const bfd_target *p = bfd_target_vector[t];
      bfd *abfd = bfd_openw (dummy_name, p->name);
      int a;

      printf ("%s\n (header %s, data %s)\n", p->name,
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));

      if (abfd == NULL)
	{
          bfd_nonfatal (dummy_name);
          ret = 0;
	  continue;
	}

      if (! bfd_set_format (abfd, bfd_object))
	{
	  if (bfd_get_error () != bfd_error_invalid_operation)
            {
	      bfd_nonfatal (p->name);
              ret = 0;
            }
	  bfd_close_all_done (abfd);
	  continue;
	}

      for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
	if (bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
	  printf ("  %s\n",
		  bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
      bfd_close_all_done (abfd);
    }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print a table showing which architectures are supported for entries
   FIRST through LAST-1 of bfd_target_vector (targets across,
   architectures down).  */

static int
display_info_table (first, last)
     int first;
     int last;
{
  int t;
  int a;
  int ret = 1;
  char *dummy_name;

  /* Print heading of target names.  */
  printf ("\n%*s", (int) LONGEST_ARCH, " ");
  for (t = first; t < last && bfd_target_vector[t]; t++)
    printf ("%s ", bfd_target_vector[t]->name);
  putchar ('\n');

  dummy_name = make_temp_file (NULL);
  for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
    if (strcmp (bfd_printable_arch_mach (a, 0), "UNKNOWN!") != 0)
      {
	printf ("%*s ", (int) LONGEST_ARCH - 1,
		bfd_printable_arch_mach (a, 0));
	for (t = first; t < last && bfd_target_vector[t]; t++)
	  {
	    const bfd_target *p = bfd_target_vector[t];
	    bfd_boolean ok = TRUE;
	    bfd *abfd = bfd_openw (dummy_name, p->name);

	    if (abfd == NULL)
	      {
		bfd_nonfatal (p->name);
                ret = 0;
		ok = FALSE;
	      }

	    if (ok)
	      {
		if (! bfd_set_format (abfd, bfd_object))
		  {
		    if (bfd_get_error () != bfd_error_invalid_operation)
                      {
		        bfd_nonfatal (p->name);
                        ret = 0;
                      }
		    ok = FALSE;
		  }
	      }

	    if (ok)
	      {
		if (! bfd_set_arch_mach (abfd, a, 0))
		  ok = FALSE;
	      }

	    if (ok)
	      printf ("%s ", p->name);
	    else
	      {
		int l = strlen (p->name);
		while (l--)
		  putchar ('-');
		putchar (' ');
	      }
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
	  }
	putchar ('\n');
      }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print tables of all the target-architecture combinations that
   BFD has been configured to support.  */

static int
display_target_tables ()
{
  int t;
  int columns;
  int ret = 1;
  char *colum;

  columns = 0;
  colum = getenv ("COLUMNS");
  if (colum != NULL)
    columns = atoi (colum);
  if (columns == 0)
    columns = 80;

  t = 0;
  while (bfd_target_vector[t] != NULL)
    {
      int oldt = t, wid;

      wid = LONGEST_ARCH + strlen (bfd_target_vector[t]->name) + 1;
      ++t;
      while (wid < columns && bfd_target_vector[t] != NULL)
	{
	  int newwid;

	  newwid = wid + strlen (bfd_target_vector[t]->name) + 1;
	  if (newwid >= columns)
	    break;
	  wid = newwid;
	  ++t;
	}
      if (! display_info_table (oldt, t))
        ret = 0;
    }

  return ret;
}

int
display_info ()
{
  printf (_("BFD header file version %s\n"), BFD_VERSION_STRING);
  if (! display_target_list () || ! display_target_tables ())
    return 1;
  else
    return 0;
}

d180 1
a180 1
     bfd_boolean verbose;
d191 1
a191 1
	  const char *ctime_result = (const char *) ctime (&when);
d270 1
a270 1

@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d41 4
a44 4
static const char * endian_string (enum bfd_endian);
static int display_target_list (void);
static int display_info_table (int, int);
static int display_target_tables (void);
d51 2
a52 1
bfd_nonfatal (const char *string)
d63 2
a64 1
bfd_fatal (const char *string)
d71 3
a73 1
report (const char * format, va_list args)
d107 1
a107 1
set_default_bfd_target (void)
d122 2
a123 1
list_matching_formats (char **p)
d134 3
a136 1
list_supported_targets (const char *name, FILE *f)
d155 3
a157 1
list_supported_architectures (const char *name, FILE *f)
d175 2
a176 1
endian_string (enum bfd_endian endian)
d190 1
a190 1
display_target_list (void)
d242 3
a244 1
display_info_table (int first, int last)
d319 1
a319 1
display_target_tables (void)
d358 1
a358 1
display_info (void)
d372 4
a375 1
print_arelt_descr (FILE *file, bfd *abfd, bfd_boolean verbose)
d406 2
a407 1
make_tempname (char *filename)
d457 3
a459 1
parse_vma (const char *s, const char *arg)
a469 25
}

/* Returns the size of the named file.  If the file does not
   exist, or if it is not a real file, then a suitable non-fatal
   error message is printed and zero is returned.  */

off_t
get_file_size (const char * file_name)
{
  struct stat statbuf;
  
  if (stat (file_name, &statbuf) < 0)
    {
      if (errno == ENOENT)
	non_fatal (_("'%s': No such file"), file_name);
      else
	non_fatal (_("Warning: could not locate '%s'.  reason: %s"),
		   file_name, strerror (errno));
    }  
  else if (! S_ISREG (statbuf.st_mode))
    non_fatal (_("Warning: '%s' is not an ordinary file"), file_name);
  else
    return statbuf.st_size;

  return 0;
@


