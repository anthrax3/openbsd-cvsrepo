head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	FSF:1.1.1
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.20;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.22.24.42;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.33;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.03.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.03.59;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.03.59;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.50.06;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.16.34;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.11;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.17.18;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.05;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.06;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* wrstabs.c -- Output stabs debugging information
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This file contains code which writes out stabs debugging
   information.  */

#include <stdio.h>
#include <assert.h>

#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "debug.h"
#include "budbg.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"

/* The size of a stabs symbol.  This presumes 32 bit values.  */

#define STAB_SYMBOL_SIZE (12)

/* An entry in a string hash table.  */

struct string_hash_entry
{
  struct bfd_hash_entry root;
  /* Next string in this table.  */
  struct string_hash_entry *next;
  /* Index in string table.  */
  long index;
  /* Size of type if this is a typedef.  */
  unsigned int size;
};

/* A string hash table.  */

struct string_hash_table
{
  struct bfd_hash_table table;
};

/* The type stack.  Each element on the stack is a string.  */

struct stab_type_stack
{
  /* The next element on the stack.  */
  struct stab_type_stack *next;
  /* This element as a string.  */
  char *string;
  /* The type index of this element.  */
  long index;
  /* The size of the type.  */
  unsigned int size;
  /* Whether type string defines a new type.  */
  bfd_boolean definition;
  /* String defining struct fields.  */
  char *fields;
  /* NULL terminated array of strings defining base classes for a
     class.  */
  char **baseclasses;
  /* String defining class methods.  */
  char *methods;
  /* String defining vtable pointer for a class.  */
  char *vtable;
};

/* This structure is used to keep track of type indices for tagged
   types.  */

struct stab_tag
{
  /* The type index.  */
  long index;
  /* The tag name.  */
  const char *tag;
  /* The kind of type.  This is set to DEBUG_KIND_ILLEGAL when the
     type is defined.  */
  enum debug_type_kind kind;
  /* The size of the struct.  */
  unsigned int size;
};

/* We remember various sorts of type indices.  They are not related,
   but, for convenience, we keep all the information in this
   structure.  */

struct stab_type_cache
{
  /* The void type index.  */
  long void_type;
  /* Signed integer type indices, indexed by size - 1.  */
  long signed_integer_types[8];
  /* Unsigned integer type indices, indexed by size - 1.  */
  long unsigned_integer_types[8];
  /* Floating point types, indexed by size - 1.  */
  long float_types[16];
  /* Pointers to types, indexed by the type index.  */
  long *pointer_types;
  size_t pointer_types_alloc;
  /* Functions returning types, indexed by the type index.  */
  long *function_types;
  size_t function_types_alloc;
  /* References to types, indexed by the type index.  */
  long *reference_types;
  size_t reference_types_alloc;
  /* Struct/union/class type indices, indexed by the struct id.  */
  struct stab_tag *struct_types;
  size_t struct_types_alloc;
};

/* This is the handle passed through debug_write.  */

struct stab_write_handle
{
  /* The BFD.  */
  bfd *abfd;
  /* This buffer holds the symbols.  */
  bfd_byte *symbols;
  size_t symbols_size;
  size_t symbols_alloc;
  /* This is a list of hash table entries for the strings.  */
  struct string_hash_entry *strings;
  /* The last string hash table entry.  */
  struct string_hash_entry *last_string;
  /* The size of the strings.  */
  size_t strings_size;
  /* This hash table eliminates duplicate strings.  */
  struct string_hash_table strhash;
  /* The type stack.  */
  struct stab_type_stack *type_stack;
  /* The next type index.  */
  long type_index;
  /* The type cache.  */
  struct stab_type_cache type_cache;
  /* A mapping from typedef names to type indices.  */
  struct string_hash_table typedef_hash;
  /* If this is not -1, it is the offset to the most recent N_SO
     symbol, and the value of that symbol needs to be set.  */
  long so_offset;
  /* If this is not -1, it is the offset to the most recent N_FUN
     symbol, and the value of that symbol needs to be set.  */
  long fun_offset;
  /* The last text section address seen.  */
  bfd_vma last_text_address;
  /* The block nesting depth.  */
  unsigned int nesting;
  /* The function address.  */
  bfd_vma fnaddr;
  /* A pending LBRAC symbol.  */
  bfd_vma pending_lbrac;
  /* The current line number file name.  */
  const char *lineno_filename;
};

static struct bfd_hash_entry *string_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static bfd_boolean stab_write_symbol
  (struct stab_write_handle *, int, int, bfd_vma, const char *);
static bfd_boolean stab_push_string
  (struct stab_write_handle *, const char *, long, bfd_boolean, unsigned int);
static bfd_boolean stab_push_defined_type
  (struct stab_write_handle *, long, unsigned int);
static char *stab_pop_type (struct stab_write_handle *);
static bfd_boolean stab_modify_type
  (struct stab_write_handle *, int, unsigned int, long **, size_t *);
static long stab_get_struct_index
  (struct stab_write_handle *, const char *, unsigned int,
   enum debug_type_kind, unsigned int *);
static bfd_boolean stab_class_method_var
  (struct stab_write_handle *, const char *, enum debug_visibility,
   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean stab_start_compilation_unit (void *, const char *);
static bfd_boolean stab_start_source (void *, const char *);
static bfd_boolean stab_empty_type (void *);
static bfd_boolean stab_void_type (void *);
static bfd_boolean stab_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean stab_float_type (void *, unsigned int);
static bfd_boolean stab_complex_type (void *, unsigned int);
static bfd_boolean stab_bool_type (void *, unsigned int);
static bfd_boolean stab_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean stab_pointer_type (void *);
static bfd_boolean stab_function_type (void *, int, bfd_boolean);
static bfd_boolean stab_reference_type (void *);
static bfd_boolean stab_range_type (void *, bfd_signed_vma, bfd_signed_vma);
static bfd_boolean stab_array_type
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean stab_set_type (void *, bfd_boolean);
static bfd_boolean stab_offset_type (void *);
static bfd_boolean stab_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean stab_const_type (void *);
static bfd_boolean stab_volatile_type (void *);
static bfd_boolean stab_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean stab_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean stab_end_struct_type (void *);
static bfd_boolean stab_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
static bfd_boolean stab_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean stab_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean stab_class_start_method (void *, const char *);
static bfd_boolean stab_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
static bfd_boolean stab_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean stab_class_end_method (void *);
static bfd_boolean stab_end_class_type (void *);
static bfd_boolean stab_typedef_type (void *, const char *);
static bfd_boolean stab_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean stab_typdef (void *, const char *);
static bfd_boolean stab_tag (void *, const char *);
static bfd_boolean stab_int_constant (void *, const char *, bfd_vma);
static bfd_boolean stab_float_constant (void *, const char *, double);
static bfd_boolean stab_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean stab_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean stab_start_function (void *, const char *, bfd_boolean);
static bfd_boolean stab_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean stab_start_block (void *, bfd_vma);
static bfd_boolean stab_end_block (void *, bfd_vma);
static bfd_boolean stab_end_function (void *);
static bfd_boolean stab_lineno (void *, const char *, unsigned long, bfd_vma);

static const struct debug_write_fns stab_fns =
{
  stab_start_compilation_unit,
  stab_start_source,
  stab_empty_type,
  stab_void_type,
  stab_int_type,
  stab_float_type,
  stab_complex_type,
  stab_bool_type,
  stab_enum_type,
  stab_pointer_type,
  stab_function_type,
  stab_reference_type,
  stab_range_type,
  stab_array_type,
  stab_set_type,
  stab_offset_type,
  stab_method_type,
  stab_const_type,
  stab_volatile_type,
  stab_start_struct_type,
  stab_struct_field,
  stab_end_struct_type,
  stab_start_class_type,
  stab_class_static_member,
  stab_class_baseclass,
  stab_class_start_method,
  stab_class_method_variant,
  stab_class_static_method_variant,
  stab_class_end_method,
  stab_end_class_type,
  stab_typedef_type,
  stab_tag_type,
  stab_typdef,
  stab_tag,
  stab_int_constant,
  stab_float_constant,
  stab_typed_constant,
  stab_variable,
  stab_start_function,
  stab_function_parameter,
  stab_start_block,
  stab_end_block,
  stab_end_function,
  stab_lineno
};

/* Routine to create an entry in a string hash table.  */

static struct bfd_hash_entry *
string_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table, const char *string)
{
  struct string_hash_entry *ret = (struct string_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct string_hash_entry *) NULL)
    ret = ((struct string_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct string_hash_entry)));
  if (ret == (struct string_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct string_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->next = NULL;
      ret->index = -1;
      ret->size = 0;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Look up an entry in a string hash table.  */

#define string_hash_lookup(t, string, create, copy) \
  ((struct string_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))

/* Add a symbol to the stabs debugging information we are building.  */

static bfd_boolean
stab_write_symbol (struct stab_write_handle *info, int type, int desc,
		   bfd_vma value, const char *string)
{
  bfd_size_type strx;
  bfd_byte sym[STAB_SYMBOL_SIZE];

  if (string == NULL)
    strx = 0;
  else
    {
      struct string_hash_entry *h;

      h = string_hash_lookup (&info->strhash, string, TRUE, TRUE);
      if (h == NULL)
	{
	  non_fatal (_("string_hash_lookup failed: %s"),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}
      if (h->index != -1)
	strx = h->index;
      else
	{
	  strx = info->strings_size;
	  h->index = strx;
	  if (info->last_string == NULL)
	    info->strings = h;
	  else
	    info->last_string->next = h;
	  info->last_string = h;
	  info->strings_size += strlen (string) + 1;
	}
    }

  /* This presumes 32 bit values.  */
  bfd_put_32 (info->abfd, strx, sym);
  bfd_put_8 (info->abfd, type, sym + 4);
  bfd_put_8 (info->abfd, 0, sym + 5);
  bfd_put_16 (info->abfd, desc, sym + 6);
  bfd_put_32 (info->abfd, value, sym + 8);

  if (info->symbols_size + STAB_SYMBOL_SIZE > info->symbols_alloc)
    {
      info->symbols_alloc *= 2;
      info->symbols = (bfd_byte *) xrealloc (info->symbols,
					     info->symbols_alloc);
    }

  memcpy (info->symbols + info->symbols_size, sym, STAB_SYMBOL_SIZE);

  info->symbols_size += STAB_SYMBOL_SIZE;

  return TRUE;
}

/* Push a string on to the type stack.  */

static bfd_boolean
stab_push_string (struct stab_write_handle *info, const char *string,
		  long index, bfd_boolean definition, unsigned int size)
{
  struct stab_type_stack *s;

  s = (struct stab_type_stack *) xmalloc (sizeof *s);
  s->string = xstrdup (string);
  s->index = index;
  s->definition = definition;
  s->size = size;

  s->fields = NULL;
  s->baseclasses = NULL;
  s->methods = NULL;
  s->vtable = NULL;

  s->next = info->type_stack;
  info->type_stack = s;

  return TRUE;
}

/* Push a type index which has already been defined.  */

static bfd_boolean
stab_push_defined_type (struct stab_write_handle *info, long index,
			unsigned int size)
{
  char buf[20];

  sprintf (buf, "%ld", index);
  return stab_push_string (info, buf, index, FALSE, size);
}

/* Pop a type off the type stack.  The caller is responsible for
   freeing the string.  */

static char *
stab_pop_type (struct stab_write_handle *info)
{
  struct stab_type_stack *s;
  char *ret;

  s = info->type_stack;
  assert (s != NULL);

  info->type_stack = s->next;

  ret = s->string;

  free (s);

  return ret;
}

/* The general routine to write out stabs in sections debugging
   information.  This accumulates the stabs symbols and the strings in
   two obstacks.  We can't easily write out the information as we go
   along, because we need to know the section sizes before we can
   write out the section contents.  ABFD is the BFD and DHANDLE is the
   handle for the debugging information.  This sets *PSYMS to point to
   the symbols, *PSYMSIZE the size of the symbols, *PSTRINGS to the
   strings, and *PSTRINGSIZE to the size of the strings.  */

bfd_boolean
write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,
					bfd_byte **psyms,
					bfd_size_type *psymsize,
					bfd_byte **pstrings,
					bfd_size_type *pstringsize)
{
  struct stab_write_handle info;
  struct string_hash_entry *h;
  bfd_byte *p;

  info.abfd = abfd;

  info.symbols_size = 0;
  info.symbols_alloc = 500;
  info.symbols = (bfd_byte *) xmalloc (info.symbols_alloc);

  info.strings = NULL;
  info.last_string = NULL;
  /* Reserve 1 byte for a null byte.  */
  info.strings_size = 1;

  if (! bfd_hash_table_init (&info.strhash.table, string_hash_newfunc)
      || ! bfd_hash_table_init (&info.typedef_hash.table, string_hash_newfunc))
    {
      non_fatal ("bfd_hash_table_init_failed: %s",
		 bfd_errmsg (bfd_get_error ()));
      return FALSE;
    }

  info.type_stack = NULL;
  info.type_index = 1;
  memset (&info.type_cache, 0, sizeof info.type_cache);
  info.so_offset = -1;
  info.fun_offset = -1;
  info.last_text_address = 0;
  info.nesting = 0;
  info.fnaddr = 0;
  info.pending_lbrac = (bfd_vma) -1;

  /* The initial symbol holds the string size.  */
  if (! stab_write_symbol (&info, 0, 0, 0, (const char *) NULL))
    return FALSE;

  /* Output an initial N_SO symbol.  */
  info.so_offset = info.symbols_size;
  if (! stab_write_symbol (&info, N_SO, 0, 0, bfd_get_filename (abfd)))
    return FALSE;

  if (! debug_write (dhandle, &stab_fns, (void *) &info))
    return FALSE;

  assert (info.pending_lbrac == (bfd_vma) -1);

  /* Output a trailing N_SO.  */
  if (! stab_write_symbol (&info, N_SO, 0, info.last_text_address,
			   (const char *) NULL))
    return FALSE;

  /* Put the string size in the initial symbol.  */
  bfd_put_32 (abfd, info.strings_size, info.symbols + 8);

  *psyms = info.symbols;
  *psymsize = info.symbols_size;

  *pstringsize = info.strings_size;
  *pstrings = (bfd_byte *) xmalloc (info.strings_size);

  p = *pstrings;
  *p++ = '\0';
  for (h = info.strings; h != NULL; h = h->next)
    {
      strcpy ((char *) p, h->root.string);
      p += strlen ((char *) p) + 1;
    }

  return TRUE;
}

/* Start writing out information for a compilation unit.  */

static bfd_boolean
stab_start_compilation_unit (void *p, const char *filename)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* We would normally output an N_SO symbol here.  However, that
     would force us to reset all of our type information.  I think we
     will be better off just outputting an N_SOL symbol, and not
     worrying about splitting information between files.  */

  info->lineno_filename = filename;

  return stab_write_symbol (info, N_SOL, 0, 0, filename);
}

/* Start writing out information for a particular source file.  */

static bfd_boolean
stab_start_source (void *p, const char *filename)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The symbol's value is supposed to be the text section
     address.  However, we would have to fill it in later, and gdb
     doesn't care, so we don't bother with it.  */

  info->lineno_filename = filename;

  return stab_write_symbol (info, N_SOL, 0, 0, filename);
}

/* Push an empty type.  This shouldn't normally happen.  We just use a
   void type.  */

static bfd_boolean
stab_empty_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* We don't call stab_void_type if the type is not yet defined,
     because that might screw up the typedef.  */

  if (info->type_cache.void_type != 0)
    return stab_push_defined_type (info, info->type_cache.void_type, 0);
  else
    {
      long index;
      char buf[40];

      index = info->type_index;
      ++info->type_index;

      sprintf (buf, "%ld=%ld", index, index);

      return stab_push_string (info, buf, index, FALSE, 0);
    }
}

/* Push a void type.  */

static bfd_boolean
stab_void_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (info->type_cache.void_type != 0)
    return stab_push_defined_type (info, info->type_cache.void_type, 0);
  else
    {
      long index;
      char buf[40];

      index = info->type_index;
      ++info->type_index;

      info->type_cache.void_type = index;

      sprintf (buf, "%ld=%ld", index, index);

      return stab_push_string (info, buf, index, TRUE, 0);
    }
}

/* Push an integer type.  */

static bfd_boolean
stab_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long *cache;

  if (size <= 0 || (size > sizeof (long) && size != 8))
    {
      non_fatal (_("stab_int_type: bad size %u"), size);
      return FALSE;
    }

  if (unsignedp)
    cache = info->type_cache.signed_integer_types;
  else
    cache = info->type_cache.unsigned_integer_types;

  if (cache[size - 1] != 0)
    return stab_push_defined_type (info, cache[size - 1], size);
  else
    {
      long index;
      char buf[100];

      index = info->type_index;
      ++info->type_index;

      cache[size - 1] = index;

      sprintf (buf, "%ld=r%ld;", index, index);
      if (unsignedp)
	{
	  strcat (buf, "0;");
	  if (size < sizeof (long))
	    sprintf (buf + strlen (buf), "%ld;", ((long) 1 << (size * 8)) - 1);
	  else if (size == sizeof (long))
	    strcat (buf, "-1;");
	  else if (size == 8)
	    strcat (buf, "01777777777777777777777;");
	  else
	    abort ();
	}
      else
	{
	  if (size <= sizeof (long))
	    sprintf (buf + strlen (buf), "%ld;%ld;",
		     (long) - ((unsigned long) 1 << (size * 8 - 1)),
		     (long) (((unsigned long) 1 << (size * 8 - 1)) - 1));
	  else if (size == 8)
	    strcat (buf, "01000000000000000000000;0777777777777777777777;");
	  else
	    abort ();
	}

      return stab_push_string (info, buf, index, TRUE, size);
    }
}

/* Push a floating point type.  */

static bfd_boolean
stab_float_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (size > 0
      && size - 1 < (sizeof info->type_cache.float_types
		     / sizeof info->type_cache.float_types[0])
      && info->type_cache.float_types[size - 1] != 0)
    return stab_push_defined_type (info,
				   info->type_cache.float_types[size - 1],
				   size);
  else
    {
      long index;
      char *int_type;
      char buf[50];

      /* Floats are defined as a subrange of int.  */
      if (! stab_int_type (info, 4, FALSE))
	return FALSE;
      int_type = stab_pop_type (info);

      index = info->type_index;
      ++info->type_index;

      if (size > 0
	  && size - 1 < (sizeof info->type_cache.float_types
			 / sizeof info->type_cache.float_types[0]))
	info->type_cache.float_types[size - 1] = index;

      sprintf (buf, "%ld=r%s;%u;0;", index, int_type, size);

      free (int_type);

      return stab_push_string (info, buf, index, TRUE, size);
    }
}

/* Push a complex type.  */

static bfd_boolean
stab_complex_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char buf[50];
  long index;

  index = info->type_index;
  ++info->type_index;

  sprintf (buf, "%ld=r%ld;%u;0;", index, index, size);

  return stab_push_string (info, buf, index, TRUE, size * 2);
}

/* Push a bfd_boolean type.  We use an XCOFF predefined type, since gdb
   always recognizes them.  */

static bfd_boolean
stab_bool_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long index;

  switch (size)
    {
    case 1:
      index = -21;
      break;

    case 2:
      index = -22;
      break;

    default:
    case 4:
      index = -16;
      break;

    case 8:
      index = -33;
      break;
    }

  return stab_push_defined_type (info, index, size);
}

/* Push an enum type.  */

static bfd_boolean
stab_enum_type (void *p, const char *tag, const char **names,
		bfd_signed_vma *vals)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  size_t len;
  const char **pn;
  char *buf;
  long index = 0;
  bfd_signed_vma *pv;

  if (names == NULL)
    {
      assert (tag != NULL);

      buf = (char *) xmalloc (10 + strlen (tag));
      sprintf (buf, "xe%s:", tag);
      /* FIXME: The size is just a guess.  */
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
      free (buf);
      return TRUE;
    }

  len = 10;
  if (tag != NULL)
    len += strlen (tag);
  for (pn = names; *pn != NULL; pn++)
    len += strlen (*pn) + 20;

  buf = (char *) xmalloc (len);

  if (tag == NULL)
    strcpy (buf, "e");
  else
    {
      index = info->type_index;
      ++info->type_index;
      sprintf (buf, "%s:T%ld=e", tag, index);
    }

  for (pn = names, pv = vals; *pn != NULL; pn++, pv++)
    sprintf (buf + strlen (buf), "%s:%ld,", *pn, (long) *pv);
  strcat (buf, ";");

  if (tag == NULL)
    {
      /* FIXME: The size is just a guess.  */
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
    }
  else
    {
      /* FIXME: The size is just a guess.  */
      if (! stab_write_symbol (info, N_LSYM, 0, 0, buf)
	  || ! stab_push_defined_type (info, index, 4))
	return FALSE;
    }

  free (buf);

  return TRUE;
}

/* Push a modification of the top type on the stack.  Cache the
   results in CACHE and CACHE_ALLOC.  */

static bfd_boolean
stab_modify_type (struct stab_write_handle *info, int mod,
		  unsigned int size, long **cache, size_t *cache_alloc)
{
  long targindex;
  long index;
  char *s, *buf;

  assert (info->type_stack != NULL);
  targindex = info->type_stack->index;

  if (targindex <= 0
      || cache == NULL)
    {
      bfd_boolean definition;

      /* Either the target type has no index, or we aren't caching
         this modifier.  Either way we have no way of recording the
         new type, so we don't bother to define one.  */
      definition = info->type_stack->definition;
      s = stab_pop_type (info);
      buf = (char *) xmalloc (strlen (s) + 2);
      sprintf (buf, "%c%s", mod, s);
      free (s);
      if (! stab_push_string (info, buf, 0, definition, size))
	return FALSE;
      free (buf);
    }
  else
    {
      if ((size_t) targindex >= *cache_alloc)
	{
	  size_t alloc;

	  alloc = *cache_alloc;
	  if (alloc == 0)
	    alloc = 10;
	  while ((size_t) targindex >= alloc)
	    alloc *= 2;
	  *cache = (long *) xrealloc (*cache, alloc * sizeof (long));
	  memset (*cache + *cache_alloc, 0,
		  (alloc - *cache_alloc) * sizeof (long));
	  *cache_alloc = alloc;
	}

      index = (*cache)[targindex];
      if (index != 0 && ! info->type_stack->definition)
	{
	  /* We have already defined a modification of this type, and
             the entry on the type stack is not a definition, so we
             can safely discard it (we may have a definition on the
             stack, even if we already defined a modification, if it
             is a struct which we did not define at the time it was
             referenced).  */
	  free (stab_pop_type (info));
	  if (! stab_push_defined_type (info, index, size))
	    return FALSE;
	}
      else
	{
	  index = info->type_index;
	  ++info->type_index;

	  s = stab_pop_type (info);
	  buf = (char *) xmalloc (strlen (s) + 20);
	  sprintf (buf, "%ld=%c%s", index, mod, s);
	  free (s);

	  (*cache)[targindex] = index;

	  if (! stab_push_string (info, buf, index, TRUE, size))
	    return FALSE;

	  free (buf);
	}
    }

  return TRUE;
}

/* Push a pointer type.  */

static bfd_boolean
stab_pointer_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The size should depend upon the architecture.  */
  return stab_modify_type (info, '*', 4, &info->type_cache.pointer_types,
			   &info->type_cache.pointer_types_alloc);
}

/* Push a function type.  */

static bfd_boolean
stab_function_type (void *p, int argcount,
		    bfd_boolean varargs ATTRIBUTE_UNUSED)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  int i;

  /* We have no way to represent the argument types, so we just
     discard them.  However, if they define new types, we must output
     them.  We do this by producing empty typedefs.  */
  for (i = 0; i < argcount; i++)
    {
      if (! info->type_stack->definition)
	free (stab_pop_type (info));
      else
	{
	  char *s, *buf;

	  s = stab_pop_type (info);

	  buf = (char *) xmalloc (strlen (s) + 3);
	  sprintf (buf, ":t%s", s);
	  free (s);

	  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
	    return FALSE;

	  free (buf);
	}
    }

  return stab_modify_type (info, 'f', 0, &info->type_cache.function_types,
			   &info->type_cache.function_types_alloc);
}

/* Push a reference type.  */

static bfd_boolean
stab_reference_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The size should depend upon the architecture.  */
  return stab_modify_type (info, '&', 4, &info->type_cache.reference_types,
			   &info->type_cache.reference_types_alloc);
}

/* Push a range type.  */

static bfd_boolean
stab_range_type (void *p, bfd_signed_vma low, bfd_signed_vma high)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int size;
  char *s, *buf;

  definition = info->type_stack->definition;
  size = info->type_stack->size;

  s = stab_pop_type (info);
  buf = (char *) xmalloc (strlen (s) + 100);
  sprintf (buf, "r%s;%ld;%ld;", s, (long) low, (long) high);
  free (s);

  if (! stab_push_string (info, buf, 0, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push an array type.  */

static bfd_boolean
stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,
		 bfd_boolean stringp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int element_size;
  char *range, *element, *buf;
  long index;
  unsigned int size;

  definition = info->type_stack->definition;
  range = stab_pop_type (info);

  definition = definition || info->type_stack->definition;
  element_size = info->type_stack->size;
  element = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (range) + strlen (element) + 100);

  if (! stringp)
    {
      index = 0;
      *buf = '\0';
    }
  else
    {
      /* We need to define a type in order to include the string
         attribute.  */
      index = info->type_index;
      ++info->type_index;
      definition = TRUE;
      sprintf (buf, "%ld=@@S;", index);
    }

  sprintf (buf + strlen (buf), "ar%s;%ld;%ld;%s",
	   range, (long) low, (long) high, element);
  free (range);
  free (element);

  if (high < low)
    size = 0;
  else
    size = element_size * ((high - low) + 1);
  if (! stab_push_string (info, buf, index, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a set type.  */

static bfd_boolean
stab_set_type (void *p, bfd_boolean bitstringp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s, *buf;
  long index;

  definition = info->type_stack->definition;

  s = stab_pop_type (info);
  buf = (char *) xmalloc (strlen (s) + 30);

  if (! bitstringp)
    {
      *buf = '\0';
      index = 0;
    }
  else
    {
      /* We need to define a type in order to include the string
         attribute.  */
      index = info->type_index;
      ++info->type_index;
      definition = TRUE;
      sprintf (buf, "%ld=@@S;", index);
    }

  sprintf (buf + strlen (buf), "S%s", s);
  free (s);

  if (! stab_push_string (info, buf, index, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push an offset type.  */

static bfd_boolean
stab_offset_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *target, *base, *buf;

  definition = info->type_stack->definition;
  target = stab_pop_type (info);

  definition = definition || info->type_stack->definition;
  base = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (target) + strlen (base) + 3);
  sprintf (buf, "@@%s,%s", base, target);
  free (base);
  free (target);

  if (! stab_push_string (info, buf, 0, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a method type.  */

static bfd_boolean
stab_method_type (void *p, bfd_boolean domainp, int argcount,
		  bfd_boolean varargs)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *domain, *return_type, *buf;
  char **args;
  int i;
  size_t len;

  /* We don't bother with stub method types, because that would
     require a mangler for C++ argument types.  This will waste space
     in the debugging output.  */

  /* We need a domain.  I'm not sure DOMAINP can ever be false,
     anyhow.  */
  if (! domainp)
    {
      if (! stab_empty_type (p))
	return FALSE;
    }

  definition = info->type_stack->definition;
  domain = stab_pop_type (info);

  /* A non-varargs function is indicated by making the last parameter
     type be void.  */

  if (argcount < 0)
    {
      args = NULL;
      argcount = 0;
    }
  else if (argcount == 0)
    {
      if (varargs)
	args = NULL;
      else
	{
	  args = (char **) xmalloc (1 * sizeof (*args));
	  if (! stab_empty_type (p))
	    return FALSE;
	  definition = definition || info->type_stack->definition;
	  args[0] = stab_pop_type (info);
	  argcount = 1;
	}
    }
  else
    {
      args = (char **) xmalloc ((argcount + 1) * sizeof (*args));
      for (i = argcount - 1; i >= 0; i--)
	{
	  definition = definition || info->type_stack->definition;
	  args[i] = stab_pop_type (info);
	}
      if (! varargs)
	{
	  if (! stab_empty_type (p))
	    return FALSE;
	  definition = definition || info->type_stack->definition;
	  args[argcount] = stab_pop_type (info);
	  ++argcount;
	}
    }

  definition = definition || info->type_stack->definition;
  return_type = stab_pop_type (info);

  len = strlen (domain) + strlen (return_type) + 10;
  for (i = 0; i < argcount; i++)
    len += strlen (args[i]);

  buf = (char *) xmalloc (len);

  sprintf (buf, "#%s,%s", domain, return_type);
  free (domain);
  free (return_type);
  for (i = 0; i < argcount; i++)
    {
      strcat (buf, ",");
      strcat (buf, args[i]);
      free (args[i]);
    }
  strcat (buf, ";");

  if (args != NULL)
    free (args);

  if (! stab_push_string (info, buf, 0, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a const version of a type.  */

static bfd_boolean
stab_const_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_modify_type (info, 'k', info->type_stack->size,
			   (long **) NULL, (size_t *) NULL);
}

/* Push a volatile version of a type.  */

static bfd_boolean
stab_volatile_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_modify_type (info, 'B', info->type_stack->size,
			   (long **) NULL, (size_t *) NULL);
}

/* Get the type index to use for a struct/union/class ID.  This should
   return -1 if it fails.  */

static long
stab_get_struct_index (struct stab_write_handle *info, const char *tag,
		       unsigned int id, enum debug_type_kind kind,
		       unsigned int *psize)
{
  if (id >= info->type_cache.struct_types_alloc)
    {
      size_t alloc;

      alloc = info->type_cache.struct_types_alloc;
      if (alloc == 0)
	alloc = 10;
      while (id >= alloc)
	alloc *= 2;
      info->type_cache.struct_types =
	(struct stab_tag *) xrealloc (info->type_cache.struct_types,
				      alloc * sizeof (struct stab_tag));
      memset ((info->type_cache.struct_types
	       + info->type_cache.struct_types_alloc),
	      0,
	      ((alloc - info->type_cache.struct_types_alloc)
	       * sizeof (struct stab_tag)));
      info->type_cache.struct_types_alloc = alloc;
    }

  if (info->type_cache.struct_types[id].index == 0)
    {
      info->type_cache.struct_types[id].index = info->type_index;
      ++info->type_index;
      info->type_cache.struct_types[id].tag = tag;
      info->type_cache.struct_types[id].kind = kind;
    }

  if (kind == DEBUG_KIND_ILLEGAL)
    {
      /* This is a definition of the struct.  */
      info->type_cache.struct_types[id].kind = kind;
      info->type_cache.struct_types[id].size = *psize;
    }
  else
    *psize = info->type_cache.struct_types[id].size;

  return info->type_cache.struct_types[id].index;
}

/* Start outputting a struct.  We ignore the tag, and handle it in
   stab_tag.  */

static bfd_boolean
stab_start_struct_type (void *p, const char *tag, unsigned int id,
			bfd_boolean structp, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long index;
  bfd_boolean definition;
  char *buf;

  buf = (char *) xmalloc (40);

  if (id == 0)
    {
      index = 0;
      *buf = '\0';
      definition = FALSE;
    }
  else
    {
      index = stab_get_struct_index (info, tag, id, DEBUG_KIND_ILLEGAL,
				     &size);
      if (index < 0)
	return FALSE;
      sprintf (buf, "%ld=", index);
      definition = TRUE;
    }

  sprintf (buf + strlen (buf), "%c%u",
	   structp ? 's' : 'u',
	   size);

  if (! stab_push_string (info, buf, index, definition, size))
    return FALSE;

  info->type_stack->fields = (char *) xmalloc (1);
  info->type_stack->fields[0] = '\0';

  return TRUE;
}

/* Add a field to a struct.  */

static bfd_boolean
stab_struct_field (void *p, const char *name, bfd_vma bitpos,
		   bfd_vma bitsize, enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int size;
  char *s, *n;
  const char *vis;

  definition = info->type_stack->definition;
  size = info->type_stack->size;
  s = stab_pop_type (info);

  /* Add this field to the end of the current struct fields, which is
     currently on the top of the stack.  */

  assert (info->type_stack->fields != NULL);
  n = (char *) xmalloc (strlen (info->type_stack->fields)
			+ strlen (name)
			+ strlen (s)
			+ 50);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PUBLIC:
      vis = "";
      break;

    case DEBUG_VISIBILITY_PRIVATE:
      vis = "/0";
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      vis = "/1";
      break;
    }

  if (bitsize == 0)
    {
      bitsize = size * 8;
      if (bitsize == 0)
	non_fatal (_("%s: warning: unknown size for field `%s' in struct"),
		   bfd_get_filename (info->abfd), name);
    }

  sprintf (n, "%s%s:%s%s,%ld,%ld;", info->type_stack->fields, name, vis, s,
	   (long) bitpos, (long) bitsize);

  free (info->type_stack->fields);
  info->type_stack->fields = n;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Finish up a struct.  */

static bfd_boolean
stab_end_struct_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  long index;
  unsigned int size;
  char *fields, *first, *buf;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  definition = info->type_stack->definition;
  index = info->type_stack->index;
  size = info->type_stack->size;
  fields = info->type_stack->fields;
  first = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (first) + strlen (fields) + 2);
  sprintf (buf, "%s%s;", first, fields);
  free (first);
  free (fields);

  if (! stab_push_string (info, buf, index, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start outputting a class.  */

static bfd_boolean
stab_start_class_type (void *p, const char *tag, unsigned int id, bfd_boolean structp, unsigned int size, bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *vstring;

  if (! vptr || ownvptr)
    {
      definition = FALSE;
      vstring = NULL;
    }
  else
    {
      definition = info->type_stack->definition;
      vstring = stab_pop_type (info);
    }

  if (! stab_start_struct_type (p, tag, id, structp, size))
    return FALSE;

  if (vptr)
    {
      char *vtable;

      if (ownvptr)
	{
	  assert (info->type_stack->index > 0);
	  vtable = (char *) xmalloc (20);
	  sprintf (vtable, "~%%%ld", info->type_stack->index);
	}
      else
	{
	  vtable = (char *) xmalloc (strlen (vstring) + 3);
	  sprintf (vtable, "~%%%s", vstring);
	  free (vstring);
	}

      info->type_stack->vtable = vtable;
    }

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a static member to the class on the type stack.  */

static bfd_boolean
stab_class_static_member (void *p, const char *name, const char *physname,
			  enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s, *n;
  const char *vis;

  definition = info->type_stack->definition;
  s = stab_pop_type (info);

  /* Add this field to the end of the current struct fields, which is
     currently on the top of the stack.  */

  assert (info->type_stack->fields != NULL);
  n = (char *) xmalloc (strlen (info->type_stack->fields)
			+ strlen (name)
			+ strlen (s)
			+ strlen (physname)
			+ 10);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PUBLIC:
      vis = "";
      break;

    case DEBUG_VISIBILITY_PRIVATE:
      vis = "/0";
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      vis = "/1";
      break;
    }

  sprintf (n, "%s%s:%s%s:%s;", info->type_stack->fields, name, vis, s,
	   physname);

  free (info->type_stack->fields);
  info->type_stack->fields = n;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a base class to the class on the type stack.  */

static bfd_boolean
stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
		      enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s;
  char *buf;
  unsigned int c;
  char **baseclasses;

  definition = info->type_stack->definition;
  s = stab_pop_type (info);

  /* Build the base class specifier.  */

  buf = (char *) xmalloc (strlen (s) + 25);
  buf[0] = virtual ? '1' : '0';
  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PRIVATE:
      buf[1] = '0';
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      buf[1] = '1';
      break;

    case DEBUG_VISIBILITY_PUBLIC:
      buf[1] = '2';
      break;
    }

  sprintf (buf + 2, "%ld,%s;", (long) bitpos, s);
  free (s);

  /* Add the new baseclass to the existing ones.  */

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  if (info->type_stack->baseclasses == NULL)
    c = 0;
  else
    {
      c = 0;
      while (info->type_stack->baseclasses[c] != NULL)
	++c;
    }

  baseclasses = (char **) xrealloc (info->type_stack->baseclasses,
				    (c + 2) * sizeof (*baseclasses));
  baseclasses[c] = buf;
  baseclasses[c + 1] = NULL;

  info->type_stack->baseclasses = baseclasses;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Start adding a method to the class on the type stack.  */

static bfd_boolean
stab_class_start_method (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *m;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  if (info->type_stack->methods == NULL)
    {
      m = (char *) xmalloc (strlen (name) + 3);
      *m = '\0';
    }
  else
    {
      m = (char *) xrealloc (info->type_stack->methods,
			     (strlen (info->type_stack->methods)
			      + strlen (name)
			      + 4));
    }

  sprintf (m + strlen (m), "%s::", name);

  info->type_stack->methods = m;

  return TRUE;
}

/* Add a variant, either static or not, to the current method.  */

static bfd_boolean
stab_class_method_var (struct stab_write_handle *info, const char *physname,
		       enum debug_visibility visibility,
		       bfd_boolean staticp, bfd_boolean constp,
		       bfd_boolean volatilep, bfd_vma voffset,
		       bfd_boolean contextp)
{
  bfd_boolean definition;
  char *type;
  char *context = NULL;
  char visc, qualc, typec;

  definition = info->type_stack->definition;
  type = stab_pop_type (info);

  if (contextp)
    {
      definition = definition || info->type_stack->definition;
      context = stab_pop_type (info);
    }

  assert (info->type_stack != NULL && info->type_stack->methods != NULL);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PRIVATE:
      visc = '0';
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      visc = '1';
      break;

    case DEBUG_VISIBILITY_PUBLIC:
      visc = '2';
      break;
    }

  if (constp)
    {
      if (volatilep)
	qualc = 'D';
      else
	qualc = 'B';
    }
  else
    {
      if (volatilep)
	qualc = 'C';
      else
	qualc = 'A';
    }

  if (staticp)
    typec = '?';
  else if (! contextp)
    typec = '.';
  else
    typec = '*';

  info->type_stack->methods =
    (char *) xrealloc (info->type_stack->methods,
		       (strlen (info->type_stack->methods)
			+ strlen (type)
			+ strlen (physname)
			+ (contextp ? strlen (context) : 0)
			+ 40));

  sprintf (info->type_stack->methods + strlen (info->type_stack->methods),
	   "%s:%s;%c%c%c", type, physname, visc, qualc, typec);
  free (type);

  if (contextp)
    {
      sprintf (info->type_stack->methods + strlen (info->type_stack->methods),
	       "%ld;%s;", (long) voffset, context);
      free (context);
    }

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a variant to the current method.  */

static bfd_boolean
stab_class_method_variant (void *p, const char *physname,
			   enum debug_visibility visibility,
			   bfd_boolean constp, bfd_boolean volatilep,
			   bfd_vma voffset, bfd_boolean contextp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_class_method_var (info, physname, visibility, FALSE, constp,
				volatilep, voffset, contextp);
}

/* Add a static variant to the current method.  */

static bfd_boolean
stab_class_static_method_variant (void *p, const char *physname,
				  enum debug_visibility visibility,
				  bfd_boolean constp, bfd_boolean volatilep)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_class_method_var (info, physname, visibility, TRUE, constp,
				volatilep, 0, FALSE);
}

/* Finish up a method.  */

static bfd_boolean
stab_class_end_method (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  assert (info->type_stack != NULL && info->type_stack->methods != NULL);

  /* We allocated enough room on info->type_stack->methods to add the
     trailing semicolon.  */
  strcat (info->type_stack->methods, ";");

  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
stab_end_class_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  size_t len;
  unsigned int i = 0;
  char *buf;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  /* Work out the size we need to allocate for the class definition.  */

  len = (strlen (info->type_stack->string)
	 + strlen (info->type_stack->fields)
	 + 10);
  if (info->type_stack->baseclasses != NULL)
    {
      len += 20;
      for (i = 0; info->type_stack->baseclasses[i] != NULL; i++)
	len += strlen (info->type_stack->baseclasses[i]);
    }
  if (info->type_stack->methods != NULL)
    len += strlen (info->type_stack->methods);
  if (info->type_stack->vtable != NULL)
    len += strlen (info->type_stack->vtable);

  /* Build the class definition.  */

  buf = (char *) xmalloc (len);

  strcpy (buf, info->type_stack->string);

  if (info->type_stack->baseclasses != NULL)
    {
      sprintf (buf + strlen (buf), "!%u,", i);
      for (i = 0; info->type_stack->baseclasses[i] != NULL; i++)
	{
	  strcat (buf, info->type_stack->baseclasses[i]);
	  free (info->type_stack->baseclasses[i]);
	}
      free (info->type_stack->baseclasses);
      info->type_stack->baseclasses = NULL;
    }

  strcat (buf, info->type_stack->fields);
  free (info->type_stack->fields);
  info->type_stack->fields = NULL;

  if (info->type_stack->methods != NULL)
    {
      strcat (buf, info->type_stack->methods);
      free (info->type_stack->methods);
      info->type_stack->methods = NULL;
    }

  strcat (buf, ";");

  if (info->type_stack->vtable != NULL)
    {
      strcat (buf, info->type_stack->vtable);
      free (info->type_stack->vtable);
      info->type_stack->vtable = NULL;
    }

  /* Replace the string on the top of the stack with the complete
     class definition.  */
  free (info->type_stack->string);
  info->type_stack->string = buf;

  return TRUE;
}

/* Push a typedef which was previously defined.  */

static bfd_boolean
stab_typedef_type (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  struct string_hash_entry *h;

  h = string_hash_lookup (&info->typedef_hash, name, FALSE, FALSE);
  assert (h != NULL && h->index > 0);

  return stab_push_defined_type (info, h->index, h->size);
}

/* Push a struct, union or class tag.  */

static bfd_boolean
stab_tag_type (void *p, const char *name, unsigned int id,
	       enum debug_type_kind kind)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long index;
  unsigned int size;

  index = stab_get_struct_index (info, name, id, kind, &size);
  if (index < 0)
    return FALSE;

  return stab_push_defined_type (info, index, size);
}

/* Define a typedef.  */

static bfd_boolean
stab_typdef (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long index;
  unsigned int size;
  char *s, *buf;
  struct string_hash_entry *h;

  index = info->type_stack->index;
  size = info->type_stack->size;
  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 20);

  if (index > 0)
    sprintf (buf, "%s:t%s", name, s);
  else
    {
      index = info->type_index;
      ++info->type_index;
      sprintf (buf, "%s:t%ld=%s", name, index, s);
    }

  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  h = string_hash_lookup (&info->typedef_hash, name, TRUE, FALSE);
  if (h == NULL)
    {
      non_fatal (_("string_hash_lookup failed: %s"),
		 bfd_errmsg (bfd_get_error ()));
      return FALSE;
    }

  /* I don't think we care about redefinitions.  */

  h->index = index;
  h->size = size;

  return TRUE;
}

/* Define a tag.  */

static bfd_boolean
stab_tag (void *p, const char *tag)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;

  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (tag) + strlen (s) + 3);

  sprintf (buf, "%s:T%s", tag, s);
  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define an integer constant.  */

static bfd_boolean
stab_int_constant (void *p, const char *name, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *buf;

  buf = (char *) xmalloc (strlen (name) + 20);
  sprintf (buf, "%s:c=i%ld", name, (long) val);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define a floating point constant.  */

static bfd_boolean
stab_float_constant (void *p, const char *name, double val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *buf;

  buf = (char *) xmalloc (strlen (name) + 20);
  sprintf (buf, "%s:c=f%g", name, val);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define a typed constant.  */

static bfd_boolean
stab_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;

  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 20);
  sprintf (buf, "%s:c=e%s,%ld", name, s, (long) val);
  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Record a variable.  */

static bfd_boolean
stab_variable (void *p, const char *name, enum debug_var_kind kind,
	       bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;
  int stab_type;
  const char *kindstr;

  s = stab_pop_type (info);

  switch (kind)
    {
    default:
      abort ();

    case DEBUG_GLOBAL:
      stab_type = N_GSYM;
      kindstr = "G";
      break;

    case DEBUG_STATIC:
      stab_type = N_STSYM;
      kindstr = "S";
      break;

    case DEBUG_LOCAL_STATIC:
      stab_type = N_STSYM;
      kindstr = "V";
      break;

    case DEBUG_LOCAL:
      stab_type = N_LSYM;
      kindstr = "";

      /* Make sure that this is a type reference or definition.  */
      if (! ISDIGIT (*s))
	{
	  char *n;
	  long index;

	  index = info->type_index;
	  ++info->type_index;
	  n = (char *) xmalloc (strlen (s) + 20);
	  sprintf (n, "%ld=%s", index, s);
	  free (s);
	  s = n;
	}
      break;

    case DEBUG_REGISTER:
      stab_type = N_RSYM;
      kindstr = "r";
      break;
    }

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 3);
  sprintf (buf, "%s:%s%s", name, kindstr, s);
  free (s);

  if (! stab_write_symbol (info, stab_type, 0, val, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
stab_start_function (void *p, const char *name, bfd_boolean globalp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *rettype, *buf;

  assert (info->nesting == 0 && info->fun_offset == -1);

  rettype = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (rettype) + 3);
  sprintf (buf, "%s:%c%s", name,
	   globalp ? 'F' : 'f',
	   rettype);

  /* We don't know the value now, so we set it in start_block.  */
  info->fun_offset = info->symbols_size;

  if (! stab_write_symbol (info, N_FUN, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
stab_function_parameter (void *p, const char *name, enum debug_parm_kind kind, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;
  int stab_type;
  char kindc;

  s = stab_pop_type (info);

  switch (kind)
    {
    default:
      abort ();

    case DEBUG_PARM_STACK:
      stab_type = N_PSYM;
      kindc = 'p';
      break;

    case DEBUG_PARM_REG:
      stab_type = N_RSYM;
      kindc = 'P';
      break;

    case DEBUG_PARM_REFERENCE:
      stab_type = N_PSYM;
      kindc = 'v';
      break;

    case DEBUG_PARM_REF_REG:
      stab_type = N_RSYM;
      kindc = 'a';
      break;
    }

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 3);
  sprintf (buf, "%s:%c%s", name, kindc, s);
  free (s);

  if (! stab_write_symbol (info, stab_type, 0, val, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start a block.  */

static bfd_boolean
stab_start_block (void *p, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* Fill in any slots which have been waiting for the first known
     text address.  */

  if (info->so_offset != -1)
    {
      bfd_put_32 (info->abfd, addr, info->symbols + info->so_offset + 8);
      info->so_offset = -1;
    }

  if (info->fun_offset != -1)
    {
      bfd_put_32 (info->abfd, addr, info->symbols + info->fun_offset + 8);
      info->fun_offset = -1;
    }

  ++info->nesting;

  /* We will be called with a top level block surrounding the
     function, but stabs information does not output that block, so we
     ignore it.  */

  if (info->nesting == 1)
    {
      info->fnaddr = addr;
      return TRUE;
    }

  /* We have to output the LBRAC symbol after any variables which are
     declared inside the block.  We postpone the LBRAC until the next
     start_block or end_block.  */

  /* If we have postponed an LBRAC, output it now.  */
  if (info->pending_lbrac != (bfd_vma) -1)
    {
      if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,
			       (const char *) NULL))
	return FALSE;
    }

  /* Remember the address and output it later.  */

  info->pending_lbrac = addr - info->fnaddr;

  return TRUE;
}

/* End a block.  */

static bfd_boolean
stab_end_block (void *p, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (addr > info->last_text_address)
    info->last_text_address = addr;

  /* If we have postponed an LBRAC, output it now.  */
  if (info->pending_lbrac != (bfd_vma) -1)
    {
      if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,
			       (const char *) NULL))
	return FALSE;
      info->pending_lbrac = (bfd_vma) -1;
    }

  assert (info->nesting > 0);

  --info->nesting;

  /* We ignore the outermost block.  */
  if (info->nesting == 0)
    return TRUE;

  return stab_write_symbol (info, N_RBRAC, 0, addr - info->fnaddr,
			    (const char *) NULL);
}

/* End a function.  */

static bfd_boolean
stab_end_function (void *p ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Output a line number.  */

static bfd_boolean
stab_lineno (void *p, const char *file, unsigned long lineno, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  assert (info->lineno_filename != NULL);

  if (addr > info->last_text_address)
    info->last_text_address = addr;

  if (strcmp (file, info->lineno_filename) != 0)
    {
      if (! stab_write_symbol (info, N_SOL, 0, addr, file))
	return FALSE;
      info->lineno_filename = file;
    }

  return stab_write_symbol (info, N_SLINE, lineno, addr - info->fnaddr,
			    (const char *) NULL);
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d176 1
a176 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d178 1
a178 1
  PARAMS ((struct stab_write_handle *, int, int, bfd_vma, const char *));
d180 1
a180 2
  PARAMS ((struct stab_write_handle *, const char *, long, bfd_boolean,
	   unsigned int));
d182 2
a183 3
  PARAMS ((struct stab_write_handle *, long, unsigned int));
static char *stab_pop_type
  PARAMS ((struct stab_write_handle *));
d185 1
a185 1
  PARAMS ((struct stab_write_handle *, int, unsigned int, long **, size_t *));
d187 2
a188 2
  PARAMS ((struct stab_write_handle *, const char *, unsigned int,
	   enum debug_type_kind, unsigned int *));
d190 10
a199 18
  PARAMS ((struct stab_write_handle *, const char *, enum debug_visibility,
	   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean));
static bfd_boolean stab_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean stab_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean stab_empty_type
  PARAMS ((PTR));
static bfd_boolean stab_void_type
  PARAMS ((PTR));
static bfd_boolean stab_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean stab_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_bool_type
  PARAMS ((PTR, unsigned int));
d201 5
a205 9
  PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
static bfd_boolean stab_pointer_type
  PARAMS ((PTR));
static bfd_boolean stab_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean stab_reference_type
  PARAMS ((PTR));
static bfd_boolean stab_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d207 6
a212 11
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean stab_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean stab_offset_type
  PARAMS ((PTR));
static bfd_boolean stab_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean stab_const_type
  PARAMS ((PTR));
static bfd_boolean stab_volatile_type
  PARAMS ((PTR));
d214 1
a214 1
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d216 2
a217 3
  PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
static bfd_boolean stab_end_struct_type
  PARAMS ((PTR));
d219 2
a220 2
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
d222 1
a222 1
  PARAMS ((PTR, const char *, const char *, enum debug_visibility));
d224 2
a225 3
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean stab_class_start_method
  PARAMS ((PTR, const char *));
d227 2
a228 2
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
d230 4
a233 8
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean stab_class_end_method
  PARAMS ((PTR));
static bfd_boolean stab_end_class_type
  PARAMS ((PTR));
static bfd_boolean stab_typedef_type
  PARAMS ((PTR, const char *));
d235 6
a240 11
  PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
static bfd_boolean stab_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean stab_tag
  PARAMS ((PTR, const char *));
static bfd_boolean stab_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean stab_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean stab_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
d242 2
a243 3
  PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
static bfd_boolean stab_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
d245 5
a249 9
  PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
static bfd_boolean stab_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_function
  PARAMS ((PTR));
static bfd_boolean stab_lineno
  PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d302 2
a303 4
string_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d339 2
a340 6
stab_write_symbol (info, type, desc, value, string)
     struct stab_write_handle *info;
     int type;
     int desc;
     bfd_vma value;
     const char *string;
d397 2
a398 6
stab_push_string (info, string, index, definition, size)
     struct stab_write_handle *info;
     const char *string;
     long index;
     bfd_boolean definition;
     unsigned int size;
d422 2
a423 4
stab_push_defined_type (info, index, size)
     struct stab_write_handle *info;
     long index;
     unsigned int size;
d435 1
a435 2
stab_pop_type (info)
     struct stab_write_handle *info;
d462 5
a466 8
write_stabs_in_sections_debugging_info (abfd, dhandle, psyms, psymsize,
					pstrings, pstringsize)
     bfd *abfd;
     PTR dhandle;
     bfd_byte **psyms;
     bfd_size_type *psymsize;
     bfd_byte **pstrings;
     bfd_size_type *pstringsize;
d510 1
a510 1
  if (! debug_write (dhandle, &stab_fns, (PTR) &info))
d543 1
a543 3
stab_start_compilation_unit (p, filename)
     PTR p;
     const char *filename;
d560 1
a560 3
stab_start_source (p, filename)
     PTR p;
     const char *filename;
d577 1
a577 2
stab_empty_type (p)
     PTR p;
d603 1
a603 2
stab_void_type (p)
     PTR p;
d628 1
a628 4
stab_int_type (p, size, unsignedp)
     PTR p;
     unsigned int size;
     bfd_boolean unsignedp;
d688 1
a688 3
stab_float_type (p, size)
     PTR p;
     unsigned int size;
d729 1
a729 3
stab_complex_type (p, size)
     PTR p;
     unsigned int size;
d747 1
a747 3
stab_bool_type (p, size)
     PTR p;
     unsigned int size;
d778 2
a779 5
stab_enum_type (p, tag, names, vals)
     PTR p;
     const char *tag;
     const char **names;
     bfd_signed_vma *vals;
d845 2
a846 6
stab_modify_type (info, mod, size, cache, cache_alloc)
     struct stab_write_handle *info;
     int mod;
     unsigned int size;
     long **cache;
     size_t *cache_alloc;
d927 1
a927 2
stab_pointer_type (p)
     PTR p;
d939 2
a940 4
stab_function_type (p, argcount, varargs)
     PTR p;
     int argcount;
     bfd_boolean varargs ATTRIBUTE_UNUSED;
d976 1
a976 2
stab_reference_type (p)
     PTR p;
d988 1
a988 4
stab_range_type (p, low, high)
     PTR p;
     bfd_signed_vma low;
     bfd_signed_vma high;
d1014 2
a1015 5
stab_array_type (p, low, high, stringp)
     PTR p;
     bfd_signed_vma low;
     bfd_signed_vma high;
     bfd_boolean stringp;
d1068 1
a1068 3
stab_set_type (p, bitstringp)
     PTR p;
     bfd_boolean bitstringp;
d1109 1
a1109 2
stab_offset_type (p)
     PTR p;
d1137 2
a1138 5
stab_method_type (p, domainp, argcount, varargs)
     PTR p;
     bfd_boolean domainp;
     int argcount;
     bfd_boolean varargs;
d1236 1
a1236 2
stab_const_type (p)
     PTR p;
d1247 1
a1247 2
stab_volatile_type (p)
     PTR p;
d1259 3
a1261 6
stab_get_struct_index (info, tag, id, kind, psize)
     struct stab_write_handle *info;
     const char *tag;
     unsigned int id;
     enum debug_type_kind kind;
     unsigned int *psize;
d1307 2
a1308 6
stab_start_struct_type (p, tag, id, structp, size)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
d1349 2
a1350 6
stab_struct_field (p, name, bitpos, bitsize, visibility)
     PTR p;
     const char *name;
     bfd_vma bitpos;
     bfd_vma bitsize;
     enum debug_visibility visibility;
d1412 1
a1412 2
stab_end_struct_type (p)
     PTR p;
d1444 1
a1444 8
stab_start_class_type (p, tag, id, structp, size, vptr, ownvptr)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1493 2
a1494 5
stab_class_static_member (p, name, physname, visibility)
     PTR p;
     const char *name;
     const char *physname;
     enum debug_visibility visibility;
d1547 2
a1548 5
stab_class_baseclass (p, bitpos, virtual, visibility)
     PTR p;
     bfd_vma bitpos;
     bfd_boolean virtual;
     enum debug_visibility visibility;
d1614 1
a1614 3
stab_class_start_method (p, name)
     PTR p;
     const char *name;
d1644 5
a1648 10
stab_class_method_var (info, physname, visibility, staticp, constp, volatilep,
		       voffset, contextp)
     struct stab_write_handle *info;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean staticp;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean contextp;
d1734 4
a1737 9
stab_class_method_variant (p, physname, visibility, constp, volatilep,
			   voffset, contextp)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean contextp;
d1748 3
a1750 6
stab_class_static_method_variant (p, physname, visibility, constp, volatilep)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
d1761 1
a1761 2
stab_class_end_method (p)
     PTR p;
d1777 1
a1777 2
stab_end_class_type (p)
     PTR p;
d1851 1
a1851 3
stab_typedef_type (p, name)
     PTR p;
     const char *name;
d1865 2
a1866 5
stab_tag_type (p, name, id, kind)
     PTR p;
     const char *name;
     unsigned int id;
     enum debug_type_kind kind;
d1882 1
a1882 3
stab_typdef (p, name)
     PTR p;
     const char *name;
d1931 1
a1931 3
stab_tag (p, tag)
     PTR p;
     const char *tag;
d1954 1
a1954 4
stab_int_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1973 1
a1973 4
stab_float_constant (p, name, val)
     PTR p;
     const char *name;
     double val;
d1992 1
a1992 4
stab_typed_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d2014 2
a2015 5
stab_variable (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_var_kind kind;
     bfd_vma val;
d2084 1
a2084 4
stab_start_function (p, name, globalp)
     PTR p;
     const char *name;
     bfd_boolean globalp;
d2112 1
a2112 5
stab_function_parameter (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_parm_kind kind;
     bfd_vma val;
d2162 1
a2162 3
stab_start_block (p, addr)
     PTR p;
     bfd_vma addr;
d2215 1
a2215 3
stab_end_block (p, addr)
     PTR p;
     bfd_vma addr;
d2246 1
a2246 2
stab_end_function (p)
     PTR p ATTRIBUTE_UNUSED;
d2254 1
a2254 5
stab_lineno (p, file, lineno, addr)
     PTR p;
     const char *file;
     unsigned long lineno;
     bfd_vma addr;
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
a26 1
#include <ctype.h>
d32 1
a34 4

/* Meaningless definition needs by aout64.h.  FIXME.  */
#define BYTES_IN_WORD 4

d75 1
a75 1
  boolean definition;
d177 1
a177 1
static boolean stab_write_symbol
d179 2
a180 2
static boolean stab_push_string
  PARAMS ((struct stab_write_handle *, const char *, long, boolean,
d182 1
a182 1
static boolean stab_push_defined_type
d184 3
a186 2
static char *stab_pop_type PARAMS ((struct stab_write_handle *));
static boolean stab_modify_type
d191 1
a191 1
static boolean stab_class_method_var
d193 18
a210 11
	   boolean, boolean, boolean, bfd_vma, boolean));

static boolean stab_start_compilation_unit PARAMS ((PTR, const char *));
static boolean stab_start_source PARAMS ((PTR, const char *));
static boolean stab_empty_type PARAMS ((PTR));
static boolean stab_void_type PARAMS ((PTR));
static boolean stab_int_type PARAMS ((PTR, unsigned int, boolean));
static boolean stab_float_type PARAMS ((PTR, unsigned int));
static boolean stab_complex_type PARAMS ((PTR, unsigned int));
static boolean stab_bool_type PARAMS ((PTR, unsigned int));
static boolean stab_enum_type
d212 23
a234 14
static boolean stab_pointer_type PARAMS ((PTR));
static boolean stab_function_type PARAMS ((PTR, int, boolean));
static boolean stab_reference_type PARAMS ((PTR));
static boolean stab_range_type PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static boolean stab_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, boolean));
static boolean stab_set_type PARAMS ((PTR, boolean));
static boolean stab_offset_type PARAMS ((PTR));
static boolean stab_method_type PARAMS ((PTR, boolean, int, boolean));
static boolean stab_const_type PARAMS ((PTR));
static boolean stab_volatile_type PARAMS ((PTR));
static boolean stab_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int));
static boolean stab_struct_field
d236 6
a241 5
static boolean stab_end_struct_type PARAMS ((PTR));
static boolean stab_start_class_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int, boolean,
	   boolean));
static boolean stab_class_static_member
d243 17
a259 12
static boolean stab_class_baseclass
  PARAMS ((PTR, bfd_vma, boolean, enum debug_visibility));
static boolean stab_class_start_method PARAMS ((PTR, const char *));
static boolean stab_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean,
	   bfd_vma, boolean));
static boolean stab_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean));
static boolean stab_class_end_method PARAMS ((PTR));
static boolean stab_end_class_type PARAMS ((PTR));
static boolean stab_typedef_type PARAMS ((PTR, const char *));
static boolean stab_tag_type
d261 11
a271 6
static boolean stab_typdef PARAMS ((PTR, const char *));
static boolean stab_tag PARAMS ((PTR, const char *));
static boolean stab_int_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean stab_float_constant PARAMS ((PTR, const char *, double));
static boolean stab_typed_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean stab_variable
d273 3
a275 2
static boolean stab_start_function PARAMS ((PTR, const char *, boolean));
static boolean stab_function_parameter
d277 7
a283 4
static boolean stab_start_block PARAMS ((PTR, bfd_vma));
static boolean stab_end_block PARAMS ((PTR, bfd_vma));
static boolean stab_end_function PARAMS ((PTR));
static boolean stab_lineno
d375 1
a375 1
static boolean
d392 1
a392 1
      h = string_hash_lookup (&info->strhash, string, true, true);
d397 1
a397 1
	  return false;
d432 1
a432 1
  return true;
d437 1
a437 1
static boolean
d442 1
a442 1
     boolean definition;
d461 1
a461 1
  return true;
d466 1
a466 1
static boolean
d475 1
a475 1
  return stab_push_string (info, buf, index, false, size);
d509 1
a509 1
boolean
d539 1
a539 1
      return false;
d554 1
a554 1
    return false;
d559 1
a559 1
    return false;
d562 1
a562 1
    return false;
d569 1
a569 1
    return false;
d588 1
a588 1
  return true;
d593 1
a593 1
static boolean
d612 1
a612 1
static boolean
d631 1
a631 1
static boolean
d652 1
a652 1
      return stab_push_string (info, buf, index, false, 0);
d658 1
a658 1
static boolean
d678 1
a678 1
      return stab_push_string (info, buf, index, true, 0);
d684 1
a684 1
static boolean
d688 1
a688 1
     boolean unsignedp;
d696 1
a696 1
      return false;
d741 1
a741 1
      return stab_push_string (info, buf, index, true, size);
d747 1
a747 1
static boolean
d768 2
a769 2
      if (! stab_int_type (info, 4, false))
	return false;
d784 1
a784 1
      return stab_push_string (info, buf, index, true, size);
d790 1
a790 1
static boolean
d804 1
a804 1
  return stab_push_string (info, buf, index, true, size * 2);
d807 1
a807 1
/* Push a boolean type.  We use an XCOFF predefined type, since gdb
d810 1
a810 1
static boolean
d827 1
a827 1
      
d843 1
a843 1
static boolean
d864 2
a865 2
      if (! stab_push_string (info, buf, 0, false, 4))
	return false;
d867 1
a867 1
      return true;
d894 2
a895 2
      if (! stab_push_string (info, buf, 0, false, 4))
	return false;
d902 1
a902 1
	return false;
d907 1
a907 1
  return true;
d913 1
a913 1
static boolean
d931 1
a931 1
      boolean definition;
d942 1
a942 1
	return false;
d973 1
a973 1
	    return false;
d987 2
a988 2
	  if (! stab_push_string (info, buf, index, true, size))
	    return false;
d994 2
a995 2
  return true;
}  
d999 1
a999 1
static boolean
d1012 1
a1012 1
static boolean
d1016 1
a1016 1
     boolean varargs ATTRIBUTE_UNUSED;
d1039 1
a1039 1
	    return false;
d1051 1
a1051 1
static boolean
d1064 1
a1064 1
static boolean
d1071 1
a1071 1
  boolean definition;
d1084 1
a1084 1
    return false;
d1088 1
a1088 1
  return true;
d1093 1
a1093 1
static boolean
d1098 1
a1098 1
     boolean stringp;
d1101 1
a1101 1
  boolean definition;
d1127 1
a1127 1
      definition = true;
d1141 1
a1141 1
    return false;
d1145 1
a1145 1
  return true;
d1150 1
a1150 1
static boolean
d1153 1
a1153 1
     boolean bitstringp;
d1156 1
a1156 1
  boolean definition;
d1176 1
a1176 1
      definition = true;
d1184 1
a1184 1
    return false;
d1188 1
a1188 1
  return true;
d1193 1
a1193 1
static boolean
d1198 1
a1198 1
  boolean definition;
d1213 1
a1213 1
    return false;
d1217 1
a1217 1
  return true;
d1222 1
a1222 1
static boolean
d1225 1
a1225 1
     boolean domainp;
d1227 1
a1227 1
     boolean varargs;
d1230 1
a1230 1
  boolean definition;
d1245 1
a1245 1
	return false;
d1267 1
a1267 1
	    return false;
d1284 1
a1284 1
	    return false;
d1315 1
a1315 1
    return false;
d1319 1
a1319 1
  return true;
d1324 1
a1324 1
static boolean
d1336 1
a1336 1
static boolean
d1400 1
a1400 2
/*ARGSUSED*/
static boolean
d1405 1
a1405 1
     boolean structp;
d1410 1
a1410 1
  boolean definition;
d1419 1
a1419 1
      definition = false;
d1426 1
a1426 1
	return false;
d1428 1
a1428 1
      definition = true;
d1436 1
a1436 1
    return false;
d1441 1
a1441 1
  return true;
d1446 1
a1446 1
static boolean
d1455 1
a1455 1
  boolean definition;
d1506 1
a1506 1
    info->type_stack->definition = true;
d1508 1
a1508 1
  return true;
d1513 1
a1513 1
static boolean
d1518 1
a1518 1
  boolean definition;
d1537 1
a1537 1
    return false;
d1541 1
a1541 1
  return true;
d1546 1
a1546 1
static boolean
d1551 1
a1551 1
     boolean structp;
d1553 2
a1554 2
     boolean vptr;
     boolean ownvptr;
d1557 1
a1557 1
  boolean definition;
d1562 1
a1562 1
      definition = false;
d1572 1
a1572 1
    return false;
d1595 1
a1595 1
    info->type_stack->definition = true;
d1597 1
a1597 1
  return true;
d1602 1
a1602 1
static boolean
d1610 1
a1610 1
  boolean definition;
d1652 1
a1652 1
    info->type_stack->definition = true;
d1654 1
a1654 1
  return true;
d1659 1
a1659 1
static boolean
d1663 1
a1663 1
     boolean virtual;
d1667 1
a1667 1
  boolean definition;
d1722 1
a1722 1
    info->type_stack->definition = true;
d1724 1
a1724 1
  return true;
d1729 1
a1729 1
static boolean
d1756 1
a1756 1
  return true;
d1761 1
a1761 1
static boolean
d1767 3
a1769 3
     boolean staticp;
     boolean constp;
     boolean volatilep;
d1771 1
a1771 1
     boolean contextp;
d1773 1
a1773 1
  boolean definition;
d1849 1
a1849 1
    info->type_stack->definition = true;
d1851 1
a1851 1
  return true;
d1856 1
a1856 1
static boolean
d1862 2
a1863 2
     boolean constp;
     boolean volatilep;
d1865 1
a1865 1
     boolean contextp;
d1869 1
a1869 1
  return stab_class_method_var (info, physname, visibility, false, constp,
d1875 1
a1875 1
static boolean
d1880 2
a1881 2
     boolean constp;
     boolean volatilep;
d1885 2
a1886 2
  return stab_class_method_var (info, physname, visibility, true, constp,
				volatilep, 0, false);
d1891 1
a1891 1
static boolean
d1903 1
a1903 1
  return true;
d1908 1
a1908 1
static boolean
d1978 1
a1978 1
  return true;
d1983 1
a1983 1
static boolean
d1991 1
a1991 1
  h = string_hash_lookup (&info->typedef_hash, name, false, false);
d1999 1
a1999 1
static boolean
d2012 1
a2012 1
    return false;
d2019 1
a2019 1
static boolean
d2048 1
a2048 1
    return false;
d2052 1
a2052 1
  h = string_hash_lookup (&info->typedef_hash, name, true, false);
d2057 1
a2057 1
      return false;
d2065 1
a2065 1
  return true;
d2070 1
a2070 1
static boolean
d2086 1
a2086 1
    return false;
d2090 1
a2090 1
  return true;
d2095 1
a2095 1
static boolean
d2108 1
a2108 1
    return false;
d2112 1
a2112 1
  return true;
d2117 1
a2117 1
static boolean
d2130 1
a2130 1
    return false;
d2134 1
a2134 1
  return true;
d2139 1
a2139 1
static boolean
d2155 1
a2155 1
    return false;
d2159 1
a2159 1
  return true;
d2164 1
a2164 1
static boolean
d2203 1
a2203 1
      if (! isdigit ((unsigned char) *s))
d2228 1
a2228 1
    return false;
d2232 1
a2232 1
  return true;
d2237 1
a2237 1
static boolean
d2241 1
a2241 1
     boolean globalp;
d2259 1
a2259 1
    return false;
d2263 1
a2263 1
  return true;
d2268 1
a2268 1
static boolean
d2313 1
a2313 1
    return false;
d2317 1
a2317 1
  return true;
d2322 1
a2322 1
static boolean
d2353 1
a2353 1
      return true;
d2365 1
a2365 1
	return false;
d2372 1
a2372 1
  return true;
d2377 1
a2377 1
static boolean
d2392 1
a2392 1
	return false;
d2402 1
a2402 1
    return true;
d2410 1
a2410 2
/*ARGSUSED*/
static boolean
d2414 1
a2414 1
  return true;
d2419 1
a2419 1
static boolean
d2436 1
a2436 1
	return false;
@


1.4
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@d2 1
a2 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1102 2
a1103 1
  sprintf (buf + strlen (buf), "ar%s;%ld;%ld;%s", range, low, high, element);
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1996 Free Software Foundation, Inc.
d366 2
a367 2
	  fprintf (stderr, "string_hash_lookup failed: %s\n",
		   bfd_errmsg (bfd_get_error ()));
d508 2
a509 2
      fprintf (stderr, "bfd_hash_table_init_failed: %s\n",
	       bfd_errmsg (bfd_get_error ()));
d555 2
a556 2
      strcpy (p, h->root.string);
      p += strlen (p) + 1;
d666 1
a666 1
      fprintf (stderr, "stab_int_type: bad size %u\n", size);
d918 1
a918 1
      if (targindex >= *cache_alloc)
d925 1
a925 1
	  while (targindex >= alloc)
d987 1
a987 1
     boolean varargs;
d1466 2
a1467 3
	fprintf (stderr,
		 "%s: warning: unknown size for field `%s' in struct\n",
		 bfd_get_filename (info->abfd), name);
d1885 1
a1885 1
  unsigned int i;
d2026 2
a2027 2
      fprintf (stderr, "string_hash_lookup failed: %s\n",
	       bfd_errmsg (bfd_get_error ()));
d2174 1
a2174 1
      if (! isdigit (*s))
d2384 1
a2384 1
     PTR p;
@


1.1
log
@Initial revision
@
text
@d50 2
d144 5
a148 2
  /* This buffer holds the strings.  */
  bfd_byte *strings;
a149 1
  size_t strings_alloc;
d330 1
d363 1
a363 1
      h = string_hash_lookup (&info->strhash, string, true, false);
a373 2
	  size_t len;

d376 6
a381 10

	  len = strlen (string);
	  while (info->strings_size + len + 1 > info->strings_alloc)
	    {
	      info->strings_alloc *= 2;
	      info->strings = (bfd_byte *) xrealloc (info->strings,
						     info->strings_alloc);
	    }
	  strcpy (info->strings + info->strings_size, string);
	  info->strings_size += len + 1;
d491 2
d500 3
a503 3
  info.strings_alloc = 500;
  info.strings = (bfd_byte *) xmalloc (info.strings_alloc);
  info.strings[0] = '\0';
a547 1
  *pstrings = info.strings;
d549 9
d934 1
a934 1
      if (index != 0)
d936 6
a941 4
	  /* If we have already defined a modification of this type,
             then the entry on the type stack can not be a definition,
             so we can safely discard it.  */
	  assert (! info->type_stack->definition);
d1106 1
a1106 1
  if (high <= low)
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a49 2
  /* Next string in this table.  */
  struct string_hash_entry *next;
d142 2
a143 5
  /* This is a list of hash table entries for the strings.  */
  struct string_hash_entry *strings;
  /* The last string hash table entry.  */
  struct string_hash_entry *last_string;
  /* The size of the strings.  */
d145 1
a325 1
      ret->next = NULL;
d358 1
a358 1
      h = string_hash_lookup (&info->strhash, string, true, true);
d369 2
d373 10
a382 6
	  if (info->last_string == NULL)
	    info->strings = h;
	  else
	    info->last_string->next = h;
	  info->last_string = h;
	  info->strings_size += strlen (string) + 1;
a491 2
  struct string_hash_entry *h;
  bfd_byte *p;
a498 3
  info.strings = NULL;
  info.last_string = NULL;
  /* Reserve 1 byte for a null byte.  */
d500 3
d547 1
a548 9
  *pstrings = (bfd_byte *) xmalloc (info.strings_size);

  p = *pstrings;
  *p++ = '\0';
  for (h = info.strings; h != NULL; h = h->next)
    {
      strcpy (p, h->root.string);
      p += strlen (p) + 1;
    }
d925 1
a925 1
      if (index != 0 && ! info->type_stack->definition)
d927 4
a930 6
	  /* We have already defined a modification of this type, and
             the entry on the type stack is not a definition, so we
             can safely discard it (we may have a definition on the
             stack, even if we already defined a modification, if it
             is a struct which we did not define at the time it was
             referenced).  */
d1095 1
a1095 1
  if (high < low)
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1102 1
a1102 2
  sprintf (buf + strlen (buf), "ar%s;%ld;%ld;%s",
	   range, (long) low, (long) high, element);
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
d366 2
a367 2
	  non_fatal (_("string_hash_lookup failed: %s"),
		     bfd_errmsg (bfd_get_error ()));
d508 2
a509 2
      non_fatal ("bfd_hash_table_init_failed: %s",
		 bfd_errmsg (bfd_get_error ()));
d555 2
a556 2
      strcpy ((char *) p, h->root.string);
      p += strlen ((char *) p) + 1;
d666 1
a666 1
      non_fatal (_("stab_int_type: bad size %u"), size);
d918 1
a918 1
      if ((size_t) targindex >= *cache_alloc)
d925 1
a925 1
	  while ((size_t) targindex >= alloc)
d987 1
a987 1
     boolean varargs ATTRIBUTE_UNUSED;
d1467 3
a1469 2
	non_fatal (_("%s: warning: unknown size for field `%s' in struct"),
		   bfd_get_filename (info->abfd), name);
d1887 1
a1887 1
  unsigned int i = 0;
d2028 2
a2029 2
      non_fatal (_("string_hash_lookup failed: %s"),
		 bfd_errmsg (bfd_get_error ()));
d2176 1
a2176 1
      if (! isdigit ((unsigned char) *s))
d2386 1
a2386 1
     PTR p ATTRIBUTE_UNUSED;
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d26 1
a31 1
#include "safe-ctype.h"
d34 4
d78 1
a78 1
  bfd_boolean definition;
d180 1
a180 1
static bfd_boolean stab_write_symbol
d182 2
a183 2
static bfd_boolean stab_push_string
  PARAMS ((struct stab_write_handle *, const char *, long, bfd_boolean,
d185 1
a185 1
static bfd_boolean stab_push_defined_type
d187 2
a188 3
static char *stab_pop_type
  PARAMS ((struct stab_write_handle *));
static bfd_boolean stab_modify_type
d193 1
a193 1
static bfd_boolean stab_class_method_var
d195 11
a205 18
	   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean));
static bfd_boolean stab_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean stab_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean stab_empty_type
  PARAMS ((PTR));
static bfd_boolean stab_void_type
  PARAMS ((PTR));
static bfd_boolean stab_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean stab_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_bool_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_enum_type
d207 14
a220 23
static bfd_boolean stab_pointer_type
  PARAMS ((PTR));
static bfd_boolean stab_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean stab_reference_type
  PARAMS ((PTR));
static bfd_boolean stab_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static bfd_boolean stab_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean stab_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean stab_offset_type
  PARAMS ((PTR));
static bfd_boolean stab_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean stab_const_type
  PARAMS ((PTR));
static bfd_boolean stab_volatile_type
  PARAMS ((PTR));
static bfd_boolean stab_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
static bfd_boolean stab_struct_field
d222 5
a226 6
static bfd_boolean stab_end_struct_type
  PARAMS ((PTR));
static bfd_boolean stab_start_class_type
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
static bfd_boolean stab_class_static_member
d228 12
a239 17
static bfd_boolean stab_class_baseclass
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean stab_class_start_method
  PARAMS ((PTR, const char *));
static bfd_boolean stab_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
static bfd_boolean stab_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean stab_class_end_method
  PARAMS ((PTR));
static bfd_boolean stab_end_class_type
  PARAMS ((PTR));
static bfd_boolean stab_typedef_type
  PARAMS ((PTR, const char *));
static bfd_boolean stab_tag_type
d241 6
a246 11
static bfd_boolean stab_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean stab_tag
  PARAMS ((PTR, const char *));
static bfd_boolean stab_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean stab_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean stab_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean stab_variable
d248 2
a249 3
static bfd_boolean stab_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
static bfd_boolean stab_function_parameter
d251 4
a254 7
static bfd_boolean stab_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_function
  PARAMS ((PTR));
static bfd_boolean stab_lineno
d346 1
a346 1
static bfd_boolean
d363 1
a363 1
      h = string_hash_lookup (&info->strhash, string, TRUE, TRUE);
d368 1
a368 1
	  return FALSE;
d403 1
a403 1
  return TRUE;
d408 1
a408 1
static bfd_boolean
d413 1
a413 1
     bfd_boolean definition;
d432 1
a432 1
  return TRUE;
d437 1
a437 1
static bfd_boolean
d446 1
a446 1
  return stab_push_string (info, buf, index, FALSE, size);
d480 1
a480 1
bfd_boolean
d510 1
a510 1
      return FALSE;
d525 1
a525 1
    return FALSE;
d530 1
a530 1
    return FALSE;
d533 1
a533 1
    return FALSE;
d540 1
a540 1
    return FALSE;
d559 1
a559 1
  return TRUE;
d564 1
a564 1
static bfd_boolean
d583 1
a583 1
static bfd_boolean
d602 1
a602 1
static bfd_boolean
d623 1
a623 1
      return stab_push_string (info, buf, index, FALSE, 0);
d629 1
a629 1
static bfd_boolean
d649 1
a649 1
      return stab_push_string (info, buf, index, TRUE, 0);
d655 1
a655 1
static bfd_boolean
d659 1
a659 1
     bfd_boolean unsignedp;
d667 1
a667 1
      return FALSE;
d712 1
a712 1
      return stab_push_string (info, buf, index, TRUE, size);
d718 1
a718 1
static bfd_boolean
d739 2
a740 2
      if (! stab_int_type (info, 4, FALSE))
	return FALSE;
d755 1
a755 1
      return stab_push_string (info, buf, index, TRUE, size);
d761 1
a761 1
static bfd_boolean
d775 1
a775 1
  return stab_push_string (info, buf, index, TRUE, size * 2);
d778 1
a778 1
/* Push a bfd_boolean type.  We use an XCOFF predefined type, since gdb
d781 1
a781 1
static bfd_boolean
d798 1
a798 1

d814 1
a814 1
static bfd_boolean
d835 2
a836 2
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
d838 1
a838 1
      return TRUE;
d865 2
a866 2
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
d873 1
a873 1
	return FALSE;
d878 1
a878 1
  return TRUE;
d884 1
a884 1
static bfd_boolean
d902 1
a902 1
      bfd_boolean definition;
d913 1
a913 1
	return FALSE;
d944 1
a944 1
	    return FALSE;
d958 2
a959 2
	  if (! stab_push_string (info, buf, index, TRUE, size))
	    return FALSE;
d965 2
a966 2
  return TRUE;
}
d970 1
a970 1
static bfd_boolean
d983 1
a983 1
static bfd_boolean
d987 1
a987 1
     bfd_boolean varargs ATTRIBUTE_UNUSED;
d1010 1
a1010 1
	    return FALSE;
d1022 1
a1022 1
static bfd_boolean
d1035 1
a1035 1
static bfd_boolean
d1042 1
a1042 1
  bfd_boolean definition;
d1055 1
a1055 1
    return FALSE;
d1059 1
a1059 1
  return TRUE;
d1064 1
a1064 1
static bfd_boolean
d1069 1
a1069 1
     bfd_boolean stringp;
d1072 1
a1072 1
  bfd_boolean definition;
d1098 1
a1098 1
      definition = TRUE;
d1112 1
a1112 1
    return FALSE;
d1116 1
a1116 1
  return TRUE;
d1121 1
a1121 1
static bfd_boolean
d1124 1
a1124 1
     bfd_boolean bitstringp;
d1127 1
a1127 1
  bfd_boolean definition;
d1147 1
a1147 1
      definition = TRUE;
d1155 1
a1155 1
    return FALSE;
d1159 1
a1159 1
  return TRUE;
d1164 1
a1164 1
static bfd_boolean
d1169 1
a1169 1
  bfd_boolean definition;
d1184 1
a1184 1
    return FALSE;
d1188 1
a1188 1
  return TRUE;
d1193 1
a1193 1
static bfd_boolean
d1196 1
a1196 1
     bfd_boolean domainp;
d1198 1
a1198 1
     bfd_boolean varargs;
d1201 1
a1201 1
  bfd_boolean definition;
d1216 1
a1216 1
	return FALSE;
d1238 1
a1238 1
	    return FALSE;
d1255 1
a1255 1
	    return FALSE;
d1286 1
a1286 1
    return FALSE;
d1290 1
a1290 1
  return TRUE;
d1295 1
a1295 1
static bfd_boolean
d1307 1
a1307 1
static bfd_boolean
d1371 2
a1372 1
static bfd_boolean
d1377 1
a1377 1
     bfd_boolean structp;
d1382 1
a1382 1
  bfd_boolean definition;
d1391 1
a1391 1
      definition = FALSE;
d1398 1
a1398 1
	return FALSE;
d1400 1
a1400 1
      definition = TRUE;
d1408 1
a1408 1
    return FALSE;
d1413 1
a1413 1
  return TRUE;
d1418 1
a1418 1
static bfd_boolean
d1427 1
a1427 1
  bfd_boolean definition;
d1478 1
a1478 1
    info->type_stack->definition = TRUE;
d1480 1
a1480 1
  return TRUE;
d1485 1
a1485 1
static bfd_boolean
d1490 1
a1490 1
  bfd_boolean definition;
d1509 1
a1509 1
    return FALSE;
d1513 1
a1513 1
  return TRUE;
d1518 1
a1518 1
static bfd_boolean
d1523 1
a1523 1
     bfd_boolean structp;
d1525 2
a1526 2
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1529 1
a1529 1
  bfd_boolean definition;
d1534 1
a1534 1
      definition = FALSE;
d1544 1
a1544 1
    return FALSE;
d1567 1
a1567 1
    info->type_stack->definition = TRUE;
d1569 1
a1569 1
  return TRUE;
d1574 1
a1574 1
static bfd_boolean
d1582 1
a1582 1
  bfd_boolean definition;
d1624 1
a1624 1
    info->type_stack->definition = TRUE;
d1626 1
a1626 1
  return TRUE;
d1631 1
a1631 1
static bfd_boolean
d1635 1
a1635 1
     bfd_boolean virtual;
d1639 1
a1639 1
  bfd_boolean definition;
d1694 1
a1694 1
    info->type_stack->definition = TRUE;
d1696 1
a1696 1
  return TRUE;
d1701 1
a1701 1
static bfd_boolean
d1728 1
a1728 1
  return TRUE;
d1733 1
a1733 1
static bfd_boolean
d1739 3
a1741 3
     bfd_boolean staticp;
     bfd_boolean constp;
     bfd_boolean volatilep;
d1743 1
a1743 1
     bfd_boolean contextp;
d1745 1
a1745 1
  bfd_boolean definition;
d1821 1
a1821 1
    info->type_stack->definition = TRUE;
d1823 1
a1823 1
  return TRUE;
d1828 1
a1828 1
static bfd_boolean
d1834 2
a1835 2
     bfd_boolean constp;
     bfd_boolean volatilep;
d1837 1
a1837 1
     bfd_boolean contextp;
d1841 1
a1841 1
  return stab_class_method_var (info, physname, visibility, FALSE, constp,
d1847 1
a1847 1
static bfd_boolean
d1852 2
a1853 2
     bfd_boolean constp;
     bfd_boolean volatilep;
d1857 2
a1858 2
  return stab_class_method_var (info, physname, visibility, TRUE, constp,
				volatilep, 0, FALSE);
d1863 1
a1863 1
static bfd_boolean
d1875 1
a1875 1
  return TRUE;
d1880 1
a1880 1
static bfd_boolean
d1950 1
a1950 1
  return TRUE;
d1955 1
a1955 1
static bfd_boolean
d1963 1
a1963 1
  h = string_hash_lookup (&info->typedef_hash, name, FALSE, FALSE);
d1971 1
a1971 1
static bfd_boolean
d1984 1
a1984 1
    return FALSE;
d1991 1
a1991 1
static bfd_boolean
d2020 1
a2020 1
    return FALSE;
d2024 1
a2024 1
  h = string_hash_lookup (&info->typedef_hash, name, TRUE, FALSE);
d2029 1
a2029 1
      return FALSE;
d2037 1
a2037 1
  return TRUE;
d2042 1
a2042 1
static bfd_boolean
d2058 1
a2058 1
    return FALSE;
d2062 1
a2062 1
  return TRUE;
d2067 1
a2067 1
static bfd_boolean
d2080 1
a2080 1
    return FALSE;
d2084 1
a2084 1
  return TRUE;
d2089 1
a2089 1
static bfd_boolean
d2102 1
a2102 1
    return FALSE;
d2106 1
a2106 1
  return TRUE;
d2111 1
a2111 1
static bfd_boolean
d2127 1
a2127 1
    return FALSE;
d2131 1
a2131 1
  return TRUE;
d2136 1
a2136 1
static bfd_boolean
d2175 1
a2175 1
      if (! ISDIGIT (*s))
d2200 1
a2200 1
    return FALSE;
d2204 1
a2204 1
  return TRUE;
d2209 1
a2209 1
static bfd_boolean
d2213 1
a2213 1
     bfd_boolean globalp;
d2231 1
a2231 1
    return FALSE;
d2235 1
a2235 1
  return TRUE;
d2240 1
a2240 1
static bfd_boolean
d2285 1
a2285 1
    return FALSE;
d2289 1
a2289 1
  return TRUE;
d2294 1
a2294 1
static bfd_boolean
d2325 1
a2325 1
      return TRUE;
d2337 1
a2337 1
	return FALSE;
d2344 1
a2344 1
  return TRUE;
d2349 1
a2349 1
static bfd_boolean
d2364 1
a2364 1
	return FALSE;
d2374 1
a2374 1
    return TRUE;
d2382 2
a2383 1
static bfd_boolean
d2387 1
a2387 1
  return TRUE;
d2392 1
a2392 1
static bfd_boolean
d2409 1
a2409 1
	return FALSE;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d176 1
a176 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d178 1
a178 1
  (struct stab_write_handle *, int, int, bfd_vma, const char *);
d180 2
a181 1
  (struct stab_write_handle *, const char *, long, bfd_boolean, unsigned int);
d183 3
a185 2
  (struct stab_write_handle *, long, unsigned int);
static char *stab_pop_type (struct stab_write_handle *);
d187 1
a187 1
  (struct stab_write_handle *, int, unsigned int, long **, size_t *);
d189 2
a190 2
  (struct stab_write_handle *, const char *, unsigned int,
   enum debug_type_kind, unsigned int *);
d192 18
a209 10
  (struct stab_write_handle *, const char *, enum debug_visibility,
   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean stab_start_compilation_unit (void *, const char *);
static bfd_boolean stab_start_source (void *, const char *);
static bfd_boolean stab_empty_type (void *);
static bfd_boolean stab_void_type (void *);
static bfd_boolean stab_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean stab_float_type (void *, unsigned int);
static bfd_boolean stab_complex_type (void *, unsigned int);
static bfd_boolean stab_bool_type (void *, unsigned int);
d211 9
a219 5
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean stab_pointer_type (void *);
static bfd_boolean stab_function_type (void *, int, bfd_boolean);
static bfd_boolean stab_reference_type (void *);
static bfd_boolean stab_range_type (void *, bfd_signed_vma, bfd_signed_vma);
d221 11
a231 6
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean stab_set_type (void *, bfd_boolean);
static bfd_boolean stab_offset_type (void *);
static bfd_boolean stab_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean stab_const_type (void *);
static bfd_boolean stab_volatile_type (void *);
d233 1
a233 1
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
d235 3
a237 2
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean stab_end_struct_type (void *);
d239 2
a240 2
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
d242 1
a242 1
  (void *, const char *, const char *, enum debug_visibility);
d244 3
a246 2
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean stab_class_start_method (void *, const char *);
d248 2
a249 2
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
d251 8
a258 4
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean stab_class_end_method (void *);
static bfd_boolean stab_end_class_type (void *);
static bfd_boolean stab_typedef_type (void *, const char *);
d260 11
a270 6
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean stab_typdef (void *, const char *);
static bfd_boolean stab_tag (void *, const char *);
static bfd_boolean stab_int_constant (void *, const char *, bfd_vma);
static bfd_boolean stab_float_constant (void *, const char *, double);
static bfd_boolean stab_typed_constant (void *, const char *, bfd_vma);
d272 3
a274 2
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean stab_start_function (void *, const char *, bfd_boolean);
d276 9
a284 5
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean stab_start_block (void *, bfd_vma);
static bfd_boolean stab_end_block (void *, bfd_vma);
static bfd_boolean stab_end_function (void *);
static bfd_boolean stab_lineno (void *, const char *, unsigned long, bfd_vma);
d337 4
a340 2
string_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table, const char *string)
d376 6
a381 2
stab_write_symbol (struct stab_write_handle *info, int type, int desc,
		   bfd_vma value, const char *string)
d438 6
a443 2
stab_push_string (struct stab_write_handle *info, const char *string,
		  long index, bfd_boolean definition, unsigned int size)
d467 4
a470 2
stab_push_defined_type (struct stab_write_handle *info, long index,
			unsigned int size)
d482 2
a483 1
stab_pop_type (struct stab_write_handle *info)
d510 8
a517 5
write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,
					bfd_byte **psyms,
					bfd_size_type *psymsize,
					bfd_byte **pstrings,
					bfd_size_type *pstringsize)
d561 1
a561 1
  if (! debug_write (dhandle, &stab_fns, (void *) &info))
d594 3
a596 1
stab_start_compilation_unit (void *p, const char *filename)
d613 3
a615 1
stab_start_source (void *p, const char *filename)
d632 2
a633 1
stab_empty_type (void *p)
d659 2
a660 1
stab_void_type (void *p)
d685 4
a688 1
stab_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
d748 3
a750 1
stab_float_type (void *p, unsigned int size)
d791 3
a793 1
stab_complex_type (void *p, unsigned int size)
d811 3
a813 1
stab_bool_type (void *p, unsigned int size)
d844 5
a848 2
stab_enum_type (void *p, const char *tag, const char **names,
		bfd_signed_vma *vals)
d914 6
a919 2
stab_modify_type (struct stab_write_handle *info, int mod,
		  unsigned int size, long **cache, size_t *cache_alloc)
d1000 2
a1001 1
stab_pointer_type (void *p)
d1013 4
a1016 2
stab_function_type (void *p, int argcount,
		    bfd_boolean varargs ATTRIBUTE_UNUSED)
d1052 2
a1053 1
stab_reference_type (void *p)
d1065 4
a1068 1
stab_range_type (void *p, bfd_signed_vma low, bfd_signed_vma high)
d1094 5
a1098 2
stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,
		 bfd_boolean stringp)
d1151 3
a1153 1
stab_set_type (void *p, bfd_boolean bitstringp)
d1194 2
a1195 1
stab_offset_type (void *p)
d1223 5
a1227 2
stab_method_type (void *p, bfd_boolean domainp, int argcount,
		  bfd_boolean varargs)
d1325 2
a1326 1
stab_const_type (void *p)
d1337 2
a1338 1
stab_volatile_type (void *p)
d1350 6
a1355 3
stab_get_struct_index (struct stab_write_handle *info, const char *tag,
		       unsigned int id, enum debug_type_kind kind,
		       unsigned int *psize)
d1401 6
a1406 2
stab_start_struct_type (void *p, const char *tag, unsigned int id,
			bfd_boolean structp, unsigned int size)
d1447 6
a1452 2
stab_struct_field (void *p, const char *name, bfd_vma bitpos,
		   bfd_vma bitsize, enum debug_visibility visibility)
d1514 2
a1515 1
stab_end_struct_type (void *p)
d1547 8
a1554 1
stab_start_class_type (void *p, const char *tag, unsigned int id, bfd_boolean structp, unsigned int size, bfd_boolean vptr, bfd_boolean ownvptr)
d1603 5
a1607 2
stab_class_static_member (void *p, const char *name, const char *physname,
			  enum debug_visibility visibility)
d1660 5
a1664 2
stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
		      enum debug_visibility visibility)
d1730 3
a1732 1
stab_class_start_method (void *p, const char *name)
d1762 10
a1771 5
stab_class_method_var (struct stab_write_handle *info, const char *physname,
		       enum debug_visibility visibility,
		       bfd_boolean staticp, bfd_boolean constp,
		       bfd_boolean volatilep, bfd_vma voffset,
		       bfd_boolean contextp)
d1857 9
a1865 4
stab_class_method_variant (void *p, const char *physname,
			   enum debug_visibility visibility,
			   bfd_boolean constp, bfd_boolean volatilep,
			   bfd_vma voffset, bfd_boolean contextp)
d1876 6
a1881 3
stab_class_static_method_variant (void *p, const char *physname,
				  enum debug_visibility visibility,
				  bfd_boolean constp, bfd_boolean volatilep)
d1892 2
a1893 1
stab_class_end_method (void *p)
d1909 2
a1910 1
stab_end_class_type (void *p)
d1984 3
a1986 1
stab_typedef_type (void *p, const char *name)
d2000 5
a2004 2
stab_tag_type (void *p, const char *name, unsigned int id,
	       enum debug_type_kind kind)
d2020 3
a2022 1
stab_typdef (void *p, const char *name)
d2071 3
a2073 1
stab_tag (void *p, const char *tag)
d2096 4
a2099 1
stab_int_constant (void *p, const char *name, bfd_vma val)
d2118 4
a2121 1
stab_float_constant (void *p, const char *name, double val)
d2140 4
a2143 1
stab_typed_constant (void *p, const char *name, bfd_vma val)
d2165 5
a2169 2
stab_variable (void *p, const char *name, enum debug_var_kind kind,
	       bfd_vma val)
d2238 4
a2241 1
stab_start_function (void *p, const char *name, bfd_boolean globalp)
d2269 5
a2273 1
stab_function_parameter (void *p, const char *name, enum debug_parm_kind kind, bfd_vma val)
d2323 3
a2325 1
stab_start_block (void *p, bfd_vma addr)
d2378 3
a2380 1
stab_end_block (void *p, bfd_vma addr)
d2411 2
a2412 1
stab_end_function (void *p ATTRIBUTE_UNUSED)
d2420 5
a2424 1
stab_lineno (void *p, const char *file, unsigned long lineno, bfd_vma addr)
@


