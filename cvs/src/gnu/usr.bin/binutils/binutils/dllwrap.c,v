head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.10
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.5;
commitid	dbwlUkpK0xDlII16;

1.5
date	2004.11.02.20.45.17;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.22.41.58;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.12.14.45.05;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.45.05;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.15.02;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.04;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.02;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* dllwrap.c -- wrapper for DLLTOOL and GCC to generate PE style DLLs
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
   Contributed by Mumit Khan (khan@@xraylith.wisc.edu).

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "bfd.h"
#include "libiberty.h"
#include "bucomm.h"
#include "getopt.h"
#include "dyn-string.h"

#include <time.h>
#include <sys/stat.h>

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN32__)
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w)&0377) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0177)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) >> 8) & 0377)
#endif
#else /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#endif /* ! HAVE_SYS_WAIT_H */

static char *driver_name = NULL;
static char *cygwin_driver_flags =
  "-Wl,--dll -nostartfiles";
static char *mingw32_driver_flags = "-mdll";
static char *generic_driver_flags = "-Wl,--dll";

static char *entry_point;

static char *dlltool_name = NULL;

static char *target = TARGET;

typedef enum {
  UNKNOWN_TARGET,
  CYGWIN_TARGET,
  MINGW_TARGET
}
target_type;

static target_type which_target = UNKNOWN_TARGET;

static int dontdeltemps = 0;
static int dry_run = 0;

static char *program_name;

static int verbose = 0;

static char *dll_file_name;
static char *dll_name;
static char *base_file_name;
static char *exp_file_name;
static char *def_file_name;
static int delete_base_file = 1;
static int delete_exp_file = 1;
static int delete_def_file = 1;

static int run (const char *, char *);
static char *mybasename (const char *);
static int strhash (const char *);
static void usage (FILE *, int);
static void display (const char *, va_list);
static void inform (const char *, ...);
static void warn (const char *, ...);
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);
static void delete_temp_files (void);
static void cleanup_and_exit (int);

/**********************************************************************/

/* Please keep the following 4 routines in sync with dlltool.c:
     display ()
     inform ()
     look_for_prog ()
     deduce_name ()
   It's not worth the hassle to break these out since dllwrap will
   (hopefully) soon be retired in favor of `ld --shared.  */

static void
display (const char * message, va_list args)
{
  if (program_name != NULL)
    fprintf (stderr, "%s: ", program_name);

  vfprintf (stderr, message, args);
  fputc ('\n', stderr);
}


static void
inform VPARAMS ((const char *message, ...))
{
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

  if (!verbose)
    return;

  display (message, args);

  VA_CLOSE (args);
}

static void
warn VPARAMS ((const char *format, ...))
{
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);

  display (format, args);

  VA_CLOSE (args);
}

/* Look for the program formed by concatenating PROG_NAME and the
   string running from PREFIX to END_PREFIX.  If the concatenated
   string contains a '/', try appending EXECUTABLE_SUFFIX if it is
   appropriate.  */

static char *
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
{
  struct stat s;
  char *cmd;

  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
#ifdef HAVE_EXECUTABLE_SUFFIX
		 + strlen (EXECUTABLE_SUFFIX)
#endif
		 + 10);
  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", prog_name);

  if (strchr (cmd, '/') != NULL)
    {
      int found;

      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
	{
	  /* xgettext:c-format */
	  inform (_("Tried file: %s"), cmd);
	  free (cmd);
	  return NULL;
	}
    }

  /* xgettext:c-format */
  inform (_("Using file: %s"), cmd);

  return cmd;
}

/* Deduce the name of the program we are want to invoke.
   PROG_NAME is the basic name of the program we want to run,
   eg "as" or "ld".  The catch is that we might want actually
   run "i386-pe-as" or "ppc-pe-ld".

   If argv[0] contains the full path, then try to find the program
   in the same place, with and then without a target-like prefix.

   Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,
   deduce_name("as") uses the following search order:

     /usr/local/bin/i586-cygwin32-as
     /usr/local/bin/as
     as

   If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each
   name, it'll try without and then with EXECUTABLE_SUFFIX.

   Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"
   as the fallback, but rather return i586-cygwin32-as.

   Oh, and given, argv[0] = dlltool, it'll return "as".

   Returns a dynamically allocated string.  */

static char *
deduce_name (const char *prog_name)
{
  char *cmd;
  char *dash, *slash, *cp;

  dash = NULL;
  slash = NULL;
  for (cp = program_name; *cp != '\0'; ++cp)
    {
      if (*cp == '-')
	dash = cp;
      if (
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
	  *cp == ':' || *cp == '\\' ||
#endif
	  *cp == '/')
	{
	  slash = cp;
	  dash = NULL;
	}
    }

  cmd = NULL;

  if (dash != NULL)
    {
      /* First, try looking for a prefixed PROG_NAME in the
         PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
      cmd = look_for_prog (prog_name, program_name, dash - program_name + 1);
    }

  if (slash != NULL && cmd == NULL)
    {
      /* Next, try looking for a PROG_NAME in the same directory as
         that of this program.  */
      cmd = look_for_prog (prog_name, program_name, slash - program_name + 1);
    }

  if (cmd == NULL)
    {
      /* Just return PROG_NAME as is.  */
      cmd = xstrdup (prog_name);
    }

  return cmd;
}

static void
delete_temp_files (void)
{
  if (delete_base_file && base_file_name)
    {
      if (verbose)
	{
	  if (dontdeltemps)
	    warn (_("Keeping temporary base file %s"), base_file_name);
	  else
	    warn (_("Deleting temporary base file %s"), base_file_name);
	}
      if (! dontdeltemps)
	{
	  unlink (base_file_name);
	  free (base_file_name);
	}
    }

  if (delete_exp_file && exp_file_name)
    {
      if (verbose)
	{
	  if (dontdeltemps)
	    warn (_("Keeping temporary exp file %s"), exp_file_name);
	  else
	    warn (_("Deleting temporary exp file %s"), exp_file_name);
	}
      if (! dontdeltemps)
	{
	  unlink (exp_file_name);
	  free (exp_file_name);
	}
    }
  if (delete_def_file && def_file_name)
    {
      if (verbose)
	{
	  if (dontdeltemps)
	    warn (_("Keeping temporary def file %s"), def_file_name);
	  else
	    warn (_("Deleting temporary def file %s"), def_file_name);
	}
      if (! dontdeltemps)
	{
	  unlink (def_file_name);
	  free (def_file_name);
	}
    }
}

static void
cleanup_and_exit (int status)
{
  delete_temp_files ();
  exit (status);
}

static int
run (const char *what, char *args)
{
  char *s;
  int pid, wait_status, retcode;
  int i;
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
#if defined(__MSDOS__) && !defined(__GO32__)
  char *temp_base = choose_temp_base ();
#else
  char *temp_base = NULL;
#endif
  int in_quote;
  char sep;

  if (verbose || dry_run)
    fprintf (stderr, "%s %s\n", what, args);

  /* Count the args */
  i = 0;
  for (s = args; *s; s++)
    if (*s == ' ')
      i++;
  i++;
  argv = alloca (sizeof (char *) * (i + 3));
  i = 0;
  argv[i++] = what;
  s = args;
  while (1)
    {
      while (*s == ' ' && *s != 0)
	s++;
      if (*s == 0)
	break;
      in_quote = (*s == '\'' || *s == '"');
      sep = (in_quote) ? *s++ : ' ';
      argv[i++] = s;
      while (*s != sep && *s != 0)
	s++;
      if (*s == 0)
	break;
      *s++ = 0;
      if (in_quote)
	s++;
    }
  argv[i++] = NULL;

  if (dry_run)
    return 0;

  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);

  if (pid == -1)
    {
      int errno_val = errno;

      fprintf (stderr, "%s: ", program_name);
      fprintf (stderr, errmsg_fmt, errmsg_arg);
      fprintf (stderr, ": %s\n", strerror (errno_val));
      return 1;
    }

  retcode = 0;
  pid = pwait (pid, &wait_status, 0);
  if (pid == -1)
    {
      warn ("wait: %s", strerror (errno));
      retcode = 1;
    }
  else if (WIFSIGNALED (wait_status))
    {
      warn (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
      retcode = 1;
    }
  else if (WIFEXITED (wait_status))
    {
      if (WEXITSTATUS (wait_status) != 0)
	{
	  warn (_("%s exited with status %d"), what, WEXITSTATUS (wait_status));
	  retcode = 1;
	}
    }
  else
    retcode = 1;

  return retcode;
}

static char *
mybasename (const char *name)
{
  const char *base = name;

  while (*name)
    {
      if (*name == '/' || *name == '\\')
	{
	  base = name + 1;
	}
      ++name;
    }
  return (char *) base;
}

static int
strhash (const char *str)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  unsigned int len;

  hash = 0;
  len = 0;
  s = (const unsigned char *) str;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  return hash;
}

/**********************************************************************/

static void
usage (FILE *file, int status)
{
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
  fprintf (file, _("  Generic options:\n"));
  fprintf (file, _("   --quiet, -q            Work quietly\n"));
  fprintf (file, _("   --verbose, -v          Verbose\n"));
  fprintf (file, _("   --version              Print dllwrap version\n"));
  fprintf (file, _("   --implib <outname>     Synonym for --output-lib\n"));
  fprintf (file, _("  Options for %s:\n"), program_name);
  fprintf (file, _("   --driver-name <driver> Defaults to \"gcc\"\n"));
  fprintf (file, _("   --driver-flags <flags> Override default ld flags\n"));
  fprintf (file, _("   --dlltool-name <dlltool> Defaults to \"dlltool\"\n"));
  fprintf (file, _("   --entry <entry>        Specify alternate DLL entry point\n"));
  fprintf (file, _("   --image-base <base>    Specify image base address\n"));
  fprintf (file, _("   --target <machine>     i386-cygwin32 or i386-mingw32\n"));
  fprintf (file, _("   --dry-run              Show what needs to be run\n"));
  fprintf (file, _("   --mno-cygwin           Create Mingw DLL\n"));
  fprintf (file, _("  Options passed to DLLTOOL:\n"));
  fprintf (file, _("   --machine <machine>\n"));
  fprintf (file, _("   --output-exp <outname> Generate export file.\n"));
  fprintf (file, _("   --output-lib <outname> Generate input library.\n"));
  fprintf (file, _("   --add-indirect         Add dll indirects to export file.\n"));
  fprintf (file, _("   --dllname <name>       Name of input dll to put into output lib.\n"));
  fprintf (file, _("   --def <deffile>        Name input .def file\n"));
  fprintf (file, _("   --output-def <deffile> Name output .def file\n"));
  fprintf (file, _("   --export-all-symbols     Export all symbols to .def\n"));
  fprintf (file, _("   --no-export-all-symbols  Only export .drectve symbols\n"));
  fprintf (file, _("   --exclude-symbols <list> Exclude <list> from .def\n"));
  fprintf (file, _("   --no-default-excludes    Zap default exclude symbols\n"));
  fprintf (file, _("   --base-file <basefile> Read linker generated base file\n"));
  fprintf (file, _("   --no-idata4           Don't generate idata$4 section\n"));
  fprintf (file, _("   --no-idata5           Don't generate idata$5 section\n"));
  fprintf (file, _("   -U                     Add underscores to .lib\n"));
  fprintf (file, _("   -k                     Kill @@<n> from exported names\n"));
  fprintf (file, _("   --add-stdcall-alias    Add aliases without @@<n>\n"));
  fprintf (file, _("   --as <name>            Use <name> for assembler\n"));
  fprintf (file, _("   --nodelete             Keep temp files.\n"));
  fprintf (file, _("  Rest are passed unmodified to the language driver\n"));
  fprintf (file, "\n\n");
  exit (status);
}

#define OPTION_START		149

/* GENERIC options.  */
#define OPTION_QUIET		(OPTION_START + 1)
#define OPTION_VERBOSE		(OPTION_QUIET + 1)
#define OPTION_VERSION		(OPTION_VERBOSE + 1)

/* DLLWRAP options.  */
#define OPTION_DRY_RUN		(OPTION_VERSION + 1)
#define OPTION_DRIVER_NAME	(OPTION_DRY_RUN + 1)
#define OPTION_DRIVER_FLAGS	(OPTION_DRIVER_NAME + 1)
#define OPTION_DLLTOOL_NAME	(OPTION_DRIVER_FLAGS + 1)
#define OPTION_ENTRY		(OPTION_DLLTOOL_NAME + 1)
#define OPTION_IMAGE_BASE	(OPTION_ENTRY + 1)
#define OPTION_TARGET		(OPTION_IMAGE_BASE + 1)
#define OPTION_MNO_CYGWIN	(OPTION_TARGET + 1)

/* DLLTOOL options.  */
#define OPTION_NODELETE		(OPTION_MNO_CYGWIN + 1)
#define OPTION_DLLNAME		(OPTION_NODELETE + 1)
#define OPTION_NO_IDATA4	(OPTION_DLLNAME + 1)
#define OPTION_NO_IDATA5	(OPTION_NO_IDATA4 + 1)
#define OPTION_OUTPUT_EXP	(OPTION_NO_IDATA5 + 1)
#define OPTION_OUTPUT_DEF	(OPTION_OUTPUT_EXP + 1)
#define OPTION_EXPORT_ALL_SYMS	(OPTION_OUTPUT_DEF + 1)
#define OPTION_NO_EXPORT_ALL_SYMS (OPTION_EXPORT_ALL_SYMS + 1)
#define OPTION_EXCLUDE_SYMS	(OPTION_NO_EXPORT_ALL_SYMS + 1)
#define OPTION_NO_DEFAULT_EXCLUDES (OPTION_EXCLUDE_SYMS + 1)
#define OPTION_OUTPUT_LIB	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DEF		(OPTION_OUTPUT_LIB + 1)
#define OPTION_ADD_UNDERSCORE	(OPTION_DEF + 1)
#define OPTION_KILLAT		(OPTION_ADD_UNDERSCORE + 1)
#define OPTION_HELP		(OPTION_KILLAT + 1)
#define OPTION_MACHINE		(OPTION_HELP + 1)
#define OPTION_ADD_INDIRECT	(OPTION_MACHINE + 1)
#define OPTION_BASE_FILE	(OPTION_ADD_INDIRECT + 1)
#define OPTION_AS		(OPTION_BASE_FILE + 1)

static const struct option long_options[] =
{
  /* generic options.  */
  {"quiet", no_argument, NULL, 'q'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, OPTION_VERSION},
  {"implib", required_argument, NULL, OPTION_OUTPUT_LIB},

  /* dllwrap options.  */
  {"dry-run", no_argument, NULL, OPTION_DRY_RUN},
  {"driver-name", required_argument, NULL, OPTION_DRIVER_NAME},
  {"driver-flags", required_argument, NULL, OPTION_DRIVER_FLAGS},
  {"dlltool-name", required_argument, NULL, OPTION_DLLTOOL_NAME},
  {"entry", required_argument, NULL, 'e'},
  {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
  {"target", required_argument, NULL, OPTION_TARGET},

  /* dlltool options.  */
  {"no-delete", no_argument, NULL, 'n'},
  {"dllname", required_argument, NULL, OPTION_DLLNAME},
  {"no-idata4", no_argument, NULL, OPTION_NO_IDATA4},
  {"no-idata5", no_argument, NULL, OPTION_NO_IDATA5},
  {"output-exp", required_argument, NULL, OPTION_OUTPUT_EXP},
  {"output-def", required_argument, NULL, OPTION_OUTPUT_DEF},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL_SYMS},
  {"no-export-all-symbols", no_argument, NULL, OPTION_NO_EXPORT_ALL_SYMS},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMS},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
  {"output-lib", required_argument, NULL, OPTION_OUTPUT_LIB},
  {"def", required_argument, NULL, OPTION_DEF},
  {"add-underscore", no_argument, NULL, 'U'},
  {"killat", no_argument, NULL, 'k'},
  {"add-stdcall-alias", no_argument, NULL, 'A'},
  {"help", no_argument, NULL, 'h'},
  {"machine", required_argument, NULL, OPTION_MACHINE},
  {"add-indirect", no_argument, NULL, OPTION_ADD_INDIRECT},
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
  {"as", required_argument, NULL, OPTION_AS},
  {0, 0, 0, 0}
};

int main (int, char **);

int
main (int argc, char **argv)
{
  int c;
  int i;

  char **saved_argv = 0;
  int cmdline_len = 0;

  int export_all = 0;

  int *dlltool_arg_indices;
  int *driver_arg_indices;

  char *driver_flags = 0;
  char *output_lib_file_name = 0;

  dyn_string_t dlltool_cmdline;
  dyn_string_t driver_cmdline;

  int def_file_seen = 0;

  char *image_base_str = 0;

  program_name = argv[0];

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  expandargv (&argc, &argv);

  saved_argv = (char **) xmalloc (argc * sizeof (char*));
  dlltool_arg_indices = (int *) xmalloc (argc * sizeof (int));
  driver_arg_indices = (int *) xmalloc (argc * sizeof (int));
  for (i = 0; i < argc; ++i)
    {
      size_t len = strlen (argv[i]);
      char *arg = (char *) xmalloc (len + 1);
      strcpy (arg, argv[i]);
      cmdline_len += len;
      saved_argv[i] = arg;
      dlltool_arg_indices[i] = 0;
      driver_arg_indices[i] = 1;
    }
  cmdline_len++;

  /* We recognize dllwrap and dlltool options, and everything else is
     passed onto the language driver (eg., to GCC). We collect options
     to dlltool and driver in dlltool_args and driver_args.  */

  opterr = 0;
  while ((c = getopt_long_only (argc, argv, "nkAqve:Uho:l:L:I:",
				long_options, (int *) 0)) != EOF)
    {
      int dlltool_arg;
      int driver_arg;
      int single_word_option_value_pair;

      dlltool_arg = 0;
      driver_arg = 1;
      single_word_option_value_pair = 0;

      if (c != '?')
	{
	  /* We recognize this option, so it has to be either dllwrap or
	     dlltool option. Do not pass to driver unless it's one of the
	     generic options that are passed to all the tools (such as -v)
	     which are dealt with later.  */
	  driver_arg = 0;
	}

      /* deal with generic and dllwrap options first.  */
      switch (c)
	{
	case 'h':
	  usage (stdout, 0);
	  break;
	case 'q':
	  verbose = 0;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case OPTION_VERSION:
	  print_version (program_name);
	  break;
	case 'e':
	  entry_point = optarg;
	  break;
	case OPTION_IMAGE_BASE:
	  image_base_str = optarg;
	  break;
	case OPTION_DEF:
	  def_file_name = optarg;
	  def_file_seen = 1;
	  delete_def_file = 0;
	  break;
	case 'n':
	  dontdeltemps = 1;
	  dlltool_arg = 1;
	  break;
	case 'o':
	  dll_file_name = optarg;
	  break;
	case 'I':
	case 'l':
	case 'L':
	  driver_arg = 1;
	  break;
	case OPTION_DLLNAME:
	  dll_name = optarg;
	  break;
	case OPTION_DRY_RUN:
	  dry_run = 1;
	  break;
	case OPTION_DRIVER_NAME:
	  driver_name = optarg;
	  break;
	case OPTION_DRIVER_FLAGS:
	  driver_flags = optarg;
	  break;
	case OPTION_DLLTOOL_NAME:
	  dlltool_name = optarg;
	  break;
	case OPTION_TARGET:
	  target = optarg;
	  break;
	case OPTION_MNO_CYGWIN:
	  target = "i386-mingw32";
	  break;
	case OPTION_BASE_FILE:
	  base_file_name = optarg;
	  delete_base_file = 0;
	  break;
	case OPTION_OUTPUT_EXP:
	  exp_file_name = optarg;
	  delete_exp_file = 0;
	  break;
	case OPTION_EXPORT_ALL_SYMS:
	  export_all = 1;
	  break;
	case OPTION_OUTPUT_LIB:
	  output_lib_file_name = optarg;
	  break;
	case '?':
	  break;
	default:
	  dlltool_arg = 1;
	  break;
	}

      /* Handle passing through --option=value case.  */
      if (optarg
	  && saved_argv[optind-1][0] == '-'
	  && saved_argv[optind-1][1] == '-'
	  && strchr (saved_argv[optind-1], '='))
	single_word_option_value_pair = 1;

      if (dlltool_arg)
	{
	  dlltool_arg_indices[optind-1] = 1;
	  if (optarg && ! single_word_option_value_pair)
	    {
	      dlltool_arg_indices[optind-2] = 1;
	    }
	}

      if (! driver_arg)
	{
	  driver_arg_indices[optind-1] = 0;
	  if (optarg && ! single_word_option_value_pair)
	    {
	      driver_arg_indices[optind-2] = 0;
	    }
	}
    }

  /* sanity checks.  */
  if (! dll_name && ! dll_file_name)
    {
      warn (_("Must provide at least one of -o or --dllname options"));
      exit (1);
    }
  else if (! dll_name)
    {
      dll_name = xstrdup (mybasename (dll_file_name));
    }
  else if (! dll_file_name)
    {
      dll_file_name = xstrdup (dll_name);
    }

  /* Deduce driver-name and dlltool-name from our own.  */
  if (driver_name == NULL)
    driver_name = deduce_name ("gcc");

  if (dlltool_name == NULL)
    dlltool_name = deduce_name ("dlltool");

  if (! def_file_seen)
    {
      def_file_name = make_temp_file (".def");
      if (dontdeltemps)
       def_file_name = mybasename (def_file_name);
      delete_def_file = 1;
      warn (_("no export definition file provided.\n\
Creating one, but that may not be what you want"));
    }

  /* set the target platform.  */
  if (strstr (target, "cygwin"))
    which_target = CYGWIN_TARGET;
  else if (strstr (target, "mingw"))
    which_target = MINGW_TARGET;
  else
    which_target = UNKNOWN_TARGET;

  /* re-create the command lines as a string, taking care to quote stuff.  */
  dlltool_cmdline = dyn_string_new (cmdline_len);
  if (verbose)
    {
      dyn_string_append_cstr (dlltool_cmdline, " -v");
    }
  dyn_string_append_cstr (dlltool_cmdline, " --dllname ");
  dyn_string_append_cstr (dlltool_cmdline, dll_name);

  for (i = 1; i < argc; ++i)
    {
      if (dlltool_arg_indices[i])
	{
	  char *arg = saved_argv[i];
	  int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (dlltool_cmdline,
	                     (quote) ? " \"" : " ");
	  dyn_string_append_cstr (dlltool_cmdline, arg);
	  dyn_string_append_cstr (dlltool_cmdline,
	                     (quote) ? "\"" : "");
	}
    }

  driver_cmdline = dyn_string_new (cmdline_len);
  if (! driver_flags || strlen (driver_flags) == 0)
    {
      switch (which_target)
	{
	case CYGWIN_TARGET:
	  driver_flags = cygwin_driver_flags;
	  break;

	case MINGW_TARGET:
	  driver_flags = mingw32_driver_flags;
	  break;

	default:
	  driver_flags = generic_driver_flags;
	  break;
	}
    }
  dyn_string_append_cstr (driver_cmdline, driver_flags);
  dyn_string_append_cstr (driver_cmdline, " -o ");
  dyn_string_append_cstr (driver_cmdline, dll_file_name);

  if (! entry_point || strlen (entry_point) == 0)
    {
      switch (which_target)
	{
	case CYGWIN_TARGET:
	  entry_point = "__cygwin_dll_entry@@12";
	  break;

	case MINGW_TARGET:
	  entry_point = "_DllMainCRTStartup@@12";
	  break;

	default:
	  entry_point = "_DllMain@@12";
	  break;
	}
    }
  dyn_string_append_cstr (driver_cmdline, " -Wl,-e,");
  dyn_string_append_cstr (driver_cmdline, entry_point);
  dyn_string_append_cstr (dlltool_cmdline, " --exclude-symbol=");
  dyn_string_append_cstr (dlltool_cmdline,
                    (entry_point[0] == '_') ? entry_point+1 : entry_point);

  if (! image_base_str || strlen (image_base_str) == 0)
    {
      char *tmpbuf = (char *) xmalloc (sizeof ("0x12345678") + 1);
      unsigned long hash = strhash (dll_file_name);
      sprintf (tmpbuf, "0x%.8lX", 0x60000000|((hash<<16)&0xFFC0000));
      image_base_str = tmpbuf;
    }

  dyn_string_append_cstr (driver_cmdline, " -Wl,--image-base,");
  dyn_string_append_cstr (driver_cmdline, image_base_str);

  if (verbose)
    {
      dyn_string_append_cstr (driver_cmdline, " -v");
    }

  for (i = 1; i < argc; ++i)
    {
      if (driver_arg_indices[i])
	{
	  char *arg = saved_argv[i];
	  int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (driver_cmdline,
	                     (quote) ? " \"" : " ");
	  dyn_string_append_cstr (driver_cmdline, arg);
	  dyn_string_append_cstr (driver_cmdline,
	                     (quote) ? "\"" : "");
	}
    }

  /*
   * Step pre-1. If no --def <EXPORT_DEF> is specified, then create it
   * and then pass it on.
   */

  if (! def_file_seen)
    {
      int i;
      dyn_string_t step_pre1;

      step_pre1 = dyn_string_new (1024);

      dyn_string_append_cstr (step_pre1, dlltool_cmdline->s);
      if (export_all)
	{
	  dyn_string_append_cstr (step_pre1, " --export-all --exclude-symbol=");
	  dyn_string_append_cstr (step_pre1,
	  "_cygwin_dll_entry@@12,DllMainCRTStartup@@12,DllMain@@12,DllEntryPoint@@12");
	}
      dyn_string_append_cstr (step_pre1, " --output-def ");
      dyn_string_append_cstr (step_pre1, def_file_name);

      for (i = 1; i < argc; ++i)
	{
	  if (driver_arg_indices[i])
	    {
	      char *arg = saved_argv[i];
	      size_t len = strlen (arg);
	      if (len >= 2 && arg[len-2] == '.'
	          && (arg[len-1] == 'o' || arg[len-1] == 'a'))
		{
		  int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
		  dyn_string_append_cstr (step_pre1,
				     (quote) ? " \"" : " ");
		  dyn_string_append_cstr (step_pre1, arg);
		  dyn_string_append_cstr (step_pre1,
				     (quote) ? "\"" : "");
		}
	    }
	}

      if (run (dlltool_name, step_pre1->s))
	cleanup_and_exit (1);

      dyn_string_delete (step_pre1);
    }

  dyn_string_append_cstr (dlltool_cmdline, " --def ");
  dyn_string_append_cstr (dlltool_cmdline, def_file_name);

  if (verbose)
    {
      fprintf (stderr, _("DLLTOOL name    : %s\n"), dlltool_name);
      fprintf (stderr, _("DLLTOOL options : %s\n"), dlltool_cmdline->s);
      fprintf (stderr, _("DRIVER name     : %s\n"), driver_name);
      fprintf (stderr, _("DRIVER options  : %s\n"), driver_cmdline->s);
    }

  /*
   * Step 1. Call GCC/LD to create base relocation file. If using GCC, the
   * driver command line will look like the following:
   *
   *    % gcc -Wl,--dll --Wl,--base-file,foo.base [rest of command line]
   *
   * If the user does not specify a base name, create temporary one that
   * is deleted at exit.
   *
   */

  if (! base_file_name)
    {
      base_file_name = make_temp_file (".base");
      if (dontdeltemps)
       base_file_name = mybasename (base_file_name);
      delete_base_file = 1;
    }

  {
    int quote;

    dyn_string_t step1 = dyn_string_new (driver_cmdline->length
					 + strlen (base_file_name)
					 + 20);
    dyn_string_append_cstr (step1, "-Wl,--base-file,");
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step1,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step1, base_file_name);
    dyn_string_append_cstr (step1,
	               (quote) ? "\"" : "");
    if (driver_cmdline->length)
      {
	dyn_string_append_cstr (step1, " ");
	dyn_string_append_cstr (step1, driver_cmdline->s);
      }

    if (run (driver_name, step1->s))
      cleanup_and_exit (1);

    dyn_string_delete (step1);
  }



  /*
   * Step 2. generate the exp file by running dlltool.
   * dlltool command line will look like the following:
   *
   *    % dlltool -Wl,--dll --Wl,--base-file,foo.base [rest of command line]
   *
   * If the user does not specify a base name, create temporary one that
   * is deleted at exit.
   *
   */

  if (! exp_file_name)
    {
      char *p = strrchr (dll_name, '.');
      size_t prefix_len = (p) ? p - dll_name : strlen (dll_name);
      exp_file_name = (char *) xmalloc (prefix_len + 4 + 1);
      strncpy (exp_file_name, dll_name, prefix_len);
      exp_file_name[prefix_len] = '\0';
      strcat (exp_file_name, ".exp");
      delete_exp_file = 1;
    }

  {
    int quote;
    dyn_string_t step2 = dyn_string_new (dlltool_cmdline->length
					 + strlen (base_file_name)
					 + strlen (exp_file_name)
				         + 20);

    dyn_string_append_cstr (step2, "--base-file ");
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step2,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step2, base_file_name);
    dyn_string_append_cstr (step2,
	               (quote) ? "\" " : " ");

    dyn_string_append_cstr (step2, "--output-exp ");
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step2,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step2, exp_file_name);
    dyn_string_append_cstr (step2,
	               (quote) ? "\"" : "");

    if (dlltool_cmdline->length)
      {
	dyn_string_append_cstr (step2, " ");
	dyn_string_append_cstr (step2, dlltool_cmdline->s);
      }

    if (run (dlltool_name, step2->s))
      cleanup_and_exit (1);

    dyn_string_delete (step2);
  }

  /*
   * Step 3. Call GCC/LD to again, adding the exp file this time.
   * driver command line will look like the following:
   *
   *    % gcc -Wl,--dll --Wl,--base-file,foo.base foo.exp [rest ...]
   */

  {
    int quote;

    dyn_string_t step3 = dyn_string_new (driver_cmdline->length
					 + strlen (exp_file_name)
					 + strlen (base_file_name)
				         + 20);
    dyn_string_append_cstr (step3, "-Wl,--base-file,");
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step3,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step3, base_file_name);
    dyn_string_append_cstr (step3,
	               (quote) ? "\" " : " ");

    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step3,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step3, exp_file_name);
    dyn_string_append_cstr (step3,
	               (quote) ? "\"" : "");

    if (driver_cmdline->length)
      {
	dyn_string_append_cstr (step3, " ");
	dyn_string_append_cstr (step3, driver_cmdline->s);
      }

    if (run (driver_name, step3->s))
      cleanup_and_exit (1);

    dyn_string_delete (step3);
  }


  /*
   * Step 4. Run DLLTOOL again using the same command line.
   */

  {
    int quote;
    dyn_string_t step4 = dyn_string_new (dlltool_cmdline->length
					 + strlen (base_file_name)
					 + strlen (exp_file_name)
				         + 20);

    dyn_string_append_cstr (step4, "--base-file ");
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step4,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step4, base_file_name);
    dyn_string_append_cstr (step4,
	               (quote) ? "\" " : " ");

    dyn_string_append_cstr (step4, "--output-exp ");
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step4,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step4, exp_file_name);
    dyn_string_append_cstr (step4,
	               (quote) ? "\"" : "");

    if (dlltool_cmdline->length)
      {
	dyn_string_append_cstr (step4, " ");
	dyn_string_append_cstr (step4, dlltool_cmdline->s);
      }

    if (output_lib_file_name)
      {
	dyn_string_append_cstr (step4, " --output-lib ");
	dyn_string_append_cstr (step4, output_lib_file_name);
      }

    if (run (dlltool_name, step4->s))
      cleanup_and_exit (1);

    dyn_string_delete (step4);
  }


  /*
   * Step 5. Link it all together and be done with it.
   * driver command line will look like the following:
   *
   *    % gcc -Wl,--dll foo.exp [rest ...]
   *
   */

  {
    int quote;

    dyn_string_t step5 = dyn_string_new (driver_cmdline->length
					 + strlen (exp_file_name)
				         + 20);
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step5,
	               (quote) ? "\"" : "");
    dyn_string_append_cstr (step5, exp_file_name);
    dyn_string_append_cstr (step5,
	               (quote) ? "\"" : "");

    if (driver_cmdline->length)
      {
	dyn_string_append_cstr (step5, " ");
	dyn_string_append_cstr (step5, driver_cmdline->s);
      }

    if (run (driver_name, step5->s))
      cleanup_and_exit (1);

    dyn_string_delete (step5);
  }

  cleanup_and_exit (0);

  return 0;
}
@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d642 2
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d117 11
a127 11
static int run PARAMS ((const char *, char *));
static char *mybasename PARAMS ((const char *));
static int strhash PARAMS ((const char *));
static void usage PARAMS ((FILE *, int));
static void display PARAMS ((const char *, va_list));
static void inform PARAMS ((const char *, ...));
static void warn PARAMS ((const char *, ...));
static char *look_for_prog PARAMS ((const char *, const char *, int));
static char *deduce_name PARAMS ((const char *));
static void delete_temp_files PARAMS ((void));
static void cleanup_and_exit PARAMS ((int));
d140 1
a140 3
display (message, args)
     const char * message;
     va_list      args;
d181 1
a181 4
look_for_prog (prog_name, prefix, end_prefix)
     const char *prog_name;
     const char *prefix;
     int end_prefix;
d247 1
a247 2
deduce_name (prog_name)
     const char *prog_name;
d295 1
a295 1
delete_temp_files ()
d346 1
a346 2
cleanup_and_exit (status)
     int status;
d353 1
a353 3
run (what, args)
     const char *what;
     char *args;
d443 1
a443 2
mybasename (name)
     const char *name;
d459 1
a459 2
strhash (str)
     const char *str;
d484 1
a484 3
usage (file, status)
     FILE *file;
     int status;
d546 1
a546 1
#define OPTION_NO_IDATA4 	(OPTION_DLLNAME + 1)
d605 1
a605 1
int main PARAMS ((int, char **));
d608 1
a608 3
main (argc, argv)
     int argc;
     char **argv;
d814 1
a814 1
	def_file_name = mybasename (def_file_name);
d999 1
a999 1
	base_file_name = mybasename (base_file_name);
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
a38 1
#include <ctype.h>
d81 1
a81 1
static char *cygwin_driver_flags = 
d93 2
a94 2
  UNKNOWN_TARGET, 
  CYGWIN_TARGET, 
d96 1
a96 1
} 
d118 2
d123 1
a123 1
static void warn PARAMS ((const char *format, ...));
d127 1
a127 1
static void cleanup_and_exit PARAMS ((int status));
a151 1
#ifdef __STDC__
d153 1
a153 1
inform (const char * message, ...)
d155 2
a156 1
  va_list args;
a160 1
  va_start (args, message);
d162 2
a163 1
  va_end (args);
d167 1
a167 1
warn (const char *format, ...)
d169 2
a170 1
  va_list args;
a171 1
  va_start (args, format);
a172 10
  va_end (args);
}
#else

static void
inform (message, va_alist)
     const char * message;
     va_dcl
{
  va_list args;
d174 1
a174 6
  if (!verbose)
    return;

  va_start (args);
  display (message, args);
  va_end (args);
a176 13
static void
warn (format, va_alist)
     const char *format;
     va_dcl
{
  va_list args;

  va_start (args);
  display (format, args);
  va_end (args);
}
#endif

d191 2
a192 2
  cmd = xmalloc (strlen (prefix) 
                 + strlen (prog_name) 
d194 1
a194 1
                 + strlen (EXECUTABLE_SUFFIX) 
d207 1
a207 1
               || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d212 1
a212 1
        {
d229 1
a229 1
   run "i386-pe-as" or "ppc-pe-ld".  
d235 1
a235 1
   deduce_name("as") uses the following search order: 
d240 1
a240 1
   
d246 1
a246 1
     
d313 2
a314 2
        {
          unlink (base_file_name);
d318 1
a318 1
  
d329 3
a331 3
        {
          unlink (exp_file_name);
          free (exp_file_name);
d344 3
a346 3
        {
          unlink (def_file_name);
          free (def_file_name);
d351 3
a353 2
static void 
cleanup_and_exit (int status)
d358 1
a358 1
  
d405 1
a405 1
        s++;
d447 1
a447 1
  
d468 3
a470 2
static int 
strhash (const char *str)
d499 1
a499 1
  fprintf (file, _("Usage %s <options> <object-files>\n"), program_name);
d541 1
a541 1
/* GENERIC options. */
d546 1
a546 1
/* DLLWRAP options. */
d556 1
a556 1
/* DLLTOOL options. */
d579 1
a579 1
  /* generic options. */
d585 1
a585 1
  /* dllwrap options. */
d594 1
a594 1
  /* dlltool options. */
d618 2
d648 9
d660 1
a660 1
  for (i = 0; i < argc; ++i) 
d674 2
a675 2
     to dlltool and driver in dlltool_args and driver_args. */
   
d677 2
a678 2
  while ((c = getopt_long_only (argc, argv, "nkAqve:Uho:l:L:I:", 
                                long_options, (int *) 0)) != EOF)
d689 1
a689 1
        {
d693 1
a693 1
	     which are dealt with later. */
d697 1
a697 1
      /* deal with generic and dllwrap options first. */
d776 5
a780 5
      
      /* Handle passing through --option=value case. */
      if (optarg 
          && saved_argv[optind-1][0] == '-' 
          && saved_argv[optind-1][1] == '-' 
d785 1
a785 1
        {
d790 1
a790 1
	    } 
d794 1
a794 1
        {
d799 1
a799 1
	    } 
d803 1
a803 1
  /* sanity checks. */
d818 1
a818 1
  /* Deduce driver-name and dlltool-name from our own. */
d829 1
a829 1
        def_file_name = mybasename (def_file_name);
d831 2
a832 2
      warn (_("no export definition file provided"));
      warn (_("creating one, but that may not be what you want"));
d834 2
a835 2
  
  /* set the target platform. */
d840 1
a840 1
  else 
d843 1
a843 1
  /* re-create the command lines as a string, taking care to quote stuff. */
d855 1
a855 1
        {
d857 2
a858 2
          int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (dlltool_cmdline, 
d861 1
a861 1
	  dyn_string_append_cstr (dlltool_cmdline, 
d870 1
a870 1
        {
d872 1
a872 1
          driver_flags = cygwin_driver_flags;
d874 1
a874 1
	
d876 1
a876 1
          driver_flags = mingw32_driver_flags;
d878 1
a878 1
	
d880 1
a880 1
          driver_flags = generic_driver_flags;
d891 1
a891 1
        {
d895 1
a895 1
	
d899 1
a899 1
	
d901 1
a901 1
          entry_point = "_DllMain@@12";
d908 2
a909 2
  dyn_string_append_cstr (dlltool_cmdline, 
                     (entry_point[0] == '_') ? entry_point+1 : entry_point);
d930 1
a930 1
        {
d932 2
a933 2
          int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (driver_cmdline, 
d936 1
a936 1
	  dyn_string_append_cstr (driver_cmdline, 
d940 1
a940 1
  
d945 2
a946 2
  
  if (! def_file_seen) 
d956 2
a957 2
          dyn_string_append_cstr (step_pre1, " --export-all --exclude-symbol=");
          dyn_string_append_cstr (step_pre1, 
d969 1
a969 1
	      if (len >= 2 && arg[len-2] == '.' 
d984 1
a984 1
      
d998 1
a998 1
 
d1002 1
a1002 1
   *    
d1009 1
a1009 1
  
d1014 1
a1014 1
        base_file_name = mybasename (base_file_name);
d1017 1
a1017 1
  
d1021 3
a1023 3
    dyn_string_t step1 = dyn_string_new (driver_cmdline->length 
                                         + strlen (base_file_name)
				         + 20);
d1025 3
a1027 3
    quote = (strchr (base_file_name, ' ') 
             || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step1, 
d1030 1
a1030 1
    dyn_string_append_cstr (step1, 
d1034 2
a1035 2
        dyn_string_append_cstr (step1, " ");
        dyn_string_append_cstr (step1, driver_cmdline->s);
d1040 1
a1040 1
    
d1047 1
a1047 1
   * Step 2. generate the exp file by running dlltool. 
d1049 1
a1049 1
   *    
d1056 1
a1056 1
  
d1067 1
a1067 1
  
d1070 3
a1072 3
    dyn_string_t step2 = dyn_string_new (dlltool_cmdline->length 
                                         + strlen (base_file_name)
                                         + strlen (exp_file_name)
d1076 3
a1078 3
    quote = (strchr (base_file_name, ' ') 
             || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step2, 
d1081 1
a1081 1
    dyn_string_append_cstr (step2, 
d1085 3
a1087 3
    quote = (strchr (exp_file_name, ' ') 
             || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step2, 
d1090 1
a1090 1
    dyn_string_append_cstr (step2, 
d1095 2
a1096 2
        dyn_string_append_cstr (step2, " ");
        dyn_string_append_cstr (step2, dlltool_cmdline->s);
d1101 1
a1101 1
    
d1108 1
a1108 1
   *    
d1115 3
a1117 3
    dyn_string_t step3 = dyn_string_new (driver_cmdline->length 
                                         + strlen (exp_file_name)
                                         + strlen (base_file_name)
d1120 3
a1122 3
    quote = (strchr (base_file_name, ' ') 
             || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step3, 
d1125 1
a1125 1
    dyn_string_append_cstr (step3, 
d1128 3
a1130 3
    quote = (strchr (exp_file_name, ' ') 
             || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step3, 
d1133 1
a1133 1
    dyn_string_append_cstr (step3, 
d1138 2
a1139 2
        dyn_string_append_cstr (step3, " ");
        dyn_string_append_cstr (step3, driver_cmdline->s);
d1144 1
a1144 1
    
d1155 3
a1157 3
    dyn_string_t step4 = dyn_string_new (dlltool_cmdline->length 
                                         + strlen (base_file_name)
                                         + strlen (exp_file_name)
d1161 3
a1163 3
    quote = (strchr (base_file_name, ' ') 
             || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step4, 
d1166 1
a1166 1
    dyn_string_append_cstr (step4, 
d1170 3
a1172 3
    quote = (strchr (exp_file_name, ' ') 
             || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step4, 
d1175 1
a1175 1
    dyn_string_append_cstr (step4, 
d1180 2
a1181 2
        dyn_string_append_cstr (step4, " ");
        dyn_string_append_cstr (step4, dlltool_cmdline->s);
d1186 2
a1187 2
        dyn_string_append_cstr (step4, " --output-lib ");
        dyn_string_append_cstr (step4, output_lib_file_name);
d1192 1
a1192 1
    
d1195 1
a1195 1
  
d1200 1
a1200 1
   *    
d1208 2
a1209 2
    dyn_string_t step5 = dyn_string_new (driver_cmdline->length 
                                         + strlen (exp_file_name)
d1211 3
a1213 3
    quote = (strchr (exp_file_name, ' ') 
             || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step5, 
d1216 1
a1216 1
    dyn_string_append_cstr (step5, 
d1221 2
a1222 2
        dyn_string_append_cstr (step5, " ");
        dyn_string_append_cstr (step5, driver_cmdline->s);
d1227 1
a1227 1
    
@


1.2
log
@Avoid calls to insecure choose_temp_base
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
d861 1
a861 1
      dyn_string_append (dlltool_cmdline, " -v");
d863 2
a864 2
  dyn_string_append (dlltool_cmdline, " --dllname ");
  dyn_string_append (dlltool_cmdline, dll_name);
d872 1
a872 1
	  dyn_string_append (dlltool_cmdline, 
d874 2
a875 2
	  dyn_string_append (dlltool_cmdline, arg);
	  dyn_string_append (dlltool_cmdline, 
d898 3
a900 3
  dyn_string_append (driver_cmdline, driver_flags);
  dyn_string_append (driver_cmdline, " -o ");
  dyn_string_append (driver_cmdline, dll_file_name);
d919 4
a922 4
  dyn_string_append (driver_cmdline, " -Wl,-e,");
  dyn_string_append (driver_cmdline, entry_point);
  dyn_string_append (dlltool_cmdline, " --exclude-symbol=");
  dyn_string_append (dlltool_cmdline, 
d933 2
a934 2
  dyn_string_append (driver_cmdline, " -Wl,--image-base,");
  dyn_string_append (driver_cmdline, image_base_str);
d938 1
a938 1
      dyn_string_append (driver_cmdline, " -v");
d947 1
a947 1
	  dyn_string_append (driver_cmdline, 
d949 2
a950 2
	  dyn_string_append (driver_cmdline, arg);
	  dyn_string_append (driver_cmdline, 
d967 1
a967 1
      dyn_string_append (step_pre1, dlltool_cmdline->s);
d970 2
a971 2
          dyn_string_append (step_pre1, " --export-all --exclude-symbol=");
          dyn_string_append (step_pre1, 
d974 2
a975 2
      dyn_string_append (step_pre1, " --output-def ");
      dyn_string_append (step_pre1, def_file_name);
d987 1
a987 1
		  dyn_string_append (step_pre1,
d989 2
a990 2
		  dyn_string_append (step_pre1, arg);
		  dyn_string_append (step_pre1,
d1002 2
a1003 2
  dyn_string_append (dlltool_cmdline, " --def ");
  dyn_string_append (dlltool_cmdline, def_file_name);
d1038 1
a1038 1
    dyn_string_append (step1, "-Wl,--base-file,");
d1041 1
a1041 1
    dyn_string_append (step1, 
d1043 2
a1044 2
    dyn_string_append (step1, base_file_name);
    dyn_string_append (step1, 
d1048 2
a1049 2
        dyn_string_append (step1, " ");
        dyn_string_append (step1, driver_cmdline->s);
d1089 1
a1089 1
    dyn_string_append (step2, "--base-file ");
d1092 1
a1092 1
    dyn_string_append (step2, 
d1094 2
a1095 2
    dyn_string_append (step2, base_file_name);
    dyn_string_append (step2, 
d1098 1
a1098 1
    dyn_string_append (step2, "--output-exp ");
d1101 1
a1101 1
    dyn_string_append (step2, 
d1103 2
a1104 2
    dyn_string_append (step2, exp_file_name);
    dyn_string_append (step2, 
d1109 2
a1110 2
        dyn_string_append (step2, " ");
        dyn_string_append (step2, dlltool_cmdline->s);
d1133 1
a1133 1
    dyn_string_append (step3, "-Wl,--base-file,");
d1136 1
a1136 1
    dyn_string_append (step3, 
d1138 2
a1139 2
    dyn_string_append (step3, base_file_name);
    dyn_string_append (step3, 
d1144 1
a1144 1
    dyn_string_append (step3, 
d1146 2
a1147 2
    dyn_string_append (step3, exp_file_name);
    dyn_string_append (step3, 
d1152 2
a1153 2
        dyn_string_append (step3, " ");
        dyn_string_append (step3, driver_cmdline->s);
d1174 1
a1174 1
    dyn_string_append (step4, "--base-file ");
d1177 1
a1177 1
    dyn_string_append (step4, 
d1179 2
a1180 2
    dyn_string_append (step4, base_file_name);
    dyn_string_append (step4, 
d1183 1
a1183 1
    dyn_string_append (step4, "--output-exp ");
d1186 1
a1186 1
    dyn_string_append (step4, 
d1188 2
a1189 2
    dyn_string_append (step4, exp_file_name);
    dyn_string_append (step4, 
d1194 2
a1195 2
        dyn_string_append (step4, " ");
        dyn_string_append (step4, dlltool_cmdline->s);
d1200 2
a1201 2
        dyn_string_append (step4, " --output-lib ");
        dyn_string_append (step4, output_lib_file_name);
d1227 1
a1227 1
    dyn_string_append (step5, 
d1229 2
a1230 2
    dyn_string_append (step5, exp_file_name);
    dyn_string_append (step5, 
d1235 2
a1236 2
        dyn_string_append (step5, " ");
        dyn_string_append (step5, driver_cmdline->s);
@


1.1
log
@Initial revision
@
text
@d395 1
d397 3
d841 3
a843 6
      char *fileprefix = choose_temp_base ();
      def_file_name = (char *) xmalloc (strlen (fileprefix) + 5);
      sprintf (def_file_name, "%s.def", 
               (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
      delete_def_file = 1;
      free (fileprefix);
d1026 3
a1028 4
      char *fileprefix = choose_temp_base ();
      base_file_name = (char *) xmalloc (strlen (fileprefix) + 6);
      sprintf (base_file_name, "%s.base", 
               (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
a1029 1
      free (fileprefix);
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d860 1
a860 1
      dyn_string_append_cstr (dlltool_cmdline, " -v");
d862 2
a863 2
  dyn_string_append_cstr (dlltool_cmdline, " --dllname ");
  dyn_string_append_cstr (dlltool_cmdline, dll_name);
d871 1
a871 1
	  dyn_string_append_cstr (dlltool_cmdline, 
d873 2
a874 2
	  dyn_string_append_cstr (dlltool_cmdline, arg);
	  dyn_string_append_cstr (dlltool_cmdline, 
d897 3
a899 3
  dyn_string_append_cstr (driver_cmdline, driver_flags);
  dyn_string_append_cstr (driver_cmdline, " -o ");
  dyn_string_append_cstr (driver_cmdline, dll_file_name);
d918 4
a921 4
  dyn_string_append_cstr (driver_cmdline, " -Wl,-e,");
  dyn_string_append_cstr (driver_cmdline, entry_point);
  dyn_string_append_cstr (dlltool_cmdline, " --exclude-symbol=");
  dyn_string_append_cstr (dlltool_cmdline, 
d932 2
a933 2
  dyn_string_append_cstr (driver_cmdline, " -Wl,--image-base,");
  dyn_string_append_cstr (driver_cmdline, image_base_str);
d937 1
a937 1
      dyn_string_append_cstr (driver_cmdline, " -v");
d946 1
a946 1
	  dyn_string_append_cstr (driver_cmdline, 
d948 2
a949 2
	  dyn_string_append_cstr (driver_cmdline, arg);
	  dyn_string_append_cstr (driver_cmdline, 
d966 1
a966 1
      dyn_string_append_cstr (step_pre1, dlltool_cmdline->s);
d969 2
a970 2
          dyn_string_append_cstr (step_pre1, " --export-all --exclude-symbol=");
          dyn_string_append_cstr (step_pre1, 
d973 2
a974 2
      dyn_string_append_cstr (step_pre1, " --output-def ");
      dyn_string_append_cstr (step_pre1, def_file_name);
d986 1
a986 1
		  dyn_string_append_cstr (step_pre1,
d988 2
a989 2
		  dyn_string_append_cstr (step_pre1, arg);
		  dyn_string_append_cstr (step_pre1,
d1001 2
a1002 2
  dyn_string_append_cstr (dlltool_cmdline, " --def ");
  dyn_string_append_cstr (dlltool_cmdline, def_file_name);
d1039 1
a1039 1
    dyn_string_append_cstr (step1, "-Wl,--base-file,");
d1042 1
a1042 1
    dyn_string_append_cstr (step1, 
d1044 2
a1045 2
    dyn_string_append_cstr (step1, base_file_name);
    dyn_string_append_cstr (step1, 
d1049 2
a1050 2
        dyn_string_append_cstr (step1, " ");
        dyn_string_append_cstr (step1, driver_cmdline->s);
d1090 1
a1090 1
    dyn_string_append_cstr (step2, "--base-file ");
d1093 1
a1093 1
    dyn_string_append_cstr (step2, 
d1095 2
a1096 2
    dyn_string_append_cstr (step2, base_file_name);
    dyn_string_append_cstr (step2, 
d1099 1
a1099 1
    dyn_string_append_cstr (step2, "--output-exp ");
d1102 1
a1102 1
    dyn_string_append_cstr (step2, 
d1104 2
a1105 2
    dyn_string_append_cstr (step2, exp_file_name);
    dyn_string_append_cstr (step2, 
d1110 2
a1111 2
        dyn_string_append_cstr (step2, " ");
        dyn_string_append_cstr (step2, dlltool_cmdline->s);
d1134 1
a1134 1
    dyn_string_append_cstr (step3, "-Wl,--base-file,");
d1137 1
a1137 1
    dyn_string_append_cstr (step3, 
d1139 2
a1140 2
    dyn_string_append_cstr (step3, base_file_name);
    dyn_string_append_cstr (step3, 
d1145 1
a1145 1
    dyn_string_append_cstr (step3, 
d1147 2
a1148 2
    dyn_string_append_cstr (step3, exp_file_name);
    dyn_string_append_cstr (step3, 
d1153 2
a1154 2
        dyn_string_append_cstr (step3, " ");
        dyn_string_append_cstr (step3, driver_cmdline->s);
d1175 1
a1175 1
    dyn_string_append_cstr (step4, "--base-file ");
d1178 1
a1178 1
    dyn_string_append_cstr (step4, 
d1180 2
a1181 2
    dyn_string_append_cstr (step4, base_file_name);
    dyn_string_append_cstr (step4, 
d1184 1
a1184 1
    dyn_string_append_cstr (step4, "--output-exp ");
d1187 1
a1187 1
    dyn_string_append_cstr (step4, 
d1189 2
a1190 2
    dyn_string_append_cstr (step4, exp_file_name);
    dyn_string_append_cstr (step4, 
d1195 2
a1196 2
        dyn_string_append_cstr (step4, " ");
        dyn_string_append_cstr (step4, dlltool_cmdline->s);
d1201 2
a1202 2
        dyn_string_append_cstr (step4, " --output-lib ");
        dyn_string_append_cstr (step4, output_lib_file_name);
d1228 1
a1228 1
    dyn_string_append_cstr (step5, 
d1230 2
a1231 2
    dyn_string_append_cstr (step5, exp_file_name);
    dyn_string_append_cstr (step5, 
d1236 2
a1237 2
        dyn_string_append_cstr (step5, " ");
        dyn_string_append_cstr (step5, driver_cmdline->s);
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d39 1
d82 1
a82 1
static char *cygwin_driver_flags =
d94 2
a95 2
  UNKNOWN_TARGET,
  CYGWIN_TARGET,
d97 1
a97 1
}
a118 2
static char *mybasename PARAMS ((const char *));
static int strhash PARAMS ((const char *));
d122 1
a122 1
static void warn PARAMS ((const char *, ...));
d126 1
a126 1
static void cleanup_and_exit PARAMS ((int));
d151 1
d153 1
a153 1
inform VPARAMS ((const char *message, ...))
d155 1
a155 2
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);
d160 1
d162 7
d170 3
a172 1
  VA_CLOSE (args);
d174 1
d177 3
a179 1
warn VPARAMS ((const char *format, ...))
d181 1
a181 2
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);
d183 16
d200 1
a200 2

  VA_CLOSE (args);
d202 1
d218 2
a219 2
  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
d221 1
a221 1
		 + strlen (EXECUTABLE_SUFFIX)
d234 1
a234 1
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d239 1
a239 1
	{
d256 1
a256 1
   run "i386-pe-as" or "ppc-pe-ld".
d262 1
a262 1
   deduce_name("as") uses the following search order:
d267 1
a267 1

d273 1
a273 1

d340 2
a341 2
	{
	  unlink (base_file_name);
d345 1
a345 1

d356 3
a358 3
	{
	  unlink (exp_file_name);
	  free (exp_file_name);
d371 3
a373 3
	{
	  unlink (def_file_name);
	  free (def_file_name);
d378 2
a379 3
static void
cleanup_and_exit (status)
     int status;
d384 1
a384 1

d427 1
a427 1
	s++;
d469 1
a469 1

d490 2
a491 3
static int
strhash (str)
     const char *str;
d520 1
a520 1
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
d562 1
a562 1
/* GENERIC options.  */
d567 1
a567 1
/* DLLWRAP options.  */
d577 1
a577 1
/* DLLTOOL options.  */
d600 1
a600 1
  /* generic options.  */
d606 1
a606 1
  /* dllwrap options.  */
d615 1
a615 1
  /* dlltool options.  */
a638 2
int main PARAMS ((int, char **));

a666 9
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d670 1
a670 1
  for (i = 0; i < argc; ++i)
d684 2
a685 2
     to dlltool and driver in dlltool_args and driver_args.  */

d687 2
a688 2
  while ((c = getopt_long_only (argc, argv, "nkAqve:Uho:l:L:I:",
				long_options, (int *) 0)) != EOF)
d699 1
a699 1
	{
d703 1
a703 1
	     which are dealt with later.  */
d707 1
a707 1
      /* deal with generic and dllwrap options first.  */
d786 5
a790 5

      /* Handle passing through --option=value case.  */
      if (optarg
	  && saved_argv[optind-1][0] == '-'
	  && saved_argv[optind-1][1] == '-'
d795 1
a795 1
	{
d800 1
a800 1
	    }
d804 1
a804 1
	{
d809 1
a809 1
	    }
d813 1
a813 1
  /* sanity checks.  */
d828 1
a828 1
  /* Deduce driver-name and dlltool-name from our own.  */
d839 2
a840 2
      sprintf (def_file_name, "%s.def",
	       (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
d844 2
a845 2
      warn (_("no export definition file provided.\n\
Creating one, but that may not be what you want"));
d847 2
a848 2

  /* set the target platform.  */
d853 1
a853 1
  else
d856 1
a856 1
  /* re-create the command lines as a string, taking care to quote stuff.  */
d868 1
a868 1
	{
d870 2
a871 2
	  int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (dlltool_cmdline,
d874 1
a874 1
	  dyn_string_append_cstr (dlltool_cmdline,
d883 1
a883 1
	{
d885 1
a885 1
	  driver_flags = cygwin_driver_flags;
d887 1
a887 1

d889 1
a889 1
	  driver_flags = mingw32_driver_flags;
d891 1
a891 1

d893 1
a893 1
	  driver_flags = generic_driver_flags;
d904 1
a904 1
	{
d908 1
a908 1

d912 1
a912 1

d914 1
a914 1
	  entry_point = "_DllMain@@12";
d921 2
a922 2
  dyn_string_append_cstr (dlltool_cmdline,
                    (entry_point[0] == '_') ? entry_point+1 : entry_point);
d943 1
a943 1
	{
d945 2
a946 2
	  int quote = (strchr (arg, ' ') || strchr (arg, '\t'));
	  dyn_string_append_cstr (driver_cmdline,
d949 1
a949 1
	  dyn_string_append_cstr (driver_cmdline,
d953 1
a953 1

d958 2
a959 2

  if (! def_file_seen)
d969 2
a970 2
	  dyn_string_append_cstr (step_pre1, " --export-all --exclude-symbol=");
	  dyn_string_append_cstr (step_pre1,
d982 1
a982 1
	      if (len >= 2 && arg[len-2] == '.'
d997 1
a997 1

d1011 1
a1011 1

d1015 1
a1015 1
   *
d1022 1
a1022 1

d1027 2
a1028 2
      sprintf (base_file_name, "%s.base",
	       (dontdeltemps) ? mybasename (fileprefix) : fileprefix);
d1032 1
a1032 1

d1036 3
a1038 3
    dyn_string_t step1 = dyn_string_new (driver_cmdline->length
					 + strlen (base_file_name)
					 + 20);
d1040 3
a1042 3
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step1,
d1045 1
a1045 1
    dyn_string_append_cstr (step1,
d1049 2
a1050 2
	dyn_string_append_cstr (step1, " ");
	dyn_string_append_cstr (step1, driver_cmdline->s);
d1055 1
a1055 1

d1062 1
a1062 1
   * Step 2. generate the exp file by running dlltool.
d1064 1
a1064 1
   *
d1071 1
a1071 1

d1082 1
a1082 1

d1085 3
a1087 3
    dyn_string_t step2 = dyn_string_new (dlltool_cmdline->length
					 + strlen (base_file_name)
					 + strlen (exp_file_name)
d1091 3
a1093 3
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step2,
d1096 1
a1096 1
    dyn_string_append_cstr (step2,
d1100 3
a1102 3
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step2,
d1105 1
a1105 1
    dyn_string_append_cstr (step2,
d1110 2
a1111 2
	dyn_string_append_cstr (step2, " ");
	dyn_string_append_cstr (step2, dlltool_cmdline->s);
d1116 1
a1116 1

d1123 1
a1123 1
   *
d1130 3
a1132 3
    dyn_string_t step3 = dyn_string_new (driver_cmdline->length
					 + strlen (exp_file_name)
					 + strlen (base_file_name)
d1135 3
a1137 3
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step3,
d1140 1
a1140 1
    dyn_string_append_cstr (step3,
d1143 3
a1145 3
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step3,
d1148 1
a1148 1
    dyn_string_append_cstr (step3,
d1153 2
a1154 2
	dyn_string_append_cstr (step3, " ");
	dyn_string_append_cstr (step3, driver_cmdline->s);
d1159 1
a1159 1

d1170 3
a1172 3
    dyn_string_t step4 = dyn_string_new (dlltool_cmdline->length
					 + strlen (base_file_name)
					 + strlen (exp_file_name)
d1176 3
a1178 3
    quote = (strchr (base_file_name, ' ')
	     || strchr (base_file_name, '\t'));
    dyn_string_append_cstr (step4,
d1181 1
a1181 1
    dyn_string_append_cstr (step4,
d1185 3
a1187 3
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step4,
d1190 1
a1190 1
    dyn_string_append_cstr (step4,
d1195 2
a1196 2
	dyn_string_append_cstr (step4, " ");
	dyn_string_append_cstr (step4, dlltool_cmdline->s);
d1201 2
a1202 2
	dyn_string_append_cstr (step4, " --output-lib ");
	dyn_string_append_cstr (step4, output_lib_file_name);
d1207 1
a1207 1

d1210 1
a1210 1

d1215 1
a1215 1
   *
d1223 2
a1224 2
    dyn_string_t step5 = dyn_string_new (driver_cmdline->length
					 + strlen (exp_file_name)
d1226 3
a1228 3
    quote = (strchr (exp_file_name, ' ')
	     || strchr (exp_file_name, '\t'));
    dyn_string_append_cstr (step5,
d1231 1
a1231 1
    dyn_string_append_cstr (step5,
d1236 2
a1237 2
	dyn_string_append_cstr (step5, " ");
	dyn_string_append_cstr (step5, driver_cmdline->s);
d1242 1
a1242 1

@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d117 11
a127 11
static int run (const char *, char *);
static char *mybasename (const char *);
static int strhash (const char *);
static void usage (FILE *, int);
static void display (const char *, va_list);
static void inform (const char *, ...);
static void warn (const char *, ...);
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);
static void delete_temp_files (void);
static void cleanup_and_exit (int);
d140 3
a142 1
display (const char * message, va_list args)
d183 4
a186 1
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
d252 2
a253 1
deduce_name (const char *prog_name)
d301 1
a301 1
delete_temp_files (void)
d352 2
a353 1
cleanup_and_exit (int status)
d360 3
a362 1
run (const char *what, char *args)
d448 2
a449 1
mybasename (const char *name)
d465 2
a466 1
strhash (const char *str)
d491 3
a493 1
usage (FILE *file, int status)
d555 1
a555 1
#define OPTION_NO_IDATA4	(OPTION_DLLNAME + 1)
d614 1
a614 1
int main (int, char **);
d617 3
a619 1
main (int argc, char **argv)
@


