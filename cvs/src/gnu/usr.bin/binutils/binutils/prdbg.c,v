head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	FSF:1.1.1
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.18;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.32;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.03.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.03.54;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.03.54;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.49.54;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.08;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.15.52;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.04;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* prdbg.c -- Print out generic debugging information.
   Copyright 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.
   Tags style generation written by Salvador E. Tropea <set@@computer.org>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This file prints out the generic debugging information, by
   supplying a set of routines to debug_write.  */

#include <stdio.h>
#include <assert.h>

#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "debug.h"
#include "budbg.h"

/* This is the structure we use as a handle for these routines.  */

struct pr_handle
{
  /* File to print information to.  */
  FILE *f;
  /* Current indentation level.  */
  unsigned int indent;
  /* Type stack.  */
  struct pr_stack *stack;
  /* Parameter number we are about to output.  */
  int parameter;
  /* The following are used only by the tags code (tg_).  */
  /* Name of the file we are using.  */
  char *filename;
  /* The BFD.  */
  bfd *abfd;
  /* The symbols table for this BFD.  */
  asymbol **syms;
  /* Pointer to a function to demangle symbols.  */
  char *(*demangler) (bfd *, const char *);
};

/* The type stack.  */

struct pr_stack
{
  /* Next element on the stack.  */
  struct pr_stack *next;
  /* This element.  */
  char *type;
  /* Current visibility of fields if this is a class.  */
  enum debug_visibility visibility;
  /* Name of the current method we are handling.  */
  const char *method;
  /* The following are used only by the tags code (tg_).  */
  /* Type for the container (struct, union, class, union class).  */
  const char *flavor;
  /* A comma separated list of parent classes.  */
  char *parents;
  /* How many parents contains parents.  */
  int num_parents;
};

static void indent (struct pr_handle *);
static bfd_boolean push_type (struct pr_handle *, const char *);
static bfd_boolean prepend_type (struct pr_handle *, const char *);
static bfd_boolean append_type (struct pr_handle *, const char *);
static bfd_boolean substitute_type (struct pr_handle *, const char *);
static bfd_boolean indent_type (struct pr_handle *);
static char *pop_type (struct pr_handle *);
static void print_vma (bfd_vma, char *, bfd_boolean, bfd_boolean);
static bfd_boolean pr_fix_visibility
  (struct pr_handle *, enum debug_visibility);
static bfd_boolean pr_start_compilation_unit (void *, const char *);
static bfd_boolean pr_start_source (void *, const char *);
static bfd_boolean pr_empty_type (void *);
static bfd_boolean pr_void_type (void *);
static bfd_boolean pr_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean pr_float_type (void *, unsigned int);
static bfd_boolean pr_complex_type (void *, unsigned int);
static bfd_boolean pr_bool_type (void *, unsigned int);
static bfd_boolean pr_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean pr_pointer_type (void *);
static bfd_boolean pr_function_type (void *, int, bfd_boolean);
static bfd_boolean pr_reference_type (void *);
static bfd_boolean pr_range_type (void *, bfd_signed_vma, bfd_signed_vma);
static bfd_boolean pr_array_type
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean pr_set_type (void *, bfd_boolean);
static bfd_boolean pr_offset_type (void *);
static bfd_boolean pr_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean pr_const_type (void *);
static bfd_boolean pr_volatile_type (void *);
static bfd_boolean pr_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean pr_end_struct_type (void *);
static bfd_boolean pr_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
static bfd_boolean pr_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean pr_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean pr_class_start_method (void *, const char *);
static bfd_boolean pr_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
static bfd_boolean pr_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean pr_class_end_method (void *);
static bfd_boolean pr_end_class_type (void *);
static bfd_boolean pr_typedef_type (void *, const char *);
static bfd_boolean pr_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean pr_typdef (void *, const char *);
static bfd_boolean pr_tag (void *, const char *);
static bfd_boolean pr_int_constant (void *, const char *, bfd_vma);
static bfd_boolean pr_float_constant (void *, const char *, double);
static bfd_boolean pr_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean pr_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean pr_start_function (void *, const char *, bfd_boolean);
static bfd_boolean pr_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean pr_start_block (void *, bfd_vma);
static bfd_boolean pr_end_block (void *, bfd_vma);
static bfd_boolean pr_end_function (void *);
static bfd_boolean pr_lineno (void *, const char *, unsigned long, bfd_vma);
static bfd_boolean append_parent (struct pr_handle *, const char *);
/* Only used by tg_ code.  */
static bfd_boolean tg_fix_visibility
  (struct pr_handle *, enum debug_visibility);
static void find_address_in_section (bfd *, asection *, void *);
static void translate_addresses (bfd *, char *, FILE *, asymbol **);
static const char *visibility_name (enum debug_visibility);
/* Tags style replacements.  */
static bfd_boolean tg_start_compilation_unit (void *, const char *);
static bfd_boolean tg_start_source (void *, const char *);
static bfd_boolean tg_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean tg_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_end_struct_type (void *);
static bfd_boolean tg_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean, bfd_boolean);
static bfd_boolean tg_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean tg_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean tg_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean tg_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean tg_end_class_type (void *);
static bfd_boolean tg_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean tg_typdef (void *, const char *);
static bfd_boolean tg_tag (void *, const char *);
static bfd_boolean tg_int_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_float_constant (void *, const char *, double);
static bfd_boolean tg_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean tg_start_function (void *, const char *, bfd_boolean);
static bfd_boolean tg_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean tg_start_block (void *, bfd_vma);
static bfd_boolean tg_end_block (void *, bfd_vma);
static bfd_boolean tg_lineno (void *, const char *, unsigned long, bfd_vma);

static const struct debug_write_fns pr_fns =
{
  pr_start_compilation_unit,
  pr_start_source,
  pr_empty_type,
  pr_void_type,
  pr_int_type,
  pr_float_type,
  pr_complex_type,
  pr_bool_type,
  pr_enum_type,
  pr_pointer_type,
  pr_function_type,
  pr_reference_type,
  pr_range_type,
  pr_array_type,
  pr_set_type,
  pr_offset_type,
  pr_method_type,
  pr_const_type,
  pr_volatile_type,
  pr_start_struct_type,
  pr_struct_field,
  pr_end_struct_type,
  pr_start_class_type,
  pr_class_static_member,
  pr_class_baseclass,
  pr_class_start_method,
  pr_class_method_variant,
  pr_class_static_method_variant,
  pr_class_end_method,
  pr_end_class_type,
  pr_typedef_type,
  pr_tag_type,
  pr_typdef,
  pr_tag,
  pr_int_constant,
  pr_float_constant,
  pr_typed_constant,
  pr_variable,
  pr_start_function,
  pr_function_parameter,
  pr_start_block,
  pr_end_block,
  pr_end_function,
  pr_lineno
};

static const struct debug_write_fns tg_fns =
{
  tg_start_compilation_unit,
  tg_start_source,
  pr_empty_type,		/* Same, push_type.  */
  pr_void_type,			/* Same, push_type.  */
  pr_int_type,			/* Same, push_type.  */
  pr_float_type,		/* Same, push_type.  */
  pr_complex_type,		/* Same, push_type.  */
  pr_bool_type,			/* Same, push_type.  */
  tg_enum_type,
  pr_pointer_type,		/* Same, changes to pointer.  */
  pr_function_type,		/* Same, push_type.  */
  pr_reference_type,		/* Same, changes to reference.  */
  pr_range_type,		/* FIXME: What's that?.  */
  pr_array_type,		/* Same, push_type.  */
  pr_set_type,			/* FIXME: What's that?.  */
  pr_offset_type,		/* FIXME: What's that?.  */
  pr_method_type,		/* Same.  */
  pr_const_type,		/* Same, changes to const.  */
  pr_volatile_type,		/* Same, changes to volatile.  */
  tg_start_struct_type,
  tg_struct_field,
  tg_end_struct_type,
  tg_start_class_type,
  tg_class_static_member,
  tg_class_baseclass,
  pr_class_start_method,	/* Same, remembers that's a method.  */
  tg_class_method_variant,
  tg_class_static_method_variant,
  pr_class_end_method,		/* Same, forgets that's a method.  */
  tg_end_class_type,
  pr_typedef_type,		/* Same, just push type.  */
  tg_tag_type,
  tg_typdef,
  tg_tag,
  tg_int_constant,		/* Untested.  */
  tg_float_constant,		/* Untested.  */
  tg_typed_constant,		/* Untested.  */
  tg_variable,
  tg_start_function,
  tg_function_parameter,
  tg_start_block,
  tg_end_block,
  pr_end_function,		/* Same, does nothing.  */
  tg_lineno
};

/* Print out the generic debugging information recorded in dhandle.  */

bfd_boolean
print_debugging_info (FILE *f, void *dhandle, bfd *abfd, asymbol **syms,
		      void *demangler, bfd_boolean as_tags)
{
  struct pr_handle info;

  info.f = f;
  info.indent = 0;
  info.stack = NULL;
  info.parameter = 0;
  info.filename = NULL;
  info.abfd = abfd;
  info.syms = syms;
  info.demangler = demangler;

  if (as_tags)
    {
      fputs ("!_TAG_FILE_FORMAT\t2\t/extended format/\n", f);
      fputs ("!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted/\n", f);
      fputs ("!_TAG_PROGRAM_AUTHOR\tIan Lance Taylor, Salvador E. Tropea and others\t//\n", f);
      fputs ("!_TAG_PROGRAM_NAME\tobjdump\t/From GNU binutils/\n", f);
    }

  return as_tags ? debug_write (dhandle, &tg_fns, (void *) & info)
    : debug_write (dhandle, &pr_fns, (void *) & info);
}

/* Indent to the current indentation level.  */

static void
indent (struct pr_handle *info)
{
  unsigned int i;

  for (i = 0; i < info->indent; i++)
    putc (' ', info->f);
}

/* Push a type on the type stack.  */

static bfd_boolean
push_type (struct pr_handle *info, const char *type)
{
  struct pr_stack *n;

  if (type == NULL)
    return FALSE;

  n = (struct pr_stack *) xmalloc (sizeof *n);
  memset (n, 0, sizeof *n);

  n->type = xstrdup (type);
  n->visibility = DEBUG_VISIBILITY_IGNORE;
  n->method = NULL;
  n->next = info->stack;
  info->stack = n;

  return TRUE;
}

/* Prepend a string onto the type on the top of the type stack.  */

static bfd_boolean
prepend_type (struct pr_handle *info, const char *s)
{
  char *n;

  assert (info->stack != NULL);

  n = (char *) xmalloc (strlen (s) + strlen (info->stack->type) + 1);
  sprintf (n, "%s%s", s, info->stack->type);
  free (info->stack->type);
  info->stack->type = n;

  return TRUE;
}

/* Append a string to the type on the top of the type stack.  */

static bfd_boolean
append_type (struct pr_handle *info, const char *s)
{
  unsigned int len;

  if (s == NULL)
    return FALSE;

  assert (info->stack != NULL);

  len = strlen (info->stack->type);
  info->stack->type = (char *) xrealloc (info->stack->type,
					 len + strlen (s) + 1);
  strcpy (info->stack->type + len, s);

  return TRUE;
}

/* Append a string to the parents on the top of the type stack.  */

static bfd_boolean
append_parent (struct pr_handle *info, const char *s)
{
  unsigned int len;

  if (s == NULL)
    return FALSE;

  assert (info->stack != NULL);

  len = info->stack->parents ? strlen (info->stack->parents) : 0;
  info->stack->parents = (char *) xrealloc (info->stack->parents,
					    len + strlen (s) + 1);
  strcpy (info->stack->parents + len, s);

  return TRUE;
}

/* We use an underscore to indicate where the name should go in a type
   string.  This function substitutes a string for the underscore.  If
   there is no underscore, the name follows the type.  */

static bfd_boolean
substitute_type (struct pr_handle *info, const char *s)
{
  char *u;

  assert (info->stack != NULL);

  u = strchr (info->stack->type, '|');
  if (u != NULL)
    {
      char *n;

      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
      strcat (n, u + 1);

      free (info->stack->type);
      info->stack->type = n;

      return TRUE;
    }

  if (strchr (s, '|') != NULL
      && (strchr (info->stack->type, '{') != NULL
	  || strchr (info->stack->type, '(') != NULL))
    {
      if (! prepend_type (info, "(")
	  || ! append_type (info, ")"))
	return FALSE;
    }

  if (*s == '\0')
    return TRUE;

  return (append_type (info, " ")
	  && append_type (info, s));
}

/* Indent the type at the top of the stack by appending spaces.  */

static bfd_boolean
indent_type (struct pr_handle *info)
{
  unsigned int i;

  for (i = 0; i < info->indent; i++)
    {
      if (! append_type (info, " "))
	return FALSE;
    }

  return TRUE;
}

/* Pop a type from the type stack.  */

static char *
pop_type (struct pr_handle *info)
{
  struct pr_stack *o;
  char *ret;

  assert (info->stack != NULL);

  o = info->stack;
  info->stack = o->next;
  ret = o->type;
  free (o);

  return ret;
}

/* Print a VMA value into a string.  */

static void
print_vma (bfd_vma vma, char *buf, bfd_boolean unsignedp, bfd_boolean hexp)
{
  if (sizeof (vma) <= sizeof (unsigned long))
    {
      if (hexp)
	sprintf (buf, "0x%lx", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, "%lu", (unsigned long) vma);
      else
	sprintf (buf, "%ld", (long) vma);
    }
  else
    {
      buf[0] = '0';
      buf[1] = 'x';
      sprintf_vma (buf + 2, vma);
    }
}

/* Start a new compilation unit.  */

static bfd_boolean
pr_start_compilation_unit (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->indent == 0);

  fprintf (info->f, "%s:\n", filename);

  return TRUE;
}

/* Start a source file within a compilation unit.  */

static bfd_boolean
pr_start_source (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->indent == 0);

  fprintf (info->f, " %s:\n", filename);

  return TRUE;
}

/* Push an empty type onto the type stack.  */

static bfd_boolean
pr_empty_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, "<undefined>");
}

/* Push a void type onto the type stack.  */

static bfd_boolean
pr_void_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, "void");
}

/* Push an integer type onto the type stack.  */

static bfd_boolean
pr_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  sprintf (ab, "%sint%d", unsignedp ? "u" : "", size * 8);
  return push_type (info, ab);
}

/* Push a floating type onto the type stack.  */

static bfd_boolean
pr_float_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  if (size == 4)
    return push_type (info, "float");
  else if (size == 8)
    return push_type (info, "double");

  sprintf (ab, "float%d", size * 8);
  return push_type (info, ab);
}

/* Push a complex type onto the type stack.  */

static bfd_boolean
pr_complex_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;

  if (! pr_float_type (p, size))
    return FALSE;

  return prepend_type (info, "complex ");
}

/* Push a bfd_boolean type onto the type stack.  */

static bfd_boolean
pr_bool_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  sprintf (ab, "bool%d", size * 8);

  return push_type (info, ab);
}

/* Push an enum type onto the type stack.  */

static bfd_boolean
pr_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int i;
  bfd_signed_vma val;

  if (! push_type (info, "enum "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag)
	  || ! append_type (info, " "))
	return FALSE;
    }
  if (! append_type (info, "{ "))
    return FALSE;

  if (names == NULL)
    {
      if (! append_type (info, "/* undefined */"))
	return FALSE;
    }
  else
    {
      val = 0;
      for (i = 0; names[i] != NULL; i++)
	{
	  if (i > 0)
	    {
	      if (! append_type (info, ", "))
		return FALSE;
	    }

	  if (! append_type (info, names[i]))
	    return FALSE;

	  if (values[i] != val)
	    {
	      char ab[20];

	      print_vma (values[i], ab, FALSE, FALSE);
	      if (! append_type (info, " = ")
		  || ! append_type (info, ab))
		return FALSE;
	      val = values[i];
	    }

	  ++val;
	}
    }

  return append_type (info, " }");
}

/* Turn the top type on the stack into a pointer.  */

static bfd_boolean
pr_pointer_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  assert (info->stack != NULL);

  s = strchr (info->stack->type, '|');
  if (s != NULL && s[1] == '[')
    return substitute_type (info, "(*|)");
  return substitute_type (info, "*|");
}

/* Turn the top type on the stack into a function returning that type.  */

static bfd_boolean
pr_function_type (void *p, int argcount, bfd_boolean varargs)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char **arg_types;
  unsigned int len;
  char *s;

  assert (info->stack != NULL);

  len = 10;

  if (argcount <= 0)
    {
      arg_types = NULL;
      len += 15;
    }
  else
    {
      int i;

      arg_types = (char **) xmalloc (argcount * sizeof *arg_types);
      for (i = argcount - 1; i >= 0; i--)
	{
	  if (! substitute_type (info, ""))
	    return FALSE;
	  arg_types[i] = pop_type (info);
	  if (arg_types[i] == NULL)
	    return FALSE;
	  len += strlen (arg_types[i]) + 2;
	}
      if (varargs)
	len += 5;
    }

  /* Now the return type is on the top of the stack.  */

  s = (char *) xmalloc (len);
  strcpy (s, "(|) (");

  if (argcount < 0)
    strcat (s, "/* unknown */");
  else
    {
      int i;

      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, arg_types[i]);
	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, "...");
	}
      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, ")");

  if (! substitute_type (info, s))
    return FALSE;

  free (s);

  return TRUE;
}

/* Turn the top type on the stack into a reference to that type.  */

static bfd_boolean
pr_reference_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->stack != NULL);

  return substitute_type (info, "&|");
}

/* Make a range type.  */

static bfd_boolean
pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char abl[20], abu[20];

  assert (info->stack != NULL);

  if (! substitute_type (info, ""))
    return FALSE;

  print_vma (lower, abl, FALSE, FALSE);
  print_vma (upper, abu, FALSE, FALSE);

  return (prepend_type (info, "range (")
	  && append_type (info, "):")
	  && append_type (info, abl)
	  && append_type (info, ":")
	  && append_type (info, abu));
}

/* Make an array type.  */

static bfd_boolean
pr_array_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper,
	       bfd_boolean stringp)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *range_type;
  char abl[20], abu[20], ab[50];

  range_type = pop_type (info);
  if (range_type == NULL)
    return FALSE;

  if (lower == 0)
    {
      if (upper == -1)
	sprintf (ab, "|[]");
      else
	{
	  print_vma (upper + 1, abu, FALSE, FALSE);
	  sprintf (ab, "|[%s]", abu);
	}
    }
  else
    {
      print_vma (lower, abl, FALSE, FALSE);
      print_vma (upper, abu, FALSE, FALSE);
      sprintf (ab, "|[%s:%s]", abl, abu);
    }

  if (! substitute_type (info, ab))
    return FALSE;

  if (strcmp (range_type, "int") != 0)
    {
      if (! append_type (info, ":")
	  || ! append_type (info, range_type))
	return FALSE;
    }

  if (stringp)
    {
      if (! append_type (info, " /* string */"))
	return FALSE;
    }

  return TRUE;
}

/* Make a set type.  */

static bfd_boolean
pr_set_type (void *p, bfd_boolean bitstringp)
{
  struct pr_handle *info = (struct pr_handle *) p;

  if (! substitute_type (info, ""))
    return FALSE;

  if (! prepend_type (info, "set { ")
      || ! append_type (info, " }"))
    return FALSE;

  if (bitstringp)
    {
      if (! append_type (info, "/* bitstring */"))
	return FALSE;
    }

  return TRUE;
}

/* Make an offset type.  */

static bfd_boolean
pr_offset_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, ""))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  return (substitute_type (info, "")
	  && prepend_type (info, " ")
	  && prepend_type (info, t)
	  && append_type (info, "::|"));
}

/* Make a method type.  */

static bfd_boolean
pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int len;
  char *domain_type;
  char **arg_types;
  char *s;

  len = 10;

  if (! domain)
    domain_type = NULL;
  else
    {
      if (! substitute_type (info, ""))
	return FALSE;
      domain_type = pop_type (info);
      if (domain_type == NULL)
	return FALSE;
      if (strncmp (domain_type, "class ", sizeof "class " - 1) == 0
	  && strchr (domain_type + sizeof "class " - 1, ' ') == NULL)
	domain_type += sizeof "class " - 1;
      else if (strncmp (domain_type, "union class ",
			sizeof "union class ") == 0
	       && (strchr (domain_type + sizeof "union class " - 1, ' ')
		   == NULL))
	domain_type += sizeof "union class " - 1;
      len += strlen (domain_type);
    }

  if (argcount <= 0)
    {
      arg_types = NULL;
      len += 15;
    }
  else
    {
      int i;

      arg_types = (char **) xmalloc (argcount * sizeof *arg_types);
      for (i = argcount - 1; i >= 0; i--)
	{
	  if (! substitute_type (info, ""))
	    return FALSE;
	  arg_types[i] = pop_type (info);
	  if (arg_types[i] == NULL)
	    return FALSE;
	  len += strlen (arg_types[i]) + 2;
	}
      if (varargs)
	len += 5;
    }

  /* Now the return type is on the top of the stack.  */

  s = (char *) xmalloc (len);
  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
  strcat (s, "::| (");

  if (argcount < 0)
    strcat (s, "/* unknown */");
  else
    {
      int i;

      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, arg_types[i]);
	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, "...");
	}
      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, ")");

  if (! substitute_type (info, s))
    return FALSE;

  free (s);

  return TRUE;
}

/* Make a const qualified type.  */

static bfd_boolean
pr_const_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return substitute_type (info, "const |");
}

/* Make a volatile qualified type.  */

static bfd_boolean
pr_volatile_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return substitute_type (info, "volatile |");
}

/* Start accumulating a struct type.  */

static bfd_boolean
pr_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;

  info->indent += 2;

  if (! push_type (info, structp ? "struct " : "union "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag))
	return FALSE;
    }
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  if (! append_type (info, " {"))
    return FALSE;
  if (size != 0 || tag != NULL)
    {
      char ab[30];

      if (! append_type (info, " /*"))
	return FALSE;

      if (size != 0)
	{
	  sprintf (ab, " size %u", size);
	  if (! append_type (info, ab))
	    return FALSE;
	}
      if (tag != NULL)
	{
	  sprintf (ab, " id %u", id);
	  if (! append_type (info, ab))
	    return FALSE;
	}
      if (! append_type (info, " */"))
	return FALSE;
    }
  if (! append_type (info, "\n"))
    return FALSE;

  info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;

  return indent_type (info);
}

/* Output the visibility of a field in a struct.  */

static bfd_boolean
pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
{
  const char *s = NULL;
  char *t;
  unsigned int len;

  assert (info->stack != NULL);

  if (info->stack->visibility == visibility)
    return TRUE;

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      s = "public";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      s = "private";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      s = "protected";
      break;
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
    default:
      abort ();
      return FALSE;
    }

  /* Trim off a trailing space in the struct string, to make the
     output look a bit better, then stick on the visibility string.  */

  t = info->stack->type;
  len = strlen (t);
  assert (t[len - 1] == ' ');
  t[len - 1] = '\0';

  if (! append_type (info, s)
      || ! append_type (info, ":\n")
      || ! indent_type (info))
    return FALSE;

  info->stack->visibility = visibility;

  return TRUE;
}

/* Add a field to a struct type.  */

static bfd_boolean
pr_struct_field (void *p, const char *name, bfd_vma bitpos, bfd_vma bitsize,
		 enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  if (! append_type (info, "; /* "))
    return FALSE;

  if (bitsize != 0)
    {
      print_vma (bitsize, ab, TRUE, FALSE);
      if (! append_type (info, "bitsize ")
	  || ! append_type (info, ab)
	  || ! append_type (info, ", "))
	return FALSE;
    }

  print_vma (bitpos, ab, TRUE, FALSE);
  if (! append_type (info, "bitpos ")
      || ! append_type (info, ab)
      || ! append_type (info, " */\n")
      || ! indent_type (info))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return append_type (info, t);
}

/* Finish a struct type.  */

static bfd_boolean
pr_end_struct_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  assert (info->stack != NULL);
  assert (info->indent >= 2);

  info->indent -= 2;

  /* Change the trailing indentation to have a close brace.  */
  s = info->stack->type + strlen (info->stack->type) - 2;
  assert (s[0] == ' ' && s[1] == ' ' && s[2] == '\0');

  *s++ = '}';
  *s = '\0';

  return TRUE;
}

/* Start a class type.  */

static bfd_boolean
pr_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *tv = NULL;

  info->indent += 2;

  if (vptr && ! ownvptr)
    {
      tv = pop_type (info);
      if (tv == NULL)
	return FALSE;
    }

  if (! push_type (info, structp ? "class " : "union class "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag))
	return FALSE;
    }
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  if (! append_type (info, " {"))
    return FALSE;
  if (size != 0 || vptr || ownvptr || tag != NULL)
    {
      if (! append_type (info, " /*"))
	return FALSE;

      if (size != 0)
	{
	  char ab[20];

	  sprintf (ab, "%u", size);
	  if (! append_type (info, " size ")
	      || ! append_type (info, ab))
	    return FALSE;
	}

      if (vptr)
	{
	  if (! append_type (info, " vtable "))
	    return FALSE;
	  if (ownvptr)
	    {
	      if (! append_type (info, "self "))
		return FALSE;
	    }
	  else
	    {
	      if (! append_type (info, tv)
		  || ! append_type (info, " "))
		return FALSE;
	    }
	}

      if (tag != NULL)
	{
	  char ab[30];

	  sprintf (ab, " id %u", id);
	  if (! append_type (info, ab))
	    return FALSE;
	}

      if (! append_type (info, " */"))
	return FALSE;
    }

  info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;

  return (append_type (info, "\n")
	  && indent_type (info));
}

/* Add a static member to a class.  */

static bfd_boolean
pr_class_static_member (void *p, const char *name, const char *physname,
			enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  if (! prepend_type (info, "static ")
      || ! append_type (info, "; /* ")
      || ! append_type (info, physname)
      || ! append_type (info, " */\n")
      || ! indent_type (info))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return append_type (info, t);
}

/* Add a base class to a class.  */

static bfd_boolean
pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
		    enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *prefix;
  char ab[20];
  char *s, *l, *n;

  assert (info->stack != NULL && info->stack->next != NULL);

  if (! substitute_type (info, ""))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (strncmp (t, "class ", sizeof "class " - 1) == 0)
    t += sizeof "class " - 1;

  /* Push it back on to take advantage of the prepend_type and
     append_type routines.  */
  if (! push_type (info, t))
    return FALSE;

  if (virtual)
    {
      if (! prepend_type (info, "virtual "))
	return FALSE;
    }

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      prefix = "public ";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      prefix = "protected ";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      prefix = "private ";
      break;
    default:
      prefix = "/* unknown visibility */ ";
      break;
    }

  if (! prepend_type (info, prefix))
    return FALSE;

  if (bitpos != 0)
    {
      print_vma (bitpos, ab, TRUE, FALSE);
      if (! append_type (info, " /* bitpos ")
	  || ! append_type (info, ab)
	  || ! append_type (info, " */"))
	return FALSE;
    }

  /* Now the top of the stack is something like "public A / * bitpos
     10 * /".  The next element on the stack is something like "class
     xx { / * size 8 * /\n...".  We want to substitute the top of the
     stack in before the {.  */
  s = strchr (info->stack->next->type, '{');
  assert (s != NULL);
  --s;

  /* If there is already a ':', then we already have a baseclass, and
     we must append this one after a comma.  */
  for (l = info->stack->next->type; l != s; l++)
    if (*l == ':')
      break;
  if (! prepend_type (info, l == s ? " : " : ", "))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
  strcat (n, s);

  free (info->stack->type);
  info->stack->type = n;

  free (t);

  return TRUE;
}

/* Start adding a method to a class.  */

static bfd_boolean
pr_class_start_method (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->stack != NULL);
  info->stack->method = name;
  return TRUE;
}

/* Add a variant to a method.  */

static bfd_boolean
pr_class_method_variant (void *p, const char *physname,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset, bfd_boolean context)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *context_type;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info,
			 (context
			  ? info->stack->next->next->method
			  : info->stack->next->method)))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Pull off the context type if there is one.  */
  if (! context)
    context_type = NULL;
  else
    {
      context_type = pop_type (info);
      if (context_type == NULL)
	return FALSE;
    }

  /* Now the top of the stack is the class.  */

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  if (! append_type (info, method_type)
      || ! append_type (info, " /* ")
      || ! append_type (info, physname)
      || ! append_type (info, " "))
    return FALSE;
  if (context || voffset != 0)
    {
      char ab[20];

      if (context)
	{
	  if (! append_type (info, "context ")
	      || ! append_type (info, context_type)
	      || ! append_type (info, " "))
	    return FALSE;
	}
      print_vma (voffset, ab, TRUE, FALSE);
      if (! append_type (info, "voffset ")
	  || ! append_type (info, ab))
	return FALSE;
    }

  return (append_type (info, " */;\n")
	  && indent_type (info));
}

/* Add a static variant to a method.  */

static bfd_boolean
pr_class_static_method_variant (void *p, const char *physname,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);
  assert (info->stack->next->method != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Mark it as static.  */
  if (! prepend_type (info, "static "))
    return FALSE;

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, info->stack->next->method))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Now the top of the stack is the class.  */

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return (append_type (info, method_type)
	  && append_type (info, " /* ")
	  && append_type (info, physname)
	  && append_type (info, " */;\n")
	  && indent_type (info));
}

/* Finish up a method.  */

static bfd_boolean
pr_class_end_method (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  info->stack->method = NULL;
  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
pr_end_class_type (void *p)
{
  return pr_end_struct_type (p);
}

/* Push a type on the stack using a typedef name.  */

static bfd_boolean
pr_typedef_type (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, name);
}

/* Push a type on the stack using a tag name.  */

static bfd_boolean
pr_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *t, *tag;
  char idbuf[20];

  switch (kind)
    {
    case DEBUG_KIND_STRUCT:
      t = "struct ";
      break;
    case DEBUG_KIND_UNION:
      t = "union ";
      break;
    case DEBUG_KIND_ENUM:
      t = "enum ";
      break;
    case DEBUG_KIND_CLASS:
      t = "class ";
      break;
    case DEBUG_KIND_UNION_CLASS:
      t = "union class ";
      break;
    default:
      abort ();
      return FALSE;
    }

  if (! push_type (info, t))
    return FALSE;
  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, "%%anon%u", id);
      tag = idbuf;
    }

  if (! append_type (info, tag))
    return FALSE;
  if (name != NULL && kind != DEBUG_KIND_ENUM)
    {
      sprintf (idbuf, " /* id %u */", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  return TRUE;
}

/* Output a typedef.  */

static bfd_boolean
pr_typdef (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  if (! substitute_type (info, name))
    return FALSE;

  s = pop_type (info);
  if (s == NULL)
    return FALSE;

  indent (info);
  fprintf (info->f, "typedef %s;\n", s);

  free (s);

  return TRUE;
}

/* Output a tag.  The tag should already be in the string on the
   stack, so all we have to do here is print it out.  */

static bfd_boolean
pr_tag (void *p, const char *name ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  fprintf (info->f, "%s;\n", t);

  free (t);

  return TRUE;
}

/* Output an integer constant.  */

static bfd_boolean
pr_int_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "const int %s = %s;\n", name, ab);
  return TRUE;
}

/* Output a floating point constant.  */

static bfd_boolean
pr_float_constant (void *p, const char *name, double val)
{
  struct pr_handle *info = (struct pr_handle *) p;

  indent (info);
  fprintf (info->f, "const double %s = %g;\n", name, val);
  return TRUE;
}

/* Output a typed constant.  */

static bfd_boolean
pr_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "const %s %s = %s;\n", t, name, ab);

  free (t);

  return TRUE;
}

/* Output a variable.  */

static bfd_boolean
pr_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  switch (kind)
    {
    case DEBUG_STATIC:
    case DEBUG_LOCAL_STATIC:
      fprintf (info->f, "static ");
      break;
    case DEBUG_REGISTER:
      fprintf (info->f, "register ");
      break;
    default:
      break;
    }
  print_vma (val, ab, TRUE, TRUE);
  fprintf (info->f, "%s /* %s */;\n", t, ab);

  free (t);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
pr_start_function (void *p, const char *name, bfd_boolean global)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  if (! global)
    fprintf (info->f, "static ");
  fprintf (info->f, "%s (", t);

  info->parameter = 1;

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
pr_function_parameter (void *p, const char *name,
		       enum debug_parm_kind kind, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  if (kind == DEBUG_PARM_REFERENCE
      || kind == DEBUG_PARM_REF_REG)
    {
      if (! pr_reference_type (p))
	return FALSE;
    }

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (info->parameter != 1)
    fprintf (info->f, ", ");

  if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)
    fprintf (info->f, "register ");

  print_vma (val, ab, TRUE, TRUE);
  fprintf (info->f, "%s /* %s */", t, ab);

  free (t);

  ++info->parameter;

  return TRUE;
}

/* Start writing out a block.  */

static bfd_boolean
pr_start_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  if (info->parameter > 0)
    {
      fprintf (info->f, ")\n");
      info->parameter = 0;
    }

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "{ /* %s */\n", ab);

  info->indent += 2;

  return TRUE;
}

/* Write out line number information.  */

static bfd_boolean
pr_lineno (void *p, const char *filename, unsigned long lineno, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "/* file %s line %lu addr %s */\n", filename, lineno, ab);

  return TRUE;
}

/* Finish writing out a block.  */

static bfd_boolean
pr_end_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  info->indent -= 2;

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "} /* %s */\n", ab);

  return TRUE;
}

/* Finish writing out a function.  */

static bfd_boolean
pr_end_function (void *p ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Tags style generation functions start here.  */

/* Variables for address to line translation.  */
static bfd_vma pc;
static const char *filename;
static const char *functionname;
static unsigned int line;
static bfd_boolean found;

/* Look for an address in a section.  This is called via
   bfd_map_over_sections.  */

static void
find_address_in_section (bfd *abfd, asection *section, void *data)
{
  bfd_vma vma;
  bfd_size_type size;
  asymbol **syms = (asymbol **) data;

  if (found)
    return;

  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)
    return;

  vma = bfd_get_section_vma (abfd, section);
  if (pc < vma)
    return;

  size = bfd_get_section_size_before_reloc (section);
  if (pc >= vma + size)
    return;

  found = bfd_find_nearest_line (abfd, section, syms, pc - vma,
				 &filename, &functionname, &line);
}

static void
translate_addresses (bfd *abfd, char *addr_hex, FILE *f, asymbol **syms)
{
  pc = bfd_scan_vma (addr_hex, NULL, 16);
  found = FALSE;
  bfd_map_over_sections (abfd, find_address_in_section, syms);

  if (! found)
    fprintf (f, "??");
  else
    fprintf (f, "%u", line);
}

/* Start a new compilation unit.  */

static bfd_boolean
tg_start_compilation_unit (void * p, const char *filename ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;

  fprintf (stderr, "New compilation unit: %s\n", filename);

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (filename);

  return TRUE;
}

/* Start a source file within a compilation unit.  */

static bfd_boolean
tg_start_source (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (filename);

  return TRUE;
}

/* Push an enum type onto the type stack.  */

static bfd_boolean
tg_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int i;
  const char *name;
  char ab[20];

  if (! pr_enum_type (p, tag, names, values))
    return FALSE;

  name = tag ? tag : "unknown";
  /* Generate an entry for the enum.  */
  if (tag)
    fprintf (info->f, "%s\t%s\t0;\"\tkind:e\ttype:%s\n", tag,
	     info->filename, info->stack->type);

  /* Generate entries for the values.  */
  if (names != NULL)
    {
      for (i = 0; names[i] != NULL; i++)
	{
	  print_vma (values[i], ab, FALSE, FALSE);
	  fprintf (info->f, "%s\t%s\t0;\"\tkind:g\tenum:%s\tvalue:%s\n",
		   names[i], info->filename, name, ab);
	}
    }

  return TRUE;
}

/* Start accumulating a struct type.  */

static bfd_boolean
tg_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp,
		      unsigned int size ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *name;
  char idbuf[20];

  if (tag != NULL)
    name = tag;
  else
    {
      name = idbuf;
      sprintf (idbuf, "%%anon%u", id);
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "struct" : "union";

  fprintf (info->f, "%s\t%s\t0;\"\tkind:%c\n", name, info->filename,
	   info->stack->flavor[0]);

  info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;

  return indent_type (info);
}

/* Output the visibility of a field in a struct.  */

static bfd_boolean
tg_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
{
  assert (info->stack != NULL);

  if (info->stack->visibility == visibility)
    return TRUE;

  assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);

  info->stack->visibility = visibility;

  return TRUE;
}

/* Add a field to a struct type.  */

static bfd_boolean
tg_struct_field (void *p, const char *name, bfd_vma bitpos ATTRIBUTE_UNUSED,
		 bfd_vma bitsize ATTRIBUTE_UNUSED,
		 enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  /* It happens, a bug? */
  if (! name[0])
    return TRUE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:m\ttype:%s\t%s:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->flavor, info->stack->type,
	   visibility_name (visibility));

  return TRUE;
}

/* Finish a struct type.  */

static bfd_boolean
tg_end_struct_type (void *p ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  assert (info->stack != NULL);

  return TRUE;
}

/* Start a class type.  */

static bfd_boolean
tg_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *tv = NULL;
  const char *name;

  info->indent += 2;

  if (vptr && ! ownvptr)
    {
      tv = pop_type (info);
      if (tv == NULL)
	return FALSE;
    }

  if (tag != NULL)
    name = tag;
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      name = idbuf;
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "class" : "union class";
  info->stack->parents = NULL;
  info->stack->num_parents = 0;

  if (size != 0 || vptr || ownvptr || tag != NULL)
    {
      if (vptr)
	{
	  if (! append_type (info, " vtable "))
	    return FALSE;
	  if (ownvptr)
	    {
	      if (! append_type (info, "self "))
		return FALSE;
	    }
	  else
	    {
	      if (! append_type (info, tv)
		  || ! append_type (info, " "))
		return FALSE;
	    }
	}
    }

  info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;

  return TRUE;
}

/* Add a static member to a class.  */

static bfd_boolean
tg_class_static_member (void *p, const char *name,
			const char *physname ATTRIBUTE_UNUSED,
			enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  int len_var, len_class;
  char *full_name;

  len_var = strlen (name);
  len_class = strlen (info->stack->next->type);
  full_name = (char *) xmalloc (len_var + len_class + 3);
  if (! full_name)
    return FALSE;
  memcpy (full_name, info->stack->next->type, len_class);
  memcpy (full_name + len_class, "::", 2);
  memcpy (full_name + len_class + 2, name, len_var + 1);

  if (! substitute_type (info, full_name))
    return FALSE;

  if (! prepend_type (info, "static "))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:x\ttype:%s\tclass:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->type,
	   visibility_name (visibility));
  free (t);
  free (full_name);

  return TRUE;
}

/* Add a base class to a class.  */

static bfd_boolean
tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,
		    bfd_boolean virtual, enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *prefix;

  assert (info->stack != NULL && info->stack->next != NULL);

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (strncmp (t, "class ", sizeof "class " - 1) == 0)
    t += sizeof "class " - 1;

  /* Push it back on to take advantage of the prepend_type and
     append_type routines.  */
  if (! push_type (info, t))
    return FALSE;

  if (virtual)
    {
      if (! prepend_type (info, "virtual "))
	return FALSE;
    }

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      prefix = "public ";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      prefix = "protected ";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      prefix = "private ";
      break;
    default:
      prefix = "/* unknown visibility */ ";
      break;
    }

  if (! prepend_type (info, prefix))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (info->stack->num_parents && ! append_parent (info, ", "))
    return FALSE;

  if (! append_parent (info, t))
    return FALSE;
  info->stack->num_parents++;

  free (t);

  return TRUE;
}

/* Add a variant to a method.  */

static bfd_boolean
tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset ATTRIBUTE_UNUSED,
			 bfd_boolean context)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *context_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  method_name = strdup (context ? info->stack->next->next->method
			: info->stack->next->method);

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, method_name))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Pull off the context type if there is one.  */
  if (! context)
    context_type = NULL;
  else
    {
      context_type = pop_type (info);
      if (context_type == NULL)
	return FALSE;
    }

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\n",
	   method_name, info->filename, method_type, info->stack->type);
  free (method_type);
  free (method_name);
  free (context_type);

  return TRUE;
}

/* Add a static variant to a method.  */

static bfd_boolean
tg_class_static_method_variant (void *p,
				const char *physname ATTRIBUTE_UNUSED,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);
  assert (info->stack->next->method != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Mark it as static.  */
  if (! prepend_type (info, "static "))
    return FALSE;

  method_name = strdup (info->stack->next->method);
  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, info->stack->next->method))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\taccess:%s\n",
	   method_name, info->filename, method_type, info->stack->type,
	   visibility_name (visibility));
  free (method_type);
  free (method_name);

  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
tg_end_class_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:c\ttype:%s", info->stack->type,
	   info->filename, info->stack->flavor);
  if (info->stack->num_parents)
    {
      fprintf  (info->f, "\tinherits:%s", info->stack->parents);
      free (info->stack->parents);
    }
  fputc ('\n', info->f);

  return tg_end_struct_type (p);
}

/* Push a type on the stack using a tag name.  */

static bfd_boolean
tg_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *t, *tag;
  char idbuf[20];

  switch (kind)
    {
    case DEBUG_KIND_STRUCT:
      t = "struct ";
      break;
    case DEBUG_KIND_UNION:
      t = "union ";
      break;
    case DEBUG_KIND_ENUM:
      t = "enum ";
      break;
    case DEBUG_KIND_CLASS:
      t = "class ";
      break;
    case DEBUG_KIND_UNION_CLASS:
      t = "union class ";
      break;
    default:
      abort ();
      return FALSE;
    }

  if (! push_type (info, t))
    return FALSE;
  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, "%%anon%u", id);
      tag = idbuf;
    }

  if (! append_type (info, tag))
    return FALSE;

  return TRUE;
}

/* Output a typedef.  */

static bfd_boolean
tg_typdef (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  s = pop_type (info);
  if (s == NULL)
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:t\ttype:%s\n", name,
	   info->filename, s);

  free (s);

  return TRUE;
}

/* Output a tag.  The tag should already be in the string on the
   stack, so all we have to do here is print it out.  */

static bfd_boolean
tg_tag (void *p ATTRIBUTE_UNUSED, const char *name ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;
  free (t);

  return TRUE;
}

/* Output an integer constant.  */

static bfd_boolean
tg_int_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const int\tvalue:%s\n",
	   name, info->filename, ab);
  return TRUE;
}

/* Output a floating point constant.  */

static bfd_boolean
tg_float_constant (void *p, const char *name, double val)
{
  struct pr_handle *info = (struct pr_handle *) p;

  indent (info);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const double\tvalue:%g\n",
	   name, info->filename, val);
  return TRUE;
}

/* Output a typed constant.  */

static bfd_boolean
tg_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const %s\tvalue:%s\n",
	   name, info->filename, t, ab);

  free (t);

  return TRUE;
}

/* Output a variable.  */

static bfd_boolean
tg_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *dname, *from_class;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  dname = name;
  if (info->demangler)
    {
      dname = info->demangler (info->abfd, name);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }

  if (dname != name)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  *sep = 0;
	  name = sep + 2;
	  from_class = dname;
	}
      else
	{
	  /* Obscure types as vts and type_info nodes.  */
	  name = dname;
	  from_class = NULL;
	}
    }
  else
    from_class = NULL;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:%s", name, info->filename, t);

  switch (kind)
    {
    case DEBUG_STATIC:
    case DEBUG_LOCAL_STATIC:
      fprintf (info->f, "\tfile:");
      break;
    case DEBUG_REGISTER:
      fprintf (info->f, "\tregister:");
      break;
    default:
      break;
    }

  if (from_class)
    {
      fprintf (info->f, "\tclass:%s",from_class);
      free ((char *) dname);
    }

  fprintf (info->f, "\n");

  free (t);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
tg_start_function (void *p, const char *name, bfd_boolean global)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *dname;

  if (! global)
    info->stack->flavor = "static";
  else
    info->stack->flavor = NULL;

  dname = name;
  if (info->demangler)
    {
      dname = info->demangler (info->abfd, name);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }

  if (! substitute_type (info, dname))
    return FALSE;

  if (dname != name)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  info->stack->method = dname;
	  *sep = 0;
	  name = sep + 2;
	}
      else
	{
	  info->stack->method = "";
	  name = dname;
	}
      sep = strchr (name, '(');
      if (sep)
	*sep = 0;
      /* Obscure functions as type_info function.  */
    }
  else
    info->stack->method = NULL;

  info->stack->parents = strdup (name);

  if (! info->stack->method && ! append_type (info, "("))
    return FALSE;

  info->parameter = 1;

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
tg_function_parameter (void *p, const char *name, enum debug_parm_kind kind,
		       bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (kind == DEBUG_PARM_REFERENCE
      || kind == DEBUG_PARM_REF_REG)
    {
      if (! pr_reference_type (p))
	return FALSE;
    }

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! info->stack->method)
    {
      if (info->parameter != 1 && ! append_type (info, ", "))
	return FALSE;

      if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)
	if (! append_type (info, "register "))
	  return FALSE;

      if (! append_type (info, t))
	return FALSE;
    }

  free (t);

  ++info->parameter;

  return TRUE;
}

/* Start writing out a block.  */

static bfd_boolean
tg_start_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20], kind, *partof;
  char *t;
  bfd_boolean local;

  if (info->parameter > 0)
    {
      info->parameter = 0;

      /* Delayed name.  */
      fprintf (info->f, "%s\t%s\t", info->stack->parents, info->filename);
      free (info->stack->parents);

      print_vma (addr, ab, TRUE, TRUE);
      translate_addresses (info->abfd, ab, info->f, info->syms);
      local = info->stack->flavor != NULL;
      if (info->stack->method && *info->stack->method)
	{
	  kind = 'm';
	  partof = (char *) info->stack->method;
	}
      else
	{
	  kind = 'f';
	  partof = NULL;
	  if (! info->stack->method && ! append_type (info, ")"))
	    return FALSE;
	}
      t = pop_type (info);
      if (t == NULL)
	return FALSE;
      fprintf (info->f, ";\"\tkind:%c\ttype:%s", kind, t);
      if (local)
	fputs ("\tfile:", info->f);
      if (partof)
	{
	  fprintf (info->f, "\tclass:%s", partof);
	  free (partof);
	}
      fputc ('\n', info->f);
    }

  return TRUE;
}

/* Write out line number information.  */

static bfd_boolean
tg_lineno (void *p ATTRIBUTE_UNUSED, const char *filename ATTRIBUTE_UNUSED,
	   unsigned long lineno ATTRIBUTE_UNUSED,
	   bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Finish writing out a block.  */

static bfd_boolean
tg_end_block (void *p ATTRIBUTE_UNUSED, bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Convert the visibility value into a human readable name.  */

static const char *
visibility_name (enum debug_visibility visibility)
{
  const char *s;

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      s = "public";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      s = "private";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      s = "protected";
      break;
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
    default:
      abort ();
      return FALSE;
    }
  return s;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002 Free Software Foundation, Inc.
d4 1
d47 9
d70 7
d79 8
a86 16
static void indent
  PARAMS ((struct pr_handle *));
static bfd_boolean push_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean prepend_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean append_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean substitute_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean indent_type
  PARAMS ((struct pr_handle *));
static char *pop_type
  PARAMS ((struct pr_handle *));
static void print_vma
  PARAMS ((bfd_vma, char *, bfd_boolean, bfd_boolean));
d88 9
a96 17
  PARAMS ((struct pr_handle *, enum debug_visibility));
static bfd_boolean pr_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean pr_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean pr_empty_type
  PARAMS ((PTR));
static bfd_boolean pr_void_type
  PARAMS ((PTR));
static bfd_boolean pr_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean pr_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_bool_type
  PARAMS ((PTR, unsigned int));
d98 5
a102 9
  PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
static bfd_boolean pr_pointer_type
  PARAMS ((PTR));
static bfd_boolean pr_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean pr_reference_type
  PARAMS ((PTR));
static bfd_boolean pr_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d104 6
a109 11
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean pr_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean pr_offset_type
  PARAMS ((PTR));
static bfd_boolean pr_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean pr_const_type
  PARAMS ((PTR));
static bfd_boolean pr_volatile_type
  PARAMS ((PTR));
d111 1
a111 1
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d113 2
a114 3
  PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
static bfd_boolean pr_end_struct_type
  PARAMS ((PTR));
d116 2
a117 2
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
d119 1
a119 1
  PARAMS ((PTR, const char *, const char *, enum debug_visibility));
d121 2
a122 3
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean pr_class_start_method
  PARAMS ((PTR, const char *));
d124 2
a125 2
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
d127 4
a130 8
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean pr_class_end_method
  PARAMS ((PTR));
static bfd_boolean pr_end_class_type
  PARAMS ((PTR));
static bfd_boolean pr_typedef_type
  PARAMS ((PTR, const char *));
d132 6
a137 11
  PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
static bfd_boolean pr_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean pr_tag
  PARAMS ((PTR, const char *));
static bfd_boolean pr_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean pr_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean pr_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
d139 2
a140 3
  PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
static bfd_boolean pr_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
d142 53
a194 10
  PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
static bfd_boolean pr_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_function
  PARAMS ((PTR));
static bfd_boolean pr_lineno
  PARAMS ((PTR, const char *, unsigned long, bfd_vma));

d243 48
d294 2
a295 3
print_debugging_info (f, dhandle)
     FILE *f;
     PTR dhandle;
d303 12
d316 2
a317 1
  return debug_write (dhandle, &pr_fns, (PTR) &info);
d323 1
a323 2
indent (info)
     struct pr_handle *info;
d334 1
a334 3
push_type (info, type)
     struct pr_handle *info;
     const char *type;
d356 1
a356 3
prepend_type (info, s)
     struct pr_handle *info;
     const char *s;
d373 1
a373 3
append_type (info, s)
     struct pr_handle *info;
     const char *s;
d390 20
d415 1
a415 3
substitute_type (info, s)
     struct pr_handle *info;
     const char *s;
d457 1
a457 2
indent_type (info)
     struct pr_handle *info;
d473 1
a473 2
pop_type (info)
     struct pr_handle *info;
d491 1
a491 5
print_vma (vma, buf, unsignedp, hexp)
     bfd_vma vma;
     char *buf;
     bfd_boolean unsignedp;
     bfd_boolean hexp;
d513 1
a513 3
pr_start_compilation_unit (p, filename)
     PTR p;
     const char *filename;
d527 1
a527 3
pr_start_source (p, filename)
     PTR p;
     const char *filename;
d541 1
a541 2
pr_empty_type (p)
     PTR p;
d551 1
a551 2
pr_void_type (p)
     PTR p;
d561 1
a561 4
pr_int_type (p, size, unsignedp)
     PTR p;
     unsigned int size;
     bfd_boolean unsignedp;
d573 1
a573 3
pr_float_type (p, size)
     PTR p;
     unsigned int size;
d590 1
a590 3
pr_complex_type (p, size)
     PTR p;
     unsigned int size;
d603 1
a603 3
pr_bool_type (p, size)
     PTR p;
     unsigned int size;
d616 2
a617 5
pr_enum_type (p, tag, names, values)
     PTR p;
     const char *tag;
     const char **names;
     bfd_signed_vma *values;
d674 1
a674 2
pr_pointer_type (p)
     PTR p;
d690 1
a690 4
pr_function_type (p, argcount, varargs)
     PTR p;
     int argcount;
     bfd_boolean varargs;
d764 1
a764 2
pr_reference_type (p)
     PTR p;
d776 1
a776 4
pr_range_type (p, lower, upper)
     PTR p;
     bfd_signed_vma lower;
     bfd_signed_vma upper;
d799 2
a800 5
pr_array_type (p, lower, upper, stringp)
     PTR p;
     bfd_signed_vma lower;
     bfd_signed_vma upper;
     bfd_boolean stringp;
d849 1
a849 3
pr_set_type (p, bitstringp)
     PTR p;
     bfd_boolean bitstringp;
d872 1
a872 2
pr_offset_type (p)
     PTR p;
d893 1
a893 5
pr_method_type (p, domain, argcount, varargs)
     PTR p;
     bfd_boolean domain;
     int argcount;
     bfd_boolean varargs;
d990 1
a990 2
pr_const_type (p)
     PTR p;
d1000 1
a1000 2
pr_volatile_type (p)
     PTR p;
d1010 2
a1011 6
pr_start_struct_type (p, tag, id, structp, size)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
d1068 1
a1068 3
pr_fix_visibility (info, visibility)
     struct pr_handle *info;
     enum debug_visibility visibility;
d1119 2
a1120 6
pr_struct_field (p, name, bitpos, bitsize, visibility)
     PTR p;
     const char *name;
     bfd_vma bitpos;
     bfd_vma bitsize;
     enum debug_visibility visibility;
d1161 1
a1161 2
pr_end_struct_type (p)
     PTR p;
d1184 3
a1186 8
pr_start_class_type (p, tag, id, structp, size, vptr, ownvptr)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1272 2
a1273 5
pr_class_static_member (p, name, physname, visibility)
     PTR p;
     const char *name;
     const char *physname;
     enum debug_visibility visibility;
d1301 2
a1302 5
pr_class_baseclass (p, bitpos, virtual, visibility)
     PTR p;
     bfd_vma bitpos;
     bfd_boolean virtual;
     enum debug_visibility visibility;
d1397 1
a1397 3
pr_class_start_method (p, name)
     PTR p;
     const char *name;
d1409 4
a1412 9
pr_class_method_variant (p, physname, visibility, constp, volatilep, voffset,
			 context)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean context;
d1489 3
a1491 6
pr_class_static_method_variant (p, physname, visibility, constp, volatilep)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
d1540 1
a1540 2
pr_class_end_method (p)
     PTR p;
d1551 1
a1551 2
pr_end_class_type (p)
     PTR p;
d1559 1
a1559 3
pr_typedef_type (p, name)
     PTR p;
     const char *name;
d1569 2
a1570 5
pr_tag_type (p, name, id, kind)
     PTR p;
     const char *name;
     unsigned int id;
     enum debug_type_kind kind;
d1623 1
a1623 3
pr_typdef (p, name)
     PTR p;
     const char *name;
d1647 1
a1647 3
pr_tag (p, name)
     PTR p;
     const char *name ATTRIBUTE_UNUSED;
d1667 1
a1667 4
pr_int_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1681 1
a1681 4
pr_float_constant (p, name, val)
     PTR p;
     const char *name;
     double val;
d1693 1
a1693 4
pr_typed_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1715 2
a1716 5
pr_variable (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_var_kind kind;
     bfd_vma val;
d1753 1
a1753 4
pr_start_function (p, name, global)
     PTR p;
     const char *name;
     bfd_boolean global;
d1778 2
a1779 5
pr_function_parameter (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_parm_kind kind;
     bfd_vma val;
d1818 1
a1818 3
pr_start_block (p, addr)
     PTR p;
     bfd_vma addr;
d1841 1
a1841 5
pr_lineno (p, filename, lineno, addr)
     PTR p;
     const char *filename;
     unsigned long lineno;
     bfd_vma addr;
d1856 1
a1856 3
pr_end_block (p, addr)
     PTR p;
     bfd_vma addr;
d1873 275
a2147 2
pr_end_function (p)
     PTR p ATTRIBUTE_UNUSED;
d2149 33
d2183 611
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d62 17
a78 9
static void indent PARAMS ((struct pr_handle *));
static boolean push_type PARAMS ((struct pr_handle *, const char *));
static boolean prepend_type PARAMS ((struct pr_handle *, const char *));
static boolean append_type PARAMS ((struct pr_handle *, const char *));
static boolean substitute_type PARAMS ((struct pr_handle *, const char *));
static boolean indent_type PARAMS ((struct pr_handle *));
static char *pop_type PARAMS ((struct pr_handle *));
static void print_vma PARAMS ((bfd_vma, char *, boolean, boolean));
static boolean pr_fix_visibility
d80 17
a96 10

static boolean pr_start_compilation_unit PARAMS ((PTR, const char *));
static boolean pr_start_source PARAMS ((PTR, const char *));
static boolean pr_empty_type PARAMS ((PTR));
static boolean pr_void_type PARAMS ((PTR));
static boolean pr_int_type PARAMS ((PTR, unsigned int, boolean));
static boolean pr_float_type PARAMS ((PTR, unsigned int));
static boolean pr_complex_type PARAMS ((PTR, unsigned int));
static boolean pr_bool_type PARAMS ((PTR, unsigned int));
static boolean pr_enum_type
d98 23
a120 14
static boolean pr_pointer_type PARAMS ((PTR));
static boolean pr_function_type PARAMS ((PTR, int, boolean));
static boolean pr_reference_type PARAMS ((PTR));
static boolean pr_range_type PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static boolean pr_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, boolean));
static boolean pr_set_type PARAMS ((PTR, boolean));
static boolean pr_offset_type PARAMS ((PTR));
static boolean pr_method_type PARAMS ((PTR, boolean, int, boolean));
static boolean pr_const_type PARAMS ((PTR));
static boolean pr_volatile_type PARAMS ((PTR));
static boolean pr_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int));
static boolean pr_struct_field
d122 6
a127 5
static boolean pr_end_struct_type PARAMS ((PTR));
static boolean pr_start_class_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int, boolean,
	   boolean));
static boolean pr_class_static_member
d129 17
a145 12
static boolean pr_class_baseclass
  PARAMS ((PTR, bfd_vma, boolean, enum debug_visibility));
static boolean pr_class_start_method PARAMS ((PTR, const char *));
static boolean pr_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean,
	   bfd_vma, boolean));
static boolean pr_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean));
static boolean pr_class_end_method PARAMS ((PTR));
static boolean pr_end_class_type PARAMS ((PTR));
static boolean pr_typedef_type PARAMS ((PTR, const char *));
static boolean pr_tag_type
d147 11
a157 6
static boolean pr_typdef PARAMS ((PTR, const char *));
static boolean pr_tag PARAMS ((PTR, const char *));
static boolean pr_int_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean pr_float_constant PARAMS ((PTR, const char *, double));
static boolean pr_typed_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean pr_variable
d159 3
a161 2
static boolean pr_start_function PARAMS ((PTR, const char *, boolean));
static boolean pr_function_parameter
d163 8
a170 4
static boolean pr_start_block PARAMS ((PTR, bfd_vma));
static boolean pr_end_block PARAMS ((PTR, bfd_vma));
static boolean pr_end_function PARAMS ((PTR));
static boolean pr_lineno PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d222 1
a222 1
boolean
d251 1
a251 1
static boolean
d259 1
a259 1
    return false;
d270 1
a270 1
  return true;
d275 1
a275 1
static boolean
d289 1
a289 1
  return true;
d294 1
a294 1
static boolean
d302 1
a302 1
    return false;
d311 1
a311 1
  return true;
d318 1
a318 1
static boolean
d341 1
a341 1
      return true;
d350 1
a350 1
	return false;
d354 1
a354 1
    return true;
d362 1
a362 1
static boolean
d371 1
a371 1
	return false;
d374 1
a374 1
  return true;
d402 2
a403 2
     boolean unsignedp;
     boolean hexp;
d424 1
a424 1
static boolean
d435 1
a435 1
  return true;
d440 1
a440 1
static boolean
d451 1
a451 1
  return true;
d456 1
a456 1
static boolean
d467 1
a467 1
static boolean
d478 1
a478 1
static boolean
d482 1
a482 1
     boolean unsignedp;
d493 1
a493 1
static boolean
d512 1
a512 1
static boolean
d520 1
a520 1
    return false;
d525 1
a525 1
/* Push a boolean type onto the type stack.  */
d527 1
a527 1
static boolean
d542 1
a542 1
static boolean
d554 1
a554 1
    return false;
d559 1
a559 1
	return false;
d562 1
a562 1
    return false;
d567 1
a567 1
	return false;
d577 1
a577 1
		return false;
d581 1
a581 1
	    return false;
d587 1
a587 1
	      print_vma (values[i], ab, false, false);
d590 1
a590 1
		return false;
d603 1
a603 1
static boolean
d620 1
a620 1
static boolean
d624 1
a624 1
     boolean varargs;
d648 1
a648 1
	    return false;
d651 1
a651 1
	    return false;
d688 1
a688 1
    return false;
d692 1
a692 1
  return true;
d697 1
a697 1
static boolean
d710 1
a710 1
static boolean
d722 1
a722 1
    return false;
d724 2
a725 2
  print_vma (lower, abl, false, false);
  print_vma (upper, abu, false, false);
d736 1
a736 2
/*ARGSUSED*/
static boolean
d741 1
a741 1
     boolean stringp;
d749 1
a749 1
    return false;
d757 1
a757 1
	  print_vma (upper + 1, abu, false, false);
d763 2
a764 2
      print_vma (lower, abl, false, false);
      print_vma (upper, abu, false, false);
d769 1
a769 1
    return false;
d775 1
a775 1
	return false;
d781 1
a781 1
	return false;
d784 1
a784 1
  return true;
d789 1
a789 2
/*ARGSUSED*/
static boolean
d792 1
a792 1
     boolean bitstringp;
d797 1
a797 1
    return false;
d801 1
a801 1
    return false;
d806 1
a806 1
	return false;
d809 1
a809 1
  return true;
d814 1
a814 1
static boolean
d822 1
a822 1
    return false;
d826 1
a826 1
    return false;
d836 1
a836 1
static boolean
d839 1
a839 1
     boolean domain;
d841 1
a841 1
     boolean varargs;
d856 1
a856 1
	return false;
d859 1
a859 1
	return false;
d884 1
a884 1
	    return false;
d887 1
a887 1
	    return false;
d928 1
a928 1
    return false;
d932 1
a932 1
  return true;
d937 1
a937 1
static boolean
d948 1
a948 1
static boolean
d959 1
a959 1
static boolean
d964 1
a964 1
     boolean structp;
d972 1
a972 1
    return false;
d976 1
a976 1
	return false;
d984 1
a984 1
	return false;
d988 1
a988 1
    return false;
d994 1
a994 1
	return false;
d1000 1
a1000 1
	    return false;
d1006 1
a1006 1
	    return false;
d1009 1
a1009 1
	return false;
d1012 1
a1012 1
    return false;
d1021 1
a1021 1
static boolean
d1033 1
a1033 3
    return true;

  assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);
d1051 1
a1051 1
      return false;
d1065 1
a1065 1
    return false;
d1069 1
a1069 1
  return true;
d1074 1
a1074 1
static boolean
d1087 1
a1087 1
    return false;
d1090 1
a1090 1
    return false;
d1094 1
a1094 1
      print_vma (bitsize, ab, true, false);
d1098 1
a1098 1
	return false;
d1101 1
a1101 1
  print_vma (bitpos, ab, true, false);
d1106 1
a1106 1
    return false;
d1110 1
a1110 1
    return false;
d1113 1
a1113 1
    return false;
d1120 1
a1120 1
static boolean
d1139 1
a1139 1
  return true;
d1144 1
a1144 1
static boolean
d1149 1
a1149 1
     boolean structp;
d1151 2
a1152 2
     boolean vptr;
     boolean ownvptr;
d1163 1
a1163 1
	return false;
d1167 1
a1167 1
    return false;
d1171 1
a1171 1
	return false;
d1179 1
a1179 1
	return false;
d1183 1
a1183 1
    return false;
d1187 1
a1187 1
	return false;
d1196 1
a1196 1
	    return false;
d1202 1
a1202 1
	    return false;
d1206 1
a1206 1
		return false;
d1212 1
a1212 1
		return false;
d1222 1
a1222 1
	    return false;
d1226 1
a1226 1
	return false;
d1237 1
a1237 1
static boolean
d1248 1
a1248 1
    return false;
d1255 1
a1255 1
    return false;
d1259 1
a1259 1
    return false;
d1262 1
a1262 1
    return false;
d1269 1
a1269 1
static boolean
d1273 1
a1273 1
     boolean virtual;
d1285 1
a1285 1
    return false;
d1289 1
a1289 1
    return false;
d1297 1
a1297 1
    return false;
d1302 1
a1302 1
	return false;
d1322 1
a1322 1
    return false;
d1326 1
a1326 1
      print_vma (bitpos, ab, true, false);
d1330 1
a1330 1
	return false;
d1347 1
a1347 1
    return false;
d1351 1
a1351 1
    return false;
d1363 1
a1363 1
  return true;
d1368 1
a1368 1
static boolean
d1377 1
a1377 1
  return true;
d1382 1
a1382 1
static boolean
d1388 2
a1389 2
     boolean constp;
     boolean volatilep;
d1391 1
a1391 1
     boolean context;
d1404 1
a1404 1
	return false;
d1409 1
a1409 1
	return false;
d1417 1
a1417 1
    return false;
d1422 1
a1422 1
    return false;
d1431 1
a1431 1
	return false;
d1437 1
a1437 1
    return false;
d1443 1
a1443 1
    return false;
d1453 1
a1453 1
	    return false;
d1455 1
a1455 1
      print_vma (voffset, ab, true, false);
d1458 1
a1458 1
	return false;
d1467 1
a1467 1
static boolean
d1472 2
a1473 2
     boolean constp;
     boolean volatilep;
d1486 1
a1486 1
	return false;
d1491 1
a1491 1
	return false;
d1496 1
a1496 1
    return false;
d1500 1
a1500 1
    return false;
d1505 1
a1505 1
    return false;
d1510 1
a1510 1
    return false;
d1521 1
a1521 1
static boolean
d1528 1
a1528 1
  return true;
d1533 1
a1533 1
static boolean
d1542 1
a1542 1
static boolean
d1554 1
a1554 1
static boolean
d1584 1
a1584 1
      return false;
d1588 1
a1588 1
    return false;
d1598 1
a1598 1
    return false;
d1603 1
a1603 1
	return false;
d1606 1
a1606 1
  return true;
d1611 1
a1611 1
static boolean
d1620 1
a1620 1
    return false;
d1624 1
a1624 1
    return false;
d1631 1
a1631 1
  return true;
d1637 1
a1637 2
/*ARGSUSED*/
static boolean
d1647 1
a1647 1
    return false;
d1654 1
a1654 1
  return true;
d1659 1
a1659 1
static boolean
d1669 1
a1669 1
  print_vma (val, ab, false, false);
d1671 1
a1671 1
  return true;
d1676 1
a1676 1
static boolean
d1686 1
a1686 1
  return true;
d1691 1
a1691 1
static boolean
d1703 1
a1703 1
    return false;
d1706 1
a1706 1
  print_vma (val, ab, false, false);
d1711 1
a1711 1
  return true;
d1716 1
a1716 1
static boolean
d1728 1
a1728 1
    return false;
d1732 1
a1732 1
    return false;
d1747 1
a1747 1
  print_vma (val, ab, true, true);
d1752 1
a1752 1
  return true;
d1757 1
a1757 1
static boolean
d1761 1
a1761 1
     boolean global;
d1767 1
a1767 1
    return false;
d1771 1
a1771 1
    return false;
d1780 1
a1780 1
  return true;
d1785 1
a1785 1
static boolean
d1800 1
a1800 1
	return false;
d1804 1
a1804 1
    return false;
d1808 1
a1808 1
    return false;
d1816 1
a1816 1
  print_vma (val, ab, true, true);
d1823 1
a1823 1
  return true;
d1828 1
a1828 1
static boolean
d1843 1
a1843 1
  print_vma (addr, ab, true, true);
d1848 1
a1848 1
  return true;
d1853 1
a1853 1
static boolean
d1864 1
a1864 1
  print_vma (addr, ab, true, true);
d1867 1
a1867 1
  return true;
d1872 1
a1872 1
static boolean
d1883 1
a1883 1
  print_vma (addr, ab, true, true);
d1886 1
a1886 1
  return true;
d1891 1
a1891 2
/*ARGSUSED*/
static boolean
d1895 1
a1895 1
  return true;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
d988 1
a988 1
  const char *s;
d1605 1
a1605 1
     const char *name;
d1859 1
a1859 1
     PTR p;
@


1.1
log
@Initial revision
@
text
@d1010 3
d1098 1
a1098 1
  assert (strcmp (s, "  ") == 0);
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a1009 3
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
d1095 1
a1095 1
  assert (s[0] == ' ' && s[1] == ' ' && s[2] == '\0');
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.
d988 1
a988 1
  const char *s = NULL;
d1605 1
a1605 1
     const char *name ATTRIBUTE_UNUSED;
d1859 1
a1859 1
     PTR p ATTRIBUTE_UNUSED;
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002 Free Software Foundation, Inc.
d62 9
a70 17
static void indent
  PARAMS ((struct pr_handle *));
static bfd_boolean push_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean prepend_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean append_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean substitute_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean indent_type
  PARAMS ((struct pr_handle *));
static char *pop_type
  PARAMS ((struct pr_handle *));
static void print_vma
  PARAMS ((bfd_vma, char *, bfd_boolean, bfd_boolean));
static bfd_boolean pr_fix_visibility
d72 10
a81 17
static bfd_boolean pr_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean pr_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean pr_empty_type
  PARAMS ((PTR));
static bfd_boolean pr_void_type
  PARAMS ((PTR));
static bfd_boolean pr_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean pr_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_bool_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_enum_type
d83 14
a96 23
static bfd_boolean pr_pointer_type
  PARAMS ((PTR));
static bfd_boolean pr_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean pr_reference_type
  PARAMS ((PTR));
static bfd_boolean pr_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static bfd_boolean pr_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean pr_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean pr_offset_type
  PARAMS ((PTR));
static bfd_boolean pr_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean pr_const_type
  PARAMS ((PTR));
static bfd_boolean pr_volatile_type
  PARAMS ((PTR));
static bfd_boolean pr_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
static bfd_boolean pr_struct_field
d98 5
a102 6
static bfd_boolean pr_end_struct_type
  PARAMS ((PTR));
static bfd_boolean pr_start_class_type
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
static bfd_boolean pr_class_static_member
d104 12
a115 17
static bfd_boolean pr_class_baseclass
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean pr_class_start_method
  PARAMS ((PTR, const char *));
static bfd_boolean pr_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
static bfd_boolean pr_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean pr_class_end_method
  PARAMS ((PTR));
static bfd_boolean pr_end_class_type
  PARAMS ((PTR));
static bfd_boolean pr_typedef_type
  PARAMS ((PTR, const char *));
static bfd_boolean pr_tag_type
d117 6
a122 11
static bfd_boolean pr_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean pr_tag
  PARAMS ((PTR, const char *));
static bfd_boolean pr_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean pr_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean pr_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean pr_variable
d124 2
a125 3
static bfd_boolean pr_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
static bfd_boolean pr_function_parameter
d127 4
a130 8
static bfd_boolean pr_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_function
  PARAMS ((PTR));
static bfd_boolean pr_lineno
  PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d182 1
a182 1
bfd_boolean
d211 1
a211 1
static bfd_boolean
d219 1
a219 1
    return FALSE;
d230 1
a230 1
  return TRUE;
d235 1
a235 1
static bfd_boolean
d249 1
a249 1
  return TRUE;
d254 1
a254 1
static bfd_boolean
d262 1
a262 1
    return FALSE;
d271 1
a271 1
  return TRUE;
d278 1
a278 1
static bfd_boolean
d301 1
a301 1
      return TRUE;
d310 1
a310 1
	return FALSE;
d314 1
a314 1
    return TRUE;
d322 1
a322 1
static bfd_boolean
d331 1
a331 1
	return FALSE;
d334 1
a334 1
  return TRUE;
d362 2
a363 2
     bfd_boolean unsignedp;
     bfd_boolean hexp;
d384 1
a384 1
static bfd_boolean
d395 1
a395 1
  return TRUE;
d400 1
a400 1
static bfd_boolean
d411 1
a411 1
  return TRUE;
d416 1
a416 1
static bfd_boolean
d427 1
a427 1
static bfd_boolean
d438 1
a438 1
static bfd_boolean
d442 1
a442 1
     bfd_boolean unsignedp;
d453 1
a453 1
static bfd_boolean
d472 1
a472 1
static bfd_boolean
d480 1
a480 1
    return FALSE;
d485 1
a485 1
/* Push a bfd_boolean type onto the type stack.  */
d487 1
a487 1
static bfd_boolean
d502 1
a502 1
static bfd_boolean
d514 1
a514 1
    return FALSE;
d519 1
a519 1
	return FALSE;
d522 1
a522 1
    return FALSE;
d527 1
a527 1
	return FALSE;
d537 1
a537 1
		return FALSE;
d541 1
a541 1
	    return FALSE;
d547 1
a547 1
	      print_vma (values[i], ab, FALSE, FALSE);
d550 1
a550 1
		return FALSE;
d563 1
a563 1
static bfd_boolean
d580 1
a580 1
static bfd_boolean
d584 1
a584 1
     bfd_boolean varargs;
d608 1
a608 1
	    return FALSE;
d611 1
a611 1
	    return FALSE;
d648 1
a648 1
    return FALSE;
d652 1
a652 1
  return TRUE;
d657 1
a657 1
static bfd_boolean
d670 1
a670 1
static bfd_boolean
d682 1
a682 1
    return FALSE;
d684 2
a685 2
  print_vma (lower, abl, FALSE, FALSE);
  print_vma (upper, abu, FALSE, FALSE);
d696 2
a697 1
static bfd_boolean
d702 1
a702 1
     bfd_boolean stringp;
d710 1
a710 1
    return FALSE;
d718 1
a718 1
	  print_vma (upper + 1, abu, FALSE, FALSE);
d724 2
a725 2
      print_vma (lower, abl, FALSE, FALSE);
      print_vma (upper, abu, FALSE, FALSE);
d730 1
a730 1
    return FALSE;
d736 1
a736 1
	return FALSE;
d742 1
a742 1
	return FALSE;
d745 1
a745 1
  return TRUE;
d750 2
a751 1
static bfd_boolean
d754 1
a754 1
     bfd_boolean bitstringp;
d759 1
a759 1
    return FALSE;
d763 1
a763 1
    return FALSE;
d768 1
a768 1
	return FALSE;
d771 1
a771 1
  return TRUE;
d776 1
a776 1
static bfd_boolean
d784 1
a784 1
    return FALSE;
d788 1
a788 1
    return FALSE;
d798 1
a798 1
static bfd_boolean
d801 1
a801 1
     bfd_boolean domain;
d803 1
a803 1
     bfd_boolean varargs;
d818 1
a818 1
	return FALSE;
d821 1
a821 1
	return FALSE;
d846 1
a846 1
	    return FALSE;
d849 1
a849 1
	    return FALSE;
d890 1
a890 1
    return FALSE;
d894 1
a894 1
  return TRUE;
d899 1
a899 1
static bfd_boolean
d910 1
a910 1
static bfd_boolean
d921 1
a921 1
static bfd_boolean
d926 1
a926 1
     bfd_boolean structp;
d934 1
a934 1
    return FALSE;
d938 1
a938 1
	return FALSE;
d946 1
a946 1
	return FALSE;
d950 1
a950 1
    return FALSE;
d956 1
a956 1
	return FALSE;
d962 1
a962 1
	    return FALSE;
d968 1
a968 1
	    return FALSE;
d971 1
a971 1
	return FALSE;
d974 1
a974 1
    return FALSE;
d983 1
a983 1
static bfd_boolean
d995 3
a997 1
    return TRUE;
d1015 1
a1015 1
      return FALSE;
d1029 1
a1029 1
    return FALSE;
d1033 1
a1033 1
  return TRUE;
d1038 1
a1038 1
static bfd_boolean
d1051 1
a1051 1
    return FALSE;
d1054 1
a1054 1
    return FALSE;
d1058 1
a1058 1
      print_vma (bitsize, ab, TRUE, FALSE);
d1062 1
a1062 1
	return FALSE;
d1065 1
a1065 1
  print_vma (bitpos, ab, TRUE, FALSE);
d1070 1
a1070 1
    return FALSE;
d1074 1
a1074 1
    return FALSE;
d1077 1
a1077 1
    return FALSE;
d1084 1
a1084 1
static bfd_boolean
d1103 1
a1103 1
  return TRUE;
d1108 1
a1108 1
static bfd_boolean
d1113 1
a1113 1
     bfd_boolean structp;
d1115 2
a1116 2
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1127 1
a1127 1
	return FALSE;
d1131 1
a1131 1
    return FALSE;
d1135 1
a1135 1
	return FALSE;
d1143 1
a1143 1
	return FALSE;
d1147 1
a1147 1
    return FALSE;
d1151 1
a1151 1
	return FALSE;
d1160 1
a1160 1
	    return FALSE;
d1166 1
a1166 1
	    return FALSE;
d1170 1
a1170 1
		return FALSE;
d1176 1
a1176 1
		return FALSE;
d1186 1
a1186 1
	    return FALSE;
d1190 1
a1190 1
	return FALSE;
d1201 1
a1201 1
static bfd_boolean
d1212 1
a1212 1
    return FALSE;
d1219 1
a1219 1
    return FALSE;
d1223 1
a1223 1
    return FALSE;
d1226 1
a1226 1
    return FALSE;
d1233 1
a1233 1
static bfd_boolean
d1237 1
a1237 1
     bfd_boolean virtual;
d1249 1
a1249 1
    return FALSE;
d1253 1
a1253 1
    return FALSE;
d1261 1
a1261 1
    return FALSE;
d1266 1
a1266 1
	return FALSE;
d1286 1
a1286 1
    return FALSE;
d1290 1
a1290 1
      print_vma (bitpos, ab, TRUE, FALSE);
d1294 1
a1294 1
	return FALSE;
d1311 1
a1311 1
    return FALSE;
d1315 1
a1315 1
    return FALSE;
d1327 1
a1327 1
  return TRUE;
d1332 1
a1332 1
static bfd_boolean
d1341 1
a1341 1
  return TRUE;
d1346 1
a1346 1
static bfd_boolean
d1352 2
a1353 2
     bfd_boolean constp;
     bfd_boolean volatilep;
d1355 1
a1355 1
     bfd_boolean context;
d1368 1
a1368 1
	return FALSE;
d1373 1
a1373 1
	return FALSE;
d1381 1
a1381 1
    return FALSE;
d1386 1
a1386 1
    return FALSE;
d1395 1
a1395 1
	return FALSE;
d1401 1
a1401 1
    return FALSE;
d1407 1
a1407 1
    return FALSE;
d1417 1
a1417 1
	    return FALSE;
d1419 1
a1419 1
      print_vma (voffset, ab, TRUE, FALSE);
d1422 1
a1422 1
	return FALSE;
d1431 1
a1431 1
static bfd_boolean
d1436 2
a1437 2
     bfd_boolean constp;
     bfd_boolean volatilep;
d1450 1
a1450 1
	return FALSE;
d1455 1
a1455 1
	return FALSE;
d1460 1
a1460 1
    return FALSE;
d1464 1
a1464 1
    return FALSE;
d1469 1
a1469 1
    return FALSE;
d1474 1
a1474 1
    return FALSE;
d1485 1
a1485 1
static bfd_boolean
d1492 1
a1492 1
  return TRUE;
d1497 1
a1497 1
static bfd_boolean
d1506 1
a1506 1
static bfd_boolean
d1518 1
a1518 1
static bfd_boolean
d1548 1
a1548 1
      return FALSE;
d1552 1
a1552 1
    return FALSE;
d1562 1
a1562 1
    return FALSE;
d1567 1
a1567 1
	return FALSE;
d1570 1
a1570 1
  return TRUE;
d1575 1
a1575 1
static bfd_boolean
d1584 1
a1584 1
    return FALSE;
d1588 1
a1588 1
    return FALSE;
d1595 1
a1595 1
  return TRUE;
d1601 2
a1602 1
static bfd_boolean
d1612 1
a1612 1
    return FALSE;
d1619 1
a1619 1
  return TRUE;
d1624 1
a1624 1
static bfd_boolean
d1634 1
a1634 1
  print_vma (val, ab, FALSE, FALSE);
d1636 1
a1636 1
  return TRUE;
d1641 1
a1641 1
static bfd_boolean
d1651 1
a1651 1
  return TRUE;
d1656 1
a1656 1
static bfd_boolean
d1668 1
a1668 1
    return FALSE;
d1671 1
a1671 1
  print_vma (val, ab, FALSE, FALSE);
d1676 1
a1676 1
  return TRUE;
d1681 1
a1681 1
static bfd_boolean
d1693 1
a1693 1
    return FALSE;
d1697 1
a1697 1
    return FALSE;
d1712 1
a1712 1
  print_vma (val, ab, TRUE, TRUE);
d1717 1
a1717 1
  return TRUE;
d1722 1
a1722 1
static bfd_boolean
d1726 1
a1726 1
     bfd_boolean global;
d1732 1
a1732 1
    return FALSE;
d1736 1
a1736 1
    return FALSE;
d1745 1
a1745 1
  return TRUE;
d1750 1
a1750 1
static bfd_boolean
d1765 1
a1765 1
	return FALSE;
d1769 1
a1769 1
    return FALSE;
d1773 1
a1773 1
    return FALSE;
d1781 1
a1781 1
  print_vma (val, ab, TRUE, TRUE);
d1788 1
a1788 1
  return TRUE;
d1793 1
a1793 1
static bfd_boolean
d1808 1
a1808 1
  print_vma (addr, ab, TRUE, TRUE);
d1813 1
a1813 1
  return TRUE;
d1818 1
a1818 1
static bfd_boolean
d1829 1
a1829 1
  print_vma (addr, ab, TRUE, TRUE);
d1832 1
a1832 1
  return TRUE;
d1837 1
a1837 1
static bfd_boolean
d1848 1
a1848 1
  print_vma (addr, ab, TRUE, TRUE);
d1851 1
a1851 1
  return TRUE;
d1856 2
a1857 1
static bfd_boolean
d1861 1
a1861 1
  return TRUE;
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
a3 1
   Tags style generation written by Salvador E. Tropea <set@@computer.org>.
a45 9
  /* The following are used only by the tags code (tg_).  */
  /* Name of the file we are using.  */
  char *filename;
  /* The BFD.  */
  bfd *abfd;
  /* The symbols table for this BFD.  */
  asymbol **syms;
  /* Pointer to a function to demangle symbols.  */
  char *(*demangler) (bfd *, const char *);
a59 7
  /* The following are used only by the tags code (tg_).  */
  /* Type for the container (struct, union, class, union class).  */
  const char *flavor;
  /* A comma separated list of parent classes.  */
  char *parents;
  /* How many parents contains parents.  */
  int num_parents;
d62 16
a77 8
static void indent (struct pr_handle *);
static bfd_boolean push_type (struct pr_handle *, const char *);
static bfd_boolean prepend_type (struct pr_handle *, const char *);
static bfd_boolean append_type (struct pr_handle *, const char *);
static bfd_boolean substitute_type (struct pr_handle *, const char *);
static bfd_boolean indent_type (struct pr_handle *);
static char *pop_type (struct pr_handle *);
static void print_vma (bfd_vma, char *, bfd_boolean, bfd_boolean);
d79 17
a95 9
  (struct pr_handle *, enum debug_visibility);
static bfd_boolean pr_start_compilation_unit (void *, const char *);
static bfd_boolean pr_start_source (void *, const char *);
static bfd_boolean pr_empty_type (void *);
static bfd_boolean pr_void_type (void *);
static bfd_boolean pr_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean pr_float_type (void *, unsigned int);
static bfd_boolean pr_complex_type (void *, unsigned int);
static bfd_boolean pr_bool_type (void *, unsigned int);
d97 9
a105 5
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean pr_pointer_type (void *);
static bfd_boolean pr_function_type (void *, int, bfd_boolean);
static bfd_boolean pr_reference_type (void *);
static bfd_boolean pr_range_type (void *, bfd_signed_vma, bfd_signed_vma);
d107 11
a117 6
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean pr_set_type (void *, bfd_boolean);
static bfd_boolean pr_offset_type (void *);
static bfd_boolean pr_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean pr_const_type (void *);
static bfd_boolean pr_volatile_type (void *);
d119 1
a119 1
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
d121 3
a123 2
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean pr_end_struct_type (void *);
d125 2
a126 2
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
d128 1
a128 1
  (void *, const char *, const char *, enum debug_visibility);
d130 3
a132 2
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean pr_class_start_method (void *, const char *);
d134 2
a135 2
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
d137 8
a144 4
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean pr_class_end_method (void *);
static bfd_boolean pr_end_class_type (void *);
static bfd_boolean pr_typedef_type (void *, const char *);
d146 11
a156 6
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean pr_typdef (void *, const char *);
static bfd_boolean pr_tag (void *, const char *);
static bfd_boolean pr_int_constant (void *, const char *, bfd_vma);
static bfd_boolean pr_float_constant (void *, const char *, double);
static bfd_boolean pr_typed_constant (void *, const char *, bfd_vma);
d158 3
a160 2
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean pr_start_function (void *, const char *, bfd_boolean);
d162 10
a171 53
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean pr_start_block (void *, bfd_vma);
static bfd_boolean pr_end_block (void *, bfd_vma);
static bfd_boolean pr_end_function (void *);
static bfd_boolean pr_lineno (void *, const char *, unsigned long, bfd_vma);
static bfd_boolean append_parent (struct pr_handle *, const char *);
/* Only used by tg_ code.  */
static bfd_boolean tg_fix_visibility
  (struct pr_handle *, enum debug_visibility);
static void find_address_in_section (bfd *, asection *, void *);
static void translate_addresses (bfd *, char *, FILE *, asymbol **);
static const char *visibility_name (enum debug_visibility);
/* Tags style replacements.  */
static bfd_boolean tg_start_compilation_unit (void *, const char *);
static bfd_boolean tg_start_source (void *, const char *);
static bfd_boolean tg_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean tg_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_end_struct_type (void *);
static bfd_boolean tg_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean, bfd_boolean);
static bfd_boolean tg_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean tg_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean tg_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean tg_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean tg_end_class_type (void *);
static bfd_boolean tg_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean tg_typdef (void *, const char *);
static bfd_boolean tg_tag (void *, const char *);
static bfd_boolean tg_int_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_float_constant (void *, const char *, double);
static bfd_boolean tg_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean tg_start_function (void *, const char *, bfd_boolean);
static bfd_boolean tg_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean tg_start_block (void *, bfd_vma);
static bfd_boolean tg_end_block (void *, bfd_vma);
static bfd_boolean tg_lineno (void *, const char *, unsigned long, bfd_vma);

a219 48
static const struct debug_write_fns tg_fns =
{
  tg_start_compilation_unit,
  tg_start_source,
  pr_empty_type,		/* Same, push_type.  */
  pr_void_type,			/* Same, push_type.  */
  pr_int_type,			/* Same, push_type.  */
  pr_float_type,		/* Same, push_type.  */
  pr_complex_type,		/* Same, push_type.  */
  pr_bool_type,			/* Same, push_type.  */
  tg_enum_type,
  pr_pointer_type,		/* Same, changes to pointer.  */
  pr_function_type,		/* Same, push_type.  */
  pr_reference_type,		/* Same, changes to reference.  */
  pr_range_type,		/* FIXME: What's that?.  */
  pr_array_type,		/* Same, push_type.  */
  pr_set_type,			/* FIXME: What's that?.  */
  pr_offset_type,		/* FIXME: What's that?.  */
  pr_method_type,		/* Same.  */
  pr_const_type,		/* Same, changes to const.  */
  pr_volatile_type,		/* Same, changes to volatile.  */
  tg_start_struct_type,
  tg_struct_field,
  tg_end_struct_type,
  tg_start_class_type,
  tg_class_static_member,
  tg_class_baseclass,
  pr_class_start_method,	/* Same, remembers that's a method.  */
  tg_class_method_variant,
  tg_class_static_method_variant,
  pr_class_end_method,		/* Same, forgets that's a method.  */
  tg_end_class_type,
  pr_typedef_type,		/* Same, just push type.  */
  tg_tag_type,
  tg_typdef,
  tg_tag,
  tg_int_constant,		/* Untested.  */
  tg_float_constant,		/* Untested.  */
  tg_typed_constant,		/* Untested.  */
  tg_variable,
  tg_start_function,
  tg_function_parameter,
  tg_start_block,
  tg_end_block,
  pr_end_function,		/* Same, does nothing.  */
  tg_lineno
};

d223 3
a225 2
print_debugging_info (FILE *f, void *dhandle, bfd *abfd, asymbol **syms,
		      void *demangler, bfd_boolean as_tags)
a232 12
  info.filename = NULL;
  info.abfd = abfd;
  info.syms = syms;
  info.demangler = demangler;

  if (as_tags)
    {
      fputs ("!_TAG_FILE_FORMAT\t2\t/extended format/\n", f);
      fputs ("!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted/\n", f);
      fputs ("!_TAG_PROGRAM_AUTHOR\tIan Lance Taylor, Salvador E. Tropea and others\t//\n", f);
      fputs ("!_TAG_PROGRAM_NAME\tobjdump\t/From GNU binutils/\n", f);
    }
d234 1
a234 2
  return as_tags ? debug_write (dhandle, &tg_fns, (void *) & info)
    : debug_write (dhandle, &pr_fns, (void *) & info);
d240 2
a241 1
indent (struct pr_handle *info)
d252 3
a254 1
push_type (struct pr_handle *info, const char *type)
d276 3
a278 1
prepend_type (struct pr_handle *info, const char *s)
d295 3
a297 1
append_type (struct pr_handle *info, const char *s)
a313 20
/* Append a string to the parents on the top of the type stack.  */

static bfd_boolean
append_parent (struct pr_handle *info, const char *s)
{
  unsigned int len;

  if (s == NULL)
    return FALSE;

  assert (info->stack != NULL);

  len = info->stack->parents ? strlen (info->stack->parents) : 0;
  info->stack->parents = (char *) xrealloc (info->stack->parents,
					    len + strlen (s) + 1);
  strcpy (info->stack->parents + len, s);

  return TRUE;
}

d319 3
a321 1
substitute_type (struct pr_handle *info, const char *s)
d363 2
a364 1
indent_type (struct pr_handle *info)
d380 2
a381 1
pop_type (struct pr_handle *info)
d399 5
a403 1
print_vma (bfd_vma vma, char *buf, bfd_boolean unsignedp, bfd_boolean hexp)
d425 3
a427 1
pr_start_compilation_unit (void *p, const char *filename)
d441 3
a443 1
pr_start_source (void *p, const char *filename)
d457 2
a458 1
pr_empty_type (void *p)
d468 2
a469 1
pr_void_type (void *p)
d479 4
a482 1
pr_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
d494 3
a496 1
pr_float_type (void *p, unsigned int size)
d513 3
a515 1
pr_complex_type (void *p, unsigned int size)
d528 3
a530 1
pr_bool_type (void *p, unsigned int size)
d543 5
a547 2
pr_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
d604 2
a605 1
pr_pointer_type (void *p)
d621 4
a624 1
pr_function_type (void *p, int argcount, bfd_boolean varargs)
d698 2
a699 1
pr_reference_type (void *p)
d711 4
a714 1
pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)
d737 5
a741 2
pr_array_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper,
	       bfd_boolean stringp)
d790 3
a792 1
pr_set_type (void *p, bfd_boolean bitstringp)
d815 2
a816 1
pr_offset_type (void *p)
d837 5
a841 1
pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)
d938 2
a939 1
pr_const_type (void *p)
d949 2
a950 1
pr_volatile_type (void *p)
d960 6
a965 2
pr_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp, unsigned int size)
d1022 3
a1024 1
pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
d1075 6
a1080 2
pr_struct_field (void *p, const char *name, bfd_vma bitpos, bfd_vma bitsize,
		 enum debug_visibility visibility)
d1121 2
a1122 1
pr_end_struct_type (void *p)
d1145 8
a1152 3
pr_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
d1238 5
a1242 2
pr_class_static_member (void *p, const char *name, const char *physname,
			enum debug_visibility visibility)
d1270 5
a1274 2
pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
		    enum debug_visibility visibility)
d1369 3
a1371 1
pr_class_start_method (void *p, const char *name)
d1383 9
a1391 4
pr_class_method_variant (void *p, const char *physname,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset, bfd_boolean context)
d1468 6
a1473 3
pr_class_static_method_variant (void *p, const char *physname,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
d1522 2
a1523 1
pr_class_end_method (void *p)
d1534 2
a1535 1
pr_end_class_type (void *p)
d1543 3
a1545 1
pr_typedef_type (void *p, const char *name)
d1555 5
a1559 2
pr_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
d1612 3
a1614 1
pr_typdef (void *p, const char *name)
d1638 3
a1640 1
pr_tag (void *p, const char *name ATTRIBUTE_UNUSED)
d1660 4
a1663 1
pr_int_constant (void *p, const char *name, bfd_vma val)
d1677 4
a1680 1
pr_float_constant (void *p, const char *name, double val)
d1692 4
a1695 1
pr_typed_constant (void *p, const char *name, bfd_vma val)
d1717 5
a1721 2
pr_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val)
d1758 4
a1761 1
pr_start_function (void *p, const char *name, bfd_boolean global)
d1786 5
a1790 2
pr_function_parameter (void *p, const char *name,
		       enum debug_parm_kind kind, bfd_vma val)
d1829 3
a1831 1
pr_start_block (void *p, bfd_vma addr)
d1854 5
a1858 1
pr_lineno (void *p, const char *filename, unsigned long lineno, bfd_vma addr)
d1873 3
a1875 1
pr_end_block (void *p, bfd_vma addr)
d1892 2
a1893 275
pr_end_function (void *p ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Tags style generation functions start here.  */

/* Variables for address to line translation.  */
static bfd_vma pc;
static const char *filename;
static const char *functionname;
static unsigned int line;
static bfd_boolean found;

/* Look for an address in a section.  This is called via
   bfd_map_over_sections.  */

static void
find_address_in_section (bfd *abfd, asection *section, void *data)
{
  bfd_vma vma;
  bfd_size_type size;
  asymbol **syms = (asymbol **) data;

  if (found)
    return;

  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)
    return;

  vma = bfd_get_section_vma (abfd, section);
  if (pc < vma)
    return;

  size = bfd_get_section_size_before_reloc (section);
  if (pc >= vma + size)
    return;

  found = bfd_find_nearest_line (abfd, section, syms, pc - vma,
				 &filename, &functionname, &line);
}

static void
translate_addresses (bfd *abfd, char *addr_hex, FILE *f, asymbol **syms)
{
  pc = bfd_scan_vma (addr_hex, NULL, 16);
  found = FALSE;
  bfd_map_over_sections (abfd, find_address_in_section, syms);

  if (! found)
    fprintf (f, "??");
  else
    fprintf (f, "%u", line);
}

/* Start a new compilation unit.  */

static bfd_boolean
tg_start_compilation_unit (void * p, const char *filename ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;

  fprintf (stderr, "New compilation unit: %s\n", filename);

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (filename);

  return TRUE;
}

/* Start a source file within a compilation unit.  */

static bfd_boolean
tg_start_source (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (filename);

  return TRUE;
}

/* Push an enum type onto the type stack.  */

static bfd_boolean
tg_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int i;
  const char *name;
  char ab[20];

  if (! pr_enum_type (p, tag, names, values))
    return FALSE;

  name = tag ? tag : "unknown";
  /* Generate an entry for the enum.  */
  if (tag)
    fprintf (info->f, "%s\t%s\t0;\"\tkind:e\ttype:%s\n", tag,
	     info->filename, info->stack->type);

  /* Generate entries for the values.  */
  if (names != NULL)
    {
      for (i = 0; names[i] != NULL; i++)
	{
	  print_vma (values[i], ab, FALSE, FALSE);
	  fprintf (info->f, "%s\t%s\t0;\"\tkind:g\tenum:%s\tvalue:%s\n",
		   names[i], info->filename, name, ab);
	}
    }

  return TRUE;
}

/* Start accumulating a struct type.  */

static bfd_boolean
tg_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp,
		      unsigned int size ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *name;
  char idbuf[20];

  if (tag != NULL)
    name = tag;
  else
    {
      name = idbuf;
      sprintf (idbuf, "%%anon%u", id);
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "struct" : "union";

  fprintf (info->f, "%s\t%s\t0;\"\tkind:%c\n", name, info->filename,
	   info->stack->flavor[0]);

  info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;

  return indent_type (info);
}

/* Output the visibility of a field in a struct.  */

static bfd_boolean
tg_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
{
  assert (info->stack != NULL);

  if (info->stack->visibility == visibility)
    return TRUE;

  assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);

  info->stack->visibility = visibility;

  return TRUE;
}

/* Add a field to a struct type.  */

static bfd_boolean
tg_struct_field (void *p, const char *name, bfd_vma bitpos ATTRIBUTE_UNUSED,
		 bfd_vma bitsize ATTRIBUTE_UNUSED,
		 enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  /* It happens, a bug? */
  if (! name[0])
    return TRUE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:m\ttype:%s\t%s:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->flavor, info->stack->type,
	   visibility_name (visibility));

  return TRUE;
}

/* Finish a struct type.  */

static bfd_boolean
tg_end_struct_type (void *p ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  assert (info->stack != NULL);

  return TRUE;
}

/* Start a class type.  */

static bfd_boolean
tg_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *tv = NULL;
  const char *name;

  info->indent += 2;

  if (vptr && ! ownvptr)
    {
      tv = pop_type (info);
      if (tv == NULL)
	return FALSE;
    }

  if (tag != NULL)
    name = tag;
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      name = idbuf;
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "class" : "union class";
  info->stack->parents = NULL;
  info->stack->num_parents = 0;

  if (size != 0 || vptr || ownvptr || tag != NULL)
    {
      if (vptr)
	{
	  if (! append_type (info, " vtable "))
	    return FALSE;
	  if (ownvptr)
	    {
	      if (! append_type (info, "self "))
		return FALSE;
	    }
	  else
	    {
	      if (! append_type (info, tv)
		  || ! append_type (info, " "))
		return FALSE;
	    }
	}
    }

  info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;

  return TRUE;
}

/* Add a static member to a class.  */

static bfd_boolean
tg_class_static_member (void *p, const char *name,
			const char *physname ATTRIBUTE_UNUSED,
			enum debug_visibility visibility)
a1894 33
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  int len_var, len_class;
  char *full_name;

  len_var = strlen (name);
  len_class = strlen (info->stack->next->type);
  full_name = (char *) xmalloc (len_var + len_class + 3);
  if (! full_name)
    return FALSE;
  memcpy (full_name, info->stack->next->type, len_class);
  memcpy (full_name + len_class, "::", 2);
  memcpy (full_name + len_class + 2, name, len_var + 1);

  if (! substitute_type (info, full_name))
    return FALSE;

  if (! prepend_type (info, "static "))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:x\ttype:%s\tclass:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->type,
	   visibility_name (visibility));
  free (t);
  free (full_name);

a1895 611
}

/* Add a base class to a class.  */

static bfd_boolean
tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,
		    bfd_boolean virtual, enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *prefix;

  assert (info->stack != NULL && info->stack->next != NULL);

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (strncmp (t, "class ", sizeof "class " - 1) == 0)
    t += sizeof "class " - 1;

  /* Push it back on to take advantage of the prepend_type and
     append_type routines.  */
  if (! push_type (info, t))
    return FALSE;

  if (virtual)
    {
      if (! prepend_type (info, "virtual "))
	return FALSE;
    }

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      prefix = "public ";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      prefix = "protected ";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      prefix = "private ";
      break;
    default:
      prefix = "/* unknown visibility */ ";
      break;
    }

  if (! prepend_type (info, prefix))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (info->stack->num_parents && ! append_parent (info, ", "))
    return FALSE;

  if (! append_parent (info, t))
    return FALSE;
  info->stack->num_parents++;

  free (t);

  return TRUE;
}

/* Add a variant to a method.  */

static bfd_boolean
tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset ATTRIBUTE_UNUSED,
			 bfd_boolean context)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *context_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  method_name = strdup (context ? info->stack->next->next->method
			: info->stack->next->method);

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, method_name))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Pull off the context type if there is one.  */
  if (! context)
    context_type = NULL;
  else
    {
      context_type = pop_type (info);
      if (context_type == NULL)
	return FALSE;
    }

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\n",
	   method_name, info->filename, method_type, info->stack->type);
  free (method_type);
  free (method_name);
  free (context_type);

  return TRUE;
}

/* Add a static variant to a method.  */

static bfd_boolean
tg_class_static_method_variant (void *p,
				const char *physname ATTRIBUTE_UNUSED,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);
  assert (info->stack->next->method != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Mark it as static.  */
  if (! prepend_type (info, "static "))
    return FALSE;

  method_name = strdup (info->stack->next->method);
  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, info->stack->next->method))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\taccess:%s\n",
	   method_name, info->filename, method_type, info->stack->type,
	   visibility_name (visibility));
  free (method_type);
  free (method_name);

  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
tg_end_class_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:c\ttype:%s", info->stack->type,
	   info->filename, info->stack->flavor);
  if (info->stack->num_parents)
    {
      fprintf  (info->f, "\tinherits:%s", info->stack->parents);
      free (info->stack->parents);
    }
  fputc ('\n', info->f);

  return tg_end_struct_type (p);
}

/* Push a type on the stack using a tag name.  */

static bfd_boolean
tg_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *t, *tag;
  char idbuf[20];

  switch (kind)
    {
    case DEBUG_KIND_STRUCT:
      t = "struct ";
      break;
    case DEBUG_KIND_UNION:
      t = "union ";
      break;
    case DEBUG_KIND_ENUM:
      t = "enum ";
      break;
    case DEBUG_KIND_CLASS:
      t = "class ";
      break;
    case DEBUG_KIND_UNION_CLASS:
      t = "union class ";
      break;
    default:
      abort ();
      return FALSE;
    }

  if (! push_type (info, t))
    return FALSE;
  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, "%%anon%u", id);
      tag = idbuf;
    }

  if (! append_type (info, tag))
    return FALSE;

  return TRUE;
}

/* Output a typedef.  */

static bfd_boolean
tg_typdef (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  s = pop_type (info);
  if (s == NULL)
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:t\ttype:%s\n", name,
	   info->filename, s);

  free (s);

  return TRUE;
}

/* Output a tag.  The tag should already be in the string on the
   stack, so all we have to do here is print it out.  */

static bfd_boolean
tg_tag (void *p ATTRIBUTE_UNUSED, const char *name ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;
  free (t);

  return TRUE;
}

/* Output an integer constant.  */

static bfd_boolean
tg_int_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const int\tvalue:%s\n",
	   name, info->filename, ab);
  return TRUE;
}

/* Output a floating point constant.  */

static bfd_boolean
tg_float_constant (void *p, const char *name, double val)
{
  struct pr_handle *info = (struct pr_handle *) p;

  indent (info);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const double\tvalue:%g\n",
	   name, info->filename, val);
  return TRUE;
}

/* Output a typed constant.  */

static bfd_boolean
tg_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const %s\tvalue:%s\n",
	   name, info->filename, t, ab);

  free (t);

  return TRUE;
}

/* Output a variable.  */

static bfd_boolean
tg_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *dname, *from_class;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  dname = name;
  if (info->demangler)
    {
      dname = info->demangler (info->abfd, name);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }

  if (dname != name)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  *sep = 0;
	  name = sep + 2;
	  from_class = dname;
	}
      else
	{
	  /* Obscure types as vts and type_info nodes.  */
	  name = dname;
	  from_class = NULL;
	}
    }
  else
    from_class = NULL;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:%s", name, info->filename, t);

  switch (kind)
    {
    case DEBUG_STATIC:
    case DEBUG_LOCAL_STATIC:
      fprintf (info->f, "\tfile:");
      break;
    case DEBUG_REGISTER:
      fprintf (info->f, "\tregister:");
      break;
    default:
      break;
    }

  if (from_class)
    {
      fprintf (info->f, "\tclass:%s",from_class);
      free ((char *) dname);
    }

  fprintf (info->f, "\n");

  free (t);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
tg_start_function (void *p, const char *name, bfd_boolean global)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *dname;

  if (! global)
    info->stack->flavor = "static";
  else
    info->stack->flavor = NULL;

  dname = name;
  if (info->demangler)
    {
      dname = info->demangler (info->abfd, name);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }

  if (! substitute_type (info, dname))
    return FALSE;

  if (dname != name)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  info->stack->method = dname;
	  *sep = 0;
	  name = sep + 2;
	}
      else
	{
	  info->stack->method = "";
	  name = dname;
	}
      sep = strchr (name, '(');
      if (sep)
	*sep = 0;
      /* Obscure functions as type_info function.  */
    }
  else
    info->stack->method = NULL;

  info->stack->parents = strdup (name);

  if (! info->stack->method && ! append_type (info, "("))
    return FALSE;

  info->parameter = 1;

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
tg_function_parameter (void *p, const char *name, enum debug_parm_kind kind,
		       bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (kind == DEBUG_PARM_REFERENCE
      || kind == DEBUG_PARM_REF_REG)
    {
      if (! pr_reference_type (p))
	return FALSE;
    }

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! info->stack->method)
    {
      if (info->parameter != 1 && ! append_type (info, ", "))
	return FALSE;

      if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)
	if (! append_type (info, "register "))
	  return FALSE;

      if (! append_type (info, t))
	return FALSE;
    }

  free (t);

  ++info->parameter;

  return TRUE;
}

/* Start writing out a block.  */

static bfd_boolean
tg_start_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20], kind, *partof;
  char *t;
  bfd_boolean local;

  if (info->parameter > 0)
    {
      info->parameter = 0;

      /* Delayed name.  */
      fprintf (info->f, "%s\t%s\t", info->stack->parents, info->filename);
      free (info->stack->parents);

      print_vma (addr, ab, TRUE, TRUE);
      translate_addresses (info->abfd, ab, info->f, info->syms);
      local = info->stack->flavor != NULL;
      if (info->stack->method && *info->stack->method)
	{
	  kind = 'm';
	  partof = (char *) info->stack->method;
	}
      else
	{
	  kind = 'f';
	  partof = NULL;
	  if (! info->stack->method && ! append_type (info, ")"))
	    return FALSE;
	}
      t = pop_type (info);
      if (t == NULL)
	return FALSE;
      fprintf (info->f, ";\"\tkind:%c\ttype:%s", kind, t);
      if (local)
	fputs ("\tfile:", info->f);
      if (partof)
	{
	  fprintf (info->f, "\tclass:%s", partof);
	  free (partof);
	}
      fputc ('\n', info->f);
    }

  return TRUE;
}

/* Write out line number information.  */

static bfd_boolean
tg_lineno (void *p ATTRIBUTE_UNUSED, const char *filename ATTRIBUTE_UNUSED,
	   unsigned long lineno ATTRIBUTE_UNUSED,
	   bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Finish writing out a block.  */

static bfd_boolean
tg_end_block (void *p ATTRIBUTE_UNUSED, bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Convert the visibility value into a human readable name.  */

static const char *
visibility_name (enum debug_visibility visibility)
{
  const char *s;

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      s = "public";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      s = "private";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      s = "protected";
      break;
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
    default:
      abort ();
      return FALSE;
    }
  return s;
@


