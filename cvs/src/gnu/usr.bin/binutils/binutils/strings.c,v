head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.7;
commitid	dbwlUkpK0xDlII16;

1.7
date	2004.11.02.20.45.19;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.33;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.34.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.49.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.54;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.54;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.03.57;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.13.35;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.16.28;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.10;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.16.58;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.05;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* strings -- print the strings of printable characters in files
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Usage: strings [options] file...

   Options:
   --all
   -a
   -		Do not scan only the initialized data section of object files.

   --print-file-name
   -f		Print the name of the file before each string.

   --bytes=min-len
   -n min-len
   -min-len	Print graphic char sequences, MIN-LEN or more bytes long,
		that are followed by a NUL or a newline.  Default is 4.

   --radix={o,x,d}
   -t {o,x,d}	Print the offset within the file before each string,
		in octal/hex/decimal.

   -o		Like -to.  (Some other implementations have -o like -to,
		others like -td.  We chose one arbitrarily.)

   --encoding={s,S,b,l,B,L}
   -e {s,S,b,l,B,L}
		Select character encoding: 7-bit-character, 8-bit-character,
		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit,
		littleendian 32-bit.

   --target=BFDNAME
		Specify a non-default object file format.

   --help
   -h		Print the usage message on the standard output.

   --version
   -v		Print the program version number.

   Written by Richard Stallman <rms@@gnu.ai.mit.edu>
   and David MacKenzie <djm@@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "bfd.h"
#include <stdio.h>
#include "getopt.h"
#include <errno.h>
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"

/* Some platforms need to put stdin into binary mode, to read
    binary files.  */
#ifdef HAVE_SETMODE
#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#define setmode _setmode
#else
#define O_BINARY 0
#endif
#endif
#if O_BINARY
#include <io.h>
#define SET_BINARY(f) do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
#endif
#endif

#define STRING_ISGRAPHIC(c) \
      (   (c) >= 0 \
       && (c) <= 255 \
       && ((c) == '\t' || ISPRINT (c) || (encoding == 'S' && (c) > 127)))

#ifndef errno
extern int errno;
#endif

/* The BFD section flags that identify an initialized data section.  */
#define DATA_FLAGS (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS)

#ifdef HAVE_FOPEN64
typedef off64_t file_off;
#define file_open(s,m) fopen64(s, m)
#else
typedef off_t file_off;
#define file_open(s,m) fopen(s, m)
#endif

/* Radix for printing addresses (must be 8, 10 or 16).  */
static int address_radix;

/* Minimum length of sequence of graphic chars to trigger output.  */
static int string_min;

/* TRUE means print address within file for each string.  */
static bfd_boolean print_addresses;

/* TRUE means print filename for each string.  */
static bfd_boolean print_filenames;

/* TRUE means for object files scan only the data section.  */
static bfd_boolean datasection_only;

/* TRUE if we found an initialized data section in the current file.  */
static bfd_boolean got_a_section;

/* The BFD object file format.  */
static char *target;

/* The character encoding format.  */
static char encoding;
static int encoding_bytes;

static struct option long_options[] =
{
  {"all", no_argument, NULL, 'a'},
  {"print-file-name", no_argument, NULL, 'f'},
  {"bytes", required_argument, NULL, 'n'},
  {"radix", required_argument, NULL, 't'},
  {"encoding", required_argument, NULL, 'e'},
  {"target", required_argument, NULL, 'T'},
  {"help", no_argument, NULL, 'h'},
  {"version", no_argument, NULL, 'v'},
  {NULL, 0, NULL, 0}
};

static void strings_a_section (bfd *, asection *, void *);
static bfd_boolean strings_object_file (const char *);
static bfd_boolean strings_file (char *file);
static int integer_arg (char *s);
static void print_strings (const char *, FILE *, file_off, int, int, char *);
static void usage (FILE *, int);
static long get_char (FILE *, file_off *, int *, char **);

int main (int, char **);

int
main (int argc, char **argv)
{
  int optc;
  int exit_status = 0;
  bfd_boolean files_given = FALSE;

#if defined (HAVE_SETLOCALE)
  setlocale (LC_ALL, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  expandargv (&argc, &argv);

  string_min = -1;
  print_addresses = FALSE;
  print_filenames = FALSE;
  datasection_only = TRUE;
  target = NULL;
  encoding = 's';

  while ((optc = getopt_long (argc, argv, "afhHn:ot:e:Vv0123456789",
			      long_options, (int *) 0)) != EOF)
    {
      switch (optc)
	{
	case 'a':
	  datasection_only = FALSE;
	  break;

	case 'f':
	  print_filenames = TRUE;
	  break;

	case 'H':
	case 'h':
	  usage (stdout, 0);

	case 'n':
	  string_min = integer_arg (optarg);
	  if (string_min < 1)
	    fatal (_("invalid number %s"), optarg);
	  break;

	case 'o':
	  print_addresses = TRUE;
	  address_radix = 8;
	  break;

	case 't':
	  print_addresses = TRUE;
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  switch (optarg[0])
	    {
	    case 'o':
	      address_radix = 8;
	      break;

	    case 'd':
	      address_radix = 10;
	      break;

	    case 'x':
	      address_radix = 16;
	      break;

	    default:
	      usage (stderr, 1);
	    }
	  break;

	case 'T':
	  target = optarg;
	  break;

	case 'e':
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  encoding = optarg[0];
	  break;

	case 'V':
	case 'v':
	  print_version ("strings");
	  break;

	case '?':
	  usage (stderr, 1);

	default:
	  if (string_min < 0)
	    string_min = optc - '0';
	  else
	    string_min = string_min * 10 + optc - '0';
	  break;
	}
    }

  if (string_min < 0)
    string_min = 4;

  switch (encoding)
    {
    case 'S':
    case 's':
      encoding_bytes = 1;
      break;
    case 'b':
    case 'l':
      encoding_bytes = 2;
      break;
    case 'B':
    case 'L':
      encoding_bytes = 4;
      break;
    default:
      usage (stderr, 1);
    }

  bfd_init ();
  set_default_bfd_target ();

  if (optind >= argc)
    {
      datasection_only = FALSE;
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
      print_strings ("{standard input}", stdin, 0, 0, 0, (char *) NULL);
      files_given = TRUE;
    }
  else
    {
      for (; optind < argc; ++optind)
	{
	  if (strcmp (argv[optind], "-") == 0)
	    datasection_only = FALSE;
	  else
	    {
	      files_given = TRUE;
	      exit_status |= strings_file (argv[optind]) == FALSE;
	    }
	}
    }

  if (!files_given)
    usage (stderr, 1);

  return (exit_status);
}

/* Scan section SECT of the file ABFD, whose printable name is FILE.
   If it contains initialized data,
   set `got_a_section' and print the strings in it.  */

static void
strings_a_section (bfd *abfd, asection *sect, void *filearg)
{
  const char *file = (const char *) filearg;

  if ((sect->flags & DATA_FLAGS) == DATA_FLAGS)
    {
      bfd_size_type sz = bfd_get_section_size_before_reloc (sect);
      void *mem = xmalloc (sz);

      if (bfd_get_section_contents (abfd, sect, mem, (file_ptr) 0, sz))
	{
	  got_a_section = TRUE;
	  print_strings (file, (FILE *) NULL, sect->filepos, 0, sz, mem);
	}
      free (mem);
    }
}

/* Scan all of the sections in FILE, and print the strings
   in the initialized data section(s).

   Return TRUE if successful,
   FALSE if not (such as if FILE is not an object file).  */

static bfd_boolean
strings_object_file (const char *file)
{
  bfd *abfd = bfd_openr (file, target);

  if (abfd == NULL)
    /* Treat the file as a non-object file.  */
    return FALSE;

  /* This call is mainly for its side effect of reading in the sections.
     We follow the traditional behavior of `strings' in that we don't
     complain if we don't recognize a file to be an object file.  */
  if (!bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      return FALSE;
    }

  got_a_section = FALSE;
  bfd_map_over_sections (abfd, strings_a_section, (void *) file);

  if (!bfd_close (abfd))
    {
      bfd_nonfatal (file);
      return FALSE;
    }

  return got_a_section;
}

/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */

static bfd_boolean
strings_file (char *file)
{
  if (get_file_size (file) < 1)
    return FALSE;

  /* If we weren't told to scan the whole file,
     try to open it as an object file and only look at
     initialized data sections.  If that fails, fall back to the
     whole file.  */
  if (!datasection_only || !strings_object_file (file))
    {
      FILE *stream;

      stream = file_open (file, FOPEN_RB);
      if (stream == NULL)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (file);
	  return FALSE;
	}

      print_strings (file, stream, (file_off) 0, 0, 0, (char *) 0);

      if (fclose (stream) == EOF)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (file);
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read the next character, return EOF if none available.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.  */

static long
get_char (FILE *stream, file_off *address, int *magiccount, char **magic)
{
  int c, i;
  long r = EOF;
  unsigned char buf[4];

  for (i = 0; i < encoding_bytes; i++)
    {
      if (*magiccount)
	{
	  (*magiccount)--;
	  c = *(*magic)++;
	}
      else
	{
	  if (stream == NULL)
	    return EOF;
#ifdef HAVE_GETC_UNLOCKED
	  c = getc_unlocked (stream);
#else
	  c = getc (stream);
#endif
	  if (c == EOF)
	    return EOF;
	}

      (*address)++;
      buf[i] = c;
    }

  switch (encoding)
    {
    case 'S':
    case 's':
      r = buf[0];
      break;
    case 'b':
      r = (buf[0] << 8) | buf[1];
      break;
    case 'l':
      r = buf[0] | (buf[1] << 8);
      break;
    case 'B':
      r = ((long) buf[0] << 24) | ((long) buf[1] << 16) |
	((long) buf[2] << 8) | buf[3];
      break;
    case 'L':
      r = buf[0] | ((long) buf[1] << 8) | ((long) buf[2] << 16) |
	((long) buf[3] << 24);
      break;
    }

  if (r == EOF)
    return 0;

  return r;
}

/* Find the strings in file FILENAME, read from STREAM.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.
   Stop reading at address STOP_POINT in the file, if nonzero.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.
   Those characters come at address ADDRESS and the data in STREAM follow.  */

static void
print_strings (const char *filename, FILE *stream, file_off address,
	       int stop_point, int magiccount, char *magic)
{
  char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));

  while (1)
    {
      file_off start;
      int i;
      long c;

      /* See if the next `string_min' chars are all graphic chars.  */
    tryline:
      if (stop_point && address >= stop_point)
	break;
      start = address;
      for (i = 0; i < string_min; i++)
	{
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    return;
	  if (! STRING_ISGRAPHIC (c))
	    /* Found a non-graphic.  Try again starting with next char.  */
	    goto tryline;
	  buf[i] = c;
	}

      /* We found a run of `string_min' graphic characters.  Print up
         to the next non-graphic character.  */

      if (print_filenames)
	printf ("%s: ", filename);
      if (print_addresses)
	switch (address_radix)
	  {
	  case 8:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lo ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7lo ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7lo ", (unsigned long) start);
	    break;

	  case 10:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Ld ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7ld ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7ld ", (long) start);
	    break;

	  case 16:
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lx ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("%lx%8.8lx ", start >> 32, start & 0xffffffff);
	    else
# endif
#endif
	      printf ("%7lx ", (unsigned long) start);
	    break;
	  }

      buf[i] = '\0';
      fputs (buf, stdout);

      while (1)
	{
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    break;
	  if (! STRING_ISGRAPHIC (c))
	    break;
	  putchar (c);
	}

      putchar ('\n');
    }
}

/* Parse string S as an integer, using decimal radix by default,
   but allowing octal and hex numbers as in C.  */

static int
integer_arg (char *s)
{
  int value;
  int radix = 10;
  char *p = s;
  int c;

  if (*p != '0')
    radix = 10;
  else if (*++p == 'x')
    {
      radix = 16;
      p++;
    }
  else
    radix = 8;

  value = 0;
  while (((c = *p++) >= '0' && c <= '9')
	 || (radix == 16 && (c & ~40) >= 'A' && (c & ~40) <= 'Z'))
    {
      value *= radix;
      if (c >= '0' && c <= '9')
	value += c - '0';
      else
	value += (c & ~40) - 'A';
    }

  if (c == 'b')
    value *= 512;
  else if (c == 'B')
    value *= 1024;
  else
    p--;

  if (*p)
    fatal (_("invalid integer argument %s"), s);

  return value;
}

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" Display printable strings in [file(s)] (stdin by default)\n"));
  fprintf (stream, _(" The options are:\n\
  -a - --all                Scan the entire file, not just the data section\n\
  -f --print-file-name      Print the name of the file before each string\n\
  -n --bytes=[number]       Locate & print any NUL-terminated sequence of at\n\
  -<number>                 least [number] characters (default 4).\n\
  -t --radix={o,x,d}        Print the location of the string in base 8, 10 or 16\n\
  -o                        An alias for --radix=o\n\
  -T --target=<BFDNAME>     Specify the binary file format\n\
  -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                            s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
  -h --help                 Display this information\n\
  -v --version              Print the program's version number\n"));
  list_supported_targets (program_name, stream);
  if (status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d171 3
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d146 7
a152 14
static void strings_a_section
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean strings_object_file
  PARAMS ((const char *));
static bfd_boolean strings_file
  PARAMS ((char *file));
static int integer_arg
  PARAMS ((char *s));
static void print_strings
  PARAMS ((const char *, FILE *, file_off, int, int, char *));
static void usage
  PARAMS ((FILE *, int));
static long get_char
  PARAMS ((FILE *, file_off *, int *, char **));
d154 1
a154 2
int main
  PARAMS ((int, char **));
d157 1
a157 3
main (argc, argv)
     int argc;
     char **argv;
d314 1
a314 4
strings_a_section (abfd, sect, filearg)
     bfd *abfd;
     asection *sect;
     PTR filearg;
d321 1
a321 1
      PTR mem = xmalloc (sz);
d339 1
a339 2
strings_object_file (file)
     const char *file;
d357 1
a357 1
  bfd_map_over_sections (abfd, strings_a_section, (PTR) file);
d371 1
a371 2
strings_file (file)
     char *file;
d373 3
d416 1
a416 5
get_char (stream, address, magiccount, magic)
     FILE *stream;
     file_off *address;
     int *magiccount;
     char **magic;
d487 2
a488 7
print_strings (filename, stream, address, stop_point, magiccount, magic)
     const char *filename;
     FILE *stream;
     file_off address;
     int stop_point;
     int magiccount;
     char *magic;
d589 1
a589 2
integer_arg (s)
     char *s;
d631 1
a631 3
usage (stream, status)
     FILE *stream;
     int status;
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d42 6
d60 3
d65 1
a65 2
#include <getopt.h>
#include <ctype.h>
d69 1
d84 1
a84 1
#define SET_BINARY(f) do { if (!isatty(f)) setmode(f,O_BINARY); } while (0)
d88 4
a91 8
/* Not all printable characters have ASCII codes (depending upon the
   LOCALE set) but on some older systems it is not safe to test isprint
   without first testing isascii...  */
#if defined isascii && !defined HAVE_LOCALE_H
#define isgraphic(c) (isascii (c) && (isprint (c) || (c) == '\t'))
#else
#define isgraphic(c) (isprint (c) || (c) == '\t')
#endif
d100 8
d114 2
a115 2
/* true means print address within file for each string.  */
static boolean print_addresses;
d117 2
a118 2
/* true means print filename for each string.  */
static boolean print_filenames;
d120 2
a121 2
/* true means for object files scan only the data section.  */
static boolean datasection_only;
d123 2
a124 2
/* true if we found an initialized data section in the current file.  */
static boolean got_a_section;
d129 4
d139 1
d146 14
a159 8
static void strings_a_section PARAMS ((bfd *, asection *, PTR));
static boolean strings_object_file PARAMS ((const char *));
static boolean strings_file PARAMS ((char *file));
static int integer_arg PARAMS ((char *s));
static void print_strings PARAMS ((const char *filename, FILE *stream,
				  file_ptr address, int stop_point,
				  int magiccount, char *magic));
static void usage PARAMS ((FILE *stream, int status));
d161 3
d171 1
a171 1
  boolean files_given = false;
d173 1
a173 1
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
d182 3
a184 3
  print_addresses = false;
  print_filenames = false;
  datasection_only = true;
d186 1
d188 1
a188 1
  while ((optc = getopt_long (argc, argv, "afn:ot:v0123456789",
d194 1
a194 1
	  datasection_only = false;
d198 1
a198 1
	  print_filenames = true;
d201 1
d208 1
a208 3
	    {
	      fatal (_("invalid number %s"), optarg);
	    }
d212 1
a212 1
	  print_addresses = true;
d217 1
a217 1
	  print_addresses = true;
d243 7
d269 18
d292 1
a292 1
      datasection_only = false;
d297 1
a297 1
      files_given = true;
d304 1
a304 1
	    datasection_only = false;
d307 2
a308 2
	      files_given = true;
	      exit_status |= (strings_file (argv[optind]) == false);
d313 1
a313 1
  if (files_given == false)
d335 1
d338 1
a338 1
	  got_a_section = true;
d348 2
a349 2
   Return true if successful,
   false if not (such as if FILE is not an object file).  */
d351 1
a351 1
static boolean
d358 2
a359 4
    {
      /* Treat the file as a non-object file.  */
      return false;
    }
d364 1
a364 1
  if (bfd_check_format (abfd, bfd_object) == false)
d367 1
a367 1
      return false;
d370 1
a370 1
  got_a_section = false;
d376 1
a376 1
      return false;
d382 1
a382 1
/* Print the strings in FILE.  Return true if ok, false if an error occurs.  */
d384 1
a384 1
static boolean
d396 1
a396 4
      stream = fopen (file, "rb");
      /* Not all systems permit "rb", so try "r" if it failed.  */
      if (stream == NULL)
	stream = fopen (file, "r");
d401 1
a401 1
	  return false;
d404 1
a404 1
      print_strings (file, stream, (file_ptr) 0, 0, 0, (char *) 0);
d410 46
a455 1
	  return false;
d457 25
d484 4
a487 1
  return true;
d506 1
a506 1
     file_ptr address;
d511 1
a511 1
  char *buf = (char *) xmalloc (string_min + 1);
d515 1
a515 1
      file_ptr start;
d517 1
a517 1
      int c;
d526 4
a529 15
	  if (magiccount)
	    {
	      magiccount--;
	      c = *magic++;
	    }
	  else
	    {
	      if (stream == NULL)
		return;
	      c = getc (stream);
	      if (c == EOF)
		return;
	    }
	  address++;
	  if (!isgraphic (c))
d544 12
a555 1
	    printf ("%7lo ", (unsigned long) start);
d559 12
a570 1
	    printf ("%7ld ", (long) start);
d574 12
a585 1
	    printf ("%7lx ", (unsigned long) start);
d594 4
a597 15
	  if (magiccount)
	    {
	      magiccount--;
	      c = *magic++;
	    }
	  else
	    {
	      if (stream == NULL)
		break;
	      c = getc (stream);
	      if (c == EOF)
		break;
	    }
	  address++;
	  if (! isgraphic (c))
d647 2
a648 3
    {
      fatal (_("invalid integer argument %s"), s);
    }
d657 14
a670 5
  fprintf (stream, _("\
Usage: %s [-afov] [-n min-len] [-min-len] [-t {o,x,d}] [-]\n\
       [--all] [--print-file-name] [--bytes=min-len] [--radix={o,x,d}]\n\
       [--target=bfdname] [--help] [--version] file...\n"),
	   program_name);
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
d79 5
a83 2
#ifdef isascii
#define isgraphic(c) (isascii (c) && isprint (c))
d85 1
a85 1
#define isgraphic(c) (isprint (c))
d147 1
a147 1
  setlocale (LC_MESSAGES, "");
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation, Inc.
d17 2
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d62 17
d125 2
d129 1
a129 1
static void print_strings PARAMS ((char *filename, FILE *stream,
d143 6
d177 1
a177 3
	      fprintf (stderr, "%s: invalid number %s\n",
		       program_name, optarg);
	      exit (1);
d222 1
a222 1
	    string_min = optc;
d233 1
d238 3
d269 1
a269 1
strings_a_section (abfd, sect, file)
d272 1
a272 1
     PTR file;
d274 2
d297 1
a297 1
     char *file;
d317 1
a317 1
  bfd_map_over_sections (abfd, strings_a_section, file);
d380 1
a380 1
     char *filename;
d513 1
a513 2
      fprintf (stderr, "%s: invalid integer argument %s\n", program_name, s);
      exit (1);
d523 1
a523 1
  fprintf (stream, "\
d526 1
a526 1
       [--target=bfdname] [--help] [--version] file...\n",
d530 1
a530 1
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94 Free Software Foundation, Inc.
a93 2
extern char *program_version;

d189 2
a190 2
	  printf ("GNU %s version %s\n", program_name, program_version);
	  exit (0);
d499 2
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
void
d234 1
a234 1
  exit (exit_status);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d115 1
a115 1
int
d234 1
a234 1
  return (exit_status);
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation, Inc.
d94 2
d191 2
a192 2
	  print_version ("strings");
	  break;
a500 2
  if (status == 0)
    fprintf (stream, "Report bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
d16 1
a16 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a105 2
static void strings_a_section PARAMS ((bfd *, asection *, PTR));
static boolean strings_object_file PARAMS ((const char *));
d108 1
a108 1
static void print_strings PARAMS ((const char *filename, FILE *stream,
a207 1
  set_default_bfd_target ();
d240 1
a240 1
strings_a_section (abfd, sect, filearg)
d243 1
a243 1
     PTR filearg;
a244 2
  const char *file = (const char *) filearg;

d266 1
a266 1
     const char *file;
d286 1
a286 1
  bfd_map_over_sections (abfd, strings_a_section, (PTR) file);
d349 1
a349 1
     const char *filename;
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a60 17
/* Some platforms need to put stdin into binary mode, to read
    binary files.  */
#ifdef HAVE_SETMODE
#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#define setmode _setmode
#else
#define O_BINARY 0
#endif
#endif
#if O_BINARY
#include <io.h>
#define SET_BINARY(f) do { if (!isatty(f)) setmode(f,O_BINARY); } while (0)
#endif
#endif

a124 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d153 3
a155 1
	      fatal (_("invalid number %s"), optarg);
d200 1
a200 1
	    string_min = optc - '0';
a215 3
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
d488 2
a489 1
      fatal (_("invalid integer argument %s"), s);
d499 1
a499 1
  fprintf (stream, _("\
d502 1
a502 1
       [--target=bfdname] [--help] [--version] file...\n"),
d506 1
a506 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d79 2
a80 5
/* Not all printable characters have ASCII codes (depending upon the
   LOCALE set) but on some older systems it is not safe to test isprint
   without first testing isascii...  */
#if defined isascii && !defined HAVE_LOCALE_H
#define isgraphic(c) (isascii (c) && (isprint (c) || (c) == '\t'))
d82 1
a82 1
#define isgraphic(c) (isprint (c) || (c) == '\t')
d144 1
a144 1
  setlocale (LC_ALL, "");
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.
a41 6
   --encoding={s,S,b,l,B,L}
   -e {s,S,b,l,B,L}
		Select character encoding: 7-bit-character, 8-bit-character,
		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit,
		littleendian 32-bit.

a53 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
d56 2
a57 1
#include "getopt.h"
a60 1
#include "safe-ctype.h"
d75 1
a75 1
#define SET_BINARY(f) do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
d79 8
a86 4
#define STRING_ISGRAPHIC(c) \
      (   (c) >= 0 \
       && (c) <= 255 \
       && ((c) == '\t' || ISPRINT (c) || (encoding == 'S' && (c) > 127)))
a94 8
#ifdef HAVE_FOPEN64
typedef off64_t file_off;
#define file_open(s,m) fopen64(s, m)
#else
typedef off_t file_off;
#define file_open(s,m) fopen(s, m)
#endif

d101 2
a102 2
/* TRUE means print address within file for each string.  */
static bfd_boolean print_addresses;
d104 2
a105 2
/* TRUE means print filename for each string.  */
static bfd_boolean print_filenames;
d107 2
a108 2
/* TRUE means for object files scan only the data section.  */
static bfd_boolean datasection_only;
d110 2
a111 2
/* TRUE if we found an initialized data section in the current file.  */
static bfd_boolean got_a_section;
a115 4
/* The character encoding format.  */
static char encoding;
static int encoding_bytes;

a121 1
  {"encoding", required_argument, NULL, 'e'},
d128 8
a135 14
static void strings_a_section
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean strings_object_file
  PARAMS ((const char *));
static bfd_boolean strings_file
  PARAMS ((char *file));
static int integer_arg
  PARAMS ((char *s));
static void print_strings
  PARAMS ((const char *, FILE *, file_off, int, int, char *));
static void usage
  PARAMS ((FILE *, int));
static long get_char
  PARAMS ((FILE *, file_off *, int *, char **));
a136 3
int main
  PARAMS ((int, char **));

d144 1
a144 1
  bfd_boolean files_given = FALSE;
d146 1
a146 1
#if defined (HAVE_SETLOCALE)
d155 3
a157 3
  print_addresses = FALSE;
  print_filenames = FALSE;
  datasection_only = TRUE;
a158 1
  encoding = 's';
d160 1
a160 1
  while ((optc = getopt_long (argc, argv, "afhHn:ot:e:Vv0123456789",
d166 1
a166 1
	  datasection_only = FALSE;
d170 1
a170 1
	  print_filenames = TRUE;
a172 1
	case 'H':
d179 3
a181 1
	    fatal (_("invalid number %s"), optarg);
d185 1
a185 1
	  print_addresses = TRUE;
d190 1
a190 1
	  print_addresses = TRUE;
a215 7
	case 'e':
	  if (optarg[1] != '\0')
	    usage (stderr, 1);
	  encoding = optarg[0];
	  break;

	case 'V':
a234 18
  switch (encoding)
    {
    case 'S':
    case 's':
      encoding_bytes = 1;
      break;
    case 'b':
    case 'l':
      encoding_bytes = 2;
      break;
    case 'B':
    case 'L':
      encoding_bytes = 4;
      break;
    default:
      usage (stderr, 1);
    }

d240 1
a240 1
      datasection_only = FALSE;
d245 1
a245 1
      files_given = TRUE;
d252 1
a252 1
	    datasection_only = FALSE;
d255 2
a256 2
	      files_given = TRUE;
	      exit_status |= strings_file (argv[optind]) == FALSE;
d261 1
a261 1
  if (!files_given)
a282 1

d285 1
a285 1
	  got_a_section = TRUE;
d295 2
a296 2
   Return TRUE if successful,
   FALSE if not (such as if FILE is not an object file).  */
d298 1
a298 1
static bfd_boolean
d305 4
a308 2
    /* Treat the file as a non-object file.  */
    return FALSE;
d313 1
a313 1
  if (!bfd_check_format (abfd, bfd_object))
d316 1
a316 1
      return FALSE;
d319 1
a319 1
  got_a_section = FALSE;
d325 1
a325 1
      return FALSE;
d331 1
a331 1
/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */
d333 1
a333 1
static bfd_boolean
d345 4
a348 1
      stream = file_open (file, FOPEN_RB);
d353 1
a353 1
	  return FALSE;
d356 1
a356 1
      print_strings (file, stream, (file_off) 0, 0, 0, (char *) 0);
d362 1
a362 46
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read the next character, return EOF if none available.
   Assume that STREAM is positioned so that the next byte read
   is at address ADDRESS in the file.

   If STREAM is NULL, do not read from it.
   The caller can supply a buffer of characters
   to be processed before the data in STREAM.
   MAGIC is the address of the buffer and
   MAGICCOUNT is how many characters are in it.  */

static long
get_char (stream, address, magiccount, magic)
     FILE *stream;
     file_off *address;
     int *magiccount;
     char **magic;
{
  int c, i;
  long r = EOF;
  unsigned char buf[4];

  for (i = 0; i < encoding_bytes; i++)
    {
      if (*magiccount)
	{
	  (*magiccount)--;
	  c = *(*magic)++;
	}
      else
	{
	  if (stream == NULL)
	    return EOF;
#ifdef HAVE_GETC_UNLOCKED
	  c = getc_unlocked (stream);
#else
	  c = getc (stream);
#endif
	  if (c == EOF)
	    return EOF;
a363 25

      (*address)++;
      buf[i] = c;
    }

  switch (encoding)
    {
    case 'S':
    case 's':
      r = buf[0];
      break;
    case 'b':
      r = (buf[0] << 8) | buf[1];
      break;
    case 'l':
      r = buf[0] | (buf[1] << 8);
      break;
    case 'B':
      r = ((long) buf[0] << 24) | ((long) buf[1] << 16) |
	((long) buf[2] << 8) | buf[3];
      break;
    case 'L':
      r = buf[0] | ((long) buf[1] << 8) | ((long) buf[2] << 16) |
	((long) buf[3] << 24);
      break;
d366 1
a366 4
  if (r == EOF)
    return 0;

  return r;
d385 1
a385 1
     file_off address;
d390 1
a390 1
  char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
d394 1
a394 1
      file_off start;
d396 1
a396 1
      long c;
d405 15
a419 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    return;
	  if (! STRING_ISGRAPHIC (c))
d434 1
a434 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lo ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7lo ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7lo ", (unsigned long) start);
d438 1
a438 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Ld ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("++%7ld ", (unsigned long) start);
	    else
# endif
#endif
	      printf ("%7ld ", (long) start);
d442 1
a442 12
#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
	    if (sizeof (start) > sizeof (long))
	      printf ("%7Lx ", (unsigned long long) start);
	    else
#else
# if !BFD_HOST_64BIT_LONG
	    if (start != (unsigned long) start)
	      printf ("%lx%8.8lx ", start >> 32, start & 0xffffffff);
	    else
# endif
#endif
	      printf ("%7lx ", (unsigned long) start);
d451 15
a465 4
	  c = get_char (stream, &address, &magiccount, &magic);
	  if (c == EOF)
	    break;
	  if (! STRING_ISGRAPHIC (c))
d515 3
a517 2
    fatal (_("invalid integer argument %s"), s);

d526 5
a530 14
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" Display printable strings in [file(s)] (stdin by default)\n"));
  fprintf (stream, _(" The options are:\n\
  -a - --all                Scan the entire file, not just the data section\n\
  -f --print-file-name      Print the name of the file before each string\n\
  -n --bytes=[number]       Locate & print any NUL-terminated sequence of at\n\
  -<number>                 least [number] characters (default 4).\n\
  -t --radix={o,x,d}        Print the location of the string in base 8, 10 or 16\n\
  -o                        An alias for --radix=o\n\
  -T --target=<BFDNAME>     Specify the binary file format\n\
  -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                            s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
  -h --help                 Display this information\n\
  -v --version              Print the program's version number\n"));
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d146 14
a159 7
static void strings_a_section (bfd *, asection *, void *);
static bfd_boolean strings_object_file (const char *);
static bfd_boolean strings_file (char *file);
static int integer_arg (char *s);
static void print_strings (const char *, FILE *, file_off, int, int, char *);
static void usage (FILE *, int);
static long get_char (FILE *, file_off *, int *, char **);
d161 2
a162 1
int main (int, char **);
d165 3
a167 1
main (int argc, char **argv)
d324 4
a327 1
strings_a_section (bfd *abfd, asection *sect, void *filearg)
d334 1
a334 1
      void *mem = xmalloc (sz);
d352 2
a353 1
strings_object_file (const char *file)
d371 1
a371 1
  bfd_map_over_sections (abfd, strings_a_section, (void *) file);
d385 2
a386 1
strings_file (char *file)
a387 3
  if (get_file_size (file) < 1)
    return FALSE;

d428 5
a432 1
get_char (FILE *stream, file_off *address, int *magiccount, char **magic)
d503 7
a509 2
print_strings (const char *filename, FILE *stream, file_off address,
	       int stop_point, int magiccount, char *magic)
d610 2
a611 1
integer_arg (char *s)
d653 3
a655 1
usage (FILE *stream, int status)
@


