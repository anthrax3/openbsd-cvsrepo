head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.25;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.32;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.29;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.03.43;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.03.43;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.15.48;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.02;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.14.24;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.03;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* coffgrok.c
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

This file is part of GNU Binutils.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Written by Steve Chamberlain (sac@@cygnus.com)

   This module reads a coff file and builds a really simple type tree
   which can be read by other programs.  The first application is a
   coff->sysroff converter.  It can be tested with coffdump.c.

*/

#include "bfd.h"
#include "libiberty.h"
#include "bucomm.h"

#include "coff/internal.h"
#include "../bfd/libcoff.h"
#include "coffgrok.h"
int lofile = 1;
static struct coff_scope *top_scope;
static struct coff_scope *file_scope;
static struct coff_ofile *ofile;

struct coff_symbol *last_function_symbol;
struct coff_type *last_function_type;
struct coff_type *last_struct;
struct coff_type *last_enum;
struct coff_sfile *cur_sfile;

static struct coff_symbol **tindex;


static asymbol **syms;
static long symcount;

#define N(x) ((x)->_n._n_nptr[1])

static struct coff_ptr_struct *rawsyms;
static int rawcount;
static bfd *abfd;

#define PTR_SIZE	4
#define SHORT_SIZE	2
#define INT_SIZE	4
#define LONG_SIZE	4
#define FLOAT_SIZE	4
#define DOUBLE_SIZE	8

#define INDEXOF(p)  ((struct coff_ptr_struct *)(p)-(rawsyms))

static struct coff_scope *empty_scope (void);
static struct coff_symbol *empty_symbol (void);
static void push_scope (int);
static void pop_scope (void);
static void do_sections_p1 (struct coff_ofile *);
static void do_sections_p2 (struct coff_ofile *);
static struct coff_where *do_where (int);
static struct coff_line *do_lines (int, char *);
static struct coff_type *do_type (int);
static struct coff_visible *do_visible (int);
static int do_define (int, struct coff_scope *);
static struct coff_ofile *doit (void);

static struct coff_scope *
empty_scope (void)
{
  struct coff_scope *l;
  l = (struct coff_scope *) (xcalloc (sizeof (struct coff_scope), 1));
  return l;
}

static struct coff_symbol *
empty_symbol (void)
{
  return (struct coff_symbol *) (xcalloc (sizeof (struct coff_symbol), 1));
}

/*int l;*/
static void
push_scope (int link)
{
  struct coff_scope *n = empty_scope ();
  if (link)
    {
      if (top_scope)
	{
	  if (top_scope->list_tail)
	    {
	      top_scope->list_tail->next = n;
	    }
	  else
	    {
	      top_scope->list_head = n;
	    }
	  top_scope->list_tail = n;
	}
    }
  n->parent = top_scope;

  top_scope = n;
}

static void
pop_scope (void)
{
  top_scope = top_scope->parent;
}

static void
do_sections_p1 (struct coff_ofile *head)
{
  asection *section;
  int idx;
  struct coff_section *all = (struct coff_section *) (xcalloc (abfd->section_count + 1,
					     sizeof (struct coff_section)));
  head->nsections = abfd->section_count + 1;
  head->sections = all;

  for (idx = 0, section = abfd->sections; section; section = section->next, idx++)
    {
      long relsize;
      int i = section->target_index;
      arelent **relpp;
      long relcount;

      relsize = bfd_get_reloc_upper_bound (abfd, section);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));
      if (relsize == 0)
	continue;
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));

      head->sections[i].name = (char *) (section->name);
      head->sections[i].code = section->flags & SEC_CODE;
      head->sections[i].data = section->flags & SEC_DATA;
      if (strcmp (section->name, ".bss") == 0)
	head->sections[i].data = 1;
      head->sections[i].address = section->lma;
      head->sections[i].size = section->_raw_size;
      head->sections[i].number = idx;
      head->sections[i].nrelocs = section->reloc_count;
      head->sections[i].relocs =
	(struct coff_reloc *) (xcalloc (section->reloc_count,
					sizeof (struct coff_reloc)));
      head->sections[i].bfd_section = section;
    }
  head->sections[0].name = "ABSOLUTE";
  head->sections[0].code = 0;
  head->sections[0].data = 0;
  head->sections[0].address = 0;
  head->sections[0].size = 0;
  head->sections[0].number = 0;
}

static void
do_sections_p2 (struct coff_ofile *head)
{
  asection *section;
  for (section = abfd->sections; section; section = section->next)
    {
      unsigned int j;

      for (j = 0; j < section->reloc_count; j++)
	{
	  int idx;
	  int i = section->target_index;
	  struct coff_reloc *r = head->sections[i].relocs + j;
	  arelent *sr = section->relocation + j;
	  r->offset = sr->address;
	  r->addend = sr->addend;
	  idx = ((coff_symbol_type *) (sr->sym_ptr_ptr[0]))->native - rawsyms;
	  r->symbol = tindex[idx];
	}
    }
}

static struct coff_where *
do_where (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  struct coff_where *where =
    (struct coff_where *) (xmalloc (sizeof (struct coff_where)));
  where->offset = sym->n_value;

  if (sym->n_scnum == -1)
    sym->n_scnum = 0;

  switch (sym->n_sclass)
    {
    case C_FIELD:
      where->where = coff_where_member_of_struct;
      where->offset = sym->n_value / 8;
      where->bitoffset = sym->n_value % 8;
      where->bitsize = rawsyms[i + 1].u.auxent.x_sym.x_misc.x_lnsz.x_size;
      break;
    case C_MOE:
      where->where = coff_where_member_of_enum;
      break;
    case C_MOS:
    case C_MOU:
      where->where = coff_where_member_of_struct;
      break;
    case C_AUTO:
    case C_ARG:
      where->where = coff_where_stack;
      break;
    case C_EXT:
    case C_STAT:
    case C_EXTDEF:
    case C_LABEL:
      where->where = coff_where_memory;
      where->section = &ofile->sections[sym->n_scnum];
      break;
    case C_REG:
    case C_REGPARM:
      where->where = coff_where_register;
      break;
    case C_ENTAG:
      where->where = coff_where_entag;
      break;
    case C_STRTAG:
    case C_UNTAG:
      where->where = coff_where_strtag;
      break;
    case C_TPDEF:
      where->where = coff_where_typedef;
      break;
    default:
      abort ();
      break;
    }
  return where;
}

static
struct coff_line *
do_lines (int i, char *name ATTRIBUTE_UNUSED)
{
  struct coff_line *res = (struct coff_line *) xcalloc (sizeof (struct coff_line), 1);
  asection *s;
  unsigned int l;

  /* Find out if this function has any line numbers in the table */
  for (s = abfd->sections; s; s = s->next)
    {
      for (l = 0; l < s->lineno_count; l++)
	{
	  if (s->lineno[l].line_number == 0)
	    {
	      if (rawsyms + i == ((coff_symbol_type *) (&(s->lineno[l].u.sym[0])))->native)
		{
		  /* These lines are for this function - so count them and stick them on */
		  int c = 0;
		  /* Find the linenumber of the top of the function, since coff linenumbers
		     are relative to the start of the function.  */
		  int start_line = rawsyms[i + 3].u.auxent.x_sym.x_misc.x_lnsz.x_lnno;

		  l++;
		  for (c = 0; s->lineno[l + c + 1].line_number; c++)
		    ;

		  /* Add two extra records, one for the prologue and one for the epilogue */
		  c += 1;
		  res->nlines = c;
		  res->lines = (int *) (xcalloc (sizeof (int), c));
		  res->addresses = (int *) (xcalloc (sizeof (int), c));
		  res->lines[0] = start_line;
		  res->addresses[0] = rawsyms[i].u.syment.n_value - s->vma;
		  for (c = 0; s->lineno[l + c + 1].line_number; c++)
		    {
		      res->lines[c + 1] = s->lineno[l + c].line_number + start_line - 1;
		      res->addresses[c + 1] = s->lineno[l + c].u.offset;
		    }
		  return res;
		}
	    }
	}
    }
  return res;
}

static
struct coff_type *
do_type (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  union internal_auxent *aux = &rawsyms[i + 1].u.auxent;
  struct coff_type *res =
    (struct coff_type *) xmalloc (sizeof (struct coff_type));
  int type = sym->n_type;
  int which_dt = 0;
  int dimind = 0;

  res->type = coff_basic_type;
  res->u.basic = type & 0xf;

  switch (type & 0xf)
    {
    case T_NULL:
    case T_VOID:
      if (sym->n_numaux && sym->n_sclass == C_STAT)
	{
	  /* This is probably a section definition */
	  res->type = coff_secdef_type;
	  res->size = aux->x_scn.x_scnlen;
	}
      else
	{
	  if (type == 0)
	    {
	      /* Don't know what this is, let's make it a simple int */
	      res->size = INT_SIZE;
	      res->u.basic = T_UINT;
	    }
	  else
	    {
	      /* Else it could be a function or pointer to void */
	      res->size = 0;
	    }
	}
      break;


      break;
    case T_UCHAR:
    case T_CHAR:
      res->size = 1;
      break;
    case T_USHORT:
    case T_SHORT:
      res->size = SHORT_SIZE;
      break;
    case T_UINT:
    case T_INT:
      res->size = INT_SIZE;
      break;
    case T_ULONG:
    case T_LONG:
      res->size = LONG_SIZE;
      break;
    case T_FLOAT:
      res->size = FLOAT_SIZE;
      break;
    case T_DOUBLE:
      res->size = DOUBLE_SIZE;
      break;
    case T_STRUCT:
    case T_UNION:
      if (sym->n_numaux)
	{
	  if (aux->x_sym.x_tagndx.p)
	    {
	      /* Referring to a struct defined elsewhere */
	      res->type = coff_structref_type;
	      res->u.astructref.ref = tindex[INDEXOF (aux->x_sym.x_tagndx.p)];
	      res->size = res->u.astructref.ref ?
		res->u.astructref.ref->type->size : 0;
	    }
	  else
	    {
	      /* A definition of a struct */
	      last_struct = res;
	      res->type = coff_structdef_type;
	      res->u.astructdef.elements = empty_scope ();
	      res->u.astructdef.idx = 0;
	      res->u.astructdef.isstruct = (type & 0xf) == T_STRUCT;
	      res->size = aux->x_sym.x_misc.x_lnsz.x_size;
	    }
	}
      else
	{
	  /* No auxents - it's anonymous */
	  res->type = coff_structref_type;
	  res->u.astructref.ref = 0;
	  res->size = 0;
	}
      break;
    case T_ENUM:
      if (aux->x_sym.x_tagndx.p)
	{
	  /* Referring to a enum defined elsewhere */
	  res->type = coff_enumref_type;
	  res->u.aenumref.ref = tindex[INDEXOF (aux->x_sym.x_tagndx.p)];
	  res->size = res->u.aenumref.ref->type->size;
	}
      else
	{
	  /* A definition of an enum */
	  last_enum = res;
	  res->type = coff_enumdef_type;
	  res->u.aenumdef.elements = empty_scope ();
	  res->size = aux->x_sym.x_misc.x_lnsz.x_size;
	}
      break;
    case T_MOE:
      break;
    }

  for (which_dt = 5; which_dt >= 0; which_dt--)
    {
      switch ((type >> ((which_dt * 2) + 4)) & 0x3)
	{
	case 0:
	  break;
	case DT_ARY:
	  {
	    struct coff_type *ptr = ((struct coff_type *)
				     xmalloc (sizeof (struct coff_type)));
	    int els = (dimind < DIMNUM
		       ? aux->x_sym.x_fcnary.x_ary.x_dimen[dimind]
		       : 0);
	    ++dimind;
	    ptr->type = coff_array_type;
	    ptr->size = els * res->size;
	    ptr->u.array.dim = els;
	    ptr->u.array.array_of = res;
	    res = ptr;
	    break;
	  }
	case DT_PTR:
	  {
	    struct coff_type *ptr =
	      (struct coff_type *) xmalloc (sizeof (struct coff_type));
	    ptr->size = PTR_SIZE;
	    ptr->type = coff_pointer_type;
	    ptr->u.pointer.points_to = res;
	    res = ptr;
	    break;
	  }
	case DT_FCN:
	  {
	    struct coff_type *ptr
	      = (struct coff_type *) xmalloc (sizeof (struct coff_type));
	    ptr->size = 0;
	    ptr->type = coff_function_type;
	    ptr->u.function.function_returns = res;
	    ptr->u.function.parameters = empty_scope ();
	    ptr->u.function.lines = do_lines (i, sym->_n._n_nptr[1]);
	    ptr->u.function.code = 0;
	    last_function_type = ptr;
	    res = ptr;
	    break;
	  }
	}
    }
  return res;
}

static struct coff_visible *
do_visible (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  struct coff_visible *visible =
    (struct coff_visible *) (xmalloc (sizeof (struct coff_visible)));
  enum coff_vis_type t;
  switch (sym->n_sclass)
    {
    case C_MOS:
    case C_MOU:
    case C_FIELD:
      t = coff_vis_member_of_struct;
      break;
    case C_MOE:
      t = coff_vis_member_of_enum;
      break;

    case C_REGPARM:
      t = coff_vis_regparam;
      break;

    case C_REG:
      t = coff_vis_register;
      break;
    case C_STRTAG:
    case C_UNTAG:
    case C_ENTAG:
    case C_TPDEF:
      t = coff_vis_tag;
      break;
    case C_AUTOARG:
    case C_ARG:
      t = coff_vis_autoparam;
      break;
    case C_AUTO:


      t = coff_vis_auto;
      break;
    case C_LABEL:
    case C_STAT:
      t = coff_vis_int_def;
      break;
    case C_EXT:
      if (sym->n_scnum == N_UNDEF)
	{
	  if (sym->n_value)
	    t = coff_vis_common;
	  else
	    t = coff_vis_ext_ref;
	}
      else
	t = coff_vis_ext_def;
      break;
    default:
      abort ();
      break;

    }
  visible->type = t;
  return visible;
}

static int
do_define (int i, struct coff_scope *b)
{
  static int symbol_index;
  struct internal_syment *sym = &rawsyms[i].u.syment;

  /* Define a symbol and attach to block b */
  struct coff_symbol *s = empty_symbol ();

  s->number = ++symbol_index;
  s->name = sym->_n._n_nptr[1];
  s->sfile = cur_sfile;
  /* Glue onto the ofile list */
  if (lofile >= 0)
    {
      if (ofile->symbol_list_tail)
	ofile->symbol_list_tail->next_in_ofile_list = s;
      else
	ofile->symbol_list_head = s;
      ofile->symbol_list_tail = s;
      /* And the block list */
    }
  if (b->vars_tail)
    b->vars_tail->next = s;
  else
    b->vars_head = s;

  b->vars_tail = s;
  b->nvars++;
  s->type = do_type (i);
  s->where = do_where (i);
  s->visible = do_visible (i);

  tindex[i] = s;

  /* We remember the lowest address in each section for each source file */

  if (s->where->where == coff_where_memory
      && s->type->type == coff_secdef_type)
    {
      struct coff_isection *is = cur_sfile->section + s->where->section->number;

      if (!is->init)
	{
	  is->low = s->where->offset;
	  is->high = s->where->offset + s->type->size;
	  is->init = 1;
	  is->parent = s->where->section;
	}

    }

  if (s->type->type == coff_function_type)
    last_function_symbol = s;

  return i + sym->n_numaux + 1;
}


static
struct coff_ofile *
doit (void)
{
  int i;
  int infile = 0;
  struct coff_ofile *head =
    (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));
  ofile = head;
  head->source_head = 0;
  head->source_tail = 0;
  head->nsources = 0;
  head->symbol_list_tail = 0;
  head->symbol_list_head = 0;
  do_sections_p1 (head);
  push_scope (1);

  for (i = 0; i < rawcount;)
    {
      struct internal_syment *sym = &rawsyms[i].u.syment;
      switch (sym->n_sclass)
	{
	case C_FILE:
	  {
	    /* new source file announced */
	    struct coff_sfile *n =
	      (struct coff_sfile *) xmalloc (sizeof (struct coff_sfile));
	    n->section = (struct coff_isection *) xcalloc (sizeof (struct coff_isection), abfd->section_count + 1);
	    cur_sfile = n;
	    n->name = sym->_n._n_nptr[1];
	    n->next = 0;

	    if (infile)
	      {
		pop_scope ();
	      }
	    infile = 1;
	    push_scope (1);
	    file_scope = n->scope = top_scope;

	    if (head->source_tail)
	      head->source_tail->next = n;
	    else
	      head->source_head = n;
	    head->source_tail = n;
	    head->nsources++;
	    i += sym->n_numaux + 1;
	  }
	  break;
	case C_FCN:
	  {
	    char *name = sym->_n._n_nptr[1];
	    if (name[1] == 'b')
	      {
		/* Function start */
		push_scope (0);
		last_function_type->u.function.code = top_scope;
		top_scope->sec = ofile->sections + sym->n_scnum;
		top_scope->offset = sym->n_value;
	      }
	    else
	      {
		top_scope->size = sym->n_value - top_scope->offset + 1;
		pop_scope ();

	      }
	    i += sym->n_numaux + 1;
	  }
	  break;

	case C_BLOCK:
	  {
	    char *name = sym->_n._n_nptr[1];
	    if (name[1] == 'b')
	      {
		/* Block start */
		push_scope (1);
		top_scope->sec = ofile->sections + sym->n_scnum;
		top_scope->offset = sym->n_value;

	      }
	    else
	      {
		top_scope->size = sym->n_value - top_scope->offset + 1;
		pop_scope ();
	      }
	    i += sym->n_numaux + 1;
	  }
	  break;
	case C_REGPARM:
	case C_ARG:
	  i = do_define (i, last_function_symbol->type->u.function.parameters);
	  break;
	case C_MOS:
	case C_MOU:
	case C_FIELD:
	  i = do_define (i, last_struct->u.astructdef.elements);
	  break;
	case C_MOE:
	  i = do_define (i, last_enum->u.aenumdef.elements);
	  break;
	case C_STRTAG:
	case C_ENTAG:
	case C_UNTAG:
	  /* Various definition */
	  i = do_define (i, top_scope);
	  break;
	case C_EXT:
	case C_LABEL:
	  i = do_define (i, file_scope);
	  break;
	case C_STAT:
	case C_TPDEF:
	case C_AUTO:
	case C_REG:
	  i = do_define (i, top_scope);
	  break;
	default:
	  abort ();
	case C_EOS:
	  i += sym->n_numaux + 1;
	  break;
	}
    }
  do_sections_p2 (head);
  return head;
}

struct coff_ofile *
coff_grok (bfd *inabfd)
{
  long storage;
  struct coff_ofile *p;
  abfd = inabfd;
  storage = bfd_get_symtab_upper_bound (abfd);

  if (storage < 0)
    bfd_fatal (abfd->filename);

  syms = (asymbol **) xmalloc (storage);
  symcount = bfd_canonicalize_symtab (abfd, syms);
  if (symcount < 0)
    bfd_fatal (abfd->filename);
  rawsyms = obj_raw_syments (abfd);
  rawcount = obj_raw_syment_count (abfd);;
  tindex = (struct coff_symbol **) (xcalloc (sizeof (struct coff_symbol *), rawcount));

  p = doit ();
  return p;
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d59 6
a64 6
#define PTR_SIZE 	4
#define SHORT_SIZE 	2
#define INT_SIZE 	4
#define LONG_SIZE 	4
#define FLOAT_SIZE 	4
#define DOUBLE_SIZE 	8
d68 12
a79 12
static struct coff_scope *empty_scope PARAMS ((void));
static struct coff_symbol *empty_symbol PARAMS ((void));
static void push_scope PARAMS ((int));
static void pop_scope PARAMS ((void));
static void do_sections_p1 PARAMS ((struct coff_ofile *));
static void do_sections_p2 PARAMS ((struct coff_ofile *));
static struct coff_where *do_where PARAMS ((int));
static struct coff_line *do_lines PARAMS ((int, char *));
static struct coff_type *do_type PARAMS ((int));
static struct coff_visible *do_visible PARAMS ((int));
static int do_define PARAMS ((int, struct coff_scope *));
static struct coff_ofile *doit PARAMS ((void));
d82 1
a82 1
empty_scope ()
d90 1
a90 1
empty_symbol ()
d97 1
a97 2
push_scope (link)
     int link;
d121 1
a121 1
pop_scope ()
d127 1
a127 2
do_sections_p1 (head)
     struct coff_ofile *head;
d176 1
a176 2
do_sections_p2 (head)
     struct coff_ofile *head;
d198 1
a198 2
do_where (i)
     int i;
d257 1
a257 3
do_lines (i, name)
     int i;
     char *name ATTRIBUTE_UNUSED;
d304 1
a304 2
do_type (i)
     int i;
d373 1
a373 1
	      /* Refering to a struct defined elsewhere */
d392 1
a392 1
	  /* No auxents - it's anonynmous */
d401 1
a401 1
	  /* Refering to a enum defined elsewhere */
d470 1
a470 2
do_visible (i)
     int i;
d534 1
a534 3
do_define (i, b)
     int i;
     struct coff_scope *b;
d594 1
a594 1
doit ()
d721 1
a721 2
coff_grok (inabfd)
     bfd *inabfd;
@


1.3
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
d29 2
a30 1
#include <bfd.h>
d58 1
a58 1
extern char *xcalloc ();
d68 13
d149 1
a149 1
        continue;
d281 1
a281 1
		     are relative to the start of the function. */
d609 1
a609 1
  (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 97, 1998 Free Software Foundation, Inc.
d248 1
a248 1
     char *name;
@


1.1
log
@Initial revision
@
text
@a0 2


d2 1
a2 2

   Copyright (C) 1994 Free Software Foundation, Inc.
d145 1
a145 1
      head->sections[i].address = section->vma;
d169 2
a170 1
      int j;
d190 2
a191 2
  struct coff_where *where
  = (struct coff_where *) (malloc (sizeof (struct coff_where)));
d252 2
a253 1
  int l;
d300 2
a301 1
  struct coff_type *res = (struct coff_type *) malloc (sizeof (struct coff_type));
d420 1
a420 1
				     malloc (sizeof (struct coff_type)));
d434 2
a435 1
	    struct coff_type *ptr = (struct coff_type *) malloc (sizeof (struct coff_type));
d444 2
a445 1
	    struct coff_type *ptr = (struct coff_type *) malloc (sizeof (struct coff_type));
d466 2
a467 1
  struct coff_visible *visible = (struct coff_visible *) (malloc (sizeof (struct coff_visible)));
d612 2
a613 1
	    struct coff_sfile *n = (struct coff_sfile *) malloc (sizeof (struct coff_sfile));
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1 2
d4 2
a5 1
   Copyright (C) 1994, 95, 1997 Free Software Foundation, Inc.
d192 2
a193 2
  struct coff_where *where =
    (struct coff_where *) (xmalloc (sizeof (struct coff_where)));
d301 1
a301 2
  struct coff_type *res =
    (struct coff_type *) xmalloc (sizeof (struct coff_type));
d420 1
a420 1
				     xmalloc (sizeof (struct coff_type)));
d434 1
a434 2
	    struct coff_type *ptr =
	      (struct coff_type *) xmalloc (sizeof (struct coff_type));
d443 1
a443 2
	    struct coff_type *ptr
	      = (struct coff_type *) xmalloc (sizeof (struct coff_type));
d464 1
a464 2
  struct coff_visible *visible =
    (struct coff_visible *) (xmalloc (sizeof (struct coff_visible)));
d609 1
a609 2
	    struct coff_sfile *n =
	      (struct coff_sfile *) xmalloc (sizeof (struct coff_sfile));
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 97, 1998 Free Software Foundation, Inc.
d145 1
a145 1
      head->sections[i].address = section->lma;
d169 1
a169 2
      unsigned int j;

d251 1
a251 2
  unsigned int l;

@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
d248 1
a248 1
     char *name ATTRIBUTE_UNUSED;
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
   Free Software Foundation, Inc.
d28 1
a28 2
#include "bfd.h"
#include "libiberty.h"
d56 1
a56 1

a65 13
static struct coff_scope *empty_scope PARAMS ((void));
static struct coff_symbol *empty_symbol PARAMS ((void));
static void push_scope PARAMS ((int));
static void pop_scope PARAMS ((void));
static void do_sections_p1 PARAMS ((struct coff_ofile *));
static void do_sections_p2 PARAMS ((struct coff_ofile *));
static struct coff_where *do_where PARAMS ((int));
static struct coff_line *do_lines PARAMS ((int, char *));
static struct coff_type *do_type PARAMS ((int));
static struct coff_visible *do_visible PARAMS ((int));
static int do_define PARAMS ((int, struct coff_scope *));
static struct coff_ofile *doit PARAMS ((void));

d134 1
a134 1
	continue;
d266 1
a266 1
		     are relative to the start of the function.  */
d594 1
a594 1
    (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d59 6
a64 6
#define PTR_SIZE	4
#define SHORT_SIZE	2
#define INT_SIZE	4
#define LONG_SIZE	4
#define FLOAT_SIZE	4
#define DOUBLE_SIZE	8
d68 12
a79 12
static struct coff_scope *empty_scope (void);
static struct coff_symbol *empty_symbol (void);
static void push_scope (int);
static void pop_scope (void);
static void do_sections_p1 (struct coff_ofile *);
static void do_sections_p2 (struct coff_ofile *);
static struct coff_where *do_where (int);
static struct coff_line *do_lines (int, char *);
static struct coff_type *do_type (int);
static struct coff_visible *do_visible (int);
static int do_define (int, struct coff_scope *);
static struct coff_ofile *doit (void);
d82 1
a82 1
empty_scope (void)
d90 1
a90 1
empty_symbol (void)
d97 2
a98 1
push_scope (int link)
d122 1
a122 1
pop_scope (void)
d128 2
a129 1
do_sections_p1 (struct coff_ofile *head)
d178 2
a179 1
do_sections_p2 (struct coff_ofile *head)
d201 2
a202 1
do_where (int i)
d261 3
a263 1
do_lines (int i, char *name ATTRIBUTE_UNUSED)
d310 2
a311 1
do_type (int i)
d380 1
a380 1
	      /* Referring to a struct defined elsewhere */
d399 1
a399 1
	  /* No auxents - it's anonymous */
d408 1
a408 1
	  /* Referring to a enum defined elsewhere */
d477 2
a478 1
do_visible (int i)
d542 3
a544 1
do_define (int i, struct coff_scope *b)
d604 1
a604 1
doit (void)
d731 2
a732 1
coff_grok (bfd *inabfd)
@


