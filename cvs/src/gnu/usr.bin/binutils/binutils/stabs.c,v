head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.50
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	FSF:1.1.1
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.19;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.26;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.33;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.09.22.29.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.32;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.34.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.03.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.03.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.03.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.50.01;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.13.34;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.16.26;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.09;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2001.06.09.22.06.20;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.16.55;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.05;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* stabs.c -- Parse stabs debugging information
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This file contains code which parses stabs debugging information.
   The organization of this code is based on the gdb stabs reading
   code.  The job it does is somewhat different, because it is not
   trying to identify the correct address for anything.  */

#include <stdio.h>

#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "demangle.h"
#include "debug.h"
#include "budbg.h"
#include "filenames.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"

/* The number of predefined XCOFF types.  */

#define XCOFF_TYPE_COUNT 34

/* This structure is used as a handle so that the stab parsing doesn't
   need to use any static variables.  */

struct stab_handle
{
  /* The BFD.  */
  bfd *abfd;
  /* TRUE if this is stabs in sections.  */
  bfd_boolean sections;
  /* The symbol table.  */
  asymbol **syms;
  /* The number of symbols.  */
  long symcount;
  /* The accumulated file name string.  */
  char *so_string;
  /* The value of the last N_SO symbol.  */
  bfd_vma so_value;
  /* The value of the start of the file, so that we can handle file
     relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma file_start_offset;
  /* The offset of the start of the function, so that we can handle
     function relative N_LBRAC and N_RBRAC symbols.  */
  bfd_vma function_start_offset;
  /* The version number of gcc which compiled the current compilation
     unit, 0 if not compiled by gcc.  */
  int gcc_compiled;
  /* Whether an N_OPT symbol was seen that was not generated by gcc,
     so that we can detect the SunPRO compiler.  */
  bfd_boolean n_opt_found;
  /* The main file name.  */
  char *main_filename;
  /* A stack of unfinished N_BINCL files.  */
  struct bincl_file *bincl_stack;
  /* A list of finished N_BINCL files.  */
  struct bincl_file *bincl_list;
  /* Whether we are inside a function or not.  */
  bfd_boolean within_function;
  /* The address of the end of the function, used if we have seen an
     N_FUN symbol while in a function.  This is -1 if we have not seen
     an N_FUN (the normal case).  */
  bfd_vma function_end;
  /* The depth of block nesting.  */
  int block_depth;
  /* List of pending variable definitions.  */
  struct stab_pending_var *pending;
  /* Number of files for which we have types.  */
  unsigned int files;
  /* Lists of types per file.  */
  struct stab_types **file_types;
  /* Predefined XCOFF types.  */
  debug_type xcoff_types[XCOFF_TYPE_COUNT];
  /* Undefined tags.  */
  struct stab_tag *tags;
  /* Set by parse_stab_type if it sees a structure defined as a cross
     reference to itself.  Reset by parse_stab_type otherwise.  */
  bfd_boolean self_crossref;
};

/* A list of these structures is used to hold pending variable
   definitions seen before the N_LBRAC of a block.  */

struct stab_pending_var
{
  /* Next pending variable definition.  */
  struct stab_pending_var *next;
  /* Name.  */
  const char *name;
  /* Type.  */
  debug_type type;
  /* Kind.  */
  enum debug_var_kind kind;
  /* Value.  */
  bfd_vma val;
};

/* A list of these structures is used to hold the types for a single
   file.  */

struct stab_types
{
  /* Next set of slots for this file.  */
  struct stab_types *next;
  /* Types indexed by type number.  */
#define STAB_TYPES_SLOTS (16)
  debug_type types[STAB_TYPES_SLOTS];
};

/* We keep a list of undefined tags that we encounter, so that we can
   fill them in if the tag is later defined.  */

struct stab_tag
{
  /* Next undefined tag.  */
  struct stab_tag *next;
  /* Tag name.  */
  const char *name;
  /* Type kind.  */
  enum debug_type_kind kind;
  /* Slot to hold real type when we discover it.  If we don't, we fill
     in an undefined tag type.  */
  debug_type slot;
  /* Indirect type we have created to point at slot.  */
  debug_type type;
};

static char *savestring (const char *, int);
static bfd_vma parse_number (const char **, bfd_boolean *);
static void bad_stab (const char *);
static void warn_stab (const char *, const char *);
static bfd_boolean parse_stab_string
  (void *, struct stab_handle *, int, int, bfd_vma, const char *);
static debug_type parse_stab_type
  (void *, struct stab_handle *, const char *, const char **, debug_type **);
static bfd_boolean parse_stab_type_number (const char **, int *);
static debug_type parse_stab_range_type
  (void *, struct stab_handle *, const char *, const char **, const int *);
static debug_type parse_stab_sun_builtin_type (void *, const char **);
static debug_type parse_stab_sun_floating_type (void *, const char **);
static debug_type parse_stab_enum_type (void *, const char **);
static debug_type parse_stab_struct_type
  (void *, struct stab_handle *, const char *, const char **,
   bfd_boolean, const int *);
static bfd_boolean parse_stab_baseclasses
  (void *, struct stab_handle *, const char **, debug_baseclass **);
static bfd_boolean parse_stab_struct_fields
  (void *, struct stab_handle *, const char **, debug_field **, bfd_boolean *);
static bfd_boolean parse_stab_cpp_abbrev
  (void *, struct stab_handle *, const char **, debug_field *);
static bfd_boolean parse_stab_one_struct_field
  (void *, struct stab_handle *, const char **, const char *,
   debug_field *, bfd_boolean *);
static bfd_boolean parse_stab_members
  (void *, struct stab_handle *, const char *, const char **, const int *,
   debug_method **);
static debug_type parse_stab_argtypes
  (void *, struct stab_handle *, debug_type, const char *, const char *,
   debug_type, const char *, bfd_boolean, bfd_boolean, const char **);
static bfd_boolean parse_stab_tilde_field
  (void *, struct stab_handle *, const char **, const int *, debug_type *,
   bfd_boolean *);
static debug_type parse_stab_array_type
  (void *, struct stab_handle *, const char **, bfd_boolean);
static void push_bincl (struct stab_handle *, const char *, bfd_vma);
static const char *pop_bincl (struct stab_handle *);
static bfd_boolean find_excl (struct stab_handle *, const char *, bfd_vma);
static bfd_boolean stab_record_variable
  (void *, struct stab_handle *, const char *, debug_type,
   enum debug_var_kind, bfd_vma);
static bfd_boolean stab_emit_pending_vars (void *, struct stab_handle *);
static debug_type *stab_find_slot (struct stab_handle *, const int *);
static debug_type stab_find_type (void *, struct stab_handle *, const int *);
static bfd_boolean stab_record_type
  (void *, struct stab_handle *, const int *, debug_type);
static debug_type stab_xcoff_builtin_type
  (void *, struct stab_handle *, int);
static debug_type stab_find_tagged_type
  (void *, struct stab_handle *, const char *, int, enum debug_type_kind);
static debug_type *stab_demangle_argtypes
  (void *, struct stab_handle *, const char *, bfd_boolean *, unsigned int);
static debug_type *stab_demangle_v3_argtypes
  (void *, struct stab_handle *, const char *, bfd_boolean *);
static debug_type stab_demangle_v3_arg
  (void *, struct stab_handle *, struct demangle_component *, debug_type,
   bfd_boolean *);

/* Save a string in memory.  */

static char *
savestring (const char *start, int len)
{
  char *ret;

  ret = (char *) xmalloc (len + 1);
  memcpy (ret, start, len);
  ret[len] = '\0';
  return ret;
}

/* Read a number from a string.  */

static bfd_vma
parse_number (const char **pp, bfd_boolean *poverflow)
{
  unsigned long ul;
  const char *orig;

  if (poverflow != NULL)
    *poverflow = FALSE;

  orig = *pp;

  errno = 0;
  ul = strtoul (*pp, (char **) pp, 0);
  if (ul + 1 != 0 || errno == 0)
    {
      /* If bfd_vma is larger than unsigned long, and the number is
         meant to be negative, we have to make sure that we sign
         extend properly.  */
      if (*orig == '-')
	return (bfd_vma) (bfd_signed_vma) (long) ul;
      return (bfd_vma) ul;
    }

  /* Note that even though strtoul overflowed, it should have set *pp
     to the end of the number, which is where we want it.  */
  if (sizeof (bfd_vma) > sizeof (unsigned long))
    {
      const char *p;
      bfd_boolean neg;
      int base;
      bfd_vma over, lastdig;
      bfd_boolean overflow;
      bfd_vma v;

      /* Our own version of strtoul, for a bfd_vma.  */
      p = orig;

      neg = FALSE;
      if (*p == '+')
	++p;
      else if (*p == '-')
	{
	  neg = TRUE;
	  ++p;
	}

      base = 10;
      if (*p == '0')
	{
	  if (p[1] == 'x' || p[1] == 'X')
	    {
	      base = 16;
	      p += 2;
	    }
	  else
	    {
	      base = 8;
	      ++p;
	    }
	}

      over = ((bfd_vma) (bfd_signed_vma) -1) / (bfd_vma) base;
      lastdig = ((bfd_vma) (bfd_signed_vma) -1) % (bfd_vma) base;

      overflow = FALSE;
      v = 0;
      while (1)
	{
	  int d;

	  d = *p++;
	  if (ISDIGIT (d))
	    d -= '0';
	  else if (ISUPPER (d))
	    d -= 'A';
	  else if (ISLOWER (d))
	    d -= 'a';
	  else
	    break;

	  if (d >= base)
	    break;

	  if (v > over || (v == over && (bfd_vma) d > lastdig))
	    {
	      overflow = TRUE;
	      break;
	    }
	}

      if (! overflow)
	{
	  if (neg)
	    v = - v;
	  return v;
	}
    }

  /* If we get here, the number is too large to represent in a
     bfd_vma.  */
  if (poverflow != NULL)
    *poverflow = TRUE;
  else
    warn_stab (orig, _("numeric overflow"));

  return 0;
}

/* Give an error for a bad stab string.  */

static void
bad_stab (const char *p)
{
  fprintf (stderr, _("Bad stab: %s\n"), p);
}

/* Warn about something in a stab string.  */

static void
warn_stab (const char *p, const char *err)
{
  fprintf (stderr, _("Warning: %s: %s\n"), err, p);
}

/* Create a handle to parse stabs symbols with.  */

void *
start_stab (void *dhandle ATTRIBUTE_UNUSED, bfd *abfd, bfd_boolean sections,
	    asymbol **syms, long symcount)
{
  struct stab_handle *ret;

  ret = (struct stab_handle *) xmalloc (sizeof *ret);
  memset (ret, 0, sizeof *ret);
  ret->abfd = abfd;
  ret->sections = sections;
  ret->syms = syms;
  ret->symcount = symcount;
  ret->files = 1;
  ret->file_types = (struct stab_types **) xmalloc (sizeof *ret->file_types);
  ret->file_types[0] = NULL;
  ret->function_end = (bfd_vma) -1;
  return (void *) ret;
}

/* When we have processed all the stabs information, we need to go
   through and fill in all the undefined tags.  */

bfd_boolean
finish_stab (void *dhandle, void *handle)
{
  struct stab_handle *info = (struct stab_handle *) handle;
  struct stab_tag *st;

  if (info->within_function)
    {
      if (! stab_emit_pending_vars (dhandle, info)
	  || ! debug_end_function (dhandle, info->function_end))
	return FALSE;
      info->within_function = FALSE;
      info->function_end = (bfd_vma) -1;
    }

  for (st = info->tags; st != NULL; st = st->next)
    {
      enum debug_type_kind kind;

      kind = st->kind;
      if (kind == DEBUG_KIND_ILLEGAL)
	kind = DEBUG_KIND_STRUCT;
      st->slot = debug_make_undefined_tagged_type (dhandle, st->name, kind);
      if (st->slot == DEBUG_TYPE_NULL)
	return FALSE;
    }

  return TRUE;
}

/* Handle a single stabs symbol.  */

bfd_boolean
parse_stab (void *dhandle, void *handle, int type, int desc, bfd_vma value,
	    const char *string)
{
  struct stab_handle *info = (struct stab_handle *) handle;

  /* gcc will emit two N_SO strings per compilation unit, one for the
     directory name and one for the file name.  We just collect N_SO
     strings as we see them, and start the new compilation unit when
     we see a non N_SO symbol.  */
  if (info->so_string != NULL
      && (type != N_SO || *string == '\0' || value != info->so_value))
    {
      if (! debug_set_filename (dhandle, info->so_string))
	return FALSE;
      info->main_filename = info->so_string;

      info->gcc_compiled = 0;
      info->n_opt_found = FALSE;

      /* Generally, for stabs in the symbol table, the N_LBRAC and
	 N_RBRAC symbols are relative to the N_SO symbol value.  */
      if (! info->sections)
	info->file_start_offset = info->so_value;

      /* We need to reset the mapping from type numbers to types.  We
	 can't free the old mapping, because of the use of
	 debug_make_indirect_type.  */
      info->files = 1;
      info->file_types = ((struct stab_types **)
			  xmalloc (sizeof *info->file_types));
      info->file_types[0] = NULL;

      info->so_string = NULL;

      /* Now process whatever type we just got.  */
    }

  switch (type)
    {
    case N_FN:
    case N_FN_SEQ:
      break;

    case N_LBRAC:
      /* Ignore extra outermost context from SunPRO cc and acc.  */
      if (info->n_opt_found && desc == 1)
	break;

      if (! info->within_function)
	{
	  fprintf (stderr, _("N_LBRAC not within function\n"));
	  return FALSE;
	}

      /* Start an inner lexical block.  */
      if (! debug_start_block (dhandle,
			       (value
				+ info->file_start_offset
				+ info->function_start_offset)))
	return FALSE;

      /* Emit any pending variable definitions.  */
      if (! stab_emit_pending_vars (dhandle, info))
	return FALSE;

      ++info->block_depth;
      break;

    case N_RBRAC:
      /* Ignore extra outermost context from SunPRO cc and acc.  */
      if (info->n_opt_found && desc == 1)
	break;

      /* We shouldn't have any pending variable definitions here, but,
         if we do, we probably need to emit them before closing the
         block.  */
      if (! stab_emit_pending_vars (dhandle, info))
	return FALSE;

      /* End an inner lexical block.  */
      if (! debug_end_block (dhandle,
			     (value
			      + info->file_start_offset
			      + info->function_start_offset)))
	return FALSE;

      --info->block_depth;
      if (info->block_depth < 0)
	{
	  fprintf (stderr, _("Too many N_RBRACs\n"));
	  return FALSE;
	}
      break;

    case N_SO:
      /* This always ends a function.  */
      if (info->within_function)
	{
	  bfd_vma endval;

	  endval = value;
	  if (*string != '\0'
	      && info->function_end != (bfd_vma) -1
	      && info->function_end < endval)
	    endval = info->function_end;
	  if (! stab_emit_pending_vars (dhandle, info)
	      || ! debug_end_function (dhandle, endval))
	    return FALSE;
	  info->within_function = FALSE;
	  info->function_end = (bfd_vma) -1;
	}

      /* An empty string is emitted by gcc at the end of a compilation
         unit.  */
      if (*string == '\0')
	return TRUE;

      /* Just accumulate strings until we see a non N_SO symbol.  If
         the string starts with a directory separator or some other
	 form of absolute path specification, we discard the previously
         accumulated strings.  */
      if (info->so_string == NULL)
	info->so_string = xstrdup (string);
      else
	{
	  char *f;

	  f = info->so_string;

	  if (IS_ABSOLUTE_PATH (string))
	    info->so_string = xstrdup (string);
	  else
	    info->so_string = concat (info->so_string, string,
				      (const char *) NULL);
	  free (f);
	}

      info->so_value = value;

      break;

    case N_SOL:
      /* Start an include file.  */
      if (! debug_start_source (dhandle, string))
	return FALSE;
      break;

    case N_BINCL:
      /* Start an include file which may be replaced.  */
      push_bincl (info, string, value);
      if (! debug_start_source (dhandle, string))
	return FALSE;
      break;

    case N_EINCL:
      /* End an N_BINCL include.  */
      if (! debug_start_source (dhandle, pop_bincl (info)))
	return FALSE;
      break;

    case N_EXCL:
      /* This is a duplicate of a header file named by N_BINCL which
         was eliminated by the linker.  */
      if (! find_excl (info, string, value))
	return FALSE;
      break;

    case N_SLINE:
      if (! debug_record_line (dhandle, desc,
			       value + (info->within_function
					? info->function_start_offset : 0)))
	return FALSE;
      break;

    case N_BCOMM:
      if (! debug_start_common_block (dhandle, string))
	return FALSE;
      break;

    case N_ECOMM:
      if (! debug_end_common_block (dhandle, string))
	return FALSE;
      break;

    case N_FUN:
      if (*string == '\0')
	{
	  if (info->within_function)
	    {
	      /* This always marks the end of a function; we don't
                 need to worry about info->function_end.  */
	      if (info->sections)
		value += info->function_start_offset;
	      if (! stab_emit_pending_vars (dhandle, info)
		  || ! debug_end_function (dhandle, value))
		return FALSE;
	      info->within_function = FALSE;
	      info->function_end = (bfd_vma) -1;
	    }
	  break;
	}

      /* A const static symbol in the .text section will have an N_FUN
         entry.  We need to use these to mark the end of the function,
         in case we are looking at gcc output before it was changed to
         always emit an empty N_FUN.  We can't call debug_end_function
         here, because it might be a local static symbol.  */
      if (info->within_function
	  && (info->function_end == (bfd_vma) -1
	      || value < info->function_end))
	info->function_end = value;

      /* Fall through.  */
      /* FIXME: gdb checks the string for N_STSYM, N_LCSYM or N_ROSYM
         symbols, and if it does not start with :S, gdb relocates the
         value to the start of the section.  gcc always seems to use
         :S, so we don't worry about this.  */
      /* Fall through.  */
    default:
      {
	const char *colon;

	colon = strchr (string, ':');
	if (colon != NULL
	    && (colon[1] == 'f' || colon[1] == 'F'))
	  {
	    if (info->within_function)
	      {
		bfd_vma endval;

		endval = value;
		if (info->function_end != (bfd_vma) -1
		    && info->function_end < endval)
		  endval = info->function_end;
		if (! stab_emit_pending_vars (dhandle, info)
		    || ! debug_end_function (dhandle, endval))
		  return FALSE;
		info->function_end = (bfd_vma) -1;
	      }
	    /* For stabs in sections, line numbers and block addresses
               are offsets from the start of the function.  */
	    if (info->sections)
	      info->function_start_offset = value;
	    info->within_function = TRUE;
	  }

	if (! parse_stab_string (dhandle, info, type, desc, value, string))
	  return FALSE;
      }
      break;

    case N_OPT:
      if (string != NULL && strcmp (string, "gcc2_compiled.") == 0)
	info->gcc_compiled = 2;
      else if (string != NULL && strcmp (string, "gcc_compiled.") == 0)
	info->gcc_compiled = 1;
      else
	info->n_opt_found = TRUE;
      break;

    case N_OBJ:
    case N_ENDM:
    case N_MAIN:
    case N_WARNING:
      break;
    }

  return TRUE;
}

/* Parse the stabs string.  */

static bfd_boolean
parse_stab_string (void *dhandle, struct stab_handle *info, int stabtype,
		   int desc, bfd_vma value, const char *string)
{
  const char *p;
  char *name;
  int type;
  debug_type dtype;
  bfd_boolean synonym;
  bfd_boolean self_crossref;
  unsigned int lineno;
  debug_type *slot;

  p = strchr (string, ':');
  if (p == NULL)
    return TRUE;

  while (p[1] == ':')
    {
      p += 2;
      p = strchr (p, ':');
      if (p == NULL)
	{
	  bad_stab (string);
	  return FALSE;
	}
    }

  /* GCC 2.x puts the line number in desc.  SunOS apparently puts in
     the number of bytes occupied by a type or object, which we
     ignore.  */
  if (info->gcc_compiled >= 2)
    lineno = desc;
  else
    lineno = 0;

  /* FIXME: Sometimes the special C++ names start with '.'.  */
  name = NULL;
  if (string[0] == '$')
    {
      switch (string[1])
	{
	case 't':
	  name = "this";
	  break;
	case 'v':
	  /* Was: name = "vptr"; */
	  break;
	case 'e':
	  name = "eh_throw";
	  break;
	case '_':
	  /* This was an anonymous type that was never fixed up.  */
	  break;
	case 'X':
	  /* SunPRO (3.0 at least) static variable encoding.  */
	  break;
	default:
	  warn_stab (string, _("unknown C++ encoded name"));
	  break;
	}
    }

  if (name == NULL)
    {
      if (p == string || (string[0] == ' ' && p == string + 1))
	name = NULL;
      else
	name = savestring (string, p - string);
    }

  ++p;
  if (ISDIGIT (*p) || *p == '(' || *p == '-')
    type = 'l';
  else
    type = *p++;

  switch (type)
    {
    case 'c':
      /* c is a special case, not followed by a type-number.
	 SYMBOL:c=iVALUE for an integer constant symbol.
	 SYMBOL:c=rVALUE for a floating constant symbol.
	 SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.
	 e.g. "b:c=e6,0" for "const b = blob1"
	 (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
      if (*p != '=')
	{
	  bad_stab (string);
	  return FALSE;
	}
      ++p;
      switch (*p++)
	{
	case 'r':
	  /* Floating point constant.  */
	  if (! debug_record_float_const (dhandle, name, atof (p)))
	    return FALSE;
	  break;
	case 'i':
	  /* Integer constant.  */
	  /* Defining integer constants this way is kind of silly,
	     since 'e' constants allows the compiler to give not only
	     the value, but the type as well.  C has at least int,
	     long, unsigned int, and long long as constant types;
	     other languages probably should have at least unsigned as
	     well as signed constants.  */
	  if (! debug_record_int_const (dhandle, name, atoi (p)))
	    return FALSE;
	  break;
	case 'e':
	  /* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value
	     can be represented as integral.
	     e.g. "b:c=e6,0" for "const b = blob1"
	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
	  dtype = parse_stab_type (dhandle, info, (const char *) NULL,
				   &p, (debug_type **) NULL);
	  if (dtype == DEBUG_TYPE_NULL)
	    return FALSE;
	  if (*p != ',')
	    {
	      bad_stab (string);
	      return FALSE;
	    }
	  if (! debug_record_typed_const (dhandle, name, dtype, atoi (p)))
	    return FALSE;
	  break;
	default:
	  bad_stab (string);
	  return FALSE;
	}

      break;

    case 'C':
      /* The name of a caught exception.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL,
			       &p, (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_label (dhandle, name, dtype, value))
	return FALSE;
      break;

    case 'f':
    case 'F':
      /* A function definition.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_function (dhandle, name, dtype, type == 'F', value))
	return FALSE;

      /* Sun acc puts declared types of arguments here.  We don't care
	 about their actual types (FIXME -- we should remember the whole
	 function prototype), but the list may define some new types
	 that we have to remember, so we must scan it now.  */
      while (*p == ';')
	{
	  ++p;
	  if (parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL)
	      == DEBUG_TYPE_NULL)
	    return FALSE;
	}

      break;

    case 'G':
      {
	char leading;
	long c;
	asymbol **ps;

	/* A global symbol.  The value must be extracted from the
	   symbol table.  */
	dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
				 (debug_type **) NULL);
	if (dtype == DEBUG_TYPE_NULL)
	  return FALSE;
	leading = bfd_get_symbol_leading_char (info->abfd);
	for (c = info->symcount, ps = info->syms; c > 0; --c, ++ps)
	  {
	    const char *n;

	    n = bfd_asymbol_name (*ps);
	    if (leading != '\0' && *n == leading)
	      ++n;
	    if (*n == *name && strcmp (n, name) == 0)
	      break;
	  }
	if (c > 0)
	  value = bfd_asymbol_value (*ps);
	if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_GLOBAL,
				    value))
	  return FALSE;
      }
      break;

      /* This case is faked by a conditional above, when there is no
	 code letter in the dbx data.  Dbx data never actually
	 contains 'l'.  */
    case 'l':
    case 's':
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL,
				  value))
	return FALSE;
      break;

    case 'p':
      /* A function parameter.  */
      if (*p != 'F')
	dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
				 (debug_type **) NULL);
      else
	{
	/* pF is a two-letter code that means a function parameter in
	   Fortran.  The type-number specifies the type of the return
	   value.  Translate it into a pointer-to-function type.  */
	  ++p;
	  dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
				   (debug_type **) NULL);
	  if (dtype != DEBUG_TYPE_NULL)
	    {
	      debug_type ftype;

	      ftype = debug_make_function_type (dhandle, dtype,
						(debug_type *) NULL, FALSE);
	      dtype = debug_make_pointer_type (dhandle, ftype);
	    }
	}
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_STACK,
				    value))
	return FALSE;

      /* FIXME: At this point gdb considers rearranging the parameter
	 address on a big endian machine if it is smaller than an int.
	 We have no way to do that, since we don't really know much
	 about the target.  */
      break;

    case 'P':
      if (stabtype == N_FUN)
	{
	  /* Prototype of a function referenced by this file.  */
	  while (*p == ';')
	    {
	      ++p;
	      if (parse_stab_type (dhandle, info, (const char *) NULL, &p,
				   (debug_type **) NULL)
		  == DEBUG_TYPE_NULL)
		return FALSE;
	    }
	  break;
	}
      /* Fall through.  */
    case 'R':
      /* Parameter which is in a register.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REG,
				    value))
	return FALSE;
      break;

    case 'r':
      /* Register variable (either global or local).  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_REGISTER,
				  value))
	return FALSE;

      /* FIXME: At this point gdb checks to combine pairs of 'p' and
	 'r' stabs into a single 'P' stab.  */
      break;

    case 'S':
      /* Static symbol at top level of file.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_STATIC,
				  value))
	return FALSE;
      break;

    case 't':
      /* A typedef.  */
      dtype = parse_stab_type (dhandle, info, name, &p, &slot);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (name == NULL)
	{
	  /* A nameless type.  Nothing to do.  */
	  return TRUE;
	}

      dtype = debug_name_type (dhandle, name, dtype);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;

      if (slot != NULL)
	*slot = dtype;

      break;

    case 'T':
      /* Struct, union, or enum tag.  For GNU C++, this can be be followed
	 by 't' which means we are typedef'ing it as well.  */
      if (*p != 't')
	{
	  synonym = FALSE;
	  /* FIXME: gdb sets synonym to TRUE if the current language
             is C++.  */
	}
      else
	{
	  synonym = TRUE;
	  ++p;
	}

      dtype = parse_stab_type (dhandle, info, name, &p, &slot);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (name == NULL)
	return TRUE;

      /* INFO->SELF_CROSSREF is set by parse_stab_type if this type is
         a cross reference to itself.  These are generated by some
         versions of g++.  */
      self_crossref = info->self_crossref;

      dtype = debug_tag_type (dhandle, name, dtype);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (slot != NULL)
	*slot = dtype;

      /* See if we have a cross reference to this tag which we can now
         fill in.  Avoid filling in a cross reference to ourselves,
         because that would lead to circular debugging information.  */
      if (! self_crossref)
	{
	  register struct stab_tag **pst;

	  for (pst = &info->tags; *pst != NULL; pst = &(*pst)->next)
	    {
	      if ((*pst)->name[0] == name[0]
		  && strcmp ((*pst)->name, name) == 0)
		{
		  (*pst)->slot = dtype;
		  *pst = (*pst)->next;
		  break;
		}
	    }
	}

      if (synonym)
	{
	  dtype = debug_name_type (dhandle, name, dtype);
	  if (dtype == DEBUG_TYPE_NULL)
	    return FALSE;

	  if (slot != NULL)
	    *slot = dtype;
	}

      break;

    case 'V':
      /* Static symbol of local scope */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      /* FIXME: gdb checks os9k_stabs here.  */
      if (! stab_record_variable (dhandle, info, name, dtype,
				  DEBUG_LOCAL_STATIC, value))
	return FALSE;
      break;

    case 'v':
      /* Reference parameter.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REFERENCE,
				    value))
	return FALSE;
      break;

    case 'a':
      /* Reference parameter which is in a register.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REF_REG,
				    value))
	return FALSE;
      break;

    case 'X':
      /* This is used by Sun FORTRAN for "function result value".
	 Sun claims ("dbx and dbxtool interfaces", 2nd ed)
	 that Pascal uses it too, but when I tried it Pascal used
	 "x:3" (local symbol) instead.  */
      dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
			       (debug_type **) NULL);
      if (dtype == DEBUG_TYPE_NULL)
	return FALSE;
      if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL,
				  value))
	return FALSE;
      break;

    default:
      bad_stab (string);
      return FALSE;
    }

  /* FIXME: gdb converts structure values to structure pointers in a
     couple of cases, depending upon the target.  */

  return TRUE;
}

/* Parse a stabs type.  The typename argument is non-NULL if this is a
   typedef or a tag definition.  The pp argument points to the stab
   string, and is updated.  The slotp argument points to a place to
   store the slot used if the type is being defined.  */

static debug_type
parse_stab_type (void *dhandle, struct stab_handle *info, const char *typename, const char **pp, debug_type **slotp)
{
  const char *orig;
  int typenums[2];
  int size;
  bfd_boolean stringp;
  int descriptor;
  debug_type dtype;

  if (slotp != NULL)
    *slotp = NULL;

  orig = *pp;

  size = -1;
  stringp = FALSE;

  info->self_crossref = FALSE;

  /* Read type number if present.  The type number may be omitted.
     for instance in a two-dimensional array declared with type
     "ar1;1;10;ar1;1;10;4".  */
  if (! ISDIGIT (**pp) && **pp != '(' && **pp != '-')
    {
      /* 'typenums=' not present, type is anonymous.  Read and return
	 the definition, but don't put it in the type vector.  */
      typenums[0] = typenums[1] = -1;
    }
  else
    {
      if (! parse_stab_type_number (pp, typenums))
	return DEBUG_TYPE_NULL;

      if (**pp != '=')
	/* Type is not being defined here.  Either it already
	   exists, or this is a forward reference to it.  */
	return stab_find_type (dhandle, info, typenums);

      /* Only set the slot if the type is being defined.  This means
         that the mapping from type numbers to types will only record
         the name of the typedef which defines a type.  If we don't do
         this, then something like
	     typedef int foo;
	     int i;
	 will record that i is of type foo.  Unfortunately, stabs
	 information is ambiguous about variable types.  For this code,
	     typedef int foo;
	     int i;
	     foo j;
	 the stabs information records both i and j as having the same
	 type.  This could be fixed by patching the compiler.  */
      if (slotp != NULL && typenums[0] >= 0 && typenums[1] >= 0)
	*slotp = stab_find_slot (info, typenums);

      /* Type is being defined here.  */
      /* Skip the '='.  */
      ++*pp;

      while (**pp == '@@')
	{
	  const char *p = *pp + 1;
	  const char *attr;

	  if (ISDIGIT (*p) || *p == '(' || *p == '-')
	    /* Member type.  */
	    break;

	  /* Type attributes.  */
	  attr = p;

	  for (; *p != ';'; ++p)
	    {
	      if (*p == '\0')
		{
		  bad_stab (orig);
		  return DEBUG_TYPE_NULL;
		}
	    }
	  *pp = p + 1;

	  switch (*attr)
	    {
	    case 's':
	      size = atoi (attr + 1);
	      size /= 8;  /* Size is in bits.  We store it in bytes.  */
	      if (size <= 0)
		size = -1;
	      break;

	    case 'S':
	      stringp = TRUE;
	      break;

	    default:
	      /* Ignore unrecognized type attributes, so future
		 compilers can invent new ones.  */
	      break;
	    }
	}
    }

  descriptor = **pp;
  ++*pp;

  switch (descriptor)
    {
    case 'x':
      {
	enum debug_type_kind code;
	const char *q1, *q2, *p;

	/* A cross reference to another type.  */
	switch (**pp)
	  {
	  case 's':
	    code = DEBUG_KIND_STRUCT;
	    break;
	  case 'u':
	    code = DEBUG_KIND_UNION;
	    break;
	  case 'e':
	    code = DEBUG_KIND_ENUM;
	    break;
	  default:
	    /* Complain and keep going, so compilers can invent new
	       cross-reference types.  */
	    warn_stab (orig, _("unrecognized cross reference type"));
	    code = DEBUG_KIND_STRUCT;
	    break;
	  }
	++*pp;

	q1 = strchr (*pp, '<');
	p = strchr (*pp, ':');
	if (p == NULL)
	  {
	    bad_stab (orig);
	    return DEBUG_TYPE_NULL;
	  }
	if (q1 != NULL && p > q1 && p[1] == ':')
	  {
	    int nest = 0;

	    for (q2 = q1; *q2 != '\0'; ++q2)
	      {
		if (*q2 == '<')
		  ++nest;
		else if (*q2 == '>')
		  --nest;
		else if (*q2 == ':' && nest == 0)
		  break;
	      }
	    p = q2;
	    if (*p != ':')
	      {
		bad_stab (orig);
		return DEBUG_TYPE_NULL;
	      }
	  }

	/* Some versions of g++ can emit stabs like
	       fleep:T20=xsfleep:
	   which define structures in terms of themselves.  We need to
	   tell the caller to avoid building a circular structure.  */
	if (typename != NULL
	    && strncmp (typename, *pp, p - *pp) == 0
	    && typename[p - *pp] == '\0')
	  info->self_crossref = TRUE;

	dtype = stab_find_tagged_type (dhandle, info, *pp, p - *pp, code);

	*pp = p + 1;
      }
      break;

    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '(':
      {
	const char *hold;
	int xtypenums[2];

	/* This type is defined as another type.  */
	(*pp)--;
	hold = *pp;

	/* Peek ahead at the number to detect void.  */
	if (! parse_stab_type_number (pp, xtypenums))
	  return DEBUG_TYPE_NULL;

	if (typenums[0] == xtypenums[0] && typenums[1] == xtypenums[1])
	  {
	    /* This type is being defined as itself, which means that
               it is void.  */
	    dtype = debug_make_void_type (dhandle);
	  }
	else
	  {
	    *pp = hold;

	    /* Go back to the number and have parse_stab_type get it.
	       This means that we can deal with something like
	       t(1,2)=(3,4)=... which the Lucid compiler uses.  */
	    dtype = parse_stab_type (dhandle, info, (const char *) NULL,
				     pp, (debug_type **) NULL);
	    if (dtype == DEBUG_TYPE_NULL)
	      return DEBUG_TYPE_NULL;
	  }

	if (typenums[0] != -1)
	  {
	    if (! stab_record_type (dhandle, info, typenums, dtype))
	      return DEBUG_TYPE_NULL;
	  }

	break;
      }

    case '*':
      dtype = debug_make_pointer_type (dhandle,
				       parse_stab_type (dhandle, info,
							(const char *) NULL,
							pp,
							(debug_type **) NULL));
      break;

    case '&':
      /* Reference to another type.  */
      dtype = (debug_make_reference_type
	       (dhandle,
		parse_stab_type (dhandle, info, (const char *) NULL, pp,
				 (debug_type **) NULL)));
      break;

    case 'f':
      /* Function returning another type.  */
      /* FIXME: gdb checks os9k_stabs here.  */
      dtype = (debug_make_function_type
	       (dhandle,
		parse_stab_type (dhandle, info, (const char *) NULL, pp,
				 (debug_type **) NULL),
		(debug_type *) NULL, FALSE));
      break;

    case 'k':
      /* Const qualifier on some type (Sun).  */
      /* FIXME: gdb accepts 'c' here if os9k_stabs.  */
      dtype = debug_make_const_type (dhandle,
				     parse_stab_type (dhandle, info,
						      (const char *) NULL,
						      pp,
						      (debug_type **) NULL));
      break;

    case 'B':
      /* Volatile qual on some type (Sun).  */
      /* FIXME: gdb accepts 'i' here if os9k_stabs.  */
      dtype = (debug_make_volatile_type
	       (dhandle,
		parse_stab_type (dhandle, info, (const char *) NULL, pp,
				 (debug_type **) NULL)));
      break;

    case '@@':
      /* Offset (class & variable) type.  This is used for a pointer
         relative to an object.  */
      {
	debug_type domain;
	debug_type memtype;

	/* Member type.  */

	domain = parse_stab_type (dhandle, info, (const char *) NULL, pp,
				  (debug_type **) NULL);
	if (domain == DEBUG_TYPE_NULL)
	  return DEBUG_TYPE_NULL;

	if (**pp != ',')
	  {
	    bad_stab (orig);
	    return DEBUG_TYPE_NULL;
	  }
	++*pp;

	memtype = parse_stab_type (dhandle, info, (const char *) NULL, pp,
				   (debug_type **) NULL);
	if (memtype == DEBUG_TYPE_NULL)
	  return DEBUG_TYPE_NULL;

	dtype = debug_make_offset_type (dhandle, domain, memtype);
      }
      break;

    case '#':
      /* Method (class & fn) type.  */
      if (**pp == '#')
	{
	  debug_type return_type;

	  ++*pp;
	  return_type = parse_stab_type (dhandle, info, (const char *) NULL,
					 pp, (debug_type **) NULL);
	  if (return_type == DEBUG_TYPE_NULL)
	    return DEBUG_TYPE_NULL;
	  if (**pp != ';')
	    {
	      bad_stab (orig);
	      return DEBUG_TYPE_NULL;
	    }
	  ++*pp;
	  dtype = debug_make_method_type (dhandle, return_type,
					  DEBUG_TYPE_NULL,
					  (debug_type *) NULL, FALSE);
	}
      else
	{
	  debug_type domain;
	  debug_type return_type;
	  debug_type *args;
	  unsigned int n;
	  unsigned int alloc;
	  bfd_boolean varargs;

	  domain = parse_stab_type (dhandle, info, (const char *) NULL,
				    pp, (debug_type **) NULL);
	  if (domain == DEBUG_TYPE_NULL)
	    return DEBUG_TYPE_NULL;

	  if (**pp != ',')
	    {
	      bad_stab (orig);
	      return DEBUG_TYPE_NULL;
	    }
	  ++*pp;

	  return_type = parse_stab_type (dhandle, info, (const char *) NULL,
					 pp, (debug_type **) NULL);
	  if (return_type == DEBUG_TYPE_NULL)
	    return DEBUG_TYPE_NULL;

	  alloc = 10;
	  args = (debug_type *) xmalloc (alloc * sizeof *args);
	  n = 0;
	  while (**pp != ';')
	    {
	      if (**pp != ',')
		{
		  bad_stab (orig);
		  return DEBUG_TYPE_NULL;
		}
	      ++*pp;

	      if (n + 1 >= alloc)
		{
		  alloc += 10;
		  args = ((debug_type *)
			  xrealloc (args, alloc * sizeof *args));
		}

	      args[n] = parse_stab_type (dhandle, info, (const char *) NULL,
					 pp, (debug_type **) NULL);
	      if (args[n] == DEBUG_TYPE_NULL)
		return DEBUG_TYPE_NULL;
	      ++n;
	    }
	  ++*pp;

	  /* If the last type is not void, then this function takes a
	     variable number of arguments.  Otherwise, we must strip
	     the void type.  */
	  if (n == 0
	      || debug_get_type_kind (dhandle, args[n - 1]) != DEBUG_KIND_VOID)
	    varargs = TRUE;
	  else
	    {
	      --n;
	      varargs = FALSE;
	    }

	  args[n] = DEBUG_TYPE_NULL;

	  dtype = debug_make_method_type (dhandle, return_type, domain, args,
					  varargs);
	}
      break;

    case 'r':
      /* Range type.  */
      dtype = parse_stab_range_type (dhandle, info, typename, pp, typenums);
      break;

    case 'b':
      /* FIXME: gdb checks os9k_stabs here.  */
      /* Sun ACC builtin int type.  */
      dtype = parse_stab_sun_builtin_type (dhandle, pp);
      break;

    case 'R':
      /* Sun ACC builtin float type.  */
      dtype = parse_stab_sun_floating_type (dhandle, pp);
      break;

    case 'e':
      /* Enumeration type.  */
      dtype = parse_stab_enum_type (dhandle, pp);
      break;

    case 's':
    case 'u':
      /* Struct or union type.  */
      dtype = parse_stab_struct_type (dhandle, info, typename, pp,
				      descriptor == 's', typenums);
      break;

    case 'a':
      /* Array type.  */
      if (**pp != 'r')
	{
	  bad_stab (orig);
	  return DEBUG_TYPE_NULL;
	}
      ++*pp;

      dtype = parse_stab_array_type (dhandle, info, pp, stringp);
      break;

    case 'S':
      dtype = debug_make_set_type (dhandle,
				   parse_stab_type (dhandle, info,
						    (const char *) NULL,
						    pp,
						    (debug_type **) NULL),
				   stringp);
      break;

    default:
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  if (dtype == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (typenums[0] != -1)
    {
      if (! stab_record_type (dhandle, info, typenums, dtype))
	return DEBUG_TYPE_NULL;
    }

  if (size != -1)
    {
      if (! debug_record_type_size (dhandle, dtype, (unsigned int) size))
	return DEBUG_TYPE_NULL;
    }

  return dtype;
}

/* Read a number by which a type is referred to in dbx data, or
   perhaps read a pair (FILENUM, TYPENUM) in parentheses.  Just a
   single number N is equivalent to (0,N).  Return the two numbers by
   storing them in the vector TYPENUMS.  */

static bfd_boolean
parse_stab_type_number (const char **pp, int *typenums)
{
  const char *orig;

  orig = *pp;

  if (**pp != '(')
    {
      typenums[0] = 0;
      typenums[1] = (int) parse_number (pp, (bfd_boolean *) NULL);
    }
  else
    {
      ++*pp;
      typenums[0] = (int) parse_number (pp, (bfd_boolean *) NULL);
      if (**pp != ',')
	{
	  bad_stab (orig);
	  return FALSE;
	}
      ++*pp;
      typenums[1] = (int) parse_number (pp, (bfd_boolean *) NULL);
      if (**pp != ')')
	{
	  bad_stab (orig);
	  return FALSE;
	}
      ++*pp;
    }

  return TRUE;
}

/* Parse a range type.  */

static debug_type
parse_stab_range_type (void *dhandle, struct stab_handle *info, const char *typename, const char **pp, const int *typenums)
{
  const char *orig;
  int rangenums[2];
  bfd_boolean self_subrange;
  debug_type index_type;
  const char *s2, *s3;
  bfd_signed_vma n2, n3;
  bfd_boolean ov2, ov3;

  orig = *pp;

  index_type = DEBUG_TYPE_NULL;

  /* First comes a type we are a subrange of.
     In C it is usually 0, 1 or the type being defined.  */
  if (! parse_stab_type_number (pp, rangenums))
    return DEBUG_TYPE_NULL;

  self_subrange = (rangenums[0] == typenums[0]
		   && rangenums[1] == typenums[1]);

  if (**pp == '=')
    {
      *pp = orig;
      index_type = parse_stab_type (dhandle, info, (const char *) NULL,
				    pp, (debug_type **) NULL);
      if (index_type == DEBUG_TYPE_NULL)
	return DEBUG_TYPE_NULL;
    }

  if (**pp == ';')
    ++*pp;

  /* The remaining two operands are usually lower and upper bounds of
     the range.  But in some special cases they mean something else.  */
  s2 = *pp;
  n2 = parse_number (pp, &ov2);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  s3 = *pp;
  n3 = parse_number (pp, &ov3);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  if (ov2 || ov3)
    {
      /* gcc will emit range stabs for long long types.  Handle this
         as a special case.  FIXME: This needs to be more general.  */
#define LLLOW   "01000000000000000000000;"
#define LLHIGH   "0777777777777777777777;"
#define ULLHIGH "01777777777777777777777;"
      if (index_type == DEBUG_TYPE_NULL)
	{
	  if (strncmp (s2, LLLOW, sizeof LLLOW - 1) == 0
	      && strncmp (s3, LLHIGH, sizeof LLHIGH - 1) == 0)
	    return debug_make_int_type (dhandle, 8, FALSE);
	  if (! ov2
	      && n2 == 0
	      && strncmp (s3, ULLHIGH, sizeof ULLHIGH - 1) == 0)
	    return debug_make_int_type (dhandle, 8, TRUE);
	}

      warn_stab (orig, _("numeric overflow"));
    }

  if (index_type == DEBUG_TYPE_NULL)
    {
      /* A type defined as a subrange of itself, with both bounds 0,
         is void.  */
      if (self_subrange && n2 == 0 && n3 == 0)
	return debug_make_void_type (dhandle);

      /* A type defined as a subrange of itself, with n2 positive and
	 n3 zero, is a complex type, and n2 is the number of bytes.  */
      if (self_subrange && n3 == 0 && n2 > 0)
	return debug_make_complex_type (dhandle, n2);

      /* If n3 is zero and n2 is positive, this is a floating point
         type, and n2 is the number of bytes.  */
      if (n3 == 0 && n2 > 0)
	return debug_make_float_type (dhandle, n2);

      /* If the upper bound is -1, this is an unsigned int.  */
      if (n2 == 0 && n3 == -1)
	{
	  /* When gcc is used with -gstabs, but not -gstabs+, it will emit
	         long long int:t6=r1;0;-1;
		 long long unsigned int:t7=r1;0;-1;
	     We hack here to handle this reasonably.  */
	  if (typename != NULL)
	    {
	      if (strcmp (typename, "long long int") == 0)
		return debug_make_int_type (dhandle, 8, FALSE);
	      else if (strcmp (typename, "long long unsigned int") == 0)
		return debug_make_int_type (dhandle, 8, TRUE);
	    }
	  /* FIXME: The size here really depends upon the target.  */
	  return debug_make_int_type (dhandle, 4, TRUE);
	}

      /* A range of 0 to 127 is char.  */
      if (self_subrange && n2 == 0 && n3 == 127)
	return debug_make_int_type (dhandle, 1, FALSE);

      /* FIXME: gdb checks for the language CHILL here.  */

      if (n2 == 0)
	{
	  if (n3 < 0)
	    return debug_make_int_type (dhandle, - n3, TRUE);
	  else if (n3 == 0xff)
	    return debug_make_int_type (dhandle, 1, TRUE);
	  else if (n3 == 0xffff)
	    return debug_make_int_type (dhandle, 2, TRUE);
	  else if (n3 == (bfd_signed_vma) 0xffffffff)
	    return debug_make_int_type (dhandle, 4, TRUE);
#ifdef BFD64
	  else if (n3 == ((((bfd_signed_vma) 0xffffffff) << 32) | 0xffffffff))
	    return debug_make_int_type (dhandle, 8, TRUE);
#endif
	}
      else if (n3 == 0
	       && n2 < 0
	       && (self_subrange || n2 == -8))
	return debug_make_int_type (dhandle, - n2, TRUE);
      else if (n2 == - n3 - 1 || n2 == n3 + 1)
	{
	  if (n3 == 0x7f)
	    return debug_make_int_type (dhandle, 1, FALSE);
	  else if (n3 == 0x7fff)
	    return debug_make_int_type (dhandle, 2, FALSE);
	  else if (n3 == 0x7fffffff)
	    return debug_make_int_type (dhandle, 4, FALSE);
#ifdef BFD64
	  else if (n3 == ((((bfd_vma) 0x7fffffff) << 32) | 0xffffffff))
	    return debug_make_int_type (dhandle, 8, FALSE);
#endif
	}
    }

  /* At this point I don't have the faintest idea how to deal with a
     self_subrange type; I'm going to assume that this is used as an
     idiom, and that all of them are special cases.  So . . .  */
  if (self_subrange)
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  index_type = stab_find_type (dhandle, info, rangenums);
  if (index_type == DEBUG_TYPE_NULL)
    {
      /* Does this actually ever happen?  Is that why we are worrying
         about dealing with it rather than just calling error_type?  */
      warn_stab (orig, _("missing index type"));
      index_type = debug_make_int_type (dhandle, 4, FALSE);
    }

  return debug_make_range_type (dhandle, index_type, n2, n3);
}

/* Sun's ACC uses a somewhat saner method for specifying the builtin
   typedefs in every file (for int, long, etc):

	type = b <signed> <width>; <offset>; <nbits>
	signed = u or s.  Possible c in addition to u or s (for char?).
	offset = offset from high order bit to start bit of type.
	width is # bytes in object of this type, nbits is # bits in type.

   The width/offset stuff appears to be for small objects stored in
   larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,
   FIXME.  */

static debug_type
parse_stab_sun_builtin_type (void *dhandle, const char **pp)
{
  const char *orig;
  bfd_boolean unsignedp;
  bfd_vma bits;

  orig = *pp;

  switch (**pp)
    {
    case 's':
      unsignedp = FALSE;
      break;
    case 'u':
      unsignedp = TRUE;
      break;
    default:
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  /* For some odd reason, all forms of char put a c here.  This is strange
     because no other type has this honor.  We can safely ignore this because
     we actually determine 'char'acterness by the number of bits specified in
     the descriptor.  */
  if (**pp == 'c')
    ++*pp;

  /* The first number appears to be the number of bytes occupied
     by this type, except that unsigned short is 4 instead of 2.
     Since this information is redundant with the third number,
     we will ignore it.  */
  (void) parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  /* The second number is always 0, so ignore it too.  */
  (void) parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  /* The third number is the number of bits for this type.  */
  bits = parse_number (pp, (bfd_boolean *) NULL);

  /* The type *should* end with a semicolon.  If it are embedded
     in a larger type the semicolon may be the only way to know where
     the type ends.  If this type is at the end of the stabstring we
     can deal with the omitted semicolon (but we don't have to like
     it).  Don't bother to complain(), Sun's compiler omits the semicolon
     for "void".  */
  if (**pp == ';')
    ++*pp;

  if (bits == 0)
    return debug_make_void_type (dhandle);

  return debug_make_int_type (dhandle, bits / 8, unsignedp);
}

/* Parse a builtin floating type generated by the Sun compiler.  */

static debug_type
parse_stab_sun_floating_type (void *dhandle, const char **pp)
{
  const char *orig;
  bfd_vma details;
  bfd_vma bytes;

  orig = *pp;

  /* The first number has more details about the type, for example
     FN_COMPLEX.  */
  details = parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  /* The second number is the number of bytes occupied by this type */
  bytes = parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }

  if (details == NF_COMPLEX
      || details == NF_COMPLEX16
      || details == NF_COMPLEX32)
    return debug_make_complex_type (dhandle, bytes);

  return debug_make_float_type (dhandle, bytes);
}

/* Handle an enum type.  */

static debug_type
parse_stab_enum_type (void *dhandle, const char **pp)
{
  const char *orig;
  const char **names;
  bfd_signed_vma *values;
  unsigned int n;
  unsigned int alloc;

  orig = *pp;

  /* FIXME: gdb checks os9k_stabs here.  */

  /* The aix4 compiler emits an extra field before the enum members;
     my guess is it's a type of some sort.  Just ignore it.  */
  if (**pp == '-')
    {
      while (**pp != ':')
	++*pp;
      ++*pp;
    }

  /* Read the value-names and their values.
     The input syntax is NAME:VALUE,NAME:VALUE, and so on.
     A semicolon or comma instead of a NAME means the end.  */
  alloc = 10;
  names = (const char **) xmalloc (alloc * sizeof *names);
  values = (bfd_signed_vma *) xmalloc (alloc * sizeof *values);
  n = 0;
  while (**pp != '\0' && **pp != ';' && **pp != ',')
    {
      const char *p;
      char *name;
      bfd_signed_vma val;

      p = *pp;
      while (*p != ':')
	++p;

      name = savestring (*pp, p - *pp);

      *pp = p + 1;
      val = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
      if (**pp != ',')
	{
	  bad_stab (orig);
	  return DEBUG_TYPE_NULL;
	}
      ++*pp;

      if (n + 1 >= alloc)
	{
	  alloc += 10;
	  names = ((const char **)
		   xrealloc (names, alloc * sizeof *names));
	  values = ((bfd_signed_vma *)
		    xrealloc (values, alloc * sizeof *values));
	}

      names[n] = name;
      values[n] = val;
      ++n;
    }

  names[n] = NULL;
  values[n] = 0;

  if (**pp == ';')
    ++*pp;

  return debug_make_enum_type (dhandle, names, values);
}

/* Read the description of a structure (or union type) and return an object
   describing the type.

   PP points to a character pointer that points to the next unconsumed token
   in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
   *PP will point to "4a:1,0,32;;".  */

static debug_type
parse_stab_struct_type (void *dhandle, struct stab_handle *info,
			const char *tagname, const char **pp,
			bfd_boolean structp, const int *typenums)
{
  const char *orig;
  bfd_vma size;
  debug_baseclass *baseclasses;
  debug_field *fields;
  bfd_boolean statics;
  debug_method *methods;
  debug_type vptrbase;
  bfd_boolean ownvptr;

  orig = *pp;

  /* Get the size.  */
  size = parse_number (pp, (bfd_boolean *) NULL);

  /* Get the other information.  */
  if (! parse_stab_baseclasses (dhandle, info, pp, &baseclasses)
      || ! parse_stab_struct_fields (dhandle, info, pp, &fields, &statics)
      || ! parse_stab_members (dhandle, info, tagname, pp, typenums, &methods)
      || ! parse_stab_tilde_field (dhandle, info, pp, typenums, &vptrbase,
				   &ownvptr))
    return DEBUG_TYPE_NULL;

  if (! statics
      && baseclasses == NULL
      && methods == NULL
      && vptrbase == DEBUG_TYPE_NULL
      && ! ownvptr)
    return debug_make_struct_type (dhandle, structp, size, fields);

  return debug_make_object_type (dhandle, structp, size, fields, baseclasses,
				 methods, vptrbase, ownvptr);
}

/* The stabs for C++ derived classes contain baseclass information which
   is marked by a '!' character after the total size.  This function is
   called when we encounter the baseclass marker, and slurps up all the
   baseclass information.

   Immediately following the '!' marker is the number of base classes that
   the class is derived from, followed by information for each base class.
   For each base class, there are two visibility specifiers, a bit offset
   to the base class information within the derived class, a reference to
   the type for the base class, and a terminating semicolon.

   A typical example, with two base classes, would be "!2,020,19;0264,21;".
						       ^^ ^ ^ ^  ^ ^  ^
	Baseclass information marker __________________|| | | |  | |  |
	Number of baseclasses __________________________| | | |  | |  |
	Visibility specifiers (2) ________________________| | |  | |  |
	Offset in bits from start of class _________________| |  | |  |
	Type number for base class ___________________________|  | |  |
	Visibility specifiers (2) _______________________________| |  |
	Offset in bits from start of class ________________________|  |
	Type number of base class ____________________________________|

  Return TRUE for success, FALSE for failure.  */

static bfd_boolean
parse_stab_baseclasses (void *dhandle, struct stab_handle *info,
			const char **pp, debug_baseclass **retp)
{
  const char *orig;
  unsigned int c, i;
  debug_baseclass *classes;

  *retp = NULL;

  orig = *pp;

  if (**pp != '!')
    {
      /* No base classes.  */
      return TRUE;
    }
  ++*pp;

  c = (unsigned int) parse_number (pp, (bfd_boolean *) NULL);

  if (**pp != ',')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  classes = (debug_baseclass *) xmalloc ((c + 1) * sizeof (**retp));

  for (i = 0; i < c; i++)
    {
      bfd_boolean virtual;
      enum debug_visibility visibility;
      bfd_vma bitpos;
      debug_type type;

      switch (**pp)
	{
	case '0':
	  virtual = FALSE;
	  break;
	case '1':
	  virtual = TRUE;
	  break;
	default:
	  warn_stab (orig, _("unknown virtual character for baseclass"));
	  virtual = FALSE;
	  break;
	}
      ++*pp;

      switch (**pp)
	{
	case '0':
	  visibility = DEBUG_VISIBILITY_PRIVATE;
	  break;
	case '1':
	  visibility = DEBUG_VISIBILITY_PROTECTED;
	  break;
	case '2':
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	default:
	  warn_stab (orig, _("unknown visibility character for baseclass"));
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	}
      ++*pp;

      /* The remaining value is the bit offset of the portion of the
	 object corresponding to this baseclass.  Always zero in the
	 absence of multiple inheritance.  */
      bitpos = parse_number (pp, (bfd_boolean *) NULL);
      if (**pp != ',')
	{
	  bad_stab (orig);
	  return FALSE;
	}
      ++*pp;

      type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			      (debug_type **) NULL);
      if (type == DEBUG_TYPE_NULL)
	return FALSE;

      classes[i] = debug_make_baseclass (dhandle, type, bitpos, virtual,
					 visibility);
      if (classes[i] == DEBUG_BASECLASS_NULL)
	return FALSE;

      if (**pp != ';')
	return FALSE;
      ++*pp;
    }

  classes[i] = DEBUG_BASECLASS_NULL;

  *retp = classes;

  return TRUE;
}

/* Read struct or class data fields.  They have the form:

	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;

   At the end, we see a semicolon instead of a field.

   In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for
   a static field.

   The optional VISIBILITY is one of:

	'/0'	(VISIBILITY_PRIVATE)
	'/1'	(VISIBILITY_PROTECTED)
	'/2'	(VISIBILITY_PUBLIC)
	'/9'	(VISIBILITY_IGNORE)

   or nothing, for C style fields with public visibility.

   Returns 1 for success, 0 for failure.  */

static bfd_boolean
parse_stab_struct_fields (void *dhandle, struct stab_handle *info,
			  const char **pp, debug_field **retp,
			  bfd_boolean *staticsp)
{
  const char *orig;
  const char *p;
  debug_field *fields;
  unsigned int c;
  unsigned int alloc;

  *retp = NULL;
  *staticsp = FALSE;

  orig = *pp;

  c = 0;
  alloc = 10;
  fields = (debug_field *) xmalloc (alloc * sizeof *fields);
  while (**pp != ';')
    {
      /* FIXME: gdb checks os9k_stabs here.  */

      p = *pp;

      /* Add 1 to c to leave room for NULL pointer at end.  */
      if (c + 1 >= alloc)
	{
	  alloc += 10;
	  fields = ((debug_field *)
		    xrealloc (fields, alloc * sizeof *fields));
	}

      /* If it starts with CPLUS_MARKER it is a special abbreviation,
	 unless the CPLUS_MARKER is followed by an underscore, in
	 which case it is just the name of an anonymous type, which we
	 should handle like any other type name.  We accept either '$'
	 or '.', because a field name can never contain one of these
	 characters except as a CPLUS_MARKER.  */

      if ((*p == '$' || *p == '.') && p[1] != '_')
	{
	  ++*pp;
	  if (! parse_stab_cpp_abbrev (dhandle, info, pp, fields + c))
	    return FALSE;
	  ++c;
	  continue;
	}

      /* Look for the ':' that separates the field name from the field
	 values.  Data members are delimited by a single ':', while member
	 functions are delimited by a pair of ':'s.  When we hit the member
	 functions (if any), terminate scan loop and return.  */

      p = strchr (p, ':');
      if (p == NULL)
	{
	  bad_stab (orig);
	  return FALSE;
	}

      if (p[1] == ':')
	break;

      if (! parse_stab_one_struct_field (dhandle, info, pp, p, fields + c,
					 staticsp))
	return FALSE;

      ++c;
    }

  fields[c] = DEBUG_FIELD_NULL;

  *retp = fields;

  return TRUE;
}

/* Special GNU C++ name.  */

static bfd_boolean
parse_stab_cpp_abbrev (void *dhandle, struct stab_handle *info,
		       const char **pp, debug_field *retp)
{
  const char *orig;
  int cpp_abbrev;
  debug_type context;
  const char *name;
  const char *typename;
  debug_type type;
  bfd_vma bitpos;

  *retp = DEBUG_FIELD_NULL;

  orig = *pp;

  if (**pp != 'v')
    {
      bad_stab (*pp);
      return FALSE;
    }
  ++*pp;

  cpp_abbrev = **pp;
  ++*pp;

  /* At this point, *pp points to something like "22:23=*22...", where
     the type number before the ':' is the "context" and everything
     after is a regular type definition.  Lookup the type, find it's
     name, and construct the field name.  */

  context = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			     (debug_type **) NULL);
  if (context == DEBUG_TYPE_NULL)
    return FALSE;

  switch (cpp_abbrev)
    {
    case 'f':
      /* $vf -- a virtual function table pointer.  */
      name = "_vptr$";
      break;
    case 'b':
      /* $vb -- a virtual bsomethingorother */
      typename = debug_get_type_name (dhandle, context);
      if (typename == NULL)
	{
	  warn_stab (orig, _("unnamed $vb type"));
	  typename = "FOO";
	}
      name = concat ("_vb$", typename, (const char *) NULL);
      break;
    default:
      warn_stab (orig, _("unrecognized C++ abbreviation"));
      name = "INVALID_CPLUSPLUS_ABBREV";
      break;
    }

  if (**pp != ':')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			  (debug_type **) NULL);
  if (**pp != ',')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  bitpos = parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  *retp = debug_make_field (dhandle, name, type, bitpos, 0,
			    DEBUG_VISIBILITY_PRIVATE);
  if (*retp == DEBUG_FIELD_NULL)
    return FALSE;

  return TRUE;
}

/* Parse a single field in a struct or union.  */

static bfd_boolean
parse_stab_one_struct_field (void *dhandle, struct stab_handle *info,
			     const char **pp, const char *p,
			     debug_field *retp, bfd_boolean *staticsp)
{
  const char *orig;
  char *name;
  enum debug_visibility visibility;
  debug_type type;
  bfd_vma bitpos;
  bfd_vma bitsize;

  orig = *pp;

  /* FIXME: gdb checks ARM_DEMANGLING here.  */

  name = savestring (*pp, p - *pp);

  *pp = p + 1;

  if (**pp != '/')
    visibility = DEBUG_VISIBILITY_PUBLIC;
  else
    {
      ++*pp;
      switch (**pp)
	{
	case '0':
	  visibility = DEBUG_VISIBILITY_PRIVATE;
	  break;
	case '1':
	  visibility = DEBUG_VISIBILITY_PROTECTED;
	  break;
	case '2':
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	default:
	  warn_stab (orig, _("unknown visibility character for field"));
	  visibility = DEBUG_VISIBILITY_PUBLIC;
	  break;
	}
      ++*pp;
    }

  type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			  (debug_type **) NULL);
  if (type == DEBUG_TYPE_NULL)
    return FALSE;

  if (**pp == ':')
    {
      char *varname;

      /* This is a static class member.  */
      ++*pp;
      p = strchr (*pp, ';');
      if (p == NULL)
	{
	  bad_stab (orig);
	  return FALSE;
	}

      varname = savestring (*pp, p - *pp);

      *pp = p + 1;

      *retp = debug_make_static_member (dhandle, name, type, varname,
					visibility);
      *staticsp = TRUE;

      return TRUE;
    }

  if (**pp != ',')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  bitpos = parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ',')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  bitsize = parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return FALSE;
    }
  ++*pp;

  if (bitpos == 0 && bitsize == 0)
    {
      /* This can happen in two cases: (1) at least for gcc 2.4.5 or
	 so, it is a field which has been optimized out.  The correct
	 stab for this case is to use VISIBILITY_IGNORE, but that is a
	 recent invention.  (2) It is a 0-size array.  For example
	 union { int num; char str[0]; } foo.  Printing "<no value>"
	 for str in "p foo" is OK, since foo.str (and thus foo.str[3])
	 will continue to work, and a 0-size array as a whole doesn't
	 have any contents to print.

	 I suspect this probably could also happen with gcc -gstabs
	 (not -gstabs+) for static fields, and perhaps other C++
	 extensions.  Hopefully few people use -gstabs with gdb, since
	 it is intended for dbx compatibility.  */
      visibility = DEBUG_VISIBILITY_IGNORE;
    }

  /* FIXME: gdb does some stuff here to mark fields as unpacked.  */

  *retp = debug_make_field (dhandle, name, type, bitpos, bitsize, visibility);

  return TRUE;
}

/* Read member function stabs info for C++ classes.  The form of each member
   function data is:

	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;

   An example with two member functions is:

	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;

   For the case of overloaded operators, the format is op$::*.funcs, where
   $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator
   name (such as `+=') and `.' marks the end of the operator name.  */

static bfd_boolean
parse_stab_members (void *dhandle, struct stab_handle *info,
		    const char *tagname, const char **pp,
		    const int *typenums, debug_method **retp)
{
  const char *orig;
  debug_method *methods;
  unsigned int c;
  unsigned int alloc;

  *retp = NULL;

  orig = *pp;

  alloc = 0;
  methods = NULL;
  c = 0;

  while (**pp != ';')
    {
      const char *p;
      char *name;
      debug_method_variant *variants;
      unsigned int cvars;
      unsigned int allocvars;
      debug_type look_ahead_type;

      p = strchr (*pp, ':');
      if (p == NULL || p[1] != ':')
	break;

      /* FIXME: Some systems use something other than '$' here.  */
      if ((*pp)[0] != 'o' || (*pp)[1] != 'p' || (*pp)[2] != '$')
	{
	  name = savestring (*pp, p - *pp);
	  *pp = p + 2;
	}
      else
	{
	  /* This is a completely weird case.  In order to stuff in the
	     names that might contain colons (the usual name delimiter),
	     Mike Tiemann defined a different name format which is
	     signalled if the identifier is "op$".  In that case, the
	     format is "op$::XXXX." where XXXX is the name.  This is
	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
	  *pp = p + 2;
	  for (p = *pp; *p != '.' && *p != '\0'; p++)
	    ;
	  if (*p != '.')
	    {
	      bad_stab (orig);
	      return FALSE;
	    }
	  name = savestring (*pp, p - *pp);
	  *pp = p + 1;
	}

      allocvars = 10;
      variants = ((debug_method_variant *)
		  xmalloc (allocvars * sizeof *variants));
      cvars = 0;

      look_ahead_type = DEBUG_TYPE_NULL;

      do
	{
	  debug_type type;
	  bfd_boolean stub;
	  char *argtypes;
	  enum debug_visibility visibility;
	  bfd_boolean constp, volatilep, staticp;
	  bfd_vma voffset;
	  debug_type context;
	  const char *physname;
	  bfd_boolean varargs;

	  if (look_ahead_type != DEBUG_TYPE_NULL)
	    {
	      /* g++ version 1 kludge */
	      type = look_ahead_type;
	      look_ahead_type = DEBUG_TYPE_NULL;
	    }
	  else
	    {
	      type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
				      (debug_type **) NULL);
	      if (type == DEBUG_TYPE_NULL)
		return FALSE;
	      if (**pp != ':')
		{
		  bad_stab (orig);
		  return FALSE;
		}
	    }

	  ++*pp;
	  p = strchr (*pp, ';');
	  if (p == NULL)
	    {
	      bad_stab (orig);
	      return FALSE;
	    }

	  stub = FALSE;
	  if (debug_get_type_kind (dhandle, type) == DEBUG_KIND_METHOD
	      && debug_get_parameter_types (dhandle, type, &varargs) == NULL)
	    stub = TRUE;

	  argtypes = savestring (*pp, p - *pp);
	  *pp = p + 1;

	  switch (**pp)
	    {
	    case '0':
	      visibility = DEBUG_VISIBILITY_PRIVATE;
	      break;
	    case '1':
	      visibility = DEBUG_VISIBILITY_PROTECTED;
	      break;
	    default:
	      visibility = DEBUG_VISIBILITY_PUBLIC;
	      break;
	    }
	  ++*pp;

	  constp = FALSE;
	  volatilep = FALSE;
	  switch (**pp)
	    {
	    case 'A':
	      /* Normal function.  */
	      ++*pp;
	      break;
	    case 'B':
	      /* const member function.  */
	      constp = TRUE;
	      ++*pp;
	      break;
	    case 'C':
	      /* volatile member function.  */
	      volatilep = TRUE;
	      ++*pp;
	      break;
	    case 'D':
	      /* const volatile member function.  */
	      constp = TRUE;
	      volatilep = TRUE;
	      ++*pp;
	      break;
	    case '*':
	    case '?':
	    case '.':
	      /* File compiled with g++ version 1; no information.  */
	      break;
	    default:
	      warn_stab (orig, _("const/volatile indicator missing"));
	      break;
	    }

	  staticp = FALSE;
	  switch (**pp)
	    {
	    case '*':
	      /* virtual member function, followed by index.  The sign
		 bit is supposedly set to distinguish
		 pointers-to-methods from virtual function indicies.  */
	      ++*pp;
	      voffset = parse_number (pp, (bfd_boolean *) NULL);
	      if (**pp != ';')
		{
		  bad_stab (orig);
		  return FALSE;
		}
	      ++*pp;
	      voffset &= 0x7fffffff;

	      if (**pp == ';' || *pp == '\0')
		{
		  /* Must be g++ version 1.  */
		  context = DEBUG_TYPE_NULL;
		}
	      else
		{
		  /* Figure out from whence this virtual function
		     came.  It may belong to virtual function table of
		     one of its baseclasses.  */
		  look_ahead_type = parse_stab_type (dhandle, info,
						     (const char *) NULL,
						     pp,
						     (debug_type **) NULL);
		  if (**pp == ':')
		    {
		      /* g++ version 1 overloaded methods.  */
		      context = DEBUG_TYPE_NULL;
		    }
		  else
		    {
		      context = look_ahead_type;
		      look_ahead_type = DEBUG_TYPE_NULL;
		      if (**pp != ';')
			{
			  bad_stab (orig);
			  return FALSE;
			}
		      ++*pp;
		    }
		}
	      break;

	    case '?':
	      /* static member function.  */
	      ++*pp;
	      staticp = TRUE;
	      voffset = 0;
	      context = DEBUG_TYPE_NULL;
	      if (strncmp (argtypes, name, strlen (name)) != 0)
		stub = TRUE;
	      break;

	    default:
	      warn_stab (orig, "member function type missing");
	      voffset = 0;
	      context = DEBUG_TYPE_NULL;
	      break;

	    case '.':
	      ++*pp;
	      voffset = 0;
	      context = DEBUG_TYPE_NULL;
	      break;
	    }

	  /* If the type is not a stub, then the argtypes string is
             the physical name of the function.  Otherwise the
             argtypes string is the mangled form of the argument
             types, and the full type and the physical name must be
             extracted from them.  */
	  if (! stub)
	    physname = argtypes;
	  else
	    {
	      debug_type class_type, return_type;

	      class_type = stab_find_type (dhandle, info, typenums);
	      if (class_type == DEBUG_TYPE_NULL)
		return FALSE;
	      return_type = debug_get_return_type (dhandle, type);
	      if (return_type == DEBUG_TYPE_NULL)
		{
		  bad_stab (orig);
		  return FALSE;
		}
	      type = parse_stab_argtypes (dhandle, info, class_type, name,
					  tagname, return_type, argtypes,
					  constp, volatilep, &physname);
	      if (type == DEBUG_TYPE_NULL)
		return FALSE;
	    }

	  if (cvars + 1 >= allocvars)
	    {
	      allocvars += 10;
	      variants = ((debug_method_variant *)
			  xrealloc (variants,
				    allocvars * sizeof *variants));
	    }

	  if (! staticp)
	    variants[cvars] = debug_make_method_variant (dhandle, physname,
							 type, visibility,
							 constp, volatilep,
							 voffset, context);
	  else
	    variants[cvars] = debug_make_static_method_variant (dhandle,
								physname,
								type,
								visibility,
								constp,
								volatilep);
	  if (variants[cvars] == DEBUG_METHOD_VARIANT_NULL)
	    return FALSE;

	  ++cvars;
	}
      while (**pp != ';' && **pp != '\0');

      variants[cvars] = DEBUG_METHOD_VARIANT_NULL;

      if (**pp != '\0')
	++*pp;

      if (c + 1 >= alloc)
	{
	  alloc += 10;
	  methods = ((debug_method *)
		     xrealloc (methods, alloc * sizeof *methods));
	}

      methods[c] = debug_make_method (dhandle, name, variants);

      ++c;
    }

  if (methods != NULL)
    methods[c] = DEBUG_METHOD_NULL;

  *retp = methods;

  return TRUE;
}

/* Parse a string representing argument types for a method.  Stabs
   tries to save space by packing argument types into a mangled
   string.  This string should give us enough information to extract
   both argument types and the physical name of the function, given
   the tag name.  */

static debug_type
parse_stab_argtypes (void *dhandle, struct stab_handle *info,
		     debug_type class_type, const char *fieldname,
		     const char *tagname, debug_type return_type,
		     const char *argtypes, bfd_boolean constp,
		     bfd_boolean volatilep, const char **pphysname)
{
  bfd_boolean is_full_physname_constructor;
  bfd_boolean is_constructor;
  bfd_boolean is_destructor;
  debug_type *args;
  bfd_boolean varargs;
  unsigned int physname_len = 0;

  /* Constructors are sometimes handled specially.  */
  is_full_physname_constructor = ((argtypes[0] == '_'
				   && argtypes[1] == '_'
				   && (ISDIGIT (argtypes[2])
				       || argtypes[2] == 'Q'
				       || argtypes[2] == 't'))
				  || strncmp (argtypes, "__ct", 4) == 0);

  is_constructor = (is_full_physname_constructor
		    || (tagname != NULL
			&& strcmp (fieldname, tagname) == 0));
  is_destructor = ((argtypes[0] == '_'
		    && (argtypes[1] == '$' || argtypes[1] == '.')
		    && argtypes[2] == '_')
		   || strncmp (argtypes, "__dt", 4) == 0);

  if (is_destructor || is_full_physname_constructor)
    *pphysname = argtypes;
  else
    {
      unsigned int len;
      const char *const_prefix;
      const char *volatile_prefix;
      char buf[20];
      unsigned int mangled_name_len;
      char *physname;

      len = tagname == NULL ? 0 : strlen (tagname);
      const_prefix = constp ? "C" : "";
      volatile_prefix = volatilep ? "V" : "";

      if (len == 0)
	sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
      else if (tagname != NULL && strchr (tagname, '<') != NULL)
	{
	  /* Template methods are fully mangled.  */
	  sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
	  tagname = NULL;
	  len = 0;
	}
      else
	sprintf (buf, "__%s%s%d", const_prefix, volatile_prefix, len);

      mangled_name_len = ((is_constructor ? 0 : strlen (fieldname))
			  + strlen (buf)
			  + len
			  + strlen (argtypes)
			  + 1);

      if (fieldname[0] == 'o'
	  && fieldname[1] == 'p'
	  && (fieldname[2] == '$' || fieldname[2] == '.'))
	{
	  const char *opname;

	  opname = cplus_mangle_opname (fieldname + 3, 0);
	  if (opname == NULL)
	    {
	      fprintf (stderr, _("No mangling for \"%s\"\n"), fieldname);
	      return DEBUG_TYPE_NULL;
	    }
	  mangled_name_len += strlen (opname);
	  physname = (char *) xmalloc (mangled_name_len);
	  strncpy (physname, fieldname, 3);
	  strcpy (physname + 3, opname);
	}
      else
	{
	  physname = (char *) xmalloc (mangled_name_len);
	  if (is_constructor)
	    physname[0] = '\0';
	  else
	    strcpy (physname, fieldname);
	}

      physname_len = strlen (physname);
      strcat (physname, buf);
      if (tagname != NULL)
	strcat (physname, tagname);
      strcat (physname, argtypes);

      *pphysname = physname;
    }

  if (*argtypes == '\0' || is_destructor)
    {
      args = (debug_type *) xmalloc (sizeof *args);
      *args = NULL;
      return debug_make_method_type (dhandle, return_type, class_type, args,
				     FALSE);
    }

  args = stab_demangle_argtypes (dhandle, info, *pphysname, &varargs, physname_len);
  if (args == NULL)
    return DEBUG_TYPE_NULL;

  return debug_make_method_type (dhandle, return_type, class_type, args,
				 varargs);
}

/* The tail end of stabs for C++ classes that contain a virtual function
   pointer contains a tilde, a %, and a type number.
   The type number refers to the base class (possibly this class itself) which
   contains the vtable pointer for the current class.

   This function is called when we have parsed all the method declarations,
   so we can look for the vptr base class info.  */

static bfd_boolean
parse_stab_tilde_field (void *dhandle, struct stab_handle *info,
			const char **pp, const int *typenums,
			debug_type *retvptrbase, bfd_boolean *retownvptr)
{
  const char *orig;
  const char *hold;
  int vtypenums[2];

  *retvptrbase = DEBUG_TYPE_NULL;
  *retownvptr = FALSE;

  orig = *pp;

  /* If we are positioned at a ';', then skip it.  */
  if (**pp == ';')
    ++*pp;

  if (**pp != '~')
    return TRUE;

  ++*pp;

  if (**pp == '=' || **pp == '+' || **pp == '-')
    {
      /* Obsolete flags that used to indicate the presence of
	 constructors and/or destructors.  */
      ++*pp;
    }

  if (**pp != '%')
    return TRUE;

  ++*pp;

  hold = *pp;

  /* The next number is the type number of the base class (possibly
     our own class) which supplies the vtable for this class.  */
  if (! parse_stab_type_number (pp, vtypenums))
    return FALSE;

  if (vtypenums[0] == typenums[0]
      && vtypenums[1] == typenums[1])
    *retownvptr = TRUE;
  else
    {
      debug_type vtype;
      const char *p;

      *pp = hold;

      vtype = parse_stab_type (dhandle, info, (const char *) NULL, pp,
			       (debug_type **) NULL);
      for (p = *pp; *p != ';' && *p != '\0'; p++)
	;
      if (*p != ';')
	{
	  bad_stab (orig);
	  return FALSE;
	}

      *retvptrbase = vtype;

      *pp = p + 1;
    }

  return TRUE;
}

/* Read a definition of an array type.  */

static debug_type
parse_stab_array_type (void *dhandle, struct stab_handle *info,
		       const char **pp, bfd_boolean stringp)
{
  const char *orig;
  const char *p;
  int typenums[2];
  debug_type index_type;
  bfd_boolean adjustable;
  bfd_signed_vma lower, upper;
  debug_type element_type;

  /* Format of an array type:
     "ar<index type>;lower;upper;<array_contents_type>".
     OS9000: "arlower,upper;<array_contents_type>".

     Fortran adjustable arrays use Adigits or Tdigits for lower or upper;
     for these, produce a type like float[][].  */

  orig = *pp;

  /* FIXME: gdb checks os9k_stabs here.  */

  /* If the index type is type 0, we take it as int.  */
  p = *pp;
  if (! parse_stab_type_number (&p, typenums))
    return DEBUG_TYPE_NULL;
  if (typenums[0] == 0 && typenums[1] == 0 && **pp != '=')
    {
      index_type = debug_find_named_type (dhandle, "int");
      if (index_type == DEBUG_TYPE_NULL)
	{
	  index_type = debug_make_int_type (dhandle, 4, FALSE);
	  if (index_type == DEBUG_TYPE_NULL)
	    return DEBUG_TYPE_NULL;
	}
      *pp = p;
    }
  else
    {
      index_type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
				    (debug_type **) NULL);
    }

  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  adjustable = FALSE;

  if (! ISDIGIT (**pp) && **pp != '-')
    {
      ++*pp;
      adjustable = TRUE;
    }

  lower = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  if (! ISDIGIT (**pp) && **pp != '-')
    {
      ++*pp;
      adjustable = TRUE;
    }

  upper = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
  if (**pp != ';')
    {
      bad_stab (orig);
      return DEBUG_TYPE_NULL;
    }
  ++*pp;

  element_type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
				  (debug_type **) NULL);
  if (element_type == DEBUG_TYPE_NULL)
    return DEBUG_TYPE_NULL;

  if (adjustable)
    {
      lower = 0;
      upper = -1;
    }

  return debug_make_array_type (dhandle, element_type, index_type, lower,
				upper, stringp);
}

/* This struct holds information about files we have seen using
   N_BINCL.  */

struct bincl_file
{
  /* The next N_BINCL file.  */
  struct bincl_file *next;
  /* The next N_BINCL on the stack.  */
  struct bincl_file *next_stack;
  /* The file name.  */
  const char *name;
  /* The hash value.  */
  bfd_vma hash;
  /* The file index.  */
  unsigned int file;
  /* The list of types defined in this file.  */
  struct stab_types *file_types;
};

/* Start a new N_BINCL file, pushing it onto the stack.  */

static void
push_bincl (struct stab_handle *info, const char *name, bfd_vma hash)
{
  struct bincl_file *n;

  n = (struct bincl_file *) xmalloc (sizeof *n);
  n->next = info->bincl_list;
  n->next_stack = info->bincl_stack;
  n->name = name;
  n->hash = hash;
  n->file = info->files;
  n->file_types = NULL;
  info->bincl_list = n;
  info->bincl_stack = n;

  ++info->files;
  info->file_types = ((struct stab_types **)
		      xrealloc (info->file_types,
				(info->files
				 * sizeof *info->file_types)));
  info->file_types[n->file] = NULL;
}

/* Finish an N_BINCL file, at an N_EINCL, popping the name off the
   stack.  */

static const char *
pop_bincl (struct stab_handle *info)
{
  struct bincl_file *o;

  o = info->bincl_stack;
  if (o == NULL)
    return info->main_filename;
  info->bincl_stack = o->next_stack;

  o->file_types = info->file_types[o->file];

  if (info->bincl_stack == NULL)
    return info->main_filename;
  return info->bincl_stack->name;
}

/* Handle an N_EXCL: get the types from the corresponding N_BINCL.  */

static bfd_boolean
find_excl (struct stab_handle *info, const char *name, bfd_vma hash)
{
  struct bincl_file *l;

  ++info->files;
  info->file_types = ((struct stab_types **)
		      xrealloc (info->file_types,
				(info->files
				 * sizeof *info->file_types)));

  for (l = info->bincl_list; l != NULL; l = l->next)
    if (l->hash == hash && strcmp (l->name, name) == 0)
      break;
  if (l == NULL)
    {
      warn_stab (name, _("Undefined N_EXCL"));
      info->file_types[info->files - 1] = NULL;
      return TRUE;
    }

  info->file_types[info->files - 1] = l->file_types;

  return TRUE;
}

/* Handle a variable definition.  gcc emits variable definitions for a
   block before the N_LBRAC, so we must hold onto them until we see
   it.  The SunPRO compiler emits variable definitions after the
   N_LBRAC, so we can call debug_record_variable immediately.  */

static bfd_boolean
stab_record_variable (void *dhandle, struct stab_handle *info,
		      const char *name, debug_type type,
		      enum debug_var_kind kind, bfd_vma val)
{
  struct stab_pending_var *v;

  if ((kind == DEBUG_GLOBAL || kind == DEBUG_STATIC)
      || ! info->within_function
      || (info->gcc_compiled == 0 && info->n_opt_found))
    return debug_record_variable (dhandle, name, type, kind, val);

  v = (struct stab_pending_var *) xmalloc (sizeof *v);
  memset (v, 0, sizeof *v);

  v->next = info->pending;
  v->name = name;
  v->type = type;
  v->kind = kind;
  v->val = val;
  info->pending = v;

  return TRUE;
}

/* Emit pending variable definitions.  This is called after we see the
   N_LBRAC that starts the block.  */

static bfd_boolean
stab_emit_pending_vars (void *dhandle, struct stab_handle *info)
{
  struct stab_pending_var *v;

  v = info->pending;
  while (v != NULL)
    {
      struct stab_pending_var *next;

      if (! debug_record_variable (dhandle, v->name, v->type, v->kind, v->val))
	return FALSE;

      next = v->next;
      free (v);
      v = next;
    }

  info->pending = NULL;

  return TRUE;
}

/* Find the slot for a type in the database.  */

static debug_type *
stab_find_slot (struct stab_handle *info, const int *typenums)
{
  int filenum;
  int index;
  struct stab_types **ps;

  filenum = typenums[0];
  index = typenums[1];

  if (filenum < 0 || (unsigned int) filenum >= info->files)
    {
      fprintf (stderr, _("Type file number %d out of range\n"), filenum);
      return NULL;
    }
  if (index < 0)
    {
      fprintf (stderr, _("Type index number %d out of range\n"), index);
      return NULL;
    }

  ps = info->file_types + filenum;

  while (index >= STAB_TYPES_SLOTS)
    {
      if (*ps == NULL)
	{
	  *ps = (struct stab_types *) xmalloc (sizeof **ps);
	  memset (*ps, 0, sizeof **ps);
	}
      ps = &(*ps)->next;
      index -= STAB_TYPES_SLOTS;
    }
  if (*ps == NULL)
    {
      *ps = (struct stab_types *) xmalloc (sizeof **ps);
      memset (*ps, 0, sizeof **ps);
    }

  return (*ps)->types + index;
}

/* Find a type given a type number.  If the type has not been
   allocated yet, create an indirect type.  */

static debug_type
stab_find_type (void *dhandle, struct stab_handle *info, const int *typenums)
{
  debug_type *slot;

  if (typenums[0] == 0 && typenums[1] < 0)
    {
      /* A negative type number indicates an XCOFF builtin type.  */
      return stab_xcoff_builtin_type (dhandle, info, typenums[1]);
    }

  slot = stab_find_slot (info, typenums);
  if (slot == NULL)
    return DEBUG_TYPE_NULL;

  if (*slot == DEBUG_TYPE_NULL)
    return debug_make_indirect_type (dhandle, slot, (const char *) NULL);

  return *slot;
}

/* Record that a given type number refers to a given type.  */

static bfd_boolean
stab_record_type (void *dhandle ATTRIBUTE_UNUSED, struct stab_handle *info,
		  const int *typenums, debug_type type)
{
  debug_type *slot;

  slot = stab_find_slot (info, typenums);
  if (slot == NULL)
    return FALSE;

  /* gdb appears to ignore type redefinitions, so we do as well.  */

  *slot = type;

  return TRUE;
}

/* Return an XCOFF builtin type.  */

static debug_type
stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
			 int typenum)
{
  debug_type rettype;
  const char *name;

  if (typenum >= 0 || typenum < -XCOFF_TYPE_COUNT)
    {
      fprintf (stderr, _("Unrecognized XCOFF type %d\n"), typenum);
      return DEBUG_TYPE_NULL;
    }
  if (info->xcoff_types[-typenum] != NULL)
    return info->xcoff_types[-typenum];

  switch (-typenum)
    {
    case 1:
      /* The size of this and all the other types are fixed, defined
	 by the debugging format.  */
      name = "int";
      rettype = debug_make_int_type (dhandle, 4, FALSE);
      break;
    case 2:
      name = "char";
      rettype = debug_make_int_type (dhandle, 1, FALSE);
      break;
    case 3:
      name = "short";
      rettype = debug_make_int_type (dhandle, 2, FALSE);
      break;
    case 4:
      name = "long";
      rettype = debug_make_int_type (dhandle, 4, FALSE);
      break;
    case 5:
      name = "unsigned char";
      rettype = debug_make_int_type (dhandle, 1, TRUE);
      break;
    case 6:
      name = "signed char";
      rettype = debug_make_int_type (dhandle, 1, FALSE);
      break;
    case 7:
      name = "unsigned short";
      rettype = debug_make_int_type (dhandle, 2, TRUE);
      break;
    case 8:
      name = "unsigned int";
      rettype = debug_make_int_type (dhandle, 4, TRUE);
      break;
    case 9:
      name = "unsigned";
      rettype = debug_make_int_type (dhandle, 4, TRUE);
    case 10:
      name = "unsigned long";
      rettype = debug_make_int_type (dhandle, 4, TRUE);
      break;
    case 11:
      name = "void";
      rettype = debug_make_void_type (dhandle);
      break;
    case 12:
      /* IEEE single precision (32 bit).  */
      name = "float";
      rettype = debug_make_float_type (dhandle, 4);
      break;
    case 13:
      /* IEEE double precision (64 bit).  */
      name = "double";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 14:
      /* This is an IEEE double on the RS/6000, and different machines
	 with different sizes for "long double" should use different
	 negative type numbers.  See stabs.texinfo.  */
      name = "long double";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 15:
      name = "integer";
      rettype = debug_make_int_type (dhandle, 4, FALSE);
      break;
    case 16:
      name = "boolean";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 17:
      name = "short real";
      rettype = debug_make_float_type (dhandle, 4);
      break;
    case 18:
      name = "real";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 19:
      /* FIXME */
      name = "stringptr";
      rettype = NULL;
      break;
    case 20:
      /* FIXME */
      name = "character";
      rettype = debug_make_int_type (dhandle, 1, TRUE);
      break;
    case 21:
      name = "logical*1";
      rettype = debug_make_bool_type (dhandle, 1);
      break;
    case 22:
      name = "logical*2";
      rettype = debug_make_bool_type (dhandle, 2);
      break;
    case 23:
      name = "logical*4";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 24:
      name = "logical";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 25:
      /* Complex type consisting of two IEEE single precision values.  */
      name = "complex";
      rettype = debug_make_complex_type (dhandle, 8);
      break;
    case 26:
      /* Complex type consisting of two IEEE double precision values.  */
      name = "double complex";
      rettype = debug_make_complex_type (dhandle, 16);
      break;
    case 27:
      name = "integer*1";
      rettype = debug_make_int_type (dhandle, 1, FALSE);
      break;
    case 28:
      name = "integer*2";
      rettype = debug_make_int_type (dhandle, 2, FALSE);
      break;
    case 29:
      name = "integer*4";
      rettype = debug_make_int_type (dhandle, 4, FALSE);
      break;
    case 30:
      /* FIXME */
      name = "wchar";
      rettype = debug_make_int_type (dhandle, 2, FALSE);
      break;
    case 31:
      name = "long long";
      rettype = debug_make_int_type (dhandle, 8, FALSE);
      break;
    case 32:
      name = "unsigned long long";
      rettype = debug_make_int_type (dhandle, 8, TRUE);
      break;
    case 33:
      name = "logical*8";
      rettype = debug_make_bool_type (dhandle, 8);
      break;
    case 34:
      name = "integer*8";
      rettype = debug_make_int_type (dhandle, 8, FALSE);
      break;
    default:
      abort ();
    }

  rettype = debug_name_type (dhandle, name, rettype);

  info->xcoff_types[-typenum] = rettype;

  return rettype;
}

/* Find or create a tagged type.  */

static debug_type
stab_find_tagged_type (void *dhandle, struct stab_handle *info,
		       const char *p, int len, enum debug_type_kind kind)
{
  char *name;
  debug_type dtype;
  struct stab_tag *st;

  name = savestring (p, len);

  /* We pass DEBUG_KIND_ILLEGAL because we want all tags in the same
     namespace.  This is right for C, and I don't know how to handle
     other languages.  FIXME.  */
  dtype = debug_find_tagged_type (dhandle, name, DEBUG_KIND_ILLEGAL);
  if (dtype != DEBUG_TYPE_NULL)
    {
      free (name);
      return dtype;
    }

  /* We need to allocate an entry on the undefined tag list.  */
  for (st = info->tags; st != NULL; st = st->next)
    {
      if (st->name[0] == name[0]
	  && strcmp (st->name, name) == 0)
	{
	  if (st->kind == DEBUG_KIND_ILLEGAL)
	    st->kind = kind;
	  free (name);
	  break;
	}
    }
  if (st == NULL)
    {
      st = (struct stab_tag *) xmalloc (sizeof *st);
      memset (st, 0, sizeof *st);

      st->next = info->tags;
      st->name = name;
      st->kind = kind;
      st->slot = DEBUG_TYPE_NULL;
      st->type = debug_make_indirect_type (dhandle, &st->slot, name);
      info->tags = st;
    }

  return st->type;
}

/* In order to get the correct argument types for a stubbed method, we
   need to extract the argument types from a C++ mangled string.
   Since the argument types can refer back to the return type, this
   means that we must demangle the entire physical name.  In gdb this
   is done by calling cplus_demangle and running the results back
   through the C++ expression parser.  Since we have no expression
   parser, we must duplicate much of the work of cplus_demangle here.

   We assume that GNU style demangling is used, since this is only
   done for method stubs, and only g++ should output that form of
   debugging information.  */

/* This structure is used to hold a pointer to type information which
   demangling a string.  */

struct stab_demangle_typestring
{
  /* The start of the type.  This is not null terminated.  */
  const char *typestring;
  /* The length of the type.  */
  unsigned int len;
};

/* This structure is used to hold information while demangling a
   string.  */

struct stab_demangle_info
{
  /* The debugging information handle.  */
  void *dhandle;
  /* The stab information handle.  */
  struct stab_handle *info;
  /* The array of arguments we are building.  */
  debug_type *args;
  /* Whether the method takes a variable number of arguments.  */
  bfd_boolean varargs;
  /* The array of types we have remembered.  */
  struct stab_demangle_typestring *typestrings;
  /* The number of typestrings.  */
  unsigned int typestring_count;
  /* The number of typestring slots we have allocated.  */
  unsigned int typestring_alloc;
};

static void stab_bad_demangle (const char *);
static unsigned int stab_demangle_count (const char **);
static bfd_boolean stab_demangle_get_count (const char **, unsigned int *);
static bfd_boolean stab_demangle_prefix
  (struct stab_demangle_info *, const char **, unsigned int);
static bfd_boolean stab_demangle_function_name
  (struct stab_demangle_info *, const char **, const char *);
static bfd_boolean stab_demangle_signature
  (struct stab_demangle_info *, const char **);
static bfd_boolean stab_demangle_qualified
  (struct stab_demangle_info *, const char **, debug_type *);
static bfd_boolean stab_demangle_template
  (struct stab_demangle_info *, const char **, char **);
static bfd_boolean stab_demangle_class
  (struct stab_demangle_info *, const char **, const char **);
static bfd_boolean stab_demangle_args
  (struct stab_demangle_info *, const char **, debug_type **, bfd_boolean *);
static bfd_boolean stab_demangle_arg
  (struct stab_demangle_info *, const char **, debug_type **,
   unsigned int *, unsigned int *);
static bfd_boolean stab_demangle_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bfd_boolean stab_demangle_fund_type
  (struct stab_demangle_info *, const char **, debug_type *);
static bfd_boolean stab_demangle_remember_type
  (struct stab_demangle_info *, const char *, int);

/* Warn about a bad demangling.  */

static void
stab_bad_demangle (const char *s)
{
  fprintf (stderr, _("bad mangled name `%s'\n"), s);
}

/* Get a count from a stab string.  */

static unsigned int
stab_demangle_count (const char **pp)
{
  unsigned int count;

  count = 0;
  while (ISDIGIT (**pp))
    {
      count *= 10;
      count += **pp - '0';
      ++*pp;
    }
  return count;
}

/* Require a count in a string.  The count may be multiple digits, in
   which case it must end in an underscore.  */

static bfd_boolean
stab_demangle_get_count (const char **pp, unsigned int *pi)
{
  if (! ISDIGIT (**pp))
    return FALSE;

  *pi = **pp - '0';
  ++*pp;
  if (ISDIGIT (**pp))
    {
      unsigned int count;
      const char *p;

      count = *pi;
      p = *pp;
      do
	{
	  count *= 10;
	  count += *p - '0';
	  ++p;
	}
      while (ISDIGIT (*p));
      if (*p == '_')
	{
	  *pp = p + 1;
	  *pi = count;
	}
    }

  return TRUE;
}

/* This function demangles a physical name, returning a NULL
   terminated array of argument types.  */

static debug_type *
stab_demangle_argtypes (void *dhandle, struct stab_handle *info,
			const char *physname, bfd_boolean *pvarargs,
			unsigned int physname_len)
{
  struct stab_demangle_info minfo;

  minfo.dhandle = dhandle;
  minfo.info = info;
  minfo.args = NULL;
  minfo.varargs = FALSE;
  minfo.typestring_alloc = 10;
  minfo.typestrings = ((struct stab_demangle_typestring *)
		       xmalloc (minfo.typestring_alloc
				* sizeof *minfo.typestrings));
  minfo.typestring_count = 0;

  /* cplus_demangle checks for special GNU mangled forms, but we can't
     see any of them in mangled method argument types.  */

  if (! stab_demangle_prefix (&minfo, &physname, physname_len))
    goto error_return;

  if (*physname != '\0')
    {
      if (! stab_demangle_signature (&minfo, &physname))
	goto error_return;
    }

  free (minfo.typestrings);
  minfo.typestrings = NULL;

  if (minfo.args == NULL)
    fprintf (stderr, _("no argument types in mangled string\n"));

  *pvarargs = minfo.varargs;
  return minfo.args;

 error_return:
  if (minfo.typestrings != NULL)
    free (minfo.typestrings);
  return NULL;
}

/* Demangle the prefix of the mangled name.  */

static bfd_boolean
stab_demangle_prefix (struct stab_demangle_info *minfo, const char **pp,
		      unsigned int physname_len)
{
  const char *scan;
  unsigned int i;

  /* cplus_demangle checks for global constructors and destructors,
     but we can't see them in mangled argument types.  */

  if (physname_len)
    scan = *pp + physname_len;
  else
    {
      /* Look for `__'.  */
      scan = *pp;
      do
	scan = strchr (scan, '_');
      while (scan != NULL && *++scan != '_');

      if (scan == NULL)
	{
	  stab_bad_demangle (*pp);
	  return FALSE;
	}

      --scan;

      /* We found `__'; move ahead to the last contiguous `__' pair.  */
      i = strspn (scan, "_");
      if (i > 2)
	scan += i - 2;
    }

  if (scan == *pp
      && (ISDIGIT (scan[2])
	  || scan[2] == 'Q'
	  || scan[2] == 't'))
    {
      /* This is a GNU style constructor name.  */
      *pp = scan + 2;
      return TRUE;
    }
  else if (scan == *pp
	   && ! ISDIGIT (scan[2])
	   && scan[2] != 't')
    {
      /* Look for the `__' that separates the prefix from the
         signature.  */
      while (*scan == '_')
	++scan;
      scan = strstr (scan, "__");
      if (scan == NULL || scan[2] == '\0')
	{
	  stab_bad_demangle (*pp);
	  return FALSE;
	}

      return stab_demangle_function_name (minfo, pp, scan);
    }
  else if (scan[2] != '\0')
    {
      /* The name doesn't start with `__', but it does contain `__'.  */
      return stab_demangle_function_name (minfo, pp, scan);
    }
  else
    {
      stab_bad_demangle (*pp);
      return FALSE;
    }
  /*NOTREACHED*/
}

/* Demangle a function name prefix.  The scan argument points to the
   double underscore which separates the function name from the
   signature.  */

static bfd_boolean
stab_demangle_function_name (struct stab_demangle_info *minfo,
			     const char **pp, const char *scan)
{
  const char *name;

  /* The string from *pp to scan is the name of the function.  We
     don't care about the name, since we just looking for argument
     types.  However, for conversion operators, the name may include a
     type which we must remember in order to handle backreferences.  */

  name = *pp;
  *pp = scan + 2;

  if (*pp - name >= 5
	   && strncmp (name, "type", 4) == 0
	   && (name[4] == '$' || name[4] == '.'))
    {
      const char *tem;

      /* This is a type conversion operator.  */
      tem = name + 5;
      if (! stab_demangle_type (minfo, &tem, (debug_type *) NULL))
	return FALSE;
    }
  else if (name[0] == '_'
	   && name[1] == '_'
	   && name[2] == 'o'
	   && name[3] == 'p')
    {
      const char *tem;

      /* This is a type conversion operator.  */
      tem = name + 4;
      if (! stab_demangle_type (minfo, &tem, (debug_type *) NULL))
	return FALSE;
    }

  return TRUE;
}

/* Demangle the signature.  This is where the argument types are
   found.  */

static bfd_boolean
stab_demangle_signature (struct stab_demangle_info *minfo, const char **pp)
{
  const char *orig;
  bfd_boolean expect_func, func_done;
  const char *hold;

  orig = *pp;

  expect_func = FALSE;
  func_done = FALSE;
  hold = NULL;

  while (**pp != '\0')
    {
      switch (**pp)
	{
	case 'Q':
	  hold = *pp;
	  if (! stab_demangle_qualified (minfo, pp, (debug_type *) NULL)
	      || ! stab_demangle_remember_type (minfo, hold, *pp - hold))
	    return FALSE;
	  expect_func = TRUE;
	  hold = NULL;
	  break;

	case 'S':
	  /* Static member function.  FIXME: Can this happen?  */
	  if (hold == NULL)
	    hold = *pp;
	  ++*pp;
	  break;

	case 'C':
	  /* Const member function.  */
	  if (hold == NULL)
	    hold = *pp;
	  ++*pp;
	  break;

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (hold == NULL)
	    hold = *pp;
	  if (! stab_demangle_class (minfo, pp, (const char **) NULL)
	      || ! stab_demangle_remember_type (minfo, hold, *pp - hold))
	    return FALSE;
	  expect_func = TRUE;
	  hold = NULL;
	  break;

	case 'F':
	  /* Function.  I don't know if this actually happens with g++
             output.  */
	  hold = NULL;
	  func_done = TRUE;
	  ++*pp;
	  if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	    return FALSE;
	  break;

	case 't':
	  /* Template.  */
	  if (hold == NULL)
	    hold = *pp;
	  if (! stab_demangle_template (minfo, pp, (char **) NULL)
	      || ! stab_demangle_remember_type (minfo, hold, *pp - hold))
	    return FALSE;
	  hold = NULL;
	  expect_func = TRUE;
	  break;

	case '_':
	  /* At the outermost level, we cannot have a return type
	     specified, so if we run into another '_' at this point we
	     are dealing with a mangled name that is either bogus, or
	     has been mangled by some algorithm we don't know how to
	     deal with.  So just reject the entire demangling.  */
	  stab_bad_demangle (orig);
	  return FALSE;

	default:
	  /* Assume we have stumbled onto the first outermost function
	     argument token, and start processing args.  */
	  func_done = TRUE;
	  if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	    return FALSE;
	  break;
	}

      if (expect_func)
	{
	  func_done = TRUE;
	  if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	    return FALSE;
	}
    }

  if (! func_done)
    {
      /* With GNU style demangling, bar__3foo is 'foo::bar(void)', and
	 bar__3fooi is 'foo::bar(int)'.  We get here when we find the
	 first case, and need to ensure that the '(void)' gets added
	 to the current declp.  */
      if (! stab_demangle_args (minfo, pp, &minfo->args, &minfo->varargs))
	return FALSE;
    }

  return TRUE;
}

/* Demangle a qualified name, such as "Q25Outer5Inner" which is the
   mangled form of "Outer::Inner".  */

static bfd_boolean
stab_demangle_qualified (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
{
  const char *orig;
  const char *p;
  unsigned int qualifiers;
  debug_type context;

  orig = *pp;

  switch ((*pp)[1])
    {
    case '_':
      /* GNU mangled name with more than 9 classes.  The count is
	 preceded by an underscore (to distinguish it from the <= 9
	 case) and followed by an underscore.  */
      p = *pp + 2;
      if (! ISDIGIT (*p) || *p == '0')
	{
	  stab_bad_demangle (orig);
	  return FALSE;
	}
      qualifiers = atoi (p);
      while (ISDIGIT (*p))
	++p;
      if (*p != '_')
	{
	  stab_bad_demangle (orig);
	  return FALSE;
	}
      *pp = p + 1;
      break;

    case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9':
      qualifiers = (*pp)[1] - '0';
      /* Skip an optional underscore after the count.  */
      if ((*pp)[2] == '_')
	++*pp;
      *pp += 2;
      break;

    case '0':
    default:
      stab_bad_demangle (orig);
      return FALSE;
    }

  context = DEBUG_TYPE_NULL;

  /* Pick off the names.  */
  while (qualifiers-- > 0)
    {
      if (**pp == '_')
	++*pp;
      if (**pp == 't')
	{
	  char *name;

	  if (! stab_demangle_template (minfo, pp,
					ptype != NULL ? &name : NULL))
	    return FALSE;

	  if (ptype != NULL)
	    {
	      context = stab_find_tagged_type (minfo->dhandle, minfo->info,
					       name, strlen (name),
					       DEBUG_KIND_CLASS);
	      free (name);
	      if (context == DEBUG_TYPE_NULL)
		return FALSE;
	    }
	}
      else
	{
	  unsigned int len;

	  len = stab_demangle_count (pp);
	  if (strlen (*pp) < len)
	    {
	      stab_bad_demangle (orig);
	      return FALSE;
	    }

	  if (ptype != NULL)
	    {
	      const debug_field *fields;

	      fields = NULL;
	      if (context != DEBUG_TYPE_NULL)
		fields = debug_get_fields (minfo->dhandle, context);

	      context = DEBUG_TYPE_NULL;

	      if (fields != NULL)
		{
		  char *name;

		  /* Try to find the type by looking through the
                     fields of context until we find a field with the
                     same type.  This ought to work for a class
                     defined within a class, but it won't work for,
                     e.g., an enum defined within a class.  stabs does
                     not give us enough information to figure out the
                     latter case.  */

		  name = savestring (*pp, len);

		  for (; *fields != DEBUG_FIELD_NULL; fields++)
		    {
		      debug_type ft;
		      const char *dn;

		      ft = debug_get_field_type (minfo->dhandle, *fields);
		      if (ft == NULL)
			return FALSE;
		      dn = debug_get_type_name (minfo->dhandle, ft);
		      if (dn != NULL && strcmp (dn, name) == 0)
			{
			  context = ft;
			  break;
			}
		    }

		  free (name);
		}

	      if (context == DEBUG_TYPE_NULL)
		{
		  /* We have to fall back on finding the type by name.
                     If there are more types to come, then this must
                     be a class.  Otherwise, it could be anything.  */

		  if (qualifiers == 0)
		    {
		      char *name;

		      name = savestring (*pp, len);
		      context = debug_find_named_type (minfo->dhandle,
						       name);
		      free (name);
		    }

		  if (context == DEBUG_TYPE_NULL)
		    {
		      context = stab_find_tagged_type (minfo->dhandle,
						       minfo->info,
						       *pp, len,
						       (qualifiers == 0
							? DEBUG_KIND_ILLEGAL
							: DEBUG_KIND_CLASS));
		      if (context == DEBUG_TYPE_NULL)
			return FALSE;
		    }
		}
	    }

	  *pp += len;
	}
    }

  if (ptype != NULL)
    *ptype = context;

  return TRUE;
}

/* Demangle a template.  If PNAME is not NULL, this sets *PNAME to a
   string representation of the template.  */

static bfd_boolean
stab_demangle_template (struct stab_demangle_info *minfo, const char **pp,
			char **pname)
{
  const char *orig;
  unsigned int r, i;

  orig = *pp;

  ++*pp;

  /* Skip the template name.  */
  r = stab_demangle_count (pp);
  if (r == 0 || strlen (*pp) < r)
    {
      stab_bad_demangle (orig);
      return FALSE;
    }
  *pp += r;

  /* Get the size of the parameter list.  */
  if (stab_demangle_get_count (pp, &r) == 0)
    {
      stab_bad_demangle (orig);
      return FALSE;
    }

  for (i = 0; i < r; i++)
    {
      if (**pp == 'Z')
	{
	  /* This is a type parameter.  */
	  ++*pp;
	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
	    return FALSE;
	}
      else
	{
	  const char *old_p;
	  bfd_boolean pointerp, realp, integralp, charp, boolp;
	  bfd_boolean done;

	  old_p = *pp;
	  pointerp = FALSE;
	  realp = FALSE;
	  integralp = FALSE;
	  charp = FALSE;
	  boolp = FALSE;
	  done = FALSE;

	  /* This is a value parameter.  */

	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
	    return FALSE;

	  while (*old_p != '\0' && ! done)
	    {
	      switch (*old_p)
		{
		case 'P':
		case 'p':
		case 'R':
		  pointerp = TRUE;
		  done = TRUE;
		  break;
		case 'C':	/* Const.  */
		case 'S':	/* Signed.  */
		case 'U':	/* Unsigned.  */
		case 'V':	/* Volatile.  */
		case 'F':	/* Function.  */
		case 'M':	/* Member function.  */
		case 'O':	/* ??? */
		  ++old_p;
		  break;
		case 'Q':	/* Qualified name.  */
		  integralp = TRUE;
		  done = TRUE;
		  break;
		case 'T':	/* Remembered type.  */
		  abort ();
		case 'v':	/* Void.  */
		  abort ();
		case 'x':	/* Long long.  */
		case 'l':	/* Long.  */
		case 'i':	/* Int.  */
		case 's':	/* Short.  */
		case 'w':	/* Wchar_t.  */
		  integralp = TRUE;
		  done = TRUE;
		  break;
		case 'b':	/* Bool.  */
		  boolp = TRUE;
		  done = TRUE;
		  break;
		case 'c':	/* Char.  */
		  charp = TRUE;
		  done = TRUE;
		  break;
		case 'r':	/* Long double.  */
		case 'd':	/* Double.  */
		case 'f':	/* Float.  */
		  realp = TRUE;
		  done = TRUE;
		  break;
		default:
		  /* Assume it's a user defined integral type.  */
		  integralp = TRUE;
		  done = TRUE;
		  break;
		}
	    }

	  if (integralp)
	    {
	      if (**pp == 'm')
		++*pp;
	      while (ISDIGIT (**pp))
		++*pp;
	    }
	  else if (charp)
	    {
	      unsigned int val;

	      if (**pp == 'm')
		++*pp;
	      val = stab_demangle_count (pp);
	      if (val == 0)
		{
		  stab_bad_demangle (orig);
		  return FALSE;
		}
	    }
	  else if (boolp)
	    {
	      unsigned int val;

	      val = stab_demangle_count (pp);
	      if (val != 0 && val != 1)
		{
		  stab_bad_demangle (orig);
		  return FALSE;
		}
	    }
	  else if (realp)
	    {
	      if (**pp == 'm')
		++*pp;
	      while (ISDIGIT (**pp))
		++*pp;
	      if (**pp == '.')
		{
		  ++*pp;
		  while (ISDIGIT (**pp))
		    ++*pp;
		}
	      if (**pp == 'e')
		{
		  ++*pp;
		  while (ISDIGIT (**pp))
		    ++*pp;
		}
	    }
	  else if (pointerp)
	    {
	      unsigned int len;

	      if (! stab_demangle_get_count (pp, &len))
		{
		  stab_bad_demangle (orig);
		  return FALSE;
		}
	      *pp += len;
	    }
	}
    }

  /* We can translate this to a string fairly easily by invoking the
     regular demangling routine.  */
  if (pname != NULL)
    {
      char *s1, *s2, *s3, *s4 = NULL;
      char *from, *to;

      s1 = savestring (orig, *pp - orig);

      s2 = concat ("NoSuchStrinG__", s1, (const char *) NULL);

      free (s1);

      s3 = cplus_demangle (s2, DMGL_ANSI);

      free (s2);

      if (s3 != NULL)
	s4 = strstr (s3, "::NoSuchStrinG");
      if (s3 == NULL || s4 == NULL)
	{
	  stab_bad_demangle (orig);
	  if (s3 != NULL)
	    free (s3);
	  return FALSE;
	}

      /* Eliminating all spaces, except those between > characters,
         makes it more likely that the demangled name will match the
         name which g++ used as the structure name.  */
      for (from = to = s3; from != s4; ++from)
	if (*from != ' '
	    || (from[1] == '>' && from > s3 && from[-1] == '>'))
	  *to++ = *from;

      *pname = savestring (s3, to - s3);

      free (s3);
    }

  return TRUE;
}

/* Demangle a class name.  */

static bfd_boolean
stab_demangle_class (struct stab_demangle_info *minfo ATTRIBUTE_UNUSED,
		     const char **pp, const char **pstart)
{
  const char *orig;
  unsigned int n;

  orig = *pp;

  n = stab_demangle_count (pp);
  if (strlen (*pp) < n)
    {
      stab_bad_demangle (orig);
      return FALSE;
    }

  if (pstart != NULL)
    *pstart = *pp;

  *pp += n;

  return TRUE;
}

/* Demangle function arguments.  If the pargs argument is not NULL, it
   is set to a NULL terminated array holding the arguments.  */

static bfd_boolean
stab_demangle_args (struct stab_demangle_info *minfo, const char **pp,
		    debug_type **pargs, bfd_boolean *pvarargs)
{
  const char *orig;
  unsigned int alloc, count;

  orig = *pp;

  alloc = 10;
  if (pargs != NULL)
    {
      *pargs = (debug_type *) xmalloc (alloc * sizeof **pargs);
      *pvarargs = FALSE;
    }
  count = 0;

  while (**pp != '_' && **pp != '\0' && **pp != 'e')
    {
      if (**pp == 'N' || **pp == 'T')
	{
	  char temptype;
	  unsigned int r, t;

	  temptype = **pp;
	  ++*pp;

	  if (temptype == 'T')
	    r = 1;
	  else
	    {
	      if (! stab_demangle_get_count (pp, &r))
		{
		  stab_bad_demangle (orig);
		  return FALSE;
		}
	    }

	  if (! stab_demangle_get_count (pp, &t))
	    {
	      stab_bad_demangle (orig);
	      return FALSE;
	    }

	  if (t >= minfo->typestring_count)
	    {
	      stab_bad_demangle (orig);
	      return FALSE;
	    }
	  while (r-- > 0)
	    {
	      const char *tem;

	      tem = minfo->typestrings[t].typestring;
	      if (! stab_demangle_arg (minfo, &tem, pargs, &count, &alloc))
		return FALSE;
	    }
	}
      else
	{
	  if (! stab_demangle_arg (minfo, pp, pargs, &count, &alloc))
	    return FALSE;
	}
    }

  if (pargs != NULL)
    (*pargs)[count] = DEBUG_TYPE_NULL;

  if (**pp == 'e')
    {
      if (pargs != NULL)
	*pvarargs = TRUE;
      ++*pp;
    }

  return TRUE;
}

/* Demangle a single argument.  */

static bfd_boolean
stab_demangle_arg (struct stab_demangle_info *minfo, const char **pp,
		   debug_type **pargs, unsigned int *pcount,
		   unsigned int *palloc)
{
  const char *start;
  debug_type type;

  start = *pp;
  if (! stab_demangle_type (minfo, pp,
			    pargs == NULL ? (debug_type *) NULL : &type)
      || ! stab_demangle_remember_type (minfo, start, *pp - start))
    return FALSE;

  if (pargs != NULL)
    {
      if (type == DEBUG_TYPE_NULL)
	return FALSE;

      if (*pcount + 1 >= *palloc)
	{
	  *palloc += 10;
	  *pargs = ((debug_type *)
		    xrealloc (*pargs, *palloc * sizeof **pargs));
	}
      (*pargs)[*pcount] = type;
      ++*pcount;
    }

  return TRUE;
}

/* Demangle a type.  If the ptype argument is not NULL, *ptype is set
   to the newly allocated type.  */

static bfd_boolean
stab_demangle_type (struct stab_demangle_info *minfo, const char **pp,
		    debug_type *ptype)
{
  const char *orig;

  orig = *pp;

  switch (**pp)
    {
    case 'P':
    case 'p':
      /* A pointer type.  */
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return FALSE;
      if (ptype != NULL)
	*ptype = debug_make_pointer_type (minfo->dhandle, *ptype);
      break;

    case 'R':
      /* A reference type.  */
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return FALSE;
      if (ptype != NULL)
	*ptype = debug_make_reference_type (minfo->dhandle, *ptype);
      break;

    case 'A':
      /* An array.  */
      {
	unsigned long high;

	++*pp;
	high = 0;
	while (**pp != '\0' && **pp != '_')
	  {
	    if (! ISDIGIT (**pp))
	      {
		stab_bad_demangle (orig);
		return FALSE;
	      }
	    high *= 10;
	    high += **pp - '0';
	    ++*pp;
	  }
	if (**pp != '_')
	  {
	    stab_bad_demangle (orig);
	    return FALSE;
	  }
	++*pp;

	if (! stab_demangle_type (minfo, pp, ptype))
	  return FALSE;
	if (ptype != NULL)
	  {
	    debug_type int_type;

	    int_type = debug_find_named_type (minfo->dhandle, "int");
	    if (int_type == NULL)
	      int_type = debug_make_int_type (minfo->dhandle, 4, FALSE);
	    *ptype = debug_make_array_type (minfo->dhandle, *ptype, int_type,
					    0, high, FALSE);
	  }
      }
      break;

    case 'T':
      /* A back reference to a remembered type.  */
      {
	unsigned int i;
	const char *p;

	++*pp;
	if (! stab_demangle_get_count (pp, &i))
	  {
	    stab_bad_demangle (orig);
	    return FALSE;
	  }
	if (i >= minfo->typestring_count)
	  {
	    stab_bad_demangle (orig);
	    return FALSE;
	  }
	p = minfo->typestrings[i].typestring;
	if (! stab_demangle_type (minfo, &p, ptype))
	  return FALSE;
      }
      break;

    case 'F':
      /* A function.  */
      {
	debug_type *args;
	bfd_boolean varargs;

	++*pp;
	if (! stab_demangle_args (minfo, pp,
				  (ptype == NULL
				   ? (debug_type **) NULL
				   : &args),
				  (ptype == NULL
				   ? (bfd_boolean *) NULL
				   : &varargs)))
	  return FALSE;
	if (**pp != '_')
	  {
	    /* cplus_demangle will accept a function without a return
	       type, but I don't know when that will happen, or what
	       to do if it does.  */
	    stab_bad_demangle (orig);
	    return FALSE;
	  }
	++*pp;
	if (! stab_demangle_type (minfo, pp, ptype))
	  return FALSE;
	if (ptype != NULL)
	  *ptype = debug_make_function_type (minfo->dhandle, *ptype, args,
					     varargs);

      }
      break;

    case 'M':
    case 'O':
      {
	bfd_boolean memberp, constp, volatilep;
	debug_type class_type = DEBUG_TYPE_NULL;
	debug_type *args;
	bfd_boolean varargs;
	unsigned int n;
	const char *name;

	memberp = **pp == 'M';
	constp = FALSE;
	volatilep = FALSE;
	args = NULL;
	varargs = FALSE;

	++*pp;
	if (ISDIGIT (**pp))
	  {
	    n = stab_demangle_count (pp);
	    if (strlen (*pp) < n)
	      {
		stab_bad_demangle (orig);
		return FALSE;
	      }
	    name = *pp;
	    *pp += n;

	    if (ptype != NULL)
	      {
		class_type = stab_find_tagged_type (minfo->dhandle,
						    minfo->info,
						    name, (int) n,
						    DEBUG_KIND_CLASS);
		if (class_type == DEBUG_TYPE_NULL)
		  return FALSE;
	      }
	  }
	else if (**pp == 'Q')
	  {
	    if (! stab_demangle_qualified (minfo, pp,
					   (ptype == NULL
					    ? (debug_type *) NULL
					    : &class_type)))
	      return FALSE;
	  }
	else
	  {
	    stab_bad_demangle (orig);
	    return FALSE;
	  }

	if (memberp)
	  {
	    if (**pp == 'C')
	      {
		constp = TRUE;
		++*pp;
	      }
	    else if (**pp == 'V')
	      {
		volatilep = TRUE;
		++*pp;
	      }
	    if (**pp != 'F')
	      {
		stab_bad_demangle (orig);
		return FALSE;
	      }
	    ++*pp;
	    if (! stab_demangle_args (minfo, pp,
				      (ptype == NULL
				       ? (debug_type **) NULL
				       : &args),
				      (ptype == NULL
				       ? (bfd_boolean *) NULL
				       : &varargs)))
	      return FALSE;
	  }

	if (**pp != '_')
	  {
	    stab_bad_demangle (orig);
	    return FALSE;
	  }
	++*pp;

	if (! stab_demangle_type (minfo, pp, ptype))
	  return FALSE;

	if (ptype != NULL)
	  {
	    if (! memberp)
	      *ptype = debug_make_offset_type (minfo->dhandle, class_type,
					       *ptype);
	    else
	      {
		/* FIXME: We have no way to record constp or
                   volatilep.  */
		*ptype = debug_make_method_type (minfo->dhandle, *ptype,
						 class_type, args, varargs);
	      }
	  }
      }
      break;

    case 'G':
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return FALSE;
      break;

    case 'C':
      ++*pp;
      if (! stab_demangle_type (minfo, pp, ptype))
	return FALSE;
      if (ptype != NULL)
	*ptype = debug_make_const_type (minfo->dhandle, *ptype);
      break;

    case 'Q':
      {
	const char *hold;

	hold = *pp;
	if (! stab_demangle_qualified (minfo, pp, ptype))
	  return FALSE;
      }
      break;

    default:
      if (! stab_demangle_fund_type (minfo, pp, ptype))
	return FALSE;
      break;
    }

  return TRUE;
}

/* Demangle a fundamental type.  If the ptype argument is not NULL,
   *ptype is set to the newly allocated type.  */

static bfd_boolean
stab_demangle_fund_type (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
{
  const char *orig;
  bfd_boolean constp, volatilep, unsignedp, signedp;
  bfd_boolean done;

  orig = *pp;

  constp = FALSE;
  volatilep = FALSE;
  unsignedp = FALSE;
  signedp = FALSE;

  done = FALSE;
  while (! done)
    {
      switch (**pp)
	{
	case 'C':
	  constp = TRUE;
	  ++*pp;
	  break;

	case 'U':
	  unsignedp = TRUE;
	  ++*pp;
	  break;

	case 'S':
	  signedp = TRUE;
	  ++*pp;
	  break;

	case 'V':
	  volatilep = TRUE;
	  ++*pp;
	  break;

	default:
	  done = TRUE;
	  break;
	}
    }

  switch (**pp)
    {
    case '\0':
    case '_':
      /* cplus_demangle permits this, but I don't know what it means.  */
      stab_bad_demangle (orig);
      break;

    case 'v': /* void */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "void");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_void_type (minfo->dhandle);
	}
      ++*pp;
      break;

    case 'x': /* long long */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle,
					  (unsignedp
					   ? "long long unsigned int"
					   : "long long int"));
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 8, unsignedp);
	}
      ++*pp;
      break;

    case 'l': /* long */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle,
					  (unsignedp
					   ? "long unsigned int"
					   : "long int"));
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 4, unsignedp);
	}
      ++*pp;
      break;

    case 'i': /* int */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle,
					  (unsignedp
					   ? "unsigned int"
					   : "int"));
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 4, unsignedp);
	}
      ++*pp;
      break;

    case 's': /* short */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle,
					  (unsignedp
					   ? "short unsigned int"
					   : "short int"));
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 2, unsignedp);
	}
      ++*pp;
      break;

    case 'b': /* bool */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "bool");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_bool_type (minfo->dhandle, 4);
	}
      ++*pp;
      break;

    case 'c': /* char */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle,
					  (unsignedp
					   ? "unsigned char"
					   : (signedp
					      ? "signed char"
					      : "char")));
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 1, unsignedp);
	}
      ++*pp;
      break;

    case 'w': /* wchar_t */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "__wchar_t");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_int_type (minfo->dhandle, 2, TRUE);
	}
      ++*pp;
      break;

    case 'r': /* long double */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "long double");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_float_type (minfo->dhandle, 8);
	}
      ++*pp;
      break;

    case 'd': /* double */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "double");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_float_type (minfo->dhandle, 8);
	}
      ++*pp;
      break;

    case 'f': /* float */
      if (ptype != NULL)
	{
	  *ptype = debug_find_named_type (minfo->dhandle, "float");
	  if (*ptype == DEBUG_TYPE_NULL)
	    *ptype = debug_make_float_type (minfo->dhandle, 4);
	}
      ++*pp;
      break;

    case 'G':
      ++*pp;
      if (! ISDIGIT (**pp))
	{
	  stab_bad_demangle (orig);
	  return FALSE;
	}
      /* Fall through.  */
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	const char *hold;

	if (! stab_demangle_class (minfo, pp, &hold))
	  return FALSE;
	if (ptype != NULL)
	  {
	    char *name;

	    name = savestring (hold, *pp - hold);
	    *ptype = debug_find_named_type (minfo->dhandle, name);
	    free (name);
	    if (*ptype == DEBUG_TYPE_NULL)
	      {
		/* FIXME: It is probably incorrect to assume that
                   undefined types are tagged types.  */
		*ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
						hold, *pp - hold,
						DEBUG_KIND_ILLEGAL);
		if (*ptype == DEBUG_TYPE_NULL)
		  return FALSE;
	      }
	  }
      }
      break;

    case 't':
      {
	char *name;

	if (! stab_demangle_template (minfo, pp,
				      ptype != NULL ? &name : NULL))
	  return FALSE;
	if (ptype != NULL)
	  {
	    *ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
					    name, strlen (name),
					    DEBUG_KIND_CLASS);
	    free (name);
	    if (*ptype == DEBUG_TYPE_NULL)
	      return FALSE;
	  }
      }
      break;

    default:
      stab_bad_demangle (orig);
      return FALSE;
    }

  if (ptype != NULL)
    {
      if (constp)
	*ptype = debug_make_const_type (minfo->dhandle, *ptype);
      if (volatilep)
	*ptype = debug_make_volatile_type (minfo->dhandle, *ptype);
    }

  return TRUE;
}

/* Remember a type string in a demangled string.  */

static bfd_boolean
stab_demangle_remember_type (struct stab_demangle_info *minfo,
			     const char *p, int len)
{
  if (minfo->typestring_count >= minfo->typestring_alloc)
    {
      minfo->typestring_alloc += 10;
      minfo->typestrings = ((struct stab_demangle_typestring *)
			    xrealloc (minfo->typestrings,
				      (minfo->typestring_alloc
				       * sizeof *minfo->typestrings)));
    }

  minfo->typestrings[minfo->typestring_count].typestring = p;
  minfo->typestrings[minfo->typestring_count].len = (unsigned int) len;
  ++minfo->typestring_count;

  return TRUE;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d150 4
a153 8
static char *savestring
  PARAMS ((const char *, int));
static bfd_vma parse_number
  PARAMS ((const char **, bfd_boolean *));
static void bad_stab
  PARAMS ((const char *));
static void warn_stab
  PARAMS ((const char *, const char *));
d155 1
a155 1
  PARAMS ((PTR, struct stab_handle *, int, int, bfd_vma, const char *));
d157 2
a158 4
  PARAMS ((PTR, struct stab_handle *, const char *, const char **,
	   debug_type **));
static bfd_boolean parse_stab_type_number
  PARAMS ((const char **, int *));
d160 4
a163 8
  PARAMS ((PTR, struct stab_handle *, const char *, const char **,
	   const int *));
static debug_type parse_stab_sun_builtin_type
  PARAMS ((PTR, const char **));
static debug_type parse_stab_sun_floating_type
  PARAMS ((PTR, const char **));
static debug_type parse_stab_enum_type
  PARAMS ((PTR, const char **));
d165 2
a166 2
  PARAMS ((PTR, struct stab_handle *, const char *, const char **,
	   bfd_boolean, const int *));
d168 1
a168 1
  PARAMS ((PTR, struct stab_handle *, const char **, debug_baseclass **));
d170 1
a170 2
  PARAMS ((PTR, struct stab_handle *, const char **, debug_field **,
	   bfd_boolean *));
d172 1
a172 1
  PARAMS ((PTR, struct stab_handle *, const char **, debug_field *));
d174 2
a175 2
  PARAMS ((PTR, struct stab_handle *, const char **, const char *,
	   debug_field *, bfd_boolean *));
d177 2
a178 2
  PARAMS ((PTR, struct stab_handle *, const char *, const char **,
	   const int *, debug_method **));
d180 2
a181 2
  PARAMS ((PTR, struct stab_handle *, debug_type, const char *, const char *,
	   debug_type, const char *, bfd_boolean, bfd_boolean, const char **));
d183 2
a184 2
  PARAMS ((PTR, struct stab_handle *, const char **, const int *,
	   debug_type *, bfd_boolean *));
d186 4
a189 7
  PARAMS ((PTR, struct stab_handle *, const char **, bfd_boolean));
static void push_bincl
  PARAMS ((struct stab_handle *, const char *, bfd_vma));
static const char *pop_bincl
  PARAMS ((struct stab_handle *));
static bfd_boolean find_excl
  PARAMS ((struct stab_handle *, const char *, bfd_vma));
d191 5
a195 8
  PARAMS ((PTR, struct stab_handle *, const char *, debug_type,
	   enum debug_var_kind, bfd_vma));
static bfd_boolean stab_emit_pending_vars
  PARAMS ((PTR, struct stab_handle *));
static debug_type *stab_find_slot
  PARAMS ((struct stab_handle *, const int *));
static debug_type stab_find_type
  PARAMS ((PTR, struct stab_handle *, const int *));
d197 1
a197 1
  PARAMS ((PTR, struct stab_handle *, const int *, debug_type));
d199 1
a199 1
  PARAMS ((PTR, struct stab_handle *, int));
d201 1
a201 2
  PARAMS ((PTR, struct stab_handle *, const char *, int,
	   enum debug_type_kind));
d203 6
a208 2
  PARAMS ((PTR, struct stab_handle *, const char *, bfd_boolean *,
	   unsigned int));
d213 1
a213 3
savestring (start, len)
     const char *start;
     int len;
d226 1
a226 3
parse_number (pp, poverflow)
     const char **pp;
     bfd_boolean *poverflow;
d336 1
a336 2
bad_stab (p)
     const char *p;
d344 1
a344 3
warn_stab (p, err)
     const char *p;
     const char *err;
d351 3
a353 7
PTR
start_stab (dhandle, abfd, sections, syms, symcount)
     PTR dhandle ATTRIBUTE_UNUSED;
     bfd *abfd;
     bfd_boolean sections;
     asymbol **syms;
     long symcount;
d367 1
a367 1
  return (PTR) ret;
d374 1
a374 3
finish_stab (dhandle, handle)
     PTR dhandle;
     PTR handle;
d406 2
a407 7
parse_stab (dhandle, handle, type, desc, value, string)
     PTR dhandle;
     PTR handle;
     int type;
     int desc;
     bfd_vma value;
     const char *string;
d679 2
a680 7
parse_stab_string (dhandle, info, stabtype, desc, value, string)
     PTR dhandle;
     struct stab_handle *info;
     int stabtype;
     int desc;
     bfd_vma value;
     const char *string;
d1125 1
a1125 6
parse_stab_type (dhandle, info, typename, pp, slotp)
     PTR dhandle;
     struct stab_handle *info;
     const char *typename;
     const char **pp;
     debug_type **slotp;
d1490 1
a1490 1
			  xrealloc ((PTR) args, alloc * sizeof *args));
d1598 1
a1598 3
parse_stab_type_number (pp, typenums)
     const char **pp;
     int *typenums;
d1634 1
a1634 6
parse_stab_range_type (dhandle, info, typename, pp, typenums)
     PTR dhandle;
     struct stab_handle *info;
     const char *typename;
     const char **pp;
     const int *typenums;
d1818 1
a1818 3
parse_stab_sun_builtin_type (dhandle, pp)
     PTR dhandle;
     const char **pp;
d1889 1
a1889 3
parse_stab_sun_floating_type (dhandle, pp)
     PTR dhandle;
     const char **pp;
d1925 1
a1925 3
parse_stab_enum_type (dhandle, pp)
     PTR dhandle;
     const char **pp;
d1978 1
a1978 1
		   xrealloc ((PTR) names, alloc * sizeof *names));
d1980 1
a1980 1
		    xrealloc ((PTR) values, alloc * sizeof *values));
d2001 1
a2001 1
   in the the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
d2005 3
a2007 7
parse_stab_struct_type (dhandle, info, tagname, pp, structp, typenums)
     PTR dhandle;
     struct stab_handle *info;
     const char *tagname;
     const char **pp;
     bfd_boolean structp;
     const int *typenums;
d2054 1
a2054 1
   						       ^^ ^ ^ ^  ^ ^  ^
d2067 2
a2068 5
parse_stab_baseclasses (dhandle, info, pp, retp)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     debug_baseclass **retp;
d2171 1
a2171 1
   	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;
d2180 1
a2180 1
   	'/0'	(VISIBILITY_PRIVATE)
d2190 3
a2192 6
parse_stab_struct_fields (dhandle, info, pp, retp, staticsp)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     debug_field **retp;
     bfd_boolean *staticsp;
d2219 1
a2219 1
		    xrealloc ((PTR) fields, alloc * sizeof *fields));
d2270 2
a2271 5
parse_stab_cpp_abbrev (dhandle, info, pp, retp)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     debug_field *retp;
d2362 3
a2364 7
parse_stab_one_struct_field (dhandle, info, pp, p, retp, staticsp)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     const char *p;
     debug_field *retp;
     bfd_boolean *staticsp;
d2496 3
a2498 7
parse_stab_members (dhandle, info, tagname, pp, typenums, retp)
     PTR dhandle;
     struct stab_handle *info;
     const char *tagname;
     const char **pp;
     const int *typenums;
     debug_method **retp;
d2534 1
a2534 1
	  /* This is a completely wierd case.  In order to stuff in the
d2758 1
a2758 1
			  xrealloc ((PTR) variants,
d2790 1
a2790 1
		     xrealloc ((PTR) methods, alloc * sizeof *methods));
d2813 5
a2817 12
parse_stab_argtypes (dhandle, info, class_type, fieldname, tagname,
		     return_type, argtypes, constp, volatilep, pphysname)
     PTR dhandle;
     struct stab_handle *info;
     debug_type class_type;
     const char *fieldname;
     const char *tagname;
     debug_type return_type;
     const char *argtypes;
     bfd_boolean constp;
     bfd_boolean volatilep;
     const char **pphysname;
d2935 3
a2937 7
parse_stab_tilde_field (dhandle, info, pp, typenums, retvptrbase, retownvptr)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     const int *typenums;
     debug_type *retvptrbase;
     bfd_boolean *retownvptr;
d3007 2
a3008 5
parse_stab_array_type (dhandle, info, pp, stringp)
     PTR dhandle;
     struct stab_handle *info;
     const char **pp;
     bfd_boolean stringp;
d3124 1
a3124 4
push_bincl (info, name, hash)
     struct stab_handle *info;
     const char *name;
     bfd_vma hash;
d3140 1
a3140 1
		      xrealloc ((PTR) info->file_types,
d3150 1
a3150 2
pop_bincl (info)
     struct stab_handle *info;
d3169 1
a3169 4
find_excl (info, name, hash)
     struct stab_handle *info;
     const char *name;
     bfd_vma hash;
d3175 1
a3175 1
		      xrealloc ((PTR) info->file_types,
d3200 3
a3202 7
stab_record_variable (dhandle, info, name, type, kind, val)
     PTR dhandle;
     struct stab_handle *info;
     const char *name;
     debug_type type;
     enum debug_var_kind kind;
     bfd_vma val;
d3228 1
a3228 3
stab_emit_pending_vars (dhandle, info)
     PTR dhandle;
     struct stab_handle *info;
d3253 1
a3253 3
stab_find_slot (info, typenums)
     struct stab_handle *info;
     const int *typenums;
d3298 1
a3298 4
stab_find_type (dhandle, info, typenums)
     PTR dhandle;
     struct stab_handle *info;
     const int *typenums;
d3321 2
a3322 5
stab_record_type (dhandle, info, typenums, type)
     PTR dhandle ATTRIBUTE_UNUSED;
     struct stab_handle *info;
     const int *typenums;
     debug_type type;
d3340 2
a3341 4
stab_xcoff_builtin_type (dhandle, info, typenum)
     PTR dhandle;
     struct stab_handle *info;
     int typenum;
d3517 2
a3518 6
stab_find_tagged_type (dhandle, info, p, len, kind)
     PTR dhandle;
     struct stab_handle *info;
     const char *p;
     int len;
     enum debug_type_kind kind;
d3593 1
a3593 1
  PTR dhandle;
d3608 3
a3610 6
static void stab_bad_demangle
  PARAMS ((const char *));
static unsigned int stab_demangle_count
  PARAMS ((const char **));
static bfd_boolean stab_demangle_get_count
  PARAMS ((const char **, unsigned int *));
d3612 1
a3612 1
  PARAMS ((struct stab_demangle_info *, const char **, unsigned int));
d3614 1
a3614 1
  PARAMS ((struct stab_demangle_info *, const char **, const char *));
d3616 1
a3616 1
  PARAMS ((struct stab_demangle_info *, const char **));
d3618 1
a3618 1
  PARAMS ((struct stab_demangle_info *, const char **, debug_type *));
d3620 1
a3620 1
  PARAMS ((struct stab_demangle_info *, const char **, char **));
d3622 1
a3622 1
  PARAMS ((struct stab_demangle_info *, const char **, const char **));
d3624 1
a3624 2
  PARAMS ((struct stab_demangle_info *, const char **, debug_type **,
	   bfd_boolean *));
d3626 2
a3627 2
  PARAMS ((struct stab_demangle_info *, const char **, debug_type **,
	   unsigned int *, unsigned int *));
d3629 1
a3629 1
  PARAMS ((struct stab_demangle_info *, const char **, debug_type *));
d3631 1
a3631 1
  PARAMS ((struct stab_demangle_info *, const char **, debug_type *));
d3633 1
a3633 1
  PARAMS ((struct stab_demangle_info *, const char *, int));
d3638 1
a3638 2
stab_bad_demangle (s)
     const char *s;
d3646 1
a3646 2
stab_demangle_count (pp)
     const char **pp;
d3664 1
a3664 3
stab_demangle_get_count (pp, pi)
     const char **pp;
     unsigned int *pi;
d3699 3
a3701 6
stab_demangle_argtypes (dhandle, info, physname, pvarargs, physname_len)
     PTR dhandle;
     struct stab_handle *info;
     const char *physname;
     bfd_boolean *pvarargs;
     unsigned int physname_len;
d3745 2
a3746 4
stab_demangle_prefix (minfo, pp, physname_len)
     struct stab_demangle_info *minfo;
     const char **pp;
     unsigned int physname_len;
d3822 2
a3823 4
stab_demangle_function_name (minfo, pp, scan)
     struct stab_demangle_info *minfo;
     const char **pp;
     const char *scan;
d3866 1
a3866 3
stab_demangle_signature (minfo, pp)
     struct stab_demangle_info *minfo;
     const char **pp;
d3980 2
a3981 4
stab_demangle_qualified (minfo, pp, ptype)
     struct stab_demangle_info *minfo;
     const char **pp;
     debug_type *ptype;
d4151 2
a4152 4
stab_demangle_template (minfo, pp, pname)
     struct stab_demangle_info *minfo;
     const char **pp;
     char **pname;
d4372 2
a4373 4
stab_demangle_class (minfo, pp, pstart)
     struct stab_demangle_info *minfo ATTRIBUTE_UNUSED;
     const char **pp;
     const char **pstart;
d4399 2
a4400 5
stab_demangle_args (minfo, pp, pargs, pvarargs)
     struct stab_demangle_info *minfo;
     const char **pp;
     debug_type **pargs;
     bfd_boolean *pvarargs;
d4479 3
a4481 6
stab_demangle_arg (minfo, pp, pargs, pcount, palloc)
     struct stab_demangle_info *minfo;
     const char **pp;
     debug_type **pargs;
     unsigned int *pcount;
     unsigned int *palloc;
d4514 2
a4515 4
stab_demangle_type (minfo, pp, ptype)
     struct stab_demangle_info *minfo;
     const char **pp;
     debug_type *ptype;
d4781 2
a4782 4
stab_demangle_fund_type (minfo, pp, ptype)
     struct stab_demangle_info *minfo;
     const char **pp;
     debug_type *ptype;
d5035 2
a5036 4
stab_demangle_remember_type (minfo, p, len)
     struct stab_demangle_info *minfo;
     const char *p;
     int len;
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
a28 1
#include <ctype.h>
d33 1
a37 4

/* Meaningless definition needs by aout64.h.  FIXME.  */
#define BYTES_IN_WORD 4

d52 2
a53 2
  /* True if this is stabs in sections.  */
  boolean sections;
d73 1
a73 1
  boolean n_opt_found;
d81 1
a81 1
  boolean within_function;
d100 1
a100 1
  boolean self_crossref;
d150 9
a158 5
static char *savestring PARAMS ((const char *, int));
static bfd_vma parse_number PARAMS ((const char **, boolean *));
static void bad_stab PARAMS ((const char *));
static void warn_stab PARAMS ((const char *, const char *));
static boolean parse_stab_string
d163 1
a163 1
static boolean parse_stab_type_number
d168 2
a169 1
static debug_type parse_stab_sun_builtin_type PARAMS ((PTR, const char **));
d172 2
a173 1
static debug_type parse_stab_enum_type PARAMS ((PTR, const char **));
d175 3
a177 3
  PARAMS ((PTR, struct stab_handle *, const char *, const char **, boolean,
	   const int *));
static boolean parse_stab_baseclasses
d179 1
a179 1
static boolean parse_stab_struct_fields
d181 2
a182 2
	   boolean *));
static boolean parse_stab_cpp_abbrev
d184 1
a184 1
static boolean parse_stab_one_struct_field
d186 2
a187 2
	   debug_field *, boolean *));
static boolean parse_stab_members
d192 2
a193 2
	   debug_type, const char *, boolean, boolean, const char **));
static boolean parse_stab_tilde_field
d195 1
a195 1
	   debug_type *, boolean *));
d197 6
a202 4
  PARAMS ((PTR, struct stab_handle *, const char **, boolean));
static void push_bincl PARAMS ((struct stab_handle *, const char *, bfd_vma));
static const char *pop_bincl PARAMS ((struct stab_handle *));
static boolean find_excl
d204 1
a204 1
static boolean stab_record_variable
d207 2
a208 1
static boolean stab_emit_pending_vars PARAMS ((PTR, struct stab_handle *));
d213 1
a213 1
static boolean stab_record_type
d221 2
a222 1
  PARAMS ((PTR, struct stab_handle *, const char *, boolean *));
d244 1
a244 1
     boolean *poverflow;
d250 1
a250 1
    *poverflow = false;
a267 1

d271 1
a271 1
      boolean neg;
d274 1
a274 1
      boolean overflow;
a277 1

d280 1
a280 1
      neg = false;
d285 1
a285 1
	  neg = true;
d307 1
a307 1
      overflow = false;
d314 1
a314 1
	  if (isdigit ((unsigned char) d))
d316 1
a316 1
	  else if (isupper ((unsigned char) d))
d318 1
a318 1
	  else if (islower ((unsigned char) d))
d328 1
a328 1
	      overflow = true;
a342 1

d344 1
a344 1
    *poverflow = true;
a371 1
/*ARGSUSED*/
d376 1
a376 1
     boolean sections;
d398 1
a398 1
boolean
d410 2
a411 2
	return false;
      info->within_function = false;
d424 1
a424 1
	return false;
d427 1
a427 1
  return true;
d432 1
a432 1
boolean
d451 1
a451 1
	return false;
d455 1
a455 1
      info->n_opt_found = false;
d489 1
a489 1
	  return false;
d497 1
a497 1
	return false;
d501 1
a501 1
	return false;
d515 1
a515 1
	return false;
d522 1
a522 1
	return false;
d528 1
a528 1
	  return false;
d545 2
a546 2
	    return false;
	  info->within_function = false;
d553 1
a553 1
	return true;
d567 1
a567 1
          if (IS_ABSOLUTE_PATH (string))
d582 1
a582 1
	return false;
d589 1
a589 1
	return false;
d595 1
a595 1
	return false;
d602 1
a602 1
	return false;
d607 3
a609 2
			       value + info->function_start_offset))
	return false;
d614 1
a614 1
	return false;
d619 1
a619 1
	return false;
d633 2
a634 2
		return false;
	      info->within_function = false;
d674 1
a674 1
		  return false;
d681 1
a681 1
	    info->within_function = true;
d685 1
a685 1
	  return false;
d695 1
a695 1
	info->n_opt_found = true;
d705 1
a705 1
  return true;
d710 1
a710 1
static boolean
d723 2
a724 2
  boolean synonym;
  boolean self_crossref;
d730 1
a730 1
    return true;
d739 1
a739 1
	  return false;
d787 1
a787 1
  if (isdigit ((unsigned char) *p) || *p == '(' || *p == '-')
d804 1
a804 1
	  return false;
d812 1
a812 1
	    return false;
d823 1
a823 1
	    return false;
d833 1
a833 1
	    return false;
d837 1
a837 1
	      return false;
d840 1
a840 1
	    return false;
d844 1
a844 1
	  return false;
d854 1
a854 1
	return false;
d856 1
a856 1
	return false;
d865 1
a865 1
	return false;
d867 1
a867 1
	return false;
d879 1
a879 1
	    return false;
d895 1
a895 1
	  return false;
d911 1
a911 1
	  return false;
d923 1
a923 1
	return false;
d926 1
a926 1
	return false;
d947 1
a947 1
						(debug_type *) NULL, false);
d952 1
a952 1
	return false;
d955 1
a955 1
	return false;
a960 1

d973 1
a973 1
		return false;
d983 1
a983 1
	return false;
d986 1
a986 1
	return false;
d994 1
a994 1
	return false;
d997 1
a997 1
	return false;
a1000 1

d1004 1
a1004 1
      /* Static symbol at top level of file */
d1008 1
a1008 1
	return false;
d1011 1
a1011 1
	return false;
d1018 1
a1018 1
	return false;
d1022 1
a1022 1
	  return true;
d1027 1
a1027 1
	return false;
d1039 2
a1040 2
	  synonym = false;
	  /* FIXME: gdb sets synonym to true if the current language
d1045 1
a1045 1
	  synonym = true;
d1051 1
a1051 1
	return false;
d1053 1
a1053 1
	return true;
d1062 1
a1062 1
	return false;
d1089 1
a1089 1
	    return false;
d1102 1
a1102 1
	return false;
d1106 1
a1106 1
	return false;
d1114 1
a1114 1
	return false;
d1117 1
a1117 1
	return false;
d1125 1
a1125 1
	return false;
d1128 1
a1128 1
	return false;
d1139 1
a1139 1
	return false;
d1142 1
a1142 1
	return false;
d1147 1
a1147 1
      return false;
d1153 1
a1153 1
  return true;
d1172 1
a1172 1
  boolean stringp;
d1182 1
a1182 1
  stringp = false;
d1184 1
a1184 1
  info->self_crossref = false;
d1189 1
a1189 1
  if (! isdigit ((unsigned char) **pp) && **pp != '(' && **pp != '-')
d1201 3
a1203 5
	{
	  /* Type is not being defined here.  Either it already
	     exists, or this is a forward reference to it.  */
	  return stab_find_type (dhandle, info, typenums);
	}
d1230 3
a1232 5
	  if (isdigit ((unsigned char) *p) || *p == '(' || *p == '-')
	    {
	      /* Member type.  */
	      break;
	    }
d1257 1
a1257 1
	      stringp = true;
a1278 1

d1334 1
a1334 1
	  info->self_crossref = true;
a1358 1

d1417 1
a1417 1
		(debug_type *) NULL, false));
d1488 1
a1488 1
					  (debug_type *) NULL, false);
d1497 1
a1497 1
	  boolean varargs;
d1548 1
a1548 1
	    varargs = true;
d1552 1
a1552 1
	      varargs = false;
d1639 1
a1639 1
static boolean
d1651 1
a1651 1
      typenums[1] = (int) parse_number (pp, (boolean *) NULL);
d1656 1
a1656 1
      typenums[0] = (int) parse_number (pp, (boolean *) NULL);
d1660 1
a1660 1
	  return false;
d1663 1
a1663 1
      typenums[1] = (int) parse_number (pp, (boolean *) NULL);
d1667 1
a1667 1
	  return false;
d1672 1
a1672 1
  return true;
d1687 1
a1687 1
  boolean self_subrange;
d1691 1
a1691 1
  boolean ov2, ov3;
d1741 2
a1742 2
#define LLLOW  "01000000000000000000000;"
#define LLHIGH "0777777777777777777777;"
d1748 1
a1748 1
	    return debug_make_int_type (dhandle, 8, false);
d1752 1
a1752 1
	    return debug_make_int_type (dhandle, 8, true);
d1785 1
a1785 1
		return debug_make_int_type (dhandle, 8, false);
d1787 1
a1787 1
		return debug_make_int_type (dhandle, 8, true);
d1790 1
a1790 1
	  return debug_make_int_type (dhandle, 4, true);
d1795 1
a1795 1
	return debug_make_int_type (dhandle, 1, false);
d1802 1
a1802 1
	    return debug_make_int_type (dhandle, - n3, true);
d1804 1
a1804 1
	    return debug_make_int_type (dhandle, 1, true);
d1806 1
a1806 1
	    return debug_make_int_type (dhandle, 2, true);
d1808 1
a1808 1
	    return debug_make_int_type (dhandle, 4, true);
d1811 1
a1811 1
	    return debug_make_int_type (dhandle, 8, true);
d1817 1
a1817 1
	return debug_make_int_type (dhandle, - n2, true);
d1821 1
a1821 1
	    return debug_make_int_type (dhandle, 1, false);
d1823 1
a1823 1
	    return debug_make_int_type (dhandle, 2, false);
d1825 1
a1825 1
	    return debug_make_int_type (dhandle, 4, false);
d1828 1
a1828 1
	    return debug_make_int_type (dhandle, 8, false);
d1848 1
a1848 1
      index_type = debug_make_int_type (dhandle, 4, false);
d1872 1
a1872 1
  boolean unsignedp;
d1880 1
a1880 1
      unsignedp = false;
d1883 1
a1883 1
      unsignedp = true;
d1902 1
a1902 1
  (void) parse_number (pp, (boolean *) NULL);
d1910 2
a1911 2
  /* The second number is always 0, so ignore it too. */
  (void) parse_number (pp, (boolean *) NULL);
d1919 2
a1920 2
  /* The third number is the number of bits for this type. */
  bits = parse_number (pp, (boolean *) NULL);
d1952 1
a1952 1
  details = parse_number (pp, (boolean *) NULL);
d1960 1
a1960 1
  bytes = parse_number (pp, (boolean *) NULL);
d1972 1
a1972 1
  return debug_make_float_type (dhandle, bytes);      
d2021 1
a2021 1
      val = (bfd_signed_vma) parse_number (pp, (boolean *) NULL);
d2065 1
a2065 1
     boolean structp;
d2072 1
a2072 1
  boolean statics;
d2075 1
a2075 1
  boolean ownvptr;
d2080 1
a2080 1
  size = parse_number (pp, (boolean *) NULL);
d2123 1
a2123 1
  Return true for success, false for failure.  */
d2125 1
a2125 1
static boolean
d2143 1
a2143 1
      return true;
d2147 1
a2147 1
  c = (unsigned int) parse_number (pp, (boolean *) NULL);
d2152 1
a2152 1
      return false;
d2160 1
a2160 1
      boolean virtual;
d2168 1
a2168 1
	  virtual = false;
d2171 1
a2171 1
	  virtual = true;
d2175 1
a2175 1
	  virtual = false;
d2201 1
a2201 1
      bitpos = parse_number (pp, (boolean *) NULL);
d2205 1
a2205 1
	  return false;
d2212 1
a2212 1
	return false;
d2217 1
a2217 1
	return false;
d2220 1
a2220 1
	return false;
d2228 1
a2228 1
  return true;
d2251 1
a2251 1
static boolean
d2257 1
a2257 1
     boolean *staticsp;
d2266 1
a2266 1
  *staticsp = false;
d2298 1
a2298 1
	    return false;
d2306 1
a2306 1
	 functions (if any), terminate scan loop and return. */
d2312 1
a2312 1
	  return false;
d2320 1
a2320 1
	return false;
d2329 1
a2329 1
  return true;
d2334 1
a2334 1
static boolean
d2356 1
a2356 1
      return false;
d2371 1
a2371 1
    return false;
d2398 1
a2398 1
      return false;
d2407 1
a2407 1
      return false;
d2411 1
a2411 1
  bitpos = parse_number (pp, (boolean *) NULL);
d2415 1
a2415 1
      return false;
d2422 1
a2422 1
    return false;
d2424 1
a2424 1
  return true;
d2429 1
a2429 1
static boolean
d2436 1
a2436 1
     boolean *staticsp;
d2480 1
a2480 1
    return false;
d2492 1
a2492 1
	  return false;
d2501 1
a2501 1
      *staticsp = true;
d2503 1
a2503 1
      return true;
d2509 1
a2509 1
      return false;
d2513 1
a2513 1
  bitpos = parse_number (pp, (boolean *) NULL);
d2517 1
a2517 1
      return false;
d2521 1
a2521 1
  bitsize = parse_number (pp, (boolean *) NULL);
d2525 1
a2525 1
      return false;
d2551 1
a2551 1
  return true;
d2567 1
a2567 1
static boolean
d2622 1
a2622 1
	      return false;
d2638 1
a2638 1
	  boolean stub;
d2641 1
a2641 1
	  boolean constp, volatilep, staticp;
d2645 1
a2645 1
	  boolean varargs;
d2658 1
a2658 1
		return false;
d2662 1
a2662 1
		  return false;
d2671 1
a2671 1
	      return false;
d2674 1
a2674 1
	  stub = false;
d2677 1
a2677 1
	    stub = true;
d2696 2
a2697 2
	  constp = false;
	  volatilep = false;
d2706 1
a2706 1
	      constp = true;
d2711 1
a2711 1
	      volatilep = true;
d2716 2
a2717 2
	      constp = true;
	      volatilep = true;
d2730 1
a2730 1
	  staticp = false;
d2738 1
a2738 1
	      voffset = parse_number (pp, (boolean *) NULL);
d2742 1
a2742 1
		  return false;
d2757 21
a2777 21
		    look_ahead_type = parse_stab_type (dhandle, info,
						       (const char *) NULL,
						       pp,
						       (debug_type **) NULL);
		    if (**pp == ':')
		      {
			/* g++ version 1 overloaded methods.  */
			context = DEBUG_TYPE_NULL;
		      }
		    else
		      {
			context = look_ahead_type;
			look_ahead_type = DEBUG_TYPE_NULL;
			if (**pp != ';')
			  {
			    bad_stab (orig);
			    return false;
			  }
			++*pp;
		      }
		  }
d2783 1
a2783 1
	      staticp = true;
d2787 1
a2787 1
		stub = true;
d2816 1
a2816 1
		return false;
d2821 1
a2821 1
		  return false;
d2827 1
a2827 1
		return false;
d2851 1
a2851 1
	    return false;
d2879 1
a2879 1
  return true;
d2898 2
a2899 2
     boolean constp;
     boolean volatilep;
d2902 3
a2904 3
  boolean is_full_physname_constructor;
  boolean is_constructor;
  boolean is_destructor;
d2906 2
a2907 1
  boolean varargs;
d2912 1
a2912 1
				   && (isdigit ((unsigned char) argtypes[2])
d2984 1
d2998 1
a2998 1
				     false);
d3001 1
a3001 1
  args = stab_demangle_argtypes (dhandle, info, *pphysname, &varargs);
d3017 1
a3017 1
static boolean
d3024 1
a3024 1
     boolean *retownvptr;
d3031 1
a3031 1
  *retownvptr = false;
d3035 1
a3035 1
  /* If we are positioned at a ';', then skip it. */
d3040 1
a3040 1
    return true;
d3047 1
a3047 1
	 constructors and/or destructors. */
d3052 1
a3052 1
    return true;
d3061 1
a3061 1
    return false;
d3065 1
a3065 1
    *retownvptr = true;
d3080 1
a3080 1
	  return false;
d3088 1
a3088 1
  return true;    
d3098 1
a3098 1
     boolean stringp;
d3104 1
a3104 1
  boolean adjustable;
d3128 1
a3128 1
	  index_type = debug_make_int_type (dhandle, 4, false);
d3147 1
a3147 1
  adjustable = false;
d3149 1
a3149 1
  if (! isdigit ((unsigned char) **pp) && **pp != '-')
d3152 1
a3152 1
      adjustable = true;
d3155 1
a3155 1
  lower = (bfd_signed_vma) parse_number (pp, (boolean *) NULL);
d3163 1
a3163 1
  if (! isdigit ((unsigned char) **pp) && **pp != '-')
d3166 1
a3166 1
      adjustable = true;
d3169 1
a3169 1
  upper = (bfd_signed_vma) parse_number (pp, (boolean *) NULL);
d3262 1
a3262 1
static boolean
d3283 1
a3283 1
      return true;
d3288 1
a3288 1
  return true;
d3296 1
a3296 1
static boolean
d3322 1
a3322 1
  return true;
d3328 1
a3328 1
static boolean
d3341 1
a3341 1
	return false;
d3350 1
a3350 1
  return true;
d3428 1
a3428 1
static boolean
d3439 1
a3439 1
    return false;
d3445 1
a3445 1
  return true;
d3473 1
a3473 1
      rettype = debug_make_int_type (dhandle, 4, false);
d3477 1
a3477 1
      rettype = debug_make_int_type (dhandle, 1, false);
d3481 1
a3481 1
      rettype = debug_make_int_type (dhandle, 2, false);
d3485 1
a3485 1
      rettype = debug_make_int_type (dhandle, 4, false);
d3489 1
a3489 1
      rettype = debug_make_int_type (dhandle, 1, true);
d3493 1
a3493 1
      rettype = debug_make_int_type (dhandle, 1, false);
d3497 1
a3497 1
      rettype = debug_make_int_type (dhandle, 2, true);
d3501 1
a3501 1
      rettype = debug_make_int_type (dhandle, 4, true);
d3505 1
a3505 1
      rettype = debug_make_int_type (dhandle, 4, true);
d3508 1
a3508 1
      rettype = debug_make_int_type (dhandle, 4, true);
d3533 1
a3533 1
      rettype = debug_make_int_type (dhandle, 4, false);
d3555 1
a3555 1
      rettype = debug_make_int_type (dhandle, 1, true);
d3585 1
a3585 1
      rettype = debug_make_int_type (dhandle, 1, false);
d3589 1
a3589 1
      rettype = debug_make_int_type (dhandle, 2, false);
d3593 1
a3593 1
      rettype = debug_make_int_type (dhandle, 4, false);
d3598 1
a3598 1
      rettype = debug_make_int_type (dhandle, 2, false);
d3602 1
a3602 1
      rettype = debug_make_int_type (dhandle, 8, false);
d3606 1
a3606 1
      rettype = debug_make_int_type (dhandle, 8, true);
d3614 1
a3614 1
      rettype = debug_make_int_type (dhandle, 8, false);
d3716 1
a3716 1
  boolean varargs;
d3725 5
a3729 3
static void stab_bad_demangle PARAMS ((const char *));
static unsigned int stab_demangle_count PARAMS ((const char **));
static boolean stab_demangle_get_count
d3731 3
a3733 3
static boolean stab_demangle_prefix
  PARAMS ((struct stab_demangle_info *, const char **));
static boolean stab_demangle_function_name
d3735 1
a3735 1
static boolean stab_demangle_signature
d3737 1
a3737 1
static boolean stab_demangle_qualified
d3739 1
a3739 1
static boolean stab_demangle_template
d3741 1
a3741 1
static boolean stab_demangle_class
d3743 1
a3743 1
static boolean stab_demangle_args
d3745 2
a3746 2
	   boolean *));
static boolean stab_demangle_arg
d3749 1
a3749 1
static boolean stab_demangle_type
d3751 1
a3751 1
static boolean stab_demangle_fund_type
d3753 1
a3753 1
static boolean stab_demangle_remember_type
d3774 1
a3774 1
  while (isdigit ((unsigned char) **pp))
d3786 1
a3786 1
static boolean
d3791 2
a3792 2
  if (! isdigit ((unsigned char) **pp))
    return false;
d3796 1
a3796 1
  if (isdigit ((unsigned char) **pp))
d3809 1
a3809 1
      while (isdigit ((unsigned char) *p));
d3817 1
a3817 1
  return true;
d3824 1
a3824 1
stab_demangle_argtypes (dhandle, info, physname, pvarargs)
d3828 2
a3829 1
     boolean *pvarargs;
d3836 1
a3836 1
  minfo.varargs = false;
d3846 1
a3846 1
  if (! stab_demangle_prefix (&minfo, &physname))
d3872 2
a3873 2
static boolean
stab_demangle_prefix (minfo, pp)
d3876 1
d3884 3
a3886 3
  /* Look for `__'.  */
  scan = *pp;
  do
d3888 5
a3892 3
      scan = strchr (scan, '_');
    }
  while (scan != NULL && *++scan != '_');
d3894 5
a3898 5
  if (scan == NULL)
    {
      stab_bad_demangle (*pp);
      return false;
    }
d3900 1
a3900 1
  --scan;
d3902 5
a3906 4
  /* We found `__'; move ahead to the last contiguous `__' pair.  */
  i = strspn (scan, "_");
  if (i > 2)
    scan += i - 2;
d3909 1
a3909 1
      && (isdigit ((unsigned char) scan[2])
d3915 1
a3915 1
      return true;
d3918 1
a3918 1
	   && ! isdigit ((unsigned char) scan[2])
d3929 1
a3929 1
	  return false;
d3942 1
a3942 1
      return false;
d3951 1
a3951 1
static boolean
d3976 1
a3976 1
	return false;
d3988 1
a3988 1
	return false;
d3991 1
a3991 1
  return true;
d3997 1
a3997 1
static boolean
d4003 1
a4003 1
  boolean expect_func, func_done;
d4008 2
a4009 2
  expect_func = false;
  func_done = false;
d4020 2
a4021 2
	    return false;
	  expect_func = true;
d4045 2
a4046 2
	    return false;
	  expect_func = true;
d4054 1
a4054 1
	  func_done = true;
d4057 1
a4057 1
	    return false;
d4066 1
a4066 1
	    return false;
d4068 1
a4068 1
	  expect_func = true;
d4078 1
a4078 1
	  return false;
d4083 1
a4083 1
	  func_done = true;
d4085 1
a4085 1
	    return false;
d4091 1
a4091 1
	  func_done = true;
d4093 1
a4093 1
	    return false;
d4104 1
a4104 1
	return false;
d4107 1
a4107 1
  return true;
d4113 1
a4113 1
static boolean
d4133 1
a4133 1
      if (! isdigit ((unsigned char) *p) || *p == '0')
d4136 1
a4136 1
	  return false;
d4139 1
a4139 1
      while (isdigit ((unsigned char) *p))
d4144 1
a4144 1
	  return false;
d4161 1
a4161 1
      return false;
d4177 1
a4177 1
	    return false;
d4186 1
a4186 1
		return false;
d4197 1
a4197 1
	      return false;
d4231 1
a4231 1
			return false;
d4268 1
a4268 1
			return false;
d4280 1
a4280 1
  return true;
d4286 1
a4286 1
static boolean
d4304 1
a4304 1
      return false;
d4312 1
a4312 1
      return false;
d4322 1
a4322 1
	    return false;
d4327 2
a4328 2
	  boolean pointerp, realp, integralp, charp, boolp;
	  boolean done;
d4331 6
a4336 6
	  pointerp = false;
	  realp = false;
	  integralp = false;
	  charp = false;
	  boolp = false;
	  done = false;
d4341 1
a4341 1
	    return false;
d4350 2
a4351 2
		  pointerp = true;
		  done = true;
d4363 2
a4364 2
		  integralp = true;
		  done = true;
d4375 2
a4376 2
		  integralp = true;
		  done = true;
d4379 2
a4380 2
		  boolp = true;
		  done = true;
d4383 2
a4384 2
		  charp = true;
		  done = true;
d4389 2
a4390 2
		  realp = true;
		  done = true;
d4394 2
a4395 2
		  integralp = true;
		  done = true;
d4404 1
a4404 1
	      while (isdigit ((unsigned char) **pp))
d4417 1
a4417 1
		  return false;
d4428 1
a4428 1
		  return false;
d4435 1
a4435 1
	      while (isdigit ((unsigned char) **pp))
d4440 1
a4440 1
		  while (isdigit ((unsigned char) **pp))
d4446 1
a4446 1
		  while (isdigit ((unsigned char) **pp))
d4457 1
a4457 1
		  return false;
d4468 1
a4468 1
      char *s1, *s2, *s3, *s4;
d4488 1
a4488 1
	  return false;
d4504 1
a4504 1
  return true;
d4509 1
a4509 1
static boolean
d4524 1
a4524 1
      return false;
d4532 1
a4532 1
  return true;
d4538 1
a4538 1
static boolean
d4543 1
a4543 1
     boolean *pvarargs;
d4554 1
a4554 1
      *pvarargs = false;
d4575 1
a4575 1
		  return false;
d4582 1
a4582 1
	      return false;
d4588 1
a4588 1
	      return false;
d4596 1
a4596 1
		return false;
d4602 1
a4602 1
	    return false;
d4612 1
a4612 1
	*pvarargs = true;
d4616 1
a4616 1
  return true;
d4621 1
a4621 1
static boolean
d4636 1
a4636 1
    return false;
d4641 1
a4641 1
	return false;
d4653 1
a4653 1
  return true;
d4659 1
a4659 1
static boolean
d4676 1
a4676 1
	return false;
d4685 1
a4685 1
	return false;
d4699 1
a4699 1
	    if (! isdigit ((unsigned char) **pp))
d4702 1
a4702 1
		return false;
d4711 1
a4711 1
	    return false;
d4716 1
a4716 1
	  return false;
d4723 1
a4723 1
	      int_type = debug_make_int_type (minfo->dhandle, 4, false);
d4725 1
a4725 1
					    0, high, false);
d4740 1
a4740 1
	    return false;
d4745 1
a4745 1
	    return false;
d4749 1
a4749 1
	  return false;
d4757 1
a4757 1
	boolean varargs;
d4765 1
a4765 1
				   ? (boolean *) NULL
d4767 1
a4767 1
	  return false;
d4774 1
a4774 1
	    return false;
d4778 1
a4778 1
	  return false;
d4789 1
a4789 1
	boolean memberp, constp, volatilep;
d4792 1
a4792 1
	boolean varargs;
d4797 2
a4798 2
	constp = false;
	volatilep = false;
d4800 1
a4800 1
	varargs = false;
d4803 1
a4803 1
	if (isdigit ((unsigned char) **pp))
d4809 1
a4809 1
		return false;
d4821 1
a4821 1
		  return false;
d4830 1
a4830 1
	      return false;
d4835 1
a4835 1
	    return false;
d4842 1
a4842 1
		constp = true;
d4847 1
a4847 1
		volatilep = true;
d4853 1
a4853 1
		return false;
d4861 1
a4861 1
				       ? (boolean *) NULL
d4863 1
a4863 1
	      return false;
d4869 1
a4869 1
	    return false;
d4874 1
a4874 1
	  return false;
d4895 1
a4895 1
	return false;
d4901 1
a4901 1
	return false;
d4912 1
a4912 1
	  return false;
d4918 1
a4918 1
	return false;
d4922 1
a4922 1
  return true;
d4928 1
a4928 1
static boolean
d4935 2
a4936 2
  boolean constp, volatilep, unsignedp, signedp;
  boolean done;
d4940 4
a4943 4
  constp = false;
  volatilep = false;
  unsignedp = false;
  signedp = false;
d4945 1
a4945 1
  done = false;
d4951 1
a4951 1
	  constp = true;
d4956 1
a4956 1
	  unsignedp = true;
d4961 1
a4961 1
	  signedp = true;
d4966 1
a4966 1
	  volatilep = true;
d4971 1
a4971 1
	  done = true;
d5076 1
a5076 1
	    *ptype = debug_make_int_type (minfo->dhandle, 2, true);
d5113 1
a5113 1
      if (! isdigit ((unsigned char) **pp))
d5116 1
a5116 1
	  return false;
d5125 1
a5125 1
	  return false;
d5141 1
a5141 1
		  return false;
d5153 1
a5153 1
	  return false;
d5161 1
a5161 1
	      return false;
d5168 1
a5168 1
      return false;
d5179 1
a5179 1
  return true;
d5184 1
a5184 1
static boolean
d5203 1
a5203 1
  return true;
@


1.5
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d37 1
a44 8
#ifndef DIR_SEPARATOR
#ifdef _WIN32
#define DIR_SEPARATOR '\\'
#else
#define DIR_SEPARATOR '/'
#endif
#endif

d565 1
a565 6
	  if (   (string[0] == '/')
	      || (string[0] == DIR_SEPARATOR)
	      || (   (DIR_SEPARATOR == '\\')
		  && (string[1] == ':')
		  && (   (string[2] == DIR_SEPARATOR)
		      || (string[2] == '/'))))
d698 1
d1815 1
a1815 1
	  else if (n3 == ((((bfd_vma) 0xffffffff) << 32) | 0xffffffff))
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1264 1
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
d43 8
d108 3
d257 8
a264 1
    return (bfd_vma) ul;
d349 1
a349 1
    warn_stab (orig, "numeric overflow");
d360 1
a360 1
  fprintf (stderr, "Bad stab: %s\n", p);
d370 1
a370 1
  fprintf (stderr, "Warning: %s: %s\n", err, p);
d378 1
a378 1
     PTR dhandle;
d492 1
a492 1
	  fprintf (stderr, "N_LBRAC not within function\n");
d531 1
a531 1
	  fprintf (stderr, "Too many N_RBRACs\n");
d560 2
a561 1
         the string starts with '/', we discard the previously
d570 7
a576 1
	  if (*string == '/')
d731 1
d780 1
a780 1
	  warn_stab (string, "unknown C++ encoded name");
d1064 5
d1076 5
a1080 3
         fill in.  */
      {
	register struct stab_tag **pst;
d1082 11
a1092 11
	for (pst = &info->tags; *pst != NULL; pst = &(*pst)->next)
	  {
	    if ((*pst)->name[0] == name[0]
		&& strcmp ((*pst)->name, name) == 0)
	      {
		(*pst)->slot = dtype;
		*pst = (*pst)->next;
		break;
	      }
	  }
      }
d1193 2
d1306 1
a1306 1
	    warn_stab (orig, "unrecognized cross reference type");
d1319 1
a1319 1
	while (q1 != NULL && p > q1 && p[1] == ':')
d1321 13
a1333 6
	    q2 = strchr (q1, '>');
	    if (q2 == NULL || q2 < p)
	      break;
	    p += 2;
	    p = strchr (p, ':');
	    if (p == NULL)
d1340 9
d1642 1
a1642 1
	return false;
d1769 1
a1769 1
      warn_stab (orig, "numeric overflow");
d1821 6
a1826 3
	  /* -1 is used for the upper bound of (4 byte) "unsigned int"
	     and "unsigned long", and we already checked for that, so
	     don't need to test for it here.  */
d1832 1
a1832 1
      else if (n2 == - n3 - 1)
d1840 4
d1861 1
a1861 1
      warn_stab (orig, "missing index type");
d2188 1
a2188 1
	  warn_stab (orig, "unknown virtual character for baseclass");
d2206 1
a2206 1
	  warn_stab (orig, "unknown visibility character for baseclass");
d2398 1
a2398 1
	  warn_stab (orig, "unnamed $vb type");
d2404 1
a2404 1
      warn_stab (orig, "unrecognized C++ abbreviation");
d2484 1
a2484 1
	  warn_stab (orig, "unknown visibility character for field");
d2740 1
a2740 1
	      warn_stab (orig, "const/volatile indicator missing");
d2980 1
a2980 1
	      fprintf (stderr, "No mangling for \"%s\"\n", fieldname);
d3005 1
a3005 1
  if (*argtypes == '\0')
d3134 1
a3134 1
    return false;
d3142 1
a3142 1
	    return false;
d3171 1
a3171 1
      return false;
d3185 1
a3185 1
      return false;
d3192 1
a3192 1
    return false;
d3211 2
d3234 2
a3235 1
  n->next = info->bincl_stack;
d3239 2
d3263 1
a3263 1
  info->bincl_stack = o->next;
a3266 3
  o->next = info->bincl_list;
  info->bincl_list = o;

d3293 1
a3293 1
      warn_stab ("N_EXCL", "Undefined N_EXCL");
d3381 1
a3381 1
      fprintf (stderr, "Type file number %d out of range\n", filenum);
d3386 1
a3386 1
      fprintf (stderr, "Type index number %d out of range\n", index);
d3442 1
a3442 1
     PTR dhandle;
d3473 1
a3473 1
      fprintf (stderr, "Unrecognized XCOFF type %d\n", typenum);
d3750 1
a3750 1
  PARAMS ((struct stab_demangle_info *, const char **));
d3772 1
a3772 1
  fprintf (stderr, "bad mangled name `%s'\n", s);
d3868 1
a3868 1
    fprintf (stderr, "no argument types in mangled string\n");
d4069 1
a4069 1
	  if (! stab_demangle_template (minfo, pp)
d4178 4
a4181 3
	  /* FIXME: I don't know how to handle the ptype != NULL case
             here.  */
	  if (! stab_demangle_template (minfo, pp))
d4183 10
d4250 1
a4250 1
	  /* We have to fall back on finding the type by name.
d4288 2
a4289 1
/* Demangle a template.  */
d4292 1
a4292 1
stab_demangle_template (minfo, pp)
d4295 1
d4469 40
d4516 1
a4516 1
     struct stab_demangle_info *minfo;
d4795 1
d4808 22
a4829 1
	if (! isdigit ((unsigned char) **pp))
d4831 5
a4835 2
	    stab_bad_demangle (orig);
	    return false;
d4837 1
a4837 2
	n = stab_demangle_count (pp);
	if (strlen (*pp) < n)
a4841 2
	name = *pp;
	*pp += n;
a4882 8
	    debug_type class_type;

	    class_type = stab_find_tagged_type (minfo->dhandle, minfo->info,
						name, (int) n,
						DEBUG_KIND_CLASS);
	    if (class_type == DEBUG_TYPE_NULL)
	      return false;

d5137 1
d5145 2
a5147 1
	    free (name);
d5153 2
a5154 5
      if (! stab_demangle_template (minfo, pp))
	return false;
      if (ptype != NULL)
	{
	  debug_type t;
d5156 13
a5168 10
	  /* FIXME: I really don't know how a template should be
             represented in the current type system.  Perhaps the
             template should be demangled into a string, and the type
             should be represented as a named type.  However, I don't
             know what the base type of the named type should be.  */
	  t = debug_make_void_type (minfo->dhandle);
	  t = debug_make_pointer_type (minfo->dhandle, t);
	  t = debug_name_type (minfo->dhandle, "TEMPLATE", t);
	  *ptype = t;
	}
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d78 1
a78 1
  /* A stack of N_BINCL files.  */
d80 2
d84 4
d191 1
a191 1
static void push_bincl PARAMS ((struct stab_handle *, const char *));
d193 2
d377 1
d395 1
a395 1
	  || ! debug_end_function (dhandle, (bfd_vma) -1))
d398 1
d522 7
d530 1
a530 1
	      || ! debug_end_function (dhandle, value))
d533 1
d571 1
a571 1
      push_bincl (info, string);
d585 2
a586 6
      ++info->files;
      info->file_types = ((struct stab_types **)
			  xrealloc ((PTR) info->file_types,
				    (info->files
				     * sizeof *info->file_types)));
      info->file_types[info->files - 1] = NULL;
d610 2
d618 1
d623 10
d649 6
d656 1
a656 1
		    || ! debug_end_function (dhandle, value))
d658 1
d3146 2
a3147 1
/* Keep a stack of N_BINCL include files.  */
d3151 1
d3153 1
d3155 6
d3166 1
a3166 1
push_bincl (info, name)
d3169 1
d3176 2
d3185 1
a3185 1
  info->file_types[info->files - 1] = NULL;
d3201 6
a3206 1
  free (o);
d3210 31
@


1.1
log
@Initial revision
@
text
@d591 16
d611 1
d2686 1
d4243 1
a4243 1
		  /* Assume it's a uder defined integral type.  */
d4944 14
a4957 1
      abort ();
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a590 16
    case N_FUN:
      if (*string == '\0')
	{
	  if (info->within_function)
	    {
	      if (info->sections)
		value += info->function_start_offset;
	      if (! stab_emit_pending_vars (dhandle, info)
		  || ! debug_end_function (dhandle, value))
		return false;
	      info->within_function = false;
	    }
	  break;
	}

      /* Fall through.  */
a594 1
      /* Fall through.  */
a2668 1
			context = DEBUG_TYPE_NULL;
d4225 1
a4225 1
		  /* Assume it's a user defined integral type.  */
d4926 1
a4926 14
      if (ptype != NULL)
	{
	  debug_type t;

	  /* FIXME: I really don't know how a template should be
             represented in the current type system.  Perhaps the
             template should be demangled into a string, and the type
             should be represented as a named type.  However, I don't
             know what the base type of the named type should be.  */
	  t = debug_make_void_type (minfo->dhandle);
	  t = debug_make_pointer_type (minfo->dhandle, t);
	  t = debug_name_type (minfo->dhandle, "TEMPLATE", t);
	  *ptype = t;
	}
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d78 1
a78 1
  /* A stack of unfinished N_BINCL files.  */
a79 2
  /* A list of finished N_BINCL files.  */
  struct bincl_file *bincl_list;
a81 4
  /* The address of the end of the function, used if we have seen an
     N_FUN symbol while in a function.  This is -1 if we have not seen
     an N_FUN (the normal case).  */
  bfd_vma function_end;
d185 1
a185 1
static void push_bincl PARAMS ((struct stab_handle *, const char *, bfd_vma));
a186 2
static boolean find_excl
  PARAMS ((struct stab_handle *, const char *, bfd_vma));
a368 1
  ret->function_end = (bfd_vma) -1;
d386 1
a386 1
	  || ! debug_end_function (dhandle, info->function_end))
a388 1
      info->function_end = (bfd_vma) -1;
a511 7
	  bfd_vma endval;

	  endval = value;
	  if (*string != '\0'
	      && info->function_end != (bfd_vma) -1
	      && info->function_end < endval)
	    endval = info->function_end;
d513 1
a513 1
	      || ! debug_end_function (dhandle, endval))
a515 1
	  info->function_end = (bfd_vma) -1;
d553 1
a553 1
      push_bincl (info, string, value);
d567 6
a572 2
      if (! find_excl (info, string, value))
	return false;
a595 2
	      /* This always marks the end of a function; we don't
                 need to worry about info->function_end.  */
a601 1
	      info->function_end = (bfd_vma) -1;
a605 10
      /* A const static symbol in the .text section will have an N_FUN
         entry.  We need to use these to mark the end of the function,
         in case we are looking at gcc output before it was changed to
         always emit an empty N_FUN.  We can't call debug_end_function
         here, because it might be a local static symbol.  */
      if (info->within_function
	  && (info->function_end == (bfd_vma) -1
	      || value < info->function_end))
	info->function_end = value;

a621 6
		bfd_vma endval;

		endval = value;
		if (info->function_end != (bfd_vma) -1
		    && info->function_end < endval)
		  endval = info->function_end;
d623 1
a623 1
		    || ! debug_end_function (dhandle, endval))
a624 1
		info->function_end = (bfd_vma) -1;
d3112 1
a3112 2
/* This struct holds information about files we have seen using
   N_BINCL.  */
a3115 1
  /* The next N_BINCL file.  */
a3116 1
  /* The file name.  */
a3117 6
  /* The hash value.  */
  bfd_vma hash;
  /* The file index.  */
  unsigned int file;
  /* The list of types defined in this file.  */
  struct stab_types *file_types;
d3123 1
a3123 1
push_bincl (info, name, hash)
a3125 1
     bfd_vma hash;
a3131 2
  n->hash = hash;
  n->file = info->files;
d3139 1
a3139 1
  info->file_types[n->file] = NULL;
d3155 1
a3155 6

  o->file_types = info->file_types[o->file];

  o->next = info->bincl_list;
  info->bincl_list = o;

a3158 31
}

/* Handle an N_EXCL: get the types from the corresponding N_BINCL.  */

static boolean
find_excl (info, name, hash)
     struct stab_handle *info;
     const char *name;
     bfd_vma hash;
{
  struct bincl_file *l;

  ++info->files;
  info->file_types = ((struct stab_types **)
		      xrealloc ((PTR) info->file_types,
				(info->files
				 * sizeof *info->file_types)));

  for (l = info->bincl_list; l != NULL; l = l->next)
    if (l->hash == hash && strcmp (l->name, name) == 0)
      break;
  if (l == NULL)
    {
      warn_stab ("N_EXCL", "Undefined N_EXCL");
      info->file_types[info->files - 1] = NULL;
      return true;
    }

  info->file_types[info->files - 1] = l->file_types;

  return true;
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a3152 2
  /* The next N_BINCL on the stack.  */
  struct bincl_file *next_stack;
d3174 1
a3174 2
  n->next = info->bincl_list;
  n->next_stack = info->bincl_stack;
a3177 2
  n->file_types = NULL;
  info->bincl_list = n;
d3200 1
a3200 1
  info->bincl_stack = o->next_stack;
d3204 3
d3233 1
a3233 1
      warn_stab (name, "Undefined N_EXCL");
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
a42 8
#ifndef DIR_SEPARATOR
#ifdef _WIN32
#define DIR_SEPARATOR '\\'
#else
#define DIR_SEPARATOR '/'
#endif
#endif

a99 3
  /* Set by parse_stab_type if it sees a structure defined as a cross
     reference to itself.  Reset by parse_stab_type otherwise.  */
  boolean self_crossref;
d246 1
a246 8
    {
      /* If bfd_vma is larger than unsigned long, and the number is
         meant to be negative, we have to make sure that we sign
         extend properly.  */
      if (*orig == '-')
	return (bfd_vma) (bfd_signed_vma) (long) ul;
      return (bfd_vma) ul;
    }
d331 1
a331 1
    warn_stab (orig, _("numeric overflow"));
d342 1
a342 1
  fprintf (stderr, _("Bad stab: %s\n"), p);
d352 1
a352 1
  fprintf (stderr, _("Warning: %s: %s\n"), err, p);
d360 1
a360 1
     PTR dhandle ATTRIBUTE_UNUSED;
d474 1
a474 1
	  fprintf (stderr, _("N_LBRAC not within function\n"));
d513 1
a513 1
	  fprintf (stderr, _("Too many N_RBRACs\n"));
d542 1
a542 2
         the string starts with a directory separator or some other
	 form of absolute path specification, we discard the previously
d551 1
a551 7

	  if (   (string[0] == '/')
	      || (string[0] == DIR_SEPARATOR)
	      || (   (DIR_SEPARATOR == '\\')
		  && (string[1] == ':')
		  && (   (string[2] == DIR_SEPARATOR)
		      || (string[2] == '/'))))
a705 1
  boolean self_crossref;
d754 1
a754 1
	  warn_stab (string, _("unknown C++ encoded name"));
a1037 5
      /* INFO->SELF_CROSSREF is set by parse_stab_type if this type is
         a cross reference to itself.  These are generated by some
         versions of g++.  */
      self_crossref = info->self_crossref;

d1045 3
a1047 5
         fill in.  Avoid filling in a cross reference to ourselves,
         because that would lead to circular debugging information.  */
      if (! self_crossref)
	{
	  register struct stab_tag **pst;
d1049 11
a1059 11
	  for (pst = &info->tags; *pst != NULL; pst = &(*pst)->next)
	    {
	      if ((*pst)->name[0] == name[0]
		  && strcmp ((*pst)->name, name) == 0)
		{
		  (*pst)->slot = dtype;
		  *pst = (*pst)->next;
		  break;
		}
	    }
	}
a1159 2
  info->self_crossref = false;

d1271 1
a1271 1
	    warn_stab (orig, _("unrecognized cross reference type"));
d1284 1
a1284 1
	if (q1 != NULL && p > q1 && p[1] == ':')
d1286 6
a1291 13
	    int nest = 0;

	    for (q2 = q1; *q2 != '\0'; ++q2)
	      {
		if (*q2 == '<')
		  ++nest;
		else if (*q2 == '>')
		  --nest;
		else if (*q2 == ':' && nest == 0)
		  break;
	      }
	    p = q2;
	    if (*p != ':')
a1297 9
	/* Some versions of g++ can emit stabs like
	       fleep:T20=xsfleep:
	   which define structures in terms of themselves.  We need to
	   tell the caller to avoid building a circular structure.  */
	if (typename != NULL
	    && strncmp (typename, *pp, p - *pp) == 0
	    && typename[p - *pp] == '\0')
	  info->self_crossref = true;

d1591 1
a1591 1
	return DEBUG_TYPE_NULL;
d1718 1
a1718 1
      warn_stab (orig, _("numeric overflow"));
d1770 3
a1772 6
	  else if (n3 == (bfd_signed_vma) 0xffffffff)
	    return debug_make_int_type (dhandle, 4, true);
#ifdef BFD64
	  else if (n3 == ((((bfd_vma) 0xffffffff) << 32) | 0xffffffff))
	    return debug_make_int_type (dhandle, 8, true);
#endif
d1778 1
a1778 1
      else if (n2 == - n3 - 1 || n2 == n3 + 1)
a1785 4
#ifdef BFD64
	  else if (n3 == ((((bfd_vma) 0x7fffffff) << 32) | 0xffffffff))
	    return debug_make_int_type (dhandle, 8, false);
#endif
d1803 1
a1803 1
      warn_stab (orig, _("missing index type"));
d2130 1
a2130 1
	  warn_stab (orig, _("unknown virtual character for baseclass"));
d2148 1
a2148 1
	  warn_stab (orig, _("unknown visibility character for baseclass"));
d2340 1
a2340 1
	  warn_stab (orig, _("unnamed $vb type"));
d2346 1
a2346 1
      warn_stab (orig, _("unrecognized C++ abbreviation"));
d2426 1
a2426 1
	  warn_stab (orig, _("unknown visibility character for field"));
d2682 1
a2682 1
	      warn_stab (orig, _("const/volatile indicator missing"));
d2922 1
a2922 1
	      fprintf (stderr, _("No mangling for \"%s\"\n"), fieldname);
d2947 1
a2947 1
  if (*argtypes == '\0' || is_destructor)
d3076 1
a3076 1
    return DEBUG_TYPE_NULL;
d3084 1
a3084 1
	    return DEBUG_TYPE_NULL;
d3113 1
a3113 1
      return DEBUG_TYPE_NULL;
d3127 1
a3127 1
      return DEBUG_TYPE_NULL;
d3134 1
a3134 1
    return DEBUG_TYPE_NULL;
d3235 1
a3235 1
      warn_stab (name, _("Undefined N_EXCL"));
d3323 1
a3323 1
      fprintf (stderr, _("Type file number %d out of range\n"), filenum);
d3328 1
a3328 1
      fprintf (stderr, _("Type index number %d out of range\n"), index);
d3384 1
a3384 1
     PTR dhandle ATTRIBUTE_UNUSED;
d3415 1
a3415 1
      fprintf (stderr, _("Unrecognized XCOFF type %d\n"), typenum);
d3692 1
a3692 1
  PARAMS ((struct stab_demangle_info *, const char **, char **));
d3714 1
a3714 1
  fprintf (stderr, _("bad mangled name `%s'\n"), s);
d3810 1
a3810 1
    fprintf (stderr, _("no argument types in mangled string\n"));
d4011 1
a4011 1
	  if (! stab_demangle_template (minfo, pp, (char **) NULL)
d4120 3
a4122 4
	  char *name;

	  if (! stab_demangle_template (minfo, pp,
					ptype != NULL ? &name : NULL))
a4123 10

	  if (ptype != NULL)
	    {
	      context = stab_find_tagged_type (minfo->dhandle, minfo->info,
					       name, strlen (name),
					       DEBUG_KIND_CLASS);
	      free (name);
	      if (context == DEBUG_TYPE_NULL)
		return false;
	    }
d4181 1
a4181 1
		  /* We have to fall back on finding the type by name.
d4219 1
a4219 2
/* Demangle a template.  If PNAME is not NULL, this sets *PNAME to a
   string representation of the template.  */
d4222 1
a4222 1
stab_demangle_template (minfo, pp, pname)
a4224 1
     char **pname;
a4397 40
  /* We can translate this to a string fairly easily by invoking the
     regular demangling routine.  */
  if (pname != NULL)
    {
      char *s1, *s2, *s3, *s4;
      char *from, *to;

      s1 = savestring (orig, *pp - orig);

      s2 = concat ("NoSuchStrinG__", s1, (const char *) NULL);

      free (s1);

      s3 = cplus_demangle (s2, DMGL_ANSI);

      free (s2);

      if (s3 != NULL)
	s4 = strstr (s3, "::NoSuchStrinG");
      if (s3 == NULL || s4 == NULL)
	{
	  stab_bad_demangle (orig);
	  if (s3 != NULL)
	    free (s3);
	  return false;
	}

      /* Eliminating all spaces, except those between > characters,
         makes it more likely that the demangled name will match the
         name which g++ used as the structure name.  */
      for (from = to = s3; from != s4; ++from)
	if (*from != ' '
	    || (from[1] == '>' && from > s3 && from[-1] == '>'))
	  *to++ = *from;

      *pname = savestring (s3, to - s3);

      free (s3);
    }

d4405 1
a4405 1
     struct stab_demangle_info *minfo ATTRIBUTE_UNUSED;
a4683 1
	debug_type class_type = DEBUG_TYPE_NULL;
d4696 1
a4696 1
	if (isdigit ((unsigned char) **pp))
d4698 2
a4699 26
	    n = stab_demangle_count (pp);
	    if (strlen (*pp) < n)
	      {
		stab_bad_demangle (orig);
		return false;
	      }
	    name = *pp;
	    *pp += n;

	    if (ptype != NULL)
	      {
		class_type = stab_find_tagged_type (minfo->dhandle,
						    minfo->info,
						    name, (int) n,
						    DEBUG_KIND_CLASS);
		if (class_type == DEBUG_TYPE_NULL)
		  return false;
	      }
	  }
	else if (**pp == 'Q')
	  {
	    if (! stab_demangle_qualified (minfo, pp,
					   (ptype == NULL
					    ? (debug_type *) NULL
					    : &class_type)))
	      return false;
d4701 2
a4702 1
	else
d4707 2
d4750 8
a5011 1
	    free (name);
a5018 2
		if (*ptype == DEBUG_TYPE_NULL)
		  return false;
d5020 1
d5026 5
a5030 2
      {
	char *name;
d5032 10
a5041 13
	if (! stab_demangle_template (minfo, pp,
				      ptype != NULL ? &name : NULL))
	  return false;
	if (ptype != NULL)
	  {
	    *ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
					    name, strlen (name),
					    DEBUG_KIND_CLASS);
	    free (name);
	    if (*ptype == DEBUG_TYPE_NULL)
	      return false;
	  }
      }
@


1.1.1.6
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@a1263 1
	      size /= 8;  /* Size is in bits.  We store it in bytes.  */
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a35 1
#include "filenames.h"
d43 8
d571 6
a576 1
          if (IS_ABSOLUTE_PATH (string))
a708 1
    case N_WARNING:
d1825 1
a1825 1
	  else if (n3 == ((((bfd_signed_vma) 0xffffffff) << 32) | 0xffffffff))
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d29 1
a33 1
#include "safe-ctype.h"
d38 4
d56 2
a57 2
  /* TRUE if this is stabs in sections.  */
  bfd_boolean sections;
d77 1
a77 1
  bfd_boolean n_opt_found;
d85 1
a85 1
  bfd_boolean within_function;
d104 1
a104 1
  bfd_boolean self_crossref;
d154 5
a158 9
static char *savestring
  PARAMS ((const char *, int));
static bfd_vma parse_number
  PARAMS ((const char **, bfd_boolean *));
static void bad_stab
  PARAMS ((const char *));
static void warn_stab
  PARAMS ((const char *, const char *));
static bfd_boolean parse_stab_string
d163 1
a163 1
static bfd_boolean parse_stab_type_number
d168 1
a168 2
static debug_type parse_stab_sun_builtin_type
  PARAMS ((PTR, const char **));
d171 1
a171 2
static debug_type parse_stab_enum_type
  PARAMS ((PTR, const char **));
d173 3
a175 3
  PARAMS ((PTR, struct stab_handle *, const char *, const char **,
	   bfd_boolean, const int *));
static bfd_boolean parse_stab_baseclasses
d177 1
a177 1
static bfd_boolean parse_stab_struct_fields
d179 2
a180 2
	   bfd_boolean *));
static bfd_boolean parse_stab_cpp_abbrev
d182 1
a182 1
static bfd_boolean parse_stab_one_struct_field
d184 2
a185 2
	   debug_field *, bfd_boolean *));
static bfd_boolean parse_stab_members
d190 2
a191 2
	   debug_type, const char *, bfd_boolean, bfd_boolean, const char **));
static bfd_boolean parse_stab_tilde_field
d193 1
a193 1
	   debug_type *, bfd_boolean *));
d195 4
a198 6
  PARAMS ((PTR, struct stab_handle *, const char **, bfd_boolean));
static void push_bincl
  PARAMS ((struct stab_handle *, const char *, bfd_vma));
static const char *pop_bincl
  PARAMS ((struct stab_handle *));
static bfd_boolean find_excl
d200 1
a200 1
static bfd_boolean stab_record_variable
d203 1
a203 2
static bfd_boolean stab_emit_pending_vars
  PARAMS ((PTR, struct stab_handle *));
d208 1
a208 1
static bfd_boolean stab_record_type
d216 1
a216 2
  PARAMS ((PTR, struct stab_handle *, const char *, bfd_boolean *,
	   unsigned int));
d238 1
a238 1
     bfd_boolean *poverflow;
d244 1
a244 1
    *poverflow = FALSE;
d262 1
d266 1
a266 1
      bfd_boolean neg;
d269 1
a269 1
      bfd_boolean overflow;
d273 1
d276 1
a276 1
      neg = FALSE;
d281 1
a281 1
	  neg = TRUE;
d303 1
a303 1
      overflow = FALSE;
d310 1
a310 1
	  if (ISDIGIT (d))
d312 1
a312 1
	  else if (ISUPPER (d))
d314 1
a314 1
	  else if (ISLOWER (d))
d324 1
a324 1
	      overflow = TRUE;
d339 1
d341 1
a341 1
    *poverflow = TRUE;
d369 1
d374 1
a374 1
     bfd_boolean sections;
d396 1
a396 1
bfd_boolean
d408 2
a409 2
	return FALSE;
      info->within_function = FALSE;
d422 1
a422 1
	return FALSE;
d425 1
a425 1
  return TRUE;
d430 1
a430 1
bfd_boolean
d449 1
a449 1
	return FALSE;
d453 1
a453 1
      info->n_opt_found = FALSE;
d487 1
a487 1
	  return FALSE;
d495 1
a495 1
	return FALSE;
d499 1
a499 1
	return FALSE;
d513 1
a513 1
	return FALSE;
d520 1
a520 1
	return FALSE;
d526 1
a526 1
	  return FALSE;
d543 2
a544 2
	    return FALSE;
	  info->within_function = FALSE;
d551 1
a551 1
	return TRUE;
d565 1
a565 1
	  if (IS_ABSOLUTE_PATH (string))
d580 1
a580 1
	return FALSE;
d587 1
a587 1
	return FALSE;
d593 1
a593 1
	return FALSE;
d600 1
a600 1
	return FALSE;
d605 2
a606 3
			       value + (info->within_function
					? info->function_start_offset : 0)))
	return FALSE;
d611 1
a611 1
	return FALSE;
d616 1
a616 1
	return FALSE;
d630 2
a631 2
		return FALSE;
	      info->within_function = FALSE;
d671 1
a671 1
		  return FALSE;
d678 1
a678 1
	    info->within_function = TRUE;
d682 1
a682 1
	  return FALSE;
d692 1
a692 1
	info->n_opt_found = TRUE;
d702 1
a702 1
  return TRUE;
d707 1
a707 1
static bfd_boolean
d720 2
a721 2
  bfd_boolean synonym;
  bfd_boolean self_crossref;
d727 1
a727 1
    return TRUE;
d736 1
a736 1
	  return FALSE;
d784 1
a784 1
  if (ISDIGIT (*p) || *p == '(' || *p == '-')
d801 1
a801 1
	  return FALSE;
d809 1
a809 1
	    return FALSE;
d820 1
a820 1
	    return FALSE;
d830 1
a830 1
	    return FALSE;
d834 1
a834 1
	      return FALSE;
d837 1
a837 1
	    return FALSE;
d841 1
a841 1
	  return FALSE;
d851 1
a851 1
	return FALSE;
d853 1
a853 1
	return FALSE;
d862 1
a862 1
	return FALSE;
d864 1
a864 1
	return FALSE;
d876 1
a876 1
	    return FALSE;
d892 1
a892 1
	  return FALSE;
d908 1
a908 1
	  return FALSE;
d920 1
a920 1
	return FALSE;
d923 1
a923 1
	return FALSE;
d944 1
a944 1
						(debug_type *) NULL, FALSE);
d949 1
a949 1
	return FALSE;
d952 1
a952 1
	return FALSE;
d958 1
d971 1
a971 1
		return FALSE;
d981 1
a981 1
	return FALSE;
d984 1
a984 1
	return FALSE;
d992 1
a992 1
	return FALSE;
d995 1
a995 1
	return FALSE;
d999 1
d1003 1
a1003 1
      /* Static symbol at top level of file.  */
d1007 1
a1007 1
	return FALSE;
d1010 1
a1010 1
	return FALSE;
d1017 1
a1017 1
	return FALSE;
d1021 1
a1021 1
	  return TRUE;
d1026 1
a1026 1
	return FALSE;
d1038 2
a1039 2
	  synonym = FALSE;
	  /* FIXME: gdb sets synonym to TRUE if the current language
d1044 1
a1044 1
	  synonym = TRUE;
d1050 1
a1050 1
	return FALSE;
d1052 1
a1052 1
	return TRUE;
d1061 1
a1061 1
	return FALSE;
d1088 1
a1088 1
	    return FALSE;
d1101 1
a1101 1
	return FALSE;
d1105 1
a1105 1
	return FALSE;
d1113 1
a1113 1
	return FALSE;
d1116 1
a1116 1
	return FALSE;
d1124 1
a1124 1
	return FALSE;
d1127 1
a1127 1
	return FALSE;
d1138 1
a1138 1
	return FALSE;
d1141 1
a1141 1
	return FALSE;
d1146 1
a1146 1
      return FALSE;
d1152 1
a1152 1
  return TRUE;
d1171 1
a1171 1
  bfd_boolean stringp;
d1181 1
a1181 1
  stringp = FALSE;
d1183 1
a1183 1
  info->self_crossref = FALSE;
d1188 1
a1188 1
  if (! ISDIGIT (**pp) && **pp != '(' && **pp != '-')
d1200 5
a1204 3
	/* Type is not being defined here.  Either it already
	   exists, or this is a forward reference to it.  */
	return stab_find_type (dhandle, info, typenums);
d1231 5
a1235 3
	  if (ISDIGIT (*p) || *p == '(' || *p == '-')
	    /* Member type.  */
	    break;
d1260 1
a1260 1
	      stringp = TRUE;
d1282 1
d1338 1
a1338 1
	  info->self_crossref = TRUE;
d1363 1
d1422 1
a1422 1
		(debug_type *) NULL, FALSE));
d1493 1
a1493 1
					  (debug_type *) NULL, FALSE);
d1502 1
a1502 1
	  bfd_boolean varargs;
d1553 1
a1553 1
	    varargs = TRUE;
d1557 1
a1557 1
	      varargs = FALSE;
d1644 1
a1644 1
static bfd_boolean
d1656 1
a1656 1
      typenums[1] = (int) parse_number (pp, (bfd_boolean *) NULL);
d1661 1
a1661 1
      typenums[0] = (int) parse_number (pp, (bfd_boolean *) NULL);
d1665 1
a1665 1
	  return FALSE;
d1668 1
a1668 1
      typenums[1] = (int) parse_number (pp, (bfd_boolean *) NULL);
d1672 1
a1672 1
	  return FALSE;
d1677 1
a1677 1
  return TRUE;
d1692 1
a1692 1
  bfd_boolean self_subrange;
d1696 1
a1696 1
  bfd_boolean ov2, ov3;
d1746 2
a1747 2
#define LLLOW   "01000000000000000000000;"
#define LLHIGH   "0777777777777777777777;"
d1753 1
a1753 1
	    return debug_make_int_type (dhandle, 8, FALSE);
d1757 1
a1757 1
	    return debug_make_int_type (dhandle, 8, TRUE);
d1790 1
a1790 1
		return debug_make_int_type (dhandle, 8, FALSE);
d1792 1
a1792 1
		return debug_make_int_type (dhandle, 8, TRUE);
d1795 1
a1795 1
	  return debug_make_int_type (dhandle, 4, TRUE);
d1800 1
a1800 1
	return debug_make_int_type (dhandle, 1, FALSE);
d1807 1
a1807 1
	    return debug_make_int_type (dhandle, - n3, TRUE);
d1809 1
a1809 1
	    return debug_make_int_type (dhandle, 1, TRUE);
d1811 1
a1811 1
	    return debug_make_int_type (dhandle, 2, TRUE);
d1813 1
a1813 1
	    return debug_make_int_type (dhandle, 4, TRUE);
d1816 1
a1816 1
	    return debug_make_int_type (dhandle, 8, TRUE);
d1822 1
a1822 1
	return debug_make_int_type (dhandle, - n2, TRUE);
d1826 1
a1826 1
	    return debug_make_int_type (dhandle, 1, FALSE);
d1828 1
a1828 1
	    return debug_make_int_type (dhandle, 2, FALSE);
d1830 1
a1830 1
	    return debug_make_int_type (dhandle, 4, FALSE);
d1833 1
a1833 1
	    return debug_make_int_type (dhandle, 8, FALSE);
d1853 1
a1853 1
      index_type = debug_make_int_type (dhandle, 4, FALSE);
d1877 1
a1877 1
  bfd_boolean unsignedp;
d1885 1
a1885 1
      unsignedp = FALSE;
d1888 1
a1888 1
      unsignedp = TRUE;
d1907 1
a1907 1
  (void) parse_number (pp, (bfd_boolean *) NULL);
d1915 2
a1916 2
  /* The second number is always 0, so ignore it too.  */
  (void) parse_number (pp, (bfd_boolean *) NULL);
d1924 2
a1925 2
  /* The third number is the number of bits for this type.  */
  bits = parse_number (pp, (bfd_boolean *) NULL);
d1957 1
a1957 1
  details = parse_number (pp, (bfd_boolean *) NULL);
d1965 1
a1965 1
  bytes = parse_number (pp, (bfd_boolean *) NULL);
d1977 1
a1977 1
  return debug_make_float_type (dhandle, bytes);
d2026 1
a2026 1
      val = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
d2070 1
a2070 1
     bfd_boolean structp;
d2077 1
a2077 1
  bfd_boolean statics;
d2080 1
a2080 1
  bfd_boolean ownvptr;
d2085 1
a2085 1
  size = parse_number (pp, (bfd_boolean *) NULL);
d2128 1
a2128 1
  Return TRUE for success, FALSE for failure.  */
d2130 1
a2130 1
static bfd_boolean
d2148 1
a2148 1
      return TRUE;
d2152 1
a2152 1
  c = (unsigned int) parse_number (pp, (bfd_boolean *) NULL);
d2157 1
a2157 1
      return FALSE;
d2165 1
a2165 1
      bfd_boolean virtual;
d2173 1
a2173 1
	  virtual = FALSE;
d2176 1
a2176 1
	  virtual = TRUE;
d2180 1
a2180 1
	  virtual = FALSE;
d2206 1
a2206 1
      bitpos = parse_number (pp, (bfd_boolean *) NULL);
d2210 1
a2210 1
	  return FALSE;
d2217 1
a2217 1
	return FALSE;
d2222 1
a2222 1
	return FALSE;
d2225 1
a2225 1
	return FALSE;
d2233 1
a2233 1
  return TRUE;
d2256 1
a2256 1
static bfd_boolean
d2262 1
a2262 1
     bfd_boolean *staticsp;
d2271 1
a2271 1
  *staticsp = FALSE;
d2303 1
a2303 1
	    return FALSE;
d2311 1
a2311 1
	 functions (if any), terminate scan loop and return.  */
d2317 1
a2317 1
	  return FALSE;
d2325 1
a2325 1
	return FALSE;
d2334 1
a2334 1
  return TRUE;
d2339 1
a2339 1
static bfd_boolean
d2361 1
a2361 1
      return FALSE;
d2376 1
a2376 1
    return FALSE;
d2403 1
a2403 1
      return FALSE;
d2412 1
a2412 1
      return FALSE;
d2416 1
a2416 1
  bitpos = parse_number (pp, (bfd_boolean *) NULL);
d2420 1
a2420 1
      return FALSE;
d2427 1
a2427 1
    return FALSE;
d2429 1
a2429 1
  return TRUE;
d2434 1
a2434 1
static bfd_boolean
d2441 1
a2441 1
     bfd_boolean *staticsp;
d2485 1
a2485 1
    return FALSE;
d2497 1
a2497 1
	  return FALSE;
d2506 1
a2506 1
      *staticsp = TRUE;
d2508 1
a2508 1
      return TRUE;
d2514 1
a2514 1
      return FALSE;
d2518 1
a2518 1
  bitpos = parse_number (pp, (bfd_boolean *) NULL);
d2522 1
a2522 1
      return FALSE;
d2526 1
a2526 1
  bitsize = parse_number (pp, (bfd_boolean *) NULL);
d2530 1
a2530 1
      return FALSE;
d2556 1
a2556 1
  return TRUE;
d2572 1
a2572 1
static bfd_boolean
d2627 1
a2627 1
	      return FALSE;
d2643 1
a2643 1
	  bfd_boolean stub;
d2646 1
a2646 1
	  bfd_boolean constp, volatilep, staticp;
d2650 1
a2650 1
	  bfd_boolean varargs;
d2663 1
a2663 1
		return FALSE;
d2667 1
a2667 1
		  return FALSE;
d2676 1
a2676 1
	      return FALSE;
d2679 1
a2679 1
	  stub = FALSE;
d2682 1
a2682 1
	    stub = TRUE;
d2701 2
a2702 2
	  constp = FALSE;
	  volatilep = FALSE;
d2711 1
a2711 1
	      constp = TRUE;
d2716 1
a2716 1
	      volatilep = TRUE;
d2721 2
a2722 2
	      constp = TRUE;
	      volatilep = TRUE;
d2735 1
a2735 1
	  staticp = FALSE;
d2743 1
a2743 1
	      voffset = parse_number (pp, (bfd_boolean *) NULL);
d2747 1
a2747 1
		  return FALSE;
d2762 21
a2782 21
		  look_ahead_type = parse_stab_type (dhandle, info,
						     (const char *) NULL,
						     pp,
						     (debug_type **) NULL);
		  if (**pp == ':')
		    {
		      /* g++ version 1 overloaded methods.  */
		      context = DEBUG_TYPE_NULL;
		    }
		  else
		    {
		      context = look_ahead_type;
		      look_ahead_type = DEBUG_TYPE_NULL;
		      if (**pp != ';')
			{
			  bad_stab (orig);
			  return FALSE;
			}
		      ++*pp;
		    }
		}
d2788 1
a2788 1
	      staticp = TRUE;
d2792 1
a2792 1
		stub = TRUE;
d2821 1
a2821 1
		return FALSE;
d2826 1
a2826 1
		  return FALSE;
d2832 1
a2832 1
		return FALSE;
d2856 1
a2856 1
	    return FALSE;
d2884 1
a2884 1
  return TRUE;
d2903 2
a2904 2
     bfd_boolean constp;
     bfd_boolean volatilep;
d2907 3
a2909 3
  bfd_boolean is_full_physname_constructor;
  bfd_boolean is_constructor;
  bfd_boolean is_destructor;
d2911 1
a2911 2
  bfd_boolean varargs;
  unsigned int physname_len = 0;
d2916 1
a2916 1
				   && (ISDIGIT (argtypes[2])
a2987 1
      physname_len = strlen (physname);
d3001 1
a3001 1
				     FALSE);
d3004 1
a3004 1
  args = stab_demangle_argtypes (dhandle, info, *pphysname, &varargs, physname_len);
d3020 1
a3020 1
static bfd_boolean
d3027 1
a3027 1
     bfd_boolean *retownvptr;
d3034 1
a3034 1
  *retownvptr = FALSE;
d3038 1
a3038 1
  /* If we are positioned at a ';', then skip it.  */
d3043 1
a3043 1
    return TRUE;
d3050 1
a3050 1
	 constructors and/or destructors.  */
d3055 1
a3055 1
    return TRUE;
d3064 1
a3064 1
    return FALSE;
d3068 1
a3068 1
    *retownvptr = TRUE;
d3083 1
a3083 1
	  return FALSE;
d3091 1
a3091 1
  return TRUE;
d3101 1
a3101 1
     bfd_boolean stringp;
d3107 1
a3107 1
  bfd_boolean adjustable;
d3131 1
a3131 1
	  index_type = debug_make_int_type (dhandle, 4, FALSE);
d3150 1
a3150 1
  adjustable = FALSE;
d3152 1
a3152 1
  if (! ISDIGIT (**pp) && **pp != '-')
d3155 1
a3155 1
      adjustable = TRUE;
d3158 1
a3158 1
  lower = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
d3166 1
a3166 1
  if (! ISDIGIT (**pp) && **pp != '-')
d3169 1
a3169 1
      adjustable = TRUE;
d3172 1
a3172 1
  upper = (bfd_signed_vma) parse_number (pp, (bfd_boolean *) NULL);
d3265 1
a3265 1
static bfd_boolean
d3286 1
a3286 1
      return TRUE;
d3291 1
a3291 1
  return TRUE;
d3299 1
a3299 1
static bfd_boolean
d3325 1
a3325 1
  return TRUE;
d3331 1
a3331 1
static bfd_boolean
d3344 1
a3344 1
	return FALSE;
d3353 1
a3353 1
  return TRUE;
d3431 1
a3431 1
static bfd_boolean
d3442 1
a3442 1
    return FALSE;
d3448 1
a3448 1
  return TRUE;
d3476 1
a3476 1
      rettype = debug_make_int_type (dhandle, 4, FALSE);
d3480 1
a3480 1
      rettype = debug_make_int_type (dhandle, 1, FALSE);
d3484 1
a3484 1
      rettype = debug_make_int_type (dhandle, 2, FALSE);
d3488 1
a3488 1
      rettype = debug_make_int_type (dhandle, 4, FALSE);
d3492 1
a3492 1
      rettype = debug_make_int_type (dhandle, 1, TRUE);
d3496 1
a3496 1
      rettype = debug_make_int_type (dhandle, 1, FALSE);
d3500 1
a3500 1
      rettype = debug_make_int_type (dhandle, 2, TRUE);
d3504 1
a3504 1
      rettype = debug_make_int_type (dhandle, 4, TRUE);
d3508 1
a3508 1
      rettype = debug_make_int_type (dhandle, 4, TRUE);
d3511 1
a3511 1
      rettype = debug_make_int_type (dhandle, 4, TRUE);
d3536 1
a3536 1
      rettype = debug_make_int_type (dhandle, 4, FALSE);
d3558 1
a3558 1
      rettype = debug_make_int_type (dhandle, 1, TRUE);
d3588 1
a3588 1
      rettype = debug_make_int_type (dhandle, 1, FALSE);
d3592 1
a3592 1
      rettype = debug_make_int_type (dhandle, 2, FALSE);
d3596 1
a3596 1
      rettype = debug_make_int_type (dhandle, 4, FALSE);
d3601 1
a3601 1
      rettype = debug_make_int_type (dhandle, 2, FALSE);
d3605 1
a3605 1
      rettype = debug_make_int_type (dhandle, 8, FALSE);
d3609 1
a3609 1
      rettype = debug_make_int_type (dhandle, 8, TRUE);
d3617 1
a3617 1
      rettype = debug_make_int_type (dhandle, 8, FALSE);
d3719 1
a3719 1
  bfd_boolean varargs;
d3728 3
a3730 5
static void stab_bad_demangle
  PARAMS ((const char *));
static unsigned int stab_demangle_count
  PARAMS ((const char **));
static bfd_boolean stab_demangle_get_count
d3732 3
a3734 3
static bfd_boolean stab_demangle_prefix
  PARAMS ((struct stab_demangle_info *, const char **, unsigned int));
static bfd_boolean stab_demangle_function_name
d3736 1
a3736 1
static bfd_boolean stab_demangle_signature
d3738 1
a3738 1
static bfd_boolean stab_demangle_qualified
d3740 1
a3740 1
static bfd_boolean stab_demangle_template
d3742 1
a3742 1
static bfd_boolean stab_demangle_class
d3744 1
a3744 1
static bfd_boolean stab_demangle_args
d3746 2
a3747 2
	   bfd_boolean *));
static bfd_boolean stab_demangle_arg
d3750 1
a3750 1
static bfd_boolean stab_demangle_type
d3752 1
a3752 1
static bfd_boolean stab_demangle_fund_type
d3754 1
a3754 1
static bfd_boolean stab_demangle_remember_type
d3775 1
a3775 1
  while (ISDIGIT (**pp))
d3787 1
a3787 1
static bfd_boolean
d3792 2
a3793 2
  if (! ISDIGIT (**pp))
    return FALSE;
d3797 1
a3797 1
  if (ISDIGIT (**pp))
d3810 1
a3810 1
      while (ISDIGIT (*p));
d3818 1
a3818 1
  return TRUE;
d3825 1
a3825 1
stab_demangle_argtypes (dhandle, info, physname, pvarargs, physname_len)
d3829 1
a3829 2
     bfd_boolean *pvarargs;
     unsigned int physname_len;
d3836 1
a3836 1
  minfo.varargs = FALSE;
d3846 1
a3846 1
  if (! stab_demangle_prefix (&minfo, &physname, physname_len))
d3872 2
a3873 2
static bfd_boolean
stab_demangle_prefix (minfo, pp, physname_len)
a3875 1
     unsigned int physname_len;
d3883 3
a3885 3
  if (physname_len)
    scan = *pp + physname_len;
  else
d3887 3
a3889 5
      /* Look for `__'.  */
      scan = *pp;
      do
	scan = strchr (scan, '_');
      while (scan != NULL && *++scan != '_');
d3891 5
a3895 5
      if (scan == NULL)
	{
	  stab_bad_demangle (*pp);
	  return FALSE;
	}
d3897 1
a3897 1
      --scan;
d3899 4
a3902 5
      /* We found `__'; move ahead to the last contiguous `__' pair.  */
      i = strspn (scan, "_");
      if (i > 2)
	scan += i - 2;
    }
d3905 1
a3905 1
      && (ISDIGIT (scan[2])
d3911 1
a3911 1
      return TRUE;
d3914 1
a3914 1
	   && ! ISDIGIT (scan[2])
d3925 1
a3925 1
	  return FALSE;
d3938 1
a3938 1
      return FALSE;
d3947 1
a3947 1
static bfd_boolean
d3972 1
a3972 1
	return FALSE;
d3984 1
a3984 1
	return FALSE;
d3987 1
a3987 1
  return TRUE;
d3993 1
a3993 1
static bfd_boolean
d3999 1
a3999 1
  bfd_boolean expect_func, func_done;
d4004 2
a4005 2
  expect_func = FALSE;
  func_done = FALSE;
d4016 2
a4017 2
	    return FALSE;
	  expect_func = TRUE;
d4041 2
a4042 2
	    return FALSE;
	  expect_func = TRUE;
d4050 1
a4050 1
	  func_done = TRUE;
d4053 1
a4053 1
	    return FALSE;
d4062 1
a4062 1
	    return FALSE;
d4064 1
a4064 1
	  expect_func = TRUE;
d4074 1
a4074 1
	  return FALSE;
d4079 1
a4079 1
	  func_done = TRUE;
d4081 1
a4081 1
	    return FALSE;
d4087 1
a4087 1
	  func_done = TRUE;
d4089 1
a4089 1
	    return FALSE;
d4100 1
a4100 1
	return FALSE;
d4103 1
a4103 1
  return TRUE;
d4109 1
a4109 1
static bfd_boolean
d4129 1
a4129 1
      if (! ISDIGIT (*p) || *p == '0')
d4132 1
a4132 1
	  return FALSE;
d4135 1
a4135 1
      while (ISDIGIT (*p))
d4140 1
a4140 1
	  return FALSE;
d4157 1
a4157 1
      return FALSE;
d4173 1
a4173 1
	    return FALSE;
d4182 1
a4182 1
		return FALSE;
d4193 1
a4193 1
	      return FALSE;
d4227 1
a4227 1
			return FALSE;
d4264 1
a4264 1
			return FALSE;
d4276 1
a4276 1
  return TRUE;
d4282 1
a4282 1
static bfd_boolean
d4300 1
a4300 1
      return FALSE;
d4308 1
a4308 1
      return FALSE;
d4318 1
a4318 1
	    return FALSE;
d4323 2
a4324 2
	  bfd_boolean pointerp, realp, integralp, charp, boolp;
	  bfd_boolean done;
d4327 6
a4332 6
	  pointerp = FALSE;
	  realp = FALSE;
	  integralp = FALSE;
	  charp = FALSE;
	  boolp = FALSE;
	  done = FALSE;
d4337 1
a4337 1
	    return FALSE;
d4346 2
a4347 2
		  pointerp = TRUE;
		  done = TRUE;
d4359 2
a4360 2
		  integralp = TRUE;
		  done = TRUE;
d4371 2
a4372 2
		  integralp = TRUE;
		  done = TRUE;
d4375 2
a4376 2
		  boolp = TRUE;
		  done = TRUE;
d4379 2
a4380 2
		  charp = TRUE;
		  done = TRUE;
d4385 2
a4386 2
		  realp = TRUE;
		  done = TRUE;
d4390 2
a4391 2
		  integralp = TRUE;
		  done = TRUE;
d4400 1
a4400 1
	      while (ISDIGIT (**pp))
d4413 1
a4413 1
		  return FALSE;
d4424 1
a4424 1
		  return FALSE;
d4431 1
a4431 1
	      while (ISDIGIT (**pp))
d4436 1
a4436 1
		  while (ISDIGIT (**pp))
d4442 1
a4442 1
		  while (ISDIGIT (**pp))
d4453 1
a4453 1
		  return FALSE;
d4464 1
a4464 1
      char *s1, *s2, *s3, *s4 = NULL;
d4484 1
a4484 1
	  return FALSE;
d4500 1
a4500 1
  return TRUE;
d4505 1
a4505 1
static bfd_boolean
d4520 1
a4520 1
      return FALSE;
d4528 1
a4528 1
  return TRUE;
d4534 1
a4534 1
static bfd_boolean
d4539 1
a4539 1
     bfd_boolean *pvarargs;
d4550 1
a4550 1
      *pvarargs = FALSE;
d4571 1
a4571 1
		  return FALSE;
d4578 1
a4578 1
	      return FALSE;
d4584 1
a4584 1
	      return FALSE;
d4592 1
a4592 1
		return FALSE;
d4598 1
a4598 1
	    return FALSE;
d4608 1
a4608 1
	*pvarargs = TRUE;
d4612 1
a4612 1
  return TRUE;
d4617 1
a4617 1
static bfd_boolean
d4632 1
a4632 1
    return FALSE;
d4637 1
a4637 1
	return FALSE;
d4649 1
a4649 1
  return TRUE;
d4655 1
a4655 1
static bfd_boolean
d4672 1
a4672 1
	return FALSE;
d4681 1
a4681 1
	return FALSE;
d4695 1
a4695 1
	    if (! ISDIGIT (**pp))
d4698 1
a4698 1
		return FALSE;
d4707 1
a4707 1
	    return FALSE;
d4712 1
a4712 1
	  return FALSE;
d4719 1
a4719 1
	      int_type = debug_make_int_type (minfo->dhandle, 4, FALSE);
d4721 1
a4721 1
					    0, high, FALSE);
d4736 1
a4736 1
	    return FALSE;
d4741 1
a4741 1
	    return FALSE;
d4745 1
a4745 1
	  return FALSE;
d4753 1
a4753 1
	bfd_boolean varargs;
d4761 1
a4761 1
				   ? (bfd_boolean *) NULL
d4763 1
a4763 1
	  return FALSE;
d4770 1
a4770 1
	    return FALSE;
d4774 1
a4774 1
	  return FALSE;
d4785 1
a4785 1
	bfd_boolean memberp, constp, volatilep;
d4788 1
a4788 1
	bfd_boolean varargs;
d4793 2
a4794 2
	constp = FALSE;
	volatilep = FALSE;
d4796 1
a4796 1
	varargs = FALSE;
d4799 1
a4799 1
	if (ISDIGIT (**pp))
d4805 1
a4805 1
		return FALSE;
d4817 1
a4817 1
		  return FALSE;
d4826 1
a4826 1
	      return FALSE;
d4831 1
a4831 1
	    return FALSE;
d4838 1
a4838 1
		constp = TRUE;
d4843 1
a4843 1
		volatilep = TRUE;
d4849 1
a4849 1
		return FALSE;
d4857 1
a4857 1
				       ? (bfd_boolean *) NULL
d4859 1
a4859 1
	      return FALSE;
d4865 1
a4865 1
	    return FALSE;
d4870 1
a4870 1
	  return FALSE;
d4891 1
a4891 1
	return FALSE;
d4897 1
a4897 1
	return FALSE;
d4908 1
a4908 1
	  return FALSE;
d4914 1
a4914 1
	return FALSE;
d4918 1
a4918 1
  return TRUE;
d4924 1
a4924 1
static bfd_boolean
d4931 2
a4932 2
  bfd_boolean constp, volatilep, unsignedp, signedp;
  bfd_boolean done;
d4936 4
a4939 4
  constp = FALSE;
  volatilep = FALSE;
  unsignedp = FALSE;
  signedp = FALSE;
d4941 1
a4941 1
  done = FALSE;
d4947 1
a4947 1
	  constp = TRUE;
d4952 1
a4952 1
	  unsignedp = TRUE;
d4957 1
a4957 1
	  signedp = TRUE;
d4962 1
a4962 1
	  volatilep = TRUE;
d4967 1
a4967 1
	  done = TRUE;
d5072 1
a5072 1
	    *ptype = debug_make_int_type (minfo->dhandle, 2, TRUE);
d5109 1
a5109 1
      if (! ISDIGIT (**pp))
d5112 1
a5112 1
	  return FALSE;
d5121 1
a5121 1
	  return FALSE;
d5137 1
a5137 1
		  return FALSE;
d5149 1
a5149 1
	  return FALSE;
d5157 1
a5157 1
	      return FALSE;
d5164 1
a5164 1
      return FALSE;
d5175 1
a5175 1
  return TRUE;
d5180 1
a5180 1
static bfd_boolean
d5199 1
a5199 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d150 8
a157 4
static char *savestring (const char *, int);
static bfd_vma parse_number (const char **, bfd_boolean *);
static void bad_stab (const char *);
static void warn_stab (const char *, const char *);
d159 1
a159 1
  (void *, struct stab_handle *, int, int, bfd_vma, const char *);
d161 4
a164 2
  (void *, struct stab_handle *, const char *, const char **, debug_type **);
static bfd_boolean parse_stab_type_number (const char **, int *);
d166 8
a173 4
  (void *, struct stab_handle *, const char *, const char **, const int *);
static debug_type parse_stab_sun_builtin_type (void *, const char **);
static debug_type parse_stab_sun_floating_type (void *, const char **);
static debug_type parse_stab_enum_type (void *, const char **);
d175 2
a176 2
  (void *, struct stab_handle *, const char *, const char **,
   bfd_boolean, const int *);
d178 1
a178 1
  (void *, struct stab_handle *, const char **, debug_baseclass **);
d180 2
a181 1
  (void *, struct stab_handle *, const char **, debug_field **, bfd_boolean *);
d183 1
a183 1
  (void *, struct stab_handle *, const char **, debug_field *);
d185 2
a186 2
  (void *, struct stab_handle *, const char **, const char *,
   debug_field *, bfd_boolean *);
d188 2
a189 2
  (void *, struct stab_handle *, const char *, const char **, const int *,
   debug_method **);
d191 2
a192 2
  (void *, struct stab_handle *, debug_type, const char *, const char *,
   debug_type, const char *, bfd_boolean, bfd_boolean, const char **);
d194 2
a195 2
  (void *, struct stab_handle *, const char **, const int *, debug_type *,
   bfd_boolean *);
d197 7
a203 4
  (void *, struct stab_handle *, const char **, bfd_boolean);
static void push_bincl (struct stab_handle *, const char *, bfd_vma);
static const char *pop_bincl (struct stab_handle *);
static bfd_boolean find_excl (struct stab_handle *, const char *, bfd_vma);
d205 8
a212 5
  (void *, struct stab_handle *, const char *, debug_type,
   enum debug_var_kind, bfd_vma);
static bfd_boolean stab_emit_pending_vars (void *, struct stab_handle *);
static debug_type *stab_find_slot (struct stab_handle *, const int *);
static debug_type stab_find_type (void *, struct stab_handle *, const int *);
d214 1
a214 1
  (void *, struct stab_handle *, const int *, debug_type);
d216 1
a216 1
  (void *, struct stab_handle *, int);
d218 2
a219 1
  (void *, struct stab_handle *, const char *, int, enum debug_type_kind);
d221 2
a222 6
  (void *, struct stab_handle *, const char *, bfd_boolean *, unsigned int);
static debug_type *stab_demangle_v3_argtypes
  (void *, struct stab_handle *, const char *, bfd_boolean *);
static debug_type stab_demangle_v3_arg
  (void *, struct stab_handle *, struct demangle_component *, debug_type,
   bfd_boolean *);
d227 3
a229 1
savestring (const char *start, int len)
d242 3
a244 1
parse_number (const char **pp, bfd_boolean *poverflow)
d354 2
a355 1
bad_stab (const char *p)
d363 3
a365 1
warn_stab (const char *p, const char *err)
d372 7
a378 3
void *
start_stab (void *dhandle ATTRIBUTE_UNUSED, bfd *abfd, bfd_boolean sections,
	    asymbol **syms, long symcount)
d392 1
a392 1
  return (void *) ret;
d399 3
a401 1
finish_stab (void *dhandle, void *handle)
d433 7
a439 2
parse_stab (void *dhandle, void *handle, int type, int desc, bfd_vma value,
	    const char *string)
d711 7
a717 2
parse_stab_string (void *dhandle, struct stab_handle *info, int stabtype,
		   int desc, bfd_vma value, const char *string)
d1162 6
a1167 1
parse_stab_type (void *dhandle, struct stab_handle *info, const char *typename, const char **pp, debug_type **slotp)
d1532 1
a1532 1
			  xrealloc (args, alloc * sizeof *args));
d1640 3
a1642 1
parse_stab_type_number (const char **pp, int *typenums)
d1678 6
a1683 1
parse_stab_range_type (void *dhandle, struct stab_handle *info, const char *typename, const char **pp, const int *typenums)
d1867 3
a1869 1
parse_stab_sun_builtin_type (void *dhandle, const char **pp)
d1940 3
a1942 1
parse_stab_sun_floating_type (void *dhandle, const char **pp)
d1978 3
a1980 1
parse_stab_enum_type (void *dhandle, const char **pp)
d2033 1
a2033 1
		   xrealloc (names, alloc * sizeof *names));
d2035 1
a2035 1
		    xrealloc (values, alloc * sizeof *values));
d2056 1
a2056 1
   in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
d2060 7
a2066 3
parse_stab_struct_type (void *dhandle, struct stab_handle *info,
			const char *tagname, const char **pp,
			bfd_boolean structp, const int *typenums)
d2113 1
a2113 1
						       ^^ ^ ^ ^  ^ ^  ^
d2126 5
a2130 2
parse_stab_baseclasses (void *dhandle, struct stab_handle *info,
			const char **pp, debug_baseclass **retp)
d2233 1
a2233 1
	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;
d2242 1
a2242 1
	'/0'	(VISIBILITY_PRIVATE)
d2252 6
a2257 3
parse_stab_struct_fields (void *dhandle, struct stab_handle *info,
			  const char **pp, debug_field **retp,
			  bfd_boolean *staticsp)
d2284 1
a2284 1
		    xrealloc (fields, alloc * sizeof *fields));
d2335 5
a2339 2
parse_stab_cpp_abbrev (void *dhandle, struct stab_handle *info,
		       const char **pp, debug_field *retp)
d2430 7
a2436 3
parse_stab_one_struct_field (void *dhandle, struct stab_handle *info,
			     const char **pp, const char *p,
			     debug_field *retp, bfd_boolean *staticsp)
d2568 7
a2574 3
parse_stab_members (void *dhandle, struct stab_handle *info,
		    const char *tagname, const char **pp,
		    const int *typenums, debug_method **retp)
d2610 1
a2610 1
	  /* This is a completely weird case.  In order to stuff in the
d2834 1
a2834 1
			  xrealloc (variants,
d2866 1
a2866 1
		     xrealloc (methods, alloc * sizeof *methods));
d2889 12
a2900 5
parse_stab_argtypes (void *dhandle, struct stab_handle *info,
		     debug_type class_type, const char *fieldname,
		     const char *tagname, debug_type return_type,
		     const char *argtypes, bfd_boolean constp,
		     bfd_boolean volatilep, const char **pphysname)
a2904 1
  bfd_boolean is_v3;
a2923 1
  is_v3 = argtypes[0] == '_' && argtypes[1] == 'Z';
d2925 1
a2925 1
  if (is_destructor || is_full_physname_constructor || is_v3)
d3018 7
a3024 3
parse_stab_tilde_field (void *dhandle, struct stab_handle *info,
			const char **pp, const int *typenums,
			debug_type *retvptrbase, bfd_boolean *retownvptr)
d3094 5
a3098 2
parse_stab_array_type (void *dhandle, struct stab_handle *info,
		       const char **pp, bfd_boolean stringp)
d3214 4
a3217 1
push_bincl (struct stab_handle *info, const char *name, bfd_vma hash)
d3233 1
a3233 1
		      xrealloc (info->file_types,
d3243 2
a3244 1
pop_bincl (struct stab_handle *info)
d3263 4
a3266 1
find_excl (struct stab_handle *info, const char *name, bfd_vma hash)
d3272 1
a3272 1
		      xrealloc (info->file_types,
d3297 7
a3303 3
stab_record_variable (void *dhandle, struct stab_handle *info,
		      const char *name, debug_type type,
		      enum debug_var_kind kind, bfd_vma val)
d3329 3
a3331 1
stab_emit_pending_vars (void *dhandle, struct stab_handle *info)
d3356 3
a3358 1
stab_find_slot (struct stab_handle *info, const int *typenums)
d3403 4
a3406 1
stab_find_type (void *dhandle, struct stab_handle *info, const int *typenums)
d3429 5
a3433 2
stab_record_type (void *dhandle ATTRIBUTE_UNUSED, struct stab_handle *info,
		  const int *typenums, debug_type type)
d3451 4
a3454 2
stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
			 int typenum)
d3630 6
a3635 2
stab_find_tagged_type (void *dhandle, struct stab_handle *info,
		       const char *p, int len, enum debug_type_kind kind)
d3710 1
a3710 1
  void *dhandle;
d3725 6
a3730 3
static void stab_bad_demangle (const char *);
static unsigned int stab_demangle_count (const char **);
static bfd_boolean stab_demangle_get_count (const char **, unsigned int *);
d3732 1
a3732 1
  (struct stab_demangle_info *, const char **, unsigned int);
d3734 1
a3734 1
  (struct stab_demangle_info *, const char **, const char *);
d3736 1
a3736 1
  (struct stab_demangle_info *, const char **);
d3738 1
a3738 1
  (struct stab_demangle_info *, const char **, debug_type *);
d3740 1
a3740 1
  (struct stab_demangle_info *, const char **, char **);
d3742 1
a3742 1
  (struct stab_demangle_info *, const char **, const char **);
d3744 2
a3745 1
  (struct stab_demangle_info *, const char **, debug_type **, bfd_boolean *);
d3747 2
a3748 2
  (struct stab_demangle_info *, const char **, debug_type **,
   unsigned int *, unsigned int *);
d3750 1
a3750 1
  (struct stab_demangle_info *, const char **, debug_type *);
d3752 1
a3752 1
  (struct stab_demangle_info *, const char **, debug_type *);
d3754 1
a3754 1
  (struct stab_demangle_info *, const char *, int);
d3759 2
a3760 1
stab_bad_demangle (const char *s)
d3768 2
a3769 1
stab_demangle_count (const char **pp)
d3787 3
a3789 1
stab_demangle_get_count (const char **pp, unsigned int *pi)
d3824 6
a3829 3
stab_demangle_argtypes (void *dhandle, struct stab_handle *info,
			const char *physname, bfd_boolean *pvarargs,
			unsigned int physname_len)
a3832 4
  /* Check for the g++ V3 ABI.  */
  if (physname[0] == '_' && physname[1] == 'Z')
    return stab_demangle_v3_argtypes (dhandle, info, physname, pvarargs);

d3873 4
a3876 2
stab_demangle_prefix (struct stab_demangle_info *minfo, const char **pp,
		      unsigned int physname_len)
d3952 4
a3955 2
stab_demangle_function_name (struct stab_demangle_info *minfo,
			     const char **pp, const char *scan)
d3998 3
a4000 1
stab_demangle_signature (struct stab_demangle_info *minfo, const char **pp)
d4114 4
a4117 2
stab_demangle_qualified (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
d4287 4
a4290 2
stab_demangle_template (struct stab_demangle_info *minfo, const char **pp,
			char **pname)
d4510 4
a4513 2
stab_demangle_class (struct stab_demangle_info *minfo ATTRIBUTE_UNUSED,
		     const char **pp, const char **pstart)
d4539 5
a4543 2
stab_demangle_args (struct stab_demangle_info *minfo, const char **pp,
		    debug_type **pargs, bfd_boolean *pvarargs)
d4622 6
a4627 3
stab_demangle_arg (struct stab_demangle_info *minfo, const char **pp,
		   debug_type **pargs, unsigned int *pcount,
		   unsigned int *palloc)
d4660 4
a4663 2
stab_demangle_type (struct stab_demangle_info *minfo, const char **pp,
		    debug_type *ptype)
d4929 4
a4932 2
stab_demangle_fund_type (struct stab_demangle_info *minfo, const char **pp,
			 debug_type *ptype)
d5185 4
a5188 2
stab_demangle_remember_type (struct stab_demangle_info *minfo,
			     const char *p, int len)
a5203 291
}

/* Demangle names encoded using the g++ V3 ABI.  The newer versions of
   g++ which use this ABI do not encode ordinary method argument types
   in a mangled name; they simply output the argument types.  However,
   for a static method, g++ simply outputs the return type and the
   physical name.  So in that case we need to demangle the name here.
   Here PHYSNAME is the physical name of the function, and we set the
   variable pointed at by PVARARGS to indicate whether this function
   is varargs.  This returns NULL, or a NULL terminated array of
   argument types.  */

static debug_type *
stab_demangle_v3_argtypes (void *dhandle, struct stab_handle *info,
			   const char *physname, bfd_boolean *pvarargs)
{
  struct demangle_component *dc;
  void *mem;
  unsigned int alloc, count;
  debug_type *pargs;

  dc = cplus_demangle_v3_components (physname, DMGL_PARAMS | DMGL_ANSI, &mem);
  if (dc == NULL)
    {
      stab_bad_demangle (physname);
      return NULL;
    }

  /* We expect to see TYPED_NAME, and the right subtree describes the
     function type.  */
  if (dc->type != DEMANGLE_COMPONENT_TYPED_NAME
      || dc->u.s_binary.right->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
    {
      fprintf (stderr, _("Demangled name is not a function\n"));
      free (mem);
      return NULL;
    }

  alloc = 10;
  pargs = (debug_type *) xmalloc (alloc * sizeof *pargs);
  *pvarargs = FALSE;

  count = 0;

  for (dc = dc->u.s_binary.right->u.s_binary.right;
       dc != NULL;
       dc = dc->u.s_binary.right)
    {
      debug_type arg;
      bfd_boolean varargs;

      if (dc->type != DEMANGLE_COMPONENT_ARGLIST)
	{
	  fprintf (stderr, _("Unexpected type in demangle tree\n"));
	  free (mem);
	  return NULL;
	}

      arg = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
				  NULL, &varargs);
      if (arg == NULL)
	{
	  if (varargs)
	    {
	      *pvarargs = TRUE;
	      continue;
	    }
	  free (mem);
	  return NULL;
	}

      if (count + 1 >= alloc)
	{
	  alloc += 10;
	  pargs = (debug_type *) xrealloc (pargs, alloc * sizeof *pargs);
	}

      pargs[count] = arg;
      ++count;
    }

  pargs[count] = DEBUG_TYPE_NULL;

  free (mem);

  return pargs;
}

/* Convert a struct demangle_component tree describing an argument
   type into a debug_type.  */

static debug_type
stab_demangle_v3_arg (void *dhandle, struct stab_handle *info,
		      struct demangle_component *dc, debug_type context,
		      bfd_boolean *pvarargs)
{
  debug_type dt;

  if (pvarargs != NULL)
    *pvarargs = FALSE;

  switch (dc->type)
    {
      /* FIXME: These are demangle component types which we probably
	 need to handle one way or another.  */
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    default:
      fprintf (stderr, _("Unrecognized demangle component\n"));
      return NULL;

    case DEMANGLE_COMPONENT_NAME:
      if (context != NULL)
	{
	  const debug_field *fields;

	  fields = debug_get_fields (dhandle, context);
	  if (fields != NULL)
	    {
	      /* Try to find this type by looking through the context
		 class.  */
	      for (; *fields != DEBUG_FIELD_NULL; fields++)
		{
		  debug_type ft;
		  const char *dn;

		  ft = debug_get_field_type (dhandle, *fields);
		  if (ft == NULL)
		    return NULL;
		  dn = debug_get_type_name (dhandle, ft);
		  if (dn != NULL
		      && (int) strlen (dn) == dc->u.s_name.len
		      && strncmp (dn, dc->u.s_name.s, dc->u.s_name.len) == 0)
		    return ft;
		}
	    }
	}
      return stab_find_tagged_type (dhandle, info, dc->u.s_name.s,
				    dc->u.s_name.len, DEBUG_KIND_ILLEGAL);

    case DEMANGLE_COMPONENT_QUAL_NAME:
      context = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
				      context, NULL);
      if (context == NULL)
	return NULL;
      return stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.right,
				   context, NULL);

    case DEMANGLE_COMPONENT_TEMPLATE:
      {
	char *p;
	size_t alc;

	/* We print this component to get a class name which we can
	   use.  FIXME: This probably won't work if the template uses
	   template parameters which refer to an outer template.  */
	p = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, dc, 20, &alc);
	if (p == NULL)
	  {
	    fprintf (stderr, _("Failed to print demangled template\n"));
	    return NULL;
	  }
	dt = stab_find_tagged_type (dhandle, info, p, strlen (p),
				    DEBUG_KIND_CLASS);
	free (p);
	return dt;
      }

    case DEMANGLE_COMPONENT_SUB_STD:
      return stab_find_tagged_type (dhandle, info, dc->u.s_string.string,
				    dc->u.s_string.len, DEBUG_KIND_ILLEGAL);

    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
      dt = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left, NULL,
				 NULL);
      if (dt == NULL)
	return NULL;

      switch (dc->type)
	{
	default:
	  abort ();
	case DEMANGLE_COMPONENT_RESTRICT:
	  /* FIXME: We have no way to represent restrict.  */
	  return dt;
	case DEMANGLE_COMPONENT_VOLATILE:
	  return debug_make_volatile_type (dhandle, dt);
	case DEMANGLE_COMPONENT_CONST:
	  return debug_make_const_type (dhandle, dt);
	case DEMANGLE_COMPONENT_POINTER:
	  return debug_make_pointer_type (dhandle, dt);
	case DEMANGLE_COMPONENT_REFERENCE:
	  return debug_make_reference_type (dhandle, dt);
	}

    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
      {
	char *p;
	size_t alc;
	debug_type ret;

	/* We print this component in order to find out the type name.
	   FIXME: Should we instead expose the
	   demangle_builtin_type_info structure?  */
	p = cplus_demangle_print (DMGL_PARAMS | DMGL_ANSI, dc, 20, &alc);
	if (p == NULL)
	  {
	    fprintf (stderr, _("Couldn't get demangled builtin type\n"));
	    return NULL;
	  }

	/* The mangling is based on the type, but does not itself
	   indicate what the sizes are.  So we have to guess.  */
	if (strcmp (p, "signed char") == 0)
	  ret = debug_make_int_type (dhandle, 1, FALSE);
	else if (strcmp (p, "bool") == 0)
	  ret = debug_make_bool_type (dhandle, 1);
	else if (strcmp (p, "char") == 0)
	  ret = debug_make_int_type (dhandle, 1, FALSE);
	else if (strcmp (p, "double") == 0)
	  ret = debug_make_float_type (dhandle, 8);
	else if (strcmp (p, "long double") == 0)
	  ret = debug_make_float_type (dhandle, 8);
	else if (strcmp (p, "float") == 0)
	  ret = debug_make_float_type (dhandle, 4);
	else if (strcmp (p, "__float128") == 0)
	  ret = debug_make_float_type (dhandle, 16);
	else if (strcmp (p, "unsigned char") == 0)
	  ret = debug_make_int_type (dhandle, 1, TRUE);
	else if (strcmp (p, "int") == 0)
	  ret = debug_make_int_type (dhandle, 4, FALSE);
	else if (strcmp (p, "unsigned int") == 0)
	  ret = debug_make_int_type (dhandle, 4, TRUE);
	else if (strcmp (p, "long") == 0)
	  ret = debug_make_int_type (dhandle, 4, FALSE);
	else if (strcmp (p, "unsigned long") == 0)
	  ret = debug_make_int_type (dhandle, 4, TRUE);
	else if (strcmp (p, "__int128") == 0)
	  ret = debug_make_int_type (dhandle, 16, FALSE);
	else if (strcmp (p, "unsigned __int128") == 0)
	  ret = debug_make_int_type (dhandle, 16, TRUE);
	else if (strcmp (p, "short") == 0)
	  ret = debug_make_int_type (dhandle, 2, FALSE);
	else if (strcmp (p, "unsigned short") == 0)
	  ret = debug_make_int_type (dhandle, 2, TRUE);
	else if (strcmp (p, "void") == 0)
	  ret = debug_make_void_type (dhandle);
	else if (strcmp (p, "wchar_t") == 0)
	  ret = debug_make_int_type (dhandle, 4, TRUE);
	else if (strcmp (p, "long long") == 0)
	  ret = debug_make_int_type (dhandle, 8, FALSE);
	else if (strcmp (p, "unsigned long long") == 0)
	  ret = debug_make_int_type (dhandle, 8, TRUE);
	else if (strcmp (p, "...") == 0)
	  {
	    if (pvarargs == NULL)
	      fprintf (stderr, _("Unexpected demangled varargs\n"));
	    else
	      *pvarargs = TRUE;
	    ret = NULL;
	  }
	else
	  {
	    fprintf (stderr, _("Unrecognized demangled builtin type\n"));
	    ret = NULL;
	  }

	free (p);

	return ret;
      }
    }
@


