head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.54
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.30.16.10.25;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.40;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.33;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.10.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.10.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.48.44;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.14.03.18;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.56;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/*
 * Copyright (c) 1983, 1993, 2001
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "corefile.h"
#include "hist.h"

    /*
     *        opcode of the `callf' instruction
     */
#define	CALLF	0xfe

    /*
     *        register for pc relative addressing
     */
#define	PC	0xf

enum tahoe_opermodes
  {
    literal, indexed, reg, regdef, autodec, autoinc, autoincdef,
    bytedisp, bytedispdef, worddisp, worddispdef, longdisp, longdispdef,
    immediate, absolute, byterel, bytereldef, wordrel, wordreldef,
    longrel, longreldef
  };
typedef enum tahoe_opermodes tahoe_operandenum;

/*
 * A symbol to be the child of indirect callf:
 */
static Sym indirectchild;

static tahoe_operandenum tahoe_operandmode PARAMS ((unsigned char *));
static char *tahoe_operandname PARAMS ((tahoe_operandenum));
static long tahoe_operandlength PARAMS ((unsigned char *));
static bfd_signed_vma tahoe_offset PARAMS ((unsigned char *));
void tahoe_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));

static tahoe_operandenum
tahoe_operandmode (modep)
     unsigned char *modep;
{
  long usesreg = *modep & 0xf;

  switch ((*modep >> 4) & 0xf)
    {
    case 0:
    case 1:
    case 2:
    case 3:
      return literal;
    case 4:
      return indexed;
    case 5:
      return reg;
    case 6:
      return regdef;
    case 7:
      return autodec;
    case 8:
      return usesreg != 0xe ? autoinc : immediate;
    case 9:
      return usesreg != PC ? autoincdef : absolute;
    case 10:
      return usesreg != PC ? bytedisp : byterel;
    case 11:
      return usesreg != PC ? bytedispdef : bytereldef;
    case 12:
      return usesreg != PC ? worddisp : wordrel;
    case 13:
      return usesreg != PC ? worddispdef : wordreldef;
    case 14:
      return usesreg != PC ? longdisp : longrel;
    case 15:
      return usesreg != PC ? longdispdef : longreldef;
    }
  /* NOTREACHED */
  abort ();
}

static char *
tahoe_operandname (mode)
     tahoe_operandenum mode;
{

  switch (mode)
    {
    case literal:
      return "literal";
    case indexed:
      return "indexed";
    case reg:
      return "register";
    case regdef:
      return "register deferred";
    case autodec:
      return "autodecrement";
    case autoinc:
      return "autoincrement";
    case autoincdef:
      return "autoincrement deferred";
    case bytedisp:
      return "byte displacement";
    case bytedispdef:
      return "byte displacement deferred";
    case byterel:
      return "byte relative";
    case bytereldef:
      return "byte relative deferred";
    case worddisp:
      return "word displacement";
    case worddispdef:
      return "word displacement deferred";
    case wordrel:
      return "word relative";
    case wordreldef:
      return "word relative deferred";
    case immediate:
      return "immediate";
    case absolute:
      return "absolute";
    case longdisp:
      return "long displacement";
    case longdispdef:
      return "long displacement deferred";
    case longrel:
      return "long relative";
    case longreldef:
      return "long relative deferred";
    }
  /* NOTREACHED */
  abort ();
}

static long
tahoe_operandlength (modep)
     unsigned char *modep;
{

  switch (tahoe_operandmode (modep))
    {
    case literal:
    case reg:
    case regdef:
    case autodec:
    case autoinc:
    case autoincdef:
      return 1;
    case bytedisp:
    case bytedispdef:
    case byterel:
    case bytereldef:
      return 2;
    case worddisp:
    case worddispdef:
    case wordrel:
    case wordreldef:
      return 3;
    case immediate:
    case absolute:
    case longdisp:
    case longdispdef:
    case longrel:
    case longreldef:
      return 5;
    case indexed:
      return 1 + tahoe_operandlength (modep + 1);
    }
  /* NOTREACHED */
  abort ();
}

static bfd_signed_vma
tahoe_offset (modep)
     unsigned char *modep;
{
  tahoe_operandenum mode = tahoe_operandmode (modep);

  ++modep;				/* skip over the mode */
  switch (mode)
    {
    default:
      fprintf (stderr, "[reladdr] not relative address\n");
      return 0;
    case byterel:
      return 1 + bfd_get_signed_8 (core_bfd, modep);
    case wordrel:
      return 2 + bfd_get_signed_16 (core_bfd, modep);
    case longrel:
      return 4 + bfd_get_signed_32 (core_bfd, modep);
    }
}

void
tahoe_find_call (parent, p_lowpc, p_highpc)
     Sym *parent;
     bfd_vma p_lowpc;
     bfd_vma p_highpc;
{
  unsigned char *instructp;
  long length;
  Sym *child;
  tahoe_operandenum mode;
  tahoe_operandenum firstmode;
  bfd_vma pc, destpc;
  static bfd_boolean inited = FALSE;

  if (!inited)
    {
      inited = TRUE;
      sym_init (&indirectchild);
      indirectchild.cg.prop.fract = 1.0;
      indirectchild.cg.cyc.head = &indirectchild;
    }

  if (core_text_space == 0)
    {
      return;
    }
  if (p_lowpc < s_lowpc)
    {
      p_lowpc = s_lowpc;
    }
  if (p_highpc > s_highpc)
    {
      p_highpc = s_highpc;
    }
  DBG (CALLDEBUG, printf ("[findcall] %s: 0x%lx to 0x%lx\n",
			  parent->name, (unsigned long) p_lowpc,
			  (unsigned long) p_highpc));
  for (pc = p_lowpc; pc < p_highpc; pc += length)
    {
      length = 1;
      instructp = ((unsigned char *) core_text_space
		   + pc - core_text_sect->vma);
      if ((*instructp & 0xff) == CALLF)
	{
	  /*
	   *    maybe a callf, better check it out.
	   *      skip the count of the number of arguments.
	   */
	  DBG (CALLDEBUG, printf ("[findcall]\t0x%lx:callf",
				  (unsigned long) pc));
	  firstmode = tahoe_operandmode (instructp + length);
	  switch (firstmode)
	    {
	    case literal:
	    case immediate:
	      break;
	    default:
	      goto botched;
	    }
	  length += tahoe_operandlength (instructp + length);
	  mode = tahoe_operandmode (instructp + length);
	  DBG (CALLDEBUG,
	       printf ("\tfirst operand is %s", tahoe_operandname (firstmode));
	       printf ("\tsecond operand is %s\n", tahoe_operandname (mode));
	    );
	  switch (mode)
	    {
	    case regdef:
	    case bytedispdef:
	    case worddispdef:
	    case longdispdef:
	    case bytereldef:
	    case wordreldef:
	    case longreldef:
	      /*
	       *    indirect call: call through pointer
	       *      either  *d(r)   as a parameter or local
	       *              (r)     as a return value
	       *              *f      as a global pointer
	       *      [are there others that we miss?,
	       *       e.g. arrays of pointers to functions???]
	       */
	      arc_add (parent, &indirectchild, (unsigned long) 0);
	      length += tahoe_operandlength (instructp + length);
	      continue;
	    case byterel:
	    case wordrel:
	    case longrel:
	      /*
	       *    regular pc relative addressing
	       *      check that this is the address of
	       *      a function.
	       */
	      destpc = pc + tahoe_offset (instructp + length);
	      if (destpc >= s_lowpc && destpc <= s_highpc)
		{
		  child = sym_lookup (&symtab, destpc);
		  DBG (CALLDEBUG,
		       printf ("[findcall]\tdestpc 0x%lx",
			       (unsigned long) destpc);
		       printf (" child->name %s", child->name);
		       printf (" child->addr 0x%lx\n",
			       (unsigned long) child->addr);
		    );
		  if (child->addr == destpc)
		    {
		      /*
		       *    a hit
		       */
		      arc_add (parent, child, (unsigned long) 0);
		      length += tahoe_operandlength (instructp + length);
		      continue;
		    }
		  goto botched;
		}
	      /*
	       *    else:
	       *      it looked like a callf,
	       *      but it wasn't to anywhere.
	       */
	      goto botched;
	    default:
	    botched:
	      /*
	       *    something funny going on.
	       */
	      DBG (CALLDEBUG, printf ("[findcall]\tbut it's a botch\n"));
	      length = 1;
	      continue;
	    }
	}
    }
}
@


1.4
log
@Update BSD licenses to include 'with or without modification'.
From binutils -current.
@
text
@d30 3
a35 1
#include "symtab.h"
d59 1
a59 1
Sym indirectchild;
d61 5
d67 1
a67 1
tahoe_operandenum
d71 1
a71 1
  long usesreg = ((long) *modep) & 0xf;
d73 1
a73 1
  switch (((long) *modep) >> 4)
d109 1
a109 1
char *
d163 1
a163 1
long
d201 3
a203 3
bfd_vma
tahoe_reladdr (modep)
     char *modep;
a205 5
  char *cp;
  short *sp;
  long *lp;
  int i;
  long value = 0;
d207 1
a207 2
  cp = modep;
  ++cp;				/* skip over the mode */
d212 1
a212 1
      return (bfd_vma) modep;
d214 1
a214 1
      return (bfd_vma) (cp + sizeof *cp + *cp);
d216 1
a216 3
      for (i = 0; (size_t) i < sizeof *sp; i++)
	value = (value << 8) + (cp[i] & 0xff);
      return (bfd_vma) (cp + sizeof *sp + value);
d218 1
a218 3
      for (i = 0; (size_t) i < sizeof *lp; i++)
	value = (value << 8) + (cp[i] & 0xff);
      return (bfd_vma) (cp + sizeof *lp + value);
d233 2
a234 2
  bfd_vma destpc;
  static bool inited = FALSE;
d259 1
a259 3
  for (instructp = (unsigned char *) core_text_space + p_lowpc;
       instructp < (unsigned char *) core_text_space + p_highpc;
       instructp += length)
d262 3
a264 1
      if (*instructp == CALLF)
d271 1
a271 3
				  ((unsigned long)
				   (instructp
				    - (unsigned char *) core_text_space))));
d315 1
a315 2
	      destpc = tahoe_reladdr (instructp + length)
		- (bfd_vma) core_text_space;
@


1.3
log
@resolve conflicts.
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 2001 Regents of the University of California.
 * All rights reserved.
d5 23
a27 13
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Regents of the University of California.
d307 1
a307 1
	       *      check that this is the address of 
@


1.1
log
@Initial revision
@
text
@d20 23
a42 1
#include "time_host.h"
d50 2
a51 2
operandenum
operandmode (modep)
d89 1
d93 2
a94 2
operandname (mode)
     operandenum mode;
d143 1
d147 1
a147 1
operandlength (modep)
d151 1
a151 1
  switch (operandmode (modep))
d178 1
a178 1
      return 1 + operandlength (modep + 1);
d181 1
d185 1
a185 1
reladdr (modep)
d188 1
a188 1
  operandenum mode = operandmode (modep);
d205 1
a205 1
      for (i = 0; i < sizeof *sp; i++)
d209 1
a209 1
      for (i = 0; i < sizeof *lp; i++)
d215 2
a216 1
find_call (parent, p_lowpc, p_highpc)
d224 2
a225 2
  operandenum mode;
  operandenum firstmode;
d237 1
a237 1
  if (textspace == 0)
d249 5
a253 4
  DBG (CALLDEBUG, printf ("[findcall] %s: 0x%x to 0x%x\n",
			  parent->name, p_lowpc, p_highpc));
  for (instructp = textspace + p_lowpc;
       instructp < textspace + p_highpc;
d263 5
a267 3
	  DBG (CALLDEBUG, printf ("[findcall]\t0x%x:callf",
				  instructp - textspace));
	  firstmode = operandmode (instructp + length);
d276 2
a277 2
	  length += operandlength (instructp + length);
	  mode = operandmode (instructp + length);
d279 2
a280 2
	       printf ("\tfirst operand is %s", operandname (firstmode));
	       printf ("\tsecond operand is %s\n", operandname (mode));
d299 2
a300 2
	      arc_add (parent, &indirectchild, (long) 0);
	      length += operandlength (instructp + length);
d310 2
a311 2
	      destpc = reladdr (instructp + length)
		- (bfd_vma) textspace;
d314 1
a314 1
		  child = sym_lookup (destpc);
d316 2
a317 1
		       printf ("[findcall]\tdestpc 0x%x", destpc);
d319 2
a320 1
		       printf (" child->addr 0x%x\n", child->addr);
d327 2
a328 2
		      arc_add (parent, child, (long) 0);
		      length += operandlength (instructp + length);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d20 1
a20 23
#include "cg_arcs.h"
#include "corefile.h"
#include "hist.h"
#include "symtab.h"

    /*
     *        opcode of the `callf' instruction
     */
#define	CALLF	0xfe

    /*
     *        register for pc relative addressing
     */
#define	PC	0xf

enum tahoe_opermodes
  {
    literal, indexed, reg, regdef, autodec, autoinc, autoincdef,
    bytedisp, bytedispdef, worddisp, worddispdef, longdisp, longdispdef,
    immediate, absolute, byterel, bytereldef, wordrel, wordreldef,
    longrel, longreldef
  };
typedef enum tahoe_opermodes tahoe_operandenum;
d28 2
a29 2
tahoe_operandenum
tahoe_operandmode (modep)
a66 1
  abort ();
d70 2
a71 2
tahoe_operandname (mode)
     tahoe_operandenum mode;
a119 1
  abort ();
d123 1
a123 1
tahoe_operandlength (modep)
d127 1
a127 1
  switch (tahoe_operandmode (modep))
d154 1
a154 1
      return 1 + tahoe_operandlength (modep + 1);
a156 1
  abort ();
d160 1
a160 1
tahoe_reladdr (modep)
d163 1
a163 1
  tahoe_operandenum mode = tahoe_operandmode (modep);
d180 1
a180 1
      for (i = 0; (size_t) i < sizeof *sp; i++)
d184 1
a184 1
      for (i = 0; (size_t) i < sizeof *lp; i++)
d190 1
a190 2
void
tahoe_find_call (parent, p_lowpc, p_highpc)
d198 2
a199 2
  tahoe_operandenum mode;
  tahoe_operandenum firstmode;
d211 1
a211 1
  if (core_text_space == 0)
d223 4
a226 5
  DBG (CALLDEBUG, printf ("[findcall] %s: 0x%lx to 0x%lx\n",
			  parent->name, (unsigned long) p_lowpc,
			  (unsigned long) p_highpc));
  for (instructp = (unsigned char *) core_text_space + p_lowpc;
       instructp < (unsigned char *) core_text_space + p_highpc;
d236 3
a238 5
	  DBG (CALLDEBUG, printf ("[findcall]\t0x%lx:callf",
				  ((unsigned long)
				   (instructp
				    - (unsigned char *) core_text_space))));
	  firstmode = tahoe_operandmode (instructp + length);
d247 2
a248 2
	  length += tahoe_operandlength (instructp + length);
	  mode = tahoe_operandmode (instructp + length);
d250 2
a251 2
	       printf ("\tfirst operand is %s", tahoe_operandname (firstmode));
	       printf ("\tsecond operand is %s\n", tahoe_operandname (mode));
d270 2
a271 2
	      arc_add (parent, &indirectchild, (unsigned long) 0);
	      length += tahoe_operandlength (instructp + length);
d281 2
a282 2
	      destpc = tahoe_reladdr (instructp + length)
		- (bfd_vma) core_text_space;
d285 1
a285 1
		  child = sym_lookup (&symtab, destpc);
d287 1
a287 2
		       printf ("[findcall]\tdestpc 0x%lx",
			       (unsigned long) destpc);
d289 1
a289 2
		       printf (" child->addr 0x%lx\n",
			       (unsigned long) child->addr);
d296 2
a297 2
		      arc_add (parent, child, (unsigned long) 0);
		      length += tahoe_operandlength (instructp + length);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 2001 Regents of the University of California.
d307 1
a307 1
	       *      check that this is the address of
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 1993, 2001
 *      The Regents of the University of California.  All rights reserved.
d5 13
a17 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a19 3
#include "search_list.h"
#include "source.h"
#include "symtab.h"
d23 1
d47 1
a47 1
static Sym indirectchild;
a48 5
static tahoe_operandenum tahoe_operandmode PARAMS ((unsigned char *));
static char *tahoe_operandname PARAMS ((tahoe_operandenum));
static long tahoe_operandlength PARAMS ((unsigned char *));
static bfd_signed_vma tahoe_offset PARAMS ((unsigned char *));
void tahoe_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
d50 1
a50 1
static tahoe_operandenum
d54 1
a54 1
  long usesreg = *modep & 0xf;
d56 1
a56 1
  switch ((*modep >> 4) & 0xf)
d92 1
a92 1
static char *
d146 1
a146 1
static long
d184 3
a186 3
static bfd_signed_vma
tahoe_offset (modep)
     unsigned char *modep;
d189 5
d195 2
a196 1
  ++modep;				/* skip over the mode */
d201 1
a201 1
      return 0;
d203 1
a203 1
      return 1 + bfd_get_signed_8 (core_bfd, modep);
d205 3
a207 1
      return 2 + bfd_get_signed_16 (core_bfd, modep);
d209 3
a211 1
      return 4 + bfd_get_signed_32 (core_bfd, modep);
d226 2
a227 2
  bfd_vma pc, destpc;
  static bfd_boolean inited = FALSE;
d252 3
a254 1
  for (pc = p_lowpc; pc < p_highpc; pc += length)
d257 1
a257 3
      instructp = ((unsigned char *) core_text_space
		   + pc - core_text_sect->vma);
      if ((*instructp & 0xff) == CALLF)
d264 3
a266 1
				  (unsigned long) pc));
d310 2
a311 1
	      destpc = pc + tahoe_offset (instructp + length);
@


