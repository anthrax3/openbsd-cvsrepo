head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.52
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.54
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.48;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.39;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.30;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.10.07;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.10.07;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.48.39;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.14.02.42;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.55;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* basic_blocks.c  -  Basic-block level related code: reading/writing
   of basic-block info to/from gmon.out; computing and formatting of
   basic-block related statistics.

   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "libiberty.h"
#include "gprof.h"
#include "basic_blocks.h"
#include "corefile.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "sym_ids.h"

static int cmp_bb PARAMS ((const PTR, const PTR));
static int cmp_ncalls PARAMS ((const PTR, const PTR));
static void fskip_string PARAMS ((FILE *));
static void annotate_with_count PARAMS ((char *, unsigned int, int, PTR));

/* Default option values:  */
bfd_boolean bb_annotate_all_lines = FALSE;
unsigned long bb_min_calls = 1;
int bb_table_length = 10;

/* Variables used to compute annotated source listing stats:  */
static long num_executable_lines;
static long num_lines_executed;


/* Helper for sorting.  Compares two symbols and returns result
   such that sorting will be increasing according to filename, line
   number, and address (in that order).  */

static int
cmp_bb (lp, rp)
     const PTR lp;
     const PTR rp;
{
  int r;
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;

  if (left->file && right->file)
    {
      r = strcmp (left->file->name, right->file->name);

      if (r)
	return r;

      if (left->line_num != right->line_num)
	return left->line_num - right->line_num;
    }

  if (left->addr < right->addr)
    return -1;
  else if (left->addr > right->addr)
    return 1;
  else
    return 0;
}


/* Helper for sorting.  Order basic blocks in decreasing number of
   calls, ties are broken in increasing order of line numbers.  */
static int
cmp_ncalls (lp, rp)
     const PTR lp;
     const PTR rp;
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;

  if (!left)
    return 1;
  else if (!right)
    return -1;

  if (left->ncalls < right->ncalls)
    return 1;
  else if (left->ncalls > right->ncalls)
    return -1;

  return left->line_num - right->line_num;
}

/* Skip over variable length string.  */
static void
fskip_string (fp)
     FILE *fp;
{
  int ch;

  while ((ch = fgetc (fp)) != EOF)
    {
      if (ch == '\0')
	break;
    }
}

/* Read a basic-block record from file IFP.  FILENAME is the name
   of file IFP and is provided for formatting error-messages only.  */

void
bb_read_rec (ifp, filename)
     FILE *ifp;
     const char *filename;
{
  int nblocks, b;
  bfd_vma addr, ncalls;
  Sym *sym;

  if (gmon_io_read_32 (ifp, &nblocks))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
      done (1);
    }

  nblocks = bfd_get_32 (core_bfd, (bfd_byte *) & nblocks);
  if (gmon_file_version == 0)
    fskip_string (ifp);

  for (b = 0; b < nblocks; ++b)
    {
      if (gmon_file_version == 0)
	{
	  int line_num;

	  /* Version 0 had lots of extra stuff that we don't
	     care about anymore.  */
	  if ((fread (&ncalls, sizeof (ncalls), 1, ifp) != 1)
	      || (fread (&addr, sizeof (addr), 1, ifp) != 1)
	      || (fskip_string (ifp), FALSE)
	      || (fskip_string (ifp), FALSE)
	      || (fread (&line_num, sizeof (line_num), 1, ifp) != 1))
	    {
	      perror (filename);
	      done (1);
	    }
	}
      else if (gmon_io_read_vma (ifp, &addr)
	       || gmon_io_read_vma (ifp, &ncalls))
	{
	  perror (filename);
	  done (1);
	}

      /* Basic-block execution counts are meaningful only if we're
	 profiling at the line-by-line level:  */
      if (line_granularity)
	{
	  sym = sym_lookup (&symtab, addr);

	  if (sym)
	    {
	      int i;

	      DBG (BBDEBUG,
		   printf ("[bb_read_rec] 0x%lx->0x%lx (%s:%d) cnt=%lu\n",
			   (unsigned long) addr, (unsigned long) sym->addr,
			   sym->name, sym->line_num, (unsigned long) ncalls));

	      for (i = 0; i < NBBS; i++)
		{
		  if (! sym->bb_addr[i] || sym->bb_addr[i] == addr)
		    {
		      sym->bb_addr[i] = addr;
		      sym->bb_calls[i] += ncalls;
		      break;
		    }
		}
	    }
	}
      else
	{
	  static bfd_boolean user_warned = FALSE;

	  if (!user_warned)
	    {
	      user_warned = TRUE;
	      fprintf (stderr,
  _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
		       whoami);
	    }
	}
    }
  return;
}

/* Write all basic-blocks with non-zero counts to file OFP.  FILENAME
   is the name of OFP and is provided for producing error-messages
   only.  */
void
bb_write_blocks (ofp, filename)
     FILE *ofp;
     const char *filename;
{
  unsigned int nblocks = 0;
  Sym *sym;
  int i;

  /* Count how many non-zero blocks with have:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
	;
      nblocks += i;
    }

  /* Write header:  */
  if (gmon_io_write_8 (ofp, GMON_TAG_BB_COUNT)
      || gmon_io_write_32 (ofp, nblocks))
    {
      perror (filename);
      done (1);
    }

  /* Write counts:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
	{
	  if (gmon_io_write_vma (ofp, sym->bb_addr[i])
	      || gmon_io_write_vma (ofp, (bfd_vma) sym->bb_calls[i]))
	    {
	      perror (filename);
	      done (1);
	    }
	}
    }
}

/* Output basic-block statistics in a format that is easily parseable.
   Current the format is:

	<filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>  */

void
print_exec_counts ()
{
  Sym **sorted_bbs, *sym;
  unsigned int i, j, len;

  if (first_output)
    first_output = FALSE;
  else
    printf ("\f\n");

  /* Sort basic-blocks according to function name and line number:  */
  sorted_bbs = (Sym **) xmalloc (symtab.len * sizeof (sorted_bbs[0]));
  len = 0;

  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      /* Accept symbol if it's in the INCL_EXEC table
	 or there is no INCL_EXEC table
	 and it does not appear in the EXCL_EXEC table.  */
      if (sym_lookup (&syms[INCL_EXEC], sym->addr)
	  || (syms[INCL_EXEC].len == 0
	      && !sym_lookup (&syms[EXCL_EXEC], sym->addr)))
	{
	  sorted_bbs[len++] = sym;
	}
    }

  qsort (sorted_bbs, len, sizeof (sorted_bbs[0]), cmp_bb);

  /* Output basic-blocks:  */

  for (i = 0; i < len; ++i)
    {
      if (sym->ncalls > 0 || ! ignore_zeros)
	{
	  /* FIXME: This only works if bfd_vma is unsigned long.  */
	  printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		  sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		  sym->name, (unsigned long) sym->addr, sym->ncalls);
	}

      for (j = 0; j < NBBS && sym->bb_addr[j]; j ++)
	{
	  if (sym->bb_calls[j] > 0 || ! ignore_zeros)
	    {
	      /* FIXME: This only works if bfd_vma is unsigned long.  */
	      printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		      sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		      sym->name, (unsigned long) sym->bb_addr[j],
		      sym->bb_calls[j]);
	    }
	}
    }
  free (sorted_bbs);
}

/* Helper for bb_annotated_source: format annotation containing
   number of line executions.  Depends on being called on each
   line of a file in sequential order.

   Global variable bb_annotate_all_lines enables execution count
   compression (counts are supressed if identical to the last one)
   and prints counts on all executed lines.  Otherwise, print
   all basic-block execution counts exactly once on the line
   that starts the basic-block.  */

static void
annotate_with_count (buf, width, line_num, arg)
     char *buf;
     unsigned int width;
     int line_num;
     PTR arg;
{
  Source_File *sf = arg;
  Sym *b;
  unsigned int i;
  static unsigned long last_count;
  unsigned long last_print = (unsigned long) -1;

  b = NULL;

  if (line_num <= sf->num_lines)
    b = sf->line[line_num - 1];

  if (!b)
    {
      for (i = 0; i < width; i++)
	buf[i] = ' ';
      buf[width] = '\0';
    }
  else
    {
      char tmpbuf[NBBS * 30];
      char *p;
      unsigned long ncalls;
      int ncalls_set;
      unsigned int len;

      ++num_executable_lines;

      p = tmpbuf;
      *p = '\0';

      ncalls = 0;
      ncalls_set = 0;

      /* If this is a function entry point, label the line no matter what.
	 Otherwise, we're in the middle of a function, so check to see
	 if the first basic-block address is larger than the starting
	 address of the line.  If so, then this line begins with a
	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
      if (b->is_func)
	{
	  sprintf (p, "%lu", b->ncalls);
	  p += strlen (p);
	  last_count = b->ncalls;
	  last_print = last_count;
	  ncalls = b->ncalls;
	  ncalls_set = 1;
	}
      else if (bb_annotate_all_lines
	       && b->bb_addr[0] && b->bb_addr[0] > b->addr)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  last_print = last_count;
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      /* Loop through all of this line's basic-blocks.  For each one,
	 update last_count, then compress sequential identical counts
	 (if bb_annotate_all_lines) and print the execution count.  */

      for (i = 0; i < NBBS && b->bb_addr[i]; i++)
	{
	  last_count = b->bb_calls[i];
	  if (! ncalls_set)
	    {
	      ncalls = 0;
	      ncalls_set = 1;
	    }
	  ncalls += last_count;

	  if (bb_annotate_all_lines && last_count == last_print)
	    continue;

	  if (p > tmpbuf)
	    *p++ = ',';
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);

	  last_print = last_count;
	}

      /* We're done.  If nothing has been printed on this line,
	 print the last execution count (bb_annotate_all_lines),
	 which could be from either a previous line (if there were
	 no BBs on this line), or from this line (if all our BB
	 counts were compressed out because they were identical).  */

      if (bb_annotate_all_lines && p == tmpbuf)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      if (! ncalls_set)
	{
	  unsigned int c;

	  for (c = 0; c < width; c++)
	    buf[c] = ' ';
	  buf[width] = '\0';
	  return;
	}

      ++num_lines_executed;

      if (ncalls < bb_min_calls)
	{
	  strcpy (tmpbuf, "#####");
	  p = tmpbuf + 5;
	}

      strcpy (p, " -> ");
      p += 4;

      len = p - tmpbuf;
      if (len >= width)
	{
	  strncpy (buf, tmpbuf, width);
	  buf[width] = '\0';
	}
      else
	{
	  unsigned int c;

	  strcpy (buf + width - len, tmpbuf);
	  for (c = 0; c < width - len; ++c)
	    buf[c] = ' ';
	}
    }
}

/* Annotate the files named in SOURCE_FILES with basic-block statistics
   (execution counts).  After each source files, a few statistics
   regarding that source file are printed.  */

void
print_annotated_source ()
{
  Sym *sym, *line_stats, *new_line;
  Source_File *sf;
  int i, table_len;
  FILE *ofp;

  /* Find maximum line number for each source file that user is
     interested in:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      /* Accept symbol if it's file is known, its line number is
	 bigger than anything we have seen for that file so far and
	 if it's in the INCL_ANNO table or there is no INCL_ANNO
	 table and it does not appear in the EXCL_ANNO table.  */
      if (sym->file && sym->line_num > sym->file->num_lines
	  && (sym_lookup (&syms[INCL_ANNO], sym->addr)
	      || (syms[INCL_ANNO].len == 0
		  && !sym_lookup (&syms[EXCL_ANNO], sym->addr))))
	{
	  sym->file->num_lines = sym->line_num;
	}
    }

  /* Allocate line descriptors:  */
  for (sf = first_src_file; sf; sf = sf->next)
    {
      if (sf->num_lines > 0)
	{
	  sf->line = (void *) xmalloc (sf->num_lines * sizeof (sf->line[0]));
	  memset (sf->line, 0, sf->num_lines * sizeof (sf->line[0]));
	}
    }

  /* Count executions per line:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      if (sym->file && sym->file->num_lines
	  && (sym_lookup (&syms[INCL_ANNO], sym->addr)
	      || (syms[INCL_ANNO].len == 0
		  && !sym_lookup (&syms[EXCL_ANNO], sym->addr))))
	{
	  sym->file->ncalls += sym->ncalls;
	  line_stats = sym->file->line[sym->line_num - 1];

	  if (!line_stats)
	    {
	      /* Common case has at most one basic-block per source line:  */
	      sym->file->line[sym->line_num - 1] = sym;
	    }
	  else if (!line_stats->addr)
	    {
	      /* sym is the 3rd .. nth basic block for this line:  */
	      line_stats->ncalls += sym->ncalls;
	    }
	  else
	    {
	      /* sym is the second basic block for this line.  */
	      new_line = (Sym *) xmalloc (sizeof (*new_line));
	      *new_line = *line_stats;
	      new_line->addr = 0;
	      new_line->ncalls += sym->ncalls;
	      sym->file->line[sym->line_num - 1] = new_line;
	    }
	}
    }

  /* Plod over source files, annotating them:  */
  for (sf = first_src_file; sf; sf = sf->next)
    {
      if (!sf->num_lines || (ignore_zeros && sf->ncalls == 0))
	continue;

      num_executable_lines = num_lines_executed = 0;

      ofp = annotate_source (sf, 16, annotate_with_count, sf);
      if (!ofp)
	continue;

      if (bb_table_length > 0)
	{
	  fprintf (ofp, _("\n\nTop %d Lines:\n\n     Line      Count\n\n"),
		   bb_table_length);

	  /* Abuse line arrays---it's not needed anymore:  */
	  qsort (sf->line, sf->num_lines, sizeof (sf->line[0]), cmp_ncalls);
	  table_len = bb_table_length;

	  if (table_len > sf->num_lines)
	    table_len = sf->num_lines;

	  for (i = 0; i < table_len; ++i)
	    {
	      sym = sf->line[i];

	      if (!sym || sym->ncalls == 0)
		  break;

	      fprintf (ofp, "%9d %10lu\n", sym->line_num, sym->ncalls);
	    }
	}

      free (sf->line);
      sf->line = 0;

      fprintf (ofp, _("\nExecution Summary:\n\n"));
      fprintf (ofp, _("%9ld   Executable lines in this file\n"),
	       num_executable_lines);
      fprintf (ofp, _("%9ld   Lines executed\n"), num_lines_executed);
      fprintf (ofp, _("%9.2f   Percent of the file executed\n"),
	       num_executable_lines
	       ? 100.0 * num_lines_executed / (double) num_executable_lines
	       : 100.0);
      fprintf (ofp, _("\n%9lu   Total number of line executions\n"),
	       sf->ncalls);
      fprintf (ofp, _("%9.2f   Average executions per line\n"),
	       num_executable_lines
	       ? (double) sf->ncalls / (double) num_executable_lines
	       : 0.0);

      if (ofp != stdout)
	fclose (ofp);
    }
}
@


1.3
log
@resolve conflicts.
@
text
@d5 1
a5 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d24 2
a25 1
#include <stdio.h>
d30 1
a30 2
#include "gprof.h"
#include "libiberty.h"
d32 1
d34 5
a38 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d41 1
a41 1
bool bb_annotate_all_lines = FALSE;
d55 3
a57 1
DEFUN (cmp_bb, (lp, rp), const void *lp AND const void *rp)
d86 3
a88 1
DEFUN (cmp_ncalls, (lp, rp), const void *lp AND const void *rp)
d108 2
a109 1
DEFUN (fskip_string, (fp), FILE * fp)
d124 3
a126 1
DEFUN (bb_read_rec, (ifp, filename), FILE * ifp AND const char *filename)
d196 1
a196 1
	  static bool user_warned = FALSE;
d214 3
a216 1
DEFUN (bb_write_blocks, (ofp, filename), FILE * ofp AND const char *filename)
d218 1
a218 1
  int nblocks = 0;
d244 1
a244 1
	      || gmon_io_write_vma (ofp, sym->bb_calls[i]))
d259 1
a259 1
DEFUN_VOID (print_exec_counts)
d262 1
a262 1
  int i, j, len;
d326 5
a330 2
DEFUN (annotate_with_count, (buf, width, line_num, arg),
       char *buf AND int width AND int line_num AND void *arg)
d334 1
a334 1
  int i;
d355 1
a355 1
      int len;
d431 1
a431 1
	  int c;
d458 1
a458 1
	  int c;
d472 1
a472 1
DEFUN_VOID (print_annotated_source)
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 23
a23 5
/*
 * Basic-block level related code: reading/writing of basic-block info
 * to/from gmon.out; computing and formatting of basic-block related
 * statistics.
 */
a24 1
#include <unistd.h>
d33 3
d37 1
a37 4

/*
 * Default option values:
 */
d42 1
a42 3
/*
 * Variables used to compute annotated source listing stats:
 */
d47 3
a49 5
/*
 * Helper for sorting.  Compares two symbols and returns result
 * such that sorting will be increasing according to filename, line
 * number, and address (in that order).
 */
d61 1
d63 1
a63 3
	{
	  return r;
	}
d66 1
a66 3
	{
	  return left->line_num - right->line_num;
	}
d70 1
a70 3
    {
      return -1;
    }
d72 1
a72 3
    {
      return 1;
    }
d74 1
a74 3
    {
      return 0;
    }
d78 2
a79 4
/*
 * Helper for sorting.  Order basic blocks in decreasing number of
 * calls, ties are broken in increasing order of line numbers.
 */
d87 1
a87 3
    {
      return 1;
    }
d89 1
a89 3
    {
      return -1;
    }
d99 1
a99 4

/*
 * Skip over variable length string.
 */
d108 1
a108 3
	{
	  break;
	}
d112 2
a114 4
/*
 * Read a basic-block record from file IFP.  FILENAME is the name
 * of file IFP and is provided for formatting error-messages only.
 */
d119 1
a119 2
  bfd_vma addr;
  unsigned long ncalls;
d122 1
a122 1
  if (fread (&nblocks, sizeof (nblocks), 1, ifp) != 1)
d124 2
a125 1
      fprintf (stderr, _("%s: %s: unexpected end of file\n"), whoami, filename);
d131 1
a131 3
    {
      fskip_string (ifp);
    }
d138 3
a140 4
	  /*
	   * Version 0 had lots of extra stuff that we don't
	   * care about anymore.
	   */
d151 2
a152 1
      else
d154 2
a155 6
	  if (fread (&addr, sizeof (addr), 1, ifp) != 1
	      || fread (&ncalls, sizeof (ncalls), 1, ifp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
d158 2
a159 4
      /*
       * Basic-block execution counts are meaningful only if we're
       * profiling at the line-by-line level:
       */
a161 6

	  /* convert from target to host endianness: */

	  addr = get_vma (core_bfd, (bfd_byte *) & addr);
	  ncalls = bfd_get_32 (core_bfd, (bfd_byte *) &ncalls);

d171 1
a171 1
			   sym->name, sym->line_num, ncalls));
d192 1
a192 1
		       _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
d200 3
a202 6

/*
 * Write all basic-blocks with non-zero counts to file OFP.  FILENAME
 * is the name of OFP and is provided for producing error-messages
 * only.
 */
a205 1
  const unsigned char tag = GMON_TAG_BB_COUNT;
a206 2
  bfd_vma addr;
  unsigned long ncalls;
d210 1
a210 2
  /* count how many non-zero blocks with have: */

d218 3
a220 4
  /* write header: */
  bfd_put_32 (core_bfd, nblocks, (bfd_byte *) & nblocks);
  if (fwrite (&tag, sizeof (tag), 1, ofp) != 1
      || fwrite (&nblocks, sizeof (nblocks), 1, ofp) != 1)
d226 1
a226 1
  /* write counts: */
d231 2
a232 5
	  put_vma (core_bfd, sym->bb_addr[i], (bfd_byte *) & addr);
	  bfd_put_32 (core_bfd, sym->bb_calls[i], (bfd_byte *) & ncalls);

	  if (fwrite (&addr, sizeof (addr), 1, ofp) != 1
	      || fwrite (&ncalls, sizeof (ncalls), 1, ofp) != 1)
d241 4
a245 6
/*
 * Output basic-block statistics in a format that is easily parseable.
 * Current the format is:
 *
 *      <filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>
 */
d253 1
a253 3
    {
      first_output = FALSE;
    }
d255 1
a255 5
    {
      printf ("\f\n");
    }

  /* sort basic-blocks according to function name and line number: */
d257 1
d260 1
d263 3
a265 5
      /*
       * Accept symbol if it's in the INCL_EXEC table
       * or there is no INCL_EXEC table
       *    and it does not appear in the EXCL_EXEC table.
       */
d273 1
d276 1
a276 1
  /* output basic-blocks: */
d287 1
d303 9
a311 11
/*
 * Helper for bb_annotated_source: format annotation containing
 * number of line executions.  Depends on being called on each
 * line of a file in sequential order.
 *
 * Global variable bb_annotate_all_lines enables execution count
 * compression (counts are supressed if identical to the last one)
 * and prints counts on all executed lines.  Otherwise, print
 * all basic-block execution counts exactly once on the line
 * that starts the basic-block.
 */
d324 1
d326 2
a327 3
    {
      b = sf->line[line_num - 1];
    }
d351 5
a355 7
       * Otherwise, we're in the middle of a function, so check to see
       * if the first basic-block address is larger than the starting
       * address of the line.  If so, then this line begins with a
       * a portion of the previous basic-block, so print that prior
       * execution count (if bb_annotate_all_lines is set).
       */

d376 2
a377 3
       * update last_count, then compress sequential identical counts
       * (if bb_annotate_all_lines) and print the execution count.
       */
d390 1
a390 3
	    {
	      continue;
	    }
d401 4
a404 5
       * print the last execution count (bb_annotate_all_lines),
       * which could be from either a previous line (if there were
       * no BBs on this line), or from this line (if all our BB
       * counts were compressed out because they were identical).
       */
d452 4
a455 5
/*
 * Annotate the files named in SOURCE_FILES with basic-block statistics
 * (execution counts).  After each source files, a few statistics
 * regarding that source file are printed.
 */
d464 2
a465 4
  /*
   * Find maximum line number for each source file that user is
   * interested in:
   */
d468 4
a471 6
      /*
       * Accept symbol if it's file is known, its line number is
       * bigger than anything we have seen for that file so far and
       * if it's in the INCL_ANNO table or there is no INCL_ANNO
       * table and it does not appear in the EXCL_ANNO table.
       */
d481 1
a481 2
  /* allocate line descriptors: */

d491 1
a491 2
  /* count executions per line: */

d501 1
d504 1
a504 1
	      /* common case has at most one basic-block per source line: */
d509 1
a509 1
	      /* sym is the 3rd .. nth basic block for this line: */
d514 1
a514 1
	      /* sym is the second basic block for this line */
d524 1
a524 2
  /* plod over source files, annotating them: */

d528 1
a528 3
	{
	  continue;
	}
d531 1
d534 1
a534 3
	{
	  continue;
	}
d541 1
a541 1
	  /* abuse line arrays---it's not needed anymore: */
d544 1
d546 2
a547 3
	    {
	      table_len = sf->num_lines;
	    }
d551 1
a552 1
		{
d554 1
a554 1
		}
d576 1
d578 1
a578 3
	{
	  fclose (ofp);
	}
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
#include "core.h"
d22 1
a22 1
int bb_min_calls = 1;
d33 1
a33 1
 * Helper for sorting.  Compares two basic-blocks and returns result
d35 1
a35 1
 * number, and basic-block address (in that order).
d37 1
d93 4
a96 4
  if (right->ncalls != left->ncalls)
    {
      return right->ncalls - left->ncalls;
    }
d129 1
a129 1
  long ncalls;
d134 1
a134 1
      fprintf (stderr, "%s: %s: unexpected end of file\n", whoami, filename);
d183 1
a185 2
	  sym->is_bb_head = TRUE;
	  sym->ncalls += bfd_get_32 (core_bfd, (bfd_byte *) & ncalls);
d187 19
a205 2
	  DBG (BBDEBUG, printf ("[bb_read_rec] 0x%lx->0x%lx (%s) cnt=%d\n",
				addr, sym->addr, sym->name, sym->ncalls));
d215 1
a215 1
		       "%s: warning: ignoring basic-block exec counts (use -l or --line)\n",
d235 1
a235 1
  long ncalls;
d237 1
d243 3
a245 4
      if (sym->ncalls > 0)
	{
	  ++nblocks;
	}
d260 1
a260 1
      if (sym->ncalls == 0)
d262 2
a263 2
	  continue;
	}
d265 6
a270 8
      put_vma (core_bfd, sym->addr, (bfd_byte *) & addr);
      bfd_put_32 (core_bfd, sym->ncalls, (bfd_byte *) & ncalls);

      if (fwrite (&addr, sizeof (addr), 1, ofp) != 1
	  || fwrite (&ncalls, sizeof (ncalls), 1, ofp) != 1)
	{
	  perror (filename);
	  done (1);
d286 1
a286 1
  int i, len;
d304 3
a306 4
       * Accept symbol if it's the start of a basic-block and it is
       * called at least bb_min_calls times and if it's in the
       * INCL_EXEC table or there is no INCL_EXEC table and it does
       * not appear in the EXCL_EXEC table.
d308 3
a310 4
      if (sym->is_bb_head && sym->ncalls >= bb_min_calls
	  && (sym_lookup (&syms[INCL_EXEC], sym->addr)
	      || (syms[INCL_EXEC].len == 0
		  && !sym_lookup (&syms[EXCL_EXEC], sym->addr))))
d321 18
a338 4
      sym = sorted_bbs[i];
      printf ("%s:%d: (%s:0x%lx) %d executions\n",
	      sym->file ? sym->file->name : "<unknown>", sym->line_num,
	      sym->name, sym->addr, sym->ncalls);
a342 1

d345 8
a352 1
 * number of line executions.
d354 1
d361 3
a363 7
  long cnt;
  static long last_count;

  if (line_num == 1)
    {
      last_count = -1;
    }
d365 1
a365 1
  b = 0;
d372 3
a374 1
      cnt = -1;
d378 6
d385 87
a471 4
      cnt = b->ncalls;
    }
  if (cnt > 0)
    {
a472 5
    }
  if (cnt < 0 && bb_annotate_all_lines)
    {
      cnt = last_count;
    }
d474 23
a496 7
  if (cnt < 0)
    {
      strcpy (buf, "\t\t");
    }
  else if (cnt < bb_min_calls)
    {
      strcpy (buf, "       ##### -> ");
a497 5
  else
    {
      sprintf (buf, "%12ld -> ", cnt);
    }
  last_count = cnt;
a499 1

d549 1
a549 1
      if (sym->is_bb_head && sym->file && sym->file->num_lines
d596 1
a596 1
	  fprintf (ofp, "\n\nTop %d Lines:\n\n     Line      Count\n\n",
d609 1
a609 1
	      if (!sym || sym->ncalls <= 0)
d613 1
a613 1
	      fprintf (ofp, "%9d %10d\n", sym->line_num, sym->ncalls);
d620 2
a621 2
      fprintf (ofp, "\nExecution Summary:\n\n");
      fprintf (ofp, "%9ld   Executable lines in this file\n",
d623 2
a624 2
      fprintf (ofp, "%9ld   Lines executed\n", num_lines_executed);
      fprintf (ofp, "%9.2f   Percent of the file executed\n",
d628 3
a630 2
      fprintf (ofp, "\n%9d   Total number of line executions\n", sf->ncalls);
      fprintf (ofp, "%9.2f   Average executions per line\n",
d632 1
a632 1
	       ? sf->ncalls / (double) num_executable_lines
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d9 1
a9 1
#include "corefile.h"
d22 1
a22 1
unsigned long bb_min_calls = 1;
d33 1
a33 1
 * Helper for sorting.  Compares two symbols and returns result
d35 1
a35 1
 * number, and address (in that order).
a36 1

d92 4
a95 4
  if (left->ncalls < right->ncalls)
    return 1;
  else if (left->ncalls > right->ncalls)
    return -1;
d128 1
a128 1
  unsigned long ncalls;
d133 1
a133 1
      fprintf (stderr, _("%s: %s: unexpected end of file\n"), whoami, filename);
a181 1
	  ncalls = bfd_get_32 (core_bfd, (bfd_byte *) &ncalls);
d184 2
d187 2
a188 19
	  if (sym)
	    {
	      int i;

	      DBG (BBDEBUG,
		   printf ("[bb_read_rec] 0x%lx->0x%lx (%s:%d) cnt=%lu\n",
			   (unsigned long) addr, (unsigned long) sym->addr,
			   sym->name, sym->line_num, ncalls));

	      for (i = 0; i < NBBS; i++)
		{
		  if (! sym->bb_addr[i] || sym->bb_addr[i] == addr)
		    {
		      sym->bb_addr[i] = addr;
		      sym->bb_calls[i] += ncalls;
		      break;
		    }
		}
	    }
d198 1
a198 1
		       _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
d218 1
a218 1
  unsigned long ncalls;
a219 1
  int i;
d225 4
a228 3
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
	;
      nblocks += i;
d243 1
a243 1
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
d245 2
a246 2
	  put_vma (core_bfd, sym->bb_addr[i], (bfd_byte *) & addr);
	  bfd_put_32 (core_bfd, sym->bb_calls[i], (bfd_byte *) & ncalls);
d248 8
a255 6
	  if (fwrite (&addr, sizeof (addr), 1, ofp) != 1
	      || fwrite (&ncalls, sizeof (ncalls), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
d271 1
a271 1
  int i, j, len;
d289 4
a292 3
       * Accept symbol if it's in the INCL_EXEC table
       * or there is no INCL_EXEC table
       *    and it does not appear in the EXCL_EXEC table.
d294 4
a297 3
      if (sym_lookup (&syms[INCL_EXEC], sym->addr)
	  || (syms[INCL_EXEC].len == 0
	      && !sym_lookup (&syms[EXCL_EXEC], sym->addr)))
d308 4
a311 18
      if (sym->ncalls > 0 || ! ignore_zeros)
	{
	  /* FIXME: This only works if bfd_vma is unsigned long.  */
	  printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		  sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		  sym->name, (unsigned long) sym->addr, sym->ncalls);
	}
      for (j = 0; j < NBBS && sym->bb_addr[j]; j ++)
	{
	  if (sym->bb_calls[j] > 0 || ! ignore_zeros)
	    {
	      /* FIXME: This only works if bfd_vma is unsigned long.  */
	      printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		      sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		      sym->name, (unsigned long) sym->bb_addr[j],
		      sym->bb_calls[j]);
	    }
	}
d316 1
d319 1
a319 8
 * number of line executions.  Depends on being called on each
 * line of a file in sequential order.
 *
 * Global variable bb_annotate_all_lines enables execution count
 * compression (counts are supressed if identical to the last one)
 * and prints counts on all executed lines.  Otherwise, print
 * all basic-block execution counts exactly once on the line
 * that starts the basic-block.
a320 1

d327 7
a333 3
  int i;
  static unsigned long last_count;
  unsigned long last_print = (unsigned long) -1;
d335 1
a335 1
  b = NULL;
d342 1
a342 3
      for (i = 0; i < width; i++)
	buf[i] = ' ';
      buf[width] = '\0';
a345 6
      char tmpbuf[NBBS * 30];
      char *p;
      unsigned long ncalls;
      int ncalls_set;
      int len;

d347 4
a350 87

      p = tmpbuf;
      *p = '\0';

      ncalls = 0;
      ncalls_set = 0;

      /* If this is a function entry point, label the line no matter what.
       * Otherwise, we're in the middle of a function, so check to see
       * if the first basic-block address is larger than the starting
       * address of the line.  If so, then this line begins with a
       * a portion of the previous basic-block, so print that prior
       * execution count (if bb_annotate_all_lines is set).
       */

      if (b->is_func)
	{
	  sprintf (p, "%lu", b->ncalls);
	  p += strlen (p);
	  last_count = b->ncalls;
	  last_print = last_count;
	  ncalls = b->ncalls;
	  ncalls_set = 1;
	}
      else if (bb_annotate_all_lines
	       && b->bb_addr[0] && b->bb_addr[0] > b->addr)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  last_print = last_count;
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      /* Loop through all of this line's basic-blocks.  For each one,
       * update last_count, then compress sequential identical counts
       * (if bb_annotate_all_lines) and print the execution count.
       */

      for (i = 0; i < NBBS && b->bb_addr[i]; i++)
	{
	  last_count = b->bb_calls[i];
	  if (! ncalls_set)
	    {
	      ncalls = 0;
	      ncalls_set = 1;
	    }
	  ncalls += last_count;

	  if (bb_annotate_all_lines && last_count == last_print)
	    {
	      continue;
	    }

	  if (p > tmpbuf)
	    *p++ = ',';
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);

	  last_print = last_count;
	}

      /* We're done.  If nothing has been printed on this line,
       * print the last execution count (bb_annotate_all_lines),
       * which could be from either a previous line (if there were
       * no BBs on this line), or from this line (if all our BB
       * counts were compressed out because they were identical).
       */

      if (bb_annotate_all_lines && p == tmpbuf)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      if (! ncalls_set)
	{
	  int c;

	  for (c = 0; c < width; c++)
	    buf[c] = ' ';
	  buf[width] = '\0';
	  return;
	}

d352 5
d358 11
a368 23
      if (ncalls < bb_min_calls)
	{
	  strcpy (tmpbuf, "#####");
	  p = tmpbuf + 5;
	}

      strcpy (p, " -> ");
      p += 4;

      len = p - tmpbuf;
      if (len >= width)
	{
	  strncpy (buf, tmpbuf, width);
	  buf[width] = '\0';
	}
      else
	{
	  int c;

	  strcpy (buf + width - len, tmpbuf);
	  for (c = 0; c < width - len; ++c)
	    buf[c] = ' ';
	}
d370 1
d373 1
d423 1
a423 1
      if (sym->file && sym->file->num_lines
d470 1
a470 1
	  fprintf (ofp, _("\n\nTop %d Lines:\n\n     Line      Count\n\n"),
d483 1
a483 1
	      if (!sym || sym->ncalls == 0)
d487 1
a487 1
	      fprintf (ofp, "%9d %10lu\n", sym->line_num, sym->ncalls);
d494 2
a495 2
      fprintf (ofp, _("\nExecution Summary:\n\n"));
      fprintf (ofp, _("%9ld   Executable lines in this file\n"),
d497 2
a498 2
      fprintf (ofp, _("%9ld   Lines executed\n"), num_lines_executed);
      fprintf (ofp, _("%9.2f   Percent of the file executed\n"),
d502 2
a503 3
      fprintf (ofp, _("\n%9lu   Total number of line executions\n"),
	       sf->ncalls);
      fprintf (ofp, _("%9.2f   Average executions per line\n"),
d505 1
a505 1
	       ? (double) sf->ncalls / (double) num_executable_lines
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 5
a5 23
/* basic_blocks.c  -  Basic-block level related code: reading/writing
   of basic-block info to/from gmon.out; computing and formatting of
   basic-block related statistics.

   Copyright 2000, 2001 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

d7 1
a15 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d17 4
a20 1
/* Default option values:  */
d25 3
a27 1
/* Variables used to compute annotated source listing stats:  */
d32 5
a36 3
/* Helper for sorting.  Compares two symbols and returns result
   such that sorting will be increasing according to filename, line
   number, and address (in that order).  */
a47 1

d49 3
a51 1
	return r;
d54 3
a56 1
	return left->line_num - right->line_num;
d60 3
a62 1
    return -1;
d64 3
a66 1
    return 1;
d68 3
a70 1
    return 0;
d74 4
a77 2
/* Helper for sorting.  Order basic blocks in decreasing number of
   calls, ties are broken in increasing order of line numbers.  */
d85 3
a87 1
    return 1;
d89 3
a91 1
    return -1;
d101 4
a104 1
/* Skip over variable length string.  */
d113 3
a115 1
	break;
a118 2
/* Read a basic-block record from file IFP.  FILENAME is the name
   of file IFP and is provided for formatting error-messages only.  */
d120 4
d128 2
a129 1
  bfd_vma addr, ncalls;
d132 1
a132 1
  if (gmon_io_read_32 (ifp, &nblocks))
d134 1
a134 2
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
d140 3
a142 1
    fskip_string (ifp);
d149 4
a152 3

	  /* Version 0 had lots of extra stuff that we don't
	     care about anymore.  */
d163 1
a163 2
      else if (gmon_io_read_vma (ifp, &addr)
	       || gmon_io_read_vma (ifp, &ncalls))
d165 6
a170 2
	  perror (filename);
	  done (1);
d173 4
a176 2
      /* Basic-block execution counts are meaningful only if we're
	 profiling at the line-by-line level:  */
d179 6
d194 1
a194 1
			   sym->name, sym->line_num, (unsigned long) ncalls));
d215 1
a215 1
  _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
d223 6
a228 3
/* Write all basic-blocks with non-zero counts to file OFP.  FILENAME
   is the name of OFP and is provided for producing error-messages
   only.  */
d232 1
d234 2
d239 2
a240 1
  /* Count how many non-zero blocks with have:  */
d248 4
a251 3
  /* Write header:  */
  if (gmon_io_write_8 (ofp, GMON_TAG_BB_COUNT)
      || gmon_io_write_32 (ofp, nblocks))
d257 1
a257 1
  /* Write counts:  */
d262 5
a266 2
	  if (gmon_io_write_vma (ofp, sym->bb_addr[i])
	      || gmon_io_write_vma (ofp, sym->bb_calls[i]))
a274 4
/* Output basic-block statistics in a format that is easily parseable.
   Current the format is:

	<filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>  */
d276 6
d289 3
a291 1
    first_output = FALSE;
d293 5
a297 1
    printf ("\f\n");
a298 1
  /* Sort basic-blocks according to function name and line number:  */
a300 1

d303 5
a307 3
      /* Accept symbol if it's in the INCL_EXEC table
	 or there is no INCL_EXEC table
	 and it does not appear in the EXCL_EXEC table.  */
a314 1

d317 1
a317 1
  /* Output basic-blocks:  */
a327 1

d343 11
a353 9
/* Helper for bb_annotated_source: format annotation containing
   number of line executions.  Depends on being called on each
   line of a file in sequential order.

   Global variable bb_annotate_all_lines enables execution count
   compression (counts are supressed if identical to the last one)
   and prints counts on all executed lines.  Otherwise, print
   all basic-block execution counts exactly once on the line
   that starts the basic-block.  */
a365 1

d367 3
a369 2
    b = sf->line[line_num - 1];

d393 7
a399 5
	 Otherwise, we're in the middle of a function, so check to see
	 if the first basic-block address is larger than the starting
	 address of the line.  If so, then this line begins with a
	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
d420 3
a422 2
	 update last_count, then compress sequential identical counts
	 (if bb_annotate_all_lines) and print the execution count.  */
d435 3
a437 1
	    continue;
d448 5
a452 4
	 print the last execution count (bb_annotate_all_lines),
	 which could be from either a previous line (if there were
	 no BBs on this line), or from this line (if all our BB
	 counts were compressed out because they were identical).  */
d500 5
a504 4
/* Annotate the files named in SOURCE_FILES with basic-block statistics
   (execution counts).  After each source files, a few statistics
   regarding that source file are printed.  */

d513 4
a516 2
  /* Find maximum line number for each source file that user is
     interested in:  */
d519 6
a524 4
      /* Accept symbol if it's file is known, its line number is
	 bigger than anything we have seen for that file so far and
	 if it's in the INCL_ANNO table or there is no INCL_ANNO
	 table and it does not appear in the EXCL_ANNO table.  */
d534 2
a535 1
  /* Allocate line descriptors:  */
d545 2
a546 1
  /* Count executions per line:  */
a555 1

d558 1
a558 1
	      /* Common case has at most one basic-block per source line:  */
d563 1
a563 1
	      /* sym is the 3rd .. nth basic block for this line:  */
d568 1
a568 1
	      /* sym is the second basic block for this line.  */
d578 2
a579 1
  /* Plod over source files, annotating them:  */
d583 3
a585 1
	continue;
a587 1

d590 3
a592 1
	continue;
d599 1
a599 1
	  /* Abuse line arrays---it's not needed anymore:  */
a601 1

d603 3
a605 2
	    table_len = sf->num_lines;

a608 1

d610 1
d612 1
a612 1

a633 1

d635 3
a637 1
	fclose (ofp);
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d5 1
a5 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d24 1
a24 2
#include "libiberty.h"
#include "gprof.h"
d29 2
a30 1
#include "search_list.h"
a31 1
#include "symtab.h"
d33 3
a35 5

static int cmp_bb PARAMS ((const PTR, const PTR));
static int cmp_ncalls PARAMS ((const PTR, const PTR));
static void fskip_string PARAMS ((FILE *));
static void annotate_with_count PARAMS ((char *, unsigned int, int, PTR));
d38 1
a38 1
bfd_boolean bb_annotate_all_lines = FALSE;
d52 1
a52 3
cmp_bb (lp, rp)
     const PTR lp;
     const PTR rp;
d81 1
a81 3
cmp_ncalls (lp, rp)
     const PTR lp;
     const PTR rp;
d101 1
a101 2
fskip_string (fp)
     FILE *fp;
d116 1
a116 3
bb_read_rec (ifp, filename)
     FILE *ifp;
     const char *filename;
d186 1
a186 1
	  static bfd_boolean user_warned = FALSE;
d204 1
a204 3
bb_write_blocks (ofp, filename)
     FILE *ofp;
     const char *filename;
d206 1
a206 1
  unsigned int nblocks = 0;
d232 1
a232 1
	      || gmon_io_write_vma (ofp, (bfd_vma) sym->bb_calls[i]))
d247 1
a247 1
print_exec_counts ()
d250 1
a250 1
  unsigned int i, j, len;
d314 2
a315 5
annotate_with_count (buf, width, line_num, arg)
     char *buf;
     unsigned int width;
     int line_num;
     PTR arg;
d319 1
a319 1
  unsigned int i;
d340 1
a340 1
      unsigned int len;
d416 1
a416 1
	  unsigned int c;
d443 1
a443 1
	  unsigned int c;
d457 1
a457 1
print_annotated_source ()
@


