head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.54
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.39;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.12.31;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.53.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.10.11;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.10.11;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.43.21;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.30.03;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.48.41;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.14.03.04;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.55;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* gmon_io.c - Input and output from/to gmon.out files.

   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "basic_blocks.h"
#include "corefile.h"
#include "call_graph.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "gmon.h"		/* Fetch header for old format.  */
#include "hertz.h"
#include "hist.h"
#include "libiberty.h"

enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
#endif
static int gmon_read_raw_arc
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
static int gmon_write_raw_arc
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));

int gmon_input = 0;
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format.  */

static enum gmon_ptr_size
gmon_get_ptr_size ()
{
  int size;

  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
    {
    case 32:
      return ptr_32bit;

    case 64:
      return ptr_64bit;

    default:
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
      done (1);
    }
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
}

int
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
{
  char buf[4];

  if (fread (buf, 1, 4, ifp) != 4)
    return 1;
  *valp = bfd_get_32 (core_bfd, buf);
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
{
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
    return 1;
  *valp = bfd_get_64 (core_bfd, buf);
  return 0;
}
#endif

int
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
	return 1;
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
	return 1;
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
      break;
#endif
    }
  return 0;
}

int
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
{
  char buf[4];

  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

int
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
{
  char buf[1];

  bfd_put_8 (core_bfd, val, buf);
  if (fwrite (buf, 1, 1, ofp) != 1)
    return 1;
  return 0;
}

int
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
{
  if (fwrite (buf, 1, n, ofp) != n)
    return 1;
  return 0;
}

static int
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif
    }
  return 0;
}

static int
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
{

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
      break;
#endif
    }
  return 0;
}

void
gmon_out_read (filename)
     const char *filename;
{
  FILE *ifp;
  struct gmon_hdr ghdr;
  unsigned char tag;
  int nhist = 0, narcs = 0, nbbs = 0;

  /* Open gmon.out file.  */
  if (strcmp (filename, "-") == 0)
    {
      ifp = stdin;
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
    }
  else
    {
      ifp = fopen (filename, FOPEN_RB);

      if (!ifp)
	{
	  perror (filename);
	  done (1);
	}
    }

  if (fread (&ghdr, sizeof (struct gmon_hdr), 1, ifp) != 1)
    {
      fprintf (stderr, _("%s: file too short to be a gmon file\n"),
	       filename);
      done (1);
    }

  if ((file_format == FF_MAGIC)
      || (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
    {
      if (file_format == FF_MAGIC && strncmp (&ghdr.cookie[0], GMON_MAGIC, 4))
	{
	  fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		   whoami, filename);
	  done (1);
	}

      /* Right magic, so it's probably really a new gmon.out file.  */
      gmon_file_version = bfd_get_32 (core_bfd, (bfd_byte *) ghdr.version);

      if (gmon_file_version != GMON_VERSION && gmon_file_version != 0)
	{
	  fprintf (stderr,
		   _("%s: file `%s' has unsupported version %d\n"),
		   whoami, filename, gmon_file_version);
	  done (1);
	}

      /* Read in all the records.  */
      while (fread (&tag, sizeof (tag), 1, ifp) == 1)
	{
	  switch (tag)
	    {
	    case GMON_TAG_TIME_HIST:
	      ++nhist;
	      gmon_input |= INPUT_HISTOGRAM;
	      hist_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_CG_ARC:
	      ++narcs;
	      gmon_input |= INPUT_CALL_GRAPH;
	      cg_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_BB_COUNT:
	      ++nbbs;
	      gmon_input |= INPUT_BB_COUNTS;
	      bb_read_rec (ifp, filename);
	      break;

	    default:
	      fprintf (stderr,
		       _("%s: %s: found bad tag %d (file corrupted?)\n"),
		       whoami, filename, tag);
	      done (1);
	    }
	}
    }
  else if (file_format == FF_AUTO
	   || file_format == FF_BSD
	   || file_format == FF_BSD44)
    {
      struct hdr
      {
	bfd_vma low_pc;
	bfd_vma high_pc;
	int ncnt;
      };
      int i, samp_bytes, header_size = 0;
      unsigned long count;
      bfd_vma from_pc, self_pc;
      static struct hdr h;
      UNIT raw_bin_count;
      struct hdr tmp;
      int version;

      /* Information from a gmon.out file is in two parts: an array of
	 sampling hits within pc ranges, and the arcs.  */
      gmon_input = INPUT_HISTOGRAM | INPUT_CALL_GRAPH;

      /* This fseek() ought to work even on stdin as long as it's
	 not an interactive device (heck, is there anybody who would
	 want to type in a gmon.out at the terminal?).  */
      if (fseek (ifp, 0, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
	{
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
		   filename);
	  done (1);
	}

      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;

      if (version == GMONVERSION)
	{
	  int profrate;

	  /* 4.4BSD format header.  */
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;

	  if (!s_highpc)
	    hz = profrate;
	  else if (hz != profrate)
	    {
	      fprintf (stderr,
		       _("%s: profiling rate incompatible with first gmon file\n"),
		       filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  /* Old style BSD format.  */
	  if (file_format == FF_BSD44)
	    {
	      fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		       whoami, filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
	    }
	}

      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      if (s_highpc && (tmp.low_pc != h.low_pc
		       || tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
	{
	  fprintf (stderr, _("%s: incompatible with first gmon file\n"),
		   filename);
	  done (1);
	}

      h = tmp;
      s_lowpc = (bfd_vma) h.low_pc;
      s_highpc = (bfd_vma) h.high_pc;
      lowpc = (bfd_vma) h.low_pc / sizeof (UNIT);
      highpc = (bfd_vma) h.high_pc / sizeof (UNIT);
      samp_bytes = h.ncnt - header_size;
      hist_num_bins = samp_bytes / sizeof (UNIT);

      DBG (SAMPLEDEBUG,
	   printf ("[gmon_out_read] lowpc 0x%lx highpc 0x%lx ncnt %d\n",
		   (unsigned long) h.low_pc, (unsigned long) h.high_pc,
		   h.ncnt);
	   printf ("[gmon_out_read]   s_lowpc 0x%lx   s_highpc 0x%lx\n",
		   (unsigned long) s_lowpc, (unsigned long) s_highpc);
	   printf ("[gmon_out_read]     lowpc 0x%lx     highpc 0x%lx\n",
		   (unsigned long) lowpc, (unsigned long) highpc);
	   printf ("[gmon_out_read] samp_bytes %d hist_num_bins %d\n",
		   samp_bytes, hist_num_bins));

      /* Make sure that we have sensible values.  */
      if (samp_bytes < 0 || lowpc > highpc)
	{
	  fprintf (stderr,
	    _("%s: file '%s' does not appear to be in gmon.out format\n"),
	    whoami, filename);
	  done (1);
	}

      if (hist_num_bins)
	++nhist;

      if (!hist_sample)
	{
	  hist_sample =
	    (int *) xmalloc (hist_num_bins * sizeof (hist_sample[0]));

	  memset (hist_sample, 0, hist_num_bins * sizeof (hist_sample[0]));
	}

      for (i = 0; i < hist_num_bins; ++i)
	{
	  if (fread (raw_bin_count, sizeof (raw_bin_count), 1, ifp) != 1)
	    {
	      fprintf (stderr,
		       _("%s: unexpected EOF after reading %d/%d bins\n"),
		       whoami, --i, hist_num_bins);
	      done (1);
	    }

	  hist_sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) raw_bin_count);
	}

      /* The rest of the file consists of a bunch of
	 <from,self,count> tuples.  */
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
	{
	  ++narcs;

	  DBG (SAMPLEDEBUG,
	     printf ("[gmon_out_read] frompc 0x%lx selfpc 0x%lx count %lu\n",
		     (unsigned long) from_pc, (unsigned long) self_pc, count));

	  /* Add this arc.  */
	  cg_tally (from_pc, self_pc, count);
	}

      fclose (ifp);

      if (hz == HZ_WRONG)
	{
	  /* How many ticks per second?  If we can't tell, report
	     time in ticks.  */
	  hz = hertz ();

	  if (hz == HZ_WRONG)
	    {
	      hz = 1;
	      fprintf (stderr, _("time is in ticks, not seconds\n"));
	    }
	}
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }

  if (output_style & STYLE_GMON_INFO)
    {
      printf (_("File `%s' (version %d) contains:\n"),
	      filename, gmon_file_version);
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
      first_output = FALSE;
    }
}


void
gmon_out_write (filename)
     const char *filename;
{
  FILE *ofp;
  struct gmon_hdr ghdr;

  ofp = fopen (filename, FOPEN_WB);
  if (!ofp)
    {
      perror (filename);
      done (1);
    }

  if (file_format == FF_AUTO || file_format == FF_MAGIC)
    {
      /* Write gmon header.  */

      memcpy (&ghdr.cookie[0], GMON_MAGIC, 4);
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);

      if (fwrite (&ghdr, sizeof (ghdr), 1, ofp) != 1)
	{
	  perror (filename);
	  done (1);
	}

      /* Write execution time histogram if we have one.  */
      if (gmon_input & INPUT_HISTOGRAM)
	hist_write_hist (ofp, filename);

      /* Write call graph arcs if we have any.  */
      if (gmon_input & INPUT_CALL_GRAPH)
	cg_write_arcs (ofp, filename);

      /* Write basic-block info if we have it.  */
      if (gmon_input & INPUT_BB_COUNTS)
	bb_write_blocks (ofp, filename);
    }
  else if (file_format == FF_BSD || file_format == FF_BSD44)
    {
      UNIT raw_bin_count;
      int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
      Arc *arc;
      Sym *sym;

      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

      /* Dump the samples.  */
      for (i = 0; i < hist_num_bins; ++i)
	{
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
	  if (fwrite (&raw_bin_count[0], sizeof (raw_bin_count), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Dump the normalized raw arc information.  */
      for (sym = symtab.base; sym < symtab.limit; ++sym)
	{
	  for (arc = sym->cg.children; arc; arc = arc->next_child)
	    {
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
		{
		  perror (filename);
		  done (1);
		}
	      DBG (SAMPLEDEBUG,
		   printf ("[dumpsum] frompc 0x%lx selfpc 0x%lx count %lu\n",
			   (unsigned long) arc->parent->addr,
			   (unsigned long) arc->child->addr, arc->count));
	    }
	}

      fclose (ofp);
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }
}
@


1.4
log
@resolve conflicts.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d22 4
a27 1
#include "bfd.h"
a32 1
#include "gprof.h"
d37 22
d62 2
a63 2
int
DEFUN (gmon_io_read_vma, (ifp, valp), FILE * ifp AND bfd_vma *valp)
d65 7
a71 2
  char buf[8];
  bfd_vma val;
d73 1
a73 1
  switch (GMON_PTR_SIZE)
d75 2
a76 5
    case 4:
      if (fread (buf, 1, 4, ifp) != 4)
	return 1;
      val = bfd_get_32 (core_bfd, buf);
      break;
d78 2
a79 5
    case 8:
      if (fread (buf, 1, 8, ifp) != 8)
	return 1;
      val = bfd_get_64 (core_bfd, buf);
      break;
d82 2
a83 2
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
d86 12
a97 2
  *valp = val;
  return 0;
d101 3
a103 1
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
d113 5
a117 2
int
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
d119 3
a121 1
  if (fread (buf, 1, n, ifp) != n)
d123 1
d126 1
d129 8
a136 3
DEFUN (gmon_io_write_vma, (ofp, val), FILE * ofp AND bfd_vma val)
{
  char buf[8];
d138 1
a138 1
  switch (GMON_PTR_SIZE)
d140 2
a141 3
    case 4:
      bfd_put_32 (core_bfd, val, buf);
      if (fwrite (buf, 1, 4, ofp) != 4)
d143 4
d149 3
a151 3
    case 8:
      bfd_put_64 (core_bfd, val, buf);
      if (fwrite (buf, 1, 8, ofp) != 8)
d153 6
d160 4
d165 8
a172 5
    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
d177 3
a179 1
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
d183 1
a183 1
  bfd_put_32 (core_bfd, val, buf);
d189 15
d205 26
a230 1
DEFUN (gmon_io_write_8, (ofp, val), FILE * ofp AND unsigned char val)
d241 4
a244 1
DEFUN (gmon_io_write, (ofp, buf, n), FILE * ofp AND char *buf AND size_t n)
d251 31
a281 14
/* get_vma and put_vma are for backwards compatibility only */
static bfd_vma
DEFUN (get_vma, (abfd, addr), bfd * abfd AND bfd_byte * addr)
{
  switch (sizeof (char*))
    {
    case 4:
      return bfd_get_32 (abfd, addr);
    case 8:
      return bfd_get_64 (abfd, addr);
    default:
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
      done (1);
d283 1
d286 6
a291 2
static void
DEFUN (put_vma, (abfd, val, addr), bfd * abfd AND bfd_vma val AND bfd_byte * addr)
d293 6
a298 1
  switch (sizeof (char*))
d300 3
a302 2
    case 4:
      bfd_put_32 (abfd, val, addr);
d304 5
a308 2
    case 8:
      bfd_put_64 (abfd, val, addr);
d310 1
a310 4
    default:
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
      done (1);
d312 1
d316 2
a317 1
DEFUN (gmon_out_read, (filename), const char *filename)
d412 1
a412 1
      int i, samp_bytes, header_size;
a414 2
      struct raw_arc raw_arc;
      struct raw_phdr raw;
d418 1
d433 5
a437 2
      if (fread (&raw, 1, sizeof (struct raw_phdr), ifp)
	  != sizeof (struct raw_phdr))
d439 2
a440 1
	  fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d445 3
a447 3
      tmp.low_pc = get_vma (core_bfd, (bfd_byte *) &raw.low_pc[0]);
      tmp.high_pc = get_vma (core_bfd, (bfd_byte *) &raw.high_pc[0]);
      tmp.ncnt = bfd_get_32 (core_bfd, (bfd_byte *) &raw.ncnt[0]);
d449 1
a449 2
      if (bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0])
	  == GMONVERSION)
d454 2
a455 1
	  profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
d467 10
a476 1
	  header_size = sizeof (struct raw_phdr);
d488 1
a488 1
	  if (fseek (ifp, sizeof (struct old_raw_phdr), SEEK_SET) < 0)
d490 7
a496 2
	      perror (filename);
	      done (1);
d498 1
d500 5
a504 1
	  header_size = sizeof (struct old_raw_phdr);
d569 1
a569 1
      while (fread (&raw_arc, sizeof (raw_arc), 1, ifp) == 1)
a571 3
	  from_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.from_pc);
	  self_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.self_pc);
	  count = bfd_get_32 (core_bfd, (bfd_byte *) raw_arc.count);
d607 9
a615 6
      printf (_("\t%d histogram record%s\n"),
	      nhist, nhist == 1 ? "" : "s");
      printf (_("\t%d call-graph record%s\n"),
	      narcs, narcs == 1 ? "" : "s");
      printf (_("\t%d basic-block count record%s\n"),
	      nbbs, nbbs == 1 ? "" : "s");
d622 2
a623 1
DEFUN (gmon_out_write, (filename), const char *filename)
d640 1
a640 1
      bfd_put_32 (core_bfd, GMON_VERSION, (bfd_byte *) ghdr.version);
a661 1
      struct raw_arc raw_arc;
d663 3
a665 2
      struct raw_phdr h;
      int i;
d669 6
a674 10
      memset (&h, 0, sizeof h);
      put_vma (core_bfd, s_lowpc, (bfd_byte *) &h.low_pc);
      put_vma (core_bfd, s_highpc, (bfd_byte *) &h.high_pc);
      bfd_put_32 (core_bfd,
		  hist_num_bins * sizeof (UNIT) + sizeof (struct raw_phdr),
		  (bfd_byte *) &h.ncnt);

      /* Write header.  Use new style BSD format is explicitly
	 specified, or if the profiling rate is non-standard;
	 otherwise, use the old BSD format.  */
d676 1
a676 1
	  || hz != hertz ())
d678 2
a679 3
	  bfd_put_32 (core_bfd, GMONVERSION, (bfd_byte *) &h.version);
	  bfd_put_32 (core_bfd, hz, (bfd_byte *) &h.profrate);
	  if (fwrite (&h, sizeof (struct raw_phdr), 1, ofp) != 1)
d681 7
a687 2
	      perror (filename);
	      done (1);
d692 34
a725 1
	  if (fwrite (&h, sizeof (struct old_raw_phdr), 1, ofp) != 1)
d732 9
d744 2
a745 1
	  bfd_put_16 (core_bfd, hist_sample[i], (bfd_byte *) & raw_bin_count[0]);
d758 2
a759 6
	      put_vma (core_bfd, arc->parent->addr,
		       (bfd_byte *) raw_arc.from_pc);
	      put_vma (core_bfd, arc->child->addr,
		       (bfd_byte *) raw_arc.self_pc);
	      bfd_put_32 (core_bfd, arc->count, (bfd_byte *) raw_arc.count);
	      if (fwrite (&raw_arc, sizeof (raw_arc), 1, ofp) != 1)
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 21
a21 3
/*
 * Input and output from/to gmon.out files.
 */
d29 1
a29 1
#include "gmon.h"		/* fetch header for old format */
d36 30
a65 1
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format */
d67 78
a144 4
/*
 * This probably ought to be in libbfd.
 */
bfd_vma
d160 1
a160 5

/*
 * This probably ought to be in libbfd.
 */
void
a177 1

d186 1
a186 2
  /* open gmon.out file: */

d197 1
d204 1
d212 2
a213 2
  if ((file_format == FF_MAGIC) ||
      (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
d222 2
a223 1
      /* right magic, so it's probably really a new gmon.out file */
a224 1
      gmon_file_version = bfd_get_32 (core_bfd, (bfd_byte *) ghdr.version);
d233 1
a233 1
      /* read in all the records: */
d283 2
a284 4
      /*
       * Information from a gmon.out file is in two parts: an array of
       * sampling hits within pc ranges, and the arcs.
       */
d287 3
a289 5
      /*
       * This fseek() ought to work even on stdin as long as it's
       * not an interactive device (heck, is there anybody who would
       * want to type in a gmon.out at the terminal?).
       */
d295 1
d303 1
d314 1
a315 1
	  profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
d330 1
a330 1
	  /* old style BSD format.  */
d347 2
a348 2
      if (s_highpc && (tmp.low_pc != h.low_pc ||
		       tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
d354 1
d362 1
d376 2
a377 2
        {
          fprintf (stderr, 
d380 2
a381 2
          done (1);
        }
d384 1
a384 3
	{
	  ++nhist;
	}
d390 1
d403 1
d407 2
a408 4
      /*
       * The rest of the file consists of a bunch of <from,self,count>
       * tuples:
       */
d415 1
d419 2
a420 1
	  /* add this arc: */
d423 1
d428 2
a429 4
	  /*
	   * How many ticks per second?  If we can't tell, report
	   * time in ticks.
	   */
d431 1
d476 1
a476 1
      /* write gmon header: */
d480 1
d487 1
a487 1
      /* write execution time histogram if we have one: */
d489 1
a489 3
	{
	  hist_write_hist (ofp, filename);
	}
d491 1
a491 1
      /* write call graph arcs if we have any: */
d493 1
a493 3
	{
	  cg_write_arcs (ofp, filename);
	}
d495 1
a495 1
      /* write basic-block info if we have it: */
d497 1
a497 3
	{
	  bb_write_blocks (ofp, filename);
	}
d516 2
a517 2
         specified, or if the profiling rate is non-standard;
         otherwise, use the old BSD format.  */
d538 1
a538 2
      /* dump the samples: */

d549 1
a549 2
      /* dump the normalized raw arc information: */

d570 1
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d7 1
a7 1
#include "core.h"
d33 1
a33 1
      fprintf (stderr, "%s: bfd_vma has unexpected size of %ld bytes\n",
d55 1
a55 1
      fprintf (stderr, "%s: bfd_vma has unexpected size of %ld bytes\n",
d75 3
d90 1
a90 1
      fprintf (stderr, "%s: file too short to be a gmon file\n",
d100 1
a100 1
	  fprintf (stderr, "%s: file `%s' has bad magic cookie\n",
d111 1
a111 1
		   "%s: file `%s' has unsupported version %d\n",
d141 1
a141 1
		       "%s: %s: found bad tag %d (file corrupted?)\n",
d147 3
a149 1
  else if (file_format == FF_AUTO || file_format == FF_BSD)
d157 2
a158 1
      int i, samp_bytes, count;
d185 1
a185 1
	  fprintf (stderr, "%s: file too short to be a gmon file\n",
d193 35
a227 3
#ifdef BSD44_FORMAT
      {
	int profrate;
d229 2
a230 12
	profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0]);
	if (!s_highpc)
	  hz = profrate;
	else if (hz != profrate)
	  {
	    fprintf (stderr,
		     "%s: profiling rate incompatible with first gmon file\n",
		     filename);
	    done (1);
	  }
      }
#endif
d235 1
a235 1
	  fprintf (stderr, "%s: incompatible with first gmon file\n",
d244 1
a244 1
      samp_bytes = h.ncnt - sizeof (struct raw_phdr);
d248 2
a249 1
		   h.low_pc, h.high_pc, h.ncnt);
d251 1
a251 1
		   s_lowpc, s_highpc);
d253 1
a253 1
		   lowpc, highpc);
d257 9
d283 1
a283 1
		       "%s: unexpected EOF after reading %d/%d bins\n",
d301 2
a302 2
	     printf ("[gmon_out_read] frompc 0x%lx selfpc 0x%lx count %d\n",
		     from_pc, self_pc, count));
d318 1
a318 1
	      fprintf (stderr, "time is in ticks, not seconds\n");
d324 1
a324 1
      fprintf (stderr, "%s: don't know how to deal with file format %d\n",
d331 1
a331 1
      printf ("File `%s' (version %d) contains:\n",
d333 1
a333 1
      printf ("\t%d histogram record%s\n",
d335 1
a335 1
      printf ("\t%d call-graph record%s\n",
d337 1
a337 1
      printf ("\t%d basic-block count record%s\n",
d387 1
a387 1
  else if (file_format == FF_BSD)
d391 2
a392 2
      bfd_vma lpc, hpc;
      int i, ncnt;
d396 3
a398 2
      put_vma (core_bfd, s_lowpc, (bfd_byte *) & lpc);
      put_vma (core_bfd, s_highpc, (bfd_byte *) & hpc);
d401 1
a401 1
		    (bfd_byte *) & ncnt);
d403 15
a417 4
      /* write header: */
      if (fwrite (&lpc, sizeof (lpc), 1, ofp) != 1
	  || fwrite (&hpc, sizeof (hpc), 1, ofp) != 1
	  || fwrite (&ncnt, sizeof (ncnt), 1, ofp) != 1)
d419 5
a423 2
	  perror (filename);
	  done (1);
d455 3
a457 2
		   printf ("[dumpsum] frompc 0x%lx selfpc 0x%lx count %d\n",
			   arc->parent->addr, arc->child->addr, arc->count));
d464 1
a464 1
      fprintf (stderr, "%s: don't know how to deal with file format %d\n",
@


1.1
log
@Initial revision
@
text
@d183 21
a203 3
      tmp.low_pc = get_vma (core_bfd, (bfd_byte *) & raw.low_pc[0]);
      tmp.high_pc = get_vma (core_bfd, (bfd_byte *) & raw.high_pc[0]);
      tmp.ncnt = bfd_get_32 (core_bfd, (bfd_byte *) & raw.ncnt[0]);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d183 3
a185 21
      tmp.low_pc = get_vma (core_bfd, (bfd_byte *) &raw.low_pc[0]);
      tmp.high_pc = get_vma (core_bfd, (bfd_byte *) &raw.high_pc[0]);
      tmp.ncnt = bfd_get_32 (core_bfd, (bfd_byte *) &raw.ncnt[0]);

#ifdef BSD44_FORMAT
      {
	int profrate;

	profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0]);
	if (!s_highpc)
	  hz = profrate;
	else if (hz != profrate)
	  {
	    fprintf (stderr,
		     "%s: profiling rate incompatible with first gmon file\n",
		     filename);
	    done (1);
	  }
      }
#endif

@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d191 1
a191 1
	profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 1
#include "corefile.h"
d33 1
a33 1
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
d55 1
a55 1
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
a74 3
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
d87 1
a87 1
      fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d97 1
a97 1
	  fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
d108 1
a108 1
		   _("%s: file `%s' has unsupported version %d\n"),
d138 1
a138 1
		       _("%s: %s: found bad tag %d (file corrupted?)\n"),
d144 1
a144 3
  else if (file_format == FF_AUTO
	   || file_format == FF_BSD
	   || file_format == FF_BSD44)
d152 1
a152 2
      int i, samp_bytes, header_size;
      unsigned long count;
d179 1
a179 1
	  fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d187 3
a189 4
      if (bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0])
	  == GMONVERSION)
	{
	  int profrate;
d191 12
a202 33
	  /* 4.4BSD format header.  */

	  profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
	  if (!s_highpc)
	    hz = profrate;
	  else if (hz != profrate)
	    {
	      fprintf (stderr,
		       _("%s: profiling rate incompatible with first gmon file\n"),
		       filename);
	      done (1);
	    }

	  header_size = sizeof (struct raw_phdr);
	}
      else
	{
	  /* old style BSD format.  */
	  if (file_format == FF_BSD44)
	    {
	      fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		       whoami, filename);
	      done (1);
	    }

	  if (fseek (ifp, sizeof (struct old_raw_phdr), SEEK_SET) < 0)
	    {
	      perror (filename);
	      done (1);
	    }

	  header_size = sizeof (struct old_raw_phdr);
	}
d207 1
a207 1
	  fprintf (stderr, _("%s: incompatible with first gmon file\n"),
d216 1
a216 1
      samp_bytes = h.ncnt - header_size;
d220 1
a220 2
		   (unsigned long) h.low_pc, (unsigned long) h.high_pc,
		   h.ncnt);
d222 1
a222 1
		   (unsigned long) s_lowpc, (unsigned long) s_highpc);
d224 1
a224 1
		   (unsigned long) lowpc, (unsigned long) highpc);
a227 9
      /* Make sure that we have sensible values.  */
      if (samp_bytes < 0 || lowpc > highpc)
        {
          fprintf (stderr, 
	    _("%s: file '%s' does not appear to be in gmon.out format\n"),
	    whoami, filename);
          done (1);
        }

d245 1
a245 1
		       _("%s: unexpected EOF after reading %d/%d bins\n"),
d263 2
a264 2
	     printf ("[gmon_out_read] frompc 0x%lx selfpc 0x%lx count %lu\n",
		     (unsigned long) from_pc, (unsigned long) self_pc, count));
d280 1
a280 1
	      fprintf (stderr, _("time is in ticks, not seconds\n"));
d286 1
a286 1
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
d293 1
a293 1
      printf (_("File `%s' (version %d) contains:\n"),
d295 1
a295 1
      printf (_("\t%d histogram record%s\n"),
d297 1
a297 1
      printf (_("\t%d call-graph record%s\n"),
d299 1
a299 1
      printf (_("\t%d basic-block count record%s\n"),
d349 1
a349 1
  else if (file_format == FF_BSD || file_format == FF_BSD44)
d353 2
a354 2
      struct raw_phdr h;
      int i;
d358 2
a359 3
      memset (&h, 0, sizeof h);
      put_vma (core_bfd, s_lowpc, (bfd_byte *) &h.low_pc);
      put_vma (core_bfd, s_highpc, (bfd_byte *) &h.high_pc);
d362 1
a362 1
		  (bfd_byte *) &h.ncnt);
d364 4
a367 15
      /* Write header.  Use new style BSD format is explicitly
         specified, or if the profiling rate is non-standard;
         otherwise, use the old BSD format.  */
      if (file_format == FF_BSD44
	  || hz != hertz ())
	{
	  bfd_put_32 (core_bfd, GMONVERSION, (bfd_byte *) &h.version);
	  bfd_put_32 (core_bfd, hz, (bfd_byte *) &h.profrate);
	  if (fwrite (&h, sizeof (struct raw_phdr), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}
      else
d369 2
a370 5
	  if (fwrite (&h, sizeof (struct old_raw_phdr), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
d402 2
a403 3
		   printf ("[dumpsum] frompc 0x%lx selfpc 0x%lx count %lu\n",
			   (unsigned long) arc->parent->addr,
			   (unsigned long) arc->child->addr, arc->count));
d410 1
a410 1
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 3
a3 21
/* gmon_io.c - Input and output from/to gmon.out files.

   Copyright 2000, 2001 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

d11 1
a11 1
#include "gmon.h"		/* Fetch header for old format.  */
d18 1
a18 30
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format.  */

int
DEFUN (gmon_io_read_vma, (ifp, valp), FILE * ifp AND bfd_vma *valp)
{
  char buf[8];
  bfd_vma val;

  switch (GMON_PTR_SIZE)
    {
    case 4:
      if (fread (buf, 1, 4, ifp) != 4)
	return 1;
      val = bfd_get_32 (core_bfd, buf);
      break;

    case 8:
      if (fread (buf, 1, 8, ifp) != 8)
	return 1;
      val = bfd_get_64 (core_bfd, buf);
      break;

    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
  *valp = val;
  return 0;
}
d20 4
a23 78
int
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
{
  char buf[4];

  if (fread (buf, 1, 4, ifp) != 4)
    return 1;
  *valp = bfd_get_32 (core_bfd, buf);
  return 0;
}

int
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write_vma, (ofp, val), FILE * ofp AND bfd_vma val)
{
  char buf[8];

  switch (GMON_PTR_SIZE)
    {
    case 4:
      bfd_put_32 (core_bfd, val, buf);
      if (fwrite (buf, 1, 4, ofp) != 4)
	return 1;
      break;

    case 8:
      bfd_put_64 (core_bfd, val, buf);
      if (fwrite (buf, 1, 8, ofp) != 8)
	return 1;
      break;

    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
  return 0;
}

int
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
{
  char buf[4];

  bfd_put_32 (core_bfd, val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write_8, (ofp, val), FILE * ofp AND unsigned char val)
{
  char buf[1];

  bfd_put_8 (core_bfd, val, buf);
  if (fwrite (buf, 1, 1, ofp) != 1)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write, (ofp, buf, n), FILE * ofp AND char *buf AND size_t n)
{
  if (fwrite (buf, 1, n, ofp) != n)
    return 1;
  return 0;
}

/* get_vma and put_vma are for backwards compatibility only */
static bfd_vma
d39 5
a43 1
static void
d61 1
d70 2
a71 1
  /* Open gmon.out file.  */
a81 1

a87 1

d95 2
a96 2
  if ((file_format == FF_MAGIC)
      || (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
d105 2
a106 1
      /* Right magic, so it's probably really a new gmon.out file.  */
a107 1

d116 1
a116 1
      /* Read in all the records.  */
d166 4
a169 2
      /* Information from a gmon.out file is in two parts: an array of
	 sampling hits within pc ranges, and the arcs.  */
d172 5
a176 3
      /* This fseek() ought to work even on stdin as long as it's
	 not an interactive device (heck, is there anybody who would
	 want to type in a gmon.out at the terminal?).  */
a181 1

a188 1

d199 1
a200 1

d215 1
a215 1
	  /* Old style BSD format.  */
d232 2
a233 2
      if (s_highpc && (tmp.low_pc != h.low_pc
		       || tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
a238 1

a245 1

d259 2
a260 2
	{
	  fprintf (stderr,
d263 2
a264 2
	  done (1);
	}
d267 3
a269 1
	++nhist;
a274 1

a286 1

d290 4
a293 2
      /* The rest of the file consists of a bunch of
	 <from,self,count> tuples.  */
a299 1

d303 1
a303 2

	  /* Add this arc.  */
a305 1

d310 4
a313 2
	  /* How many ticks per second?  If we can't tell, report
	     time in ticks.  */
a314 1

d359 1
a359 1
      /* Write gmon header.  */
a362 1

d369 1
a369 1
      /* Write execution time histogram if we have one.  */
d371 3
a373 1
	hist_write_hist (ofp, filename);
d375 1
a375 1
      /* Write call graph arcs if we have any.  */
d377 3
a379 1
	cg_write_arcs (ofp, filename);
d381 1
a381 1
      /* Write basic-block info if we have it.  */
d383 3
a385 1
	bb_write_blocks (ofp, filename);
d404 2
a405 2
	 specified, or if the profiling rate is non-standard;
	 otherwise, use the old BSD format.  */
d426 2
a427 1
      /* Dump the samples.  */
d438 2
a439 1
      /* Dump the normalized raw arc information.  */
a459 1

@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a21 4
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
d24 1
d30 1
a34 22
enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
#endif
static int gmon_read_raw_arc
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
static int gmon_write_raw_arc
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));

d38 2
a39 2
static enum gmon_ptr_size
gmon_get_ptr_size ()
d41 2
a42 1
  int size;
d44 1
a44 7
  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
d46 5
a50 2
    case 32:
      return ptr_32bit;
d52 5
a56 2
    case 64:
      return ptr_64bit;
d59 2
a60 2
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
d63 2
a64 12
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
d68 1
a68 3
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
d78 2
a79 5
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
d81 1
a81 3
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
a82 1
  *valp = bfd_get_64 (core_bfd, buf);
a84 1
#endif
d87 3
a89 8
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif
d91 1
a91 1
  switch (gmon_get_ptr_size ())
d93 3
a95 2
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
a96 4
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
d99 3
a101 3
#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
a102 6
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
d104 5
a108 1
#endif
d114 1
a114 14
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
d118 1
a118 1
  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
a123 15
#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

d125 1
a125 26
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
d136 1
a136 4
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
d143 14
a156 31
static int
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif
a157 1
  return 0;
d160 2
a161 6
static int
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
d163 1
a163 6

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
d165 2
a166 3
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
d168 2
a169 5

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
d171 4
a174 1
#endif
a175 1
  return 0;
d179 1
a179 2
gmon_out_read (filename)
     const char *filename;
d274 1
a274 1
      int i, samp_bytes, header_size = 0;
d277 2
a281 1
      int version;
d296 2
a297 5
      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
d299 1
a299 2
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d304 3
a306 3
      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;
d308 2
a309 1
      if (version == GMONVERSION)
d314 1
a314 2
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;
d326 1
a326 10
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
d338 1
a338 1
	  switch (gmon_get_ptr_size ())
d340 2
a341 7
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
a342 1
	}
d344 1
a344 5
      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
d409 1
a409 1
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
d412 3
d450 6
a455 9
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
d462 1
a462 2
gmon_out_write (filename)
     const char *filename;
d479 1
a479 1
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);
d501 1
d503 2
a504 3
      int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
d508 10
a517 6
      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
d519 1
a519 1
	  || hz != hertz())
d521 3
a523 2
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
d525 2
a526 7
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
d531 1
a531 34
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
a537 9
      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

d541 1
a541 2
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
d554 6
a559 2
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
@


