head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.56
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.54
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.40;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.12.32;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.53.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.10.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.10.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.43.24;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.30.07;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.48.42;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.14.03.15;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.56;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* hist.c  -  Histogram related operations.

   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "libiberty.h"
#include "gprof.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "corefile.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "hist.h"
#include "sym_ids.h"
#include "utils.h"

#define UNITS_TO_CODE (offset_to_code / sizeof(UNIT))

static void scale_and_align_entries PARAMS ((void));
static void print_header PARAMS ((int));
static void print_line PARAMS ((Sym *, double));
static int cmp_time PARAMS ((const PTR, const PTR));

/* Declarations of automatically generated functions to output blurbs.  */
extern void flat_blurb PARAMS ((FILE * fp));

bfd_vma s_lowpc;		/* Lowest address in .text.  */
bfd_vma s_highpc = 0;		/* Highest address in .text.  */
bfd_vma lowpc, highpc;		/* Same, but expressed in UNITs.  */
int hist_num_bins = 0;		/* Number of histogram samples.  */
int *hist_sample = 0;		/* Histogram samples (shorts in the file!).  */
double hist_scale;
char hist_dimension[16] = "seconds";
char hist_dimension_abbrev = 's';

static double accum_time;	/* Accumulated time so far for print_line(). */
static double total_time;	/* Total time for all routines.  */

/* Table of SI prefixes for powers of 10 (used to automatically
   scale some of the values in the flat profile).  */
const struct
  {
    char prefix;
    double scale;
  }
SItab[] =
{
  { 'T', 1e-12 },				/* tera */
  { 'G', 1e-09 },				/* giga */
  { 'M', 1e-06 },				/* mega */
  { 'K', 1e-03 },				/* kilo */
  { ' ', 1e-00 },
  { 'm', 1e+03 },				/* milli */
  { 'u', 1e+06 },				/* micro */
  { 'n', 1e+09 },				/* nano */
  { 'p', 1e+12 },				/* pico */
  { 'f', 1e+15 },				/* femto */
  { 'a', 1e+18 }				/* ato */
};


/* Read the histogram from file IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  */

void
hist_read_rec (ifp, filename)
     FILE * ifp;
     const char *filename;
{
  bfd_vma n_lowpc, n_highpc;
  int i, ncnt, profrate;
  UNIT count;

  if (gmon_io_read_vma (ifp, &n_lowpc)
      || gmon_io_read_vma (ifp, &n_highpc)
      || gmon_io_read_32 (ifp, &ncnt)
      || gmon_io_read_32 (ifp, &profrate)
      || gmon_io_read (ifp, hist_dimension, 15)
      || gmon_io_read (ifp, &hist_dimension_abbrev, 1))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);

      done (1);
    }

  if (!s_highpc)
    {
      /* This is the first histogram record.  */
      s_lowpc = n_lowpc;
      s_highpc = n_highpc;
      lowpc = (bfd_vma) n_lowpc / sizeof (UNIT);
      highpc = (bfd_vma) n_highpc / sizeof (UNIT);
      hist_num_bins = ncnt;
      hz = profrate;
    }

  DBG (SAMPLEDEBUG,
       printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %d\n",
	       (unsigned long) n_lowpc, (unsigned long) n_highpc, ncnt);
       printf ("[hist_read_rec] s_lowpc 0x%lx s_highpc 0x%lx nsamples %d\n",
	       (unsigned long) s_lowpc, (unsigned long) s_highpc,
	       hist_num_bins);
       printf ("[hist_read_rec]   lowpc 0x%lx   highpc 0x%lx\n",
	       (unsigned long) lowpc, (unsigned long) highpc));

  if (n_lowpc != s_lowpc || n_highpc != s_highpc
      || ncnt != hist_num_bins || hz != profrate)
    {
      fprintf (stderr, _("%s: `%s' is incompatible with first gmon file\n"),
	       whoami, filename);
      done (1);
    }

  if (!hist_sample)
    {
      hist_sample = (int *) xmalloc (hist_num_bins * sizeof (hist_sample[0]));
      memset (hist_sample, 0, hist_num_bins * sizeof (hist_sample[0]));
    }

  for (i = 0; i < hist_num_bins; ++i)
    {
      if (fread (&count[0], sizeof (count), 1, ifp) != 1)
	{
	  fprintf (stderr,
		  _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
		   whoami, filename, i, hist_num_bins);
	  done (1);
	}
      hist_sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) & count[0]);
      DBG (SAMPLEDEBUG,
	   printf ("[hist_read_rec] 0x%lx: %u\n",
		   (unsigned long) (n_lowpc + i * (n_highpc - n_lowpc) / ncnt),
		   hist_sample[i]));
    }
}


/* Write execution histogram to file OFP.  FILENAME is the name
   of OFP and is provided for formatting error-messages only.  */

void
hist_write_hist (ofp, filename)
     FILE * ofp;
     const char *filename;
{
  UNIT count;
  int i;

  /* Write header.  */

  if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
      || gmon_io_write_vma (ofp, s_lowpc)
      || gmon_io_write_vma (ofp, s_highpc)
      || gmon_io_write_32 (ofp, hist_num_bins)
      || gmon_io_write_32 (ofp, hz)
      || gmon_io_write (ofp, hist_dimension, 15)
      || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
    {
      perror (filename);
      done (1);
    }

  for (i = 0; i < hist_num_bins; ++i)
    {
      bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i], (bfd_byte *) &count[0]);

      if (fwrite (&count[0], sizeof (count), 1, ofp) != 1)
	{
	  perror (filename);
	  done (1);
	}
    }
}


/* Calculate scaled entry point addresses (to save time in
   hist_assign_samples), and, on architectures that have procedure
   entry masks at the start of a function, possibly push the scaled
   entry points over the procedure entry mask, if it turns out that
   the entry point is in one bin and the code for a routine is in the
   next bin.  */

static void
scale_and_align_entries ()
{
  Sym *sym;
  bfd_vma bin_of_entry;
  bfd_vma bin_of_code;

  for (sym = symtab.base; sym < symtab.limit; sym++)
    {
      sym->hist.scaled_addr = sym->addr / sizeof (UNIT);
      bin_of_entry = (sym->hist.scaled_addr - lowpc) / hist_scale;
      bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - lowpc)
		     / hist_scale);
      if (bin_of_entry < bin_of_code)
	{
	  DBG (SAMPLEDEBUG,
	       printf ("[scale_and_align_entries] pushing 0x%lx to 0x%lx\n",
		       (unsigned long) sym->hist.scaled_addr,
		       (unsigned long) (sym->hist.scaled_addr
					+ UNITS_TO_CODE)));
	  sym->hist.scaled_addr += UNITS_TO_CODE;
	}
    }
}


/* Assign samples to the symbol to which they belong.

   Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)
   which may overlap one more symbol address ranges.  If a symbol
   overlaps with the bin's address range by O percent, then O percent
   of the bin's count is credited to that symbol.

   There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be
   with respect to the symbol's address range [SYM_LOW_PC,
   SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes
   the distance (in UNITs) between the arrows, the fraction of the
   sample that is to be credited to the symbol which starts at
   SYM_LOW_PC.

	  sym_low_pc                                      sym_high_pc
	       |                                               |
	       v                                               v

	       +-----------------------------------------------+
	       |                                               |
	  |  ->|    |<-         ->|         |<-         ->|    |<-  |
	  |         |             |         |             |         |
	  +---------+             +---------+             +---------+

	  ^         ^             ^         ^             ^         ^
	  |         |             |         |             |         |
     bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc

   For the VAX we assert that samples will never fall in the first two
   bytes of any routine, since that is the entry mask, thus we call
   scale_and_align_entries() to adjust the entry points if the entry
   mask falls in one bin but the code for the routine doesn't start
   until the next bin.  In conjunction with the alignment of routine
   addresses, this should allow us to have only one sample for every
   four bytes of text space and never have any overlap (the two end
   cases, above).  */

void
hist_assign_samples ()
{
  bfd_vma bin_low_pc, bin_high_pc;
  bfd_vma sym_low_pc, sym_high_pc;
  bfd_vma overlap, addr;
  int bin_count, i;
  unsigned int j;
  double time, credit;

  /* Read samples and assign to symbols.  */
  hist_scale = highpc - lowpc;
  hist_scale /= hist_num_bins;
  scale_and_align_entries ();

  /* Iterate over all sample bins.  */
  for (i = 0, j = 1; i < hist_num_bins; ++i)
    {
      bin_count = hist_sample[i];
      if (! bin_count)
	continue;

      bin_low_pc = lowpc + (bfd_vma) (hist_scale * i);
      bin_high_pc = lowpc + (bfd_vma) (hist_scale * (i + 1));
      time = bin_count;

      DBG (SAMPLEDEBUG,
	   printf (
      "[assign_samples] bin_low_pc=0x%lx, bin_high_pc=0x%lx, bin_count=%d\n",
		    (unsigned long) (sizeof (UNIT) * bin_low_pc),
		    (unsigned long) (sizeof (UNIT) * bin_high_pc),
		    bin_count));
      total_time += time;

      /* Credit all symbols that are covered by bin I.  */
      for (j = j - 1; j < symtab.len; ++j)
	{
	  sym_low_pc = symtab.base[j].hist.scaled_addr;
	  sym_high_pc = symtab.base[j + 1].hist.scaled_addr;

	  /* If high end of bin is below entry address,
	     go for next bin.  */
	  if (bin_high_pc < sym_low_pc)
	    break;

	  /* If low end of bin is above high end of symbol,
	     go for next symbol.  */
	  if (bin_low_pc >= sym_high_pc)
	    continue;

	  overlap =
	    MIN (bin_high_pc, sym_high_pc) - MAX (bin_low_pc, sym_low_pc);
	  if (overlap > 0)
	    {
	      DBG (SAMPLEDEBUG,
		   printf (
	       "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			   (unsigned long) symtab.base[j].addr,
			   (unsigned long) (sizeof (UNIT) * sym_high_pc),
			   symtab.base[j].name, overlap * time / hist_scale,
			   (long) overlap));

	      addr = symtab.base[j].addr;
	      credit = overlap * time / hist_scale;

	      /* Credit symbol if it appears in INCL_FLAT or that
		 table is empty and it does not appear it in
		 EXCL_FLAT.  */
	      if (sym_lookup (&syms[INCL_FLAT], addr)
		  || (syms[INCL_FLAT].len == 0
		      && !sym_lookup (&syms[EXCL_FLAT], addr)))
		{
		  symtab.base[j].hist.time += credit;
		}
	      else
		{
		  total_time -= credit;
		}
	    }
	}
    }

  DBG (SAMPLEDEBUG, printf ("[assign_samples] total_time %f\n",
			    total_time));
}


/* Print header for flag histogram profile.  */

static void
print_header (prefix)
     int prefix;
{
  char unit[64];

  sprintf (unit, _("%c%c/call"), prefix, hist_dimension_abbrev);

  if (bsd_style_output)
    {
      printf (_("\ngranularity: each sample hit covers %ld byte(s)"),
	      (long) hist_scale * sizeof (UNIT));
      if (total_time > 0.0)
	{
	  printf (_(" for %.2f%% of %.2f %s\n\n"),
		  100.0 / total_time, total_time / hz, hist_dimension);
	}
    }
  else
    {
      printf (_("\nEach sample counts as %g %s.\n"), 1.0 / hz, hist_dimension);
    }

  if (total_time <= 0.0)
    {
      printf (_(" no time accumulated\n\n"));

      /* This doesn't hurt since all the numerators will be zero.  */
      total_time = 1.0;
    }

  printf ("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "),
	  "");
  printf ("%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	  _("time"), hist_dimension, hist_dimension, _("calls"), unit, unit,
	  _("name"));
}


static void
print_line (sym, scale)
     Sym *sym;
     double scale;
{
  if (ignore_zeros && sym->ncalls == 0 && sym->hist.time == 0)
    return;

  accum_time += sym->hist.time;

  if (bsd_style_output)
    printf ("%5.1f %10.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);
  else
    printf ("%6.2f %9.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);

  if (sym->ncalls != 0)
    printf (" %8lu %8.2f %8.2f  ",
	    sym->ncalls, scale * sym->hist.time / hz / sym->ncalls,
	    scale * (sym->hist.time + sym->cg.child_time) / hz / sym->ncalls);
  else
    printf (" %8.8s %8.8s %8.8s  ", "", "", "");

  if (bsd_style_output)
    print_name (sym);
  else
    print_name_only (sym);

  printf ("\n");
}


/* Compare LP and RP.  The primary comparison key is execution time,
   the secondary is number of invocation, and the tertiary is the
   lexicographic order of the function names.  */

static int
cmp_time (lp, rp)
     const PTR lp;
     const PTR rp;
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;
  double time_diff;

  time_diff = right->hist.time - left->hist.time;

  if (time_diff > 0.0)
    return 1;

  if (time_diff < 0.0)
    return -1;

  if (right->ncalls > left->ncalls)
    return 1;

  if (right->ncalls < left->ncalls)
    return -1;

  return strcmp (left->name, right->name);
}


/* Print the flat histogram profile.  */

void
hist_print ()
{
  Sym **time_sorted_syms, *top_dog, *sym;
  unsigned int index;
  unsigned log_scale;
  double top_time, time;
  bfd_vma addr;

  if (first_output)
    first_output = FALSE;
  else
    printf ("\f\n");

  accum_time = 0.0;

  if (bsd_style_output)
    {
      if (print_descriptions)
	{
	  printf (_("\n\n\nflat profile:\n"));
	  flat_blurb (stdout);
	}
    }
  else
    {
      printf (_("Flat profile:\n"));
    }

  /* Sort the symbol table by time (call-count and name as secondary
     and tertiary keys).  */
  time_sorted_syms = (Sym **) xmalloc (symtab.len * sizeof (Sym *));

  for (index = 0; index < symtab.len; ++index)
    time_sorted_syms[index] = &symtab.base[index];

  qsort (time_sorted_syms, symtab.len, sizeof (Sym *), cmp_time);

  if (bsd_style_output)
    {
      log_scale = 5;		/* Milli-seconds is BSD-default.  */
    }
  else
    {
      /* Search for symbol with highest per-call
	 execution time and scale accordingly.  */
      log_scale = 0;
      top_dog = 0;
      top_time = 0.0;

      for (index = 0; index < symtab.len; ++index)
	{
	  sym = time_sorted_syms[index];

	  if (sym->ncalls != 0)
	    {
	      time = (sym->hist.time + sym->cg.child_time) / sym->ncalls;

	      if (time > top_time)
		{
		  top_dog = sym;
		  top_time = time;
		}
	    }
	}

      if (top_dog && top_dog->ncalls != 0 && top_time > 0.0)
	{
	  top_time /= hz;

	  for (log_scale = 0; log_scale < ARRAY_SIZE (SItab); log_scale ++)
	    {
	      double scaled_value = SItab[log_scale].scale * top_time;

	      if (scaled_value >= 1.0 && scaled_value < 1000.0) 
		break;
	    }
	}
    }

  /* For now, the dimension is always seconds.  In the future, we
     may also want to support other (pseudo-)dimensions (such as
     I-cache misses etc.).  */
  print_header (SItab[log_scale].prefix);

  for (index = 0; index < symtab.len; ++index)
    {
      addr = time_sorted_syms[index]->addr;

      /* Print symbol if its in INCL_FLAT table or that table
	is empty and the symbol is not in EXCL_FLAT.  */
      if (sym_lookup (&syms[INCL_FLAT], addr)
	  || (syms[INCL_FLAT].len == 0
	      && !sym_lookup (&syms[EXCL_FLAT], addr)))
	print_line (time_sorted_syms[index], SItab[log_scale].scale);
    }

  free (time_sorted_syms);

  if (print_descriptions && !bsd_style_output)
    flat_blurb (stdout);
}
@


1.4
log
@resolve conflicts.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
a21 1
#include <stdio.h>
d24 3
a30 1
#include "symtab.h"
d37 3
d83 3
a85 1
DEFUN (hist_read_rec, (ifp, filename), FILE * ifp AND const char *filename)
d160 3
a162 1
DEFUN (hist_write_hist, (ofp, filename), FILE * ofp AND const char *filename)
d183 1
a183 1
      bfd_put_16 (core_bfd, hist_sample[i], (bfd_byte *) & count[0]);
d265 1
a265 1
DEFUN_VOID (hist_assign_samples)
d354 2
a355 1
DEFUN (print_header, (prefix), const char prefix)
d394 3
a396 1
DEFUN (print_line, (sym, scale), Sym * sym AND double scale)
d433 3
a435 1
DEFUN (cmp_time, (lp, rp), const PTR lp AND const PTR rp)
d462 1
a462 1
DEFUN_VOID (hist_print)
d466 1
a466 1
  int log_scale;
d531 1
a531 3
	  while (SItab[log_scale].scale * top_time < 1000.0
		 && ((size_t) log_scale
		     < sizeof (SItab) / sizeof (SItab[0]) - 1))
d533 4
a536 1
	      ++log_scale;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 21
a21 3
/*
 * Histogram related operations.
 */
d37 1
a37 1
/* declarations of automatically generated functions to output blurbs: */
d40 5
a44 5
bfd_vma s_lowpc;		/* lowest address in .text */
bfd_vma s_highpc = 0;		/* highest address in .text */
bfd_vma lowpc, highpc;		/* same, but expressed in UNITs */
int hist_num_bins = 0;		/* number of histogram samples */
int *hist_sample = 0;		/* histogram samples (shorts in the file!) */
d46 1
a46 2
char hist_dimension[sizeof (((struct gmon_hist_hdr *) 0)->dimen) + 1] =
  "seconds";
d49 5
a53 6
static double accum_time;	/* accumulated time so far for print_line() */
static double total_time;	/* total time for all routines */
/*
 * Table of SI prefixes for powers of 10 (used to automatically
 * scale some of the values in the flat profile).
 */
d61 11
a71 44
  {
    'T', 1e-12
  }
  ,				/* tera */
  {
    'G', 1e-09
  }
  ,				/* giga */
  {
    'M', 1e-06
  }
  ,				/* mega */
  {
    'K', 1e-03
  }
  ,				/* kilo */
  {
    ' ', 1e-00
  }
  ,
  {
    'm', 1e+03
  }
  ,				/* milli */
  {
    'u', 1e+06
  }
  ,				/* micro */
  {
    'n', 1e+09
  }
  ,				/* nano */
  {
    'p', 1e+12
  }
  ,				/* pico */
  {
    'f', 1e+15
  }
  ,				/* femto */
  {
    'a', 1e+18
  }
  ,				/* ato */
d74 4
a77 4
/*
 * Read the histogram from file IFP.  FILENAME is the name of IFP and
 * is provided for formatting error messages only.
 */
a80 1
  struct gmon_hist_hdr hdr;
d85 6
a90 1
  if (fread (&hdr, sizeof (hdr), 1, ifp) != 1)
d94 1
a97 8
  n_lowpc = (bfd_vma) get_vma (core_bfd, (bfd_byte *) hdr.low_pc);
  n_highpc = (bfd_vma) get_vma (core_bfd, (bfd_byte *) hdr.high_pc);
  ncnt = bfd_get_32 (core_bfd, (bfd_byte *) hdr.hist_size);
  profrate = bfd_get_32 (core_bfd, (bfd_byte *) hdr.prof_rate);
  strncpy (hist_dimension, hdr.dimen, sizeof (hdr.dimen));
  hist_dimension[sizeof (hdr.dimen)] = '\0';
  hist_dimension_abbrev = hdr.dimen_abbrev;

d100 1
a100 3

      /* this is the first histogram record: */

d137 1
a137 1
		   _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
d142 4
d150 3
a152 4
/*
 * Write execution histogram to file OFP.  FILENAME is the name
 * of OFP and is provided for formatting error-messages only.
 */
a155 2
  struct gmon_hist_hdr hdr;
  unsigned char tag;
d159 1
a159 9
  /* write header: */

  tag = GMON_TAG_TIME_HIST;
  put_vma (core_bfd, s_lowpc, (bfd_byte *) hdr.low_pc);
  put_vma (core_bfd, s_highpc, (bfd_byte *) hdr.high_pc);
  bfd_put_32 (core_bfd, hist_num_bins, (bfd_byte *) hdr.hist_size);
  bfd_put_32 (core_bfd, hz, (bfd_byte *) hdr.prof_rate);
  strncpy (hdr.dimen, hist_dimension, sizeof (hdr.dimen));
  hdr.dimen_abbrev = hist_dimension_abbrev;
d161 7
a167 2
  if (fwrite (&tag, sizeof (tag), 1, ofp) != 1
      || fwrite (&hdr, sizeof (hdr), 1, ofp) != 1)
d176 1
d186 7
a192 8
/*
 * Calculate scaled entry point addresses (to save time in
 * hist_assign_samples), and, on architectures that have procedure
 * entry masks at the start of a function, possibly push the scaled
 * entry points over the procedure entry mask, if it turns out that
 * the entry point is in one bin and the code for a routine is in the
 * next bin.
 */
d204 2
a205 1
      bin_of_code = (sym->hist.scaled_addr + UNITS_TO_CODE - lowpc) / hist_scale;
d219 37
a255 38
/*
 * Assign samples to the symbol to which they belong.
 *
 * Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)
 * which may overlap one more symbol address ranges.  If a symbol
 * overlaps with the bin's address range by O percent, then O percent
 * of the bin's count is credited to that symbol.
 *
 * There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be
 * with respect to the symbol's address range [SYM_LOW_PC,
 * SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes
 * the distance (in UNITs) between the arrows, the fraction of the
 * sample that is to be credited to the symbol which starts at
 * SYM_LOW_PC.
 *
 *        sym_low_pc                                      sym_high_pc
 *             |                                               |
 *             v                                               v
 *
 *             +-----------------------------------------------+
 *             |                                               |
 *        |  ->|    |<-         ->|         |<-         ->|    |<-  |
 *        |         |             |         |             |         |
 *        +---------+             +---------+             +---------+
 *
 *        ^         ^             ^         ^             ^         ^
 *        |         |             |         |             |         |
 *   bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc
 *
 * For the VAX we assert that samples will never fall in the first two
 * bytes of any routine, since that is the entry mask, thus we call
 * scale_and_align_entries() to adjust the entry points if the entry
 * mask falls in one bin but the code for the routine doesn't start
 * until the next bin.  In conjunction with the alignment of routine
 * addresses, this should allow us to have only one sample for every
 * four bytes of text space and never have any overlap (the two end
 * cases, above).
 */
d266 1
a266 1
  /* read samples and assign to symbols: */
d271 1
a271 2
  /* iterate over all sample bins: */

d275 3
a277 4
      if (!bin_count)
	{
	  continue;
	}
d281 1
d290 1
a290 2
      /* credit all symbols that are covered by bin I: */

d295 3
a297 4
	  /*
	   * If high end of bin is below entry address, go for next
	   * bin:
	   */
d299 4
a302 7
	    {
	      break;
	    }
	  /*
	   * If low end of bin is above high end of symbol, go for
	   * next symbol.
	   */
d304 2
a305 3
	    {
	      continue;
	    }
d312 6
a317 5
			    "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			    (unsigned long) symtab.base[j].addr,
			    (unsigned long) (sizeof (UNIT) * sym_high_pc),
			    symtab.base[j].name, overlap * time / hist_scale,
			    (long) overlap));
d320 4
a323 5
	      /*
	       * Credit symbol if it appears in INCL_FLAT or that
	       * table is empty and it does not appear it in
	       * EXCL_FLAT.
	       */
d337 1
d343 2
a344 3
/*
 * Print header for flag histogram profile:
 */
d370 2
a371 1
      /* this doesn't hurt since all the numerators will be zero: */
d376 2
a377 1
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "), "");
d388 1
a388 3
    {
      return;
    }
d391 1
d393 3
a395 5
    {
      printf ("%5.1f %10.2f %8.2f",
	      total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	      accum_time / hz, sym->hist.time / hz);
    }
d397 4
a400 5
    {
      printf ("%6.2f %9.2f %8.2f",
	      total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	      accum_time / hz, sym->hist.time / hz);
    }
d402 3
a404 5
    {
      printf (" %8lu %8.2f %8.2f  ",
	      sym->ncalls, scale * sym->hist.time / hz / sym->ncalls,
	  scale * (sym->hist.time + sym->cg.child_time) / hz / sym->ncalls);
    }
d406 2
a407 3
    {
      printf (" %8.8s %8.8s %8.8s  ", "", "", "");
    }
d409 1
a409 3
    {
      print_name (sym);
    }
d411 2
a412 3
    {
      print_name_only (sym);
    }
d417 4
a420 5
/*
 * Compare LP and RP.  The primary comparison key is execution time,
 * the secondary is number of invocation, and the tertiary is the
 * lexicographic order of the function names.
 */
d429 1
d431 2
a432 3
    {
      return 1;
    }
d434 1
a434 3
    {
      return -1;
    }
d437 2
a438 3
    {
      return 1;
    }
d440 1
a440 3
    {
      return -1;
    }
d446 2
a447 3
/*
 * Print the flat histogram profile.
 */
d458 1
a458 3
    {
      first_output = FALSE;
    }
d460 1
a460 3
    {
      printf ("\f\n");
    }
d463 1
d476 3
a478 4
  /*
   * Sort the symbol table by time (call-count and name as secondary
   * and tertiary keys):
   */
d480 1
d482 2
a483 3
    {
      time_sorted_syms[index] = &symtab.base[index];
    }
d488 1
a488 1
      log_scale = 5;		/* milli-seconds is BSD-default */
d492 2
a493 4
      /*
       * Search for symbol with highest per-call execution time and
       * scale accordingly:
       */
d497 1
d501 1
d505 1
d513 1
d517 1
d527 3
a529 5
  /*
   * For now, the dimension is always seconds.  In the future, we
   * may also want to support other (pseudo-)dimensions (such as
   * I-cache misses etc.).
   */
d531 1
d535 3
a537 4
      /*
       * Print symbol if its in INCL_FLAT table or that table
       * is empty and the symbol is not in EXCL_FLAT.
       */
d541 1
a541 3
	{
	  print_line (time_sorted_syms[index], SItab[log_scale].scale);
	}
d543 1
d547 1
a547 3
    {
      flat_blurb (stdout);
    }
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d7 1
a7 1
#include "core.h"
d15 4
d105 1
a105 1
      fprintf (stderr, "%s: %s: unexpected end of file\n",
d133 1
a133 1
	       n_lowpc, n_highpc, ncnt);
d135 2
a136 1
	       s_lowpc, s_highpc, hist_num_bins);
d138 1
a138 1
	       lowpc, highpc));
d143 1
a143 1
      fprintf (stderr, "%s: `%s' is incompatible with first gmon file\n",
d159 1
a159 1
		   "%s: %s: unexpected EOF after reading %d of %d samples\n",
d233 3
a235 2
		       sym->hist.scaled_addr,
		       sym->hist.scaled_addr + UNITS_TO_CODE));
d286 2
a287 1
  int bin_count, i, j;
d310 2
a311 1
		    sizeof (UNIT) * bin_low_pc, sizeof (UNIT) * bin_high_pc,
d344 2
a345 1
			    symtab.base[j].addr, sizeof (UNIT) * sym_high_pc,
d347 1
a347 1
			    overlap));
d381 1
a381 1
  sprintf (unit, "%c%c/call", prefix, hist_dimension_abbrev);
d385 1
a385 1
      printf ("\ngranularity: each sample hit covers %ld byte(s)",
d389 1
a389 1
	  printf (" for %.2f%% of %.2f %s\n\n",
d395 1
a395 1
      printf ("\nEach sample counts as %g %s.\n", 1.0 / hz, hist_dimension);
d400 1
a400 1
      printf (" no time accumulated\n\n");
d406 1
a406 1
	  "%  ", "cumulative", "self  ", "", "self  ", "total ", "");
d408 2
a409 2
	  "time", hist_dimension, hist_dimension, "calls", unit, unit,
	  "name");
d434 1
a434 1
  if (sym->ncalls)
d436 1
a436 1
      printf (" %8d %8.2f %8.2f  ",
a466 1
  long call_diff;
d478 1
a478 2
  call_diff = right->ncalls - left->ncalls;
  if (call_diff > 0)
d482 1
a482 1
  if (call_diff < 0)
d498 2
a499 1
  int index, log_scale;
d517 1
a517 1
	  printf ("\n\n\nflat profile:\n");
d523 1
a523 1
      printf ("Flat profile:\n");
d552 1
a552 1
	  if (sym->ncalls)
d562 1
a562 1
      if (top_dog && top_dog->ncalls && top_time > 0.0)
d566 2
a567 1
		 && log_scale < sizeof (SItab) / sizeof (SItab[0]) - 1)
@


1.1
log
@Initial revision
@
text
@d213 1
a213 1
DEFUN_VOID (scale_and_align_entries)
a215 1
#if OFFSET_TO_CODE > 0
a217 1
#endif
a221 1
#if OFFSET_TO_CODE > 0
d228 3
a230 2
		 sym->hist.scaled_addr, sym->aligned_addr + UNITS_TO_CODE));
	  sym->aligned_addr += UNITS_TO_CODE;
a231 1
#endif /* OFFSET_TO_CODE > 0 */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d213 1
a213 1
scale_and_align_entries ()
d216 1
d219 1
d224 1
d231 2
a232 3
		       sym->hist.scaled_addr,
		       sym->hist.scaled_addr + UNITS_TO_CODE));
	  sym->hist.scaled_addr += UNITS_TO_CODE;
d234 1
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a14 2
static void scale_and_align_entries PARAMS ((void));

@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 1
#include "corefile.h"
a14 2
#define UNITS_TO_CODE (offset_to_code / sizeof(UNIT))

d103 1
a103 1
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
d131 1
a131 1
	       (unsigned long) n_lowpc, (unsigned long) n_highpc, ncnt);
d133 1
a133 2
	       (unsigned long) s_lowpc, (unsigned long) s_highpc,
	       hist_num_bins);
d135 1
a135 1
	       (unsigned long) lowpc, (unsigned long) highpc));
d140 1
a140 1
      fprintf (stderr, _("%s: `%s' is incompatible with first gmon file\n"),
d156 1
a156 1
		   _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
d230 2
a231 3
		       (unsigned long) sym->hist.scaled_addr,
		       (unsigned long) (sym->hist.scaled_addr
					+ UNITS_TO_CODE)));
d282 1
a282 2
  int bin_count, i;
  unsigned int j;
d305 1
a305 2
		    (unsigned long) (sizeof (UNIT) * bin_low_pc),
		    (unsigned long) (sizeof (UNIT) * bin_high_pc),
d338 1
a338 2
			    (unsigned long) symtab.base[j].addr,
			    (unsigned long) (sizeof (UNIT) * sym_high_pc),
d340 1
a340 1
			    (long) overlap));
d374 1
a374 1
  sprintf (unit, _("%c%c/call"), prefix, hist_dimension_abbrev);
d378 1
a378 1
      printf (_("\ngranularity: each sample hit covers %ld byte(s)"),
d382 1
a382 1
	  printf (_(" for %.2f%% of %.2f %s\n\n"),
d388 1
a388 1
      printf (_("\nEach sample counts as %g %s.\n"), 1.0 / hz, hist_dimension);
d393 1
a393 1
      printf (_(" no time accumulated\n\n"));
d399 1
a399 1
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "), "");
d401 2
a402 2
	  _("time"), hist_dimension, hist_dimension, _("calls"), unit, unit,
	  _("name"));
d427 1
a427 1
  if (sym->ncalls != 0)
d429 1
a429 1
      printf (" %8lu %8.2f %8.2f  ",
d460 1
d472 2
a473 1
  if (right->ncalls > left->ncalls)
d477 1
a477 1
  if (right->ncalls < left->ncalls)
d493 1
a493 2
  unsigned int index;
  int log_scale;
d511 1
a511 1
	  printf (_("\n\n\nflat profile:\n"));
d517 1
a517 1
      printf (_("Flat profile:\n"));
d546 1
a546 1
	  if (sym->ncalls != 0)
d556 1
a556 1
      if (top_dog && top_dog->ncalls != 0 && top_time > 0.0)
d560 1
a560 2
		 && ((size_t) log_scale
		     < sizeof (SItab) / sizeof (SItab[0]) - 1))
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 3
a3 21
/* hist.c  -  Histogram related operations.

   Copyright 2000, 2001 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

d19 1
a19 1
/* Declarations of automatically generated functions to output blurbs.  */
d22 5
a26 5
bfd_vma s_lowpc;		/* Lowest address in .text.  */
bfd_vma s_highpc = 0;		/* Highest address in .text.  */
bfd_vma lowpc, highpc;		/* Same, but expressed in UNITs.  */
int hist_num_bins = 0;		/* Number of histogram samples.  */
int *hist_sample = 0;		/* Histogram samples (shorts in the file!).  */
d28 2
a29 1
char hist_dimension[16] = "seconds";
d32 6
a37 5
static double accum_time;	/* Accumulated time so far for print_line(). */
static double total_time;	/* Total time for all routines.  */

/* Table of SI prefixes for powers of 10 (used to automatically
   scale some of the values in the flat profile).  */
d45 44
a88 11
  { 'T', 1e-12 },				/* tera */
  { 'G', 1e-09 },				/* giga */
  { 'M', 1e-06 },				/* mega */
  { 'K', 1e-03 },				/* kilo */
  { ' ', 1e-00 },
  { 'm', 1e+03 },				/* milli */
  { 'u', 1e+06 },				/* micro */
  { 'n', 1e+09 },				/* nano */
  { 'p', 1e+12 },				/* pico */
  { 'f', 1e+15 },				/* femto */
  { 'a', 1e+18 }				/* ato */
d91 4
a94 4

/* Read the histogram from file IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  */

d98 1
d103 1
a103 6
  if (gmon_io_read_vma (ifp, &n_lowpc)
      || gmon_io_read_vma (ifp, &n_highpc)
      || gmon_io_read_32 (ifp, &ncnt)
      || gmon_io_read_32 (ifp, &profrate)
      || gmon_io_read (ifp, hist_dimension, 15)
      || gmon_io_read (ifp, &hist_dimension_abbrev, 1))
a106 1

d110 8
d120 3
a122 1
      /* This is the first histogram record.  */
d159 1
a159 1
		  _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
a163 4
      DBG (SAMPLEDEBUG,
	   printf ("[hist_read_rec] 0x%lx: %u\n",
		   (unsigned long) (n_lowpc + i * (n_highpc - n_lowpc) / ncnt),
		   hist_sample[i]));
d168 4
a171 3
/* Write execution histogram to file OFP.  FILENAME is the name
   of OFP and is provided for formatting error-messages only.  */

d175 2
d180 9
a188 1
  /* Write header.  */
d190 2
a191 7
  if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
      || gmon_io_write_vma (ofp, s_lowpc)
      || gmon_io_write_vma (ofp, s_highpc)
      || gmon_io_write_32 (ofp, hist_num_bins)
      || gmon_io_write_32 (ofp, hz)
      || gmon_io_write (ofp, hist_dimension, 15)
      || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
a199 1

d209 8
a216 7
/* Calculate scaled entry point addresses (to save time in
   hist_assign_samples), and, on architectures that have procedure
   entry masks at the start of a function, possibly push the scaled
   entry points over the procedure entry mask, if it turns out that
   the entry point is in one bin and the code for a routine is in the
   next bin.  */

d228 1
a228 2
      bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - lowpc)
		     / hist_scale);
d242 38
a279 37
/* Assign samples to the symbol to which they belong.

   Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)
   which may overlap one more symbol address ranges.  If a symbol
   overlaps with the bin's address range by O percent, then O percent
   of the bin's count is credited to that symbol.

   There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be
   with respect to the symbol's address range [SYM_LOW_PC,
   SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes
   the distance (in UNITs) between the arrows, the fraction of the
   sample that is to be credited to the symbol which starts at
   SYM_LOW_PC.

	  sym_low_pc                                      sym_high_pc
	       |                                               |
	       v                                               v

	       +-----------------------------------------------+
	       |                                               |
	  |  ->|    |<-         ->|         |<-         ->|    |<-  |
	  |         |             |         |             |         |
	  +---------+             +---------+             +---------+

	  ^         ^             ^         ^             ^         ^
	  |         |             |         |             |         |
     bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc

   For the VAX we assert that samples will never fall in the first two
   bytes of any routine, since that is the entry mask, thus we call
   scale_and_align_entries() to adjust the entry points if the entry
   mask falls in one bin but the code for the routine doesn't start
   until the next bin.  In conjunction with the alignment of routine
   addresses, this should allow us to have only one sample for every
   four bytes of text space and never have any overlap (the two end
   cases, above).  */

d290 1
a290 1
  /* Read samples and assign to symbols.  */
d295 2
a296 1
  /* Iterate over all sample bins.  */
d300 4
a303 3
      if (! bin_count)
	continue;

a306 1

d315 2
a316 1
      /* Credit all symbols that are covered by bin I.  */
d321 4
a324 3

	  /* If high end of bin is below entry address,
	     go for next bin.  */
d326 7
a332 4
	    break;

	  /* If low end of bin is above high end of symbol,
	     go for next symbol.  */
d334 3
a336 2
	    continue;

d343 5
a347 6
	       "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			   (unsigned long) symtab.base[j].addr,
			   (unsigned long) (sizeof (UNIT) * sym_high_pc),
			   symtab.base[j].name, overlap * time / hist_scale,
			   (long) overlap));

d350 5
a354 4

	      /* Credit symbol if it appears in INCL_FLAT or that
		 table is empty and it does not appear it in
		 EXCL_FLAT.  */
a367 1

d373 3
a375 2
/* Print header for flag histogram profile.  */

d401 1
a401 2

      /* This doesn't hurt since all the numerators will be zero.  */
d406 1
a406 2
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "),
	  "");
d417 3
a419 1
    return;
a421 1

d423 5
a427 3
    printf ("%5.1f %10.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);
d429 5
a433 4
    printf ("%6.2f %9.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);

d435 5
a439 3
    printf (" %8lu %8.2f %8.2f  ",
	    sym->ncalls, scale * sym->hist.time / hz / sym->ncalls,
	    scale * (sym->hist.time + sym->cg.child_time) / hz / sym->ncalls);
d441 3
a443 2
    printf (" %8.8s %8.8s %8.8s  ", "", "", "");

d445 3
a447 1
    print_name (sym);
d449 3
a451 2
    print_name_only (sym);

d456 5
a460 4
/* Compare LP and RP.  The primary comparison key is execution time,
   the secondary is number of invocation, and the tertiary is the
   lexicographic order of the function names.  */

a468 1

d470 3
a472 2
    return 1;

d474 3
a476 1
    return -1;
d479 3
a481 2
    return 1;

d483 3
a485 1
    return -1;
d491 3
a493 2
/* Print the flat histogram profile.  */

d504 3
a506 1
    first_output = FALSE;
d508 3
a510 1
    printf ("\f\n");
a512 1

d525 4
a528 3

  /* Sort the symbol table by time (call-count and name as secondary
     and tertiary keys).  */
a529 1

d531 3
a533 2
    time_sorted_syms[index] = &symtab.base[index];

d538 1
a538 1
      log_scale = 5;		/* Milli-seconds is BSD-default.  */
d542 4
a545 2
      /* Search for symbol with highest per-call
	 execution time and scale accordingly.  */
a548 1

a551 1

a554 1

a561 1

a564 1

d574 5
a578 3
  /* For now, the dimension is always seconds.  In the future, we
     may also want to support other (pseudo-)dimensions (such as
     I-cache misses etc.).  */
a579 1

d583 4
a586 3

      /* Print symbol if its in INCL_FLAT table or that table
	is empty and the symbol is not in EXCL_FLAT.  */
d590 3
a592 1
	print_line (time_sorted_syms[index], SItab[log_scale].scale);
a593 1

d597 3
a599 1
    flat_blurb (stdout);
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d22 1
a24 3
#include "search_list.h"
#include "source.h"
#include "symtab.h"
d29 1
a35 3
static void print_header PARAMS ((int));
static void print_line PARAMS ((Sym *, double));
static int cmp_time PARAMS ((const PTR, const PTR));
d79 1
a79 3
hist_read_rec (ifp, filename)
     FILE * ifp;
     const char *filename;
d154 1
a154 3
hist_write_hist (ofp, filename)
     FILE * ofp;
     const char *filename;
d175 1
a175 1
      bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i], (bfd_byte *) &count[0]);
d257 1
a257 1
hist_assign_samples ()
d346 1
a346 2
print_header (prefix)
     int prefix;
d385 1
a385 3
print_line (sym, scale)
     Sym *sym;
     double scale;
d422 1
a422 3
cmp_time (lp, rp)
     const PTR lp;
     const PTR rp;
d449 1
a449 1
hist_print ()
d453 1
a453 1
  unsigned log_scale;
d518 3
a520 1
	  for (log_scale = 0; log_scale < ARRAY_SIZE (SItab); log_scale ++)
d522 1
a522 4
	      double scaled_value = SItab[log_scale].scale * top_time;

	      if (scaled_value >= 1.0 && scaled_value < 1000.0) 
		break;
@


