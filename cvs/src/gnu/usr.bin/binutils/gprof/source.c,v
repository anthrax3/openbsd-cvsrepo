head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.40;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.12.32;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.07.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.10.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.10.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.50.32;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.48.43;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.14.03.16;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.56;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* source.c - Keep track of source files.

   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "gprof.h"
#include "libiberty.h"
#include "filenames.h"
#include "search_list.h"
#include "source.h"

#define EXT_ANNO "-ann"		/* Postfix of annotated files.  */

/* Default option values.  */
bfd_boolean create_annotation_files = FALSE;

Search_List src_search_list = {0, 0};
Source_File *first_src_file = 0;


Source_File *
source_file_lookup_path (path)
     const char *path;
{
  Source_File *sf;

  for (sf = first_src_file; sf; sf = sf->next)
    {
      if (FILENAME_CMP (path, sf->name) == 0)
	break;
    }

  if (!sf)
    {
      /* Create a new source file descriptor.  */
      sf = (Source_File *) xmalloc (sizeof (*sf));

      memset (sf, 0, sizeof (*sf));

      sf->name = xstrdup (path);
      sf->next = first_src_file;
      first_src_file = sf;
    }

  return sf;
}


Source_File *
source_file_lookup_name (filename)
     const char *filename;
{
  const char *fname;
  Source_File *sf;

  /* The user cannot know exactly how a filename will be stored in
     the debugging info (e.g., ../include/foo.h
     vs. /usr/include/foo.h).  So we simply compare the filename
     component of a path only.  */
  for (sf = first_src_file; sf; sf = sf->next)
    {
      fname = strrchr (sf->name, '/');

      if (fname)
	++fname;
      else
	fname = sf->name;

      if (FILENAME_CMP (filename, fname) == 0)
	break;
    }

  return sf;
}


FILE *
annotate_source (sf, max_width, annote, arg)
     Source_File *sf;
     unsigned int max_width;
     void (*annote) PARAMS ((char *, unsigned int, int, void *));
     void *arg;
{
  static bfd_boolean first_file = TRUE;
  int i, line_num, nread;
  bfd_boolean new_line;
  char buf[8192];
  char fname[PATH_MAX];
  char *annotation, *name_only;
  FILE *ifp, *ofp;
  Search_List_Elem *sle = src_search_list.head;

  /* Open input file.  If open fails, walk along search-list until
     open succeeds or reaching end of list.  */
  strcpy (fname, sf->name);

  if (IS_ABSOLUTE_PATH (sf->name))
    sle = 0;			/* Don't use search list for absolute paths.  */

  name_only = 0;
  while (TRUE)
    {
      DBG (SRCDEBUG, printf ("[annotate_source]: looking for %s, trying %s\n",
			     sf->name, fname));

      ifp = fopen (fname, FOPEN_RB);
      if (ifp)
	break;

      if (!sle && !name_only)
	{
	  name_only = strrchr (sf->name, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	  {
	    char *bslash = strrchr (sf->name, '\\');
	    if (name_only == NULL || (bslash != NULL && bslash > name_only))
	      name_only = bslash;
	    if (name_only == NULL && sf->name[0] != '\0' && sf->name[1] == ':')
	      name_only = (char *)sf->name + 1;
	  }
#endif
	  if (name_only)
	    {
	      /* Try search-list again, but this time with name only.  */
	      ++name_only;
	      sle = src_search_list.head;
	    }
	}

      if (sle)
	{
	  strcpy (fname, sle->path);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	  /* d:foo is not the same thing as d:/foo!  */
	  if (fname[strlen (fname) - 1] == ':')
	    strcat (fname, ".");
#endif
	  strcat (fname, "/");

	  if (name_only)
	    strcat (fname, name_only);
	  else
	    strcat (fname, sf->name);

	  sle = sle->next;
	}
      else
	{
	  if (errno == ENOENT)
	    fprintf (stderr, _("%s: could not locate `%s'\n"),
		     whoami, sf->name);
	  else
	    perror (sf->name);

	  return 0;
	}
    }

  ofp = stdout;

  if (create_annotation_files)
    {
      /* Try to create annotated source file.  */
      const char *filename;

      /* Create annotation files in the current working directory.  */
      filename = strrchr (sf->name, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	{
	  char *bslash = strrchr (sf->name, '\\');
	  if (filename == NULL || (bslash != NULL && bslash > filename))
	    filename = bslash;
	  if (filename == NULL && sf->name[0] != '\0' && sf->name[1] == ':')
	    filename = sf->name + 1;
	}
#endif
      if (filename)
	++filename;
      else
	filename = sf->name;

      strcpy (fname, filename);
      strcat (fname, EXT_ANNO);
#ifdef __MSDOS__
      {
	/* foo.cpp-ann can overwrite foo.cpp due to silent truncation of
	   file names on 8+3 filesystems.  Their `stat' better be good...  */
	struct stat buf1, buf2;

	if (stat (filename, &buf1) == 0
	    && stat (fname, &buf2) == 0
	    && buf1.st_ino == buf2.st_ino)
	  {
	    char *dot = strrchr (fname, '.');

	    if (dot)
	      *dot = '\0';
	    strcat (fname, ".ann");
	  }
      }
#endif
      ofp = fopen (fname, "w");

      if (!ofp)
	{
	  perror (fname);
	  return 0;
	}
    }

  /* Print file names if output goes to stdout
     and there are more than one source file.  */
  if (ofp == stdout)
    {
      if (first_file)
	first_file = FALSE;
      else
	fputc ('\n', ofp);

      if (first_output)
	first_output = FALSE;
      else
	fprintf (ofp, "\f\n");

      fprintf (ofp, _("*** File %s:\n"), sf->name);
    }

  annotation = xmalloc (max_width + 1);
  line_num = 1;
  new_line = TRUE;

  while ((nread = fread (buf, 1, sizeof (buf), ifp)) > 0)
    {
      for (i = 0; i < nread; ++i)
	{
	  if (new_line)
	    {
	      (*annote) (annotation, max_width, line_num, arg);
	      fputs (annotation, ofp);
	      ++line_num;
	      new_line = FALSE;
	    }

	  new_line = (buf[i] == '\n');
	  fputc (buf[i], ofp);
	}
    }

  free (annotation);
  return ofp;
}
@


1.4
log
@resolve conflicts.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d31 1
a31 1
bool create_annotation_files = FALSE;
d38 2
a39 1
DEFUN (source_file_lookup_path, (path), const char *path)
d66 2
a67 1
DEFUN (source_file_lookup_name, (filename), const char *filename)
d94 5
a98 4
DEFUN (annotate_source, (sf, max_width, annote, arg),
       Source_File * sf AND int max_width
       AND void (*annote) PARAMS ((char *buf, int w, int l, void *arg))
       AND void *arg)
d100 1
a100 1
  static bool first_file = TRUE;
d102 1
a102 1
  bool new_line;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 21
a21 3
/*
 * Keeps track of source files.
 */
d28 1
a28 1
#define EXT_ANNO "-ann"		/* postfix of annotated files */
d30 1
a30 3
/*
 * Default option values:
 */
d33 1
a33 2
Search_List src_search_list =
{0, 0};
d45 1
a45 3
	{
	  break;
	}
d47 1
d50 2
a51 1
      /* create a new source file descriptor: */
a52 1
      sf = (Source_File *) xmalloc (sizeof (*sf));
d54 1
d59 1
d69 5
a73 6
  /*
   * The user cannot know exactly how a filename will be stored in
   * the debugging info (e.g., ../include/foo.h
   * vs. /usr/include/foo.h).  So we simply compare the filename
   * component of a path only:
   */
d77 1
d79 1
a79 3
	{
	  ++fname;
	}
d81 2
a82 3
	{
	  fname = sf->name;
	}
d84 1
a84 3
	{
	  break;
	}
d86 1
d106 2
a107 4
  /*
   * Open input file.  If open fails, walk along search-list until
   * open succeeds or reaching end of list:
   */
d109 1
d111 2
a112 3
    {
      sle = 0;			/* don't use search list for absolute paths */
    }
d118 1
d121 2
a122 3
	{
	  break;
	}
d129 1
a129 1
	    if (bslash > name_only)
d137 1
a137 1
	      /* try search-list again, but this time with name only: */
d142 1
d152 1
d154 1
a154 3
	    {
	      strcat (fname, name_only);
	    }
d156 2
a157 3
	    {
	      strcat (fname, sf->name);
	    }
d163 2
a164 4
	    {
	      fprintf (stderr, _("%s: could not locate `%s'\n"),
		       whoami, sf->name);
	    }
d166 2
a167 3
	    {
	      perror (sf->name);
	    }
d173 1
d176 1
a176 1
      /* try to create annotated source file: */
d179 1
a179 1
      /* create annotation files in the current working directory: */
d184 1
a184 1
	  if (bslash > filename)
d191 1
a191 3
	{
	  ++filename;
	}
d193 1
a193 3
	{
	  filename = sf->name;
	}
d216 1
d224 2
a225 4
  /*
   * Print file names if output goes to stdout and there are
   * more than one source file:
   */
d229 1
a229 3
	{
	  first_file = FALSE;
	}
d231 2
a232 3
	{
	  fputc ('\n', ofp);
	}
d234 1
a234 3
	{
	  first_output = FALSE;
	}
d236 2
a237 3
	{
	  fprintf (ofp, "\f\n");
	}
d244 1
d256 1
d261 1
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d6 1
d29 1
a29 1
      if (strcmp (path, sf->name) == 0)
d70 1
a70 1
      if (strcmp (filename, fname) == 0)
d99 1
a99 1
  if (sf->name[0] == '/')
d116 9
d135 5
d155 1
a155 1
	      fprintf (stderr, "%s: could not locate `%s'\n",
d174 9
d194 18
d242 1
a242 1
      fprintf (ofp, "*** File %s:\n", sf->name);
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
      sf->name = strdup (path);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d39 1
a39 1
      sf->name = xstrdup (path);
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@a5 1
#include "filenames.h"
d28 1
a28 1
      if (FILENAME_CMP (path, sf->name) == 0)
d69 1
a69 1
      if (FILENAME_CMP (filename, fname) == 0)
d98 1
a98 1
  if (IS_ABSOLUTE_PATH (sf->name))
a114 9
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	  {
	    char *bslash = strrchr (sf->name, '\\');
	    if (bslash > name_only)
	      name_only = bslash;
	    if (name_only == NULL && sf->name[0] != '\0' && sf->name[1] == ':')
	      name_only = (char *)sf->name + 1;
	  }
#endif
a124 5
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	  /* d:foo is not the same thing as d:/foo!  */
	  if (fname[strlen (fname) - 1] == ':')
	    strcat (fname, ".");
#endif
d140 1
a140 1
	      fprintf (stderr, _("%s: could not locate `%s'\n"),
a158 9
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	{
	  char *bslash = strrchr (sf->name, '\\');
	  if (bslash > filename)
	    filename = bslash;
	  if (filename == NULL && sf->name[0] != '\0' && sf->name[1] == ':')
	    filename = sf->name + 1;
	}
#endif
a169 18
#ifdef __MSDOS__
      {
	/* foo.cpp-ann can overwrite foo.cpp due to silent truncation of
	   file names on 8+3 filesystems.  Their `stat' better be good...  */
	struct stat buf1, buf2;

	if (stat (filename, &buf1) == 0
	    && stat (fname, &buf2) == 0
	    && buf1.st_ino == buf2.st_ino)
	  {
	    char *dot = strrchr (fname, '.');

	    if (dot)
	      *dot = '\0';
	    strcat (fname, ".ann");
	  }
      }
#endif
d200 1
a200 1
      fprintf (ofp, _("*** File %s:\n"), sf->name);
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 3
a3 21
/* source.c - Keep track of source files.

   Copyright 2000, 2001 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

d10 1
a10 1
#define EXT_ANNO "-ann"		/* Postfix of annotated files.  */
d12 3
a14 1
/* Default option values.  */
d17 2
a18 1
Search_List src_search_list = {0, 0};
d30 3
a32 1
	break;
a33 1

d36 2
a37 1
      /* Create a new source file descriptor.  */
a38 1

a39 1

a43 1

d53 6
a58 5

  /* The user cannot know exactly how a filename will be stored in
     the debugging info (e.g., ../include/foo.h
     vs. /usr/include/foo.h).  So we simply compare the filename
     component of a path only.  */
a61 1

d63 3
a65 1
	++fname;
d67 3
a69 2
	fname = sf->name;

d71 3
a73 1
	break;
a74 1

d94 4
a97 2
  /* Open input file.  If open fails, walk along search-list until
     open succeeds or reaching end of list.  */
a98 1

d100 3
a102 2
    sle = 0;			/* Don't use search list for absolute paths.  */

a107 1

d110 3
a112 2
	break;

d119 1
a119 1
	    if (name_only == NULL || (bslash != NULL && bslash > name_only))
d127 1
a127 1
	      /* Try search-list again, but this time with name only.  */
a131 1

a140 1

d142 3
a144 1
	    strcat (fname, name_only);
d146 3
a148 2
	    strcat (fname, sf->name);

d154 4
a157 2
	    fprintf (stderr, _("%s: could not locate `%s'\n"),
		     whoami, sf->name);
d159 3
a161 2
	    perror (sf->name);

a166 1

d169 1
a169 1
      /* Try to create annotated source file.  */
d172 1
a172 1
      /* Create annotation files in the current working directory.  */
d177 1
a177 1
	  if (filename == NULL || (bslash != NULL && bslash > filename))
d184 3
a186 1
	++filename;
d188 3
a190 1
	filename = sf->name;
a212 1

d220 4
a223 2
  /* Print file names if output goes to stdout
     and there are more than one source file.  */
d227 3
a229 1
	first_file = FALSE;
d231 3
a233 2
	fputc ('\n', ofp);

d235 3
a237 1
	first_output = FALSE;
d239 3
a241 2
	fprintf (ofp, "\f\n");

a247 1

a258 1

a262 1

@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d31 1
a31 1
bfd_boolean create_annotation_files = FALSE;
d38 1
a38 2
source_file_lookup_path (path)
     const char *path;
d65 1
a65 2
source_file_lookup_name (filename)
     const char *filename;
d92 4
a95 5
annotate_source (sf, max_width, annote, arg)
     Source_File *sf;
     unsigned int max_width;
     void (*annote) PARAMS ((char *, unsigned int, int, void *));
     void *arg;
d97 1
a97 1
  static bfd_boolean first_file = TRUE;
d99 1
a99 1
  bfd_boolean new_line;
@


