head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.52
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.50
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.46
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.42
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.44
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.36
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.40
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.38
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.34
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.32
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.30
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.28
	OPENBSD_5_0:1.2.0.26
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.24
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.22
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.18
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.16
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2005.05.03.10.59.13;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.12.14.45.37;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.45.37;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.09.22.06.44;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.23.17;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.14;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.2
log
@When printing a function name for warning or error lines, prefer a global
symbol on arm, rather the local symbols ($a/$d/$t) the arm ELF ABI creates.

This makes ld unreferenced symbols error much more useable.

tweaks and ok kettenis@@, 2+ months ago but I forgot to commit...
@
text
@/* 32-bit ELF support for ARM
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef USE_REL
#define USE_REL	0
#endif

typedef unsigned long int insn32;
typedef unsigned short int insn16;

static bfd_boolean elf32_arm_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean elf32_arm_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_arm_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_arm_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static int elf32_arm_get_symbol_type
  PARAMS (( Elf_Internal_Sym *, int));
static struct bfd_link_hash_table *elf32_arm_link_hash_table_create
  PARAMS ((bfd *));
static bfd_reloc_status_type elf32_arm_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma, struct bfd_link_info *, asection *,
	   const char *, int, struct elf_link_hash_entry *));
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
static struct elf_link_hash_entry *find_thumb_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
static struct elf_link_hash_entry *find_arm_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
static void elf32_arm_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));
static int elf32_arm_to_thumb_stub
  PARAMS ((struct bfd_link_info *, const char *, bfd *, bfd *, asection *,
	   bfd_byte *, asection *, bfd_vma, bfd_signed_vma, bfd_vma));
static int elf32_thumb_to_arm_stub
  PARAMS ((struct bfd_link_info *, const char *, bfd *, bfd *, asection *,
	   bfd_byte *, asection *, bfd_vma, bfd_signed_vma, bfd_vma));
static bfd_boolean elf32_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static asection * elf32_arm_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_arm_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static bfd_boolean elf32_arm_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf32_arm_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf32_arm_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf32_arm_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static struct bfd_hash_entry * elf32_arm_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
#if USE_REL
static void arm_add_to_rel
  PARAMS ((bfd *, bfd_byte *, reloc_howto_type *, bfd_signed_vma));
#endif
static bfd_boolean allocate_dynrelocs 
  PARAMS ((struct elf_link_hash_entry *h, PTR inf));
static bfd_boolean create_got_section 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static bfd_boolean elf32_arm_create_dynamic_sections 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static enum elf_reloc_type_class elf32_arm_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_object_p
  PARAMS ((bfd *));

#ifndef ELFARM_NABI_C_INCLUDED
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));
#endif


#define INTERWORK_FLAG(abfd)   (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK)

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.  */
#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
#define ELF_DYNAMIC_INTERPRETER     "/usr/lib/ld.so.1"

#ifdef FOUR_WORD_PLT

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 16

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 16

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };

#else

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 20

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };

#endif

/* The ARM linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */
struct elf32_arm_relocs_copied
  {
    /* Next section.  */
    struct elf32_arm_relocs_copied * next;
    /* A section in dynobj.  */
    asection * section;
    /* Number of relocs copied in this section.  */
    bfd_size_type count;
  };

/* Arm ELF linker hash entry.  */
struct elf32_arm_link_hash_entry
  {
    struct elf_link_hash_entry root;

    /* Number of PC relative relocs copied for this symbol.  */
    struct elf32_arm_relocs_copied * relocs_copied;
  };

/* Traverse an arm ELF linker hash table.  */
#define elf32_arm_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
    (info)))

/* Get the ARM elf linker hash table from a link_info structure.  */
#define elf32_arm_hash_table(info) \
  ((struct elf32_arm_link_hash_table *) ((info)->hash))

/* ARM ELF linker hash table.  */
struct elf32_arm_link_hash_table
  {
    /* The main hash table.  */
    struct elf_link_hash_table root;

    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
    bfd_size_type thumb_glue_size;

    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
    bfd_size_type arm_glue_size;

    /* An arbitrary input BFD chosen to hold the glue sections.  */
    bfd * bfd_of_glue_owner;

    /* A boolean indicating whether knowledge of the ARM's pipeline
       length should be applied by the linker.  */
    int no_pipeline_knowledge;

    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;

    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
  };

/* Create an entry in an ARM ELF linker hash table.  */

static struct bfd_hash_entry *
elf32_arm_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry * entry;
     struct bfd_hash_table * table;
     const char * string;
{
  struct elf32_arm_link_hash_entry * ret =
    (struct elf32_arm_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf32_arm_link_hash_entry *) NULL)
    ret = ((struct elf32_arm_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_arm_link_hash_entry)));
  if (ret == (struct elf32_arm_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_arm_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf32_arm_link_hash_entry *) NULL)
    ret->relocs_copied = NULL;

  return (struct bfd_hash_entry *) ret;
}

/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf32_arm_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");

  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;

	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->relocs_copied;
	}

      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

/* Create an ARM elf linker hash table.  */

static struct bfd_link_hash_table *
elf32_arm_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct elf32_arm_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf32_arm_link_hash_table);

  ret = (struct elf32_arm_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf32_arm_link_hash_table *) NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      elf32_arm_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->thumb_glue_size = 0;
  ret->arm_glue_size = 0;
  ret->bfd_of_glue_owner = NULL;
  ret->no_pipeline_knowledge = 0;
  ret->sym_sec.abfd = NULL;

  return &ret->root.root;
}

/* Locate the Thumb encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_thumb_glue (link_info, name, input_bfd)
     struct bfd_link_info *link_info;
     const char *name;
     bfd *input_bfd;
{
  char *tmp_name;
  struct elf_link_hash_entry *hash;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the armelf specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  hash = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (hash == NULL)
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%s: unable to find THUMB glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);

  free (tmp_name);

  return hash;
}

/* Locate the ARM encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_arm_glue (link_info, name, input_bfd)
     struct bfd_link_info *link_info;
     const char *name;
     bfd *input_bfd;
{
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the elfarm specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%s: unable to find ARM glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);

  free (tmp_name);

  return myh;
}

/* ARM->Thumb glue:

   .arm
   __func_from_arm:
   ldr r12, __func_addr
   bx  r12
   __func_addr:
   .word func    @@ behave as if you saw a ARM_32 reloc.  */

#define ARM2THUMB_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM

   .thumb                               .thumb
   .align 2                             .align 2
   __func_from_thumb:              __func_from_thumb:
   bx pc                                push {r6, lr}
   nop                                  ldr  r6, __func_addr
   .arm                                         mov  lr, pc
   __func_change_to_arm:                        bx   r6
   b func                       .arm
   __func_back_to_thumb:
   ldmia r13! {r6, lr}
   bx    lr
   __func_addr:
   .word        func  */

#define THUMB2ARM_GLUE_SIZE 8
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn = 0x46c0;
static const insn32 t2a3_b_insn = 0xea000000;

#ifndef ELFARM_NABI_C_INCLUDED
bfd_boolean
bfd_elf32_arm_allocate_interworking_sections (info)
     struct bfd_link_info * info;
{
  asection * s;
  bfd_byte * foo;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
				   ARM2THUMB_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);

      s->_raw_size = s->_cooked_size = globals->arm_glue_size;
      s->contents = foo;
    }

  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);

      s->_raw_size = s->_cooked_size = globals->thumb_glue_size;
      s->contents = foo;
    }

  return TRUE;
}

static void
record_arm_to_thumb_glue (link_info, h)
     struct bfd_link_info * link_info;
     struct elf_link_hash_entry * h;
{
  const char * name = h->root.root.string;
  asection * s;
  char * tmp_name;
  struct elf_link_hash_entry * myh;
  struct bfd_link_hash_entry * bh;
  struct elf32_arm_link_hash_table * globals;
  bfd_vma val;

  globals = elf32_arm_hash_table (link_info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return;
    }

  /* The only trick here is using hash_table->arm_glue_size as the value. Even
     though the section isn't allocated yet, this is where we will be putting
     it.  */
  bh = NULL;
  val = globals->arm_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;

  return;
}

static void
record_thumb_to_arm_glue (link_info, h)
     struct bfd_link_info *link_info;
     struct elf_link_hash_entry *h;
{
  const char *name = h->root.root.string;
  asection *s;
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct bfd_link_hash_entry *bh;
  struct elf32_arm_link_hash_table *hash_table;
  char bind;
  bfd_vma val;

  hash_table = elf32_arm_hash_table (link_info);

  BFD_ASSERT (hash_table != NULL);
  BFD_ASSERT (hash_table->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (hash_table->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return;
    }

  bh = NULL;
  val = hash_table->thumb_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  /* If we mark it 'Thumb', the disassembler will do a better job.  */
  myh = (struct elf_link_hash_entry *) bh;
  bind = ELF_ST_BIND (myh->type);
  myh->type = ELF_ST_INFO (bind, STT_ARM_TFUNC);

  free (tmp_name);

#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"

  /* Allocate another symbol to mark where we switch to Arm mode.  */
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (CHANGE_TO_ARM) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, CHANGE_TO_ARM, name);

  bh = NULL;
  val = hash_table->thumb_glue_size + 4,
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  hash_table->thumb_glue_size += THUMB2ARM_GLUE_SIZE;

  return;
}

/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */

bfd_boolean
bfd_elf32_arm_add_glue_sections_to_bfd (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  asection *sec;

  /* If we are only performing a partial
     link do not bother adding the glue.  */
  if (info->relocatable)
    return TRUE;

  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      /* Note: we do not include the flag SEC_LINKER_CREATED, as this
	 will prevent elf_link_input_bfd() from processing the contents
	 of this section.  */
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);

      if (sec == NULL
	  || !bfd_set_section_flags (abfd, sec, flags)
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      /* Set the gc mark to prevent the section from being removed by garbage
	 collection, despite the fact that no relocs refer to this section.  */
      sec->gc_mark = 1;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);

      if (sec == NULL
	  || !bfd_set_section_flags (abfd, sec, flags)
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      sec->gc_mark = 1;
    }

  return TRUE;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */

bfd_boolean
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocatable)
    return TRUE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;

  return TRUE;
}

bfd_boolean
bfd_elf32_arm_process_before_allocation (abfd, link_info, no_pipeline_knowledge)
     bfd *abfd;
     struct bfd_link_info *link_info;
     int no_pipeline_knowledge;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;

  asection *sec;
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (link_info->relocatable)
    return TRUE;

  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
  globals = elf32_arm_hash_table (link_info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  globals->no_pipeline_knowledge = no_pipeline_knowledge;

  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return TRUE;

  for (; sec != NULL; sec = sec->next)
    {
      if (sec->reloc_count == 0)
	continue;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

      /* Load the relocs.  */
      internal_relocs
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);

      if (internal_relocs == NULL)
	goto error_return;

      irelend = internal_relocs + sec->reloc_count;
      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  long r_type;
	  unsigned long r_index;

	  struct elf_link_hash_entry *h;

	  r_type = ELF32_R_TYPE (irel->r_info);
	  r_index = ELF32_R_SYM (irel->r_info);

	  /* These are the only relocation types we care about.  */
	  if (   r_type != R_ARM_PC24
	      && r_type != R_ARM_THM_PC22)
	    continue;

	  /* Get the section contents if we haven't done so already.  */
	  if (contents == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (elf_section_data (sec)->this_hdr.contents != NULL)
		contents = elf_section_data (sec)->this_hdr.contents;
	      else
		{
		  /* Go get them off disk.  */
		  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
		  if (contents == NULL)
		    goto error_return;

		  if (!bfd_get_section_contents (abfd, sec, contents,
						 (file_ptr) 0, sec->_raw_size))
		    goto error_return;
		}
	    }

	  /* If the relocation is not against a symbol it cannot concern us.  */
	  h = NULL;

	  /* We don't care about local symbols.  */
	  if (r_index < symtab_hdr->sh_info)
	    continue;

	  /* This is an external symbol.  */
	  r_index -= symtab_hdr->sh_info;
	  h = (struct elf_link_hash_entry *)
	    elf_sym_hashes (abfd)[r_index];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  switch (r_type)
	    {
	    case R_ARM_PC24:
	      /* This one is a call from arm code.  We need to look up
	         the target of the call.  If it is a thumb target, we
	         insert glue.  */
	      if (ELF_ST_TYPE(h->type) == STT_ARM_TFUNC)
		record_arm_to_thumb_glue (link_info, h);
	      break;

	    case R_ARM_THM_PC22:
	      /* This one is a call from thumb code.  We look
	         up the target of the call.  If it is not a thumb
                 target, we insert glue.  */
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC)
		record_thumb_to_arm_glue (link_info, h);
	      break;

	    default:
	      break;
	    }
	}

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;

      if (internal_relocs != NULL
	  && elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      internal_relocs = NULL;
    }

  return TRUE;

error_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}
#endif

/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an
   offset, insert the offset into the thumb branch and return finished
   instruction.

   It takes two thumb instructions to encode the target address. Each has
   11 bits to invest. The upper 11 bits are stored in one (identified by
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).

   Combine together and shifted left by 1 (it's a half word address) and
   there you have it.

   Op: 1111 = F,
   H-0, upper address-0 = 000
   Op: 1111 = F,
   H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com.  */

#define LOW_HI_ORDER      0xF800F000
#define HI_LOW_ORDER      0xF000F800

static insn32
insert_thumb_branch (br_insn, rel_off)
     insn32 br_insn;
     int rel_off;
{
  unsigned int low_bits;
  unsigned int high_bits;

  BFD_ASSERT ((rel_off & 1) != 1);

  rel_off >>= 1;				/* Half word aligned address.  */
  low_bits = rel_off & 0x000007FF;		/* The bottom 11 bits.  */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* The top 11 bits.  */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    /* FIXME: abort is probably not the right call. krk@@cygnus.com  */
    abort ();			/* error - not a valid branch instruction form.  */

  return br_insn;
}

/* Thumb code calling an ARM function.  */

static int
elf32_thumb_to_arm_stub (info, name, input_bfd, output_bfd, input_section,
			 hit_data, sym_sec, offset, addend, val)
     struct bfd_link_info * info;
     const char *           name;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             hit_data;
     asection *             sym_sec;
     bfd_vma                offset;
     bfd_signed_vma         addend;
     bfd_vma                val;
{
  asection * s = 0;
  bfd_vma my_offset;
  unsigned long int tmp;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_thumb_glue (info, name, input_bfd);
  if (myh == NULL)
    return FALSE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;

  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): warning: interworking not enabled."),
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
	    (_("  first occurrence: %s: thumb call to arm"),
	     bfd_archive_filename (input_bfd));

	  return FALSE;
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
		  s->contents + my_offset);

      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
		  s->contents + my_offset + 2);

      ret_offset =
	/* Address of destination of the stub.  */
	((bfd_signed_vma) val)
	- ((bfd_signed_vma)
	   /* Offset from the start of the current section to the start of the stubs.  */
	   (s->output_offset
	    /* Offset of the start of this stub from the start of the stubs.  */
	    + my_offset
	    /* Address of the start of the current section.  */
	    + s->output_section->vma)
	   /* The branch instruction is 4 bytes into the stub.  */
	   + 4
	   /* ARM branches work from the pc of the instruction + 8.  */
	   + 8);

      bfd_put_32 (output_bfd,
		  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
		  s->contents + my_offset + 4);
    }

  BFD_ASSERT (my_offset <= globals->thumb_glue_size);

  /* Now go back and fix up the original BL insn to point to here.  */
  ret_offset =
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
    - 8;

  tmp = bfd_get_32 (input_bfd, hit_data
		    - input_section->vma);

  bfd_put_32 (output_bfd,
	      (bfd_vma) insert_thumb_branch (tmp, ret_offset),
	      hit_data - input_section->vma);

  return TRUE;
}

/* Arm code calling a Thumb function.  */

static int
elf32_arm_to_thumb_stub (info, name, input_bfd, output_bfd, input_section,
			 hit_data, sym_sec, offset, addend, val)
     struct bfd_link_info * info;
     const char *           name;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             hit_data;
     asection *             sym_sec;
     bfd_vma                offset;
     bfd_signed_vma         addend;
     bfd_vma                val;
{
  unsigned long int tmp;
  bfd_vma my_offset;
  asection * s;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_arm_glue (info, name, input_bfd);
  if (myh == NULL)
    return FALSE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): warning: interworking not enabled."),
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
	    (_("  first occurrence: %s: arm call to thumb"),
	     bfd_archive_filename (input_bfd));
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
		  s->contents + my_offset);

      bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
		  s->contents + my_offset + 4);

      /* It's a thumb address.  Add the low order bit.  */
      bfd_put_32 (output_bfd, val | a2t3_func_addr_insn,
		  s->contents + my_offset + 8);
    }

  BFD_ASSERT (my_offset <= globals->arm_glue_size);

  tmp = bfd_get_32 (input_bfd, hit_data);
  tmp = tmp & 0xFF000000;

  /* Somehow these are both 4 too far, so subtract 8.  */
  ret_offset = (s->output_offset
		+ my_offset
		+ s->output_section->vma
		- (input_section->output_offset
		   + input_section->output_section->vma
		   + offset + addend)
		- 8);

  tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);

  bfd_put_32 (output_bfd, (bfd_vma) tmp, hit_data - input_section->vma);

  return TRUE;
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
			       input_section, contents, rel, value,
			       info, sym_sec, sym_name, sym_flags, h)
     reloc_howto_type *     howto;
     bfd *                  input_bfd;
     bfd *                  output_bfd;
     asection *             input_section;
     bfd_byte *             contents;
     Elf_Internal_Rela *    rel;
     bfd_vma                value;
     struct bfd_link_info * info;
     asection *             sym_sec;
     const char *           sym_name;
     int		    sym_flags;
     struct elf_link_hash_entry * h;
{
  unsigned long                 r_type = howto->type;
  unsigned long                 r_symndx;
  bfd_byte *                    hit_data = contents + rel->r_offset;
  bfd *                         dynobj = NULL;
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  bfd_vma *                     local_got_offsets;
  asection *                    sgot = NULL;
  asection *                    splt = NULL;
  asection *                    sreloc = NULL;
  bfd_vma                       addend;
  bfd_signed_vma                signed_addend;
  struct elf32_arm_link_hash_table * globals;

  /* If the start address has been set, then set the EF_ARM_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.

     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.

     Note - if the user deliberately sets a start address of 0, the
     flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_ARM_HASENTRY;

  globals = elf32_arm_hash_table (info);

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      splt = bfd_get_section_by_name (dynobj, ".plt");
    }
  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);
  r_symndx = ELF32_R_SYM (rel->r_info);

#if USE_REL
  addend = bfd_get_32 (input_bfd, hit_data) & howto->src_mask;

  if (addend & ((howto->src_mask + 1) >> 1))
    {
      signed_addend = -1;
      signed_addend &= ~ howto->src_mask;
      signed_addend |= addend;
    }
  else
    signed_addend = addend;
#else
  addend = signed_addend = rel->r_addend;
#endif

  switch (r_type)
    {
    case R_ARM_NONE:
      return bfd_reloc_ok;

    case R_ARM_PC24:
    case R_ARM_ABS32:
    case R_ARM_REL32:
#ifndef OLD_ARM_ABI
    case R_ARM_XPC25:
#endif
    case R_ARM_PLT32:
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	return bfd_reloc_ok;

      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
	  && h != NULL
	  && splt != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset);
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}

      /* When generating a shared object, these relocations are copied
	 into the output file to be resolved at run time.  */
      if (info->shared
	  && (input_section->flags & SEC_ALLOC)
	  && (r_type != R_ARM_REL32
	      || !SYMBOL_CALLS_LOCAL (info, h))
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
	  && r_type != R_ARM_PLT32)
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;
	  bfd_boolean skip, relocate;

	  if (sreloc == NULL)
	    {
	      const char * name;

	      name = (bfd_elf_string_from_elf_section
		      (input_bfd,
		       elf_elfheader (input_bfd)->e_shstrndx,
		       elf_section_data (input_section)->rel_hdr.sh_name));
	      if (name == NULL)
		return bfd_reloc_notsupported;

	      BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			  && strcmp (bfd_get_section_name (input_bfd,
							   input_section),
				     name + 4) == 0);

	      sreloc = bfd_get_section_by_name (dynobj, name);
	      BFD_ASSERT (sreloc != NULL);
	    }

	  skip = FALSE;
	  relocate = FALSE;

	  outrel.r_offset =
	    _bfd_elf_section_offset (output_bfd, info, input_section,
				     rel->r_offset);
	  if (outrel.r_offset == (bfd_vma) -1)
	    skip = TRUE;
	  else if (outrel.r_offset == (bfd_vma) -2)
	    skip = TRUE, relocate = TRUE;
	  outrel.r_offset += (input_section->output_section->vma
			      + input_section->output_offset);

	  if (skip)
	    memset (&outrel, 0, sizeof outrel);
	  else if (h != NULL
		   && h->dynindx != -1
		   && (!info->shared
		       || !info->symbolic
		       || (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
	  else
	    {
	      /* This symbol is local, or marked to become local.  */
	      relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	    }

	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);

	  /* If this reloc is against an external symbol, we do not want to
	     fiddle with the addend.  Otherwise, we need to include the symbol
	     value so that it becomes an addend for the dynamic reloc.  */
	  if (! relocate)
	    return bfd_reloc_ok;

	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}
      else switch (r_type)
	{
#ifndef OLD_ARM_ABI
	case R_ARM_XPC25:	  /* Arm BLX instruction.  */
#endif
	case R_ARM_PC24:	  /* Arm B/BL instruction */
	case R_ARM_PLT32:
#ifndef OLD_ARM_ABI
	  if (r_type == R_ARM_XPC25)
	    {
	      /* Check for Arm calling Arm function.  */
	      /* FIXME: Should we translate the instruction into a BL
		 instruction instead ?  */
	      if (sym_flags != STT_ARM_TFUNC)
		(*_bfd_error_handler) (_("\
%s: Warning: Arm BLX instruction targets Arm function '%s'."),
				       bfd_archive_filename (input_bfd),
				       h ? h->root.root.string : "(local)");
	    }
	  else
#endif
	    {
	      /* Check for Arm calling Thumb function.  */
	      if (sym_flags == STT_ARM_TFUNC)
		{
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd, output_bfd,
					   input_section, hit_data, sym_sec, rel->r_offset,
					   signed_addend, value);
		  return bfd_reloc_ok;
		}
	    }

	  if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
	      || strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0)
	    {
	      /* The old way of doing things.  Trearing the addend as a
		 byte sized field and adding in the pipeline offset.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += addend;

	      if (! globals->no_pipeline_knowledge)
		value -= 8;
	    }
	  else
	    {
	      /* The ARM ELF ABI says that this reloc is computed as: S - P + A
		 where:
		  S is the address of the symbol in the relocation.
		  P is address of the instruction being relocated.
		  A is the addend (extracted from the instruction) in bytes.

		 S is held in 'value'.
		 P is the base address of the section containing the instruction
		   plus the offset of the reloc into that section, ie:
		     (input_section->output_section->vma +
		      input_section->output_offset +
		      rel->r_offset).
		 A is the addend, converted into bytes, ie:
		     (signed_addend * 4)

		 Note: None of these operations have knowledge of the pipeline
		 size of the processor, thus it is up to the assembler to encode
		 this information into the addend.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += (signed_addend << howto->size);

	      /* Previous versions of this code also used to add in the pipeline
		 offset here.  This is wrong because the linker is not supposed
		 to know about such things, and one day it might change.  In order
		 to support old binaries that need the old behaviour however, so
		 we attempt to detect which ABI was used to create the reloc.  */
	      if (! globals->no_pipeline_knowledge)
		{
		  Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form */

		  i_ehdrp = elf_elfheader (input_bfd);

		  if (i_ehdrp->e_ident[EI_OSABI] == 0)
		    value -= 8;
		}
	    }

	  signed_addend = value;
	  signed_addend >>= howto->rightshift;

	  /* It is not an error for an undefined weak reference to be
	     out of range.  Any program that branches to such a symbol
	     is going to crash anyway, so there is no point worrying
	     about getting the destination exactly right.  */
	  if (! h || h->root.type != bfd_link_hash_undefweak)
	    {
	      /* Perform a signed range check.  */
	      if (   signed_addend >   ((bfd_signed_vma)  (howto->dst_mask >> 1))
		  || signed_addend < - ((bfd_signed_vma) ((howto->dst_mask + 1) >> 1)))
		return bfd_reloc_overflow;
	    }

#ifndef OLD_ARM_ABI
	  /* If necessary set the H bit in the BLX instruction.  */
	  if (r_type == R_ARM_XPC25 && ((value & 2) == 2))
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask))
	      | (1 << 24);
	  else
#endif
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
	  break;

	case R_ARM_ABS32:
	  value += addend;
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
	  break;

	case R_ARM_REL32:
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  value += addend;
	  break;
	}

      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS8:
      value += addend;
      if ((long) value > 0x7f || (long) value < -0x80)
	return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS16:
      value += addend;

      if ((long) value > 0x7fff || (long) value < -0x8000)
	return bfd_reloc_overflow;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS12:
      /* Support ldr and str instruction for the arm */
      /* Also thumb b (unconditional branch).  ??? Really?  */
      value += addend;

      if ((long) value > 0x7ff || (long) value < -0x800)
	return bfd_reloc_overflow;

      value |= (bfd_get_32 (input_bfd, hit_data) & 0xfffff000);
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_THM_ABS5:
      /* Support ldr and str instructions for the thumb.  */
#if USE_REL
      /* Need to refetch addend.  */
      addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
      /* ??? Need to determine shift amount from operand size.  */
      addend >>= howto->rightshift;
#endif
      value += addend;

      /* ??? Isn't value unsigned?  */
      if ((long) value > 0x1f || (long) value < -0x10)
	return bfd_reloc_overflow;

      /* ??? Value needs to be properly shifted into place first.  */
      value |= bfd_get_16 (input_bfd, hit_data) & 0xf83f;
      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

#ifndef OLD_ARM_ABI
    case R_ARM_THM_XPC22:
#endif
    case R_ARM_THM_PC22:
      /* Thumb BL (branch long instruction).  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
	bfd_signed_vma signed_check;

#if USE_REL
	/* Need to refetch the addend and squish the two 11 bit pieces
	   together.  */
	{
	  bfd_vma upper = upper_insn & 0x7ff;
	  bfd_vma lower = lower_insn & 0x7ff;
	  upper = (upper ^ 0x400) - 0x400; /* Sign extend.  */
	  addend = (upper << 12) | (lower << 1);
	  signed_addend = addend;
	}
#endif
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22)
	  {
	    /* Check for Thumb to Thumb call.  */
	    /* FIXME: Should we translate the instruction into a BL
	       instruction instead ?  */
	    if (sym_flags == STT_ARM_TFUNC)
	      (*_bfd_error_handler) (_("\
%s: Warning: Thumb BLX instruction targets thumb function '%s'."),
				     bfd_archive_filename (input_bfd),
				     h ? h->root.root.string : "(local)");
	  }
	else
#endif
	  {
	    /* If it is not a call to Thumb, assume call to Arm.
	       If it is a call relative to a section name, then it is not a
	       function call at all, but rather a long jump.  */
	    if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
	      {
		if (elf32_thumb_to_arm_stub
		    (info, sym_name, input_bfd, output_bfd, input_section,
		     hit_data, sym_sec, rel->r_offset, signed_addend, value))
		  return bfd_reloc_ok;
		else
		  return bfd_reloc_dangerous;
	      }
	  }

	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	if (! globals->no_pipeline_knowledge)
	  {
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form.  */

	    i_ehdrp = elf_elfheader (input_bfd);

	    /* Previous versions of this code also used to add in the pipline
	       offset here.  This is wrong because the linker is not supposed
	       to know about such things, and one day it might change.  In order
	       to support old binaries that need the old behaviour however, so
	       we attempt to detect which ABI was used to create the reloc.  */
	    if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
		|| strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0
		|| i_ehdrp->e_ident[EI_OSABI] == 0)
	      relocation += 4;
	  }

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  relocation = (relocation + 2) & ~ 3;
#endif
	/* Put RELOCATION back into the insn.  */
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 12) & 0x7ff);
	lower_insn = (lower_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 1) & 0x7ff);

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }
      break;

    case R_ARM_THM_PC11:
      /* Thumb B (branch) instruction).  */
      {
	bfd_signed_vma relocation;
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_signed_vma signed_check;

#if USE_REL
	/* Need to refetch addend.  */
	addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	if (addend & ((howto->src_mask + 1) >> 1))
	  {
	    signed_addend = -1;
	    signed_addend &= ~ howto->src_mask;
	    signed_addend |= addend;
	  }
	else
	  signed_addend = addend;
	/* The value in the insn has been right shifted.  We need to
	   undo this, so that we can perform the address calculation
	   in terms of bytes.  */
	signed_addend <<= howto->rightshift;
#endif
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	relocation >>= howto->rightshift;
	signed_check = relocation;
	relocation &= howto->dst_mask;
	relocation |= (bfd_get_16 (input_bfd, hit_data) & (~ howto->dst_mask));

	bfd_put_16 (input_bfd, relocation, hit_data);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  return bfd_reloc_overflow;

	return bfd_reloc_ok;
      }

    case R_ARM_GNU_VTINHERIT:
    case R_ARM_GNU_VTENTRY:
      return bfd_reloc_ok;

    case R_ARM_COPY:
      return bfd_reloc_notsupported;

    case R_ARM_GLOB_DAT:
      return bfd_reloc_notsupported;

    case R_ARM_JUMP_SLOT:
      return bfd_reloc_notsupported;

    case R_ARM_RELATIVE:
      return bfd_reloc_notsupported;

    case R_ARM_GOTOFF:
      /* Relocation is relative to the start of the
         global offset table.  */

      BFD_ASSERT (sgot != NULL);
      if (sgot == NULL)
        return bfd_reloc_notsupported;

      /* If we are addressing a Thumb function, we need to adjust the
	 address by one, so that attempts to call the function pointer will
	 correctly interpret it as Thumb code.  */
      if (sym_flags == STT_ARM_TFUNC)
	value += 1;

      /* Note that sgot->output_offset is not involved in this
         calculation.  We always want the start of .got.  If we
         define _GLOBAL_OFFSET_TABLE in a different way, as is
         permitted by the ABI, we might have to change this
         calculation.  */
      value -= sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_GOTPC:
      /* Use global offset table as symbol value.  */
      BFD_ASSERT (sgot != NULL);

      if (sgot == NULL)
        return bfd_reloc_notsupported;

      value = sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_GOT32:
      /* Relocation is to the entry for this symbol in the
         global offset table.  */
      if (sgot == NULL)
	return bfd_reloc_notsupported;

      if (h != NULL)
	{
	  bfd_vma off;
	  bfd_boolean dyn;

	  off = h->got.offset;
	  BFD_ASSERT (off != (bfd_vma) -1);
	  dyn = globals->root.dynamic_sections_created;

	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
	    {
	      /* This is actually a static link, or it is a -Bsymbolic link
		 and the symbol is defined locally.  We must initialize this
		 entry in the global offset table.  Since the offset must
		 always be a multiple of 4, we use the least significant bit
		 to record whether we have initialized it already.

		 When doing a dynamic link, we create a .rel.got relocation
		 entry to initialize the value.  This is done in the
		 finish_dynamic_symbol routine.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  /* If we are addressing a Thumb function, we need to
		     adjust the address by one, so that attempts to
		     call the function pointer will correctly
		     interpret it as Thumb code.  */
		  if (sym_flags == STT_ARM_TFUNC)
		    value |= 1;

		  bfd_put_32 (output_bfd, value, sgot->contents + off);
		  h->got.offset |= 1;
		}
	    }

	  value = sgot->output_offset + off;
	}
      else
	{
	  bfd_vma off;

	  BFD_ASSERT (local_got_offsets != NULL &&
		      local_got_offsets[r_symndx] != (bfd_vma) -1);

	  off = local_got_offsets[r_symndx];

	  /* The offset must always be a multiple of 4.  We use the
	     least significant bit to record whether we have already
	     generated the necessary reloc.  */
	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      bfd_put_32 (output_bfd, value, sgot->contents + off);

	      if (info->shared)
		{
		  asection * srelgot;
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;

		  srelgot = bfd_get_section_by_name (dynobj, ".rel.got");
		  BFD_ASSERT (srelgot != NULL);

		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + off);
		  outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
		}

	      local_got_offsets[r_symndx] |= 1;
	    }

	  value = sgot->output_offset + off;
	}

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);

    case R_ARM_SBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_AMP_VCALL9:
      return bfd_reloc_notsupported;

    case R_ARM_RSBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_THM_RPC22:
      return bfd_reloc_notsupported;

    case R_ARM_RREL32:
      return bfd_reloc_notsupported;

    case R_ARM_RABS32:
      return bfd_reloc_notsupported;

    case R_ARM_RPC24:
      return bfd_reloc_notsupported;

    case R_ARM_RBASE:
      return bfd_reloc_notsupported;

    default:
      return bfd_reloc_notsupported;
    }
}

#if USE_REL
/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS.  */
static void
arm_add_to_rel (abfd, address, howto, increment)
     bfd *              abfd;
     bfd_byte *         address;
     reloc_howto_type * howto;
     bfd_signed_vma     increment;
{
  bfd_signed_vma addend;

  if (howto->type == R_ARM_THM_PC22)
    {
      int upper_insn, lower_insn;
      int upper, lower;

      upper_insn = bfd_get_16 (abfd, address);
      lower_insn = bfd_get_16 (abfd, address + 2);
      upper = upper_insn & 0x7ff;
      lower = lower_insn & 0x7ff;

      addend = (upper << 12) | (lower << 1);
      addend += increment;
      addend >>= 1;

      upper_insn = (upper_insn & 0xf800) | ((addend >> 11) & 0x7ff);
      lower_insn = (lower_insn & 0xf800) | (addend & 0x7ff);

      bfd_put_16 (abfd, (bfd_vma) upper_insn, address);
      bfd_put_16 (abfd, (bfd_vma) lower_insn, address + 2);
    }
  else
    {
      bfd_vma        contents;

      contents = bfd_get_32 (abfd, address);

      /* Get the (signed) value from the instruction.  */
      addend = contents & howto->src_mask;
      if (addend & ((howto->src_mask + 1) >> 1))
	{
	  bfd_signed_vma mask;

	  mask = -1;
	  mask &= ~ howto->src_mask;
	  addend |= mask;
	}

      /* Add in the increment, (which is a byte value).  */
      switch (howto->type)
	{
	default:
	  addend += increment;
	  break;

	case R_ARM_PC24:
	  addend <<= howto->size;
	  addend += increment;

	  /* Should we check for overflow here ?  */

	  /* Drop any undesired bits.  */
	  addend >>= howto->rightshift;
	  break;
	}

      contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);

      bfd_put_32 (abfd, contents, address);
    }
}
#endif /* USE_REL */

/* Relocate an ARM ELF section.  */
static bfd_boolean
elf32_arm_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;

#if !USE_REL
  if (info->relocatable)
    return TRUE;
#endif

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int                          r_type;
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      arelent                      bfd_reloc;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type   = ELF32_R_TYPE (rel->r_info);

      if (   r_type == R_ARM_GNU_VTENTRY
          || r_type == R_ARM_GNU_VTINHERIT)
        continue;

      elf32_arm_info_to_howto (input_bfd, & bfd_reloc, rel);
      howto = bfd_reloc.howto;

#if USE_REL
      if (info->relocatable)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  arm_add_to_rel (input_bfd, contents + rel->r_offset,
				  howto,
				  (bfd_signed_vma) (sec->output_offset
						    + sym->st_value));
		}
	    }

	  continue;
	}
#endif

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
#if USE_REL
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	  if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;
	      bfd_vma addend, value;

	      if (howto->rightshift)
		{
		  (*_bfd_error_handler)
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

	      value = bfd_get_32 (input_bfd, contents + rel->r_offset);

	      /* Get the (signed) value from the instruction.  */
	      addend = value & howto->src_mask;
	      if (addend & ((howto->src_mask + 1) >> 1))
		{
		  bfd_signed_vma mask;

		  mask = -1;
		  mask &= ~ howto->src_mask;
		  addend |= mask;
		}
	      msec = sec;
	      addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      value = (value & ~ howto->dst_mask) | (addend & howto->dst_mask);
	      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
	    }
#else
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
#endif
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  
	  if (unresolved_reloc || relocation != 0)
	    {
	      /* In these cases, we don't need the relocation value.
	         We check specially because in some obscure cases
	         sec->output_section will be NULL.  */
	      switch (r_type)
		{
	        case R_ARM_PC24:
	        case R_ARM_ABS32:
		case R_ARM_THM_PC22:
	        case R_ARM_PLT32:

	          if (info->shared
	              && (
			  (!info->symbolic && h->dynindx != -1)
	                  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
			  )
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	              && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_ARM_ABS32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
		      )
	            relocation = 0;
		  break;

	        case R_ARM_GOTPC:
	          relocation = 0;
		  break;

	        case R_ARM_GOT32:
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
	                  || (!info->symbolic && h->dynindx != -1)
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
	            relocation = 0;
		  break;

	        default:
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
		       bfd_archive_filename (input_bfd),
		       r_type,
		       h->root.root.string,
		       bfd_get_section_name (input_bfd, input_section));
		  break;
		}
	    }
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      r = elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
					 input_section, contents, rel,
					 relocation, info, sec, name,
					 (h ? ELF_ST_TYPE (h->type) :
					  ELF_ST_TYPE (sym->st_info)), h);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) 0;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      /* If the overflowing reloc was to an undefined symbol,
		 we have already printed one error message and there
		 is no point complaining again.  */
	      if ((! h ||
		   h->root.type != bfd_link_hash_undefined)
		  && (!((*info->callbacks->reloc_overflow)
			(info, name, howto->name, (bfd_vma) 0,
			 input_bfd, input_section, rel->r_offset))))
		  return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, name, input_bfd, input_section,
		     rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous error");
	      goto common_error;

	    default:
	      msg = _("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (abfd)
     bfd *abfd;
{
  unsigned int mach;
  
  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);

  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  return TRUE;
}

/* Function to keep ARM specific flags in the ELF header.  */
static bfd_boolean
elf32_arm_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  if (elf_flags_init (abfd)
      && elf_elfheader (abfd)->e_flags != flags)
    {
      if (EF_ARM_EABI_VERSION (flags) == EF_ARM_EABI_UNKNOWN)
	{
	  if (flags & EF_ARM_INTERWORK)
	    (*_bfd_error_handler) (_("\
Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
				   bfd_archive_filename (abfd));
	  else
	    _bfd_error_handler (_("\
Warning: Clearing the interworking flag of %s due to outside request"),
				bfd_archive_filename (abfd));
	}
    }
  else
    {
      elf_elfheader (abfd)->e_flags = flags;
      elf_flags_init (abfd) = TRUE;
    }

  return TRUE;
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
elf32_arm_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword in_flags;
  flagword out_flags;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (elf_flags_init (obfd)
      && EF_ARM_EABI_VERSION (out_flags) == EF_ARM_EABI_UNKNOWN
      && in_flags != out_flags)
    {
      /* Cannot mix APCS26 and APCS32 code.  */
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	return FALSE;

      /* Cannot mix float APCS and non-float APCS code.  */
      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	return FALSE;

      /* If the src and dest have different interworking flags
         then turn off the interworking bit.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (out_flags & EF_ARM_INTERWORK)
	    _bfd_error_handler (_("\
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
				bfd_get_filename (obfd),
				bfd_archive_filename (ibfd));

	  in_flags &= ~EF_ARM_INTERWORK;
	}

      /* Likewise for PIC, though don't warn for this case.  */
      if ((in_flags & EF_ARM_PIC) != (out_flags & EF_ARM_PIC))
	in_flags &= ~EF_ARM_PIC;
    }

  elf_elfheader (obfd)->e_flags = in_flags;
  elf_flags_init (obfd) = TRUE;

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_arm_merge_private_bfd_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
{
  flagword out_flags;
  flagword in_flags;
  bfd_boolean flags_compatible = TRUE;
  asection *sec;

  /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  /* The input BFD must have had its flags initialised.  */
  /* The following seems bogus to me -- The flags are initialized in
     the assembler but I don't think an elf_flags_init field is
     written into the object.  */
  /* BFD_ASSERT (elf_flags_init (ibfd)); */

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))
    {
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
         uninitialised values, which surprise surprise, correspond
         to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Identical flags must be compatible.  */
  if (in_flags == out_flags)
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatibility.  Do not short-circuit
     dynamic objects; their section list may be emptied by
    elf_link_add_object_symbols.

    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;
      bfd_boolean only_data_sections = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

	      null_input_bfd = FALSE;
	      break;
	    }
	}

      if (null_input_bfd || only_data_sections)
	return TRUE;
    }

  /* Complain about various flag mismatches.  */
  if (EF_ARM_EABI_VERSION (in_flags) != EF_ARM_EABI_VERSION (out_flags))
    {
      _bfd_error_handler (_("\
ERROR: %s is compiled for EABI version %d, whereas %s is compiled for version %d"),
			  bfd_archive_filename (ibfd),
			  (in_flags & EF_ARM_EABIMASK) >> 24,
			  bfd_get_filename (obfd),
			  (out_flags & EF_ARM_EABIMASK) >> 24);
      return FALSE;
    }

  /* Not sure what needs to be checked for EABI versions >= 1.  */
  if (EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
    {
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	{
	  _bfd_error_handler (_("\
ERROR: %s is compiled for APCS-%d, whereas target %s uses APCS-%d"),
			      bfd_archive_filename (ibfd),
			      in_flags & EF_ARM_APCS_26 ? 26 : 32,
			      bfd_get_filename (obfd),
			      out_flags & EF_ARM_APCS_26 ? 26 : 32);
	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	{
	  if (in_flags & EF_ARM_APCS_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s passes floats in float registers, whereas %s passes them in integer registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s passes floats in integer registers, whereas %s passes them in float registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_VFP_FLOAT) != (out_flags & EF_ARM_VFP_FLOAT))
	{
	  if (in_flags & EF_ARM_VFP_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses VFP instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s uses FPA instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s does not use Maverick instructions, whereas %s does"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
	{
	  /* We can allow interworking between code that is VFP format
	     layout, and uses either soft float or integer regs for
	     passing floating point arguments and results.  We already
	     know that the APCS_FLOAT flags match; similarly for VFP
	     flags.  */
	  if ((in_flags & EF_ARM_APCS_FLOAT) != 0
	      || (in_flags & EF_ARM_VFP_FLOAT) == 0)
	    {
	      if (in_flags & EF_ARM_SOFT_FLOAT)
		_bfd_error_handler (_("\
ERROR: %s uses software FP, whereas %s uses hardware FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));
	      else
		_bfd_error_handler (_("\
ERROR: %s uses hardware FP, whereas %s uses software FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));

	      flags_compatible = FALSE;
	    }
	}
#endif

      /* Interworking mismatch is only a warning.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (in_flags & EF_ARM_INTERWORK)
	    {
	      _bfd_error_handler (_("\
Warning: %s supports interworking, whereas %s does not"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	  else
	    {
	      _bfd_error_handler (_("\
Warning: %s does not support interworking, whereas %s does"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	}
    }

  return flags_compatible;
}

/* Display the flags field.  */

static bfd_boolean
elf32_arm_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE * file = (FILE *) ptr;
  unsigned long flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;
  /* Ignore init flag - it may not be set, despite the flags field
     containing valid data.  */

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  switch (EF_ARM_EABI_VERSION (flags))
    {
    case EF_ARM_EABI_UNKNOWN:
      /* The following flag bits are GNU extensions and not part of the
	 official ARM ELF extended ABI.  Hence they are only decoded if
	 the EABI version is not set.  */
      if (flags & EF_ARM_INTERWORK)
	fprintf (file, _(" [interworking enabled]"));

      if (flags & EF_ARM_APCS_26)
	fprintf (file, " [APCS-26]");
      else
	fprintf (file, " [APCS-32]");

      if (flags & EF_ARM_VFP_FLOAT)
	fprintf (file, _(" [VFP float format]"));
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
      else
	fprintf (file, _(" [FPA float format]"));

      if (flags & EF_ARM_APCS_FLOAT)
	fprintf (file, _(" [floats passed in float registers]"));

      if (flags & EF_ARM_PIC)
	fprintf (file, _(" [position independent]"));

      if (flags & EF_ARM_NEW_ABI)
	fprintf (file, _(" [new ABI]"));

      if (flags & EF_ARM_OLD_ABI)
	fprintf (file, _(" [old ABI]"));

      if (flags & EF_ARM_SOFT_FLOAT)
	fprintf (file, _(" [software FP]"));

      flags &= ~(EF_ARM_INTERWORK | EF_ARM_APCS_26 | EF_ARM_APCS_FLOAT
		 | EF_ARM_PIC | EF_ARM_NEW_ABI | EF_ARM_OLD_ABI
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
      break;

    case EF_ARM_EABI_VER1:
      fprintf (file, _(" [Version1 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      flags &= ~ EF_ARM_SYMSARESORTED;
      break;

    case EF_ARM_EABI_VER2:
      fprintf (file, _(" [Version2 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      if (flags & EF_ARM_DYNSYMSUSESEGIDX)
	fprintf (file, _(" [dynamic symbols use segment index]"));

      if (flags & EF_ARM_MAPSYMSFIRST)
	fprintf (file, _(" [mapping symbols precede others]"));

      flags &= ~(EF_ARM_SYMSARESORTED | EF_ARM_DYNSYMSUSESEGIDX
		 | EF_ARM_MAPSYMSFIRST);
      break;

    default:
      fprintf (file, _(" <EABI version unrecognised>"));
      break;
    }

  flags &= ~ EF_ARM_EABIMASK;

  if (flags & EF_ARM_RELEXEC)
    fprintf (file, _(" [relocatable executable]"));

  if (flags & EF_ARM_HASENTRY)
    fprintf (file, _(" [has entry point]"));

  flags &= ~ (EF_ARM_RELEXEC | EF_ARM_HASENTRY);

  if (flags)
    fprintf (file, _("<Unrecognised flag bits set>"));

  fputc ('\n', file);

  return TRUE;
}

static int
elf32_arm_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym * elf_sym;
     int type;
{
  switch (ELF_ST_TYPE (elf_sym->st_info))
    {
    case STT_ARM_TFUNC:
      return ELF_ST_TYPE (elf_sym->st_info);

    case STT_ARM_16BIT:
      /* If the symbol is not an object, return the STT_ARM_16BIT flag.
	 This allows us to distinguish between data used by Thumb instructions
	 and non-data (which is probably code) inside Thumb regions of an
	 executable.  */
      if (type != STT_OBJECT)
	return ELF_ST_TYPE (elf_sym->st_info);
      break;

    default:
      break;
    }

  return type;
}

static asection *
elf32_arm_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GNU_VTINHERIT:
      case R_ARM_GNU_VTENTRY:
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

	  default:
	    break;
          }
       }
     }
   else
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_arm_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GOT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_ARM_ABS32:
      case R_ARM_REL32:
      case R_ARM_PC24:
      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_arm_link_hash_entry *eh;
	    struct elf32_arm_relocs_copied **pp;
	    struct elf32_arm_relocs_copied *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
	      {
		eh = (struct elf32_arm_link_hash_entry *) h;

		for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		     pp = &p->next)
		if (p->section == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	      }
	  }
	break;

      default:
	break;
      }

  return TRUE;
}

/* Look through the relocs for a section during the first phase.  */

static bfd_boolean
elf32_arm_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sreloc;
  bfd_vma *local_got_offsets;
  struct elf32_arm_link_hash_table *htab;

  if (info->relocatable)
    return TRUE;

  htab = elf32_arm_hash_table (info);
  sreloc = NULL;

  dynobj = elf_hash_table (info)->dynobj;
  local_got_offsets = elf_local_got_offsets (abfd);

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes
    + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);

  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
        {
	  case R_ARM_GOT32:
	    /* This symbol requires a global offset table entry.  */
	    if (h != NULL)
	      {
		h->got.refcount++;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;

		    size = symtab_hdr->sh_info;
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		  }
		local_got_refcounts[r_symndx] += 1;
	      }
	    break;

	  case R_ARM_GOTOFF:
	  case R_ARM_GOTPC:
	    if (htab->sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
	    break;

	  case R_ARM_ABS32:
	  case R_ARM_REL32:
	  case R_ARM_PC24:
	  case R_ARM_PLT32:
	    if (h != NULL)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		if (!info->shared)
		  h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

		/* We may need a .plt entry if the function this reloc
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_PLT32)
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
		h->plt.refcount += 1;
	      }

	    /* If we are creating a shared library, and this is a reloc
               against a global symbol, or a non PC relative reloc
               against a local symbol, then we need to copy the reloc
               into the shared library.  However, if we are linking with
               -Bsymbolic, we do not need to copy a reloc against a
               global symbol which is defined in an object we are
               including in the link (i.e., DEF_REGULAR is set).  At
               this point we have not seen all the input files, so it is
               possible that DEF_REGULAR is not set now but will be set
               later (it is never cleared).  We account for that
               possibility below by storing information in the
               relocs_copied field of the hash table entry.  */
	    if (info->shared
		&& (sec->flags & SEC_ALLOC) != 0
		&& ((ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32)
		    || (h != NULL
			&& (! info->symbolic
			    || (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      {
		struct elf32_arm_relocs_copied *p, **head;

	        /* When creating a shared object, we must copy these
                   reloc types into the output file.  We create a reloc
                   section in dynobj and make room for this reloc.  */
	        if (sreloc == NULL)
		  {
		    const char * name;

		    name = (bfd_elf_string_from_elf_section
			    (abfd,
			     elf_elfheader (abfd)->e_shstrndx,
			     elf_section_data (sec)->rel_hdr.sh_name));
		    if (name == NULL)
		      return FALSE;

		    BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			        && strcmp (bfd_get_section_name (abfd, sec),
					   name + 4) == 0);

		    sreloc = bfd_get_section_by_name (dynobj, name);
		    if (sreloc == NULL)
		      {
		        flagword flags;

		        sreloc = bfd_make_section (dynobj, name);
		        flags = (SEC_HAS_CONTENTS | SEC_READONLY
			         | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		        if ((sec->flags & SEC_ALLOC) != 0)
			  flags |= SEC_ALLOC | SEC_LOAD;
		        if (sreloc == NULL
			    || ! bfd_set_section_flags (dynobj, sreloc, flags)
			    || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			  return FALSE;
		      }

		    elf_section_data (sec)->sreloc = sreloc;
		  }

		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
		  {
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */
		    
		    asection *s;
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
		    if (s == NULL)
		      return FALSE;
		    
		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
		  }
		
		p = *head;
		if (p == NULL || p->section != sec)
		  {
		    bfd_size_type amt = sizeof *p;
		    p = bfd_alloc (htab->root.dynobj, amt);
		    if (p == NULL)
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->section = sec;
		    p->count = 0;
		  }
		
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
		  p->count += 1;
	      }
	    break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_ARM_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_ARM_GNU_VTENTRY:
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
        }
    }

  return TRUE;
}

/* Find the nearest line to a particular section and offset, for error
   reporting.   This code is a duplicate of the code in elf.c, except
   that it also accepts STT_ARM_TFUNC as a symbol that names a function.  */

static bfd_boolean
elf32_arm_find_nearest_line
  (abfd, section, symbols, offset, filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  bfd_boolean found;
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;
  int binding;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return TRUE;

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return FALSE;

  if (found)
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  filename = NULL;
  func = NULL;
  low_func = 0;
  binding = -1;

  for (p = symbols; *p != NULL; p++)
    {
      elf_symbol_type *q;

      q = (elf_symbol_type *) *p;

      if (bfd_get_section (&q->symbol) != section)
	continue;

      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))
	{
	default:
	  break;
	case STT_FILE:
	  filename = bfd_asymbol_name (&q->symbol);
	  break;
	case STT_NOTYPE:
	case STT_FUNC:
	case STT_ARM_TFUNC:
	  if (q->symbol.section == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
	    {
	      /* Prefer a global symbol rather than $a/$d/$t local symbols */
	      if (ELF_ST_BIND (q->internal_elf_sym.st_info) != STB_LOCAL
		  || binding == -1)
		{
		  func = (asymbol *) q;
		  low_func = q->symbol.value;
		  binding = ELF_ST_BIND (q->internal_elf_sym.st_info);
		}
	    }
	  break;
	}
    }

  if (func == NULL)
    return FALSE;

  *filename_ptr = filename;
  *functionname_ptr = bfd_asymbol_name (func);
  *line_ptr = 0;

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf32_arm_adjust_dynamic_symbol (info, h)
     struct bfd_link_info * info;
     struct elf_link_hash_entry * h;
{
  bfd * dynobj;
  asection * s;
  unsigned int power_of_two;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}

      return TRUE;
    }
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_ARM_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rel.bss");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf32_External_Rel);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->_raw_size;

  /* Increment the section size to make room for the symbol.  */
  s->_raw_size += h->size;

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_HEADER_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rel);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rel);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_arm_link_hash_entry *) h;
  if (eh->relocs_copied == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* Discard relocs on undefined weak syms with non-default
         visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->relocs_copied = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->relocs_copied = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->relocs_copied; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->section)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rel);
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_arm_size_dynamic_sections (output_bfd, info)
     bfd * output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info * info;
{
  bfd * dynobj;
  asection * s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_arm_relocs_copied *p;

	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->section)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rel);
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rel);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char * name;
      bfd_boolean strip;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

      if (strcmp (name, ".plt") == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
	}
      else if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rel.bss and
		 .rel.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there are any reloc sections other
                 than .rel.plt.  */
	      if (strcmp (name, ".rel.plt") != 0)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_arm_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!info->shared)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (   !add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (   !add_dynamic_entry (DT_REL, 0)
	      || !add_dynamic_entry (DT_RELSZ, 0)
	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
	    return FALSE;
	}

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	  info->flags |= DF_TEXTREL;
	}
    }
#undef add_synamic_entry

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf32_arm_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd * output_bfd;
     struct bfd_link_info * info;
     struct elf_link_hash_entry * h;
     Elf_Internal_Sym * sym;
{
  bfd * dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection * splt;
      asection * sgot;
      asection * srel;
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rel;
      bfd_byte *loc;
      bfd_vma got_displacement;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srel = bfd_get_section_by_name (dynobj, ".rel.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Calculate the displacement between the PLT slot and the
	 entry in the GOT.  */
      got_displacement = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset
			  - splt->output_section->vma
			  - splt->output_offset
			  - h->plt.offset
			  - 8);

      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

      /* Fill in the entry in the procedure linkage table.  */
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
		  splt->contents + h->plt.offset + 0);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
		  splt->contents + h->plt.offset + 8);
#ifdef FOUR_WORD_PLT
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		  splt->contents + h->plt.offset + 12);
#endif

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset),
		  sgot->contents + got_offset);
      
      /* Fill in the entry in the .rel.plt section.  */
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + got_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_JUMP_SLOT);
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection * sgot;
      asection * srel;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rel.got");
      BFD_ASSERT (sgot != NULL && srel != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
	}

      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
    }

  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
    {
      asection * s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rel.bss");
      BFD_ASSERT (s != NULL);

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_COPY);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf32_arm_finish_dynamic_sections (output_bfd, info)
     bfd * output_bfd;
     struct bfd_link_info * info;
{
  bfd * dynobj;
  asection * sgot;
  asection * sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char * name;
	  asection * s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rel.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rel.plt");
	      BFD_ASSERT (s != NULL);
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELSZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_REL).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELSZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rel.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_REL entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rel.plt");
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	      /* Set the bottom bit of DT_INIT/FINI if the
		 corresponding function is Thumb.  */
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      /* If it wasn't set by elf_bfd_final_link
		 then there is nothing to adjust.  */
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry * eh;

		  eh = elf_link_hash_lookup (elf_hash_table (info), name,
					     FALSE, FALSE, TRUE);
		  if (eh != (struct elf_link_hash_entry *) NULL
		      && ELF_ST_TYPE (eh->type) == STT_ARM_TFUNC)
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->_raw_size > 0)
	{
	  bfd_vma got_displacement;

	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[1], splt->contents +  4);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[2], splt->contents +  8);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[3], splt->contents + 12);
#ifdef FOUR_WORD_PLT
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
#else
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
#endif
	}

      /* UnixWare sets the entsize of .plt to 4, although that doesn't
	 really seem like the right value.  */
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot->_raw_size > 0)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

  return TRUE;
}

static void
elf32_arm_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI]      = ARM_ELF_OS_ABI_VERSION;
  i_ehdrp->e_ident[EI_ABIVERSION] = ARM_ELF_ABI_VERSION;
}

static enum elf_reloc_type_class
elf32_arm_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_ARM_RELATIVE:
      return reloc_class_relative;
    case R_ARM_JUMP_SLOT:
      return reloc_class_plt;
    case R_ARM_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, Elf_Internal_Shdr *));
static void        elf32_arm_final_write_processing  PARAMS ((bfd *, bfd_boolean));

/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

void
elf32_arm_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

#define ELF_ARCH			bfd_arch_arm
#define ELF_MACHINE_CODE		EM_ARM
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
#define ELF_MAXPAGESIZE			0x8000
#endif

#define bfd_elf32_bfd_copy_private_bfd_data	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	elf32_arm_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags		elf32_arm_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data	elf32_arm_print_private_bfd_data
#define bfd_elf32_bfd_link_hash_table_create    elf32_arm_link_hash_table_create
#define bfd_elf32_bfd_reloc_type_lookup		elf32_arm_reloc_type_lookup
#define bfd_elf32_find_nearest_line	        elf32_arm_find_nearest_line

#define elf_backend_get_symbol_type             elf32_arm_get_symbol_type
#define elf_backend_gc_mark_hook                elf32_arm_gc_mark_hook
#define elf_backend_gc_sweep_hook               elf32_arm_gc_sweep_hook
#define elf_backend_check_relocs                elf32_arm_check_relocs
#define elf_backend_relocate_section		elf32_arm_relocate_section
#define elf_backend_adjust_dynamic_symbol	elf32_arm_adjust_dynamic_symbol
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
#define elf_backend_finish_dynamic_symbol	elf32_arm_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections	elf32_arm_finish_dynamic_sections
#define elf_backend_size_dynamic_sections	elf32_arm_size_dynamic_sections
#define elf_backend_post_process_headers	elf32_arm_post_process_headers
#define elf_backend_reloc_type_class		elf32_arm_reloc_type_class
#define elf_backend_object_p			elf32_arm_object_p
#define elf_backend_section_flags		elf32_arm_section_flags
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol

#define elf_backend_can_refcount    1
#define elf_backend_can_gc_sections 1
#define elf_backend_plt_readonly    1
#define elf_backend_want_got_plt    1
#define elf_backend_want_plt_sym    0
#if !USE_REL
#define elf_backend_rela_normal     1
#endif

#define elf_backend_got_header_size	12

#include "elf32-target.h"

@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1998, 1999 Free Software Foundation, Inc.
d21 3
d28 1
a28 1
static boolean elf32_arm_set_private_flags
d30 1
a30 1
static boolean elf32_arm_copy_private_bfd_data
d32 1
a32 1
static boolean elf32_arm_merge_private_bfd_data
d34 1
a34 1
static boolean elf32_arm_print_private_bfd_data
d43 1
a43 2
	   const char *, unsigned char, struct elf_link_hash_entry *));

d47 1
a47 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d49 1
a49 5
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d58 56
d118 1
a118 5
   name can be changed. The only requirement is the %s be present.
 */

#define INTERWORK_FLAG( abfd )   (elf_elfheader (abfd)->e_flags & EF_INTERWORK)

d129 6
a135 1

d141 18
a158 1
   linker first */
d160 21
a180 7
static const bfd_byte elf32_arm_plt0_entry [PLT_ENTRY_SIZE] =
{
  0x04, 0xe0, 0x2d, 0xe5,	/* str   lr, [sp, #-4]!     */
  0x10, 0xe0, 0x9f, 0xe5,	/* ldr   lr, [pc, #16]      */
  0x0e, 0xe0, 0x8f, 0xe0,	/* adr   lr, pc, lr         */
  0x08, 0xf0, 0xbe, 0xe5	/* ldr   pc, [lr, #8]!      */
};
d184 6
d191 1
a191 8
static const bfd_byte elf32_arm_plt_entry [PLT_ENTRY_SIZE] =
{
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr   ip, [pc, #4]       */
  0x0c, 0xc0, 0x8f, 0xe0,	/* add   ip, pc, ip         */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr   pc, [ip]           */
  0x00, 0x00, 0x00, 0x00        /* offset to symbol in got  */
};

d201 9
a209 10

struct elf32_arm_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf32_arm_pcrel_relocs_copied * next;
  /* A section in dynobj.  */
  asection * section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};
a211 1

d213 2
a214 2
{
  struct elf_link_hash_entry root;
d216 3
a218 8
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf32_arm_pcrel_relocs_copied * pcrel_relocs_copied;
};

/* Declare this now that the above structures are defined.  */

static boolean elf32_arm_discard_copies
  PARAMS ((struct elf32_arm_link_hash_entry *, PTR));
a220 1

d224 1
a224 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d231 1
a231 1
/* ARM ELF linker hash table */
d237 2
a238 2
    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
    long int thumb_glue_size;
d240 2
a241 2
    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
    long int arm_glue_size;
d243 1
a243 1
    /* An arbitary input BFD chosen to hold the glue sections.  */
d249 12
a262 1

d288 1
a288 1
    ret->pcrel_relocs_copied = NULL;
d293 110
a402 1
/* Create an ARM elf linker hash table */
d409 1
d411 1
a411 2
  ret = ((struct elf32_arm_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf32_arm_link_hash_table)));
d418 1
a418 1
      bfd_release (abfd, ret);
d422 7
d433 1
d438 2
d443 1
a443 1
     CONST char *name;
d453 2
a454 3

  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1));
d461 1
a461 1
    (&(hash_table)->root, tmp_name, false, false, true);
d465 2
a466 2
    _bfd_error_handler (_ ("%s: unable to find THUMB glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
d473 2
d478 1
a478 1
     CONST char *name;
d488 2
a489 2
  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d496 1
a496 1
    (&(hash_table)->root, tmp_name, false, false, true);
d500 2
a501 2
    _bfd_error_handler (_ ("%s: unable to find ARM glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
d508 1
a508 2
/*
   ARM->Thumb glue:
d515 1
a515 2
   .word func    @@ behave as if you saw a ARM_32 reloc
 */
d522 1
a522 2
/*
   Thumb->ARM:                          Thumb->(non-interworking aware) ARM
d536 1
a536 2
   .word        func
 */
d543 2
a544 8
static const insn16 t2a1_push_insn = 0xb540;
static const insn16 t2a2_ldr_insn = 0x4e03;
static const insn16 t2a3_mov_insn = 0x46fe;
static const insn16 t2a4_bx_insn = 0x4730;
static const insn32 t2a5_pop_insn = 0xe8bd4040;
static const insn32 t2a6_bx_insn = 0xe12fff1e;

boolean
d560 2
a561 2
      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);
d565 2
a566 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->arm_glue_size);
d581 2
a582 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->thumb_glue_size);
d588 1
a588 1
  return true;
d597 1
a597 1
  register asection * s;
d600 1
d602 1
a611 1

d614 2
a615 2
  tmp_name = ((char *)
       bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d622 1
a622 1
    (&(globals)->root, tmp_name, false, false, true);
d626 1
d628 1
a628 1
      return;			/* we've already seen this guy */
d634 5
a638 6

  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner, tmp_name,
				    BSF_GLOBAL,
				    s, globals->arm_glue_size + 1,
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
d653 1
a653 1
  register asection *s;
d656 1
d659 1
d671 2
a672 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d679 1
a679 1
    (&(hash_table)->root, tmp_name, false, false, true);
d683 1
d685 1
a685 1
      return;			/* we've already seen this guy */
d688 5
a692 4
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner, tmp_name,
			     BSF_GLOBAL, s, hash_table->thumb_glue_size + 1,
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
d694 2
a695 1
  /* If we mark it 'thumb', the disassembler will do a better job.  */
a700 2
  /* Allocate another symbol to mark where we switch to arm mode.  */

d704 3
a706 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (CHANGE_TO_ARM) + 1);
d712 5
a716 6
  myh = NULL;

  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner, tmp_name,
			      BSF_LOCAL, s, hash_table->thumb_glue_size + 4,
				    NULL, true, false,
				    (struct bfd_link_hash_entry **) &myh);
d725 5
a729 5
/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */
boolean
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
a732 1
  struct elf32_arm_link_hash_table *globals;
d736 4
a739 11
  /* If we are only performing a partial link do not bother
     getting a bfd to hold the glue.  */
  if (info->relocateable)
    return true;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return true;
d755 2
a756 2
	return false;
      
d773 2
a774 2
	return false;
      
d778 26
d807 1
a807 1
  return true;
d810 1
a810 1
boolean
d817 1
a817 1
  Elf_Internal_Rela *free_relocs = NULL;
a819 3
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
d826 2
a827 2
  if (link_info->relocateable)
    return true;
a830 1

d842 1
a842 1
    return true;
d850 1
d852 3
d856 2
a857 4
      irel = (_bfd_elf32_link_read_relocs (abfd, sec, (PTR) NULL,
					(Elf_Internal_Rela *) NULL, false));

      BFD_ASSERT (irel != 0);
d859 2
a860 2
      irelend = irel + sec->reloc_count;
      for (; irel < irelend; irel++)
d870 1
a870 1
	  /* These are the only relocation types we care about */
a886 1
		  free_contents = contents;
d889 1
a889 1
					      (file_ptr) 0, sec->_raw_size))
d894 1
a894 23
	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (extsyms == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (symtab_hdr->contents != NULL)
		extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	      else
		{
		  /* Go get them off disk.  */
		  extsyms = ((Elf32_External_Sym *)
			     bfd_malloc (symtab_hdr->sh_size));
		  if (extsyms == NULL)
		    goto error_return;
		  free_extsyms = extsyms;
		  if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		      || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
			  != symtab_hdr->sh_size))
		    goto error_return;
		}
	    }

	  /* If the relocation is not against a symbol it cannot concern us. */

d897 1
a897 1
	  /* We don't care about local symbols */
d901 1
a901 1
	  /* This is an external symbol */
a916 1

a924 1

d933 10
d945 2
a946 2
  return true;
  
d948 8
a955 8
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  
  return false;
d957 1
d966 1
a966 1
   11 bits to invest. The upper 11 bits are stored in one (identifed by
d985 1
a985 1
   reverse.  nickc@@cygnus.com  */
d987 2
a988 2
#define LOW_HI_ORDER 0xF800F000
#define HI_LOW_ORDER 0xF000F800
a997 1

d1000 3
a1002 3
  rel_off >>= 1;		/* half word aligned address */
  low_bits = rel_off & 0x000007FF;	/* the bottom 11 bits */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* the top 11 bits */
d1009 2
a1010 3
    abort ();			/* error - not a valid branch instruction form */

  /* FIXME: abort is probably not the right call. krk@@cygnus.com */
d1015 2
a1016 1
/* Thumb code calling an ARM function */
d1032 1
a1032 1
  long int my_offset;
d1040 1
a1040 1
    return false;
d1062 6
a1067 6
	  _bfd_error_handler
	    (_ ("%s(%s): warning: interworking not enabled."),
	     bfd_get_filename (sym_sec->owner), name);
	  _bfd_error_handler
	    (_ ("  first occurrence: %s: thumb call to arm"),
	     bfd_get_filename (input_bfd));
d1069 1
a1069 1
	  return false;
d1075 1
a1075 1
      bfd_put_16 (output_bfd, t2a1_bx_pc_insn,
d1078 1
a1078 1
      bfd_put_16 (output_bfd, t2a2_noop_insn,
d1082 2
a1083 1
	((bfd_signed_vma) val)	/* Address of destination of the stub */
d1085 10
a1094 5
	   (s->output_offset	/* Offset from the start of the current section to the start of the stubs.  */
	    + my_offset		/* Offset of the start of this stub from the start of the stubs.  */
	    + s->output_section->vma)	/* Address of the start of the current section.  */
	   + 4			/* The branch instruction is 4 bytes into the stub.  */
	   + 8);		/* ARM branches work from the pc of the instruction + 8.  */
d1097 1
a1097 1
		  t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d1103 1
a1103 2
  /* Now go back and fix up the original BL insn to point
     to here.  */
d1105 7
a1111 4
    s->output_offset
    + my_offset
    - (input_section->output_offset
       + offset + addend)
d1118 1
a1118 1
	      insert_thumb_branch (tmp, ret_offset),
d1121 1
a1121 1
  return true;
d1124 2
a1125 1
/* Arm code calling a Thumb function */
d1141 1
a1141 1
  long int my_offset;
d1149 1
a1149 1
    return false;
d1169 6
a1174 6
	  _bfd_error_handler
	    (_ ("%s(%s): warning: interworking not enabled."),
	     bfd_get_filename (sym_sec->owner), name);
	  _bfd_error_handler
	    (_ ("  first occurrence: %s: arm call to thumb"),
	     bfd_get_filename (input_bfd));
d1176 1
d1180 1
a1180 1
      bfd_put_32 (output_bfd, a2t1_ldr_insn,
d1183 1
a1183 1
      bfd_put_32 (output_bfd, a2t2_bx_r12_insn,
d1196 9
a1204 9
  /* Somehow these are both 4 too far, so subtract 8. */
  ret_offset = s->output_offset
    + my_offset
    + s->output_section->vma
    - (input_section->output_offset
       + input_section->output_section->vma
       + offset + addend)
    - 8;
  
d1207 1
a1207 2
  bfd_put_32 (output_bfd, tmp, hit_data
	      - input_section->vma);
d1209 1
a1209 1
  return true;
d1213 1
d1228 1
a1228 1
     unsigned char          sym_flags;
d1245 12
d1270 1
a1270 1
#ifdef USE_REL
d1293 32
d1326 1
a1326 2
	 into the output file to be resolved at run time. */

d1328 8
a1335 6
	  && (r_type != R_ARM_PC24
 	      || (h != NULL
	          && h->dynindx != -1
		  && (! info->symbolic
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1337 3
a1339 2
	  Elf_Internal_Rel outrel;
	  boolean skip, relocate;
d1361 2
a1362 17
	  skip = false;

	  if (elf_section_data (input_section)->stab_info == NULL)
	    outrel.r_offset = rel->r_offset;
	  else
	    {
	      bfd_vma off;

	      off = (_bfd_stab_section_offset
		     (output_bfd, &elf_hash_table (info)->stab_info,
		      input_section,
		      & elf_section_data (input_section)->stab_info,
		      rel->r_offset));
	      if (off == (bfd_vma) -1)
		skip = true;
	      outrel.r_offset = off;
	    }
d1364 7
d1375 8
a1382 13
	    {
	      memset (&outrel, 0, sizeof outrel);
	      relocate = false;
	    }
	  else if (r_type == R_ARM_PC24)
	    {
	      BFD_ASSERT (h != NULL && h->dynindx != -1);
	      if ((input_section->flags & SEC_ALLOC) != 0)
		relocate = false;
	      else
		relocate = true;
	      outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_PC24);
	    }
d1385 3
a1387 17
	      if (h == NULL
		  || ((info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0))
		{
		  relocate = true;
		  outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		}
	      else
		{
		  BFD_ASSERT (h->dynindx != -1);
		  if ((input_section->flags & SEC_ALLOC) != 0)
		    relocate = false;
		  else
		    relocate = true;
		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_ABS32);
		}
d1390 4
a1393 6
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
				    (((Elf32_External_Rel *)
				      sreloc->contents)
				     + sreloc->reloc_count));
	  ++sreloc->reloc_count;
	  
d1396 1
a1396 1
	     value so that it becomes an addend for the dynamic reloc. */
a1399 1
	  
d1406 19
a1424 5
	case R_ARM_PC24:
	  /* Arm B/BL instruction */

	  /* Check for arm calling thumb function.  */
	  if (sym_flags == STT_ARM_TFUNC)
d1426 8
a1433 4
	      elf32_arm_to_thumb_stub (info, sym_name, input_bfd, output_bfd,
				       input_section, hit_data, sym_sec, rel->r_offset,
				       signed_addend, value);
	      return bfd_reloc_ok;
a1440 1

a1468 1

d1490 3
d1495 2
a1496 2
	     is going to crash anyway, so there is no point worrying 
	     about getting the destination exactly right.  */	     
d1500 1
a1500 3
	      signed_addend = value;
	      signed_addend >>= howto->rightshift;
	      if (signed_addend > ((bfd_signed_vma)(howto->dst_mask >> 1))
d1504 11
a1514 3
	      
	  value = (signed_addend & howto->dst_mask)
	    | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
d1525 1
a1525 1
		    + input_section->output_offset);
d1563 2
a1564 2
      /* Support ldr and str instructions for the thumb. */
#ifdef USE_REL
d1581 3
d1585 1
a1585 1
      /* Thumb BL (branch long instruction). */
d1587 5
a1591 5
	bfd_vma        relocation;
	boolean        overflow = false;
	bfd_vma        upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma        lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
d1593 1
a1593 1
	bfd_vma        check;
d1596 1
a1596 1
#ifdef USE_REL
d1602 1
a1602 1
	  upper = (upper ^ 0x400) - 0x400; /* sign extend */
d1607 14
a1620 5

        /* If it is not a call to thumb, assume call to arm.
	   If it is a call relative to a section name, then it is not a
	   function call at all, but rather a long jump.  */
	if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
d1622 12
a1633 6
	    if (elf32_thumb_to_arm_stub
		(info, sym_name, input_bfd, output_bfd, input_section,
		 hit_data, sym_sec, rel->r_offset, signed_addend, value))
	      return bfd_reloc_ok;
	    else
	      return bfd_reloc_dangerous;
d1641 1
a1641 1
	
d1644 2
a1645 2
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form */
	    
d1670 1
a1670 1
	  overflow = true;
d1672 9
d1693 44
d1760 7
a1766 1
      
d1771 1
a1771 2
         calculation. */

d1774 2
a1775 2
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);
d1778 1
a1778 2
      /* Use global offset table as symbol value. */

d1786 2
a1787 2
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);
d1791 1
a1791 1
         global offset table. */
d1798 1
d1802 1
d1804 5
a1808 3
	  if (!elf_hash_table (info)->dynamic_sections_created ||
	      (info->shared && (info->symbolic || h->dynindx == -1)
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d1818 1
a1818 2
		 finish_dynamic_symbol routine. */

d1823 7
d1848 1
a1848 1
	     generated the necessary reloc. */
d1858 2
a1859 1
		  Elf_Internal_Rel outrel;
d1868 3
a1870 5
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
					    (((Elf32_External_Rel *)
					      srelgot->contents)
					     + srelgot->reloc_count));
		  ++srelgot->reloc_count;
a1877 8
      
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
      				       contents, rel->r_offset, value,
      				       (bfd_vma) 0);

    case R_ARM_PLT32:
      /* Relocation is to the entry for this symbol in the
         procedure linkage table.  */
a1878 22
      /* Resolve a PLT32 reloc against a local symbol directly,
         without using the procedure linkage table. */
      if (h == NULL)
        return _bfd_final_link_relocate (howto, input_bfd, input_section,
        				 contents, rel->r_offset, value,
        				 (bfd_vma) 0);

      if (h->plt.offset == (bfd_vma) -1)
        /* We didn't make a PLT entry for this symbol.  This
           happens when statically linking PIC code, or when
           using -Bsymbolic.  */
	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 (bfd_vma) 0);

      BFD_ASSERT(splt != NULL);
      if (splt == NULL)
        return bfd_reloc_notsupported;

      value = (splt->output_section->vma
	       + splt->output_offset
	       + h->plt.offset);
d1880 2
a1881 2
        			       contents, rel->r_offset, value,
        			       (bfd_vma) 0);
d1912 1
a1912 1
#ifdef USE_REL
a1920 1
  bfd_vma        contents;
d1923 4
a1926 1
  contents = bfd_get_32 (abfd, address);
d1928 16
a1943 3
  /* Get the (signed) value from the instruction.  */
  addend = contents & howto->src_mask;
  if (addend & ((howto->src_mask + 1) >> 1))
d1945 32
a1976 6
      bfd_signed_vma mask;
      
      mask = -1;
      mask &= ~ howto->src_mask;
      addend |= mask;
    }
d1978 1
a1978 13
  /* Add in the increment, (which is a byte value).  */
  switch (howto->type)
    {
    case R_ARM_THM_PC22:
    default:
      addend += increment;
      break;
      
    case R_ARM_PC24:
      addend <<= howto->size;
      addend +=  increment;
      
      /* Should we check for overflow here ?  */
d1980 1
a1980 3
      /* Drop any undesired bits.  */
      addend >>= howto->rightshift;
      break;
a1981 4
  
  contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);
  
  bfd_put_32 (abfd, contents, address);
d1986 1
a1986 1
static boolean
d1989 8
a1996 8
     bfd *                  output_bfd;
     struct bfd_link_info * info;
     bfd *                  input_bfd;
     asection *             input_section;
     bfd_byte *             contents;
     Elf_Internal_Rela *    relocs;
     Elf_Internal_Sym *     local_syms;
     asection **            local_sections;
d1998 10
a2007 5
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
  const char *                  name;
d2036 2
a2037 1
      if (info->relocateable)
d2039 1
a2039 1
	  /* This is a relocateable link.  We don't have to change
a2048 1
#ifdef USE_REL
d2050 3
a2052 5
				  howto, sec->output_offset + sym->st_value);
#else
		  rel->r_addend += (sec->output_offset + sym->st_value)
		    >> howto->rightshift;
#endif
d2058 1
d2064 1
d2069 1
d2073 39
d2115 9
a2123 6
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
a2124 4
	      int relocation_needed = 1;

	      sec = h->root.u.def.section;

d2127 1
a2127 1
	         sec->output_section will be NULL. */
d2132 3
d2137 1
a2137 1
	              	  (!info->symbolic && h->dynindx != -1)
d2140 9
a2148 1
	              && ((input_section->flags & SEC_ALLOC) != 0)
d2150 1
a2150 1
	            relocation_needed = 0;
d2154 1
a2154 1
	          relocation_needed = 0;
d2158 4
a2161 2
	          if (elf_hash_table(info)->dynamic_sections_created
	              && (!info->shared
d2163 3
a2165 4
	                  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
			  )
		      )
	            relocation_needed = 0;
d2168 8
a2175 3
	        case R_ARM_PLT32:
	          if (h->plt.offset != (bfd_vma)-1)
	            relocation_needed = 0;
a2176 10

	        default:
		  if (sec->output_section == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
			 bfd_get_filename (input_bfd), h->root.root.string,
			 bfd_get_section_name (input_bfd, input_section));
		      relocation_needed = 0;
		    }
a2177 20

	      if (relocation_needed)
		relocation = h->root.u.def.value
		  + sec->output_section->vma
		  + sec->output_offset;
	      else
		relocation = 0;
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared && !info->symbolic && !info->no_undefined)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined))))
		return false;
	      relocation = 0;
d2204 9
a2212 4
	      if (!((*info->callbacks->reloc_overflow)
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return false;
d2218 2
a2219 2
		     rel->r_offset, true)))
		return false;
d2223 1
a2223 1
	      msg = _ ("internal error: out of range error");
d2227 1
a2227 1
	      msg = _ ("internal error: unsupported relocation error");
d2231 1
a2231 1
	      msg = _ ("internal error: dangerous error");
d2235 1
a2235 1
	      msg = _ ("internal error: unknown error");
d2242 1
a2242 1
		return false;
d2248 23
a2270 1
  return true;
d2273 2
a2274 2
/* Function to keep ARM specific flags in the ELF header. */
static boolean
d2282 11
a2292 8
      if (flags & EF_INTERWORK)
	_bfd_error_handler (_ ("\
Warning: Not setting interwork flag of %s since it has already been specified as non-interworking"),
			    bfd_get_filename (abfd));
      else
	_bfd_error_handler (_ ("\
Warning: Clearing the interwork flag of %s due to outside request"),
			    bfd_get_filename (abfd));
d2297 1
a2297 1
      elf_flags_init (abfd) = true;
d2300 1
a2300 1
  return true;
d2303 3
a2305 2
/* Copy backend specific data from one object module to another */
static boolean
d2313 1
a2313 1
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d2315 1
a2315 1
    return true;
d2317 1
a2317 1
  in_flags = elf_elfheader (ibfd)->e_flags;
d2320 3
a2322 1
  if (elf_flags_init (obfd) && in_flags != out_flags)
a2323 4
      /* Cannot mix PIC and non-PIC code.  */
      if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
	return false;

d2325 2
a2326 2
      if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
	return false;
d2329 2
a2330 2
      if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
	return false;
d2334 1
a2334 1
      if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
d2336 5
a2340 4
	  if (out_flags & EF_INTERWORK)
	    _bfd_error_handler (_ ("\
Warning: Clearing the interwork flag in %s because non-interworking code in %s has been linked with it"),
			  bfd_get_filename (obfd), bfd_get_filename (ibfd));
d2342 1
a2342 1
	  in_flags &= ~EF_INTERWORK;
d2344 4
d2351 1
a2351 1
  elf_flags_init (obfd) = true;
d2353 1
a2353 1
  return true;
d2358 2
a2359 1
static boolean
d2361 2
a2362 2
     bfd *ibfd;
     bfd *obfd;
d2366 6
d2375 1
a2375 16
    return true;

  /* Check if we have the same endianess */
  if (   ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	(_("%s: compiled for a %s endian system and target is %s endian"),
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
d2380 1
a2380 1
     written into the object */
d2388 5
a2392 5
      /* If the input is the default architecture then do not
         bother setting the flags for the output architecture,
         instead allow future merges to do this.  If no future
         merges ever set these flags then they will retain their
         unitialised values, which surprise surprise, correspond
d2394 3
a2396 2
      if (bfd_get_arch_info (ibfd)->the_default)
	return true;
d2398 1
a2398 1
      elf_flags_init (obfd) = true;
d2405 1
a2405 1
      return true;
d2408 6
a2413 1
  /* Check flag compatibility.  */
d2415 36
a2450 1
    return true;
d2453 10
d2464 107
a2570 33
  if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
    _bfd_error_handler (_ ("\
Error: %s compiled for APCS-%d, whereas %s is compiled for APCS-%d"),
			bfd_get_filename (ibfd),
			in_flags & EF_APCS_26 ? 26 : 32,
			bfd_get_filename (obfd),
			out_flags & EF_APCS_26 ? 26 : 32);

  if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
    _bfd_error_handler (_ ("\
Error: %s passes floats in %s registers, whereas %s passes them in %s registers"),
			bfd_get_filename (ibfd),
		     in_flags & EF_APCS_FLOAT ? _ ("float") : _ ("integer"),
			bfd_get_filename (obfd),
		      out_flags & EF_APCS_26 ? _ ("float") : _ ("integer"));

  if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
    _bfd_error_handler (_ ("\
Error: %s is compiled as position %s code, whereas %s is not"),
			bfd_get_filename (ibfd),
		    in_flags & EF_PIC ? _ ("independent") : _ ("dependent"),
			bfd_get_filename (obfd));

  /* Interworking mismatch is only a warning. */
  if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
    {
      _bfd_error_handler (_ ("\
Warning: %s %s interworking, whereas %s %s"),
			  bfd_get_filename (ibfd),
	  in_flags & EF_INTERWORK ? _ ("supports") : _ ("does not support"),
			  bfd_get_filename (obfd),
		    out_flags & EF_INTERWORK ? _ ("does not") : _ ("does"));
      return true;
d2573 1
a2573 1
  return false;
d2576 3
a2578 2
/* Display the flags field */
static boolean
d2583 2
a2584 1
  FILE *file = (FILE *) ptr;
d2591 3
a2593 1
  /* Ignore init flag - it may not be set, despite the flags field containing valid data.  */
d2596 15
a2610 1
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2612 66
a2677 4
  if (elf_elfheader (abfd)->e_flags & EF_INTERWORK)
    fprintf (file, _ (" [interworking enabled]"));
  else
    fprintf (file, _ (" [interworking not enabled]"));
d2679 2
a2680 4
  if (elf_elfheader (abfd)->e_flags & EF_APCS_26)
    fprintf (file, _ (" [APCS-26]"));
  else
    fprintf (file, _ (" [APCS-32]"));
d2682 1
a2682 4
  if (elf_elfheader (abfd)->e_flags & EF_APCS_FLOAT)
    fprintf (file, _ (" [floats passed in float registers]"));
  else
    fprintf (file, _ (" [floats passed in integer registers]"));
d2684 2
a2685 4
  if (elf_elfheader (abfd)->e_flags & EF_PIC)
    fprintf (file, _ (" [position independent]"));
  else
    fprintf (file, _ (" [absolute position]"));
d2689 1
a2689 1
  return true;
d2701 1
a2701 1
      break;
d2710 3
d2719 2
a2720 2
elf32_arm_gc_mark_hook (abfd, info, rel, h, sym)
       bfd *abfd;
d2750 2
a2751 9
     {
       if (!(elf_bad_symtab (abfd)
           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
                && sym->st_shndx != SHN_COMMON))
          {
            return bfd_section_from_elf_index (abfd, sym->st_shndx);
          }
      }
d2757 1
a2757 1
static boolean
d2764 71
a2834 2
  /* We don't support garbage collection of GOT and PLT relocs yet.  */
  return true;
d2839 1
a2839 1
static boolean
d2841 4
a2844 4
     bfd *                      abfd;
     struct bfd_link_info *     info;
     asection *                 sec;
     const Elf_Internal_Rela *  relocs;
d2846 16
a2861 14
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  struct elf_link_hash_entry ** sym_hashes_end;
  const Elf_Internal_Rela *     rel;
  const Elf_Internal_Rela *     rel_end;
  bfd *                         dynobj;
  asection * sgot, *srelgot, *sreloc;
  bfd_vma * local_got_offsets;
  
  if (info->relocateable)
    return true;
  
  sgot = srelgot = sreloc = NULL;
  
d2867 3
a2869 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d2872 1
a2872 1
  
d2878 1
a2878 1
      
a2883 18
      
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_ARM_GOT32:
	    case R_ARM_GOTOFF:
	    case R_ARM_GOTPC:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return false;
	      break;

	    default:
	      break;
	    }
	}
a2888 29
	    if (sgot == NULL)
	      {
	        sgot = bfd_get_section_by_name (dynobj, ".got");
	        BFD_ASSERT (sgot != NULL);
	      }

	    /* Get the got relocation section if necessary.  */
	    if (srelgot == NULL
	        && (h != NULL || info->shared))
	      {
	        srelgot = bfd_get_section_by_name (dynobj, ".rel.got");
		
	        /* If no got relocation section, make one and initialize.  */
	        if (srelgot == NULL)
		  {
		    srelgot = bfd_make_section (dynobj, ".rel.got");
		    if (srelgot == NULL
		        || ! bfd_set_section_flags (dynobj, srelgot,
		  				    (SEC_ALLOC
						     | SEC_LOAD
						     | SEC_HAS_CONTENTS
						     | SEC_IN_MEMORY
						     | SEC_LINKER_CREATED
						     | SEC_READONLY))
		        || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		      return false;
		  }
	      }

d2891 1
a2891 12
	        if (h->got.offset != (bfd_vma) -1)
		  /* We have already allocated space in the .got.  */
		  break;

	        h->got.offset = sgot->_raw_size;

	        /* Make sure this symbol is output as a dynamic symbol.  */
	        if (h->dynindx == -1)
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return false;

	        srelgot->_raw_size += sizeof (Elf32_External_Rel);
d2895 5
a2899 3
     	        /* This is a global offset table entry for a local
                   symbol.  */
	        if (local_got_offsets == NULL)
d2901 1
a2901 2
		    size_t size;
		    register unsigned int i;
d2903 7
a2909 7
		    size = symtab_hdr->sh_info * sizeof (bfd_vma);
		    local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		    if (local_got_offsets == NULL)
		      return false;
		    elf_local_got_offsets (abfd) = local_got_offsets;
		    for (i = 0; i < symtab_hdr->sh_info; i++)
		      local_got_offsets[i] = (bfd_vma) -1;
d2911 1
a2911 12

	        if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		  /* We have already allocated space in the .got.  */
		  break;

	        local_got_offsets[r_symndx] = sgot->_raw_size;

	        if (info->shared)
		  /* If we are generating a shared object, we need to
		     output a R_ARM_RELATIVE reloc so that the dynamic
		     linker can adjust this GOT entry.  */
		  srelgot->_raw_size += sizeof (Elf32_External_Rel);
a2912 2

	    sgot->_raw_size += 4;
d2915 9
a2923 14
  	  case R_ARM_PLT32:
	    /* This symbol requires a procedure linkage table entry.  We
               actually build the entry in adjust_dynamic_symbol,
               because this might be a case of linking PIC code which is
               never referenced by a dynamic object, in which case we
               don't need to generate a procedure linkage table entry
               after all.  */

	    /* If this is a local symbol, we resolve it directly without
               creating a procedure linkage table entry.  */
	    if (h == NULL)
	      continue;

	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2929 25
d2965 1
a2965 1
               pcrel_relocs_copied field of the hash table entry.  */
d2967 8
a2974 5
	      && (ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
	        || (h != NULL
		  && (! info->symbolic
		    || (h->elf_link_hash_flags
		      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d2976 2
d2990 1
a2990 1
		      return false;
d2993 1
a2993 1
		 	        && strcmp (bfd_get_section_name (abfd, sec),
d3009 1
a3009 1
			  return false;
d3011 2
d3015 24
a3038 11
	        sreloc->_raw_size += sizeof (Elf32_External_Rel);
	        /* If we are linking with -Bsymbolic, and this is a
                   global symbol, we count the number of PC relative
                   relocations we have entered for this symbol, so that
                   we can discard them again if the symbol is later
                   defined by a regular object.  Note that this function
                   is only called if we are using an elf_i386 linker
                   hash table, which means that h is really a pointer to
                   an elf_i386_link_hash_entry.  */
	        if (h != NULL && info->symbolic
		    && ELF32_R_TYPE (rel->r_info) == R_ARM_PC24)
d3040 2
a3041 9
		    struct elf32_arm_link_hash_entry * eh;
		    struct elf32_arm_pcrel_relocs_copied * p;

		    eh = (struct elf32_arm_link_hash_entry *) h;

		    for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		      if (p->section == sreloc)
		        break;

d3043 5
a3047 13
		      {
		        p = ((struct elf32_arm_pcrel_relocs_copied *)
			     bfd_alloc (dynobj, sizeof * p));

		        if (p == NULL)
			  return false;
		        p->next = eh->pcrel_relocs_copied;
		        eh->pcrel_relocs_copied = p;
		        p->section = sreloc;
		        p->count = 0;
		      }

		    ++p->count;
d3049 4
d3059 2
a3060 2
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return false;
d3062 1
a3062 1
	  
d3066 2
a3067 2
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return false;
d3072 1
a3072 1
  return true;
a3074 1

d3077 1
a3077 1
   that it also accepts STT_ARM_TFUNC as a symbol that names a function. */
d3079 1
a3079 1
static boolean
d3082 14
a3095 13
     bfd *          abfd;
     asection *     section;
     asymbol **     symbols;
     bfd_vma        offset;
     CONST char **  filename_ptr;
     CONST char **  functionname_ptr;
     unsigned int * line_ptr;
{
  boolean      found;
  const char * filename;
  asymbol *    func;
  bfd_vma      low_func;
  asymbol **   p;
d3099 3
a3101 2
				     line_ptr, 0))
    return true;
d3107 1
a3107 1
    return false;
d3110 1
a3110 1
    return true;
d3113 1
a3113 1
    return false;
d3118 1
d3143 8
a3150 2
	      func = (asymbol *) q;
	      low_func = q->symbol.value;
d3157 1
a3157 1
    return false;
d3163 1
a3163 1
  return true;
d3172 1
a3172 1
static boolean
d3200 4
a3203 3
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
d3206 6
a3211 6
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PC32
             reloc instead.  */
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
	  return true;
d3214 1
a3214 46
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->_raw_size == 0)
	s->_raw_size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	}

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += 4;

      /* We also need to make an entry in the .rel.plt section.  */

      s = bfd_get_section_by_name (dynobj, ".rel.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf32_External_Rel);

      return true;
d3216 7
d3233 1
a3233 1
      return true;
d3244 1
a3244 1
    return true;
a3254 1

d3284 1
a3284 1
	return false;
d3294 172
a3465 1
  return true;
d3470 1
a3470 1
static boolean
d3472 1
a3472 1
     bfd * output_bfd;
d3477 4
a3480 3
  boolean plt;
  boolean relocs;
  boolean reltext;
d3482 1
d3489 1
a3489 1
      if (! info->shared)
d3497 4
a3500 1
  else
d3502 63
a3564 18
      /* We may have created entries in the .rel.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rel.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rel.got");
      if (s != NULL)
	s->_raw_size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    elf32_arm_link_hash_traverse (elf32_arm_hash_table (info),
				  elf32_arm_discard_copies,
				  (PTR) NULL);
d3569 2
a3570 3
  plt = false;
  relocs = false;
  reltext = false;
d3574 1
a3574 1
      boolean strip;
d3583 1
a3583 1
      strip = false;
d3591 1
a3591 1
	      strip = true;
d3596 1
a3596 1
	      plt = true;
d3612 1
a3612 1
	      strip = true;
a3615 2
	      asection * target;

d3619 1
a3619 19
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rel.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 4);
		  
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d3634 1
a3634 9
	  asection ** spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

d3641 1
a3641 1
	return false;
d3651 4
a3654 1
      if (! info->shared)
d3656 2
a3657 2
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
d3662 5
a3666 5
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
	    return false;
d3671 4
a3674 5
	  if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELENT,
						sizeof (Elf32_External_Rel)))
	    return false;
d3677 1
a3677 1
      if (reltext)
d3679 3
a3681 2
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
d3684 1
d3686 1
a3686 25
  return true;
}

/* This function is called via elf32_arm_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

static boolean
elf32_arm_discard_copies (h, ignore)
     struct elf32_arm_link_hash_entry * h;
     PTR ignore ATTRIBUTE_UNUSED;
{
  struct elf32_arm_pcrel_relocs_copied * s;

  /* We only discard relocs for symbols defined in a regular object.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return true;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rel);

  return true;
d3692 1
a3692 1
static boolean
d3710 3
a3712 1
      Elf_Internal_Rel rel;
d3728 1
a3728 1
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d3735 12
d3748 10
a3757 11
      memcpy (splt->contents + h->plt.offset,
              elf32_arm_plt_entry,
	      PLT_ENTRY_SIZE);
      bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset
		       - splt->output_section->vma
		       - splt->output_offset
		       - h->plt.offset - 12),
		      splt->contents + h->plt.offset + 12);
d3764 1
a3764 1

d3770 2
a3771 3
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) srel->contents
				 + plt_index));
d3778 7
d3792 2
a3793 1
      Elf_Internal_Rel rel;
a3796 1

d3803 1
a3803 1
		      + (h->got.offset &~ 1));
d3805 5
a3809 4
      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  The entry in
	 the global offset table will already have been initialized in
	 the relocate_section function.  */
d3811 5
a3815 3
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
d3818 1
d3823 2
a3824 4
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) srel->contents
				 + srel->reloc_count));
      ++srel->reloc_count;
d3830 2
a3831 1
      Elf_Internal_Rel rel;
a3833 1

d3846 2
a3847 4
      bfd_elf32_swap_reloc_out (output_bfd, &rel,
				((Elf32_External_Rel *) s->contents
				 + s->reloc_count));
      ++s->reloc_count;
d3855 1
a3855 1
  return true;
d3860 1
a3860 1
static boolean
d3885 1
d3941 25
d3971 22
a3992 1
	memcpy (splt->contents, elf32_arm_plt0_entry, PLT_ENTRY_SIZE);
d4014 1
a4014 1
  return true;
d4022 1
a4022 1
  Elf_Internal_Ehdr * i_ehdrp;	/* Elf file header, internal form */
d4030 40
d4073 3
d4077 1
d4079 2
a4080 3

#define bfd_elf32_bfd_copy_private_bfd_data 	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data 	elf32_arm_merge_private_bfd_data
d4084 1
a4084 1
#define bfd_elf32_bfd_reloc_type_lookup 	elf32_arm_reloc_type_lookup
d4091 1
a4091 1
#define elf_backend_relocate_section    	elf32_arm_relocate_section
d4093 1
a4093 1
#define elf_backend_create_dynamic_sections	_bfd_elf_create_dynamic_sections
d4098 5
d4104 1
d4109 3
a4113 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
d4116 1
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d1759 1
a1759 8
	              && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_ARM_ABS32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d1803 1
a1803 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1810 1
a1810 2
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
d1839 4
a1842 9
	      /* If the overflowing reloc was to an undefined symbol,
		 we have already printed one error message and there
		 is no point complaining again.  */
	      if ((! h ||
		   h->root.type != bfd_link_hash_undefined)
		  && (!((*info->callbacks->reloc_overflow)
			(info, name, howto->name, (bfd_vma) 0,
			 input_bfd, input_section, rel->r_offset))))
		  return false;
d1926 4
a1948 4

      /* Likewise for PIC, though don't warn for this case.  */
      if ((in_flags & EF_PIC) != (out_flags & EF_PIC))
	in_flags &= ~EF_PIC;
a1965 3
  boolean flags_compatible = true;
  boolean null_input_bfd = true;
  asection *sec;
d1997 5
a2001 5
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
         uninitialised values, which surprise surprise, correspond
d2003 1
a2003 2
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
d2016 1
a2016 1
  /* Identical flags must be compatible.  */
d2020 1
a2020 20
  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic glue sections.  */
      if (strcmp (sec->name, ".glue_7")
	  && strcmp (sec->name, ".glue_7t"))
	{
	  null_input_bfd = false;
	  break;
	}
    }
  if (null_input_bfd)
    return true;

  /* If any of the input BFDs is non-PIC, the output is also position 
     dependent.  */
  if (!(in_flags & EF_PIC))
    elf_elfheader (obfd)->e_flags &= ~EF_PIC;
a2021 1
  /* Complain about various flag mismatches.  */
d2023 1
a2023 2
    {
      _bfd_error_handler (_ ("\
a2028 2
      flags_compatible = false;
    }
d2031 1
a2031 2
    {
      _bfd_error_handler (_ ("\
a2036 2
      flags_compatible = false;
    }
d2038 9
a2046 2
#ifdef EF_SOFT_FLOAT
  if ((in_flags & EF_SOFT_FLOAT) != (out_flags & EF_SOFT_FLOAT))
a2048 12
Error: %s uses %s floating point, whereas %s uses %s floating point"),
			  bfd_get_filename (ibfd),
			  in_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"),
			  bfd_get_filename (obfd),
			  out_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"));
      flags_compatible = false;
    }
#endif

  /* Interworking mismatch is only a warning.  */
  if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
    _bfd_error_handler (_ ("\
d2054 2
d2057 1
a2057 1
  return flags_compatible;
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d20 1
d40 1
a59 2
#define INTERWORK_FLAG(abfd)   (elf_elfheader (abfd)->e_flags & EF_INTERWORK)

d63 5
a67 1
   name can be changed. The only requirement is the %s be present.  */
d79 1
d85 3
a87 2
   linker first.  */
static const unsigned long elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
d89 4
a92 4
  0xe52de004,	/* str   lr, [sp, #-4]!     */
  0xe59fe010,	/* ldr   lr, [pc, #16]      */
  0xe08fe00e,	/* add   lr, pc, lr         */
  0xe5bef008	/* ldr   pc, [lr, #8]!      */
d97 2
a98 1
static const unsigned long elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
d100 4
a103 4
  0xe59fc004,	/* ldr   ip, [pc, #4]       */
  0xe08fc00c,	/* add   ip, pc, ip         */
  0xe59cf000,	/* ldr   pc, [ip]           */
  0x00000000	/* offset to symbol in got  */
d106 1
d115 1
d127 1
d137 1
d142 1
d153 1
a153 1
/* ARM ELF linker hash table.  */
d155 17
a171 3
{
  /* The main hash table.  */
  struct elf_link_hash_table root;
a172 13
  /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
  long int thumb_glue_size;

  /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
  long int arm_glue_size;

  /* An arbitary input BFD chosen to hold the glue sections.  */
  bfd * bfd_of_glue_owner;

  /* A boolean indicating whether knowledge of the ARM's pipeline
     length should be applied by the linker.  */
  int no_pipeline_knowledge;
};
d204 1
a204 1
/* Create an ARM elf linker hash table.  */
a231 2
/* Locate the Thumb encoded calling stub for NAME.  */

d245 1
d258 1
a258 1
    _bfd_error_handler (_("%s: unable to find THUMB glue '%s' for `%s'"),
a265 2
/* Locate the ARM encoded calling stub for NAME.  */

d291 1
a291 1
    _bfd_error_handler (_("%s: unable to find ARM glue '%s' for `%s'"),
d299 2
a300 1
/* ARM->Thumb glue:
d307 2
a308 1
   .word func    @@ behave as if you saw a ARM_32 reloc.  */
d315 2
a316 1
/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM
d330 2
a331 1
   .word        func  */
d411 1
a425 1
      /* We've already seen this guy.  */
d427 1
a427 1
      return;
d433 1
a479 1
      /* We've already seen this guy.  */
d481 1
a481 1
      return;
d489 1
a489 1
  /* If we mark it 'Thumb', the disassembler will do a better job.  */
d495 2
a499 1
  /* Allocate another symbol to mark where we switch to Arm mode.  */
a522 1

d559 1
a559 1

d577 1
a577 1

d611 1
d631 1
a632 1
      /* Load the relocs.  */
d649 1
a649 1
	  /* These are the only relocation types we care about.  */
a665 1

a686 1

a687 1

d695 2
a696 1
	  /* If the relocation is not against a symbol it cannot concern us.  */
d699 1
a699 1
	  /* We don't care about local symbols.  */
d703 1
a703 1
	  /* This is an external symbol.  */
d719 1
d728 1
d740 1
a740 1

d748 1
a748 1

d778 1
a778 1
   reverse.  nickc@@cygnus.com.  */
d780 2
a781 2
#define LOW_HI_ORDER      0xF800F000
#define HI_LOW_ORDER      0xF000F800
d791 1
d794 3
a796 3
  rel_off >>= 1;				/* Half word aligned address.  */
  low_bits = rel_off & 0x000007FF;		/* The bottom 11 bits.  */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* The top 11 bits.  */
d803 3
a805 2
    /* FIXME: abort is probably not the right call. krk@@cygnus.com  */
    abort ();			/* error - not a valid branch instruction form.  */
d810 1
a810 2
/* Thumb code calling an ARM function.  */

d857 1
a857 1
	    (_("%s(%s): warning: interworking not enabled."),
d860 1
a860 1
	    (_("  first occurrence: %s: thumb call to arm"),
d876 1
a876 2
	/* Address of destination of the stub.  */
	((bfd_signed_vma) val)
d878 5
a882 10
	   /* Offset from the start of the current section to the start of the stubs.  */
	   (s->output_offset
	    /* Offset of the start of this stub from the start of the stubs.  */
	    + my_offset
	    /* Address of the start of the current section.  */
	    + s->output_section->vma)
	   /* The branch instruction is 4 bytes into the stub.  */
	   + 4
	   /* ARM branches work from the pc of the instruction + 8.  */
	   + 8);
d910 1
a910 2
/* Arm code calling a Thumb function.  */

d955 1
a955 1
	    (_("%s(%s): warning: interworking not enabled."),
d958 1
a958 1
	    (_("  first occurrence: %s: arm call to thumb"),
a960 1

d980 1
a980 1
  /* Somehow these are both 4 too far, so subtract 8.  */
d988 1
a988 1

a997 1

a1028 12
  /* If the start address has been set, then set the EF_ARM_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.
     
     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.

     Note - if the user deliberately sets a start address of 0, the
     flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_ARM_HASENTRY;
      
a1064 3
#ifndef OLD_ARM_ABI
    case R_ARM_XPC25:
#endif
d1066 2
a1067 1
	 into the output file to be resolved at run time.  */
d1160 1
a1160 1

d1163 1
a1163 1
	     value so that it becomes an addend for the dynamic reloc.  */
d1167 1
d1174 5
a1178 18
#ifndef OLD_ARM_ABI
	case R_ARM_XPC25:	  /* Arm BLX instruction.  */
#endif
	case R_ARM_PC24:	  /* Arm B/BL instruction */
#ifndef OLD_ARM_ABI
	  if (r_type == R_ARM_XPC25)
	    {
	      /* Check for Arm calling Arm function.  */
	      /* FIXME: Should we translate the instruction into a BL
		 instruction instead ?  */
	      if (sym_flags != STT_ARM_TFUNC)
		_bfd_error_handler (_("\
%s: Warning: Arm BLX instruction targets Arm function '%s'."),
				    bfd_get_filename (input_bfd),
				    h ? h->root.root.string : "(local)");
	    }
	  else
#endif
d1180 4
a1183 8
	      /* Check for Arm calling Thumb function.  */
	      if (sym_flags == STT_ARM_TFUNC)
		{
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd, output_bfd,
					   input_section, hit_data, sym_sec, rel->r_offset,
					   signed_addend, value);
		  return bfd_reloc_ok;
		}
d1191 1
d1220 1
a1241 3
	  signed_addend = value;
	  signed_addend >>= howto->rightshift;

d1244 2
a1245 2
	     is going to crash anyway, so there is no point worrying
	     about getting the destination exactly right.  */
d1249 3
a1251 1
	      if (   signed_addend >   ((bfd_signed_vma)  (howto->dst_mask >> 1))
d1255 3
a1257 11

#ifndef OLD_ARM_ABI
	  /* If necessary set the H bit in the BLX instruction.  */
	  if (r_type == R_ARM_XPC25 && ((value & 2) == 2))
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask))
	      | (1 << 24);
	  else
#endif
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
d1306 1
a1306 1
      /* Support ldr and str instructions for the thumb.  */
a1323 3
#ifndef OLD_ARM_ABI
    case R_ARM_THM_XPC22:
#endif
d1325 1
a1325 1
      /* Thumb BL (branch long instruction).  */
d1342 1
a1342 1
	  upper = (upper ^ 0x400) - 0x400; /* Sign extend.  */
d1347 5
a1351 2
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22)
d1353 6
a1358 24
	    /* Check for Thumb to Thumb call.  */
	    /* FIXME: Should we translate the instruction into a BL
	       instruction instead ?  */
	    if (sym_flags == STT_ARM_TFUNC)
	      _bfd_error_handler (_("\
%s: Warning: Thumb BLX instruction targets thumb function '%s'."),
				  bfd_get_filename (input_bfd),
				  h ? h->root.root.string : "(local)");
	  }
	else
#endif
	  {
	    /* If it is not a call to Thumb, assume call to Arm.
	       If it is a call relative to a section name, then it is not a
	       function call at all, but rather a long jump.  */
	    if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
	      {
		if (elf32_thumb_to_arm_stub
		    (info, sym_name, input_bfd, output_bfd, input_section,
		     hit_data, sym_sec, rel->r_offset, signed_addend, value))
		  return bfd_reloc_ok;
		else
		  return bfd_reloc_dangerous;
	      }
d1366 1
a1366 1

d1369 2
a1370 2
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form.  */

a1400 12
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  lower_insn &= ~1;
#endif	
d1432 1
a1432 1

d1437 2
a1438 1
         calculation.  */
d1445 2
a1446 1
      /* Use global offset table as symbol value.  */
d1459 1
a1459 1
         global offset table.  */
d1482 2
a1483 1
		 finish_dynamic_symbol routine.  */
d1506 1
a1506 1
	     generated the necessary reloc.  */
d1537 1
a1537 1

d1547 1
a1547 1
         without using the procedure linkage table.  */
d1610 1
d1613 5
a1617 1
  if (howto->type == R_ARM_THM_PC22)
d1619 6
a1624 2
      int upper_insn, lower_insn;
      int upper, lower;
d1626 5
a1630 6
      upper_insn = bfd_get_16 (abfd, address);
      lower_insn = bfd_get_16 (abfd, address + 2);
      upper = upper_insn & 0x7ff;
      lower = lower_insn & 0x7ff;

      addend = (upper << 12) | (lower << 1);
d1632 7
a1638 1
      addend >>= 1;
d1640 3
a1642 44
      upper_insn = (upper_insn & 0xf800) | ((addend >> 11) & 0x7ff);
      lower_insn = (lower_insn & 0xf800) | (addend & 0x7ff);

      bfd_put_16 (abfd, upper_insn, address);
      bfd_put_16 (abfd, lower_insn, address + 2);
    }
  else
    {
      bfd_vma        contents;

      contents = bfd_get_32 (abfd, address);

      /* Get the (signed) value from the instruction.  */
      addend = contents & howto->src_mask;
      if (addend & ((howto->src_mask + 1) >> 1))
	{
	  bfd_signed_vma mask;

	  mask = -1;
	  mask &= ~ howto->src_mask;
	  addend |= mask;
	}

      /* Add in the increment, (which is a byte value).  */
      switch (howto->type)
	{
	default:
	  addend += increment;
	  break;

	case R_ARM_PC24:
	  addend <<= howto->size;
	  addend +=  increment;

	  /* Should we check for overflow here ?  */

	  /* Drop any undesired bits.  */
	  addend >>= howto->rightshift;
	  break;
	}

      contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);

      bfd_put_32 (abfd, contents, address);
d1644 4
a1725 1

d1737 1
a1737 2

	  while (   h->root.type == bfd_link_hash_indirect
d1740 1
a1740 2

	  if (   h->root.type == bfd_link_hash_defined
d1749 1
a1749 1
	         sec->output_section will be NULL.  */
d1868 1
a1868 1
	      msg = _("internal error: out of range error");
d1872 1
a1872 1
	      msg = _("internal error: unsupported relocation error");
d1876 1
a1876 1
	      msg = _("internal error: dangerous error");
d1880 1
a1880 1
	      msg = _("internal error: unknown error");
d1896 1
a1896 1
/* Function to keep ARM specific flags in the ELF header.  */
d1905 2
a1906 4
      if (EF_ARM_EABI_VERSION (flags) == EF_ARM_EABI_UNKNOWN)
	{
	  if (flags & EF_INTERWORK)
	    _bfd_error_handler (_("\
d1908 3
a1910 3
				bfd_get_filename (abfd));
	  else
	    _bfd_error_handler (_("\
d1912 1
a1912 2
				bfd_get_filename (abfd));
	}
d1923 1
a1923 2
/* Copy backend specific data from one object module to another.  */

d1932 1
a1932 1
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d1936 1
a1936 1
  in_flags  = elf_elfheader (ibfd)->e_flags;
d1939 1
a1939 3
  if (elf_flags_init (obfd)
      && EF_ARM_EABI_VERSION (out_flags) == EF_ARM_EABI_UNKNOWN
      && in_flags != out_flags)
d1954 1
a1954 1
	    _bfd_error_handler (_("\
a1973 1

d1976 2
a1977 2
     bfd * ibfd;
     bfd * obfd;
a1984 4
  /* Check if we have the same endianess.  */
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;

d1989 15
d2007 1
a2007 1
     written into the object.  */
d2055 5
d2061 1
a2061 13
  if (EF_ARM_EABI_VERSION (in_flags) != EF_ARM_EABI_VERSION (out_flags))
    {
      _bfd_error_handler (_("\
Error: %s compiled for EABI version %d, whereas %s is compiled for version %d"),
			 bfd_get_filename (ibfd),
			 (in_flags & EF_ARM_EABIMASK) >> 24,
			 bfd_get_filename (obfd),
			 (out_flags & EF_ARM_EABIMASK) >> 24);
      return false;
    }

  /* Not sure what needs to be checked for EABI versions >= 1.  */
  if (EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
d2063 1
a2063 3
      if ((in_flags & EF_APCS_26) != (out_flags & EF_APCS_26))
	{
	  _bfd_error_handler (_("\
d2069 2
a2070 2
	  flags_compatible = false;
	}
d2072 3
a2074 3
      if ((in_flags & EF_APCS_FLOAT) != (out_flags & EF_APCS_FLOAT))
	{
	  _bfd_error_handler (_("\
d2077 1
a2077 1
		     in_flags & EF_APCS_FLOAT ? _("float") : _("integer"),
d2079 3
a2081 3
		      out_flags & EF_APCS_26 ? _("float") : _("integer"));
	  flags_compatible = false;
	}
d2084 3
a2086 3
      if ((in_flags & EF_SOFT_FLOAT) != (out_flags & EF_SOFT_FLOAT))
	{
	  _bfd_error_handler (_ ("\
d2088 6
a2093 6
			      bfd_get_filename (ibfd),
			      in_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"),
			      bfd_get_filename (obfd),
			      out_flags & EF_SOFT_FLOAT ? _("soft") : _("hard"));
	  flags_compatible = false;
	}
d2096 3
a2098 3
      /* Interworking mismatch is only a warning.  */
      if ((in_flags & EF_INTERWORK) != (out_flags & EF_INTERWORK))
	_bfd_error_handler (_("\
d2101 1
a2101 1
	  in_flags & EF_INTERWORK ? _("supports") : _("does not support"),
d2103 1
a2103 2
		    out_flags & EF_INTERWORK ? _("does not") : _("does"));
    }
d2108 1
a2108 2
/* Display the flags field.  */

d2114 1
a2114 2
  FILE * file = (FILE *) ptr;
  unsigned long flags;
d2121 1
a2121 3
  flags = elf_elfheader (abfd)->e_flags;
  /* Ignore init flag - it may not be set, despite the flags field
     containing valid data.  */
d2124 1
a2124 1
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2126 4
a2129 8
  switch (EF_ARM_EABI_VERSION (flags))
    {
    case EF_ARM_EABI_UNKNOWN:
      /* The following flag bits are GNU extenstions and not part of the
	 official ARM ELF extended ABI.  Hence they are only decoded if
	 the EABI version is not set.  */
      if (flags & EF_INTERWORK)
	fprintf (file, _(" [interworking enabled]"));
d2131 4
a2134 4
      if (flags & EF_APCS_26)
	fprintf (file, _(" [APCS-26]"));
      else
	fprintf (file, _(" [APCS-32]"));
d2136 4
a2139 2
      if (flags & EF_APCS_FLOAT)
	fprintf (file, _(" [floats passed in float registers]"));
d2141 4
a2144 44
      if (flags & EF_PIC)
	fprintf (file, _(" [position independent]"));

      if (flags & EF_NEW_ABI)
	fprintf (file, _(" [new ABI]"));

      if (flags & EF_OLD_ABI)
	fprintf (file, _(" [old ABI]"));

      if (flags & EF_SOFT_FLOAT)
	fprintf (file, _(" [software FP]"));

      flags &= ~(EF_INTERWORK | EF_APCS_26 | EF_APCS_FLOAT | EF_PIC
		 | EF_NEW_ABI | EF_OLD_ABI | EF_SOFT_FLOAT);
      break;

    case EF_ARM_EABI_VER1:
      fprintf (file, _(" [Version1 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      flags &= ~ EF_ARM_SYMSARESORTED;
      break;

    default:
      fprintf (file, _(" <EABI version unrecognised>"));
      break;
    }

  flags &= ~ EF_ARM_EABIMASK;

  if (flags & EF_ARM_RELEXEC)
    fprintf (file, _(" [relocatable executable]"));

  if (flags & EF_ARM_HASENTRY)
    fprintf (file, _(" [has entry point]"));

  flags &= ~ (EF_ARM_RELEXEC | EF_ARM_HASENTRY);

  if (flags)
    fprintf (file, _("<Unrecognised flag bits set>"));
d2160 1
a2160 1

a2168 3

    default:
      break;
d2248 1
a2248 1

d2251 1
a2251 1

d2253 1
a2253 1

d2259 1
a2259 3
  sym_hashes_end = sym_hashes
    + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);

d2262 1
a2262 1

d2268 1
a2268 1

d2274 1
a2274 1

d2308 1
a2308 1

d2493 1
a2493 1

d2506 1
d2509 1
a2509 1
   that it also accepts STT_ARM_TFUNC as a symbol that names a function.  */
d2530 1
a2530 2
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
d2670 1
d2715 1
d2875 1
a2875 1

d2928 1
a2928 1
	  if (   ! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
d2937 1
a2937 1
	  if (   ! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
a2947 1
	  info->flags |= DF_TEXTREL;
d3023 3
a3025 6
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0],
		  splt->contents + h->plt.offset + 0);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1],
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2],
		  splt->contents + h->plt.offset + 8);
a3054 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
d3066 1
d3101 1
a3154 1

d3215 1
a3215 6
	{
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[1], splt->contents +  4);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[2], splt->contents +  8);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[3], splt->contents + 12);
	}
d3245 1
a3245 1
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
d3253 1
d3257 1
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a19 4
#ifndef USE_REL
#define USE_REL	0
#endif

d23 1
a23 1
static bfd_boolean elf32_arm_set_private_flags
d25 1
a25 1
static bfd_boolean elf32_arm_copy_private_bfd_data
d27 1
a27 1
static bfd_boolean elf32_arm_merge_private_bfd_data
d29 1
a29 1
static bfd_boolean elf32_arm_print_private_bfd_data
d38 1
a38 1
	   const char *, int, struct elf_link_hash_entry *));
d42 1
a42 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
d44 5
a48 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
a56 48
static bfd_boolean elf32_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static asection * elf32_arm_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_arm_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static bfd_boolean elf32_arm_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf32_arm_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf32_arm_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf32_arm_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static struct bfd_hash_entry * elf32_arm_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
#if USE_REL
static void arm_add_to_rel
  PARAMS ((bfd *, bfd_byte *, reloc_howto_type *, bfd_signed_vma));
#endif
static enum elf_reloc_type_class elf32_arm_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf32_arm_object_p
  PARAMS ((bfd *));

#ifndef ELFARM_NABI_C_INCLUDED
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));
bfd_boolean bfd_elf32_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));
#endif

d58 1
a58 1
#define INTERWORK_FLAG(abfd)   (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK)
d81 7
a87 7
static const bfd_vma elf32_arm_plt0_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe52de004,	/* str   lr, [sp, #-4]!     */
    0xe59fe010,	/* ldr   lr, [pc, #16]      */
    0xe08fe00e,	/* add   lr, pc, lr         */
    0xe5bef008	/* ldr   pc, [lr, #8]!      */
  };
d91 7
a97 7
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
 {
   0xe59fc004,	/* ldr   ip, [pc, #4]       */
   0xe08fc00c,	/* add   ip, pc, ip         */
   0xe59cf000,	/* ldr   pc, [ip]           */
   0x00000000	/* offset to symbol in got  */
 };
d108 8
a115 8
  {
    /* Next section.  */
    struct elf32_arm_pcrel_relocs_copied * next;
    /* A section in dynobj.  */
    asection * section;
    /* Number of relocs copied in this section.  */
    bfd_size_type count;
  };
d119 2
a120 2
  {
    struct elf_link_hash_entry root;
d122 3
a124 3
    /* Number of PC relative relocs copied for this symbol.  */
    struct elf32_arm_pcrel_relocs_copied * pcrel_relocs_copied;
  };
d127 1
a127 1
static bfd_boolean elf32_arm_discard_copies
d134 1
a134 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d143 17
a159 17
  {
    /* The main hash table.  */
    struct elf_link_hash_table root;

    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
    bfd_size_type thumb_glue_size;

    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
    bfd_size_type arm_glue_size;

    /* An arbitary input BFD chosen to hold the glue sections.  */
    bfd * bfd_of_glue_owner;

    /* A boolean indicating whether knowledge of the ARM's pipeline
       length should be applied by the linker.  */
    int no_pipeline_knowledge;
  };
a197 1
  bfd_size_type amt = sizeof (struct elf32_arm_link_hash_table);
d199 2
a200 1
  ret = (struct elf32_arm_link_hash_table *) bfd_malloc (amt);
d207 1
a207 1
      free (ret);
d224 1
a224 1
     const char *name;
d234 2
a235 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d242 1
a242 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d246 2
a247 2
    (*_bfd_error_handler) (_("%s: unable to find THUMB glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);
d259 1
a259 1
     const char *name;
d269 2
a270 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d277 1
a277 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d281 2
a282 2
    (*_bfd_error_handler) (_("%s: unable to find ARM glue '%s' for `%s'"),
			   bfd_archive_filename (input_bfd), tmp_name, name);
d324 8
a331 2
#ifndef ELFARM_NABI_C_INCLUDED
bfd_boolean
d347 2
a348 2
      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
				   ARM2THUMB_GLUE_SECTION_NAME);
d352 2
a353 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);
d368 2
a369 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);
d375 1
a375 1
  return TRUE;
d384 1
a384 1
  asection * s;
a386 1
  struct bfd_link_hash_entry * bh;
a387 1
  bfd_vma val;
d399 2
a400 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d407 1
a407 1
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d419 5
a423 5
  bh = NULL;
  val = globals->arm_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);
d438 1
a438 1
  asection *s;
a440 1
  struct bfd_link_hash_entry *bh;
a442 1
  bfd_vma val;
d454 1
a454 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d461 1
a461 1
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);
d470 4
a473 5
  bh = NULL;
  val = hash_table->thumb_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);
a475 1
  myh = (struct elf_link_hash_entry *) bh;
d485 1
a485 2
  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (CHANGE_TO_ARM) + 1);
d491 6
a496 5
  bh = NULL;
  val = hash_table->thumb_glue_size + 4,
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);
d505 3
a507 2
/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */
d509 2
a510 2
bfd_boolean
bfd_elf32_arm_add_glue_sections_to_bfd (abfd, info)
d514 1
d518 2
a519 2
  /* If we are only performing a partial
     link do not bother adding the glue.  */
d521 8
a528 1
    return TRUE;
d544 1
a544 1
	return FALSE;
d562 1
a562 1
	return FALSE;
a566 26
  return TRUE;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em  */

bfd_boolean
bfd_elf32_arm_get_bfd_for_interworking (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocateable)
    return TRUE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

d570 1
a570 1
  return TRUE;
d573 1
a573 1
bfd_boolean
d580 1
a580 1
  Elf_Internal_Rela *internal_relocs = NULL;
d583 3
d593 1
a593 1
    return TRUE;
d608 1
a608 1
    return TRUE;
d618 2
a619 3
      internal_relocs
	= _bfd_elf32_link_read_relocs (abfd, sec, (PTR) NULL,
				       (Elf_Internal_Rela *) NULL, FALSE);
d621 1
a621 2
      if (internal_relocs == NULL)
	goto error_return;
d623 2
a624 2
      irelend = internal_relocs + sec->reloc_count;
      for (irel = internal_relocs; irel < irelend; irel++)
d652 2
d655 24
a678 1
						 (file_ptr) 0, sec->_raw_size))
a721 10

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;

      if (internal_relocs != NULL
	  && elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      internal_relocs = NULL;
d724 1
a724 1
  return TRUE;
d727 6
a732 6
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d734 1
a734 1
  return FALSE;
a735 1
#endif
d810 1
a810 1
  bfd_vma my_offset;
d818 1
a818 1
    return FALSE;
d840 1
a840 1
	  (*_bfd_error_handler)
d842 2
a843 2
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
d845 1
a845 1
	     bfd_archive_filename (input_bfd));
d847 1
a847 1
	  return FALSE;
d853 1
a853 1
      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
d856 1
a856 1
      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
d875 1
a875 1
		  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d881 2
a882 1
  /* Now go back and fix up the original BL insn to point to here.  */
d884 4
a887 7
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
d894 1
a894 1
	      (bfd_vma) insert_thumb_branch (tmp, ret_offset),
d897 1
a897 1
  return TRUE;
d917 1
a917 1
  bfd_vma my_offset;
d925 1
a925 1
    return FALSE;
d945 1
a945 1
	  (*_bfd_error_handler)
d947 2
a948 2
	     bfd_archive_filename (sym_sec->owner), name);
	  (*_bfd_error_handler)
d950 1
a950 1
	     bfd_archive_filename (input_bfd));
d956 1
a956 1
      bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
d959 1
a959 1
      bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
d973 7
a979 7
  ret_offset = (s->output_offset
		+ my_offset
		+ s->output_section->vma
		- (input_section->output_offset
		   + input_section->output_section->vma
		   + offset + addend)
		- 8);
d983 2
a984 1
  bfd_put_32 (output_bfd, (bfd_vma) tmp, hit_data - input_section->vma);
d986 1
a986 1
  return TRUE;
d1005 1
a1005 1
     int		    sym_flags;
d1025 1
a1025 1

d1033 1
a1033 1

d1047 1
a1047 1
#if USE_REL
a1075 1
	  && r_symndx != 0
d1077 1
a1077 1
	      || (h != NULL
d1083 2
a1084 3
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;
	  bfd_boolean skip, relocate;
d1106 17
a1122 2
	  skip = FALSE;
	  relocate = FALSE;
a1123 7
	  outrel.r_offset =
	    _bfd_elf_section_offset (output_bfd, info, input_section,
				     rel->r_offset);
	  if (outrel.r_offset == (bfd_vma) -1)
	    skip = TRUE;
	  else if (outrel.r_offset == (bfd_vma) -2)
	    skip = TRUE, relocate = TRUE;
d1128 4
a1131 1
	    memset (&outrel, 0, sizeof outrel);
d1135 4
a1138 2
	      if ((input_section->flags & SEC_ALLOC) == 0)
		relocate = TRUE;
d1148 1
a1148 1
		  relocate = TRUE;
d1154 4
a1157 2
		  if ((input_section->flags & SEC_ALLOC) == 0)
		    relocate = TRUE;
d1162 5
a1166 3
	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1191 1
a1191 1
		(*_bfd_error_handler) (_("\
d1193 2
a1194 2
				       bfd_archive_filename (input_bfd),
				       h ? h->root.root.string : "(local)");
d1298 1
a1298 1
		    + input_section->output_offset + rel->r_offset);
d1337 1
a1337 1
#if USE_REL
d1360 5
a1364 5
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
d1366 1
a1366 1
	bfd_vma check;
d1369 1
a1369 1
#if USE_REL
d1387 1
a1387 1
	      (*_bfd_error_handler) (_("\
d1389 2
a1390 2
				     bfd_archive_filename (input_bfd),
				     h ? h->root.root.string : "(local)");
d1443 1
a1443 1
	  overflow = TRUE;
a1444 9
#ifndef OLD_ARM_ABI
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  relocation = (relocation + 2) & ~ 3;
#endif
d1449 12
a1468 44
    case R_ARM_THM_PC11:
      /* Thumb B (branch) instruction).  */
      {
	bfd_signed_vma relocation;
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_signed_vma signed_check;

#if USE_REL
	/* Need to refetch addend.  */
	addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	if (addend & ((howto->src_mask + 1) >> 1))
	  {
	    signed_addend = -1;
	    signed_addend &= ~ howto->src_mask;
	    signed_addend |= addend;
	  }
	else
	  signed_addend = addend;
	/* The value in the insn has been right shifted.  We need to
	   undo this, so that we can perform the address calculation
	   in terms of bytes.  */
	signed_addend <<= howto->rightshift;
#endif
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	relocation >>= howto->rightshift;
	signed_check = relocation;
	relocation &= howto->dst_mask;
	relocation |= (bfd_get_16 (input_bfd, hit_data) & (~ howto->dst_mask));

	bfd_put_16 (input_bfd, relocation, hit_data);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  return bfd_reloc_overflow;

	return bfd_reloc_ok;
      }

a1492 6
      /* If we are addressing a Thumb function, we need to adjust the
	 address by one, so that attempts to call the function pointer will
	 correctly interpret it as Thumb code.  */
      if (sym_flags == STT_ARM_TFUNC)
	value += 1;

d1500 2
a1501 2
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);
d1512 2
a1513 2
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);
a1544 7
		  /* If we are addressing a Thumb function, we need to
		     adjust the address by one, so that attempts to
		     call the function pointer will correctly
		     interpret it as Thumb code.  */
		  if (sym_flags == STT_ARM_TFUNC)
		    value |= 1;

d1573 1
a1573 2
		  Elf_Internal_Rela outrel;
		  bfd_byte *loc;
d1582 5
a1586 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d1596 2
a1597 2
				       contents, rel->r_offset, value,
				       (bfd_vma) 0);
d1607 2
a1608 2
				 contents, rel->r_offset, value,
				 (bfd_vma) 0);
d1626 2
a1627 2
			       contents, rel->r_offset, value,
			       (bfd_vma) 0);
d1658 1
a1658 1
#if USE_REL
d1686 2
a1687 2
      bfd_put_16 (abfd, (bfd_vma) upper_insn, address);
      bfd_put_16 (abfd, (bfd_vma) lower_insn, address + 2);
d1715 1
a1715 1
	  addend += increment;
d1732 1
a1732 1
static bfd_boolean
d1735 8
a1742 8
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1744 5
a1748 10
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;

#if !USE_REL
  if (info->relocateable)
    return TRUE;
#endif
a1776 1
#if USE_REL
d1789 1
d1791 5
a1795 3
				  howto,
				  (bfd_signed_vma) (sec->output_offset
						    + sym->st_value));
a1800 1
#endif
a1810 1
#if USE_REL
a1813 39
	  if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;
	      bfd_vma addend, value;

	      if (howto->rightshift)
		{
		  (*_bfd_error_handler)
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

	      value = bfd_get_32 (input_bfd, contents + rel->r_offset);

	      /* Get the (signed) value from the instruction.  */
	      addend = value & howto->src_mask;
	      if (addend & ((howto->src_mask + 1) >> 1))
		{
		  bfd_signed_vma mask;

		  mask = -1;
		  mask &= ~ howto->src_mask;
		  addend |= mask;
		}
	      msec = sec;
	      addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      value = (value & ~ howto->dst_mask) | (addend & howto->dst_mask);
	      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
	    }
#else
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
#endif
a1836 1
		case R_ARM_THM_PC22:
d1839 1
a1839 1
		  (!info->symbolic && h->dynindx != -1)
d1877 2
a1878 4
			(_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
			 bfd_archive_filename (input_bfd),
			 r_type,
			 h->root.root.string,
d1904 1
a1904 1
		return FALSE;
d1940 1
a1940 1
		  return FALSE;
d1946 2
a1947 2
		     rel->r_offset, TRUE)))
		return FALSE;
d1970 1
a1970 1
		return FALSE;
d1976 1
a1976 23
  return TRUE;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (abfd)
     bfd *abfd;
{
  unsigned int mach;
  
  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);

  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  return TRUE;
d1980 1
a1980 1
static bfd_boolean
d1990 4
a1993 4
	  if (flags & EF_ARM_INTERWORK)
	    (*_bfd_error_handler) (_("\
Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
				   bfd_archive_filename (abfd));
d1996 2
a1997 2
Warning: Clearing the interworking flag of %s due to outside request"),
				bfd_archive_filename (abfd));
d2003 1
a2003 1
      elf_flags_init (abfd) = TRUE;
d2006 1
a2006 1
  return TRUE;
d2011 1
a2011 1
static bfd_boolean
d2021 1
a2021 1
    return TRUE;
d2031 2
a2032 2
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	return FALSE;
d2035 2
a2036 2
      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	return FALSE;
d2040 1
a2040 1
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
d2042 1
a2042 1
	  if (out_flags & EF_ARM_INTERWORK)
d2044 2
a2045 3
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
				bfd_get_filename (obfd),
				bfd_archive_filename (ibfd));
d2047 1
a2047 1
	  in_flags &= ~EF_ARM_INTERWORK;
d2051 2
a2052 2
      if ((in_flags & EF_ARM_PIC) != (out_flags & EF_ARM_PIC))
	in_flags &= ~EF_ARM_PIC;
d2056 1
a2056 1
  elf_flags_init (obfd) = TRUE;
d2058 1
a2058 1
  return TRUE;
d2064 1
a2064 1
static bfd_boolean
d2071 2
a2072 2
  bfd_boolean flags_compatible = TRUE;
  bfd_boolean null_input_bfd = TRUE;
d2076 2
a2077 2
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;
d2081 1
a2081 1
    return TRUE;
d2102 1
a2102 1
	return TRUE;
d2104 1
a2104 1
      elf_flags_init (obfd) = TRUE;
d2111 1
a2111 1
      return TRUE;
a2113 5
  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

d2116 1
a2116 1
    return TRUE;
d2127 1
a2127 1
	  null_input_bfd = FALSE;
d2132 1
a2132 1
    return TRUE;
d2138 6
a2143 6
ERROR: %s is compiled for EABI version %d, whereas %s is compiled for version %d"),
			  bfd_archive_filename (ibfd),
			  (in_flags & EF_ARM_EABIMASK) >> 24,
			  bfd_get_filename (obfd),
			  (out_flags & EF_ARM_EABIMASK) >> 24);
      return FALSE;
d2149 1
a2149 1
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
d2152 6
a2157 6
ERROR: %s is compiled for APCS-%d, whereas target %s uses APCS-%d"),
			      bfd_archive_filename (ibfd),
			      in_flags & EF_ARM_APCS_26 ? 26 : 32,
			      bfd_get_filename (obfd),
			      out_flags & EF_ARM_APCS_26 ? 26 : 32);
	  flags_compatible = FALSE;
d2160 1
a2160 1
      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
d2162 7
a2168 12
	  if (in_flags & EF_ARM_APCS_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s passes floats in float registers, whereas %s passes them in integer registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s passes floats in integer registers, whereas %s passes them in float registers"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
d2171 10
a2180 56
      if ((in_flags & EF_ARM_VFP_FLOAT) != (out_flags & EF_ARM_VFP_FLOAT))
	{
	  if (in_flags & EF_ARM_VFP_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses VFP instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s uses FPA instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));
	  else
	    _bfd_error_handler (_("\
ERROR: %s uses Maverick instructions, whereas %s does not"),
				bfd_archive_filename (ibfd),
				bfd_get_filename (obfd));

	  flags_compatible = FALSE;
	}

#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
	{
	  /* We can allow interworking between code that is VFP format
	     layout, and uses either soft float or integer regs for
	     passing floating point arguments and results.  We already
	     know that the APCS_FLOAT flags match; similarly for VFP
	     flags.  */
	  if ((in_flags & EF_ARM_APCS_FLOAT) != 0
	      || (in_flags & EF_ARM_VFP_FLOAT) == 0)
	    {
	      if (in_flags & EF_ARM_SOFT_FLOAT)
		_bfd_error_handler (_("\
ERROR: %s uses software FP, whereas %s uses hardware FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));
	      else
		_bfd_error_handler (_("\
ERROR: %s uses hardware FP, whereas %s uses software FP"),
				    bfd_archive_filename (ibfd),
				    bfd_get_filename (obfd));

	      flags_compatible = FALSE;
	    }
d2185 7
a2191 17
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (in_flags & EF_ARM_INTERWORK)
	    {
	      _bfd_error_handler (_("\
Warning: %s supports interworking, whereas %s does not"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	  else
	    {
	      _bfd_error_handler (_("\
Warning: %s does not support interworking, whereas %s does"),
				  bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	}
d2199 1
a2199 1
static bfd_boolean
d2225 1
a2225 1
      if (flags & EF_ARM_INTERWORK)
d2228 2
a2229 2
      if (flags & EF_ARM_APCS_26)
	fprintf (file, " [APCS-26]");
d2231 1
a2231 1
	fprintf (file, " [APCS-32]");
d2233 1
a2233 8
      if (flags & EF_ARM_VFP_FLOAT)
	fprintf (file, _(" [VFP float format]"));
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
      else
	fprintf (file, _(" [FPA float format]"));

      if (flags & EF_ARM_APCS_FLOAT)
d2236 1
a2236 1
      if (flags & EF_ARM_PIC)
d2239 1
a2239 1
      if (flags & EF_ARM_NEW_ABI)
d2242 1
a2242 1
      if (flags & EF_ARM_OLD_ABI)
d2245 1
a2245 1
      if (flags & EF_ARM_SOFT_FLOAT)
d2248 2
a2249 4
      flags &= ~(EF_ARM_INTERWORK | EF_ARM_APCS_26 | EF_ARM_APCS_FLOAT
		 | EF_ARM_PIC | EF_ARM_NEW_ABI | EF_ARM_OLD_ABI
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
a2262 18
    case EF_ARM_EABI_VER2:
      fprintf (file, _(" [Version2 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      if (flags & EF_ARM_DYNSYMSUSESEGIDX)
	fprintf (file, _(" [dynamic symbols use segment index]"));

      if (flags & EF_ARM_MAPSYMSFIRST)
	fprintf (file, _(" [mapping symbols precede others]"));

      flags &= ~(EF_ARM_SYMSARESORTED | EF_ARM_DYNSYMSUSESEGIDX
		 | EF_ARM_MAPSYMSFIRST);
      break;

d2283 1
a2283 1
  return TRUE;
d2313 2
a2314 2
elf32_arm_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
d2344 9
a2352 2
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

d2358 1
a2358 1
static bfd_boolean
d2366 1
a2366 1
  return TRUE;
d2371 1
a2371 1
static bfd_boolean
d2373 4
a2376 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2378 8
a2385 8
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sgot, *srelgot, *sreloc;
  bfd_vma *local_got_offsets;
d2388 1
a2388 1
    return TRUE;
d2425 1
a2425 1
		return FALSE;
d2455 1
a2455 1
						    (SEC_ALLOC
d2462 1
a2462 1
		      return FALSE;
d2477 1
a2477 1
		    return FALSE;
d2483 1
a2483 1
	        /* This is a global offset table entry for a local
d2487 2
a2488 2
		    bfd_size_type size;
		    unsigned int i;
d2490 1
a2490 2
		    size = symtab_hdr->sh_info;
		    size *= sizeof (bfd_vma);
d2493 1
a2493 1
		      return FALSE;
d2515 1
a2515 1
	  case R_ARM_PLT32:
d2565 1
a2565 1
		      return FALSE;
d2568 1
a2568 1
			        && strcmp (bfd_get_section_name (abfd, sec),
d2584 1
a2584 1
			  return FALSE;
a2585 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d2612 2
a2613 1
			     bfd_alloc (dynobj, (bfd_size_type) sizeof * p));
d2615 1
a2615 1
			  return FALSE;
d2631 1
a2631 1
            return FALSE;
d2638 1
a2638 1
            return FALSE;
d2643 1
a2643 1
  return TRUE;
d2650 1
a2650 1
static bfd_boolean
d2653 13
a2665 13
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  bfd_boolean found;
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;
d2671 1
a2671 1
    return TRUE;
d2677 1
a2677 1
    return FALSE;
d2680 1
a2680 1
    return TRUE;
d2683 1
a2683 1
    return FALSE;
d2720 1
a2720 1
    return FALSE;
d2726 1
a2726 1
  return TRUE;
d2735 1
a2735 1
static bfd_boolean
a2762 6
      /* If we link a program (not a DSO), we'll get rid of unnecessary
	 PLT entries; we point to the actual symbols -- even for pic
	 relocs, because a program built with -fpic should have the same
	 result as one built without -fpic, specifically considering weak
	 symbols.
	 FIXME: m68k and i386 differ here, for unclear reasons.  */
d2764 2
a2765 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d2768 4
a2771 4
	     file, but the symbol was not defined by a dynamic object.
	     In such a case, we don't actually need to build a
	     procedure linkage table, and we can just do a PC32 reloc
	     instead.  */
d2773 1
a2773 2
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	  return TRUE;
d2780 1
a2780 1
	    return FALSE;
d2820 1
a2820 1
      return TRUE;
d2832 1
a2832 1
      return TRUE;
d2843 1
a2843 1
    return TRUE;
d2883 1
a2883 1
	return FALSE;
d2893 1
a2893 1
  return TRUE;
d2898 1
a2898 1
static bfd_boolean
d2900 1
a2900 1
     bfd * output_bfd ATTRIBUTE_UNUSED;
d2905 3
a2907 2
  bfd_boolean plt;
  bfd_boolean relocs;
d2947 3
a2949 2
  plt = FALSE;
  relocs = FALSE;
d2953 1
a2953 1
      bfd_boolean strip;
d2962 1
a2962 1
      strip = FALSE;
d2970 1
a2970 1
	      strip = TRUE;
d2975 1
a2975 1
	      plt = TRUE;
d2991 1
a2991 1
	      strip = TRUE;
d2995 2
d3000 19
a3018 1
		relocs = TRUE;
d3033 9
a3041 1
	  _bfd_strip_section_from_output (info, s);
d3048 1
a3048 1
	return FALSE;
d3058 1
a3058 4
#define add_dynamic_entry(TAG, VAL) \
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))

      if (!info->shared)
d3060 2
a3061 2
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
d3066 5
a3070 5
	  if (   !add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
d3075 5
a3079 4
	  if (   !add_dynamic_entry (DT_REL, 0)
	      || !add_dynamic_entry (DT_RELSZ, 0)
	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
	    return FALSE;
d3082 1
a3082 1
      if ((info->flags & DF_TEXTREL) != 0)
d3084 2
a3085 2
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
a3088 1
#undef add_synamic_entry
d3090 1
a3090 1
  return TRUE;
d3100 1
a3100 1
static bfd_boolean
a3106 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf32_arm_link_hash_entry *) h->root.root.u.i.link;

d3109 1
a3109 1
    return TRUE;
d3114 1
a3114 1
  return TRUE;
d3120 1
a3120 1
static bfd_boolean
d3138 1
a3138 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3188 3
a3190 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3211 1
a3211 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3221 1
a3221 1
		      + (h->got.offset &~ (bfd_vma) 1));
d3237 4
a3240 2
      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3246 1
a3246 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3261 4
a3264 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d3272 1
a3272 1
  return TRUE;
d3277 1
a3277 1
static bfd_boolean
a3357 25

	      /* Set the bottom bit of DT_INIT/FINI if the
		 corresponding function is Thumb.  */
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      /* If it wasn't set by elf_bfd_final_link
		 then there is nothing to ajdust.  */
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry * eh;

		  eh = elf_link_hash_lookup (elf_hash_table (info), name,
					     FALSE, FALSE, TRUE);
		  if (eh != (struct elf_link_hash_entry *) NULL
		      && ELF_ST_TYPE (eh->type) == STT_ARM_TFUNC)
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
d3390 1
a3390 1
  return TRUE;
a3405 41
static enum elf_reloc_type_class
elf32_arm_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_ARM_RELATIVE:
      return reloc_class_relative;
    case R_ARM_JUMP_SLOT:
      return reloc_class_plt;
    case R_ARM_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static bfd_boolean elf32_arm_section_flags           PARAMS ((flagword *, Elf_Internal_Shdr *));
static void        elf32_arm_final_write_processing  PARAMS ((bfd *, bfd_boolean));

/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

void
elf32_arm_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

d3410 2
a3411 2
#define bfd_elf32_bfd_copy_private_bfd_data	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	elf32_arm_merge_private_bfd_data
d3415 1
a3415 1
#define bfd_elf32_bfd_reloc_type_lookup		elf32_arm_reloc_type_lookup
d3422 1
a3422 1
#define elf_backend_relocate_section		elf32_arm_relocate_section
a3428 4
#define elf_backend_reloc_type_class		elf32_arm_reloc_type_class
#define elf_backend_object_p			elf32_arm_object_p
#define elf_backend_section_flags		elf32_arm_section_flags
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
a3433 3
#if !USE_REL
#define elf_backend_rela_normal     1
#endif
a3438 1

@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
a86 6
static bfd_boolean allocate_dynrelocs 
  PARAMS ((struct elf_link_hash_entry *h, PTR inf));
static bfd_boolean create_got_section 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
static bfd_boolean elf32_arm_create_dynamic_sections 
  PARAMS ((bfd * dynobj, struct bfd_link_info * info));
a121 6
#ifdef FOUR_WORD_PLT

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 16

d129 1
a129 32
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  };

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [PLT_ENTRY_SIZE / 4] =
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };

#else

/* The size in bytes of the special first entry in the procedure
   linkage table.  */
#define PLT_HEADER_SIZE 20

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [PLT_HEADER_SIZE / 4] =
d131 4
a134 5
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
d140 6
a145 7
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };

#endif
d155 1
a155 1
struct elf32_arm_relocs_copied
d158 1
a158 1
    struct elf32_arm_relocs_copied * next;
d171 1
a171 1
    struct elf32_arm_relocs_copied * relocs_copied;
d174 4
d195 1
a195 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d198 1
a198 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d201 1
a201 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
a206 12

    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;

    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
d234 1
a234 1
    ret->relocs_copied = NULL;
a238 109
/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf32_arm_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
  return TRUE;
}

/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");

  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;

	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->relocs_copied;
	}

      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a258 7
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
a262 1
  ret->sym_sec.abfd = NULL;
d567 1
a567 1
  if (info->relocatable)
d623 1
a623 1
  if (info->relocatable)
d655 1
a655 1
  if (link_info->relocatable)
d682 2
a683 2
	= _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);
d795 1
a795 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
a1124 29
    case R_ARM_PLT32:
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	return bfd_reloc_ok;

      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
	  && h != NULL
	  && splt != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset);
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
	}

d1128 7
a1134 8
	  && (input_section->flags & SEC_ALLOC)
	  && (r_type != R_ARM_REL32
	      || !SYMBOL_CALLS_LOCAL (info, h))
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
	  && r_type != R_ARM_PLT32)
d1175 7
a1181 7
	  else if (h != NULL
		   && h->dynindx != -1
		   && (!info->shared
		       || !info->symbolic
		       || (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d1184 15
a1198 3
	      /* This symbol is local, or marked to become local.  */
	      relocate = TRUE;
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
a1220 1
	case R_ARM_PLT32:
a1607 1
	  bfd_boolean dyn;
a1610 1
	  dyn = globals->root.dynamic_sections_created;
d1612 3
a1614 5
	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
d1689 30
d1841 1
a1841 1
  if (info->relocatable)
d1873 1
a1873 1
      if (info->relocatable)
d1875 1
a1875 1
	  /* This is a relocatable link.  We don't have to change
d1946 1
a1946 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1951 5
a1955 2
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
d1957 2
a1958 6
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  
	  if (unresolved_reloc || relocation != 0)
d1960 4
a1971 2
	        case R_ARM_PLT32:

d1974 1
a1974 1
			  (!info->symbolic && h->dynindx != -1)
a1976 1
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
d1986 1
a1986 1
	            relocation = 0;
d1990 1
a1990 1
	          relocation = 0;
d1994 2
a1995 4
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
d1997 9
a2005 3
	                  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
	            relocation = 0;
d2009 10
a2018 8
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%s: warning: unresolvable relocation %d against symbol `%s' from %s section"),
		       bfd_archive_filename (input_bfd),
		       r_type,
		       h->root.root.string,
		       bfd_get_section_name (input_bfd, input_section));
		  break;
d2020 23
d2232 1
d2283 11
a2293 29
  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatibility.  Do not short-circuit
     dynamic objects; their section list may be emptied by
    elf_link_add_object_symbols.

    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;
      bfd_boolean only_data_sections = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

	      null_input_bfd = FALSE;
	      break;
	    }
a2294 3

      if (null_input_bfd || only_data_sections)
	return TRUE;
d2296 2
d2366 1
a2366 1
ERROR: %s does not use Maverick instructions, whereas %s does"),
d2448 1
a2448 1
      /* The following flag bits are GNU extensions and not part of the
d2611 1
a2611 70
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GOT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_ARM_ABS32:
      case R_ARM_REL32:
      case R_ARM_PC24:
      case R_ARM_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf32_arm_link_hash_entry *eh;
	    struct elf32_arm_relocs_copied **pp;
	    struct elf32_arm_relocs_copied *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		|| ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
	      {
		eh = (struct elf32_arm_link_hash_entry *) h;

		for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		     pp = &p->next)
		if (p->section == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	      }
	  }
	break;

      default:
	break;
      }

d2630 1
a2630 1
  asection *sreloc;
a2631 1
  struct elf32_arm_link_hash_table *htab;
d2633 1
a2633 1
  if (info->relocatable)
d2636 1
a2636 2
  htab = elf32_arm_hash_table (info);
  sreloc = NULL;
d2661 18
d2683 29
d2714 12
a2725 1
		h->got.refcount++;
d2729 3
a2731 5
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
d2734 1
d2737 3
a2739 4
		    size *= (sizeof (bfd_signed_vma) + sizeof(char));
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
d2741 3
a2743 1
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
d2745 12
a2756 1
		local_got_refcounts[r_symndx] += 1;
d2758 2
d2762 14
a2775 9
	  case R_ARM_GOTOFF:
	  case R_ARM_GOTPC:
	    if (htab->sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
a2780 25
	  case R_ARM_PLT32:
	    if (h != NULL)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		if (!info->shared)
		  h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

		/* We may need a .plt entry if the function this reloc
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_PC24
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_PLT32)
		  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
		h->plt.refcount += 1;
	      }

d2792 1
a2792 1
               relocs_copied field of the hash table entry.  */
d2794 5
a2798 8
		&& (sec->flags & SEC_ALLOC) != 0
		&& ((ELF32_R_TYPE (rel->r_info) != R_ARM_PC24
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_PLT32
		     && ELF32_R_TYPE (rel->r_info) != R_ARM_REL32)
		    || (h != NULL
			&& (! info->symbolic
			    || (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0))))
a2799 2
		struct elf32_arm_relocs_copied *p, **head;

d2833 2
a2834 2

		    elf_section_data (sec)->sreloc = sreloc;
d2837 11
a2847 3
		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
d2849 9
a2857 23
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */
		    
		    asection *s;
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
		    if (s == NULL)
		      return FALSE;
		    
		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
		  }
		
		p = *head;
		if (p == NULL || p->section != sec)
		  {
		    bfd_size_type amt = sizeof *p;
		    p = bfd_alloc (htab->root.dynobj, amt);
d2859 12
a2870 5
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->section = sec;
		    p->count = 0;
a2871 4
		
		if (ELF32_R_TYPE (rel->r_info) == R_ARM_ABS32
		    || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
		  p->count += 1;
d2878 1
a2878 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2885 1
a2885 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d3011 8
a3018 4
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d3021 5
a3025 5
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
d3027 1
d3030 44
a3075 7
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;
a3149 171
/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_HEADER_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rel);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rel);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_arm_link_hash_entry *) h;
  if (eh->relocs_copied == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* Discard relocs on undefined weak syms with non-default
         visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->relocs_copied = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->relocs_copied = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->relocs_copied; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->section)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rel);
    }

  return TRUE;
}

a3160 2
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;
a3161 1
  htab = elf32_arm_hash_table (info);
d3168 1
a3168 1
      if (info->executable)
d3176 20
a3195 68

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_arm_relocs_copied *p;

	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->section)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rel);
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rel);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d3283 1
a3283 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d3320 27
a3369 1
      bfd_vma got_displacement;
d3385 1
a3385 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
a3391 12
      /* Calculate the displacement between the PLT slot and the
	 entry in the GOT.  */
      got_displacement = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset
			  - splt->output_section->vma
			  - splt->output_offset
			  - h->plt.offset
			  - 8);

      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

d3393 1
a3393 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
d3395 1
a3395 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
d3397 1
a3397 1
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
d3399 8
a3406 4
#ifdef FOUR_WORD_PLT
      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		  splt->contents + h->plt.offset + 12);
#endif
d3413 1
a3413 1
      
d3454 4
a3457 5
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
d3459 3
a3461 5
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	}
a3463 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
d3596 1
a3596 1
		 then there is nothing to adjust.  */
a3616 9
	  bfd_vma got_displacement;

	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

a3620 7
#ifdef FOUR_WORD_PLT
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
#else
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
#endif
a3701 3
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
a3702 1
#endif
d3718 1
a3718 1
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
a3726 1
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol
a3727 1
#define elf_backend_can_refcount    1
d3737 1
@


