head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.50
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.46
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.48
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.40
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.44
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.42
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.38
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.36
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.34
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.32
	OPENBSD_5_0:1.1.1.3.0.30
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.28
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.26
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.22
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.24
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.20
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.45.59;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.45.59;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.28.20;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* vms-tir.c -- BFD back-end for VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.

   TIR record handling functions
   ETIR record handling functions

   go and read the openVMS linker manual (esp. appendix B)
   if you don't know what's going on here :-)

   Written by Klaus K"ampf (kkaempf@@rmi.de)

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


/* The following type abbreviations are used:

	cs	counted string (ascii string with length byte)
	by	byte (1 byte)
	sh	short (2 byte, 16 bit)
	lw	longword (4 byte, 32 bit)
	qw	quadword (8 byte, 64 bit)
	da	data stream  */

#include <ctype.h>

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libbfd.h"

#include "vms.h"

static void image_set_ptr PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr PARAMS ((bfd *abfd, uquad offset));
static void image_dump PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q PARAMS ((bfd *abfd, uquad value));

/*-----------------------------------------------------------------------------*/

static int
check_section (abfd, size)
     bfd *abfd;
     int size;
{
  int offset;

  offset = PRIV(image_ptr) - PRIV(image_section)->contents;
  if ((bfd_size_type) (offset + size) > PRIV(image_section)->_raw_size)
    {
      PRIV(image_section)->contents = bfd_realloc (PRIV(image_section)->contents, offset + size);
      if (PRIV(image_section)->contents == 0)
	{
	  (*_bfd_error_handler) (_("No Mem !"));
	  return -1;
	}
      PRIV(image_section)->_raw_size = offset + size;
      PRIV(image_ptr) = PRIV(image_section)->contents + offset;
    }

  return 0;
}

/* routines to fill sections contents during tir/etir read */

/* Initialize image buffer pointer to be filled  */

static void
image_set_ptr (abfd, psect, offset)
     bfd *abfd;
     int psect;
     uquad offset;
{
#if VMS_DEBUG
  _bfd_vms_debug (4, "image_set_ptr (%d=%s, %d)\n",
		psect, PRIV(sections)[psect]->name, offset);
#endif

  PRIV(image_ptr) = PRIV(sections)[psect]->contents + offset;
  PRIV(image_section) = PRIV(sections)[psect];
  return;
}


/* Increment image buffer pointer by offset  */

static void
image_inc_ptr (abfd, offset)
     bfd *abfd;
     uquad offset;
{
#if VMS_DEBUG
  _bfd_vms_debug (4, "image_inc_ptr (%d)\n", offset);
#endif

  PRIV(image_ptr) += offset;

  return;
}


/* Dump multiple bytes to section image  */

static void
image_dump (abfd, ptr, size, offset)
    bfd *abfd;
    unsigned char *ptr;
    int size;
    int offset ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (8, "image_dump from (%p, %d) to (%p)\n", ptr, size, PRIV(image_ptr));
  _bfd_hexdump (9, ptr, size, offset);
#endif

  if (PRIV(is_vax) && check_section (abfd, size))
    return;

  while (size-- > 0)
    *PRIV(image_ptr)++ = *ptr++;
  return;
}


/* Write byte to section image  */

static void
image_write_b (abfd, value)
     bfd *abfd;
     unsigned int value;
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_b(%02x)\n", (int)value);
#endif

  if (PRIV(is_vax) && check_section (abfd, 1))
    return;

  *PRIV(image_ptr)++ = (value & 0xff);
  return;
}


/* Write 2-byte word to image  */

static void
image_write_w (abfd, value)
     bfd *abfd;
     unsigned int value;
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_w(%04x)\n", (int)value);
#endif

  if (PRIV(is_vax) && check_section (abfd, 2))
    return;

  bfd_putl16 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 2;

  return;
}


/* Write 4-byte long to image  */

static void
image_write_l (abfd, value)
     bfd *abfd;
     unsigned long value;
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_l (%08lx)\n", value);
#endif

  if (PRIV(is_vax) && check_section (abfd, 4))
    return;

  bfd_putl32 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 4;

  return;
}


/* Write 8-byte quad to image  */

static void
image_write_q (abfd, value)
     bfd *abfd;
     uquad value;
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_q (%016lx)\n", value);
#endif

  if (PRIV(is_vax) && check_section (abfd, 8))
    return;

  bfd_putl64 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 8;

  return;
}


#define HIGHBIT(op) ((op & 0x80000000L) == 0x80000000L)

/* etir_sta
  
   vms stack commands
  
   handle sta_xxx commands in etir section
   ptr points to data area in record
  
   see table B-8 of the openVMS linker manual  */

static boolean
etir_sta (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
{

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sta %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  switch (cmd)
    {
      /* stack */

      /* stack global
	   arg: cs	symbol name

	   stack 32 bit value of symbol (high bits set to 0)  */

      case ETIR_S_C_STA_GBL:
	{
	  char *name;
	  vms_symbol_entry *entry;

	  name = _bfd_vms_save_counted_string (ptr);
	  entry = (vms_symbol_entry *)
		  bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	  if (entry == (vms_symbol_entry *)NULL)
	    {
#if VMS_DEBUG
	      _bfd_vms_debug (3, "ETIR_S_C_STA_GBL: no symbol \"%s\"\n", name);
#endif
	      _bfd_vms_push (abfd, (uquad)0, -1);
	    }
	  else
	    {
	      _bfd_vms_push (abfd, (uquad)(entry->symbol->value), -1);
	    }
	}
      break;

	/* stack longword
	   arg: lw	value

	   stack 32 bit value, sign extend to 64 bit  */

      case ETIR_S_C_STA_LW:
	_bfd_vms_push (abfd, (uquad)bfd_getl32 (ptr), -1);
      break;

	/* stack global
	   arg: qw	value

	   stack 64 bit value of symbol	 */

      case ETIR_S_C_STA_QW:
	_bfd_vms_push (abfd, (uquad)bfd_getl64(ptr), -1);
      break;

	/* stack psect base plus quadword offset
	   arg: lw	section index
	  	qw	signed quadword offset (low 32 bits)

	   stack qw argument and section index
	   (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB)  */

      case ETIR_S_C_STA_PQ:
  	{
	  uquad dummy;
	  unsigned int psect;

	  psect = bfd_getl32 (ptr);
	  if (psect >= PRIV(section_count))
	    {
	      (*_bfd_error_handler) (_("Bad section index in ETIR_S_C_STA_PQ"));
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  dummy = bfd_getl64 (ptr+4);
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

	/* all not supported  */

      case ETIR_S_C_STA_LI:
      case ETIR_S_C_STA_MOD:
      case ETIR_S_C_STA_CKARG:

	(*_bfd_error_handler) (_("Unsupported STA cmd %d"), cmd);
	return false;
      break;

      default:
	(*_bfd_error_handler) (_("Reserved STA cmd %d"), cmd);
	return false;
      break;
    }
#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sta true\n");
#endif
  return true;
}


/*
   etir_sto
  
   vms store commands
  
   handle sto_xxx commands in etir section
   ptr points to data area in record
  
   see table B-9 of the openVMS linker manual  */

static boolean
etir_sto (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
{
  uquad dummy;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sto %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  switch (cmd)
    {

      /* store byte: pop stack, write byte
	 arg: -  */

    case ETIR_S_C_STO_B:
      dummy = _bfd_vms_pop (abfd, &psect);
#if 0
      if (is_share)		/* FIXME */
	(*_bfd_error_handler) ("ETIR_S_C_STO_B: byte fixups not supported");
#endif
      image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
      break;

      /* store word: pop stack, write word
	 arg: -  */

    case ETIR_S_C_STO_W:
      dummy = _bfd_vms_pop (abfd, &psect);
#if 0
      if (is_share)		/* FIXME */
	(*_bfd_error_handler) ("ETIR_S_C_STO_B: word fixups not supported");
#endif
      image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
      break;

      /* store longword: pop stack, write longword
	 arg: -  */

    case ETIR_S_C_STO_LW:
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy += (PRIV(sections)[psect])->vma;
      image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;

      /* store quadword: pop stack, write quadword
	 arg: -  */

    case ETIR_S_C_STO_QW:
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy += (PRIV(sections)[psect])->vma;
      image_write_q (abfd, dummy);		/* FIXME: check top bits */
      break;

      /* store immediate repeated: pop stack for repeat count
	 arg: lw	byte count
	 da	data  */

    case ETIR_S_C_STO_IMMR:
      {
	unsigned long size;

	size = bfd_getl32 (ptr);
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0L)
	  image_dump (abfd, ptr+4, size, 0);
      }
      break;

      /* store global: write symbol value
	 arg: cs	global symbol name  */

    case ETIR_S_C_STO_GBL:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
	  {
	    (*_bfd_error_handler) (_("ETIR_S_C_STO_GBL: no symbol \"%s\""),
				   name);
	    return false;
	  }
	else
	  image_write_q (abfd, (uquad)(entry->symbol->value));	/* FIXME, reloc */
      }
      break;

      /* store code address: write address of entry point
	 arg: cs	global symbol name (procedure)  */

    case ETIR_S_C_STO_CA:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
	  {
	    (*_bfd_error_handler) (_("ETIR_S_C_STO_CA: no symbol \"%s\""),
				   name);
	    return false;
	  }
	else
	  image_write_q (abfd, (uquad)(entry->symbol->value));	/* FIXME, reloc */
      }
      break;

      /* not supported  */

    case ETIR_S_C_STO_RB:
    case ETIR_S_C_STO_AB:
      (*_bfd_error_handler) (_("ETIR_S_C_STO_RB/AB: Not supported"));
      break;

    /* store offset to psect: pop stack, add low 32 bits to base of psect
       arg: -  */

    case ETIR_S_C_STO_OFF:
      {
	uquad q;
	int psect;

	q = _bfd_vms_pop (abfd, &psect);
	q += (PRIV(sections)[psect])->vma;
	image_write_q (abfd, q);
      }
      break;

      /* store immediate
	 arg: lw	count of bytes
	 da	data  */

    case ETIR_S_C_STO_IMM:
      {
	int size;

	size = bfd_getl32 (ptr);
	image_dump (abfd, ptr+4, size, 0);
      }
      break;

      /* this code is 'reserved to digital' according to the openVMS linker manual,
	 however it is generated by the DEC C compiler and defined in the include file.
	 FIXME, since the following is just a guess
	 store global longword: store 32bit value of symbol
	 arg: cs	symbol name  */

    case ETIR_S_C_STO_GBL_LW:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
	  {
#if VMS_DEBUG
	    _bfd_vms_debug (3, "ETIR_S_C_STO_GBL_LW: no symbol \"%s\"\n", name);
#endif
	    image_write_l (abfd, (unsigned long)0);	/* FIXME, reloc */
	  }
	else
	  image_write_l (abfd, (unsigned long)(entry->symbol->value));	/* FIXME, reloc */
      }
      break;

      /* not supported  */

    case ETIR_S_C_STO_LP_PSB:
      (*_bfd_error_handler) (_("ETIR_S_C_STO_LP_PSB: Not supported"));
      break;

    /* */

    case ETIR_S_C_STO_HINT_GBL:
      (*_bfd_error_handler) (_("ETIR_S_C_STO_HINT_GBL: not implemented"));
      break;

    /* */

    case ETIR_S_C_STO_HINT_PS:
      (*_bfd_error_handler) (_("ETIR_S_C_STO_HINT_PS: not implemented"));
      break;

    default:
      (*_bfd_error_handler) (_("Reserved STO cmd %d"), cmd);
      break;
    }

  return true;
}

/* stack operator commands
   all 32 bit signed arithmetic
   all word just like a stack calculator
   arguments are popped from stack, results are pushed on stack
  
   see table B-10 of the openVMS linker manual  */

static boolean
etir_opr (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr ATTRIBUTE_UNUSED;
{
  long op1, op2;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_opr %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  switch (cmd)
    {
      /* operation */

      /* no-op  */

    case ETIR_S_C_OPR_NOP:
      break;

      /* add  */

    case ETIR_S_C_OPR_ADD:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 + op2), -1);
      break;

      /* subtract  */

    case ETIR_S_C_OPR_SUB:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op2 - op1), -1);
      break;

      /* multiply  */

    case ETIR_S_C_OPR_MUL:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 * op2), -1);
      break;

      /* divide  */

    case ETIR_S_C_OPR_DIV:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      if (op2 == 0)
	_bfd_vms_push (abfd, (uquad)0L, -1);
      else
	_bfd_vms_push (abfd, (uquad)(op2 / op1), -1);
      break;

      /* logical and  */

    case ETIR_S_C_OPR_AND:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 & op2), -1);
      break;

      /* logical inclusive or	 */

    case ETIR_S_C_OPR_IOR:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 | op2), -1);
      break;

      /* logical exclusive or  */

    case ETIR_S_C_OPR_EOR:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 ^ op2), -1);
      break;

      /* negate  */

    case ETIR_S_C_OPR_NEG:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(-op1), -1);
      break;

      /* complement  */

    case ETIR_S_C_OPR_COM:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad)(op1 ^ -1L), -1);
      break;

      /* insert field  */

    case ETIR_S_C_OPR_INSV:
      (void)_bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_INSV: Not supported"));
      break;

    /* arithmetic shift  */

    case ETIR_S_C_OPR_ASH:
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
      if (op2 < 0)		/* shift right */
	op1 >>= -op2;
      else			/* shift left */
	op1 <<= op2;
      _bfd_vms_push (abfd, (uquad)op1, -1);
      break;

      /* unsigned shift  */

    case ETIR_S_C_OPR_USH:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_USH: Not supported"));
      break;

      /* rotate  */

    case ETIR_S_C_OPR_ROT:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_ROT: Not supported"));
      break;

      /* select  */

    case ETIR_S_C_OPR_SEL:
      if ((long)_bfd_vms_pop (abfd, NULL) & 0x01L)
	(void)_bfd_vms_pop (abfd, NULL);
      else
	{
	  op1 = (long)_bfd_vms_pop (abfd, NULL);
	  (void)_bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad)op1, -1);
	}
      break;

      /* redefine symbol to current location  */

    case ETIR_S_C_OPR_REDEF:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_REDEF: Not supported"));
      break;

      /* define a literal  */

    case ETIR_S_C_OPR_DFLIT:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_DFLIT: Not supported"));
      break;

    default:
      (*_bfd_error_handler) (_("Reserved OPR cmd %d"), cmd);
      break;
    }

  return true;
}


/* control commands
  
   see table B-11 of the openVMS linker manual  */

static boolean
etir_ctl (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
{
  uquad	 dummy;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_ctl %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  switch (cmd)
    {
      /* set relocation base: pop stack, set image location counter
	 arg: -  */

    case ETIR_S_C_CTL_SETRB:
      dummy = _bfd_vms_pop (abfd, &psect);
      image_set_ptr (abfd, psect, dummy);
      break;

      /* augment relocation base: increment image location counter by offset
	 arg: lw	offset value  */

    case ETIR_S_C_CTL_AUGRB:
      dummy = bfd_getl32 (ptr);
      image_inc_ptr (abfd, dummy);
      break;

      /* define location: pop index, save location counter under index
	 arg: -  */

    case ETIR_S_C_CTL_DFLOC:
      dummy = _bfd_vms_pop (abfd, NULL);
      /* FIXME */
      break;

      /* set location: pop index, restore location counter from index
	 arg: -  */

    case ETIR_S_C_CTL_STLOC:
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME */
      break;

      /* stack defined location: pop index, push location counter from index
	 arg: -  */

    case ETIR_S_C_CTL_STKDL:
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME */
      break;

    default:
      (*_bfd_error_handler) (_("Reserved CTL cmd %d"), cmd);
      break;
    }
  return true;
}


/* store conditional commands
  
   see table B-12 and B-13 of the openVMS linker manual  */

static boolean
etir_stc (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr ATTRIBUTE_UNUSED;
{

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_stc %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  switch (cmd)
    {
      /* 200 Store-conditional Linkage Pair
	 arg:  */

    case ETIR_S_C_STC_LP:
      (*_bfd_error_handler) (_("ETIR_S_C_STC_LP: not supported"));
      break;

      /* 201 Store-conditional Linkage Pair with Procedure Signature
	 arg:	lw	linkage index
	 cs	procedure name
	 by	signature length
	 da	signature  */

    case ETIR_S_C_STC_LP_PSB:
      image_inc_ptr (abfd, 16);	/* skip entry,procval */
      break;

      /* 202 Store-conditional Address at global address
	 arg:	lw	linkage index
	 cs	global name  */

    case ETIR_S_C_STC_GBL:
      (*_bfd_error_handler) (_("ETIR_S_C_STC_GBL: not supported"));
      break;

      /* 203 Store-conditional Code Address at global address
	 arg:	lw	linkage index
	 cs	procedure name  */

    case ETIR_S_C_STC_GCA:
      (*_bfd_error_handler) (_("ETIR_S_C_STC_GCA: not supported"));
      break;

      /* 204 Store-conditional Address at psect + offset
	 arg:	lw	linkage index
	 lw	psect index
	 qw	offset  */

    case ETIR_S_C_STC_PS:
      (*_bfd_error_handler) (_("ETIR_S_C_STC_PS: not supported"));
      break;

      /* 205 Store-conditional NOP at address of global
	 arg:  */

    case ETIR_S_C_STC_NOP_GBL:

      /* 206 Store-conditional NOP at pect + offset
	 arg:  */

    case ETIR_S_C_STC_NOP_PS:

      /* 207 Store-conditional BSR at global address
	 arg:  */

    case ETIR_S_C_STC_BSR_GBL:

      /* 208 Store-conditional BSR at pect + offset
	 arg:  */

    case ETIR_S_C_STC_BSR_PS:

      /* 209 Store-conditional LDA at global address
	 arg:  */

    case ETIR_S_C_STC_LDA_GBL:

      /* 210 Store-conditional LDA at psect + offset
	 arg:  */

    case ETIR_S_C_STC_LDA_PS:

      /* 211 Store-conditional BSR or Hint at global address
	 arg:  */

    case ETIR_S_C_STC_BOH_GBL:

      /* 212 Store-conditional BSR or Hint at pect + offset
	 arg:  */

    case ETIR_S_C_STC_BOH_PS:

      /* 213 Store-conditional NOP,BSR or HINT at global address
	 arg:  */

    case ETIR_S_C_STC_NBH_GBL:

      /* 214 Store-conditional NOP,BSR or HINT at psect + offset
	 arg:  */

    case ETIR_S_C_STC_NBH_PS:
/* FIXME     (*_bfd_error_handler) ("ETIR_S_C_STC_xx: (%d) not supported", cmd); */
      break;

    default:
#if VMS_DEBUG
      _bfd_vms_debug (3,  "Reserved STC cmd %d", cmd);
#endif
      break;
    }
  return true;
}


static asection *
new_section (abfd, idx)
     bfd *abfd ATTRIBUTE_UNUSED;
     int idx;
{
  asection *section;
  char sname[16];
  char *name;

#if VMS_DEBUG
  _bfd_vms_debug (5,  "new_section %d\n", idx);
#endif
  sprintf (sname, SECTION_NAME_TEMPLATE, idx);

  name = bfd_malloc (strlen (sname) + 1);
  if (name == 0)
    return 0;
  strcpy (name, sname);

  section = bfd_malloc (sizeof (asection));
  if (section == 0)
    {
#if VMS_DEBUG
      _bfd_vms_debug (6,  "bfd_make_section (%s) failed", name);
#endif
      return 0;
    }

  section->_raw_size = 0;
  section->vma = 0;
  section->contents = 0;
  section->_cooked_size = 0;
  section->name = name;
  section->index = idx;

  return section;
}


static int
alloc_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
{
#if VMS_DEBUG
  _bfd_vms_debug (4,  "alloc_section %d\n", idx);
#endif

  PRIV(sections) = ((asection **)
		    bfd_realloc (PRIV(sections), (idx+1) * sizeof (asection *)));
  if (PRIV(sections) == 0)
    return -1;

  while (PRIV(section_count) <= idx)
    {
      PRIV(sections)[PRIV(section_count)] = new_section (abfd, PRIV(section_count));
      if (PRIV(sections)[PRIV(section_count)] == 0)
	return -1;
      PRIV(section_count)++;
    }

  return 0;
}


/*
 * tir_sta
 *
 * vax stack commands
 *
 * handle sta_xxx commands in tir section
 * ptr points to data area in record
 *
 * see table 7-3 of the VAX/VMS linker manual
 */

static unsigned char *
tir_sta (bfd *abfd, unsigned char *ptr)
{
  int cmd = *ptr++;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_sta %d\n", cmd);
#endif

  switch (cmd)
    {
  /* stack */
      case TIR_S_C_STA_GBL:
	/*
	 * stack global
	 * arg: cs	symbol name
	 *
	 * stack 32 bit value of symbol (high bits set to 0)
	 */
	{
	  char *name;
	  vms_symbol_entry *entry;

	  name = _bfd_vms_save_counted_string (ptr);

          entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;

	  _bfd_vms_push (abfd, (unsigned long)(entry->symbol->value), -1);
	  ptr += *ptr + 1;
	}
      break;

      case TIR_S_C_STA_SB:
	/*
	 * stack signed byte
	 * arg: by	value
	 *
	 * stack byte value, sign extend to 32 bit
	 */
	_bfd_vms_push (abfd, (long)*ptr++, -1);
      break;

      case TIR_S_C_STA_SW:
	/*
	 * stack signed short word
	 * arg: sh	value
	 *
	 * stack 16 bit value, sign extend to 32 bit
	 */
	_bfd_vms_push (abfd, (long)bfd_getl16(ptr), -1);
	ptr += 2;
      break;

      case TIR_S_C_STA_LW:
	/*
	 * stack signed longword
	 * arg: lw	value
	 *
	 * stack 32 bit value
	 */
	_bfd_vms_push (abfd, (long)bfd_getl32 (ptr), -1);
	ptr += 4;
      break;

      case TIR_S_C_STA_PB:
      case TIR_S_C_STA_WPB:
	/*
	 * stack psect base plus byte offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	by	signed byte offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;

	  if (cmd == TIR_S_C_STA_PB)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }

	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }

	  dummy = (long)*ptr++;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_PW:
      case TIR_S_C_STA_WPW:
	/*
	 * stack psect base plus word offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	sh	signed short offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;

	  if (cmd == TIR_S_C_STA_PW)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }

	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }

	  dummy = bfd_getl16(ptr); ptr+=2;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_PL:
      case TIR_S_C_STA_WPL:
	/*
	 * stack psect base plus long offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	lw	signed longword offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;

	  if (cmd == TIR_S_C_STA_PL)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }

	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }

	  dummy = bfd_getl32 (ptr); ptr += 4;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_UB:
	/*
	 * stack unsigned byte
	 * arg: by	value
	 *
	 * stack byte value
	 */
	_bfd_vms_push (abfd, (unsigned long)*ptr++, -1);
      break;

      case TIR_S_C_STA_UW:
	/*
	 * stack unsigned short word
	 * arg: sh	value
	 *
	 * stack 16 bit value
	 */
	_bfd_vms_push (abfd, (unsigned long)bfd_getl16(ptr), -1);
	ptr += 2;
      break;

      case TIR_S_C_STA_BFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
	/*FALLTHRU*/
      case TIR_S_C_STA_WFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
	/*FALLTHRU*/
      case TIR_S_C_STA_LFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
        (*_bfd_error_handler) (_("Stack-from-image not implemented"));
	return NULL;

      case TIR_S_C_STA_EPM:
	/*
	 * stack entry point mask
	 * arg: cs	symbol name
	 *
	 * stack (unsigned) entry point mask of symbol
	 * err if symbol is no entry point
	 */
	{
	  char *name;
	  vms_symbol_entry *entry;

	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;

          (*_bfd_error_handler) (_("Stack-entry-mask not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
      break;

      case TIR_S_C_STA_CKARG:
	/*
	 * compare procedure argument
	 * arg: cs	symbol name
	 *	by	argument index
	 *	da	argument descriptor
	 *
	 * compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 * and stack TRUE (args match) or FALSE (args dont match) value
	 */
        (*_bfd_error_handler) (_("PASSMECH not fully implemented"));
	_bfd_vms_push (abfd, 1L, -1);
	break;

      case TIR_S_C_STA_LSY:
	/*
	 * stack local symbol value
	 * arg:	sh	environment index
	 *	cs	symbol name
	 */
	{
	  int envidx;
	  char *name;
	  vms_symbol_entry *entry;

	  envidx = bfd_getl16(ptr); ptr += 2;
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;
          (*_bfd_error_handler) (_("Stack-local-symbol not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
      break;

      case TIR_S_C_STA_LIT:
	/*
	 * stack literal
 	 * arg:	by	literal index
	 *
	 * stack literal
	 */
	ptr++;
	_bfd_vms_push (abfd, 0L, -1);
	(*_bfd_error_handler) (_("Stack-literal not fully implemented"));
	break;

      case TIR_S_C_STA_LEPM:
	/*
	 * stack local symbol entry point mask
	 * arg:	sh	environment index
	 *	cs	symbol name
	 *
	 * stack (unsigned) entry point mask of symbol
	 * err if symbol is no entry point
	 */
	{
	  int envidx;
	  char *name;
	  vms_symbol_entry *entry;

	  envidx = bfd_getl16(ptr); ptr += 2;
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;
	  (*_bfd_error_handler) (_("Stack-local-symbol-entry-point-mask not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
      break;

      default:
	(*_bfd_error_handler) (_("Reserved STA cmd %d"), ptr[-1]);
	return NULL;
      break;
  }

  return ptr;
}


/*
 * tir_sto
 *
 * vax store commands
 *
 * handle sto_xxx commands in tir section
 * ptr points to data area in record
 *
 * see table 7-4 of the VAX/VMS linker manual
 */

static unsigned char *
tir_sto (bfd *abfd, unsigned char *ptr)
{
  unsigned long dummy;
  int size;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_sto %d\n", *ptr);
#endif

  switch (*ptr++)
    {
      case TIR_S_C_STO_SB:
	/*
	 * store signed byte: pop stack, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_SW:
	/*
	 * store signed word: pop stack, write word
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_LW:
	/*
	 * store longword: pop stack, write longword
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_BD:
	/*
	 * store byte displaced: pop stack, sub lc+1, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 1);
	image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_WD:
	/*
	 * store word displaced: pop stack, sub lc+2, write word
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 2);
	image_write_w (abfd, dummy & 0xffff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_LD:
	/*
	 * store long displaced: pop stack, sub lc+4, write long
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 4);
	image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_LI:
	/*
	 * store short literal: pop stack, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_PIDR:
	/*
	 * store position independent data reference: pop stack, write longword
	 * arg: -
	 * FIXME: incomplete !
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_l (abfd, dummy & 0xffffffff);
      break;
      case TIR_S_C_STO_PICR:
	/*
	 * store position independent code reference: pop stack, write longword
	 * arg: -
	 * FIXME: incomplete !
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, 0x9f);
	image_write_l (abfd, dummy & 0xffffffff);
      break;
      case TIR_S_C_STO_RIVB:
	/*
	 * store repeated immediate variable bytes
	 * 1-byte count n field followed by n bytes of data
	 * pop stack, write n bytes <stack> times
	 */
	size = *ptr++;
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0L)
	  image_dump (abfd, ptr, size, 0);
	ptr += size;
	break;
      case TIR_S_C_STO_B:
	/*
	 * store byte from top longword
	 */
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	image_write_b (abfd, dummy & 0xff);
	break;
      case TIR_S_C_STO_W:
	/*
	 * store word from top longword
	 */
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	image_write_w (abfd, dummy & 0xffff);
	break;
      case TIR_S_C_STO_RB:
	/*
	 * store repeated byte from top longword
	 */
	size = (unsigned long)_bfd_vms_pop (abfd, NULL);
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (size-- > 0)
	  image_write_b (abfd, dummy & 0xff);
	break;
      case TIR_S_C_STO_RW:
	/*
	 * store repeated word from top longword
	 */
	size = (unsigned long)_bfd_vms_pop (abfd, NULL);
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (size-- > 0)
	  image_write_w (abfd, dummy & 0xffff);
	break;

      case TIR_S_C_STO_RSB:
      case TIR_S_C_STO_RSW:
      case TIR_S_C_STO_RL:
      case TIR_S_C_STO_VPS:
      case TIR_S_C_STO_USB:
      case TIR_S_C_STO_USW:
      case TIR_S_C_STO_RUB:
      case TIR_S_C_STO_RUW:
      case TIR_S_C_STO_PIRR:
	(*_bfd_error_handler) (_("Unimplemented STO cmd %d"), ptr[-1]);
      break;

      default:
	(*_bfd_error_handler) (_("Reserved STO cmd %d"), ptr[-1]);
      break;
  }

  return ptr;
}


/*
 * stack operator commands
 * all 32 bit signed arithmetic
 * all word just like a stack calculator
 * arguments are popped from stack, results are pushed on stack
 *
 * see table 7-5 of the VAX/VMS linker manual
 */

static unsigned char *
tir_opr (bfd *abfd, unsigned char *ptr)
{
  long op1, op2;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_opr %d\n", *ptr);
#endif

  switch (*ptr++)
    {
  /* operation */
      case TIR_S_C_OPR_NOP:
	/*
	 * no-op
	 */
      break;

      case TIR_S_C_OPR_ADD:
	/*
	 * add
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 + op2), -1);
      break;

      case TIR_S_C_OPR_SUB:
	/*
	 * subtract
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op2 - op1), -1);
      break;

      case TIR_S_C_OPR_MUL:
	/*
	 * multiply
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 * op2), -1);
      break;

      case TIR_S_C_OPR_DIV:
	/*
	 * divide
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (op2 == 0)
	  _bfd_vms_push (abfd, (unsigned long)0L, -1);
	else
	  _bfd_vms_push (abfd, (unsigned long)(op2 / op1), -1);
      break;

      case TIR_S_C_OPR_AND:
	/*
	 * logical and
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 & op2), -1);
      break;

      case TIR_S_C_OPR_IOR:
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	/*
	 * logical inclusive or
	 */
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 | op2), -1);
      break;

      case TIR_S_C_OPR_EOR:
	/*
	 * logical exclusive or
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 ^ op2), -1);
      break;

      case TIR_S_C_OPR_NEG:
	/*
	 * negate
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(-op1), -1);
      break;

      case TIR_S_C_OPR_COM:
	/*
	 * complement
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long)(op1 ^ -1L), -1);
      break;

      case TIR_S_C_OPR_INSV:
	/*
	 * insert field
	 */
	(void)_bfd_vms_pop (abfd, NULL);
	(*_bfd_error_handler)  ("TIR_S_C_OPR_INSV incomplete");
      break;

      case TIR_S_C_OPR_ASH:
	/*
	 * arithmetic shift
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(op1))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_ASH incomplete"));
      break;

      case TIR_S_C_OPR_USH:
	/*
	 * unsigned shift
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(op1))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_USH incomplete"));
      break;

      case TIR_S_C_OPR_ROT:
	/*
	 * rotate
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(0))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_ROT incomplete"));
      break;

      case TIR_S_C_OPR_SEL:
	/*
	 * select
	 */
	if ((long)_bfd_vms_pop (abfd, NULL) & 0x01L)
	  (void)_bfd_vms_pop (abfd, NULL);
	else
	  {
	    op1 = (long)_bfd_vms_pop (abfd, NULL);
	    (void)_bfd_vms_pop (abfd, NULL);
	    _bfd_vms_push (abfd, (unsigned long)op1, -1);
	  }
      break;

      case TIR_S_C_OPR_REDEF:
	/*
	 * redefine symbol to current location
	 */
	(*_bfd_error_handler) (_("TIR_S_C_OPR_REDEF not supported"));
      break;

      case TIR_S_C_OPR_DFLIT:
	/*
	 * define a literal
	 */
	(*_bfd_error_handler) (_("TIR_S_C_OPR_DFLIT not supported"));
      break;

      default:
	(*_bfd_error_handler) (_("Reserved OPR cmd %d"), ptr[-1]);
      break;
    }

  return ptr;
}


static unsigned char *
tir_ctl (bfd *abfd, unsigned char *ptr)
/*
 * control commands
 *
 * see table 7-6 of the VAX/VMS linker manual
 */
{
  unsigned long dummy;
  unsigned int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_ctl %d\n", *ptr);
#endif

  switch (*ptr++)
    {
      case TIR_S_C_CTL_SETRB:
	/*
	 * set relocation base: pop stack, set image location counter
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	if (psect >= PRIV(section_count))
	  {
	    alloc_section (abfd, psect);
	  }
	image_set_ptr (abfd, psect, dummy);
      break;
      case TIR_S_C_CTL_AUGRB:
	/*
	 * augment relocation base: increment image location counter by offset
	 * arg: lw	offset value
	 */
	dummy = bfd_getl32 (ptr);
	image_inc_ptr (abfd, dummy);
      break;
      case TIR_S_C_CTL_DFLOC:
	/*
	 * define location: pop index, save location counter under index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, NULL);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_DFLOC not fully implemented"));
      break;
      case TIR_S_C_CTL_STLOC:
	/*
	 * set location: pop index, restore location counter from index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_STLOC not fully implemented"));
      break;
    case TIR_S_C_CTL_STKDL:
	/*
	 * stack defined location: pop index, push location counter from index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_STKDL not fully implemented"));
      break;
    default:
        (*_bfd_error_handler) (_("Reserved CTL cmd %d"), ptr[-1]);
	break;
  }
  return ptr;
}


/*
 * handle command from TIR section
 */

static unsigned char *
tir_cmd (bfd *abfd, unsigned char *ptr)
{
  struct {
    int mincod;
    int maxcod;
    unsigned char * (*explain)(bfd *, unsigned char *);
  } tir_table[] = {
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta }
   ,{ TIR_S_C_MINSTOCOD, TIR_S_C_MAXSTOCOD, tir_sto }
   ,{ TIR_S_C_MINOPRCOD, TIR_S_C_MAXOPRCOD, tir_opr }
   ,{ TIR_S_C_MINCTLCOD, TIR_S_C_MAXCTLCOD, tir_ctl }
   ,{ -1, -1, NULL }
  };
  int i = 0;

#if VMS_DEBUG
  _bfd_vms_debug (4, "tir_cmd %d/%x\n", *ptr, *ptr);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  if (*ptr & 0x80)				/* store immediate */
    {
      i = 128 - (*ptr++ & 0x7f);
      image_dump (abfd, ptr, i, 0);
      ptr += i;
    }
  else
    {
      while (tir_table[i].mincod >= 0)
	{
	  if ( (tir_table[i].mincod <= *ptr) 
	    && (*ptr <= tir_table[i].maxcod))
	    {
	      ptr = tir_table[i].explain (abfd, ptr);
	      break;
	    }
	  i++;
	}
      if (tir_table[i].mincod < 0)
	{
	  (*_bfd_error_handler) (_("Obj code %d not found"), *ptr);
	  ptr = 0;
	}
    }

  return ptr;
}


/* handle command from ETIR section  */

static int
etir_cmd (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
{
  static struct {
    int mincod;
    int maxcod;
    boolean (*explain) PARAMS((bfd *, int, unsigned char *));
  } etir_table[] = {
    { ETIR_S_C_MINSTACOD, ETIR_S_C_MAXSTACOD, etir_sta },
    { ETIR_S_C_MINSTOCOD, ETIR_S_C_MAXSTOCOD, etir_sto },
    { ETIR_S_C_MINOPRCOD, ETIR_S_C_MAXOPRCOD, etir_opr },
    { ETIR_S_C_MINCTLCOD, ETIR_S_C_MAXCTLCOD, etir_ctl },
    { ETIR_S_C_MINSTCCOD, ETIR_S_C_MAXSTCCOD, etir_stc },
    { -1, -1, NULL }
  };

  int i = 0;

#if VMS_DEBUG
  _bfd_vms_debug (4, "etir_cmd %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int)ptr);
#endif

  while (etir_table[i].mincod >= 0)
    {
      if ( (etir_table[i].mincod <= cmd) 
	&& (cmd <= etir_table[i].maxcod))
	{
	  if (!etir_table[i].explain (abfd, cmd, ptr))
	    return -1;
	  break;
	}
      i++;
    }

#if VMS_DEBUG
  _bfd_vms_debug (4, "etir_cmd: = 0\n");
#endif
  return 0;
}


/* Text Information and Relocation Records (OBJ$C_TIR)
   handle tir record  */

static int
analyze_tir (abfd, ptr, length)
     bfd *abfd;
     unsigned char *ptr;
     unsigned int length;
{
  unsigned char *maxptr;

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_tir: %d bytes\n", length);
#endif

  maxptr = ptr + length;

  while (ptr < maxptr)
    {
      ptr = tir_cmd (abfd, ptr);
      if (ptr == 0)
	return -1;
    }

  return 0;
}


/* Text Information and Relocation Records (EOBJ$C_ETIR)
   handle etir record  */

static int
analyze_etir (abfd, ptr, length)
     bfd *abfd;
     unsigned char *ptr;
     unsigned int length;
{
  int cmd;
  unsigned char *maxptr;
  int result = 0;

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_etir: %d bytes\n", length);
#endif

  maxptr = ptr + length;

  while (ptr < maxptr)
    {
      cmd = bfd_getl16 (ptr);
      length = bfd_getl16 (ptr + 2);
      result = etir_cmd (abfd, cmd, ptr+4);
      if (result != 0)
	break;
      ptr += length;
    }

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_etir: = %d\n", result);
#endif

  return result;
}


/* process ETIR record
  
   return 0 on success, -1 on error  */

int
_bfd_vms_slurp_tir (abfd, objtype)
     bfd *abfd;
     int objtype;
{
  int result;

#if VMS_DEBUG
  _bfd_vms_debug (2, "TIR/ETIR\n");
#endif

  switch (objtype)
    {
      case EOBJ_S_C_ETIR:
	PRIV(vms_rec) += 4;	/* skip type, size */
	PRIV(rec_size) -= 4;
	result = analyze_etir (abfd, PRIV(vms_rec), PRIV(rec_size));
	break;
      case OBJ_S_C_TIR:
	PRIV(vms_rec) += 1;	/* skip type */
	PRIV(rec_size) -= 1;
	result = analyze_tir (abfd, PRIV(vms_rec), PRIV(rec_size));
	break;
      default:
	result = -1;
	break;
    }

  return result;
}


/* process EDBG record
   return 0 on success, -1 on error
  
   not implemented yet  */

int
_bfd_vms_slurp_dbg (abfd, objtype)
     bfd *abfd;
     int objtype ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "DBG/EDBG\n");
#endif

  abfd->flags |= (HAS_DEBUG | HAS_LINENO);
  return 0;
}


/* process ETBT record
   return 0 on success, -1 on error
  
   not implemented yet  */

int
_bfd_vms_slurp_tbt (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "TBT/ETBT\n");
#endif

  return 0;
}


/* process LNK record
   return 0 on success, -1 on error
  
   not implemented yet  */

int
_bfd_vms_slurp_lnk (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "LNK\n");
#endif

  return 0;
}

/*----------------------------------------------------------------------*/
/*									*/
/*	WRITE ETIR SECTION						*/
/*									*/
/*	this is still under construction and therefore not documented	*/
/*									*/
/*----------------------------------------------------------------------*/

static void start_etir_record PARAMS ((bfd *abfd, int index, uquad offset, boolean justoffset));
static void sto_imm PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record PARAMS ((bfd *abfd));

static void
sto_imm (abfd, sptr, vaddr, index)
     bfd *abfd;
     vms_section *sptr;
     bfd_vma vaddr;
     int index;
{
  int size;
  int ssize;
  unsigned char *cptr;

#if VMS_DEBUG
  _bfd_vms_debug (8, "sto_imm %d bytes\n", sptr->size);
  _bfd_hexdump (9, sptr->contents, (int)sptr->size, (int)vaddr);
#endif

  ssize = sptr->size;
  cptr = sptr->contents;

  while (ssize > 0)
    {

      size = ssize;				/* try all the rest */

      if (_bfd_vms_output_check (abfd, size) < 0)
	{					/* doesn't fit, split ! */
	  end_etir_record (abfd);
	  start_etir_record (abfd, index, vaddr, false);
	  size = _bfd_vms_output_check (abfd, 0);	/* get max size */
	  if (size > ssize)			/* more than what's left ? */
	    size = ssize;
	}

      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_IMM, -1);
      _bfd_vms_output_long (abfd, (unsigned long)(size));
      _bfd_vms_output_dump (abfd, cptr, size);
      _bfd_vms_output_flush (abfd);

#if VMS_DEBUG
      _bfd_vms_debug (10, "dumped %d bytes\n", size);
      _bfd_hexdump (10, cptr, (int)size, (int)vaddr);
#endif

      vaddr += size;
      ssize -= size;
      cptr += size;
    }

  return;
}

/*-------------------------------------------------------------------*/

/* start ETIR record for section #index at virtual addr offset.  */

static void
start_etir_record (abfd, index, offset, justoffset)
    bfd *abfd;
    int index;
    uquad offset;
    boolean justoffset;
{
  if (!justoffset)
    {
      _bfd_vms_output_begin (abfd, EOBJ_S_C_ETIR, -1);	/* one ETIR per section */
      _bfd_vms_output_push (abfd);
    }

  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_PQ, -1);	/* push start offset */
  _bfd_vms_output_long (abfd, (unsigned long)index);
  _bfd_vms_output_quad (abfd, (uquad)offset);
  _bfd_vms_output_flush (abfd);

  _bfd_vms_output_begin (abfd, ETIR_S_C_CTL_SETRB, -1);	/* start = pop () */
  _bfd_vms_output_flush (abfd);

  return;
}


/* end etir record  */
static void
end_etir_record (abfd)
    bfd *abfd;
{
  _bfd_vms_output_pop (abfd);
  _bfd_vms_output_end (abfd); 
}

/* write section contents for bfd abfd  */

int
_bfd_vms_write_tir (abfd, objtype)
     bfd *abfd;
     int objtype ATTRIBUTE_UNUSED;
{
  asection *section;
  vms_section *sptr;
  int nextoffset;

#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_tir (%p, %d)\n", abfd, objtype);
#endif

  _bfd_vms_output_alignment (abfd, 4);

  nextoffset = 0;
  PRIV(vms_linkage_index) = 1;

  /* dump all other sections  */

  section = abfd->sections;

  while (section != NULL)
    {

#if VMS_DEBUG
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n", section->index, section->name, (int)(section->_raw_size));
#endif

      if (section->flags & SEC_RELOC)
	{
	  int i;

	  if ((i = section->reloc_count) <= 0)
	    {
	      (*_bfd_error_handler) (_("SEC_RELOC with no relocs in section %s"),
				     section->name);
	    }
#if VMS_DEBUG
	  else
	    {
	      arelent **rptr;
	      _bfd_vms_debug (4, "%d relocations:\n", i);
	      rptr = section->orelocation;
	      while (i-- > 0)
		{
		  _bfd_vms_debug (4, "sym %s in sec %s, value %08lx, addr %08lx, off %08lx, len %d: %s\n",
			      (*(*rptr)->sym_ptr_ptr)->name,
			      (*(*rptr)->sym_ptr_ptr)->section->name,
			      (long)(*(*rptr)->sym_ptr_ptr)->value,
			      (*rptr)->address, (*rptr)->addend,
			      bfd_get_reloc_size((*rptr)->howto),
			      (*rptr)->howto->name);
		  rptr++;
		}
	    }
#endif
	}

      if ((section->flags & SEC_HAS_CONTENTS)
	&& (! bfd_is_com_section (section)))
	{
	  bfd_vma vaddr;		/* virtual addr in section */

	  sptr = _bfd_get_vms_section (abfd, section->index);
	  if (sptr == NULL)
	    {
	      bfd_set_error (bfd_error_no_contents);
	      return -1;
	    }

	  vaddr = (bfd_vma)(sptr->offset);

	  start_etir_record (abfd, section->index, (uquad) sptr->offset,
			     false);

	  while (sptr != NULL)				/* one STA_PQ, CTL_SETRB per vms_section */
	    {

	      if (section->flags & SEC_RELOC)			/* check for relocs */
		{
		  arelent **rptr = section->orelocation;
		  int i = section->reloc_count;
		  for (;;)
		    {
		      bfd_size_type addr = (*rptr)->address;
		      bfd_size_type len = bfd_get_reloc_size ((*rptr)->howto);
		      if (sptr->offset < addr)		/* sptr starts before reloc */
			{
			  bfd_size_type before = addr - sptr->offset;
			  if (sptr->size <= before)		/* complete before */
			    {
			      sto_imm (abfd, sptr, vaddr, section->index);
			      vaddr += sptr->size;
			      break;
			    }
			  else				/* partly before */
			    {
			      int after = sptr->size - before;
			      sptr->size = before;
			      sto_imm (abfd, sptr, vaddr, section->index);
			      vaddr += sptr->size;
			      sptr->contents += before;
			      sptr->offset += before;
			      sptr->size = after;
			    }
			}
		      else if (sptr->offset == addr)	/* sptr starts at reloc */
			{
			  asymbol *sym = *(*rptr)->sym_ptr_ptr;
			  asection *sec = sym->section;

			  switch ((*rptr)->howto->type)
			    {
			    case ALPHA_R_IGNORE:
			      break;

			    case ALPHA_R_REFLONG:
			      {
				if (bfd_is_und_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd,
								strlen((char *)sym->name))
					< 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_GBL_LW,
							    -1);
				    _bfd_vms_output_counted (abfd,
							      _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_flush (abfd);
				  }
				else if (bfd_is_abs_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd, 16) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STA_LW,
							    -1);
				    _bfd_vms_output_quad (abfd,
							   (uquad)sym->value);
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_LW,
							    -1);
				    _bfd_vms_output_flush (abfd);
				  }
				else
				  {
				    if (_bfd_vms_output_check (abfd, 32) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STA_PQ,
							    -1);
				    _bfd_vms_output_long (abfd,
							   (unsigned long)(sec->index));
				    _bfd_vms_output_quad (abfd,
							   ((uquad)(*rptr)->addend
							    + (uquad)sym->value));
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_LW,
							    -1);
				    _bfd_vms_output_flush (abfd);
				  }
			      }
			      break;

			    case ALPHA_R_REFQUAD:
			      {
				if (bfd_is_und_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd,
								strlen((char *)sym->name))
					< 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_GBL,
							    -1);
				    _bfd_vms_output_counted (abfd,
							      _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_flush (abfd);
				  }
				else if (bfd_is_abs_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd, 16) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STA_QW,
							    -1);
				    _bfd_vms_output_quad (abfd,
							   (uquad)sym->value);
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_QW,
							    -1);
				    _bfd_vms_output_flush (abfd);
				  }
				else
				  {
				    if (_bfd_vms_output_check (abfd, 32) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, false);
				      }
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STA_PQ,
							    -1);
				    _bfd_vms_output_long (abfd,
							   (unsigned long)(sec->index));
				    _bfd_vms_output_quad (abfd,
							   ((uquad)(*rptr)->addend
							    + (uquad)sym->value));
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							    ETIR_S_C_STO_OFF,
							    -1);
				    _bfd_vms_output_flush (abfd);
				  }
			      }
			      break;

			    case ALPHA_R_HINT:
			      {
				int hint_size;

				hint_size = sptr->size;
				sptr->size = len;
				sto_imm (abfd, sptr, vaddr, section->index);
				sptr->size = hint_size;
#if 0
				vms_output_begin(abfd, ETIR_S_C_STO_HINT_GBL, -1);
				vms_output_long(abfd, (unsigned long)(sec->index));
				vms_output_quad(abfd, (uquad)addr);

				vms_output_counted(abfd, _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				vms_output_flush(abfd);
#endif
			      }
			      break;
			    case ALPHA_R_LINKAGE:
			      {
				if (_bfd_vms_output_check (abfd, 64) < 0)
				  {
				    end_etir_record (abfd);
				    start_etir_record (abfd, section->index,
						       vaddr, false);
				  }
				_bfd_vms_output_begin (abfd,
							ETIR_S_C_STC_LP_PSB,
							-1);
				_bfd_vms_output_long (abfd,
						       (unsigned long)PRIV(vms_linkage_index));
				PRIV(vms_linkage_index) += 2;
				_bfd_vms_output_counted (abfd,
							  _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_byte (abfd, 0);
				_bfd_vms_output_flush (abfd);
			      }
			      break;

			    case ALPHA_R_CODEADDR:
			      {
				if (_bfd_vms_output_check (abfd,
							    strlen((char *)sym->name))
				    < 0)
				  {
				    end_etir_record (abfd);
				    start_etir_record (abfd,
						       section->index,
						       vaddr, false);
				  }
				_bfd_vms_output_begin (abfd,
							ETIR_S_C_STO_CA,
							-1);
				_bfd_vms_output_counted (abfd,
							  _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_flush (abfd);
			      }
			      break;

			    default:
			      (*_bfd_error_handler) (_("Unhandled relocation %s"),
						     (*rptr)->howto->name);
			      break;
			    }

			  vaddr += len;

			  if (len == sptr->size)
			    {
			      break;
			    }
			  else
			    {
			      sptr->contents += len;
			      sptr->offset += len;
			      sptr->size -= len;
			      i--;
			      rptr++;
			    }
			}
		      else					/* sptr starts after reloc */
			{
			  i--;				/* check next reloc */
			  rptr++;
			}

		      if (i==0)				/* all reloc checked */
			{
			  if (sptr->size > 0)
			    {
			      sto_imm (abfd, sptr, vaddr, section->index);	/* dump rest */
			      vaddr += sptr->size;
			    }
			  break;
			}
		    } /* for (;;) */
		} /* if SEC_RELOC */
	      else						/* no relocs, just dump */
		{
		  sto_imm (abfd, sptr, vaddr, section->index);
		  vaddr += sptr->size;
		}

	      sptr = sptr->next;

	    } /* while (sptr != 0) */

	  end_etir_record (abfd);

	} /* has_contents */

      section = section->next;
    }

  _bfd_vms_output_alignment(abfd, 2);
  return 0;
}


/* write traceback data for bfd abfd  */

int
_bfd_vms_write_tbt (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_tbt (%p, %d)\n", abfd, objtype);
#endif

  return 0;
}


/* write debug info for bfd abfd  */

int
_bfd_vms_write_dbg (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_dbg (%p, objtype)\n", abfd, objtype);
#endif

  return 0;
}
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d27 1
d99 1
d116 1
d139 1
d158 1
d179 1
d200 1
d225 1
a225 1

d227 1
a227 1

d230 1
a230 1

d271 1
a271 1
	      _bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
d339 1
d342 1
a342 1

d344 1
a344 1

d347 1
a347 1

d441 1
a441 1
	  image_write_q (abfd, (uquad) (entry->symbol->value));	/* FIXME, reloc */
d462 1
a462 1
	  image_write_q (abfd, (uquad) (entry->symbol->value));	/* FIXME, reloc */
d521 1
a521 1
	  image_write_l (abfd, (unsigned long) (entry->symbol->value));	/* FIXME, reloc */
d555 1
a555 1

d585 1
a585 1
      _bfd_vms_push (abfd, (uquad) (op1 + op2), -1);
d593 1
a593 1
      _bfd_vms_push (abfd, (uquad) (op2 - op1), -1);
d601 1
a601 1
      _bfd_vms_push (abfd, (uquad) (op1 * op2), -1);
d612 1
a612 1
	_bfd_vms_push (abfd, (uquad) (op2 / op1), -1);
d620 1
a620 1
      _bfd_vms_push (abfd, (uquad) (op1 & op2), -1);
d628 1
a628 1
      _bfd_vms_push (abfd, (uquad) (op1 | op2), -1);
d636 1
a636 1
      _bfd_vms_push (abfd, (uquad) (op1 ^ op2), -1);
d643 1
a643 1
      _bfd_vms_push (abfd, (uquad) (-op1), -1);
d650 1
a650 1
      _bfd_vms_push (abfd, (uquad) (op1 ^ -1L), -1);
d717 1
d719 1
a719 1

d785 1
d787 1
a787 1

d907 1
d946 1
d972 1
d1013 1
a1013 1
	  _bfd_vms_push (abfd, (unsigned long) (entry->symbol->value), -1);
d1295 1
d1467 1
d1501 1
a1501 1
	_bfd_vms_push (abfd, (unsigned long) (op1 + op2), -1);
d1510 1
a1510 1
	_bfd_vms_push (abfd, (unsigned long) (op2 - op1), -1);
d1519 1
a1519 1
	_bfd_vms_push (abfd, (unsigned long) (op1 * op2), -1);
d1531 1
a1531 1
	  _bfd_vms_push (abfd, (unsigned long) (op2 / op1), -1);
d1540 1
a1540 1
	_bfd_vms_push (abfd, (unsigned long) (op1 & op2), -1);
d1549 1
a1549 1
	_bfd_vms_push (abfd, (unsigned long) (op1 | op2), -1);
d1558 1
a1558 1
	_bfd_vms_push (abfd, (unsigned long) (op1 ^ op2), -1);
d1566 1
a1566 1
	_bfd_vms_push (abfd, (unsigned long) (-op1), -1);
d1574 1
a1574 1
	_bfd_vms_push (abfd, (unsigned long) (op1 ^ -1L), -1);
d1663 1
d1732 1
d1743 1
a1743 1
    unsigned char * (*explain) (bfd *, unsigned char *);
d1768 1
a1768 1
	  if ( (tir_table[i].mincod <= *ptr)
d1786 1
d1817 1
a1817 1
      if ( (etir_table[i].mincod <= cmd)
d1833 1
d1861 1
d1898 1
d1900 1
a1900 1

d1934 1
d1937 1
a1937 1

d1953 1
d1956 1
a1956 1

d1971 1
d1974 1
a1974 1

d2035 1
a2035 1
      _bfd_vms_output_long (abfd, (unsigned long) (size));
d2080 1
d2087 1
a2087 1
  _bfd_vms_output_end (abfd);
d2118 1
a2118 1
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n", section->index, section->name, (int) (section->_raw_size));
d2141 1
a2141 1
			      (long) (*(*rptr)->sym_ptr_ptr)->value,
d2163 1
a2163 1
	  vaddr = (bfd_vma) (sptr->offset);
d2262 1
a2262 1
							   (unsigned long) (sec->index));
d2264 1
a2264 1
							   ((uquad) (*rptr)->addend
d2328 1
a2328 1
							   (unsigned long) (sec->index));
d2330 1
a2330 1
							   ((uquad) (*rptr)->addend
d2351 1
a2351 1
				vms_output_long(abfd, (unsigned long) (sec->index));
d2459 1
d2473 1
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d13 13
a25 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 2
d45 9
a53 42
static void image_set_ptr
  PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr
  PARAMS ((bfd *abfd, uquad offset));
static void image_dump
  PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l
  PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q
  PARAMS ((bfd *abfd, uquad value));
static int check_section
  PARAMS ((bfd *, int));
static bfd_boolean etir_sta
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_sto
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_opr
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_ctl
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_stc
  PARAMS ((bfd *, int, unsigned char *));
static asection *new_section
  PARAMS ((bfd *, int));
static int alloc_section
  PARAMS ((bfd *, unsigned int));
static int etir_cmd
  PARAMS ((bfd *, int, unsigned char *));
static int analyze_tir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static int analyze_etir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static unsigned char * tir_opr
  PARAMS ((bfd *, unsigned char *));
static const char * tir_cmd_name
  PARAMS ((int));
static const char * cmd_name
  PARAMS ((int));
a54 1

d60 1
a60 1
  bfd_size_type offset;
d62 2
a63 2
  offset = PRIV (image_ptr) - PRIV (image_section)->contents;
  if (offset + size > PRIV (image_section)->_raw_size)
d65 2
a66 3
      PRIV (image_section)->contents
	= bfd_realloc (PRIV (image_section)->contents, offset + size);
      if (PRIV (image_section)->contents == 0)
d71 2
a72 2
      PRIV (image_section)->_raw_size = offset + size;
      PRIV (image_ptr) = PRIV (image_section)->contents + offset;
d78 1
a78 1
/* Routines to fill sections contents during tir/etir read.  */
d80 1
a80 1
/* Initialize image buffer pointer to be filled.  */
d90 1
a90 1
		  psect, PRIV (sections)[psect]->name, offset);
d93 2
a94 2
  PRIV (image_ptr) = PRIV (sections)[psect]->contents + offset;
  PRIV (image_section) = PRIV (sections)[psect];
d98 1
a98 1
/* Increment image buffer pointer by offset.  */
d109 1
a109 1
  PRIV (image_ptr) += offset;
d114 1
a114 1
/* Dump multiple bytes to section image.  */
d124 1
a124 2
  _bfd_vms_debug (8, "image_dump from (%p, %d) to (%p)\n", ptr, size,
		  PRIV (image_ptr));
d128 1
a128 1
  if (PRIV (is_vax) && check_section (abfd, size))
d132 1
a132 1
    *PRIV (image_ptr)++ = *ptr++;
d136 1
a136 1
/* Write byte to section image.  */
d144 1
a144 1
  _bfd_vms_debug (6, "image_write_b(%02x)\n", (int) value);
d147 1
a147 1
  if (PRIV (is_vax) && check_section (abfd, 1))
d150 1
a150 1
  *PRIV (image_ptr)++ = (value & 0xff);
d154 1
a154 1
/* Write 2-byte word to image.  */
d162 1
a162 1
  _bfd_vms_debug (6, "image_write_w(%04x)\n", (int) value);
d165 1
a165 1
  if (PRIV (is_vax) && check_section (abfd, 2))
d168 2
a169 2
  bfd_putl16 ((bfd_vma) value, PRIV (image_ptr));
  PRIV (image_ptr) += 2;
d174 1
a174 1
/* Write 4-byte long to image.  */
d185 1
a185 1
  if (PRIV (is_vax) && check_section (abfd, 4))
d188 2
a189 2
  bfd_putl32 ((bfd_vma) value, PRIV (image_ptr));
  PRIV (image_ptr) += 4;
d194 1
a194 1
/* Write 8-byte quad to image.  */
d205 1
a205 1
  if (PRIV (is_vax) && check_section (abfd, 8))
d208 2
a209 2
  bfd_putl64 (value, PRIV (image_ptr));
  PRIV (image_ptr) += 8;
a213 40
static const char *
cmd_name (cmd)
     int cmd;
{
  switch (cmd)
    {
    case ETIR_S_C_STA_GBL: return "ETIR_S_C_STA_GBL";
    case ETIR_S_C_STA_PQ: return "ETIR_S_C_STA_PQ";
    case ETIR_S_C_STA_LI: return "ETIR_S_C_STA_LI";
    case ETIR_S_C_STA_MOD: return "ETIR_S_C_STA_MOD";
    case ETIR_S_C_STA_CKARG: return "ETIR_S_C_STA_CKARG";
    case ETIR_S_C_STO_B: return "ETIR_S_C_STO_B";
    case ETIR_S_C_STO_W: return "ETIR_S_C_STO_W";
    case ETIR_S_C_STO_GBL: return "ETIR_S_C_STO_GBL";
    case ETIR_S_C_STO_CA: return "ETIR_S_C_STO_CA";
    case ETIR_S_C_STO_RB: return "ETIR_S_C_STO_RB";
    case ETIR_S_C_STO_AB: return "ETIR_S_C_STO_AB";
    case ETIR_S_C_STO_GBL_LW: return "ETIR_S_C_STO_GBL_LW";
    case ETIR_S_C_STO_LP_PSB: return "ETIR_S_C_STO_LP_PSB";
    case ETIR_S_C_STO_HINT_GBL: return "ETIR_S_C_STO_HINT_GBL";
    case ETIR_S_C_STO_HINT_PS: return "ETIR_S_C_STO_HINT_PS";
    case ETIR_S_C_OPR_INSV: return "ETIR_S_C_OPR_INSV";
    case ETIR_S_C_OPR_USH: return "ETIR_S_C_OPR_USH";
    case ETIR_S_C_OPR_ROT: return "ETIR_S_C_OPR_ROT";
    case ETIR_S_C_OPR_REDEF: return "ETIR_S_C_OPR_REDEF";
    case ETIR_S_C_OPR_DFLIT: return "ETIR_S_C_OPR_DFLIT";
    case ETIR_S_C_STC_LP: return "ETIR_S_C_STC_LP";
    case ETIR_S_C_STC_GBL: return "ETIR_S_C_STC_GBL";
    case ETIR_S_C_STC_GCA: return "ETIR_S_C_STC_GCA";
    case ETIR_S_C_STC_PS: return "ETIR_S_C_STC_PS";
    case ETIR_S_C_STC_NBH_PS: return "ETIR_S_C_STC_NBH_PS";
    case ETIR_S_C_STC_NOP_GBL: return "ETIR_S_C_STC_NOP_GBL";
    case ETIR_S_C_STC_NOP_PS: return "ETIR_S_C_STC_NOP_PS";
    case ETIR_S_C_STC_BSR_GBL: return "ETIR_S_C_STC_BSR_GBL";
    case ETIR_S_C_STC_BSR_PS: return "ETIR_S_C_STC_BSR_PS";
    case ETIR_S_C_STC_LDA_GBL: return "ETIR_S_C_STC_LDA_GBL";
    case ETIR_S_C_STC_LDA_PS: return "ETIR_S_C_STC_LDA_PS";
    case ETIR_S_C_STC_BOH_GBL: return "ETIR_S_C_STC_BOH_GBL";
    case ETIR_S_C_STC_BOH_PS: return "ETIR_S_C_STC_BOH_PS";
    case ETIR_S_C_STC_NBH_GBL: return "ETIR_S_C_STC_NBH_GBL";
a214 5
    default:
      /* These names have not yet been added to this switch statement.  */
      abort ();
    }
}
d224 1
a224 1
   see table B-8 of the openVMS linker manual.  */
d226 1
a226 1
static bfd_boolean
d235 1
a235 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d243 1
a243 1
	 arg: cs	symbol name
d245 1
a245 1
	 stack 32 bit value of symbol (high bits set to 0)  */
d247 4
a250 4
    case ETIR_S_C_STA_GBL:
      {
	char *name;
	vms_symbol_entry *entry;
d252 5
a256 5
	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *)
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
	if (entry == (vms_symbol_entry *) NULL)
	  {
d258 1
a258 2
	    _bfd_vms_debug (3, "%s: no symbol \"%s\"\n",
			    cmd_name (cmd), name);
d260 7
a266 7
	    _bfd_vms_push (abfd, (uquad) 0, -1);
	  }
	else
	  {
	    _bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
	  }
      }
d269 2
a270 2
      /* stack longword
	 arg: lw	value
d272 1
a272 1
	 stack 32 bit value, sign extend to 64 bit  */
d274 2
a275 2
    case ETIR_S_C_STA_LW:
      _bfd_vms_push (abfd, (uquad) bfd_getl32 (ptr), -1);
d278 2
a279 2
      /* stack global
	 arg: qw	value
d281 1
a281 1
	 stack 64 bit value of symbol	 */
d283 2
a284 2
    case ETIR_S_C_STA_QW:
      _bfd_vms_push (abfd, (uquad) bfd_getl64 (ptr), -1);
d287 3
a289 3
      /* stack psect base plus quadword offset
	 arg: lw	section index
	 qw	signed quadword offset (low 32 bits)
d291 2
a292 2
	 stack qw argument and section index
	 (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB)  */
d294 4
a297 4
    case ETIR_S_C_STA_PQ:
      {
	uquad dummy;
	unsigned int psect;
d299 10
a308 11
	psect = bfd_getl32 (ptr);
	if (psect >= PRIV (section_count))
	  {
	    (*_bfd_error_handler) (_("bad section index in %s"),
				   cmd_name (cmd));
	    bfd_set_error (bfd_error_bad_value);
	    return FALSE;
	  }
	dummy = bfd_getl64 (ptr+4);
	_bfd_vms_push (abfd, dummy, (int) psect);
      }
d311 8
a318 5
    case ETIR_S_C_STA_LI:
    case ETIR_S_C_STA_MOD:
    case ETIR_S_C_STA_CKARG:
      (*_bfd_error_handler) (_("unsupported STA cmd %s"), cmd_name (cmd));
      return FALSE;
d321 3
a323 3
    default:
      (*_bfd_error_handler) (_("reserved STA cmd %d"), cmd);
      return FALSE;
d329 1
a329 1
  return TRUE;
d340 1
a340 1
   see table B-9 of the openVMS linker manual.  */
d342 1
a342 1
static bfd_boolean
d353 1
a353 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d358 1
d366 1
a366 2
	(*_bfd_error_handler) ("%s: byte fixups not supported",
			       cmd_name (cmd));
d368 1
a368 2
      /* FIXME: check top bits */
      image_write_b (abfd, (unsigned int) dummy & 0xff);
d378 1
a378 2
	(*_bfd_error_handler) ("%s: word fixups not supported",
			       cmd_name (cmd));
d380 1
a380 2
      /* FIXME: check top bits */
      image_write_w (abfd, (unsigned int) dummy & 0xffff);
d388 2
a389 3
      dummy += (PRIV (sections)[psect])->vma;
      /* FIXME: check top bits.  */
      image_write_l (abfd, (unsigned int) dummy & 0xffffffff);
d397 1
a397 1
      dummy += (PRIV (sections)[psect])->vma;
d407 1
a407 1
	int size;
d410 2
a411 2
	dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0)
d417 1
a417 1
	 arg: cs	global symbol name.  */
d425 2
a426 3
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == (vms_symbol_entry *) NULL)
d428 3
a430 3
	    (*_bfd_error_handler) (_("%s: no symbol \"%s\""),
				   cmd_name (cmd), name);
	    return FALSE;
d433 1
a433 2
	  /* FIXME, reloc.  */
	  image_write_q (abfd, (uquad) (entry->symbol->value));
d438 1
a438 1
	 arg: cs	global symbol name (procedure).  */
d446 2
a447 3
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == (vms_symbol_entry *) NULL)
d449 3
a451 3
	    (*_bfd_error_handler) (_("%s: no symbol \"%s\""),
				   cmd_name (cmd), name);
	    return FALSE;
d458 9
a466 2
      /* Store offset to psect: pop stack, add low 32 bits to base of psect
	 arg: none.  */
d471 1
a471 1
	int psect1;
d473 2
a474 2
	q = _bfd_vms_pop (abfd, &psect1);
	q += (PRIV (sections)[psect1])->vma;
d479 1
a479 1
      /* Store immediate
d481 1
a481 1
	      da	data.  */
d492 2
a493 3
      /* This code is 'reserved to digital' according to the openVMS
	 linker manual, however it is generated by the DEC C compiler
	 and defined in the include file.
d496 1
a496 1
	 arg: cs	symbol name.  */
d504 2
a505 3
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == (vms_symbol_entry *) NULL)
d508 1
a508 1
	    _bfd_vms_debug (3, "%s: no symbol \"%s\"\n", cmd_name (cmd), name);
d510 1
a510 1
	    image_write_l (abfd, (unsigned long) 0);	/* FIXME, reloc */
d513 1
a513 2
	  /* FIXME, reloc.  */
	  image_write_l (abfd, (unsigned long) (entry->symbol->value));
d517 2
a518 2
    case ETIR_S_C_STO_RB:
    case ETIR_S_C_STO_AB:
d520 1
a520 1
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d523 2
d526 5
d532 1
a532 1
      (*_bfd_error_handler) (_("%s: not implemented"), cmd_name (cmd));
d536 1
a536 1
      (*_bfd_error_handler) (_("reserved STO cmd %d"), cmd);
d540 1
a540 1
  return TRUE;
d543 1
a543 1
/* Stack operator commands
d548 1
a548 1
   see table B-10 of the openVMS linker manual.  */
d550 1
a550 1
static bfd_boolean
d560 1
a560 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d565 5
a569 1
    case ETIR_S_C_OPR_NOP:      /* no-op  */
d572 5
a576 3
    case ETIR_S_C_OPR_ADD:      /* add  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d580 5
a584 3
    case ETIR_S_C_OPR_SUB:      /* subtract  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d588 5
a592 3
    case ETIR_S_C_OPR_MUL:      /* multiply  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d596 5
a600 3
    case ETIR_S_C_OPR_DIV:      /* divide  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d602 1
a602 1
	_bfd_vms_push (abfd, (uquad) 0, -1);
d607 5
a611 3
    case ETIR_S_C_OPR_AND:      /* logical and  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d615 5
a619 3
    case ETIR_S_C_OPR_IOR:      /* logical inclusive or	 */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d623 5
a627 3
    case ETIR_S_C_OPR_EOR:      /* logical exclusive or  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d631 4
a634 2
    case ETIR_S_C_OPR_NEG:      /* negate  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
d638 4
a641 2
    case ETIR_S_C_OPR_COM:      /* complement  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
d645 12
a656 3
    case ETIR_S_C_OPR_ASH:      /* arithmetic shift  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
d661 1
a661 1
      _bfd_vms_push (abfd, (uquad) op1, -1);
d664 4
a667 7
    case ETIR_S_C_OPR_INSV:      /* insert field  */
      (void) _bfd_vms_pop (abfd, NULL);
    case ETIR_S_C_OPR_USH:       /* unsigned shift  */
    case ETIR_S_C_OPR_ROT:       /* rotate  */
    case ETIR_S_C_OPR_REDEF:     /* Redefine symbol to current location.  */
    case ETIR_S_C_OPR_DFLIT:     /* Define a literal.  */
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d670 11
a680 3
    case ETIR_S_C_OPR_SEL:      /* select  */
      if ((long) _bfd_vms_pop (abfd, NULL) & 0x01L)
	(void) _bfd_vms_pop (abfd, NULL);
d683 3
a685 3
	  op1 = (long) _bfd_vms_pop (abfd, NULL);
	  (void) _bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad) op1, -1);
d689 12
d702 1
a702 1
      (*_bfd_error_handler) (_("reserved OPR cmd %d"), cmd);
d706 1
a706 1
  return TRUE;
d709 1
a709 1
/* Control commands.
d711 1
a711 1
   See table B-11 of the openVMS linker manual.  */
d713 1
a713 1
static bfd_boolean
d724 1
a724 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d730 1
a730 1
	 arg: none.  */
d746 1
a746 1
	 arg: none.  */
d754 1
a754 1
	 arg: none.  */
d762 1
a762 1
	 arg: none.  */
d770 1
a770 1
      (*_bfd_error_handler) (_("reserved CTL cmd %d"), cmd);
d773 1
a773 1
  return TRUE;
d778 1
a778 1
   See table B-12 and B-13 of the openVMS linker manual.  */
d780 1
a780 1
static bfd_boolean
d786 1
d789 1
a789 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d795 1
a795 1
	 arg: none.  */
d798 1
a798 1
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d803 3
a805 3
		cs	procedure name
		by	signature length
		da	signature.  */
d808 1
a808 1
      image_inc_ptr (abfd, (uquad) 16);	/* skip entry,procval */
d813 1
a813 1
		cs	global name.  */
d816 1
a816 1
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d821 1
a821 1
		cs	procedure name.  */
d824 1
a824 1
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d829 2
a830 2
		lw	psect index
		qw	offset.  */
d833 1
a833 1
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
d837 1
a837 1
	 arg: none.  */
d842 1
a842 1
	 arg: none.  */
d847 1
a847 1
	 arg: none.  */
d852 1
a852 1
	 arg: none.  */
d857 1
a857 1
	 arg: none.  */
d862 1
a862 1
	 arg: none.  */
d867 1
a867 1
	 arg: none.  */
d872 1
a872 1
	 arg: none.  */
d877 1
a877 1
	 arg: none.  */
d882 1
a882 1
	 arg: none.  */
d885 1
a885 4
      /* FIXME */
#if 0
      (*_bfd_error_handler) ("%s: not supported", cmd_name (cmd));
#endif
d890 1
a890 1
      _bfd_vms_debug (3,  "reserved STC cmd %d", cmd);
d894 1
a894 1
  return TRUE;
d907 1
a907 1
  _bfd_vms_debug (5, "new_section %d\n", idx);
d911 1
a911 1
  name = bfd_malloc ((bfd_size_type) strlen (sname) + 1);
d916 1
a916 1
  section = bfd_malloc ((bfd_size_type) sizeof (asection));
a939 2
  bfd_size_type amt;

d941 1
a941 1
  _bfd_vms_debug (4, "alloc_section %d\n", idx);
d944 3
a946 4
  amt = idx + 1;
  amt *= sizeof (asection *);
  PRIV (sections) = (asection **) bfd_realloc (PRIV (sections), amt);
  if (PRIV (sections) == 0)
d949 1
a949 1
  while (PRIV (section_count) <= idx)
d951 2
a952 3
      PRIV (sections)[PRIV (section_count)]
	= new_section (abfd, (int) PRIV (section_count));
      if (PRIV (sections)[PRIV (section_count)] == 0)
d954 1
a954 1
      PRIV (section_count)++;
d960 10
a969 8
/* tir_sta

   vax stack commands

   Handle sta_xxx commands in tir section
   ptr points to data area in record

   See table 7-3 of the VAX/VMS linker manual.  */
d982 11
a992 9
      /* stack */
    case TIR_S_C_STA_GBL:
      /* stack global
	 arg: cs	symbol name

	 stack 32 bit value of symbol (high bits set to 0).  */
      {
	char *name;
	vms_symbol_entry *entry;
d994 1
a994 1
	name = _bfd_vms_save_counted_string (ptr);
d996 3
a998 3
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
d1000 3
a1002 3
	_bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
	ptr += *ptr + 1;
      }
d1005 19
a1023 6
    case TIR_S_C_STA_SB:
      /* stack signed byte
	 arg: by	value

	 stack byte value, sign extend to 32 bit.  */
      _bfd_vms_push (abfd, (uquad) *ptr++, -1);
d1026 23
a1048 3
    case TIR_S_C_STA_SW:
      /* stack signed short word
	 arg: sh	value
d1050 7
a1056 4
	 stack 16 bit value, sign extend to 32 bit.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl16 (ptr), -1);
      ptr += 2;
      break;
d1058 4
a1061 3
    case TIR_S_C_STA_LW:
      /* stack signed longword
	 arg: lw	value
d1063 18
a1080 4
	 stack 32 bit value.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl32 (ptr), -1);
      ptr += 4;
      break;
d1082 7
a1088 9
    case TIR_S_C_STA_PB:
    case TIR_S_C_STA_WPB:
      /* stack psect base plus byte offset (word index)
	 arg: by	section index
		(sh	section index)
		by	signed byte offset.  */
      {
	unsigned long dummy;
	unsigned int psect;
d1090 4
a1093 7
	if (cmd == TIR_S_C_STA_PB)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }
d1095 18
a1112 2
	if (psect >= PRIV (section_count))
	  alloc_section (abfd, psect);
d1114 7
a1120 5
	dummy = (long) *ptr++;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
      }
      break;
d1122 4
a1125 9
    case TIR_S_C_STA_PW:
    case TIR_S_C_STA_WPW:
      /* stack psect base plus word offset (word index)
	 arg: by	section index
		(sh	section index)
		sh	signed short offset.  */
      {
	unsigned long dummy;
	unsigned int psect;
d1127 25
a1151 15
	if (cmd == TIR_S_C_STA_PW)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }

	if (psect >= PRIV (section_count))
	  alloc_section (abfd, psect);

	dummy = bfd_getl16 (ptr); ptr+=2;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
      }
d1154 34
a1187 9
    case TIR_S_C_STA_PL:
    case TIR_S_C_STA_WPL:
      /* stack psect base plus long offset (word index)
	 arg: by	section index
		(sh	section index)
		lw	signed longword offset.	 */
      {
	unsigned long dummy;
	unsigned int psect;
d1189 9
a1197 15
	if (cmd == TIR_S_C_STA_PL)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }

	if (psect >= PRIV (section_count))
	  alloc_section (abfd, psect);

	dummy = bfd_getl32 (ptr); ptr += 4;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
      }
d1200 13
a1212 34
    case TIR_S_C_STA_UB:
      /* stack unsigned byte
	 arg: by	value

	 stack byte value.  */
      _bfd_vms_push (abfd, (uquad) *ptr++, -1);
      break;

    case TIR_S_C_STA_UW:
      /* stack unsigned short word
	 arg: sh	value

	 stack 16 bit value.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl16 (ptr), -1);
      ptr += 2;
      break;

    case TIR_S_C_STA_BFI:
      /* stack byte from image
	 arg: none.  */
      /* FALLTHRU  */
    case TIR_S_C_STA_WFI:
      /* stack byte from image
	 arg: none.  */
      /* FALLTHRU */
    case TIR_S_C_STA_LFI:
      /* stack byte from image
	 arg: none.  */
      (*_bfd_error_handler) (_("stack-from-image not implemented"));
      return NULL;

    case TIR_S_C_STA_EPM:
      /* stack entry point mask
	 arg: cs	symbol name
d1214 20
a1233 15
	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
      {
	char *name;
	vms_symbol_entry *entry;

	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;

	(*_bfd_error_handler) (_("stack-entry-mask not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
d1236 11
a1246 20
    case TIR_S_C_STA_CKARG:
      /* compare procedure argument
	 arg: cs	symbol name
		by	argument index
		da	argument descriptor

	 compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 and stack TRUE (args match) or FALSE (args dont match) value.  */
      (*_bfd_error_handler) (_("PASSMECH not fully implemented"));
      _bfd_vms_push (abfd, (uquad) 1, -1);
      break;

    case TIR_S_C_STA_LSY:
      /* stack local symbol value
	 arg:	sh	environment index
		cs	symbol name.  */
      {
	int envidx;
	char *name;
	vms_symbol_entry *entry;
d1248 23
a1270 10
	envidx = bfd_getl16 (ptr);
	ptr += 2;
	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
	(*_bfd_error_handler) (_("stack-local-symbol not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
d1273 3
a1275 32
    case TIR_S_C_STA_LIT:
      /* stack literal
	 arg:	by	literal index

	 stack literal.  */
      ptr++;
      _bfd_vms_push (abfd, (uquad) 0, -1);
      (*_bfd_error_handler) (_("stack-literal not fully implemented"));
      break;

    case TIR_S_C_STA_LEPM:
      /* stack local symbol entry point mask
	 arg:	sh	environment index
		cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
      {
	int envidx;
	char *name;
	vms_symbol_entry *entry;

	envidx = bfd_getl16 (ptr);
	ptr += 2;
	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
	(*_bfd_error_handler) (_("stack-local-symbol-entry-point-mask not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
d1277 1
a1277 6

    default:
      (*_bfd_error_handler) (_("reserved STA cmd %d"), ptr[-1]);
      return NULL;
      break;
    }
d1282 10
a1291 39
static const char *
tir_cmd_name (cmd)
     int cmd;
{
  switch (cmd)
    {
    case TIR_S_C_STO_RSB: return "TIR_S_C_STO_RSB";
    case TIR_S_C_STO_RSW: return "TIR_S_C_STO_RSW";
    case TIR_S_C_STO_RL: return "TIR_S_C_STO_RL";
    case TIR_S_C_STO_VPS: return "TIR_S_C_STO_VPS";
    case TIR_S_C_STO_USB: return "TIR_S_C_STO_USB";
    case TIR_S_C_STO_USW: return "TIR_S_C_STO_USW";
    case TIR_S_C_STO_RUB: return "TIR_S_C_STO_RUB";
    case TIR_S_C_STO_RUW: return "TIR_S_C_STO_RUW";
    case TIR_S_C_STO_PIRR: return "TIR_S_C_STO_PIRR";
    case TIR_S_C_OPR_INSV: return "TIR_S_C_OPR_INSV";
    case TIR_S_C_OPR_DFLIT: return "TIR_S_C_OPR_DFLIT";
    case TIR_S_C_OPR_REDEF: return "TIR_S_C_OPR_REDEF";
    case TIR_S_C_OPR_ROT: return "TIR_S_C_OPR_ROT";
    case TIR_S_C_OPR_USH: return "TIR_S_C_OPR_USH";
    case TIR_S_C_OPR_ASH: return "TIR_S_C_OPR_ASH";
    case TIR_S_C_CTL_DFLOC: return "TIR_S_C_CTL_DFLOC";
    case TIR_S_C_CTL_STLOC: return "TIR_S_C_CTL_STLOC";
    case TIR_S_C_CTL_STKDL: return "TIR_S_C_CTL_STKDL";

    default:
      /* These strings have not been added yet.  */
      abort ();
    }
}

/* tir_sto

   vax store commands

   handle sto_xxx commands in tir section
   ptr points to data area in record

   See table 7-4 of the VAX/VMS linker manual.  */
d1306 99
a1404 97
    case TIR_S_C_STO_SB:
      /* store signed byte: pop stack, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_SW:
      /* store signed word: pop stack, write word
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LW:
      /* store longword: pop stack, write longword
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_l (abfd, dummy & 0xffffffff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_BD:
      /* store byte displaced: pop stack, sub lc+1, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 1);
      image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_WD:
      /* store word displaced: pop stack, sub lc+2, write word
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 2);
      image_write_w (abfd, dummy & 0xffff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LD:
      /* store long displaced: pop stack, sub lc+4, write long
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 4);
      image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LI:
      /* store short literal: pop stack, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_PIDR:
      /* store position independent data reference: pop stack, write longword
	 arg: none.
	 FIXME: incomplete !  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_l (abfd, dummy & 0xffffffff);
      break;

    case TIR_S_C_STO_PICR:
      /* store position independent code reference: pop stack, write longword
	 arg: none.
	 FIXME: incomplete !  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, 0x9f);
      image_write_l (abfd, dummy & 0xffffffff);
      break;

    case TIR_S_C_STO_RIVB:
      /* store repeated immediate variable bytes
	 1-byte count n field followed by n bytes of data
	 pop stack, write n bytes <stack> times.  */
      size = *ptr++;
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (dummy-- > 0L)
	image_dump (abfd, ptr, size, 0);
      ptr += size;
      break;

    case TIR_S_C_STO_B:
      /* store byte from top longword.  */
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      image_write_b (abfd, dummy & 0xff);
      break;

    case TIR_S_C_STO_W:
      /* store word from top longword.  */
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      image_write_w (abfd, dummy & 0xffff);
      break;

    case TIR_S_C_STO_RB:
      /* store repeated byte from top longword.  */
      size = (unsigned long) _bfd_vms_pop (abfd, NULL);
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (size-- > 0)
d1406 6
a1411 7
      break;

    case TIR_S_C_STO_RW:
      /* store repeated word from top longword.  */
      size = (unsigned long) _bfd_vms_pop (abfd, NULL);
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (size-- > 0)
d1413 19
a1431 1
      break;
d1433 10
a1442 10
    case TIR_S_C_STO_RSB:
    case TIR_S_C_STO_RSW:
    case TIR_S_C_STO_RL:
    case TIR_S_C_STO_VPS:
    case TIR_S_C_STO_USB:
    case TIR_S_C_STO_USW:
    case TIR_S_C_STO_RUB:
    case TIR_S_C_STO_RUW:
    case TIR_S_C_STO_PIRR:
      (*_bfd_error_handler) (_("%s: not implemented"), tir_cmd_name (ptr[-1]));
d1445 2
a1446 2
    default:
      (*_bfd_error_handler) (_("reserved STO cmd %d"), ptr[-1]);
d1448 1
a1448 1
    }
d1453 8
a1460 6
/* stack operator commands
   all 32 bit signed arithmetic
   all word just like a stack calculator
   arguments are popped from stack, results are pushed on stack

   See table 7-5 of the VAX/VMS linker manual.  */
d1463 1
a1463 3
tir_opr (abfd, ptr)
     bfd *abfd;
     unsigned char *ptr;
d1473 44
a1516 2
      /* operation */
    case TIR_S_C_OPR_NOP: /* no-op */
d1519 105
a1623 4
    case TIR_S_C_OPR_ADD: /* add */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 + op2), -1);
d1626 12
a1637 42
    case TIR_S_C_OPR_SUB: /* subtract */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op2 - op1), -1);
      break;

    case TIR_S_C_OPR_MUL: /* multiply */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 * op2), -1);
      break;

    case TIR_S_C_OPR_DIV: /* divide */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (op2 == 0)
	_bfd_vms_push (abfd, (uquad) 0, -1);
      else
	_bfd_vms_push (abfd, (uquad) (op2 / op1), -1);
      break;

    case TIR_S_C_OPR_AND: /* logical and */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 & op2), -1);
      break;

    case TIR_S_C_OPR_IOR: /* logical inclusive or */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 | op2), -1);
      break;

    case TIR_S_C_OPR_EOR: /* logical exclusive or */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ op2), -1);
      break;

    case TIR_S_C_OPR_NEG: /* negate */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (-op1), -1);
d1640 2
a1641 66
    case TIR_S_C_OPR_COM: /* complement */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ -1L), -1);
      break;

    case TIR_S_C_OPR_INSV: /* insert field */
      (void) _bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_ASH: /* arithmetic shift */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (op1))	/* shift right */
	op2 >>= op1;
      else			/* shift left */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_USH: /* unsigned shift */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (op1))	/* shift right */
	op2 >>= op1;
      else			/* shift left */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_ROT: /* rotate */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (0))	/* shift right */
	op2 >>= op1;
      else		/* shift left */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_SEL: /* select */
      if ((long) _bfd_vms_pop (abfd, NULL) & 0x01L)
	(void) _bfd_vms_pop (abfd, NULL);
      else
	{
	  op1 = (long) _bfd_vms_pop (abfd, NULL);
	  (void) _bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad) op1, -1);
	}
      break;

    case TIR_S_C_OPR_REDEF: /* Redefine symbol to current location.  */
    case TIR_S_C_OPR_DFLIT: /* Define a literal.  */
      (*_bfd_error_handler) (_("%s: not supported"),
			     tir_cmd_name (ptr[-1]));
      break;

    default:
      (*_bfd_error_handler) (_("reserved OPR cmd %d"), ptr[-1]);
a1647 4
/* control commands

   See table 7-6 of the VAX/VMS linker manual.  */

d1650 5
d1665 11
a1675 14
    case TIR_S_C_CTL_SETRB:
      /* Set relocation base: pop stack, set image location counter
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      if (psect >= PRIV (section_count))
	alloc_section (abfd, psect);
      image_set_ptr (abfd, (int) psect, (uquad) dummy);
      break;

    case TIR_S_C_CTL_AUGRB:
      /* Augment relocation base: increment image location counter by offset
	 arg: lw	offset value.  */
      dummy = bfd_getl32 (ptr);
      image_inc_ptr (abfd, (uquad) dummy);
d1677 23
a1699 15

    case TIR_S_C_CTL_DFLOC:
      /* Define location: pop index, save location counter under index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_CTL_STLOC:
      /* Set location: pop index, restore location counter from index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
a1700 1

d1702 6
a1707 5
      /* Stack defined location: pop index, push location counter from index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
a1708 1

d1710 3
a1712 3
      (*_bfd_error_handler) (_("reserved CTL cmd %d"), ptr[-1]);
      break;
    }
d1716 3
a1718 1
/* Handle command from TIR section.  */
d1723 1
a1723 2
  struct
  {
d1727 6
a1732 8
  }
  tir_table[] =
  {
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta },
    { TIR_S_C_MINSTOCOD, TIR_S_C_MAXSTOCOD, tir_sto },
    { TIR_S_C_MINOPRCOD, TIR_S_C_MAXOPRCOD, tir_opr },
    { TIR_S_C_MINCTLCOD, TIR_S_C_MAXCTLCOD, tir_ctl },
    { -1, -1, NULL }
d1738 1
a1738 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d1752 1
a1752 1
	       && (*ptr <= tir_table[i].maxcod))
d1761 1
a1761 1
	  (*_bfd_error_handler) (_("obj code %d not found"), *ptr);
d1769 1
a1769 1
/* Handle command from ETIR section.  */
d1777 1
a1777 2
  static struct
  {
d1780 2
a1781 4
    bfd_boolean (*explain) PARAMS ((bfd *, int, unsigned char *));
  }
  etir_table[] =
  {
d1794 1
a1794 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d1800 1
a1800 1
	   && (cmd <= etir_table[i].maxcod))
d1816 1
a1816 1
   handle tir record.  */
d1843 1
a1843 1
   handle etir record.  */
d1878 3
a1880 2
/* Process ETIR record
   Return 0 on success, -1 on error.  */
d1895 13
a1907 13
    case EOBJ_S_C_ETIR:
      PRIV (vms_rec) += 4;	/* skip type, size */
      PRIV (rec_size) -= 4;
      result = analyze_etir (abfd, PRIV (vms_rec), (unsigned) PRIV (rec_size));
      break;
    case OBJ_S_C_TIR:
      PRIV (vms_rec) += 1;	/* skip type */
      PRIV (rec_size) -= 1;
      result = analyze_tir (abfd, PRIV (vms_rec), (unsigned) PRIV (rec_size));
      break;
    default:
      result = -1;
      break;
d1913 2
a1914 2
/* Process EDBG record
   Return 0 on success, -1 on error
d1916 1
a1916 1
   Not implemented yet.  */
d1931 2
a1932 2
/* Process ETBT record
   Return 0 on success, -1 on error
d1934 1
a1934 1
   Not implemented yet.  */
d1948 2
a1949 2
/* Process LNK record
   Return 0 on success, -1 on error
d1951 1
a1951 1
   Not implemented yet.  */
d1965 11
a1975 10
/* WRITE ETIR SECTION

   This is still under construction and therefore not documented.  */

static void start_etir_record
  PARAMS ((bfd *abfd, int index, uquad offset, bfd_boolean justoffset));
static void sto_imm
  PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record
  PARAMS ((bfd *abfd));
d1990 1
a1990 1
  _bfd_hexdump (9, sptr->contents, (int) sptr->size, (int) vaddr);
d1998 1
d2004 1
a2004 1
	  start_etir_record (abfd, index, vaddr, FALSE);
d2017 1
a2017 1
      _bfd_hexdump (10, cptr, (int) size, (int) vaddr);
d2024 2
d2028 3
a2030 1
/* Start ETIR record for section #index at virtual addr offset.  */
d2037 1
a2037 1
    bfd_boolean justoffset;
d2046 2
a2047 2
  _bfd_vms_output_long (abfd, (unsigned long) index);
  _bfd_vms_output_quad (abfd, (uquad) offset);
d2052 2
d2056 1
a2056 2
/* End etir record.  */

d2065 1
a2065 1
/* Write section contents for bfd abfd.  */
d2083 1
a2083 1
  PRIV (vms_linkage_index) = 1;
d2085 1
a2085 1
  /* Dump all other sections.  */
d2093 1
a2093 3
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n",
		      section->index, section->name,
		      (int) (section->_raw_size));
d2114 6
a2119 6
				  (*(*rptr)->sym_ptr_ptr)->name,
				  (*(*rptr)->sym_ptr_ptr)->section->name,
				  (long) (*(*rptr)->sym_ptr_ptr)->value,
				  (*rptr)->address, (*rptr)->addend,
				  bfd_get_reloc_size ((*rptr)->howto),
				  (*rptr)->howto->name);
d2127 1
a2127 1
	  && (! bfd_is_com_section (section)))
d2129 1
a2129 1
	  bfd_vma vaddr;		/* Virtual addr in section.  */
d2141 1
a2141 1
			     FALSE);
d2143 1
a2143 1
	  while (sptr != NULL)	/* one STA_PQ, CTL_SETRB per vms_section */
d2146 1
a2146 1
	      if (section->flags & SEC_RELOC)	/* check for relocs */
a2149 1

d2154 1
a2154 1
		      if (sptr->offset < addr)	/* sptr starts before reloc */
d2157 1
a2157 1
			  if (sptr->size <= before)	/* complete before */
d2174 1
a2174 1
		      else if (sptr->offset == addr) /* sptr starts at reloc */
d2188 3
a2190 4
				    int slen = strlen ((char *) sym->name);
				    char *hash;

				    if (_bfd_vms_output_check (abfd, slen) < 0)
d2195 1
a2195 1
							   vaddr, FALSE);
d2198 4
a2201 5
							   ETIR_S_C_STO_GBL_LW,
							   -1);
				    hash = (_bfd_vms_length_hash_symbol
					    (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_counted (abfd, hash);
d2211 1
a2211 1
							   vaddr, FALSE);
d2214 2
a2215 2
							   ETIR_S_C_STA_LW,
							   -1);
d2217 1
a2217 1
							  (uquad) sym->value);
d2220 2
a2221 2
							   ETIR_S_C_STO_LW,
							   -1);
d2231 1
a2231 1
							   vaddr, FALSE);
d2234 2
a2235 2
							   ETIR_S_C_STA_PQ,
							   -1);
d2237 1
a2237 1
							  (unsigned long) (sec->index));
d2239 2
a2240 2
							  ((uquad) (*rptr)->addend
							   + (uquad) sym->value));
d2243 2
a2244 2
							   ETIR_S_C_STO_LW,
							   -1);
d2254 3
a2256 3
				    int slen = strlen ((char *) sym->name);
				    char *hash;
				    if (_bfd_vms_output_check (abfd, slen) < 0)
d2261 1
a2261 1
							   vaddr, FALSE);
d2264 4
a2267 5
							   ETIR_S_C_STO_GBL,
							   -1);
				    hash = (_bfd_vms_length_hash_symbol
					    (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_counted (abfd, hash);
d2277 1
a2277 1
							   vaddr, FALSE);
d2280 2
a2281 2
							   ETIR_S_C_STA_QW,
							   -1);
d2283 1
a2283 1
							  (uquad) sym->value);
d2286 2
a2287 2
							   ETIR_S_C_STO_QW,
							   -1);
d2297 1
a2297 1
							   vaddr, FALSE);
d2300 2
a2301 2
							   ETIR_S_C_STA_PQ,
							   -1);
d2303 1
a2303 1
							  (unsigned long) (sec->index));
d2305 2
a2306 2
							  ((uquad) (*rptr)->addend
							   + (uquad) sym->value));
d2309 2
a2310 2
							   ETIR_S_C_STO_OFF,
							   -1);
a2318 1
				char *hash ATTRIBUTE_UNUSED;
d2325 3
a2327 9
				vms_output_begin (abfd,
						  ETIR_S_C_STO_HINT_GBL, -1);
				vms_output_long (abfd,
						 (unsigned long) (sec->index));
				vms_output_quad (abfd, (uquad) addr);

				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				vms_output_counted (abfd, hash);
d2329 2
a2330 1
				vms_output_flush (abfd);
a2335 2
				char *hash;

d2340 1
a2340 1
						       vaddr, FALSE);
d2343 2
a2344 2
						       ETIR_S_C_STC_LP_PSB,
						       -1);
d2346 4
a2349 5
						      (unsigned long) PRIV (vms_linkage_index));
				PRIV (vms_linkage_index) += 2;
				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_counted (abfd, hash);
d2357 3
a2359 3
				int slen = strlen ((char *) sym->name);
				char *hash;
				if (_bfd_vms_output_check (abfd, slen) < 0)
d2364 1
a2364 1
						       vaddr, FALSE);
d2367 4
a2370 5
						       ETIR_S_C_STO_CA,
						       -1);
				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_counted (abfd, hash);
d2396 1
a2396 1
		      else			/* sptr starts after reloc */
d2398 1
a2398 1
			  i--;			/* check next reloc */
d2402 1
a2402 1
		      if (i==0)			/* all reloc checked */
d2406 1
a2406 2
			      /* dump rest */
			      sto_imm (abfd, sptr, vaddr, section->index);
d2413 1
a2413 1
	      else				/* no relocs, just dump */
d2430 1
a2430 1
  _bfd_vms_output_alignment (abfd, 2);
d2434 1
a2434 1
/* Write traceback data for bfd abfd.  */
d2448 1
a2448 1
/* Write debug info for bfd abfd.  */
@


