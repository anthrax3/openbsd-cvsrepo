head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	FSF:1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.11;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.20;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.06.08;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.06.08;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.20.08;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.50;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.26.46;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.18;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.31;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for linux flavored m68k a.out binaries.
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define	TARGET_PAGE_SIZE 4096
#define ZMAGIC_DISK_BLOCK_SIZE 1024
#define	SEGMENT_SIZE TARGET_PAGE_SIZE
#define TEXT_START_ADDR	0x0
#define N_SHARED_LIB(x) 0

#define MACHTYPE_OK(mtype) ((mtype) == M_68020 || (mtype) == M_UNKNOWN)

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"
#include "aout/ar.h"
#include "libaout.h"           /* BFD a.out internal data structures */

#define TARGET_IS_BIG_ENDIAN_P
#define DEFAULT_ARCH bfd_arch_m68k

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (m68klinux_,OP)
#define TARGETNAME "a.out-m68k-linux"

extern const bfd_target MY(vec);

/* We always generate QMAGIC files in preference to ZMAGIC files.  It
   would be possible to make this a linker option, if that ever
   becomes important.  */

static void MY_final_link_callback
  PARAMS ((bfd *, file_ptr *, file_ptr *, file_ptr *));
static bfd_boolean m68klinux_bfd_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean m68klinux_write_object_contents PARAMS ((bfd *));

static bfd_boolean
m68klinux_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  obj_aout_subformat (abfd) = q_magic_format;
  return NAME(aout,final_link) (abfd, info, MY_final_link_callback);
}

#define MY_bfd_final_link m68klinux_bfd_final_link

/* Set the machine type correctly.  */

static bfd_boolean
m68klinux_write_object_contents (abfd)
     bfd *abfd;
{
  struct external_exec exec_bytes;
  struct internal_exec *execp = exec_hdr (abfd);

  N_SET_MACHTYPE (*execp, M_68020);

  obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;

  WRITE_HEADERS(abfd, execp);

  return TRUE;
}

#define MY_write_object_contents m68klinux_write_object_contents

/* Code to link against Linux a.out shared libraries.  */

/* See if a symbol name is a reference to the global offset table.  */

#ifndef GOT_REF_PREFIX
#define	GOT_REF_PREFIX	"__GOT_"
#endif

#define IS_GOT_SYM(name) \
  (strncmp (name, GOT_REF_PREFIX, sizeof GOT_REF_PREFIX - 1) == 0)

/* See if a symbol name is a reference to the procedure linkage table.  */

#ifndef PLT_REF_PREFIX
#define	PLT_REF_PREFIX	"__PLT_"
#endif

#define IS_PLT_SYM(name) \
  (strncmp (name, PLT_REF_PREFIX, sizeof PLT_REF_PREFIX - 1) == 0)

/* This string is used to generate specialized error messages.  */

#ifndef NEEDS_SHRLIB
#define NEEDS_SHRLIB "__NEEDS_SHRLIB_"
#endif

/* This special symbol is a set vector that contains a list of
   pointers to fixup tables.  It will be present in any dynamically
   linked file.  The linker generated fixup table should also be added
   to the list, and it should always appear in the second slot (the
   first one is a dummy with a magic number that is defined in
   crt0.o).  */

#ifndef SHARABLE_CONFLICTS
#define SHARABLE_CONFLICTS "__SHARABLE_CONFLICTS__"
#endif

/* We keep a list of fixups.  The terminology is a bit strange, but
   each fixup contains two 32 bit numbers.  A regular fixup contains
   an address and a pointer, and at runtime we should store the
   address at the location pointed to by the pointer.  A builtin fixup
   contains two pointers, and we should read the address using one
   pointer and store it at the location pointed to by the other
   pointer.  Builtin fixups come into play when we have duplicate
   __GOT__ symbols for the same variable.  The builtin fixup will copy
   the GOT pointer from one over into the other.  */

struct fixup
{
  struct fixup *next;
  struct linux_link_hash_entry *h;
  bfd_vma value;

  /* Nonzero if this is a jump instruction that needs to be fixed,
     zero if this is just a pointer */
  char jump;

  char builtin;
};

/* We don't need a special hash table entry structure, but we do need
   to keep some information between linker passes, so we use a special
   hash table.  */

struct linux_link_hash_entry
{
  struct aout_link_hash_entry root;
};

struct linux_link_hash_table
{
  struct aout_link_hash_table root;

  /* First dynamic object found in link.  */
  bfd *dynobj;

  /* Number of fixups.  */
  size_t fixup_count;

  /* Number of builtin fixups.  */
  size_t local_builtins;

  /* List of fixups.  */
  struct fixup *fixup_list;
};

static struct bfd_hash_entry *linux_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *linux_link_hash_table_create
  PARAMS ((bfd *));
static struct fixup *new_fixup
  PARAMS ((struct bfd_link_info *, struct linux_link_hash_entry *,
	   bfd_vma, int));
static bfd_boolean linux_link_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean linux_add_one_symbol
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
	   struct bfd_link_hash_entry **));
static bfd_boolean linux_tally_symbols
  PARAMS ((struct linux_link_hash_entry *, PTR));
static bfd_boolean linux_finish_dynamic_link
  PARAMS ((bfd *, struct bfd_link_info *));

/* Routine to create an entry in an Linux link hash table.  */

static struct bfd_hash_entry *
linux_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct linux_link_hash_entry *ret = (struct linux_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct linux_link_hash_entry *) NULL)
    ret = ((struct linux_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct linux_link_hash_entry)));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct linux_link_hash_entry *)
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
  if (ret != NULL)
    {
      /* Set local fields; there aren't any.  */
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a Linux link hash table.  */

static struct bfd_link_hash_table *
linux_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct linux_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct linux_link_hash_table);

  ret = (struct linux_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct linux_link_hash_table *) NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_link_hash_table *) NULL;
    }
  if (! NAME(aout,link_hash_table_init) (&ret->root, abfd,
					 linux_link_hash_newfunc))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  ret->dynobj = NULL;
  ret->fixup_count = 0;
  ret->local_builtins = 0;
  ret->fixup_list = NULL;

  return &ret->root.root;
}

/* Look up an entry in a Linux link hash table.  */

#define linux_link_hash_lookup(table, string, create, copy, follow) \
  ((struct linux_link_hash_entry *) \
   aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			  (follow)))

/* Traverse a Linux link hash table.  */

#define linux_link_hash_traverse(table, func, info)			\
  (aout_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the Linux link hash table from the info structure.  This is
   just a cast.  */

#define linux_hash_table(p) ((struct linux_link_hash_table *) ((p)->hash))

/* Store the information for a new fixup.  */

static struct fixup *
new_fixup (info, h, value, builtin)
     struct bfd_link_info *info;
     struct linux_link_hash_entry *h;
     bfd_vma value;
     int builtin;
{
  struct fixup *f;

  f = (struct fixup *) bfd_hash_allocate (&info->hash->table,
					  sizeof (struct fixup));
  if (f == NULL)
    return f;
  f->next = linux_hash_table (info)->fixup_list;
  linux_hash_table (info)->fixup_list = f;
  f->h = h;
  f->value = value;
  f->builtin = builtin;
  f->jump = 0;
  ++linux_hash_table (info)->fixup_count;
  return f;
}

/* We come here once we realize that we are going to link to a shared
   library.  We need to create a special section that contains the
   fixup table, and we ultimately need to add a pointer to this into
   the set vector for SHARABLE_CONFLICTS.  At this point we do not
   know the size of the section, but that's OK - we just need to
   create it for now.  */

static bfd_boolean
linux_link_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  flagword flags;
  register asection *s;

  /* Note that we set the SEC_IN_MEMORY flag.  */
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;

  /* We choose to use the name ".linux-dynamic" for the fixup table.
     Why not? */
  s = bfd_make_section (abfd, ".linux-dynamic");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;
  s->_raw_size = 0;
  s->contents = 0;

  return TRUE;
}

/* Function to add a single symbol to the linker hash table.  This is
   a wrapper around _bfd_generic_link_add_one_symbol which handles the
   tweaking needed for dynamic linking support.  */

static bfd_boolean
linux_add_one_symbol (info, abfd, name, flags, section, value, string,
		      copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
{
  struct linux_link_hash_entry *h;
  bfd_boolean insert;

  /* Look up and see if we already have this symbol in the hash table.
     If we do, and the defining entry is from a shared library, we
     need to create the dynamic sections.

     FIXME: What if abfd->xvec != info->hash->creator?  We may want to
     be able to link Linux a.out and ELF objects together, but serious
     confusion is possible.  */

  insert = FALSE;

  if (! info->relocatable
      && linux_hash_table (info)->dynobj == NULL
      && strcmp (name, SHARABLE_CONFLICTS) == 0
      && (flags & BSF_CONSTRUCTOR) != 0
      && abfd->xvec == info->hash->creator)
    {
      if (! linux_link_create_dynamic_sections (abfd, info))
	return FALSE;
      linux_hash_table (info)->dynobj = abfd;
      insert = TRUE;
    }

  if (bfd_is_abs_section (section)
      && abfd->xvec == info->hash->creator)
    {
      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,
				  FALSE, FALSE);
      if (h != NULL
	  && (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak))
	{
	  struct fixup *f;

	  if (hashp != NULL)
	    *hashp = (struct bfd_link_hash_entry *) h;

	  f = new_fixup (info, h, value, ! IS_PLT_SYM (name));
	  if (f == NULL)
	    return FALSE;
	  f->jump = IS_PLT_SYM (name);

	  return TRUE;
	}
    }

  /* Do the usual procedure for adding a symbol.  */
  if (! _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,
					  value, string, copy, collect,
					  hashp))
    return FALSE;

  /* Insert a pointer to our table in the set vector.  The dynamic
     linker requires this information */
  if (insert)
    {
      asection *s;

      /* Here we do our special thing to add the pointer to the
	 dynamic section in the SHARABLE_CONFLICTS set vector.  */
      s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
				   ".linux-dynamic");
      BFD_ASSERT (s != NULL);

      if (! (_bfd_generic_link_add_one_symbol
	     (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	      FALSE, FALSE, NULL)))
	return FALSE;
    }

  return TRUE;
}

/* We will crawl the hash table and come here for every global symbol.
   We will examine each entry and see if there are indications that we
   need to add a fixup.  There are two possible cases - one is where
   you have duplicate definitions of PLT or GOT symbols - these will
   have already been caught and added as "builtin" fixups.  If we find
   that the corresponding non PLT/GOT symbol is also present, we
   convert it to a regular fixup instead.

   This function is called via linux_link_hash_traverse.  */

static bfd_boolean
linux_tally_symbols (h, data)
     struct linux_link_hash_entry *h;
     PTR data;
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;
  struct fixup *f, *f1;
  int is_plt;
  struct linux_link_hash_entry *h1, *h2;
  bfd_boolean exists;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct linux_link_hash_entry *) h->root.root.u.i.link;

  if (h->root.root.type == bfd_link_hash_undefined
      && strncmp (h->root.root.root.string, NEEDS_SHRLIB,
		  sizeof NEEDS_SHRLIB - 1) == 0)
    {
      const char *name;
      char *p;
      char *alloc = NULL;

      name = h->root.root.root.string + sizeof NEEDS_SHRLIB - 1;
      p = strrchr (name, '_');
      if (p != NULL)
	alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);

      if (p == NULL || alloc == NULL)
	(*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
			       name);
      else
	{
	  strcpy (alloc, name);
	  p = strrchr (alloc, '_');
	  *p++ = '\0';
	  (*_bfd_error_handler)
	    (_("Output file requires shared library `%s.so.%s'\n"),
	     alloc, p);
	  free (alloc);
	}

      abort ();
    }

  /* If this symbol is not a PLT/GOT, we do not even need to look at it */
  is_plt = IS_PLT_SYM (h->root.root.root.string);

  if (is_plt || IS_GOT_SYM (h->root.root.root.string))
    {
      /* Look up this symbol twice.  Once just as a regular lookup,
	 and then again following all of the indirect links until we
	 reach a real symbol.  */
      h1 = linux_link_hash_lookup (linux_hash_table (info),
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, TRUE);
      /* h2 does not follow indirect symbols.  */
      h2 = linux_link_hash_lookup (linux_hash_table (info),
				   (h->root.root.root.string
				    + sizeof PLT_REF_PREFIX - 1),
				   FALSE, FALSE, FALSE);

      /* The real symbol must exist but if it is also an ABS symbol,
	 there is no need to have a fixup.  This is because they both
	 came from the same library.  If on the other hand, we had to
	 use an indirect symbol to get to the real symbol, we add the
	 fixup anyway, since there are cases where these symbols come
	 from different shared libraries */
      if (h1 != NULL
	  && (((h1->root.root.type == bfd_link_hash_defined
		|| h1->root.root.type == bfd_link_hash_defweak)
	       && ! bfd_is_abs_section (h1->root.root.u.def.section))
	      || h2->root.root.type == bfd_link_hash_indirect))
	{
	  /* See if there is a "builtin" fixup already present
	     involving this symbol.  If so, convert it to a regular
	     fixup.  In the end, this relaxes some of the requirements
	     about the order of performing fixups.  */
	  exists = FALSE;
	  for (f1 = linux_hash_table (info)->fixup_list;
	       f1 != NULL;
	       f1 = f1->next)
	    {
	      if ((f1->h != h && f1->h != h1)
		  || (! f1->builtin && ! f1->jump))
		continue;
	      if (f1->h == h1)
		exists = TRUE;
	      if (! exists
		  && bfd_is_abs_section (h->root.root.u.def.section))
		{
		  f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);
		  f->jump = is_plt;
		}
	      f1->h = h1;
	      f1->jump = is_plt;
	      f1->builtin = 0;
	      exists = TRUE;
	    }
	  if (! exists
	      && bfd_is_abs_section (h->root.root.u.def.section))
	    {
	      f = new_fixup (info, h1, h->root.root.u.def.value, 0);
	      if (f == NULL)
		{
		  /* FIXME: No way to return error.  */
		  abort ();
		}
	      f->jump = is_plt;
	    }
	}

      /* Quick and dirty way of stripping these symbols from the
	 symtab.  */
      if (bfd_is_abs_section (h->root.root.u.def.section))
	h->root.written = TRUE;
    }

  return TRUE;
}

/* This is called to set the size of the .linux-dynamic section is.
   It is called by the Linux linker emulation before_allocation
   routine.  We have finished reading all of the input files, and now
   we just scan the hash tables to find out how many additional fixups
   are required.  */

bfd_boolean
bfd_m68klinux_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct fixup *f;
  asection *s;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* First find the fixups...  */
  linux_link_hash_traverse (linux_hash_table (info),
			    linux_tally_symbols,
			    (PTR) info);

  /* If there are builtin fixups, leave room for a marker.  This is
     used by the dynamic linker so that it knows that all that follow
     are builtin fixups instead of regular fixups.  */
  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
    {
      if (f->builtin)
	{
	  ++linux_hash_table (info)->fixup_count;
	  ++linux_hash_table (info)->local_builtins;
	  break;
	}
    }

  if (linux_hash_table (info)->dynobj == NULL)
    {
      if (linux_hash_table (info)->fixup_count > 0)
	abort ();
      return TRUE;
    }

  /* Allocate memory for our fixup table.  We will fill it in later.  */
  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
			       ".linux-dynamic");
  if (s != NULL)
    {
      s->_raw_size = linux_hash_table (info)->fixup_count + 1;
      s->_raw_size *= 8;
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
      if (s->contents == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
    }

  return TRUE;
}

/* We come here once we are ready to actually write the fixup table to
   the output file.  Scan the fixup tables and so forth and generate
   the stuff we need.  */

static bfd_boolean
linux_finish_dynamic_link (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  asection *s, *os, *is;
  bfd_byte *fixup_table;
  struct linux_link_hash_entry *h;
  struct fixup *f;
  unsigned int new_addr;
  int section_offset;
  unsigned int fixups_written;

  if (linux_hash_table (info)->dynobj == NULL)
    return TRUE;

  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,
			       ".linux-dynamic");
  BFD_ASSERT (s != NULL);
  os = s->output_section;
  fixups_written = 0;

#ifdef LINUX_LINK_DEBUG
  printf ("Fixup table file offset: %x  VMA: %x\n",
	  os->filepos + s->output_offset,
	  os->vma + s->output_offset);
#endif

  fixup_table = s->contents;
  bfd_put_32 (output_bfd, (bfd_vma) linux_hash_table (info)->fixup_count,
	      fixup_table);
  fixup_table += 4;

  /* Fill in fixup table.  */
  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
    {
      if (f->builtin)
	continue;

      if (f->h->root.root.type != bfd_link_hash_defined
	  && f->h->root.root.type != bfd_link_hash_defweak)
	{
	  (*_bfd_error_handler)
	    (_("Symbol %s not defined for fixups\n"),
	     f->h->root.root.root.string);
	  continue;
	}

      is = f->h->root.root.u.def.section;
      section_offset = is->output_section->vma + is->output_offset;
      new_addr = f->h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
      printf ("Fixup(%d) %s: %x %x\n",f->jump, f->h->root.root.string,
	      new_addr, f->value);
#endif

      if (f->jump)
	{
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value + 2, fixup_table);
	  fixup_table += 4;
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	}
      ++fixups_written;
    }

  if (linux_hash_table (info)->local_builtins != 0)
    {
      /* Special marker so we know to switch to the other type of fixup */
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
      fixup_table += 4;
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
      fixup_table += 4;
      ++fixups_written;
      for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)
	{
	  if (! f->builtin)
	    continue;

	  if (f->h->root.root.type != bfd_link_hash_defined
	      && f->h->root.root.type != bfd_link_hash_defweak)
	    {
	      (*_bfd_error_handler)
		(_("Symbol %s not defined for fixups\n"),
		 f->h->root.root.root.string);
	      continue;
	    }

	  is = f->h->root.root.u.def.section;
	  section_offset = is->output_section->vma + is->output_offset;
	  new_addr = f->h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
	  printf ("Fixup(B) %s: %x %x\n", f->h->root.root.string,
		  new_addr, f->value);
#endif

	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, f->value, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
  }

  if (linux_hash_table (info)->fixup_count != fixups_written)
    {
      (*_bfd_error_handler) (_("Warning: fixup count mismatch\n"));
      while (linux_hash_table (info)->fixup_count > fixups_written)
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
	  fixup_table += 4;
	  ++fixups_written;
	}
    }

  h = linux_link_hash_lookup (linux_hash_table (info),
			      "__BUILTIN_FIXUPS__",
			      FALSE, FALSE, FALSE);

  if (h != NULL
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak))
    {
      is = h->root.root.u.def.section;
      section_offset = is->output_section->vma + is->output_offset;
      new_addr = h->root.root.u.def.value + section_offset;

#ifdef LINUX_LINK_DEBUG
      printf ("Builtin fixup table at %x\n", new_addr);
#endif

      bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
    }
  else
    bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);

  if (bfd_seek (output_bfd, (file_ptr) (os->filepos + s->output_offset),
		SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd) != s->_raw_size)
    return FALSE;

  return TRUE;
}

#define MY_bfd_link_hash_table_create linux_link_hash_table_create
#define MY_add_one_symbol linux_add_one_symbol
#define MY_finish_dynamic_link linux_finish_dynamic_link

#define MY_zmagic_contiguous 1

#include "aout-target.h"
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d116 1
a116 1
   pointers to fixup tables.  It will be present in any dynamicly
d360 1
a360 1
  if (! info->relocateable
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000
a25 1
#define BYTES_IN_WORD 4
d39 5
a43 1
#define MY(OP) CAT(m68klinux_,OP)
d54 1
a54 1
static boolean m68klinux_bfd_final_link
d56 1
a56 1
static boolean m68klinux_write_object_contents PARAMS ((bfd *));
d58 1
a58 1
static boolean
d71 1
a71 1
static boolean
d84 1
a84 1
  return true;
d182 1
a182 1
static boolean linux_link_create_dynamic_sections
d184 1
a184 1
static boolean linux_add_one_symbol
d186 1
a186 1
	   bfd_vma, const char *, boolean, boolean,
d188 1
a188 1
static boolean linux_tally_symbols
d190 1
a190 1
static boolean linux_finish_dynamic_link
d230 1
d232 1
a232 2
  ret = ((struct linux_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct linux_link_hash_table)));
d265 1
a265 1
    (boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\
d305 1
a305 1
static boolean
d322 1
a322 1
    return false;
d326 1
a326 1
  return true;
d333 1
a333 1
static boolean
d343 2
a344 2
     boolean copy;
     boolean collect;
d348 1
a348 1
  boolean insert;
d358 1
a358 1
  insert = false;
d367 1
a367 1
	return false;
d369 1
a369 1
      insert = true;
d375 2
a376 2
      h = linux_link_hash_lookup (linux_hash_table (info), name, false,
				  false, false);
d388 1
a388 1
	    return false;
d391 1
a391 1
	  return true;
d399 1
a399 1
    return false;
d415 3
a417 2
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, 0, NULL, false, false, NULL)))
	return false;
d420 1
a420 1
  return true;
d433 1
a433 1
static boolean
d442 4
a445 1
  boolean exists;
d458 1
a458 1
	alloc = (char *) bfd_malloc (strlen (name) + 1);
d488 1
a488 1
				   false, false, true);
d493 1
a493 1
				   false, false, false);
d511 1
a511 1
	  exists = false;
d520 1
a520 1
		exists = true;
d530 1
a530 1
	      exists = true;
d548 1
a548 1
	h->root.written = true;
d551 1
a551 1
  return true;
d560 1
a560 1
boolean
d569 1
a569 1
    return true;
d593 1
a593 1
      return true;
d601 3
a603 2
      s->_raw_size = 8 + linux_hash_table (info)->fixup_count * 8;
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
d607 1
a607 1
	  return false;
a608 1
      memset (s->contents, 0, (size_t) s->_raw_size);
d611 1
a611 1
  return true;
d618 1
a618 1
static boolean
d632 1
a632 1
    return true;
d647 2
a648 1
  bfd_put_32 (output_bfd, linux_hash_table (info)->fixup_count, fixup_table);
d677 1
a677 1
	  bfd_put_32 (output_bfd, new_addr, fixup_table);
d684 1
a684 1
	  bfd_put_32 (output_bfd, new_addr, fixup_table);
d695 1
a695 1
      bfd_put_32 (output_bfd, 0, fixup_table);
d697 1
a697 1
      bfd_put_32 (output_bfd, 0, fixup_table);
d723 1
a723 1
	  bfd_put_32 (output_bfd, new_addr, fixup_table);
d736 1
a736 1
	  bfd_put_32 (output_bfd, 0, fixup_table);
d738 1
a738 1
	  bfd_put_32 (output_bfd, 0, fixup_table);
d746 1
a746 1
			      false, false, false);
d760 1
a760 1
      bfd_put_32 (output_bfd, new_addr, fixup_table);
d763 1
a763 1
    bfd_put_32 (output_bfd, 0, fixup_table);
d765 3
a767 2
  if (bfd_seek (output_bfd, os->filepos + s->output_offset, SEEK_SET) != 0)
    return false;
d769 2
a770 3
  if (bfd_write ((PTR) s->contents, 1, s->_raw_size, output_bfd)
      != s->_raw_size)
    return false;
d772 1
a772 1
  return true;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999
d482 2
a483 2
      /* h2 does not follow indirect symbols. */
      h2 = linux_link_hash_lookup (linux_hash_table (info), 
d539 1
a539 1
	 symtab. */
d564 1
a564 1
  /* First find the fixups... */
d634 1
a634 1
  printf ("Fixup table file offset: %x  VMA: %x\n", 
d736 1
a736 1
  h = linux_link_hash_lookup (linux_hash_table (info), 
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 1996 Free Software Foundation, Inc.
d28 2
d51 3
d305 1
a305 1
     struct bfd_link_info *info;
d454 1
a454 1
	(*_bfd_error_handler) ("Output file requires shared library `%s'\n",
d462 1
a462 1
	    ("Output file requires shared library `%s.so.%s'\n",
d653 1
a653 1
	    ("Symbol %s not defined for fixups\n",
d701 1
a701 1
		("Symbol %s not defined for fixups\n",
d725 1
a725 1
      (*_bfd_error_handler) ("Warning: fixup count mismatch\n");
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a26 2
#define MACHTYPE_OK(mtype) ((mtype) == M_68020 || (mtype) == M_UNKNOWN)

a47 3
static boolean m68klinux_bfd_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean m68klinux_write_object_contents PARAMS ((bfd *));
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d304 1
a304 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d453 1
a453 1
	(*_bfd_error_handler) (_("Output file requires shared library `%s'\n"),
d461 1
a461 1
	    (_("Output file requires shared library `%s.so.%s'\n"),
d652 1
a652 1
	    (_("Symbol %s not defined for fixups\n"),
d700 1
a700 1
		(_("Symbol %s not defined for fixups\n"),
d724 1
a724 1
      (*_bfd_error_handler) (_("Warning: fixup count mismatch\n"));
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000
d482 2
a483 2
      /* h2 does not follow indirect symbols.  */
      h2 = linux_link_hash_lookup (linux_hash_table (info),
d539 1
a539 1
	 symtab.  */
d564 1
a564 1
  /* First find the fixups...  */
d634 1
a634 1
  printf ("Fixup table file offset: %x  VMA: %x\n",
d736 1
a736 1
  h = linux_link_hash_lookup (linux_hash_table (info),
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003
d26 1
d40 1
a40 5

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (m68klinux_,OP)
d51 1
a51 1
static bfd_boolean m68klinux_bfd_final_link
d53 1
a53 1
static bfd_boolean m68klinux_write_object_contents PARAMS ((bfd *));
d55 1
a55 1
static bfd_boolean
d68 1
a68 1
static bfd_boolean
d81 1
a81 1
  return TRUE;
d179 1
a179 1
static bfd_boolean linux_link_create_dynamic_sections
d181 1
a181 1
static bfd_boolean linux_add_one_symbol
d183 1
a183 1
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
d185 1
a185 1
static bfd_boolean linux_tally_symbols
d187 1
a187 1
static bfd_boolean linux_finish_dynamic_link
a226 1
  bfd_size_type amt = sizeof (struct linux_link_hash_table);
d228 2
a229 1
  ret = (struct linux_link_hash_table *) bfd_malloc (amt);
d262 1
a262 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\
d302 1
a302 1
static bfd_boolean
d319 1
a319 1
    return FALSE;
d323 1
a323 1
  return TRUE;
d330 1
a330 1
static bfd_boolean
d340 2
a341 2
     bfd_boolean copy;
     bfd_boolean collect;
d345 1
a345 1
  bfd_boolean insert;
d355 1
a355 1
  insert = FALSE;
d364 1
a364 1
	return FALSE;
d366 1
a366 1
      insert = TRUE;
d372 2
a373 2
      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,
				  FALSE, FALSE);
d385 1
a385 1
	    return FALSE;
d388 1
a388 1
	  return TRUE;
d396 1
a396 1
    return FALSE;
d412 2
a413 3
	      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,
	      FALSE, FALSE, NULL)))
	return FALSE;
d416 1
a416 1
  return TRUE;
d429 1
a429 1
static bfd_boolean
d438 1
a438 4
  bfd_boolean exists;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct linux_link_hash_entry *) h->root.root.u.i.link;
d451 1
a451 1
	alloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);
d481 1
a481 1
				   FALSE, FALSE, TRUE);
d486 1
a486 1
				   FALSE, FALSE, FALSE);
d504 1
a504 1
	  exists = FALSE;
d513 1
a513 1
		exists = TRUE;
d523 1
a523 1
	      exists = TRUE;
d541 1
a541 1
	h->root.written = TRUE;
d544 1
a544 1
  return TRUE;
d553 1
a553 1
bfd_boolean
d562 1
a562 1
    return TRUE;
d586 1
a586 1
      return TRUE;
d594 2
a595 3
      s->_raw_size = linux_hash_table (info)->fixup_count + 1;
      s->_raw_size *= 8;
      s->contents = (bfd_byte *) bfd_zalloc (output_bfd, s->_raw_size);
d599 1
a599 1
	  return FALSE;
d601 1
d604 1
a604 1
  return TRUE;
d611 1
a611 1
static bfd_boolean
d625 1
a625 1
    return TRUE;
d640 1
a640 2
  bfd_put_32 (output_bfd, (bfd_vma) linux_hash_table (info)->fixup_count,
	      fixup_table);
d669 1
a669 1
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
d676 1
a676 1
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
d687 1
a687 1
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
d689 1
a689 1
      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
d715 1
a715 1
	  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
d728 1
a728 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
d730 1
a730 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
d738 1
a738 1
			      FALSE, FALSE, FALSE);
d752 1
a752 1
      bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);
d755 1
a755 1
    bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);
d757 2
a758 3
  if (bfd_seek (output_bfd, (file_ptr) (os->filepos + s->output_offset),
		SEEK_SET) != 0)
    return FALSE;
d760 3
a762 2
  if (bfd_bwrite ((PTR) s->contents, s->_raw_size, output_bfd) != s->_raw_size)
    return FALSE;
d764 1
a764 1
  return TRUE;
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d116 1
a116 1
   pointers to fixup tables.  It will be present in any dynamically
d360 1
a360 1
  if (! info->relocatable
@


