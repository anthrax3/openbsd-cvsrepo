head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.54
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.10;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.19;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.59;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.59;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.05;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.49;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.26.35;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* HP PA-RISC SOM object file format:  definitions internal to BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2003 Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah (pa-gdb-bugs@@cs.utah.edu).

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _LIBHPPA_H
#define _LIBHPPA_H

#define BYTES_IN_WORD 4
#define PA_PAGESIZE 0x1000

/* The PA instruction set variants.  */
enum pa_arch {pa10 = 10, pa11 = 11, pa20 = 20, pa20w = 25};

/* HP PA-RISC relocation types */

enum hppa_reloc_field_selector_type
  {
    R_HPPA_FSEL = 0x0,
    R_HPPA_LSSEL = 0x1,
    R_HPPA_RSSEL = 0x2,
    R_HPPA_LSEL = 0x3,
    R_HPPA_RSEL = 0x4,
    R_HPPA_LDSEL = 0x5,
    R_HPPA_RDSEL = 0x6,
    R_HPPA_LRSEL = 0x7,
    R_HPPA_RRSEL = 0x8,
    R_HPPA_NSEL  = 0x9,
    R_HPPA_NLSEL  = 0xa,
    R_HPPA_NLRSEL  = 0xb,
    R_HPPA_PSEL = 0xc,
    R_HPPA_LPSEL = 0xd,
    R_HPPA_RPSEL = 0xe,
    R_HPPA_TSEL = 0xf,
    R_HPPA_LTSEL = 0x10,
    R_HPPA_RTSEL = 0x11,
    R_HPPA_LTPSEL = 0x12,
    R_HPPA_RTPSEL = 0x13
  };

/* /usr/include/reloc.h defines these to constants.  We want to use
   them in enums, so #undef them before we start using them.  We might
   be able to fix this another way by simply managing not to include
   /usr/include/reloc.h, but currently GDB picks up these defines
   somewhere.  */
#undef e_fsel
#undef e_lssel
#undef e_rssel
#undef e_lsel
#undef e_rsel
#undef e_ldsel
#undef e_rdsel
#undef e_lrsel
#undef e_rrsel
#undef e_nsel
#undef e_nlsel
#undef e_nlrsel
#undef e_psel
#undef e_lpsel
#undef e_rpsel
#undef e_tsel
#undef e_ltsel
#undef e_rtsel
#undef e_one
#undef e_two
#undef e_pcrel
#undef e_con
#undef e_plabel
#undef e_abs

/* for compatibility */
enum hppa_reloc_field_selector_type_alt
  {
    e_fsel = R_HPPA_FSEL,
    e_lssel = R_HPPA_LSSEL,
    e_rssel = R_HPPA_RSSEL,
    e_lsel = R_HPPA_LSEL,
    e_rsel = R_HPPA_RSEL,
    e_ldsel = R_HPPA_LDSEL,
    e_rdsel = R_HPPA_RDSEL,
    e_lrsel = R_HPPA_LRSEL,
    e_rrsel = R_HPPA_RRSEL,
    e_nsel = R_HPPA_NSEL,
    e_nlsel = R_HPPA_NLSEL,
    e_nlrsel = R_HPPA_NLRSEL,
    e_psel = R_HPPA_PSEL,
    e_lpsel = R_HPPA_LPSEL,
    e_rpsel = R_HPPA_RPSEL,
    e_tsel = R_HPPA_TSEL,
    e_ltsel = R_HPPA_LTSEL,
    e_rtsel = R_HPPA_RTSEL,
    e_ltpsel = R_HPPA_LTPSEL,
    e_rtpsel = R_HPPA_RTPSEL
  };

enum hppa_reloc_expr_type
  {
    R_HPPA_E_ONE = 0,
    R_HPPA_E_TWO = 1,
    R_HPPA_E_PCREL = 2,
    R_HPPA_E_CON = 3,
    R_HPPA_E_PLABEL = 7,
    R_HPPA_E_ABS = 18
  };

/* for compatibility */
enum hppa_reloc_expr_type_alt
  {
    e_one = R_HPPA_E_ONE,
    e_two = R_HPPA_E_TWO,
    e_pcrel = R_HPPA_E_PCREL,
    e_con = R_HPPA_E_CON,
    e_plabel = R_HPPA_E_PLABEL,
    e_abs = R_HPPA_E_ABS
  };


/* Relocations for function calls must be accompanied by parameter
   relocation bits.  These bits describe exactly where the caller has
   placed the function's arguments and where it expects to find a return
   value.

   Both ELF and SOM encode this information within the addend field
   of the call relocation.  (Note this could break very badly if one
   was to make a call like bl foo + 0x12345678).

   The high order 10 bits contain parameter relocation information,
   the low order 22 bits contain the constant offset.  */

#define HPPA_R_ARG_RELOC(a)	\
  (((a) >> 22) & 0x3ff)
#define HPPA_R_CONSTANT(a)	\
  ((((bfd_signed_vma)(a)) << (BFD_ARCH_SIZE-22)) >> (BFD_ARCH_SIZE-22))
#define HPPA_R_ADDEND(r, c)	\
  (((r) << 22) + ((c) & 0x3fffff))


/* Some functions to manipulate PA instructions.  */

/* Declare the functions with the unused attribute to avoid warnings.  */
static inline int sign_extend (int, int) ATTRIBUTE_UNUSED;
static inline int low_sign_extend (int, int) ATTRIBUTE_UNUSED;
static inline int sign_unext (int, int) ATTRIBUTE_UNUSED;
static inline int low_sign_unext (int, int) ATTRIBUTE_UNUSED;
static inline int re_assemble_3 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_12 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_14 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_16 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_17 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_21 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_22 (int) ATTRIBUTE_UNUSED;
static inline bfd_signed_vma hppa_field_adjust
  (bfd_vma, bfd_signed_vma, enum hppa_reloc_field_selector_type_alt)
  ATTRIBUTE_UNUSED;
static inline int bfd_hppa_insn2fmt (bfd *, int) ATTRIBUTE_UNUSED;
static inline int hppa_rebuild_insn (int, int, int) ATTRIBUTE_UNUSED;


/* The *sign_extend functions are used to assemble various bitfields
   taken from an instruction and return the resulting immediate
   value.  */

static inline int
sign_extend (int x, int len)
{
  int signbit = (1 << (len - 1));
  int mask = (signbit << 1) - 1;
  return ((x & mask) ^ signbit) - signbit;
}

static inline int
low_sign_extend (int x, int len)
{
  return (x >> 1) - ((x & 1) << (len - 1));
}


/* The re_assemble_* functions prepare an immediate value for
   insertion into an opcode. pa-risc uses all sorts of weird bitfields
   in the instruction to hold the value.  */

static inline int
sign_unext (int x, int len)
{
  int len_ones;

  len_ones = (1 << len) - 1;

  return x & len_ones;
}

static inline int
low_sign_unext (int x, int len)
{
  int temp;
  int sign;

  sign = (x >> (len-1)) & 1;

  temp = sign_unext (x, len-1);

  return (temp << 1) | sign;
}

static inline int
re_assemble_3 (int as3)
{
  return ((  (as3 & 4) << (13-2))
	  | ((as3 & 3) << (13+1)));
}

static inline int
re_assemble_12 (int as12)
{
  return ((  (as12 & 0x800) >> 11)
	  | ((as12 & 0x400) >> (10 - 2))
	  | ((as12 & 0x3ff) << (1 + 2)));
}

static inline int
re_assemble_14 (int as14)
{
  return ((  (as14 & 0x1fff) << 1)
	  | ((as14 & 0x2000) >> 13));
}

static inline int
re_assemble_16 (int as16)
{
  int s, t;

  /* Unusual 16-bit encoding, for wide mode only.  */
  t = (as16 << 1) & 0xffff;
  s = (as16 & 0x8000);
  return (t ^ s ^ (s >> 1)) | (s >> 15);
}

static inline int
re_assemble_17 (int as17)
{
  return ((  (as17 & 0x10000) >> 16)
	  | ((as17 & 0x0f800) << (16 - 11))
	  | ((as17 & 0x00400) >> (10 - 2))
	  | ((as17 & 0x003ff) << (1 + 2)));
}

static inline int
re_assemble_21 (int as21)
{
  return ((  (as21 & 0x100000) >> 20)
	  | ((as21 & 0x0ffe00) >> 8)
	  | ((as21 & 0x000180) << 7)
	  | ((as21 & 0x00007c) << 14)
	  | ((as21 & 0x000003) << 12));
}

static inline int
re_assemble_22 (int as22)
{
  return ((  (as22 & 0x200000) >> 21)
	  | ((as22 & 0x1f0000) << (21 - 16))
	  | ((as22 & 0x00f800) << (16 - 11))
	  | ((as22 & 0x000400) >> (10 - 2))
	  | ((as22 & 0x0003ff) << (1 + 2)));
}


/* Handle field selectors for PA instructions.
   The L and R (and LS, RS etc.) selectors are used in pairs to form a
   full 32 bit address.  eg.

   LDIL	L'start,%r1		; put left part into r1
   LDW	R'start(%r1),%r2	; add r1 and right part to form address

   This function returns sign extended values in all cases.
*/

static inline bfd_signed_vma
hppa_field_adjust (bfd_vma sym_val,
		   bfd_signed_vma addend,
		   enum hppa_reloc_field_selector_type_alt r_field)
{
  bfd_signed_vma value;

  value = sym_val + addend;
  switch (r_field)
    {
    case e_fsel:
      /* F: No change.  */
      break;

    case e_nsel:
      /* N: null selector.  I don't really understand what this is all
	 about, but HP's documentation says "this indicates that zero
	 bits are to be used for the displacement on the instruction.
	 This fixup is used to identify three-instruction sequences to
	 access data (for importing shared library data)."  */
      value = 0;
      break;

    case e_lsel:
    case e_nlsel:
      /* L:  Select top 21 bits.  */
      value = value >> 11;
      break;

    case e_rsel:
      /* R:  Select bottom 11 bits.  */
      value = value & 0x7ff;
      break;

    case e_lssel:
      /* LS:  Round to nearest multiple of 2048 then select top 21 bits.  */
      value = value + 0x400;
      value = value >> 11;
      break;

    case e_rssel:
      /* RS:  Select bottom 11 bits for LS.
	 We need to return a value such that 2048 * LS'x + RS'x == x.
	 ie. RS'x = x - ((x + 0x400) & -0x800)
	 this is just a sign extension from bit 21.  */
      value = ((value & 0x7ff) ^ 0x400) - 0x400;
      break;

    case e_ldsel:
      /* LD:  Round to next multiple of 2048 then select top 21 bits.
	 Yes, if we are already on a multiple of 2048, we go up to the
	 next one.  RD in this case will be -2048.  */
      value = value + 0x800;
      value = value >> 11;
      break;

    case e_rdsel:
      /* RD:  Set bits 0-20 to one.  */
      value = value | -0x800;
      break;

    case e_lrsel:
    case e_nlrsel:
      /* LR:  L with rounding of the addend to nearest 8k.  */
      value = sym_val + ((addend + 0x1000) & -0x2000);
      value = value >> 11;
      break;

    case e_rrsel:
      /* RR:  R with rounding of the addend to nearest 8k.
	 We need to return a value such that 2048 * LR'x + RR'x == x
	 ie. RR'x = s+a - (s + (((a + 0x1000) & -0x2000) & -0x800))
	 .	  = s+a - ((s & -0x800) + ((a + 0x1000) & -0x2000))
	 .	  = (s & 0x7ff) + a - ((a + 0x1000) & -0x2000)  */
      value = (sym_val & 0x7ff) + (((addend & 0x1fff) ^ 0x1000) - 0x1000);
      break;

    default:
      abort ();
    }
  return value;
}

/* PA-RISC OPCODES */
#define get_opcode(insn)	(((insn) >> 26) & 0x3f)

enum hppa_opcode_type
{
  /* None of the opcodes in the first group generate relocs, so we
     aren't too concerned about them.  */
  OP_SYSOP   = 0x00,
  OP_MEMMNG  = 0x01,
  OP_ALU     = 0x02,
  OP_NDXMEM  = 0x03,
  OP_SPOP    = 0x04,
  OP_DIAG    = 0x05,
  OP_FMPYADD = 0x06,
  OP_UNDEF07 = 0x07,
  OP_COPRW   = 0x09,
  OP_COPRDW  = 0x0b,
  OP_COPR    = 0x0c,
  OP_FLOAT   = 0x0e,
  OP_PRDSPEC = 0x0f,
  OP_UNDEF15 = 0x15,
  OP_UNDEF1d = 0x1d,
  OP_FMPYSUB = 0x26,
  OP_FPFUSED = 0x2e,
  OP_SHEXDP0 = 0x34,
  OP_SHEXDP1 = 0x35,
  OP_SHEXDP2 = 0x36,
  OP_UNDEF37 = 0x37,
  OP_SHEXDP3 = 0x3c,
  OP_SHEXDP4 = 0x3d,
  OP_MULTMED = 0x3e,
  OP_UNDEF3f = 0x3f,

  OP_LDIL    = 0x08,
  OP_ADDIL   = 0x0a,

  OP_LDO     = 0x0d,
  OP_LDB     = 0x10,
  OP_LDH     = 0x11,
  OP_LDW     = 0x12,
  OP_LDWM    = 0x13,
  OP_STB     = 0x18,
  OP_STH     = 0x19,
  OP_STW     = 0x1a,
  OP_STWM    = 0x1b,

  OP_LDD     = 0x14,
  OP_STD     = 0x1c,

  OP_FLDW    = 0x16,
  OP_LDWL    = 0x17,
  OP_FSTW    = 0x1e,
  OP_STWL    = 0x1f,

  OP_COMBT   = 0x20,
  OP_COMIBT  = 0x21,
  OP_COMBF   = 0x22,
  OP_COMIBF  = 0x23,
  OP_CMPBDT  = 0x27,
  OP_ADDBT   = 0x28,
  OP_ADDIBT  = 0x29,
  OP_ADDBF   = 0x2a,
  OP_ADDIBF  = 0x2b,
  OP_CMPBDF  = 0x2f,
  OP_BVB     = 0x30,
  OP_BB      = 0x31,
  OP_MOVB    = 0x32,
  OP_MOVIB   = 0x33,
  OP_CMPIBD  = 0x3b,

  OP_COMICLR = 0x24,
  OP_SUBI    = 0x25,
  OP_ADDIT   = 0x2c,
  OP_ADDI    = 0x2d,

  OP_BE      = 0x38,
  OP_BLE     = 0x39,
  OP_BL      = 0x3a
};


/* Given a machine instruction, return its format.  */

static inline int
bfd_hppa_insn2fmt (bfd *abfd, int insn)
{
  enum hppa_opcode_type op = get_opcode (insn);

  switch (op)
    {
    case OP_COMICLR:
    case OP_SUBI:
    case OP_ADDIT:
    case OP_ADDI:
      return 11;

    case OP_COMBT:
    case OP_COMIBT:
    case OP_COMBF:
    case OP_COMIBF:
    case OP_CMPBDT:
    case OP_ADDBT:
    case OP_ADDIBT:
    case OP_ADDBF:
    case OP_ADDIBF:
    case OP_CMPBDF:
    case OP_BVB:
    case OP_BB:
    case OP_MOVB:
    case OP_MOVIB:
    case OP_CMPIBD:
      return 12;

    case OP_LDO:
    case OP_LDB:
    case OP_LDH:
    case OP_LDW:
    case OP_LDWM:
    case OP_STB:
    case OP_STH:
    case OP_STW:
    case OP_STWM:
      if (abfd->arch_info->mach >= 25)
	return 16;	/* Wide mode, format 16.  */
      return 14;

    case OP_FLDW:
    case OP_LDWL:
    case OP_FSTW:
    case OP_STWL:
      /* This is a hack.  Unfortunately, format 11 is already taken
	 and we're using integers rather than an enum, so it's hard
	 to describe the 11a format.  */
      if (abfd->arch_info->mach >= 25)
	return -16;	/* Wide mode, format 16a.  */
      return -11;

    case OP_LDD:
    case OP_STD:
      if (abfd->arch_info->mach >= 25)
	return -10;	/* Wide mode, format 10a.  */
      return 10;

    case OP_BL:
      if ((insn & 0x8000) != 0)
	return 22;
      /* fall thru */
    case OP_BE:
    case OP_BLE:
      return 17;

    case OP_LDIL:
    case OP_ADDIL:
      return 21;

    default:
      break;
    }
  return 32;
}


/* Insert VALUE into INSN using R_FORMAT to determine exactly what
   bits to change.  */

static inline int
hppa_rebuild_insn (int insn, int value, int r_format)
{
  switch (r_format)
    {
    case 11:
      return (insn & ~ 0x7ff) | low_sign_unext (value, 11);

    case 12:
      return (insn & ~ 0x1ffd) | re_assemble_12 (value);


    case 10:
      return (insn & ~ 0x3ff1) | re_assemble_14 (value & -8);

    case -11:
      return (insn & ~ 0x3ff9) | re_assemble_14 (value & -4);

    case 14:
      return (insn & ~ 0x3fff) | re_assemble_14 (value);


    case -10:
      return (insn & ~ 0xfff1) | re_assemble_16 (value & -8);

    case -16:
      return (insn & ~ 0xfff9) | re_assemble_16 (value & -4);

    case 16:
      return (insn & ~ 0xffff) | re_assemble_16 (value);


    case 17:
      return (insn & ~ 0x1f1ffd) | re_assemble_17 (value);

    case 21:
      return (insn & ~ 0x1fffff) | re_assemble_21 (value);

    case 22:
      return (insn & ~ 0x3ff1ffd) | re_assemble_22 (value);

    case 32:
      return value;

    default:
      abort ();
    }
  return insn;
}

#endif /* _LIBHPPA_H */
@


1.4
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000
   Free Software Foundation, Inc.
a29 8
#ifndef INLINE
#ifdef __GNUC__
#define INLINE inline
#else
#define INLINE
#endif /* GNU C? */
#endif /* INLINE */

d159 16
a174 16
static INLINE int sign_extend PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int low_sign_extend PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int sign_unext PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int low_sign_unext PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_3 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_12 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_14 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_16 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_17 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_21 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_22 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE bfd_signed_vma hppa_field_adjust
  PARAMS ((bfd_vma, bfd_signed_vma,
	   enum hppa_reloc_field_selector_type_alt)) ATTRIBUTE_UNUSED;
static INLINE int bfd_hppa_insn2fmt PARAMS ((bfd *, int)) ATTRIBUTE_UNUSED;
static INLINE int hppa_rebuild_insn PARAMS ((int, int, int)) ATTRIBUTE_UNUSED;
d181 2
a182 3
static INLINE int
sign_extend (x, len)
     int x, len;
d189 2
a190 3
static INLINE int
low_sign_extend (x, len)
     int x, len;
d200 2
a201 3
static INLINE int
sign_unext (x, len)
     int x, len;
d210 2
a211 3
static INLINE int
low_sign_unext (x, len)
     int x, len;
d223 2
a224 3
static INLINE int
re_assemble_3 (as3)
     int as3;
d230 2
a231 3
static INLINE int
re_assemble_12 (as12)
     int as12;
d238 2
a239 3
static INLINE int
re_assemble_14 (as14)
     int as14;
d245 2
a246 3
static INLINE int
re_assemble_16 (as16)
     int as16;
d256 2
a257 3
static INLINE int
re_assemble_17 (as17)
     int as17;
d265 2
a266 3
static INLINE int
re_assemble_21 (as21)
     int as21;
d275 2
a276 3
static INLINE int
re_assemble_22 (as22)
     int as22;
d296 4
a299 5
static INLINE bfd_signed_vma
hppa_field_adjust (sym_val, addend, r_field)
     bfd_vma sym_val;
     bfd_signed_vma addend;
     enum hppa_reloc_field_selector_type_alt r_field;
d462 2
a463 4
static INLINE int
bfd_hppa_insn2fmt (abfd, insn)
     bfd *abfd;
     int insn;
d544 2
a545 5
static INLINE int
hppa_rebuild_insn (insn, value, r_format)
     int insn;
     int value;
     int r_format;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 98, 99, 2000
d24 2
a25 2
#ifndef _HPPA_H
#define _HPPA_H
a37 45
#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
/* Declare the functions with the unused attribute to avoid warnings.  */
static INLINE unsigned int assemble_3 (unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_3 (unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned int assemble_12 (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_12 (unsigned int, unsigned int *,
				    unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long assemble_17 (unsigned int, unsigned int,
					 unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_17 (unsigned int, unsigned int *,
				    unsigned int *, unsigned int *)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_22 (unsigned int, unsigned int *,
				    unsigned int *, unsigned int *,
				    unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long assemble_21 (unsigned int)
     __attribute ((__unused__));
static INLINE void dis_assemble_21 (unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long sign_extend (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE unsigned int ones (int) __attribute ((__unused__));
static INLINE void sign_unext (unsigned int, unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long low_sign_extend (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE void low_sign_unext (unsigned int, unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long hppa_field_adjust (unsigned long, unsigned long,
					       unsigned short)
     __attribute__ ((__unused__));
static INLINE int bfd_hppa_insn2fmt (unsigned long)
     __attribute__ ((__unused__));
static INLINE  unsigned long hppa_rebuild_insn (bfd *, unsigned long,
						unsigned long, unsigned long)
     __attribute__ ((__unused__));
#endif /* gcc 2.7 or higher */


d39 1
a39 1
enum pa_arch {pa10 = 10, pa11 = 11, pa20 = 20};
a154 27
   
#define HPPA_R_ARG_RELOC(a)	(((a) >> 22) & 0x3FF)
#define HPPA_R_CONSTANT(a)	((((int)(a)) << 10) >> 10)
#define HPPA_R_ADDEND(r,c)	(((r) << 22) + ((c) & 0x3FFFFF))
#define HPPA_WIDE	       (0) /* PSW W-bit, need to check! FIXME */

/* These macros get bit fields using HP's numbering (MSB = 0),
 * but note that "MASK" assumes that the LSB bits are what's
 * wanted.
 */
#ifndef GET_FIELD
#define GET_FIELD(X, FROM, TO) \
  ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))
#endif  
#define GET_BIT(X, WHICH) \
  GET_FIELD (X, WHICH, WHICH)

#define MASK(SIZE) \
  (~((-1) << SIZE))
  
#define CATENATE(X, XSIZE, Y, YSIZE) \
  (((X & MASK (XSIZE)) << YSIZE) | (Y & MASK (YSIZE)))

#define ELEVEN(X) \
  CATENATE (GET_BIT (X, 10), 1, GET_FIELD (X, 0, 9), 10)
  
/* Some functions to manipulate PA instructions.  */
d156 6
a161 5
/* NOTE: these use the HP convention that f{1} is the _left_ most
 *       bit (MSB) of f; they sometimes have to impose an assumption
 *       about the size of a field; and as far as I can tell, most
 *       aren't used.
 */
a162 6
static INLINE unsigned long
sign_extend (x, len)
     unsigned int x, len;
{
  return (int)(x >> (len - 1) ? (-1 << len) | x : x);
}
d164 1
a164 6
static INLINE unsigned int
assemble_3 (x)
     unsigned int x;
{
  return CATENATE (GET_BIT (x, 2), 1, GET_FIELD (x, 0, 1), 2);
}
d166 22
a187 7
static INLINE void
dis_assemble_3 (x, r)
     unsigned int x;
     unsigned int *r;
{
  *r = (((x & 4) >> 2) | ((x & 3) << 1)) & 7;
}
d189 3
a191 3
static INLINE unsigned int
assemble_6 (x, y)
     unsigned int x, y;
d193 3
a195 1
  return (((x & 0x1) << 5) + (32 - (y & 0x1f)));
d198 3
a200 3
static INLINE unsigned int
assemble_12 (x, y)
     unsigned int x, y;
d202 1
a202 2
  return CATENATE (CATENATE (y, 1, GET_BIT (x, 10), 1), 2,
 		   GET_FIELD (x, 0, 9), 9);
a204 8
static INLINE void
dis_assemble_12 (as12, x, y)
     unsigned int as12;
     unsigned int *x, *y;
{
  *y = (as12 & 0x800) >> 11;
  *x = ((as12 & 0x3ff) << 1) | ((as12 & 0x400) >> 10);
}
d206 3
a208 6
static INLINE unsigned long
assemble_16 (x, y)
     unsigned int x, y;
{
  /* Depends on PSW W-bit !*/
  unsigned int temp;
d210 3
a212 16
  if (HPPA_WIDE)
    temp = CATENATE (CATENATE (GET_BIT (y, 13), 1,
			       (GET_BIT (y, 13) ^ GET_BIT (x, 0)), 1), 2,
		     CATENATE ((GET_BIT (y, 13) ^ GET_BIT (x, 1)), 1,
			       GET_FIELD (y, 0, 12), 13), 14);
  else
    temp = CATENATE (CATENATE (GET_BIT (y, 13), 1, GET_BIT (y, 13), 1), 2,
		     CATENATE (GET_BIT (y, 13), 1, GET_FIELD (y, 0, 12), 13), 14);

  return sign_extend (temp, 16);
}


static INLINE unsigned long
assemble_16a (x, y, z)
     unsigned int x, y, z;
d214 1
a214 2
  /* Depends on PSW W-bit !*/
  unsigned int temp;
d216 1
a216 5
  if (HPPA_WIDE)
    temp = CATENATE (CATENATE (z, 1, (z ^ GET_BIT (x, 0)), 1), 2,
		     CATENATE ((z ^ GET_BIT (x, 1)), 1, y, 11), 12);
  else 
      temp = CATENATE (CATENATE (z, 1, z, 1), 2, CATENATE (z, 1, y, 11), 12);
d218 1
a218 1
  return sign_extend ((temp << 2), 16);
d221 3
a223 3
static INLINE unsigned long
assemble_17 (x, y, z)
     unsigned int x, y, z;
d225 2
a226 1
  unsigned long temp;
d228 1
a228 5
  temp = CATENATE (CATENATE (z, 1, x, 5), 6,
		   CATENATE (GET_BIT (y, 10), 1, GET_FIELD (y, 0, 9), 10), 11);
  
  return temp;
}
d230 1
a230 5
static INLINE void
dis_assemble_17 (as17, x, y, z)
     unsigned int as17;
     unsigned int *x, *y, *z;
{
d232 1
a232 3
  *z = (as17 & 0x10000) >> 16;
  *x = (as17 & 0x0f800) >> 11;
  *y = (((as17 & 0x00400) >> 10) | ((as17 & 0x3ff) << 1)) & 0x7ff;
d235 3
a237 4
static INLINE void
dis_assemble_22 (as22, a, b, c, d)
     unsigned int as22;
     unsigned int *a, *b, *c, *d;
d239 2
a240 5

  *d = (as22 & 0x200000) >> 21;
  *a = (as22 & 0x1f0000) >> 16;
  *b = (as22 & 0x0f800) >> 11;
  *c = (((as22 & 0x00400) >> 10) | ((as22 & 0x3ff) << 1)) & 0x7ff;
d243 3
a245 3
static INLINE unsigned long
assemble_21 (x)
     unsigned int x;
d247 3
a249 8
  unsigned long temp;

  temp = ((x & 1) << 20) |
    ((x & 0xffe) << 8) |
    ((x & 0xc000) >> 7) |
    ((x & 0x1f0000) >> 14) |
    ((x & 0x003000) >> 12);
  return temp & 0x1fffff;
d252 3
a254 3
static INLINE unsigned long
assemble_22 (a,b,c,d)
     unsigned int a,b,c,d;
d256 2
a257 6
  unsigned long temp;
  
  temp = CATENATE (CATENATE (d, 1, a, 5), 6,
		   CATENATE (b, 5, ELEVEN (c), 11), 16);

  return sign_extend (temp, 22);
d260 3
a262 3
static INLINE void
dis_assemble_21 (as21, x)
     unsigned int as21, *x;
d264 1
a264 1
  unsigned long temp;
d266 4
a269 7

  temp = (as21 & 0x100000) >> 20;
  temp |= (as21 & 0x0ffe00) >> 8;
  temp |= (as21 & 0x000180) << 7;
  temp |= (as21 & 0x00007c) << 14;
  temp |= (as21 & 0x000003) << 12;
  *x = temp;
d272 3
a274 3
static INLINE unsigned int
ones (n)
     int n;
d276 4
a279 12
  unsigned int len_ones;
  int i;

  i = 0;
  len_ones = 0;
  while (i < n)
    {
      len_ones = (len_ones << 1) | 1;
      i++;
    }

  return len_ones;
d282 3
a284 4
static INLINE void
sign_unext (x, len, result)
     unsigned int x, len;
     unsigned int *result;
d286 5
a290 5
  unsigned int len_ones;

  len_ones = ones (len);

  *result = x & len_ones;
d293 3
a295 3
static INLINE unsigned long
low_sign_extend (x, len)
     unsigned int x, len;
d297 5
a301 1
  return (int)((x & 0x1 ? (-1 << (len - 1)) : 0) | x >> 1);
a303 10
static INLINE void
low_sign_unext (x, len, result)
     unsigned int x, len;
     unsigned int *result;
{
  unsigned int temp;
  unsigned int sign;
  unsigned int rest;
  unsigned int one_bit_at_len;
  unsigned int len_ones;
d305 3
a307 2
  len_ones = ones (len);
  one_bit_at_len = 1 << (len - 1);
d309 2
a310 3
  sign_unext (x, len, &temp);
  sign = temp & one_bit_at_len;
  sign >>= (len - 1);
d312 2
a313 2
  rest = temp & (len_ones ^ one_bit_at_len);
  rest <<= 1;
d315 7
a321 4
  *result = rest | sign;
}

/* Handle field selectors for PA instructions.  */
d323 1
a323 6
static INLINE unsigned long
hppa_field_adjust (value, constant_value, r_field)
     unsigned long value;
     unsigned long constant_value;
     unsigned short r_field;
{
d326 2
a327 11
    case e_fsel:		/* F  : no change		      */
    case e_nsel:		/* N  : no change		       */
      value += constant_value;
      break;

    case e_lssel:		/* LS : if (bit 21) then add 0x800
				   arithmetic shift right 11 bits */
      value += constant_value;
      if (value & 0x00000400)
	value += 0x800;
      value = (value & 0xfffff800) >> 11;
d330 7
a336 6
    case e_rssel:		/* RS : Sign extend from bit 21	*/
      value += constant_value;
      if (value & 0x00000400)
	value |= 0xfffff800;
      else
	value &= 0x7ff;
d339 4
a342 4
    case e_lsel:		/* L  : Arithmetic shift right 11 bits */
    case e_nlsel:		/* NL  : Arithmetic shift right 11 bits */
      value += constant_value;
      value = (value & 0xfffff800) >> 11;
d345 2
a346 2
    case e_rsel:		/* R  : Set bits 0-20 to zero	  */
      value += constant_value;
d350 41
a390 21
    case e_ldsel:		/* LD : Add 0x800, arithmetic shift
				   right 11 bits		  */
      value += constant_value;
      value += 0x800;
      value = (value & 0xfffff800) >> 11;
      break;

    case e_rdsel:		/* RD : Set bits 0-20 to one	   */
      value += constant_value;
      value |= 0xfffff800;
      break;

    case e_lrsel:		/* LR : L with "rounded" constant      */
    case e_nlrsel:		/* NLR : NL with "rounded" constant      */
      value = value + ((constant_value + 0x1000) & 0xffffe000);
      value = (value & 0xfffff800) >> 11;
      break;

    case e_rrsel:		/* RR : R with "rounded" constant      */
      value = value + ((constant_value + 0x1000) & 0xffffe000);
      value = (value & 0x7ff) + constant_value - ((constant_value + 0x1000) & 0xffffe000);
a396 1

d400 79
a478 1
#define get_opcode(insn)	((insn) & 0xfc000000) >> 26
d480 8
a487 2
/* FIXME: this list is incomplete.  It should also be an enumerated
   type rather than #defines.  */
a488 58
#define LDO	0x0d
#define LDB	0x10
#define LDH	0x11
#define LDW	0x12
#define LDWM	0x13
#define STB	0x18
#define STH	0x19
#define STW	0x1a
#define STWM	0x1b
#define COMICLR	0x24
#define SUBI	0x25
#define SUBIO	0x25
#define ADDIT	0x2c
#define ADDITO	0x2c
#define ADDI	0x2d
#define ADDIO	0x2d
#define LDIL	0x08
#define ADDIL	0x0a

#define MOVB	0x32
#define MOVIB	0x33
#define COMBT	0x20
#define COMBF	0x22
#define COMIBT	0x21
#define COMIBF	0x23
#define ADDBT	0x28
#define ADDBF	0x2a
#define ADDIBT	0x29
#define ADDIBF	0x2b
#define BVB	0x30
#define BB	0x31

#define BL	0x3a
#define BLE	0x39
#define BE	0x38

#define CMPBDT	0x27
#define CMPBDF	0x2f
#define CMPIBD	0x3b
#define LDD	0x14
#define STD	0x1c
#define LDWL	0x17
#define STWL	0x1f
#define FDLW    0x16
#define FSTW    0x1e
  
/* Given a machine instruction, return its format.

   FIXME:  opcodes which do not map to a known format
   should return an error of some sort.  */

static INLINE int
bfd_hppa_insn2fmt (insn)
     unsigned long insn;
{
  int fmt = -1;
  unsigned char op = get_opcode (insn);
  
d491 40
a530 37
    case ADDI:
    case ADDIT:
    case SUBI:
      fmt = 11;
      break;
    case MOVB:
    case MOVIB:
    case COMBT:
    case COMBF:
    case COMIBT:
    case COMIBF:
    case ADDBT:
    case ADDBF:
    case ADDIBT:
    case ADDIBF:
    case BVB:
    case BB:
    case CMPBDT:
    case CMPBDF:
    case CMPIBD:
      fmt = 12;
      break;
    case LDO:
    case LDB:
    case LDH:
    case LDW:
    case LDWM:
    case STB:
    case STH:
    case STW:
    case STWM:
      fmt = 14;
      break;
    case LDWL:
    case STWL:
    case FDLW:
    case FSTW:
d533 13
a545 11
	 to describe the 10a format.  */
      fmt = -11;
      break;
    case LDD:
    case STD:
      fmt = 10;
      break;
    case BL:
    case BE:
    case BLE:
      if ((insn & 0x00008000) == 0x00008000)
d547 9
a555 6
      fmt = 17;
      break;
    case LDIL:
    case ADDIL:
      fmt = 21;
      break;
a556 1
      fmt = 32;
d559 1
a559 1
  return fmt;
d565 6
a570 7
   
static INLINE unsigned long
hppa_rebuild_insn (abfd, insn, value, r_format)
     bfd *abfd ATTRIBUTE_UNUSED;
     unsigned long insn;
     unsigned long value;
     unsigned long r_format;
a571 3
  unsigned long const_part;
  unsigned long rebuilt_part;

d575 4
a578 2
      {
	unsigned w1, w;
a579 5
	const_part = insn & 0xffffe002;
	dis_assemble_12 (value, &w1, &w);
	rebuilt_part = (w1 << 2) | w;
	return const_part | rebuilt_part;
      }
d581 2
a582 3
    case 12:
      {
	unsigned w1, w;
d584 2
a585 5
	const_part = insn & 0xffffe002;
	dis_assemble_12 (value, &w1, &w);
	rebuilt_part = (w1 << 2) | w;
	return const_part | rebuilt_part;
      }
d588 12
a599 7
      {
	unsigned int ext;
	
	const_part = insn & 0xffffc000;
	low_sign_unext (value, 14, &ext);
	return const_part | ext;
      }
d602 1
a602 8
      {
	unsigned w1, w2, w;

	const_part = insn & 0xffe0e002;
	dis_assemble_17 (value, &w1, &w2, &w);
	rebuilt_part = (w2 << 2) | (w1 << 16) | w;
	return const_part | rebuilt_part;
      }
d605 1
a605 2
      {
	unsigned int w;
d607 2
a608 4
	const_part = insn & 0xffe00000;
	dis_assemble_21 (value, &w);
	return const_part | w;
      }
a610 1
      const_part = 0;
d619 1
a619 1
#endif /* _HPPA_H */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d38 1
a38 1
#if __GNUC__ >= 2 && __GNUC_MINOR__ >= 7
d55 4
d75 1
a75 1
static INLINE char bfd_hppa_insn2fmt (unsigned long)
d82 1
d107 3
a109 1
    R_HPPA_RTSEL = 0x11
d162 3
a164 1
    e_rtsel = R_HPPA_RTSEL
d204 12
d217 9
d227 14
d245 1
a245 1
  return (((x & 1) << 2) | ((x & 6) >> 1)) & 7;
d257 7
d267 2
a268 1
  return (((y & 1) << 11) | ((x & 1) << 10) | ((x & 0x7fe) >> 1)) & 0xfff;
d281 36
d322 4
a325 5
  temp = ((z & 1) << 16) |
    ((x & 0x1f) << 11) |
    ((y & 1) << 10) |
    ((y & 0x7fe) >> 1);
  return temp & 0x1ffff;
d339 12
d365 12
a391 7
static INLINE unsigned long
sign_extend (x, len)
     unsigned int x, len;
{
  return (int)(x >> (len - 1) ? (-1 << len) | x : x);
}

d463 1
a463 1
    case e_fsel:		/* F  : no change                      */
d476 1
a476 1
    case e_rssel:		/* RS : Sign extend from bit 21        */
d490 1
a490 1
    case e_rsel:		/* R  : Set bits 0-20 to zero          */
d496 1
a496 1
				   right 11 bits                  */
d502 1
a502 1
    case e_rdsel:		/* RD : Set bits 0-20 to one           */
d567 9
d582 1
a582 1
static INLINE char
d586 1
a586 1
  char fmt = -1;
d608 3
d624 13
d640 2
d661 1
a661 1
     bfd *abfd;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
d37 40
d78 1
a78 1
enum pa_arch {pa10 = 10, pa11 = 11};
d93 9
a101 6
    R_HPPA_PSEL = 0x9,
    R_HPPA_LPSEL = 0xa,
    R_HPPA_RPSEL = 0xb,
    R_HPPA_TSEL = 0xc,
    R_HPPA_LTSEL = 0xd,
    R_HPPA_RTSEL = 0xe
d118 3
d146 3
d359 1
d380 1
d403 1
d560 7
a566 3
      const_part = insn & 0xffffc000;
      low_sign_unext (value, 14, &rebuilt_part);
      return const_part | rebuilt_part;
d579 7
a585 3
      const_part = insn & 0xffe00000;
      dis_assemble_21 (value, &rebuilt_part);
      return const_part | rebuilt_part;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a36 40
#if __GNUC__ >= 2 && __GNUC_MINOR__ >= 7
/* Declare the functions with the unused attribute to avoid warnings.  */
static INLINE unsigned int assemble_3 (unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_3 (unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned int assemble_12 (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_12 (unsigned int, unsigned int *,
				    unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long assemble_17 (unsigned int, unsigned int,
					 unsigned int)
     __attribute__ ((__unused__));
static INLINE void dis_assemble_17 (unsigned int, unsigned int *,
				    unsigned int *, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long assemble_21 (unsigned int)
     __attribute ((__unused__));
static INLINE void dis_assemble_21 (unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long sign_extend (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE unsigned int ones (int) __attribute ((__unused__));
static INLINE void sign_unext (unsigned int, unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long low_sign_extend (unsigned int, unsigned int)
     __attribute__ ((__unused__));
static INLINE void low_sign_unext (unsigned int, unsigned int, unsigned int *)
     __attribute__ ((__unused__));
static INLINE unsigned long hppa_field_adjust (unsigned long, unsigned long,
					       unsigned short)
     __attribute__ ((__unused__));
static INLINE char bfd_hppa_insn2fmt (unsigned long)
     __attribute__ ((__unused__));
static INLINE  unsigned long hppa_rebuild_insn (bfd *, unsigned long,
						unsigned long, unsigned long)
     __attribute__ ((__unused__));
#endif /* gcc 2.7 or higher */

d38 1
a38 1
enum pa_arch {pa10 = 10, pa11 = 11, pa20 = 20};
d53 6
a58 9
    R_HPPA_NSEL  = 0x9,
    R_HPPA_NLSEL  = 0xa,
    R_HPPA_NLRSEL  = 0xb,
    R_HPPA_PSEL = 0xc,
    R_HPPA_LPSEL = 0xd,
    R_HPPA_RPSEL = 0xe,
    R_HPPA_TSEL = 0xf,
    R_HPPA_LTSEL = 0x10,
    R_HPPA_RTSEL = 0x11
a74 3
#undef e_nsel
#undef e_nlsel
#undef e_nlrsel
a99 3
    e_nsel = R_HPPA_NSEL,
    e_nlsel = R_HPPA_NLSEL,
    e_nlrsel = R_HPPA_NLRSEL,
a309 1
    case e_nsel:		/* N  : no change		       */
a329 1
    case e_nlsel:		/* NL  : Arithmetic shift right 11 bits */
a351 1
    case e_nlrsel:		/* NLR : NL with "rounded" constant      */
d508 3
a510 7
      {
	unsigned int ext;
	
	const_part = insn & 0xffffc000;
	low_sign_unext (value, 14, &ext);
	return const_part | ext;
      }
d523 3
a525 7
      {
	unsigned int w;

	const_part = insn & 0xffe00000;
	dis_assemble_21 (value, &w);
	return const_part | w;
      }
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 98, 99, 2000
   Free Software Foundation, Inc.
d37 1
a37 1
#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
a53 4
static INLINE void dis_assemble_22 (unsigned int, unsigned int *,
				    unsigned int *, unsigned int *,
				    unsigned int *)
     __attribute__ ((__unused__));
d70 1
a70 1
static INLINE int bfd_hppa_insn2fmt (unsigned long)
a76 1

d101 1
a101 3
    R_HPPA_RTSEL = 0x11,
    R_HPPA_LTPSEL = 0x12,
    R_HPPA_RTPSEL = 0x13
d154 1
a154 3
    e_rtsel = R_HPPA_RTSEL,
    e_ltpsel = R_HPPA_LTPSEL,
    e_rtpsel = R_HPPA_RTPSEL
a193 12
#define HPPA_WIDE	       (0) /* PSW W-bit, need to check! FIXME */

/* These macros get bit fields using HP's numbering (MSB = 0),
 * but note that "MASK" assumes that the LSB bits are what's
 * wanted.
 */
#ifndef GET_FIELD
#define GET_FIELD(X, FROM, TO) \
  ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))
#endif  
#define GET_BIT(X, WHICH) \
  GET_FIELD (X, WHICH, WHICH)
a194 9
#define MASK(SIZE) \
  (~((-1) << SIZE))
  
#define CATENATE(X, XSIZE, Y, YSIZE) \
  (((X & MASK (XSIZE)) << YSIZE) | (Y & MASK (YSIZE)))

#define ELEVEN(X) \
  CATENATE (GET_BIT (X, 10), 1, GET_FIELD (X, 0, 9), 10)
  
a195 14

/* NOTE: these use the HP convention that f{1} is the _left_ most
 *       bit (MSB) of f; they sometimes have to impose an assumption
 *       about the size of a field; and as far as I can tell, most
 *       aren't used.
 */

static INLINE unsigned long
sign_extend (x, len)
     unsigned int x, len;
{
  return (int)(x >> (len - 1) ? (-1 << len) | x : x);
}

d200 1
a200 1
  return CATENATE (GET_BIT (x, 2), 1, GET_FIELD (x, 0, 1), 2);
a211 7
assemble_6 (x, y)
     unsigned int x, y;
{
  return (((x & 0x1) << 5) + (32 - (y & 0x1f)));
}

static INLINE unsigned int
d215 1
a215 2
  return CATENATE (CATENATE (y, 1, GET_BIT (x, 10), 1), 2,
 		   GET_FIELD (x, 0, 9), 9);
a227 36
assemble_16 (x, y)
     unsigned int x, y;
{
  /* Depends on PSW W-bit !*/
  unsigned int temp;

  if (HPPA_WIDE)
    temp = CATENATE (CATENATE (GET_BIT (y, 13), 1,
			       (GET_BIT (y, 13) ^ GET_BIT (x, 0)), 1), 2,
		     CATENATE ((GET_BIT (y, 13) ^ GET_BIT (x, 1)), 1,
			       GET_FIELD (y, 0, 12), 13), 14);
  else
    temp = CATENATE (CATENATE (GET_BIT (y, 13), 1, GET_BIT (y, 13), 1), 2,
		     CATENATE (GET_BIT (y, 13), 1, GET_FIELD (y, 0, 12), 13), 14);

  return sign_extend (temp, 16);
}


static INLINE unsigned long
assemble_16a (x, y, z)
     unsigned int x, y, z;
{
  /* Depends on PSW W-bit !*/
  unsigned int temp;

  if (HPPA_WIDE)
    temp = CATENATE (CATENATE (z, 1, (z ^ GET_BIT (x, 0)), 1), 2,
		     CATENATE ((z ^ GET_BIT (x, 1)), 1, y, 11), 12);
  else 
      temp = CATENATE (CATENATE (z, 1, z, 1), 2, CATENATE (z, 1, y, 11), 12);

  return sign_extend ((temp << 2), 16);
}

static INLINE unsigned long
d233 5
a237 4
  temp = CATENATE (CATENATE (z, 1, x, 5), 6,
		   CATENATE (GET_BIT (y, 10), 1, GET_FIELD (y, 0, 9), 10), 11);
  
  return temp;
a250 12
static INLINE void
dis_assemble_22 (as22, a, b, c, d)
     unsigned int as22;
     unsigned int *a, *b, *c, *d;
{

  *d = (as22 & 0x200000) >> 21;
  *a = (as22 & 0x1f0000) >> 16;
  *b = (as22 & 0x0f800) >> 11;
  *c = (((as22 & 0x00400) >> 10) | ((as22 & 0x3ff) << 1)) & 0x7ff;
}

a264 12
static INLINE unsigned long
assemble_22 (a,b,c,d)
     unsigned int a,b,c,d;
{
  unsigned long temp;
  
  temp = CATENATE (CATENATE (d, 1, a, 5), 6,
		   CATENATE (b, 5, ELEVEN (c), 11), 16);

  return sign_extend (temp, 22);
}

d280 7
d358 1
a358 1
    case e_fsel:		/* F  : no change		      */
d371 1
a371 1
    case e_rssel:		/* RS : Sign extend from bit 21	*/
d385 1
a385 1
    case e_rsel:		/* R  : Set bits 0-20 to zero	  */
d391 1
a391 1
				   right 11 bits		  */
d397 1
a397 1
    case e_rdsel:		/* RD : Set bits 0-20 to one	   */
a461 9
#define CMPBDT	0x27
#define CMPBDF	0x2f
#define CMPIBD	0x3b
#define LDD	0x14
#define STD	0x1c
#define LDWL	0x17
#define STWL	0x1f
#define FDLW    0x16
#define FSTW    0x1e
d468 1
a468 1
static INLINE int
d472 1
a472 1
  int fmt = -1;
a493 3
    case CMPBDT:
    case CMPBDF:
    case CMPIBD:
a506 13
    case LDWL:
    case STWL:
    case FDLW:
    case FSTW:
      /* This is a hack.  Unfortunately, format 11 is already taken
	 and we're using integers rather than an enum, so it's hard
	 to describe the 10a format.  */
      fmt = -11;
      break;
    case LDD:
    case STD:
      fmt = 10;
      break;
a509 2
      if ((insn & 0x00008000) == 0x00008000)
	return 22;
d529 1
a529 1
     bfd *abfd ATTRIBUTE_UNUSED;
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000
d24 2
a25 2
#ifndef _LIBHPPA_H
#define _LIBHPPA_H
d38 45
d84 1
a84 1
enum pa_arch {pa10 = 10, pa11 = 11, pa20 = 20, pa20w = 25};
d200 27
d228 5
a232 6
#define HPPA_R_ARG_RELOC(a)	\
  (((a) >> 22) & 0x3ff)
#define HPPA_R_CONSTANT(a)	\
  ((((bfd_signed_vma)(a)) << (BFD_ARCH_SIZE-22)) >> (BFD_ARCH_SIZE-22))
#define HPPA_R_ADDEND(r, c)	\
  (((r) << 22) + ((c) & 0x3fffff))
d234 6
d241 14
a254 1
/* Some functions to manipulate PA instructions.  */
d256 6
a261 22
/* Declare the functions with the unused attribute to avoid warnings.  */
static INLINE int sign_extend PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int low_sign_extend PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int sign_unext PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int low_sign_unext PARAMS ((int, int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_3 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_12 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_14 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_16 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_17 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_21 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE int re_assemble_22 PARAMS ((int)) ATTRIBUTE_UNUSED;
static INLINE bfd_signed_vma hppa_field_adjust
  PARAMS ((bfd_vma, bfd_signed_vma,
	   enum hppa_reloc_field_selector_type_alt)) ATTRIBUTE_UNUSED;
static INLINE int bfd_hppa_insn2fmt PARAMS ((bfd *, int)) ATTRIBUTE_UNUSED;
static INLINE int hppa_rebuild_insn PARAMS ((int, int, int)) ATTRIBUTE_UNUSED;


/* The *sign_extend functions are used to assemble various bitfields
   taken from an instruction and return the resulting immediate
   value.  */
d263 3
a265 3
static INLINE int
sign_extend (x, len)
     int x, len;
d267 2
a268 3
  int signbit = (1 << (len - 1));
  int mask = (signbit << 1) - 1;
  return ((x & mask) ^ signbit) - signbit;
d271 4
a274 3
static INLINE int
low_sign_extend (x, len)
     int x, len;
d276 2
a277 1
  return (x >> 1) - ((x & 1) << (len - 1));
d280 18
a298 3
/* The re_assemble_* functions prepare an immediate value for
   insertion into an opcode. pa-risc uses all sorts of weird bitfields
   in the instruction to hold the value.  */
d300 3
a302 3
static INLINE int
sign_unext (x, len)
     int x, len;
d304 2
a305 1
  int len_ones;
d307 5
a311 1
  len_ones = (1 << len) - 1;
d313 1
a313 1
  return x & len_ones;
d316 3
a318 3
static INLINE int
low_sign_unext (x, len)
     int x, len;
d320 1
a320 2
  int temp;
  int sign;
d322 5
a326 1
  sign = (x >> (len-1)) & 1;
d328 5
a332 1
  temp = sign_unext (x, len-1);
d334 3
a336 1
  return (temp << 1) | sign;
d339 4
a342 3
static INLINE int
re_assemble_3 (as3)
     int as3;
d344 5
a348 2
  return ((  (as3 & 4) << (13-2))
	  | ((as3 & 3) << (13+1)));
d351 3
a353 3
static INLINE int
re_assemble_12 (as12)
     int as12;
d355 8
a362 3
  return ((  (as12 & 0x800) >> 11)
	  | ((as12 & 0x400) >> (10 - 2))
	  | ((as12 & 0x3ff) << (1 + 2)));
d365 3
a367 3
static INLINE int
re_assemble_14 (as14)
     int as14;
d369 6
a374 2
  return ((  (as14 & 0x1fff) << 1)
	  | ((as14 & 0x2000) >> 13));
d377 3
a379 3
static INLINE int
re_assemble_16 (as16)
     int as16;
d381 1
a381 1
  int s, t;
d383 7
a389 4
  /* Unusual 16-bit encoding, for wide mode only.  */
  t = (as16 << 1) & 0xffff;
  s = (as16 & 0x8000);
  return (t ^ s ^ (s >> 1)) | (s >> 15);
d392 3
a394 3
static INLINE int
re_assemble_17 (as17)
     int as17;
d396 12
a407 4
  return ((  (as17 & 0x10000) >> 16)
	  | ((as17 & 0x0f800) << (16 - 11))
	  | ((as17 & 0x00400) >> (10 - 2))
	  | ((as17 & 0x003ff) << (1 + 2)));
d410 4
a413 3
static INLINE int
re_assemble_21 (as21)
     int as21;
d415 5
a419 5
  return ((  (as21 & 0x100000) >> 20)
	  | ((as21 & 0x0ffe00) >> 8)
	  | ((as21 & 0x000180) << 7)
	  | ((as21 & 0x00007c) << 14)
	  | ((as21 & 0x000003) << 12));
d422 3
a424 3
static INLINE int
re_assemble_22 (as22)
     int as22;
d426 1
a426 5
  return ((  (as22 & 0x200000) >> 21)
	  | ((as22 & 0x1f0000) << (21 - 16))
	  | ((as22 & 0x00f800) << (16 - 11))
	  | ((as22 & 0x000400) >> (10 - 2))
	  | ((as22 & 0x0003ff) << (1 + 2)));
d429 10
d440 2
a441 3
/* Handle field selectors for PA instructions.
   The L and R (and LS, RS etc.) selectors are used in pairs to form a
   full 32 bit address.  eg.
d443 3
a445 2
   LDIL	L'start,%r1		; put left part into r1
   LDW	R'start(%r1),%r2	; add r1 and right part to form address
d447 2
a448 2
   This function returns sign extended values in all cases.
*/
d450 10
a459 5
static INLINE bfd_signed_vma
hppa_field_adjust (sym_val, addend, r_field)
     bfd_vma sym_val;
     bfd_signed_vma addend;
     enum hppa_reloc_field_selector_type_alt r_field;
a460 3
  bfd_signed_vma value;

  value = sym_val + addend;
d463 11
a473 2
    case e_fsel:
      /* F: No change.  */
d476 6
a481 7
    case e_nsel:
      /* N: null selector.  I don't really understand what this is all
	 about, but HP's documentation says "this indicates that zero
	 bits are to be used for the displacement on the instruction.
	 This fixup is used to identify three-instruction sequences to
	 access data (for importing shared library data)."  */
      value = 0;
d484 4
a487 4
    case e_lsel:
    case e_nlsel:
      /* L:  Select top 21 bits.  */
      value = value >> 11;
d490 2
a491 2
    case e_rsel:
      /* R:  Select bottom 11 bits.  */
d495 21
a515 41
    case e_lssel:
      /* LS:  Round to nearest multiple of 2048 then select top 21 bits.  */
      value = value + 0x400;
      value = value >> 11;
      break;

    case e_rssel:
      /* RS:  Select bottom 11 bits for LS.
	 We need to return a value such that 2048 * LS'x + RS'x == x.
	 ie. RS'x = x - ((x + 0x400) & -0x800)
	 this is just a sign extension from bit 21.  */
      value = ((value & 0x7ff) ^ 0x400) - 0x400;
      break;

    case e_ldsel:
      /* LD:  Round to next multiple of 2048 then select top 21 bits.
	 Yes, if we are already on a multiple of 2048, we go up to the
	 next one.  RD in this case will be -2048.  */
      value = value + 0x800;
      value = value >> 11;
      break;

    case e_rdsel:
      /* RD:  Set bits 0-20 to one.  */
      value = value | -0x800;
      break;

    case e_lrsel:
    case e_nlrsel:
      /* LR:  L with rounding of the addend to nearest 8k.  */
      value = sym_val + ((addend + 0x1000) & -0x2000);
      value = value >> 11;
      break;

    case e_rrsel:
      /* RR:  R with rounding of the addend to nearest 8k.
	 We need to return a value such that 2048 * LR'x + RR'x == x
	 ie. RR'x = s+a - (s + (((a + 0x1000) & -0x2000) & -0x800))
	 .	  = s+a - ((s & -0x800) + ((a + 0x1000) & -0x2000))
	 .	  = (s & 0x7ff) + a - ((a + 0x1000) & -0x2000)  */
      value = (sym_val & 0x7ff) + (((addend & 0x1fff) ^ 0x1000) - 0x1000);
d522 1
d526 1
a526 79
#define get_opcode(insn)	(((insn) >> 26) & 0x3f)

enum hppa_opcode_type
{
  /* None of the opcodes in the first group generate relocs, so we
     aren't too concerned about them.  */
  OP_SYSOP   = 0x00,
  OP_MEMMNG  = 0x01,
  OP_ALU     = 0x02,
  OP_NDXMEM  = 0x03,
  OP_SPOP    = 0x04,
  OP_DIAG    = 0x05,
  OP_FMPYADD = 0x06,
  OP_UNDEF07 = 0x07,
  OP_COPRW   = 0x09,
  OP_COPRDW  = 0x0b,
  OP_COPR    = 0x0c,
  OP_FLOAT   = 0x0e,
  OP_PRDSPEC = 0x0f,
  OP_UNDEF15 = 0x15,
  OP_UNDEF1d = 0x1d,
  OP_FMPYSUB = 0x26,
  OP_FPFUSED = 0x2e,
  OP_SHEXDP0 = 0x34,
  OP_SHEXDP1 = 0x35,
  OP_SHEXDP2 = 0x36,
  OP_UNDEF37 = 0x37,
  OP_SHEXDP3 = 0x3c,
  OP_SHEXDP4 = 0x3d,
  OP_MULTMED = 0x3e,
  OP_UNDEF3f = 0x3f,

  OP_LDIL    = 0x08,
  OP_ADDIL   = 0x0a,

  OP_LDO     = 0x0d,
  OP_LDB     = 0x10,
  OP_LDH     = 0x11,
  OP_LDW     = 0x12,
  OP_LDWM    = 0x13,
  OP_STB     = 0x18,
  OP_STH     = 0x19,
  OP_STW     = 0x1a,
  OP_STWM    = 0x1b,

  OP_LDD     = 0x14,
  OP_STD     = 0x1c,

  OP_FLDW    = 0x16,
  OP_LDWL    = 0x17,
  OP_FSTW    = 0x1e,
  OP_STWL    = 0x1f,

  OP_COMBT   = 0x20,
  OP_COMIBT  = 0x21,
  OP_COMBF   = 0x22,
  OP_COMIBF  = 0x23,
  OP_CMPBDT  = 0x27,
  OP_ADDBT   = 0x28,
  OP_ADDIBT  = 0x29,
  OP_ADDBF   = 0x2a,
  OP_ADDIBF  = 0x2b,
  OP_CMPBDF  = 0x2f,
  OP_BVB     = 0x30,
  OP_BB      = 0x31,
  OP_MOVB    = 0x32,
  OP_MOVIB   = 0x33,
  OP_CMPIBD  = 0x3b,

  OP_COMICLR = 0x24,
  OP_SUBI    = 0x25,
  OP_ADDIT   = 0x2c,
  OP_ADDI    = 0x2d,

  OP_BE      = 0x38,
  OP_BLE     = 0x39,
  OP_BL      = 0x3a
};

d528 2
a529 8
/* Given a machine instruction, return its format.  */

static INLINE int
bfd_hppa_insn2fmt (abfd, insn)
     bfd *abfd;
     int insn;
{
  enum hppa_opcode_type op = get_opcode (insn);
d531 58
d591 37
a627 40
    case OP_COMICLR:
    case OP_SUBI:
    case OP_ADDIT:
    case OP_ADDI:
      return 11;

    case OP_COMBT:
    case OP_COMIBT:
    case OP_COMBF:
    case OP_COMIBF:
    case OP_CMPBDT:
    case OP_ADDBT:
    case OP_ADDIBT:
    case OP_ADDBF:
    case OP_ADDIBF:
    case OP_CMPBDF:
    case OP_BVB:
    case OP_BB:
    case OP_MOVB:
    case OP_MOVIB:
    case OP_CMPIBD:
      return 12;

    case OP_LDO:
    case OP_LDB:
    case OP_LDH:
    case OP_LDW:
    case OP_LDWM:
    case OP_STB:
    case OP_STH:
    case OP_STW:
    case OP_STWM:
      if (abfd->arch_info->mach >= 25)
	return 16;	/* Wide mode, format 16.  */
      return 14;

    case OP_FLDW:
    case OP_LDWL:
    case OP_FSTW:
    case OP_STWL:
d630 11
a640 13
	 to describe the 11a format.  */
      if (abfd->arch_info->mach >= 25)
	return -16;	/* Wide mode, format 16a.  */
      return -11;

    case OP_LDD:
    case OP_STD:
      if (abfd->arch_info->mach >= 25)
	return -10;	/* Wide mode, format 10a.  */
      return 10;

    case OP_BL:
      if ((insn & 0x8000) != 0)
d642 6
a647 9
      /* fall thru */
    case OP_BE:
    case OP_BLE:
      return 17;

    case OP_LDIL:
    case OP_ADDIL:
      return 21;

d649 1
d652 1
a652 1
  return 32;
d658 10
a668 6
static INLINE int
hppa_rebuild_insn (insn, value, r_format)
     int insn;
     int value;
     int r_format;
{
d672 8
a679 1
      return (insn & ~ 0x7ff) | low_sign_unext (value, 11);
d682 2
a683 2
      return (insn & ~ 0x1ffd) | re_assemble_12 (value);

d685 5
a689 5
    case 10:
      return (insn & ~ 0x3ff1) | re_assemble_14 (value & -8);

    case -11:
      return (insn & ~ 0x3ff9) | re_assemble_14 (value & -4);
d692 7
a698 1
      return (insn & ~ 0x3fff) | re_assemble_14 (value);
d700 3
d704 5
a708 12
    case -10:
      return (insn & ~ 0xfff1) | re_assemble_16 (value & -8);

    case -16:
      return (insn & ~ 0xfff9) | re_assemble_16 (value & -4);

    case 16:
      return (insn & ~ 0xffff) | re_assemble_16 (value);


    case 17:
      return (insn & ~ 0x1f1ffd) | re_assemble_17 (value);
d711 2
a712 1
      return (insn & ~ 0x1fffff) | re_assemble_21 (value);
d714 4
a717 2
    case 22:
      return (insn & ~ 0x3ff1ffd) | re_assemble_22 (value);
d720 1
d729 1
a729 1
#endif /* _LIBHPPA_H */
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2003 Free Software Foundation, Inc.
d30 8
d167 16
a182 16
static inline int sign_extend (int, int) ATTRIBUTE_UNUSED;
static inline int low_sign_extend (int, int) ATTRIBUTE_UNUSED;
static inline int sign_unext (int, int) ATTRIBUTE_UNUSED;
static inline int low_sign_unext (int, int) ATTRIBUTE_UNUSED;
static inline int re_assemble_3 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_12 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_14 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_16 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_17 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_21 (int) ATTRIBUTE_UNUSED;
static inline int re_assemble_22 (int) ATTRIBUTE_UNUSED;
static inline bfd_signed_vma hppa_field_adjust
  (bfd_vma, bfd_signed_vma, enum hppa_reloc_field_selector_type_alt)
  ATTRIBUTE_UNUSED;
static inline int bfd_hppa_insn2fmt (bfd *, int) ATTRIBUTE_UNUSED;
static inline int hppa_rebuild_insn (int, int, int) ATTRIBUTE_UNUSED;
d189 3
a191 2
static inline int
sign_extend (int x, int len)
d198 3
a200 2
static inline int
low_sign_extend (int x, int len)
d210 3
a212 2
static inline int
sign_unext (int x, int len)
d221 3
a223 2
static inline int
low_sign_unext (int x, int len)
d235 3
a237 2
static inline int
re_assemble_3 (int as3)
d243 3
a245 2
static inline int
re_assemble_12 (int as12)
d252 3
a254 2
static inline int
re_assemble_14 (int as14)
d260 3
a262 2
static inline int
re_assemble_16 (int as16)
d272 3
a274 2
static inline int
re_assemble_17 (int as17)
d282 3
a284 2
static inline int
re_assemble_21 (int as21)
d293 3
a295 2
static inline int
re_assemble_22 (int as22)
d315 5
a319 4
static inline bfd_signed_vma
hppa_field_adjust (bfd_vma sym_val,
		   bfd_signed_vma addend,
		   enum hppa_reloc_field_selector_type_alt r_field)
d482 4
a485 2
static inline int
bfd_hppa_insn2fmt (bfd *abfd, int insn)
d566 5
a570 2
static inline int
hppa_rebuild_insn (int insn, int value, int r_format)
@


