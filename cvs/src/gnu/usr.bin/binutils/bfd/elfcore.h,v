head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.15;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.44;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.19.19;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.42;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.25.31;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.17;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.28;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ELF core file support for BFD.
   Copyright 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

char*
elf_core_file_failing_command (bfd *abfd)
{
  return elf_tdata (abfd)->core_command;
}

int
elf_core_file_failing_signal (bfd *abfd)
{
  return elf_tdata (abfd)->core_signal;
}

bfd_boolean
elf_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)
{
  char* corename;

  /* xvecs must match if both are ELF files for the same target.  */

  if (core_bfd->xvec != exec_bfd->xvec)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  /* See if the name in the corefile matches the executable name.  */
  corename = elf_tdata (core_bfd)->core_program;
  if (corename != NULL)
    {
      const char* execname = strrchr (exec_bfd->filename, '/');

      execname = execname ? execname + 1 : exec_bfd->filename;

      if (strcmp (execname, corename) != 0)
	return FALSE;
    }

  return TRUE;
}

/*  Core files are simply standard ELF formatted files that partition
    the file using the execution view of the file (program header table)
    rather than the linking view.  In fact, there is no section header
    table in a core file.

    The process status information (including the contents of the general
    register set) and the floating point register set are stored in a
    segment of type PT_NOTE.  We handcraft a couple of extra bfd sections
    that allow standard bfd access to the general registers (.reg) and the
    floating point registers (.reg2).  */

const bfd_target *
elf_core_file_p (bfd *abfd)
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form.  */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form.  */
  Elf_Internal_Phdr *i_phdrp;	/* Elf program header, internal form.  */
  unsigned int phindex;
  const struct elf_backend_data *ebd;
  struct bfd_preserve preserve;
  bfd_size_type amt;

  preserve.marker = NULL;

  /* Read in the ELF header in external format.  */
  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto wrong;
      else
	goto fail;
    }

  /* Check the magic number.  */
  if (! elf_file_p (&x_ehdr))
    goto wrong;

  /* FIXME: Check EI_VERSION here !  */

  /* Check the address size ("class").  */
  if (x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    goto wrong;

  /* Check the byteorder.  */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian.  */
      if (! bfd_big_endian (abfd))
	goto wrong;
      break;
    case ELFDATA2LSB:		/* Little-endian.  */
      if (! bfd_little_endian (abfd))
	goto wrong;
      break;
    default:
      goto wrong;
    }

  if (!bfd_preserve_save (abfd, &preserve))
    goto fail;

  /* Give abfd an elf_obj_tdata.  */
  if (! (*abfd->xvec->_bfd_set_format[bfd_core]) (abfd))
    goto fail;
  preserve.marker = elf_tdata (abfd);

  /* Swap in the rest of the header, now that we have the byte order.  */
  i_ehdrp = elf_elfheader (abfd);
  elf_swap_ehdr_in (abfd, &x_ehdr, i_ehdrp);

#if DEBUG & 1
  elf_debug_file (i_ehdrp);
#endif

  ebd = get_elf_backend_data (abfd);

  /* Check that the ELF e_machine field matches what this particular
     BFD format expects.  */

  if (ebd->elf_machine_code != i_ehdrp->e_machine
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
    {
      const bfd_target * const *target_ptr;

      if (ebd->elf_machine_code != EM_NONE)
	goto wrong;

      /* This is the generic ELF target.  Let it match any ELF target
	 for which we do not have a specific backend.  */

      for (target_ptr = bfd_target_vector; *target_ptr != NULL; target_ptr++)
	{
	  const struct elf_backend_data *back;

	  if ((*target_ptr)->flavour != bfd_target_elf_flavour)
	    continue;
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
	          && i_ehdrp->e_machine == back->elf_machine_alt1)
	      || (back->elf_machine_alt2 != 0
	          && i_ehdrp->e_machine == back->elf_machine_alt2))
	    {
	      /* target_ptr is an ELF backend which matches this
		 object file, so reject the generic ELF target.  */
	      goto wrong;
	    }
	}
    }

  /* If there is no program header, or the type is not a core file, then
     we are hosed.  */
  if (i_ehdrp->e_phoff == 0 || i_ehdrp->e_type != ET_CORE)
    goto wrong;

  /* Does BFD's idea of the phdr size match the size
     recorded in the file? */
  if (i_ehdrp->e_phentsize != sizeof (Elf_External_Phdr))
    goto wrong;

  /* Move to the start of the program headers.  */
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
    goto wrong;

  /* Allocate space for the program headers.  */
  amt = sizeof (*i_phdrp) * i_ehdrp->e_phnum;
  i_phdrp = bfd_alloc (abfd, amt);
  if (!i_phdrp)
    goto fail;

  elf_tdata (abfd)->phdr = i_phdrp;

  /* Read and convert to internal form.  */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
    {
      Elf_External_Phdr x_phdr;

      if (bfd_bread (&x_phdr, sizeof (x_phdr), abfd) != sizeof (x_phdr))
	goto fail;

      elf_swap_phdr_in (abfd, &x_phdr, i_phdrp + phindex);
    }

  /* Set the machine architecture.  Do this before processing the
     program headers since we need to know the architecture type
     when processing the notes of some systems' core files.  */
  if (! bfd_default_set_arch_mach (abfd, ebd->arch, 0))
    {
      /* It's OK if this fails for the generic target.  */
      if (ebd->elf_machine_code != EM_NONE)
	goto fail;
    }

  /* Process each program header.  */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
    if (! bfd_section_from_phdr (abfd, i_phdrp + phindex, (int) phindex))
      goto fail;

  /* Save the entry point from the ELF header.  */
  bfd_get_start_address (abfd) = i_ehdrp->e_entry;

  /* Let the backend double check the format and override global
     information.  */
  if (ebd->elf_backend_object_p
      && (! (*ebd->elf_backend_object_p) (abfd)))
    goto wrong;

  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;

wrong:
  /* There is way too much undoing of half-known state here.  The caller,
     bfd_check_format_matches, really shouldn't iterate on live bfd's to
     check match/no-match like it does.  We have to rely on that a call to
     bfd_default_set_arch_mach with the previously known mach, undoes what
     was done by the first bfd_default_set_arch_mach (with mach 0) here.
     For this to work, only elf-data and the mach may be changed by the
     target-specific elf_backend_object_p function.  Note that saving the
     whole bfd here and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
  bfd_set_error (bfd_error_wrong_format);

fail:
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
  return NULL;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d22 1
a22 2
elf_core_file_failing_command (abfd)
     bfd *abfd;
d28 1
a28 2
elf_core_file_failing_signal (abfd)
     bfd *abfd;
d34 1
a34 3
elf_core_file_matches_executable_p (core_bfd, exec_bfd)
     bfd *core_bfd;
     bfd *exec_bfd;
d54 1
a54 1
      if (strcmp(execname, corename) != 0)
d73 1
a73 2
elf_core_file_p (abfd)
     bfd *abfd;
d79 1
a79 1
  struct elf_backend_data *ebd;
d86 1
a86 2
  if (bfd_bread ((PTR) &x_ehdr, (bfd_size_type) sizeof (x_ehdr), abfd)
      != sizeof (x_ehdr))
a118 5
  /* Give abfd an elf_obj_tdata.  */
  amt = sizeof (struct elf_obj_tdata);
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
    goto fail;
d122 4
a125 1
  elf_tdata (abfd) = preserve.marker;
d156 1
a156 1
	  struct elf_backend_data *back;
d160 1
a160 1
	  back = (struct elf_backend_data *) (*target_ptr)->backend_data;
d190 1
a190 1
  i_phdrp = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d201 1
a201 2
      if (bfd_bread ((PTR) &x_phdr, (bfd_size_type) sizeof (x_phdr), abfd)
	  != sizeof (x_phdr))
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 2000, 2001
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
a35 1
boolean
d47 1
a47 1
      return false;
a50 1

d55 1
d59 1
a59 1
	return false;
d62 1
a62 1
  return true;
d74 1
a74 3
    floating point registers (.reg2).

 */
d80 3
a82 3
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_Internal_Phdr *i_phdrp = NULL;	/* Elf program header, internal form */
d85 4
a88 2
  struct elf_obj_tdata *preserved_tdata = elf_tdata (abfd);
  struct elf_obj_tdata *new_tdata = NULL;
d91 2
a92 1
  if (bfd_read ((PTR) & x_ehdr, sizeof (x_ehdr), 1, abfd) != sizeof (x_ehdr))
d95 3
a97 2
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
d101 1
a101 1
  if (elf_file_p (&x_ehdr) == false)
d104 1
a104 1
  /* FIXME: Check EI_VERSION here ! */
d113 1
a113 1
    case ELFDATA2MSB:		/* Big-endian */
d117 1
a117 1
    case ELFDATA2LSB:		/* Little-endian */
d126 8
a133 5
  new_tdata =
    (struct elf_obj_tdata *) bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
  if (new_tdata == NULL)
    return NULL;
  elf_tdata (abfd) = new_tdata;
d169 5
a173 1
	  if (back->elf_machine_code == i_ehdrp->e_machine)
d193 1
a193 1
  if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0)
d197 2
a198 2
  i_phdrp = (Elf_Internal_Phdr *)
    bfd_alloc (abfd, sizeof (*i_phdrp) * i_ehdrp->e_phnum);
d208 2
a209 1
      if (bfd_read ((PTR) &x_phdr, sizeof (x_phdr), 1, abfd)
d216 3
a218 8
  /* Process each program header.  */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
    {
      if (!_bfd_elfcore_section_from_phdr (abfd, i_phdrp + phindex, phindex))
	goto fail;
    }

  /* Set the machine architecture.  */
d226 5
d236 3
a238 5
  if (ebd->elf_backend_object_p)
    {
      if ((*ebd->elf_backend_object_p) (abfd) == false)
	goto wrong;
    }
d240 1
d244 9
d254 1
d256 2
a257 5
  if (i_phdrp != NULL)
    bfd_release (abfd, i_phdrp);
  if (new_tdata != NULL)
    bfd_release (abfd, new_tdata);
  elf_tdata (abfd) = preserved_tdata;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
a20 1

a34 1

d42 1
a42 1
  /* xvecs must match if both are ELF files for the same target. */
d50 1
a50 1
  /* See if the name in the corefile matches the executable name. */
a64 1

d84 1
a84 1
  Elf_Internal_Phdr *i_phdrp;	/* Elf program header, internal form */
d87 2
d98 1
a98 1
  /* Check the magic number. */
d100 1
a100 5
    {
    wrong:
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d104 1
a104 1
  /* Check the address size ("class"). */
d108 1
a108 1
  /* Check the byteorder. */
d123 2
a124 2
  /* Give abfd an elf_obj_tdata. */
  elf_tdata (abfd) =
d126 1
a126 1
  if (elf_tdata (abfd) == NULL)
d128 1
d130 1
a130 3
  /* FIXME: from here on down, "goto wrong" will leak memory.  */

  /* Swap in the rest of the header, now that we have the byte order. */
d174 1
a174 1
     we are hosed. */
d183 5
a187 1
  /* Allocate space for the program headers. */
d191 1
a191 1
    return NULL;
d195 1
a195 1
  /* Read and convert to internal form. */
d201 1
a201 1
	return NULL;
d206 1
a206 1
  /* Process each program header. */
d210 1
a210 1
	return NULL;
d213 1
a213 1
  /* Set the machine architecture. */
d218 1
a218 1
	return NULL;
d221 1
a221 1
  /* Save the entry point from the ELF header. */
d224 8
d233 10
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
a18 1
/* Core file support */
a19 24
#ifdef HAVE_SYS_PROCFS_H		/* Some core file support requires host /proc files */
#include <signal.h>
#include <sys/procfs.h>

/* Solaris includes the field pr_who that indicates the thread number within
   the process.  */

#ifdef PIOCOPENLWP
#define get_thread(STATUS) ((((prstatus_t *)(STATUS))->pr_who << 16) \
			    | ((prstatus_t *)(STATUS))->pr_pid)
#else
#define get_thread(STATUS) (((prstatus_t *)(STATUS))->pr_pid)
#endif
#else
#define bfd_prstatus(abfd, descdata, descsz, filepos, thread) true
#define bfd_fpregset(abfd, descdata, descsz, filepos, thread) true
#define bfd_prpsinfo(abfd, descdata, descsz, filepos) true
#define get_thread(STATUS) (1)
#endif

#ifdef HAVE_SYS_PROCFS_H

static int did_reg;
static int did_reg2;
d21 1
a21 119
static boolean
bfd_prstatus (abfd, descdata, descsz, filepos, thread)
     bfd *abfd;
     char *descdata;
     int descsz;
     long filepos;
     int thread;
{
  asection *newsect;
  prstatus_t *status = (prstatus_t *) 0;

  if (descsz == sizeof (prstatus_t))
    {
      char secname[100];
      char *p;

      sprintf (secname, ".reg/%d", thread);
      p = bfd_alloc (abfd, strlen (secname) + 1);
      if (!p)
	return false;
      strcpy (p, secname);
      
      newsect = bfd_make_section (abfd, p);
      if (newsect == NULL)
	return false;
      newsect->_raw_size = sizeof (status->pr_reg);
      newsect->filepos = filepos + (long) &status->pr_reg;
      newsect->flags = SEC_HAS_CONTENTS;
      newsect->alignment_power = 2;
      if ((core_prstatus (abfd) = bfd_alloc (abfd, descsz)) != NULL)
	{
	  memcpy (core_prstatus (abfd), descdata, descsz);
	}

      if (!did_reg++)
	{
	  asection *regsect;

	  regsect = bfd_make_section (abfd, ".reg");
	  if (regsect == NULL)
	    return false;
	  regsect->_raw_size = newsect->_raw_size;
	  regsect->filepos = newsect->filepos;
	  regsect->flags = newsect->flags;
	  regsect->alignment_power = newsect->alignment_power;
	}
    }
  return true;
}

/* Stash a copy of the prpsinfo structure away for future use. */

static boolean
bfd_prpsinfo (abfd, descdata, descsz, filepos)
     bfd *abfd;
     char *descdata;
     int descsz;
     long filepos;
{
  if (descsz == sizeof (prpsinfo_t))
    {
      if ((core_prpsinfo (abfd) = bfd_alloc (abfd, descsz)) == NULL)
	return false;
      memcpy (core_prpsinfo (abfd), descdata, descsz);
    }
  return true;
}

static boolean
bfd_fpregset (abfd, descdata, descsz, filepos, thread)
     bfd *abfd;
     char *descdata;
     int descsz;
     long filepos;
     int thread;
{
  asection *newsect;
  char secname[100];
  char *p;

  sprintf (secname, ".reg2/%d", thread);
  p = bfd_alloc (abfd, strlen (secname) + 1);
  if (!p)
    return false;
  strcpy (p, secname);

  newsect = bfd_make_section (abfd, p);
  if (newsect == NULL)
    return false;
  newsect->_raw_size = descsz;
  newsect->filepos = filepos;
  newsect->flags = SEC_HAS_CONTENTS;
  newsect->alignment_power = 2;

  if (!did_reg2++)
    {
      asection *regsect;

      regsect = bfd_make_section (abfd, ".reg2");
      if (regsect == NULL)
	return false;
      regsect->_raw_size = newsect->_raw_size;
      regsect->filepos = newsect->filepos;
      regsect->flags = newsect->flags;
      regsect->alignment_power = newsect->alignment_power;
    }

  return true;
}

#endif /* HAVE_SYS_PROCFS_H */

/* Return a pointer to the args (including the command name) that were
   seen by the program that generated the core dump.  Note that for
   some reason, a spurious space is tacked onto the end of the args
   in some (at least one anyway) implementations, so strip it off if
   it exists. */

char *
d25 1
a25 17
#ifdef HAVE_SYS_PROCFS_H
  if (core_prpsinfo (abfd))
    {
      prpsinfo_t *p = core_prpsinfo (abfd);
      char *scan = p->pr_psargs;
      while (*scan++)
	{;
	}
      scan -= 2;
      if ((scan > p->pr_psargs) && (*scan == ' '))
	{
	  *scan = '\000';
	}
      return p->pr_psargs;
    }
#endif
  return NULL;
a27 5
/* Return the number of the signal that caused the core dump.  Presumably,
   since we have a core file, we got a signal of some kind, so don't bother
   checking the other process status fields, just return the signal number.
   */

d32 1
a32 7
#ifdef HAVE_SYS_PROCFS_H
  if (core_prstatus (abfd))
    {
      return ((prstatus_t *) (core_prstatus (abfd)))->pr_cursig;
    }
#endif
  return -1;
a34 5
/* Check to see if the core file could reasonably be expected to have
   come for the current executable file.  Note that by default we return
   true unless we find something that indicates that there might be a
   problem.
   */
d41 1
a41 4
#ifdef HAVE_SYS_PROCFS_H
  char *corename;
  char *execname;
#endif
d43 1
a43 1
  /* First, xvecs must match since both are ELF files for the same target. */
d51 1
a51 1
#ifdef HAVE_SYS_PROCFS_H
d53 2
a54 8
  /* If no prpsinfo, just return true.  Otherwise, grab the last component
     of the exec'd pathname from the prpsinfo. */

  if (core_prpsinfo (core_bfd))
    {
      corename = (((prpsinfo_t *) core_prpsinfo (core_bfd))->pr_fname);
    }
  else
d56 2
a57 2
      return true;
    }
d59 2
a60 5
  /* Find the last component of the executable pathname. */

  if ((execname = strrchr (exec_bfd->filename, '/')) != NULL)
    {
      execname++;
a61 10
  else
    {
      execname = (char *) exec_bfd->filename;
    }

  /* See if they match */

  return strcmp (execname, corename) ? false : true;

#else
a63 2

#endif /* HAVE_SYS_PROCFS_H */
a65 109
/* ELF core files contain a segment of type PT_NOTE, that holds much of
   the information that would normally be available from the /proc interface
   for the process, at the time the process dumped core.  Currently this
   includes copies of the prstatus, prpsinfo, and fpregset structures.

   Since these structures are potentially machine dependent in size and
   ordering, bfd provides two levels of support for them.  The first level,
   available on all machines since it does not require that the host
   have /proc support or the relevant include files, is to create a bfd
   section for each of the prstatus, prpsinfo, and fpregset structures,
   without any interpretation of their contents.  With just this support,
   the bfd client will have to interpret the structures itself.  Even with
   /proc support, it might want these full structures for it's own reasons.

   In the second level of support, where HAVE_SYS_PROCFS_H is defined,
   bfd will pick apart the structures to gather some additional
   information that clients may want, such as the general register
   set, the name of the exec'ed file and its arguments, the signal (if
   any) that caused the core dump, etc.

   */

static boolean
elf_corefile_note (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
{
  Elf_External_Note *x_note_p;	/* Elf note, external form */
  Elf_Internal_Note i_note;	/* Elf note, internal form */
  char *buf = NULL;		/* Entire note segment contents */
  char *namedata;		/* Name portion of the note */
  char *descdata;		/* Descriptor portion of the note */
  char *sectname;		/* Name to use for new section */
  long filepos;			/* File offset to descriptor data */
  asection *newsect;
  int thread = 1;		/* Current thread number */

#ifdef HAVE_SYS_PROCFS_H
  did_reg = 0;			/* Non-zero if we made .reg section */
  did_reg2 = 0;			/* Ditto for .reg2 */
#endif

  if (hdr->p_filesz > 0
      && (buf = (char *) bfd_malloc ((size_t) hdr->p_filesz)) != NULL
      && bfd_seek (abfd, hdr->p_offset, SEEK_SET) != -1
      && bfd_read ((PTR) buf, hdr->p_filesz, 1, abfd) == hdr->p_filesz)
    {
      x_note_p = (Elf_External_Note *) buf;
      while ((char *) x_note_p < (buf + hdr->p_filesz))
	{
	  i_note.namesz = bfd_h_get_32 (abfd, (bfd_byte *) x_note_p->namesz);
	  i_note.descsz = bfd_h_get_32 (abfd, (bfd_byte *) x_note_p->descsz);
	  i_note.type = bfd_h_get_32 (abfd, (bfd_byte *) x_note_p->type);
	  namedata = x_note_p->name;
	  descdata = namedata + BFD_ALIGN (i_note.namesz, 4);
	  filepos = hdr->p_offset + (descdata - buf);
	  switch (i_note.type)
	    {
	    case NT_PRSTATUS:
	      /* process descdata as prstatus info */
	      thread = get_thread (descdata);
	      if (! bfd_prstatus (abfd, descdata, i_note.descsz, filepos,
				  thread))
		return false;
	      sectname = NULL;
	      break;
	    case NT_FPREGSET:
	      /* process descdata as fpregset info */
	      if (! bfd_fpregset (abfd, descdata, i_note.descsz, filepos,
				  thread))
		return false;
	      sectname = NULL;
	      break;
	    case NT_PRPSINFO:
	      /* process descdata as prpsinfo */
	      if (! bfd_prpsinfo (abfd, descdata, i_note.descsz, filepos))
		return false;
	      sectname = ".prpsinfo";
	      break;
	    default:
	      /* Unknown descriptor, just ignore it. */
	      sectname = NULL;
	      break;
	    }
	  if (sectname != NULL)
	    {
	      newsect = bfd_make_section (abfd, sectname);
	      if (newsect == NULL)
		return false;
	      newsect->_raw_size = i_note.descsz;
	      newsect->filepos = filepos;
	      newsect->flags = SEC_ALLOC | SEC_HAS_CONTENTS;
	      newsect->alignment_power = 2;
	    }
	  x_note_p = (Elf_External_Note *)
	    (descdata + BFD_ALIGN (i_note.descsz, 4));
	}
    }
  if (buf != NULL)
    {
      free (buf);
    }
  else if (hdr->p_filesz > 0)
    {
      return false;
    }
  return true;

}
d86 1
a86 2
  Elf_External_Phdr x_phdr;	/* Program header table entry, external form */
  Elf_Internal_Phdr *i_phdrp;	/* Program header table, internal form */
a90 1

d98 1
a98 6
  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry, and it must have a
     program header table (FIXME: See comments re segments at top of this
     file). */

d106 1
a106 1
  /* FIXME, Check EI_VERSION here !  */
d108 3
a110 11
  {
#if ARCH_SIZE == 32
    int desired_address_size = ELFCLASS32;
#endif
#if ARCH_SIZE == 64
    int desired_address_size = ELFCLASS64;
#endif

    if (x_ehdr.e_ident[EI_CLASS] != desired_address_size)
      goto wrong;
  }
d112 1
a112 1
  /* Switch xvec to match the specified byte order.  */
d123 1
a123 2
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
d127 1
a127 3
  /* Allocate an instance of the elf_obj_tdata structure and hook it up to
     the tdata pointer in the bfd. */

d133 1
a133 1
  /* FIXME, `wrong' returns from this point onward, leak memory.  */
d135 1
a135 1
  /* Now that we know the byte order, swap in the rest of the header */
d138 1
d147 1
d149 4
a152 2
      && (ebd->elf_machine_alt1 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt2))
d161 1
d183 4
a186 5
  /* Allocate space for a copy of the program header table in
     internal form, seek to the program header table in the file,
     read it in, and convert it to internal form.  As a simple sanity
     check, verify that the what BFD thinks is the size of each program
     header table entry actually matches the size recorded in the file. */
d188 1
a188 2
  if (i_ehdrp->e_phentsize != sizeof (x_phdr))
    goto wrong;
d193 5
a197 3
  if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) == -1)
    return NULL;
  for (phindex = 0; phindex < i_ehdrp->e_phnum; phindex++)
d199 2
a200 1
      if (bfd_read ((PTR) & x_phdr, sizeof (x_phdr), 1, abfd)
d203 1
d207 6
a212 2
  /* Once all of the program headers have been read and converted, we
     can start processing them. */
d214 2
a215 1
  for (phindex = 0; phindex < i_ehdrp->e_phnum; phindex++)
d217 3
a219 6
      bfd_section_from_phdr (abfd, i_phdrp + phindex, phindex);
      if ((i_phdrp + phindex)->p_type == PT_NOTE)
	{
	  if (! elf_corefile_note (abfd, i_phdrp + phindex))
	    return NULL;
	}
d222 1
a222 2
  /* Remember the entry point specified in the ELF file header. */

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright  1995 Free Software Foundation, Inc.
d22 1
d24 7
d32 5
a36 2
#define bfd_prstatus(abfd, descdata, descsz, filepos) true
#define bfd_fpregset(abfd, descdata, descsz, filepos) true
d38 1
d43 3
d47 1
a47 1
bfd_prstatus (abfd, descdata, descsz, filepos)
d52 1
d59 10
a68 1
      newsect = bfd_make_section (abfd, ".reg");
d79 13
d108 1
a108 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d115 1
a115 1
bfd_fpregset (abfd, descdata, descsz, filepos)
d120 1
d123 8
d132 1
a132 1
  newsect = bfd_make_section (abfd, ".reg2");
d139 14
d300 6
d308 1
a308 1
      && (buf = (char *) malloc ((size_t) hdr->p_filesz)) != NULL
d325 3
a327 1
	      if (! bfd_prstatus (abfd, descdata, i_note.descsz, filepos))
d329 1
a329 1
	      sectname = ".prstatus";
d333 2
a334 1
	      if (! bfd_fpregset (abfd, descdata, i_note.descsz, filepos))
d336 1
a336 1
	      sectname = ".fpregset";
a368 1
      bfd_set_error (bfd_error_no_memory);
d439 1
a439 1
      if (abfd->xvec->byteorder_big_p == false)
d443 1
a443 1
      if (abfd->xvec->byteorder_big_p == true)
d457 1
a457 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d515 1
a515 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
a21 1
#include <signal.h>
a22 7

/* Solaris includes the field pr_who that indicates the thread number within
   the process.  */

#ifdef PIOCOPENLWP
#define get_thread(STATUS) ((((prstatus_t *)(STATUS))->pr_who << 16) \
			    | ((prstatus_t *)(STATUS))->pr_pid)
d24 2
a25 5
#define get_thread(STATUS) (((prstatus_t *)(STATUS))->pr_pid)
#endif
#else
#define bfd_prstatus(abfd, descdata, descsz, filepos, thread) true
#define bfd_fpregset(abfd, descdata, descsz, filepos, thread) true
a26 1
#define get_thread(STATUS) (1)
a30 3
static int did_reg;
static int did_reg2;

d32 1
a32 1
bfd_prstatus (abfd, descdata, descsz, filepos, thread)
a36 1
     int thread;
d43 1
a43 10
      char secname[100];
      char *p;

      sprintf (secname, ".reg/%d", thread);
      p = bfd_alloc (abfd, strlen (secname) + 1);
      if (!p)
	return false;
      strcpy (p, secname);
      
      newsect = bfd_make_section (abfd, p);
a53 13

      if (!did_reg++)
	{
	  asection *regsect;

	  regsect = bfd_make_section (abfd, ".reg");
	  if (regsect == NULL)
	    return false;
	  regsect->_raw_size = newsect->_raw_size;
	  regsect->filepos = newsect->filepos;
	  regsect->flags = newsect->flags;
	  regsect->alignment_power = newsect->alignment_power;
	}
d70 4
a73 1
	return false;
d80 1
a80 1
bfd_fpregset (abfd, descdata, descsz, filepos, thread)
a84 1
     int thread;
a86 8
  char secname[100];
  char *p;

  sprintf (secname, ".reg2/%d", thread);
  p = bfd_alloc (abfd, strlen (secname) + 1);
  if (!p)
    return false;
  strcpy (p, secname);
d88 1
a88 1
  newsect = bfd_make_section (abfd, p);
a94 14

  if (!did_reg2++)
    {
      asection *regsect;

      regsect = bfd_make_section (abfd, ".reg2");
      if (regsect == NULL)
	return false;
      regsect->_raw_size = newsect->_raw_size;
      regsect->filepos = newsect->filepos;
      regsect->flags = newsect->flags;
      regsect->alignment_power = newsect->alignment_power;
    }

a241 6
  int thread = 1;		/* Current thread number */

#ifdef HAVE_SYS_PROCFS_H
  did_reg = 0;			/* Non-zero if we made .reg section */
  did_reg2 = 0;			/* Ditto for .reg2 */
#endif
d244 1
a244 1
      && (buf = (char *) bfd_malloc ((size_t) hdr->p_filesz)) != NULL
d261 1
a261 3
	      thread = get_thread (descdata);
	      if (! bfd_prstatus (abfd, descdata, i_note.descsz, filepos,
				  thread))
d263 1
a263 1
	      sectname = NULL;
d267 1
a267 2
	      if (! bfd_fpregset (abfd, descdata, i_note.descsz, filepos,
				  thread))
d269 1
a269 1
	      sectname = NULL;
d302 1
d373 1
a373 1
      if (! bfd_big_endian (abfd))
d377 1
a377 1
      if (! bfd_little_endian (abfd))
d391 4
a394 1
    return NULL;
d452 4
a455 1
    return NULL;
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
a33 6

static boolean bfd_prstatus PARAMS ((bfd *, char *, int, long, int));
static boolean bfd_prpsinfo PARAMS ((bfd *, char *, int, long));
static boolean bfd_fpregset PARAMS ((bfd *, char *, int, long, int));
static boolean elf_corefile_note PARAMS ((bfd *, Elf_Internal_Phdr *));

@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d19 1
d21 148
d170 1
a170 1
char*
d174 17
a190 1
  return elf_tdata (abfd)->core_command;
d193 5
d202 7
a208 1
  return elf_tdata (abfd)->core_signal;
d211 5
d222 4
a225 1
  char* corename;
d227 1
a227 1
  /* xvecs must match if both are ELF files for the same target. */
d235 1
a235 1
  /* See if the name in the corefile matches the executable name. */
d237 8
a244 2
  corename = elf_tdata (core_bfd)->core_program;
  if (corename != NULL)
d246 4
a249 2
      const char* execname = strrchr (exec_bfd->filename, '/');
      execname = execname ? execname + 1 : exec_bfd->filename;
d251 7
a257 2
      if (strcmp(execname, corename) != 0)
	return false;
d260 6
d267 2
d271 109
d400 2
a401 1
  Elf_Internal_Phdr *i_phdrp;	/* Elf program header, internal form */
d406 1
d414 6
a419 1
  /* Check the magic number. */
d427 9
a435 1
  /* FIXME: Check EI_VERSION here ! */
d437 3
a439 3
  /* Check the address size ("class"). */
  if (x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    goto wrong;
d441 1
a441 1
  /* Check the byteorder. */
d452 2
a453 1
    default:
d457 3
a459 1
  /* Give abfd an elf_obj_tdata. */
d465 1
a465 1
  /* FIXME: from here on down, "goto wrong" will leak memory.  */
d467 1
a467 1
  /* Swap in the rest of the header, now that we have the byte order. */
a469 1

a477 1

d479 2
a480 4
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
a488 1

d510 7
a516 3
  /* Does BFD's idea of the phdr size match the size
     recorded in the file? */
  if (i_ehdrp->e_phentsize != sizeof (Elf_External_Phdr))
a517 2

  /* Allocate space for the program headers. */
d522 3
a524 5

  elf_tdata (abfd)->phdr = i_phdrp;

  /* Read and convert to internal form. */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
d526 1
a526 2
      Elf_External_Phdr x_phdr;
      if (bfd_read ((PTR) &x_phdr, sizeof (x_phdr), 1, abfd)
a528 1

d532 4
a535 2
  /* Process each program header. */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
d537 6
a542 2
      if (!_bfd_elfcore_section_from_phdr (abfd, i_phdrp + phindex, phindex))
	return NULL;
d545 1
a545 7
  /* Set the machine architecture. */
  if (! bfd_default_set_arch_mach (abfd, ebd->arch, 0))
    {
      /* It's OK if this fails for the generic target.  */
      if (ebd->elf_machine_code != EM_NONE)
	return NULL;
    }
a546 1
  /* Save the entry point from the ELF header. */
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
d20 1
d35 1
d43 1
a43 1
  /* xvecs must match if both are ELF files for the same target.  */
d51 1
a51 1
  /* See if the name in the corefile matches the executable name.  */
d66 1
d86 1
a86 1
  Elf_Internal_Phdr *i_phdrp = NULL;	/* Elf program header, internal form */
a88 2
  struct elf_obj_tdata *preserved_tdata = elf_tdata (abfd);
  struct elf_obj_tdata *new_tdata = NULL;
d98 1
a98 1
  /* Check the magic number.  */
d100 5
a104 1
    goto wrong;
d108 1
a108 1
  /* Check the address size ("class").  */
d112 1
a112 1
  /* Check the byteorder.  */
d127 2
a128 2
  /* Give abfd an elf_obj_tdata.  */
  new_tdata =
d130 1
a130 1
  if (new_tdata == NULL)
a131 1
  elf_tdata (abfd) = new_tdata;
d133 3
a135 1
  /* Swap in the rest of the header, now that we have the byte order.  */
d179 1
a179 1
     we are hosed.  */
d188 1
a188 5
  /* Move to the start of the program headers.  */
  if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0)
    goto wrong;

  /* Allocate space for the program headers.  */
d192 1
a192 1
    goto fail;
d196 1
a196 1
  /* Read and convert to internal form.  */
d202 1
a202 1
	goto fail;
d207 1
a207 1
  /* Process each program header.  */
d211 1
a211 1
	goto fail;
d214 1
a214 1
  /* Set the machine architecture.  */
d219 1
a219 1
	goto fail;
d222 1
a222 1
  /* Save the entry point from the ELF header.  */
a224 8
  /* Let the backend double check the format and override global
     information.  */
  if (ebd->elf_backend_object_p)
    {
      if ((*ebd->elf_backend_object_p) (abfd) == false)
	goto wrong;
    }

a225 10

wrong:
  bfd_set_error (bfd_error_wrong_format);
fail:
  if (i_phdrp != NULL)
    bfd_release (abfd, i_phdrp);
  if (new_tdata != NULL)
    bfd_release (abfd, new_tdata);
  elf_tdata (abfd) = preserved_tdata;
  return NULL;
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
a35 1
bfd_boolean
d47 1
a47 1
      return FALSE;
d51 1
a55 1

d59 1
a59 1
	return FALSE;
d62 1
a62 1
  return TRUE;
d74 3
a76 1
    floating point registers (.reg2).  */
d82 3
a84 3
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form.  */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form.  */
  Elf_Internal_Phdr *i_phdrp;	/* Elf program header, internal form.  */
d87 2
a88 4
  struct bfd_preserve preserve;
  bfd_size_type amt;

  preserve.marker = NULL;
d91 1
a91 2
  if (bfd_bread ((PTR) &x_ehdr, (bfd_size_type) sizeof (x_ehdr), abfd)
      != sizeof (x_ehdr))
d94 2
a95 3
	goto wrong;
      else
	goto fail;
d99 1
a99 1
  if (! elf_file_p (&x_ehdr))
d102 1
a102 1
  /* FIXME: Check EI_VERSION here !  */
d111 1
a111 1
    case ELFDATA2MSB:		/* Big-endian.  */
d115 1
a115 1
    case ELFDATA2LSB:		/* Little-endian.  */
d124 5
a128 8
  amt = sizeof (struct elf_obj_tdata);
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
    goto fail;
  if (!bfd_preserve_save (abfd, &preserve))
    goto fail;

  elf_tdata (abfd) = preserve.marker;
d164 1
a164 5
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
	          && i_ehdrp->e_machine == back->elf_machine_alt1)
	      || (back->elf_machine_alt2 != 0
	          && i_ehdrp->e_machine == back->elf_machine_alt2))
d184 1
a184 1
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
d188 2
a189 2
  amt = sizeof (*i_phdrp) * i_ehdrp->e_phnum;
  i_phdrp = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d199 1
a199 2

      if (bfd_bread ((PTR) &x_phdr, (bfd_size_type) sizeof (x_phdr), abfd)
d206 8
a213 3
  /* Set the machine architecture.  Do this before processing the
     program headers since we need to know the architecture type
     when processing the notes of some systems' core files.  */
a220 5
  /* Process each program header.  */
  for (phindex = 0; phindex < i_ehdrp->e_phnum; ++phindex)
    if (! bfd_section_from_phdr (abfd, i_phdrp + phindex, (int) phindex))
      goto fail;

d226 5
a230 3
  if (ebd->elf_backend_object_p
      && (! (*ebd->elf_backend_object_p) (abfd)))
    goto wrong;
a231 1
  bfd_preserve_finish (abfd, &preserve);
a234 9
  /* There is way too much undoing of half-known state here.  The caller,
     bfd_check_format_matches, really shouldn't iterate on live bfd's to
     check match/no-match like it does.  We have to rely on that a call to
     bfd_default_set_arch_mach with the previously known mach, undoes what
     was done by the first bfd_default_set_arch_mach (with mach 0) here.
     For this to work, only elf-data and the mach may be changed by the
     target-specific elf_backend_object_p function.  Note that saving the
     whole bfd here and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
a235 1

d237 5
a241 2
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d22 2
a23 1
elf_core_file_failing_command (bfd *abfd)
d29 2
a30 1
elf_core_file_failing_signal (bfd *abfd)
d36 3
a38 1
elf_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)
d58 1
a58 1
      if (strcmp (execname, corename) != 0)
d77 2
a78 1
elf_core_file_p (bfd *abfd)
d84 1
a84 1
  const struct elf_backend_data *ebd;
d91 2
a92 1
  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
d125 5
d133 1
a133 4
  /* Give abfd an elf_obj_tdata.  */
  if (! (*abfd->xvec->_bfd_set_format[bfd_core]) (abfd))
    goto fail;
  preserve.marker = elf_tdata (abfd);
d164 1
a164 1
	  const struct elf_backend_data *back;
d168 1
a168 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
d198 1
a198 1
  i_phdrp = bfd_alloc (abfd, amt);
d209 2
a210 1
      if (bfd_bread (&x_phdr, sizeof (x_phdr), abfd) != sizeof (x_phdr))
@


