head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.08.10.03.25.39;	author guenther;	state Exp;
branches;
next	1.9;
commitid	Ks9P0sWl5Nnr4POS;

1.9
date	2013.04.19.23.20.53;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.20.45.02;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.19;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.05;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.32.40;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.23;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.23;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.47;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.36.51;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.11.59;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.17.40;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.22;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.20.00;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.09;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.12;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Format time_t with %lld after casting to long long
@
text
@/* BFD back-end for archive files (libraries).
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
@@setfilename archive-info
SECTION
	Archives

DESCRIPTION
	An archive (or library) is just another BFD.  It has a symbol
	table, although there's not much a user program will do with it.

	The big difference between an archive BFD and an ordinary BFD
	is that the archive doesn't have sections.  Instead it has a
	chain of BFDs that are considered its contents.  These BFDs can
	be manipulated like any other.  The BFDs contained in an
	archive opened for reading will all be opened for reading.  You
	may put either input or output BFDs into an archive opened for
	output; they will be handled correctly when the archive is closed.

	Use <<bfd_openr_next_archived_file>> to step through
	the contents of an archive opened for input.  You don't
	have to read the entire archive if you don't want
	to!  Read it until you find what you want.

	Archive contents of output BFDs are chained through the
	<<next>> pointer in a BFD.  The first one is findable through
	the <<archive_head>> slot of the archive.  Set it with
	<<bfd_set_archive_head>> (q.v.).  A given BFD may be in only one
	open output archive at a time.

	As expected, the BFD archive code is more general than the
	archive code of any given environment.  BFD archives may
	contain files of different formats (e.g., a.out and coff) and
	even different architectures.  You may even place archives
	recursively into archives!

	This can cause unexpected confusion, since some archive
	formats are more expressive than others.  For instance, Intel
	COFF archives can preserve long filenames; SunOS a.out archives
	cannot.  If you move a file from the first to the second
	format and back again, the filename may be truncated.
	Likewise, different a.out environments have different
	conventions as to how they truncate filenames, whether they
	preserve directory names in filenames, etc.  When
	interoperating with native tools, be sure your files are
	homogeneous.

	Beware: most of these formats do not react well to the
	presence of spaces in filenames.  We do the best we can, but
	can't always handle this case due to restrictions in the format of
	archives.  Many Unix utilities are braindead in regards to
	spaces and such in filenames anyway, so this shouldn't be much
	of a restriction.

	Archives are supported in BFD in <<archive.c>>.

*/

/* Assumes:
   o - all archive elements start on an even boundary, newline padded;
   o - all arch headers are char *;
   o - all arch headers are the same size (across architectures).
*/

/* Some formats provide a way to cram a long filename into the short
   (16 chars) space provided by a BSD archive.  The trick is: make a
   special "file" in the front of the archive, sort of like the SYMDEF
   entry.  If the filename is too long to fit, put it in the extended
   name table, and use its index as the filename.  To prevent
   confusion prepend the index with a space.  This means you can't
   have filenames that start with a space, but then again, many Unix
   utilities can't handle that anyway.

   This scheme unfortunately requires that you stand on your head in
   order to write an archive since you need to put a magic file at the
   front, and need to touch every entry to do so.  C'est la vie.

   We support two variants of this idea:
   The SVR4 format (extended name table is named "//"),
   and an extended pseudo-BSD variant (extended name table is named
   "ARFILENAMES/").  The origin of the latter format is uncertain.

   BSD 4.4 uses a third scheme:  It writes a long filename
   directly after the header.  This allows 'ar q' to work.
   We currently can read BSD 4.4 archives, but not write them.
*/

/* Summary of archive member names:

 Symbol table (must be first):
 "__.SYMDEF       " - Symbol table, Berkeley style, produced by ranlib.
 "/               " - Symbol table, system 5 style.

 Long name table (must be before regular file members):
 "//              " - Long name table, System 5 R4 style.
 "ARFILENAMES/    " - Long name table, non-standard extended BSD (not BSD 4.4).

 Regular file members with short names:
 "filename.o/     " - Regular file, System 5 style (embedded spaces ok).
 "filename.o      " - Regular file, Berkeley style (no embedded spaces).

 Regular files with long names (or embedded spaces, for BSD variants):
 "/18             " - SVR4 style, name at offset 18 in name table.
 "#1/23           " - Long name (or embedded paces) 23 characters long,
		      BSD 4.4 style, full name follows header.
		      Implemented for reading, not writing.
 " 18             " - Long name 18 characters long, extended pseudo-BSD.
 */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "aout/ar.h"
#include "aout/ranlib.h"
#include "safe-ctype.h"

#ifndef errno
extern int errno;
#endif

#ifdef GNU960
#define BFD_GNU960_ARMAG(abfd)	(BFD_COFF_FILE_P((abfd)) ? ARMAG : ARMAGB)
#endif

/* We keep a cache of archive filepointers to archive elements to
   speed up searching the archive by filepos.  We only add an entry to
   the cache when we actually read one.  We also don't sort the cache;
   it's generally short enough to search linearly.
   Note that the pointers here point to the front of the ar_hdr, not
   to the front of the contents!  */
struct ar_cache {
  file_ptr ptr;
  bfd *arelt;
  struct ar_cache *next;
};

#define ar_padchar(abfd) ((abfd)->xvec->ar_pad_char)
#define ar_maxnamelen(abfd) ((abfd)->xvec->ar_max_namelen)

#define arch_eltdata(bfd) ((struct areltdata *) ((bfd)->arelt_data))
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata(bfd)->arch_header)


bfd_boolean
_bfd_generic_mkarchive (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct artdata);

  abfd->tdata.aout_ar_data = bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == NULL)
    return FALSE;

  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
  bfd_ardata (abfd)->tdata = NULL;

  return TRUE;
}

/*
FUNCTION
	bfd_get_next_mapent

SYNOPSIS
	symindex bfd_get_next_mapent
	  (bfd *abfd, symindex previous, carsym **sym);

DESCRIPTION
	Step through archive @@var{abfd}'s symbol table (if it
	has one).  Successively update @@var{sym} with the next symbol's
	information, returning that symbol's (internal) index into the
	symbol table.

	Supply <<BFD_NO_MORE_SYMBOLS>> as the @@var{previous} entry to get
	the first one; returns <<BFD_NO_MORE_SYMBOLS>> when you've already
	got the last one.

	A <<carsym>> is a canonical archive symbol.  The only
	user-visible element is its name, a null-terminated string.
*/

symindex
bfd_get_next_mapent (bfd *abfd, symindex prev, carsym **entry)
{
  if (!bfd_has_map (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return BFD_NO_MORE_SYMBOLS;
    }

  if (prev == BFD_NO_MORE_SYMBOLS)
    prev = 0;
  else
    ++prev;
  if (prev >= bfd_ardata (abfd)->symdef_count)
    return BFD_NO_MORE_SYMBOLS;

  *entry = (bfd_ardata (abfd)->symdefs + prev);
  return prev;
}

/* To be called by backends only */

bfd *
_bfd_create_empty_archive_element_shell (bfd *obfd)
{
  return _bfd_new_bfd_contained_in (obfd);
}

/*
FUNCTION
	bfd_set_archive_head

SYNOPSIS
	bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

DESCRIPTION
	Set the head of the chain of
	BFDs contained in the archive @@var{output} to @@var{new_head}.
*/

bfd_boolean
bfd_set_archive_head (bfd *output_archive, bfd *new_head)
{
  output_archive->archive_head = new_head;
  return TRUE;
}

bfd *
_bfd_look_for_bfd_in_cache (bfd *arch_bfd, file_ptr filepos)
{
  struct ar_cache *current;

  for (current = bfd_ardata (arch_bfd)->cache; current != NULL;
       current = current->next)
    if (current->ptr == filepos)
      return current->arelt;

  return NULL;
}

/* Kind of stupid to call cons for each one, but we don't do too many */
bfd_boolean
_bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)
{
  bfd_size_type amt = sizeof (struct ar_cache);

  struct ar_cache *new_cache = bfd_zalloc (arch_bfd, amt);
  if (new_cache == NULL)
    return FALSE;

  new_cache->ptr = filepos;
  new_cache->arelt = new_elt;
  new_cache->next = NULL;
  if (bfd_ardata (arch_bfd)->cache == NULL)
    bfd_ardata (arch_bfd)->cache = new_cache;
  else
    {
      struct ar_cache *current = bfd_ardata (arch_bfd)->cache;

      while (current->next != NULL)
	current = current->next;
      current->next = new_cache;
    }

  return TRUE;
}

/* The name begins with space.  Hence the rest of the name is an index into
   the string table.  */

static char *
get_extended_arelt_filename (bfd *arch, const char *name)
{
  unsigned long index = 0;

  /* Should extract string so that I can guarantee not to overflow into
     the next region, but I'm too lazy.  */
  errno = 0;
  /* Skip first char, which is '/' in SVR4 or ' ' in some other variants.  */
  index = strtol (name + 1, NULL, 10);
  if (errno != 0)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  return bfd_ardata (arch)->extended_names + index;
}

/* This functions reads an arch header and returns an areltdata pointer, or
   NULL on error.

   Presumes the file pointer is already in the right place (ie pointing
   to the ar_hdr in the file).   Moves the file pointer; on success it
   should be pointing to the front of the file contents; on failure it
   could have been moved arbitrarily.
*/

void *
_bfd_generic_read_ar_hdr (bfd *abfd)
{
  return _bfd_generic_read_ar_hdr_mag (abfd, NULL);
}

/* Alpha ECOFF uses an optional different ARFMAG value, so we have a
   variant of _bfd_generic_read_ar_hdr which accepts a magic string.  */

void *
_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
{
  struct ar_hdr hdr;
  char *hdrp = (char *) &hdr;
  size_t parsed_size;
  struct areltdata *ared;
  char *filename = NULL;
  bfd_size_type namelen = 0;
  bfd_size_type allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);
  char *allocptr = 0;

  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_no_more_archived_files);
      return NULL;
    }
  if (strncmp (hdr.ar_fmag, ARFMAG, 2) != 0
      && (mag == NULL
	  || strncmp (hdr.ar_fmag, mag, 2) != 0))
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  errno = 0;
  parsed_size = strtol (hdr.ar_size, NULL, 10);
  if (errno != 0)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return NULL;
    }

  /* Extract the filename from the archive - there are two ways to
     specify an extended name table, either the first char of the
     name is a space, or it's a slash.  */
  if ((hdr.ar_name[0] == '/'
       || (hdr.ar_name[0] == ' '
	   && memchr (hdr.ar_name, '/', ar_maxnamelen (abfd)) == NULL))
      && bfd_ardata (abfd)->extended_names != NULL)
    {
      filename = get_extended_arelt_filename (abfd, hdr.ar_name);
      if (filename == NULL)
	{
	  bfd_set_error (bfd_error_malformed_archive);
	  return NULL;
	}
    }
  /* BSD4.4-style long filename.
     Only implemented for reading, so far!  */
  else if (hdr.ar_name[0] == '#'
	   && hdr.ar_name[1] == '1'
	   && hdr.ar_name[2] == '/'
	   && ISDIGIT (hdr.ar_name[3]))
    {
      /* BSD-4.4 extended name */
      namelen = atoi (&hdr.ar_name[3]);
      allocsize += namelen + 1;
      parsed_size -= namelen;

      allocptr = bfd_zalloc (abfd, allocsize);
      if (allocptr == NULL)
	return NULL;
      filename = (allocptr
		  + sizeof (struct areltdata)
		  + sizeof (struct ar_hdr));
      if (bfd_bread (filename, namelen, abfd) != namelen)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
      filename[namelen] = '\0';
    }
  else
    {
      /* We judge the end of the name by looking for '/' or ' '.
	 Note:  The SYSV format (terminated by '/') allows embedded
	 spaces, so only look for ' ' if we don't find '/'.  */

      char *e;
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
      if (e == NULL)
	{
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
	  if (e == NULL)
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
	}

      if (e != NULL)
	namelen = e - hdr.ar_name;
      else
	{
	  /* If we didn't find a termination character, then the name
	     must be the entire field.  */
	  namelen = ar_maxnamelen (abfd);
	}

      allocsize += namelen + 1;
    }

  if (!allocptr)
    {
      allocptr = bfd_zalloc (abfd, allocsize);
      if (allocptr == NULL)
	return NULL;
    }

  ared = (struct areltdata *) allocptr;

  ared->arch_header = allocptr + sizeof (struct areltdata);
  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));
  ared->parsed_size = parsed_size;

  if (filename != NULL)
    ared->filename = filename;
  else
    {
      ared->filename = allocptr + (sizeof (struct areltdata) +
				   sizeof (struct ar_hdr));
      if (namelen)
	memcpy (ared->filename, hdr.ar_name, namelen);
      ared->filename[namelen] = '\0';
    }

  return ared;
}

/* This is an internal function; it's mainly used when indexing
   through the archive symbol table, but also used to get the next
   element, since it handles the bookkeeping so nicely for us.  */

bfd *
_bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
{
  struct areltdata *new_areldata;
  bfd *n_nfd;

  n_nfd = _bfd_look_for_bfd_in_cache (archive, filepos);
  if (n_nfd)
    return n_nfd;

  if (0 > bfd_seek (archive, filepos, SEEK_SET))
    return NULL;

  if ((new_areldata = _bfd_read_ar_hdr (archive)) == NULL)
    return NULL;

  n_nfd = _bfd_create_empty_archive_element_shell (archive);
  if (n_nfd == NULL)
    {
      bfd_release (archive, new_areldata);
      return NULL;
    }

  n_nfd->origin = bfd_tell (archive);
  n_nfd->arelt_data = new_areldata;
  n_nfd->filename = new_areldata->filename;

  if (_bfd_add_bfd_to_archive_cache (archive, filepos, n_nfd))
    return n_nfd;

  /* Huh?  */
  bfd_release (archive, n_nfd);
  bfd_release (archive, new_areldata);
  return NULL;
}

/* Return the BFD which is referenced by the symbol in ABFD indexed by
   INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */

bfd *
_bfd_generic_get_elt_at_index (bfd *abfd, symindex index)
{
  carsym *entry;

  entry = bfd_ardata (abfd)->symdefs + index;
  return _bfd_get_elt_at_filepos (abfd, entry->file_offset);
}

/*
FUNCTION
	bfd_openr_next_archived_file

SYNOPSIS
	bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);

DESCRIPTION
	Provided a BFD, @@var{archive}, containing an archive and NULL, open
	an input BFD on the first contained element and returns that.
	Subsequent calls should pass
	the archive and the previous return value to return a created
	BFD to the next contained element. NULL is returned when there
	are no more.
*/

bfd *
bfd_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  if ((bfd_get_format (archive) != bfd_archive) ||
      (archive->direction == write_direction))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  return BFD_SEND (archive,
		   openr_next_archived_file, (archive, last_file));
}

bfd *
bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  file_ptr filestart;

  if (!last_file)
    filestart = bfd_ardata (archive)->first_file_filepos;
  else
    {
      unsigned int size = arelt_size (last_file);
      /* Pad to an even boundary...
	 Note that last_file->origin can be odd in the case of
	 BSD-4.4-style element with a long odd size.  */
      filestart = last_file->origin + size;
      filestart += filestart % 2;
    }

  return _bfd_get_elt_at_filepos (archive, filestart);
}

const bfd_target *
bfd_generic_archive_p (bfd *abfd)
{
  struct artdata *tdata_hold;
  char armag[SARMAG + 1];
  bfd_size_type amt;

  if (bfd_bread (armag, SARMAG, abfd) != SARMAG)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

#ifdef GNU960
  if (strncmp (armag, BFD_GNU960_ARMAG (abfd), SARMAG) != 0)
    return 0;
#else
  if (strncmp (armag, ARMAG, SARMAG) != 0 &&
      strncmp (armag, ARMAGB, SARMAG) != 0)
    return 0;
#endif

  tdata_hold = bfd_ardata (abfd);

  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == NULL)
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  bfd_ardata (abfd)->first_file_filepos = SARMAG;
  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
  bfd_ardata (abfd)->tdata = NULL;

  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd))
      || !BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      bfd_release (abfd, bfd_ardata (abfd));
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  if (bfd_has_map (abfd))
    {
      bfd *first;

      /* This archive has a map, so we may presume that the contents
	 are object files.  Make sure that if the first file in the
	 archive can be recognized as an object file, it is for this
	 target.  If not, assume that this is the wrong format.  If
	 the first file is not an object file, somebody is doing
	 something weird, and we permit it so that ar -t will work.

	 This is done because any normal format will recognize any
	 normal archive, regardless of the format of the object files.
	 We do accept an empty archive.  */

      first = bfd_openr_next_archived_file (abfd, NULL);
      if (first != NULL)
	{
	  bfd_boolean fail;

	  first->target_defaulted = FALSE;
	  fail = FALSE;
	  if (bfd_check_format (first, bfd_object)
	      && first->xvec != abfd->xvec)
	    {
#if 0
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's close to impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
	      bfd_close (first);
	      bfd_release (abfd, bfd_ardata (abfd));
#endif
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
	      return NULL;
	    }
	  /* And we ought to close `first' here too.  */
	}
    }

  return abfd->xvec;
}

/* Some constants for a 32 bit BSD archive structure.  We do not
   support 64 bit archives presently; so far as I know, none actually
   exist.  Supporting them would require changing these constants, and
   changing some H_GET_32 to H_GET_64.  */

/* The size of an external symdef structure.  */
#define BSD_SYMDEF_SIZE 8

/* The offset from the start of a symdef structure to the file offset.  */
#define BSD_SYMDEF_OFFSET_SIZE 4

/* The size of the symdef count.  */
#define BSD_SYMDEF_COUNT_SIZE 4

/* The size of the string count.  */
#define BSD_STRING_COUNT_SIZE 4

/* Returns FALSE on error, TRUE otherwise */

static bfd_boolean
do_slurp_bsd_armap (bfd *abfd)
{
  struct areltdata *mapdata;
  unsigned int counter;
  bfd_byte *raw_armap, *rbase;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  bfd_size_type parsed_size, amt;
  carsym *set;

  mapdata = _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;
  parsed_size = mapdata->parsed_size;
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */

  raw_armap = bfd_zalloc (abfd, parsed_size);
  if (raw_armap == NULL)
    return FALSE;

  if (bfd_bread (raw_armap, parsed_size, abfd) != parsed_size)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
    byebye:
      bfd_release (abfd, raw_armap);
      return FALSE;
    }

  ardata->symdef_count = H_GET_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;

  if (ardata->symdef_count * BSD_SYMDEF_SIZE >
      parsed_size - BSD_SYMDEF_COUNT_SIZE)
    {
      /* Probably we're using the wrong byte ordering.  */
      bfd_set_error (bfd_error_wrong_format);
      goto byebye;
    }

  ardata->cache = 0;
  rbase = raw_armap + BSD_SYMDEF_COUNT_SIZE;
  stringbase = ((char *) rbase
		+ ardata->symdef_count * BSD_SYMDEF_SIZE
		+ BSD_STRING_COUNT_SIZE);
  amt = ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  for (counter = 0, set = ardata->symdefs;
       counter < ardata->symdef_count;
       counter++, set++, rbase += BSD_SYMDEF_SIZE)
    {
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
    }

  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;
  /* FIXME, we should provide some way to free raw_ardata when
     we are done using the strings from it.  For now, it seems
     to be allocated on an objalloc anyway...  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/* Returns FALSE on error, TRUE otherwise.  */

static bfd_boolean
do_slurp_coff_armap (bfd *abfd)
{
  struct areltdata *mapdata;
  int *raw_armap, *rawptr;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  bfd_size_type stringsize;
  unsigned int parsed_size;
  carsym *carsyms;
  bfd_size_type nsymz;		/* Number of symbols in armap.  */
  bfd_vma (*swap) (const void *);
  char int_buf[sizeof (long)];
  bfd_size_type carsym_size, ptrsize;
  unsigned int i;

  mapdata = _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;
  parsed_size = mapdata->parsed_size;
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */

  if (bfd_bread (int_buf, 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }
  /* It seems that all numeric information in a coff archive is always
     in big endian format, nomatter the host or target.  */
  swap = bfd_getb32;
  nsymz = bfd_getb32 (int_buf);
  stringsize = parsed_size - (4 * nsymz) - 4;

#if 1
  /* ... except that some archive formats are broken, and it may be our
     fault - the i960 little endian coff sometimes has big and sometimes
     little, because our tools changed.  Here's a horrible hack to clean
     up the crap.  */

  if (stringsize > 0xfffff
      && bfd_get_arch (abfd) == bfd_arch_i960
      && bfd_get_flavour (abfd) == bfd_target_coff_flavour)
    {
      /* This looks dangerous, let's do it the other way around.  */
      nsymz = bfd_getl32 (int_buf);
      stringsize = parsed_size - (4 * nsymz) - 4;
      swap = bfd_getl32;
    }
#endif

  /* The coff armap must be read sequentially.  So we construct a
     bsd-style one in core all at once, for simplicity.  */

  carsym_size = (nsymz * sizeof (carsym));
  ptrsize = (4 * nsymz);

  ardata->symdefs = bfd_zalloc (abfd, carsym_size + stringsize + 1);
  if (ardata->symdefs == NULL)
    return FALSE;
  carsyms = ardata->symdefs;
  stringbase = ((char *) ardata->symdefs) + carsym_size;

  /* Allocate and read in the raw offsets.  */
  raw_armap = bfd_alloc (abfd, ptrsize);
  if (raw_armap == NULL)
    goto release_symdefs;
  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto release_raw_armap;
    }

  /* OK, build the carsyms.  */
  for (i = 0; i < nsymz; i++)
    {
      rawptr = raw_armap + i;
      carsyms->file_offset = swap ((bfd_byte *) rawptr);
      carsyms->name = stringbase;
      stringbase += strlen (stringbase) + 1;
      carsyms++;
    }
  *stringbase = 0;

  ardata->symdef_count = nsymz;
  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;

  bfd_has_map (abfd) = TRUE;
  bfd_release (abfd, raw_armap);

  /* Check for a second archive header (as used by PE).  */
  {
    struct areltdata *tmp;

    bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET);
    tmp = _bfd_read_ar_hdr (abfd);
    if (tmp != NULL)
      {
	if (tmp->arch_header[0] == '/'
	    && tmp->arch_header[1] == ' ')
	  {
	    ardata->first_file_filepos +=
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~(unsigned) 1;
	  }
	bfd_release (abfd, tmp);
      }
  }

  return TRUE;

release_raw_armap:
  bfd_release (abfd, raw_armap);
release_symdefs:
  bfd_release (abfd, (ardata)->symdefs);
  return FALSE;
}

/* This routine can handle either coff-style or bsd-style armaps.
   Returns FALSE on error, TRUE otherwise */

bfd_boolean
bfd_slurp_armap (bfd *abfd)
{
  char nextname[17];
  int i = bfd_bread (nextname, 16, abfd);

  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  if (!strncmp (nextname, "__.SYMDEF       ", 16)
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* old Linux archives */
    return do_slurp_bsd_armap (abfd);
  else if (!strncmp (nextname, "/               ", 16))
    return do_slurp_coff_armap (abfd);
  else if (!strncmp (nextname, "/SYM64/         ", 16))
    {
      /* 64bit ELF (Irix 6) archive.  */
#ifdef BFD64
      extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
      return bfd_elf64_archive_slurp_armap (abfd);
#else
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
#endif
    }

  bfd_has_map (abfd) = FALSE;
  return TRUE;
}

/* Returns FALSE on error, TRUE otherwise */
/* flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
   header is in a slightly different order and the map name is '/'.
   This flavour is used by hp300hpux.  */

#define HPUX_SYMDEF_COUNT_SIZE 2

bfd_boolean
bfd_slurp_bsd_armap_f2 (bfd *abfd)
{
  struct areltdata *mapdata;
  char nextname[17];
  unsigned int counter;
  bfd_byte *raw_armap, *rbase;
  struct artdata *ardata = bfd_ardata (abfd);
  char *stringbase;
  unsigned int stringsize;
  bfd_size_type amt;
  carsym *set;
  int i = bfd_bread (nextname, 16, abfd);

  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  /* The archive has at least 16 bytes in it.  */
  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  if (!strncmp (nextname, "__.SYMDEF       ", 16)
      || !strncmp (nextname, "__.SYMDEF/      ", 16)) /* old Linux archives */
    return do_slurp_bsd_armap (abfd);

  if (strncmp (nextname, "/               ", 16))
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  mapdata = _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;

  amt = mapdata->parsed_size;
  raw_armap = bfd_zalloc (abfd, amt);
  if (raw_armap == NULL)
    {
    byebye:
      bfd_release (abfd, mapdata);
      return FALSE;
    }

  if (bfd_bread (raw_armap, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
    byebyebye:
      bfd_release (abfd, raw_armap);
      goto byebye;
    }

  ardata->symdef_count = H_GET_16 (abfd, raw_armap);

  if (ardata->symdef_count * BSD_SYMDEF_SIZE
      > mapdata->parsed_size - HPUX_SYMDEF_COUNT_SIZE)
    {
      /* Probably we're using the wrong byte ordering.  */
      bfd_set_error (bfd_error_wrong_format);
      goto byebyebye;
    }

  ardata->cache = 0;

  stringsize = H_GET_32 (abfd, raw_armap + HPUX_SYMDEF_COUNT_SIZE);
  /* Skip sym count and string sz.  */
  stringbase = ((char *) raw_armap
		+ HPUX_SYMDEF_COUNT_SIZE
		+ BSD_STRING_COUNT_SIZE);
  rbase = (bfd_byte *) stringbase + stringsize;
  amt = ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  for (counter = 0, set = ardata->symdefs;
       counter < ardata->symdef_count;
       counter++, set++, rbase += BSD_SYMDEF_SIZE)
    {
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
    }

  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary if you have to.  */
  ardata->first_file_filepos += (ardata->first_file_filepos) % 2;
  /* FIXME, we should provide some way to free raw_ardata when
     we are done using the strings from it.  For now, it seems
     to be allocated on an objalloc anyway...  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/** Extended name table.

  Normally archives support only 14-character filenames.

  Intel has extended the format: longer names are stored in a special
  element (the first in the archive, or second if there is an armap);
  the name in the ar_hdr is replaced by <space><index into filename
  element>.  Index is the P.R. of an int (decimal).  Data General have
  extended the format by using the prefix // for the special element.  */

/* Returns FALSE on error, TRUE otherwise.  */

bfd_boolean
_bfd_slurp_extended_name_table (bfd *abfd)
{
  char nextname[17];
  struct areltdata *namedata;
  bfd_size_type amt;

  /* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,
     we probably don't want to return TRUE.  */
  bfd_seek (abfd, bfd_ardata (abfd)->first_file_filepos, SEEK_SET);
  if (bfd_bread (nextname, 16, abfd) == 16)
    {
      if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
	return FALSE;

      if (strncmp (nextname, "ARFILENAMES/    ", 16) != 0 &&
	  strncmp (nextname, "//              ", 16) != 0)
	{
	  bfd_ardata (abfd)->extended_names = NULL;
	  return TRUE;
	}

      namedata = _bfd_read_ar_hdr (abfd);
      if (namedata == NULL)
	return FALSE;

      amt = namedata->parsed_size;
      bfd_ardata (abfd)->extended_names = bfd_zalloc (abfd, amt);
      if (bfd_ardata (abfd)->extended_names == NULL)
	{
	byebye:
	  bfd_release (abfd, namedata);
	  return FALSE;
	}

      if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_malformed_archive);
	  bfd_release (abfd, (bfd_ardata (abfd)->extended_names));
	  bfd_ardata (abfd)->extended_names = NULL;
	  goto byebye;
	}

      /* Since the archive is supposed to be printable if it contains
	 text, the entries in the list are newline-padded, not null
	 padded. In SVR4-style archives, the names also have a
	 trailing '/'.  DOS/NT created archive often have \ in them
	 We'll fix all problems here..  */
      {
	char *temp = bfd_ardata (abfd)->extended_names;
	char *limit = temp + namedata->parsed_size;
	for (; temp < limit; ++temp)
	  {
	    if (*temp == '\012')
	      temp[temp[-1] == '/' ? -1 : 0] = '\0';
	    if (*temp == '\\')
	      *temp = '/';
	  }
      }

      /* Pad to an even boundary if you have to.  */
      bfd_ardata (abfd)->first_file_filepos = bfd_tell (abfd);
      bfd_ardata (abfd)->first_file_filepos +=
	(bfd_ardata (abfd)->first_file_filepos) % 2;

      /* FIXME, we can't release namedata here because it was allocated
	 below extended_names on the objalloc...  */
#if 0
      bfd_release (abfd, namedata);
#endif
    }
  return TRUE;
}

#ifdef VMS

/* Return a copy of the stuff in the filename between any :]> and a
   semicolon.  */

static const char *
normalize (bfd *abfd, const char *file)
{
  const char *first;
  const char *last;
  char *copy;

  first = file + strlen (file) - 1;
  last = first + 1;

  while (first != file)
    {
      if (*first == ';')
	last = first;
      if (*first == ':' || *first == ']' || *first == '>')
	{
	  first++;
	  break;
	}
      first--;
    }

  copy = bfd_alloc (abfd, last - first + 1);
  if (copy == NULL)
    return NULL;

  memcpy (copy, first, last - first);
  copy[last - first] = 0;

  return copy;
}

#else
static const char *
normalize (bfd *abfd ATTRIBUTE_UNUSED, const char *file)
{
  const char *filename = strrchr (file, '/');

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
  if (filename != NULL)
    filename++;
  else
    filename = file;
  return filename;
}
#endif

/* Build a BFD style extended name table.  */

bfd_boolean
_bfd_archive_bsd_construct_extended_name_table (bfd *abfd,
						char **tabloc,
						bfd_size_type *tablen,
						const char **name)
{
  *name = "ARFILENAMES/";
  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);
}

/* Build an SVR4 style extended name table.  */

bfd_boolean
_bfd_archive_coff_construct_extended_name_table (bfd *abfd,
						 char **tabloc,
						 bfd_size_type *tablen,
						 const char **name)
{
  *name = "//";
  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);
}

/* Follows archive_head and produces an extended name table if
   necessary.  Returns (in tabloc) a pointer to an extended name
   table, and in tablen the length of the table.  If it makes an entry
   it clobbers the filename so that the element may be written without
   further massage.  Returns TRUE if it ran successfully, FALSE if
   something went wrong.  A successful return may still involve a
   zero-length tablen!  */

bfd_boolean
_bfd_construct_extended_name_table (bfd *abfd,
				    bfd_boolean trailing_slash,
				    char **tabloc,
				    bfd_size_type *tablen)
{
  unsigned int maxname = abfd->xvec->ar_max_namelen;
  bfd_size_type total_namelen = 0;
  bfd *current;
  char *strptr;

  *tablen = 0;

  /* Figure out how long the table should be.  */
  for (current = abfd->archive_head; current != NULL; current = current->next)
    {
      const char *normal;
      unsigned int thislen;

      normal = normalize (current, current->filename);
      if (normal == NULL)
	return FALSE;

      thislen = strlen (normal);

      if (thislen > maxname
	  && (bfd_get_file_flags (abfd) & BFD_TRADITIONAL_FORMAT) != 0)
	thislen = maxname;

      if (thislen > maxname)
	{
	  /* Add one to leave room for \n.  */
	  total_namelen += thislen + 1;
	  if (trailing_slash)
	    {
	      /* Leave room for trailing slash.  */
	      ++total_namelen;
	    }
	}
      else
	{
	  struct ar_hdr *hdr = arch_hdr (current);
	  if (strncmp (normal, hdr->ar_name, thislen) != 0
	      || (thislen < sizeof hdr->ar_name
		  && hdr->ar_name[thislen] != ar_padchar (current)))
	    {
	      /* Must have been using extended format even though it
	         didn't need to.  Fix it to use normal format.  */
	      memcpy (hdr->ar_name, normal, thislen);
	      if (thislen < maxname
		  || (thislen == maxname && thislen < sizeof hdr->ar_name))
		hdr->ar_name[thislen] = ar_padchar (current);
	    }
	}
    }

  if (total_namelen == 0)
    return TRUE;

  *tabloc = bfd_zalloc (abfd, total_namelen);
  if (*tabloc == NULL)
    return FALSE;

  *tablen = total_namelen;
  strptr = *tabloc;

  for (current = abfd->archive_head; current != NULL; current =
       current->next)
    {
      const char *normal;
      unsigned int thislen;

      normal = normalize (current, current->filename);
      if (normal == NULL)
	return FALSE;

      thislen = strlen (normal);
      if (thislen > maxname)
	{
	  /* Works for now; may need to be re-engineered if we
	     encounter an oddball archive format and want to
	     generalise this hack.  */
	  struct ar_hdr *hdr = arch_hdr (current);
	  strcpy (strptr, normal);
	  if (! trailing_slash)
	    strptr[thislen] = '\012';
	  else
	    {
	      strptr[thislen] = '/';
	      strptr[thislen + 1] = '\012';
	    }
	  hdr->ar_name[0] = ar_padchar (current);
	  /* We know there will always be enough room (one of the few
	     cases where you may safely use sprintf).  */
	  sprintf ((hdr->ar_name) + 1, "%-d", (unsigned) (strptr - *tabloc));
	  /* Kinda Kludgy.  We should just use the returned value of
	     sprintf but not all implementations get this right.  */
	  {
	    char *temp = hdr->ar_name + 2;
	    for (; temp < hdr->ar_name + maxname; temp++)
	      if (*temp == '\0')
		*temp = ' ';
	  }
	  strptr += thislen + 1;
	  if (trailing_slash)
	    ++strptr;
	}
    }

  return TRUE;
}

/** A couple of functions for creating ar_hdrs */

#ifdef HPUX_LARGE_AR_IDS
/* Function to encode large UID/GID values according to HP.  */

static void
hpux_uid_gid_encode (char str[6], long int id)
{
  int cnt;

  str[5] = '@@' + (id & 3);
  id >>= 2;

  for (cnt = 4; cnt >= 0; ++cnt, id >>= 6)
    str[cnt] = ' ' + (id & 0x3f);
}
#endif	/* HPUX_LARGE_AR_IDS */

#ifndef HAVE_GETUID
#define getuid() 0
#endif

#ifndef HAVE_GETGID
#define getgid() 0
#endif

/* Takes a filename, returns an arelt_data for it, or NULL if it can't
   make one.  The filename must refer to a filename in the filesystem.
   The filename field of the ar_hdr will NOT be initialized.  If member
   is set, and it's an in-memory bfd, we fake it.  */

static struct areltdata *
bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
{
  struct stat status;
  struct areltdata *ared;
  struct ar_hdr *hdr;
  char *temp, *temp1;
  bfd_size_type amt;

  if (member && (member->flags & BFD_IN_MEMORY) != 0)
    {
      /* Assume we just "made" the member, and fake it.  */
      struct bfd_in_memory *bim = member->iostream;
      time (&status.st_mtime);
      status.st_uid = getuid ();
      status.st_gid = getgid ();
      status.st_mode = 0644;
      status.st_size = bim->size;
    }
  else if (stat (filename, &status) != 0)
    {
      bfd_set_error (bfd_error_system_call);
      return NULL;
    }

  amt = sizeof (struct ar_hdr) + sizeof (struct areltdata);
  ared = bfd_zalloc (abfd, amt);
  if (ared == NULL)
    return NULL;
  hdr = (struct ar_hdr *) (((char *) ared) + sizeof (struct areltdata));

  /* ar headers are space padded, not null padded!  */
  memset (hdr, ' ', sizeof (struct ar_hdr));

  strncpy (hdr->ar_fmag, ARFMAG, 2);

  /* Goddamned sprintf doesn't permit MAXIMUM field lengths.  */
  sprintf ((hdr->ar_date), "%-12lld", (long long) status.st_mtime);
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_uid > 99999)
    hpux_uid_gid_encode (hdr->ar_gid, (long) status.st_uid);
  else
#endif
    sprintf ((hdr->ar_uid), "%ld", (long) status.st_uid);
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_gid > 99999)
    hpux_uid_gid_encode (hdr->ar_uid, (long) status.st_gid);
  else
#endif
  sprintf ((hdr->ar_gid), "%ld", (long) status.st_gid);
  sprintf ((hdr->ar_mode), "%-8o", (unsigned int) status.st_mode);
  sprintf ((hdr->ar_size), "%-10ld", (long) status.st_size);
  /* Correct for a lossage in sprintf whereby it null-terminates.  I cannot
     understand how these C losers could design such a ramshackle bunch of
     IO operations.  */
  temp = (char *) hdr;
  temp1 = temp + sizeof (struct ar_hdr) - 2;
  for (; temp < temp1; temp++)
    {
      if (*temp == '\0')
	*temp = ' ';
    }
  strncpy (hdr->ar_fmag, ARFMAG, 2);
  ared->parsed_size = status.st_size;
  ared->arch_header = (char *) hdr;

  return ared;
}

/* This is magic required by the "ar" program.  Since it's
   undocumented, it's undocumented.  You may think that it would take
   a strong stomach to write this, and it does, but it takes even a
   stronger stomach to try to code around such a thing!  */

struct ar_hdr *bfd_special_undocumented_glue (bfd *, const char *);

struct ar_hdr *
bfd_special_undocumented_glue (bfd *abfd, const char *filename)
{
  struct areltdata *ar_elt = bfd_ar_hdr_from_filesystem (abfd, filename, 0);
  if (ar_elt == NULL)
    return NULL;
  return (struct ar_hdr *) ar_elt->arch_header;
}

/* Analogous to stat call.  */

int
bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
{
  struct ar_hdr *hdr;
  char *aloser;

  if (abfd->arelt_data == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  hdr = arch_hdr (abfd);

#define foo(arelt, stelt, size)				\
  buf->stelt = strtol (hdr->arelt, &aloser, size);	\
  if (aloser == hdr->arelt)	      			\
    return -1;

#define fooll(arelt, stelt, size)			\
  buf->stelt = strtoll (hdr->arelt, &aloser, size);	\
  if (aloser == hdr->arelt)	      			\
    return -1;

  /* Some platforms support special notations for large IDs.  */
#ifdef HPUX_LARGE_AR_IDS
# define foo2(arelt, stelt, size)					\
  if (hdr->arelt[5] == ' ')						\
    {									\
      foo (arelt, stelt, size);						\
    }									\
  else									\
    {									\
      int cnt;								\
      for (buf->stelt = cnt = 0; cnt < 5; ++cnt)			\
	{								\
	  if (hdr->arelt[cnt] < ' ' || hdr->arelt[cnt] > ' ' + 0x3f)	\
	    return -1;							\
	  buf->stelt <<= 6;						\
	  buf->stelt += hdr->arelt[cnt] - ' ';				\
	}								\
      if (hdr->arelt[5] < '@@' || hdr->arelt[5] > '@@' + 3)		\
	return -1;							\
      buf->stelt <<= 2;							\
      buf->stelt += hdr->arelt[5] - '@@';				\
    }
#else
# define foo2(arelt, stelt, size) foo (arelt, stelt, size)
#endif

  fooll (ar_date, st_mtime, 10);
  foo2 (ar_uid, st_uid, 10);
  foo2 (ar_gid, st_gid, 10);
  foo (ar_mode, st_mode, 8);

  buf->st_size = arch_eltdata (abfd)->parsed_size;

  return 0;
}

void
bfd_dont_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  /* FIXME: This interacts unpleasantly with ar's quick-append option.
     Fortunately ic960 users will never use that option.  Fixing this
     is very hard; fortunately I know how to do it and will do so once
     intel's release is out the door.  */

  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename;
  size_t maxlen = ar_maxnamelen (abfd);

  if ((bfd_get_file_flags (abfd) & BFD_TRADITIONAL_FORMAT) != 0)
    {
      bfd_bsd_truncate_arname (abfd, pathname, arhdr);
      return;
    }

  filename = normalize (abfd, pathname);
  if (filename == NULL)
    {
      /* FIXME */
      abort ();
    }

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);

  /* Add the padding character if there is room for it.  */
  if (length < maxlen
      || (length == maxlen && length < sizeof hdr->ar_name))
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

void
bfd_bsd_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename = strrchr (pathname, '/');
  size_t maxlen = ar_maxnamelen (abfd);

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

  if (filename == NULL)
    filename = pathname;
  else
    ++filename;

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);
  else
    {
      /* pathname: meet procrustes */
      memcpy (hdr->ar_name, filename, maxlen);
      length = maxlen;
    }

  if (length < maxlen)
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

/* Store name into ar header.  Truncates the name to fit.
   1> strip pathname to be just the basename.
   2> if it's short enuf to fit, stuff it in.
   3> If it doesn't end with .o, truncate it to fit
   4> truncate it before the .o, append .o, stuff THAT in.  */

/* This is what gnu ar does.  It's better but incompatible with the
   bsd ar.  */

void
bfd_gnu_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
{
  struct ar_hdr *hdr = (struct ar_hdr *) arhdr;
  size_t length;
  const char *filename = strrchr (pathname, '/');
  size_t maxlen = ar_maxnamelen (abfd);

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

  if (filename == NULL)
    filename = pathname;
  else
    ++filename;

  length = strlen (filename);

  if (length <= maxlen)
    memcpy (hdr->ar_name, filename, length);
  else
    {				/* pathname: meet procrustes */
      memcpy (hdr->ar_name, filename, maxlen);
      if ((filename[length - 2] == '.') && (filename[length - 1] == 'o'))
	{
	  hdr->ar_name[maxlen - 2] = '.';
	  hdr->ar_name[maxlen - 1] = 'o';
	}
      length = maxlen;
    }

  if (length < 16)
    (hdr->ar_name)[length] = ar_padchar (abfd);
}

/* The BFD is open for write and has its format set to bfd_archive.  */

bfd_boolean
_bfd_write_archive_contents (bfd *arch)
{
  bfd *current;
  char *etable = NULL;
  bfd_size_type elength = 0;
  const char *ename = NULL;
  bfd_boolean makemap = bfd_has_map (arch);
  /* If no .o's, don't bother to make a map.  */
  bfd_boolean hasobjects = FALSE;
  bfd_size_type wrote;
  unsigned int i;
  int tries;

  /* Verify the viability of all entries; if any of them live in the
     filesystem (as opposed to living in an archive open for input)
     then construct a fresh ar_hdr for them.  */
  for (current = arch->archive_head; current; current = current->next)
    {
      /* This check is checking the bfds for the objects we're reading
	 from (which are usually either an object file or archive on
	 disk), not the archive entries we're writing to.  We don't
	 actually create bfds for the archive members, we just copy
	 them byte-wise when we write out the archive.  */
      if (bfd_write_p (current))
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  return FALSE;
	}
      if (!current->arelt_data)
	{
	  current->arelt_data =
	    bfd_ar_hdr_from_filesystem (arch, current->filename, current);
	  if (!current->arelt_data)
	    return FALSE;

	  /* Put in the file name.  */
	  BFD_SEND (arch, _bfd_truncate_arname,
		    (arch, current->filename, (char *) arch_hdr (current)));
	}

      if (makemap && ! hasobjects)
	{			/* Don't bother if we won't make a map!  */
	  if ((bfd_check_format (current, bfd_object))
#if 0				/* FIXME -- these are not set correctly */
	      && ((bfd_get_file_flags (current) & HAS_SYMS))
#endif
	    )
	    hasobjects = TRUE;
	}
    }

  if (!BFD_SEND (arch, _bfd_construct_extended_name_table,
		 (arch, &etable, &elength, &ename)))
    return FALSE;

  if (bfd_seek (arch, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
#ifdef GNU960
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), SARMAG, arch);
#else
  wrote = bfd_bwrite (ARMAG, SARMAG, arch);
#endif
  if (wrote != SARMAG)
    return FALSE;

  if (makemap && hasobjects)
    {
      if (! _bfd_compute_and_write_armap (arch, (unsigned int) elength))
	return FALSE;
    }

  if (elength != 0)
    {
      struct ar_hdr hdr;

      memset (&hdr, 0, sizeof (struct ar_hdr));
      strcpy (hdr.ar_name, ename);
      /* Round size up to even number in archive header.  */
      sprintf (&(hdr.ar_size[0]), "%-10d",
	       (int) ((elength + 1) & ~(bfd_size_type) 1));
      strncpy (hdr.ar_fmag, ARFMAG, 2);
      for (i = 0; i < sizeof (struct ar_hdr); i++)
	if (((char *) (&hdr))[i] == '\0')
	  (((char *) (&hdr))[i]) = ' ';
      if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
	   != sizeof (struct ar_hdr))
	  || bfd_bwrite (etable, elength, arch) != elength)
	return FALSE;
      if ((elength % 2) == 1)
	{
	  if (bfd_bwrite ("\012", 1, arch) != 1)
	    return FALSE;
	}
    }

  for (current = arch->archive_head; current; current = current->next)
    {
      char buffer[DEFAULT_BUFFERSIZE];
      unsigned int remaining = arelt_size (current);
      struct ar_hdr *hdr = arch_hdr (current);

      /* Write ar header.  */
      if (bfd_bwrite (hdr, sizeof (*hdr), arch)
	  != sizeof (*hdr))
	return FALSE;
      if (bfd_seek (current, (file_ptr) 0, SEEK_SET) != 0)
	return FALSE;
      while (remaining)
	{
	  unsigned int amt = DEFAULT_BUFFERSIZE;
	  if (amt > remaining)
	    amt = remaining;
	  errno = 0;
	  if (bfd_bread (buffer, amt, current) != amt)
	    {
	      if (bfd_get_error () != bfd_error_system_call)
		bfd_set_error (bfd_error_malformed_archive);
	      return FALSE;
	    }
	  if (bfd_bwrite (buffer, amt, arch) != amt)
	    return FALSE;
	  remaining -= amt;
	}
      if ((arelt_size (current) % 2) == 1)
	{
	  if (bfd_bwrite ("\012", 1, arch) != 1)
	    return FALSE;
	}
    }

  if (makemap && hasobjects)
    {
      /* Verify the timestamp in the archive file.  If it would not be
	 accepted by the linker, rewrite it until it would be.  If
	 anything odd happens, break out and just return.  (The
	 Berkeley linker checks the timestamp and refuses to read the
	 table-of-contents if it is >60 seconds less than the file's
	 modified-time.  That painful hack requires this painful hack.  */
      tries = 1;
      do
	{
	  if (bfd_update_armap_timestamp (arch))
	    break;
	  (*_bfd_error_handler)
	    (_("Warning: writing archive was slow: rewriting timestamp\n"));
	}
      while (++tries < 6);
    }

  return TRUE;
}

/* Note that the namidx for the first symbol is 0.  */

bfd_boolean
_bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
{
  char *first_name = NULL;
  bfd *current;
  file_ptr elt_no = 0;
  struct orl *map = NULL;
  unsigned int orl_max = 1024;		/* fine initial default */
  unsigned int orl_count = 0;
  int stridx = 0;		/* string index */
  asymbol **syms = NULL;
  long syms_max = 0;
  bfd_boolean ret;
  bfd_size_type amt;

  /* Dunno if this is the best place for this info...  */
  if (elength != 0)
    elength += sizeof (struct ar_hdr);
  elength += elength % 2;

  amt = orl_max * sizeof (struct orl);
  map = bfd_malloc (amt);
  if (map == NULL)
    goto error_return;

  /* We put the symbol names on the arch objalloc, and then discard
     them when done.  */
  first_name = bfd_alloc (arch, 1);
  if (first_name == NULL)
    goto error_return;

  /* Drop all the files called __.SYMDEF, we're going to make our own.  */
  while (arch->archive_head &&
	 strcmp (arch->archive_head->filename, "__.SYMDEF") == 0)
    arch->archive_head = arch->archive_head->next;

  /* Map over each element.  */
  for (current = arch->archive_head;
       current != NULL;
       current = current->next, elt_no++)
    {
      if (bfd_check_format (current, bfd_object)
	  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)
	{
	  long storage;
	  long symcount;
	  long src_count;

	  storage = bfd_get_symtab_upper_bound (current);
	  if (storage < 0)
	    goto error_return;

	  if (storage != 0)
	    {
	      if (storage > syms_max)
		{
		  if (syms_max > 0)
		    free (syms);
		  syms_max = storage;
		  syms = bfd_malloc (syms_max);
		  if (syms == NULL)
		    goto error_return;
		}
	      symcount = bfd_canonicalize_symtab (current, syms);
	      if (symcount < 0)
		goto error_return;

	      /* Now map over all the symbols, picking out the ones we
                 want.  */
	      for (src_count = 0; src_count < symcount; src_count++)
		{
		  flagword flags = (syms[src_count])->flags;
		  asection *sec = syms[src_count]->section;

		  if ((flags & BSF_GLOBAL ||
		       flags & BSF_WEAK ||
		       flags & BSF_INDIRECT ||
		       bfd_is_com_section (sec))
		      && ! bfd_is_und_section (sec))
		    {
		      bfd_size_type namelen;
		      struct orl *new_map;

		      /* This symbol will go into the archive header.  */
		      if (orl_count == orl_max)
			{
			  orl_max *= 2;
			  amt = orl_max * sizeof (struct orl);
			  new_map = bfd_realloc (map, amt);
			  if (new_map == NULL)
			    goto error_return;

			  map = new_map;
			}

		      namelen = strlen (syms[src_count]->name);
		      amt = sizeof (char *);
		      map[orl_count].name = bfd_alloc (arch, amt);
		      if (map[orl_count].name == NULL)
			goto error_return;
		      *(map[orl_count].name) = bfd_alloc (arch, namelen + 1);
		      if (*(map[orl_count].name) == NULL)
			goto error_return;
		      strcpy (*(map[orl_count].name), syms[src_count]->name);
		      map[orl_count].u.abfd = current;
		      map[orl_count].namidx = stridx;

		      stridx += namelen + 1;
		      ++orl_count;
		    }
		}
	    }

	  /* Now ask the BFD to free up any cached information, so we
	     don't fill all of memory with symbol tables.  */
	  if (! bfd_free_cached_info (current))
	    goto error_return;
	}
    }

  /* OK, now we have collected all the data, let's write them out.  */
  ret = BFD_SEND (arch, write_armap,
		  (arch, elength, map, orl_count, stridx));

  if (syms_max > 0)
    free (syms);
  if (map != NULL)
    free (map);
  if (first_name != NULL)
    bfd_release (arch, first_name);

  return ret;

 error_return:
  if (syms_max > 0)
    free (syms);
  if (map != NULL)
    free (map);
  if (first_name != NULL)
    bfd_release (arch, first_name);

  return FALSE;
}

bfd_boolean
bsd_write_armap (bfd *arch,
		 unsigned int elength,
		 struct orl *map,
		 unsigned int orl_count,
		 int stridx)
{
  int padit = stridx & 1;
  unsigned int ranlibsize = orl_count * BSD_SYMDEF_SIZE;
  unsigned int stringsize = stridx + padit;
  /* Include 8 bytes to store ranlibsize and stringsize in output.  */
  unsigned int mapsize = ranlibsize + stringsize + 8;
  file_ptr firstreal;
  bfd *current = arch->archive_head;
  bfd *last_elt = current;	/* last element arch seen */
  bfd_byte temp[4];
  unsigned int count;
  struct ar_hdr hdr;
  struct stat statbuf;
  unsigned int i;

  firstreal = mapsize + elength + sizeof (struct ar_hdr) + SARMAG;

  stat (arch->filename, &statbuf);
  memset (&hdr, 0, sizeof (struct ar_hdr));
  sprintf (hdr.ar_name, RANLIBMAG);
  /* Remember the timestamp, to keep it holy.  But fudge it a little.  */
  bfd_ardata (arch)->armap_timestamp = statbuf.st_mtime + ARMAP_TIME_OFFSET;
  bfd_ardata (arch)->armap_datepos = (SARMAG
				      + offsetof (struct ar_hdr, ar_date[0]));
  sprintf (hdr.ar_date, "%lld", (long long)bfd_ardata (arch)->armap_timestamp);
  sprintf (hdr.ar_uid, "%ld", (long) getuid ());
  sprintf (hdr.ar_gid, "%ld", (long) getgid ());
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  strncpy (hdr.ar_fmag, ARFMAG, 2);
  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return FALSE;
  H_PUT_32 (arch, ranlibsize, temp);
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;

  for (count = 0; count < orl_count; count++)
    {
      bfd_byte buf[BSD_SYMDEF_SIZE];

      if (map[count].u.abfd != last_elt)
	{
	  do
	    {
	      firstreal += arelt_size (current) + sizeof (struct ar_hdr);
	      firstreal += firstreal % 2;
	      current = current->next;
	    }
	  while (current != map[count].u.abfd);
	}			/* if new archive element */

      last_elt = current;
      H_PUT_32 (arch, map[count].namidx, buf);
      H_PUT_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);
      if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)
	  != BSD_SYMDEF_SIZE)
	return FALSE;
    }

  /* Now write the strings themselves.  */
  H_PUT_32 (arch, stringsize, temp);
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
    return FALSE;
  for (count = 0; count < orl_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
    }

  /* The spec sez this should be a newline.  But in order to be
     bug-compatible for sun's ar we use a null.  */
  if (padit)
    {
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
    }

  return TRUE;
}

/* At the end of archive file handling, update the timestamp in the
   file, so the linker will accept it.

   Return TRUE if the timestamp was OK, or an unusual problem happened.
   Return FALSE if we updated the timestamp.  */

bfd_boolean
_bfd_archive_bsd_update_armap_timestamp (bfd *arch)
{
  struct stat archstat;
  struct ar_hdr hdr;
  unsigned int i;

  /* Flush writes, get last-write timestamp from file, and compare it
     to the timestamp IN the file.  */
  bfd_flush (arch);
  if (bfd_stat (arch, &archstat) == -1)
    {
      bfd_perror (_("Reading archive file mod timestamp"));

      /* Can't read mod time for some reason.  */
      return TRUE;
    }
  if (archstat.st_mtime <= bfd_ardata (arch)->armap_timestamp)
    /* OK by the linker's rules.  */
    return TRUE;

  /* Update the timestamp.  */
  bfd_ardata (arch)->armap_timestamp = archstat.st_mtime + ARMAP_TIME_OFFSET;

  /* Prepare an ASCII version suitable for writing.  */
  memset (hdr.ar_date, 0, sizeof (hdr.ar_date));
  sprintf (hdr.ar_date, "%lld", (long long)bfd_ardata (arch)->armap_timestamp);
  for (i = 0; i < sizeof (hdr.ar_date); i++)
    if (hdr.ar_date[i] == '\0')
      (hdr.ar_date)[i] = ' ';

  /* Write it into the file.  */
  bfd_ardata (arch)->armap_datepos = (SARMAG
				      + offsetof (struct ar_hdr, ar_date[0]));
  if (bfd_seek (arch, bfd_ardata (arch)->armap_datepos, SEEK_SET) != 0
      || (bfd_bwrite (hdr.ar_date, sizeof (hdr.ar_date), arch)
	  != sizeof (hdr.ar_date)))
    {
      bfd_perror (_("Writing updated armap timestamp"));

      /* Some error while writing.  */
      return TRUE;
    }

  /* We updated the timestamp successfully.  */
  return FALSE;
}

/* A coff armap looks like :
   lARMAG
   struct ar_hdr with name = '/'
   number of symbols
   offset of file for symbol 0
   offset of file for symbol 1

   offset of file for symbol n-1
   symbol name 0
   symbol name 1

   symbol name n-1
*/

bfd_boolean
coff_write_armap (bfd *arch,
		  unsigned int elength,
		  struct orl *map,
		  unsigned int symbol_count,
		  int stridx)
{
  /* The size of the ranlib is the number of exported symbols in the
     archive * the number of bytes in an int, + an int for the count.  */
  unsigned int ranlibsize = (symbol_count * 4) + 4;
  unsigned int stringsize = stridx;
  unsigned int mapsize = stringsize + ranlibsize;
  unsigned int archive_member_file_ptr;
  bfd *current = arch->archive_head;
  unsigned int count;
  struct ar_hdr hdr;
  unsigned int i;
  int padit = mapsize & 1;

  if (padit)
    mapsize++;

  /* Work out where the first object file will go in the archive.  */
  archive_member_file_ptr = (mapsize
			     + elength
			     + sizeof (struct ar_hdr)
			     + SARMAG);

  memset (&hdr, 0, sizeof (struct ar_hdr));
  hdr.ar_name[0] = '/';
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  sprintf (hdr.ar_date, "%ld", (long) time (NULL));
  /* This, at least, is what Intel coff sets the values to.  */
  sprintf ((hdr.ar_uid), "%d", 0);
  sprintf ((hdr.ar_gid), "%d", 0);
  sprintf ((hdr.ar_mode), "%-7o", (unsigned) 0);
  strncpy (hdr.ar_fmag, ARFMAG, 2);

  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Write the ar header for this item and the number of symbols.  */

  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return FALSE;

  if (!bfd_write_bigendian_4byte_int (arch, symbol_count))
    return FALSE;

  /* Two passes, first write the file offsets for each symbol -
     remembering that each offset is on a two byte boundary.  */

  /* Write out the file offset for the file associated with each
     symbol, and remember to keep the offsets padded out.  */

  current = arch->archive_head;
  count = 0;
  while (current != NULL && count < symbol_count)
    {
      /* For each symbol which is used defined in this object, write
	 out the object file's address in the archive.  */

      while (count < symbol_count && map[count].u.abfd == current)
	{
	  if (!bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr))
	    return FALSE;
	  count++;
	}
      /* Add size of this archive entry.  */
      archive_member_file_ptr += arelt_size (current) + sizeof (struct ar_hdr);
      /* Remember aboout the even alignment.  */
      archive_member_file_ptr += archive_member_file_ptr % 2;
      current = current->next;
    }

  /* Now write the strings themselves.  */
  for (count = 0; count < symbol_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_bwrite (*map[count].name, len, arch) != len)
	return FALSE;
    }

  /* The spec sez this should be a newline.  But in order to be
     bug-compatible for arc960 we use a null.  */
  if (padit)
    {
      if (bfd_bwrite ("", 1, arch) != 1)
	return FALSE;
    }

  return TRUE;
}
@


1.9
log
@Use time_t instead of long for archive timestamps, and print them as long long;
prodding deraadt@@
@
text
@d1940 1
a1940 1
  sprintf (hdr.ar_date, "%ld", bfd_ardata (arch)->armap_timestamp);
d2033 1
a2033 1
  sprintf (hdr.ar_date, "%ld", bfd_ardata (arch)->armap_timestamp);
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1367 1
a1367 1
  sprintf ((hdr->ar_date), "%-12ld", (long) status.st_mtime);
d1440 5
d1471 1
a1471 1
  foo (ar_date, st_mtime, 10);
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *)arch_eltdata(bfd)->arch_header)
a162 12
static char *get_extended_arelt_filename
  PARAMS ((bfd *arch, const char *name));
static bfd_boolean do_slurp_bsd_armap
  PARAMS ((bfd *abfd));
static bfd_boolean do_slurp_coff_armap
  PARAMS ((bfd *abfd));
bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *abfd));
static const char *normalize
  PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem
  PARAMS ((bfd *abfd, const char *, bfd *member));
d165 1
a165 2
_bfd_generic_mkarchive (abfd)
     bfd *abfd;
d169 1
a169 1
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
d187 2
a188 1
	symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);
d205 1
a205 4
bfd_get_next_mapent (abfd, prev, entry)
     bfd *abfd;
     symindex prev;
     carsym **entry;
d227 1
a227 2
_bfd_create_empty_archive_element_shell (obfd)
     bfd *obfd;
d237 1
a237 1
	bfd_boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d245 1
a245 3
bfd_set_archive_head (output_archive, new_head)
     bfd *output_archive;
     bfd *new_head;
a246 1

d252 1
a252 3
_bfd_look_for_bfd_in_cache (arch_bfd, filepos)
     bfd *arch_bfd;
     file_ptr filepos;
d266 1
a266 3
_bfd_add_bfd_to_archive_cache (arch_bfd, filepos, new_elt)
     bfd *arch_bfd, *new_elt;
     file_ptr filepos;
d270 1
a270 1
  struct ar_cache *new_cache = (struct ar_cache *) bfd_zalloc (arch_bfd, amt);
d276 1
a276 1
  new_cache->next = (struct ar_cache *) NULL;
d295 1
a295 3
get_extended_arelt_filename (arch, name)
     bfd *arch;
     const char *name;
d322 2
a323 3
PTR
_bfd_generic_read_ar_hdr (abfd)
     bfd *abfd;
d325 1
a325 1
  return _bfd_generic_read_ar_hdr_mag (abfd, (const char *) NULL);
d331 2
a332 4
PTR
_bfd_generic_read_ar_hdr_mag (abfd, mag)
     bfd *abfd;
     const char *mag;
d343 1
a343 2
  if (bfd_bread ((PTR) hdrp, (bfd_size_type) sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
d413 1
a413 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d416 1
a416 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d418 1
a418 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d443 1
a443 1
  memcpy ((char *) ared->arch_header, (char *) &hdr, sizeof (struct ar_hdr));
d453 1
a453 1
	memcpy (ared->filename, hdr.ar_name, (size_t) namelen);
d457 1
a457 1
  return (PTR) ared;
d465 1
a465 3
_bfd_get_elt_at_filepos (archive, filepos)
     bfd *archive;
     file_ptr filepos;
d477 1
a477 1
  if ((new_areldata = (struct areltdata *) _bfd_read_ar_hdr (archive)) == NULL)
d483 1
a483 1
      bfd_release (archive, (PTR) new_areldata);
d488 1
a488 1
  n_nfd->arelt_data = (PTR) new_areldata;
d495 2
a496 2
  bfd_release (archive, (PTR) n_nfd);
  bfd_release (archive, (PTR) new_areldata);
d504 1
a504 3
_bfd_generic_get_elt_at_index (abfd, index)
     bfd *abfd;
     symindex index;
d517 1
a517 1
	bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);
d529 1
a529 3
bfd_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d539 1
a539 3
		   openr_next_archived_file,
		   (archive,
		    last_file));
d543 1
a543 3
bfd_generic_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d563 1
a563 2
bfd_generic_archive_p (abfd)
     bfd *abfd;
d569 1
a569 1
  if (bfd_bread ((PTR) armag, (bfd_size_type) SARMAG, abfd) != SARMAG)
d588 1
a588 1
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d627 1
a627 1
      first = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
d642 1
a642 1
	      (void) bfd_close (first);
d676 1
a676 2
do_slurp_bsd_armap (abfd)
     bfd *abfd;
d686 1
a686 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d690 1
a690 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d692 2
a693 2
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, parsed_size);
  if (raw_armap == (bfd_byte *) NULL)
d696 1
a696 1
  if (bfd_bread ((PTR) raw_armap, parsed_size, abfd) != parsed_size)
d701 1
a701 1
      bfd_release (abfd, (PTR) raw_armap);
d720 2
a721 2
  amt = (bfd_size_type) ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d746 1
a746 2
do_slurp_coff_armap (abfd)
     bfd *abfd;
d756 1
a756 1
  bfd_vma (*swap) PARAMS ((const bfd_byte *));
d761 1
a761 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d765 1
a765 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d767 1
a767 1
  if (bfd_bread ((PTR) int_buf, (bfd_size_type) 4, abfd) != 4)
d776 1
a776 1
  nsymz = bfd_getb32 ((PTR) int_buf);
d790 1
a790 1
      nsymz = bfd_getl32 ((PTR) int_buf);
d802 1
a802 1
  ardata->symdefs = (carsym *) bfd_zalloc (abfd, carsym_size + stringsize + 1);
d809 1
a809 1
  raw_armap = (int *) bfd_alloc (abfd, ptrsize);
d812 2
a813 2
  if (bfd_bread ((PTR) raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread ((PTR) stringbase, stringsize, abfd) != stringsize))
d824 1
a824 1
      carsyms->file_offset = swap ((PTR) rawptr);
d837 1
a837 1
  bfd_release (abfd, (PTR) raw_armap);
d844 1
a844 1
    tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d860 1
a860 1
  bfd_release (abfd, (PTR) raw_armap);
d862 1
a862 1
  bfd_release (abfd, (PTR) (ardata)->symdefs);
d870 1
a870 2
bfd_slurp_armap (abfd)
     bfd *abfd;
d873 1
a873 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d892 1
d912 1
a912 2
bfd_slurp_bsd_armap_f2 (abfd)
     bfd *abfd;
d923 1
a923 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d944 1
a944 1
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d949 1
a949 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
d953 1
a953 1
      bfd_release (abfd, (PTR) mapdata);
d957 1
a957 1
  if (bfd_bread ((PTR) raw_armap, amt, abfd) != amt)
d962 1
a962 1
      bfd_release (abfd, (PTR) raw_armap);
d966 1
a966 1
  ardata->symdef_count = H_GET_16 (abfd, (PTR) raw_armap);
d984 2
a985 2
  amt = (bfd_size_type) ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d1020 1
a1020 2
_bfd_slurp_extended_name_table (abfd)
     bfd *abfd;
d1029 1
a1029 1
  if (bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd) == 16)
d1041 1
a1041 1
      namedata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
d1050 1
a1050 1
	  bfd_release (abfd, (PTR) namedata);
d1054 1
a1054 1
      if (bfd_bread ((PTR) bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1058 1
a1058 1
	  bfd_release (abfd, (PTR) (bfd_ardata (abfd)->extended_names));
d1100 1
a1100 3
normalize (abfd, file)
     bfd *abfd;
     const char *file;
d1121 1
a1121 1
  copy = (char *) bfd_alloc (abfd, (bfd_size_type) (last - first + 1));
d1133 1
a1133 3
normalize (abfd, file)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *file;
d1147 1
a1147 1
  if (filename != (char *) NULL)
d1158 4
a1161 5
_bfd_archive_bsd_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
d1170 4
a1173 5
_bfd_archive_coff_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
d1188 4
a1191 5
_bfd_construct_extended_name_table (abfd, trailing_slash, tabloc, tablen)
     bfd *abfd;
     bfd_boolean trailing_slash;
     char **tabloc;
     bfd_size_type *tablen;
d1305 1
a1305 3
hpux_uid_gid_encode (str, id)
     char str[6];
     long int id;
d1331 1
a1331 4
bfd_ar_hdr_from_filesystem (abfd, filename, member)
     bfd *abfd;
     const char *filename;
     bfd *member;
d1342 1
a1342 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) member->iostream;
d1356 1
a1356 1
  ared = (struct areltdata *) bfd_zalloc (abfd, amt);
d1362 1
a1362 1
  memset ((PTR) hdr, ' ', sizeof (struct ar_hdr));
d1408 1
a1408 2
struct ar_hdr *bfd_special_undocumented_glue
  PARAMS ((bfd *, const char *));
d1411 1
a1411 3
bfd_special_undocumented_glue (abfd, filename)
     bfd *abfd;
     const char *filename;
d1422 1
a1422 3
bfd_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
d1477 1
a1477 4
bfd_dont_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1514 1
a1514 4
bfd_bsd_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1562 1
a1562 4
bfd_gnu_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd;
     const char *pathname;
     char *arhdr;
d1607 1
a1607 2
_bfd_write_archive_contents (arch)
     bfd *arch;
d1638 1
a1638 1
	    (PTR) bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1643 2
a1644 3
	  BFD_SEND (arch, _bfd_truncate_arname, (arch,
						 current->filename,
					      (char *) arch_hdr (current)));
d1665 1
a1665 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), (bfd_size_type) SARMAG, arch);
d1667 1
a1667 1
  wrote = bfd_bwrite (ARMAG, (bfd_size_type) SARMAG, arch);
d1682 1
a1682 1
      memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d1691 1
a1691 1
      if ((bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d1697 1
a1697 1
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
d1709 1
a1709 1
      if (bfd_bwrite ((PTR) hdr, (bfd_size_type) sizeof (*hdr), arch)
d1720 1
a1720 1
	  if (bfd_bread (buffer, (bfd_size_type) amt, current) != amt)
d1726 1
a1726 1
	  if (bfd_bwrite (buffer, (bfd_size_type) amt, arch) != amt)
d1732 1
a1732 1
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
d1762 1
a1762 3
_bfd_compute_and_write_armap (arch, elength)
     bfd *arch;
     unsigned int elength;
d1781 2
a1782 2
  amt = (bfd_size_type) orl_max * sizeof (struct orl);
  map = (struct orl *) bfd_malloc (amt);
d1788 1
a1788 1
  first_name = bfd_alloc (arch, (bfd_size_type) 1);
d1799 1
a1799 1
       current != (bfd *) NULL;
d1820 1
a1820 1
		  syms = (asymbol **) bfd_malloc ((bfd_size_type) syms_max);
d1848 3
a1850 3
			  amt = (bfd_size_type) orl_max * sizeof (struct orl);
			  new_map = (struct orl *) bfd_realloc (map, amt);
			  if (new_map == (struct orl *) NULL)
d1858 1
a1858 1
		      map[orl_count].name = (char **) bfd_alloc (arch, amt);
d1906 5
a1910 6
bsd_write_armap (arch, elength, map, orl_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d1929 1
a1929 1
  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d1943 1
a1943 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d1947 1
a1947 1
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
d1968 1
a1968 1
      if (bfd_bwrite (buf, (bfd_size_type) BSD_SYMDEF_SIZE, arch)
d1975 1
a1975 1
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
d1981 1
a1981 1
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
d1989 1
a1989 1
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
d2003 1
a2003 2
_bfd_archive_bsd_update_armap_timestamp (arch)
     bfd *arch;
d2037 1
a2037 1
      || (bfd_bwrite (hdr.ar_date, (bfd_size_type) sizeof (hdr.ar_date), arch)
d2065 5
a2069 6
coff_write_armap (arch, elength, map, symbol_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int symbol_count;
     int stridx;
d2092 1
a2092 1
  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
d2108 1
a2108 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d2123 1
a2123 1
  while (current != (bfd *) NULL && count < symbol_count)
d2135 1
a2135 2
      archive_member_file_ptr += (arelt_size (current)
				  + sizeof (struct ar_hdr));
d2146 1
a2146 1
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
d2154 1
a2154 1
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000
d135 1
a135 1
#include <ctype.h>
a144 6
/* Define offsetof for those systems which lack it */

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

d163 12
a174 8
static char *get_extended_arelt_filename PARAMS ((bfd *arch,
						  const char *name));
static boolean do_slurp_bsd_armap PARAMS ((bfd *abfd));
static boolean do_slurp_coff_armap PARAMS ((bfd *abfd));
static const char *normalize PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem PARAMS ((bfd *abfd,
							     const char *,
							     bfd *member));
d176 1
a176 1
boolean
d180 1
a180 2
  abfd->tdata.aout_ar_data = ((struct artdata *)
			      bfd_zalloc (abfd, sizeof (struct artdata)));
d182 1
d184 1
a184 1
    return false;
d192 1
a192 1
  return true;
d253 1
a253 1
	boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d260 1
a260 1
boolean
d267 1
a267 1
  return true;
d286 1
a286 1
boolean
d291 1
a291 3
  struct ar_cache *new_cache = ((struct ar_cache *)
				bfd_zalloc (arch_bfd,
					    sizeof (struct ar_cache)));
d293 1
d295 1
a295 1
    return false;
d311 1
a311 1
  return true;
d364 1
a364 1
  unsigned int parsed_size;
d367 2
a368 2
  unsigned int namelen = 0;
  unsigned int allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);
d371 1
a371 1
  if (bfd_read ((PTR) hdrp, 1, sizeof (struct ar_hdr), abfd)
d414 1
a414 1
	   && isdigit ((unsigned char) hdr.ar_name[3]))
d427 1
a427 1
      if (bfd_read (filename, 1, namelen, abfd) != namelen)
d442 1
a442 1
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d445 1
a445 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d447 1
a447 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d482 1
a482 1
	memcpy (ared->filename, hdr.ar_name, namelen);
d607 1
d609 1
a609 3
  tdata_hold = abfd->tdata.aout_ar_data;

  if (bfd_read ((PTR) armag, 1, SARMAG, abfd) != SARMAG)
d625 1
a625 4
  /* We are setting bfd_ardata(abfd) here, but since bfd_ardata
     involves a cast, we can't do it as the left operand of assignment.  */
  abfd->tdata.aout_ar_data = ((struct artdata *)
			      bfd_zalloc (abfd, sizeof (struct artdata)));
d627 2
d630 4
a633 1
    return NULL;
d642 2
a643 1
  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd)))
a644 2
      bfd_release (abfd, bfd_ardata (abfd));
      abfd->tdata.aout_ar_data = tdata_hold;
a646 5
      return NULL;
    }

  if (!BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
    {
d648 1
a648 3
      abfd->tdata.aout_ar_data = tdata_hold;
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
d670 1
a670 1
	  boolean fail;
d672 2
a673 2
	  first->target_defaulted = false;
	  fail = false;
d677 5
d684 3
a686 2
	      abfd->tdata.aout_ar_data = tdata_hold;
	      bfd_set_error (bfd_error_wrong_format);
d689 1
a689 3

	  /* We ought to close first here, but we can't, because we
             have no way to remove it from the archive cache.  FIXME.  */
d699 1
a699 1
   changing some bfd_h_get_32 to bfd_h_get_64.  */
d713 1
a713 1
/* Returns false on error, true otherwise */
d715 1
a715 1
static boolean
d724 1
a724 1
  unsigned int parsed_size;
d729 1
a729 1
    return false;
d735 1
a735 1
    return false;
d737 1
a737 1
  if (bfd_read ((PTR) raw_armap, 1, parsed_size, abfd) != parsed_size)
d743 1
a743 1
      return false;
d746 1
a746 1
  ardata->symdef_count = bfd_h_get_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;
d761 2
a762 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * sizeof (carsym)));
d764 1
a764 1
    return false;
d770 2
a771 2
      set->name = bfd_h_get_32 (abfd, rbase) + stringbase;
      set->file_offset = bfd_h_get_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d780 2
a781 2
  bfd_has_map (abfd) = true;
  return true;
d784 1
a784 1
/* Returns false on error, true otherwise.  */
d786 1
a786 1
static boolean
d794 1
a794 1
  unsigned int stringsize;
d797 1
a797 1
  unsigned int nsymz;		/* Number of symbols in armap.  */
d800 2
a801 1
  unsigned int carsym_size, ptrsize, i;
d805 1
a805 1
    return false;
d809 1
a809 1
  if (bfd_read ((PTR) int_buf, 1, 4, abfd) != 4)
d813 1
a813 1
      return false;
d846 1
a846 1
    return false;
d854 2
a855 2
  if (bfd_read ((PTR) raw_armap, 1, ptrsize, abfd) != ptrsize
      || bfd_read ((PTR) stringbase, 1, stringsize, abfd) != stringsize)
d878 1
a878 1
  bfd_has_map (abfd) = true;
d885 1
a885 1
    bfd_seek (abfd,   ardata->first_file_filepos, SEEK_SET);
d893 1
a893 1
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~1;
d899 1
a899 1
  return true;
d905 1
a905 1
  return false;
d909 1
a909 1
   Returns false on error, true otherwise */
d911 1
a911 1
boolean
d916 1
a916 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d919 1
a919 1
    return true;
d921 1
a921 1
    return false;
d923 2
a924 2
  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
    return false;
d933 4
a936 1
      /* Irix 6 archive--must be recognized by code in elf64-mips.c.  */
d938 2
a939 1
      return false;
d942 2
a943 2
  bfd_has_map (abfd) = false;
  return true;
d946 1
a946 1
/* Returns false on error, true otherwise */
d953 1
a953 1
boolean
d964 1
d966 1
a966 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d969 1
a969 1
    return true;
d971 1
a971 1
    return false;
d974 2
a975 2
  if (bfd_seek (abfd, -16L, SEEK_CUR) != 0)
    return false;
d983 2
a984 2
      bfd_has_map (abfd) = false;
      return true;
d989 1
a989 1
    return false;
d991 2
a992 1
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, mapdata->parsed_size);
d997 1
a997 1
      return false;
d1000 1
a1000 2
  if (bfd_read ((PTR) raw_armap, 1, mapdata->parsed_size, abfd) !=
      mapdata->parsed_size)
d1009 1
a1009 1
  ardata->symdef_count = bfd_h_get_16 (abfd, (PTR) raw_armap);
d1021 1
a1021 1
  stringsize = bfd_h_get_32 (abfd, raw_armap + HPUX_SYMDEF_COUNT_SIZE);
d1027 2
a1028 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * BSD_SYMDEF_SIZE));
d1030 1
a1030 1
    return false;
d1036 2
a1037 2
      set->name = bfd_h_get_32 (abfd, rbase) + stringbase;
      set->file_offset = bfd_h_get_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d1046 2
a1047 2
  bfd_has_map (abfd) = true;
  return true;
d1060 1
a1060 1
/* Returns false on error, true otherwise.  */
d1062 1
a1062 1
boolean
d1068 1
d1071 1
a1071 1
     we probably don't want to return true.  */
d1073 1
a1073 1
  if (bfd_read ((PTR) nextname, 1, 16, abfd) == 16)
d1075 2
a1076 2
      if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
	return false;
d1082 1
a1082 1
	  return true;
d1087 1
a1087 1
	return false;
d1089 2
a1090 2
      bfd_ardata (abfd)->extended_names =
	bfd_zalloc (abfd, namedata->parsed_size);
d1095 1
a1095 1
	  return false;
d1098 1
a1098 2
      if (bfd_read ((PTR) bfd_ardata (abfd)->extended_names, 1,
		    namedata->parsed_size, abfd) != namedata->parsed_size)
d1135 1
a1135 1
  return true;
d1148 2
a1149 2
  CONST char *first;
  CONST char *last;
d1167 1
a1167 1
  copy = (char *) bfd_alloc (abfd, last - first + 1);
d1205 1
a1205 1
boolean
d1213 1
a1213 1
  return _bfd_construct_extended_name_table (abfd, false, tabloc, tablen);
d1218 1
a1218 1
boolean
d1226 1
a1226 1
  return _bfd_construct_extended_name_table (abfd, true, tabloc, tablen);
d1233 1
a1233 1
   further massage.  Returns true if it ran successfully, false if
d1237 1
a1237 1
boolean
d1240 1
a1240 1
     boolean trailing_slash;
d1245 1
a1245 1
  unsigned int total_namelen = 0;
d1259 1
a1259 1
	return false;
d1295 1
a1295 1
    return true;
d1299 1
a1299 1
    return false;
d1312 1
a1312 1
	return false;
d1347 1
a1347 1
  return true;
d1393 1
d1411 2
a1412 2
  ared = (struct areltdata *) bfd_zalloc (abfd, sizeof (struct ar_hdr) +
					  sizeof (struct areltdata));
d1464 2
a1465 1
struct ar_hdr *bfd_special_undocumented_glue PARAMS ((bfd *, const char *));
d1540 1
a1540 1
     CONST char *pathname;
d1580 1
a1580 1
     CONST char *pathname;
d1584 3
a1586 3
  int length;
  CONST char *filename = strrchr (pathname, '/');
  int maxlen = ar_maxnamelen (abfd);
d1631 1
a1631 1
     CONST char *pathname;
d1635 3
a1637 3
  int length;
  CONST char *filename = strrchr (pathname, '/');
  int maxlen = ar_maxnamelen (abfd);
d1676 1
a1676 1
boolean
d1684 3
a1686 2
  boolean makemap = bfd_has_map (arch);
  boolean hasobjects = false;	/* If no .o's, don't bother to make a map.  */
d1704 1
a1704 1
	  return false;
d1711 1
a1711 1
	    return false;
d1726 1
a1726 1
	    hasobjects = true;
d1732 1
a1732 1
    return false;
d1735 1
a1735 1
    return false;
d1737 1
a1737 1
  wrote = bfd_write (BFD_GNU960_ARMAG (arch), 1, SARMAG, arch);
d1739 1
a1739 1
  wrote = bfd_write (ARMAG, 1, SARMAG, arch);
d1742 1
a1742 1
    return false;
d1746 2
a1747 2
      if (_bfd_compute_and_write_armap (arch, elength) != true)
	return false;
d1758 1
a1758 1
	       (int) ((elength + 1) & ~1));
d1763 1
a1763 1
      if ((bfd_write ((char *) &hdr, 1, sizeof (struct ar_hdr), arch)
d1765 2
a1766 2
	  || bfd_write (etable, 1, elength, arch) != elength)
	return false;
d1769 2
a1770 2
	  if (bfd_write ("\012", 1, 1, arch) != 1)
	    return false;
d1781 3
a1783 2
      if (bfd_write ((char *) hdr, 1, sizeof (*hdr), arch) != sizeof (*hdr))
	return false;
d1785 1
a1785 1
	return false;
d1792 1
a1792 1
	  if (bfd_read (buffer, amt, 1, current) != amt)
d1796 1
a1796 1
	      return false;
d1798 2
a1799 2
	  if (bfd_write (buffer, amt, 1, arch) != amt)
	    return false;
d1804 2
a1805 2
	  if (bfd_write ("\012", 1, 1, arch) != 1)
	    return false;
d1828 1
a1828 1
  return true;
d1833 1
a1833 1
boolean
d1842 2
a1843 2
  int orl_max = 1024;		/* fine initial default */
  int orl_count = 0;
d1847 2
a1848 1
  boolean ret;
d1855 2
a1856 1
  map = (struct orl *) bfd_malloc (orl_max * sizeof (struct orl));
d1862 1
a1862 1
  first_name = bfd_alloc (arch, 1);
d1876 2
a1877 2
      if ((bfd_check_format (current, bfd_object) == true)
	  && ((bfd_get_file_flags (current) & HAS_SYMS)))
d1894 1
a1894 1
		  syms = (asymbol **) bfd_malloc ((size_t) syms_max);
d1915 1
a1915 1
		      size_t namelen;
d1922 2
a1923 3
			  new_map =
			    ((struct orl *)
			     bfd_realloc (map, orl_max * sizeof (struct orl)));
d1931 2
a1932 3
		      map[orl_count].name = ((char **)
					     bfd_alloc (arch,
							sizeof (char *)));
d1939 2
a1940 2
		      (map[orl_count]).pos = (file_ptr) current;
		      (map[orl_count]).namidx = stridx;
d1976 1
a1976 1
  return false;
d1979 1
a1979 1
boolean
d2018 1
a2018 1
  if (bfd_write ((char *) &hdr, 1, sizeof (struct ar_hdr), arch)
d2020 4
a2023 4
    return false;
  bfd_h_put_32 (arch, (bfd_vma) ranlibsize, temp);
  if (bfd_write (temp, 1, sizeof (temp), arch) != sizeof (temp))
    return false;
d2029 1
a2029 1
      if (((bfd *) (map[count]).pos) != last_elt)
d2037 1
a2037 1
	  while (current != (bfd *) (map[count]).pos);
d2041 5
a2045 4
      bfd_h_put_32 (arch, map[count].namidx, buf);
      bfd_h_put_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);
      if (bfd_write (buf, BSD_SYMDEF_SIZE, 1, arch) != BSD_SYMDEF_SIZE)
	return false;
d2049 3
a2051 3
  bfd_h_put_32 (arch, stringsize, temp);
  if (bfd_write (temp, 1, sizeof (temp), arch) != sizeof (temp))
    return false;
d2056 2
a2057 2
      if (bfd_write (*map[count].name, 1, len, arch) != len)
	return false;
d2064 2
a2065 2
      if (bfd_write ("", 1, 1, arch) != 1)
	return false;
d2068 1
a2068 1
  return true;
d2074 2
a2075 2
   Return true if the timestamp was OK, or an unusual problem happened.
   Return false if we updated the timestamp.  */
d2077 1
a2077 1
boolean
d2090 1
a2090 1
      perror (_("Reading archive file mod timestamp"));
d2093 1
a2093 1
      return true;
d2097 1
a2097 1
    return true;
d2113 1
a2113 1
      || (bfd_write (hdr.ar_date, sizeof (hdr.ar_date), 1, arch)
d2116 1
a2116 2
      /* FIXME: bfd can't call perror.  */
      perror (_("Writing updated armap timestamp"));
d2119 1
a2119 1
      return true;
d2123 1
a2123 1
  return false;
d2140 1
a2140 1
boolean
d2149 1
a2149 1
     archive * the number of bytes in a int, + an int for the count.  */
d2153 1
a2153 1
  file_ptr archive_member_file_ptr;
d2185 1
a2185 1
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), arch)
d2187 1
a2187 1
    return false;
d2189 2
a2190 1
  bfd_write_bigendian_4byte_int (arch, symbol_count);
d2205 1
a2205 1
      while (count < symbol_count && ((bfd *) (map[count]).pos) == current)
d2207 2
a2208 1
	  bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr);
d2224 2
a2225 2
      if (bfd_write (*map[count].name, 1, len, arch) != len)
	return false;
d2232 2
a2233 2
      if (bfd_write ("", 1, 1, arch) != 1)
	return false;
d2236 1
a2236 1
  return true;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d156 2
a157 4
   to the front of the contents!
*/
struct ar_cache
{
d166 1
a166 1
#define arch_eltdata(bfd) ((struct areltdata *)((bfd)->arelt_data))
d318 1
a318 1
   the string table. */
d328 1
a328 1
     the next region, but I'm too lazy. */
d330 1
a330 1
  /* Skip first char, which is '/' in SVR4 or ' ' in some other variants. */
d413 1
a413 1
     Only implemented for reading, so far! */
d442 1
a442 1
	 spaces, so only look for ' ' if we don't find '/'. */
d448 1
a448 1
          e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d450 1
a450 1
            e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d528 1
a528 1
  /* huh? */
a561 1

d596 1
a596 1
	 BSD-4.4-style element with a long odd size. */
a603 1

d630 1
a630 1
     involves a cast, we can't do it as the left operand of assignment. */
d737 1
a737 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more. */
d782 1
a782 1
  /* Pad to an even boundary if you have to */
d786 1
a786 1
     to be allocated on an objalloc anyway... */
d791 2
a792 1
/* Returns false on error, true otherwise */
d804 1
a804 1
  unsigned int nsymz;		/* Number of symbols in armap. */
d813 1
a813 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more. */
d822 1
a822 1
     in big endian format, nomatter the host or target. */
d837 1
a837 1
      /* This looks dangerous, let's do it the other way around */
d845 1
a845 1
     bsd-style one in core all at once, for simplicity. */
d856 1
a856 1
  /* Allocate and read in the raw offsets. */
d868 1
a868 1
  /* OK, build the carsyms */
d881 1
a881 1
  /* Pad to an even boundary if you have to */
a883 1

d887 1
a887 2

  /* Check for a second archive header (as used by PE) */
d893 1
a893 1
    if (tmp != NULL) 
d896 1
a896 1
	    && tmp->arch_header[1] == ' ') 
d899 1
a899 1
	      (tmp->parsed_size + sizeof(struct ar_hdr) + 1) & ~1;
d951 1
a951 1
   This flavour is used by hp300hpux. */
d974 1
a974 1
  /* The archive has at least 16 bytes in it */
d1023 1
a1023 1
  /* skip sym count and string sz */
d1043 1
a1043 1
  /* Pad to an even boundary if you have to */
d1047 1
a1047 1
     to be allocated on an objalloc anyway... */
d1060 3
a1062 1
  extended the format by using the prefix // for the special element */
a1063 1
/* Returns false on error, true otherwise */
d1117 7
a1123 6
	for (; temp < limit; ++temp) {
	  if (*temp == '\012')
	    temp[temp[-1] == '/' ? -1 : 0] = '\0';
	  if (*temp == '\\')
	    *temp = '/';
	}
d1126 1
a1126 1
      /* Pad to an even boundary if you have to */
d1132 4
a1135 2
	 below extended_names on the objalloc... */
      /* bfd_release (abfd, namedata); */
d1143 2
a1144 1
   semicolon */
a1186 1

d1191 1
a1191 1
    if (bslash > filename)
d1253 1
a1253 1
  /* Figure out how long the table should be */
d1321 1
a1321 1
	     generalise this hack. */
d1333 1
a1333 1
	     cases where you may safely use sprintf). */
d1336 1
a1336 1
	     sprintf but not all implementations get this right */
d1354 18
d1383 1
a1383 1
   is set, and it's an in-memory bfd, we fake it. */
d1398 1
a1398 1
      /* Assume we just "made" the member, and fake it */
d1400 3
a1402 3
      time(&status.st_mtime);
      status.st_uid = getuid();
      status.st_gid = getgid();
d1418 1
a1418 1
  /* ar headers are space padded, not null padded! */
d1423 1
a1423 1
  /* Goddamned sprintf doesn't permit MAXIMUM field lengths */
d1425 15
a1439 1
  sprintf ((hdr->ar_uid), "%ld", (long) status.st_uid);
d1445 1
a1445 1
     IO operations */
d1461 3
a1463 3
    undocumented, it's undocumented.  You may think that it would take
    a strong stomach to write this, and it does, but it takes even a
    stronger stomach to try to code around such a thing!  */
d1478 1
a1479 1
/* Analogous to stat call */
d1496 30
a1525 3
#define foo(arelt, stelt, size)  \
  buf->stelt = strtol (hdr->arelt, &aloser, size); \
  if (aloser == hdr->arelt) return -1;
d1528 2
a1529 2
  foo (ar_uid, st_uid, 10);
  foo (ar_gid, st_gid, 10);
d1546 1
a1546 1
     intel's release is out the door. */
d1592 1
a1592 1
    if (bslash > filename)
d1626 1
a1626 1
   bsd ar. */
d1643 1
a1643 1
    if (bslash > filename)
d1674 1
a1674 1
/* The BFD is open for write and has its format set to bfd_archive */
d1685 1
a1685 1
  boolean hasobjects = false;	/* if no .o's, don't bother to make a map */
d1695 5
d1712 1
a1712 1
	  /* Put in the file name */
d1719 1
a1719 1
	{			/* don't bother if we won't make a map! */
d1779 1
a1779 1
      /* write ar header */
d1829 1
a1829 1
/* Note that the namidx for the first symbol is 0 */
d1847 1
a1847 1
  /* Dunno if this is the best place for this info... */
d1862 1
a1862 2
  /* Drop all the files called __.SYMDEF, we're going to make our
     own */
d1867 1
a1867 1
  /* Map over each element */
d1898 2
a1899 1
	      /* Now map over all the symbols, picking out the ones we want */
d1914 1
a1914 1
		      /* This symbol will go into the archive header */
d1953 1
a1953 1
  /* OK, now we have collected all the data, let's write them out */
d1988 1
a1988 1
  /* Include 8 bytes to store ranlibsize and stringsize in output. */
d2045 1
a2045 1
  /* now write the strings themselves */
d2058 1
a2058 1
     bug-compatible for sun's ar we use a null. */
d2088 3
a2090 1
      return true;		/* Can't read mod time for some reason */
d2093 2
a2094 1
    return true;		/* OK by the linker's rules */
d2115 3
a2117 1
      return true;		/* Some error while writing */
d2120 2
a2121 1
  return false;			/* We updated the timestamp successfully.  */
d2147 1
a2147 1
     archive * the number of bytes in a int, + an int for the count */
d2161 1
a2161 1
  /* work out where the first object file will go in the archive */
d2171 1
a2171 1
  /* This, at least, is what Intel coff sets the values to.: */
d2181 1
a2181 1
  /* Write the ar header for this item and the number of symbols */
d2199 2
a2200 2
      /* For each symbol which is used defined in this object, write out
	 the object file's address in the archive */
d2202 1
a2202 1
      while (((bfd *) (map[count]).pos) == current)
d2207 1
a2207 1
      /* Add size of this archive entry */
d2210 1
a2210 1
      /* remember aboout the even alignment */
d2215 1
a2215 1
  /* now write the strings themselves */
d2225 1
a2225 1
     bug-compatible for arc960 we use a null. */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a133 2
#include <errno.h>
#include <string.h>		/* For memchr, strrchr and friends */
a143 3
/* Can't define this in hosts/foo.h, because (e.g. in gprof) the hosts file
   is included, then obstack.h, which thinks if offsetof is defined, it
   doesn't need to include stddef.h.  */
d146 1
a146 1
#if !defined (offsetof)
d176 2
a177 1
							     const char *));
d399 1
a399 1
     specify an extendend name table, either the first char of the
d415 4
a418 2
  else if (hdr.ar_name[0] == '#' && hdr.ar_name[1] == '1'
	   && hdr.ar_name[2] == '/' && isdigit (hdr.ar_name[3]))
d445 3
a447 3
      namelen = 0;
      while (hdr.ar_name[namelen] != '\0' &&
	     hdr.ar_name[namelen] != '/')
d449 12
a460 9
	  namelen++;
	  if (namelen == (unsigned) ar_maxnamelen (abfd))
	    {
	      namelen = 0;
	      while (hdr.ar_name[namelen] != ' '
		     && namelen < (unsigned) ar_maxnamelen (abfd))
		namelen++;
	      break;
	    }
d651 2
d660 2
d789 1
a789 1
     to be allocated on an obstack anyway... */
d1051 1
a1051 1
     to be allocated on an obstack anyway... */
d1134 1
a1134 1
	 below extended_names on the obstack... */
d1181 1
a1181 1
     bfd *abfd;
d1186 11
d1354 8
d1364 2
a1365 1
   The filename field of the ar_hdr will NOT be initialized */
d1368 1
a1368 1
bfd_ar_hdr_from_filesystem (abfd, filename)
d1371 1
d1378 11
a1388 1
  if (stat (filename, &status) != 0)
d1433 2
d1438 1
a1438 1
     char *filename;
d1440 1
a1440 1
  struct areltdata *ar_elt = bfd_ar_hdr_from_filesystem (abfd, filename);
d1529 11
d1580 11
d1644 1
a1644 1
	    (PTR) bfd_ar_hdr_from_filesystem (arch, current->filename);
d1757 1
a1757 1
	    ("Warning: writing archive was slow: rewriting timestamp\n");
d1792 1
a1792 1
  /* We put the symbol names on the arch obstack, and then discard
a1944 1
#ifndef _WIN32
a1946 4
#else
  sprintf (hdr.ar_uid, "%ld", (long) 666);
  sprintf (hdr.ar_gid, "%ld", (long) 42);
#endif
d2023 1
a2023 1
      perror ("Reading archive file mod timestamp");
d2047 1
a2047 1
      perror ("Writing updated armap timestamp");
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d829 3
a831 1
  if (stringsize > 0xfffff)
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d933 6
d1882 1
d1885 4
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
d190 1
a190 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d251 1
a251 9
  bfd *nbfd;

  nbfd = _bfd_new_bfd_contained_in (obfd);
  if (nbfd == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  return nbfd;
d302 1
a302 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d358 5
a362 3
#ifndef errno
  extern int errno;
#endif
d364 5
d385 3
a387 1
  if (strncmp (hdr.ar_fmag, ARFMAG, 2))
d428 1
a428 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
d468 1
a468 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
d533 2
a534 6
/*
FUNCTION
	bfd_get_elt_at_index

SYNOPSIS
	bfd *bfd_get_elt_at_index(bfd *archive, int index);
a535 6
DESCRIPTION
	Return the BFD which is referenced by the symbol in @@var{archive}
	indexed by @@var{index}.  @@var{index} should have been returned by
	<<bfd_get_next_mapent>> (q.v.).

*/
d537 1
a537 1
bfd_get_elt_at_index (abfd, index)
d539 1
a539 1
     int index;
d636 1
a636 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d664 5
a668 3
	 are object files.  Make sure that the first file in the
	 archive can be recognized as an object file for this target.
	 If not, assume that this is the wrong format.
d681 2
a682 3
	  if (! bfd_check_format (first, bfd_object))
	    fail = true;
	  else if (first->xvec != abfd->xvec)
a683 8
	      bfd_set_error (bfd_error_wrong_format);
	      fail = true;
	    }
	  if (fail)
	    {
	      bfd_error_type err;

	      err = bfd_get_error ();
d687 1
a687 1
	      bfd_set_error (err);
d738 1
a738 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d768 1
a768 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d846 1
a846 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d853 1
a853 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto release_symdefs;
    }
a984 1
      bfd_set_error (bfd_error_no_memory);
d1022 1
a1022 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
a1082 1
	  bfd_set_error (bfd_error_no_memory);
d1156 1
a1156 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1276 1
a1276 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1352 1
a1352 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1719 1
a1719 1
  map = (struct orl *) malloc (orl_max * sizeof (struct orl));
d1721 1
a1721 1
    goto no_memory_return;
d1727 1
a1727 1
    goto no_memory_return;
d1758 1
a1758 1
		  syms = (asymbol **) malloc ((size_t) syms_max);
d1760 1
a1760 1
		    goto no_memory_return;
d1785 3
a1787 3
			  new_map = ((struct orl *)
				     realloc ((PTR) map,
					      orl_max * sizeof (struct orl)));
d1789 1
a1789 1
			    goto no_memory_return;
d1799 1
a1799 1
			goto no_memory_return;
d1802 1
a1802 1
			goto no_memory_return;
a1831 3

 no_memory_return:
  bfd_set_error (bfd_error_no_memory);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d190 4
a193 1
    return false;
d254 9
a262 1
  return _bfd_new_bfd_contained_in (obfd);
d313 4
a316 1
    return false;
d372 3
a374 5
  return _bfd_generic_read_ar_hdr_mag (abfd, (const char *) NULL);
}

/* Alpha ECOFF uses an optional different ARFMAG value, so we have a
   variant of _bfd_generic_read_ar_hdr which accepts a magic string.  */
a375 5
PTR
_bfd_generic_read_ar_hdr_mag (abfd, mag)
     bfd *abfd;
     const char *mag;
{
d392 1
a392 3
  if (strncmp (hdr.ar_fmag, ARFMAG, 2) != 0
      && (mag == NULL
	  || strncmp (hdr.ar_fmag, mag, 2) != 0))
d433 4
a436 1
	return NULL;
d476 4
a479 1
	return NULL;
d544 6
a549 2
/* Return the BFD which is referenced by the symbol in ABFD indexed by
   INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */
d551 6
d558 1
a558 1
_bfd_generic_get_elt_at_index (abfd, index)
d560 1
a560 1
     symindex index;
d657 4
a660 1
    return NULL;
d688 3
a690 5
	 are object files.  Make sure that if the first file in the
	 archive can be recognized as an object file, it is for this
	 target.  If not, assume that this is the wrong format.  If
	 the first file is not an object file, somebody is doing
	 something weird, and we permit it so that ar -t will work.
d703 3
a705 2
	  if (bfd_check_format (first, bfd_object)
	      && first->xvec != abfd->xvec)
d707 8
d718 1
a718 1
	      bfd_set_error (bfd_error_wrong_format);
d769 4
a772 1
    return false;
d802 4
a805 1
    return false;
d883 4
a886 1
    return false;
d893 4
a896 1
    goto release_symdefs;
d1028 1
d1066 4
a1069 1
    return false;
d1130 1
d1204 4
a1207 1
    return NULL;
d1327 4
a1330 1
    return false;
d1406 4
a1409 1
    return NULL;
d1776 1
a1776 1
  map = (struct orl *) bfd_malloc (orl_max * sizeof (struct orl));
d1778 1
a1778 1
    goto error_return;
d1784 1
a1784 1
    goto error_return;
d1815 1
a1815 1
		  syms = (asymbol **) bfd_malloc ((size_t) syms_max);
d1817 1
a1817 1
		    goto error_return;
d1842 3
a1844 3
			  new_map =
			    ((struct orl *)
			     bfd_realloc (map, orl_max * sizeof (struct orl)));
d1846 1
a1846 1
			    goto error_return;
d1856 1
a1856 1
			goto error_return;
d1859 1
a1859 1
			goto error_return;
d1889 3
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a932 6
  else if (!strncmp (nextname, "/SYM64/         ", 16))
    {
      /* Irix 6 archive--must be recognized by code in elf64-mips.c.  */
      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
a1875 1
#ifndef _WIN32
a1877 4
#else
  sprintf (hdr.ar_uid, "%ld", (long) 666);
  sprintf (hdr.ar_gid, "%ld", (long) 42);
#endif
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d829 1
a829 3
  if (stringsize > 0xfffff
      && bfd_get_arch (abfd) == bfd_arch_i960
      && bfd_get_flavour (abfd) == bfd_target_coff_flavour)
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d145 3
d150 1
a150 1
#ifndef offsetof
d783 1
a783 1
     to be allocated on an objalloc anyway... */
d1045 1
a1045 1
     to be allocated on an objalloc anyway... */
d1128 1
a1128 1
	 below extended_names on the objalloc... */
d1731 1
a1731 1
  /* We put the symbol names on the arch objalloc, and then discard
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d133 2
d177 1
a177 2
							     const char *,
							     bfd *member));
d399 1
a399 1
     specify an extended name table, either the first char of the
d415 2
a416 4
  else if (hdr.ar_name[0] == '#'
	   && hdr.ar_name[1] == '1'
	   && hdr.ar_name[2] == '/'
	   && isdigit ((unsigned char) hdr.ar_name[3]))
d443 3
a445 3
      char *e;
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
      if (e == NULL)
d447 9
a455 12
          e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
	  if (e == NULL)
            e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
	}

      if (e != NULL)
	namelen = e - hdr.ar_name;
      else
	{
	  /* If we didn't find a termination character, then the name
	     must be the entire field.  */
	  namelen = ar_maxnamelen (abfd);
a645 2
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
a652 2
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
d1172 1
a1172 1
     bfd *abfd ATTRIBUTE_UNUSED;
a1176 11

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
a1333 8
#ifndef HAVE_GETUID
#define getuid() 0
#endif

#ifndef HAVE_GETGID
#define getgid() 0
#endif

d1336 1
a1336 2
   The filename field of the ar_hdr will NOT be initialized.  If member
   is set, and it's an in-memory bfd, we fake it. */
d1339 1
a1339 1
bfd_ar_hdr_from_filesystem (abfd, filename, member)
a1341 1
     bfd *member;
d1348 1
a1348 11
  if (member && (member->flags & BFD_IN_MEMORY) != 0)
    {
      /* Assume we just "made" the member, and fake it */
      struct bfd_in_memory *bim = (struct bfd_in_memory *) member->iostream;
      time(&status.st_mtime);
      status.st_uid = getuid();
      status.st_gid = getgid();
      status.st_mode = 0644;
      status.st_size = bim->size;
    }
  else if (stat (filename, &status) != 0)
a1392 2
struct ar_hdr *bfd_special_undocumented_glue PARAMS ((bfd *, const char *));

d1396 1
a1396 1
     const char *filename;
d1398 1
a1398 1
  struct areltdata *ar_elt = bfd_ar_hdr_from_filesystem (abfd, filename, 0);
a1486 11
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

a1526 11
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (pathname, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && pathname[0] != '\0' && pathname[1] == ':')
      filename = pathname + 1;
  }
#endif

d1580 1
a1580 1
	    (PTR) bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1693 1
a1693 1
	    (_("Warning: writing archive was slow: rewriting timestamp\n"));
d1881 1
d1884 4
d1964 1
a1964 1
      perror (_("Reading archive file mod timestamp"));
d1988 1
a1988 1
      perror (_("Writing updated armap timestamp"));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
d155 4
a158 2
   to the front of the contents!  */
struct ar_cache {
d167 1
a167 1
#define arch_eltdata(bfd) ((struct areltdata *) ((bfd)->arelt_data))
d319 1
a319 1
   the string table.  */
d329 1
a329 1
     the next region, but I'm too lazy.  */
d331 1
a331 1
  /* Skip first char, which is '/' in SVR4 or ' ' in some other variants.  */
d414 1
a414 1
     Only implemented for reading, so far!  */
d443 1
a443 1
	 spaces, so only look for ' ' if we don't find '/'.  */
d449 1
a449 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d451 1
a451 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d529 1
a529 1
  /* Huh?  */
d563 1
d598 1
a598 1
	 BSD-4.4-style element with a long odd size.  */
d606 1
d633 1
a633 1
     involves a cast, we can't do it as the left operand of assignment.  */
d740 1
a740 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d785 1
a785 1
  /* Pad to an even boundary if you have to.  */
d789 1
a789 1
     to be allocated on an objalloc anyway...  */
d794 1
a794 2
/* Returns false on error, true otherwise.  */

d806 1
a806 1
  unsigned int nsymz;		/* Number of symbols in armap.  */
d815 1
a815 1
  bfd_release (abfd, (PTR) mapdata);	/* Don't need it any more.  */
d824 1
a824 1
     in big endian format, nomatter the host or target.  */
d839 1
a839 1
      /* This looks dangerous, let's do it the other way around.  */
d847 1
a847 1
     bsd-style one in core all at once, for simplicity.  */
d858 1
a858 1
  /* Allocate and read in the raw offsets.  */
d870 1
a870 1
  /* OK, build the carsyms.  */
d883 1
a883 1
  /* Pad to an even boundary if you have to.  */
d886 1
d890 2
a891 1
  /* Check for a second archive header (as used by PE).  */
d897 1
a897 1
    if (tmp != NULL)
d900 1
a900 1
	    && tmp->arch_header[1] == ' ')
d903 1
a903 1
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~1;
d955 1
a955 1
   This flavour is used by hp300hpux.  */
d978 1
a978 1
  /* The archive has at least 16 bytes in it.  */
d1027 1
a1027 1
  /* Skip sym count and string sz.  */
d1047 1
a1047 1
  /* Pad to an even boundary if you have to.  */
d1051 1
a1051 1
     to be allocated on an objalloc anyway...  */
d1064 1
a1064 3
  extended the format by using the prefix // for the special element.  */

/* Returns false on error, true otherwise.  */
d1066 1
d1120 6
a1125 7
	for (; temp < limit; ++temp)
	  {
	    if (*temp == '\012')
	      temp[temp[-1] == '/' ? -1 : 0] = '\0';
	    if (*temp == '\\')
	      *temp = '/';
	  }
d1128 1
a1128 1
      /* Pad to an even boundary if you have to.  */
d1134 2
a1135 4
	 below extended_names on the objalloc...  */
#if 0
      bfd_release (abfd, namedata);
#endif
d1143 1
a1143 2
   semicolon.  */

d1186 1
d1191 1
a1191 1
    if (filename == NULL || (bslash != NULL && bslash > filename))
d1253 1
a1253 1
  /* Figure out how long the table should be.  */
d1321 1
a1321 1
	     generalise this hack.  */
d1333 1
a1333 1
	     cases where you may safely use sprintf).  */
d1336 1
a1336 1
	     sprintf but not all implementations get this right.  */
a1353 18
#ifdef HPUX_LARGE_AR_IDS
/* Function to encode large UID/GID values according to HP.  */

static void
hpux_uid_gid_encode (str, id)
     char str[6];
     long int id;
{
  int cnt;

  str[5] = '@@' + (id & 3);
  id >>= 2;

  for (cnt = 4; cnt >= 0; ++cnt, id >>= 6)
    str[cnt] = ' ' + (id & 0x3f);
}
#endif	/* HPUX_LARGE_AR_IDS */

d1365 1
a1365 1
   is set, and it's an in-memory bfd, we fake it.  */
d1380 1
a1380 1
      /* Assume we just "made" the member, and fake it.  */
d1382 3
a1384 3
      time (&status.st_mtime);
      status.st_uid = getuid ();
      status.st_gid = getgid ();
d1400 1
a1400 1
  /* ar headers are space padded, not null padded!  */
d1405 1
a1405 1
  /* Goddamned sprintf doesn't permit MAXIMUM field lengths.  */
d1407 1
a1407 15
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_uid > 99999)
    hpux_uid_gid_encode (hdr->ar_gid, (long) status.st_uid);
  else
#endif
    sprintf ((hdr->ar_uid), "%ld", (long) status.st_uid);
#ifdef HPUX_LARGE_AR_IDS
  /* HP has a very "special" way to handle UID/GID's with numeric values
     > 99999.  */
  if (status.st_gid > 99999)
    hpux_uid_gid_encode (hdr->ar_uid, (long) status.st_gid);
  else
#endif
d1413 1
a1413 1
     IO operations.  */
d1429 3
a1431 3
   undocumented, it's undocumented.  You may think that it would take
   a strong stomach to write this, and it does, but it takes even a
   stronger stomach to try to code around such a thing!  */
a1445 1
/* Analogous to stat call.  */
d1447 1
d1464 3
a1466 30
#define foo(arelt, stelt, size)				\
  buf->stelt = strtol (hdr->arelt, &aloser, size);	\
  if (aloser == hdr->arelt)	      			\
    return -1;

  /* Some platforms support special notations for large IDs.  */
#ifdef HPUX_LARGE_AR_IDS
# define foo2(arelt, stelt, size)					\
  if (hdr->arelt[5] == ' ')						\
    {									\
      foo (arelt, stelt, size);						\
    }									\
  else									\
    {									\
      int cnt;								\
      for (buf->stelt = cnt = 0; cnt < 5; ++cnt)			\
	{								\
	  if (hdr->arelt[cnt] < ' ' || hdr->arelt[cnt] > ' ' + 0x3f)	\
	    return -1;							\
	  buf->stelt <<= 6;						\
	  buf->stelt += hdr->arelt[cnt] - ' ';				\
	}								\
      if (hdr->arelt[5] < '@@' || hdr->arelt[5] > '@@' + 3)		\
	return -1;							\
      buf->stelt <<= 2;							\
      buf->stelt += hdr->arelt[5] - '@@';				\
    }
#else
# define foo2(arelt, stelt, size) foo (arelt, stelt, size)
#endif
d1469 2
a1470 2
  foo2 (ar_uid, st_uid, 10);
  foo2 (ar_gid, st_gid, 10);
d1487 1
a1487 1
     intel's release is out the door.  */
d1533 1
a1533 1
    if (filename == NULL || (bslash != NULL && bslash > filename))
d1567 1
a1567 1
   bsd ar.  */
d1584 1
a1584 1
    if (filename == NULL || (bslash != NULL && bslash > filename))
d1615 1
a1615 1
/* The BFD is open for write and has its format set to bfd_archive.  */
d1626 1
a1626 1
  boolean hasobjects = false;	/* If no .o's, don't bother to make a map.  */
a1635 5
      /* This check is checking the bfds for the objects we're reading
	 from (which are usually either an object file or archive on
	 disk), not the archive entries we're writing to.  We don't
	 actually create bfds for the archive members, we just copy
	 them byte-wise when we write out the archive.  */
d1648 1
a1648 1
	  /* Put in the file name.  */
d1655 1
a1655 1
	{			/* Don't bother if we won't make a map!  */
d1715 1
a1715 1
      /* Write ar header.  */
d1765 1
a1765 1
/* Note that the namidx for the first symbol is 0.  */
d1783 1
a1783 1
  /* Dunno if this is the best place for this info...  */
d1798 2
a1799 1
  /* Drop all the files called __.SYMDEF, we're going to make our own.  */
d1804 1
a1804 1
  /* Map over each element.  */
d1835 1
a1835 2
	      /* Now map over all the symbols, picking out the ones we
                 want.  */
d1850 1
a1850 1
		      /* This symbol will go into the archive header.  */
d1889 1
a1889 1
  /* OK, now we have collected all the data, let's write them out.  */
d1924 1
a1924 1
  /* Include 8 bytes to store ranlibsize and stringsize in output.  */
d1981 1
a1981 1
  /* Now write the strings themselves.  */
d1994 1
a1994 1
     bug-compatible for sun's ar we use a null.  */
d2024 1
a2024 3

      /* Can't read mod time for some reason.  */
      return true;
d2027 1
a2027 2
    /* OK by the linker's rules.  */
    return true;
d2048 1
a2048 3

      /* Some error while writing.  */
      return true;
d2051 1
a2051 2
  /* We updated the timestamp successfully.  */
  return false;
d2077 1
a2077 1
     archive * the number of bytes in a int, + an int for the count.  */
d2091 1
a2091 1
  /* Work out where the first object file will go in the archive.  */
d2101 1
a2101 1
  /* This, at least, is what Intel coff sets the values to.  */
d2111 1
a2111 1
  /* Write the ar header for this item and the number of symbols.  */
d2129 2
a2130 2
      /* For each symbol which is used defined in this object, write
	 out the object file's address in the archive.  */
d2132 1
a2132 1
      while (count < symbol_count && ((bfd *) (map[count]).pos) == current)
d2137 1
a2137 1
      /* Add size of this archive entry.  */
d2140 1
a2140 1
      /* Remember aboout the even alignment.  */
d2145 1
a2145 1
  /* Now write the strings themselves.  */
d2155 1
a2155 1
     bug-compatible for arc960 we use a null.  */
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d135 1
a135 1
#include "safe-ctype.h"
d145 6
d169 8
a176 12
static char *get_extended_arelt_filename
  PARAMS ((bfd *arch, const char *name));
static bfd_boolean do_slurp_bsd_armap
  PARAMS ((bfd *abfd));
static bfd_boolean do_slurp_coff_armap
  PARAMS ((bfd *abfd));
bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *abfd));
static const char *normalize
  PARAMS ((bfd *, const char *file));
static struct areltdata *bfd_ar_hdr_from_filesystem
  PARAMS ((bfd *abfd, const char *, bfd *member));
d178 1
a178 1
bfd_boolean
d182 2
a183 1
  bfd_size_type amt = sizeof (struct artdata);
a184 1
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
d186 1
a186 1
    return FALSE;
d194 1
a194 1
  return TRUE;
d255 1
a255 1
	bfd_boolean bfd_set_archive_head(bfd *output, bfd *new_head);
d262 1
a262 1
bfd_boolean
d269 1
a269 1
  return TRUE;
d288 1
a288 1
bfd_boolean
d293 3
a295 1
  bfd_size_type amt = sizeof (struct ar_cache);
a296 1
  struct ar_cache *new_cache = (struct ar_cache *) bfd_zalloc (arch_bfd, amt);
d298 1
a298 1
    return FALSE;
d314 1
a314 1
  return TRUE;
d367 1
a367 1
  size_t parsed_size;
d370 2
a371 2
  bfd_size_type namelen = 0;
  bfd_size_type allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);
d374 1
a374 1
  if (bfd_bread ((PTR) hdrp, (bfd_size_type) sizeof (struct ar_hdr), abfd)
d417 1
a417 1
	   && ISDIGIT (hdr.ar_name[3]))
d430 1
a430 1
      if (bfd_bread (filename, namelen, abfd) != namelen)
d445 1
a445 1
      e = (char *) memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d448 1
a448 1
	  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d450 1
a450 1
	    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d485 1
a485 1
	memcpy (ared->filename, hdr.ar_name, (size_t) namelen);
a609 1
  bfd_size_type amt;
d611 3
a613 1
  if (bfd_bread ((PTR) armag, (bfd_size_type) SARMAG, abfd) != SARMAG)
d629 4
a632 1
  tdata_hold = bfd_ardata (abfd);
a633 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d635 1
a635 4
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }
d644 1
a644 2
  if (!BFD_SEND (abfd, _bfd_slurp_armap, (abfd))
      || !BFD_SEND (abfd, _bfd_slurp_extended_name_table, (abfd)))
d646 2
d650 5
d656 3
a658 1
      bfd_ardata (abfd) = tdata_hold;
d680 1
a680 1
	  bfd_boolean fail;
d682 2
a683 2
	  first->target_defaulted = FALSE;
	  fail = FALSE;
a686 5
#if 0
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's close to impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
d689 2
a690 3
#endif
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
d693 3
a695 1
	  /* And we ought to close `first' here too.  */
d705 1
a705 1
   changing some H_GET_32 to H_GET_64.  */
d719 1
a719 1
/* Returns FALSE on error, TRUE otherwise */
d721 1
a721 1
static bfd_boolean
d730 1
a730 1
  bfd_size_type parsed_size, amt;
d735 1
a735 1
    return FALSE;
d741 1
a741 1
    return FALSE;
d743 1
a743 1
  if (bfd_bread ((PTR) raw_armap, parsed_size, abfd) != parsed_size)
d749 1
a749 1
      return FALSE;
d752 1
a752 1
  ardata->symdef_count = H_GET_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;
d767 3
a769 2
  amt = (bfd_size_type) ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d771 1
a771 1
    return FALSE;
d777 2
a778 2
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d787 2
a788 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d791 1
a791 1
/* Returns FALSE on error, TRUE otherwise.  */
d793 1
a793 1
static bfd_boolean
d801 1
a801 1
  bfd_size_type stringsize;
d804 1
a804 1
  bfd_size_type nsymz;		/* Number of symbols in armap.  */
d807 1
a807 2
  bfd_size_type carsym_size, ptrsize;
  unsigned int i;
d811 1
a811 1
    return FALSE;
d815 1
a815 1
  if (bfd_bread ((PTR) int_buf, (bfd_size_type) 4, abfd) != 4)
d819 1
a819 1
      return FALSE;
d852 1
a852 1
    return FALSE;
d860 2
a861 2
  if (bfd_bread ((PTR) raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread ((PTR) stringbase, stringsize, abfd) != stringsize))
d884 1
a884 1
  bfd_has_map (abfd) = TRUE;
d891 1
a891 1
    bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET);
d899 1
a899 1
	      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~(unsigned) 1;
d905 1
a905 1
  return TRUE;
d911 1
a911 1
  return FALSE;
d915 1
a915 1
   Returns FALSE on error, TRUE otherwise */
d917 1
a917 1
bfd_boolean
d922 1
a922 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d925 1
a925 1
    return TRUE;
d927 1
a927 1
    return FALSE;
d929 2
a930 2
  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;
d939 1
a939 4
      /* 64bit ELF (Irix 6) archive.  */
#ifdef BFD64
      return bfd_elf64_archive_slurp_armap (abfd);
#else
d941 1
a941 2
      return FALSE;
#endif
d944 2
a945 2
  bfd_has_map (abfd) = FALSE;
  return TRUE;
d948 1
a948 1
/* Returns FALSE on error, TRUE otherwise */
d955 1
a955 1
bfd_boolean
a965 1
  bfd_size_type amt;
d967 1
a967 1
  int i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d970 1
a970 1
    return TRUE;
d972 1
a972 1
    return FALSE;
d975 2
a976 2
  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;
d984 2
a985 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d990 1
a990 1
    return FALSE;
d992 1
a992 2
  amt = mapdata->parsed_size;
  raw_armap = (bfd_byte *) bfd_zalloc (abfd, amt);
d997 1
a997 1
      return FALSE;
d1000 2
a1001 1
  if (bfd_bread ((PTR) raw_armap, amt, abfd) != amt)
d1010 1
a1010 1
  ardata->symdef_count = H_GET_16 (abfd, (PTR) raw_armap);
d1022 1
a1022 1
  stringsize = H_GET_32 (abfd, raw_armap + HPUX_SYMDEF_COUNT_SIZE);
d1028 3
a1030 2
  amt = (bfd_size_type) ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d1032 1
a1032 1
    return FALSE;
d1038 2
a1039 2
      set->name = H_GET_32 (abfd, rbase) + stringbase;
      set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);
d1048 2
a1049 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d1062 1
a1062 1
/* Returns FALSE on error, TRUE otherwise.  */
d1064 1
a1064 1
bfd_boolean
a1069 1
  bfd_size_type amt;
d1072 1
a1072 1
     we probably don't want to return TRUE.  */
d1074 1
a1074 1
  if (bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd) == 16)
d1076 2
a1077 2
      if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
	return FALSE;
d1083 1
a1083 1
	  return TRUE;
d1088 1
a1088 1
	return FALSE;
d1090 2
a1091 2
      amt = namedata->parsed_size;
      bfd_ardata (abfd)->extended_names = bfd_zalloc (abfd, amt);
d1096 1
a1096 1
	  return FALSE;
d1099 2
a1100 1
      if (bfd_bread ((PTR) bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1137 1
a1137 1
  return TRUE;
d1150 2
a1151 2
  const char *first;
  const char *last;
d1169 1
a1169 1
  copy = (char *) bfd_alloc (abfd, (bfd_size_type) (last - first + 1));
d1207 1
a1207 1
bfd_boolean
d1215 1
a1215 1
  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);
d1220 1
a1220 1
bfd_boolean
d1228 1
a1228 1
  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);
d1235 1
a1235 1
   further massage.  Returns TRUE if it ran successfully, FALSE if
d1239 1
a1239 1
bfd_boolean
d1242 1
a1242 1
     bfd_boolean trailing_slash;
d1247 1
a1247 1
  bfd_size_type total_namelen = 0;
d1261 1
a1261 1
	return FALSE;
d1297 1
a1297 1
    return TRUE;
d1301 1
a1301 1
    return FALSE;
d1314 1
a1314 1
	return FALSE;
d1349 1
a1349 1
  return TRUE;
a1394 1
  bfd_size_type amt;
d1412 2
a1413 2
  amt = sizeof (struct ar_hdr) + sizeof (struct areltdata);
  ared = (struct areltdata *) bfd_zalloc (abfd, amt);
d1465 1
a1465 2
struct ar_hdr *bfd_special_undocumented_glue
  PARAMS ((bfd *, const char *));
d1540 1
a1540 1
     const char *pathname;
d1580 1
a1580 1
     const char *pathname;
d1584 3
a1586 3
  size_t length;
  const char *filename = strrchr (pathname, '/');
  size_t maxlen = ar_maxnamelen (abfd);
d1631 1
a1631 1
     const char *pathname;
d1635 3
a1637 3
  size_t length;
  const char *filename = strrchr (pathname, '/');
  size_t maxlen = ar_maxnamelen (abfd);
d1676 1
a1676 1
bfd_boolean
d1684 2
a1685 3
  bfd_boolean makemap = bfd_has_map (arch);
  /* If no .o's, don't bother to make a map.  */
  bfd_boolean hasobjects = FALSE;
d1703 1
a1703 1
	  return FALSE;
d1710 1
a1710 1
	    return FALSE;
d1725 1
a1725 1
	    hasobjects = TRUE;
d1731 1
a1731 1
    return FALSE;
d1734 1
a1734 1
    return FALSE;
d1736 1
a1736 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), (bfd_size_type) SARMAG, arch);
d1738 1
a1738 1
  wrote = bfd_bwrite (ARMAG, (bfd_size_type) SARMAG, arch);
d1741 1
a1741 1
    return FALSE;
d1745 2
a1746 2
      if (! _bfd_compute_and_write_armap (arch, (unsigned int) elength))
	return FALSE;
d1757 1
a1757 1
	       (int) ((elength + 1) & ~(bfd_size_type) 1));
d1762 1
a1762 1
      if ((bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d1764 2
a1765 2
	  || bfd_bwrite (etable, elength, arch) != elength)
	return FALSE;
d1768 2
a1769 2
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
	    return FALSE;
d1780 2
a1781 3
      if (bfd_bwrite ((PTR) hdr, (bfd_size_type) sizeof (*hdr), arch)
	  != sizeof (*hdr))
	return FALSE;
d1783 1
a1783 1
	return FALSE;
d1790 1
a1790 1
	  if (bfd_bread (buffer, (bfd_size_type) amt, current) != amt)
d1794 1
a1794 1
	      return FALSE;
d1796 2
a1797 2
	  if (bfd_bwrite (buffer, (bfd_size_type) amt, arch) != amt)
	    return FALSE;
d1802 2
a1803 2
	  if (bfd_bwrite ("\012", (bfd_size_type) 1, arch) != 1)
	    return FALSE;
d1826 1
a1826 1
  return TRUE;
d1831 1
a1831 1
bfd_boolean
d1840 2
a1841 2
  unsigned int orl_max = 1024;		/* fine initial default */
  unsigned int orl_count = 0;
d1845 1
a1845 2
  bfd_boolean ret;
  bfd_size_type amt;
d1852 1
a1852 2
  amt = (bfd_size_type) orl_max * sizeof (struct orl);
  map = (struct orl *) bfd_malloc (amt);
d1858 1
a1858 1
  first_name = bfd_alloc (arch, (bfd_size_type) 1);
d1872 2
a1873 2
      if (bfd_check_format (current, bfd_object)
	  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)
d1890 1
a1890 1
		  syms = (asymbol **) bfd_malloc ((bfd_size_type) syms_max);
d1911 1
a1911 1
		      bfd_size_type namelen;
d1918 3
a1920 2
			  amt = (bfd_size_type) orl_max * sizeof (struct orl);
			  new_map = (struct orl *) bfd_realloc (map, amt);
d1928 3
a1930 2
		      amt = sizeof (char *);
		      map[orl_count].name = (char **) bfd_alloc (arch, amt);
d1937 2
a1938 2
		      map[orl_count].u.abfd = current;
		      map[orl_count].namidx = stridx;
d1974 1
a1974 1
  return FALSE;
d1977 1
a1977 1
bfd_boolean
d2016 1
a2016 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d2018 4
a2021 4
    return FALSE;
  H_PUT_32 (arch, ranlibsize, temp);
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
    return FALSE;
d2027 1
a2027 1
      if (map[count].u.abfd != last_elt)
d2035 1
a2035 1
	  while (current != map[count].u.abfd);
d2039 4
a2042 5
      H_PUT_32 (arch, map[count].namidx, buf);
      H_PUT_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);
      if (bfd_bwrite (buf, (bfd_size_type) BSD_SYMDEF_SIZE, arch)
	  != BSD_SYMDEF_SIZE)
	return FALSE;
d2046 3
a2048 3
  H_PUT_32 (arch, stringsize, temp);
  if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), arch) != sizeof (temp))
    return FALSE;
d2053 2
a2054 2
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
	return FALSE;
d2061 2
a2062 2
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
	return FALSE;
d2065 1
a2065 1
  return TRUE;
d2071 2
a2072 2
   Return TRUE if the timestamp was OK, or an unusual problem happened.
   Return FALSE if we updated the timestamp.  */
d2074 1
a2074 1
bfd_boolean
d2087 1
a2087 1
      bfd_perror (_("Reading archive file mod timestamp"));
d2090 1
a2090 1
      return TRUE;
d2094 1
a2094 1
    return TRUE;
d2110 1
a2110 1
      || (bfd_bwrite (hdr.ar_date, (bfd_size_type) sizeof (hdr.ar_date), arch)
d2113 2
a2114 1
      bfd_perror (_("Writing updated armap timestamp"));
d2117 1
a2117 1
      return TRUE;
d2121 1
a2121 1
  return FALSE;
d2138 1
a2138 1
bfd_boolean
d2147 1
a2147 1
     archive * the number of bytes in an int, + an int for the count.  */
d2151 1
a2151 1
  unsigned int archive_member_file_ptr;
d2183 1
a2183 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
d2185 1
a2185 1
    return FALSE;
d2187 1
a2187 2
  if (!bfd_write_bigendian_4byte_int (arch, symbol_count))
    return FALSE;
d2202 1
a2202 1
      while (count < symbol_count && map[count].u.abfd == current)
d2204 1
a2204 2
	  if (!bfd_write_bigendian_4byte_int (arch, archive_member_file_ptr))
	    return FALSE;
d2220 2
a2221 2
      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
	return FALSE;
d2228 2
a2229 2
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
	return FALSE;
d2232 1
a2232 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d161 1
a161 1
#define arch_hdr(bfd) ((struct ar_hdr *) arch_eltdata(bfd)->arch_header)
d163 12
d177 2
a178 1
_bfd_generic_mkarchive (bfd *abfd)
d182 1
a182 1
  abfd->tdata.aout_ar_data = bfd_zalloc (abfd, amt);
d200 1
a200 2
	symindex bfd_get_next_mapent
	  (bfd *abfd, symindex previous, carsym **sym);
d217 4
a220 1
bfd_get_next_mapent (bfd *abfd, symindex prev, carsym **entry)
d242 2
a243 1
_bfd_create_empty_archive_element_shell (bfd *obfd)
d253 1
a253 1
	bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
d261 3
a263 1
bfd_set_archive_head (bfd *output_archive, bfd *new_head)
d265 1
d271 3
a273 1
_bfd_look_for_bfd_in_cache (bfd *arch_bfd, file_ptr filepos)
d287 3
a289 1
_bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)
d293 1
a293 1
  struct ar_cache *new_cache = bfd_zalloc (arch_bfd, amt);
d299 1
a299 1
  new_cache->next = NULL;
d318 3
a320 1
get_extended_arelt_filename (bfd *arch, const char *name)
d347 3
a349 2
void *
_bfd_generic_read_ar_hdr (bfd *abfd)
d351 1
a351 1
  return _bfd_generic_read_ar_hdr_mag (abfd, NULL);
d357 4
a360 2
void *
_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
d371 2
a372 1
  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))
d442 1
a442 1
      e = memchr (hdr.ar_name, '\0', ar_maxnamelen (abfd));
d445 1
a445 1
	  e = memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));
d447 1
a447 1
	    e = memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));
d472 1
a472 1
  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));
d482 1
a482 1
	memcpy (ared->filename, hdr.ar_name, namelen);
d486 1
a486 1
  return ared;
d494 3
a496 1
_bfd_get_elt_at_filepos (bfd *archive, file_ptr filepos)
d508 1
a508 1
  if ((new_areldata = _bfd_read_ar_hdr (archive)) == NULL)
d514 1
a514 1
      bfd_release (archive, new_areldata);
d519 1
a519 1
  n_nfd->arelt_data = new_areldata;
d526 2
a527 2
  bfd_release (archive, n_nfd);
  bfd_release (archive, new_areldata);
d535 3
a537 1
_bfd_generic_get_elt_at_index (bfd *abfd, symindex index)
d550 1
a550 1
	bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
d562 3
a564 1
bfd_openr_next_archived_file (bfd *archive, bfd *last_file)
d574 3
a576 1
		   openr_next_archived_file, (archive, last_file));
d580 3
a582 1
bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
d602 2
a603 1
bfd_generic_archive_p (bfd *abfd)
d609 1
a609 1
  if (bfd_bread (armag, SARMAG, abfd) != SARMAG)
d628 1
a628 1
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
d667 1
a667 1
      first = bfd_openr_next_archived_file (abfd, NULL);
d682 1
a682 1
	      bfd_close (first);
d716 2
a717 1
do_slurp_bsd_armap (bfd *abfd)
d727 1
a727 1
  mapdata = _bfd_read_ar_hdr (abfd);
d731 1
a731 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d733 2
a734 2
  raw_armap = bfd_zalloc (abfd, parsed_size);
  if (raw_armap == NULL)
d737 1
a737 1
  if (bfd_bread (raw_armap, parsed_size, abfd) != parsed_size)
d742 1
a742 1
      bfd_release (abfd, raw_armap);
d761 2
a762 2
  amt = ardata->symdef_count * sizeof (carsym);
  ardata->symdefs = bfd_alloc (abfd, amt);
d787 2
a788 1
do_slurp_coff_armap (bfd *abfd)
d798 1
a798 1
  bfd_vma (*swap) (const void *);
d803 1
a803 1
  mapdata = _bfd_read_ar_hdr (abfd);
d807 1
a807 1
  bfd_release (abfd, mapdata);	/* Don't need it any more.  */
d809 1
a809 1
  if (bfd_bread (int_buf, 4, abfd) != 4)
d818 1
a818 1
  nsymz = bfd_getb32 (int_buf);
d832 1
a832 1
      nsymz = bfd_getl32 (int_buf);
d844 1
a844 1
  ardata->symdefs = bfd_zalloc (abfd, carsym_size + stringsize + 1);
d851 1
a851 1
  raw_armap = bfd_alloc (abfd, ptrsize);
d854 2
a855 2
  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))
d866 1
a866 1
      carsyms->file_offset = swap ((bfd_byte *) rawptr);
d879 1
a879 1
  bfd_release (abfd, raw_armap);
d886 1
a886 1
    tmp = _bfd_read_ar_hdr (abfd);
d902 1
a902 1
  bfd_release (abfd, raw_armap);
d904 1
a904 1
  bfd_release (abfd, (ardata)->symdefs);
d912 2
a913 1
bfd_slurp_armap (bfd *abfd)
d916 1
a916 1
  int i = bfd_bread (nextname, 16, abfd);
a934 1
      extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
d954 2
a955 1
bfd_slurp_bsd_armap_f2 (bfd *abfd)
d966 1
a966 1
  int i = bfd_bread (nextname, 16, abfd);
d987 1
a987 1
  mapdata = _bfd_read_ar_hdr (abfd);
d992 1
a992 1
  raw_armap = bfd_zalloc (abfd, amt);
d996 1
a996 1
      bfd_release (abfd, mapdata);
d1000 1
a1000 1
  if (bfd_bread (raw_armap, amt, abfd) != amt)
d1005 1
a1005 1
      bfd_release (abfd, raw_armap);
d1009 1
a1009 1
  ardata->symdef_count = H_GET_16 (abfd, raw_armap);
d1027 2
a1028 2
  amt = ardata->symdef_count * BSD_SYMDEF_SIZE;
  ardata->symdefs = bfd_alloc (abfd, amt);
d1063 2
a1064 1
_bfd_slurp_extended_name_table (bfd *abfd)
d1073 1
a1073 1
  if (bfd_bread (nextname, 16, abfd) == 16)
d1085 1
a1085 1
      namedata = _bfd_read_ar_hdr (abfd);
d1094 1
a1094 1
	  bfd_release (abfd, namedata);
d1098 1
a1098 1
      if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)
d1102 1
a1102 1
	  bfd_release (abfd, (bfd_ardata (abfd)->extended_names));
d1144 3
a1146 1
normalize (bfd *abfd, const char *file)
d1167 1
a1167 1
  copy = bfd_alloc (abfd, last - first + 1);
d1179 3
a1181 1
normalize (bfd *abfd ATTRIBUTE_UNUSED, const char *file)
d1195 1
a1195 1
  if (filename != NULL)
d1206 5
a1210 4
_bfd_archive_bsd_construct_extended_name_table (bfd *abfd,
						char **tabloc,
						bfd_size_type *tablen,
						const char **name)
d1219 5
a1223 4
_bfd_archive_coff_construct_extended_name_table (bfd *abfd,
						 char **tabloc,
						 bfd_size_type *tablen,
						 const char **name)
d1238 5
a1242 4
_bfd_construct_extended_name_table (bfd *abfd,
				    bfd_boolean trailing_slash,
				    char **tabloc,
				    bfd_size_type *tablen)
d1356 3
a1358 1
hpux_uid_gid_encode (char str[6], long int id)
d1384 4
a1387 1
bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
d1398 1
a1398 1
      struct bfd_in_memory *bim = member->iostream;
d1412 1
a1412 1
  ared = bfd_zalloc (abfd, amt);
d1418 1
a1418 1
  memset (hdr, ' ', sizeof (struct ar_hdr));
d1464 2
a1465 1
struct ar_hdr *bfd_special_undocumented_glue (bfd *, const char *);
d1468 3
a1470 1
bfd_special_undocumented_glue (bfd *abfd, const char *filename)
d1481 3
a1483 1
bfd_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
d1538 4
a1541 1
bfd_dont_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1578 4
a1581 1
bfd_bsd_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1629 4
a1632 1
bfd_gnu_truncate_arname (bfd *abfd, const char *pathname, char *arhdr)
d1677 2
a1678 1
_bfd_write_archive_contents (bfd *arch)
d1709 1
a1709 1
	    bfd_ar_hdr_from_filesystem (arch, current->filename, current);
d1714 3
a1716 2
	  BFD_SEND (arch, _bfd_truncate_arname,
		    (arch, current->filename, (char *) arch_hdr (current)));
d1737 1
a1737 1
  wrote = bfd_bwrite (BFD_GNU960_ARMAG (arch), SARMAG, arch);
d1739 1
a1739 1
  wrote = bfd_bwrite (ARMAG, SARMAG, arch);
d1754 1
a1754 1
      memset (&hdr, 0, sizeof (struct ar_hdr));
d1763 1
a1763 1
      if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d1769 1
a1769 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d1781 1
a1781 1
      if (bfd_bwrite (hdr, sizeof (*hdr), arch)
d1792 1
a1792 1
	  if (bfd_bread (buffer, amt, current) != amt)
d1798 1
a1798 1
	  if (bfd_bwrite (buffer, amt, arch) != amt)
d1804 1
a1804 1
	  if (bfd_bwrite ("\012", 1, arch) != 1)
d1834 3
a1836 1
_bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
d1855 2
a1856 2
  amt = orl_max * sizeof (struct orl);
  map = bfd_malloc (amt);
d1862 1
a1862 1
  first_name = bfd_alloc (arch, 1);
d1873 1
a1873 1
       current != NULL;
d1894 1
a1894 1
		  syms = bfd_malloc (syms_max);
d1922 3
a1924 3
			  amt = orl_max * sizeof (struct orl);
			  new_map = bfd_realloc (map, amt);
			  if (new_map == NULL)
d1932 1
a1932 1
		      map[orl_count].name = bfd_alloc (arch, amt);
d1980 6
a1985 5
bsd_write_armap (bfd *arch,
		 unsigned int elength,
		 struct orl *map,
		 unsigned int orl_count,
		 int stridx)
d2004 1
a2004 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2018 1
a2018 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2022 1
a2022 1
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
d2043 1
a2043 1
      if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)
d2050 1
a2050 1
  if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))
d2056 1
a2056 1
      if (bfd_bwrite (*map[count].name, len, arch) != len)
d2064 1
a2064 1
      if (bfd_bwrite ("", 1, arch) != 1)
d2078 2
a2079 1
_bfd_archive_bsd_update_armap_timestamp (bfd *arch)
d2113 1
a2113 1
      || (bfd_bwrite (hdr.ar_date, sizeof (hdr.ar_date), arch)
d2141 6
a2146 5
coff_write_armap (bfd *arch,
		  unsigned int elength,
		  struct orl *map,
		  unsigned int symbol_count,
		  int stridx)
d2169 1
a2169 1
  memset (&hdr, 0, sizeof (struct ar_hdr));
d2185 1
a2185 1
  if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
d2200 1
a2200 1
  while (current != NULL && count < symbol_count)
d2212 2
a2213 1
      archive_member_file_ptr += arelt_size (current) + sizeof (struct ar_hdr);
d2224 1
a2224 1
      if (bfd_bwrite (*map[count].name, len, arch) != len)
d2232 1
a2232 1
      if (bfd_bwrite ("", 1, arch) != 1)
@


