head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.14
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.12
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.10
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.10
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.8
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.18
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.16
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.14
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.16.0.6
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.4
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	new-binutils:1.8.0.14
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.01.13.20.05.01;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	g6XJnUzGzjQTJJPi;

1.22
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.12.12.37.40;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.31.22.44.50;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.05.19.41.32;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.02.20.45.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.30.21.10.51;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.30.21.06.47;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.17.20.55.08;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.17.20.50.13;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.02.21.52.26;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.09.22.29.25;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.12.19.11.12;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.03.33.02;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.28.22.41.42;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.28.18.24.02;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.09.06.19.28.20;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.09.04.19.00.28;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.14.20.41.24;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.44.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.45;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.45;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.31;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.41;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.24;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.18.47;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.37;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.06.43;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.23.09;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.12;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.20;	author miod;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Generate a PT_PHDR entry for static PIE binaries.  Modern GDB needs this to
do some sanity checking while it determines the load base.

ok kurt@@
@
text
@/* ELF executable support for BFD.

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*  SECTION

	ELF backends

	BFD support for ELF formats is being worked on.
	Currently, the best supported back ends are for sparc and i386
	(running svr4 or Solaris 2).

	Documentation of the internals of the support code still needs
	to be written.  The code is changing quickly enough that we
	haven't bothered yet.  */

/* For sparc64-cross-sparc32.  */
#define _SYSCALL32
#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libbfd.h"
#define ARCH_SIZE 0
#include "elf-bfd.h"
#include "libiberty.h"

static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct bfd_strtab_hash **, int) ;
static bfd_boolean elfcore_read_notes (bfd *, file_ptr, bfd_size_type) ;

/* Swap version information in and out.  The version information is
   currently size independent.  If that ever changes, this code will
   need to move into elfcode.h.  */

/* Swap in a Verdef structure.  */

void
_bfd_elf_swap_verdef_in (bfd *abfd,
			 const Elf_External_Verdef *src,
			 Elf_Internal_Verdef *dst)
{
  dst->vd_version = H_GET_16 (abfd, src->vd_version);
  dst->vd_flags   = H_GET_16 (abfd, src->vd_flags);
  dst->vd_ndx     = H_GET_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = H_GET_16 (abfd, src->vd_cnt);
  dst->vd_hash    = H_GET_32 (abfd, src->vd_hash);
  dst->vd_aux     = H_GET_32 (abfd, src->vd_aux);
  dst->vd_next    = H_GET_32 (abfd, src->vd_next);
}

/* Swap out a Verdef structure.  */

void
_bfd_elf_swap_verdef_out (bfd *abfd,
			  const Elf_Internal_Verdef *src,
			  Elf_External_Verdef *dst)
{
  H_PUT_16 (abfd, src->vd_version, dst->vd_version);
  H_PUT_16 (abfd, src->vd_flags, dst->vd_flags);
  H_PUT_16 (abfd, src->vd_ndx, dst->vd_ndx);
  H_PUT_16 (abfd, src->vd_cnt, dst->vd_cnt);
  H_PUT_32 (abfd, src->vd_hash, dst->vd_hash);
  H_PUT_32 (abfd, src->vd_aux, dst->vd_aux);
  H_PUT_32 (abfd, src->vd_next, dst->vd_next);
}

/* Swap in a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_in (bfd *abfd,
			  const Elf_External_Verdaux *src,
			  Elf_Internal_Verdaux *dst)
{
  dst->vda_name = H_GET_32 (abfd, src->vda_name);
  dst->vda_next = H_GET_32 (abfd, src->vda_next);
}

/* Swap out a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_out (bfd *abfd,
			   const Elf_Internal_Verdaux *src,
			   Elf_External_Verdaux *dst)
{
  H_PUT_32 (abfd, src->vda_name, dst->vda_name);
  H_PUT_32 (abfd, src->vda_next, dst->vda_next);
}

/* Swap in a Verneed structure.  */

void
_bfd_elf_swap_verneed_in (bfd *abfd,
			  const Elf_External_Verneed *src,
			  Elf_Internal_Verneed *dst)
{
  dst->vn_version = H_GET_16 (abfd, src->vn_version);
  dst->vn_cnt     = H_GET_16 (abfd, src->vn_cnt);
  dst->vn_file    = H_GET_32 (abfd, src->vn_file);
  dst->vn_aux     = H_GET_32 (abfd, src->vn_aux);
  dst->vn_next    = H_GET_32 (abfd, src->vn_next);
}

/* Swap out a Verneed structure.  */

void
_bfd_elf_swap_verneed_out (bfd *abfd,
			   const Elf_Internal_Verneed *src,
			   Elf_External_Verneed *dst)
{
  H_PUT_16 (abfd, src->vn_version, dst->vn_version);
  H_PUT_16 (abfd, src->vn_cnt, dst->vn_cnt);
  H_PUT_32 (abfd, src->vn_file, dst->vn_file);
  H_PUT_32 (abfd, src->vn_aux, dst->vn_aux);
  H_PUT_32 (abfd, src->vn_next, dst->vn_next);
}

/* Swap in a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_in (bfd *abfd,
			  const Elf_External_Vernaux *src,
			  Elf_Internal_Vernaux *dst)
{
  dst->vna_hash  = H_GET_32 (abfd, src->vna_hash);
  dst->vna_flags = H_GET_16 (abfd, src->vna_flags);
  dst->vna_other = H_GET_16 (abfd, src->vna_other);
  dst->vna_name  = H_GET_32 (abfd, src->vna_name);
  dst->vna_next  = H_GET_32 (abfd, src->vna_next);
}

/* Swap out a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_out (bfd *abfd,
			   const Elf_Internal_Vernaux *src,
			   Elf_External_Vernaux *dst)
{
  H_PUT_32 (abfd, src->vna_hash, dst->vna_hash);
  H_PUT_16 (abfd, src->vna_flags, dst->vna_flags);
  H_PUT_16 (abfd, src->vna_other, dst->vna_other);
  H_PUT_32 (abfd, src->vna_name, dst->vna_name);
  H_PUT_32 (abfd, src->vna_next, dst->vna_next);
}

/* Swap in a Versym structure.  */

void
_bfd_elf_swap_versym_in (bfd *abfd,
			 const Elf_External_Versym *src,
			 Elf_Internal_Versym *dst)
{
  dst->vs_vers = H_GET_16 (abfd, src->vs_vers);
}

/* Swap out a Versym structure.  */

void
_bfd_elf_swap_versym_out (bfd *abfd,
			  const Elf_Internal_Versym *src,
			  Elf_External_Versym *dst)
{
  H_PUT_16 (abfd, src->vs_vers, dst->vs_vers);
}

/* Standard ELF hash function.  Do not change this function; you will
   cause invalid hash tables to be generated.  */

unsigned long
bfd_elf_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 0;
  unsigned long g;
  int ch;

  while ((ch = *name++) != '\0')
    {
      h = (h << 4) + ch;
      if ((g = (h & 0xf0000000)) != 0)
	{
	  h ^= g >> 24;
	  /* The ELF ABI says `h &= ~g', but this is equivalent in
	     this case and on some machines one insn instead of two.  */
	  h ^= g;
	}
    }
  return h & 0xffffffff;
}

/* Read a specified number of bytes at a specified offset in an ELF
   file, into a newly allocated buffer, and return a pointer to the
   buffer.  */

static char *
elf_read (bfd *abfd, file_ptr offset, bfd_size_type size)
{
  char *buf;

  if ((buf = bfd_alloc (abfd, size)) == NULL)
    return NULL;
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return NULL;
  if (bfd_bread (buf, size, abfd) != size)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_file_truncated);
      return NULL;
    }
  return buf;
}

bfd_boolean
bfd_elf_mkobject (bfd *abfd)
{
  /* This just does initialization.  */
  /* coff_mkobject zalloc's space for tdata.coff_obj_data ...  */
  elf_tdata (abfd) = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
  if (elf_tdata (abfd) == 0)
    return FALSE;
  /* Since everything is done at close time, do we need any
     initialization?  */

  return TRUE;
}

bfd_boolean
bfd_elf_mkcorefile (bfd *abfd)
{
  /* I think this can be done just like an object file.  */
  return bfd_elf_mkobject (abfd);
}

char *
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr **i_shdrp;
  char *shstrtab = NULL;
  file_ptr offset;
  bfd_size_type shstrtabsize;

  i_shdrp = elf_elfsections (abfd);
  if (i_shdrp == 0 || i_shdrp[shindex] == 0)
    return 0;

  shstrtab = (char *) i_shdrp[shindex]->contents;
  if (shstrtab == NULL)
    {
      /* No cached one, attempt to read, and cache what we read.  */
      offset = i_shdrp[shindex]->sh_offset;
      shstrtabsize = i_shdrp[shindex]->sh_size;
      shstrtab = elf_read (abfd, offset, shstrtabsize);
      i_shdrp[shindex]->contents = shstrtab;
    }
  return shstrtab;
}

char *
bfd_elf_string_from_elf_section (bfd *abfd,
				 unsigned int shindex,
				 unsigned int strindex)
{
  Elf_Internal_Shdr *hdr;

  if (strindex == 0)
    return "";

  hdr = elf_elfsections (abfd)[shindex];

  if (hdr->contents == NULL
      && bfd_elf_get_str_section (abfd, shindex) == NULL)
    return NULL;

  if (strindex >= hdr->sh_size)
    {
      (*_bfd_error_handler)
	(_("%s: invalid string offset %u >= %lu for section `%s'"),
	 bfd_archive_filename (abfd), strindex, (unsigned long) hdr->sh_size,
	 ((shindex == elf_elfheader(abfd)->e_shstrndx
	   && strindex == hdr->sh_name)
	  ? ".shstrtab"
	  : elf_string_from_elf_strtab (abfd, hdr->sh_name)));
      return "";
    }

  return ((char *) hdr->contents) + strindex;
}

/* Read and convert symbols to internal format.
   SYMCOUNT specifies the number of symbols to read, starting from
   symbol SYMOFFSET.  If any of INTSYM_BUF, EXTSYM_BUF or EXTSHNDX_BUF
   are non-NULL, they are used to store the internal symbols, external
   symbols, and symbol section index extensions, respectively.  */

Elf_Internal_Sym *
bfd_elf_get_elf_syms (bfd *ibfd,
		      Elf_Internal_Shdr *symtab_hdr,
		      size_t symcount,
		      size_t symoffset,
		      Elf_Internal_Sym *intsym_buf,
		      void *extsym_buf,
		      Elf_External_Sym_Shndx *extshndx_buf)
{
  Elf_Internal_Shdr *shndx_hdr;
  void *alloc_ext;
  const bfd_byte *esym;
  Elf_External_Sym_Shndx *alloc_extshndx;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  size_t extsym_size;
  bfd_size_type amt;
  file_ptr pos;

  if (symcount == 0)
    return intsym_buf;

  /* Normal syms might have section extension entries.  */
  shndx_hdr = NULL;
  if (symtab_hdr == &elf_tdata (ibfd)->symtab_hdr)
    shndx_hdr = &elf_tdata (ibfd)->symtab_shndx_hdr;

  /* Read the symbols.  */
  alloc_ext = NULL;
  alloc_extshndx = NULL;
  bed = get_elf_backend_data (ibfd);
  extsym_size = bed->s->sizeof_sym;
  amt = symcount * extsym_size;
  pos = symtab_hdr->sh_offset + symoffset * extsym_size;
  if (extsym_buf == NULL)
    {
      alloc_ext = bfd_malloc (amt);
      extsym_buf = alloc_ext;
    }
  if (extsym_buf == NULL
      || bfd_seek (ibfd, pos, SEEK_SET) != 0
      || bfd_bread (extsym_buf, amt, ibfd) != amt)
    {
      intsym_buf = NULL;
      goto out;
    }

  if (shndx_hdr == NULL || shndx_hdr->sh_size == 0)
    extshndx_buf = NULL;
  else
    {
      amt = symcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);
      if (extshndx_buf == NULL)
	{
	  alloc_extshndx = bfd_malloc (amt);
	  extshndx_buf = alloc_extshndx;
	}
      if (extshndx_buf == NULL
	  || bfd_seek (ibfd, pos, SEEK_SET) != 0
	  || bfd_bread (extshndx_buf, amt, ibfd) != amt)
	{
	  intsym_buf = NULL;
	  goto out;
	}
    }

  if (intsym_buf == NULL)
    {
      bfd_size_type amt = symcount * sizeof (Elf_Internal_Sym);
      intsym_buf = bfd_malloc (amt);
      if (intsym_buf == NULL)
	goto out;
    }

  /* Convert the symbols to internal form.  */
  isymend = intsym_buf + symcount;
  for (esym = extsym_buf, isym = intsym_buf, shndx = extshndx_buf;
       isym < isymend;
       esym += extsym_size, isym++, shndx = shndx != NULL ? shndx + 1 : NULL)
    (*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym);

 out:
  if (alloc_ext != NULL)
    free (alloc_ext);
  if (alloc_extshndx != NULL)
    free (alloc_extshndx);

  return intsym_buf;
}

/* Look up a symbol name.  */
const char *
bfd_elf_local_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
{
  unsigned int iname = isym->st_name;
  unsigned int shindex = elf_tdata (abfd)->symtab_hdr.sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym->st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

/* Elf_Internal_Shdr->contents is an array of these for SHT_GROUP
   sections.  The first element is the flags, the rest are section
   pointers.  */

typedef union elf_internal_group {
  Elf_Internal_Shdr *shdr;
  unsigned int flags;
} Elf_Internal_Group;

/* Return the name of the group signature symbol.  Why isn't the
   signature just a string?  */

static const char *
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
{
  Elf_Internal_Shdr *hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;

  /* First we need to ensure the symbol table is available.  */
  if (! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return NULL;

  /* Go read the symbol.  */
  hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, hdr, 1, ghdr->sh_info,
			    &isym, esym, &eshndx) == NULL)
    return NULL;

  return bfd_elf_local_sym_name (abfd, &isym);
}

/* Set next_in_group list pointer, and group name for NEWSECT.  */

static bfd_boolean
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
{
  unsigned int num_group = elf_tdata (abfd)->num_group;

  /* If num_group is zero, read in all SHT_GROUP sections.  The count
     is set to -1 if there are no SHT_GROUP sections.  */
  if (num_group == 0)
    {
      unsigned int i, shnum;

      /* First count the number of groups.  If we have a SHT_GROUP
	 section with just a flag word (ie. sh_size is 4), ignore it.  */
      shnum = elf_numsections (abfd);
      num_group = 0;
      for (i = 0; i < shnum; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];
	  if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
	    num_group += 1;
	}

      if (num_group == 0)
	num_group = (unsigned) -1;
      elf_tdata (abfd)->num_group = num_group;

      if (num_group > 0)
	{
	  /* We keep a list of elf section headers for group sections,
	     so we can find them quickly.  */
	  bfd_size_type amt = num_group * sizeof (Elf_Internal_Shdr *);
	  elf_tdata (abfd)->group_sect_ptr = bfd_alloc (abfd, amt);
	  if (elf_tdata (abfd)->group_sect_ptr == NULL)
	    return FALSE;

	  num_group = 0;
	  for (i = 0; i < shnum; i++)
	    {
	      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];
	      if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
		{
		  unsigned char *src;
		  Elf_Internal_Group *dest;

		  /* Add to list of sections.  */
		  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;
		  num_group += 1;

		  /* Read the raw contents.  */
		  BFD_ASSERT (sizeof (*dest) >= 4);
		  amt = shdr->sh_size * sizeof (*dest) / 4;
		  shdr->contents = bfd_alloc (abfd, amt);
		  if (shdr->contents == NULL
		      || bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0
		      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)
			  != shdr->sh_size))
		    return FALSE;

		  /* Translate raw contents, a flag word followed by an
		     array of elf section indices all in target byte order,
		     to the flag word followed by an array of elf section
		     pointers.  */
		  src = shdr->contents + shdr->sh_size;
		  dest = (Elf_Internal_Group *) (shdr->contents + amt);
		  while (1)
		    {
		      unsigned int idx;

		      src -= 4;
		      --dest;
		      idx = H_GET_32 (abfd, src);
		      if (src == shdr->contents)
			{
			  dest->flags = idx;
			  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))
			    shdr->bfd_section->flags
			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
			  break;
			}
		      if (idx >= shnum)
			{
			  ((*_bfd_error_handler)
			   (_("%s: invalid SHT_GROUP entry"),
			    bfd_archive_filename (abfd)));
			  idx = 0;
			}
		      dest->shdr = elf_elfsections (abfd)[idx];
		    }
		}
	    }
	}
    }

  if (num_group != (unsigned) -1)
    {
      unsigned int i;

      for (i = 0; i < num_group; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;
	  unsigned int n_elt = shdr->sh_size / 4;

	  /* Look through this group's sections to see if current
	     section is a member.  */
	  while (--n_elt != 0)
	    if ((++idx)->shdr == hdr)
	      {
		asection *s = NULL;

		/* We are a member of this group.  Go looking through
		   other members to see if any others are linked via
		   next_in_group.  */
		idx = (Elf_Internal_Group *) shdr->contents;
		n_elt = shdr->sh_size / 4;
		while (--n_elt != 0)
		  if ((s = (++idx)->shdr->bfd_section) != NULL
		      && elf_next_in_group (s) != NULL)
		    break;
		if (n_elt != 0)
		  {
		    /* Snarf the group name from other member, and
		       insert current section in circular list.  */
		    elf_group_name (newsect) = elf_group_name (s);
		    elf_next_in_group (newsect) = elf_next_in_group (s);
		    elf_next_in_group (s) = newsect;
		  }
		else
		  {
		    const char *gname;

		    gname = group_signature (abfd, shdr);
		    if (gname == NULL)
		      return FALSE;
		    elf_group_name (newsect) = gname;

		    /* Start a circular list with one element.  */
		    elf_next_in_group (newsect) = newsect;
		  }

		/* If the group section has been created, point to the
		   new member.  */
		if (shdr->bfd_section != NULL)
		  elf_next_in_group (shdr->bfd_section) = newsect;

		i = num_group - 1;
		break;
	      }
	}
    }

  if (elf_group_name (newsect) == NULL)
    {
      (*_bfd_error_handler) (_("%s: no group info for section %s"),
			     bfd_archive_filename (abfd), newsect->name);
    }
  return TRUE;
}

bfd_boolean
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED, asection *group)
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      s->output_section = bfd_abs_section_ptr;
      s = elf_next_in_group (s);
      /* These lists are circular.  */
      if (s == first)
	break;
    }
  return TRUE;
}

/* Make a BFD section from an ELF section.  We store a pointer to the
   BFD section in the bfd_section field of the header.  */

bfd_boolean
_bfd_elf_make_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name)
{
  asection *newsect;
  flagword flags;
  const struct elf_backend_data *bed;

  if (hdr->bfd_section != NULL)
    {
      BFD_ASSERT (strcmp (name,
			  bfd_get_section_name (abfd, hdr->bfd_section)) == 0);
      return TRUE;
    }

  newsect = bfd_make_section_anyway (abfd, name);
  if (newsect == NULL)
    return FALSE;

  /* Always use the real type/flags.  */
  elf_section_type (newsect) = hdr->sh_type;
  elf_section_flags (newsect) = hdr->sh_flags;

  newsect->filepos = hdr->sh_offset;

  if (! bfd_set_section_vma (abfd, newsect, hdr->sh_addr)
      || ! bfd_set_section_size (abfd, newsect, hdr->sh_size)
      || ! bfd_set_section_alignment (abfd, newsect,
				      bfd_log2 ((bfd_vma) hdr->sh_addralign)))
    return FALSE;

  flags = SEC_NO_FLAGS;
  if (hdr->sh_type != SHT_NOBITS)
    flags |= SEC_HAS_CONTENTS;
  if (hdr->sh_type == SHT_GROUP)
    flags |= SEC_GROUP | SEC_EXCLUDE;
  if ((hdr->sh_flags & SHF_ALLOC) != 0)
    {
      flags |= SEC_ALLOC;
      if (hdr->sh_type != SHT_NOBITS)
	flags |= SEC_LOAD;
    }
  if ((hdr->sh_flags & SHF_WRITE) == 0)
    flags |= SEC_READONLY;
  if ((hdr->sh_flags & SHF_EXECINSTR) != 0)
    flags |= SEC_CODE;
  else if ((flags & SEC_LOAD) != 0)
    flags |= SEC_DATA;
  if ((hdr->sh_flags & SHF_MERGE) != 0)
    {
      flags |= SEC_MERGE;
      newsect->entsize = hdr->sh_entsize;
      if ((hdr->sh_flags & SHF_STRINGS) != 0)
	flags |= SEC_STRINGS;
    }
  if (hdr->sh_flags & SHF_GROUP)
    if (!setup_group (abfd, hdr, newsect))
      return FALSE;
  if ((hdr->sh_flags & SHF_TLS) != 0)
    flags |= SEC_THREAD_LOCAL;

  /* The debugging sections appear to be recognized only by name, not
     any sort of flag.  */
  {
    static const char *debug_sec_names [] =
    {
      ".debug",
      ".gnu.linkonce.wi.",
      ".line",
      ".stab"
    };
    int i;

    for (i = ARRAY_SIZE (debug_sec_names); i--;)
      if (strncmp (name, debug_sec_names[i], strlen (debug_sec_names[i])) == 0)
	break;

    if (i >= 0)
      flags |= SEC_DEBUGGING;
  }

  /* As a GNU extension, if the name begins with .gnu.linkonce, we
     only link a single copy of the section.  This is used to support
     g++.  g++ will emit each template expansion in its own section.
     The symbols will be defined as weak, so that multiple definitions
     are permitted.  The GNU linker extension is to actually discard
     all but one of the sections.  */
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0
      && elf_next_in_group (newsect) == NULL)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_flags)
    if (! bed->elf_backend_section_flags (&flags, hdr))
      return FALSE;

  if (! bfd_set_section_flags (abfd, newsect, flags))
    return FALSE;

  if ((flags & SEC_ALLOC) != 0)
    {
      Elf_Internal_Phdr *phdr;
      unsigned int i;

      /* Look through the phdrs to see if we need to adjust the lma.
         If all the p_paddr fields are zero, we ignore them, since
         some ELF linkers produce such output.  */
      phdr = elf_tdata (abfd)->phdr;
      for (i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
	{
	  if (phdr->p_paddr != 0)
	    break;
	}
      if (i < elf_elfheader (abfd)->e_phnum)
	{
	  phdr = elf_tdata (abfd)->phdr;
	  for (i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
	    {
	      /* This section is part of this segment if its file
		 offset plus size lies within the segment's memory
		 span and, if the section is loaded, the extent of the
		 loaded data lies within the extent of the segment.

		 Note - we used to check the p_paddr field as well, and
		 refuse to set the LMA if it was 0.  This is wrong
		 though, as a perfectly valid initialised segment can
		 have a p_paddr of zero.  Some architectures, eg ARM,
	         place special significance on the address 0 and
	         executables need to be able to have a segment which
	         covers this address.  */
	      if (phdr->p_type == PT_LOAD
		  && (bfd_vma) hdr->sh_offset >= phdr->p_offset
		  && (hdr->sh_offset + hdr->sh_size
		      <= phdr->p_offset + phdr->p_memsz)
		  && ((flags & SEC_LOAD) == 0
		      || (hdr->sh_offset + hdr->sh_size
			  <= phdr->p_offset + phdr->p_filesz)))
		{
		  if ((flags & SEC_LOAD) == 0)
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_addr - phdr->p_vaddr);
		  else
		    /* We used to use the same adjustment for SEC_LOAD
		       sections, but that doesn't work if the segment
		       is packed with code from multiple VMAs.
		       Instead we calculate the section LMA based on
		       the segment LMA.  It is assumed that the
		       segment will contain sections with contiguous
		       LMAs, even if the VMAs are not.  */
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_offset - phdr->p_offset);

		  /* With contiguous segments, we can't tell from file
		     offsets whether a section with zero size should
		     be placed at the end of one segment or the
		     beginning of the next.  Decide based on vaddr.  */
		  if (hdr->sh_addr >= phdr->p_vaddr
		      && (hdr->sh_addr + hdr->sh_size
			  <= phdr->p_vaddr + phdr->p_memsz))
		    break;
		}
	    }
	}
    }

  hdr->bfd_section = newsect;
  elf_section_data (newsect)->this_hdr = *hdr;

  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_elf_find_section

SYNOPSIS
	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);

DESCRIPTION
	Helper functions for GDB to locate the string tables.
	Since BFD hides string tables from callers, GDB needs to use an
	internal hook to find them.  Sun's .stabstr, in particular,
	isn't even pointed to by the .stab section, so ordinary
	mechanisms wouldn't work to find it, even if we had some.
*/

struct elf_internal_shdr *
bfd_elf_find_section (bfd *abfd, char *name)
{
  Elf_Internal_Shdr **i_shdrp;
  char *shstrtab;
  unsigned int max;
  unsigned int i;

  i_shdrp = elf_elfsections (abfd);
  if (i_shdrp != NULL)
    {
      shstrtab = bfd_elf_get_str_section (abfd,
					  elf_elfheader (abfd)->e_shstrndx);
      if (shstrtab != NULL)
	{
	  max = elf_numsections (abfd);
	  for (i = 1; i < max; i++)
	    if (!strcmp (&shstrtab[i_shdrp[i]->sh_name], name))
	      return i_shdrp[i];
	}
    }
  return 0;
}

const char *const bfd_elf_section_type_names[] = {
  "SHT_NULL", "SHT_PROGBITS", "SHT_SYMTAB", "SHT_STRTAB",
  "SHT_RELA", "SHT_HASH", "SHT_DYNAMIC", "SHT_NOTE",
  "SHT_NOBITS", "SHT_REL", "SHT_SHLIB", "SHT_DYNSYM",
};

/* ELF relocs are against symbols.  If we are producing relocatable
   output, and the reloc is against an external symbol, and nothing
   has given us any additional addend, the resulting reloc will also
   be against the same symbol.  In such a case, we don't want to
   change anything about the way the reloc is handled, since it will
   all be done at final link time.  Rather than put special case code
   into bfd_perform_relocation, all the reloc types use this howto
   function.  It just short circuits the reloc if producing
   relocatable output against an external symbol.  */

bfd_reloc_status_type
bfd_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol,
		       void *data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  return bfd_reloc_continue;
}

/* Make sure sec_info_type is cleared if sec_info is cleared too.  */

static void
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
{
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
}

/* Finish SHF_MERGE section merging.  */

bfd_boolean
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
{
  if (!is_elf_hash_table (info->hash))
    return FALSE;
  if (elf_hash_table (info)->merge_info)
    _bfd_merge_sections (abfd, elf_hash_table (info)->merge_info,
			 merge_sections_remove_hook);
  return TRUE;
}

void
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
{
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
  if (!is_elf_hash_table (info->hash))
    return;

  sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
}

/* Copy the program header and other data from one object module to
   another.  */

bfd_boolean
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;
  return TRUE;
}

/* Print out the program headers.  */

bfd_boolean
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
{
  FILE *f = farg;
  Elf_Internal_Phdr *p;
  asection *s;
  bfd_byte *dynbuf = NULL;

  p = elf_tdata (abfd)->phdr;
  if (p != NULL)
    {
      unsigned int i, c;

      fprintf (f, _("\nProgram Header:\n"));
      c = elf_elfheader (abfd)->e_phnum;
      for (i = 0; i < c; i++, p++)
	{
	  const char *pt;
	  char buf[20];

	  switch (p->p_type)
	    {
	    case PT_NULL: pt = "NULL"; break;
	    case PT_LOAD: pt = "LOAD"; break;
	    case PT_DYNAMIC: pt = "DYNAMIC"; break;
	    case PT_INTERP: pt = "INTERP"; break;
	    case PT_NOTE: pt = "NOTE"; break;
	    case PT_SHLIB: pt = "SHLIB"; break;
	    case PT_PHDR: pt = "PHDR"; break;
	    case PT_TLS: pt = "TLS"; break;
	    case PT_GNU_EH_FRAME: pt = "EH_FRAME"; break;
	    case PT_GNU_STACK: pt = "STACK"; break;
	    case PT_OPENBSD_RANDOMIZE: pt = "OPENBSD_RANDOMIZE"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); pt = buf; break;
	    }
	  fprintf (f, "%8s off    0x", pt);
	  bfd_fprintf_vma (abfd, f, p->p_offset);
	  fprintf (f, " vaddr 0x");
	  bfd_fprintf_vma (abfd, f, p->p_vaddr);
	  fprintf (f, " paddr 0x");
	  bfd_fprintf_vma (abfd, f, p->p_paddr);
	  fprintf (f, " align 2**%u\n", bfd_log2 (p->p_align));
	  fprintf (f, "         filesz 0x");
	  bfd_fprintf_vma (abfd, f, p->p_filesz);
	  fprintf (f, " memsz 0x");
	  bfd_fprintf_vma (abfd, f, p->p_memsz);
	  fprintf (f, " flags %c%c%c",
		   (p->p_flags & PF_R) != 0 ? 'r' : '-',
		   (p->p_flags & PF_W) != 0 ? 'w' : '-',
		   (p->p_flags & PF_X) != 0 ? 'x' : '-');
	  if ((p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X));
	  fprintf (f, "\n");
	}
    }

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      int elfsec;
      unsigned long shlink;
      bfd_byte *extdyn, *extdynend;
      size_t extdynsize;
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

      fprintf (f, _("\nDynamic Section:\n"));

      dynbuf = bfd_malloc (s->_raw_size);
      if (dynbuf == NULL)
	goto error_return;
      if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
	goto error_return;

      elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
      if (elfsec == -1)
	goto error_return;
      shlink = elf_elfsections (abfd)[elfsec]->sh_link;

      extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
      swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

      extdyn = dynbuf;
      extdynend = extdyn + s->_raw_size;
      for (; extdyn < extdynend; extdyn += extdynsize)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  char ab[20];
	  bfd_boolean stringp;

	  (*swap_dyn_in) (abfd, extdyn, &dyn);

	  if (dyn.d_tag == DT_NULL)
	    break;

	  stringp = FALSE;
	  switch (dyn.d_tag)
	    {
	    default:
	      sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
	      name = ab;
	      break;

	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
	    case DT_PLTRELSZ: name = "PLTRELSZ"; break;
	    case DT_PLTGOT: name = "PLTGOT"; break;
	    case DT_HASH: name = "HASH"; break;
	    case DT_STRTAB: name = "STRTAB"; break;
	    case DT_SYMTAB: name = "SYMTAB"; break;
	    case DT_RELA: name = "RELA"; break;
	    case DT_RELASZ: name = "RELASZ"; break;
	    case DT_RELAENT: name = "RELAENT"; break;
	    case DT_STRSZ: name = "STRSZ"; break;
	    case DT_SYMENT: name = "SYMENT"; break;
	    case DT_INIT: name = "INIT"; break;
	    case DT_FINI: name = "FINI"; break;
	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
	    case DT_SYMBOLIC: name = "SYMBOLIC"; break;
	    case DT_REL: name = "REL"; break;
	    case DT_RELSZ: name = "RELSZ"; break;
	    case DT_RELENT: name = "RELENT"; break;
	    case DT_PLTREL: name = "PLTREL"; break;
	    case DT_DEBUG: name = "DEBUG"; break;
	    case DT_TEXTREL: name = "TEXTREL"; break;
	    case DT_JMPREL: name = "JMPREL"; break;
	    case DT_BIND_NOW: name = "BIND_NOW"; break;
	    case DT_INIT_ARRAY: name = "INIT_ARRAY"; break;
	    case DT_FINI_ARRAY: name = "FINI_ARRAY"; break;
	    case DT_INIT_ARRAYSZ: name = "INIT_ARRAYSZ"; break;
	    case DT_FINI_ARRAYSZ: name = "FINI_ARRAYSZ"; break;
	    case DT_RUNPATH: name = "RUNPATH"; stringp = TRUE; break;
	    case DT_FLAGS: name = "FLAGS"; break;
	    case DT_PREINIT_ARRAY: name = "PREINIT_ARRAY"; break;
	    case DT_PREINIT_ARRAYSZ: name = "PREINIT_ARRAYSZ"; break;
	    case DT_CHECKSUM: name = "CHECKSUM"; break;
	    case DT_PLTPADSZ: name = "PLTPADSZ"; break;
	    case DT_MOVEENT: name = "MOVEENT"; break;
	    case DT_MOVESZ: name = "MOVESZ"; break;
	    case DT_FEATURE: name = "FEATURE"; break;
	    case DT_POSFLAG_1: name = "POSFLAG_1"; break;
	    case DT_SYMINSZ: name = "SYMINSZ"; break;
	    case DT_SYMINENT: name = "SYMINENT"; break;
	    case DT_CONFIG: name = "CONFIG"; stringp = TRUE; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = TRUE; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = TRUE; break;
	    case DT_PLTPAD: name = "PLTPAD"; break;
	    case DT_MOVETAB: name = "MOVETAB"; break;
	    case DT_SYMINFO: name = "SYMINFO"; break;
	    case DT_RELACOUNT: name = "RELACOUNT"; break;
	    case DT_RELCOUNT: name = "RELCOUNT"; break;
	    case DT_FLAGS_1: name = "FLAGS_1"; break;
	    case DT_VERSYM: name = "VERSYM"; break;
	    case DT_VERDEF: name = "VERDEF"; break;
	    case DT_VERDEFNUM: name = "VERDEFNUM"; break;
	    case DT_VERNEED: name = "VERNEED"; break;
	    case DT_VERNEEDNUM: name = "VERNEEDNUM"; break;
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
	    case DT_USED: name = "USED"; break;
	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
	    }

	  fprintf (f, "  %-11s ", name);
	  if (! stringp)
	    fprintf (f, "0x%lx", (unsigned long) dyn.d_un.d_val);
	  else
	    {
	      const char *string;
	      unsigned int tagv = dyn.d_un.d_val;

	      string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
	      if (string == NULL)
		goto error_return;
	      fprintf (f, "%s", string);
	    }
	  fprintf (f, "\n");
	}

      free (dynbuf);
      dynbuf = NULL;
    }

  if ((elf_dynverdef (abfd) != 0 && elf_tdata (abfd)->verdef == NULL)
      || (elf_dynverref (abfd) != 0 && elf_tdata (abfd)->verref == NULL))
    {
      if (! _bfd_elf_slurp_version_tables (abfd))
	return FALSE;
    }

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Verdef *t;

      fprintf (f, _("\nVersion definitions:\n"));
      for (t = elf_tdata (abfd)->verdef; t != NULL; t = t->vd_nextdef)
	{
	  fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
		   t->vd_flags, t->vd_hash, t->vd_nodename);
	  if (t->vd_auxptr->vda_nextptr != NULL)
	    {
	      Elf_Internal_Verdaux *a;

	      fprintf (f, "\t");
	      for (a = t->vd_auxptr->vda_nextptr;
		   a != NULL;
		   a = a->vda_nextptr)
		fprintf (f, "%s ", a->vda_nodename);
	      fprintf (f, "\n");
	    }
	}
    }

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Verneed *t;

      fprintf (f, _("\nVersion References:\n"));
      for (t = elf_tdata (abfd)->verref; t != NULL; t = t->vn_nextref)
	{
	  Elf_Internal_Vernaux *a;

	  fprintf (f, _("  required from %s:\n"), t->vn_filename);
	  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	    fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
		     a->vna_flags, a->vna_other, a->vna_nodename);
	}
    }

  return TRUE;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return FALSE;
}

/* Display ELF-specific fields of a symbol.  */

void
bfd_elf_print_symbol (bfd *abfd,
		      void *filep,
		      asymbol *symbol,
		      bfd_print_symbol_type how)
{
  FILE *file = filep;
  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file, "elf ");
      bfd_fprintf_vma (abfd, file, symbol->value);
      fprintf (file, " %lx", (long) symbol->flags);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name;
	const char *name = NULL;
	const struct elf_backend_data *bed;
	unsigned char st_other;
	bfd_vma val;

	section_name = symbol->section ? symbol->section->name : "(*none*)";

	bed = get_elf_backend_data (abfd);
	if (bed->elf_backend_print_symbol_all)
	  name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);

	if (name == NULL)
	  {
	    name = symbol->name;
	    bfd_print_symbol_vandf (abfd, file, symbol);
	  }

	fprintf (file, " %s\t", section_name);
	/* Print the "other" value for a symbol.  For common symbols,
	   we've already printed the size; now print the alignment.
	   For other symbols, we have no specified alignment, and
	   we've printed the address; now print the size.  */
	if (bfd_is_com_section (symbol->section))
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_value;
	else
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_size;
	bfd_fprintf_vma (abfd, file, val);

	/* If we have version information, print it.  */
	if (elf_tdata (abfd)->dynversym_section != 0
	    && (elf_tdata (abfd)->dynverdef_section != 0
		|| elf_tdata (abfd)->dynverref_section != 0))
	  {
	    unsigned int vernum;
	    const char *version_string;

	    vernum = ((elf_symbol_type *) symbol)->version & VERSYM_VERSION;

	    if (vernum == 0)
	      version_string = "";
	    else if (vernum == 1)
	      version_string = "Base";
	    else if (vernum <= elf_tdata (abfd)->cverdefs)
	      version_string =
		elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
	    else
	      {
		Elf_Internal_Verneed *t;

		version_string = "";
		for (t = elf_tdata (abfd)->verref;
		     t != NULL;
		     t = t->vn_nextref)
		  {
		    Elf_Internal_Vernaux *a;

		    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		      {
			if (a->vna_other == vernum)
			  {
			    version_string = a->vna_nodename;
			    break;
			  }
		      }
		  }
	      }

	    if ((((elf_symbol_type *) symbol)->version & VERSYM_HIDDEN) == 0)
	      fprintf (file, "  %-11s", version_string);
	    else
	      {
		int i;

		fprintf (file, " (%s)", version_string);
		for (i = 10 - strlen (version_string); i > 0; --i)
		  putc (' ', file);
	      }
	  }

	/* If the st_other field is not zero, print it.  */
	st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;

	switch (st_other)
	  {
	  case 0: break;
	  case STV_INTERNAL:  fprintf (file, " .internal");  break;
	  case STV_HIDDEN:    fprintf (file, " .hidden");    break;
	  case STV_PROTECTED: fprintf (file, " .protected"); break;
	  default:
	    /* Some other non-defined flags are also present, so print
	       everything hex.  */
	    fprintf (file, " 0x%02x", (unsigned int) st_other);
	  }

	fprintf (file, " %s", name);
      }
      break;
    }
}

/* Create an entry in an ELF linker hash table.  */

struct bfd_hash_entry *
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;
      struct elf_link_hash_table *htab = (struct elf_link_hash_table *) table;

      /* Set local fields.  */
      ret->indx = -1;
      ret->dynindx = -1;
      ret->dynstr_index = 0;
      ret->elf_hash_value = 0;
      ret->weakdef = NULL;
      ret->verinfo.verdef = NULL;
      ret->vtable_entries_size = 0;
      ret->vtable_entries_used = NULL;
      ret->vtable_parent = NULL;
      ret->got = htab->init_refcount;
      ret->plt = htab->init_refcount;
      ret->size = 0;
      ret->type = STT_NOTYPE;
      ret->other = 0;
      /* Assume that we have been called by a non-ELF symbol reader.
         This flag is then reset by the code which reads an ELF input
         file.  This ensures that a symbol created by a non-ELF symbol
         reader will have the flag set correctly.  */
      ret->elf_link_hash_flags = ELF_LINK_NON_ELF;
    }

  return entry;
}

/* Copy data from an indirect symbol to its direct symbol, hiding the
   old indirect symbol.  Also used for copying flags to a weakdef.  */

void
_bfd_elf_link_hash_copy_indirect (const struct elf_backend_data *bed,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
{
  bfd_signed_vma tmp;
  bfd_signed_vma lowest_valid = bed->can_refcount;

  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */

  dir->elf_link_hash_flags
    |= ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_NON_GOT_REF
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED);

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the global and procedure linkage table refcount entries.
     These may have been already set up by a check_relocs routine.  */
  tmp = dir->got.refcount;
  if (tmp < lowest_valid)
    {
      dir->got.refcount = ind->got.refcount;
      ind->got.refcount = tmp;
    }
  else
    BFD_ASSERT (ind->got.refcount < lowest_valid);

  tmp = dir->plt.refcount;
  if (tmp < lowest_valid)
    {
      dir->plt.refcount = ind->plt.refcount;
      ind->plt.refcount = tmp;
    }
  else
    BFD_ASSERT (ind->plt.refcount < lowest_valid);

  if (dir->dynindx == -1)
    {
      dir->dynindx = ind->dynindx;
      dir->dynstr_index = ind->dynstr_index;
      ind->dynindx = -1;
      ind->dynstr_index = 0;
    }
  else
    BFD_ASSERT (ind->dynindx == -1);
}

void
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
{
  h->plt = elf_hash_table (info)->init_offset;
  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  if (force_local)
    {
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }
}

/* Initialize an ELF linker hash table.  */

bfd_boolean
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
{
  bfd_boolean ret;

  table->dynamic_sections_created = FALSE;
  table->dynobj = NULL;
  /* Make sure can_refcount is extended to the width and signedness of
     init_refcount before we subtract one from it.  */
  table->init_refcount.refcount = get_elf_backend_data (abfd)->can_refcount;
  table->init_refcount.refcount -= 1;
  table->init_offset.offset = -(bfd_vma) 1;
  /* The first dynamic symbol is a dummy.  */
  table->dynsymcount = 1;
  table->dynstr = NULL;
  table->bucketcount = 0;
  table->needed = NULL;
  table->hgot = NULL;
  table->stab_info = NULL;
  table->merge_info = NULL;
  memset (&table->eh_info, 0, sizeof (table->eh_info));
  table->dynlocal = NULL;
  table->runpath = NULL;
  table->tls_sec = NULL;
  table->tls_size = 0;
  table->loaded = NULL;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc);
  table->root.type = bfd_link_elf_hash_table;

  return ret;
}

/* Create an ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_link_hash_table);

  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (ret, abfd, _bfd_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

/* This is a hook for the ELF emulation code in the generic linker to
   tell the backend linker what file name to use for the DT_NEEDED
   entry for a dynamic object.  */

void
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dt_name (abfd) = name;
}

void
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dyn_lib_class (abfd) = lib_class;
}

/* Get the list of DT_NEEDED entries for a link.  This is a hook for
   the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->needed;
}

/* Get the list of DT_RPATH/DT_RUNPATH entries for a link.  This is a
   hook for the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->runpath;
}

/* Get the name actually used for a dynamic object for a link.  This
   is the SONAME entry if there is one.  Otherwise, it is the string
   passed to bfd_elf_set_dt_needed_name, or it is the filename.  */

const char *
bfd_elf_get_dt_soname (bfd *abfd)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    return elf_dt_name (abfd);
  return NULL;
}

/* Get the list of DT_NEEDED entries from a BFD.  This is a hook for
   the ELF linker emulation code.  */

bfd_boolean
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
{
  asection *s;
  bfd_byte *dynbuf = NULL;
  int elfsec;
  unsigned long shlink;
  bfd_byte *extdyn, *extdynend;
  size_t extdynsize;
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

  *pneeded = NULL;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || bfd_get_format (abfd) != bfd_object)
    return TRUE;

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s == NULL || s->_raw_size == 0)
    return TRUE;

  dynbuf = bfd_malloc (s->_raw_size);
  if (dynbuf == NULL)
    goto error_return;

  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
    goto error_return;

  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
  if (elfsec == -1)
    goto error_return;

  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

  extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
  swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

  extdyn = dynbuf;
  extdynend = extdyn + s->_raw_size;
  for (; extdyn < extdynend; extdyn += extdynsize)
    {
      Elf_Internal_Dyn dyn;

      (*swap_dyn_in) (abfd, extdyn, &dyn);

      if (dyn.d_tag == DT_NULL)
	break;

      if (dyn.d_tag == DT_NEEDED)
	{
	  const char *string;
	  struct bfd_link_needed_list *l;
	  unsigned int tagv = dyn.d_un.d_val;
	  bfd_size_type amt;

	  string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
	  if (string == NULL)
	    goto error_return;

	  amt = sizeof *l;
	  l = bfd_alloc (abfd, amt);
	  if (l == NULL)
	    goto error_return;

	  l->by = abfd;
	  l->name = string;
	  l->next = *pneeded;
	  *pneeded = l;
	}
    }

  free (dynbuf);

  return TRUE;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return FALSE;
}

/* Allocate an ELF string table--force the first byte to be zero.  */

struct bfd_strtab_hash *
_bfd_elf_stringtab_init (void)
{
  struct bfd_strtab_hash *ret;

  ret = _bfd_stringtab_init ();
  if (ret != NULL)
    {
      bfd_size_type loc;

      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
      BFD_ASSERT (loc == 0 || loc == (bfd_size_type) -1);
      if (loc == (bfd_size_type) -1)
	{
	  _bfd_stringtab_free (ret);
	  ret = NULL;
	}
    }
  return ret;
}

/* ELF .o/exec file reading */

/* Create a new bfd section from an ELF section header.  */

bfd_boolean
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr *hdr = elf_elfsections (abfd)[shindex];
  Elf_Internal_Ehdr *ehdr = elf_elfheader (abfd);
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const char *name;

  name = elf_string_from_elf_strtab (abfd, hdr->sh_name);

  switch (hdr->sh_type)
    {
    case SHT_NULL:
      /* Inactive section. Throw it away.  */
      return TRUE;

    case SHT_PROGBITS:	/* Normal section with contents.  */
    case SHT_NOBITS:	/* .bss section.  */
    case SHT_HASH:	/* .hash section.  */
    case SHT_NOTE:	/* .note section.  */
    case SHT_INIT_ARRAY:	/* .init_array section.  */
    case SHT_FINI_ARRAY:	/* .fini_array section.  */
    case SHT_PREINIT_ARRAY:	/* .preinit_array section.  */
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);

    case SHT_DYNAMIC:	/* Dynamic linking information.  */
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return FALSE;
      if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
	{
	  Elf_Internal_Shdr *dynsymhdr;

	  /* The shared libraries distributed with hpux11 have a bogus
	     sh_link field for the ".dynamic" section.  Find the
	     string table for the ".dynsym" section instead.  */
	  if (elf_dynsymtab (abfd) != 0)
	    {
	      dynsymhdr = elf_elfsections (abfd)[elf_dynsymtab (abfd)];
	      hdr->sh_link = dynsymhdr->sh_link;
	    }
	  else
	    {
	      unsigned int i, num_sec;

	      num_sec = elf_numsections (abfd);
	      for (i = 1; i < num_sec; i++)
		{
		  dynsymhdr = elf_elfsections (abfd)[i];
		  if (dynsymhdr->sh_type == SHT_DYNSYM)
		    {
		      hdr->sh_link = dynsymhdr->sh_link;
		      break;
		    }
		}
	    }
	}
      break;

    case SHT_SYMTAB:		/* A symbol table */
      if (elf_onesymtab (abfd) == shindex)
	return TRUE;

      BFD_ASSERT (hdr->sh_entsize == bed->s->sizeof_sym);
      BFD_ASSERT (elf_onesymtab (abfd) == 0);
      elf_onesymtab (abfd) = shindex;
      elf_tdata (abfd)->symtab_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = hdr = &elf_tdata (abfd)->symtab_hdr;
      abfd->flags |= HAS_SYMS;

      /* Sometimes a shared object will map in the symbol table.  If
         SHF_ALLOC is set, and this is a shared object, then we also
         treat this section as a BFD section.  We can not base the
         decision purely on SHF_ALLOC, because that flag is sometimes
         set in a relocatable object file, which would confuse the
         linker.  */
      if ((hdr->sh_flags & SHF_ALLOC) != 0
	  && (abfd->flags & DYNAMIC) != 0
	  && ! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return FALSE;

      return TRUE;

    case SHT_DYNSYM:		/* A dynamic symbol table */
      if (elf_dynsymtab (abfd) == shindex)
	return TRUE;

      BFD_ASSERT (hdr->sh_entsize == bed->s->sizeof_sym);
      BFD_ASSERT (elf_dynsymtab (abfd) == 0);
      elf_dynsymtab (abfd) = shindex;
      elf_tdata (abfd)->dynsymtab_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      abfd->flags |= HAS_SYMS;

      /* Besides being a symbol table, we also treat this as a regular
	 section, so that objcopy can handle it.  */
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);

    case SHT_SYMTAB_SHNDX:	/* Symbol section indices when >64k sections */
      if (elf_symtab_shndx (abfd) == shindex)
	return TRUE;

      /* Get the associated symbol table.  */
      if (! bfd_section_from_shdr (abfd, hdr->sh_link)
	  || hdr->sh_link != elf_onesymtab (abfd))
	return FALSE;

      elf_symtab_shndx (abfd) = shindex;
      elf_tdata (abfd)->symtab_shndx_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->symtab_shndx_hdr;
      return TRUE;

    case SHT_STRTAB:		/* A string table */
      if (hdr->bfd_section != NULL)
	return TRUE;
      if (ehdr->e_shstrndx == shindex)
	{
	  elf_tdata (abfd)->shstrtab_hdr = *hdr;
	  elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->shstrtab_hdr;
	  return TRUE;
	}
      {
	unsigned int i, num_sec;

	num_sec = elf_numsections (abfd);
	for (i = 1; i < num_sec; i++)
	  {
	    Elf_Internal_Shdr *hdr2 = elf_elfsections (abfd)[i];
	    if (hdr2->sh_link == shindex)
	      {
		if (! bfd_section_from_shdr (abfd, i))
		  return FALSE;
		if (elf_onesymtab (abfd) == i)
		  {
		    elf_tdata (abfd)->strtab_hdr = *hdr;
		    elf_elfsections (abfd)[shindex] =
		      &elf_tdata (abfd)->strtab_hdr;
		    return TRUE;
		  }
		if (elf_dynsymtab (abfd) == i)
		  {
		    elf_tdata (abfd)->dynstrtab_hdr = *hdr;
		    elf_elfsections (abfd)[shindex] = hdr =
		      &elf_tdata (abfd)->dynstrtab_hdr;
		    /* We also treat this as a regular section, so
		       that objcopy can handle it.  */
		    break;
		  }
#if 0 /* Not handling other string tables specially right now.  */
		hdr2 = elf_elfsections (abfd)[i];	/* in case it moved */
		/* We have a strtab for some random other section.  */
		newsect = (asection *) hdr2->bfd_section;
		if (!newsect)
		  break;
		hdr->bfd_section = newsect;
		hdr2 = &elf_section_data (newsect)->str_hdr;
		*hdr2 = *hdr;
		elf_elfsections (abfd)[shindex] = hdr2;
#endif
	      }
	  }
      }

      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);

    case SHT_REL:
    case SHT_RELA:
      /* *These* do a lot of work -- but build no sections!  */
      {
	asection *target_sect;
	Elf_Internal_Shdr *hdr2;
	unsigned int num_sec = elf_numsections (abfd);

	/* Check for a bogus link to avoid crashing.  */
	if ((hdr->sh_link >= SHN_LORESERVE && hdr->sh_link <= SHN_HIRESERVE)
	    || hdr->sh_link >= num_sec)
	  {
	    ((*_bfd_error_handler)
	     (_("%s: invalid link %lu for reloc section %s (index %u)"),
	      bfd_archive_filename (abfd), hdr->sh_link, name, shindex));
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
	  }

	/* For some incomprehensible reason Oracle distributes
	   libraries for Solaris in which some of the objects have
	   bogus sh_link fields.  It would be nice if we could just
	   reject them, but, unfortunately, some people need to use
	   them.  We scan through the section headers; if we find only
	   one suitable symbol table, we clobber the sh_link to point
	   to it.  I hope this doesn't break anything.  */
	if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_SYMTAB
	    && elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_DYNSYM)
	  {
	    unsigned int scan;
	    int found;

	    found = 0;
	    for (scan = 1; scan < num_sec; scan++)
	      {
		if (elf_elfsections (abfd)[scan]->sh_type == SHT_SYMTAB
		    || elf_elfsections (abfd)[scan]->sh_type == SHT_DYNSYM)
		  {
		    if (found != 0)
		      {
			found = 0;
			break;
		      }
		    found = scan;
		  }
	      }
	    if (found != 0)
	      hdr->sh_link = found;
	  }

	/* Get the symbol table.  */
	if (elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_SYMTAB
	    && ! bfd_section_from_shdr (abfd, hdr->sh_link))
	  return FALSE;

	/* If this reloc section does not use the main symbol table we
	   don't treat it as a reloc section.  BFD can't adequately
	   represent such a section, so at least for now, we don't
	   try.  We just present it as a normal section.  We also
	   can't use it as a reloc section if it points to the null
	   section.  */
	if (hdr->sh_link != elf_onesymtab (abfd) || hdr->sh_info == SHN_UNDEF)
	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name);

	if (! bfd_section_from_shdr (abfd, hdr->sh_info))
	  return FALSE;
	target_sect = bfd_section_from_elf_index (abfd, hdr->sh_info);
	if (target_sect == NULL)
	  return FALSE;

	if ((target_sect->flags & SEC_RELOC) == 0
	    || target_sect->reloc_count == 0)
	  hdr2 = &elf_section_data (target_sect)->rel_hdr;
	else
	  {
	    bfd_size_type amt;
	    BFD_ASSERT (elf_section_data (target_sect)->rel_hdr2 == NULL);
	    amt = sizeof (*hdr2);
	    hdr2 = bfd_alloc (abfd, amt);
	    elf_section_data (target_sect)->rel_hdr2 = hdr2;
	  }
	*hdr2 = *hdr;
	elf_elfsections (abfd)[shindex] = hdr2;
	target_sect->reloc_count += NUM_SHDR_ENTRIES (hdr);
	target_sect->flags |= SEC_RELOC;
	target_sect->relocation = NULL;
	target_sect->rel_filepos = hdr->sh_offset;
	/* In the section to which the relocations apply, mark whether
	   its relocations are of the REL or RELA variety.  */
	if (hdr->sh_size != 0)
	  target_sect->use_rela_p = hdr->sh_type == SHT_RELA;
	abfd->flags |= HAS_RELOC;
	return TRUE;
      }
      break;

    case SHT_GNU_verdef:
      elf_dynverdef (abfd) = shindex;
      elf_tdata (abfd)->dynverdef_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

    case SHT_GNU_versym:
      elf_dynversym (abfd) = shindex;
      elf_tdata (abfd)->dynversym_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

    case SHT_GNU_verneed:
      elf_dynverref (abfd) = shindex;
      elf_tdata (abfd)->dynverref_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

    case SHT_SHLIB:
      return TRUE;

    case SHT_GROUP:
      /* We need a BFD section for objcopy and relocatable linking,
	 and it's handy to have the signature available as the section
	 name.  */
      name = group_signature (abfd, hdr);
      if (name == NULL)
	return FALSE;
      if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return FALSE;
      if (hdr->contents != NULL)
	{
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) hdr->contents;
	  unsigned int n_elt = hdr->sh_size / 4;
	  asection *s;

	  if (idx->flags & GRP_COMDAT)
	    hdr->bfd_section->flags
	      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

	  while (--n_elt != 0)
	    if ((s = (++idx)->shdr->bfd_section) != NULL
		&& elf_next_in_group (s) != NULL)
	      {
		elf_next_in_group (hdr->bfd_section) = s;
		break;
	      }
	}
      break;

    default:
      /* Check for any processor-specific section types.  */
      {
	if (bed->elf_backend_section_from_shdr)
	  (*bed->elf_backend_section_from_shdr) (abfd, hdr, name);
      }
      break;
    }

  return TRUE;
}

/* Return the section for the local symbol specified by ABFD, R_SYMNDX.
   Return SEC for sections that have no elf section, and NULL on error.  */

asection *
bfd_section_from_r_symndx (bfd *abfd,
			   struct sym_sec_cache *cache,
			   asection *sec,
			   unsigned long r_symndx)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
  unsigned int ent = r_symndx % LOCAL_SYM_CACHE_SIZE;

  if (cache->abfd == abfd && cache->indx[ent] == r_symndx)
    return cache->sec[ent];

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
			    &isym, esym, &eshndx) == NULL)
    return NULL;

  if (cache->abfd != abfd)
    {
      memset (cache->indx, -1, sizeof (cache->indx));
      cache->abfd = abfd;
    }
  cache->indx[ent] = r_symndx;
  cache->sec[ent] = sec;
  if ((isym.st_shndx != SHN_UNDEF && isym.st_shndx < SHN_LORESERVE)
      || isym.st_shndx > SHN_HIRESERVE)
    {
      asection *s;
      s = bfd_section_from_elf_index (abfd, isym.st_shndx);
      if (s != NULL)
	cache->sec[ent] = s;
    }
  return cache->sec[ent];
}

/* Given an ELF section number, retrieve the corresponding BFD
   section.  */

asection *
bfd_section_from_elf_index (bfd *abfd, unsigned int index)
{
  if (index >= elf_numsections (abfd))
    return NULL;
  return elf_elfsections (abfd)[index]->bfd_section;
}

static struct bfd_elf_special_section const special_sections[] =
{
  { ".bss",            4, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".comment",        8,  0, SHT_PROGBITS, 0 },
  { ".data",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".data1",          6,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".debug",          6,  0, SHT_PROGBITS, 0 },
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".debug_line",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_info",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_abbrev",  13,  0, SHT_PROGBITS, 0 },
  { ".debug_aranges", 14,  0, SHT_PROGBITS, 0 },
  { ".dynamic",        8,  0, SHT_DYNAMIC,  SHF_ALLOC },
  { ".dynstr",         7,  0, SHT_STRTAB,   SHF_ALLOC },
  { ".dynsym",         7,  0, SHT_DYNSYM,   SHF_ALLOC },
  { ".got",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
  { ".gnu.version",   12,  0, SHT_GNU_versym, 0 },
  { ".gnu.version_d", 14,  0, SHT_GNU_verdef, 0 },
  { ".gnu.version_r", 14,  0, SHT_GNU_verneed, 0 },
  { ".note",           5, -1, SHT_NOTE,     0 },
  { ".rela",           5, -1, SHT_RELA,     0 },
  { ".rel",            4, -1, SHT_REL,      0 },
  { ".stabstr",        5,  3, SHT_STRTAB,   0 },
  { NULL,              0,  0, 0,            0 }
};

static const struct bfd_elf_special_section *
get_special_section (const char *name,
		     const struct bfd_elf_special_section *special_sections,
		     unsigned int rela)
{
  int i;
  int len = strlen (name);

  for (i = 0; special_sections[i].prefix != NULL; i++)
    {
      int suffix_len;
      int prefix_len = special_sections[i].prefix_length;

      if (len < prefix_len)
	continue;
      if (memcmp (name, special_sections[i].prefix, prefix_len) != 0)
	continue;

      suffix_len = special_sections[i].suffix_length;
      if (suffix_len <= 0)
	{
	  if (name[prefix_len] != 0)
	    {
	      if (suffix_len == 0)
		continue;
	      if (name[prefix_len] != '.'
		  && (suffix_len == -2
		      || (rela && special_sections[i].type == SHT_REL)))
		continue;
	    }
	}
      else
	{
	  if (len < prefix_len + suffix_len)
	    continue;
	  if (memcmp (name + len - suffix_len,
		      special_sections[i].prefix + prefix_len,
		      suffix_len) != 0)
	    continue;
	}
      return &special_sections[i];
    }

  return NULL;
}

const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct bfd_elf_special_section *ssect = NULL;

  /* See if this is one of the special sections.  */
  if (name)
    {
      unsigned int rela = bed->default_use_rela_p;

      if (bed->special_sections)
	ssect = get_special_section (name, bed->special_sections, rela);

      if (! ssect)
	ssect = get_special_section (name, special_sections, rela);
    }

  return ssect;
}

bfd_boolean
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
{
  struct bfd_elf_section_data *sdata;
  const struct bfd_elf_special_section *ssect;

  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == NULL)
    {
      sdata = bfd_zalloc (abfd, sizeof (*sdata));
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  elf_section_type (sec) = SHT_NULL;
  ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
  if (ssect != NULL)
    {
      elf_section_type (sec) = ssect->type;
      elf_section_flags (sec) = ssect->attr;
    }

  /* Indicate whether or not this section should use RELA relocations.  */
  sec->use_rela_p = get_elf_backend_data (abfd)->default_use_rela_p;

  return TRUE;
}

/* Create a new bfd section from an ELF program header.

   Since program segments have no names, we generate a synthetic name
   of the form segment<NUM>, where NUM is generally the index in the
   program header table.  For segments that are split (see below) we
   generate the names segment<NUM>a and segment<NUM>b.

   Note that some program segments may have a file size that is different than
   (less than) the memory size.  All this means is that at execution the
   system must allocate the amount of memory specified by the memory size,
   but only initialize it with the first "file size" bytes read from the
   file.  This would occur for example, with program segments consisting
   of combined data+bss.

   To handle the above situation, this routine generates TWO bfd sections
   for the single program segment.  The first has the length specified by
   the file size of the segment, and the second has the length specified
   by the difference between the two sizes.  In effect, the segment is split
   into it's initialized and uninitialized parts.

 */

bfd_boolean
_bfd_elf_make_section_from_phdr (bfd *abfd,
				 Elf_Internal_Phdr *hdr,
				 int index,
				 const char *typename)
{
  asection *newsect;
  char *name;
  char namebuf[64];
  size_t len;
  int split;

  split = ((hdr->p_memsz > 0)
	    && (hdr->p_filesz > 0)
	    && (hdr->p_memsz > hdr->p_filesz));
  sprintf (namebuf, "%s%d%s", typename, index, split ? "a" : "");
  len = strlen (namebuf) + 1;
  name = bfd_alloc (abfd, len);
  if (!name)
    return FALSE;
  memcpy (name, namebuf, len);
  newsect = bfd_make_section (abfd, name);
  if (newsect == NULL)
    return FALSE;
  newsect->vma = hdr->p_vaddr;
  newsect->lma = hdr->p_paddr;
  newsect->_raw_size = hdr->p_filesz;
  newsect->filepos = hdr->p_offset;
  newsect->flags |= SEC_HAS_CONTENTS;
  newsect->alignment_power = bfd_log2 (hdr->p_align);
  if (hdr->p_type == PT_LOAD)
    {
      newsect->flags |= SEC_ALLOC;
      newsect->flags |= SEC_LOAD;
      if (hdr->p_flags & PF_X)
	{
	  /* FIXME: all we known is that it has execute PERMISSION,
	     may be data.  */
	  newsect->flags |= SEC_CODE;
	}
    }
  if (!(hdr->p_flags & PF_W))
    {
      newsect->flags |= SEC_READONLY;
    }

  if (split)
    {
      sprintf (namebuf, "%s%db", typename, index);
      len = strlen (namebuf) + 1;
      name = bfd_alloc (abfd, len);
      if (!name)
	return FALSE;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == NULL)
	return FALSE;
      newsect->vma = hdr->p_vaddr + hdr->p_filesz;
      newsect->lma = hdr->p_paddr + hdr->p_filesz;
      newsect->_raw_size = hdr->p_memsz - hdr->p_filesz;
      if (hdr->p_type == PT_LOAD)
	{
	  newsect->flags |= SEC_ALLOC;
	  if (hdr->p_flags & PF_X)
	    newsect->flags |= SEC_CODE;
	}
      if (!(hdr->p_flags & PF_W))
	newsect->flags |= SEC_READONLY;
    }

  return TRUE;
}

bfd_boolean
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index)
{
  const struct elf_backend_data *bed;

  switch (hdr->p_type)
    {
    case PT_NULL:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "null");

    case PT_LOAD:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "load");

    case PT_DYNAMIC:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "dynamic");

    case PT_INTERP:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "interp");

    case PT_NOTE:
      if (! _bfd_elf_make_section_from_phdr (abfd, hdr, index, "note"))
	return FALSE;
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
	return FALSE;
      return TRUE;

    case PT_SHLIB:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "shlib");

    case PT_PHDR:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "phdr");

    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "eh_frame_hdr");

    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");

    case PT_OPENBSD_RANDOMIZE:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "openbsd_randomize");

    default:
      /* Check for any processor-specific program segment types.
         If no handler for them, default to making "segment" sections.  */
      bed = get_elf_backend_data (abfd);
      if (bed->elf_backend_section_from_phdr)
	return (*bed->elf_backend_section_from_phdr) (abfd, hdr, index);
      else
	return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "segment");
    }
}

/* Initialize REL_HDR, the section-header for new section, containing
   relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA
   relocations; otherwise, we use REL relocations.  */

bfd_boolean
_bfd_elf_init_reloc_shdr (bfd *abfd,
			  Elf_Internal_Shdr *rel_hdr,
			  asection *asect,
			  bfd_boolean use_rela_p)
{
  char *name;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_size_type amt = sizeof ".rela" + strlen (asect->name);

  name = bfd_alloc (abfd, amt);
  if (name == NULL)
    return FALSE;
  sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", asect->name);
  rel_hdr->sh_name =
    (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd), name,
					FALSE);
  if (rel_hdr->sh_name == (unsigned int) -1)
    return FALSE;
  rel_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
  rel_hdr->sh_entsize = (use_rela_p
			 ? bed->s->sizeof_rela
			 : bed->s->sizeof_rel);
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
  rel_hdr->sh_flags = 0;
  rel_hdr->sh_addr = 0;
  rel_hdr->sh_size = 0;
  rel_hdr->sh_offset = 0;

  return TRUE;
}

/* Set up an ELF internal section header for a section.  */

static void
elf_fake_sections (bfd *abfd, asection *asect, void *failedptrarg)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean *failedptr = failedptrarg;
  Elf_Internal_Shdr *this_hdr;

  if (*failedptr)
    {
      /* We already failed; just get out of the bfd_map_over_sections
         loop.  */
      return;
    }

  this_hdr = &elf_section_data (asect)->this_hdr;

  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
    {
      *failedptr = TRUE;
      return;
    }

  this_hdr->sh_flags = 0;

  if ((asect->flags & SEC_ALLOC) != 0
      || asect->user_set_vma)
    this_hdr->sh_addr = asect->vma;
  else
    this_hdr->sh_addr = 0;

  this_hdr->sh_offset = 0;
  this_hdr->sh_size = asect->_raw_size;
  this_hdr->sh_link = 0;
  this_hdr->sh_addralign = 1 << asect->alignment_power;
  /* The sh_entsize and sh_info fields may have been set already by
     copy_private_section_data.  */

  this_hdr->bfd_section = asect;
  this_hdr->contents = NULL;

  /* If the section type is unspecified, we set it based on
     asect->flags.  */
  if (this_hdr->sh_type == SHT_NULL)
    {
      if ((asect->flags & SEC_ALLOC) != 0
	  && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      || (asect->flags & SEC_NEVER_LOAD) != 0))
	this_hdr->sh_type = SHT_NOBITS;
      else
	this_hdr->sh_type = SHT_PROGBITS;
    }

  switch (this_hdr->sh_type)
    {
    default:
      break;

    case SHT_STRTAB:
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
    case SHT_NOTE:
    case SHT_NOBITS:
    case SHT_PROGBITS:
      break;

    case SHT_HASH:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;

    case SHT_DYNSYM:
      this_hdr->sh_entsize = bed->s->sizeof_sym;
      break;

    case SHT_DYNAMIC:
      this_hdr->sh_entsize = bed->s->sizeof_dyn;
      break;

    case SHT_RELA:
      if (get_elf_backend_data (abfd)->may_use_rela_p)
	this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case SHT_REL:
      if (get_elf_backend_data (abfd)->may_use_rel_p)
	this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case SHT_GNU_versym:
      this_hdr->sh_entsize = sizeof (Elf_External_Versym);
      break;

     case SHT_GNU_verdef:
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
         cverdefs.  The linker will set cverdefs, but sh_info will be
         zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverdefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverdefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverdefs);
      break;

    case SHT_GNU_verneed:
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
         cverrefs.  The linker will set cverrefs, but sh_info will be
         zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverrefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverrefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverrefs);
      break;

    case SHT_GROUP:
      this_hdr->sh_entsize = 4;
      break;
    }

  if ((asect->flags & SEC_ALLOC) != 0)
    this_hdr->sh_flags |= SHF_ALLOC;
  if ((asect->flags & SEC_READONLY) == 0)
    this_hdr->sh_flags |= SHF_WRITE;
  if ((asect->flags & SEC_CODE) != 0)
    this_hdr->sh_flags |= SHF_EXECINSTR;
  if ((asect->flags & SEC_MERGE) != 0)
    {
      this_hdr->sh_flags |= SHF_MERGE;
      this_hdr->sh_entsize = asect->entsize;
      if ((asect->flags & SEC_STRINGS) != 0)
	this_hdr->sh_flags |= SHF_STRINGS;
    }
  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)
    this_hdr->sh_flags |= SHF_GROUP;
  if ((asect->flags & SEC_THREAD_LOCAL) != 0)
    {
      this_hdr->sh_flags |= SHF_TLS;
      if (asect->_raw_size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *o;

	  this_hdr->sh_size = 0;
	  for (o = asect->link_order_head; o != NULL; o = o->next)
	    if (this_hdr->sh_size < o->offset + o->size)
	      this_hdr->sh_size = o->offset + o->size;
	  if (this_hdr->sh_size)
	    this_hdr->sh_type = SHT_NOBITS;
	}
    }

  /* Check for processor-specific section types.  */
  if (bed->elf_backend_fake_sections
      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))
    *failedptr = TRUE;

  /* If the section has relocs, set up a section header for the
     SHT_REL[A] section.  If two relocation sections are required for
     this section, it is up to the processor-specific back-end to
     create the other.  */
  if ((asect->flags & SEC_RELOC) != 0
      && !_bfd_elf_init_reloc_shdr (abfd,
				    &elf_section_data (asect)->rel_hdr,
				    asect,
				    asect->use_rela_p))
    *failedptr = TRUE;
}

/* Fill in the contents of a SHT_GROUP section.  */

void
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
{
  bfd_boolean *failedptr = failedptrarg;
  unsigned long symindx;
  asection *elt, *first;
  unsigned char *loc;
  struct bfd_link_order *l;
  bfd_boolean gas;

  if (elf_section_data (sec)->this_hdr.sh_type != SHT_GROUP
      || *failedptr)
    return;

  symindx = 0;
  if (elf_group_id (sec) != NULL)
    symindx = elf_group_id (sec)->udata.i;

  if (symindx == 0)
    {
      /* If called from the assembler, swap_out_syms will have set up
	 elf_section_syms;  If called for "ld -r", use target_index.  */
      if (elf_section_syms (abfd) != NULL)
	symindx = elf_section_syms (abfd)[sec->index]->udata.i;
      else
	symindx = sec->target_index;
    }
  elf_section_data (sec)->this_hdr.sh_info = symindx;

  /* The contents won't be allocated for "ld -r" or objcopy.  */
  gas = TRUE;
  if (sec->contents == NULL)
    {
      gas = FALSE;
      sec->contents = bfd_alloc (abfd, sec->_raw_size);

      /* Arrange for the section to be written out.  */
      elf_section_data (sec)->this_hdr.contents = sec->contents;
      if (sec->contents == NULL)
	{
	  *failedptr = TRUE;
	  return;
	}
    }

  loc = sec->contents + sec->_raw_size;

  /* Get the pointer to the first section in the group that gas
     squirreled away here.  objcopy arranges for this to be set to the
     start of the input section group.  */
  first = elt = elf_next_in_group (sec);

  /* First element is a flag word.  Rest of section is elf section
     indices for all the sections of the group.  Write them backwards
     just to keep the group in the same order as given in .section
     directives, not that it matters.  */
  while (elt != NULL)
    {
      asection *s;
      unsigned int idx;

      loc -= 4;
      s = elt;
      if (!gas)
	s = s->output_section;
      idx = 0;
      if (s != NULL)
	idx = elf_section_data (s)->this_idx;
      H_PUT_32 (abfd, idx, loc);
      elt = elf_next_in_group (elt);
      if (elt == first)
	break;
    }

  /* If this is a relocatable link, then the above did nothing because
     SEC is the output section.  Look through the input sections
     instead.  */
  for (l = sec->link_order_head; l != NULL; l = l->next)
    if (l->type == bfd_indirect_link_order
	&& (elt = elf_next_in_group (l->u.indirect.section)) != NULL)
      do
	{
	  loc -= 4;
	  H_PUT_32 (abfd,
		    elf_section_data (elt->output_section)->this_idx, loc);
	  elt = elf_next_in_group (elt);
	  /* During a relocatable link, the lists are circular.  */
	}
      while (elt != elf_next_in_group (l->u.indirect.section));

  /* With ld -r, merging SHT_GROUP sections results in wasted space
     due to allowing for the flag word on each input.  We may well
     duplicate entries too.  */
  while ((loc -= 4) > sec->contents)
    H_PUT_32 (abfd, 0, loc);

  if (loc != sec->contents)
    abort ();

  H_PUT_32 (abfd, sec->flags & SEC_LINK_ONCE ? GRP_COMDAT : 0, loc);
}

/* Assign all ELF section numbers.  The dummy first section is handled here
   too.  The link/info pointers for the standard section types are filled
   in here too, while we're at it.  */

static bfd_boolean
assign_section_numbers (bfd *abfd)
{
  struct elf_obj_tdata *t = elf_tdata (abfd);
  asection *sec;
  unsigned int section_number, secn;
  Elf_Internal_Shdr **i_shdrp;
  bfd_size_type amt;

  section_number = 1;

  _bfd_elf_strtab_clear_all_refs (elf_shstrtab (abfd));

  for (sec = abfd->sections; sec; sec = sec->next)
    {
      struct bfd_elf_section_data *d = elf_section_data (sec);

      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      d->this_idx = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->this_hdr.sh_name);
      if ((sec->flags & SEC_RELOC) == 0)
	d->rel_idx = 0;
      else
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->rel_idx = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr.sh_name);
	}

      if (d->rel_hdr2)
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->rel_idx2 = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr2->sh_name);
	}
      else
	d->rel_idx2 = 0;
    }

  if (section_number == SHN_LORESERVE)
    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
  t->shstrtab_section = section_number++;
  _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->shstrtab_hdr.sh_name);
  elf_elfheader (abfd)->e_shstrndx = t->shstrtab_section;

  if (bfd_get_symcount (abfd) > 0)
    {
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      t->symtab_section = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->symtab_hdr.sh_name);
      if (section_number > SHN_LORESERVE - 2)
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  t->symtab_shndx_section = section_number++;
	  t->symtab_shndx_hdr.sh_name
	    = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
						  ".symtab_shndx", FALSE);
	  if (t->symtab_shndx_hdr.sh_name == (unsigned int) -1)
	    return FALSE;
	}
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      t->strtab_section = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);
    }

  _bfd_elf_strtab_finalize (elf_shstrtab (abfd));
  t->shstrtab_hdr.sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));

  elf_numsections (abfd) = section_number;
  elf_elfheader (abfd)->e_shnum = section_number;
  if (section_number > SHN_LORESERVE)
    elf_elfheader (abfd)->e_shnum -= SHN_HIRESERVE + 1 - SHN_LORESERVE;

  /* Set up the list of section header pointers, in agreement with the
     indices.  */
  amt = section_number * sizeof (Elf_Internal_Shdr *);
  i_shdrp = bfd_zalloc (abfd, amt);
  if (i_shdrp == NULL)
    return FALSE;

  amt = sizeof (Elf_Internal_Shdr);
  i_shdrp[0] = bfd_zalloc (abfd, amt);
  if (i_shdrp[0] == NULL)
    {
      bfd_release (abfd, i_shdrp);
      return FALSE;
    }

  elf_elfsections (abfd) = i_shdrp;

  i_shdrp[t->shstrtab_section] = &t->shstrtab_hdr;
  if (bfd_get_symcount (abfd) > 0)
    {
      i_shdrp[t->symtab_section] = &t->symtab_hdr;
      if (elf_numsections (abfd) > SHN_LORESERVE)
	{
	  i_shdrp[t->symtab_shndx_section] = &t->symtab_shndx_hdr;
	  t->symtab_shndx_hdr.sh_link = t->symtab_section;
	}
      i_shdrp[t->strtab_section] = &t->strtab_hdr;
      t->symtab_hdr.sh_link = t->strtab_section;
    }
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      struct bfd_elf_section_data *d = elf_section_data (sec);
      asection *s;
      const char *name;

      i_shdrp[d->this_idx] = &d->this_hdr;
      if (d->rel_idx != 0)
	i_shdrp[d->rel_idx] = &d->rel_hdr;
      if (d->rel_idx2 != 0)
	i_shdrp[d->rel_idx2] = d->rel_hdr2;

      /* Fill in the sh_link and sh_info fields while we're at it.  */

      /* sh_link of a reloc section is the section index of the symbol
	 table.  sh_info is the section index of the section to which
	 the relocation entries apply.  */
      if (d->rel_idx != 0)
	{
	  d->rel_hdr.sh_link = t->symtab_section;
	  d->rel_hdr.sh_info = d->this_idx;
	}
      if (d->rel_idx2 != 0)
	{
	  d->rel_hdr2->sh_link = t->symtab_section;
	  d->rel_hdr2->sh_info = d->this_idx;
	}

      switch (d->this_hdr.sh_type)
	{
	case SHT_REL:
	case SHT_RELA:
	  /* A reloc section which we are treating as a normal BFD
	     section.  sh_link is the section index of the symbol
	     table.  sh_info is the section index of the section to
	     which the relocation entries apply.  We assume that an
	     allocated reloc section uses the dynamic symbol table.
	     FIXME: How can we be sure?  */
	  s = bfd_get_section_by_name (abfd, ".dynsym");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;

	  /* We look up the section the relocs apply to by name.  */
	  name = sec->name;
	  if (d->this_hdr.sh_type == SHT_REL)
	    name += 4;
	  else
	    name += 5;
	  s = bfd_get_section_by_name (abfd, name);
	  if (s != NULL)
	    d->this_hdr.sh_info = elf_section_data (s)->this_idx;
	  break;

	case SHT_STRTAB:
	  /* We assume that a section named .stab*str is a stabs
	     string section.  We look for a section with the same name
	     but without the trailing ``str'', and set its sh_link
	     field to point to this section.  */
	  if (strncmp (sec->name, ".stab", sizeof ".stab" - 1) == 0
	      && strcmp (sec->name + strlen (sec->name) - 3, "str") == 0)
	    {
	      size_t len;
	      char *alc;

	      len = strlen (sec->name);
	      alc = bfd_malloc (len - 2);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, sec->name, len - 3);
	      alc[len - 3] = '\0';
	      s = bfd_get_section_by_name (abfd, alc);
	      free (alc);
	      if (s != NULL)
		{
		  elf_section_data (s)->this_hdr.sh_link = d->this_idx;

		  /* This is a .stab section.  */
		  if (elf_section_data (s)->this_hdr.sh_entsize == 0)
		    elf_section_data (s)->this_hdr.sh_entsize
		      = 4 + 2 * bfd_get_arch_size (abfd) / 8;
		}
	    }
	  break;

	case SHT_DYNAMIC:
	case SHT_DYNSYM:
	case SHT_GNU_verneed:
	case SHT_GNU_verdef:
	  /* sh_link is the section header index of the string table
	     used for the dynamic entries, or the symbol table, or the
	     version strings.  */
	  s = bfd_get_section_by_name (abfd, ".dynstr");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  break;

	case SHT_HASH:
	case SHT_GNU_versym:
	  /* sh_link is the section header index of the symbol table
	     this hash table or version table is for.  */
	  s = bfd_get_section_by_name (abfd, ".dynsym");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  break;

	case SHT_GROUP:
	  d->this_hdr.sh_link = t->symtab_section;
	}
    }

  for (secn = 1; secn < section_number; ++secn)
    if (i_shdrp[secn] == NULL)
      i_shdrp[secn] = i_shdrp[0];
    else
      i_shdrp[secn]->sh_name = _bfd_elf_strtab_offset (elf_shstrtab (abfd),
						       i_shdrp[secn]->sh_name);
  return TRUE;
}

/* Map symbol from it's internal number to the external number, moving
   all local symbols to be at the head of the list.  */

static int
sym_is_global (bfd *abfd, asymbol *sym)
{
  /* If the backend has a special mapping, use it.  */
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);

  return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
	  || bfd_is_und_section (bfd_get_section (sym))
	  || bfd_is_com_section (bfd_get_section (sym)));
}

static bfd_boolean
elf_map_symbols (bfd *abfd)
{
  unsigned int symcount = bfd_get_symcount (abfd);
  asymbol **syms = bfd_get_outsymbols (abfd);
  asymbol **sect_syms;
  unsigned int num_locals = 0;
  unsigned int num_globals = 0;
  unsigned int num_locals2 = 0;
  unsigned int num_globals2 = 0;
  int max_index = 0;
  unsigned int idx;
  asection *asect;
  asymbol **new_syms;
  bfd_size_type amt;

#ifdef DEBUG
  fprintf (stderr, "elf_map_symbols\n");
  fflush (stderr);
#endif

  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (max_index < asect->index)
	max_index = asect->index;
    }

  max_index++;
  amt = max_index * sizeof (asymbol *);
  sect_syms = bfd_zalloc (abfd, amt);
  if (sect_syms == NULL)
    return FALSE;
  elf_section_syms (abfd) = sect_syms;
  elf_num_section_syms (abfd) = max_index;

  /* Init sect_syms entries for any section symbols we have already
     decided to output.  */
  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];

      if ((sym->flags & BSF_SECTION_SYM) != 0
	  && sym->value == 0)
	{
	  asection *sec;

	  sec = sym->section;

	  if (sec->owner != NULL)
	    {
	      if (sec->owner != abfd)
		{
		  if (sec->output_offset != 0)
		    continue;

		  sec = sec->output_section;

		  /* Empty sections in the input files may have had a
		     section symbol created for them.  (See the comment
		     near the end of _bfd_generic_link_output_symbols in
		     linker.c).  If the linker script discards such
		     sections then we will reach this point.  Since we know
		     that we cannot avoid this case, we detect it and skip
		     the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the
		     linker testsuite test ld-scripts/weak.exp for an ELF
		     port that uses the generic linker.  */
		  if (sec->owner == NULL)
		    continue;

		  BFD_ASSERT (sec->owner == abfd);
		}
	      sect_syms[sec->index] = syms[idx];
	    }
	}
    }

  /* Classify all of the symbols.  */
  for (idx = 0; idx < symcount; idx++)
    {
      if (!sym_is_global (abfd, syms[idx]))
	num_locals++;
      else
	num_globals++;
    }

  /* We will be adding a section symbol for each BFD section.  Most normal
     sections will already have a section symbol in outsymbols, but
     eg. SHT_GROUP sections will not, and we need the section symbol mapped
     at least in that case.  */
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == NULL)
	{
	  if (!sym_is_global (abfd, asect->symbol))
	    num_locals++;
	  else
	    num_globals++;
	}
    }

  /* Now sort the symbols so the local symbols are first.  */
  amt = (num_locals + num_globals) * sizeof (asymbol *);
  new_syms = bfd_alloc (abfd, amt);

  if (new_syms == NULL)
    return FALSE;

  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];
      unsigned int i;

      if (!sym_is_global (abfd, sym))
	i = num_locals2++;
      else
	i = num_locals + num_globals2++;
      new_syms[i] = sym;
      sym->udata.i = i + 1;
    }
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == NULL)
	{
	  asymbol *sym = asect->symbol;
	  unsigned int i;

	  sect_syms[asect->index] = sym;
	  if (!sym_is_global (abfd, sym))
	    i = num_locals2++;
	  else
	    i = num_locals + num_globals2++;
	  new_syms[i] = sym;
	  sym->udata.i = i + 1;
	}
    }

  bfd_set_symtab (abfd, new_syms, num_locals + num_globals);

  elf_num_locals (abfd) = num_locals;
  elf_num_globals (abfd) = num_globals;
  return TRUE;
}

/* Align to the maximum file alignment that could be required for any
   ELF data structure.  */

static inline file_ptr
align_file_position (file_ptr off, int align)
{
  return (off + align - 1) & ~(align - 1);
}

/* Assign a file position to a section, optionally aligning to the
   required section alignment.  */

file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
					   file_ptr offset,
					   bfd_boolean align)
{
  if (align)
    {
      unsigned int al;

      al = i_shdrp->sh_addralign;
      if (al > 1)
	offset = BFD_ALIGN (offset, al);
    }
  i_shdrp->sh_offset = offset;
  if (i_shdrp->bfd_section != NULL)
    i_shdrp->bfd_section->filepos = offset;
  if (i_shdrp->sh_type != SHT_NOBITS)
    offset += i_shdrp->sh_size;
  return offset;
}

/* Compute the file positions we are going to put the sections at, and
   otherwise prepare to begin writing out the ELF file.  If LINK_INFO
   is not NULL, this is being called by the ELF backend linker.  */

bfd_boolean
_bfd_elf_compute_section_file_positions (bfd *abfd,
					 struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean failed;
  struct bfd_strtab_hash *strtab;
  Elf_Internal_Shdr *shstrtab_hdr;

  if (abfd->output_has_begun)
    return TRUE;

  /* Do any elf backend specific processing first.  */
  if (bed->elf_backend_begin_write_processing)
    (*bed->elf_backend_begin_write_processing) (abfd, link_info);

  if (! prep_headers (abfd))
    return FALSE;

  /* Post process the headers if necessary.  */
  if (bed->elf_backend_post_process_headers)
    (*bed->elf_backend_post_process_headers) (abfd, link_info);

  failed = FALSE;
  bfd_map_over_sections (abfd, elf_fake_sections, &failed);
  if (failed)
    return FALSE;

  if (!assign_section_numbers (abfd))
    return FALSE;

  /* The backend linker builds symbol table information itself.  */
  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
    {
      /* Non-zero if doing a relocatable link.  */
      int relocatable_p = ! (abfd->flags & (EXEC_P | DYNAMIC));

      if (! swap_out_syms (abfd, &strtab, relocatable_p))
	return FALSE;
    }

  if (link_info == NULL)
    {
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	return FALSE;
    }

  shstrtab_hdr = &elf_tdata (abfd)->shstrtab_hdr;
  /* sh_name was set in prep_headers.  */
  shstrtab_hdr->sh_type = SHT_STRTAB;
  shstrtab_hdr->sh_flags = 0;
  shstrtab_hdr->sh_addr = 0;
  shstrtab_hdr->sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));
  shstrtab_hdr->sh_entsize = 0;
  shstrtab_hdr->sh_link = 0;
  shstrtab_hdr->sh_info = 0;
  /* sh_offset is set in assign_file_positions_except_relocs.  */
  shstrtab_hdr->sh_addralign = 1;

  if (!assign_file_positions_except_relocs (abfd, link_info))
    return FALSE;

  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
    {
      file_ptr off;
      Elf_Internal_Shdr *hdr;

      off = elf_tdata (abfd)->next_file_pos;

      hdr = &elf_tdata (abfd)->symtab_hdr;
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      if (hdr->sh_size != 0)
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      hdr = &elf_tdata (abfd)->strtab_hdr;
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      elf_tdata (abfd)->next_file_pos = off;

      /* Now that we know where the .strtab section goes, write it
         out.  */
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, strtab))
	return FALSE;
      _bfd_stringtab_free (strtab);
    }

  abfd->output_has_begun = TRUE;

  return TRUE;
}

/* Create a mapping from a set of sections to a program segment.  */

static struct elf_segment_map *
make_mapping (bfd *abfd,
	      asection **sections,
	      unsigned int from,
	      unsigned int to,
	      bfd_boolean phdr)
{
  struct elf_segment_map *m;
  unsigned int i;
  asection **hdrpp;
  bfd_size_type amt;

  amt = sizeof (struct elf_segment_map);
  amt += (to - from - 1) * sizeof (asection *);
  m = bfd_zalloc (abfd, amt);
  if (m == NULL)
    return NULL;
  m->next = NULL;
  m->p_type = PT_LOAD;
  for (i = from, hdrpp = sections + from; i < to; i++, hdrpp++)
    m->sections[i - from] = *hdrpp;
  m->count = to - from;

  if (from == 0 && phdr)
    {
      /* Include the headers in the first PT_LOAD segment.  */
      m->includes_filehdr = 1;
      m->includes_phdrs = 1;
    }

  return m;
}

/* Set up a mapping from BFD sections to program segments.  */

static bfd_boolean
map_sections_to_segments (bfd *abfd)
{
  asection **sections = NULL;
  asection *s;
  unsigned int i;
  unsigned int count;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
  struct elf_segment_map *m;
  asection *last_hdr;
  bfd_vma last_size;
  unsigned int phdr_index;
  bfd_vma maxpagesize;
  asection **hdrpp;
  bfd_boolean phdr_in_segment = TRUE;
  bfd_boolean writable;
  int tls_count = 0;
  asection *first_tls = NULL;
  asection *dynsec, *eh_frame_hdr, *randomdata;
  bfd_size_type amt;

  if (elf_tdata (abfd)->segment_map != NULL)
    return TRUE;

  if (bfd_count_sections (abfd) == 0)
    return TRUE;

  /* Select the allocated sections, and sort them.  */

  amt = bfd_count_sections (abfd) * sizeof (asection *);
  sections = bfd_malloc (amt);
  if (sections == NULL)
    goto error_return;

  i = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_ALLOC) != 0)
	{
	  sections[i] = s;
	  ++i;
	}
    }
  BFD_ASSERT (i <= bfd_count_sections (abfd));
  count = i;

  qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);

  /* Build the mapping.  */

  mfirst = NULL;
  pm = &mfirst;

  /* If we have a .interp section, or are creating an executable and
     have a .dynamic section, then create a PT_PHDR segment for the
     program headers.  */
  s = bfd_get_section_by_name (abfd, ".interp");
  if ((s != NULL && (s->flags & SEC_LOAD) != 0) ||
      (bfd_get_section_by_name (abfd, ".dynamic") &&
       elf_tdata (abfd)->executable))
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_PHDR;
      /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
      m->p_flags = PF_R | PF_X;
      m->p_flags_valid = 1;
      m->includes_phdrs = 1;

      *pm = m;
      pm = &m->next;
    }      

  /* If we have a .interp section, then create a PT_INTERP segment for
     the .interp section.  */
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_INTERP;
      m->count = 1;
      m->sections[0] = s;

      *pm = m;
      pm = &m->next;
    }

  /* Look through the sections.  We put sections in the same program
     segment when the start of the second section can be placed within
     a few bytes of the end of the first section.  */
  last_hdr = NULL;
  last_size = 0;
  phdr_index = 0;
  maxpagesize = get_elf_backend_data (abfd)->maxpagesize;
  writable = FALSE;
  dynsec = bfd_get_section_by_name (abfd, ".dynamic");
  if (dynsec != NULL
      && (dynsec->flags & SEC_LOAD) == 0)
    dynsec = NULL;

  /* Deal with -Ttext or something similar such that the first section
     is not adjacent to the program headers.  This is an
     approximation, since at this point we don't know exactly how many
     program headers we will need.  */
  if (count > 0)
    {
      bfd_size_type phdr_size;

      phdr_size = elf_tdata (abfd)->program_header_size;
      if (phdr_size == 0)
	phdr_size = get_elf_backend_data (abfd)->s->sizeof_phdr;
      if ((abfd->flags & D_PAGED) == 0
	  || sections[0]->lma < phdr_size
	  || sections[0]->lma % maxpagesize < phdr_size % maxpagesize)
	phdr_in_segment = FALSE;
    }

  for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)
    {
      asection *hdr;
      bfd_boolean new_segment;

      hdr = *hdrpp;

      /* See if this section and the last one will fit in the same
         segment.  */

      if (last_hdr == NULL)
	{
	  /* If we don't have a segment yet, then we don't need a new
	     one (we build the last one after this loop).  */
	  new_segment = FALSE;
	}
      else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)
	{
	  /* If this section has a different relation between the
             virtual address and the load address, then we need a new
             segment.  */
	  new_segment = TRUE;
	}
      else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
	       < BFD_ALIGN (hdr->lma, maxpagesize))
	{
	  /* If putting this section in this segment would force us to
             skip a page in the segment, then we need a new segment.  */
	  new_segment = TRUE;
	}
      else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
	       && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
	{
	  /* We don't want to put a loadable section after a
             nonloadable section in the same segment.
             Consider .tbss sections as loadable for this purpose.  */
	  new_segment = TRUE;
	}
      else if ((abfd->flags & D_PAGED) == 0)
	{
	  /* If the file is not demand paged, which means that we
             don't require the sections to be correctly aligned in the
             file, then there is no other reason for a new segment.  */
	  new_segment = FALSE;
	}
      else if (! writable
	       && (hdr->flags & SEC_READONLY) == 0
	       && (((last_hdr->lma + last_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
	{
	  /* We don't want to put a writable section in a read only
             segment, unless they are on the same page in memory
             anyhow.  We already know that the last section does not
             bring us past the current section on the page, so the
             only case in which the new section is not on the same
             page as the previous section is when the previous section
             ends precisely on a page boundary.  */
	  new_segment = TRUE;
	}
      else
	{
	  /* Otherwise, we can use the same segment.  */
	  new_segment = FALSE;
	}

      if (! new_segment)
	{
	  if ((hdr->flags & SEC_READONLY) == 0)
	    writable = TRUE;
	  last_hdr = hdr;
	  /* .tbss sections effectively have zero size.  */
	  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	    last_size = hdr->_raw_size;
	  else
	    last_size = 0;
	  continue;
	}

      /* We need a new program segment.  We must create a new program
         header holding all the sections from phdr_index until hdr.  */

      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
      if (m == NULL)
	goto error_return;

      *pm = m;
      pm = &m->next;

      if ((hdr->flags & SEC_READONLY) == 0)
	writable = TRUE;
      else
	writable = FALSE;

      last_hdr = hdr;
      /* .tbss sections effectively have zero size.  */
      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	last_size = hdr->_raw_size;
      else
	last_size = 0;
      phdr_index = i;
      phdr_in_segment = FALSE;
    }

  /* Create a final PT_LOAD program segment.  */
  if (last_hdr != NULL)
    {
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
      if (m == NULL)
	goto error_return;

      *pm = m;
      pm = &m->next;
    }

  /* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
  if (dynsec != NULL)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_DYNAMIC;
      m->count = 1;
      m->sections[0] = dynsec;

      *pm = m;
      pm = &m->next;
    }

  /* For each loadable .note section, add a PT_NOTE segment.  We don't
     use bfd_get_section_by_name, because if we link together
     nonloadable .note sections and loadable .note sections, we will
     generate two .note sections in the output file.  FIXME: Using
     names for section types is bogus anyhow.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
	{
	  amt = sizeof (struct elf_segment_map);
	  m = bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_NOTE;
	  m->count = 1;
	  m->sections[0] = s;

	  *pm = m;
	  pm = &m->next;
	}
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  if (! tls_count)
	    first_tls = s;
	  tls_count++;
	}
    }

  /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
  if (tls_count > 0)
    {
      int i;

      amt = sizeof (struct elf_segment_map);
      amt += (tls_count - 1) * sizeof (asection *);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_TLS;
      m->count = tls_count;
      /* Mandated PF_R.  */
      m->p_flags = PF_R;
      m->p_flags_valid = 1;
      for (i = 0; i < tls_count; ++i)
	{
	  BFD_ASSERT (first_tls->flags & SEC_THREAD_LOCAL);
	  m->sections[i] = first_tls;
	  first_tls = first_tls->next;
	}

      *pm = m;
      pm = &m->next;
    }

  /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME
     segment.  */
  eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
  if (eh_frame_hdr != NULL
      && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_EH_FRAME;
      m->count = 1;
      m->sections[0] = eh_frame_hdr->output_section;

      *pm = m;
      pm = &m->next;
    }

  if (elf_tdata (abfd)->stack_flags)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_STACK;
      m->p_flags = elf_tdata (abfd)->stack_flags;
      m->p_flags_valid = 1;

      *pm = m;
      pm = &m->next;
    }

  /* If there is a .openbsd.randomdata section, throw in a PT_OPENBSD_RANDOMIZE
     segment.  */
  randomdata = bfd_get_section_by_name (abfd, ".openbsd.randomdata");
  if (randomdata != NULL && (randomdata->flags & SEC_LOAD) != 0)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_OPENBSD_RANDOMIZE;
      m->count = 1;
      m->sections[0] = randomdata->output_section;

      *pm = m;
      pm = &m->next;
    }

  free (sections);
  sections = NULL;

  elf_tdata (abfd)->segment_map = mfirst;
  return TRUE;

 error_return:
  if (sections != NULL)
    free (sections);
  return FALSE;
}

/* Sort sections by address.  */

static int
elf_sort_sections (const void *arg1, const void *arg2)
{
  const asection *sec1 = *(const asection **) arg1;
  const asection *sec2 = *(const asection **) arg2;
  bfd_size_type size1, size2;

  /* Sort by LMA first, since this is the address used to
     place the section into a segment.  */
  if (sec1->lma < sec2->lma)
    return -1;
  else if (sec1->lma > sec2->lma)
    return 1;

  /* Then sort by VMA.  Normally the LMA and the VMA will be
     the same, and this will do nothing.  */
  if (sec1->vma < sec2->vma)
    return -1;
  else if (sec1->vma > sec2->vma)
    return 1;

  /* Put !SEC_LOAD sections after SEC_LOAD ones.  */

#define TOEND(x) (((x)->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)

  if (TOEND (sec1))
    {
      if (TOEND (sec2))
	{
	  /* If the indicies are the same, do not return 0
	     here, but continue to try the next comparison.  */
	  if (sec1->target_index - sec2->target_index != 0)
	    return sec1->target_index - sec2->target_index;
	}
      else
	return 1;
    }
  else if (TOEND (sec2))
    return -1;

#undef TOEND

  /* Sort by size, to put zero sized sections
     before others at the same address.  */

  size1 = (sec1->flags & SEC_LOAD) ? sec1->_raw_size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->_raw_size : 0;

  if (size1 < size2)
    return -1;
  if (size1 > size2)
    return 1;

  return sec1->target_index - sec2->target_index;
}

/* Ian Lance Taylor writes:

   We shouldn't be using % with a negative signed number.  That's just
   not good.  We have to make sure either that the number is not
   negative, or that the number has an unsigned type.  When the types
   are all the same size they wind up as unsigned.  When file_ptr is a
   larger signed type, the arithmetic winds up as signed long long,
   which is wrong.

   What we're trying to say here is something like ``increase OFF by
   the least amount that will cause it to be equal to the VMA modulo
   the page size.''  */
/* In other words, something like:

   vma_offset = m->sections[0]->vma % bed->maxpagesize;
   off_offset = off % bed->maxpagesize;
   if (vma_offset < off_offset)
     adjustment = vma_offset + bed->maxpagesize - off_offset;
   else
     adjustment = vma_offset - off_offset;
     
   which can can be collapsed into the expression below.  */

static file_ptr
vma_page_aligned_bias (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
{
  return ((vma - off) % maxpagesize);
}

/* Assign file positions to the sections based on the mapping from
   sections to segments.  This function also sets up some fields in
   the file header, and writes out the program headers.  */

static bfd_boolean
assign_file_positions_for_segments (bfd *abfd, struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int count;
  struct elf_segment_map *m;
  unsigned int alloc;
  Elf_Internal_Phdr *phdrs;
  file_ptr off, voff;
  bfd_vma filehdr_vaddr, filehdr_paddr;
  bfd_vma phdrs_vaddr, phdrs_paddr;
  Elf_Internal_Phdr *p;
  bfd_size_type amt;

  if (elf_tdata (abfd)->segment_map == NULL)
    {
      if (! map_sections_to_segments (abfd))
	return FALSE;
    }
  else
    {
      /* The placement algorithm assumes that non allocated sections are
	 not in PT_LOAD segments.  We ensure this here by removing such
	 sections from the segment map.  */
      for (m = elf_tdata (abfd)->segment_map;
	   m != NULL;
	   m = m->next)
	{
	  unsigned int new_count;
	  unsigned int i;

	  if (m->p_type != PT_LOAD)
	    continue;

	  new_count = 0;
	  for (i = 0; i < m->count; i ++)
	    {
	      if ((m->sections[i]->flags & SEC_ALLOC) != 0)
		{
		  if (i != new_count)
		    m->sections[new_count] = m->sections[i];

		  new_count ++;
		}
	    }

	  if (new_count != m->count)
	    m->count = new_count;
	}
    }

  if (bed->elf_backend_modify_segment_map)
    {
      if (! (*bed->elf_backend_modify_segment_map) (abfd, link_info))
	return FALSE;
    }

  count = 0;
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
    ++count;

  elf_elfheader (abfd)->e_phoff = bed->s->sizeof_ehdr;
  elf_elfheader (abfd)->e_phentsize = bed->s->sizeof_phdr;
  elf_elfheader (abfd)->e_phnum = count;

  if (count == 0)
    return TRUE;

  /* If we already counted the number of program segments, make sure
     that we allocated enough space.  This happens when SIZEOF_HEADERS
     is used in a linker script.  */
  alloc = elf_tdata (abfd)->program_header_size / bed->s->sizeof_phdr;
  if (alloc != 0 && count > alloc)
    {
      ((*_bfd_error_handler)
       (_("%s: Not enough room for program headers (allocated %u, need %u)"),
	bfd_get_filename (abfd), alloc, count));
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (alloc == 0)
    alloc = count;

  amt = alloc * sizeof (Elf_Internal_Phdr);
  phdrs = bfd_alloc (abfd, amt);
  if (phdrs == NULL)
    return FALSE;

  off = bed->s->sizeof_ehdr;
  off += alloc * bed->s->sizeof_phdr;

  filehdr_vaddr = 0;
  filehdr_paddr = 0;
  phdrs_vaddr = 0;
  phdrs_paddr = 0;

  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
    {
      unsigned int i;
      asection **secpp;

      /* If elf_segment_map is not from map_sections_to_segments, the
         sections may not be correctly ordered.  NOTE: sorting should
	 not be done to the PT_NOTE section of a corefile, which may
	 contain several pseudo-sections artificially created by bfd.
	 Sorting these pseudo-sections breaks things badly.  */
      if (m->count > 1
	  && !(elf_elfheader (abfd)->e_type == ET_CORE
	       && m->p_type == PT_NOTE))
	qsort (m->sections, (size_t) m->count, sizeof (asection *),
	       elf_sort_sections);

      p->p_type = m->p_type;
      p->p_flags = m->p_flags;

      if (p->p_type == PT_LOAD
	  && m->count > 0
	  && (m->sections[0]->flags & SEC_ALLOC) != 0)
	{
	  if ((abfd->flags & D_PAGED) != 0)
	    off += vma_page_aligned_bias (m->sections[0]->vma, off,
					  bed->maxpagesize);
	  else
	    {
	      bfd_size_type align;

	      align = 0;
	      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
		{
		  bfd_size_type secalign;

		  secalign = bfd_get_section_alignment (abfd, *secpp);
		  if (secalign > align)
		    align = secalign;
		}

	      off += vma_page_aligned_bias (m->sections[0]->vma, off,
					    1 << align);
	    }
	}

      if (m->count == 0)
	p->p_vaddr = 0;
      else
	p->p_vaddr = m->sections[0]->vma;

      if (m->p_paddr_valid)
	p->p_paddr = m->p_paddr;
      else if (m->count == 0)
	p->p_paddr = 0;
      else
	p->p_paddr = m->sections[0]->lma;

      if (p->p_type == PT_LOAD
	  && (abfd->flags & D_PAGED) != 0)
	p->p_align = bed->maxpagesize;
      else if (m->count == 0)
	p->p_align = 1 << bed->s->log_file_align;
      else
	p->p_align = 0;

      p->p_offset = 0;
      p->p_filesz = 0;
      p->p_memsz = 0;

      if (m->includes_filehdr)
	{
	  if (! m->p_flags_valid)
	    p->p_flags |= PF_R;
	  p->p_offset = 0;
	  p->p_filesz = bed->s->sizeof_ehdr;
	  p->p_memsz = bed->s->sizeof_ehdr;
	  if (m->count > 0)
	    {
	      BFD_ASSERT (p->p_type == PT_LOAD);

	      if (p->p_vaddr < (bfd_vma) off)
		{
		  (*_bfd_error_handler)
		    (_("%s: Not enough room for program headers, try linking with -N"),
		     bfd_get_filename (abfd));
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}

	      p->p_vaddr -= off;
	      if (! m->p_paddr_valid)
		p->p_paddr -= off;
	    }
	  if (p->p_type == PT_LOAD)
	    {
	      filehdr_vaddr = p->p_vaddr;
	      filehdr_paddr = p->p_paddr;
	    }
	}

      if (m->includes_phdrs)
	{
	  if (! m->p_flags_valid)
	    p->p_flags |= PF_R;

	  if (m->includes_filehdr)
	    {
	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr + bed->s->sizeof_ehdr;
		  phdrs_paddr = p->p_paddr + bed->s->sizeof_ehdr;
		}
	    }
	  else
	    {
	      p->p_offset = bed->s->sizeof_ehdr;

	      if (m->count > 0)
		{
		  BFD_ASSERT (p->p_type == PT_LOAD);
		  p->p_vaddr -= off - p->p_offset;
		  if (! m->p_paddr_valid)
		    p->p_paddr -= off - p->p_offset;
		}

	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr;
		  phdrs_paddr = p->p_paddr;
		}
	      else
		phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;
	    }

	  p->p_filesz += alloc * bed->s->sizeof_phdr;
	  p->p_memsz += alloc * bed->s->sizeof_phdr;
	}

      if (p->p_type == PT_LOAD
	  || (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core))
	{
	  if (! m->includes_filehdr && ! m->includes_phdrs)
	    p->p_offset = off;
	  else
	    {
	      file_ptr adjust;

	      adjust = off - (p->p_offset + p->p_filesz);
	      p->p_filesz += adjust;
	      p->p_memsz += adjust;
	    }
	}

      voff = off;

      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
	{
	  asection *sec;
	  flagword flags;
	  bfd_size_type align;

	  sec = *secpp;
	  flags = sec->flags;
	  align = 1 << bfd_get_section_alignment (abfd, sec);

	  /* The section may have artificial alignment forced by a
	     link script.  Notice this case by the gap between the
	     cumulative phdr lma and the section's lma.  */
	  if (p->p_paddr + p->p_memsz < sec->lma)
	    {
	      bfd_vma adjust = sec->lma - (p->p_paddr + p->p_memsz);

	      p->p_memsz += adjust;
	      if (p->p_type == PT_LOAD
		  || (p->p_type == PT_NOTE
		      && bfd_get_format (abfd) == bfd_core))
		{
		  off += adjust;
		  voff += adjust;
		}
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_THREAD_LOCAL) != 0)
		p->p_filesz += adjust;
	    }

	  if (p->p_type == PT_LOAD)
	    {
	      bfd_signed_vma adjust;

	      if ((flags & SEC_LOAD) != 0)
		{
		  adjust = sec->lma - (p->p_paddr + p->p_memsz);
		  if (adjust < 0)
		    adjust = 0;
		}
	      else if ((flags & SEC_ALLOC) != 0)
		{
		  /* The section VMA must equal the file position
		     modulo the page size.  FIXME: I'm not sure if
		     this adjustment is really necessary.  We used to
		     not have the SEC_LOAD case just above, and then
		     this was necessary, but now I'm not sure.  */
		  if ((abfd->flags & D_PAGED) != 0)
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    bed->maxpagesize);
		  else
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    align);
		}
	      else
		adjust = 0;

	      if (adjust != 0)
		{
		  if (i == 0)
		    {
		      (* _bfd_error_handler) (_("\
Error: First section in segment (%s) starts at 0x%x whereas the segment starts at 0x%x"),
					      bfd_section_name (abfd, sec),
					      sec->lma,
					      p->p_paddr);
		      return FALSE;
		    }
		  p->p_memsz += adjust;
		  off += adjust;
		  voff += adjust;
		  if ((flags & SEC_LOAD) != 0)
		    p->p_filesz += adjust;
		}

	      sec->filepos = off;

	      /* We check SEC_HAS_CONTENTS here because if NOLOAD is
                 used in a linker script we may have a section with
                 SEC_LOAD clear but which is supposed to have
                 contents.  */
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_HAS_CONTENTS) != 0)
		off += sec->_raw_size;

	      if ((flags & SEC_ALLOC) != 0
		  && ((flags & SEC_LOAD) != 0
		      || (flags & SEC_THREAD_LOCAL) == 0))
		voff += sec->_raw_size;
	    }

	  if (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core)
	    {
	      /* The actual "note" segment has i == 0.
		 This is the one that actually contains everything.  */
	      if (i == 0)
		{
		  sec->filepos = off;
		  p->p_filesz = sec->_raw_size;
		  off += sec->_raw_size;
		  voff = off;
		}
	      else
		{
		  /* Fake sections -- don't need to be written.  */
		  sec->filepos = 0;
		  sec->_raw_size = 0;
		  flags = sec->flags = 0;
		}
	      p->p_memsz = 0;
	      p->p_align = 1;
	    }
	  else
	    {
	      if ((sec->flags & SEC_LOAD) != 0
		  || (sec->flags & SEC_THREAD_LOCAL) == 0
		  || p->p_type == PT_TLS)
	      p->p_memsz += sec->_raw_size;

	      if ((flags & SEC_LOAD) != 0)
		p->p_filesz += sec->_raw_size;

	      if (p->p_type == PT_TLS
		  && sec->_raw_size == 0
		  && (sec->flags & SEC_HAS_CONTENTS) == 0)
		{
		  struct bfd_link_order *o;
		  bfd_vma tbss_size = 0;

		  for (o = sec->link_order_head; o != NULL; o = o->next)
		    if (tbss_size < o->offset + o->size)
		      tbss_size = o->offset + o->size;

		  p->p_memsz += tbss_size;
		}

	      if (align > p->p_align
		  && (p->p_type != PT_LOAD || (abfd->flags & D_PAGED) == 0))
		p->p_align = align;
	    }

	  if (! m->p_flags_valid)
	    {
	      p->p_flags |= PF_R;
	      if ((flags & SEC_CODE) != 0)
		p->p_flags |= PF_X;
	      if ((flags & SEC_READONLY) == 0)
		p->p_flags |= PF_W;
	    }
	}
    }

  /* Now that we have set the section file positions, we can set up
     the file positions for the non PT_LOAD segments.  */
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
    {
      if (p->p_type != PT_LOAD && m->count > 0)
	{
	  BFD_ASSERT (! m->includes_filehdr && ! m->includes_phdrs);
	  p->p_offset = m->sections[0]->filepos;
	}
      if (m->count == 0)
	{
	  if (m->includes_filehdr)
	    {
	      p->p_vaddr = filehdr_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = filehdr_paddr;
	    }
	  else if (m->includes_phdrs)
	    {
	      p->p_vaddr = phdrs_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = phdrs_paddr;
	    }
	}
    }

  /* Clear out any program headers we allocated but did not use.  */
  for (; count < alloc; count++, p++)
    {
      memset (p, 0, sizeof *p);
      p->p_type = PT_NULL;
    }

  elf_tdata (abfd)->phdr = phdrs;

  elf_tdata (abfd)->next_file_pos = off;

  /* Write out the program headers.  */
  if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, SEEK_SET) != 0
      || bed->s->write_out_phdrs (abfd, phdrs, alloc) != 0)
    return FALSE;

  return TRUE;
}

/* Get the size of the program header.

   If this is called by the linker before any of the section VMA's are set, it
   can't calculate the correct value for a strange memory layout.  This only
   happens when SIZEOF_HEADERS is used in a linker script.  In this case,
   SORTED_HDRS is NULL and we assume the normal scenario of one text and one
   data segment (exclusive of .interp and .dynamic).

   ??? User written scripts must either not use SIZEOF_HEADERS, or assume there
   will be two segments.  */

static bfd_size_type
get_program_header_size (bfd *abfd)
{
  size_t segs;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We can't return a different result each time we're called.  */
  if (elf_tdata (abfd)->program_header_size != 0)
    return elf_tdata (abfd)->program_header_size;

  if (elf_tdata (abfd)->segment_map != NULL)
    {
      struct elf_segment_map *m;

      segs = 0;
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	++segs;
      elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
      return elf_tdata (abfd)->program_header_size;
    }

  /* We used to assume that two PT_LOAD segments would be enough,
     code and data, with the change to pad the PLT and GOT, this is no
     longer true. Now there can be several PT_LOAD sections. 7 seems
     to be enough with BSS_PLT and .rodata-X, where we have text, data,
     GOT, dynamic, PLT, bss */
  segs = 7;

  s = bfd_get_section_by_name (abfd, ".interp");
  s = bfd_get_section_by_name (abfd, ".interp");
  if ((s != NULL && (s->flags & SEC_LOAD) != 0) ||
      (bfd_get_section_by_name (abfd, ".dynamic") &&
       elf_tdata (abfd)->executable))
    {
      /* We need a PT_PHDR segment.  */
      ++segs;
    }

  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* If we have a loadable interpreter section, we need a
	 PT_INTERP segment.  */
      ++segs;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
    {
      /* We need a PT_DYNAMIC segment.  */
      ++segs;
    }

  if (bfd_get_section_by_name (abfd, ".openbsd.randomdata") != NULL)
    {
      /* We need a PT_OPENBSD_RANDOMIZE segment.  */
      ++segs;
    }

  if (elf_tdata (abfd)->eh_frame_hdr)
    {
      /* We need a PT_GNU_EH_FRAME segment.  */
      ++segs;
    }

  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
	{
	  /* We need a PT_NOTE segment.  */
	  ++segs;
	}
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  /* We need a PT_TLS segment.  */
	  ++segs;
	  break;
	}
    }

  /* Let the backend count up any program headers it might need.  */
  if (bed->elf_backend_additional_program_headers)
    {
      int a;

      a = (*bed->elf_backend_additional_program_headers) (abfd);
      if (a == -1)
	abort ();
      segs += a;
    }

  elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
  return elf_tdata (abfd)->program_header_size;
}

/* Work out the file positions of all the sections.  This is called by
   _bfd_elf_compute_section_file_positions.  All the section sizes and
   VMAs must be known before this is called.

   We do not consider reloc sections at this point, unless they form
   part of the loadable image.  Reloc sections are assigned file
   positions in assign_file_positions_for_relocs, which is called by
   write_object_contents and final_link.

   We also don't set the positions of the .symtab and .strtab here.  */

static bfd_boolean
assign_file_positions_except_relocs (bfd *abfd,
				     struct bfd_link_info *link_info)
{
  struct elf_obj_tdata * const tdata = elf_tdata (abfd);
  Elf_Internal_Ehdr * const i_ehdrp = elf_elfheader (abfd);
  Elf_Internal_Shdr ** const i_shdrpp = elf_elfsections (abfd);
  unsigned int num_sec = elf_numsections (abfd);
  file_ptr off;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      && bfd_get_format (abfd) != bfd_core)
    {
      Elf_Internal_Shdr **hdrpp;
      unsigned int i;

      /* Start after the ELF header.  */
      off = i_ehdrp->e_ehsize;

      /* We are not creating an executable, which means that we are
	 not creating a program header, and that the actual order of
	 the sections in the file is unimportant.  */
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
	{
	  Elf_Internal_Shdr *hdr;

	  hdr = *hdrpp;
	  if (hdr->sh_type == SHT_REL
	      || hdr->sh_type == SHT_RELA
	      || i == tdata->symtab_section
	      || i == tdata->symtab_shndx_section
	      || i == tdata->strtab_section)
	    {
	      hdr->sh_offset = -1;
	    }
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
	}
    }
  else
    {
      unsigned int i;
      Elf_Internal_Shdr **hdrpp;

      /* Assign file positions for the loaded sections based on the
         assignment of sections to segments.  */
      if (! assign_file_positions_for_segments (abfd, link_info))
	return FALSE;

      /* Assign file positions for the other sections.  */

      off = elf_tdata (abfd)->next_file_pos;
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
	{
	  Elf_Internal_Shdr *hdr;

	  hdr = *hdrpp;
	  if (hdr->bfd_section != NULL
	      && hdr->bfd_section->filepos != 0)
	    hdr->sh_offset = hdr->bfd_section->filepos;
	  else if ((hdr->sh_flags & SHF_ALLOC) != 0)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: warning: allocated section `%s' not in segment"),
		bfd_get_filename (abfd),
		(hdr->bfd_section == NULL
		 ? "*unknown*"
		 : hdr->bfd_section->name)));
	      if ((abfd->flags & D_PAGED) != 0)
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      bed->maxpagesize);
	      else
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      hdr->sh_addralign);
	      off = _bfd_elf_assign_file_position_for_section (hdr, off,
							       FALSE);
	    }
	  else if (hdr == i_shdrpp[tdata->symtab_section]
		   || hdr == i_shdrpp[tdata->symtab_shndx_section]
		   || hdr == i_shdrpp[tdata->strtab_section])
	    hdr->sh_offset = -1;
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
	}
    }

  /* Place the section headers.  */
  off = align_file_position (off, 1 << bed->s->log_file_align);
  i_ehdrp->e_shoff = off;
  off += i_ehdrp->e_shnum * i_ehdrp->e_shentsize;

  elf_tdata (abfd)->next_file_pos = off;

  return TRUE;
}

static bfd_boolean
prep_headers (bfd *abfd)
{
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_Internal_Phdr *i_phdrp = 0; /* Program header table, internal form */
  Elf_Internal_Shdr **i_shdrp;	/* Section header table, internal form */
  struct elf_strtab_hash *shstrtab;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  i_ehdrp = elf_elfheader (abfd);
  i_shdrp = elf_elfsections (abfd);

  shstrtab = _bfd_elf_strtab_init ();
  if (shstrtab == NULL)
    return FALSE;

  elf_shstrtab (abfd) = shstrtab;

  i_ehdrp->e_ident[EI_MAG0] = ELFMAG0;
  i_ehdrp->e_ident[EI_MAG1] = ELFMAG1;
  i_ehdrp->e_ident[EI_MAG2] = ELFMAG2;
  i_ehdrp->e_ident[EI_MAG3] = ELFMAG3;

  i_ehdrp->e_ident[EI_CLASS] = bed->s->elfclass;
  i_ehdrp->e_ident[EI_DATA] =
    bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;
  i_ehdrp->e_ident[EI_VERSION] = bed->s->ev_current;

  if ((abfd->flags & DYNAMIC) != 0)
    i_ehdrp->e_type = ET_DYN;
  else if ((abfd->flags & EXEC_P) != 0)
    i_ehdrp->e_type = ET_EXEC;
  else if (bfd_get_format (abfd) == bfd_core)
    i_ehdrp->e_type = ET_CORE;
  else
    i_ehdrp->e_type = ET_REL;

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_unknown:
      i_ehdrp->e_machine = EM_NONE;
      break;

      /* There used to be a long list of cases here, each one setting
	 e_machine to the same EM_* macro #defined as ELF_MACHINE_CODE
	 in the corresponding bfd definition.  To avoid duplication,
	 the switch was removed.  Machines that need special handling
	 can generally do it in elf_backend_final_write_processing(),
	 unless they need the information earlier than the final write.
	 Such need can generally be supplied by replacing the tests for
	 e_machine with the conditions used to determine it.  */
    default:
      i_ehdrp->e_machine = bed->elf_machine_code;
    }

  i_ehdrp->e_version = bed->s->ev_current;
  i_ehdrp->e_ehsize = bed->s->sizeof_ehdr;

  /* No program header, for now.  */
  i_ehdrp->e_phoff = 0;
  i_ehdrp->e_phentsize = 0;
  i_ehdrp->e_phnum = 0;

  /* Each bfd section is section header entry.  */
  i_ehdrp->e_entry = bfd_get_start_address (abfd);
  i_ehdrp->e_shentsize = bed->s->sizeof_shdr;

  /* If we're building an executable, we'll need a program header table.  */
  if (abfd->flags & EXEC_P)
    {
      /* It all happens later.  */
#if 0
      i_ehdrp->e_phentsize = sizeof (Elf_External_Phdr);

      /* elf_build_phdrs() returns a (NULL-terminated) array of
	 Elf_Internal_Phdrs.  */
      i_phdrp = elf_build_phdrs (abfd, i_ehdrp, i_shdrp, &i_ehdrp->e_phnum);
      i_ehdrp->e_phoff = outbase;
      outbase += i_ehdrp->e_phentsize * i_ehdrp->e_phnum;
#endif
    }
  else
    {
      i_ehdrp->e_phentsize = 0;
      i_phdrp = 0;
      i_ehdrp->e_phoff = 0;
    }

  elf_tdata (abfd)->symtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", FALSE);
  elf_tdata (abfd)->strtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", FALSE);
  elf_tdata (abfd)->shstrtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", FALSE);
  if (elf_tdata (abfd)->symtab_hdr.sh_name == (unsigned int) -1
      || elf_tdata (abfd)->symtab_hdr.sh_name == (unsigned int) -1
      || elf_tdata (abfd)->shstrtab_hdr.sh_name == (unsigned int) -1)
    return FALSE;

  return TRUE;
}

/* Assign file positions for all the reloc sections which are not part
   of the loadable file image.  */

void
_bfd_elf_assign_file_positions_for_relocs (bfd *abfd)
{
  file_ptr off;
  unsigned int i, num_sec;
  Elf_Internal_Shdr **shdrpp;

  off = elf_tdata (abfd)->next_file_pos;

  num_sec = elf_numsections (abfd);
  for (i = 1, shdrpp = elf_elfsections (abfd) + 1; i < num_sec; i++, shdrpp++)
    {
      Elf_Internal_Shdr *shdrp;

      shdrp = *shdrpp;
      if ((shdrp->sh_type == SHT_REL || shdrp->sh_type == SHT_RELA)
	  && shdrp->sh_offset == -1)
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, TRUE);
    }

  elf_tdata (abfd)->next_file_pos = off;
}

bfd_boolean
_bfd_elf_write_object_contents (bfd *abfd)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  Elf_Internal_Ehdr *i_ehdrp;
  Elf_Internal_Shdr **i_shdrp;
  bfd_boolean failed;
  unsigned int count, num_sec;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;

  i_shdrp = elf_elfsections (abfd);
  i_ehdrp = elf_elfheader (abfd);

  failed = FALSE;
  bfd_map_over_sections (abfd, bed->s->write_relocs, &failed);
  if (failed)
    return FALSE;

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* After writing the headers, we need to write the sections too...  */
  num_sec = elf_numsections (abfd);
  for (count = 1; count < num_sec; count++)
    {
      if (bed->elf_backend_section_processing)
	(*bed->elf_backend_section_processing) (abfd, i_shdrp[count]);
      if (i_shdrp[count]->contents)
	{
	  bfd_size_type amt = i_shdrp[count]->sh_size;

	  if (bfd_seek (abfd, i_shdrp[count]->sh_offset, SEEK_SET) != 0
	      || bfd_bwrite (i_shdrp[count]->contents, amt, abfd) != amt)
	    return FALSE;
	}
      if (count == SHN_LORESERVE - 1)
	count += SHN_HIRESERVE + 1 - SHN_LORESERVE;
    }

  /* Write out the section header names.  */
  if (bfd_seek (abfd, elf_tdata (abfd)->shstrtab_hdr.sh_offset, SEEK_SET) != 0
      || ! _bfd_elf_strtab_emit (abfd, elf_shstrtab (abfd)))
    return FALSE;

  if (bed->elf_backend_final_write_processing)
    (*bed->elf_backend_final_write_processing) (abfd,
						elf_tdata (abfd)->linker);

  return bed->s->write_shdrs_and_ehdr (abfd);
}

bfd_boolean
_bfd_elf_write_corefile_contents (bfd *abfd)
{
  /* Hopefully this can be done just like an object file.  */
  return _bfd_elf_write_object_contents (abfd);
}

/* Given a section, search the header to find them.  */

int
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
{
  const struct elf_backend_data *bed;
  int index;

  if (elf_section_data (asect) != NULL
      && elf_section_data (asect)->this_idx != 0)
    return elf_section_data (asect)->this_idx;

  if (bfd_is_abs_section (asect))
    index = SHN_ABS;
  else if (bfd_is_com_section (asect))
    index = SHN_COMMON;
  else if (bfd_is_und_section (asect))
    index = SHN_UNDEF;
  else
    {
      Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
      int maxindex = elf_numsections (abfd);

      for (index = 1; index < maxindex; index++)
	{
	  Elf_Internal_Shdr *hdr = i_shdrp[index];

	  if (hdr != NULL && hdr->bfd_section == asect)
	    return index;
	}
      index = -1;
    }

  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_from_bfd_section)
    {
      int retval = index;

      if ((*bed->elf_backend_section_from_bfd_section) (abfd, asect, &retval))
	return retval;
    }

  if (index == -1)
    bfd_set_error (bfd_error_nonrepresentable_section);

  return index;
}

/* Given a BFD symbol, return the index in the ELF symbol table, or -1
   on error.  */

int
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
{
  asymbol *asym_ptr = *asym_ptr_ptr;
  int idx;
  flagword flags = asym_ptr->flags;

  /* When gas creates relocations against local labels, it creates its
     own symbol for the section, but does put the symbol into the
     symbol chain, so udata is 0.  When the linker is generating
     relocatable output, this section symbol may be for one of the
     input sections rather than the output section.  */
  if (asym_ptr->udata.i == 0
      && (flags & BSF_SECTION_SYM)
      && asym_ptr->section)
    {
      int indx;

      if (asym_ptr->section->output_section != NULL)
	indx = asym_ptr->section->output_section->index;
      else
	indx = asym_ptr->section->index;
      if (indx < elf_num_section_syms (abfd)
	  && elf_section_syms (abfd)[indx] != NULL)
	asym_ptr->udata.i = elf_section_syms (abfd)[indx]->udata.i;
    }

  idx = asym_ptr->udata.i;

  if (idx == 0)
    {
      /* This case can occur when using --strip-symbol on a symbol
         which is used in a relocation entry.  */
      (*_bfd_error_handler)
	(_("%s: symbol `%s' required but not present"),
	 bfd_archive_filename (abfd), bfd_asymbol_name (asym_ptr));
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

#if DEBUG & 4
  {
    fprintf (stderr,
	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n",
	     (long) asym_ptr, asym_ptr->name, idx, flags,
	     elf_symbol_flags (flags));
    fflush (stderr);
  }
#endif

  return idx;
}

/* Copy private BFD data.  This copies any program header information.  */

static bfd_boolean
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
  const struct elf_backend_data *bed;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (elf_tdata (ibfd)->phdr == NULL)
    return TRUE;

  bed = get_elf_backend_data (ibfd);
  iehdr = elf_elfheader (ibfd);

  map_first = NULL;
  pointer_to_map = &map_first;

  num_segments = elf_elfheader (ibfd)->e_phnum;
  maxpagesize = get_elf_backend_data (obfd)->maxpagesize;

  /* Returns the end address of the segment + 1.  */
#define SEGMENT_END(segment, start)					\
  (start + (segment->p_memsz > segment->p_filesz			\
	    ? segment->p_memsz : segment->p_filesz))

#define SECTION_SIZE(section, segment)					\
  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\
    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\
   ? section->_raw_size : 0)

  /* Returns TRUE if the given section is contained within
     the given segment.  VMA addresses are compared.  */
#define IS_CONTAINED_BY_VMA(section, segment)				\
  (section->vma >= segment->p_vaddr					\
   && (section->vma + SECTION_SIZE (section, segment)			\
       <= (SEGMENT_END (segment, segment->p_vaddr))))

  /* Returns TRUE if the given section is contained within
     the given segment.  LMA addresses are compared.  */
#define IS_CONTAINED_BY_LMA(section, segment, base)			\
  (section->lma >= base							\
   && (section->lma + SECTION_SIZE (section, segment)			\
       <= SEGMENT_END (segment, base)))

  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc.  */
#define IS_COREFILE_NOTE(p, s)						\
  (p->p_type == PT_NOTE							\
   && bfd_get_format (ibfd) == bfd_core					\
   && s->vma == 0 && s->lma == 0					\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))

  /* The complicated case when p_vaddr is 0 is to handle the Solaris
     linker, which generates a PT_INTERP section with p_vaddr and
     p_memsz set to 0.  */
#define IS_SOLARIS_PT_INTERP(p, s)					\
  (p->p_vaddr == 0							\
   && p->p_paddr == 0							\
   && p->p_memsz == 0							\
   && p->p_filesz > 0							\
   && (s->flags & SEC_HAS_CONTENTS) != 0				\
   && s->_raw_size > 0							\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))

  /* Decide if the given section should be included in the given segment.
     A section will be included if:
       1. It is within the address space of the segment -- we use the LMA
          if that is set for the segment and the VMA otherwise,
       2. It is an allocated segment,
       3. There is an output section associated with it,
       4. The section has not already been allocated to a previous segment.
       5. PT_GNU_STACK segments do not include any sections.
       6. PT_TLS segment includes only SHF_TLS sections.
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
  ((((segment->p_paddr							\
      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
      : IS_CONTAINED_BY_VMA (section, segment))				\
     && (section->flags & SEC_ALLOC) != 0)				\
    || IS_COREFILE_NOTE (segment, section))				\
   && section->output_section != NULL					\
   && segment->p_type != PT_GNU_STACK					\
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
   && ! section->segment_mark)

  /* Returns TRUE iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)			\
  (seg1->field >= SEGMENT_END (seg2, seg2->field))

  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both
     their VMA address ranges and their LMA address ranges overlap.
     It is possible to have overlapping VMA ranges without overlapping LMA
     ranges.  RedBoot images for example can have both .data and .bss mapped
     to the same VMA range, but with the .data section mapped to a different
     LMA.  */
#define SEGMENT_OVERLAPS(seg1, seg2)					\
  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\
   && !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))

  /* Initialise the segment mark field.  */
  for (section = ibfd->sections; section != NULL; section = section->next)
    section->segment_mark = FALSE;

  /* Scan through the segments specified in the program header
     of the input BFD.  For this first scan we look for overlaps
     in the loadable segments.  These can be created by weird
     parameters to objcopy.  Also, fix some solaris weirdness.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    {
      unsigned int j;
      Elf_Internal_Phdr *segment2;

      if (segment->p_type == PT_INTERP)
	for (section = ibfd->sections; section; section = section->next)
	  if (IS_SOLARIS_PT_INTERP (segment, section))
	    {
	      /* Mininal change so that the normal section to segment
		 assignment code will work.  */
	      segment->p_vaddr = section->vma;
	      break;
	    }

      if (segment->p_type != PT_LOAD)
	continue;

      /* Determine if this segment overlaps any previous segments.  */
      for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2 ++)
	{
	  bfd_signed_vma extra_length;

	  if (segment2->p_type != PT_LOAD
	      || ! SEGMENT_OVERLAPS (segment, segment2))
	    continue;

	  /* Merge the two segments together.  */
	  if (segment2->p_vaddr < segment->p_vaddr)
	    {
	      /* Extend SEGMENT2 to include SEGMENT and then delete
                 SEGMENT.  */
	      extra_length =
		SEGMENT_END (segment, segment->p_vaddr)
		- SEGMENT_END (segment2, segment2->p_vaddr);

	      if (extra_length > 0)
		{
		  segment2->p_memsz  += extra_length;
		  segment2->p_filesz += extra_length;
		}

	      segment->p_type = PT_NULL;

	      /* Since we have deleted P we must restart the outer loop.  */
	      i = 0;
	      segment = elf_tdata (ibfd)->phdr;
	      break;
	    }
	  else
	    {
	      /* Extend SEGMENT to include SEGMENT2 and then delete
                 SEGMENT2.  */
	      extra_length =
		SEGMENT_END (segment2, segment2->p_vaddr)
		- SEGMENT_END (segment, segment->p_vaddr);

	      if (extra_length > 0)
		{
		  segment->p_memsz  += extra_length;
		  segment->p_filesz += extra_length;
		}

	      segment2->p_type = PT_NULL;
	    }
	}
    }

  /* The second scan attempts to assign sections to segments.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i ++, segment ++)
    {
      unsigned int  section_count;
      asection **   sections;
      asection *    output_section;
      unsigned int  isec;
      bfd_vma       matching_lma;
      bfd_vma       suggested_lma;
      unsigned int  j;
      bfd_size_type amt;

      if (segment->p_type == PT_NULL)
	continue;

      /* Compute how many sections might be placed into this segment.  */
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
	  ++section_count;

      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
      amt = sizeof (struct elf_segment_map);
      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = bfd_alloc (obfd, amt);
      if (map == NULL)
	return FALSE;

      /* Initialise the fields of the segment map.  Default to
	 using the physical address of the segment in the input BFD.  */
      map->next          = NULL;
      map->p_type        = segment->p_type;
      map->p_flags       = segment->p_flags;
      map->p_flags_valid = 1;
      map->p_paddr       = segment->p_paddr;
      map->p_paddr_valid = 1;

      /* Determine if this segment contains the ELF file header
	 and if it contains the program headers themselves.  */
      map->includes_filehdr = (segment->p_offset == 0
			       && segment->p_filesz >= iehdr->e_ehsize);

      map->includes_phdrs = 0;

      if (! phdr_included || segment->p_type != PT_LOAD)
	{
	  map->includes_phdrs =
	    (segment->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (segment->p_offset + segment->p_filesz
		 >= ((bfd_vma) iehdr->e_phoff
		     + iehdr->e_phnum * iehdr->e_phentsize)));

	  if (segment->p_type == PT_LOAD && map->includes_phdrs)
	    phdr_included = TRUE;
	}

      if (section_count == 0)
	{
	  /* Special segments, such as the PT_PHDR segment, may contain
	     no sections, but ordinary, loadable segments should contain
	     something.  They are allowed by the ELF spec however, so only
	     a warning is produced.  */
	  if (segment->p_type == PT_LOAD)
	    (*_bfd_error_handler)
	      (_("%s: warning: Empty loadable segment detected, is this intentional ?\n"),
	       bfd_archive_filename (ibfd));

	  map->count = 0;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  continue;
	}

      /* Now scan the sections in the input BFD again and attempt
	 to add their corresponding output sections to the segment map.
	 The problem here is how to handle an output section which has
	 been moved (ie had its LMA changed).  There are four possibilities:

	 1. None of the sections have been moved.
	    In this case we can continue to use the segment LMA from the
	    input BFD.

	 2. All of the sections have been moved by the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section.

	 3. Some of the sections have been moved, others have not.
	    In this case those sections which have not been moved can be
	    placed in the current segment which will have to have its size,
	    and possibly its LMA changed, and a new segment or segments will
	    have to be created to contain the other sections.

	 4. The sections have been moved, but not by the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section and we will have to create a new segment
	    or segments to contain the other sections.

	 In order to save time, we allocate an array to hold the section
	 pointers that we are interested in.  As these sections get assigned
	 to a segment, they are removed from this array.  */

      /* Gcc 2.96 miscompiles this code on mips. Don't do casting here
	 to work around this long long bug.  */
      amt = section_count * sizeof (asection *);
      sections = bfd_malloc (amt);
      if (sections == NULL)
	return FALSE;

      /* Step One: Scan for segment vs section LMA conflicts.
	 Also add the sections to the section array allocated above.
	 Also add the sections to the current segment.  In the common
	 case, where the sections have not been moved, this means that
	 we have completely filled the segment, and there is nothing
	 more to do.  */
      isec = 0;
      matching_lma = 0;
      suggested_lma = 0;

      for (j = 0, section = ibfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
	    {
	      output_section = section->output_section;

	      sections[j ++] = section;

	      /* The Solaris native linker always sets p_paddr to 0.
		 We try to catch that case here, and set it to the
		 correct value.  Note - some backends require that
		 p_paddr be left as zero.  */
	      if (segment->p_paddr == 0
		  && segment->p_vaddr != 0
		  && (! bed->want_p_paddr_set_to_zero)
		  && isec == 0
		  && output_section->lma != 0
		  && (output_section->vma == (segment->p_vaddr
					      + (map->includes_filehdr
						 ? iehdr->e_ehsize
						 : 0)
					      + (map->includes_phdrs
						 ? (iehdr->e_phnum
						    * iehdr->e_phentsize)
						 : 0))))
		map->p_paddr = segment->p_vaddr;

	      /* Match up the physical address of the segment with the
		 LMA address of the output section.  */
	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section)
		  || (bed->want_p_paddr_set_to_zero &&
		      IS_CONTAINED_BY_VMA (output_section, segment))
                )
		{
		  if (matching_lma == 0)
		    matching_lma = output_section->lma;

		  /* We assume that if the section fits within the segment
		     then it does not overlap any other section within that
		     segment.  */
		  map->sections[isec ++] = output_section;
		}
	      else if (suggested_lma == 0)
		suggested_lma = output_section->lma;
	    }
	}

      BFD_ASSERT (j == section_count);

      /* Step Two: Adjust the physical address of the current segment,
	 if necessary.  */
      if (isec == section_count)
	{
	  /* All of the sections fitted within the segment as currently
	     specified.  This is the default case.  Add the segment to
	     the list of built segments and carry on to process the next
	     program header in the input BFD.  */
	  map->count = section_count;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  free (sections);
	  continue;
	}
      else
	{
	  if (matching_lma != 0)
	    {
	      /* At least one section fits inside the current segment.
		 Keep it, but modify its physical address to match the
		 LMA of the first section that fitted.  */
	      map->p_paddr = matching_lma;
	    }
	  else
	    {
	      /* None of the sections fitted inside the current segment.
		 Change the current segment's physical address to match
		 the LMA of the first section.  */
	      map->p_paddr = suggested_lma;
	    }

	  /* Offset the segment physical address from the lma
	     to allow for space taken up by elf headers.  */
	  if (map->includes_filehdr)
	    map->p_paddr -= iehdr->e_ehsize;

	  if (map->includes_phdrs)
	    {
	      map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;

	      /* iehdr->e_phnum is just an estimate of the number
		 of program headers that we will need.  Make a note
		 here of the number we used and the segment we chose
		 to hold these headers, so that we can adjust the
		 offset when we know the correct value.  */
	      phdr_adjust_num = iehdr->e_phnum;
	      phdr_adjust_seg = map;
	    }
	}

      /* Step Three: Loop over the sections again, this time assigning
	 those that fit to the current segment and removing them from the
	 sections array; but making sure not to leave large gaps.  Once all
	 possible sections have been assigned to the current segment it is
	 added to the list of built segments and if sections still remain
	 to be assigned, a new segment is constructed before repeating
	 the loop.  */
      isec = 0;
      do
	{
	  map->count = 0;
	  suggested_lma = 0;

	  /* Fill the current segment with sections that fit.  */
	  for (j = 0; j < section_count; j++)
	    {
	      section = sections[j];

	      if (section == NULL)
		continue;

	      output_section = section->output_section;

	      BFD_ASSERT (output_section != NULL);

	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section))
		{
		  if (map->count == 0)
		    {
		      /* If the first section in a segment does not start at
			 the beginning of the segment, then something is
			 wrong.  */
		      if (output_section->lma !=
			  (map->p_paddr
			   + (map->includes_filehdr ? iehdr->e_ehsize : 0)
			   + (map->includes_phdrs
			      ? iehdr->e_phnum * iehdr->e_phentsize
			      : 0)))
			abort ();
		    }
		  else
		    {
		      asection * prev_sec;

		      prev_sec = map->sections[map->count - 1];

		      /* If the gap between the end of the previous section
			 and the start of this section is more than
			 maxpagesize then we need to start a new segment.  */
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size,
				      maxpagesize)
			   < BFD_ALIGN (output_section->lma, maxpagesize))
			  || ((prev_sec->lma + prev_sec->_raw_size)
			      > output_section->lma))
			{
			  if (suggested_lma == 0)
			    suggested_lma = output_section->lma;

			  continue;
			}
		    }

		  map->sections[map->count++] = output_section;
		  ++isec;
		  sections[j] = NULL;
		  section->segment_mark = TRUE;
		}
	      else if (suggested_lma == 0)
		suggested_lma = output_section->lma;
	    }

	  BFD_ASSERT (map->count > 0);

	  /* Add the current segment to the list of built segments.  */
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  if (isec < section_count)
	    {
	      /* We still have not allocated all of the sections to
		 segments.  Create a new segment here, initialise it
		 and carry on looping.  */
	      amt = sizeof (struct elf_segment_map);
	      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
	      map = bfd_alloc (obfd, amt);
	      if (map == NULL)
		{
		  free (sections);
		  return FALSE;
		}

	      /* Initialise the fields of the segment map.  Set the physical
		 physical address to the LMA of the first section that has
		 not yet been assigned.  */
	      map->next             = NULL;
	      map->p_type           = segment->p_type;
	      map->p_flags          = segment->p_flags;
	      map->p_flags_valid    = 1;
	      map->p_paddr          = suggested_lma;
	      map->p_paddr_valid    = 1;
	      map->includes_filehdr = 0;
	      map->includes_phdrs   = 0;
	    }
	}
      while (isec < section_count);

      free (sections);
    }

  /* The Solaris linker creates program headers in which all the
     p_paddr fields are zero.  When we try to objcopy or strip such a
     file, we get confused.  Check for this case, and if we find it
     reset the p_paddr_valid fields.  */
  for (map = map_first; map != NULL; map = map->next)
    if (map->p_paddr != 0)
      break;
  if (map == NULL)
    for (map = map_first; map != NULL; map = map->next)
      map->p_paddr_valid = 0;

  elf_tdata (obfd)->segment_map = map_first;

  /* If we had to estimate the number of program headers that were
     going to be needed, then check our estimate now and adjust
     the offset if necessary.  */
  if (phdr_adjust_seg != NULL)
    {
      unsigned int count;

      for (count = 0, map = map_first; map != NULL; map = map->next)
	count++;

      if (count > phdr_adjust_num)
	phdr_adjust_seg->p_paddr
	  -= (count - phdr_adjust_num) * iehdr->e_phentsize;
    }

#if 0
  /* Final Step: Sort the segments into ascending order of physical
     address.  */
  if (map_first != NULL)
    {
      struct elf_segment_map *prev;

      prev = map_first;
      for (map = map_first->next; map != NULL; prev = map, map = map->next)
	{
	  /* Yes I know - its a bubble sort....  */
	  if (map->next != NULL && (map->next->p_paddr < map->p_paddr))
	    {
	      /* Swap map and map->next.  */
	      prev->next = map->next;
	      map->next = map->next->next;
	      prev->next->next = map;

	      /* Restart loop.  */
	      map = map_first;
	    }
	}
    }
#endif

#undef SEGMENT_END
#undef SECTION_SIZE
#undef IS_CONTAINED_BY_VMA
#undef IS_CONTAINED_BY_LMA
#undef IS_COREFILE_NOTE
#undef IS_SOLARIS_PT_INTERP
#undef INCLUDE_SECTION_IN_SEGMENT
#undef SEGMENT_AFTER_SEGMENT
#undef SEGMENT_OVERLAPS
  return TRUE;
}

/* Copy private section information.  This copies over the entsize
   field, and sometimes the info field.  */

bfd_boolean
_bfd_elf_copy_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec)
{
  Elf_Internal_Shdr *ihdr, *ohdr;

  if (ibfd->xvec->flavour != bfd_target_elf_flavour
      || obfd->xvec->flavour != bfd_target_elf_flavour)
    return TRUE;

  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
	asection *s;

	/* Only set up the segments if there are no more SEC_ALLOC
	   sections.  FIXME: This won't do the right thing if objcopy is
	   used to remove the last SEC_ALLOC section, since objcopy
	   won't call this routine in that case.  */
	for (s = isec->next; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) != 0)
	    break;
	if (s == NULL)
	  {
	    if (! copy_private_bfd_data (ibfd, obfd))
	      return FALSE;
	  }
    }

  ihdr = &elf_section_data (isec)->this_hdr;
  ohdr = &elf_section_data (osec)->this_hdr;

  ohdr->sh_entsize = ihdr->sh_entsize;

  if (ihdr->sh_type == SHT_SYMTAB
      || ihdr->sh_type == SHT_DYNSYM
      || ihdr->sh_type == SHT_GNU_verneed
      || ihdr->sh_type == SHT_GNU_verdef)
    ohdr->sh_info = ihdr->sh_info;

  /* Set things up for objcopy.  The output SHT_GROUP section will
     have its elf_next_in_group pointing back to the input group
     members.  */
  elf_next_in_group (osec) = elf_next_in_group (isec);
  elf_group_name (osec) = elf_group_name (isec);

  osec->use_rela_p = isec->use_rela_p;

  return TRUE;
}

/* Copy private symbol information.  If this symbol is in a section
   which we did not map into a BFD section, try to map the section
   index correctly.  We use special macro definitions for the mapped
   section indices; these definitions are interpreted by the
   swap_out_syms function.  */

#define MAP_ONESYMTAB (SHN_HIOS + 1)
#define MAP_DYNSYMTAB (SHN_HIOS + 2)
#define MAP_STRTAB    (SHN_HIOS + 3)
#define MAP_SHSTRTAB  (SHN_HIOS + 4)
#define MAP_SYM_SHNDX (SHN_HIOS + 5)

bfd_boolean
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
				   asymbol *isymarg,
				   bfd *obfd,
				   asymbol *osymarg)
{
  elf_symbol_type *isym, *osym;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  isym = elf_symbol_from (ibfd, isymarg);
  osym = elf_symbol_from (obfd, osymarg);

  if (isym != NULL
      && osym != NULL
      && bfd_is_abs_section (isym->symbol.section))
    {
      unsigned int shndx;

      shndx = isym->internal_elf_sym.st_shndx;
      if (shndx == elf_onesymtab (ibfd))
	shndx = MAP_ONESYMTAB;
      else if (shndx == elf_dynsymtab (ibfd))
	shndx = MAP_DYNSYMTAB;
      else if (shndx == elf_tdata (ibfd)->strtab_section)
	shndx = MAP_STRTAB;
      else if (shndx == elf_tdata (ibfd)->shstrtab_section)
	shndx = MAP_SHSTRTAB;
      else if (shndx == elf_tdata (ibfd)->symtab_shndx_section)
	shndx = MAP_SYM_SHNDX;
      osym->internal_elf_sym.st_shndx = shndx;
    }

  return TRUE;
}

/* Swap out the symbols.  */

static bfd_boolean
swap_out_syms (bfd *abfd,
	       struct bfd_strtab_hash **sttp,
	       int relocatable_p)
{
  const struct elf_backend_data *bed;
  int symcount;
  asymbol **syms;
  struct bfd_strtab_hash *stt;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  char *outbound_syms;
  char *outbound_shndx;
  int idx;
  bfd_size_type amt;
  bfd_boolean name_local_sections;

  if (!elf_map_symbols (abfd))
    return FALSE;

  /* Dump out the symtabs.  */
  stt = _bfd_elf_stringtab_init ();
  if (stt == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);
  symcount = bfd_get_symcount (abfd);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  symtab_hdr->sh_type = SHT_SYMTAB;
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
  symtab_hdr->sh_info = elf_num_locals (abfd) + 1;
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;

  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  symstrtab_hdr->sh_type = SHT_STRTAB;

  amt = (bfd_size_type) (1 + symcount) * bed->s->sizeof_sym;
  outbound_syms = bfd_alloc (abfd, amt);
  if (outbound_syms == NULL)
    {
      _bfd_stringtab_free (stt);
      return FALSE;
    }
  symtab_hdr->contents = outbound_syms;

  outbound_shndx = NULL;
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      amt = (bfd_size_type) (1 + symcount) * sizeof (Elf_External_Sym_Shndx);
      outbound_shndx = bfd_zalloc (abfd, amt);
      if (outbound_shndx == NULL)
	{
	  _bfd_stringtab_free (stt);
	  return FALSE;
	}

      symtab_shndx_hdr->contents = outbound_shndx;
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_size = amt;
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
    }

  /* Now generate the data (for "contents").  */
  {
    /* Fill in zeroth symbol and swap it out.  */
    Elf_Internal_Sym sym;
    sym.st_name = 0;
    sym.st_value = 0;
    sym.st_size = 0;
    sym.st_info = 0;
    sym.st_other = 0;
    sym.st_shndx = SHN_UNDEF;
    bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
    outbound_syms += bed->s->sizeof_sym;
    if (outbound_shndx != NULL)
      outbound_shndx += sizeof (Elf_External_Sym_Shndx);
  }

  name_local_sections
    = (bed->elf_backend_name_local_section_symbols
       && bed->elf_backend_name_local_section_symbols (abfd));

  syms = bfd_get_outsymbols (abfd);
  for (idx = 0; idx < symcount; idx++)
    {
      Elf_Internal_Sym sym;
      bfd_vma value = syms[idx]->value;
      elf_symbol_type *type_ptr;
      flagword flags = syms[idx]->flags;
      int type;

      if (!name_local_sections
	  && (flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
	{
	  /* Local section symbols have no name.  */
	  sym.st_name = 0;
	}
      else
	{
	  sym.st_name = (unsigned long) _bfd_stringtab_add (stt,
							    syms[idx]->name,
							    TRUE, FALSE);
	  if (sym.st_name == (unsigned long) -1)
	    {
	      _bfd_stringtab_free (stt);
	      return FALSE;
	    }
	}

      type_ptr = elf_symbol_from (abfd, syms[idx]);

      if ((flags & BSF_SECTION_SYM) == 0
	  && bfd_is_com_section (syms[idx]->section))
	{
	  /* ELF common symbols put the alignment into the `value' field,
	     and the size into the `size' field.  This is backwards from
	     how BFD handles it, so reverse it here.  */
	  sym.st_size = value;
	  if (type_ptr == NULL
	      || type_ptr->internal_elf_sym.st_value == 0)
	    sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
	  else
	    sym.st_value = type_ptr->internal_elf_sym.st_value;
	  sym.st_shndx = _bfd_elf_section_from_bfd_section
	    (abfd, syms[idx]->section);
	}
      else
	{
	  asection *sec = syms[idx]->section;
	  int shndx;

	  if (sec->output_section)
	    {
	      value += sec->output_offset;
	      sec = sec->output_section;
	    }

	  /* Don't add in the section vma for relocatable output.  */
	  if (! relocatable_p)
	    value += sec->vma;
	  sym.st_value = value;
	  sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

	  if (bfd_is_abs_section (sec)
	      && type_ptr != NULL
	      && type_ptr->internal_elf_sym.st_shndx != 0)
	    {
	      /* This symbol is in a real ELF section which we did
		 not create as a BFD section.  Undo the mapping done
		 by copy_private_symbol_data.  */
	      shndx = type_ptr->internal_elf_sym.st_shndx;
	      switch (shndx)
		{
		case MAP_ONESYMTAB:
		  shndx = elf_onesymtab (abfd);
		  break;
		case MAP_DYNSYMTAB:
		  shndx = elf_dynsymtab (abfd);
		  break;
		case MAP_STRTAB:
		  shndx = elf_tdata (abfd)->strtab_section;
		  break;
		case MAP_SHSTRTAB:
		  shndx = elf_tdata (abfd)->shstrtab_section;
		  break;
		case MAP_SYM_SHNDX:
		  shndx = elf_tdata (abfd)->symtab_shndx_section;
		  break;
		default:
		  break;
		}
	    }
	  else
	    {
	      shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

	      if (shndx == -1)
		{
		  asection *sec2;

		  /* Writing this would be a hell of a lot easier if
		     we had some decent documentation on bfd, and
		     knew what to expect of the library, and what to
		     demand of applications.  For example, it
		     appears that `objcopy' might not set the
		     section of a symbol to be a section that is
		     actually in the output file.  */
		  sec2 = bfd_get_section_by_name (abfd, sec->name);
		  if (sec2 == NULL)
		    {
		      _bfd_error_handler (_("\
Unable to find equivalent output section for symbol '%s' from section '%s'"),
					  syms[idx]->name ? syms[idx]->name : "<Local sym>",
					  sec->name);
		      bfd_set_error (bfd_error_invalid_operation);
		      _bfd_stringtab_free (stt);
		      return FALSE;
		    }

		  shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
		  BFD_ASSERT (shndx != -1);
		}
	    }

	  sym.st_shndx = shndx;
	}

      if ((flags & BSF_THREAD_LOCAL) != 0)
	type = STT_TLS;
      else if ((flags & BSF_FUNCTION) != 0)
	type = STT_FUNC;
      else if ((flags & BSF_OBJECT) != 0)
	type = STT_OBJECT;
      else
	type = STT_NOTYPE;

      if (syms[idx]->section->flags & SEC_THREAD_LOCAL)
	type = STT_TLS;

      /* Processor-specific types.  */
      if (type_ptr != NULL
	  && bed->elf_backend_get_symbol_type)
	type = ((*bed->elf_backend_get_symbol_type)
		(&type_ptr->internal_elf_sym, type));

      if (flags & BSF_SECTION_SYM)
	{
	  if (flags & BSF_GLOBAL)
	    sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  else
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	}
      else if (bfd_is_com_section (syms[idx]->section))
	sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
      else if (bfd_is_und_section (syms[idx]->section))
	sym.st_info = ELF_ST_INFO (((flags & BSF_WEAK)
				    ? STB_WEAK
				    : STB_GLOBAL),
				   type);
      else if (flags & BSF_FILE)
	sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
      else
	{
	  int bind = STB_LOCAL;

	  if (flags & BSF_LOCAL)
	    bind = STB_LOCAL;
	  else if (flags & BSF_WEAK)
	    bind = STB_WEAK;
	  else if (flags & BSF_GLOBAL)
	    bind = STB_GLOBAL;

	  sym.st_info = ELF_ST_INFO (bind, type);
	}

      if (type_ptr != NULL)
	sym.st_other = type_ptr->internal_elf_sym.st_other;
      else
	sym.st_other = 0;

      bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
      outbound_syms += bed->s->sizeof_sym;
      if (outbound_shndx != NULL)
	outbound_shndx += sizeof (Elf_External_Sym_Shndx);
    }

  *sttp = stt;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (stt);
  symstrtab_hdr->sh_type = SHT_STRTAB;

  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  symstrtab_hdr->sh_addralign = 1;

  return TRUE;
}

/* Return the number of bytes required to hold the symtab vector.

   Note that we base it on the count plus 1, since we will null terminate
   the vector allocated based on this size.  However, the ELF symbol table
   always has a dummy entry as symbol #0, so it ends up even.  */

long
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->symtab_hdr;

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
				sec_ptr asect)
{
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

/* Canonicalize the relocs.  */

long
_bfd_elf_canonicalize_reloc (bfd *abfd,
			     sec_ptr section,
			     arelent **relptr,
			     asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count;
}

long
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);

  if (symcount >= 0)
    bfd_get_symcount (abfd) = symcount;
  return symcount;
}

long
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
				      asymbol **allocation)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);

  if (symcount >= 0)
    bfd_get_dynamic_symcount (abfd) = symcount;
  return symcount;
}

/* Return the size required for the dynamic reloc entries.  Any
   section that was actually installed in the BFD, and has type
   SHT_REL or SHT_RELA, and uses the dynamic symbol table, is
   considered to be a dynamic reloc section.  */

long
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  long ret;
  asection *s;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  ret = sizeof (arelent *);
  for (s = abfd->sections; s != NULL; s = s->next)
    if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	&& (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	    || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
      ret += ((s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize)
	      * sizeof (arelent *));

  return ret;
}

/* Canonicalize the dynamic relocation entries.  Note that we return
   the dynamic relocations as a single block, although they are
   actually associated with particular sections; the interface, which
   was designed for SunOS style shared libraries, expects that there
   is only one set of dynamic relocs.  Any section that was actually
   installed in the BFD, and has type SHT_REL or SHT_RELA, and uses
   the dynamic symbol table, is considered to be a dynamic reloc
   section.  */

long
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
				     arelent **storage,
				     asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read in the version information.  */

bfd_boolean
_bfd_elf_slurp_version_tables (bfd *abfd)
{
  bfd_byte *contents = NULL;
  bfd_size_type amt;

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verdef *everdef;
      Elf_Internal_Verdef *iverdef;
      Elf_Internal_Verdef *iverdefarr;
      Elf_Internal_Verdef iverdefmem;
      unsigned int i;
      unsigned int maxidx;

      hdr = &elf_tdata (abfd)->dynverdef_hdr;

      contents = bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;

      /* We know the number of entries in the section but not the maximum
	 index.  Therefore we have to run through all entries and find
	 the maximum.  */
      everdef = (Elf_External_Verdef *) contents;
      maxidx = 0;
      for (i = 0; i < hdr->sh_info; ++i)
	{
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)
	    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdefmem.vd_next));
	}

      amt = (bfd_size_type) maxidx * sizeof (Elf_Internal_Verdef);
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = maxidx;

      everdef = (Elf_External_Verdef *) contents;
      iverdefarr = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++)
	{
	  Elf_External_Verdaux *everdaux;
	  Elf_Internal_Verdaux *iverdaux;
	  unsigned int j;

	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];
	  memcpy (iverdef, &iverdefmem, sizeof (Elf_Internal_Verdef));

	  iverdef->vd_bfd = abfd;

	  amt = (bfd_size_type) iverdef->vd_cnt * sizeof (Elf_Internal_Verdaux);
	  iverdef->vd_auxptr = bfd_alloc (abfd, amt);
	  if (iverdef->vd_auxptr == NULL)
	    goto error_return;

	  everdaux = ((Elf_External_Verdaux *)
		      ((bfd_byte *) everdef + iverdef->vd_aux));
	  iverdaux = iverdef->vd_auxptr;
	  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
	    {
	      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);

	      iverdaux->vda_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 iverdaux->vda_name);
	      if (iverdaux->vda_nodename == NULL)
		goto error_return;

	      if (j + 1 < iverdef->vd_cnt)
		iverdaux->vda_nextptr = iverdaux + 1;
	      else
		iverdaux->vda_nextptr = NULL;

	      everdaux = ((Elf_External_Verdaux *)
			  ((bfd_byte *) everdaux + iverdaux->vda_next));
	    }

	  iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;

	  if (i + 1 < hdr->sh_info)
	    iverdef->vd_nextdef = iverdef + 1;
	  else
	    iverdef->vd_nextdef = NULL;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdef->vd_next));
	}

      free (contents);
      contents = NULL;
    }

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verneed *everneed;
      Elf_Internal_Verneed *iverneed;
      unsigned int i;

      hdr = &elf_tdata (abfd)->dynverref_hdr;

      amt = (bfd_size_type) hdr->sh_info * sizeof (Elf_Internal_Verneed);
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
      if (elf_tdata (abfd)->verref == NULL)
	goto error_return;

      elf_tdata (abfd)->cverrefs = hdr->sh_info;

      contents = bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;

      everneed = (Elf_External_Verneed *) contents;
      iverneed = elf_tdata (abfd)->verref;
      for (i = 0; i < hdr->sh_info; i++, iverneed++)
	{
	  Elf_External_Vernaux *evernaux;
	  Elf_Internal_Vernaux *ivernaux;
	  unsigned int j;

	  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);

	  iverneed->vn_bfd = abfd;

	  iverneed->vn_filename =
	    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					     iverneed->vn_file);
	  if (iverneed->vn_filename == NULL)
	    goto error_return;

	  amt = iverneed->vn_cnt;
	  amt *= sizeof (Elf_Internal_Vernaux);
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);

	  evernaux = ((Elf_External_Vernaux *)
		      ((bfd_byte *) everneed + iverneed->vn_aux));
	  ivernaux = iverneed->vn_auxptr;
	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
	    {
	      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);

	      ivernaux->vna_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 ivernaux->vna_name);
	      if (ivernaux->vna_nodename == NULL)
		goto error_return;

	      if (j + 1 < iverneed->vn_cnt)
		ivernaux->vna_nextptr = ivernaux + 1;
	      else
		ivernaux->vna_nextptr = NULL;

	      evernaux = ((Elf_External_Vernaux *)
			  ((bfd_byte *) evernaux + ivernaux->vna_next));
	    }

	  if (i + 1 < hdr->sh_info)
	    iverneed->vn_nextref = iverneed + 1;
	  else
	    iverneed->vn_nextref = NULL;

	  everneed = ((Elf_External_Verneed *)
		      ((bfd_byte *) everneed + iverneed->vn_next));
	}

      free (contents);
      contents = NULL;
    }

  return TRUE;

 error_return:
  if (contents != NULL)
    free (contents);
  return FALSE;
}

asymbol *
_bfd_elf_make_empty_symbol (bfd *abfd)
{
  elf_symbol_type *newsym;
  bfd_size_type amt = sizeof (elf_symbol_type);

  newsym = bfd_zalloc (abfd, amt);
  if (!newsym)
    return NULL;
  else
    {
      newsym->symbol.the_bfd = abfd;
      return &newsym->symbol;
    }
}

void
_bfd_elf_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			  asymbol *symbol,
			  symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

/* Return whether a symbol name implies a local symbol.  Most targets
   use this function for the is_local_label_name entry point, but some
   override it.  */

bfd_boolean
_bfd_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *name)
{
  /* Normal local symbols start with ``.L''.  */
  if (name[0] == '.' && name[1] == 'L')
    return TRUE;

  /* At least some SVR4 compilers (e.g., UnixWare 2.1 cc) generate
     DWARF debugging symbols starting with ``..''.  */
  if (name[0] == '.' && name[1] == '.')
    return TRUE;

  /* gcc will sometimes generate symbols beginning with ``_.L_'' when
     emitting DWARF debugging output.  I suspect this is actually a
     small bug in gcc (it calls ASM_OUTPUT_LABEL when it should call
     ASM_GENERATE_INTERNAL_LABEL, and this causes the leading
     underscore to be emitted on some ELF targets).  For ease of use,
     we treat such symbols as local.  */
  if (name[0] == '_' && name[1] == '.' && name[2] == 'L' && name[3] == '_')
    return TRUE;

  return FALSE;
}

alent *
_bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol ATTRIBUTE_UNUSED)
{
  abort ();
  return NULL;
}

bfd_boolean
_bfd_elf_set_arch_mach (bfd *abfd,
			enum bfd_architecture arch,
			unsigned long machine)
{
  /* If this isn't the right architecture for this backend, and this
     isn't the generic backend, fail.  */
  if (arch != get_elf_backend_data (abfd)->arch
      && arch != bfd_arch_unknown
      && get_elf_backend_data (abfd)->arch != bfd_arch_unknown)
    return FALSE;

  return bfd_default_set_arch_mach (abfd, arch, machine);
}

/* Find the function to a particular section and offset,
   for error reporting.  */

static bfd_boolean
elf_find_function (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *section,
		   asymbol **symbols,
		   bfd_vma offset,
		   const char **filename_ptr,
		   const char **functionname_ptr)
{
  const char *filename;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;

  filename = NULL;
  func = NULL;
  low_func = 0;

  for (p = symbols; *p != NULL; p++)
    {
      elf_symbol_type *q;

      q = (elf_symbol_type *) *p;

      if (bfd_get_section (&q->symbol) != section)
	continue;

      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))
	{
	default:
	  break;
	case STT_FILE:
	  filename = bfd_asymbol_name (&q->symbol);
	  break;
	case STT_NOTYPE:
	case STT_FUNC:
	  if (q->symbol.section == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
	    {
	      func = (asymbol *) q;
	      low_func = q->symbol.value;
	    }
	  break;
	}
    }

  if (func == NULL)
    return FALSE;

  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return TRUE;
}

/* Find the nearest line to a particular section and offset,
   for error reporting.  */

bfd_boolean
_bfd_elf_find_nearest_line (bfd *abfd,
			    asection *section,
			    asymbol **symbols,
			    bfd_vma offset,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
{
  bfd_boolean found;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return TRUE;
    }

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return TRUE;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return FALSE;
  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  if (! elf_find_function (abfd, section, symbols, offset,
			   filename_ptr, functionname_ptr))
    return FALSE;

  *line_ptr = 0;
  return TRUE;
}

int
_bfd_elf_sizeof_headers (bfd *abfd, bfd_boolean reloc)
{
  int ret;

  ret = get_elf_backend_data (abfd)->s->sizeof_ehdr;
  if (! reloc)
    ret += get_program_header_size (abfd);
  return ret;
}

bfd_boolean
_bfd_elf_set_section_contents (bfd *abfd,
			       sec_ptr section,
			       const void *location,
			       file_ptr offset,
			       bfd_size_type count)
{
  Elf_Internal_Shdr *hdr;
  bfd_signed_vma pos;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;

  hdr = &elf_section_data (section)->this_hdr;
  pos = hdr->sh_offset + offset;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

void
_bfd_elf_no_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *cache_ptr ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  abort ();
}

/* Try to convert a non-ELF reloc into an ELF one.  */

bfd_boolean
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
{
  /* Check whether we really have an ELF howto.  */

  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec)
    {
      bfd_reloc_code_real_type code;
      reloc_howto_type *howto;

      /* Alien reloc: Try to determine its type to replace it with an
	 equivalent ELF reloc.  */

      if (areloc->howto->pc_relative)
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8_PCREL;
	      break;
	    case 12:
	      code = BFD_RELOC_12_PCREL;
	      break;
	    case 16:
	      code = BFD_RELOC_16_PCREL;
	      break;
	    case 24:
	      code = BFD_RELOC_24_PCREL;
	      break;
	    case 32:
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 64:
	      code = BFD_RELOC_64_PCREL;
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);

	  if (areloc->howto->pcrel_offset != howto->pcrel_offset)
	    {
	      if (howto->pcrel_offset)
		areloc->addend += areloc->address;
	      else
		areloc->addend -= areloc->address; /* addend is unsigned!! */
	    }
	}
      else
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8;
	      break;
	    case 14:
	      code = BFD_RELOC_14;
	      break;
	    case 16:
	      code = BFD_RELOC_16;
	      break;
	    case 26:
	      code = BFD_RELOC_26;
	      break;
	    case 32:
	      code = BFD_RELOC_32;
	      break;
	    case 64:
	      code = BFD_RELOC_64;
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);
	}

      if (howto)
	areloc->howto = howto;
      else
	goto fail;
    }

  return TRUE;

 fail:
  (*_bfd_error_handler)
    (_("%s: unsupported relocation type %s"),
     bfd_archive_filename (abfd), areloc->howto->name);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

bfd_boolean
_bfd_elf_close_and_cleanup (bfd *abfd)
{
  if (bfd_get_format (abfd) == bfd_object)
    {
      if (elf_shstrtab (abfd) != NULL)
	_bfd_elf_strtab_free (elf_shstrtab (abfd));
    }

  return _bfd_generic_close_and_cleanup (abfd);
}

/* For Rel targets, we encode meaningful data for BFD_RELOC_VTABLE_ENTRY
   in the relocation's offset.  Thus we cannot allow any sort of sanity
   range-checking to interfere.  There is nothing else to do in processing
   this reloc.  */

bfd_reloc_status_type
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd ATTRIBUTE_UNUSED, arelent *re ATTRIBUTE_UNUSED,
   struct bfd_symbol *symbol ATTRIBUTE_UNUSED,
   void *data ATTRIBUTE_UNUSED, asection *is ATTRIBUTE_UNUSED,
   bfd *obfd ATTRIBUTE_UNUSED, char **errmsg ATTRIBUTE_UNUSED)
{
  return bfd_reloc_ok;
}

/* Elf core file support.  Much of this only works on native
   toolchains, since we rely on knowing the
   machine-dependent procfs structure in order to pick
   out details about the corefile.  */

#ifdef HAVE_SYS_PROCFS_H
# include <sys/procfs.h>
#endif

/* FIXME: this is kinda wrong, but it's what gdb wants.  */

static int
elfcore_make_pid (bfd *abfd)
{
  int pid;

  pid = elf_tdata (abfd)->core_lwpid;
  if (pid == 0)
    pid = elf_tdata (abfd)->core_pid;

  return pid;
}

/* If there isn't a section called NAME, make one, using
   data from SECT.  Note, this function will generate a
   reference to NAME, so you shouldn't deallocate or
   overwrite it.  */

static bfd_boolean
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
{
  asection *sect2;

  if (bfd_get_section_by_name (abfd, name) != NULL)
    return TRUE;

  sect2 = bfd_make_section (abfd, name);
  if (sect2 == NULL)
    return FALSE;

  sect2->_raw_size = sect->_raw_size;
  sect2->filepos = sect->filepos;
  sect2->flags = sect->flags;
  sect2->alignment_power = sect->alignment_power;
  return TRUE;
}

/* Create a pseudosection containing SIZE bytes at FILEPOS.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents. */
bfd_boolean
_bfd_elfcore_make_pseudosection (bfd *abfd,
				 char *name,
				 size_t size,
				 ufile_ptr filepos)
{
  char buf[100];
  char *threaded_name;
  size_t len;
  asection *sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  threaded_name = bfd_alloc (abfd, len);
  if (threaded_name == NULL)
    return FALSE;
  memcpy (threaded_name, buf, len);

  sect = bfd_make_section_anyway (abfd, threaded_name);
  if (sect == NULL)
    return FALSE;
  sect->_raw_size = size;
  sect->filepos = filepos;
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, name, sect);
}

/* prstatus_t exists on:
     solaris 2.5+
     linux 2.[01] + glibc
     unixware 4.2
*/

#if defined (HAVE_PRSTATUS_T)

static bfd_boolean
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t raw_size;
  int offset;

  if (note->descsz == sizeof (prstatus_t))
    {
      prstatus_t prstat;

      raw_size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      elf_tdata (abfd)->core_pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
#if defined (HAVE_PRSTATUS_T_PR_WHO)
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
#endif
    }
#if defined (HAVE_PRSTATUS32_T)
  else if (note->descsz == sizeof (prstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      prstatus32_t prstat;

      raw_size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus32_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      elf_tdata (abfd)->core_pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
#if defined (HAVE_PRSTATUS32_T_PR_WHO)
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
#endif
    }
#endif /* HAVE_PRSTATUS32_T */
  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return TRUE;
    }

  /* Make a ".reg/999" section and a ".reg" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}
#endif /* defined (HAVE_PRSTATUS_T) */

/* Create a pseudosection containing the exact contents of NOTE.  */
static bfd_boolean
elfcore_make_note_pseudosection (bfd *abfd,
				 char *name,
				 Elf_Internal_Note *note)
{
  return _bfd_elfcore_make_pseudosection (abfd, name,
					  note->descsz, note->descpos);
}

/* There isn't a consistent prfpregset_t across platforms,
   but it doesn't matter, because we don't have to pick this
   data structure apart.  */

static bfd_boolean
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg2", note);
}

/* Linux dumps the Intel SSE regs in a note named "LINUX" with a note
   type of 5 (NT_PRXFPREG).  Just include the whole note's contents
   literally.  */

static bfd_boolean
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);
}

#if defined (HAVE_PRPSINFO_T)
typedef prpsinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PRPSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef prpsinfo32_t elfcore_psinfo32_t;
#endif
#endif

#if defined (HAVE_PSINFO_T)
typedef psinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef psinfo32_t elfcore_psinfo32_t;
#endif
#endif

/* return a malloc'ed copy of a string at START which is at
   most MAX bytes long, possibly without a terminating '\0'.
   the copy will always have a terminating '\0'.  */

char *
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
{
  char *dups;
  char *end = memchr (start, '\0', max);
  size_t len;

  if (end == NULL)
    len = max;
  else
    len = end - start;

  dups = bfd_alloc (abfd, len + 1);
  if (dups == NULL)
    return NULL;

  memcpy (dups, start, len);
  dups[len] = '\0';

  return dups;
}

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
static bfd_boolean
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz == sizeof (elfcore_psinfo_t))
    {
      elfcore_psinfo_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));

      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));

      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
    }
#if defined (HAVE_PRPSINFO32_T) || defined (HAVE_PSINFO32_T)
  else if (note->descsz == sizeof (elfcore_psinfo32_t))
    {
      /* 64-bit host, 32-bit corefile */
      elfcore_psinfo32_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));

      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));

      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
    }
#endif

  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return TRUE;
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}
#endif /* defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T) */

#if defined (HAVE_PSTATUS_T)
static bfd_boolean
elfcore_grok_pstatus (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz == sizeof (pstatus_t)
#if defined (HAVE_PXSTATUS_T)
      || note->descsz == sizeof (pxstatus_t)
#endif
      )
    {
      pstatus_t pstat;

      memcpy (&pstat, note->descdata, sizeof (pstat));

      elf_tdata (abfd)->core_pid = pstat.pr_pid;
    }
#if defined (HAVE_PSTATUS32_T)
  else if (note->descsz == sizeof (pstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      pstatus32_t pstat;

      memcpy (&pstat, note->descdata, sizeof (pstat));

      elf_tdata (abfd)->core_pid = pstat.pr_pid;
    }
#endif
  /* Could grab some more details from the "representative"
     lwpstatus_t in pstat.pr_lwp, but we'll catch it all in an
     NT_LWPSTATUS note, presumably.  */

  return TRUE;
}
#endif /* defined (HAVE_PSTATUS_T) */

#if defined (HAVE_LWPSTATUS_T)
static bfd_boolean
elfcore_grok_lwpstatus (bfd *abfd, Elf_Internal_Note *note)
{
  lwpstatus_t lwpstat;
  char buf[100];
  char *name;
  size_t len;
  asection *sect;

  if (note->descsz != sizeof (lwpstat)
#if defined (HAVE_LWPXSTATUS_T)
      && note->descsz != sizeof (lwpxstatus_t)
#endif
      )
    return TRUE;

  memcpy (&lwpstat, note->descdata, sizeof (lwpstat));

  elf_tdata (abfd)->core_lwpid = lwpstat.pr_lwpid;
  elf_tdata (abfd)->core_signal = lwpstat.pr_cursig;

  /* Make a ".reg/999" section.  */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, buf, len);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.gregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.gregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_REG)
  sect->_raw_size = sizeof (lwpstat.pr_reg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_reg);
#endif

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (!elfcore_maybe_make_sect (abfd, ".reg", sect))
    return FALSE;

  /* Make a ".reg2/999" section */

  sprintf (buf, ".reg2/%d", elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, buf, len);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.fpregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.fpregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_FPREG)
  sect->_raw_size = sizeof (lwpstat.pr_fpreg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_fpreg);
#endif

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, ".reg2", sect);
}
#endif /* defined (HAVE_LWPSTATUS_T) */

#if defined (HAVE_WIN32_PSTATUS_T)
static bfd_boolean
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
{
  char buf[30];
  char *name;
  size_t len;
  asection *sect;
  win32_pstatus_t pstatus;

  if (note->descsz < sizeof (pstatus))
    return TRUE;

  memcpy (&pstatus, note->descdata, sizeof (pstatus));

  switch (pstatus.data_type)
    {
    case NOTE_INFO_PROCESS:
      /* FIXME: need to add ->core_command.  */
      elf_tdata (abfd)->core_signal = pstatus.data.process_info.signal;
      elf_tdata (abfd)->core_pid = pstatus.data.process_info.pid;
      break;

    case NOTE_INFO_THREAD:
      /* Make a ".reg/999" section.  */
      sprintf (buf, ".reg/%d", pstatus.data.thread_info.tid);

      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, len);
      if (name == NULL)
	return FALSE;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway (abfd, name);
      if (sect == NULL)
	return FALSE;

      sect->_raw_size = sizeof (pstatus.data.thread_info.thread_context);
      sect->filepos = (note->descpos
		       + offsetof (struct win32_pstatus,
				   data.thread_info.thread_context));
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 2;

      if (pstatus.data.thread_info.is_active_thread)
	if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
	  return FALSE;
      break;

    case NOTE_INFO_MODULE:
      /* Make a ".module/xxxxxxxx" section.  */
      sprintf (buf, ".module/%08x", pstatus.data.module_info.base_address);

      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, len);
      if (name == NULL)
	return FALSE;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway (abfd, name);

      if (sect == NULL)
	return FALSE;

      sect->_raw_size = note->descsz;
      sect->filepos = note->descpos;
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 2;
      break;

    default:
      return TRUE;
    }

  return TRUE;
}
#endif /* HAVE_WIN32_PSTATUS_T */

static bfd_boolean
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  switch (note->type)
    {
    default:
      return TRUE;

    case NT_PRSTATUS:
      if (bed->elf_backend_grok_prstatus)
	if ((*bed->elf_backend_grok_prstatus) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRSTATUS_T)
      return elfcore_grok_prstatus (abfd, note);
#else
      return TRUE;
#endif

#if defined (HAVE_PSTATUS_T)
    case NT_PSTATUS:
      return elfcore_grok_pstatus (abfd, note);
#endif

#if defined (HAVE_LWPSTATUS_T)
    case NT_LWPSTATUS:
      return elfcore_grok_lwpstatus (abfd, note);
#endif

    case NT_FPREGSET:		/* FIXME: rename to NT_PRFPREG */
      return elfcore_grok_prfpreg (abfd, note);

#if defined (HAVE_WIN32_PSTATUS_T)
    case NT_WIN32PSTATUS:
      return elfcore_grok_win32pstatus (abfd, note);
#endif

    case NT_PRXFPREG:		/* Linux SSE extension */
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_prxfpreg (abfd, note);
      else
	return TRUE;

    case NT_PRPSINFO:
    case NT_PSINFO:
      if (bed->elf_backend_grok_psinfo)
	if ((*bed->elf_backend_grok_psinfo) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
      return elfcore_grok_psinfo (abfd, note);
#else
      return TRUE;
#endif

    case NT_AUXV:
      {
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");

	if (sect == NULL)
	  return FALSE;
	sect->_raw_size = note->descsz;
	sect->filepos = note->descpos;
	sect->flags = SEC_HAS_CONTENTS;
	sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

	return TRUE;
      }
    }
}

static bfd_boolean
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
{
  char *cp;

  cp = strchr (note->namedata, '@@');
  if (cp != NULL)
    {
      *lwpidp = atoi(cp + 1);
      return TRUE;
    }
  return FALSE;
}

static bfd_boolean
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{

  /* Signal number at offset 0x08. */
  elf_tdata (abfd)->core_signal
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x08);

  /* Process ID at offset 0x50. */
  elf_tdata (abfd)->core_pid
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x50);

  /* Command name at 0x7c (max 32 bytes, including nul). */
  elf_tdata (abfd)->core_command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x7c, 31);

  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
					  note);
}

static bfd_boolean
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  int lwp;

  if (elfcore_netbsd_get_lwpid (note, &lwp))
    elf_tdata (abfd)->core_lwpid = lwp;

  if (note->type == NT_NETBSDCORE_PROCINFO)
    {
      /* NetBSD-specific core "procinfo".  Note that we expect to
         find this note before any of the others, which is fine,
         since the kernel writes this note out first when it
         creates a core file.  */

      return elfcore_grok_netbsd_procinfo (abfd, note);
    }

  /* As of Jan 2002 there are no other machine-independent notes
     defined for NetBSD core files.  If the note type is less
     than the start of the machine-dependent note types, we don't
     understand it.  */

  if (note->type < NT_NETBSDCORE_FIRSTMACH)
    return TRUE;


  switch (bfd_get_arch (abfd))
    {
    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0 and
       PT_GETFPREGS == mach+2.  */

    case bfd_arch_alpha:
    case bfd_arch_sparc:
      switch (note->type)
        {
        case NT_NETBSDCORE_FIRSTMACH+0:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+2:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }

    /* On all other arch's, PT_GETREGS == mach+1 and
       PT_GETFPREGS == mach+3.  */

    default:
      switch (note->type)
        {
        case NT_NETBSDCORE_FIRSTMACH+1:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+3:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }
    }
    /* NOTREACHED */
}

static bfd_boolean
elfcore_grok_openbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{
  /* Signal number at offset 0x08. */
  elf_tdata (abfd)->core_signal
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x08);

  /* Process ID at offset 0x20. */
  elf_tdata (abfd)->core_pid
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x20);

  /* Command name at 0x48 (max 32 bytes, including nul). */
  elf_tdata (abfd)->core_command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x48, 31);

  return TRUE;
}

static bfd_boolean
elfcore_grok_openbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  int lwp;

  if (elfcore_netbsd_get_lwpid (note, &lwp))
    elf_tdata (abfd)->core_lwpid = lwp;

  if (note->type == NT_OPENBSD_PROCINFO)
    return elfcore_grok_openbsd_procinfo (abfd, note);

  if (note->type == NT_OPENBSD_REGS)
    return elfcore_make_note_pseudosection (abfd, ".reg", note);

  if (note->type == NT_OPENBSD_FPREGS)
    return elfcore_make_note_pseudosection (abfd, ".reg2", note);

  if (note->type == NT_OPENBSD_XFPREGS)
    return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);

  if (note->type == NT_OPENBSD_AUXV)
    {
      asection *sect = bfd_make_section_anyway (abfd, ".auxv");

      if (sect == NULL)
	return FALSE;
      sect->_raw_size = note->descsz;
      sect->filepos = note->descpos;
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return TRUE;
    }

  if (note->type == NT_OPENBSD_WCOOKIE)
    {
      asection *sect = bfd_make_section_anyway (abfd, ".wcookie");

      if (sect == NULL)
	return FALSE;
      sect->_raw_size = note->descsz;
      sect->filepos = note->descpos;
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return TRUE;
    }

  return TRUE;
}

static bfd_boolean
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, pid_t *tid)
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;
  short sig;
  unsigned flags;

  /* nto_procfs_status 'pid' field is at offset 0.  */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, (bfd_byte *) ddata);

  /* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
  *tid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'flags' field is at offset 8.  */
  flags = bfd_get_32 (abfd, (bfd_byte *) ddata + 8);

  /* nto_procfs_status 'what' field is at offset 14.  */
  if ((sig = bfd_get_16 (abfd, (bfd_byte *) ddata + 14)) > 0)
    {
      elf_tdata (abfd)->core_signal = sig;
      elf_tdata (abfd)->core_lwpid = *tid;
    }

  /* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores
     do not come from signals so we make sure we set the current
     thread just in case.  */
  if (flags & 0x00000080)
    elf_tdata (abfd)->core_lwpid = *tid;

  /* Make a ".qnx_core_status/%d" section.  */
  sprintf (buf, ".qnx_core_status/%d", *tid);

  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_gregs (bfd *abfd, Elf_Internal_Note *note, pid_t tid)
{
  char buf[100];
  char *name;
  asection *sect;

  /* Make a ".reg/%d" section.  */
  sprintf (buf, ".reg/%d", tid);

  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  /* This is the current thread.  */
  if (elf_tdata (abfd)->core_lwpid == tid)
    return elfcore_maybe_make_sect (abfd, ".reg", sect);

  return TRUE;
}

#define BFD_QNT_CORE_INFO	7
#define BFD_QNT_CORE_STATUS	8
#define BFD_QNT_CORE_GREG	9
#define BFD_QNT_CORE_FPREG	10

static bfd_boolean
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
{
  /* Every GREG section has a STATUS section before it.  Store the
     tid from the previous call to pass down to the next gregs
     function.  */
  static pid_t tid = 1;

  switch (note->type)
    {
    case BFD_QNT_CORE_INFO:   return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS: return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:   return elfcore_grok_nto_gregs (abfd, note, tid);
    case BFD_QNT_CORE_FPREG:  return elfcore_grok_prfpreg (abfd, note);
    default:                  return TRUE;
    }
}

/* Function: elfcore_write_note

   Inputs:
     buffer to hold note
     name of note
     type of note
     data for note
     size of data for note

   Return:
   End of buffer containing note.  */

char *
elfcore_write_note (bfd  *abfd,
		    char *buf,
		    int  *bufsiz,
		    const char *name,
		    int  type,
		    const void *input,
		    int  size)
{
  Elf_External_Note *xnp;
  size_t namesz;
  size_t pad;
  size_t newspace;
  char *p, *dest;

  namesz = 0;
  pad = 0;
  if (name != NULL)
    {
      const struct elf_backend_data *bed;

      namesz = strlen (name) + 1;
      bed = get_elf_backend_data (abfd);
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
    }

  newspace = 12 + namesz + pad + size;

  p = realloc (buf, *bufsiz + newspace);
  dest = p + *bufsiz;
  *bufsiz += newspace;
  xnp = (Elf_External_Note *) dest;
  H_PUT_32 (abfd, namesz, xnp->namesz);
  H_PUT_32 (abfd, size, xnp->descsz);
  H_PUT_32 (abfd, type, xnp->type);
  dest = xnp->name;
  if (name != NULL)
    {
      memcpy (dest, name, namesz);
      dest += namesz;
      while (pad != 0)
	{
	  *dest++ = '\0';
	  --pad;
	}
    }
  memcpy (dest, input, size);
  return p;
}

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
char *
elfcore_write_prpsinfo (bfd  *abfd,
			char *buf,
			int  *bufsiz,
			const char *fname,
			const char *psargs)
{
  int note_type;
  char *note_name = "CORE";

#if defined (HAVE_PSINFO_T)
  psinfo_t  data;
  note_type = NT_PSINFO;
#else
  prpsinfo_t data;
  note_type = NT_PRPSINFO;
#endif

  memset (&data, 0, sizeof (data));
  strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
  strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, note_type, &data, sizeof (data));
}
#endif	/* PSINFO_T or PRPSINFO_T */

#if defined (HAVE_PRSTATUS_T)
char *
elfcore_write_prstatus (bfd *abfd,
			char *buf,
			int *bufsiz,
			long pid,
			int cursig,
			const void *gregs)
{
  prstatus_t prstat;
  char *note_name = "CORE";

  memset (&prstat, 0, sizeof (prstat));
  prstat.pr_pid = pid;
  prstat.pr_cursig = cursig;
  memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRSTATUS, &prstat, sizeof (prstat));
}
#endif /* HAVE_PRSTATUS_T */

#if defined (HAVE_LWPSTATUS_T)
char *
elfcore_write_lwpstatus (bfd *abfd,
			 char *buf,
			 int *bufsiz,
			 long pid,
			 int cursig,
			 const void *gregs)
{
  lwpstatus_t lwpstat;
  char *note_name = "CORE";

  memset (&lwpstat, 0, sizeof (lwpstat));
  lwpstat.pr_lwpid  = pid >> 16;
  lwpstat.pr_cursig = cursig;
#if defined (HAVE_LWPSTATUS_T_PR_REG)
  memcpy (lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
#elif defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
#if !defined(gregs)
  memcpy (lwpstat.pr_context.uc_mcontext.gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.gregs));
#else
  memcpy (lwpstat.pr_context.uc_mcontext.__gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.__gregs));
#endif
#endif
  return elfcore_write_note (abfd, buf, bufsiz, note_name,
			     NT_LWPSTATUS, &lwpstat, sizeof (lwpstat));
}
#endif /* HAVE_LWPSTATUS_T */

#if defined (HAVE_PSTATUS_T)
char *
elfcore_write_pstatus (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       long pid,
		       int cursig,
		       const void *gregs)
{
  pstatus_t pstat;
  char *note_name = "CORE";

  memset (&pstat, 0, sizeof (pstat));
  pstat.pr_pid = pid & 0xffff;
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
			    NT_PSTATUS, &pstat, sizeof (pstat));
  return buf;
}
#endif /* HAVE_PSTATUS_T */

char *
elfcore_write_prfpreg (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *fpregs,
		       int size)
{
  char *note_name = "CORE";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_FPREGSET, fpregs, size);
}

char *
elfcore_write_prxfpreg (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *xfpregs,
			int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRXFPREG, xfpregs, size);
}

static bfd_boolean
elfcore_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
{
  char *buf;
  char *p;

  if (size <= 0)
    return TRUE;

  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;

  buf = bfd_malloc (size);
  if (buf == NULL)
    return FALSE;

  if (bfd_bread (buf, size, abfd) != size)
    {
    error:
      free (buf);
      return FALSE;
    }

  p = buf;
  while (p < buf + size)
    {
      /* FIXME: bad alignment assumption.  */
      Elf_External_Note *xnp = (Elf_External_Note *) p;
      Elf_Internal_Note in;

      in.type = H_GET_32 (abfd, xnp->type);

      in.namesz = H_GET_32 (abfd, xnp->namesz);
      in.namedata = xnp->name;

      in.descsz = H_GET_32 (abfd, xnp->descsz);
      in.descdata = in.namedata + BFD_ALIGN (in.namesz, 4);
      in.descpos = offset + (in.descdata - buf);

      if (strncmp (in.namedata, "NetBSD-CORE", 11) == 0)
        {
          if (! elfcore_grok_netbsd_note (abfd, &in))
            goto error;
        }
      if (strncmp (in.namedata, "OpenBSD", 7) == 0)
        {
          if (! elfcore_grok_openbsd_note (abfd, &in))
            goto error;
        }
      else if (strncmp (in.namedata, "QNX", 3) == 0)
	{
	  if (! elfcore_grok_nto_note (abfd, &in))
	    goto error;
	}
      else
        {
          if (! elfcore_grok_note (abfd, &in))
            goto error;
        }

      p = in.descdata + BFD_ALIGN (in.descsz, 4);
    }

  free (buf);
  return TRUE;
}

/* Providing external access to the ELF program header table.  */

/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */

long
bfd_get_elf_phdr_upper_bound (bfd *abfd)
{
  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return elf_elfheader (abfd)->e_phnum * sizeof (Elf_Internal_Phdr);
}

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */

int
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
{
  int num_phdrs;

  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  num_phdrs = elf_elfheader (abfd)->e_phnum;
  memcpy (phdrs, elf_tdata (abfd)->phdr,
	  num_phdrs * sizeof (Elf_Internal_Phdr));

  return num_phdrs;
}

void
_bfd_elf_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    sprintf_vma (buf, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  sprintf (buf, "%016lx", value);
#else
	  sprintf (buf, "%08lx%08lx", _bfd_int64_high (value),
		   _bfd_int64_low (value));
#endif
	}
      else
	sprintf (buf, "%08lx", (unsigned long) (value & 0xffffffff));
    }
#else
  sprintf_vma (buf, value);
#endif
}

void
_bfd_elf_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    fprintf_vma ((FILE *) stream, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  fprintf ((FILE *) stream, "%016lx", value);
#else
	  fprintf ((FILE *) stream, "%08lx%08lx",
		   _bfd_int64_high (value), _bfd_int64_low (value));
#endif
	}
      else
	fprintf ((FILE *) stream, "%08lx",
		 (unsigned long) (value & 0xffffffff));
    }
#else
  fprintf_vma ((FILE *) stream, value);
#endif
}

enum elf_reloc_type_class
_bfd_elf_reloc_type_class (const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
{
  return reloc_class_normal;
}

/* For RELA architectures, return the relocation value for a
   relocation against a local symbol.  */

bfd_vma
_bfd_elf_rela_local_sym (bfd *abfd,
			 Elf_Internal_Sym *sym,
			 asection **psec,
			 Elf_Internal_Rela *rel)
{
  asection *sec = *psec;
  bfd_vma relocation;

  relocation = (sec->output_section->vma
		+ sec->output_offset
		+ sym->st_value);
  if ((sec->flags & SEC_MERGE)
      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      rel->r_addend =
	_bfd_merged_section_offset (abfd, psec,
				    elf_section_data (sec)->sec_info,
				    sym->st_value + rel->r_addend,
				    0);
      sec = *psec;
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
    }
  return relocation;
}

bfd_vma
_bfd_elf_rel_local_sym (bfd *abfd,
			Elf_Internal_Sym *sym,
			asection **psec,
			bfd_vma addend)
{
  asection *sec = *psec;

  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
    return sym->st_value + addend;

  return _bfd_merged_section_offset (abfd, psec,
				     elf_section_data (sec)->sec_info,
				     sym->st_value + addend, 0);
}

bfd_vma
_bfd_elf_section_offset (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 bfd_vma offset)
{
  struct bfd_elf_section_data *sec_data;

  sec_data = elf_section_data (sec);
  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
      return _bfd_stab_section_offset (abfd,
				       &elf_hash_table (info)->merge_info,
				       sec, &sec_data->sec_info, offset);
    case ELF_INFO_TYPE_EH_FRAME:
      return _bfd_elf_eh_frame_section_offset (abfd, sec, offset);
    default:
      return offset;
    }
}

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */

bfd *
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  return (*get_elf_backend_data (templ)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, loadbasep, target_read_memory);
}
@


1.22
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d3237 3
a3239 3
  /* If we have a .interp section, then create a PT_PHDR segment for
     the program headers and a PT_INTERP segment for the .interp
     section.  */
d3241 3
a3243 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
d3258 1
d3260 4
d4144 9
d4156 2
a4157 4
	 PT_INTERP segment.  In this case, assume we also need a
	 PT_PHDR segment, although that may not be true for all
	 targets.  */
      segs += 2;
@


1.21
log
@Don't munge PID and TID together, since the way GDB displays them isn't very
helpful.  Just provide the TID instead.
@
text
@d971 1
d2295 4
d3202 1
a3202 1
  asection *dynsec, *eh_frame_hdr;
d3522 18
d4149 6
@


1.20
log
@Properly recognize threads in OpenBSD core dumps.
@
text
@d6323 7
a6329 2
  return ((elf_tdata (abfd)->core_lwpid << 16)
	  + (elf_tdata (abfd)->core_pid));
@


1.19
log
@Teach bfd and gdb about the upcoming ELF core dumps.
@
text
@d6986 5
@


1.18
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d6966 64
d7362 5
@


1.17
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d44 5
a48 63
static INLINE struct elf_segment_map *make_mapping
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, bfd_boolean));
static bfd_boolean map_sections_to_segments
  PARAMS ((bfd *));
static int elf_sort_sections
  PARAMS ((const PTR, const PTR));
static bfd_boolean assign_file_positions_for_segments
  PARAMS ((bfd *));
static bfd_boolean assign_file_positions_except_relocs
  PARAMS ((bfd *));
static bfd_boolean prep_headers
  PARAMS ((bfd *));
static bfd_boolean swap_out_syms
  PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static bfd_boolean copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static char *elf_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static const char *group_signature
  PARAMS ((bfd *, Elf_Internal_Shdr *));
static bfd_boolean setup_group
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void merge_sections_remove_hook
  PARAMS ((bfd *, asection *));
static void elf_fake_sections
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean assign_section_numbers
  PARAMS ((bfd *));
static INLINE int sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean elf_map_symbols
  PARAMS ((bfd *));
static bfd_size_type get_program_header_size
  PARAMS ((bfd *));
static bfd_boolean elfcore_read_notes
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean elf_find_function
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **));
static int elfcore_make_pid
  PARAMS ((bfd *));
static bfd_boolean elfcore_maybe_make_sect
  PARAMS ((bfd *, char *, asection *));
static bfd_boolean elfcore_make_note_pseudosection
  PARAMS ((bfd *, char *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prxfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_netbsd_get_lwpid
  PARAMS ((Elf_Internal_Note *, int *));
static bfd_boolean elfcore_grok_netbsd_procinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_netbsd_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_nto_gregs
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t));
static bfd_boolean elfcore_grok_nto_status
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t *));
static bfd_boolean elfcore_grok_nto_note
  PARAMS ((bfd *, Elf_Internal_Note *));
d57 3
a59 4
_bfd_elf_swap_verdef_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdef *src;
     Elf_Internal_Verdef *dst;
d73 3
a75 4
_bfd_elf_swap_verdef_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdef *src;
     Elf_External_Verdef *dst;
d89 3
a91 4
_bfd_elf_swap_verdaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdaux *src;
     Elf_Internal_Verdaux *dst;
d100 3
a102 4
_bfd_elf_swap_verdaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdaux *src;
     Elf_External_Verdaux *dst;
d111 3
a113 4
_bfd_elf_swap_verneed_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verneed *src;
     Elf_Internal_Verneed *dst;
d125 3
a127 4
_bfd_elf_swap_verneed_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verneed *src;
     Elf_External_Verneed *dst;
d139 3
a141 4
_bfd_elf_swap_vernaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Vernaux *src;
     Elf_Internal_Vernaux *dst;
d153 3
a155 4
_bfd_elf_swap_vernaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Vernaux *src;
     Elf_External_Vernaux *dst;
d167 3
a169 4
_bfd_elf_swap_versym_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Versym *src;
     Elf_Internal_Versym *dst;
d177 3
a179 4
_bfd_elf_swap_versym_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Versym *src;
     Elf_External_Versym *dst;
d188 1
a188 2
bfd_elf_hash (namearg)
     const char *namearg;
d214 1
a214 4
elf_read (abfd, offset, size)
     bfd *abfd;
     file_ptr offset;
     bfd_size_type size;
d222 1
a222 1
  if (bfd_bread ((PTR) buf, size, abfd) != size)
d232 1
a232 2
bfd_elf_mkobject (abfd)
     bfd *abfd;
d236 1
a236 2
  bfd_size_type amt = sizeof (struct elf_obj_tdata);
  elf_tdata (abfd) = (struct elf_obj_tdata *) bfd_zalloc (abfd, amt);
d246 1
a246 2
bfd_elf_mkcorefile (abfd)
     bfd *abfd;
d253 1
a253 3
bfd_elf_get_str_section (abfd, shindex)
     bfd *abfd;
     unsigned int shindex;
d271 1
a271 1
      i_shdrp[shindex]->contents = (PTR) shstrtab;
d277 3
a279 4
bfd_elf_string_from_elf_section (abfd, shindex, strindex)
     bfd *abfd;
     unsigned int shindex;
     unsigned int strindex;
d314 7
a320 9
bfd_elf_get_elf_syms (ibfd, symtab_hdr, symcount, symoffset,
		      intsym_buf, extsym_buf, extshndx_buf)
     bfd *ibfd;
     Elf_Internal_Shdr *symtab_hdr;
     size_t symcount;
     size_t symoffset;
     Elf_Internal_Sym *intsym_buf;
     PTR extsym_buf;
     Elf_External_Sym_Shndx *extshndx_buf;
d323 1
a323 1
  PTR alloc_ext;
d329 1
a329 1
  struct elf_backend_data *bed;
d370 1
a370 1
	  alloc_extshndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
d385 1
a385 1
      intsym_buf = (Elf_Internal_Sym *) bfd_malloc (amt);
d395 1
a395 1
    (*bed->s->swap_symbol_in) (ibfd, esym, (const PTR) shndx, isym);
d408 1
a408 3
bfd_elf_local_sym_name (abfd, isym)
     bfd *abfd;
     Elf_Internal_Sym *isym;
d434 1
a434 3
group_signature (abfd, ghdr)
     bfd *abfd;
     Elf_Internal_Shdr *ghdr;
d457 1
a457 4
setup_group (abfd, hdr, newsect)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *newsect;
d616 1
a616 3
bfd_elf_discard_group (abfd, group)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *group;
d636 3
a638 4
_bfd_elf_make_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d642 1
a642 1
  struct elf_backend_data *bed;
d655 4
d823 1
a823 3
bfd_elf_find_section (abfd, name)
     bfd *abfd;
     char *name;
d852 1
a852 1
/* ELF relocs are against symbols.  If we are producing relocateable
d860 1
a860 1
   relocateable output against an external symbol.  */
d863 7
a869 14
bfd_elf_generic_reloc (abfd,
		       reloc_entry,
		       symbol,
		       data,
		       input_section,
		       output_bfd,
		       error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d871 1
a871 1
  if (output_bfd != (bfd *) NULL
d886 2
a887 3
merge_sections_remove_hook (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d896 1
a896 3
_bfd_elf_merge_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d898 1
a898 1
  if (!is_elf_hash_table (info))
d907 1
a907 3
_bfd_elf_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info;
d911 1
a911 1
  if (!is_elf_hash_table (info))
d921 1
a921 3
_bfd_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d940 1
a940 3
_bfd_elf_print_private_bfd_data (abfd, farg)
     bfd *abfd;
     PTR farg;
d942 1
a942 1
  FILE *f = (FILE *) farg;
d970 1
d1001 1
a1001 1
      void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1005 1
a1005 1
      dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
d1008 1
a1008 2
      if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				      s->_raw_size))
d1028 1
a1028 1
	  (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);
d1177 4
a1180 5
bfd_elf_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
     PTR filep;
     asymbol *symbol;
     bfd_print_symbol_type how;
d1182 1
a1182 1
  FILE *file = (FILE *) filep;
d1197 1
a1197 1
	struct elf_backend_data *bed;
d1210 1
a1210 1
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d1299 3
a1301 4
_bfd_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
a1324 1
      ret->linker_section_pointer = NULL;
d1348 3
a1350 3
_bfd_elf_link_hash_copy_indirect (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d1358 7
a1364 6
  dir->elf_link_hash_flags |=
    (ind->elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));
d1401 3
a1403 4
_bfd_elf_link_hash_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
d1422 6
a1427 6
_bfd_elf_link_hash_table_init (table, abfd, newfunc)
     struct elf_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d1449 2
a1450 1
  table->tls_segment = NULL;
d1462 1
a1462 2
_bfd_elf_link_hash_table_create (abfd)
     bfd *abfd;
d1467 2
a1468 2
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_link_hash_table *) NULL)
d1482 1
a1482 2
   entry for a dynamic object.  The generic linker passes name as an
   empty string to indicate that no DT_NEEDED entry should be made.  */
d1485 1
a1485 3
bfd_elf_set_dt_needed_name (abfd, name)
     bfd *abfd;
     const char *name;
d1493 1
a1493 3
bfd_elf_set_dt_needed_soname (abfd, name)
     bfd *abfd;
     const char *name;
d1497 1
a1497 1
    elf_dt_soname (abfd) = name;
d1504 2
a1505 3
bfd_elf_get_needed_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1507 1
a1507 1
  if (! is_elf_hash_table (info))
d1516 2
a1517 3
bfd_elf_get_runpath_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1519 1
a1519 1
  if (! is_elf_hash_table (info))
d1529 1
a1529 2
bfd_elf_get_dt_soname (abfd)
     bfd *abfd;
d1541 2
a1542 3
bfd_elf_get_bfd_needed_list (abfd, pneeded)
     bfd *abfd;
     struct bfd_link_needed_list **pneeded;
d1550 1
a1550 1
  void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1562 1
a1562 1
  dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
d1566 1
a1566 2
  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				  s->_raw_size))
d1584 1
a1584 1
      (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);
d1601 1
a1601 1
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d1625 1
a1625 1
_bfd_elf_stringtab_init ()
d1650 1
a1650 3
bfd_section_from_shdr (abfd, shindex)
     bfd *abfd;
     unsigned int shindex;
d1654 1
a1654 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1722 1
a1722 1
         set in a relocateable object file, which would confuse the
d1890 1
a1890 1
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d1974 4
a1977 5
bfd_section_from_r_symndx (abfd, cache, sec, r_symndx)
     bfd *abfd;
     struct sym_sec_cache *cache;
     asection *sec;
     unsigned long r_symndx;
d2000 2
a2001 1
  if (isym.st_shndx < SHN_LORESERVE || isym.st_shndx > SHN_HIRESERVE)
d2015 1
a2015 3
bfd_section_from_elf_index (abfd, index)
     bfd *abfd;
     unsigned int index;
d2022 109
d2132 1
a2132 3
_bfd_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d2135 1
d2140 1
a2140 2
      bfd_size_type amt = sizeof (*sdata);
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, amt);
d2143 9
a2151 1
      sec->used_by_bfd = (PTR) sdata;
d2183 4
a2186 5
_bfd_elf_make_section_from_phdr (abfd, hdr, index, typename)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
     int index;
     const char *typename;
d2199 1
a2199 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d2211 1
d2232 1
a2232 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d2256 1
a2256 4
bfd_section_from_phdr (abfd, hdr, index)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
     int index;
d2258 1
a2258 1
  struct elf_backend_data *bed;
d2277 1
a2277 1
      if (! elfcore_read_notes (abfd, (file_ptr) hdr->p_offset, hdr->p_filesz))
d2291 3
d2310 4
a2313 5
_bfd_elf_init_reloc_shdr (abfd, rel_hdr, asect, use_rela_p)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *asect;
     bfd_boolean use_rela_p;
d2316 1
a2316 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2332 1
a2332 1
  rel_hdr->sh_addralign = bed->s->file_align;
d2344 1
a2344 4
elf_fake_sections (abfd, asect, failedptrarg)
     bfd *abfd;
     asection *asect;
     PTR failedptrarg;
d2346 2
a2347 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2385 13
a2397 4
  /* FIXME: This should not be based on section names.  */
  if (strcmp (asect->name, ".dynstr") == 0)
    this_hdr->sh_type = SHT_STRTAB;
  else if (strcmp (asect->name, ".hash") == 0)
d2399 13
a2411 1
      this_hdr->sh_type = SHT_HASH;
d2413 3
a2415 4
    }
  else if (strcmp (asect->name, ".dynsym") == 0)
    {
      this_hdr->sh_type = SHT_DYNSYM;
d2417 3
a2419 4
    }
  else if (strcmp (asect->name, ".dynamic") == 0)
    {
      this_hdr->sh_type = SHT_DYNAMIC;
d2421 13
a2433 27
    }
  else if (strncmp (asect->name, ".rela", 5) == 0
	   && get_elf_backend_data (abfd)->may_use_rela_p)
    {
      this_hdr->sh_type = SHT_RELA;
      this_hdr->sh_entsize = bed->s->sizeof_rela;
    }
  else if (strncmp (asect->name, ".rel", 4) == 0
	   && get_elf_backend_data (abfd)->may_use_rel_p)
    {
      this_hdr->sh_type = SHT_REL;
      this_hdr->sh_entsize = bed->s->sizeof_rel;
    }
  else if (strcmp (asect->name, ".init_array") == 0)
    this_hdr->sh_type = SHT_INIT_ARRAY;
  else if (strcmp (asect->name, ".fini_array") == 0)
    this_hdr->sh_type = SHT_FINI_ARRAY;
  else if (strcmp (asect->name, ".preinit_array") == 0)
    this_hdr->sh_type = SHT_PREINIT_ARRAY;
  else if (strncmp (asect->name, ".note", 5) == 0)
    this_hdr->sh_type = SHT_NOTE;
  else if (strncmp (asect->name, ".stab", 5) == 0
	   && strcmp (asect->name + strlen (asect->name) - 3, "str") == 0)
    this_hdr->sh_type = SHT_STRTAB;
  else if (strcmp (asect->name, ".gnu.version") == 0)
    {
      this_hdr->sh_type = SHT_GNU_versym;
d2435 3
a2437 4
    }
  else if (strcmp (asect->name, ".gnu.version_d") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verdef;
d2447 3
a2449 4
    }
  else if (strcmp (asect->name, ".gnu.version_r") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verneed;
d2459 3
a2461 4
    }
  else if ((asect->flags & SEC_GROUP) != 0)
    {
      this_hdr->sh_type = SHT_GROUP;
d2463 1
a2464 6
  else if ((asect->flags & SEC_ALLOC) != 0
	   && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	       || (asect->flags & SEC_NEVER_LOAD) != 0))
    this_hdr->sh_type = SHT_NOBITS;
  else
    this_hdr->sh_type = SHT_PROGBITS;
d2517 1
a2517 4
bfd_elf_set_group_contents (abfd, sec, failedptrarg)
     bfd *abfd;
     asection *sec;
     PTR failedptrarg;
d2519 1
a2519 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2623 1
a2623 2
assign_section_numbers (abfd)
     bfd *abfd;
d2704 1
a2704 1
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
d2709 1
a2709 1
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d2795 1
a2795 1
	      alc = (char *) bfd_malloc ((bfd_size_type) (len - 2));
d2852 2
a2853 4
static INLINE int
sym_is_global (abfd, sym)
     bfd *abfd;
     asymbol *sym;
d2856 3
a2858 3
  if (get_elf_backend_data (abfd)->elf_backend_sym_is_global)
    return ((*get_elf_backend_data (abfd)->elf_backend_sym_is_global)
	    (abfd, sym));
d2866 1
a2866 2
elf_map_symbols (abfd)
     bfd *abfd;
d2894 1
a2894 1
  sect_syms = (asymbol **) bfd_zalloc (abfd, amt);
d2968 1
a2968 1
  new_syms = (asymbol **) bfd_alloc (abfd, amt);
d3012 2
a3013 6
static INLINE file_ptr align_file_position
  PARAMS ((file_ptr, int));
static INLINE file_ptr
align_file_position (off, align)
     file_ptr off;
     int align;
d3021 4
a3024 5
INLINE file_ptr
_bfd_elf_assign_file_position_for_section (i_shdrp, offset, align)
     Elf_Internal_Shdr *i_shdrp;
     file_ptr offset;
     bfd_boolean align;
d3047 2
a3048 3
_bfd_elf_compute_section_file_positions (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info;
d3050 1
a3050 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3106 1
a3106 1
  if (!assign_file_positions_except_relocs (abfd))
d3143 6
a3148 7
static INLINE struct elf_segment_map *
make_mapping (abfd, sections, from, to, phdr)
     bfd *abfd;
     asection **sections;
     unsigned int from;
     unsigned int to;
     bfd_boolean phdr;
d3157 1
a3157 1
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3179 1
a3179 2
map_sections_to_segments (abfd)
     bfd *abfd;
d3189 1
d3209 1
a3209 1
  sections = (asection **) bfd_malloc (amt);
d3239 1
a3239 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3253 1
a3253 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3269 1
d3318 1
a3318 1
      else if (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
d3325 2
a3326 2
      else if ((last_hdr->flags & SEC_LOAD) == 0
	       && (hdr->flags & SEC_LOAD) != 0)
d3329 2
a3330 1
             nonloadable section in the same segment.  */
d3342 1
a3342 1
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
d3366 5
d3390 5
d3414 1
a3414 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3437 1
a3437 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3463 1
a3463 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3490 1
a3490 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3502 15
d3532 1
a3532 3
elf_sort_sections (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d3587 29
d3621 1
a3621 2
assign_file_positions_for_segments (abfd)
     bfd *abfd;
d3673 1
a3673 1
      if (! (*bed->elf_backend_modify_segment_map) (abfd))
d3705 1
a3705 1
  phdrs = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d3743 2
a3744 1
	    off += (m->sections[0]->vma - off) % bed->maxpagesize;
d3759 2
a3760 1
	      off += (m->sections[0]->vma - off) % (1 << align);
d3780 1
a3780 1
	p->p_align = bed->s->file_align;
d3922 2
a3923 1
		    adjust = (sec->vma - voff) % bed->maxpagesize;
d3925 2
a3926 1
		    adjust = (sec->vma - voff) % align;
d4085 1
a4085 2
get_program_header_size (abfd)
     bfd *abfd;
d4089 1
a4089 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4135 6
d4188 2
a4189 2
assign_file_positions_except_relocs (abfd)
     bfd *abfd;
d4196 1
a4196 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4240 1
a4240 1
      if (! assign_file_positions_for_segments (abfd))
d4263 2
a4264 1
		off += (hdr->sh_addr - off) % bed->maxpagesize;
d4266 2
a4267 1
		off += (hdr->sh_addr - off) % hdr->sh_addralign;
d4271 1
a4271 3
	  else if (hdr->sh_type == SHT_REL
		   || hdr->sh_type == SHT_RELA
		   || hdr == i_shdrpp[tdata->symtab_section]
d4287 1
a4287 1
  off = align_file_position (off, bed->s->file_align);
d4297 1
a4297 2
prep_headers (abfd)
     bfd *abfd;
d4303 1
a4303 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4348 2
a4349 5
      if (get_elf_backend_data (abfd) != NULL)
	i_ehdrp->e_machine = get_elf_backend_data (abfd)->elf_machine_code;
      else
	i_ehdrp->e_machine = EM_NONE;
      }
d4402 1
a4402 2
_bfd_elf_assign_file_positions_for_relocs (abfd)
     bfd *abfd;
d4425 1
a4425 2
_bfd_elf_write_object_contents (abfd)
     bfd *abfd;
d4427 1
a4427 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4434 1
a4434 2
      && ! _bfd_elf_compute_section_file_positions
             (abfd, (struct bfd_link_info *) NULL))
d4478 1
a4478 2
_bfd_elf_write_corefile_contents (abfd)
     bfd *abfd;
d4487 1
a4487 3
_bfd_elf_section_from_bfd_section (abfd, asect)
     bfd *abfd;
     struct sec *asect;
d4489 1
a4489 1
  struct elf_backend_data *bed;
d4536 1
a4536 3
_bfd_elf_symbol_from_bfd_symbol (abfd, asym_ptr_ptr)
     bfd *abfd;
     asymbol **asym_ptr_ptr;
d4591 1
a4591 3
copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d4605 1
a4605 1
  struct elf_backend_data *bed;
d4677 3
a4679 2
       5. PT_TLS segment includes only SHF_TLS sections.
       6. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
d4687 1
d4731 1
a4731 1
		 assigment code will work.  */
d4817 1
a4817 1
      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d4898 1
a4898 1
      sections = (asection **) bfd_malloc (amt);
d5100 1
a5100 1
	      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d5194 4
a5197 5
_bfd_elf_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
d5258 4
a5261 5
_bfd_elf_copy_private_symbol_data (ibfd, isymarg, obfd, osymarg)
     bfd *ibfd;
     asymbol *isymarg;
     bfd *obfd;
     asymbol *osymarg;
d5298 3
a5300 4
swap_out_syms (abfd, sttp, relocatable_p)
     bfd *abfd;
     struct bfd_strtab_hash **sttp;
     int relocatable_p;
d5302 1
a5302 1
  struct elf_backend_data *bed;
d5313 1
d5330 1
a5330 1
  symtab_hdr->sh_addralign = bed->s->file_align;
d5342 1
a5342 1
  symtab_hdr->contents = (PTR) outbound_syms;
d5379 4
d5392 2
a5393 1
      if ((flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
d5588 1
a5588 2
_bfd_elf_get_symtab_upper_bound (abfd)
     bfd *abfd;
d5603 1
a5603 2
_bfd_elf_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
d5624 2
a5625 3
_bfd_elf_get_reloc_upper_bound (abfd, asect)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr asect;
d5633 4
a5636 5
_bfd_elf_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d5640 1
a5640 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5655 1
a5655 3
_bfd_elf_get_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d5657 2
a5658 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, FALSE);
d5666 2
a5667 3
_bfd_elf_canonicalize_dynamic_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d5669 2
a5670 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, TRUE);
d5683 1
a5683 2
_bfd_elf_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d5715 3
a5717 4
_bfd_elf_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d5719 1
a5719 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d5758 1
a5758 2
_bfd_elf_slurp_version_tables (abfd)
     bfd *abfd;
d5775 1
a5775 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d5779 1
a5779 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d5799 1
a5799 1
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *) bfd_zalloc (abfd, amt);
d5821 1
a5821 1
	  iverdef->vd_auxptr = (Elf_Internal_Verdaux *) bfd_alloc (abfd, amt);
d5872 1
a5872 2
      elf_tdata (abfd)->verref =
	(Elf_Internal_Verneed *) bfd_zalloc (abfd, amt);
d5878 1
a5878 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d5882 1
a5882 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d5905 1
a5905 1
	  iverneed->vn_auxptr = (Elf_Internal_Vernaux *) bfd_alloc (abfd, amt);
d5951 1
a5951 2
_bfd_elf_make_empty_symbol (abfd)
     bfd *abfd;
d5956 1
a5956 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d5967 3
a5969 4
_bfd_elf_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d5979 2
a5980 3
_bfd_elf_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d6004 2
a6005 3
_bfd_elf_get_lineno (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
d6012 3
a6014 4
_bfd_elf_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d6030 6
a6035 8
elf_find_function (abfd, section, symbols, offset,
		   filename_ptr, functionname_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
d6090 7
a6096 9
_bfd_elf_find_nearest_line (abfd, section, symbols, offset,
			    filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d6145 1
a6145 3
_bfd_elf_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc;
d6156 5
a6160 6
_bfd_elf_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d6166 1
a6166 2
      && ! (_bfd_elf_compute_section_file_positions
	    (abfd, (struct bfd_link_info *) NULL)))
d6179 3
a6181 4
_bfd_elf_no_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d6189 1
a6189 3
_bfd_elf_validate_reloc (abfd, areloc)
     bfd *abfd;
     arelent *areloc;
d6283 1
a6283 2
_bfd_elf_close_and_cleanup (abfd)
     bfd *abfd;
d6300 5
a6304 8
_bfd_elf_rel_vtable_reloc_fn (abfd, re, symbol, data, is, obfd, errmsg)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *re ATTRIBUTE_UNUSED;
     struct symbol_cache_entry *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *is ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     char **errmsg ATTRIBUTE_UNUSED;
d6321 1
a6321 2
elfcore_make_pid (abfd)
     bfd *abfd;
d6333 1
a6333 4
elfcore_maybe_make_sect (abfd, name, sect)
     bfd *abfd;
     char *name;
     asection *sect;
d6359 4
a6362 5
_bfd_elfcore_make_pseudosection (abfd, name, size, filepos)
     bfd *abfd;
     char *name;
     size_t size;
     ufile_ptr filepos;
d6373 1
a6373 1
  threaded_name = bfd_alloc (abfd, (bfd_size_type) len);
d6378 1
a6378 1
  sect = bfd_make_section (abfd, threaded_name);
a6395 2
static bfd_boolean elfcore_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d6398 1
a6398 3
elfcore_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6469 3
a6471 4
elfcore_make_note_pseudosection (abfd, name, note)
     bfd *abfd;
     char *name;
     Elf_Internal_Note *note;
d6482 1
a6482 3
elfcore_grok_prfpreg (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6492 1
a6492 3
elfcore_grok_prxfpreg (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6516 1
a6516 4
_bfd_elfcore_strndup (abfd, start, max)
     bfd *abfd;
     char *start;
     size_t max;
d6527 1
a6527 1
  dups = bfd_alloc (abfd, (bfd_size_type) len + 1);
a6537 3
static bfd_boolean elfcore_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));

d6539 1
a6539 3
elfcore_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
a6596 3
static bfd_boolean elfcore_grok_pstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

d6598 1
a6598 3
elfcore_grok_pstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
a6631 3
static bfd_boolean elfcore_grok_lwpstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

d6633 1
a6633 3
elfcore_grok_lwpstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6657 1
a6657 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6662 1
a6662 1
  sect = bfd_make_section (abfd, name);
d6687 1
a6687 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6692 1
a6692 1
  sect = bfd_make_section (abfd, name);
d6716 1
a6716 3
elfcore_grok_win32pstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6742 1
a6742 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6748 1
a6748 1
      sect = bfd_make_section (abfd, name);
d6769 1
a6769 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6775 1
a6775 1
      sect = bfd_make_section (abfd, name);
d6795 1
a6795 3
elfcore_grok_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6797 1
a6797 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6849 14
d6867 1
a6867 3
elfcore_netbsd_get_lwpid (note, lwpidp)
     Elf_Internal_Note *note;
     int *lwpidp;
d6881 1
a6881 3
elfcore_grok_netbsd_procinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6896 2
a6897 1
  return TRUE;
d6901 1
a6901 3
elfcore_grok_netbsd_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6966 1
a6966 4
elfcore_grok_nto_status (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t *tid;
d6972 2
d6978 5
a6982 2
  /* nto_procfs_status 'tid' field is at offset 4.  */
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);
d6985 5
a6989 1
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, (bfd_byte *) ddata + 14);
d6991 5
a6995 2
  /* Pass tid back.  */
  *tid = elf_tdata (abfd)->core_lwpid;
d7000 1
a7000 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d7005 1
a7005 1
  sect = bfd_make_section (abfd, name);
d7018 1
a7018 4
elfcore_grok_nto_gregs (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t tid;
d7027 1
a7027 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d7032 1
a7032 1
  sect = bfd_make_section (abfd, name);
d7041 5
a7045 1
  return elfcore_maybe_make_sect (abfd, ".reg", sect);
d7054 1
a7054 3
elfcore_grok_nto_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d7084 7
a7090 8
elfcore_write_note (abfd, buf, bufsiz, name, type, input, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *name;
     int  type;
     const PTR input;
     int  size;
d7102 1
a7102 1
      struct elf_backend_data *bed;
d7106 1
a7106 1
      pad = -namesz & (bed->s->file_align - 1);
d7109 1
a7109 1
  newspace = sizeof (Elf_External_Note) - 1 + namesz + pad + size;
d7135 5
a7139 6
elfcore_write_prpsinfo (abfd, buf, bufsiz, fname, psargs)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *fname;
     const char *psargs;
d7162 6
a7167 7
elfcore_write_prstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7183 6
a7188 7
elfcore_write_lwpstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7214 6
a7219 7
elfcore_write_pstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7233 5
a7237 6
elfcore_write_prfpreg (abfd, buf, bufsiz, fpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR fpregs;
     int size;
d7245 5
a7249 6
elfcore_write_prxfpreg (abfd, buf, bufsiz, xfpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR xfpregs;
     int size;
d7257 1
a7257 4
elfcore_read_notes (abfd, offset, size)
     bfd *abfd;
     file_ptr offset;
     bfd_size_type size;
d7325 1
a7325 2
bfd_get_elf_phdr_upper_bound (abfd)
     bfd *abfd;
d7345 1
a7345 3
bfd_get_elf_phdrs (abfd, phdrs)
     bfd *abfd;
     void *phdrs;
d7363 1
a7363 4
_bfd_elf_sprintf_vma (abfd, buf, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     bfd_vma value;
d7391 1
a7391 4
_bfd_elf_fprintf_vma (abfd, stream, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR stream;
     bfd_vma value;
d7420 1
a7420 2
_bfd_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED;
d7429 4
a7432 5
_bfd_elf_rela_local_sym (abfd, sym, sec, rel)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection *sec;
     Elf_Internal_Rela *rel;
d7434 1
a7443 3
      asection *msec;

      msec = sec;
d7445 1
a7445 1
	_bfd_merged_section_offset (abfd, &msec,
d7448 4
a7451 3
				    (bfd_vma) 0)
	- relocation;
      rel->r_addend += msec->output_section->vma + msec->output_offset;
d7457 4
a7460 5
_bfd_elf_rel_local_sym (abfd, sym, psec, addend)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma addend;
d7469 1
a7469 1
				     sym->st_value + addend, (bfd_vma) 0);
d7473 4
a7476 5
_bfd_elf_section_offset (abfd, info, sec, offset)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     bfd_vma offset;
d7492 24
@


1.16
log
@Again this comment was not updated. now we have 7 load sections.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d21 1
a21 1
/*
a22 1
SECTION
d31 1
a31 2
	haven't bothered yet.
 */
d41 1
d44 62
a105 19
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, boolean));
static boolean map_sections_to_segments PARAMS ((bfd *));
static int elf_sort_sections PARAMS ((const PTR, const PTR));
static boolean assign_file_positions_for_segments PARAMS ((bfd *));
static boolean assign_file_positions_except_relocs PARAMS ((bfd *));
static boolean prep_headers PARAMS ((bfd *));
static boolean swap_out_syms PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static boolean copy_private_bfd_data PARAMS ((bfd *, bfd *));
static char *elf_read PARAMS ((bfd *, long, unsigned int));
static void elf_fake_sections PARAMS ((bfd *, asection *, PTR));
static boolean assign_section_numbers PARAMS ((bfd *));
static INLINE int sym_is_global PARAMS ((bfd *, asymbol *));
static boolean elf_map_symbols PARAMS ((bfd *));
static bfd_size_type get_program_header_size PARAMS ((bfd *));
static boolean elfcore_read_notes PARAMS ((bfd *, bfd_vma, bfd_vma));
static boolean elf_find_function PARAMS ((bfd *, asection *,
                                         asymbol **,
                                         bfd_vma, const char **,
                                         const char **));
d119 7
a125 7
  dst->vd_version = bfd_h_get_16 (abfd, src->vd_version);
  dst->vd_flags   = bfd_h_get_16 (abfd, src->vd_flags);
  dst->vd_ndx     = bfd_h_get_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = bfd_h_get_16 (abfd, src->vd_cnt);
  dst->vd_hash    = bfd_h_get_32 (abfd, src->vd_hash);
  dst->vd_aux     = bfd_h_get_32 (abfd, src->vd_aux);
  dst->vd_next    = bfd_h_get_32 (abfd, src->vd_next);
d136 7
a142 7
  bfd_h_put_16 (abfd, src->vd_version, dst->vd_version);
  bfd_h_put_16 (abfd, src->vd_flags, dst->vd_flags);
  bfd_h_put_16 (abfd, src->vd_ndx, dst->vd_ndx);
  bfd_h_put_16 (abfd, src->vd_cnt, dst->vd_cnt);
  bfd_h_put_32 (abfd, src->vd_hash, dst->vd_hash);
  bfd_h_put_32 (abfd, src->vd_aux, dst->vd_aux);
  bfd_h_put_32 (abfd, src->vd_next, dst->vd_next);
d153 2
a154 2
  dst->vda_name = bfd_h_get_32 (abfd, src->vda_name);
  dst->vda_next = bfd_h_get_32 (abfd, src->vda_next);
d165 2
a166 2
  bfd_h_put_32 (abfd, src->vda_name, dst->vda_name);
  bfd_h_put_32 (abfd, src->vda_next, dst->vda_next);
d177 5
a181 5
  dst->vn_version = bfd_h_get_16 (abfd, src->vn_version);
  dst->vn_cnt     = bfd_h_get_16 (abfd, src->vn_cnt);
  dst->vn_file    = bfd_h_get_32 (abfd, src->vn_file);
  dst->vn_aux     = bfd_h_get_32 (abfd, src->vn_aux);
  dst->vn_next    = bfd_h_get_32 (abfd, src->vn_next);
d192 5
a196 5
  bfd_h_put_16 (abfd, src->vn_version, dst->vn_version);
  bfd_h_put_16 (abfd, src->vn_cnt, dst->vn_cnt);
  bfd_h_put_32 (abfd, src->vn_file, dst->vn_file);
  bfd_h_put_32 (abfd, src->vn_aux, dst->vn_aux);
  bfd_h_put_32 (abfd, src->vn_next, dst->vn_next);
d207 5
a211 5
  dst->vna_hash  = bfd_h_get_32 (abfd, src->vna_hash);
  dst->vna_flags = bfd_h_get_16 (abfd, src->vna_flags);
  dst->vna_other = bfd_h_get_16 (abfd, src->vna_other);
  dst->vna_name  = bfd_h_get_32 (abfd, src->vna_name);
  dst->vna_next  = bfd_h_get_32 (abfd, src->vna_next);
d222 5
a226 5
  bfd_h_put_32 (abfd, src->vna_hash, dst->vna_hash);
  bfd_h_put_16 (abfd, src->vna_flags, dst->vna_flags);
  bfd_h_put_16 (abfd, src->vna_other, dst->vna_other);
  bfd_h_put_32 (abfd, src->vna_name, dst->vna_name);
  bfd_h_put_32 (abfd, src->vna_next, dst->vna_next);
d237 1
a237 1
  dst->vs_vers = bfd_h_get_16 (abfd, src->vs_vers);
d248 1
a248 1
  bfd_h_put_16 (abfd, src->vs_vers, dst->vs_vers);
d274 1
a274 1
  return h;
d284 2
a285 2
     long offset;
     unsigned int size;
d291 1
a291 1
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
d293 1
a293 1
  if (bfd_read ((PTR) buf, size, 1, abfd) != size)
d302 1
a302 1
boolean
d308 2
a309 2
  elf_tdata (abfd) = (struct elf_obj_tdata *)
    bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
d311 1
a311 1
    return false;
d315 1
a315 1
  return true;
d318 1
a318 1
boolean
d333 2
a334 2
  unsigned int offset;
  unsigned int shstrtabsize;
d373 1
a373 1
	 bfd_get_filename (abfd), strindex, (unsigned long) hdr->sh_size,
d384 336
d723 1
a723 1
boolean
d737 1
a737 1
      return true;
d742 1
a742 1
    return false;
d749 2
a750 2
				      bfd_log2 (hdr->sh_addralign)))
    return false;
d755 2
d769 12
d794 1
a794 1
    for (i = sizeof (debug_sec_names) / sizeof (debug_sec_names[0]); i--;)
d808 2
a809 1
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
d815 1
a815 1
      return false;
d818 1
a818 1
    return false;
d839 12
d852 3
a854 4
		  && phdr->p_vaddr != phdr->p_paddr
		  && phdr->p_vaddr <= hdr->sh_addr
		  && (phdr->p_vaddr + phdr->p_memsz
		      >= hdr->sh_addr + hdr->sh_size)
d856 2
a857 3
		      || (phdr->p_offset <= (bfd_vma) hdr->sh_offset
			  && (phdr->p_offset + phdr->p_filesz
			      >= hdr->sh_offset + hdr->sh_size))))
d859 22
a880 2
		  newsect->lma += phdr->p_paddr - phdr->p_vaddr;
		  break;
d889 1
a889 1
  return true;
d920 2
a921 2
      shstrtab = bfd_elf_get_str_section
	(abfd, elf_elfheader (abfd)->e_shstrndx);
d924 1
a924 1
	  max = elf_elfheader (abfd)->e_shnum;
d977 61
d1040 1
a1040 1
boolean
d1059 1
a1059 1
	  const char *s;
d1064 10
a1073 8
	    case PT_NULL: s = "NULL"; break;
	    case PT_LOAD: s = "LOAD"; break;
	    case PT_DYNAMIC: s = "DYNAMIC"; break;
	    case PT_INTERP: s = "INTERP"; break;
	    case PT_NOTE: s = "NOTE"; break;
	    case PT_SHLIB: s = "SHLIB"; break;
	    case PT_PHDR: s = "PHDR"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); s = buf; break;
d1075 2
a1076 2
	  fprintf (f, "%8s off    0x", s);
	  fprintf_vma (f, p->p_offset);
d1078 1
a1078 1
	  fprintf_vma (f, p->p_vaddr);
d1080 1
a1080 1
	  fprintf_vma (f, p->p_paddr);
d1083 1
a1083 1
	  fprintf_vma (f, p->p_filesz);
d1085 1
a1085 1
	  fprintf_vma (f, p->p_memsz);
d1090 2
a1091 2
	  if ((p->p_flags &~ (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (PF_R | PF_W | PF_X));
d1100 1
a1100 1
      unsigned long link;
d1117 1
a1117 1
      link = elf_elfsections (abfd)[elfsec]->sh_link;
d1129 1
a1129 1
	  boolean stringp;
d1136 1
a1136 1
	  stringp = false;
d1144 1
a1144 1
	    case DT_NEEDED: name = "NEEDED"; stringp = true; break;
d1157 2
a1158 2
	    case DT_SONAME: name = "SONAME"; stringp = true; break;
	    case DT_RPATH: name = "RPATH"; stringp = true; break;
d1172 1
a1172 1
	    case DT_RUNPATH: name = "RUNPATH"; stringp = true; break;
d1184 3
a1186 3
	    case DT_CONFIG: name = "CONFIG"; stringp = true; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = true; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = true; break;
d1198 1
a1198 1
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
d1200 1
a1200 1
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
d1209 1
d1211 1
a1211 2
	      string = bfd_elf_string_from_elf_section (abfd, link,
							dyn.d_un.d_val);
d1227 1
a1227 1
	return false;
d1269 1
a1269 1
  return true;
d1274 1
a1274 1
  return false;
d1294 1
a1294 1
      fprintf_vma (file, symbol->value);
d1303 1
d1314 1
a1314 1
	    bfd_print_symbol_vandf ((PTR) file, symbol);
d1322 5
a1326 4
	fprintf_vma (file,
		     (bfd_is_com_section (symbol->section)
		      ? ((elf_symbol_type *) symbol)->internal_elf_sym.st_value
		      : ((elf_symbol_type *) symbol)->internal_elf_sym.st_size));
a1407 2
  struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;

d1410 6
a1415 5
  if (ret == (struct elf_link_hash_entry *) NULL)
    ret = ((struct elf_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry)));
  if (ret == (struct elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d1418 2
a1419 4
  ret = ((struct elf_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret != (struct elf_link_hash_entry *) NULL)
d1421 3
a1425 1
      ret->size = 0;
d1428 1
d1430 1
a1430 3
      ret->got.offset = (bfd_vma) -1;
      ret->plt.offset = (bfd_vma) -1;
      ret->linker_section_pointer = (elf_linker_section_pointers_t *)0;
d1432 1
a1433 1
      ret->vtable_entries_size = 0;
d1435 3
d1447 1
a1447 1
  return (struct bfd_hash_entry *) ret;
d1451 1
a1451 1
   old indirect symbol.  */
d1454 2
a1455 1
_bfd_elf_link_hash_copy_indirect (dir, ind)
d1458 3
d1471 4
a1474 1
  /* Copy over the global and procedure linkage table offset entries.
d1476 2
a1477 1
  if (dir->got.offset == (bfd_vma) -1)
d1479 2
a1480 2
      dir->got.offset = ind->got.offset;
      ind->got.offset = (bfd_vma) -1;
d1482 2
a1483 1
  BFD_ASSERT (ind->got.offset == (bfd_vma) -1);
d1485 2
a1486 1
  if (dir->plt.offset == (bfd_vma) -1)
d1488 2
a1489 2
      dir->plt.offset = ind->plt.offset;
      ind->plt.offset = (bfd_vma) -1;
d1491 2
a1492 1
  BFD_ASSERT (ind->plt.offset == (bfd_vma) -1);
d1501 2
a1502 1
  BFD_ASSERT (ind->dynindx == -1);
d1506 2
a1507 2
_bfd_elf_link_hash_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1509 1
d1511 1
d1513 10
a1522 3
  h->plt.offset = (bfd_vma) -1;
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
d1527 1
a1527 1
boolean
d1531 3
a1533 3
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d1535 3
a1537 1
  table->dynamic_sections_created = false;
d1539 5
a1548 1
  table->runpath = NULL;
d1551 2
d1554 8
a1561 1
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d1571 1
d1573 1
a1573 2
  ret = ((struct elf_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_link_hash_table)));
d1579 1
a1579 1
      bfd_release (abfd, ret);
d1619 1
a1619 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
d1632 1
a1632 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
d1654 1
a1654 1
boolean
d1662 1
a1662 1
  unsigned long link;
d1671 1
a1671 1
    return true;
d1675 1
a1675 1
    return true;
d1689 1
a1689 1
  link = elf_elfsections (abfd)[elfsec]->sh_link;
d1709 2
d1712 1
a1712 2
	  string = bfd_elf_string_from_elf_section (abfd, link,
						    dyn.d_un.d_val);
d1716 2
a1717 1
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, sizeof *l);
d1730 1
a1730 1
  return true;
d1735 1
a1735 1
  return false;
d1750 1
a1750 1
      loc = _bfd_stringtab_add (ret, "", true, false);
d1765 1
a1765 1
boolean
d1773 1
a1773 1
  char *name;
d1781 1
a1781 1
      return true;
a1783 1
    case SHT_DYNAMIC:	/* Dynamic linking information.  */
d1787 3
d1792 33
d1827 1
a1827 1
	return true;
d1845 1
a1845 1
	return false;
d1847 1
a1847 1
      return true;
d1851 1
a1851 1
	return true;
d1864 14
d1880 1
a1880 1
	return true;
d1885 1
a1885 1
	  return true;
d1888 1
a1888 1
	unsigned int i;
d1890 2
a1891 1
	for (i = 1; i < ehdr->e_shnum; i++)
d1897 1
a1897 1
		  return false;
d1903 1
a1903 1
		    return true;
d1937 1
d1940 2
a1941 1
	if (hdr->sh_link >= ehdr->e_shnum)
d1945 1
a1945 1
	      bfd_get_filename (abfd), hdr->sh_link, name, shindex));
d1959 1
a1959 1
	    int scan;
d1963 1
a1963 1
	    for (scan = 1; scan < ehdr->e_shnum; scan++)
d1983 1
a1983 1
	  return false;
d1995 1
a1995 1
	  return false;
d1998 1
a1998 1
	  return false;
d2005 1
d2007 2
a2008 1
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, sizeof (*hdr2));
d2020 1
a2020 2
	  elf_section_data (target_sect)->use_rela_p
	    = (hdr->sh_type == SHT_RELA);
d2022 1
a2022 1
	return true;
d2045 30
a2074 1
      return true;
d2085 42
a2126 1
  return true;
d2137 1
a2137 2
  BFD_ASSERT (index > 0 && index < SHN_LORESERVE);
  if (index >= elf_elfheader (abfd)->e_shnum)
d2142 1
a2142 1
boolean
d2149 9
a2157 4
  sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, sizeof (*sdata));
  if (!sdata)
    return false;
  sec->used_by_bfd = (PTR) sdata;
d2160 1
a2160 2
  sdata->use_rela_p
    = get_elf_backend_data (abfd)->default_use_rela_p;
d2162 1
a2162 1
  return true;
d2187 1
a2187 1
boolean
d2197 1
d2204 2
a2205 1
  name = bfd_alloc (abfd, strlen (namebuf) + 1);
d2207 2
a2208 2
    return false;
  strcpy (name, namebuf);
d2211 1
a2211 1
    return false;
d2236 2
a2237 1
      name = bfd_alloc (abfd, strlen (namebuf) + 1);
d2239 2
a2240 2
	return false;
      strcpy (name, namebuf);
d2243 1
a2243 1
	return false;
d2257 1
a2257 1
  return true;
d2260 1
a2260 1
boolean
d2284 4
a2287 4
	return false;
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
	return false;
      return true;
d2295 4
d2311 1
a2311 1
   relocations against ASECT.  If USE_RELA_P is true, we use RELA
d2314 1
a2314 1
boolean
d2319 1
a2319 1
     boolean use_rela_p;
d2322 2
a2323 1
  struct elf_backend_data *bed;
d2325 1
a2325 2
  bed = get_elf_backend_data (abfd);
  name = bfd_alloc (abfd, sizeof ".rela" + strlen (asect->name));
d2327 1
a2327 1
    return false;
d2330 2
a2331 2
    (unsigned int) _bfd_stringtab_add (elf_shstrtab (abfd), name,
				       true, false);
d2333 1
a2333 1
    return false;
d2344 1
a2344 1
  return true;
d2356 1
a2356 1
  boolean *failedptr = (boolean *) failedptrarg;
d2368 3
a2370 4
  this_hdr->sh_name = (unsigned long) _bfd_stringtab_add (elf_shstrtab (abfd),
							  asect->name,
							  true, false);
  if (this_hdr->sh_name == (unsigned long) -1)
d2372 1
a2372 1
      *failedptr = true;
d2424 6
d2466 5
d2472 2
a2473 1
	   && ((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0))
d2484 24
d2510 3
a2512 2
  if (bed->elf_backend_fake_sections)
    (*bed->elf_backend_fake_sections) (abfd, this_hdr, asect);
d2522 109
a2630 2
				    elf_section_data (asect)->use_rela_p))
    *failedptr = true;
d2637 1
a2637 1
static boolean
d2643 1
a2643 1
  unsigned int section_number;
d2645 1
d2649 2
d2655 2
d2658 1
d2662 6
a2667 1
	d->rel_idx = section_number++;
d2670 6
a2675 1
	d->rel_idx2 = section_number++;
d2680 2
d2683 1
a2684 1
  t->shstrtab_hdr.sh_size = _bfd_stringtab_size (elf_shstrtab (abfd));
d2688 2
d2691 14
d2706 1
d2709 4
d2714 2
d2719 2
a2720 2
  i_shdrp = ((Elf_Internal_Shdr **)
	     bfd_alloc (abfd, section_number * sizeof (Elf_Internal_Shdr *)));
d2722 1
a2722 1
    return false;
d2724 2
a2725 2
  i_shdrp[0] = ((Elf_Internal_Shdr *)
		bfd_alloc (abfd, sizeof (Elf_Internal_Shdr)));
d2729 1
a2729 1
      return false;
a2730 1
  memset (i_shdrp[0], 0, sizeof (Elf_Internal_Shdr));
d2738 5
d2811 1
a2811 1
	      alc = (char *) bfd_malloc (len - 2);
d2813 2
a2814 2
		return false;
	      strncpy (alc, sec->name, len - 3);
d2823 3
a2825 2
		  elf_section_data (s)->this_hdr.sh_entsize =
		    4 + 2 * bfd_get_arch_size (abfd) / 8;
d2850 3
d2856 7
a2862 1
  return true;
d2883 1
a2883 1
static boolean
d2887 1
a2887 1
  int symcount = bfd_get_symcount (abfd);
d2890 4
a2893 4
  int num_locals = 0;
  int num_globals = 0;
  int num_locals2 = 0;
  int num_globals2 = 0;
d2895 1
a2895 2
  int num_sections = 0;
  int idx;
d2898 1
a2898 1
  asymbol *sym;
a2904 2
  /* Add a section symbol for each BFD section.  FIXME: Is this really
     necessary?  */
d2912 2
a2913 1
  sect_syms = (asymbol **) bfd_zalloc (abfd, max_index * sizeof (asymbol *));
d2915 1
a2915 1
    return false;
d2917 1
d2919 2
d2923 1
a2923 1
      sym = syms[idx];
d2941 10
a2950 9
		  /* Empty sections in the input files may have had a section
		     symbol created for them.  (See the comment near the end of
		     _bfd_generic_link_output_symbols in linker.c).  If the linker
		     script discards such sections then we will reach this point.
		     Since we know that we cannot avoid this case, we detect it
		     and skip the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the linker
		     testsuite test ld-scripts/weak.exp for an ELF port that uses
		     the generic linker.  */
d2961 2
a2962 1
  for (asect = abfd->sections; asect; asect = asect->next)
d2964 2
a2965 26
      if (sect_syms[asect->index] != NULL)
	continue;

      sym = bfd_make_empty_symbol (abfd);
      if (sym == NULL)
	return false;
      sym->the_bfd = abfd;
      sym->name = asect->name;
      sym->value = 0;
      /* Set the flags to 0 to indicate that this one was newly added.  */
      sym->flags = 0;
      sym->section = asect;
      sect_syms[asect->index] = sym;
      num_sections++;
#ifdef DEBUG
      fprintf (stderr,
 _("creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n"),
	       asect->name, (long) asect->vma, asect->index, (long) asect);
#endif
    }

  /* Classify all of the symbols.  */
  for (idx = 0; idx < symcount; idx++)
    {
      if (!sym_is_global (abfd, syms[idx]))
	num_locals++;
d2969 5
d2976 1
a2976 2
      if (sect_syms[asect->index] != NULL
	  && sect_syms[asect->index]->flags == 0)
d2978 1
a2978 2
	  sect_syms[asect->index]->flags = BSF_SECTION_SYM;
	  if (!sym_is_global (abfd, sect_syms[asect->index]))
a2981 1
	  sect_syms[asect->index]->flags = 0;
d2986 3
a2988 3
  new_syms = ((asymbol **)
	      bfd_alloc (abfd,
			 (num_locals + num_globals) * sizeof (asymbol *)));
d2990 1
a2990 1
    return false;
d2995 1
a2995 1
      int i;
d3006 1
a3006 2
      if (sect_syms[asect->index] != NULL
	  && sect_syms[asect->index]->flags == 0)
d3008 2
a3009 2
	  asymbol *sym = sect_syms[asect->index];
	  int i;
d3011 1
a3011 1
	  sym->flags = BSF_SECTION_SYM;
d3025 1
a3025 1
  return true;
d3031 2
a3032 1
static INLINE file_ptr align_file_position PARAMS ((file_ptr, int));
d3048 1
a3048 1
     boolean align;
d3070 1
a3070 1
boolean
d3076 1
a3076 1
  boolean failed;
d3081 1
a3081 1
    return true;
d3088 1
a3088 1
    return false;
d3094 1
a3094 1
  failed = false;
d3097 1
a3097 1
    return false;
d3100 1
a3100 1
    return false;
d3109 8
a3116 1
	return false;
d3124 1
a3124 1
  shstrtab_hdr->sh_size = _bfd_stringtab_size (elf_shstrtab (abfd));
d3132 1
a3132 1
    return false;
d3142 5
a3146 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3149 1
a3149 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3157 1
a3157 1
	return false;
d3161 1
a3161 1
  abfd->output_has_begun = true;
d3163 1
a3163 1
  return true;
d3174 1
a3174 1
     boolean phdr;
d3179 1
d3181 3
a3183 4
  m = ((struct elf_segment_map *)
       bfd_zalloc (abfd,
		   (sizeof (struct elf_segment_map)
		    + (to - from - 1) * sizeof (asection *))));
d3204 1
a3204 1
static boolean
d3219 6
a3224 3
  boolean phdr_in_segment = true;
  boolean writable;
  asection *dynsec;
d3227 1
a3227 1
    return true;
d3230 1
a3230 1
    return true;
d3234 2
a3235 2
  sections = (asection **) bfd_malloc (bfd_count_sections (abfd)
				       * sizeof (asection *));
d3264 2
a3265 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d3278 2
a3279 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d3297 1
a3297 1
  writable = false;
d3317 1
a3317 1
	phdr_in_segment = false;
d3323 1
a3323 1
      boolean new_segment;
d3334 1
a3334 1
	  new_segment = false;
d3341 1
a3341 1
	  new_segment = true;
d3348 1
a3348 1
	  new_segment = true;
d3355 1
a3355 1
	  new_segment = true;
d3362 1
a3362 1
	  new_segment = false;
d3366 3
a3368 2
	       && (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
		   == hdr->lma))
d3377 1
a3377 1
	  new_segment = true;
d3382 1
a3382 1
	  new_segment = false;
d3388 1
a3388 1
	    writable = true;
d3404 1
a3404 1
	writable = true;
d3406 1
a3406 1
	writable = false;
d3410 1
a3410 1
      phdr_in_segment = false;
d3427 2
a3428 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d3450 2
a3451 2
	  m = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d3462 52
d3520 1
a3520 1
  return true;
d3525 1
a3525 1
  return false;
d3537 1
d3555 1
a3555 1
#define TOEND(x) (((x)->flags & SEC_LOAD) == 0)
d3560 6
a3565 1
	return sec1->target_index - sec2->target_index;
d3569 1
a3569 2

  if (TOEND (sec2))
d3574 2
a3575 2
  /* Sort by size, to put zero sized sections before others at the
     same address.  */
d3577 4
a3580 1
  if (sec1->_raw_size < sec2->_raw_size)
d3582 1
a3582 1
  if (sec1->_raw_size > sec2->_raw_size)
d3592 1
a3592 1
static boolean
d3605 1
d3610 32
a3641 1
	return false;
d3647 1
a3647 1
	return false;
d3659 1
a3659 1
    return true;
d3671 1
a3671 1
      return false;
d3677 2
a3678 2
  phdrs = ((Elf_Internal_Phdr *)
	   bfd_alloc (abfd, alloc * sizeof (Elf_Internal_Phdr)));
d3680 1
a3680 1
    return false;
d3698 7
a3704 2
         sections may not be correctly ordered.  */
      if (m->count > 0)
d3772 3
a3774 2
		  _bfd_error_handler (_("%s: Not enough room for program headers, try linking with -N"),
				      bfd_get_filename (abfd));
d3776 1
a3776 1
		  return false;
d3857 2
a3858 2
	     cumulative phdr vma and the section's vma.  */
	  if (p->p_vaddr + p->p_memsz < sec->vma)
d3860 1
a3860 1
	      bfd_vma adjust = sec->vma - (p->p_vaddr + p->p_memsz);
d3863 9
a3871 3
	      off += adjust;
	      voff += adjust;
	      if ((flags & SEC_LOAD) != 0)
d3904 6
a3909 8
		      (* _bfd_error_handler)
			(_("Error: First section in segment (%s) starts at 0x%x"),
			 bfd_section_name (abfd, sec), sec->lma);
		      (* _bfd_error_handler)
			(_("       whereas segment starts at 0x%x"),
			 p->p_paddr);

		      return false;
d3928 3
a3930 1
	      if ((flags & SEC_ALLOC) != 0)
d3957 3
d3965 14
d4035 1
a4035 1
  if (bfd_seek (abfd, bed->s->sizeof_ehdr, SEEK_SET) != 0
d4037 1
a4037 1
    return false;
d4039 1
a4039 1
  return true;
d4099 6
d4115 10
d4151 1
a4151 1
static boolean
d4158 1
d4174 1
a4174 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < i_ehdrp->e_shnum; i++, hdrpp++)
d4179 5
a4183 1
	  if (hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
a4185 1
	      continue;
d4187 4
a4190 2
	  if (i == tdata->symtab_section
	      || i == tdata->strtab_section)
d4192 2
a4193 2
	      hdr->sh_offset = -1;
	      continue;
a4194 2

	  off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d4205 1
a4205 1
	return false;
d4210 1
a4210 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < i_ehdrp->e_shnum; i++, hdrpp++)
d4231 1
a4231 1
							       false);
d4236 1
d4240 7
a4246 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d4257 1
a4257 1
  return true;
d4260 1
a4260 1
static boolean
d4267 1
a4267 2
  int count;
  struct bfd_strtab_hash *shstrtab;
d4273 1
a4273 1
  shstrtab = _bfd_elf_stringtab_init ();
d4275 1
a4275 1
    return false;
a4288 6
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NONE;
  i_ehdrp->e_ident[EI_ABIVERSION] = 0;

  for (count = EI_PAD; count < EI_NIDENT; count++)
    i_ehdrp->e_ident[count] = 0;

d4303 12
a4314 3
    case bfd_arch_sparc:
      if (bfd_get_arch_size (abfd) == 64)
	i_ehdrp->e_machine = EM_SPARCV9;
d4316 3
a4318 94
	i_ehdrp->e_machine = EM_SPARC;
      break;
    case bfd_arch_i370:
      i_ehdrp->e_machine = EM_S370;
      break;
    case bfd_arch_i386:
      if (bfd_get_arch_size (abfd) == 64)
	i_ehdrp->e_machine = EM_X86_64;
      else
	i_ehdrp->e_machine = EM_386;
      break;
    case bfd_arch_ia64:
      i_ehdrp->e_machine = EM_IA_64;
      break;
    case bfd_arch_m68hc11:
      i_ehdrp->e_machine = EM_68HC11;
      break;
    case bfd_arch_m68hc12:
      i_ehdrp->e_machine = EM_68HC12;
      break;
    case bfd_arch_m68k:
      i_ehdrp->e_machine = EM_68K;
      break;
    case bfd_arch_m88k:
      i_ehdrp->e_machine = EM_88K;
      break;
    case bfd_arch_i860:
      i_ehdrp->e_machine = EM_860;
      break;
    case bfd_arch_i960:
      i_ehdrp->e_machine = EM_960;
      break;
    case bfd_arch_mips:	/* MIPS Rxxxx */
      i_ehdrp->e_machine = EM_MIPS;	/* only MIPS R3000 */
      break;
    case bfd_arch_hppa:
      i_ehdrp->e_machine = EM_PARISC;
      break;
    case bfd_arch_powerpc:
      i_ehdrp->e_machine = EM_PPC;
      break;
    case bfd_arch_alpha:
      i_ehdrp->e_machine = EM_ALPHA;
      break;
    case bfd_arch_sh:
      i_ehdrp->e_machine = EM_SH;
      break;
    case bfd_arch_d10v:
      i_ehdrp->e_machine = EM_CYGNUS_D10V;
      break;
    case bfd_arch_d30v:
      i_ehdrp->e_machine = EM_CYGNUS_D30V;
      break;
    case bfd_arch_fr30:
      i_ehdrp->e_machine = EM_CYGNUS_FR30;
      break;
    case bfd_arch_mcore:
      i_ehdrp->e_machine = EM_MCORE;
      break;
    case bfd_arch_avr:
      i_ehdrp->e_machine = EM_AVR;
      break;
    case bfd_arch_v850:
      switch (bfd_get_mach (abfd))
	{
	default:
	case 0:               i_ehdrp->e_machine = EM_CYGNUS_V850; break;
	}
      break;
    case bfd_arch_arc:
      i_ehdrp->e_machine = EM_CYGNUS_ARC;
      break;
    case bfd_arch_arm:
      i_ehdrp->e_machine = EM_ARM;
      break;
    case bfd_arch_m32r:
      i_ehdrp->e_machine = EM_CYGNUS_M32R;
      break;
    case bfd_arch_mn10200:
      i_ehdrp->e_machine = EM_CYGNUS_MN10200;
      break;
    case bfd_arch_mn10300:
      i_ehdrp->e_machine = EM_CYGNUS_MN10300;
      break;
    case bfd_arch_pj:
      i_ehdrp->e_machine = EM_PJ;
      break;
    case bfd_arch_cris:
      i_ehdrp->e_machine = EM_CRIS;
      break;
      /* Also note that EM_M32, AT&T WE32100 is unknown to bfd.  */
    default:
      i_ehdrp->e_machine = EM_NONE;
    }
d4353 1
a4353 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".symtab", true, false);
d4355 1
a4355 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".strtab", true, false);
d4357 1
a4357 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".shstrtab", true, false);
d4361 1
a4361 1
    return false;
d4363 1
a4363 1
  return true;
d4374 1
a4374 1
  unsigned int i;
d4379 2
a4380 3
  for (i = 1, shdrpp = elf_elfsections (abfd) + 1;
       i < elf_elfheader (abfd)->e_shnum;
       i++, shdrpp++)
d4387 1
a4387 1
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, true);
d4393 1
a4393 1
boolean
d4400 2
a4401 2
  boolean failed;
  unsigned int count;
d4406 1
a4406 1
    return false;
d4411 1
a4411 1
  failed = false;
d4414 1
a4414 1
    return false;
d4419 2
a4420 1
  for (count = 1; count < i_ehdrp->e_shnum; count++)
d4426 2
d4429 2
a4430 4
	      || (bfd_write (i_shdrp[count]->contents, i_shdrp[count]->sh_size,
			     1, abfd)
		  != i_shdrp[count]->sh_size))
	    return false;
d4432 2
d4438 2
a4439 2
      || ! _bfd_stringtab_emit (abfd, elf_shstrtab (abfd)))
    return false;
d4448 1
a4448 1
boolean
d4463 1
a4463 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
a4464 2
  Elf_Internal_Shdr *hdr;
  int maxindex = elf_elfheader (abfd)->e_shnum;
d4466 11
a4476 1
  for (index = 0; index < maxindex; index++)
d4478 11
a4488 3
      hdr = i_shdrp[index];
      if (hdr->bfd_section == asect)
	return index;
d4491 1
d4494 1
a4494 3
      for (index = 0; index < maxindex; index++)
	{
	  int retval;
d4496 2
a4497 6
	  hdr = i_shdrp[index];
	  retval = index;
	  if ((*bed->elf_backend_section_from_bfd_section)
	      (abfd, hdr, asect, &retval))
	    return retval;
	}
d4500 2
a4501 8
  if (bfd_is_abs_section (asect))
    return SHN_ABS;
  if (bfd_is_com_section (asect))
    return SHN_COMMON;
  if (bfd_is_und_section (asect))
    return SHN_UNDEF;

  bfd_set_error (bfd_error_nonrepresentable_section);
d4503 1
a4503 1
  return -1;
d4533 2
a4534 1
      if (elf_section_syms (abfd)[indx])
d4546 1
a4546 1
	 bfd_get_filename (abfd), bfd_asymbol_name (asym_ptr));
d4554 1
a4554 1
	     _("elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n"),
d4566 1
a4566 1
static boolean
d4571 13
a4583 12
  Elf_Internal_Ehdr *       iehdr;
  struct elf_segment_map *  map;
  struct elf_segment_map *  map_first;
  struct elf_segment_map ** pointer_to_map;
  Elf_Internal_Phdr *       segment;
  asection *                section;
  unsigned int              i;
  unsigned int              num_segments;
  boolean                   phdr_included = false;
  bfd_vma                   maxpagesize;
  struct elf_segment_map *  phdr_adjust_seg = NULL;
  unsigned int              phdr_adjust_num = 0;
d4587 1
a4587 1
    return true;
d4590 1
a4590 1
    return true;
d4592 1
d4602 8
a4609 3
#define SEGMENT_END(segment, start) 			\
  (start + (segment->p_memsz > segment->p_filesz 	\
   ? segment->p_memsz : segment->p_filesz))
d4611 1
a4611 1
  /* Returns true if the given section is contained within
d4613 4
a4616 4
#define IS_CONTAINED_BY_VMA(section, segment)		\
  (section->vma >= segment->p_vaddr			\
   && (section->vma + section->_raw_size)		\
   <= (SEGMENT_END (segment, segment->p_vaddr)))
d4618 1
a4618 1
  /* Returns true if the given section is contained within
d4620 4
a4623 4
#define IS_CONTAINED_BY_LMA(section, segment, base)	\
    (section->lma >= base				\
     && (section->lma + section->_raw_size)		\
     <= SEGMENT_END (segment, base))
d4626 7
a4632 7
#define IS_COREFILE_NOTE(p, s)                          \
	    (p->p_type == PT_NOTE                       \
	     && bfd_get_format (ibfd) == bfd_core       \
	     && s->vma == 0 && s->lma == 0              \
	     && (bfd_vma) s->filepos >= p->p_offset     \
	     && (bfd_vma) s->filepos + s->_raw_size     \
	     <= p->p_offset + p->p_filesz)
d4637 10
a4646 8
#define IS_SOLARIS_PT_INTERP(p, s)			\
	    (   p->p_vaddr == 0				\
	     && p->p_filesz > 0				\
	     && (s->flags & SEC_HAS_CONTENTS) != 0	\
	     && s->_raw_size > 0			\
	     && (bfd_vma) s->filepos >= p->p_offset	\
	     && ((bfd_vma) s->filepos + s->_raw_size	\
		     <= p->p_offset + p->p_filesz))
d4650 2
a4651 1
       1. It is within the address space of the segment,
d4654 32
a4685 16
       4. The section has not already been allocated to a previous segment.  */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment)	\
  ((((IS_CONTAINED_BY_VMA (section, segment) 		\
      || IS_SOLARIS_PT_INTERP (segment, section))	\
     && (section->flags & SEC_ALLOC) != 0)		\
    || IS_COREFILE_NOTE (segment, section))		\
   && section->output_section != NULL			\
   && section->segment_mark == false)

  /* Returns true iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)		\
    (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))

  /* Returns true iff seg1 and seg2 overlap.  */
#define SEGMENT_OVERLAPS(seg1, seg2)			\
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2) || SEGMENT_AFTER_SEGMENT (seg2, seg1)))
d4689 1
a4689 1
    section->segment_mark = false;
d4693 2
a4694 2
     in the loadable segments.  These can be created by wierd
     parameters to objcopy.  */
d4702 10
d4777 1
d4783 4
a4786 3
      section_count = 0;
      for (section = ibfd->sections; section != NULL; section = section->next)
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
d4789 5
a4793 6
      /* Allocate a segment map big enough to contain all of the
	 sections we have selected.  */
      map = ((struct elf_segment_map *)
	   bfd_alloc (obfd,
		      (sizeof (struct elf_segment_map)
		       + ((size_t) section_count - 1) * sizeof (asection *))));
d4795 1
a4795 1
	return false;
d4822 1
a4822 1
	    phdr_included = true;
d4829 2
a4830 1
	     something.  */
d4832 3
a4834 3
	      _bfd_error_handler
		(_("%s: warning: Empty loadable segment detected\n"),
		 bfd_get_filename (ibfd));
d4862 1
a4862 1
	 4. The sections have been moved, but not be the same amount.
d4871 4
a4874 2
      sections = (asection **) bfd_malloc
	(sizeof (asection *) * section_count);
d4876 1
a4876 1
	return false;
d4892 1
a4892 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
d4900 2
a4901 1
		 correct value.  */
d4904 1
d4912 2
a4913 1
						 ? iehdr->e_phnum * iehdr->e_phentsize
d4920 4
a4923 1
		  || IS_COREFILE_NOTE (segment, section))
d4992 1
a4992 1
	 those that fit to the current segment and remvoing them from the
d5041 5
a5045 3
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
			  < BFD_ALIGN (output_section->lma, maxpagesize))
			  || ((prev_sec->lma + prev_sec->_raw_size) > output_section->lma))
d5057 1
a5057 1
		  section->segment_mark = true;
d5074 3
a5076 5
	      map = ((struct elf_segment_map *)
		     bfd_alloc (obfd,
				(sizeof (struct elf_segment_map)
				 + ((size_t) section_count - 1)
				 * sizeof (asection *))));
d5078 4
a5081 1
		return false;
d5109 2
a5110 4
    {
      for (map = map_first; map != NULL; map = map->next)
	map->p_paddr_valid = 0;
    }
d5115 1
a5115 1
     going to be needed, then check our estimate know and adjust
d5155 1
d5163 1
a5163 1
  return true;
d5169 1
a5169 1
boolean
d5180 1
a5180 1
    return true;
d5182 1
a5182 7
  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  */
  if (elf_tdata (obfd)->segment_map == NULL
      && elf_tdata (ibfd)->phdr != NULL)
d5184 1
a5184 1
      asection *s;
d5186 12
a5197 12
      /* Only set up the segments if there are no more SEC_ALLOC
         sections.  FIXME: This won't do the right thing if objcopy is
         used to remove the last SEC_ALLOC section, since objcopy
         won't call this routine in that case.  */
      for (s = isec->next; s != NULL; s = s->next)
	if ((s->flags & SEC_ALLOC) != 0)
	  break;
      if (s == NULL)
	{
	  if (! copy_private_bfd_data (ibfd, obfd))
	    return false;
	}
d5211 5
a5215 2
  elf_section_data (osec)->use_rela_p
    = elf_section_data (isec)->use_rela_p;
d5217 3
a5219 1
  return true;
d5228 5
a5232 4
#define MAP_ONESYMTAB (SHN_LORESERVE - 1)
#define MAP_DYNSYMTAB (SHN_LORESERVE - 2)
#define MAP_STRTAB (SHN_LORESERVE - 3)
#define MAP_SHSTRTAB (SHN_LORESERVE - 4)
d5234 1
a5234 1
boolean
d5245 1
a5245 1
    return true;
d5265 2
d5270 1
a5270 1
  return true;
d5275 1
a5275 1
static boolean
d5281 11
a5291 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5294 1
a5294 1
    return false;
d5297 15
a5311 28
  {
    int symcount = bfd_get_symcount (abfd);
    asymbol **syms = bfd_get_outsymbols (abfd);
    struct bfd_strtab_hash *stt;
    Elf_Internal_Shdr *symtab_hdr;
    Elf_Internal_Shdr *symstrtab_hdr;
    char *outbound_syms;
    int idx;

    stt = _bfd_elf_stringtab_init ();
    if (stt == NULL)
      return false;

    symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
    symtab_hdr->sh_type = SHT_SYMTAB;
    symtab_hdr->sh_entsize = bed->s->sizeof_sym;
    symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
    symtab_hdr->sh_info = elf_num_locals (abfd) + 1;
    symtab_hdr->sh_addralign = bed->s->file_align;

    symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
    symstrtab_hdr->sh_type = SHT_STRTAB;

    outbound_syms = bfd_alloc (abfd,
			       (1 + symcount) * bed->s->sizeof_sym);
    if (outbound_syms == NULL)
      return false;
    symtab_hdr->contents = (PTR) outbound_syms;
d5313 3
a5315 1
    /* now generate the data (for "contents") */
d5317 2
a5318 10
      /* Fill in zeroth symbol and swap it out.  */
      Elf_Internal_Sym sym;
      sym.st_name = 0;
      sym.st_value = 0;
      sym.st_size = 0;
      sym.st_info = 0;
      sym.st_other = 0;
      sym.st_shndx = SHN_UNDEF;
      bed->s->swap_symbol_out (abfd, &sym, (PTR) outbound_syms);
      outbound_syms += bed->s->sizeof_sym;
d5320 1
a5320 7
    for (idx = 0; idx < symcount; idx++)
      {
	Elf_Internal_Sym sym;
	bfd_vma value = syms[idx]->value;
	elf_symbol_type *type_ptr;
	flagword flags = syms[idx]->flags;
	int type;
d5322 11
a5332 13
	if ((flags & BSF_SECTION_SYM) != 0)
	  {
	    /* Section symbols have no name.  */
	    sym.st_name = 0;
	  }
	else
	  {
	    sym.st_name = (unsigned long) _bfd_stringtab_add (stt,
							      syms[idx]->name,
							      true, false);
	    if (sym.st_name == (unsigned long) -1)
	      return false;
	  }
d5334 6
a5339 1
	type_ptr = elf_symbol_from (abfd, syms[idx]);
d5341 15
a5355 19
	if ((flags & BSF_SECTION_SYM) == 0
	    && bfd_is_com_section (syms[idx]->section))
	  {
	    /* ELF common symbols put the alignment into the `value' field,
	       and the size into the `size' field.  This is backwards from
	       how BFD handles it, so reverse it here.  */
	    sym.st_size = value;
	    if (type_ptr == NULL
		|| type_ptr->internal_elf_sym.st_value == 0)
	      sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
	    else
	      sym.st_value = type_ptr->internal_elf_sym.st_value;
	    sym.st_shndx = _bfd_elf_section_from_bfd_section
	      (abfd, syms[idx]->section);
	  }
	else
	  {
	    asection *sec = syms[idx]->section;
	    int shndx;
d5357 8
a5364 40
	    if (sec->output_section)
	      {
		value += sec->output_offset;
		sec = sec->output_section;
	      }
	    /* Don't add in the section vma for relocatable output.  */
	    if (! relocatable_p)
	      value += sec->vma;
	    sym.st_value = value;
	    sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

	    if (bfd_is_abs_section (sec)
		&& type_ptr != NULL
		&& type_ptr->internal_elf_sym.st_shndx != 0)
	      {
		/* This symbol is in a real ELF section which we did
                   not create as a BFD section.  Undo the mapping done
                   by copy_private_symbol_data.  */
		shndx = type_ptr->internal_elf_sym.st_shndx;
		switch (shndx)
		  {
		  case MAP_ONESYMTAB:
		    shndx = elf_onesymtab (abfd);
		    break;
		  case MAP_DYNSYMTAB:
		    shndx = elf_dynsymtab (abfd);
		    break;
		  case MAP_STRTAB:
		    shndx = elf_tdata (abfd)->strtab_section;
		    break;
		  case MAP_SHSTRTAB:
		    shndx = elf_tdata (abfd)->shstrtab_section;
		    break;
		  default:
		    break;
		  }
	      }
	    else
	      {
		shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d5366 16
a5381 3
		if (shndx == -1)
		  {
		    asection *sec2;
d5383 1
a5383 13
		    /* Writing this would be a hell of a lot easier if
		       we had some decent documentation on bfd, and
		       knew what to expect of the library, and what to
		       demand of applications.  For example, it
		       appears that `objcopy' might not set the
		       section of a symbol to be a section that is
		       actually in the output file.  */
		    sec2 = bfd_get_section_by_name (abfd, sec->name);
		    BFD_ASSERT (sec2 != 0);
		    shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
		    BFD_ASSERT (shndx != -1);
		  }
	      }
d5385 19
a5403 2
	    sym.st_shndx = shndx;
	  }
d5405 5
a5409 6
	if ((flags & BSF_FUNCTION) != 0)
	  type = STT_FUNC;
	else if ((flags & BSF_OBJECT) != 0)
	  type = STT_OBJECT;
	else
	  type = STT_NOTYPE;
d5411 38
a5448 19
        /* Processor-specific types */
        if (type_ptr != NULL
	    && bed->elf_backend_get_symbol_type)
          type = (*bed->elf_backend_get_symbol_type) (&type_ptr->internal_elf_sym, type);

	if (flags & BSF_SECTION_SYM)
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	else if (bfd_is_com_section (syms[idx]->section))
	  sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
	else if (bfd_is_und_section (syms[idx]->section))
	  sym.st_info = ELF_ST_INFO (((flags & BSF_WEAK)
				      ? STB_WEAK
				      : STB_GLOBAL),
				     type);
	else if (flags & BSF_FILE)
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
	else
	  {
	    int bind = STB_LOCAL;
d5450 3
a5452 6
	    if (flags & BSF_LOCAL)
	      bind = STB_LOCAL;
	    else if (flags & BSF_WEAK)
	      bind = STB_WEAK;
	    else if (flags & BSF_GLOBAL)
	      bind = STB_GLOBAL;
d5454 74
a5527 2
	    sym.st_info = ELF_ST_INFO (bind, type);
	  }
d5529 4
a5532 4
	if (type_ptr != NULL)
	  sym.st_other = type_ptr->internal_elf_sym.st_other;
	else
	  sym.st_other = 0;
d5534 5
a5538 3
	bed->s->swap_symbol_out (abfd, &sym, (PTR) outbound_syms);
	outbound_syms += bed->s->sizeof_sym;
      }
d5540 10
a5549 11
    *sttp = stt;
    symstrtab_hdr->sh_size = _bfd_stringtab_size (stt);
    symstrtab_hdr->sh_type = SHT_STRTAB;

    symstrtab_hdr->sh_flags = 0;
    symstrtab_hdr->sh_addr = 0;
    symstrtab_hdr->sh_entsize = 0;
    symstrtab_hdr->sh_link = 0;
    symstrtab_hdr->sh_info = 0;
    symstrtab_hdr->sh_addralign = 1;
  }
d5551 1
a5551 1
  return true;
d5617 1
d5619 1
a5619 4
  if (! get_elf_backend_data (abfd)->s->slurp_reloc_table (abfd,
							   section,
							   symbols,
							   false))
d5636 2
a5637 2
  long symcount = get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, false);
d5649 6
a5654 2
  return get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, true);
d5701 2
a5702 1
  boolean (*slurp_relocs) PARAMS ((bfd *, asection *, asymbol **, boolean));
d5723 1
a5723 1
	  if (! (*slurp_relocs) (abfd, s, syms, true))
d5740 1
a5740 1
boolean
d5745 1
d5763 1
a5763 1
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
d5782 2
a5783 3
      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, maxidx * sizeof (Elf_Internal_Verdef)));
d5804 2
a5805 4
	  iverdef->vd_auxptr = ((Elf_Internal_Verdaux *)
				bfd_alloc (abfd,
					   (iverdef->vd_cnt
					    * sizeof (Elf_Internal_Verdaux))));
d5855 1
d5857 1
a5857 2
	((Elf_Internal_Verneed *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verneed)));
d5867 1
a5867 1
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
d5888 3
a5890 4
	  iverneed->vn_auxptr =
	    ((Elf_Internal_Vernaux *)
	     bfd_alloc (abfd,
			iverneed->vn_cnt * sizeof (Elf_Internal_Vernaux)));
d5927 1
a5927 1
  return true;
d5930 1
a5930 1
  if (contents == NULL)
d5932 1
a5932 1
  return false;
d5940 1
d5942 1
a5942 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, sizeof (elf_symbol_type));
d5965 1
a5965 1
boolean
d5972 1
a5972 1
    return true;
d5977 1
a5977 1
    return true;
d5986 1
a5986 1
    return true;
d5988 1
a5988 1
  return false;
d6000 1
a6000 1
boolean
d6011 1
a6011 1
    return false;
d6019 1
a6019 1
static boolean
d6068 1
a6068 1
    return false;
d6075 1
a6075 1
  return true;
d6081 1
a6081 1
boolean
d6092 1
a6092 1
  boolean found;
d6103 1
a6103 1
      return true;
d6116 1
a6116 1
      return true;
d6123 3
a6125 3
    return false;
  if (found)
    return true;
d6128 1
a6128 1
    return false;
d6132 1
a6132 1
    return false;
d6135 1
a6135 1
  return true;
d6141 1
a6141 1
     boolean reloc;
d6151 1
a6151 1
boolean
d6160 1
d6163 3
a6165 3
      && ! _bfd_elf_compute_section_file_positions
      (abfd, (struct bfd_link_info *) NULL))
    return false;
d6168 4
d6173 1
a6173 6
  if (bfd_seek (abfd, hdr->sh_offset + offset, SEEK_SET) == -1)
    return false;
  if (bfd_write (location, 1, count, abfd) != count)
    return false;

  return true;
a6184 11
#if 0
void
_bfd_elf_no_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rel *dst;
{
  abort ();
}
#endif

d6187 1
a6187 1
boolean
d6273 1
a6273 1
  return true;
d6278 1
a6278 1
     bfd_get_filename (abfd), areloc->howto->name);
d6280 1
a6280 1
  return false;
d6283 1
a6283 1
boolean
d6290 1
a6290 1
	_bfd_stringtab_free (elf_shstrtab (abfd));
a6322 6
/* Define offsetof for those systems which lack it.  */

#ifndef offsetof
# define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

d6338 1
a6338 1
static boolean
d6347 1
a6347 1
    return true;
d6351 1
a6351 1
    return false;
d6357 40
a6396 1
  return true;
d6406 4
a6409 1
static boolean
d6414 1
a6414 4
  char buf[100];
  char *name;
  asection *sect;
  int raw_size;
d6425 4
a6428 1
      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
d6451 4
a6454 1
      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
d6472 1
a6472 1
      return true;
d6475 3
a6477 22
  /* Make a ".reg/999" section.  */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return false;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return false;

  sect->_raw_size = raw_size;
  sect->filepos = note->descpos + offset;

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
    return false;

  return true;
d6481 2
a6482 9
/* Create a pseudosection containing the exact contents of NOTE.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents: the contents of NOTE.  */

static boolean
d6488 2
a6489 24
  char buf[100];
  char *threaded_name;
  asection *sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  threaded_name = bfd_alloc (abfd, strlen (buf) + 1);
  if (threaded_name == NULL)
    return false;
  strcpy (threaded_name, buf);

  sect = bfd_make_section (abfd, threaded_name);
  if (sect == NULL)
    return false;
  sect->_raw_size = note->descsz;
  sect->filepos = note->descpos;
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, name, sect))
    return false;

  return true;
d6496 1
a6496 1
static boolean
d6508 1
a6508 1
static boolean
a6529 2
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)

d6534 2
a6535 2
static char*
elfcore_strndup (abfd, start, max)
d6538 1
a6538 1
     int max;
d6540 1
a6540 1
  char *dup;
d6542 1
a6542 1
  int len;
d6549 2
a6550 2
  dup = bfd_alloc (abfd, len + 1);
  if (dup == NULL)
d6553 2
a6554 2
  memcpy (dup, start, len);
  dup[len] = '\0';
d6556 1
a6556 1
  return dup;
d6559 5
a6563 1
static boolean
d6575 2
a6576 1
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d6579 2
a6580 1
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d6591 2
a6592 1
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d6595 2
a6596 1
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d6604 1
a6604 1
      return true;
d6619 1
a6619 1
  return true;
d6624 4
a6627 1
static boolean
d6659 1
a6659 1
  return true;
d6664 4
a6667 1
static boolean
d6675 1
d6683 1
a6683 1
    return true;
d6693 2
a6694 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d6696 2
a6697 2
    return false;
  strcpy (name, buf);
d6701 1
a6701 1
    return false;
d6718 1
a6718 1
    return false;
d6723 2
a6724 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d6726 2
a6727 2
    return false;
  strcpy (name, buf);
d6731 1
a6731 1
    return false;
d6747 1
a6747 4
  if (!elfcore_maybe_make_sect (abfd, ".reg2", sect))
    return false;

  return true;
d6752 1
a6752 1
static boolean
d6759 1
d6764 1
a6764 1
    return true;
d6766 1
a6766 1
  memcpy (&pstatus, note->descdata, note->descsz);
d6780 2
a6781 1
      name = bfd_alloc (abfd, strlen (buf) + 1);
d6783 1
a6783 1
	return false;
d6785 1
a6785 1
      strcpy (name, buf);
d6789 1
a6789 1
	return false;
d6792 3
a6794 2
      sect->filepos = note->descpos + offsetof (struct win32_pstatus,
						data.thread_info.thread_context);
d6800 1
a6800 1
	  return false;
d6807 2
a6808 1
      name = bfd_alloc (abfd, strlen (buf) + 1);
d6810 1
a6810 1
	return false;
d6812 1
a6812 1
      strcpy (name, buf);
d6817 1
a6817 1
	return false;
d6826 1
a6826 1
      return true;
d6829 1
a6829 1
  return true;
d6833 1
a6833 1
static boolean
d6838 2
d6843 1
a6843 1
      return true;
d6845 4
a6849 1
    case NT_PRSTATUS:
d6851 2
d6874 2
a6875 2
      if (note->namesz == 5
	  && ! strcmp (note->namedata, "LINUX"))
d6878 1
a6878 1
	return true;
a6879 1
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
d6882 4
d6887 2
d6893 395
a7287 1
static boolean
d7290 2
a7291 2
     bfd_vma offset;
     bfd_vma size;
d7297 1
a7297 1
    return true;
d7299 2
a7300 2
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
    return false;
d7302 1
a7302 1
  buf = bfd_malloc ((size_t) size);
d7304 1
a7304 1
    return false;
d7306 1
a7306 1
  if (bfd_read (buf, size, 1, abfd) != size)
d7310 1
a7310 1
      return false;
d7320 1
a7320 1
      in.type = bfd_h_get_32 (abfd, (bfd_byte *) xnp->type);
d7322 1
a7322 1
      in.namesz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->namesz);
d7325 1
a7325 1
      in.descsz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->descsz);
d7329 15
a7343 2
      if (! elfcore_grok_note (abfd, &in))
	goto error;
d7349 1
a7349 16
  return true;
}

/* FIXME: This function is now unnecessary.  Callers can just call
   bfd_section_from_phdr directly.  */

boolean
_bfd_elfcore_section_from_phdr (abfd, phdr, sec_num)
     bfd *abfd;
     Elf_Internal_Phdr* phdr;
     int sec_num;
{
  if (! bfd_section_from_phdr (abfd, phdr, sec_num))
    return false;

  return true;
d7368 1
a7368 2
  return (elf_elfheader (abfd)->e_phnum
	  * sizeof (Elf_Internal_Phdr));
d7397 143
@


1.15
log
@ELF security enhancement: put .rodata into it's own load section instead
of putting it with the text. This removes the execute permission
from readonly data. This constrains the executable region to portions
of the executable which need to be executable. Note: not all processors
or mmus are capable of -X protection at the page level, but should
handle ELF images which specify specific RWX protections on each section.
@
text
@d3103 3
a3105 3
     longer true. Now there can be several PT_LOAD sections. 6 seems
     to be enough with BSS_PLT, where we have text, data, GOT, dynamic,
     PLT, bss */
@


1.14
log
@Update comment for linker change which just committed.
@
text
@d3106 1
a3106 1
  segs = 6;
@


1.13
log
@This is a project to modify executables so that they do not have any
executable regions which are writable. If a section of an executable is
writable and executable, it is much easier for errant code to modify the
executable's behavior.

Two current areas in shared library environments which have this
critical problem are the GOT (Global Offset Table) and PLT (Procedure
Linkage Table). The PLT is required to be executable and both GOT and
PLT are writable on most architectures. On most ELF architecture
machines this would cause shared libraries to have data and BSS marked
as executable.

Padding to the linker script for programs and shared libraries/objects
to isolate the GOT and PLT into their own load sections in the
executables. This allows only the text(readonly) region and the PLT
region to be marked executable with the normal data and BSS not marked
as executable. The PLT region is still marked executable on most
architectures because the PLT lives in the "data" or "BSS" regions
and the dynamic loader will need to modify it. Since the GOT and PLT
should only ever be written by the dynamic linker, it will be modified
to mprotect those regions so that they are not writable during normal
execution. If the dynamic linker needs to modify the regions later,
(eg for lazy binding), it will mprotect the region, make the necessary
changes, and mprotect it back. Since it is possible to receive a
signal which would interrupt the program flow and perhaps cause the
dynamic linker to modify the same (or nearby) PLT references, it is now
necessary for signals to be blocked for the duration of the mprotect.
@
text
@d3101 5
a3105 2
  /* Assume we will need exactly two PT_LOAD segments: one for text
     and one for data.  */
@


1.12
log
@resolve conflicts.
@
text
@d3103 1
a3103 1
  segs = 2;
@


1.11
log
@Leave space for terminating NULL if empty symbol table. from bfd-current
via pr 2447; deraadt@@ ok.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d35 2
d60 4
d237 1
a237 1
   buffer. */
d241 1
a241 1
     bfd * abfd;
d262 1
a262 1
     bfd * abfd;
d264 2
a265 2
  /* this just does initialization */
  /* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
d270 2
a271 2
  /* since everything is done at close time, do we need any
     initialization? */
d278 1
a278 1
     bfd * abfd;
d280 1
a280 1
  /* I think this can be done just like an object file. */
d286 1
a286 1
     bfd * abfd;
d301 1
a301 1
      /* No cached one, attempt to read, and cache what we read. */
d312 1
a312 1
     bfd * abfd;
d353 1
d392 17
a408 4
  if (strncmp (name, ".debug", sizeof ".debug" - 1) == 0
      || strncmp (name, ".line", sizeof ".line" - 1) == 0
      || strncmp (name, ".stab", sizeof ".stab" - 1) == 0)
    flags |= SEC_DEBUGGING;
d419 5
d486 1
a486 1
     bfd * abfd;
a525 1
/*ARGSUSED*/
d681 26
a706 2
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
d712 3
d813 2
a814 2
	CONST char *section_name;
	CONST char *name = NULL;
d817 1
a817 1
	
d822 1
a822 1
	    name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);
d826 1
a826 1
	    name = symbol->name;  
d893 1
a893 1
	
d1005 2
a1006 1
_bfd_elf_link_hash_hide_symbol(h)
a1009 1
  h->dynindx = -1;
d1011 2
d1032 1
d1076 10
d1099 13
d1236 1
a1236 1
/* Create a new bfd section from an ELF section header. */
d1409 4
a1412 2
	   try.  We just present it as a normal section.  */
	if (hdr->sh_link != elf_onesymtab (abfd))
d1432 1
a1432 1
	target_sect->reloc_count += hdr->sh_size / hdr->sh_entsize;
d1506 1
a1506 1
  sdata->use_rela_p 
d1569 1
a1569 1
	     may be data. */
d1641 1
a1641 1
         If no handler for them, default to making "segment" sections. */
a1688 1
/*ARGSUSED*/
d1802 1
a1802 4
	   && (asect->flags & SEC_LOAD) != 0)
    this_hdr->sh_type = SHT_PROGBITS;
  else if ((asect->flags & SEC_ALLOC) != 0
	   && ((asect->flags & SEC_LOAD) == 0))
d1805 1
a1805 4
    {
      /* Who knows?  */
      this_hdr->sh_type = SHT_PROGBITS;
    }
d1821 1
a1821 1
     create the other.  */ 
d1823 1
a1823 1
      && !_bfd_elf_init_reloc_shdr (abfd, 
d1825 1
a1825 1
				    asect, 
a1841 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1976 1
a1976 1
		    4 + 2 * (bed->s->arch_size / 8);
d2065 1
a2065 1
      
d2079 1
a2079 1
		  
d2978 4
a2981 2
	      if (i == 0)	/* the actual "note" segment */
		{		/* this one actually contains everything. */
d2987 1
a2987 1
	      else	/* fake sections -- don't need to be written */
d2989 1
d2992 1
a2992 1
		  flags = sec->flags = 0;	/* no contents */
d3306 1
a3306 1
      if (bed->s->arch_size == 64)
d3315 13
a3327 1
      i_ehdrp->e_machine = EM_386;
d3378 1
a3378 1
   case bfd_arch_arc:
d3381 1
a3381 1
   case bfd_arch_arm:
d3396 4
a3399 1
      /* also note that EM_M32, AT&T WE32100 is unknown to bfd */
d3406 1
a3406 1
  /* no program header, for now. */
d3411 1
a3411 1
  /* each bfd section is section header entry */
d3415 1
a3415 1
  /* if we're building an executable, we'll need a program header table */
d3418 1
a3418 1
      /* it all happens later */
d3423 1
a3423 1
	 Elf_Internal_Phdrs */
d3503 1
a3503 1
  /* After writing the headers, we need to write the sections too... */
d3534 1
a3534 1
  /* Hopefully this can be done just like an object file. */
d3537 3
a3539 1
/* given a section, search the header to find them... */
d3648 12
a3659 8
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;
  unsigned int i;
  unsigned int num_segments;
  boolean phdr_included = false;
d3670 2
a3671 2
  mfirst = NULL;
  pm = &mfirst;
d3674 1
d3676 26
a3701 13
#define IS_CONTAINED_BY(addr, len, bottom, phdr)		 	\
	  ((addr) >= (bottom)				 	  	\
	   && (   ((addr) + (len)) <= ((bottom) + (phdr)->p_memsz)	\
	       || ((addr) + (len)) <= ((bottom) + (phdr)->p_filesz)))

  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc. */

#define IS_COREFILE_NOTE(p, s)                                          \
	    (p->p_type == PT_NOTE                                       \
	     && bfd_get_format (ibfd) == bfd_core                       \
	     && s->vma == 0 && s->lma == 0                              \
	     && (bfd_vma) s->filepos >= p->p_offset                     \
	     && (bfd_vma) s->filepos + s->_raw_size                     \
d3707 8
d3716 25
a3740 8
#define IS_SOLARIS_PT_INTERP(p, s)					\
	    (p->p_vaddr == 0						\
	     && p->p_filesz > 0						\
	     && (s->flags & SEC_HAS_CONTENTS) != 0			\
	     && s->_raw_size > 0					\
	     && (bfd_vma) s->filepos >= p->p_offset			\
	     && ((bfd_vma) s->filepos + s->_raw_size			\
		     <= p->p_offset + p->p_filesz))
d3743 6
a3748 2
     of the input BFD.  */
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < num_segments; i++, p++)
a3749 7
      unsigned int csecs;
      asection *s;
      asection **sections;
      asection *os;
      unsigned int isec;
      bfd_vma matching_lma;
      bfd_vma suggested_lma;
d3751 4
d3756 71
a3826 16
      /* For each section in the input BFD, decide if it should be
	 included in the current segment.  A section will be included
	 if it is within the address space of the segment, and it is
	 an allocated segment, and there is an output section
	 associated with it.  */
      csecs = 0;
      for (s = ibfd->sections; s != NULL; s = s->next)
	if (s->output_section != NULL)
	  {
	    if ((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	      ++csecs;
	    else if (IS_COREFILE_NOTE (p, s))
	      ++csecs;
	  }
d3830 1
a3830 1
      m = ((struct elf_segment_map *)
d3833 2
a3834 2
		       + ((size_t) csecs - 1) * sizeof (asection *))));
      if (m == NULL)
d3839 6
a3844 6
      m->next          = NULL;
      m->p_type        = p->p_type;
      m->p_flags       = p->p_flags;
      m->p_flags_valid = 1;
      m->p_paddr       = p->p_paddr;
      m->p_paddr_valid = 1;
d3848 2
a3849 2
      m->includes_filehdr = (p->p_offset == 0
			     && p->p_filesz >= iehdr->e_ehsize);
d3851 1
a3851 1
      m->includes_phdrs = 0;
d3853 1
a3853 1
      if (! phdr_included || p->p_type != PT_LOAD)
d3855 3
a3857 3
	  m->includes_phdrs =
	    (p->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (p->p_offset + p->p_filesz
d3860 2
a3861 1
	  if (p->p_type == PT_LOAD && m->includes_phdrs)
d3865 1
a3865 1
      if (csecs == 0)
d3870 1
a3870 2

	  if (p->p_type == PT_LOAD)
d3875 3
a3877 3
	  m->count = 0;
	  *pm = m;
	  pm = &m->next;
d3910 2
a3911 1
      sections = (asection **) bfd_malloc (sizeof (asection *) * csecs);
a3920 1

d3925 3
a3927 1
      for (j = 0, s = ibfd->sections; s != NULL; s = s->next)
d3929 3
a3931 1
	  os = s->output_section;
d3933 1
a3933 7
	  if ((((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	       || IS_COREFILE_NOTE (p, s))
	      && os != NULL)
	    {
	      sections[j++] = s;
d3938 2
a3939 2
	      if (p->p_paddr == 0
		  && p->p_vaddr != 0
d3941 9
a3949 9
		  && os->lma != 0
		  && (os->vma == (p->p_vaddr
				  + (m->includes_filehdr
				     ? iehdr->e_ehsize
				     : 0)
				  + (m->includes_phdrs
				     ? iehdr->e_phnum * iehdr->e_phentsize
				     : 0))))
		m->p_paddr = p->p_vaddr;
d3953 2
a3954 2
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
d3957 1
a3957 1
		    matching_lma = os->lma;
d3960 1
a3960 1
		     that it does not overlap any other section within that
d3962 1
a3962 1
		  m->sections[isec++] = os;
d3965 1
a3965 1
		suggested_lma = os->lma;
d3969 1
a3969 1
      BFD_ASSERT (j == csecs);
d3973 1
a3973 1
      if (isec == csecs)
d3979 3
a3981 3
	  m->count = csecs;
	  *pm = m;
	  pm = &m->next;
d3993 1
a3993 2

	      m->p_paddr = matching_lma;
d4000 2
d4003 4
a4006 2
	      m->p_paddr = suggested_lma;
	    }
d4008 3
a4010 4
	  /* Offset the segment physical address from the lma to allow
	     for space taken up by elf headers.  */
	  if (m->includes_filehdr)
	    m->p_paddr -= iehdr->e_ehsize;
d4012 8
a4019 2
	  if (m->includes_phdrs)
	    m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
d4032 1
a4032 1
	  m->count = 0;
d4036 1
a4036 1
	  for (j = 0; j < csecs; j++)
d4038 1
a4038 1
	      s = sections[j];
d4040 1
a4040 1
	      if (s == NULL)
d4043 1
a4043 1
	      os = s->output_section;
d4045 4
a4048 2
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
d4050 1
a4050 1
		  if (m->count == 0)
d4053 8
a4060 7
			 the beginning of the segment, then something is wrong.  */
		      if (os->lma != (m->p_paddr
				      + (m->includes_filehdr
					 ? iehdr->e_ehsize : 0)
				      + (m->includes_phdrs
					 ? iehdr->e_phnum * iehdr->e_phentsize
					 : 0)))
a4065 1
		      bfd_vma maxpagesize;
d4067 1
a4067 2
		      prev_sec = m->sections[m->count - 1];
		      maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
d4070 5
a4074 4
			 and the start of this section is more than maxpagesize
			 then we need to start a new segment.  */
		      if (BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
			  < BFD_ALIGN (os->lma, maxpagesize))
d4077 1
a4077 1
			    suggested_lma = os->lma;
d4083 1
a4083 1
		  m->sections[m->count++] = os;
d4086 1
d4089 1
a4089 1
		suggested_lma = os->lma;
d4092 1
a4092 1
	  BFD_ASSERT (m->count > 0);
d4095 2
a4096 2
	  *pm = m;
	  pm = &m->next;
d4098 1
a4098 1
	  if (isec < csecs)
d4103 6
a4108 6

	      m = ((struct elf_segment_map *)
		   bfd_alloc (obfd,
			      (sizeof (struct elf_segment_map)
			       + ((size_t) csecs - 1) * sizeof (asection *))));
	      if (m == NULL)
d4114 8
a4121 9

	      m->next             = NULL;
	      m->p_type           = p->p_type;
	      m->p_flags          = p->p_flags;
	      m->p_flags_valid    = 1;
	      m->p_paddr          = suggested_lma;
	      m->p_paddr_valid    = 1;
	      m->includes_filehdr = 0;
	      m->includes_phdrs   = 0;
d4124 1
a4124 1
      while (isec < csecs);
d4133 2
a4134 2
  for (m = mfirst; m != NULL; m = m->next)
    if (m->p_paddr != 0)
d4136 1
a4136 1
  if (m == NULL)
d4138 2
a4139 2
      for (m = mfirst; m != NULL; m = m->next)
	m->p_paddr_valid = 0;
d4142 16
a4157 1
  elf_tdata (obfd)->segment_map = mfirst;
d4160 3
a4162 2
  /* Final Step: Sort the segments into ascending order of physical address. */
  if (mfirst != NULL)
d4164 1
a4164 1
      struct elf_segment_map* prev;
d4166 2
a4167 2
      prev = mfirst;
      for (m = mfirst->next; m != NULL; prev = m, m = m->next)
d4169 2
a4170 2
	  /* Yes I know - its a bubble sort....*/
	  if (m->next != NULL && (m->next->p_paddr < m->p_paddr))
d4172 4
a4175 4
	      /* swap m and m->next */
	      prev->next = m->next;
	      m->next = m->next->next;
	      prev->next->next = m;
d4177 2
a4178 2
	      /* restart loop. */
	      m = mfirst;
d4184 4
a4187 1
#undef IS_CONTAINED_BY
d4189 3
a4191 1
#undef IS_COREFILE_NOTE
d4313 1
a4313 1
  /* Dump out the symtabs. */
d4364 5
a4368 3
	if (flags & BSF_SECTION_SYM)
	  /* Section symbols have no names.  */
	  sym.st_name = 0;
d4740 2
a4741 2
	  if ((iverdefmem.vd_ndx & VERSYM_VERSION) > maxidx)
	    maxidx = iverdefmem.vd_ndx & VERSYM_VERSION;
d4984 2
a4985 2
/* Find the nearest line to a particular section and offset, for error
   reporting.  */
d4987 4
a4990 9
boolean
_bfd_elf_find_nearest_line (abfd,
			    section,
			    symbols,
			    offset,
			    filename_ptr,
			    functionname_ptr,
			    line_ptr)
     bfd *abfd;
d4994 2
a4995 3
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
     unsigned int *line_ptr;
a4996 1
  boolean found;
a5001 21
  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr, 
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0))
    return true;

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return false;
  if (found)
    return true;

  if (symbols == NULL)
    return false;

d5038 64
a5101 2
  *filename_ptr = filename;
  *functionname_ptr = bfd_asymbol_name (func);
d5171 1
a5171 1
  /* Check whether we really have an ELF howto. */
d5179 1
a5179 1
	 equivalent ELF reloc. */
a5291 1

d5296 1
a5296 1
   out details about the corefile. */
d5302 1
a5302 2

/* Define offsetof for those systems which lack it. */
d5308 1
a5308 2

/* FIXME: this is kinda wrong, but it's what gdb wants. */
d5312 1
a5312 1
     bfd* abfd;
a5317 1

d5321 1
a5321 1
   overwrite it. */
d5325 3
a5327 3
     bfd* abfd;
     char* name;
     asection* sect;
d5329 1
a5329 1
  asection* sect2;
a5344 1

d5346 1
a5346 1
     solaris 2.[567]
d5354 2
a5355 2
     bfd* abfd;
     Elf_Internal_Note* note;
a5356 1
  prstatus_t prstat;
d5358 22
a5379 17
  char* name;
  asection* sect;

  if (note->descsz != sizeof (prstat))
    return true;

  memcpy (&prstat, note->descdata, sizeof (prstat));

  elf_tdata (abfd)->core_signal = prstat.pr_cursig;
  elf_tdata (abfd)->core_pid = prstat.pr_pid;

  /* pr_who exists on:
       solaris 2.[567]
       unixware 4.2
     pr_who doesn't exist on:
       linux 2.[01]
  */
d5381 1
a5381 1
  elf_tdata (abfd)->core_lwpid = prstat.pr_who;
d5383 6
d5390 26
a5415 1
  /* Make a ".reg/999" section. */
d5426 4
a5429 2
  sect->_raw_size = sizeof (prstat.pr_reg);
  sect->filepos = note->descpos + offsetof (prstatus_t, pr_reg);
a5439 1

d5450 1
a5450 1
     bfd* abfd;
d5452 1
a5452 1
     Elf_Internal_Note* note;
d5456 1
a5456 1
  asection* sect;
a5479 1

d5482 2
a5483 1
   data structure apart. */
d5486 2
a5487 2
     bfd* abfd;
     Elf_Internal_Note* note;
a5491 1

d5495 1
d5498 2
a5499 2
     bfd* abfd;
     Elf_Internal_Note* note;
a5503 1

d5505 4
a5508 1
# define elfcore_psinfo_t prpsinfo_t
d5512 4
a5515 1
# define elfcore_psinfo_t psinfo_t
a5517 1

d5522 1
a5522 1
   the copy will always have a terminating '\0'. */
d5526 2
a5527 2
     bfd* abfd;
     char* start;
d5530 2
a5531 2
  char* dup;
  char* end = memchr (start, '\0', max);
d5551 2
a5552 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5554 17
a5570 1
  elfcore_psinfo_t psinfo;
d5572 1
a5572 2
  if (note->descsz != sizeof (elfcore_psinfo_t))
    return true;
d5574 2
a5575 1
  memcpy (&psinfo, note->descdata, note->descsz);
d5577 4
a5580 2
  elf_tdata (abfd)->core_program
    = elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5582 6
a5587 2
  elf_tdata (abfd)->core_command
    = elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5591 1
a5591 1
     implementations, so strip it off if it exists. */
d5594 1
a5594 1
    char* command = elf_tdata (abfd)->core_command;
a5604 1

d5608 2
a5609 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5611 7
a5617 1
  pstatus_t pstat;
d5619 1
a5619 2
  if (note->descsz != sizeof (pstat))
    return true;
d5621 7
a5627 1
  memcpy (&pstat, note->descdata, sizeof (pstat));
d5629 1
a5629 1
  elf_tdata (abfd)->core_pid = pstat.pr_pid;
d5631 3
d5636 1
a5636 1
     NT_LWPSTATUS note, presumably. */
a5641 1

d5645 2
a5646 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5650 2
a5651 2
  char* name;
  asection* sect;
d5653 5
a5657 1
  if (note->descsz != sizeof (lwpstat))
d5665 1
a5665 1
  /* Make a ".reg/999" section. */
d5730 2
a5731 2
     bfd * abfd;
     Elf_Internal_Note * note;
d5734 2
a5735 2
  char * name;
  asection * sect;
d5741 3
a5743 3
  memcpy (& pstatus, note->descdata, note->descsz);
  
  switch (pstatus.data_type) 
d5749 1
a5749 1
      break ;
d5754 1
a5754 1
      
d5757 2
a5758 2
        return false;
      
d5763 2
a5764 2
        return false;
      
d5778 2
a5779 2
      sprintf (buf, ".module/%08x" , pstatus.data.module_info.base_address);
      
d5783 1
a5783 1
      
d5787 1
a5787 1
      
d5790 1
a5790 1
      
d5807 2
a5808 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5834 1
a5834 1
    case NT_WIN32PSTATUS:	
d5838 1
a5838 1
  case NT_PRXFPREG:		/* Linux SSE extension */
a5852 1

d5855 1
a5855 1
     bfd* abfd;
d5859 2
a5860 2
  char* buf;
  char* p;
d5882 2
a5883 2
      /* FIXME: bad alignment assumption. */
      Elf_External_Note* xnp = (Elf_External_Note*) p;
a5904 1

d5910 1
a5910 1
     bfd* abfd;
a5918 2


d5925 1
a5939 1

d5947 1
d5962 1
a5962 1
  memcpy (phdrs, elf_tdata (abfd)->phdr, 
@


1.10
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d4316 3
a4318 1
  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
d4338 3
a4340 1
  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
@


1.9
log
@Help stupid cvs fixing basic conflicts.
@
text
@d4491 2
d4494 1
a4497 8
      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verdef)));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = hdr->sh_info;

d4505 24
d4530 2
a4531 2
      iverdef = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++, iverdef++)
d4537 4
a4540 1
	  _bfd_elf_swap_verdef_in (abfd, everdef, iverdef);
@


1.8
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d48 1
a48 1
static boolean swap_out_syms PARAMS ((bfd *, struct bfd_strtab_hash **));
d56 145
d203 2
a204 2
   cause invalid hash tables to be generated.  (Well, you would if this
   were being used yet.)  */
d206 2
a207 2
bfd_elf_hash (name)
     CONST unsigned char *name;
d209 1
d220 3
a222 1
	  h &= ~g;
d254 1
a254 1
elf_mkobject (abfd)
d269 8
d320 12
d406 3
a408 1
      /* Look through the phdrs to see if we need to adjust the lma.  */
d412 7
a418 9
	  if (phdr->p_type == PT_LOAD
	      && phdr->p_paddr != 0
	      && phdr->p_vaddr != phdr->p_paddr
	      && phdr->p_vaddr <= hdr->sh_addr
	      && phdr->p_vaddr + phdr->p_memsz >= hdr->sh_addr + hdr->sh_size
	      && ((flags & SEC_LOAD) == 0
		  || (phdr->p_offset <= hdr->sh_offset
		      && (phdr->p_offset + phdr->p_filesz
			  >= hdr->sh_offset + hdr->sh_size))))
d420 13
a432 2
	      newsect->lma += phdr->p_paddr - phdr->p_vaddr;
	      break;
d471 2
a472 1
      shstrtab = bfd_elf_get_str_section (abfd, elf_elfheader (abfd)->e_shstrndx);
d509 1
a509 1
     bfd *abfd;
d512 1
a512 1
     PTR data;
d515 1
a515 1
     char **error_message;
d546 1
a546 1
      fprintf (f, "\nProgram Header:\n");
d594 1
a594 1
      fprintf (f, "\nDynamic Section:\n");
d656 7
d685 46
d740 1
d742 2
a743 2
bfd_elf_print_symbol (ignore_abfd, filep, symbol, how)
     bfd *ignore_abfd;
d762 4
d767 11
a777 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
d787 68
a854 1
	fprintf (file, " %s", symbol->name);
d890 2
a891 2
      ret->got_offset = (bfd_vma) -1;
      ret->plt_offset = (bfd_vma) -1;
d893 4
d898 1
d909 52
d980 1
d1022 1
a1022 1
   the ELF emulation code.  */
d1026 1
a1026 1
     bfd *abfd;
d1047 85
d1283 9
a1336 1

d1356 5
d1366 18
d1420 1
a1420 1
  sdata = (struct bfd_elf_section_data *) bfd_alloc (abfd, sizeof (*sdata));
d1424 5
a1428 1
  memset (sdata, 0, sizeof (*sdata));
d1455 1
a1455 1
bfd_section_from_phdr (abfd, hdr, index)
d1459 1
d1466 4
a1469 4
  split = ((hdr->p_memsz > 0) &&
	   (hdr->p_filesz > 0) &&
	   (hdr->p_memsz > hdr->p_filesz));
  sprintf (namebuf, split ? "segment%da" : "segment%d", index);
d1500 1
a1500 1
      sprintf (namebuf, "segment%db", index);
d1524 83
d1662 1
a1662 1
      this_hdr->sh_entsize = bed->s->arch_size / 8;
d1675 1
a1675 1
	   && get_elf_backend_data (abfd)->use_rela_p)
d1681 1
a1681 1
	   && ! get_elf_backend_data (abfd)->use_rela_p)
d1686 1
a1686 1
  else if (strcmp (asect->name, ".note") == 0)
d1691 31
d1742 2
a1743 6
  {
    struct elf_backend_data *bed = get_elf_backend_data (abfd);

    if (bed->elf_backend_fake_sections)
      (*bed->elf_backend_fake_sections) (abfd, this_hdr, asect);
  }
d1746 10
a1755 6
     SHT_REL[A] section.  */
  if ((asect->flags & SEC_RELOC) != 0)
    {
      Elf_Internal_Shdr *rela_hdr;
      int use_rela_p = get_elf_backend_data (abfd)->use_rela_p;
      char *name;
d1757 1
a1757 29
      rela_hdr = &elf_section_data (asect)->rel_hdr;
      name = bfd_alloc (abfd, sizeof ".rela" + strlen (asect->name));
      if (name == NULL)
	{
	  *failedptr = true;
	  return;
	}
      sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", asect->name);
      rela_hdr->sh_name =
	(unsigned int) _bfd_stringtab_add (elf_shstrtab (abfd), name,
					   true, false);
      if (rela_hdr->sh_name == (unsigned int) -1)
	{
	  *failedptr = true;
	  return;
	}
      rela_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
      rela_hdr->sh_entsize = (use_rela_p
			      ? bed->s->sizeof_rela
			      : bed->s->sizeof_rel);
      rela_hdr->sh_addralign = bed->s->file_align;
      rela_hdr->sh_flags = 0;
      rela_hdr->sh_addr = 0;
      rela_hdr->sh_size = 0;
      rela_hdr->sh_offset = 0;
    }
}

/* Assign all ELF section numbers.  The dummy first section is handled here
d1782 5
d1793 1
a1793 1
  if (abfd->symcount > 0)
d1820 1
a1820 1
  if (abfd->symcount > 0)
d1835 2
d1848 5
d1911 2
d1914 2
a1915 1
	     used for the dynamic entries or symbol table.  */
d1922 1
d1924 1
a1924 1
	     this hash table is for.  */
d1969 1
d1992 4
a1995 2
      if ((syms[idx]->flags & BSF_SECTION_SYM) != 0
	  && (syms[idx]->value + syms[idx]->section->vma) == 0)
d1999 2
a2000 1
	  sec = syms[idx]->section;
d2007 1
d2009 13
a2030 2
      asymbol *sym;

d2047 1
a2047 1
	       "creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n",
d2179 4
d2192 1
a2192 1
  if (link_info == NULL && abfd->symcount > 0)
d2194 4
a2197 1
      if (! swap_out_syms (abfd, &strtab))
d2216 1
a2216 1
  if (link_info == NULL && abfd->symcount > 0)
d2297 1
a2297 1
  boolean phdr_in_section = true;
d2390 1
d2392 1
a2392 1
	phdr_in_section = false;
d2419 1
a2419 1
	       < hdr->lma)
d2425 7
a2438 7
      else if ((last_hdr->flags & SEC_LOAD) == 0
	       && (hdr->flags & SEC_LOAD) != 0)
	{
	  /* We don't want to put a loadable section after a
             nonloadable section in the same segment.  */
	  new_segment = true;
	}
d2470 1
a2470 1
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_section);
d2484 1
a2484 1
      phdr_in_section = false;
d2490 1
a2490 1
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_section);
d2514 24
d2550 1
a2550 1
/* Sort sections by VMA.  */
d2560 3
a2562 1
  if (sec1->vma < sec2->vma)
d2564 1
a2564 1
  else if (sec1->vma > sec2->vma)
d2567 3
a2569 3
  /* Sort by LMA.  Normally the LMA and the VMA will be the same, and
     this will do nothing.  */
  if (sec1->lma < sec2->lma)
d2571 1
a2571 1
  else if (sec1->lma > sec2->lma)
d2579 6
a2584 4
    if (TOEND (sec2))
      return sec1->target_index - sec2->target_index;
    else 
      return 1;
d2650 1
a2650 1
       ("%s: Not enough room for program headers (allocated %u, need %u)",
d2671 1
d2686 1
a2686 5

      if (m->p_flags_valid)
	p->p_flags = m->p_flags;
      else
	p->p_flags = 0;
d2695 15
a2709 2
	    off += ((m->sections[0]->vma - off)
		    % (1 << bfd_get_section_alignment (abfd, m->sections[0])));
d2746 9
d2770 1
d2782 1
d2790 1
d2796 2
d2799 1
d2804 2
a2805 1
      if (p->p_type == PT_LOAD)
d2820 1
d2831 14
d2847 1
a2847 1
	      bfd_vma adjust;
d2849 7
a2855 3
	      /* The section VMA must equal the file position modulo
                 the page size.  */
	      if ((flags & SEC_ALLOC) != 0)
d2857 5
d2866 7
a2872 1
		  if (adjust != 0)
d2874 8
a2881 7
		      if (i == 0)
			abort ();
		      p->p_memsz += adjust;
		      off += adjust;
		      voff += adjust;
		      if ((flags & SEC_LOAD) != 0)
			p->p_filesz += adjust;
d2883 5
d2892 6
a2897 1
	      if ((flags & SEC_LOAD) != 0)
d2899 1
d2904 21
a2924 1
	  p->p_memsz += sec->_raw_size;
d2926 2
a2927 2
	  if ((flags & SEC_LOAD) != 0)
	    p->p_filesz += sec->_raw_size;
d2929 4
a2932 2
	  if (align > p->p_align)
	    p->p_align = align;
d3046 10
d3092 2
a3093 1
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
d3120 1
a3120 1
	  
d3148 1
a3148 1
	       ("%s: warning: allocated section `%s' not in segment",
d3167 1
a3167 1
	}		   
d3185 1
a3185 1
  Elf_Internal_Phdr *i_phdrp = 0;	/* Program header table, internal form */
d3210 3
d3220 2
d3232 1
a3232 1
	i_ehdrp->e_machine = EM_SPARC64;
d3236 3
d3251 3
d3269 31
d3306 3
d3399 2
a3400 2
      && ! _bfd_elf_compute_section_file_positions (abfd,
						    (struct bfd_link_info *) NULL))
d3410 1
d3440 7
d3487 2
d3530 1
a3530 1
	("%s: symbol `%s' required but not present",
d3539 1
a3539 1
	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n",
d3559 1
d3561 3
a3563 1
  unsigned int i, c;
d3577 33
a3609 2
  c = elf_elfheader (ibfd)->e_phnum;
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < c; i++, p++)
d3613 2
a3614 1
      struct elf_segment_map *m;
d3616 9
a3624 1

a3625 4

      /* The complicated case when p_vaddr is 0 is to handle the
	 Solaris linker, which generates a PT_INTERP section with
	 p_vaddr and p_memsz set to 0.  */
d3627 9
a3635 12
	if (((s->vma >= p->p_vaddr
	      && (s->vma + s->_raw_size <= p->p_vaddr + p->p_memsz
		  || s->vma + s->_raw_size <= p->p_vaddr + p->p_filesz))
	     || (p->p_vaddr == 0
		 && p->p_filesz > 0
		 && (s->flags & SEC_HAS_CONTENTS) != 0
		 && (bfd_vma) s->filepos >= p->p_offset
		 && ((bfd_vma) s->filepos + s->_raw_size
		     <= p->p_offset + p->p_filesz)))
	    && (s->flags & SEC_ALLOC) != 0
	    && s->output_section != NULL)
	  ++csecs;
d3637 2
d3642 1
a3642 1
		       + (csecs - 1) * sizeof (asection *))));
d3646 5
a3650 3
      m->next = NULL;
      m->p_type = p->p_type;
      m->p_flags = p->p_flags;
d3652 1
a3652 1
      m->p_paddr = p->p_paddr;
d3655 2
d3660 164
a3823 4
      m->includes_phdrs = (p->p_offset <= (bfd_vma) iehdr->e_phoff
			   && (p->p_offset + p->p_filesz
			       >= ((bfd_vma) iehdr->e_phoff
				   + iehdr->e_phnum * iehdr->e_phentsize)));
d3825 7
d3833 1
a3833 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d3835 64
a3898 11
	  if (((s->vma >= p->p_vaddr
		&& (s->vma + s->_raw_size <= p->p_vaddr + p->p_memsz
		    || s->vma + s->_raw_size <= p->p_vaddr + p->p_filesz))
	       || (p->p_vaddr == 0
		   && p->p_filesz > 0
		   && (s->flags & SEC_HAS_CONTENTS) != 0
		   && (bfd_vma) s->filepos >= p->p_offset
		   && ((bfd_vma) s->filepos + s->_raw_size
		       <= p->p_offset + p->p_filesz)))
	      && (s->flags & SEC_ALLOC) != 0
	      && s->output_section != NULL)
d3900 23
a3922 2
	      m->sections[isec] = s->output_section;
	      ++isec;
d3925 4
a3928 2
      BFD_ASSERT (isec == csecs);
      m->count = csecs;
d3930 11
a3940 2
      *pm = m;
      pm = &m->next;
d3945 27
d4001 6
a4006 4
      /* Only set up the segments when all the sections have been set
         up.  */
      for (s = ibfd->sections; s != NULL; s = s->next)
	if (s->output_section == NULL)
d4021 3
a4023 1
      || ihdr->sh_type == SHT_DYNSYM)
d4026 3
d4083 1
a4083 1
swap_out_syms (abfd, sttp)
d4086 1
d4158 2
a4159 1
	if (bfd_is_com_section (syms[idx]->section))
d4170 2
a4171 2
	    sym.st_shndx = _bfd_elf_section_from_bfd_section (abfd,
							      syms[idx]->section);
d4183 3
a4185 1
	    value += sec->vma;
d4247 8
a4254 1
	if (bfd_is_com_section (syms[idx]->section))
a4260 2
	else if (flags & BSF_SECTION_SYM)
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
d4277 5
a4281 1
	sym.st_other = 0;
d4343 1
a4343 1
     bfd *abfd;
d4361 4
a4364 1
  if (! get_elf_backend_data (abfd)->s->slurp_reloc_table (abfd, section, symbols))
d4381 2
a4382 1
  long symcount = get_elf_backend_data (abfd)->s->slurp_symbol_table (abfd, alocation, false);
d4394 2
a4395 1
  return get_elf_backend_data (abfd)->s->slurp_symbol_table (abfd, alocation, true);
d4398 7
a4404 2
asymbol *
_bfd_elf_make_empty_symbol (abfd)
d4407 2
a4408 1
  elf_symbol_type *newsym;
d4410 1
a4410 4
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, sizeof (elf_symbol_type));
  if (!newsym)
    return NULL;
  else
d4412 257
a4668 2
      newsym->symbol.the_bfd = abfd;
      return &newsym->symbol;
d4674 1
a4674 1
     bfd *ignore_abfd;
d4681 30
d4713 2
a4714 2
     bfd *ignore_abfd;
     asymbol *symbol;
d4761 10
d4802 1
d4848 2
a4849 2
      && ! _bfd_elf_compute_section_file_positions (abfd,
						    (struct bfd_link_info *) NULL))
d4864 3
a4866 3
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d4891 1
a4891 1
  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec) 
d4895 1
a4895 1
      
d4904 1
a4904 1
	      code = BFD_RELOC_8_PCREL; 
d4907 1
a4907 1
	      code = BFD_RELOC_12_PCREL; 
d4910 1
a4910 1
	      code = BFD_RELOC_16_PCREL; 
d4913 1
a4913 1
	      code = BFD_RELOC_24_PCREL; 
d4916 1
a4916 1
	      code = BFD_RELOC_32_PCREL; 
d4919 1
a4919 1
	      code = BFD_RELOC_64_PCREL; 
d4940 1
a4940 1
	      code = BFD_RELOC_8; 
d4943 1
a4943 1
	      code = BFD_RELOC_14; 
d4946 1
a4946 1
	      code = BFD_RELOC_16; 
d4949 1
a4949 1
	      code = BFD_RELOC_26; 
d4952 1
a4952 1
	      code = BFD_RELOC_32; 
d4955 1
a4955 1
	      code = BFD_RELOC_64; 
d4974 1
a4974 1
    ("%s: unsupported relocation type %s",
d4978 636
@


1.7
log
@Need a real fix. Remove workaround...
@
text
@d50 6
d2045 1
a2045 1
	  && (m->sections[0]->flags & SEC_LOAD) != 0)
d2509 6
d2919 4
@


1.6
log
@workaround for header bug
@
text
@d2275 1
a2275 1
      segs = 1;
d2284 1
a2284 1
  segs = 3;
@


1.5
log
@Seems they fixed that old bug. Remove workaround
@
text
@d2275 1
a2275 1
      segs = 0;
d2284 1
a2284 1
  segs = 2;
@


1.4
log
@Merge the Cygnus 960904 sources
@
text
@a864 5
/*XXX Why is sh_info sometimes (-static linked) zero? */
        if(hdr->sh_info == 0)
          return true;
/*XXX*/

@


1.3
log
@Fixes to make MIPS arc port to use in tree binutils.
@
text
@d43 1
d215 9
d240 5
a244 1
	      && phdr->p_vaddr + phdr->p_memsz >= hdr->sh_addr + hdr->sh_size)
d1062 2
a1063 1
  if ((asect->flags & SEC_ALLOC) != 0)
d1758 15
a1772 6
  /* Deal with -Ttext or something similar such that the
     first section is not adjacent to the program headers.  */
  if (count
      && ((sections[0]->lma % maxpagesize) <
	  (elf_tdata (abfd)->program_header_size % maxpagesize)))
    phdr_in_section = false;
d1777 1
d1782 51
a1832 14
         segment.  Don't put a loadable section after a non-loadable
         section.  If we are building a dynamic executable, don't put
         a writable section in a read only segment (we don't do this
         for a non-dynamic executable because some people prefer to
         have only one program segment; anybody can use PHDRS in their
         linker script to control what happens anyhow).  */
      if (last_hdr == NULL
	  || ((BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
	       >= hdr->lma)
	      && ((last_hdr->flags & SEC_LOAD) != 0
		  || (hdr->flags & SEC_LOAD) == 0)
	      && (dynsec == NULL
		  || writable
		  || (hdr->flags & SEC_READONLY) != 0)))
d1834 8
d1846 2
a1847 3
      /* This section won't fit in the program segment.  We must
         create a new program header holding all the sections from
         phdr_index until hdr.  */
d1858 2
d1920 7
d1966 1
a1966 1
  file_ptr off;
d2045 7
a2051 1
	off += (m->sections[0]->vma - off) % bed->maxpagesize;
d2065 2
a2066 1
      if (p->p_type == PT_LOAD)
d2144 1
d2153 1
d2163 4
a2166 1
		  adjust = (sec->vma - off) % bed->maxpagesize;
d2173 1
d2183 2
a2191 1
	  align = 1 << bfd_get_section_alignment (abfd, sec);
d2403 4
a2406 1
	      off += (hdr->sh_addr - off) % bed->maxpagesize;
d2501 6
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d850 6
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993 Free Software Foundation, Inc.
d41 4
a44 4
static file_ptr map_program_segments PARAMS ((bfd *, file_ptr,
					      Elf_Internal_Shdr *,
					      Elf_Internal_Shdr **,
					      bfd_size_type));
d48 1
d86 1
a86 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d107 1
a107 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d227 1
d329 157
d541 1
a541 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_hash_entry *) ret;
    }
d557 1
d559 5
a563 1
      ret->elf_link_hash_flags = 0;
d586 2
d602 1
a602 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d623 3
a625 2
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    elf_dt_needed_name (abfd) = name;
d628 2
a629 1
/* Get the list of DT_NEEDED entries for a link.  */
d640 14
d704 1
a803 1
	int use_rela_p = get_elf_backend_data (abfd)->use_rela_p;
a847 14
	/* Don't allow REL relocations on a machine that uses RELA and
	   vice versa.  */
	/* @@@@ Actually, the generic ABI does suggest that both might be
	   used in one file.  But the four ABI Processor Supplements I
	   have access to right now all specify that only one is used on
	   each of those architectures.  It's conceivable that, e.g., a
	   bunch of absolute 32-bit relocs might be more compact in REL
	   form even on a RELA machine...  */
	BFD_ASSERT (use_rela_p
		    ? (hdr->sh_type == SHT_RELA
		       && hdr->sh_entsize == bed->s->sizeof_rela)
		    : (hdr->sh_type == SHT_REL
		       && hdr->sh_entsize == bed->s->sizeof_rel));

d854 9
a862 1
	hdr2 = &elf_section_data (target_sect)->rel_hdr;
d865 1
a865 1
	target_sect->reloc_count = hdr->sh_size / hdr->sh_entsize;
a873 3
    case SHT_NOTE:
      break;

d912 1
a912 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d957 1
a957 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d988 1
a988 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
a1130 1
	  bfd_set_error (bfd_error_no_memory);
d1199 1
a1199 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
a1205 1
      bfd_set_error (bfd_error_no_memory);
d1277 1
a1277 1
	      alc = (char *) malloc (len - 2);
d1279 1
a1279 4
		{
		  bfd_set_error (bfd_error_no_memory);
		  return false;
		}
d1368 1
a1368 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1445 1
a1445 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1603 13
a1615 1
/* Get the size of the program header.
d1617 11
a1627 4
   SORTED_HDRS, if non-NULL, is an array of COUNT pointers to headers sorted
   by VMA.  Non-allocated sections (!SHF_ALLOC) must appear last.  All
   section VMAs and sizes are known so we can compute the correct value.
   (??? This may not be perfectly true.  What cases do we miss?)
d1629 6
a1634 2
   If SORTED_HDRS is NULL we assume there are two segments: text and data
   (exclusive of .interp and .dynamic).
d1636 2
a1637 5
   If this is called by the linker before any of the section VMA's are set, it
   can't calculate the correct value for a strange memory layout.  This only
   happens when SIZEOF_HEADERS is used in a linker script.  In this case,
   SORTED_HDRS is NULL and we assume the normal scenario of one text and one
   data segment (exclusive of .interp and .dynamic).
d1639 1
a1639 2
   ??? User written scripts must either not use SIZEOF_HEADERS, or assume there
   will be two segments.  */
d1641 2
a1642 2
static bfd_size_type
get_program_header_size (abfd, sorted_hdrs, count, maxpagesize)
a1643 3
     Elf_Internal_Shdr **sorted_hdrs;
     unsigned int count;
     bfd_vma maxpagesize;
d1645 1
a1645 1
  size_t segs;
d1647 44
a1690 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1692 51
a1742 3
  /* We can't return a different result each time we're called.  */
  if (elf_tdata (abfd)->program_header_size != 0)
    return elf_tdata (abfd)->program_header_size;
d1744 1
a1744 1
  if (sorted_hdrs != NULL)
d1746 3
a1748 27
      unsigned int i;
      unsigned int last_type;
      Elf_Internal_Shdr **hdrpp;
      /* What we think the current segment's offset is.  */
      bfd_vma p_offset;
      /* What we think the current segment's address is.  */
      bfd_vma p_vaddr;
      /* How big we think the current segment is.  */
      bfd_vma p_memsz;
      /* What we think the current file offset is.  */
      bfd_vma file_offset;
      bfd_vma next_offset;

      /* Scan the headers and compute the number of segments required.  This
	 code is intentionally similar to the code in map_program_segments.

	 The `sh_offset' field isn't valid at this point, so we keep our own
	 running total in `file_offset'.

	 This works because section VMAs are already known.  */

      segs = 1;
      /* Make sure the first section goes in the first segment.  */
      file_offset = p_offset = sorted_hdrs[0]->sh_addr % maxpagesize;
      p_vaddr = sorted_hdrs[0]->sh_addr;
      p_memsz = 0;
      last_type = SHT_PROGBITS;
d1750 15
a1764 1
      for (i = 0, hdrpp = sorted_hdrs; i < count; i++, hdrpp++)
d1766 3
a1768 1
	  Elf_Internal_Shdr *hdr;
d1770 3
a1772 1
	  hdr = *hdrpp;
d1774 3
a1776 27
	  /* Ignore any section which will not be part of the process
	     image.  */
	  if ((hdr->sh_flags & SHF_ALLOC) == 0)
	    continue;

	  /* Keep track of where this and the next sections go.
	     The section VMA must equal the file position modulo
	     the page size.  */
	  file_offset += (hdr->sh_addr - file_offset) % maxpagesize;
	  next_offset = file_offset;
	  if (hdr->sh_type != SHT_NOBITS)
	    next_offset = file_offset + hdr->sh_size;

	  /* If this section fits in the segment we are constructing, add
	     it in.  */
	  if ((file_offset - (p_offset + p_memsz)
	       == hdr->sh_addr - (p_vaddr + p_memsz))
	      && (last_type != SHT_NOBITS || hdr->sh_type == SHT_NOBITS))
	    {
	      bfd_size_type adjust;

	      adjust = hdr->sh_addr - (p_vaddr + p_memsz);
	      p_memsz += hdr->sh_size + adjust;
	      file_offset = next_offset;
	      last_type = hdr->sh_type;
	      continue;
	    }
d1778 2
a1779 2
	  /* The section won't fit, start a new segment.  */
	  ++segs;
d1781 2
a1782 5
	  /* Initialize the segment.  */
	  p_vaddr = hdr->sh_addr;
	  p_memsz = hdr->sh_size;
	  p_offset = file_offset;
	  file_offset = next_offset;
d1784 3
a1786 2
	  last_type = hdr->sh_type;
	}
d1788 3
a1790 1
  else
d1792 6
a1797 3
      /* Assume we will need exactly two PT_LOAD segments: one for text
	 and one for data.  */
      segs = 2;
d1800 2
a1801 2
  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
d1803 11
a1813 5
      /* If we have a loadable interpreter section, we need a
	 PT_INTERP segment.  In this case, assume we also need a
	 PT_PHDR segment, although that may not be true for all
	 targets.  */
      segs += 2;
d1816 44
a1859 5
  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
    {
      /* We need a PT_DYNAMIC segment.  */
      ++segs;
    }
d1861 4
a1864 4
  /* Let the backend count up any program headers it might need.  */
  if (bed->elf_backend_create_program_headers)
    segs = ((*bed->elf_backend_create_program_headers)
	    (abfd, (Elf_Internal_Phdr *) NULL, segs));
d1866 1
a1866 2
  elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
  return elf_tdata (abfd)->program_header_size;
d1869 3
a1871 5
/* Create the program header.  OFF is the file offset where the
   program header should be written.  FIRST is the first loadable ELF
   section.  SORTED_HDRS is the ELF sections sorted by section
   address.  PHDR_SIZE is the size of the program header as returned
   by get_program_header_size.  */
d1873 2
a1874 2
static file_ptr
map_program_segments (abfd, off, first, sorted_hdrs, phdr_size)
d1876 16
a1891 15
     file_ptr off;
     Elf_Internal_Shdr *first;
     Elf_Internal_Shdr **sorted_hdrs;
     bfd_size_type phdr_size;
{
  Elf_Internal_Phdr phdrs[10];
  unsigned int phdr_count;
  Elf_Internal_Phdr *phdr;
  int phdr_size_adjust;
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  asection *sinterp, *sdyn;
  unsigned int last_type;
  Elf_Internal_Ehdr *i_ehdrp;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1893 5
a1897 3
  BFD_ASSERT ((abfd->flags & (EXEC_P | DYNAMIC)) != 0);
  BFD_ASSERT (phdr_size / sizeof (Elf_Internal_Phdr)
	      <= sizeof phdrs / sizeof (phdrs[0]));
d1899 7
a1905 2
  phdr_count = 0;
  phdr = phdrs;
d1907 2
a1908 4
  if (bed->want_hdr_in_seg)
    phdr_size_adjust = first->sh_offset - phdr_size;
  else
    phdr_size_adjust = 0;
d1910 12
a1921 26
  /* If we have a loadable .interp section, we must create a PT_INTERP
     segment which must precede all PT_LOAD segments.  We assume that
     we must also create a PT_PHDR segment, although that may not be
     true for all targets.  */
  sinterp = bfd_get_section_by_name (abfd, ".interp");
  if (sinterp != NULL && (sinterp->flags & SEC_LOAD) != 0)
    {
      BFD_ASSERT (first != NULL);

      phdr->p_type = PT_PHDR;

      phdr->p_offset = off;

      /* Account for any adjustment made because of the alignment of
	 the first loadable section.  */
      phdr_size_adjust = (first->sh_offset - phdr_size) - off;
      BFD_ASSERT (phdr_size_adjust >= 0 && phdr_size_adjust < 128);

      /* The program header precedes all loadable sections.  This lets
	 us compute its loadable address.  This depends on the linker
	 script.  */
      phdr->p_vaddr = first->sh_addr - (phdr_size + phdr_size_adjust);

      phdr->p_paddr = first->bfd_section->lma - (phdr_size + phdr_size_adjust);
      phdr->p_filesz = phdr_size;
      phdr->p_memsz = phdr_size;
d1923 2
a1924 2
      /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
      phdr->p_flags = PF_R | PF_X;
d1926 4
a1929 2
      phdr->p_align = bed->s->file_align;
      BFD_ASSERT ((phdr->p_vaddr - phdr->p_offset) % bed->s->file_align == 0);
d1931 2
a1932 2
      /* Include the ELF header in the first loadable segment.  */
      phdr_size_adjust += off;
d1934 7
a1940 24
      ++phdr_count;
      ++phdr;

      phdr->p_type = PT_INTERP;
      phdr->p_offset = sinterp->filepos;
      phdr->p_vaddr = sinterp->vma;
      phdr->p_paddr = sinterp->lma;
      phdr->p_filesz = sinterp->_raw_size;
      phdr->p_memsz = sinterp->_raw_size;
      phdr->p_flags = PF_R;
      phdr->p_align = 1 << bfd_get_section_alignment (abfd, sinterp);

      ++phdr_count;
      ++phdr;
    }

  /* Look through the sections to see how they will be divided into
     program segments.  The sections must be arranged in order by
     sh_addr for this to work correctly.  */
  phdr->p_type = PT_NULL;
  last_type = SHT_PROGBITS;
  for (i = 1, hdrpp = sorted_hdrs;
       i < elf_elfheader (abfd)->e_shnum;
       i++, hdrpp++)
d1942 64
a2005 1
      Elf_Internal_Shdr *hdr;
d2007 31
a2037 1
      hdr = *hdrpp;
d2039 7
a2045 4
      /* Ignore any section which will not be part of the process
	 image.  */
      if ((hdr->sh_flags & SHF_ALLOC) == 0)
	continue;
d2047 4
a2050 21
      /* If this section fits in the segment we are constructing, add
	 it in.  */
      if (phdr->p_type != PT_NULL
	  && (hdr->sh_offset - (phdr->p_offset + phdr->p_memsz)
	      == hdr->sh_addr - (phdr->p_vaddr + phdr->p_memsz))
	  && (hdr->sh_addr - hdr->bfd_section->lma
	      == phdr->p_vaddr - phdr->p_paddr)
	  && (last_type != SHT_NOBITS || hdr->sh_type == SHT_NOBITS))
	{
	  bfd_size_type adjust;

	  adjust = hdr->sh_addr - (phdr->p_vaddr + phdr->p_memsz);
	  phdr->p_memsz += hdr->sh_size + adjust;
	  if (hdr->sh_type != SHT_NOBITS)
	    phdr->p_filesz += hdr->sh_size + adjust;
	  if ((hdr->sh_flags & SHF_WRITE) != 0)
	    phdr->p_flags |= PF_W;
	  if ((hdr->sh_flags & SHF_EXECINSTR) != 0)
	    phdr->p_flags |= PF_X;
	  last_type = hdr->sh_type;
	  continue;
d2053 52
a2104 6
      /* The section won't fit, start a new segment.  If we're already in one,
	 move to the next one.  */
      if (phdr->p_type != PT_NULL)
	{
	  ++phdr;
	  ++phdr_count;
d2106 1
d2108 5
a2112 69
      /* Initialize the segment.  */
      phdr->p_type = PT_LOAD;
      phdr->p_offset = hdr->sh_offset;
      phdr->p_vaddr = hdr->sh_addr;
      phdr->p_paddr = hdr->bfd_section->lma;
      if (hdr->sh_type == SHT_NOBITS)
	phdr->p_filesz = 0;
      else
	phdr->p_filesz = hdr->sh_size;
      phdr->p_memsz = hdr->sh_size;
      phdr->p_flags = PF_R;
      if ((hdr->sh_flags & SHF_WRITE) != 0)
	phdr->p_flags |= PF_W;
      if ((hdr->sh_flags & SHF_EXECINSTR) != 0)
	phdr->p_flags |= PF_X;
      phdr->p_align = bed->maxpagesize;

      if (hdr == first
	  && (bed->want_hdr_in_seg
	      || (sinterp != NULL
		  && (sinterp->flags & SEC_LOAD) != 0)))
	{
	  phdr->p_offset -= phdr_size + phdr_size_adjust;
	  phdr->p_vaddr -= phdr_size + phdr_size_adjust;
	  phdr->p_paddr -= phdr_size + phdr_size_adjust;
	  phdr->p_filesz += phdr_size + phdr_size_adjust;
	  phdr->p_memsz += phdr_size + phdr_size_adjust;
	}

      last_type = hdr->sh_type;
    }

  if (phdr->p_type != PT_NULL)
    {
      ++phdr;
      ++phdr_count;
    }

  /* If we have a .dynamic section, create a PT_DYNAMIC segment.  */
  sdyn = bfd_get_section_by_name (abfd, ".dynamic");
  if (sdyn != NULL && (sdyn->flags & SEC_LOAD) != 0)
    {
      phdr->p_type = PT_DYNAMIC;
      phdr->p_offset = sdyn->filepos;
      phdr->p_vaddr = sdyn->vma;
      phdr->p_paddr = sdyn->lma;
      phdr->p_filesz = sdyn->_raw_size;
      phdr->p_memsz = sdyn->_raw_size;
      phdr->p_flags = PF_R;
      if ((sdyn->flags & SEC_READONLY) == 0)
	phdr->p_flags |= PF_W;
      if ((sdyn->flags & SEC_CODE) != 0)
	phdr->p_flags |= PF_X;
      phdr->p_align = 1 << bfd_get_section_alignment (abfd, sdyn);

      ++phdr;
      ++phdr_count;
    }

  /* Let the backend create additional program headers.  */
  if (bed->elf_backend_create_program_headers)
    phdr_count = (*bed->elf_backend_create_program_headers) (abfd,
							     phdrs,
							     phdr_count);

  /* Make sure the return value from get_program_header_size matches
     what we computed here.  Actually, it's OK if we allocated too
     much space in the program header.  */
  if (phdr_count > phdr_size / bed->s->sizeof_phdr)
d2114 20
a2133 7
      ((*_bfd_error_handler)
       ("%s: Not enough room for program headers (allocated %lu, need %u)",
	bfd_get_filename (abfd),
	(unsigned long) (phdr_size / bed->s->sizeof_phdr),
	phdr_count));
      bfd_set_error (bfd_error_bad_value);
      return (file_ptr) -1;
d2136 2
a2137 13
  /* Set up program header information.  */
  i_ehdrp = elf_elfheader (abfd);
  i_ehdrp->e_phentsize = bed->s->sizeof_phdr;
  i_ehdrp->e_phoff = off;
  i_ehdrp->e_phnum = phdr_count;

  /* Save the program headers away.  I don't think anybody uses this
     information right now.  */
  elf_tdata (abfd)->phdr = ((Elf_Internal_Phdr *)
			    bfd_alloc (abfd,
				       (phdr_count
					* sizeof (Elf_Internal_Phdr))));
  if (elf_tdata (abfd)->phdr == NULL && phdr_count != 0)
d2139 2
a2140 2
      bfd_set_error (bfd_error_no_memory);
      return (file_ptr) -1;
d2142 4
a2145 2
  memcpy (elf_tdata (abfd)->phdr, phdrs,
	  phdr_count * sizeof (Elf_Internal_Phdr));
d2148 40
a2187 2
  if (bfd_seek (abfd, off, SEEK_SET) != 0)
    return (file_ptr) -1;
d2189 3
a2191 2
  if (bed->s->write_out_phdrs (abfd, phdrs, phdr_count) != 0)
    return (file_ptr) -1;
d2193 29
a2221 1
  return off + phdr_count * bed->s->sizeof_phdr;
a2234 2
static int elf_sort_hdrs PARAMS ((const PTR, const PTR));

a2244 3
  /* Start after the ELF header.  */
  off = i_ehdrp->e_ehsize;

d2250 3
d2278 1
a2278 5
      file_ptr phdr_off;
      bfd_size_type phdr_size;
      bfd_vma maxpagesize;
      size_t hdrppsize;
      Elf_Internal_Shdr **sorted_hdrs;
a2279 3
      unsigned int i;
      Elf_Internal_Shdr *first;
      file_ptr phdr_map;
d2281 4
a2284 1
      /* We are creating an executable.  */
d2286 1
a2286 15
      maxpagesize = get_elf_backend_data (abfd)->maxpagesize;
      if (maxpagesize == 0)
	maxpagesize = 1;

      /* We must sort the sections.  The GNU linker will always create
	 the sections in an appropriate order, but the Irix 5 linker
	 will not.  We don't include the dummy first section in the
	 sort.  We sort sections which are not SHF_ALLOC to the end.  */
      hdrppsize = (i_ehdrp->e_shnum - 1) * sizeof (Elf_Internal_Shdr *);
      sorted_hdrs = (Elf_Internal_Shdr **) malloc (hdrppsize);
      if (sorted_hdrs == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d2288 2
a2289 19
      memcpy (sorted_hdrs, i_shdrpp + 1, hdrppsize);
      qsort (sorted_hdrs, (size_t) i_ehdrp->e_shnum - 1,
	     sizeof (Elf_Internal_Shdr *), elf_sort_hdrs);

      /* We can't actually create the program header until we have set the
	 file positions for the sections, and we can't do that until we know
	 how big the header is going to be.  */
      off = align_file_position (off, bed->s->file_align);
      phdr_size = get_program_header_size (abfd,
					   sorted_hdrs, i_ehdrp->e_shnum - 1,
					   maxpagesize);
      if (phdr_size == (bfd_size_type) -1)
	return false;

      /* Compute the file offsets of each section.  */
      phdr_off = off;
      off += phdr_size;
      first = NULL;
      for (i = 1, hdrpp = sorted_hdrs; i < i_ehdrp->e_shnum; i++, hdrpp++)
d2294 4
a2297 17
	  if ((hdr->sh_flags & SHF_ALLOC) == 0)
	    {
	      if (hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
		{
		  hdr->sh_offset = -1;
		  continue;
		}
	      if (hdr == i_shdrpp[tdata->symtab_section]
		  || hdr == i_shdrpp[tdata->strtab_section])
		{
		  hdr->sh_offset = -1;
		  continue;
		}
	      off = _bfd_elf_assign_file_position_for_section (hdr, off,
							       true);
	    }
	  else
d2299 7
a2305 7
	      if (first == NULL)
		first = hdr;

	      /* The section VMA must equal the file position modulo
		 the page size.  This is required by the program
		 header.  */
	      off += (hdr->sh_addr - off) % maxpagesize;
d2309 8
a2316 11
	}

      /* Create the program header.  */
      phdr_map = map_program_segments (abfd, phdr_off, first, sorted_hdrs,
				       phdr_size);
      if (phdr_map == (file_ptr) -1)
	return false;
      BFD_ASSERT ((bfd_size_type) phdr_map
		  <= (bfd_size_type) phdr_off + phdr_size);

      free (sorted_hdrs);
a2328 41
/* Sort the ELF headers by VMA.  We sort headers which are not
   SHF_ALLOC to the end.  */
static int
elf_sort_hdrs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  int ret;
  const Elf_Internal_Shdr *hdr1 = *(const Elf_Internal_Shdr **) arg1;
  const Elf_Internal_Shdr *hdr2 = *(const Elf_Internal_Shdr **) arg2;

#define TOEND(x) (((x)->sh_flags & SHF_ALLOC)==0)

  if (TOEND (hdr1))
    if (TOEND (hdr2))
      return 0;
    else 
      return 1;

  if (TOEND (hdr2))
    return -1;

  if (hdr1->sh_addr < hdr2->sh_addr)
    return -1;
  else if (hdr1->sh_addr > hdr2->sh_addr)
    return 1;

  /* Put !SHT_NOBITS sections before SHT_NOBITS ones.
     The main loop in map_program_segments requires this. */

  ret = (hdr1->sh_type == SHT_NOBITS) - (hdr2->sh_type == SHT_NOBITS);

  if (ret != 0)
    return ret;
  if (hdr1->sh_size < hdr2->sh_size)
    return -1;
  if (hdr1->sh_size > hdr2->sh_size)
    return 1;
  return 0;
}

d2356 1
a2356 1
    abfd->xvec->byteorder_big_p ? ELFDATA2MSB : ELFDATA2LSB;
d2574 4
a2577 2
/* given a symbol, return the bfd index for that symbol.  */
 int
d2580 1
a2580 1
     struct symbol_cache_entry **asym_ptr_ptr;
d2582 1
a2582 1
  struct symbol_cache_entry *asym_ptr = *asym_ptr_ptr;
d2606 11
a2616 1
  BFD_ASSERT (idx != 0);
d2622 2
a2623 1
     (long) asym_ptr, asym_ptr->name, idx, flags, elf_symbol_flags (flags));
d2631 105
d2752 22
d2869 1
a2869 4
      {
	bfd_set_error (bfd_error_no_memory);
	return false;
      }
d2891 1
d2986 7
d2994 1
a2994 1
	  sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_OBJECT);
d2999 1
a2999 3
				     ((flags & BSF_FUNCTION)
				      ? STT_FUNC
				      : STT_NOTYPE));
a3006 1
	    int type = STT_OBJECT;
a3014 3
	    if (flags & BSF_FUNCTION)
	      type = STT_FUNC;

d3138 1
a3138 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d3199 1
d3202 1
d3205 8
d3218 1
d3237 7
a3243 3
	  if (func == NULL
	      || q->symbol.value <= offset)
	    func = (asymbol *) q;
d3266 1
a3266 2
    ret += get_program_header_size (abfd, (Elf_Internal_Shdr **) NULL, 0,
				    (bfd_vma) 0);
d3314 98
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d41 4
a44 4
static INLINE struct elf_segment_map *make_mapping
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, boolean));
static int elf_sort_sections PARAMS ((const PTR, const PTR));
static boolean assign_file_positions_for_segments PARAMS ((bfd *));
a47 1
static boolean copy_private_bfd_data PARAMS ((bfd *, bfd *));
d85 4
a88 1
    return NULL;
d109 4
a112 1
    return false;
a231 1
	      && phdr->p_paddr != 0
a332 157
/* Print out the program headers.  */

boolean
_bfd_elf_print_private_bfd_data (abfd, farg)
     bfd *abfd;
     PTR farg;
{
  FILE *f = (FILE *) farg;
  Elf_Internal_Phdr *p;
  asection *s;
  bfd_byte *dynbuf = NULL;

  p = elf_tdata (abfd)->phdr;
  if (p != NULL)
    {
      unsigned int i, c;

      fprintf (f, "\nProgram Header:\n");
      c = elf_elfheader (abfd)->e_phnum;
      for (i = 0; i < c; i++, p++)
	{
	  const char *s;
	  char buf[20];

	  switch (p->p_type)
	    {
	    case PT_NULL: s = "NULL"; break;
	    case PT_LOAD: s = "LOAD"; break;
	    case PT_DYNAMIC: s = "DYNAMIC"; break;
	    case PT_INTERP: s = "INTERP"; break;
	    case PT_NOTE: s = "NOTE"; break;
	    case PT_SHLIB: s = "SHLIB"; break;
	    case PT_PHDR: s = "PHDR"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); s = buf; break;
	    }
	  fprintf (f, "%8s off    0x", s);
	  fprintf_vma (f, p->p_offset);
	  fprintf (f, " vaddr 0x");
	  fprintf_vma (f, p->p_vaddr);
	  fprintf (f, " paddr 0x");
	  fprintf_vma (f, p->p_paddr);
	  fprintf (f, " align 2**%u\n", bfd_log2 (p->p_align));
	  fprintf (f, "         filesz 0x");
	  fprintf_vma (f, p->p_filesz);
	  fprintf (f, " memsz 0x");
	  fprintf_vma (f, p->p_memsz);
	  fprintf (f, " flags %c%c%c",
		   (p->p_flags & PF_R) != 0 ? 'r' : '-',
		   (p->p_flags & PF_W) != 0 ? 'w' : '-',
		   (p->p_flags & PF_X) != 0 ? 'x' : '-');
	  if ((p->p_flags &~ (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (PF_R | PF_W | PF_X));
	  fprintf (f, "\n");
	}
    }

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      int elfsec;
      unsigned long link;
      bfd_byte *extdyn, *extdynend;
      size_t extdynsize;
      void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));

      fprintf (f, "\nDynamic Section:\n");

      dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
      if (dynbuf == NULL)
	goto error_return;
      if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				      s->_raw_size))
	goto error_return;

      elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
      if (elfsec == -1)
	goto error_return;
      link = elf_elfsections (abfd)[elfsec]->sh_link;

      extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
      swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

      extdyn = dynbuf;
      extdynend = extdyn + s->_raw_size;
      for (; extdyn < extdynend; extdyn += extdynsize)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  char ab[20];
	  boolean stringp;

	  (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);

	  if (dyn.d_tag == DT_NULL)
	    break;

	  stringp = false;
	  switch (dyn.d_tag)
	    {
	    default:
	      sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
	      name = ab;
	      break;

	    case DT_NEEDED: name = "NEEDED"; stringp = true; break;
	    case DT_PLTRELSZ: name = "PLTRELSZ"; break;
	    case DT_PLTGOT: name = "PLTGOT"; break;
	    case DT_HASH: name = "HASH"; break;
	    case DT_STRTAB: name = "STRTAB"; break;
	    case DT_SYMTAB: name = "SYMTAB"; break;
	    case DT_RELA: name = "RELA"; break;
	    case DT_RELASZ: name = "RELASZ"; break;
	    case DT_RELAENT: name = "RELAENT"; break;
	    case DT_STRSZ: name = "STRSZ"; break;
	    case DT_SYMENT: name = "SYMENT"; break;
	    case DT_INIT: name = "INIT"; break;
	    case DT_FINI: name = "FINI"; break;
	    case DT_SONAME: name = "SONAME"; stringp = true; break;
	    case DT_RPATH: name = "RPATH"; stringp = true; break;
	    case DT_SYMBOLIC: name = "SYMBOLIC"; break;
	    case DT_REL: name = "REL"; break;
	    case DT_RELSZ: name = "RELSZ"; break;
	    case DT_RELENT: name = "RELENT"; break;
	    case DT_PLTREL: name = "PLTREL"; break;
	    case DT_DEBUG: name = "DEBUG"; break;
	    case DT_TEXTREL: name = "TEXTREL"; break;
	    case DT_JMPREL: name = "JMPREL"; break;
	    }

	  fprintf (f, "  %-11s ", name);
	  if (! stringp)
	    fprintf (f, "0x%lx", (unsigned long) dyn.d_un.d_val);
	  else
	    {
	      const char *string;

	      string = bfd_elf_string_from_elf_section (abfd, link,
							dyn.d_un.d_val);
	      if (string == NULL)
		goto error_return;
	      fprintf (f, "%s", string);
	    }
	  fprintf (f, "\n");
	}

      free (dynbuf);
      dynbuf = NULL;
    }

  return true;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return false;
}

d388 4
a391 1
    return (struct bfd_hash_entry *) ret;
a406 1
      ret->linker_section_pointer = (elf_linker_section_pointers_t *)0;
d408 1
a408 5
      /* Assume that we have been called by a non-ELF symbol reader.
         This flag is then reset by the code which reads an ELF input
         file.  This ensures that a symbol created by a non-ELF symbol
         reader will have the flag set correctly.  */
      ret->elf_link_hash_flags = ELF_LINK_NON_ELF;
a430 2
  table->hgot = NULL;
  table->stab_info = NULL;
d445 4
a448 1
    return NULL;
d469 2
a470 3
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dt_name (abfd) = name;
d473 1
a473 2
/* Get the list of DT_NEEDED entries for a link.  This is a hook for
   the ELF emulation code.  */
a483 14

/* Get the name actually used for a dynamic object for a link.  This
   is the SONAME entry if there is one.  Otherwise, it is the string
   passed to bfd_elf_set_dt_needed_name, or it is the filename.  */

const char *
bfd_elf_get_dt_soname (abfd)
     bfd *abfd;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    return elf_dt_name (abfd);
  return NULL;
}
a533 1
    case SHT_NOTE:	/* .note section.  */
d633 1
d678 14
d698 1
a698 9
	if ((target_sect->flags & SEC_RELOC) == 0
	    || target_sect->reloc_count == 0)
	  hdr2 = &elf_section_data (target_sect)->rel_hdr;
	else
	  {
	    BFD_ASSERT (elf_section_data (target_sect)->rel_hdr2 == NULL);
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, sizeof (*hdr2));
	    elf_section_data (target_sect)->rel_hdr2 = hdr2;
	  }
d701 1
a701 1
	target_sect->reloc_count += hdr->sh_size / hdr->sh_entsize;
d710 3
d751 4
a754 1
    return false;
d799 4
a802 1
    return false;
d833 4
a836 1
	return false;
d979 1
d1048 4
a1051 1
    return false;
d1058 1
d1130 1
a1130 1
	      alc = (char *) bfd_malloc (len - 2);
d1132 4
a1135 1
		return false;
d1224 4
a1227 1
    return false;
d1304 4
a1307 1
    return false;
d1465 1
a1465 1
/* Create a mapping from a set of sections to a program segment.  */
d1467 4
a1470 11
static INLINE struct elf_segment_map *
make_mapping (abfd, sections, from, to, phdr)
     bfd *abfd;
     asection **sections;
     unsigned int from;
     unsigned int to;
     boolean phdr;
{
  struct elf_segment_map *m;
  unsigned int i;
  asection **hdrpp;
d1472 2
a1473 11
  m = ((struct elf_segment_map *)
       bfd_zalloc (abfd,
		   (sizeof (struct elf_segment_map)
		    + (to - from - 1) * sizeof (asection *))));
  if (m == NULL)
    return NULL;
  m->next = NULL;
  m->p_type = PT_LOAD;
  for (i = from, hdrpp = sections + from; i < to; i++, hdrpp++)
    m->sections[i - from] = *hdrpp;
  m->count = to - from;
d1475 5
a1479 6
  if (from == 0 && phdr)
    {
      /* Include the headers in the first PT_LOAD segment.  */
      m->includes_filehdr = 1;
      m->includes_phdrs = 1;
    }
d1481 2
a1482 2
  return m;
}
d1484 2
a1485 4
/* Set up a mapping from BFD sections to program segments.  */

static boolean
map_sections_to_segments (abfd)
d1487 3
d1491 1
a1491 1
  asection **sections = NULL;
d1493 1
a1493 12
  unsigned int i;
  unsigned int count;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
  struct elf_segment_map *m;
  asection *last_hdr;
  unsigned int phdr_index;
  bfd_vma maxpagesize;
  asection **hdrpp;
  boolean phdr_in_section = true;
  boolean writable;
  asection *dynsec;
d1495 3
a1497 2
  if (elf_tdata (abfd)->segment_map != NULL)
    return true;
d1499 29
a1527 4
  if (bfd_count_sections (abfd) == 0)
    return true;

  /* Select the allocated sections, and sort them.  */
d1529 1
a1529 9
  sections = (asection **) bfd_malloc (bfd_count_sections (abfd)
				       * sizeof (asection *));
  if (sections == NULL)
    goto error_return;

  i = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_ALLOC) != 0)
d1531 1
a1531 6
	  sections[i] = s;
	  ++i;
	}
    }
  BFD_ASSERT (i <= bfd_count_sections (abfd));
  count = i;
d1533 1
a1533 1
  qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);
d1535 27
a1561 1
  /* Build the mapping.  */
d1563 2
a1564 2
  mfirst = NULL;
  pm = &mfirst;
d1566 5
a1570 51
  /* If we have a .interp section, then create a PT_PHDR segment for
     the program headers and a PT_INTERP segment for the .interp
     section.  */
  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_PHDR;
      /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
      m->p_flags = PF_R | PF_X;
      m->p_flags_valid = 1;
      m->includes_phdrs = 1;

      *pm = m;
      pm = &m->next;

      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_INTERP;
      m->count = 1;
      m->sections[0] = s;

      *pm = m;
      pm = &m->next;
    }

  /* Look through the sections.  We put sections in the same program
     segment when the start of the second section can be placed within
     a few bytes of the end of the first section.  */
  last_hdr = NULL;
  phdr_index = 0;
  maxpagesize = get_elf_backend_data (abfd)->maxpagesize;
  writable = false;
  dynsec = bfd_get_section_by_name (abfd, ".dynamic");
  if (dynsec != NULL
      && (dynsec->flags & SEC_LOAD) == 0)
    dynsec = NULL;

  /* Deal with -Ttext or something similar such that the
     first section is not adjacent to the program headers.  */
  if (count
      && ((sections[0]->lma % maxpagesize) <
	  (elf_tdata (abfd)->program_header_size % maxpagesize)))
    phdr_in_section = false;
d1572 4
a1575 1
  for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)
d1577 3
a1579 41
      asection *hdr;

      hdr = *hdrpp;

      /* See if this section and the last one will fit in the same
         segment.  Don't put a loadable section after a non-loadable
         section.  If we are building a dynamic executable, don't put
         a writable section in a read only segment (we don't do this
         for a non-dynamic executable because some people prefer to
         have only one program segment; anybody can use PHDRS in their
         linker script to control what happens anyhow).  */
      if (last_hdr == NULL
	  || ((BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
	       >= hdr->lma)
	      && ((last_hdr->flags & SEC_LOAD) != 0
		  || (hdr->flags & SEC_LOAD) == 0)
	      && (dynsec == NULL
		  || writable
		  || (hdr->flags & SEC_READONLY) != 0)))
	{
	  last_hdr = hdr;
	  continue;
	}

      /* This section won't fit in the program segment.  We must
         create a new program header holding all the sections from
         phdr_index until hdr.  */

      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_section);
      if (m == NULL)
	goto error_return;

      *pm = m;
      pm = &m->next;

      if ((hdr->flags & SEC_READONLY) == 0)
	writable = true;

      last_hdr = hdr;
      phdr_index = i;
      phdr_in_section = false;
d1582 2
a1583 2
  /* Create a final PT_LOAD program segment.  */
  if (last_hdr != NULL)
d1585 5
a1589 6
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_section);
      if (m == NULL)
	goto error_return;

      *pm = m;
      pm = &m->next;
d1592 1
a1592 2
  /* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
  if (dynsec != NULL)
d1594 2
a1595 11
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_DYNAMIC;
      m->count = 1;
      m->sections[0] = dynsec;

      *pm = m;
      pm = &m->next;
d1598 4
a1601 2
  free (sections);
  sections = NULL;
d1603 2
a1604 7
  elf_tdata (abfd)->segment_map = mfirst;
  return true;

 error_return:
  if (sections != NULL)
    free (sections);
  return false;
d1607 5
a1611 18
/* Sort sections by VMA.  */

static int
elf_sort_sections (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  const asection *sec1 = *(const asection **) arg1;
  const asection *sec2 = *(const asection **) arg2;

  if (sec1->vma < sec2->vma)
    return -1;
  else if (sec1->vma > sec2->vma)
    return 1;

  /* Put !SEC_LOAD sections after SEC_LOAD ones.  */

#define TOEND(x) (((x)->flags & SEC_LOAD) == 0)
d1613 2
a1614 28
  if (TOEND (sec1))
    if (TOEND (sec2))
      return sec1->target_index - sec2->target_index;
    else 
      return 1;

  if (TOEND (sec2))
    return -1;

#undef TOEND

  /* Sort by size, to put zero sized sections before others at the
     same address.  */

  if (sec1->_raw_size < sec2->_raw_size)
    return -1;
  if (sec1->_raw_size > sec2->_raw_size)
    return 1;

  return sec1->target_index - sec2->target_index;
}

/* Assign file positions to the sections based on the mapping from
   sections to segments.  This function also sets up some fields in
   the file header, and writes out the program headers.  */

static boolean
assign_file_positions_for_segments (abfd)
d1616 15
a1630 10
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int count;
  struct elf_segment_map *m;
  unsigned int alloc;
  Elf_Internal_Phdr *phdrs;
  file_ptr off;
  bfd_vma filehdr_vaddr, filehdr_paddr;
  bfd_vma phdrs_vaddr, phdrs_paddr;
  Elf_Internal_Phdr *p;
d1632 3
a1634 11
  if (elf_tdata (abfd)->segment_map == NULL)
    {
      if (! map_sections_to_segments (abfd))
	return false;
    }

  if (bed->elf_backend_modify_segment_map)
    {
      if (! (*bed->elf_backend_modify_segment_map) (abfd))
	return false;
    }
d1636 2
a1637 7
  count = 0;
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
    ++count;

  elf_elfheader (abfd)->e_phoff = bed->s->sizeof_ehdr;
  elf_elfheader (abfd)->e_phentsize = bed->s->sizeof_phdr;
  elf_elfheader (abfd)->e_phnum = count;
d1639 4
a1642 2
  if (count == 0)
    return true;
d1644 26
a1669 12
  /* If we already counted the number of program segments, make sure
     that we allocated enough space.  This happens when SIZEOF_HEADERS
     is used in a linker script.  */
  alloc = elf_tdata (abfd)->program_header_size / bed->s->sizeof_phdr;
  if (alloc != 0 && count > alloc)
    {
      ((*_bfd_error_handler)
       ("%s: Not enough room for program headers (allocated %u, need %u)",
	bfd_get_filename (abfd), alloc, count));
      bfd_set_error (bfd_error_bad_value);
      return false;
    }
d1671 2
a1672 2
  if (alloc == 0)
    alloc = count;
d1674 2
a1675 4
  phdrs = ((Elf_Internal_Phdr *)
	   bfd_alloc (abfd, alloc * sizeof (Elf_Internal_Phdr)));
  if (phdrs == NULL)
    return false;
d1677 2
a1678 2
  off = bed->s->sizeof_ehdr;
  off += alloc * bed->s->sizeof_phdr;
d1680 24
a1703 7
  filehdr_vaddr = 0;
  filehdr_paddr = 0;
  phdrs_vaddr = 0;
  phdrs_paddr = 0;
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
d1705 1
a1705 2
      unsigned int i;
      asection **secpp;
d1707 1
a1707 5
      /* If elf_segment_map is not from map_sections_to_segments, the
         sections may not be correctly ordered.  */
      if (m->count > 0)
	qsort (m->sections, (size_t) m->count, sizeof (asection *),
	       elf_sort_sections);
d1709 4
a1712 1
      p->p_type = m->p_type;
d1714 21
a1734 52
      if (m->p_flags_valid)
	p->p_flags = m->p_flags;
      else
	p->p_flags = 0;

      if (p->p_type == PT_LOAD
	  && m->count > 0
	  && (m->sections[0]->flags & SEC_LOAD) != 0)
	off += (m->sections[0]->vma - off) % bed->maxpagesize;

      if (m->count == 0)
	p->p_vaddr = 0;
      else
	p->p_vaddr = m->sections[0]->vma;

      if (m->p_paddr_valid)
	p->p_paddr = m->p_paddr;
      else if (m->count == 0)
	p->p_paddr = 0;
      else
	p->p_paddr = m->sections[0]->lma;

      if (p->p_type == PT_LOAD)
	p->p_align = bed->maxpagesize;
      else if (m->count == 0)
	p->p_align = bed->s->file_align;
      else
	p->p_align = 0;

      p->p_offset = 0;
      p->p_filesz = 0;
      p->p_memsz = 0;

      if (m->includes_filehdr)
	{
	  if (! m->p_flags_valid)
	    p->p_flags |= PF_R;
	  p->p_offset = 0;
	  p->p_filesz = bed->s->sizeof_ehdr;
	  p->p_memsz = bed->s->sizeof_ehdr;
	  if (m->count > 0)
	    {
	      BFD_ASSERT (p->p_type == PT_LOAD);
	      p->p_vaddr -= off;
	      if (! m->p_paddr_valid)
		p->p_paddr -= off;
	    }
	  if (p->p_type == PT_LOAD)
	    {
	      filehdr_vaddr = p->p_vaddr;
	      filehdr_paddr = p->p_paddr;
	    }
d1737 6
a1742 30
      if (m->includes_phdrs)
	{
	  if (! m->p_flags_valid)
	    p->p_flags |= PF_R;
	  if (m->includes_filehdr)
	    {
	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr + bed->s->sizeof_ehdr;
		  phdrs_paddr = p->p_paddr + bed->s->sizeof_ehdr;
		}
	    }
	  else
	    {
	      p->p_offset = bed->s->sizeof_ehdr;
	      if (m->count > 0)
		{
		  BFD_ASSERT (p->p_type == PT_LOAD);
		  p->p_vaddr -= off - p->p_offset;
		  if (! m->p_paddr_valid)
		    p->p_paddr -= off - p->p_offset;
		}
	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr;
		  phdrs_paddr = p->p_paddr;
		}
	    }
	  p->p_filesz += alloc * bed->s->sizeof_phdr;
	  p->p_memsz += alloc * bed->s->sizeof_phdr;
d1745 69
a1813 74
      if (p->p_type == PT_LOAD)
	{
	  if (! m->includes_filehdr && ! m->includes_phdrs)
	    p->p_offset = off;
	  else
	    {
	      file_ptr adjust;

	      adjust = off - (p->p_offset + p->p_filesz);
	      p->p_filesz += adjust;
	      p->p_memsz += adjust;
	    }
	}

      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
	{
	  asection *sec;
	  flagword flags;
	  bfd_size_type align;

	  sec = *secpp;
	  flags = sec->flags;

	  if (p->p_type == PT_LOAD)
	    {
	      bfd_vma adjust;

	      /* The section VMA must equal the file position modulo
                 the page size.  */
	      if ((flags & SEC_ALLOC) != 0)
		{
		  adjust = (sec->vma - off) % bed->maxpagesize;
		  if (adjust != 0)
		    {
		      if (i == 0)
			abort ();
		      p->p_memsz += adjust;
		      off += adjust;
		      if ((flags & SEC_LOAD) != 0)
			p->p_filesz += adjust;
		    }
		}

	      sec->filepos = off;

	      if ((flags & SEC_LOAD) != 0)
		off += sec->_raw_size;
	    }

	  p->p_memsz += sec->_raw_size;

	  if ((flags & SEC_LOAD) != 0)
	    p->p_filesz += sec->_raw_size;

	  align = 1 << bfd_get_section_alignment (abfd, sec);
	  if (align > p->p_align)
	    p->p_align = align;

	  if (! m->p_flags_valid)
	    {
	      p->p_flags |= PF_R;
	      if ((flags & SEC_CODE) != 0)
		p->p_flags |= PF_X;
	      if ((flags & SEC_READONLY) == 0)
		p->p_flags |= PF_W;
	    }
	}
    }

  /* Now that we have set the section file positions, we can set up
     the file positions for the non PT_LOAD segments.  */
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
d1815 7
a1821 20
      if (p->p_type != PT_LOAD && m->count > 0)
	{
	  BFD_ASSERT (! m->includes_filehdr && ! m->includes_phdrs);
	  p->p_offset = m->sections[0]->filepos;
	}
      if (m->count == 0)
	{
	  if (m->includes_filehdr)
	    {
	      p->p_vaddr = filehdr_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = filehdr_paddr;
	    }
	  else if (m->includes_phdrs)
	    {
	      p->p_vaddr = phdrs_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = phdrs_paddr;
	    }
	}
d1824 13
a1836 2
  /* Clear out any program headers we allocated but did not use.  */
  for (; count < alloc; count++, p++)
d1838 2
a1839 2
      memset (p, 0, sizeof *p);
      p->p_type = PT_NULL;
d1841 2
a1842 4

  elf_tdata (abfd)->phdr = phdrs;

  elf_tdata (abfd)->next_file_pos = off;
d1845 2
a1846 40
  if (bfd_seek (abfd, bed->s->sizeof_ehdr, SEEK_SET) != 0
      || bed->s->write_out_phdrs (abfd, phdrs, alloc) != 0)
    return false;

  return true;
}

/* Get the size of the program header.

   If this is called by the linker before any of the section VMA's are set, it
   can't calculate the correct value for a strange memory layout.  This only
   happens when SIZEOF_HEADERS is used in a linker script.  In this case,
   SORTED_HDRS is NULL and we assume the normal scenario of one text and one
   data segment (exclusive of .interp and .dynamic).

   ??? User written scripts must either not use SIZEOF_HEADERS, or assume there
   will be two segments.  */

static bfd_size_type
get_program_header_size (abfd)
     bfd *abfd;
{
  size_t segs;
  asection *s;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We can't return a different result each time we're called.  */
  if (elf_tdata (abfd)->program_header_size != 0)
    return elf_tdata (abfd)->program_header_size;

  if (elf_tdata (abfd)->segment_map != NULL)
    {
      struct elf_segment_map *m;

      segs = 0;
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	++segs;
      elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
      return elf_tdata (abfd)->program_header_size;
    }
d1848 2
a1849 3
  /* Assume we will need exactly two PT_LOAD segments: one for text
     and one for data.  */
  segs = 2;
d1851 1
a1851 29
  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* If we have a loadable interpreter section, we need a
	 PT_INTERP segment.  In this case, assume we also need a
	 PT_PHDR segment, although that may not be true for all
	 targets.  */
      segs += 2;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
    {
      /* We need a PT_DYNAMIC segment.  */
      ++segs;
    }

  /* Let the backend count up any program headers it might need.  */
  if (bed->elf_backend_additional_program_headers)
    {
      int a;

      a = (*bed->elf_backend_additional_program_headers) (abfd);
      if (a == -1)
	abort ();
      segs += a;
    }

  elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
  return elf_tdata (abfd)->program_header_size;
d1865 2
d1877 3
a1884 3
      /* Start after the ELF header.  */
      off = i_ehdrp->e_ehsize;

d1910 6
d1917 20
a1936 1
      Elf_Internal_Shdr **hdrpp;
d1938 12
a1949 3
      /* Assign file positions for the loaded sections based on the
         assignment of sections to segments.  */
      if (! assign_file_positions_for_segments (abfd))
d1952 5
a1956 4
      /* Assign file positions for the other sections.  */

      off = elf_tdata (abfd)->next_file_pos;
      for (i = 1, hdrpp = i_shdrpp + 1; i < i_ehdrp->e_shnum; i++, hdrpp++)
d1961 17
a1977 4
	  if (hdr->bfd_section != NULL
	      && hdr->bfd_section->filepos != 0)
	    hdr->sh_offset = hdr->bfd_section->filepos;
	  else if ((hdr->sh_flags & SHF_ALLOC) != 0)
d1979 7
a1985 7
	      ((*_bfd_error_handler)
	       ("%s: warning: allocated section `%s' not in segment",
		bfd_get_filename (abfd),
		(hdr->bfd_section == NULL
		 ? "*unknown*"
		 : hdr->bfd_section->name)));
	      off += (hdr->sh_addr - off) % bed->maxpagesize;
d1989 11
a1999 8
	  else if (hdr->sh_type == SHT_REL
		   || hdr->sh_type == SHT_RELA
		   || hdr == i_shdrpp[tdata->symtab_section]
		   || hdr == i_shdrpp[tdata->strtab_section])
	    hdr->sh_offset = -1;
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
	}		   
d2012 41
d2080 1
a2080 1
    bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;
d2298 2
a2299 4
/* Given a BFD symbol, return the index in the ELF symbol table, or -1
   on error.  */

int
d2302 1
a2302 1
     asymbol **asym_ptr_ptr;
d2304 1
a2304 1
  asymbol *asym_ptr = *asym_ptr_ptr;
d2328 1
a2328 11

  if (idx == 0)
    {
      /* This case can occur when using --strip-symbol on a symbol
         which is used in a relocation entry.  */
      (*_bfd_error_handler)
	("%s: symbol `%s' required but not present",
	 bfd_get_filename (abfd), bfd_asymbol_name (asym_ptr));
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }
d2334 1
a2334 2
	     (long) asym_ptr, asym_ptr->name, idx, flags,
	     elf_symbol_flags (flags));
a2341 105
/* Copy private BFD data.  This copies any program header information.  */

static boolean
copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
  Elf_Internal_Phdr *p;
  unsigned int i, c;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  if (elf_tdata (ibfd)->phdr == NULL)
    return true;

  iehdr = elf_elfheader (ibfd);

  mfirst = NULL;
  pm = &mfirst;

  c = elf_elfheader (ibfd)->e_phnum;
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < c; i++, p++)
    {
      unsigned int csecs;
      asection *s;
      struct elf_segment_map *m;
      unsigned int isec;

      csecs = 0;

      /* The complicated case when p_vaddr is 0 is to handle the
	 Solaris linker, which generates a PT_INTERP section with
	 p_vaddr and p_memsz set to 0.  */
      for (s = ibfd->sections; s != NULL; s = s->next)
	if (((s->vma >= p->p_vaddr
	      && (s->vma + s->_raw_size <= p->p_vaddr + p->p_memsz
		  || s->vma + s->_raw_size <= p->p_vaddr + p->p_filesz))
	     || (p->p_vaddr == 0
		 && p->p_filesz > 0
		 && (s->flags & SEC_HAS_CONTENTS) != 0
		 && (bfd_vma) s->filepos >= p->p_offset
		 && ((bfd_vma) s->filepos + s->_raw_size
		     <= p->p_offset + p->p_filesz)))
	    && (s->flags & SEC_ALLOC) != 0
	    && s->output_section != NULL)
	  ++csecs;

      m = ((struct elf_segment_map *)
	   bfd_alloc (obfd,
		      (sizeof (struct elf_segment_map)
		       + (csecs - 1) * sizeof (asection *))));
      if (m == NULL)
	return false;

      m->next = NULL;
      m->p_type = p->p_type;
      m->p_flags = p->p_flags;
      m->p_flags_valid = 1;
      m->p_paddr = p->p_paddr;
      m->p_paddr_valid = 1;

      m->includes_filehdr = (p->p_offset == 0
			     && p->p_filesz >= iehdr->e_ehsize);

      m->includes_phdrs = (p->p_offset <= (bfd_vma) iehdr->e_phoff
			   && (p->p_offset + p->p_filesz
			       >= ((bfd_vma) iehdr->e_phoff
				   + iehdr->e_phnum * iehdr->e_phentsize)));

      isec = 0;
      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  if (((s->vma >= p->p_vaddr
		&& (s->vma + s->_raw_size <= p->p_vaddr + p->p_memsz
		    || s->vma + s->_raw_size <= p->p_vaddr + p->p_filesz))
	       || (p->p_vaddr == 0
		   && p->p_filesz > 0
		   && (s->flags & SEC_HAS_CONTENTS) != 0
		   && (bfd_vma) s->filepos >= p->p_offset
		   && ((bfd_vma) s->filepos + s->_raw_size
		       <= p->p_offset + p->p_filesz)))
	      && (s->flags & SEC_ALLOC) != 0
	      && s->output_section != NULL)
	    {
	      m->sections[isec] = s->output_section;
	      ++isec;
	    }
	}
      BFD_ASSERT (isec == csecs);
      m->count = csecs;

      *pm = m;
      pm = &m->next;
    }

  elf_tdata (obfd)->segment_map = mfirst;

  return true;
}

a2357 22
  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  */
  if (elf_tdata (obfd)->segment_map == NULL
      && elf_tdata (ibfd)->phdr != NULL)
    {
      asection *s;

      /* Only set up the segments when all the sections have been set
         up.  */
      for (s = ibfd->sections; s != NULL; s = s->next)
	if (s->output_section == NULL)
	  break;
      if (s == NULL)
	{
	  if (! copy_private_bfd_data (ibfd, obfd))
	    return false;
	}
    }

d2453 4
a2456 1
      return false;
a2477 1
	int type;
a2571 7
	if ((flags & BSF_FUNCTION) != 0)
	  type = STT_FUNC;
	else if ((flags & BSF_OBJECT) != 0)
	  type = STT_OBJECT;
	else
	  type = STT_NOTYPE;

d2573 1
a2573 1
	  sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
d2578 3
a2580 1
				     type);
d2588 1
d2597 3
d2723 4
a2726 1
    return NULL;
a2786 1
  boolean found;
a2788 1
  bfd_vma low_func;
a2790 8
  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return false;
  if (found)
    return true;

a2795 1
  low_func = 0;
d2814 3
a2816 7
	  if (q->symbol.section == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
	    {
	      func = (asymbol *) q;
	      low_func = q->symbol.value;
	    }
d2839 2
a2840 1
    ret += get_program_header_size (abfd);
a2887 98

/* Try to convert a non-ELF reloc into an ELF one.  */

boolean
_bfd_elf_validate_reloc (abfd, areloc)
     bfd *abfd;
     arelent *areloc;
{
  /* Check whether we really have an ELF howto. */

  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec) 
    {
      bfd_reloc_code_real_type code;
      reloc_howto_type *howto;
      
      /* Alien reloc: Try to determine its type to replace it with an
	 equivalent ELF reloc. */

      if (areloc->howto->pc_relative)
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8_PCREL; 
	      break;
	    case 12:
	      code = BFD_RELOC_12_PCREL; 
	      break;
	    case 16:
	      code = BFD_RELOC_16_PCREL; 
	      break;
	    case 24:
	      code = BFD_RELOC_24_PCREL; 
	      break;
	    case 32:
	      code = BFD_RELOC_32_PCREL; 
	      break;
	    case 64:
	      code = BFD_RELOC_64_PCREL; 
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);

	  if (areloc->howto->pcrel_offset != howto->pcrel_offset)
	    {
	      if (howto->pcrel_offset)
		areloc->addend += areloc->address;
	      else
		areloc->addend -= areloc->address; /* addend is unsigned!! */
	    }
	}
      else
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8; 
	      break;
	    case 14:
	      code = BFD_RELOC_14; 
	      break;
	    case 16:
	      code = BFD_RELOC_16; 
	      break;
	    case 26:
	      code = BFD_RELOC_26; 
	      break;
	    case 32:
	      code = BFD_RELOC_32; 
	      break;
	    case 64:
	      code = BFD_RELOC_64; 
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);
	}

      if (howto)
	areloc->howto = howto;
      else
	goto fail;
    }

  return true;

 fail:
  (*_bfd_error_handler)
    ("%s: unsupported relocation type %s",
     bfd_get_filename (abfd), areloc->howto->name);
  bfd_set_error (bfd_error_bad_value);
  return false;
}
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a42 1
static boolean map_sections_to_segments PARAMS ((bfd *));
a213 9
  /* As a GNU extension, if the name begins with .gnu.linkonce, we
     only link a single copy of the section.  This is used to support
     g++.  g++ will emit each template expansion in its own section.
     The symbols will be defined as weak, so that multiple definitions
     are permitted.  The GNU linker extension is to actually discard
     all but one of the sections.  */
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

d230 1
a230 5
	      && phdr->p_vaddr + phdr->p_memsz >= hdr->sh_addr + hdr->sh_size
	      && ((flags & SEC_LOAD) == 0
		  || (phdr->p_offset <= hdr->sh_offset
		      && (phdr->p_offset + phdr->p_filesz
			  >= hdr->sh_offset + hdr->sh_size))))
d1042 1
a1042 2
  if ((asect->flags & SEC_ALLOC) != 0
      || asect->user_set_vma)
d1737 6
a1742 15
  /* Deal with -Ttext or something similar such that the first section
     is not adjacent to the program headers.  This is an
     approximation, since at this point we don't know exactly how many
     program headers we will need.  */
  if (count > 0)
    {
      bfd_size_type phdr_size;

      phdr_size = elf_tdata (abfd)->program_header_size;
      if (phdr_size == 0)
	phdr_size = get_elf_backend_data (abfd)->s->sizeof_phdr;
      if ((abfd->flags & D_PAGED) == 0
	  || sections[0]->lma % maxpagesize < phdr_size % maxpagesize)
	phdr_in_section = false;
    }
a1746 1
      boolean new_segment;
d1751 14
a1764 51
         segment.  */

      if (last_hdr == NULL)
	{
	  /* If we don't have a segment yet, then we don't need a new
	     one (we build the last one after this loop).  */
	  new_segment = false;
	}
      else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)
	{
	  /* If this section has a different relation between the
             virtual address and the load address, then we need a new
             segment.  */
	  new_segment = true;
	}
      else if (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
	       < hdr->lma)
	{
	  /* If putting this section in this segment would force us to
             skip a page in the segment, then we need a new segment.  */
	  new_segment = true;
	}
      else if ((abfd->flags & D_PAGED) == 0)
	{
	  /* If the file is not demand paged, which means that we
             don't require the sections to be correctly aligned in the
             file, then there is no other reason for a new segment.  */
	  new_segment = false;
	}
      else if ((last_hdr->flags & SEC_LOAD) == 0
	       && (hdr->flags & SEC_LOAD) != 0)
	{
	  /* We don't want to put a loadable section after a
             nonloadable section in the same segment.  */
	  new_segment = true;
	}
      else if (! writable
	       && (hdr->flags & SEC_READONLY) == 0
	       && (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
		   == hdr->lma))
	{
	  /* We don't want to put a writable section in a read only
             segment, unless they are on the same page in memory
             anyhow.  We already know that the last section does not
             bring us past the current section on the page, so the
             only case in which the new section is not on the same
             page as the previous section is when the previous section
             ends precisely on a page boundary.  */
	  new_segment = true;
	}
      else
a1765 8
	  /* Otherwise, we can use the same segment.  */
	  new_segment = false;
	}

      if (! new_segment)
	{
	  if ((hdr->flags & SEC_READONLY) == 0)
	    writable = true;
d1770 3
a1772 2
      /* We need a new program segment.  We must create a new program
         header holding all the sections from phdr_index until hdr.  */
a1782 2
      else
	writable = false;
a1842 7
  /* Sort by LMA.  Normally the LMA and the VMA will be the same, and
     this will do nothing.  */
  if (sec1->lma < sec2->lma)
    return -1;
  else if (sec1->lma > sec2->lma)
    return 1;

d1882 1
a1882 1
  file_ptr off, voff;
d1961 1
a1961 7
	{
	  if ((abfd->flags & D_PAGED) != 0)
	    off += (m->sections[0]->vma - off) % bed->maxpagesize;
	  else
	    off += ((m->sections[0]->vma - off)
		    % (1 << bfd_get_section_alignment (abfd, m->sections[0])));
	}
d1975 1
a1975 2
      if (p->p_type == PT_LOAD
	  && (abfd->flags & D_PAGED) != 0)
a2052 1
      voff = off;
a2060 1
	  align = 1 << bfd_get_section_alignment (abfd, sec);
d2070 1
a2070 4
		  if ((abfd->flags & D_PAGED) != 0)
		    adjust = (sec->vma - voff) % bed->maxpagesize;
		  else
		    adjust = (sec->vma - voff) % align;
a2076 1
		      voff += adjust;
a2085 2
	      if ((flags & SEC_ALLOC) != 0)
		voff += sec->_raw_size;
d2093 1
d2305 1
a2305 4
	      if ((abfd->flags & D_PAGED) != 0)
		off += (hdr->sh_addr - off) % bed->maxpagesize;
	      else
		off += (hdr->sh_addr - off) % hdr->sh_addralign;
a2399 6
      break;
    case bfd_arch_alpha:
      i_ehdrp->e_machine = EM_ALPHA;
      break;
    case bfd_arch_sh:
      i_ehdrp->e_machine = EM_SH;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a49 6
static char *elf_read PARAMS ((bfd *, long, unsigned int));
static void elf_fake_sections PARAMS ((bfd *, asection *, PTR));
static boolean assign_section_numbers PARAMS ((bfd *));
static INLINE int sym_is_global PARAMS ((bfd *, asymbol *));
static boolean elf_map_symbols PARAMS ((bfd *));
static bfd_size_type get_program_header_size PARAMS ((bfd *));
d2038 1
a2038 1
	  && (m->sections[0]->flags & SEC_ALLOC) != 0)
a2501 6
    case bfd_arch_mn10200:
      i_ehdrp->e_machine = EM_CYGNUS_MN10200;
      break;
    case bfd_arch_mn10300:
      i_ehdrp->e_machine = EM_CYGNUS_MN10300;
      break;
a2905 4

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
a56 144
/* Swap version information in and out.  The version information is
   currently size independent.  If that ever changes, this code will
   need to move into elfcode.h.  */

/* Swap in a Verdef structure.  */

void
_bfd_elf_swap_verdef_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdef *src;
     Elf_Internal_Verdef *dst;
{
  dst->vd_version = bfd_h_get_16 (abfd, src->vd_version);
  dst->vd_flags   = bfd_h_get_16 (abfd, src->vd_flags);
  dst->vd_ndx     = bfd_h_get_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = bfd_h_get_16 (abfd, src->vd_cnt);
  dst->vd_hash    = bfd_h_get_32 (abfd, src->vd_hash);
  dst->vd_aux     = bfd_h_get_32 (abfd, src->vd_aux);
  dst->vd_next    = bfd_h_get_32 (abfd, src->vd_next);
}

/* Swap out a Verdef structure.  */

void
_bfd_elf_swap_verdef_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdef *src;
     Elf_External_Verdef *dst;
{
  bfd_h_put_16 (abfd, src->vd_version, dst->vd_version);
  bfd_h_put_16 (abfd, src->vd_flags, dst->vd_flags);
  bfd_h_put_16 (abfd, src->vd_ndx, dst->vd_ndx);
  bfd_h_put_16 (abfd, src->vd_cnt, dst->vd_cnt);
  bfd_h_put_32 (abfd, src->vd_hash, dst->vd_hash);
  bfd_h_put_32 (abfd, src->vd_aux, dst->vd_aux);
  bfd_h_put_32 (abfd, src->vd_next, dst->vd_next);
}

/* Swap in a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdaux *src;
     Elf_Internal_Verdaux *dst;
{
  dst->vda_name = bfd_h_get_32 (abfd, src->vda_name);
  dst->vda_next = bfd_h_get_32 (abfd, src->vda_next);
}

/* Swap out a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdaux *src;
     Elf_External_Verdaux *dst;
{
  bfd_h_put_32 (abfd, src->vda_name, dst->vda_name);
  bfd_h_put_32 (abfd, src->vda_next, dst->vda_next);
}

/* Swap in a Verneed structure.  */

void
_bfd_elf_swap_verneed_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verneed *src;
     Elf_Internal_Verneed *dst;
{
  dst->vn_version = bfd_h_get_16 (abfd, src->vn_version);
  dst->vn_cnt     = bfd_h_get_16 (abfd, src->vn_cnt);
  dst->vn_file    = bfd_h_get_32 (abfd, src->vn_file);
  dst->vn_aux     = bfd_h_get_32 (abfd, src->vn_aux);
  dst->vn_next    = bfd_h_get_32 (abfd, src->vn_next);
}

/* Swap out a Verneed structure.  */

void
_bfd_elf_swap_verneed_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verneed *src;
     Elf_External_Verneed *dst;
{
  bfd_h_put_16 (abfd, src->vn_version, dst->vn_version);
  bfd_h_put_16 (abfd, src->vn_cnt, dst->vn_cnt);
  bfd_h_put_32 (abfd, src->vn_file, dst->vn_file);
  bfd_h_put_32 (abfd, src->vn_aux, dst->vn_aux);
  bfd_h_put_32 (abfd, src->vn_next, dst->vn_next);
}

/* Swap in a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Vernaux *src;
     Elf_Internal_Vernaux *dst;
{
  dst->vna_hash  = bfd_h_get_32 (abfd, src->vna_hash);
  dst->vna_flags = bfd_h_get_16 (abfd, src->vna_flags);
  dst->vna_other = bfd_h_get_16 (abfd, src->vna_other);
  dst->vna_name  = bfd_h_get_32 (abfd, src->vna_name);
  dst->vna_next  = bfd_h_get_32 (abfd, src->vna_next);
}

/* Swap out a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Vernaux *src;
     Elf_External_Vernaux *dst;
{
  bfd_h_put_32 (abfd, src->vna_hash, dst->vna_hash);
  bfd_h_put_16 (abfd, src->vna_flags, dst->vna_flags);
  bfd_h_put_16 (abfd, src->vna_other, dst->vna_other);
  bfd_h_put_32 (abfd, src->vna_name, dst->vna_name);
  bfd_h_put_32 (abfd, src->vna_next, dst->vna_next);
}

/* Swap in a Versym structure.  */

void
_bfd_elf_swap_versym_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Versym *src;
     Elf_Internal_Versym *dst;
{
  dst->vs_vers = bfd_h_get_16 (abfd, src->vs_vers);
}

/* Swap out a Versym structure.  */

void
_bfd_elf_swap_versym_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Versym *src;
     Elf_External_Versym *dst;
{
  bfd_h_put_16 (abfd, src->vs_vers, dst->vs_vers);
}

d106 1
a106 1
bfd_elf_mkobject (abfd)
a475 7
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
	    case DT_VERSYM: name = "VERSYM"; break;
	    case DT_VERDEF: name = "VERDEF"; break;
	    case DT_VERDEFNUM: name = "VERDEFNUM"; break;
	    case DT_VERNEED: name = "VERNEED"; break;
	    case DT_VERNEEDNUM: name = "VERNEEDNUM"; break;
a497 46
  if ((elf_dynverdef (abfd) != 0 && elf_tdata (abfd)->verdef == NULL)
      || (elf_dynverref (abfd) != 0 && elf_tdata (abfd)->verref == NULL))
    {
      if (! _bfd_elf_slurp_version_tables (abfd))
	return false;
    }

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Verdef *t;

      fprintf (f, "\nVersion definitions:\n");
      for (t = elf_tdata (abfd)->verdef; t != NULL; t = t->vd_nextdef)
	{
	  fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
		   t->vd_flags, t->vd_hash, t->vd_nodename);
	  if (t->vd_auxptr->vda_nextptr != NULL)
	    {
	      Elf_Internal_Verdaux *a;

	      fprintf (f, "\t");
	      for (a = t->vd_auxptr->vda_nextptr;
		   a != NULL;
		   a = a->vda_nextptr)
		fprintf (f, "%s ", a->vda_nodename);
	      fprintf (f, "\n");
	    }
	}
    }

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Verneed *t;

      fprintf (f, "\nVersion References:\n");
      for (t = elf_tdata (abfd)->verref; t != NULL; t = t->vn_nextref)
	{
	  Elf_Internal_Vernaux *a;

	  fprintf (f, "  required from %s:\n", t->vn_filename);
	  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	    fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
		     a->vna_flags, a->vna_other, a->vna_nodename);
	}
    }

a506 1

d508 2
a509 2
bfd_elf_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
a538 58

	/* If we have version information, print it.  */
	if (elf_tdata (abfd)->dynversym_section != 0
	    && (elf_tdata (abfd)->dynverdef_section != 0
		|| elf_tdata (abfd)->dynverref_section != 0))
	  {
	    unsigned int vernum;
	    const char *version_string;

	    vernum = ((elf_symbol_type *) symbol)->version & VERSYM_VERSION;

	    if (vernum == 0)
	      version_string = "";
	    else if (vernum == 1)
	      version_string = "Base";
	    else if (vernum <= elf_tdata (abfd)->cverdefs)
	      version_string =
		elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
	    else
	      {
		Elf_Internal_Verneed *t;

		version_string = "";
		for (t = elf_tdata (abfd)->verref;
		     t != NULL;
		     t = t->vn_nextref)
		  {
		    Elf_Internal_Vernaux *a;

		    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		      {
			if (a->vna_other == vernum)
			  {
			    version_string = a->vna_nodename;
			    break;
			  }
		      }
		  }
	      }

	    if ((((elf_symbol_type *) symbol)->version & VERSYM_HIDDEN) == 0)
	      fprintf (file, "  %-11s", version_string);
	    else
	      {
		int i;

		fprintf (file, " (%s)", version_string);
		for (i = 10 - strlen (version_string); i > 0; --i)
		  putc (' ', file);
	      }
	  }

	/* If the st_other field is not zero, print it.  */
	if (((elf_symbol_type *) symbol)->internal_elf_sym.st_other != 0)
	  fprintf (file, " 0x%02x",
		   ((unsigned int)
		    ((elf_symbol_type *) symbol)->internal_elf_sym.st_other));

a577 1
      ret->verinfo.verdef = NULL;
a578 1
      ret->other = 0;
a893 18
    case SHT_GNU_verdef:
      elf_dynverdef (abfd) = shindex;
      elf_tdata (abfd)->dynverdef_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

    case SHT_GNU_versym:
      elf_dynversym (abfd) = shindex;
      elf_tdata (abfd)->dynversym_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

    case SHT_GNU_verneed:
      elf_dynverref (abfd) = shindex;
      elf_tdata (abfd)->dynverref_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
      break;

d1108 1
a1108 1
  else if (strncmp (asect->name, ".note", 5) == 0)
a1112 31
  else if (strcmp (asect->name, ".gnu.version") == 0)
    {
      this_hdr->sh_type = SHT_GNU_versym;
      this_hdr->sh_entsize = sizeof (Elf_External_Versym);
    }
  else if (strcmp (asect->name, ".gnu.version_d") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verdef;
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
         cverdefs.  The linker will set cverdefs, but sh_info will be
         zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverdefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverdefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverdefs);
    }
  else if (strcmp (asect->name, ".gnu.version_r") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verneed;
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
         cverrefs.  The linker will set cverrefs, but sh_info will be
         zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverrefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverrefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverrefs);
    }
a1317 2
	case SHT_GNU_verneed:
	case SHT_GNU_verdef:
d1319 1
a1319 2
	     used for the dynamic entries, or the symbol table, or the
	     version strings.  */
a1325 1
	case SHT_GNU_versym:
d1327 1
a1327 1
	     this hash table or version table is for.  */
a1892 24
  /* For each loadable .note section, add a PT_NOTE segment.  We don't
     use bfd_get_section_by_name, because if we link together
     nonloadable .note sections and loadable .note sections, we will
     generate two .note sections in the output file.  FIXME: Using
     names for section types is bogus anyhow.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
	{
	  m = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_NOTE;
	  m->count = 1;
	  m->sections[0] = s;

	  *pm = m;
	  pm = &m->next;
	}
    }

a2306 10
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
	{
	  /* We need a PT_NOTE segment.  */
	  ++segs;
	}
    }

a2507 6
    case bfd_arch_d10v:
      i_ehdrp->e_machine = EM_CYGNUS_D10V;
      break;
    case bfd_arch_m32r:
      i_ehdrp->e_machine = EM_CYGNUS_M32R;
      break;
d2799 1
a2799 1
		       + ((size_t) csecs - 1) * sizeof (asection *))));
d2893 1
a2893 3
      || ihdr->sh_type == SHT_DYNSYM
      || ihdr->sh_type == SHT_GNU_verneed
      || ihdr->sh_type == SHT_GNU_verdef)
d3135 1
a3135 5
	if (type_ptr != NULL)
	  sym.st_other = type_ptr->internal_elf_sym.st_other;
	else
	  sym.st_other = 0;

d3215 1
a3215 4
  if (! get_elf_backend_data (abfd)->s->slurp_reloc_table (abfd,
							   section,
							   symbols,
							   false))
a3246 258
/* Return the size required for the dynamic reloc entries.  Any
   section that was actually installed in the BFD, and has type
   SHT_REL or SHT_RELA, and uses the dynamic symbol table, is
   considered to be a dynamic reloc section.  */

long
_bfd_elf_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  long ret;
  asection *s;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  ret = sizeof (arelent *);
  for (s = abfd->sections; s != NULL; s = s->next)
    if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	&& (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	    || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
      ret += ((s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize)
	      * sizeof (arelent *));

  return ret;
}

/* Canonicalize the dynamic relocation entries.  Note that we return
   the dynamic relocations as a single block, although they are
   actually associated with particular sections; the interface, which
   was designed for SunOS style shared libraries, expects that there
   is only one set of dynamic relocs.  Any section that was actually
   installed in the BFD, and has type SHT_REL or SHT_RELA, and uses
   the dynamic symbol table, is considered to be a dynamic reloc
   section.  */

long
_bfd_elf_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
{
  boolean (*slurp_relocs) PARAMS ((bfd *, asection *, asymbol **, boolean));
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, true))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read in the version information.  */

boolean
_bfd_elf_slurp_version_tables (abfd)
     bfd *abfd;
{
  bfd_byte *contents = NULL;

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verdef *everdef;
      Elf_Internal_Verdef *iverdef;
      unsigned int i;

      hdr = &elf_tdata (abfd)->dynverdef_hdr;

      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verdef)));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = hdr->sh_info;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;

      everdef = (Elf_External_Verdef *) contents;
      iverdef = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++, iverdef++)
	{
	  Elf_External_Verdaux *everdaux;
	  Elf_Internal_Verdaux *iverdaux;
	  unsigned int j;

	  _bfd_elf_swap_verdef_in (abfd, everdef, iverdef);

	  iverdef->vd_bfd = abfd;

	  iverdef->vd_auxptr = ((Elf_Internal_Verdaux *)
				bfd_alloc (abfd,
					   (iverdef->vd_cnt
					    * sizeof (Elf_Internal_Verdaux))));
	  if (iverdef->vd_auxptr == NULL)
	    goto error_return;

	  everdaux = ((Elf_External_Verdaux *)
		      ((bfd_byte *) everdef + iverdef->vd_aux));
	  iverdaux = iverdef->vd_auxptr;
	  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
	    {
	      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);

	      iverdaux->vda_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 iverdaux->vda_name);
	      if (iverdaux->vda_nodename == NULL)
		goto error_return;

	      if (j + 1 < iverdef->vd_cnt)
		iverdaux->vda_nextptr = iverdaux + 1;
	      else
		iverdaux->vda_nextptr = NULL;

	      everdaux = ((Elf_External_Verdaux *)
			  ((bfd_byte *) everdaux + iverdaux->vda_next));
	    }

	  iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;

	  if (i + 1 < hdr->sh_info)
	    iverdef->vd_nextdef = iverdef + 1;
	  else
	    iverdef->vd_nextdef = NULL;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdef->vd_next));
	}

      free (contents);
      contents = NULL;
    }

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verneed *everneed;
      Elf_Internal_Verneed *iverneed;
      unsigned int i;

      hdr = &elf_tdata (abfd)->dynverref_hdr;

      elf_tdata (abfd)->verref =
	((Elf_Internal_Verneed *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verneed)));
      if (elf_tdata (abfd)->verref == NULL)
	goto error_return;

      elf_tdata (abfd)->cverrefs = hdr->sh_info;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;

      everneed = (Elf_External_Verneed *) contents;
      iverneed = elf_tdata (abfd)->verref;
      for (i = 0; i < hdr->sh_info; i++, iverneed++)
	{
	  Elf_External_Vernaux *evernaux;
	  Elf_Internal_Vernaux *ivernaux;
	  unsigned int j;

	  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);

	  iverneed->vn_bfd = abfd;

	  iverneed->vn_filename =
	    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					     iverneed->vn_file);
	  if (iverneed->vn_filename == NULL)
	    goto error_return;

	  iverneed->vn_auxptr =
	    ((Elf_Internal_Vernaux *)
	     bfd_alloc (abfd,
			iverneed->vn_cnt * sizeof (Elf_Internal_Vernaux)));

	  evernaux = ((Elf_External_Vernaux *)
		      ((bfd_byte *) everneed + iverneed->vn_aux));
	  ivernaux = iverneed->vn_auxptr;
	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
	    {
	      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);

	      ivernaux->vna_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 ivernaux->vna_name);
	      if (ivernaux->vna_nodename == NULL)
		goto error_return;

	      if (j + 1 < iverneed->vn_cnt)
		ivernaux->vna_nextptr = ivernaux + 1;
	      else
		ivernaux->vna_nextptr = NULL;

	      evernaux = ((Elf_External_Vernaux *)
			  ((bfd_byte *) evernaux + ivernaux->vna_next));
	    }

	  if (i + 1 < hdr->sh_info)
	    iverneed->vn_nextref = iverneed + 1;
	  else
	    iverneed->vn_nextref = NULL;

	  everneed = ((Elf_External_Verneed *)
		      ((bfd_byte *) everneed + iverneed->vn_next));
	}

      free (contents);
      contents = NULL;
    }

  return true;

 error_return:
  if (contents == NULL)
    free (contents);
  return false;
}

a3269 30
}

/* Return whether a symbol name implies a local symbol.  Most targets
   use this function for the is_local_label_name entry point, but some
   override it.  */

boolean
_bfd_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  /* Normal local symbols start with ``.L''.  */
  if (name[0] == '.' && name[1] == 'L')
    return true;

  /* At least some SVR4 compilers (e.g., UnixWare 2.1 cc) generate
     DWARF debugging symbols starting with ``..''.  */
  if (name[0] == '.' && name[1] == '.')
    return true;

  /* gcc will sometimes generate symbols beginning with ``_.L_'' when
     emitting DWARF debugging output.  I suspect this is actually a
     small bug in gcc (it calls ASM_OUTPUT_LABEL when it should call
     ASM_GENERATE_INTERNAL_LABEL, and this causes the leading
     underscore to be emitted on some ELF targets).  For ease of use,
     we treat such symbols as local.  */
  if (name[0] == '_' && name[1] == '.' && name[2] == 'L' && name[3] == '_')
    return true;

  return false;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d48 1
a48 1
static boolean swap_out_syms PARAMS ((bfd *, struct bfd_strtab_hash **, int));
a55 1
static boolean elfcore_read_notes PARAMS ((bfd *, bfd_vma, bfd_vma));
d202 2
a203 2
   cause invalid hash tables to be generated.  */

d205 2
a206 2
bfd_elf_hash (namearg)
     const char *namearg;
a207 1
  const unsigned char *name = (const unsigned char *) namearg;
d218 1
a218 3
	  /* The ELF ABI says `h &= ~g', but this is equivalent in
	     this case and on some machines one insn instead of two.  */
	  h ^= g;
a264 8
boolean
bfd_elf_mkcorefile (abfd)
     bfd * abfd;
{
  /* I think this can be done just like an object file. */
  return bfd_elf_mkobject (abfd);
}

a307 12
  if (strindex >= hdr->sh_size)
    {
      (*_bfd_error_handler)
	(_("%s: invalid string offset %u >= %lu for section `%s'"),
	 bfd_get_filename (abfd), strindex, (unsigned long) hdr->sh_size,
	 ((shindex == elf_elfheader(abfd)->e_shstrndx
	   && strindex == hdr->sh_name)
	  ? ".shstrtab"
	  : elf_string_from_elf_strtab (abfd, hdr->sh_name)));
      return "";
    }

d382 1
a382 3
      /* Look through the phdrs to see if we need to adjust the lma.
         If all the p_paddr fields are zero, we ignore them, since
         some ELF linkers produce such output.  */
d386 9
a394 7
	  if (phdr->p_paddr != 0)
	    break;
	}
      if (i < elf_elfheader (abfd)->e_phnum)
	{
	  phdr = elf_tdata (abfd)->phdr;
	  for (i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
d396 2
a397 13
	      if (phdr->p_type == PT_LOAD
		  && phdr->p_vaddr != phdr->p_paddr
		  && phdr->p_vaddr <= hdr->sh_addr
		  && (phdr->p_vaddr + phdr->p_memsz
		      >= hdr->sh_addr + hdr->sh_size)
		  && ((flags & SEC_LOAD) == 0
		      || (phdr->p_offset <= (bfd_vma) hdr->sh_offset
			  && (phdr->p_offset + phdr->p_filesz
			      >= hdr->sh_offset + hdr->sh_size))))
		{
		  newsect->lma += phdr->p_paddr - phdr->p_vaddr;
		  break;
		}
d436 1
a436 2
      shstrtab = bfd_elf_get_str_section
	(abfd, elf_elfheader (abfd)->e_shstrndx);
d473 1
a473 1
     bfd *abfd ATTRIBUTE_UNUSED;
d476 1
a476 1
     PTR data ATTRIBUTE_UNUSED;
d479 1
a479 1
     char **error_message ATTRIBUTE_UNUSED;
d510 1
a510 1
      fprintf (f, _("\nProgram Header:\n"));
d558 1
a558 1
      fprintf (f, _("\nDynamic Section:\n"));
d660 1
a660 1
      fprintf (f, _("\nVersion definitions:\n"));
d683 1
a683 1
      fprintf (f, _("\nVersion References:\n"));
d688 1
a688 1
	  fprintf (f, _("  required from %s:\n"), t->vn_filename);
a725 4
	CONST char *name = NULL;
	struct elf_backend_data *bed;
	unsigned char st_other;
	
d727 1
a727 11

	bed = get_elf_backend_data (abfd);
	if (bed->elf_backend_print_symbol_all)
	    name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);

	if (name == NULL)
	  {
	    name = symbol->name;  
	    bfd_print_symbol_vandf ((PTR) file, symbol);
	  }

d790 4
a793 13
	st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;
	
	switch (st_other)
	  {
	  case 0: break;
	  case STV_INTERNAL:  fprintf (file, " .internal");  break;
	  case STV_HIDDEN:    fprintf (file, " .hidden");    break;
	  case STV_PROTECTED: fprintf (file, " .protected"); break;
	  default:
	    /* Some other non-defined flags are also present, so print
	       everything hex.  */
	    fprintf (file, " 0x%02x", (unsigned int) st_other);
	  }
d795 1
a795 1
	fprintf (file, " %s", name);
d831 2
a832 2
      ret->got.offset = (bfd_vma) -1;
      ret->plt.offset = (bfd_vma) -1;
a834 3
      ret->vtable_entries_used = NULL;
      ret->vtable_entries_size = 0;
      ret->vtable_parent = NULL;
a846 52
/* Copy data from an indirect symbol to its direct symbol, hiding the
   old indirect symbol.  */

void
_bfd_elf_link_hash_copy_indirect (dir, ind)
     struct elf_link_hash_entry *dir, *ind;
{
  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */

  dir->elf_link_hash_flags |=
    (ind->elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));

  /* Copy over the global and procedure linkage table offset entries.
     These may have been already set up by a check_relocs routine.  */
  if (dir->got.offset == (bfd_vma) -1)
    {
      dir->got.offset = ind->got.offset;
      ind->got.offset = (bfd_vma) -1;
    }
  BFD_ASSERT (ind->got.offset == (bfd_vma) -1);

  if (dir->plt.offset == (bfd_vma) -1)
    {
      dir->plt.offset = ind->plt.offset;
      ind->plt.offset = (bfd_vma) -1;
    }
  BFD_ASSERT (ind->plt.offset == (bfd_vma) -1);

  if (dir->dynindx == -1)
    {
      dir->dynindx = ind->dynindx;
      dir->dynstr_index = ind->dynstr_index;
      ind->dynindx = -1;
      ind->dynstr_index = 0;
    }
  BFD_ASSERT (ind->dynindx == -1);
}

void
_bfd_elf_link_hash_hide_symbol(h)
     struct elf_link_hash_entry *h;
{
  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  h->dynindx = -1;
  h->plt.offset = (bfd_vma) -1;
}

a865 1
  table->dynlocal = NULL;
d907 1
a907 1
   the linker ELF emulation code.  */
d911 1
a911 1
     bfd *abfd ATTRIBUTE_UNUSED;
a931 85

/* Get the list of DT_NEEDED entries from a BFD.  This is a hook for
   the ELF linker emulation code.  */

boolean
bfd_elf_get_bfd_needed_list (abfd, pneeded)
     bfd *abfd;
     struct bfd_link_needed_list **pneeded;
{
  asection *s;
  bfd_byte *dynbuf = NULL;
  int elfsec;
  unsigned long link;
  bfd_byte *extdyn, *extdynend;
  size_t extdynsize;
  void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));

  *pneeded = NULL;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || bfd_get_format (abfd) != bfd_object)
    return true;

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s == NULL || s->_raw_size == 0)
    return true;

  dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
  if (dynbuf == NULL)
    goto error_return;

  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				  s->_raw_size))
    goto error_return;

  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
  if (elfsec == -1)
    goto error_return;

  link = elf_elfsections (abfd)[elfsec]->sh_link;

  extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
  swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

  extdyn = dynbuf;
  extdynend = extdyn + s->_raw_size;
  for (; extdyn < extdynend; extdyn += extdynsize)
    {
      Elf_Internal_Dyn dyn;

      (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);

      if (dyn.d_tag == DT_NULL)
	break;

      if (dyn.d_tag == DT_NEEDED)
	{
	  const char *string;
	  struct bfd_link_needed_list *l;

	  string = bfd_elf_string_from_elf_section (abfd, link,
						    dyn.d_un.d_val);
	  if (string == NULL)
	    goto error_return;

	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, sizeof *l);
	  if (l == NULL)
	    goto error_return;

	  l->by = abfd;
	  l->name = string;
	  l->next = *pneeded;
	  *pneeded = l;
	}
    }

  free (dynbuf);

  return true;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return false;
}
a1082 9
	/* Check for a bogus link to avoid crashing.  */
	if (hdr->sh_link >= ehdr->e_shnum)
	  {
	    ((*_bfd_error_handler)
	     (_("%s: invalid link %lu for reloc section %s (index %u)"),
	      bfd_get_filename (abfd), hdr->sh_link, name, shindex));
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
	  }

a1146 5
	/* In the section to which the relocations apply, mark whether
	   its relocations are of the REL or RELA variety.  */
	if (hdr->sh_size != 0)
	  elf_section_data (target_sect)->use_rela_p
	    = (hdr->sh_type == SHT_RELA);
d1206 1
a1206 1
  sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, sizeof (*sdata));
d1210 1
a1210 5

  /* Indicate whether or not this section should use RELA relocations.  */
  sdata->use_rela_p 
    = get_elf_backend_data (abfd)->default_use_rela_p;

d1237 1
a1237 1
_bfd_elf_make_section_from_phdr (abfd, hdr, index, typename)
a1240 1
     const char *typename;
d1247 4
a1250 4
  split = ((hdr->p_memsz > 0)
	    && (hdr->p_filesz > 0)
	    && (hdr->p_memsz > hdr->p_filesz));
  sprintf (namebuf, "%s%d%s", typename, index, split ? "a" : "");
d1281 1
a1281 1
      sprintf (namebuf, "%s%db", typename, index);
a1304 83
boolean
bfd_section_from_phdr (abfd, hdr, index)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
     int index;
{
  struct elf_backend_data *bed;

  switch (hdr->p_type)
    {
    case PT_NULL:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "null");

    case PT_LOAD:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "load");

    case PT_DYNAMIC:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "dynamic");

    case PT_INTERP:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "interp");

    case PT_NOTE:
      if (! _bfd_elf_make_section_from_phdr (abfd, hdr, index, "note"))
	return false;
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
	return false;
      return true;

    case PT_SHLIB:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "shlib");

    case PT_PHDR:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "phdr");

    default:
      /* Check for any processor-specific program segment types.
         If no handler for them, default to making "segment" sections. */
      bed = get_elf_backend_data (abfd);
      if (bed->elf_backend_section_from_phdr)
	return (*bed->elf_backend_section_from_phdr) (abfd, hdr, index);
      else
	return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "segment");
    }
}

/* Initialize REL_HDR, the section-header for new section, containing
   relocations against ASECT.  If USE_RELA_P is true, we use RELA
   relocations; otherwise, we use REL relocations.  */

boolean
_bfd_elf_init_reloc_shdr (abfd, rel_hdr, asect, use_rela_p)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *asect;
     boolean use_rela_p;
{
  char *name;
  struct elf_backend_data *bed;

  bed = get_elf_backend_data (abfd);
  name = bfd_alloc (abfd, sizeof ".rela" + strlen (asect->name));
  if (name == NULL)
    return false;
  sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", asect->name);
  rel_hdr->sh_name =
    (unsigned int) _bfd_stringtab_add (elf_shstrtab (abfd), name,
				       true, false);
  if (rel_hdr->sh_name == (unsigned int) -1)
    return false;
  rel_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
  rel_hdr->sh_entsize = (use_rela_p
			 ? bed->s->sizeof_rela
			 : bed->s->sizeof_rel);
  rel_hdr->sh_addralign = bed->s->file_align;
  rel_hdr->sh_flags = 0;
  rel_hdr->sh_addr = 0;
  rel_hdr->sh_size = 0;
  rel_hdr->sh_offset = 0;

  return true;
}

d1360 1
a1360 1
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
d1373 1
a1373 1
	   && get_elf_backend_data (abfd)->may_use_rela_p)
d1379 1
a1379 1
	   && get_elf_backend_data (abfd)->may_use_rel_p)
d1440 6
a1445 2
  if (bed->elf_backend_fake_sections)
    (*bed->elf_backend_fake_sections) (abfd, this_hdr, asect);
d1448 33
a1480 9
     SHT_REL[A] section.  If two relocation sections are required for
     this section, it is up to the processor-specific back-end to
     create the other.  */ 
  if ((asect->flags & SEC_RELOC) != 0
      && !_bfd_elf_init_reloc_shdr (abfd, 
				    &elf_section_data (asect)->rel_hdr,
				    asect, 
				    elf_section_data (asect)->use_rela_p))
    *failedptr = true;
a1507 5

      if (d->rel_hdr2)
	d->rel_idx2 = section_number++;
      else
	d->rel_idx2 = 0;
d1514 1
a1514 1
  if (bfd_get_symcount (abfd) > 0)
d1541 1
a1541 1
  if (bfd_get_symcount (abfd) > 0)
a1555 2
      if (d->rel_idx2 != 0)
	i_shdrp[d->rel_idx2] = d->rel_hdr2;
a1566 5
      if (d->rel_idx2 != 0)
	{
	  d->rel_hdr2->sh_link = t->symtab_section;
	  d->rel_hdr2->sh_info = d->this_idx;
	}
a1682 1
  asymbol *sym;
d1705 2
a1706 4
      sym = syms[idx];
      
      if ((sym->flags & BSF_SECTION_SYM) != 0
	  && sym->value == 0)
d1710 1
a1710 2
	  sec = sym->section;

a1716 1
		  
a1717 13

		  /* Empty sections in the input files may have had a section
		     symbol created for them.  (See the comment near the end of
		     _bfd_generic_link_output_symbols in linker.c).  If the linker
		     script discards such sections then we will reach this point.
		     Since we know that we cannot avoid this case, we detect it
		     and skip the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the linker
		     testsuite test ld-scripts/weak.exp for an ELF port that uses
		     the generic linker.  */
		  if (sec->owner == NULL)
		    continue;

d1727 2
d1745 1
a1745 1
 _("creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n"),
a1876 4
  /* Post process the headers if necessary.  */
  if (bed->elf_backend_post_process_headers)
    (*bed->elf_backend_post_process_headers) (abfd, link_info);

d1886 1
a1886 1
  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
d1888 1
a1888 4
      /* Non-zero if doing a relocatable link.  */
      int relocatable_p = ! (abfd->flags & (EXEC_P | DYNAMIC));

      if (! swap_out_syms (abfd, &strtab, relocatable_p))
d1907 1
a1907 1
  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
d1988 1
a1988 1
  boolean phdr_in_segment = true;
a2080 1
	  || sections[0]->lma < phdr_size
d2082 1
a2082 1
	phdr_in_segment = false;
d2109 1
a2109 1
	       < BFD_ALIGN (hdr->lma, maxpagesize))
d2115 7
a2128 7
      else if ((abfd->flags & D_PAGED) == 0)
	{
	  /* If the file is not demand paged, which means that we
             don't require the sections to be correctly aligned in the
             file, then there is no other reason for a new segment.  */
	  new_segment = false;
	}
d2160 1
a2160 1
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
d2174 1
a2174 1
      phdr_in_segment = false;
d2180 1
a2180 1
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
d2240 1
a2240 1
/* Sort sections by address.  */
d2250 1
a2250 3
  /* Sort by LMA first, since this is the address used to
     place the section into a segment.  */
  if (sec1->lma < sec2->lma)
d2252 1
a2252 1
  else if (sec1->lma > sec2->lma)
d2255 3
a2257 3
  /* Then sort by VMA.  Normally the LMA and the VMA will be
     the same, and this will do nothing.  */
  if (sec1->vma < sec2->vma)
d2259 1
a2259 1
  else if (sec1->vma > sec2->vma)
d2267 4
a2270 6
    {
      if (TOEND (sec2))
	return sec1->target_index - sec2->target_index;
      else
	return 1;
    }
d2336 1
a2336 1
       (_("%s: Not enough room for program headers (allocated %u, need %u)"),
a2356 1

d2371 5
a2375 1
      p->p_flags = m->p_flags;
d2384 2
a2385 15
	    {
	      bfd_size_type align;

	      align = 0;
	      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
		{
		  bfd_size_type secalign;

		  secalign = bfd_get_section_alignment (abfd, *secpp);
		  if (secalign > align)
		    align = secalign;
		}

	      off += (m->sections[0]->vma - off) % (1 << align);
	    }
a2421 9

	      if (p->p_vaddr < (bfd_vma) off)
		{
		  _bfd_error_handler (_("%s: Not enough room for program headers, try linking with -N"),
				      bfd_get_filename (abfd));
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}

a2436 1

a2447 1

a2454 1

a2459 2
	      else
		phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;
a2460 1

d2465 1
a2465 2
      if (p->p_type == PT_LOAD
	  || (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core))
a2479 1

a2489 14
	  /* The section may have artificial alignment forced by a
	     link script.  Notice this case by the gap between the
	     cumulative phdr vma and the section's vma.  */
	  if (p->p_vaddr + p->p_memsz < sec->vma)
	    {
	      bfd_vma adjust = sec->vma - (p->p_vaddr + p->p_memsz);

	      p->p_memsz += adjust;
	      off += adjust;
	      voff += adjust;
	      if ((flags & SEC_LOAD) != 0)
		p->p_filesz += adjust;
	    }

d2492 1
a2492 1
	      bfd_signed_vma adjust;
d2494 3
a2496 7
	      if ((flags & SEC_LOAD) != 0)
		{
		  adjust = sec->lma - (p->p_paddr + p->p_memsz);
		  if (adjust < 0)
		    adjust = 0;
		}
	      else if ((flags & SEC_ALLOC) != 0)
a2497 5
		  /* The section VMA must equal the file position
		     modulo the page size.  FIXME: I'm not sure if
		     this adjustment is really necessary.  We used to
		     not have the SEC_LOAD case just above, and then
		     this was necessary, but now I'm not sure.  */
d2502 1
a2502 7
		}
	      else
		adjust = 0;

	      if (adjust != 0)
		{
		  if (i == 0)
d2504 7
a2510 8
		      (* _bfd_error_handler)
			(_("Error: First section in segment (%s) starts at 0x%x"),
			 bfd_section_name (abfd, sec), sec->lma);
		      (* _bfd_error_handler)
			(_("       whereas segment starts at 0x%x"),
			 p->p_paddr);

		      return false;
a2511 5
		  p->p_memsz += adjust;
		  off += adjust;
		  voff += adjust;
		  if ((flags & SEC_LOAD) != 0)
		    p->p_filesz += adjust;
d2516 1
a2516 6
	      /* We check SEC_HAS_CONTENTS here because if NOLOAD is
                 used in a linker script we may have a section with
                 SEC_LOAD clear but which is supposed to have
                 contents.  */
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_HAS_CONTENTS) != 0)
a2517 1

d2522 1
a2522 21
	  if (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core)
	    {
	      if (i == 0)	/* the actual "note" segment */
		{		/* this one actually contains everything. */
		  sec->filepos = off;
		  p->p_filesz = sec->_raw_size;
		  off += sec->_raw_size;
		  voff = off;
		}
	      else	/* fake sections -- don't need to be written */
		{
		  sec->filepos = 0;
		  sec->_raw_size = 0;
		  flags = sec->flags = 0;	/* no contents */
		}
	      p->p_memsz = 0;
	      p->p_align = 1;
	    }
	  else
	    {
	      p->p_memsz += sec->_raw_size;
d2524 2
a2525 2
	      if ((flags & SEC_LOAD) != 0)
		p->p_filesz += sec->_raw_size;
d2527 2
a2528 4
	      if (align > p->p_align
		  && (p->p_type != PT_LOAD || (abfd->flags & D_PAGED) == 0))
		p->p_align = align;
	    }
d2688 1
a2688 2
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      && bfd_get_format (abfd) != bfd_core)
d2715 1
a2715 1

d2743 1
a2743 1
	       (_("%s: warning: allocated section `%s' not in segment"),
d2762 1
a2762 1
	}
d2780 1
a2780 1
  Elf_Internal_Phdr *i_phdrp = 0; /* Program header table, internal form */
a2804 3
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NONE;
  i_ehdrp->e_ident[EI_ABIVERSION] = 0;

a2811 2
  else if (bfd_get_format (abfd) == bfd_core)
    i_ehdrp->e_type = ET_CORE;
d2822 1
a2822 1
	i_ehdrp->e_machine = EM_SPARCV9;
a2825 3
    case bfd_arch_i370:
      i_ehdrp->e_machine = EM_S370;
      break;
a2837 3
    case bfd_arch_i960:
      i_ehdrp->e_machine = EM_960;
      break;
a2855 25
    case bfd_arch_d30v:
      i_ehdrp->e_machine = EM_CYGNUS_D30V;
      break;
    case bfd_arch_fr30:
      i_ehdrp->e_machine = EM_CYGNUS_FR30;
      break;
    case bfd_arch_mcore:
      i_ehdrp->e_machine = EM_MCORE;
      break;
    case bfd_arch_avr:
      i_ehdrp->e_machine = EM_AVR;
      break;
    case bfd_arch_v850:
      switch (bfd_get_mach (abfd))
	{
	default:
	case 0:               i_ehdrp->e_machine = EM_CYGNUS_V850; break;
	}
      break;
   case bfd_arch_arc:
      i_ehdrp->e_machine = EM_CYGNUS_ARC;
      break;
   case bfd_arch_arm:
      i_ehdrp->e_machine = EM_ARM;
      break;
a2864 3
    case bfd_arch_pj:
      i_ehdrp->e_machine = EM_PJ;
      break;
d2955 2
a2956 2
      && ! _bfd_elf_compute_section_file_positions
             (abfd, (struct bfd_link_info *) NULL))
a2965 1

a2994 7
boolean
_bfd_elf_write_corefile_contents (abfd)
     bfd *abfd;
{
  /* Hopefully this can be done just like an object file. */
  return _bfd_elf_write_object_contents (abfd);
}
a3034 2
  bfd_set_error (bfd_error_nonrepresentable_section);

d3076 1
a3076 1
	(_("%s: symbol `%s' required but not present"),
d3085 1
a3085 1
	     _("elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n"),
a3104 1
  struct elf_segment_map *m;
d3106 1
a3106 3
  unsigned int i;
  unsigned int num_segments;
  boolean phdr_included = false;
d3120 2
a3121 33
  num_segments = elf_elfheader (ibfd)->e_phnum;

#define IS_CONTAINED_BY(addr, len, bottom, phdr)		 	\
	  ((addr) >= (bottom)				 	  	\
	   && (   ((addr) + (len)) <= ((bottom) + (phdr)->p_memsz)	\
	       || ((addr) + (len)) <= ((bottom) + (phdr)->p_filesz)))

  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc. */

#define IS_COREFILE_NOTE(p, s)                                          \
	    (p->p_type == PT_NOTE                                       \
	     && bfd_get_format (ibfd) == bfd_core                       \
	     && s->vma == 0 && s->lma == 0                              \
	     && (bfd_vma) s->filepos >= p->p_offset                     \
	     && (bfd_vma) s->filepos + s->_raw_size                     \
	     <= p->p_offset + p->p_filesz)

  /* The complicated case when p_vaddr is 0 is to handle the Solaris
     linker, which generates a PT_INTERP section with p_vaddr and
     p_memsz set to 0.  */

#define IS_SOLARIS_PT_INTERP(p, s)					\
	    (p->p_vaddr == 0						\
	     && p->p_filesz > 0						\
	     && (s->flags & SEC_HAS_CONTENTS) != 0			\
	     && s->_raw_size > 0					\
	     && (bfd_vma) s->filepos >= p->p_offset			\
	     && ((bfd_vma) s->filepos + s->_raw_size			\
		     <= p->p_offset + p->p_filesz))

  /* Scan through the segments specified in the program header
     of the input BFD.  */
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < num_segments; i++, p++)
d3125 1
a3125 2
      asection **sections;
      asection *os;
d3127 1
a3127 9
      bfd_vma matching_lma;
      bfd_vma suggested_lma;
      unsigned int j;

      /* For each section in the input BFD, decide if it should be
	 included in the current segment.  A section will be included
	 if it is within the address space of the segment, and it is
	 an allocated segment, and there is an output section
	 associated with it.  */
d3129 4
d3134 12
a3145 9
	if (s->output_section != NULL)
	  {
	    if ((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	      ++csecs;
	    else if (IS_COREFILE_NOTE (p, s))
	      ++csecs;
	  }
a3146 2
      /* Allocate a segment map big enough to contain all of the
	 sections we have selected.  */
d3154 3
a3156 5
      /* Initialise the fields of the segment map.  Default to
	 using the physical address of the segment in the input BFD.  */
      m->next          = NULL;
      m->p_type        = p->p_type;
      m->p_flags       = p->p_flags;
d3158 1
a3158 1
      m->p_paddr       = p->p_paddr;
a3160 2
      /* Determine if this segment contains the ELF file header
	 and if it contains the program headers themselves.  */
d3164 4
a3167 69
      m->includes_phdrs = 0;

      if (! phdr_included || p->p_type != PT_LOAD)
	{
	  m->includes_phdrs =
	    (p->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (p->p_offset + p->p_filesz
		 >= ((bfd_vma) iehdr->e_phoff
		     + iehdr->e_phnum * iehdr->e_phentsize)));
	  if (p->p_type == PT_LOAD && m->includes_phdrs)
	    phdr_included = true;
	}

      if (csecs == 0)
	{
	  /* Special segments, such as the PT_PHDR segment, may contain
	     no sections, but ordinary, loadable segments should contain
	     something.  */

	  if (p->p_type == PT_LOAD)
	      _bfd_error_handler
		(_("%s: warning: Empty loadable segment detected\n"),
		 bfd_get_filename (ibfd));

	  m->count = 0;
	  *pm = m;
	  pm = &m->next;

	  continue;
	}

      /* Now scan the sections in the input BFD again and attempt
	 to add their corresponding output sections to the segment map.
	 The problem here is how to handle an output section which has
	 been moved (ie had its LMA changed).  There are four possibilities:

	 1. None of the sections have been moved.
	    In this case we can continue to use the segment LMA from the
	    input BFD.

	 2. All of the sections have been moved by the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section.

	 3. Some of the sections have been moved, others have not.
	    In this case those sections which have not been moved can be
	    placed in the current segment which will have to have its size,
	    and possibly its LMA changed, and a new segment or segments will
	    have to be created to contain the other sections.

	 4. The sections have been moved, but not be the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section and we will have to create a new segment
	    or segments to contain the other sections.

	 In order to save time, we allocate an array to hold the section
	 pointers that we are interested in.  As these sections get assigned
	 to a segment, they are removed from this array.  */

      sections = (asection **) bfd_malloc (sizeof (asection *) * csecs);
      if (sections == NULL)
	return false;

      /* Step One: Scan for segment vs section LMA conflicts.
	 Also add the sections to the section array allocated above.
	 Also add the sections to the current segment.  In the common
	 case, where the sections have not been moved, this means that
	 we have completely filled the segment, and there is nothing
	 more to do.  */
d3170 1
a3170 4
      matching_lma = 0;
      suggested_lma = 0;

      for (j = 0, s = ibfd->sections; s != NULL; s = s->next)
d3172 11
a3182 7
	  os = s->output_section;

	  if ((((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	       || IS_COREFILE_NOTE (p, s))
	      && os != NULL)
d3184 2
a3185 33
	      sections[j++] = s;

	      /* The Solaris native linker always sets p_paddr to 0.
		 We try to catch that case here, and set it to the
		 correct value.  */
	      if (p->p_paddr == 0
		  && p->p_vaddr != 0
		  && isec == 0
		  && os->lma != 0
		  && (os->vma == (p->p_vaddr
				  + (m->includes_filehdr
				     ? iehdr->e_ehsize
				     : 0)
				  + (m->includes_phdrs
				     ? iehdr->e_phnum * iehdr->e_phentsize
				     : 0))))
		m->p_paddr = p->p_vaddr;

	      /* Match up the physical address of the segment with the
		 LMA address of the output section.  */
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
		{
		  if (matching_lma == 0)
		    matching_lma = os->lma;

		  /* We assume that if the section fits within the segment
		     that it does not overlap any other section within that
		     segment.  */
		  m->sections[isec++] = os;
		}
	      else if (suggested_lma == 0)
		suggested_lma = os->lma;
d3188 2
d3191 2
a3192 161
      BFD_ASSERT (j == csecs);

      /* Step Two: Adjust the physical address of the current segment,
	 if necessary.  */
      if (isec == csecs)
	{
	  /* All of the sections fitted within the segment as currently
	     specified.  This is the default case.  Add the segment to
	     the list of built segments and carry on to process the next
	     program header in the input BFD.  */
	  m->count = csecs;
	  *pm = m;
	  pm = &m->next;

	  free (sections);
	  continue;
	}
      else
	{
	  if (matching_lma != 0)
	    {
	      /* At least one section fits inside the current segment.
		 Keep it, but modify its physical address to match the
		 LMA of the first section that fitted.  */

	      m->p_paddr = matching_lma;
	    }
	  else
	    {
	      /* None of the sections fitted inside the current segment.
		 Change the current segment's physical address to match
		 the LMA of the first section.  */

	      m->p_paddr = suggested_lma;
	    }

	  /* Offset the segment physical address from the lma to allow
	     for space taken up by elf headers.  */
	  if (m->includes_filehdr)
	    m->p_paddr -= iehdr->e_ehsize;

	  if (m->includes_phdrs)
	    m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
	}

      /* Step Three: Loop over the sections again, this time assigning
	 those that fit to the current segment and remvoing them from the
	 sections array; but making sure not to leave large gaps.  Once all
	 possible sections have been assigned to the current segment it is
	 added to the list of built segments and if sections still remain
	 to be assigned, a new segment is constructed before repeating
	 the loop.  */
      isec = 0;
      do
	{
	  m->count = 0;
	  suggested_lma = 0;

	  /* Fill the current segment with sections that fit.  */
	  for (j = 0; j < csecs; j++)
	    {
	      s = sections[j];

	      if (s == NULL)
		continue;

	      os = s->output_section;

	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
		{
		  if (m->count == 0)
		    {
		      /* If the first section in a segment does not start at
			 the beginning of the segment, then something is wrong.  */
		      if (os->lma != (m->p_paddr
				      + (m->includes_filehdr
					 ? iehdr->e_ehsize : 0)
				      + (m->includes_phdrs
					 ? iehdr->e_phnum * iehdr->e_phentsize
					 : 0)))
			abort ();
		    }
		  else
		    {
		      asection * prev_sec;
		      bfd_vma maxpagesize;

		      prev_sec = m->sections[m->count - 1];
		      maxpagesize = get_elf_backend_data (obfd)->maxpagesize;

		      /* If the gap between the end of the previous section
			 and the start of this section is more than maxpagesize
			 then we need to start a new segment.  */
		      if (BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
			  < BFD_ALIGN (os->lma, maxpagesize))
			{
			  if (suggested_lma == 0)
			    suggested_lma = os->lma;

			  continue;
			}
		    }

		  m->sections[m->count++] = os;
		  ++isec;
		  sections[j] = NULL;
		}
	      else if (suggested_lma == 0)
		suggested_lma = os->lma;
	    }

	  BFD_ASSERT (m->count > 0);

	  /* Add the current segment to the list of built segments.  */
	  *pm = m;
	  pm = &m->next;

	  if (isec < csecs)
	    {
	      /* We still have not allocated all of the sections to
		 segments.  Create a new segment here, initialise it
		 and carry on looping.  */

	      m = ((struct elf_segment_map *)
		   bfd_alloc (obfd,
			      (sizeof (struct elf_segment_map)
			       + ((size_t) csecs - 1) * sizeof (asection *))));
	      if (m == NULL)
		return false;

	      /* Initialise the fields of the segment map.  Set the physical
		 physical address to the LMA of the first section that has
		 not yet been assigned.  */

	      m->next             = NULL;
	      m->p_type           = p->p_type;
	      m->p_flags          = p->p_flags;
	      m->p_flags_valid    = 1;
	      m->p_paddr          = suggested_lma;
	      m->p_paddr_valid    = 1;
	      m->includes_filehdr = 0;
	      m->includes_phdrs   = 0;
	    }
	}
      while (isec < csecs);

      free (sections);
    }

  /* The Solaris linker creates program headers in which all the
     p_paddr fields are zero.  When we try to objcopy or strip such a
     file, we get confused.  Check for this case, and if we find it
     reset the p_paddr_valid fields.  */
  for (m = mfirst; m != NULL; m = m->next)
    if (m->p_paddr != 0)
      break;
  if (m == NULL)
    {
      for (m = mfirst; m != NULL; m = m->next)
	m->p_paddr_valid = 0;
a3196 27
#if 0
  /* Final Step: Sort the segments into ascending order of physical address. */
  if (mfirst != NULL)
    {
      struct elf_segment_map* prev;

      prev = mfirst;
      for (m = mfirst->next; m != NULL; prev = m, m = m->next)
	{
	  /* Yes I know - its a bubble sort....*/
	  if (m->next != NULL && (m->next->p_paddr < m->p_paddr))
	    {
	      /* swap m and m->next */
	      prev->next = m->next;
	      m->next = m->next->next;
	      prev->next->next = m;

	      /* restart loop. */
	      m = mfirst;
	    }
	}
    }
#endif

#undef IS_CONTAINED_BY
#undef IS_SOLARIS_PT_INTERP
#undef IS_COREFILE_NOTE
d3226 4
a3229 6
      /* Only set up the segments if there are no more SEC_ALLOC
         sections.  FIXME: This won't do the right thing if objcopy is
         used to remove the last SEC_ALLOC section, since objcopy
         won't call this routine in that case.  */
      for (s = isec->next; s != NULL; s = s->next)
	if ((s->flags & SEC_ALLOC) != 0)
a3248 3
  elf_section_data (osec)->use_rela_p
    = elf_section_data (isec)->use_rela_p;

d3303 1
a3303 1
swap_out_syms (abfd, sttp, relocatable_p)
a3305 1
     int relocatable_p;
d3377 1
a3377 2
	if ((flags & BSF_SECTION_SYM) == 0
	    && bfd_is_com_section (syms[idx]->section))
d3388 2
a3389 2
	    sym.st_shndx = _bfd_elf_section_from_bfd_section
	      (abfd, syms[idx]->section);
d3401 1
a3401 3
	    /* Don't add in the section vma for relocatable output.  */
	    if (! relocatable_p)
	      value += sec->vma;
d3463 1
a3463 8
        /* Processor-specific types */
        if (type_ptr != NULL
	    && bed->elf_backend_get_symbol_type)
          type = (*bed->elf_backend_get_symbol_type) (&type_ptr->internal_elf_sym, type);

	if (flags & BSF_SECTION_SYM)
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	else if (bfd_is_com_section (syms[idx]->section))
d3470 2
d3554 1
a3554 1
     bfd *abfd ATTRIBUTE_UNUSED;
d3592 1
a3592 2
  long symcount = get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, false);
d3604 1
a3604 2
  return get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, true);
d3883 1
a3883 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d3896 1
a3896 1
     bfd *abfd ATTRIBUTE_UNUSED;
d3922 2
a3923 2
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
a3969 10
  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr, 
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0))
    return true;

a4000 1
	case STT_NOTYPE:
d4046 2
a4047 2
      && ! _bfd_elf_compute_section_file_positions
      (abfd, (struct bfd_link_info *) NULL))
d4062 3
a4064 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d4089 1
a4089 1
  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec)
d4093 1
a4093 1

d4102 1
a4102 1
	      code = BFD_RELOC_8_PCREL;
d4105 1
a4105 1
	      code = BFD_RELOC_12_PCREL;
d4108 1
a4108 1
	      code = BFD_RELOC_16_PCREL;
d4111 1
a4111 1
	      code = BFD_RELOC_24_PCREL;
d4114 1
a4114 1
	      code = BFD_RELOC_32_PCREL;
d4117 1
a4117 1
	      code = BFD_RELOC_64_PCREL;
d4138 1
a4138 1
	      code = BFD_RELOC_8;
d4141 1
a4141 1
	      code = BFD_RELOC_14;
d4144 1
a4144 1
	      code = BFD_RELOC_16;
d4147 1
a4147 1
	      code = BFD_RELOC_26;
d4150 1
a4150 1
	      code = BFD_RELOC_32;
d4153 1
a4153 1
	      code = BFD_RELOC_64;
d4172 1
a4172 1
    (_("%s: unsupported relocation type %s"),
a4175 636
}

boolean
_bfd_elf_close_and_cleanup (abfd)
     bfd *abfd;
{
  if (bfd_get_format (abfd) == bfd_object)
    {
      if (elf_shstrtab (abfd) != NULL)
	_bfd_stringtab_free (elf_shstrtab (abfd));
    }

  return _bfd_generic_close_and_cleanup (abfd);
}

/* For Rel targets, we encode meaningful data for BFD_RELOC_VTABLE_ENTRY
   in the relocation's offset.  Thus we cannot allow any sort of sanity
   range-checking to interfere.  There is nothing else to do in processing
   this reloc.  */

bfd_reloc_status_type
_bfd_elf_rel_vtable_reloc_fn (abfd, re, symbol, data, is, obfd, errmsg)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *re ATTRIBUTE_UNUSED;
     struct symbol_cache_entry *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *is ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     char **errmsg ATTRIBUTE_UNUSED;
{
  return bfd_reloc_ok;
}


/* Elf core file support.  Much of this only works on native
   toolchains, since we rely on knowing the
   machine-dependent procfs structure in order to pick
   out details about the corefile. */

#ifdef HAVE_SYS_PROCFS_H
# include <sys/procfs.h>
#endif


/* Define offsetof for those systems which lack it. */

#ifndef offsetof
# define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif


/* FIXME: this is kinda wrong, but it's what gdb wants. */

static int
elfcore_make_pid (abfd)
     bfd* abfd;
{
  return ((elf_tdata (abfd)->core_lwpid << 16)
	  + (elf_tdata (abfd)->core_pid));
}


/* If there isn't a section called NAME, make one, using
   data from SECT.  Note, this function will generate a
   reference to NAME, so you shouldn't deallocate or
   overwrite it. */

static boolean
elfcore_maybe_make_sect (abfd, name, sect)
     bfd* abfd;
     char* name;
     asection* sect;
{
  asection* sect2;

  if (bfd_get_section_by_name (abfd, name) != NULL)
    return true;

  sect2 = bfd_make_section (abfd, name);
  if (sect2 == NULL)
    return false;

  sect2->_raw_size = sect->_raw_size;
  sect2->filepos = sect->filepos;
  sect2->flags = sect->flags;
  sect2->alignment_power = sect->alignment_power;
  return true;
}


/* prstatus_t exists on:
     solaris 2.[567]
     linux 2.[01] + glibc
     unixware 4.2
*/

#if defined (HAVE_PRSTATUS_T)
static boolean
elfcore_grok_prstatus (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  prstatus_t prstat;
  char buf[100];
  char* name;
  asection* sect;

  if (note->descsz != sizeof (prstat))
    return true;

  memcpy (&prstat, note->descdata, sizeof (prstat));

  elf_tdata (abfd)->core_signal = prstat.pr_cursig;
  elf_tdata (abfd)->core_pid = prstat.pr_pid;

  /* pr_who exists on:
       solaris 2.[567]
       unixware 4.2
     pr_who doesn't exist on:
       linux 2.[01]
  */
#if defined (HAVE_PRSTATUS_T_PR_WHO)
  elf_tdata (abfd)->core_lwpid = prstat.pr_who;
#endif

  /* Make a ".reg/999" section. */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return false;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return false;
  sect->_raw_size = sizeof (prstat.pr_reg);
  sect->filepos = note->descpos + offsetof (prstatus_t, pr_reg);
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
    return false;

  return true;
}
#endif /* defined (HAVE_PRSTATUS_T) */


/* Create a pseudosection containing the exact contents of NOTE.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents: the contents of NOTE.  */

static boolean
elfcore_make_note_pseudosection (abfd, name, note)
     bfd* abfd;
     char *name;
     Elf_Internal_Note* note;
{
  char buf[100];
  char *threaded_name;
  asection* sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  threaded_name = bfd_alloc (abfd, strlen (buf) + 1);
  if (threaded_name == NULL)
    return false;
  strcpy (threaded_name, buf);

  sect = bfd_make_section (abfd, threaded_name);
  if (sect == NULL)
    return false;
  sect->_raw_size = note->descsz;
  sect->filepos = note->descpos;
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, name, sect))
    return false;

  return true;
}


/* There isn't a consistent prfpregset_t across platforms,
   but it doesn't matter, because we don't have to pick this
   data structure apart. */
static boolean
elfcore_grok_prfpreg (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  return elfcore_make_note_pseudosection (abfd, ".reg2", note);
}


/* Linux dumps the Intel SSE regs in a note named "LINUX" with a note
   type of 5 (NT_PRXFPREG).  Just include the whole note's contents
   literally.  */
static boolean
elfcore_grok_prxfpreg (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);
}


#if defined (HAVE_PRPSINFO_T)
# define elfcore_psinfo_t prpsinfo_t
#endif

#if defined (HAVE_PSINFO_T)
# define elfcore_psinfo_t psinfo_t
#endif


#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)

/* return a malloc'ed copy of a string at START which is at
   most MAX bytes long, possibly without a terminating '\0'.
   the copy will always have a terminating '\0'. */

static char*
elfcore_strndup (abfd, start, max)
     bfd* abfd;
     char* start;
     int max;
{
  char* dup;
  char* end = memchr (start, '\0', max);
  int len;

  if (end == NULL)
    len = max;
  else
    len = end - start;

  dup = bfd_alloc (abfd, len + 1);
  if (dup == NULL)
    return NULL;

  memcpy (dup, start, len);
  dup[len] = '\0';

  return dup;
}

static boolean
elfcore_grok_psinfo (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  elfcore_psinfo_t psinfo;

  if (note->descsz != sizeof (elfcore_psinfo_t))
    return true;

  memcpy (&psinfo, note->descdata, note->descsz);

  elf_tdata (abfd)->core_program
    = elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));

  elf_tdata (abfd)->core_command
    = elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists. */

  {
    char* command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return true;
}
#endif /* defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T) */


#if defined (HAVE_PSTATUS_T)
static boolean
elfcore_grok_pstatus (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  pstatus_t pstat;

  if (note->descsz != sizeof (pstat))
    return true;

  memcpy (&pstat, note->descdata, sizeof (pstat));

  elf_tdata (abfd)->core_pid = pstat.pr_pid;

  /* Could grab some more details from the "representative"
     lwpstatus_t in pstat.pr_lwp, but we'll catch it all in an
     NT_LWPSTATUS note, presumably. */

  return true;
}
#endif /* defined (HAVE_PSTATUS_T) */


#if defined (HAVE_LWPSTATUS_T)
static boolean
elfcore_grok_lwpstatus (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  lwpstatus_t lwpstat;
  char buf[100];
  char* name;
  asection* sect;

  if (note->descsz != sizeof (lwpstat))
    return true;

  memcpy (&lwpstat, note->descdata, sizeof (lwpstat));

  elf_tdata (abfd)->core_lwpid = lwpstat.pr_lwpid;
  elf_tdata (abfd)->core_signal = lwpstat.pr_cursig;

  /* Make a ".reg/999" section. */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return false;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return false;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.gregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.gregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_REG)
  sect->_raw_size = sizeof (lwpstat.pr_reg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_reg);
#endif

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (!elfcore_maybe_make_sect (abfd, ".reg", sect))
    return false;

  /* Make a ".reg2/999" section */

  sprintf (buf, ".reg2/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return false;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return false;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.fpregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.fpregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_FPREG)
  sect->_raw_size = sizeof (lwpstat.pr_fpreg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_fpreg);
#endif

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (!elfcore_maybe_make_sect (abfd, ".reg2", sect))
    return false;

  return true;
}
#endif /* defined (HAVE_LWPSTATUS_T) */

#if defined (HAVE_WIN32_PSTATUS_T)
static boolean
elfcore_grok_win32pstatus (abfd, note)
     bfd * abfd;
     Elf_Internal_Note * note;
{
  char buf[30];
  char * name;
  asection * sect;
  win32_pstatus_t pstatus;

  if (note->descsz < sizeof (pstatus))
    return true;

  memcpy (& pstatus, note->descdata, note->descsz);
  
  switch (pstatus.data_type) 
    {
    case NOTE_INFO_PROCESS:
      /* FIXME: need to add ->core_command.  */
      elf_tdata (abfd)->core_signal = pstatus.data.process_info.signal;
      elf_tdata (abfd)->core_pid = pstatus.data.process_info.pid;
      break ;

    case NOTE_INFO_THREAD:
      /* Make a ".reg/999" section.  */
      sprintf (buf, ".reg/%d", pstatus.data.thread_info.tid);
      
      name = bfd_alloc (abfd, strlen (buf) + 1);
      if (name == NULL)
        return false;
      
      strcpy (name, buf);

      sect = bfd_make_section (abfd, name);
      if (sect == NULL)
        return false;
      
      sect->_raw_size = sizeof (pstatus.data.thread_info.thread_context);
      sect->filepos = note->descpos + offsetof (struct win32_pstatus,
						data.thread_info.thread_context);
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 2;

      if (pstatus.data.thread_info.is_active_thread)
	if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
	  return false;
      break;

    case NOTE_INFO_MODULE:
      /* Make a ".module/xxxxxxxx" section.  */
      sprintf (buf, ".module/%08x" , pstatus.data.module_info.base_address);
      
      name = bfd_alloc (abfd, strlen (buf) + 1);
      if (name == NULL)
	return false;
      
      strcpy (name, buf);

      sect = bfd_make_section (abfd, name);
      
      if (sect == NULL)
	return false;
      
      sect->_raw_size = note->descsz;
      sect->filepos = note->descpos;
      sect->flags = SEC_HAS_CONTENTS;
      sect->alignment_power = 2;
      break;

    default:
      return true;
    }

  return true;
}
#endif /* HAVE_WIN32_PSTATUS_T */

static boolean
elfcore_grok_note (abfd, note)
     bfd* abfd;
     Elf_Internal_Note* note;
{
  switch (note->type)
    {
    default:
      return true;

#if defined (HAVE_PRSTATUS_T)
    case NT_PRSTATUS:
      return elfcore_grok_prstatus (abfd, note);
#endif

#if defined (HAVE_PSTATUS_T)
    case NT_PSTATUS:
      return elfcore_grok_pstatus (abfd, note);
#endif

#if defined (HAVE_LWPSTATUS_T)
    case NT_LWPSTATUS:
      return elfcore_grok_lwpstatus (abfd, note);
#endif

    case NT_FPREGSET:		/* FIXME: rename to NT_PRFPREG */
      return elfcore_grok_prfpreg (abfd, note);

#if defined (HAVE_WIN32_PSTATUS_T)
    case NT_WIN32PSTATUS:	
      return elfcore_grok_win32pstatus (abfd, note);
#endif

  case NT_PRXFPREG:		/* Linux SSE extension */
      if (note->namesz == 5
	  && ! strcmp (note->namedata, "LINUX"))
	return elfcore_grok_prxfpreg (abfd, note);
      else
	return true;

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
    case NT_PRPSINFO:
    case NT_PSINFO:
      return elfcore_grok_psinfo (abfd, note);
#endif
    }
}


static boolean
elfcore_read_notes (abfd, offset, size)
     bfd* abfd;
     bfd_vma offset;
     bfd_vma size;
{
  char* buf;
  char* p;

  if (size <= 0)
    return true;

  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
    return false;

  buf = bfd_malloc ((size_t) size);
  if (buf == NULL)
    return false;

  if (bfd_read (buf, size, 1, abfd) != size)
    {
    error:
      free (buf);
      return false;
    }

  p = buf;
  while (p < buf + size)
    {
      /* FIXME: bad alignment assumption. */
      Elf_External_Note* xnp = (Elf_External_Note*) p;
      Elf_Internal_Note in;

      in.type = bfd_h_get_32 (abfd, (bfd_byte *) xnp->type);

      in.namesz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->namesz);
      in.namedata = xnp->name;

      in.descsz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->descsz);
      in.descdata = in.namedata + BFD_ALIGN (in.namesz, 4);
      in.descpos = offset + (in.descdata - buf);

      if (! elfcore_grok_note (abfd, &in))
	goto error;

      p = in.descdata + BFD_ALIGN (in.descsz, 4);
    }

  free (buf);
  return true;
}


/* FIXME: This function is now unnecessary.  Callers can just call
   bfd_section_from_phdr directly.  */

boolean
_bfd_elfcore_section_from_phdr (abfd, phdr, sec_num)
     bfd* abfd;
     Elf_Internal_Phdr* phdr;
     int sec_num;
{
  if (! bfd_section_from_phdr (abfd, phdr, sec_num))
    return false;

  return true;
}



/* Providing external access to the ELF program header table.  */

/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */
long
bfd_get_elf_phdr_upper_bound (abfd)
     bfd *abfd;
{
  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return (elf_elfheader (abfd)->e_phnum
	  * sizeof (Elf_Internal_Phdr));
}


/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */
int
bfd_get_elf_phdrs (abfd, phdrs)
     bfd *abfd;
     void *phdrs;
{
  int num_phdrs;

  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  num_phdrs = elf_elfheader (abfd)->e_phnum;
  memcpy (phdrs, elf_tdata (abfd)->phdr, 
	  num_phdrs * sizeof (Elf_Internal_Phdr));

  return num_phdrs;
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@a4490 2
      Elf_Internal_Verdef *iverdefarr;
      Elf_Internal_Verdef iverdefmem;
a4491 1
      unsigned int maxidx;
d4495 8
a4509 24
      /* We know the number of entries in the section but not the maximum
	 index.  Therefore we have to run through all entries and find
	 the maximum.  */
      everdef = (Elf_External_Verdef *) contents;
      maxidx = 0;
      for (i = 0; i < hdr->sh_info; ++i)
	{
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  if ((iverdefmem.vd_ndx & VERSYM_VERSION) > maxidx)
	    maxidx = iverdefmem.vd_ndx & VERSYM_VERSION;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdefmem.vd_next));
	}

      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, maxidx * sizeof (Elf_Internal_Verdef)));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = maxidx;

d4511 2
a4512 2
      iverdefarr = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++)
d4518 1
a4518 4
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];
	  memcpy (iverdef, &iverdefmem, sizeof (Elf_Internal_Verdef));
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a33 2
/* For sparc64-cross-sparc32.  */
#define _SYSCALL32
a56 4
static boolean elf_find_function PARAMS ((bfd *, asection *,
                                         asymbol **,
                                         bfd_vma, const char **,
                                         const char **));
d230 1
a230 1
   buffer.  */
d234 1
a234 1
     bfd *abfd;
d255 1
a255 1
     bfd *abfd;
d257 2
a258 2
  /* This just does initialization.  */
  /* coff_mkobject zalloc's space for tdata.coff_obj_data ...  */
d263 2
a264 2
  /* Since everything is done at close time, do we need any
     initialization?  */
d271 1
a271 1
     bfd *abfd;
d273 1
a273 1
  /* I think this can be done just like an object file.  */
d279 1
a279 1
     bfd *abfd;
d294 1
a294 1
      /* No cached one, attempt to read, and cache what we read.  */
d305 1
a305 1
     bfd *abfd;
a345 1
  struct elf_backend_data *bed;
d384 4
a387 17
  {
    static const char *debug_sec_names [] =
    {
      ".debug",
      ".gnu.linkonce.wi.",
      ".line",
      ".stab"
    };
    int i;

    for (i = sizeof (debug_sec_names) / sizeof (debug_sec_names[0]); i--;)
      if (strncmp (name, debug_sec_names[i], strlen (debug_sec_names[i])) == 0)
	break;

    if (i >= 0)
      flags |= SEC_DEBUGGING;
  }
a397 5
  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_flags)
    if (! bed->elf_backend_section_flags (&flags, hdr))
      return false;

d460 1
a460 1
     bfd *abfd;
d500 1
d656 2
a657 26
	    case DT_BIND_NOW: name = "BIND_NOW"; break;
	    case DT_INIT_ARRAY: name = "INIT_ARRAY"; break;
	    case DT_FINI_ARRAY: name = "FINI_ARRAY"; break;
	    case DT_INIT_ARRAYSZ: name = "INIT_ARRAYSZ"; break;
	    case DT_FINI_ARRAYSZ: name = "FINI_ARRAYSZ"; break;
	    case DT_RUNPATH: name = "RUNPATH"; stringp = true; break;
	    case DT_FLAGS: name = "FLAGS"; break;
	    case DT_PREINIT_ARRAY: name = "PREINIT_ARRAY"; break;
	    case DT_PREINIT_ARRAYSZ: name = "PREINIT_ARRAYSZ"; break;
	    case DT_CHECKSUM: name = "CHECKSUM"; break;
	    case DT_PLTPADSZ: name = "PLTPADSZ"; break;
	    case DT_MOVEENT: name = "MOVEENT"; break;
	    case DT_MOVESZ: name = "MOVESZ"; break;
	    case DT_FEATURE: name = "FEATURE"; break;
	    case DT_POSFLAG_1: name = "POSFLAG_1"; break;
	    case DT_SYMINSZ: name = "SYMINSZ"; break;
	    case DT_SYMINENT: name = "SYMINENT"; break;
	    case DT_CONFIG: name = "CONFIG"; stringp = true; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = true; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = true; break;
	    case DT_PLTPAD: name = "PLTPAD"; break;
	    case DT_MOVETAB: name = "MOVETAB"; break;
	    case DT_SYMINFO: name = "SYMINFO"; break;
	    case DT_RELACOUNT: name = "RELACOUNT"; break;
	    case DT_RELCOUNT: name = "RELCOUNT"; break;
	    case DT_FLAGS_1: name = "FLAGS_1"; break;
a662 3
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
	    case DT_USED: name = "USED"; break;
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
d761 2
a762 2
	const char *section_name;
	const char *name = NULL;
d765 1
a765 1

d770 1
a770 1
	  name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);
d774 1
a774 1
	    name = symbol->name;
d841 1
a841 1

d953 1
a953 2
_bfd_elf_link_hash_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d957 1
a958 2
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
a977 1
  table->runpath = NULL;
a1020 10
void
bfd_elf_set_dt_needed_soname (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dt_soname (abfd) = name;
}

a1033 13
/* Get the list of DT_RPATH/DT_RUNPATH entries for a link.  This is a
   hook for the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_runpath_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
    return NULL;
  return elf_hash_table (info)->runpath;
}

d1158 1
a1158 1
/* Create a new bfd section from an ELF section header.  */
d1331 2
a1332 4
	   try.  We just present it as a normal section.  We also
	   can't use it as a reloc section if it points to the null
	   section.  */
	if (hdr->sh_link != elf_onesymtab (abfd) || hdr->sh_info == SHN_UNDEF)
d1352 1
a1352 1
	target_sect->reloc_count += NUM_SHDR_ENTRIES (hdr);
d1426 1
a1426 1
  sdata->use_rela_p
d1489 1
a1489 1
	     may be data.  */
d1561 1
a1561 1
         If no handler for them, default to making "segment" sections.  */
d1609 1
d1723 4
a1726 1
	   && ((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0))
d1729 4
a1732 1
    this_hdr->sh_type = SHT_PROGBITS;
d1748 1
a1748 1
     create the other.  */
d1750 1
a1750 1
      && !_bfd_elf_init_reloc_shdr (abfd,
d1752 1
a1752 1
				    asect,
d1769 1
d1904 1
a1904 1
		    4 + 2 * bfd_get_arch_size (abfd) / 8;
d1993 1
a1993 1

d2007 1
a2007 1

d2906 2
a2907 4
	      /* The actual "note" segment has i == 0.
		 This is the one that actually contains everything.  */
	      if (i == 0)
		{
d2913 1
a2913 1
	      else
a2914 1
		  /* Fake sections -- don't need to be written.  */
d2917 1
a2917 1
		  flags = sec->flags = 0;
d3231 1
a3231 1
      if (bfd_get_arch_size (abfd) == 64)
d3240 1
a3240 13
      if (bfd_get_arch_size (abfd) == 64)
	i_ehdrp->e_machine = EM_X86_64;
      else
	i_ehdrp->e_machine = EM_386;
      break;
    case bfd_arch_ia64:
      i_ehdrp->e_machine = EM_IA_64;
      break;
    case bfd_arch_m68hc11:
      i_ehdrp->e_machine = EM_68HC11;
      break;
    case bfd_arch_m68hc12:
      i_ehdrp->e_machine = EM_68HC12;
d3291 1
a3291 1
    case bfd_arch_arc:
d3294 1
a3294 1
    case bfd_arch_arm:
d3309 1
a3309 4
    case bfd_arch_cris:
      i_ehdrp->e_machine = EM_CRIS;
      break;
      /* Also note that EM_M32, AT&T WE32100 is unknown to bfd.  */
d3316 1
a3316 1
  /* No program header, for now.  */
d3321 1
a3321 1
  /* Each bfd section is section header entry.  */
d3325 1
a3325 1
  /* If we're building an executable, we'll need a program header table.  */
d3328 1
a3328 1
      /* It all happens later.  */
d3333 1
a3333 1
	 Elf_Internal_Phdrs.  */
d3413 1
a3413 1
  /* After writing the headers, we need to write the sections too...  */
d3444 1
a3444 1
  /* Hopefully this can be done just like an object file.  */
d3447 1
a3447 3

/* Given a section, search the header to find them.  */

d3556 8
a3563 12
  Elf_Internal_Ehdr *       iehdr;
  struct elf_segment_map *  map;
  struct elf_segment_map *  map_first;
  struct elf_segment_map ** pointer_to_map;
  Elf_Internal_Phdr *       segment;
  asection *                section;
  unsigned int              i;
  unsigned int              num_segments;
  boolean                   phdr_included = false;
  bfd_vma                   maxpagesize;
  struct elf_segment_map *  phdr_adjust_seg = NULL;
  unsigned int              phdr_adjust_num = 0;
d3574 2
a3575 2
  map_first = NULL;
  pointer_to_map = &map_first;
a3577 1
  maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
d3579 13
a3591 26
  /* Returns the end address of the segment + 1.  */
#define SEGMENT_END(segment, start) 			\
  (start + (segment->p_memsz > segment->p_filesz 	\
   ? segment->p_memsz : segment->p_filesz))

  /* Returns true if the given section is contained within
     the given segment.  VMA addresses are compared.  */
#define IS_CONTAINED_BY_VMA(section, segment)		\
  (section->vma >= segment->p_vaddr			\
   && (section->vma + section->_raw_size)		\
   <= (SEGMENT_END (segment, segment->p_vaddr)))

  /* Returns true if the given section is contained within
     the given segment.  LMA addresses are compared.  */
#define IS_CONTAINED_BY_LMA(section, segment, base)	\
    (section->lma >= base				\
     && (section->lma + section->_raw_size)		\
     <= SEGMENT_END (segment, base))

  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc.  */
#define IS_COREFILE_NOTE(p, s)                          \
	    (p->p_type == PT_NOTE                       \
	     && bfd_get_format (ibfd) == bfd_core       \
	     && s->vma == 0 && s->lma == 0              \
	     && (bfd_vma) s->filepos >= p->p_offset     \
	     && (bfd_vma) s->filepos + s->_raw_size     \
d3597 8
a3604 7
#define IS_SOLARIS_PT_INTERP(p, s)			\
	    (   p->p_vaddr == 0				\
	     && p->p_filesz > 0				\
	     && (s->flags & SEC_HAS_CONTENTS) != 0	\
	     && s->_raw_size > 0			\
	     && (bfd_vma) s->filepos >= p->p_offset	\
	     && ((bfd_vma) s->filepos + s->_raw_size	\
a3606 26
  /* Decide if the given section should be included in the given segment.
     A section will be included if:
       1. It is within the address space of the segment,
       2. It is an allocated segment,
       3. There is an output section associated with it,
       4. The section has not already been allocated to a previous segment.  */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment)	\
  ((((IS_CONTAINED_BY_VMA (section, segment) 		\
      || IS_SOLARIS_PT_INTERP (segment, section))	\
     && (section->flags & SEC_ALLOC) != 0)		\
    || IS_COREFILE_NOTE (segment, section))		\
   && section->output_section != NULL			\
   && section->segment_mark == false)

  /* Returns true iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)		\
    (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))

  /* Returns true iff seg1 and seg2 overlap.  */
#define SEGMENT_OVERLAPS(seg1, seg2)			\
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2) || SEGMENT_AFTER_SEGMENT (seg2, seg1)))

  /* Initialise the segment mark field.  */
  for (section = ibfd->sections; section != NULL; section = section->next)
    section->segment_mark = false;

d3608 2
a3609 6
     of the input BFD.  For this first scan we look for overlaps
     in the loadable segments.  These can be created by wierd
     parameters to objcopy.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
d3611 7
a3618 1
      Elf_Internal_Phdr *segment2;
d3620 16
a3635 74
      if (segment->p_type != PT_LOAD)
	continue;

      /* Determine if this segment overlaps any previous segments.  */
      for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2 ++)
	{
	  bfd_signed_vma extra_length;

	  if (segment2->p_type != PT_LOAD
	      || ! SEGMENT_OVERLAPS (segment, segment2))
	    continue;

	  /* Merge the two segments together.  */
	  if (segment2->p_vaddr < segment->p_vaddr)
	    {
	      /* Extend SEGMENT2 to include SEGMENT and then delete
                 SEGMENT.  */
	      extra_length =
		SEGMENT_END (segment, segment->p_vaddr)
		- SEGMENT_END (segment2, segment2->p_vaddr);

	      if (extra_length > 0)
		{
		  segment2->p_memsz  += extra_length;
		  segment2->p_filesz += extra_length;
		}

	      segment->p_type = PT_NULL;

	      /* Since we have deleted P we must restart the outer loop.  */
	      i = 0;
	      segment = elf_tdata (ibfd)->phdr;
	      break;
	    }
	  else
	    {
	      /* Extend SEGMENT to include SEGMENT2 and then delete
                 SEGMENT2.  */
	      extra_length =
		SEGMENT_END (segment2, segment2->p_vaddr)
		- SEGMENT_END (segment, segment->p_vaddr);

	      if (extra_length > 0)
		{
		  segment->p_memsz  += extra_length;
		  segment->p_filesz += extra_length;
		}

	      segment2->p_type = PT_NULL;
	    }
	}
    }

  /* The second scan attempts to assign sections to segments.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i ++, segment ++)
    {
      unsigned int  section_count;
      asection **   sections;
      asection *    output_section;
      unsigned int  isec;
      bfd_vma       matching_lma;
      bfd_vma       suggested_lma;
      unsigned int  j;

      if (segment->p_type == PT_NULL)
	continue;

      /* Compute how many sections might be placed into this segment.  */
      section_count = 0;
      for (section = ibfd->sections; section != NULL; section = section->next)
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
	  ++section_count;
d3639 1
a3639 1
      map = ((struct elf_segment_map *)
d3642 2
a3643 2
		       + ((size_t) section_count - 1) * sizeof (asection *))));
      if (map == NULL)
d3648 6
a3653 6
      map->next          = NULL;
      map->p_type        = segment->p_type;
      map->p_flags       = segment->p_flags;
      map->p_flags_valid = 1;
      map->p_paddr       = segment->p_paddr;
      map->p_paddr_valid = 1;
d3657 2
a3658 2
      map->includes_filehdr = (segment->p_offset == 0
			       && segment->p_filesz >= iehdr->e_ehsize);
d3660 1
a3660 1
      map->includes_phdrs = 0;
d3662 1
a3662 1
      if (! phdr_included || segment->p_type != PT_LOAD)
d3664 3
a3666 3
	  map->includes_phdrs =
	    (segment->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (segment->p_offset + segment->p_filesz
d3669 1
a3669 2

	  if (segment->p_type == PT_LOAD && map->includes_phdrs)
d3673 1
a3673 1
      if (section_count == 0)
d3678 2
a3679 1
	  if (segment->p_type == PT_LOAD)
d3684 3
a3686 3
	  map->count = 0;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;
d3719 1
a3719 2
      sections = (asection **) bfd_malloc
	(sizeof (asection *) * section_count);
d3729 1
d3734 1
a3734 3
      for (j = 0, section = ibfd->sections;
	   section != NULL;
	   section = section->next)
d3736 7
a3742 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
d3744 1
a3744 3
	      output_section = section->output_section;

	      sections[j ++] = section;
d3749 2
a3750 2
	      if (segment->p_paddr == 0
		  && segment->p_vaddr != 0
d3752 9
a3760 9
		  && output_section->lma != 0
		  && (output_section->vma == (segment->p_vaddr
					      + (map->includes_filehdr
						 ? iehdr->e_ehsize
						 : 0)
					      + (map->includes_phdrs
						 ? iehdr->e_phnum * iehdr->e_phentsize
						 : 0))))
		map->p_paddr = segment->p_vaddr;
d3764 2
a3765 2
	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section))
d3768 1
a3768 1
		    matching_lma = output_section->lma;
d3771 1
a3771 1
		     then it does not overlap any other section within that
d3773 1
a3773 1
		  map->sections[isec ++] = output_section;
d3776 1
a3776 1
		suggested_lma = output_section->lma;
d3780 1
a3780 1
      BFD_ASSERT (j == section_count);
d3784 1
a3784 1
      if (isec == section_count)
d3790 3
a3792 3
	  map->count = section_count;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;
d3804 2
a3805 1
	      map->p_paddr = matching_lma;
d3812 2
a3813 1
	      map->p_paddr = suggested_lma;
d3816 4
a3819 4
	  /* Offset the segment physical address from the lma
	     to allow for space taken up by elf headers.  */
	  if (map->includes_filehdr)
	    map->p_paddr -= iehdr->e_ehsize;
d3821 2
a3822 12
	  if (map->includes_phdrs)
	    {
	      map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;

	      /* iehdr->e_phnum is just an estimate of the number
		 of program headers that we will need.  Make a note
		 here of the number we used and the segment we chose
		 to hold these headers, so that we can adjust the
		 offset when we know the correct value.  */
	      phdr_adjust_num = iehdr->e_phnum;
	      phdr_adjust_seg = map;
	    }
d3835 1
a3835 1
	  map->count = 0;
d3839 1
a3839 1
	  for (j = 0; j < section_count; j++)
d3841 1
a3841 1
	      section = sections[j];
d3843 1
a3843 1
	      if (section == NULL)
d3846 1
a3846 1
	      output_section = section->output_section;
d3848 2
a3849 4
	      BFD_ASSERT (output_section != NULL);

	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section))
d3851 1
a3851 1
		  if (map->count == 0)
d3854 7
a3860 8
			 the beginning of the segment, then something is
			 wrong.  */
		      if (output_section->lma !=
			  (map->p_paddr
			   + (map->includes_filehdr ? iehdr->e_ehsize : 0)
			   + (map->includes_phdrs
			      ? iehdr->e_phnum * iehdr->e_phentsize
			      : 0)))
d3866 1
d3868 2
a3869 1
		      prev_sec = map->sections[map->count - 1];
d3872 4
a3875 5
			 and the start of this section is more than
			 maxpagesize then we need to start a new segment.  */
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
			  < BFD_ALIGN (output_section->lma, maxpagesize))
			  || ((prev_sec->lma + prev_sec->_raw_size) > output_section->lma))
d3878 1
a3878 1
			    suggested_lma = output_section->lma;
d3884 1
a3884 1
		  map->sections[map->count++] = output_section;
a3886 1
		  section->segment_mark = true;
d3889 1
a3889 1
		suggested_lma = output_section->lma;
d3892 1
a3892 1
	  BFD_ASSERT (map->count > 0);
d3895 2
a3896 2
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;
d3898 1
a3898 1
	  if (isec < section_count)
d3903 6
a3908 6
	      map = ((struct elf_segment_map *)
		     bfd_alloc (obfd,
				(sizeof (struct elf_segment_map)
				 + ((size_t) section_count - 1)
				 * sizeof (asection *))));
	      if (map == NULL)
d3914 9
a3922 8
	      map->next             = NULL;
	      map->p_type           = segment->p_type;
	      map->p_flags          = segment->p_flags;
	      map->p_flags_valid    = 1;
	      map->p_paddr          = suggested_lma;
	      map->p_paddr_valid    = 1;
	      map->includes_filehdr = 0;
	      map->includes_phdrs   = 0;
d3925 1
a3925 1
      while (isec < section_count);
d3934 2
a3935 2
  for (map = map_first; map != NULL; map = map->next)
    if (map->p_paddr != 0)
d3937 1
a3937 1
  if (map == NULL)
d3939 2
a3940 2
      for (map = map_first; map != NULL; map = map->next)
	map->p_paddr_valid = 0;
d3943 1
a3943 16
  elf_tdata (obfd)->segment_map = map_first;

  /* If we had to estimate the number of program headers that were
     going to be needed, then check our estimate know and adjust
     the offset if necessary.  */
  if (phdr_adjust_seg != NULL)
    {
      unsigned int count;

      for (count = 0, map = map_first; map != NULL; map = map->next)
	count++;

      if (count > phdr_adjust_num)
	phdr_adjust_seg->p_paddr
	  -= (count - phdr_adjust_num) * iehdr->e_phentsize;
    }
d3946 2
a3947 3
  /* Final Step: Sort the segments into ascending order of physical
     address.  */
  if (map_first != NULL)
d3949 1
a3949 1
      struct elf_segment_map *prev;
d3951 2
a3952 2
      prev = map_first;
      for (map = map_first->next; map != NULL; prev = map, map = map->next)
d3954 2
a3955 2
	  /* Yes I know - its a bubble sort....  */
	  if (map->next != NULL && (map->next->p_paddr < map->p_paddr))
d3957 4
a3960 4
	      /* Swap map and map->next.  */
	      prev->next = map->next;
	      map->next = map->next->next;
	      prev->next->next = map;
d3962 2
a3963 2
	      /* Restart loop.  */
	      map = map_first;
d3969 2
a3970 3
#undef SEGMENT_END
#undef IS_CONTAINED_BY_VMA
#undef IS_CONTAINED_BY_LMA
a3971 4
#undef IS_SOLARIS_PT_INTERP
#undef INCLUDE_SECTION_IN_SEGMENT
#undef SEGMENT_AFTER_SEGMENT
#undef SEGMENT_OVERLAPS
d4093 1
a4093 1
  /* Dump out the symtabs.  */
d4144 3
a4146 5
	if ((flags & BSF_SECTION_SYM) != 0)
	  {
	    /* Section symbols have no name.  */
	    sym.st_name = 0;
	  }
d4514 2
a4515 2
	  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)
	    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);
d4758 2
a4759 2
/* Find the function to a particular section and offset,
   for error reporting.  */
d4761 9
a4769 4
static boolean
elf_find_function (abfd, section, symbols, offset,
		   filename_ptr, functionname_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
d4773 3
a4775 2
     const char **filename_ptr;
     const char **functionname_ptr;
d4777 1
d4783 21
d4840 2
a4841 64
  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return true;
}

/* Find the nearest line to a particular section and offset,
   for error reporting.  */

boolean
_bfd_elf_find_nearest_line (abfd, section, symbols, offset,
			    filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  boolean found;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return true;
    }

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return true;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return false;
  if (found)
    return true;

  if (symbols == NULL)
    return false;

  if (! elf_find_function (abfd, section, symbols, offset,
			   filename_ptr, functionname_ptr))
    return false;

d4911 1
a4911 1
  /* Check whether we really have an ELF howto.  */
d4919 1
a4919 1
	 equivalent ELF reloc.  */
d5032 1
d5037 1
a5037 1
   out details about the corefile.  */
d5043 2
a5044 1
/* Define offsetof for those systems which lack it.  */
d5050 2
a5051 1
/* FIXME: this is kinda wrong, but it's what gdb wants.  */
d5055 1
a5055 1
     bfd *abfd;
d5061 1
d5065 1
a5065 1
   overwrite it.  */
d5069 3
a5071 3
     bfd *abfd;
     char *name;
     asection *sect;
d5073 1
a5073 1
  asection *sect2;
d5089 1
d5091 1
a5091 1
     solaris 2.5+
d5099 2
a5100 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5102 1
d5104 17
a5120 22
  char *name;
  asection *sect;
  int raw_size;
  int offset;

  if (note->descsz == sizeof (prstatus_t))
    {
      prstatus_t prstat;

      raw_size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      elf_tdata (abfd)->core_pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
d5122 1
a5122 1
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
a5123 6
    }
#if defined (HAVE_PRSTATUS32_T)
  else if (note->descsz == sizeof (prstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      prstatus32_t prstat;
d5125 1
a5125 26
      raw_size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus32_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      elf_tdata (abfd)->core_pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
#if defined (HAVE_PRSTATUS32_T_PR_WHO)
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
#endif
    }
#endif /* HAVE_PRSTATUS32_T */
  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return true;
    }

  /* Make a ".reg/999" section.  */
d5136 2
a5137 4

  sect->_raw_size = raw_size;
  sect->filepos = note->descpos + offset;

d5148 1
d5159 1
a5159 1
     bfd *abfd;
d5161 1
a5161 1
     Elf_Internal_Note *note;
d5165 1
a5165 1
  asection *sect;
d5189 1
d5192 1
a5192 2
   data structure apart.  */

d5195 2
a5196 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5201 1
a5204 1

d5207 2
a5208 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5213 1
d5215 1
a5215 4
typedef prpsinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PRPSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef prpsinfo32_t elfcore_psinfo32_t;
#endif
d5219 1
a5219 4
typedef psinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef psinfo32_t elfcore_psinfo32_t;
#endif
d5221 1
d5227 1
a5227 1
   the copy will always have a terminating '\0'.  */
d5231 2
a5232 2
     bfd *abfd;
     char *start;
d5235 2
a5236 2
  char *dup;
  char *end = memchr (start, '\0', max);
d5256 2
a5257 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5259 1
a5259 3
  if (note->descsz == sizeof (elfcore_psinfo_t))
    {
      elfcore_psinfo_t psinfo;
d5261 2
a5262 13
      memcpy (&psinfo, note->descdata, sizeof (psinfo));

      elf_tdata (abfd)->core_program
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));

      elf_tdata (abfd)->core_command
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
    }
#if defined (HAVE_PRPSINFO32_T) || defined (HAVE_PSINFO32_T)
  else if (note->descsz == sizeof (elfcore_psinfo32_t))
    {
      /* 64-bit host, 32-bit corefile */
      elfcore_psinfo32_t psinfo;
d5264 1
a5264 1
      memcpy (&psinfo, note->descdata, sizeof (psinfo));
d5266 2
a5267 2
      elf_tdata (abfd)->core_program
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5269 2
a5270 11
      elf_tdata (abfd)->core_command
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
    }
#endif

  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return true;
    }
d5274 1
a5274 1
     implementations, so strip it off if it exists.  */
d5277 1
a5277 1
    char *command = elf_tdata (abfd)->core_command;
d5288 1
d5292 2
a5293 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5295 1
a5295 7
  if (note->descsz == sizeof (pstatus_t)
#if defined (HAVE_PXSTATUS_T)
      || note->descsz == sizeof (pxstatus_t)
#endif
      )
    {
      pstatus_t pstat;
d5297 2
a5298 1
      memcpy (&pstat, note->descdata, sizeof (pstat));
d5300 1
a5300 7
      elf_tdata (abfd)->core_pid = pstat.pr_pid;
    }
#if defined (HAVE_PSTATUS32_T)
  else if (note->descsz == sizeof (pstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      pstatus32_t pstat;
d5302 1
a5302 1
      memcpy (&pstat, note->descdata, sizeof (pstat));
a5303 3
      elf_tdata (abfd)->core_pid = pstat.pr_pid;
    }
#endif
d5306 1
a5306 1
     NT_LWPSTATUS note, presumably.  */
d5312 1
d5316 2
a5317 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5321 2
a5322 2
  char *name;
  asection *sect;
d5324 1
a5324 5
  if (note->descsz != sizeof (lwpstat)
#if defined (HAVE_LWPXSTATUS_T)
      && note->descsz != sizeof (lwpxstatus_t)
#endif
      )
d5332 1
a5332 1
  /* Make a ".reg/999" section.  */
d5397 2
a5398 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5401 2
a5402 2
  char *name;
  asection *sect;
d5408 3
a5410 3
  memcpy (&pstatus, note->descdata, note->descsz);

  switch (pstatus.data_type)
d5416 1
a5416 1
      break;
d5421 1
a5421 1

d5424 2
a5425 2
	return false;

d5430 2
a5431 2
	return false;

d5445 2
a5446 2
      sprintf (buf, ".module/%08x", pstatus.data.module_info.base_address);

d5450 1
a5450 1

d5454 1
a5454 1

d5457 1
a5457 1

d5474 2
a5475 2
     bfd *abfd;
     Elf_Internal_Note *note;
d5501 1
a5501 1
    case NT_WIN32PSTATUS:
d5505 1
a5505 1
    case NT_PRXFPREG:		/* Linux SSE extension */
d5520 1
d5523 1
a5523 1
     bfd *abfd;
d5527 2
a5528 2
  char *buf;
  char *p;
d5550 2
a5551 2
      /* FIXME: bad alignment assumption.  */
      Elf_External_Note *xnp = (Elf_External_Note *) p;
d5573 1
d5579 1
a5579 1
     bfd *abfd;
d5588 2
a5595 1

d5610 1
a5617 1

d5632 1
a5632 1
  memcpy (phdrs, elf_tdata (abfd)->phdr,
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d21 1
a21 1
/*  SECTION
d23 1
d32 2
a33 1
	haven't bothered yet.  */
a42 1
#include "libiberty.h"
d45 19
a63 62
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, bfd_boolean));
static bfd_boolean map_sections_to_segments
  PARAMS ((bfd *));
static int elf_sort_sections
  PARAMS ((const PTR, const PTR));
static bfd_boolean assign_file_positions_for_segments
  PARAMS ((bfd *));
static bfd_boolean assign_file_positions_except_relocs
  PARAMS ((bfd *));
static bfd_boolean prep_headers
  PARAMS ((bfd *));
static bfd_boolean swap_out_syms
  PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static bfd_boolean copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static char *elf_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static const char *group_signature
  PARAMS ((bfd *, Elf_Internal_Shdr *));
static bfd_boolean setup_group
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void merge_sections_remove_hook
  PARAMS ((bfd *, asection *));
static void elf_fake_sections
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean assign_section_numbers
  PARAMS ((bfd *));
static INLINE int sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean elf_map_symbols
  PARAMS ((bfd *));
static bfd_size_type get_program_header_size
  PARAMS ((bfd *));
static bfd_boolean elfcore_read_notes
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean elf_find_function
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **));
static int elfcore_make_pid
  PARAMS ((bfd *));
static bfd_boolean elfcore_maybe_make_sect
  PARAMS ((bfd *, char *, asection *));
static bfd_boolean elfcore_make_note_pseudosection
  PARAMS ((bfd *, char *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prxfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_netbsd_get_lwpid
  PARAMS ((Elf_Internal_Note *, int *));
static bfd_boolean elfcore_grok_netbsd_procinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_netbsd_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_nto_gregs
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t));
static bfd_boolean elfcore_grok_nto_status
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t *));
static bfd_boolean elfcore_grok_nto_note
  PARAMS ((bfd *, Elf_Internal_Note *));
d77 7
a83 7
  dst->vd_version = H_GET_16 (abfd, src->vd_version);
  dst->vd_flags   = H_GET_16 (abfd, src->vd_flags);
  dst->vd_ndx     = H_GET_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = H_GET_16 (abfd, src->vd_cnt);
  dst->vd_hash    = H_GET_32 (abfd, src->vd_hash);
  dst->vd_aux     = H_GET_32 (abfd, src->vd_aux);
  dst->vd_next    = H_GET_32 (abfd, src->vd_next);
d94 7
a100 7
  H_PUT_16 (abfd, src->vd_version, dst->vd_version);
  H_PUT_16 (abfd, src->vd_flags, dst->vd_flags);
  H_PUT_16 (abfd, src->vd_ndx, dst->vd_ndx);
  H_PUT_16 (abfd, src->vd_cnt, dst->vd_cnt);
  H_PUT_32 (abfd, src->vd_hash, dst->vd_hash);
  H_PUT_32 (abfd, src->vd_aux, dst->vd_aux);
  H_PUT_32 (abfd, src->vd_next, dst->vd_next);
d111 2
a112 2
  dst->vda_name = H_GET_32 (abfd, src->vda_name);
  dst->vda_next = H_GET_32 (abfd, src->vda_next);
d123 2
a124 2
  H_PUT_32 (abfd, src->vda_name, dst->vda_name);
  H_PUT_32 (abfd, src->vda_next, dst->vda_next);
d135 5
a139 5
  dst->vn_version = H_GET_16 (abfd, src->vn_version);
  dst->vn_cnt     = H_GET_16 (abfd, src->vn_cnt);
  dst->vn_file    = H_GET_32 (abfd, src->vn_file);
  dst->vn_aux     = H_GET_32 (abfd, src->vn_aux);
  dst->vn_next    = H_GET_32 (abfd, src->vn_next);
d150 5
a154 5
  H_PUT_16 (abfd, src->vn_version, dst->vn_version);
  H_PUT_16 (abfd, src->vn_cnt, dst->vn_cnt);
  H_PUT_32 (abfd, src->vn_file, dst->vn_file);
  H_PUT_32 (abfd, src->vn_aux, dst->vn_aux);
  H_PUT_32 (abfd, src->vn_next, dst->vn_next);
d165 5
a169 5
  dst->vna_hash  = H_GET_32 (abfd, src->vna_hash);
  dst->vna_flags = H_GET_16 (abfd, src->vna_flags);
  dst->vna_other = H_GET_16 (abfd, src->vna_other);
  dst->vna_name  = H_GET_32 (abfd, src->vna_name);
  dst->vna_next  = H_GET_32 (abfd, src->vna_next);
d180 5
a184 5
  H_PUT_32 (abfd, src->vna_hash, dst->vna_hash);
  H_PUT_16 (abfd, src->vna_flags, dst->vna_flags);
  H_PUT_16 (abfd, src->vna_other, dst->vna_other);
  H_PUT_32 (abfd, src->vna_name, dst->vna_name);
  H_PUT_32 (abfd, src->vna_next, dst->vna_next);
d195 1
a195 1
  dst->vs_vers = H_GET_16 (abfd, src->vs_vers);
d206 1
a206 1
  H_PUT_16 (abfd, src->vs_vers, dst->vs_vers);
d232 1
a232 1
  return h & 0xffffffff;
d242 2
a243 2
     file_ptr offset;
     bfd_size_type size;
d249 1
a249 1
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
d251 1
a251 1
  if (bfd_bread ((PTR) buf, size, abfd) != size)
d260 1
a260 1
bfd_boolean
d266 2
a267 2
  bfd_size_type amt = sizeof (struct elf_obj_tdata);
  elf_tdata (abfd) = (struct elf_obj_tdata *) bfd_zalloc (abfd, amt);
d269 1
a269 1
    return FALSE;
d273 1
a273 1
  return TRUE;
d276 1
a276 1
bfd_boolean
d291 2
a292 2
  file_ptr offset;
  bfd_size_type shstrtabsize;
d331 1
a331 1
	 bfd_archive_filename (abfd), strindex, (unsigned long) hdr->sh_size,
a341 336
/* Read and convert symbols to internal format.
   SYMCOUNT specifies the number of symbols to read, starting from
   symbol SYMOFFSET.  If any of INTSYM_BUF, EXTSYM_BUF or EXTSHNDX_BUF
   are non-NULL, they are used to store the internal symbols, external
   symbols, and symbol section index extensions, respectively.  */

Elf_Internal_Sym *
bfd_elf_get_elf_syms (ibfd, symtab_hdr, symcount, symoffset,
		      intsym_buf, extsym_buf, extshndx_buf)
     bfd *ibfd;
     Elf_Internal_Shdr *symtab_hdr;
     size_t symcount;
     size_t symoffset;
     Elf_Internal_Sym *intsym_buf;
     PTR extsym_buf;
     Elf_External_Sym_Shndx *extshndx_buf;
{
  Elf_Internal_Shdr *shndx_hdr;
  PTR alloc_ext;
  const bfd_byte *esym;
  Elf_External_Sym_Shndx *alloc_extshndx;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_backend_data *bed;
  size_t extsym_size;
  bfd_size_type amt;
  file_ptr pos;

  if (symcount == 0)
    return intsym_buf;

  /* Normal syms might have section extension entries.  */
  shndx_hdr = NULL;
  if (symtab_hdr == &elf_tdata (ibfd)->symtab_hdr)
    shndx_hdr = &elf_tdata (ibfd)->symtab_shndx_hdr;

  /* Read the symbols.  */
  alloc_ext = NULL;
  alloc_extshndx = NULL;
  bed = get_elf_backend_data (ibfd);
  extsym_size = bed->s->sizeof_sym;
  amt = symcount * extsym_size;
  pos = symtab_hdr->sh_offset + symoffset * extsym_size;
  if (extsym_buf == NULL)
    {
      alloc_ext = bfd_malloc (amt);
      extsym_buf = alloc_ext;
    }
  if (extsym_buf == NULL
      || bfd_seek (ibfd, pos, SEEK_SET) != 0
      || bfd_bread (extsym_buf, amt, ibfd) != amt)
    {
      intsym_buf = NULL;
      goto out;
    }

  if (shndx_hdr == NULL || shndx_hdr->sh_size == 0)
    extshndx_buf = NULL;
  else
    {
      amt = symcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);
      if (extshndx_buf == NULL)
	{
	  alloc_extshndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  extshndx_buf = alloc_extshndx;
	}
      if (extshndx_buf == NULL
	  || bfd_seek (ibfd, pos, SEEK_SET) != 0
	  || bfd_bread (extshndx_buf, amt, ibfd) != amt)
	{
	  intsym_buf = NULL;
	  goto out;
	}
    }

  if (intsym_buf == NULL)
    {
      bfd_size_type amt = symcount * sizeof (Elf_Internal_Sym);
      intsym_buf = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (intsym_buf == NULL)
	goto out;
    }

  /* Convert the symbols to internal form.  */
  isymend = intsym_buf + symcount;
  for (esym = extsym_buf, isym = intsym_buf, shndx = extshndx_buf;
       isym < isymend;
       esym += extsym_size, isym++, shndx = shndx != NULL ? shndx + 1 : NULL)
    (*bed->s->swap_symbol_in) (ibfd, esym, (const PTR) shndx, isym);

 out:
  if (alloc_ext != NULL)
    free (alloc_ext);
  if (alloc_extshndx != NULL)
    free (alloc_extshndx);

  return intsym_buf;
}

/* Look up a symbol name.  */
const char *
bfd_elf_local_sym_name (abfd, isym)
     bfd *abfd;
     Elf_Internal_Sym *isym;
{
  unsigned int iname = isym->st_name;
  unsigned int shindex = elf_tdata (abfd)->symtab_hdr.sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym->st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

/* Elf_Internal_Shdr->contents is an array of these for SHT_GROUP
   sections.  The first element is the flags, the rest are section
   pointers.  */

typedef union elf_internal_group {
  Elf_Internal_Shdr *shdr;
  unsigned int flags;
} Elf_Internal_Group;

/* Return the name of the group signature symbol.  Why isn't the
   signature just a string?  */

static const char *
group_signature (abfd, ghdr)
     bfd *abfd;
     Elf_Internal_Shdr *ghdr;
{
  Elf_Internal_Shdr *hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;

  /* First we need to ensure the symbol table is available.  */
  if (! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return NULL;

  /* Go read the symbol.  */
  hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, hdr, 1, ghdr->sh_info,
			    &isym, esym, &eshndx) == NULL)
    return NULL;

  return bfd_elf_local_sym_name (abfd, &isym);
}

/* Set next_in_group list pointer, and group name for NEWSECT.  */

static bfd_boolean
setup_group (abfd, hdr, newsect)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *newsect;
{
  unsigned int num_group = elf_tdata (abfd)->num_group;

  /* If num_group is zero, read in all SHT_GROUP sections.  The count
     is set to -1 if there are no SHT_GROUP sections.  */
  if (num_group == 0)
    {
      unsigned int i, shnum;

      /* First count the number of groups.  If we have a SHT_GROUP
	 section with just a flag word (ie. sh_size is 4), ignore it.  */
      shnum = elf_numsections (abfd);
      num_group = 0;
      for (i = 0; i < shnum; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];
	  if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
	    num_group += 1;
	}

      if (num_group == 0)
	num_group = (unsigned) -1;
      elf_tdata (abfd)->num_group = num_group;

      if (num_group > 0)
	{
	  /* We keep a list of elf section headers for group sections,
	     so we can find them quickly.  */
	  bfd_size_type amt = num_group * sizeof (Elf_Internal_Shdr *);
	  elf_tdata (abfd)->group_sect_ptr = bfd_alloc (abfd, amt);
	  if (elf_tdata (abfd)->group_sect_ptr == NULL)
	    return FALSE;

	  num_group = 0;
	  for (i = 0; i < shnum; i++)
	    {
	      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];
	      if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
		{
		  unsigned char *src;
		  Elf_Internal_Group *dest;

		  /* Add to list of sections.  */
		  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;
		  num_group += 1;

		  /* Read the raw contents.  */
		  BFD_ASSERT (sizeof (*dest) >= 4);
		  amt = shdr->sh_size * sizeof (*dest) / 4;
		  shdr->contents = bfd_alloc (abfd, amt);
		  if (shdr->contents == NULL
		      || bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0
		      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)
			  != shdr->sh_size))
		    return FALSE;

		  /* Translate raw contents, a flag word followed by an
		     array of elf section indices all in target byte order,
		     to the flag word followed by an array of elf section
		     pointers.  */
		  src = shdr->contents + shdr->sh_size;
		  dest = (Elf_Internal_Group *) (shdr->contents + amt);
		  while (1)
		    {
		      unsigned int idx;

		      src -= 4;
		      --dest;
		      idx = H_GET_32 (abfd, src);
		      if (src == shdr->contents)
			{
			  dest->flags = idx;
			  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))
			    shdr->bfd_section->flags
			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
			  break;
			}
		      if (idx >= shnum)
			{
			  ((*_bfd_error_handler)
			   (_("%s: invalid SHT_GROUP entry"),
			    bfd_archive_filename (abfd)));
			  idx = 0;
			}
		      dest->shdr = elf_elfsections (abfd)[idx];
		    }
		}
	    }
	}
    }

  if (num_group != (unsigned) -1)
    {
      unsigned int i;

      for (i = 0; i < num_group; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;
	  unsigned int n_elt = shdr->sh_size / 4;

	  /* Look through this group's sections to see if current
	     section is a member.  */
	  while (--n_elt != 0)
	    if ((++idx)->shdr == hdr)
	      {
		asection *s = NULL;

		/* We are a member of this group.  Go looking through
		   other members to see if any others are linked via
		   next_in_group.  */
		idx = (Elf_Internal_Group *) shdr->contents;
		n_elt = shdr->sh_size / 4;
		while (--n_elt != 0)
		  if ((s = (++idx)->shdr->bfd_section) != NULL
		      && elf_next_in_group (s) != NULL)
		    break;
		if (n_elt != 0)
		  {
		    /* Snarf the group name from other member, and
		       insert current section in circular list.  */
		    elf_group_name (newsect) = elf_group_name (s);
		    elf_next_in_group (newsect) = elf_next_in_group (s);
		    elf_next_in_group (s) = newsect;
		  }
		else
		  {
		    const char *gname;

		    gname = group_signature (abfd, shdr);
		    if (gname == NULL)
		      return FALSE;
		    elf_group_name (newsect) = gname;

		    /* Start a circular list with one element.  */
		    elf_next_in_group (newsect) = newsect;
		  }

		/* If the group section has been created, point to the
		   new member.  */
		if (shdr->bfd_section != NULL)
		  elf_next_in_group (shdr->bfd_section) = newsect;

		i = num_group - 1;
		break;
	      }
	}
    }

  if (elf_group_name (newsect) == NULL)
    {
      (*_bfd_error_handler) (_("%s: no group info for section %s"),
			     bfd_archive_filename (abfd), newsect->name);
    }
  return TRUE;
}

bfd_boolean
bfd_elf_discard_group (abfd, group)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *group;
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      s->output_section = bfd_abs_section_ptr;
      s = elf_next_in_group (s);
      /* These lists are circular.  */
      if (s == first)
	break;
    }
  return TRUE;
}

d345 1
a345 1
bfd_boolean
d359 1
a359 1
      return TRUE;
d364 1
a364 1
    return FALSE;
d371 2
a372 2
				      bfd_log2 ((bfd_vma) hdr->sh_addralign)))
    return FALSE;
a376 2
  if (hdr->sh_type == SHT_GROUP)
    flags |= SEC_GROUP | SEC_EXCLUDE;
a388 12
  if ((hdr->sh_flags & SHF_MERGE) != 0)
    {
      flags |= SEC_MERGE;
      newsect->entsize = hdr->sh_entsize;
      if ((hdr->sh_flags & SHF_STRINGS) != 0)
	flags |= SEC_STRINGS;
    }
  if (hdr->sh_flags & SHF_GROUP)
    if (!setup_group (abfd, hdr, newsect))
      return FALSE;
  if ((hdr->sh_flags & SHF_TLS) != 0)
    flags |= SEC_THREAD_LOCAL;
d402 1
a402 1
    for (i = ARRAY_SIZE (debug_sec_names); i--;)
d416 1
a416 2
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0
      && elf_next_in_group (newsect) == NULL)
d422 1
a422 1
      return FALSE;
d425 1
a425 1
    return FALSE;
a445 12
	      /* This section is part of this segment if its file
		 offset plus size lies within the segment's memory
		 span and, if the section is loaded, the extent of the
		 loaded data lies within the extent of the segment.

		 Note - we used to check the p_paddr field as well, and
		 refuse to set the LMA if it was 0.  This is wrong
		 though, as a perfectly valid initialised segment can
		 have a p_paddr of zero.  Some architectures, eg ARM,
	         place special significance on the address 0 and
	         executables need to be able to have a segment which
	         covers this address.  */
d447 4
a450 3
		  && (bfd_vma) hdr->sh_offset >= phdr->p_offset
		  && (hdr->sh_offset + hdr->sh_size
		      <= phdr->p_offset + phdr->p_memsz)
d452 3
a454 2
		      || (hdr->sh_offset + hdr->sh_size
			  <= phdr->p_offset + phdr->p_filesz)))
d456 2
a457 22
		  if ((flags & SEC_LOAD) == 0)
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_addr - phdr->p_vaddr);
		  else
		    /* We used to use the same adjustment for SEC_LOAD
		       sections, but that doesn't work if the segment
		       is packed with code from multiple VMAs.
		       Instead we calculate the section LMA based on
		       the segment LMA.  It is assumed that the
		       segment will contain sections with contiguous
		       LMAs, even if the VMAs are not.  */
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_offset - phdr->p_offset);

		  /* With contiguous segments, we can't tell from file
		     offsets whether a section with zero size should
		     be placed at the end of one segment or the
		     beginning of the next.  Decide based on vaddr.  */
		  if (hdr->sh_addr >= phdr->p_vaddr
		      && (hdr->sh_addr + hdr->sh_size
			  <= phdr->p_vaddr + phdr->p_memsz))
		    break;
d466 1
a466 1
  return TRUE;
d497 2
a498 2
      shstrtab = bfd_elf_get_str_section (abfd,
					  elf_elfheader (abfd)->e_shstrndx);
d501 1
a501 1
	  max = elf_numsections (abfd);
a553 61
/* Make sure sec_info_type is cleared if sec_info is cleared too.  */

static void
merge_sections_remove_hook (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
{
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
}

/* Finish SHF_MERGE section merging.  */

bfd_boolean
_bfd_elf_merge_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  if (!is_elf_hash_table (info))
    return FALSE;
  if (elf_hash_table (info)->merge_info)
    _bfd_merge_sections (abfd, elf_hash_table (info)->merge_info,
			 merge_sections_remove_hook);
  return TRUE;
}

void
_bfd_elf_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info;
{
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
  if (!is_elf_hash_table (info))
    return;

  sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
}

/* Copy the program header and other data from one object module to
   another.  */

bfd_boolean
_bfd_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;
  return TRUE;
}

d556 1
a556 1
bfd_boolean
d575 1
a575 1
	  const char *pt;
d580 8
a587 10
	    case PT_NULL: pt = "NULL"; break;
	    case PT_LOAD: pt = "LOAD"; break;
	    case PT_DYNAMIC: pt = "DYNAMIC"; break;
	    case PT_INTERP: pt = "INTERP"; break;
	    case PT_NOTE: pt = "NOTE"; break;
	    case PT_SHLIB: pt = "SHLIB"; break;
	    case PT_PHDR: pt = "PHDR"; break;
	    case PT_TLS: pt = "TLS"; break;
	    case PT_GNU_EH_FRAME: pt = "EH_FRAME"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); pt = buf; break;
d589 2
a590 2
	  fprintf (f, "%8s off    0x", pt);
	  bfd_fprintf_vma (abfd, f, p->p_offset);
d592 1
a592 1
	  bfd_fprintf_vma (abfd, f, p->p_vaddr);
d594 1
a594 1
	  bfd_fprintf_vma (abfd, f, p->p_paddr);
d597 1
a597 1
	  bfd_fprintf_vma (abfd, f, p->p_filesz);
d599 1
a599 1
	  bfd_fprintf_vma (abfd, f, p->p_memsz);
d604 2
a605 2
	  if ((p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X));
d614 1
a614 1
      unsigned long shlink;
d631 1
a631 1
      shlink = elf_elfsections (abfd)[elfsec]->sh_link;
d643 1
a643 1
	  bfd_boolean stringp;
d650 1
a650 1
	  stringp = FALSE;
d658 1
a658 1
	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
d671 2
a672 2
	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
d686 1
a686 1
	    case DT_RUNPATH: name = "RUNPATH"; stringp = TRUE; break;
d698 3
a700 3
	    case DT_CONFIG: name = "CONFIG"; stringp = TRUE; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = TRUE; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = TRUE; break;
d712 1
a712 1
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
d714 1
a714 1
	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
a722 1
	      unsigned int tagv = dyn.d_un.d_val;
d724 2
a725 1
	      string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
d741 1
a741 1
	return FALSE;
d783 1
a783 1
  return TRUE;
d788 1
a788 1
  return FALSE;
d808 1
a808 1
      bfd_fprintf_vma (abfd, file, symbol->value);
a816 1
	bfd_vma val;
d827 1
a827 1
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d835 4
a838 5
	if (bfd_is_com_section (symbol->section))
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_value;
	else
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_size;
	bfd_fprintf_vma (abfd, file, val);
d920 2
d924 5
a928 6
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }
d931 4
a934 2
  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
a935 3
      struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;
      struct elf_link_hash_table *htab = (struct elf_link_hash_table *) table;

d938 1
a940 1
      ret->elf_hash_value = 0;
d942 3
a944 1
      ret->linker_section_pointer = NULL;
d946 1
a947 1
      ret->vtable_entries_used = NULL;
a948 3
      ret->got = htab->init_refcount;
      ret->plt = htab->init_refcount;
      ret->size = 0;
d958 1
a958 1
  return entry;
d962 1
a962 1
   old indirect symbol.  Also used for copying flags to a weakdef.  */
d965 1
a965 2
_bfd_elf_link_hash_copy_indirect (bed, dir, ind)
     struct elf_backend_data *bed;
a967 3
  bfd_signed_vma tmp;
  bfd_signed_vma lowest_valid = bed->can_refcount;

d978 1
a978 4
  if (ind->root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the global and procedure linkage table refcount entries.
d980 1
a980 2
  tmp = dir->got.refcount;
  if (tmp < lowest_valid)
d982 2
a983 2
      dir->got.refcount = ind->got.refcount;
      ind->got.refcount = tmp;
d985 1
a985 2
  else
    BFD_ASSERT (ind->got.refcount < lowest_valid);
d987 1
a987 2
  tmp = dir->plt.refcount;
  if (tmp < lowest_valid)
d989 2
a990 2
      dir->plt.refcount = ind->plt.refcount;
      ind->plt.refcount = tmp;
d992 1
a992 2
  else
    BFD_ASSERT (ind->plt.refcount < lowest_valid);
d1001 1
a1001 2
  else
    BFD_ASSERT (ind->dynindx == -1);
d1005 2
a1006 2
_bfd_elf_link_hash_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
a1007 1
     bfd_boolean force_local;
a1008 1
  h->plt = elf_hash_table (info)->init_offset;
d1010 3
a1012 10
  if (force_local)
    {
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }
d1017 1
a1017 1
bfd_boolean
d1021 3
a1023 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d1025 1
a1025 3
  bfd_boolean ret;

  table->dynamic_sections_created = FALSE;
a1026 5
  /* Make sure can_refcount is extended to the width and signedness of
     init_refcount before we subtract one from it.  */
  table->init_refcount.refcount = get_elf_backend_data (abfd)->can_refcount;
  table->init_refcount.refcount -= 1;
  table->init_offset.offset = -(bfd_vma) 1;
d1032 1
a1034 2
  table->merge_info = NULL;
  memset (&table->eh_info, 0, sizeof (table->eh_info));
d1036 1
a1036 8
  table->runpath = NULL;
  table->tls_segment = NULL;
  table->loaded = NULL;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc);
  table->root.type = bfd_link_elf_hash_table;

  return ret;
a1045 1
  bfd_size_type amt = sizeof (struct elf_link_hash_table);
d1047 2
a1048 1
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
d1054 1
a1054 1
      free (ret);
d1094 1
a1094 1
  if (! is_elf_hash_table (info))
d1107 1
a1107 1
  if (! is_elf_hash_table (info))
d1129 1
a1129 1
bfd_boolean
d1137 1
a1137 1
  unsigned long shlink;
d1146 1
a1146 1
    return TRUE;
d1150 1
a1150 1
    return TRUE;
d1164 1
a1164 1
  shlink = elf_elfsections (abfd)[elfsec]->sh_link;
a1183 2
	  unsigned int tagv = dyn.d_un.d_val;
	  bfd_size_type amt;
d1185 2
a1186 1
	  string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
d1190 1
a1190 2
	  amt = sizeof *l;
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d1203 1
a1203 1
  return TRUE;
d1208 1
a1208 1
  return FALSE;
d1223 1
a1223 1
      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
d1238 1
a1238 1
bfd_boolean
d1246 1
a1246 1
  const char *name;
d1254 1
a1254 1
      return TRUE;
d1257 1
a1260 3
    case SHT_INIT_ARRAY:	/* .init_array section.  */
    case SHT_FINI_ARRAY:	/* .fini_array section.  */
    case SHT_PREINIT_ARRAY:	/* .preinit_array section.  */
a1262 33
    case SHT_DYNAMIC:	/* Dynamic linking information.  */
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return FALSE;
      if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
	{
	  Elf_Internal_Shdr *dynsymhdr;

	  /* The shared libraries distributed with hpux11 have a bogus
	     sh_link field for the ".dynamic" section.  Find the
	     string table for the ".dynsym" section instead.  */
	  if (elf_dynsymtab (abfd) != 0)
	    {
	      dynsymhdr = elf_elfsections (abfd)[elf_dynsymtab (abfd)];
	      hdr->sh_link = dynsymhdr->sh_link;
	    }
	  else
	    {
	      unsigned int i, num_sec;

	      num_sec = elf_numsections (abfd);
	      for (i = 1; i < num_sec; i++)
		{
		  dynsymhdr = elf_elfsections (abfd)[i];
		  if (dynsymhdr->sh_type == SHT_DYNSYM)
		    {
		      hdr->sh_link = dynsymhdr->sh_link;
		      break;
		    }
		}
	    }
	}
      break;

d1265 1
a1265 1
	return TRUE;
d1283 1
a1283 1
	return FALSE;
d1285 1
a1285 1
      return TRUE;
d1289 1
a1289 1
	return TRUE;
a1301 14
    case SHT_SYMTAB_SHNDX:	/* Symbol section indices when >64k sections */
      if (elf_symtab_shndx (abfd) == shindex)
	return TRUE;

      /* Get the associated symbol table.  */
      if (! bfd_section_from_shdr (abfd, hdr->sh_link)
	  || hdr->sh_link != elf_onesymtab (abfd))
	return FALSE;

      elf_symtab_shndx (abfd) = shindex;
      elf_tdata (abfd)->symtab_shndx_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->symtab_shndx_hdr;
      return TRUE;

d1304 1
a1304 1
	return TRUE;
d1309 1
a1309 1
	  return TRUE;
d1312 1
a1312 1
	unsigned int i, num_sec;
d1314 1
a1314 2
	num_sec = elf_numsections (abfd);
	for (i = 1; i < num_sec; i++)
d1320 1
a1320 1
		  return FALSE;
d1326 1
a1326 1
		    return TRUE;
a1359 1
	unsigned int num_sec = elf_numsections (abfd);
d1362 1
a1362 2
	if ((hdr->sh_link >= SHN_LORESERVE && hdr->sh_link <= SHN_HIRESERVE)
	    || hdr->sh_link >= num_sec)
d1366 1
a1366 1
	      bfd_archive_filename (abfd), hdr->sh_link, name, shindex));
d1380 1
a1380 1
	    unsigned int scan;
d1384 1
a1384 1
	    for (scan = 1; scan < num_sec; scan++)
d1404 1
a1404 1
	  return FALSE;
d1416 1
a1416 1
	  return FALSE;
d1419 1
a1419 1
	  return FALSE;
a1425 1
	    bfd_size_type amt;
d1427 1
a1427 2
	    amt = sizeof (*hdr2);
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d1439 2
a1440 1
	  target_sect->use_rela_p = hdr->sh_type == SHT_RELA;
d1442 1
a1442 1
	return TRUE;
d1465 1
a1465 30
      return TRUE;

    case SHT_GROUP:
      /* We need a BFD section for objcopy and relocatable linking,
	 and it's handy to have the signature available as the section
	 name.  */
      name = group_signature (abfd, hdr);
      if (name == NULL)
	return FALSE;
      if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return FALSE;
      if (hdr->contents != NULL)
	{
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) hdr->contents;
	  unsigned int n_elt = hdr->sh_size / 4;
	  asection *s;

	  if (idx->flags & GRP_COMDAT)
	    hdr->bfd_section->flags
	      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

	  while (--n_elt != 0)
	    if ((s = (++idx)->shdr->bfd_section) != NULL
		&& elf_next_in_group (s) != NULL)
	      {
		elf_next_in_group (hdr->bfd_section) = s;
		break;
	      }
	}
      break;
d1476 1
a1476 42
  return TRUE;
}

/* Return the section for the local symbol specified by ABFD, R_SYMNDX.
   Return SEC for sections that have no elf section, and NULL on error.  */

asection *
bfd_section_from_r_symndx (abfd, cache, sec, r_symndx)
     bfd *abfd;
     struct sym_sec_cache *cache;
     asection *sec;
     unsigned long r_symndx;
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
  unsigned int ent = r_symndx % LOCAL_SYM_CACHE_SIZE;

  if (cache->abfd == abfd && cache->indx[ent] == r_symndx)
    return cache->sec[ent];

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
			    &isym, esym, &eshndx) == NULL)
    return NULL;

  if (cache->abfd != abfd)
    {
      memset (cache->indx, -1, sizeof (cache->indx));
      cache->abfd = abfd;
    }
  cache->indx[ent] = r_symndx;
  cache->sec[ent] = sec;
  if (isym.st_shndx < SHN_LORESERVE || isym.st_shndx > SHN_HIRESERVE)
    {
      asection *s;
      s = bfd_section_from_elf_index (abfd, isym.st_shndx);
      if (s != NULL)
	cache->sec[ent] = s;
    }
  return cache->sec[ent];
d1487 2
a1488 1
  if (index >= elf_numsections (abfd))
d1493 1
a1493 1
bfd_boolean
d1500 4
a1503 9
  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == NULL)
    {
      bfd_size_type amt = sizeof (*sdata);
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = (PTR) sdata;
    }
d1506 2
a1507 1
  sec->use_rela_p = get_elf_backend_data (abfd)->default_use_rela_p;
d1509 1
a1509 1
  return TRUE;
d1534 1
a1534 1
bfd_boolean
a1543 1
  size_t len;
d1550 1
a1550 2
  len = strlen (namebuf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d1552 2
a1553 2
    return FALSE;
  memcpy (name, namebuf, len);
d1556 1
a1556 1
    return FALSE;
d1581 1
a1581 2
      len = strlen (namebuf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d1583 2
a1584 2
	return FALSE;
      memcpy (name, namebuf, len);
d1587 1
a1587 1
	return FALSE;
d1601 1
a1601 1
  return TRUE;
d1604 1
a1604 1
bfd_boolean
d1628 4
a1631 4
	return FALSE;
      if (! elfcore_read_notes (abfd, (file_ptr) hdr->p_offset, hdr->p_filesz))
	return FALSE;
      return TRUE;
a1638 4
    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "eh_frame_hdr");

d1651 1
a1651 1
   relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA
d1654 1
a1654 1
bfd_boolean
d1659 1
a1659 1
     bfd_boolean use_rela_p;
d1662 1
a1662 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_size_type amt = sizeof ".rela" + strlen (asect->name);
d1664 2
a1665 1
  name = bfd_alloc (abfd, amt);
d1667 1
a1667 1
    return FALSE;
d1670 2
a1671 2
    (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd), name,
					FALSE);
d1673 1
a1673 1
    return FALSE;
d1684 1
a1684 1
  return TRUE;
d1696 1
a1696 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d1708 4
a1711 3
  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
d1713 1
a1713 1
      *failedptr = TRUE;
a1764 6
  else if (strcmp (asect->name, ".init_array") == 0)
    this_hdr->sh_type = SHT_INIT_ARRAY;
  else if (strcmp (asect->name, ".fini_array") == 0)
    this_hdr->sh_type = SHT_FINI_ARRAY;
  else if (strcmp (asect->name, ".preinit_array") == 0)
    this_hdr->sh_type = SHT_PREINIT_ARRAY;
a1800 5
  else if ((asect->flags & SEC_GROUP) != 0)
    {
      this_hdr->sh_type = SHT_GROUP;
      this_hdr->sh_entsize = 4;
    }
d1802 1
a1802 2
	   && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	       || (asect->flags & SEC_NEVER_LOAD) != 0))
a1812 24
  if ((asect->flags & SEC_MERGE) != 0)
    {
      this_hdr->sh_flags |= SHF_MERGE;
      this_hdr->sh_entsize = asect->entsize;
      if ((asect->flags & SEC_STRINGS) != 0)
	this_hdr->sh_flags |= SHF_STRINGS;
    }
  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)
    this_hdr->sh_flags |= SHF_GROUP;
  if ((asect->flags & SEC_THREAD_LOCAL) != 0)
    {
      this_hdr->sh_flags |= SHF_TLS;
      if (asect->_raw_size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *o;

	  this_hdr->sh_size = 0;
	  for (o = asect->link_order_head; o != NULL; o = o->next)
	    if (this_hdr->sh_size < o->offset + o->size)
	      this_hdr->sh_size = o->offset + o->size;
	  if (this_hdr->sh_size)
	    this_hdr->sh_type = SHT_NOBITS;
	}
    }
d1815 2
a1816 3
  if (bed->elf_backend_fake_sections
      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))
    *failedptr = TRUE;
d1826 2
a1827 109
				    asect->use_rela_p))
    *failedptr = TRUE;
}

/* Fill in the contents of a SHT_GROUP section.  */

void
bfd_elf_set_group_contents (abfd, sec, failedptrarg)
     bfd *abfd;
     asection *sec;
     PTR failedptrarg;
{
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
  unsigned long symindx;
  asection *elt, *first;
  unsigned char *loc;
  struct bfd_link_order *l;
  bfd_boolean gas;

  if (elf_section_data (sec)->this_hdr.sh_type != SHT_GROUP
      || *failedptr)
    return;

  symindx = 0;
  if (elf_group_id (sec) != NULL)
    symindx = elf_group_id (sec)->udata.i;

  if (symindx == 0)
    {
      /* If called from the assembler, swap_out_syms will have set up
	 elf_section_syms;  If called for "ld -r", use target_index.  */
      if (elf_section_syms (abfd) != NULL)
	symindx = elf_section_syms (abfd)[sec->index]->udata.i;
      else
	symindx = sec->target_index;
    }
  elf_section_data (sec)->this_hdr.sh_info = symindx;

  /* The contents won't be allocated for "ld -r" or objcopy.  */
  gas = TRUE;
  if (sec->contents == NULL)
    {
      gas = FALSE;
      sec->contents = bfd_alloc (abfd, sec->_raw_size);

      /* Arrange for the section to be written out.  */
      elf_section_data (sec)->this_hdr.contents = sec->contents;
      if (sec->contents == NULL)
	{
	  *failedptr = TRUE;
	  return;
	}
    }

  loc = sec->contents + sec->_raw_size;

  /* Get the pointer to the first section in the group that gas
     squirreled away here.  objcopy arranges for this to be set to the
     start of the input section group.  */
  first = elt = elf_next_in_group (sec);

  /* First element is a flag word.  Rest of section is elf section
     indices for all the sections of the group.  Write them backwards
     just to keep the group in the same order as given in .section
     directives, not that it matters.  */
  while (elt != NULL)
    {
      asection *s;
      unsigned int idx;

      loc -= 4;
      s = elt;
      if (!gas)
	s = s->output_section;
      idx = 0;
      if (s != NULL)
	idx = elf_section_data (s)->this_idx;
      H_PUT_32 (abfd, idx, loc);
      elt = elf_next_in_group (elt);
      if (elt == first)
	break;
    }

  /* If this is a relocatable link, then the above did nothing because
     SEC is the output section.  Look through the input sections
     instead.  */
  for (l = sec->link_order_head; l != NULL; l = l->next)
    if (l->type == bfd_indirect_link_order
	&& (elt = elf_next_in_group (l->u.indirect.section)) != NULL)
      do
	{
	  loc -= 4;
	  H_PUT_32 (abfd,
		    elf_section_data (elt->output_section)->this_idx, loc);
	  elt = elf_next_in_group (elt);
	  /* During a relocatable link, the lists are circular.  */
	}
      while (elt != elf_next_in_group (l->u.indirect.section));

  /* With ld -r, merging SHT_GROUP sections results in wasted space
     due to allowing for the flag word on each input.  We may well
     duplicate entries too.  */
  while ((loc -= 4) > sec->contents)
    H_PUT_32 (abfd, 0, loc);

  if (loc != sec->contents)
    abort ();

  H_PUT_32 (abfd, sec->flags & SEC_LINK_ONCE ? GRP_COMDAT : 0, loc);
d1834 1
a1834 1
static bfd_boolean
d1840 1
a1840 1
  unsigned int section_number, secn;
a1841 1
  bfd_size_type amt;
a1844 2
  _bfd_elf_strtab_clear_all_refs (elf_shstrtab (abfd));

a1848 2
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a1849 1
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->this_hdr.sh_name);
d1853 1
a1853 6
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->rel_idx = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr.sh_name);
	}
d1856 1
a1856 6
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->rel_idx2 = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr2->sh_name);
	}
a1860 2
  if (section_number == SHN_LORESERVE)
    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a1861 1
  _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->shstrtab_hdr.sh_name);
d1863 1
a1866 2
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a1867 14
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->symtab_hdr.sh_name);
      if (section_number > SHN_LORESERVE - 2)
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  t->symtab_shndx_section = section_number++;
	  t->symtab_shndx_hdr.sh_name
	    = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
						  ".symtab_shndx", FALSE);
	  if (t->symtab_shndx_hdr.sh_name == (unsigned int) -1)
	    return FALSE;
	}
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a1868 1
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);
a1870 4
  _bfd_elf_strtab_finalize (elf_shstrtab (abfd));
  t->shstrtab_hdr.sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));

  elf_numsections (abfd) = section_number;
a1871 2
  if (section_number > SHN_LORESERVE)
    elf_elfheader (abfd)->e_shnum -= SHN_HIRESERVE + 1 - SHN_LORESERVE;
d1875 2
a1876 2
  amt = section_number * sizeof (Elf_Internal_Shdr *);
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
d1878 1
a1878 1
    return FALSE;
d1880 2
a1881 2
  amt = sizeof (Elf_Internal_Shdr);
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d1885 1
a1885 1
      return FALSE;
d1887 1
a1894 5
      if (elf_numsections (abfd) > SHN_LORESERVE)
	{
	  i_shdrp[t->symtab_shndx_section] = &t->symtab_shndx_hdr;
	  t->symtab_shndx_hdr.sh_link = t->symtab_section;
	}
d1963 1
a1963 1
	      alc = (char *) bfd_malloc ((bfd_size_type) (len - 2));
d1965 2
a1966 2
		return FALSE;
	      memcpy (alc, sec->name, len - 3);
d1975 2
a1976 3
		  if (elf_section_data (s)->this_hdr.sh_entsize == 0)
		    elf_section_data (s)->this_hdr.sh_entsize
		      = 4 + 2 * bfd_get_arch_size (abfd) / 8;
a2000 3

	case SHT_GROUP:
	  d->this_hdr.sh_link = t->symtab_section;
d2004 1
a2004 7
  for (secn = 1; secn < section_number; ++secn)
    if (i_shdrp[secn] == NULL)
      i_shdrp[secn] = i_shdrp[0];
    else
      i_shdrp[secn]->sh_name = _bfd_elf_strtab_offset (elf_shstrtab (abfd),
						       i_shdrp[secn]->sh_name);
  return TRUE;
d2025 1
a2025 1
static bfd_boolean
d2029 1
a2029 1
  unsigned int symcount = bfd_get_symcount (abfd);
d2032 4
a2035 4
  unsigned int num_locals = 0;
  unsigned int num_globals = 0;
  unsigned int num_locals2 = 0;
  unsigned int num_globals2 = 0;
d2037 2
a2038 1
  unsigned int idx;
d2041 1
a2041 1
  bfd_size_type amt;
d2048 2
d2057 1
a2057 2
  amt = max_index * sizeof (asymbol *);
  sect_syms = (asymbol **) bfd_zalloc (abfd, amt);
d2059 1
a2059 1
    return FALSE;
a2060 1
  elf_num_section_syms (abfd) = max_index;
a2061 2
  /* Init sect_syms entries for any section symbols we have already
     decided to output.  */
d2064 1
a2064 1
      asymbol *sym = syms[idx];
d2082 9
a2090 10
		  /* Empty sections in the input files may have had a
		     section symbol created for them.  (See the comment
		     near the end of _bfd_generic_link_output_symbols in
		     linker.c).  If the linker script discards such
		     sections then we will reach this point.  Since we know
		     that we cannot avoid this case, we detect it and skip
		     the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the
		     linker testsuite test ld-scripts/weak.exp for an ELF
		     port that uses the generic linker.  */
d2101 25
a2125 2
  /* Classify all of the symbols.  */
  for (idx = 0; idx < symcount; idx++)
a2131 5

  /* We will be adding a section symbol for each BFD section.  Most normal
     sections will already have a section symbol in outsymbols, but
     eg. SHT_GROUP sections will not, and we need the section symbol mapped
     at least in that case.  */
d2134 2
a2135 1
      if (sect_syms[asect->index] == NULL)
d2137 2
a2138 1
	  if (!sym_is_global (abfd, asect->symbol))
d2142 1
d2147 3
a2149 3
  amt = (num_locals + num_globals) * sizeof (asymbol *);
  new_syms = (asymbol **) bfd_alloc (abfd, amt);

d2151 1
a2151 1
    return FALSE;
d2156 1
a2156 1
      unsigned int i;
d2167 2
a2168 1
      if (sect_syms[asect->index] == NULL)
d2170 2
a2171 2
	  asymbol *sym = asect->symbol;
	  unsigned int i;
d2173 1
a2173 1
	  sect_syms[asect->index] = sym;
d2187 1
a2187 1
  return TRUE;
d2193 1
a2193 2
static INLINE file_ptr align_file_position
  PARAMS ((file_ptr, int));
d2209 1
a2209 1
     bfd_boolean align;
d2231 1
a2231 1
bfd_boolean
d2237 1
a2237 1
  bfd_boolean failed;
d2242 1
a2242 1
    return TRUE;
d2249 1
a2249 1
    return FALSE;
d2255 1
a2255 1
  failed = FALSE;
d2258 1
a2258 1
    return FALSE;
d2261 1
a2261 1
    return FALSE;
d2270 1
a2270 8
	return FALSE;
    }

  if (link_info == NULL)
    {
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	return FALSE;
d2278 1
a2278 1
  shstrtab_hdr->sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));
d2286 1
a2286 1
    return FALSE;
d2296 1
a2296 5
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      if (hdr->sh_size != 0)
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d2299 1
a2299 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d2307 1
a2307 1
	return FALSE;
d2311 1
a2311 1
  abfd->output_has_begun = TRUE;
d2313 1
a2313 1
  return TRUE;
d2324 1
a2324 1
     bfd_boolean phdr;
a2328 1
  bfd_size_type amt;
d2330 4
a2333 3
  amt = sizeof (struct elf_segment_map);
  amt += (to - from - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d2354 1
a2354 1
static bfd_boolean
d2369 3
a2371 6
  bfd_boolean phdr_in_segment = TRUE;
  bfd_boolean writable;
  int tls_count = 0;
  asection *first_tls = NULL;
  asection *dynsec, *eh_frame_hdr;
  bfd_size_type amt;
d2374 1
a2374 1
    return TRUE;
d2377 1
a2377 1
    return TRUE;
d2381 2
a2382 2
  amt = bfd_count_sections (abfd) * sizeof (asection *);
  sections = (asection **) bfd_malloc (amt);
d2411 2
a2412 2
      amt = sizeof (struct elf_segment_map);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d2425 2
a2426 2
      amt = sizeof (struct elf_segment_map);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d2444 1
a2444 1
  writable = FALSE;
d2464 1
a2464 1
	phdr_in_segment = FALSE;
d2470 1
a2470 1
      bfd_boolean new_segment;
d2481 1
a2481 1
	  new_segment = FALSE;
d2488 1
a2488 1
	  new_segment = TRUE;
d2495 1
a2495 1
	  new_segment = TRUE;
d2502 1
a2502 1
	  new_segment = TRUE;
d2509 1
a2509 1
	  new_segment = FALSE;
d2513 2
a2514 3
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
d2523 1
a2523 1
	  new_segment = TRUE;
d2528 1
a2528 1
	  new_segment = FALSE;
d2534 1
a2534 1
	    writable = TRUE;
d2550 1
a2550 1
	writable = TRUE;
d2552 1
a2552 1
	writable = FALSE;
d2556 1
a2556 1
      phdr_in_segment = FALSE;
d2573 2
a2574 2
      amt = sizeof (struct elf_segment_map);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d2596 2
a2597 2
	  amt = sizeof (struct elf_segment_map);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
a2607 52
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  if (! tls_count)
	    first_tls = s;
	  tls_count++;
	}
    }

  /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
  if (tls_count > 0)
    {
      int i;

      amt = sizeof (struct elf_segment_map);
      amt += (tls_count - 1) * sizeof (asection *);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_TLS;
      m->count = tls_count;
      /* Mandated PF_R.  */
      m->p_flags = PF_R;
      m->p_flags_valid = 1;
      for (i = 0; i < tls_count; ++i)
	{
	  BFD_ASSERT (first_tls->flags & SEC_THREAD_LOCAL);
	  m->sections[i] = first_tls;
	  first_tls = first_tls->next;
	}

      *pm = m;
      pm = &m->next;
    }

  /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME
     segment.  */
  eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
  if (eh_frame_hdr != NULL
      && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
    {
      amt = sizeof (struct elf_segment_map);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_EH_FRAME;
      m->count = 1;
      m->sections[0] = eh_frame_hdr->output_section;

      *pm = m;
      pm = &m->next;
d2614 1
a2614 1
  return TRUE;
d2619 1
a2619 1
  return FALSE;
a2630 1
  bfd_size_type size1, size2;
d2648 1
a2648 1
#define TOEND(x) (((x)->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)
d2653 1
a2653 6
	{
	  /* If the indicies are the same, do not return 0
	     here, but continue to try the next comparison.  */
	  if (sec1->target_index - sec2->target_index != 0)
	    return sec1->target_index - sec2->target_index;
	}
d2657 2
a2658 1
  else if (TOEND (sec2))
d2663 2
a2664 2
  /* Sort by size, to put zero sized sections
     before others at the same address.  */
d2666 1
a2666 4
  size1 = (sec1->flags & SEC_LOAD) ? sec1->_raw_size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->_raw_size : 0;

  if (size1 < size2)
d2668 1
a2668 1
  if (size1 > size2)
d2678 1
a2678 1
static bfd_boolean
a2690 1
  bfd_size_type amt;
d2695 1
a2695 32
	return FALSE;
    }
  else
    {
      /* The placement algorithm assumes that non allocated sections are
	 not in PT_LOAD segments.  We ensure this here by removing such
	 sections from the segment map.  */
      for (m = elf_tdata (abfd)->segment_map;
	   m != NULL;
	   m = m->next)
	{
	  unsigned int new_count;
	  unsigned int i;

	  if (m->p_type != PT_LOAD)
	    continue;

	  new_count = 0;
	  for (i = 0; i < m->count; i ++)
	    {
	      if ((m->sections[i]->flags & SEC_ALLOC) != 0)
		{
		  if (i != new_count)
		    m->sections[new_count] = m->sections[i];

		  new_count ++;
		}
	    }

	  if (new_count != m->count)
	    m->count = new_count;
	}
d2701 1
a2701 1
	return FALSE;
d2713 1
a2713 1
    return TRUE;
d2725 1
a2725 1
      return FALSE;
d2731 2
a2732 2
  amt = alloc * sizeof (Elf_Internal_Phdr);
  phdrs = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d2734 1
a2734 1
    return FALSE;
d2752 2
a2753 7
         sections may not be correctly ordered.  NOTE: sorting should
	 not be done to the PT_NOTE section of a corefile, which may
	 contain several pseudo-sections artificially created by bfd.
	 Sorting these pseudo-sections breaks things badly.  */
      if (m->count > 1
	  && !(elf_elfheader (abfd)->e_type == ET_CORE
	       && m->p_type == PT_NOTE))
d2821 2
a2822 3
		  (*_bfd_error_handler)
		    (_("%s: Not enough room for program headers, try linking with -N"),
		     bfd_get_filename (abfd));
d2824 1
a2824 1
		  return FALSE;
d2905 2
a2906 2
	     cumulative phdr lma and the section's lma.  */
	  if (p->p_paddr + p->p_memsz < sec->lma)
d2908 1
a2908 1
	      bfd_vma adjust = sec->lma - (p->p_paddr + p->p_memsz);
d2911 3
a2913 9
	      if (p->p_type == PT_LOAD
		  || (p->p_type == PT_NOTE
		      && bfd_get_format (abfd) == bfd_core))
		{
		  off += adjust;
		  voff += adjust;
		}
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_THREAD_LOCAL) != 0)
d2946 8
a2953 6
		      (* _bfd_error_handler) (_("\
Error: First section in segment (%s) starts at 0x%x whereas the segment starts at 0x%x"),
					      bfd_section_name (abfd, sec),
					      sec->lma,
					      p->p_paddr);
		      return FALSE;
d2972 1
a2972 3
	      if ((flags & SEC_ALLOC) != 0
		  && ((flags & SEC_LOAD) != 0
		      || (flags & SEC_THREAD_LOCAL) == 0))
a2998 3
	      if ((sec->flags & SEC_LOAD) != 0
		  || (sec->flags & SEC_THREAD_LOCAL) == 0
		  || p->p_type == PT_TLS)
a3003 14
	      if (p->p_type == PT_TLS
		  && sec->_raw_size == 0
		  && (sec->flags & SEC_HAS_CONTENTS) == 0)
		{
		  struct bfd_link_order *o;
		  bfd_vma tbss_size = 0;

		  for (o = sec->link_order_head; o != NULL; o = o->next)
		    if (tbss_size < o->offset + o->size)
		      tbss_size = o->offset + o->size;

		  p->p_memsz += tbss_size;
		}

d3060 1
a3060 1
  if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, SEEK_SET) != 0
d3062 1
a3062 1
    return FALSE;
d3064 1
a3064 1
  return TRUE;
a3120 6
  if (elf_tdata (abfd)->eh_frame_hdr)
    {
      /* We need a PT_GNU_EH_FRAME segment.  */
      ++segs;
    }

a3130 10
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  /* We need a PT_TLS segment.  */
	  ++segs;
	  break;
	}
    }

d3157 1
a3157 1
static bfd_boolean
a3163 1
  unsigned int num_sec = elf_numsections (abfd);
d3179 1
a3179 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
d3184 6
a3189 4
	  if (hdr->sh_type == SHT_REL
	      || hdr->sh_type == SHT_RELA
	      || i == tdata->symtab_section
	      || i == tdata->symtab_shndx_section
d3193 1
a3194 2
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3196 1
a3196 5
	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
d3207 1
a3207 1
	return FALSE;
d3212 1
a3212 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
d3233 1
a3233 1
							       FALSE);
a3237 1
		   || hdr == i_shdrpp[tdata->symtab_shndx_section]
d3241 1
a3241 7
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
d3252 1
a3252 1
  return TRUE;
d3255 1
a3255 1
static bfd_boolean
d3262 2
a3263 1
  struct elf_strtab_hash *shstrtab;
d3269 1
a3269 1
  shstrtab = _bfd_elf_strtab_init ();
d3271 1
a3271 1
    return FALSE;
d3285 6
d3305 95
a3399 9

      /* There used to be a long list of cases here, each one setting
	 e_machine to the same EM_* macro #defined as ELF_MACHINE_CODE
	 in the corresponding bfd definition.  To avoid duplication,
	 the switch was removed.  Machines that need special handling
	 can generally do it in elf_backend_final_write_processing(),
	 unless they need the information earlier than the final write.
	 Such need can generally be supplied by replacing the tests for
	 e_machine with the conditions used to determine it.  */
d3401 2
a3402 6
      if (get_elf_backend_data (abfd) != NULL)
	i_ehdrp->e_machine = get_elf_backend_data (abfd)->elf_machine_code;
      else
	i_ehdrp->e_machine = EM_NONE;
      }

d3437 1
a3437 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", FALSE);
d3439 1
a3439 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", FALSE);
d3441 1
a3441 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", FALSE);
d3445 1
a3445 1
    return FALSE;
d3447 1
a3447 1
  return TRUE;
d3458 1
a3458 1
  unsigned int i, num_sec;
d3463 3
a3465 2
  num_sec = elf_numsections (abfd);
  for (i = 1, shdrpp = elf_elfsections (abfd) + 1; i < num_sec; i++, shdrpp++)
d3472 1
a3472 1
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, TRUE);
d3478 1
a3478 1
bfd_boolean
d3485 2
a3486 2
  bfd_boolean failed;
  unsigned int count, num_sec;
d3491 1
a3491 1
    return FALSE;
d3496 1
a3496 1
  failed = FALSE;
d3499 1
a3499 1
    return FALSE;
d3504 1
a3504 2
  num_sec = elf_numsections (abfd);
  for (count = 1; count < num_sec; count++)
a3509 2
	  bfd_size_type amt = i_shdrp[count]->sh_size;

d3511 4
a3514 2
	      || bfd_bwrite (i_shdrp[count]->contents, amt, abfd) != amt)
	    return FALSE;
a3515 2
      if (count == SHN_LORESERVE - 1)
	count += SHN_HIRESERVE + 1 - SHN_LORESERVE;
d3520 2
a3521 2
      || ! _bfd_elf_strtab_emit (abfd, elf_shstrtab (abfd)))
    return FALSE;
d3530 1
a3530 1
bfd_boolean
d3545 2
a3546 1
  struct elf_backend_data *bed;
d3548 2
d3551 6
a3556 3
  if (elf_section_data (asect) != NULL
      && elf_section_data (asect)->this_idx != 0)
    return elf_section_data (asect)->this_idx;
d3558 1
a3558 7
  if (bfd_is_abs_section (asect))
    index = SHN_ABS;
  else if (bfd_is_com_section (asect))
    index = SHN_COMMON;
  else if (bfd_is_und_section (asect))
    index = SHN_UNDEF;
  else
d3560 1
a3560 4
      Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
      int maxindex = elf_numsections (abfd);

      for (index = 1; index < maxindex; index++)
d3562 1
a3562 1
	  Elf_Internal_Shdr *hdr = i_shdrp[index];
d3564 5
a3568 2
	  if (hdr != NULL && hdr->bfd_section == asect)
	    return index;
a3569 1
      index = -1;
d3572 6
a3577 8
  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_from_bfd_section)
    {
      int retval = index;

      if ((*bed->elf_backend_section_from_bfd_section) (abfd, asect, &retval))
	return retval;
    }
d3579 1
a3579 2
  if (index == -1)
    bfd_set_error (bfd_error_nonrepresentable_section);
d3581 1
a3581 1
  return index;
d3611 1
a3611 2
      if (indx < elf_num_section_syms (abfd)
	  && elf_section_syms (abfd)[indx] != NULL)
d3623 1
a3623 1
	 bfd_archive_filename (abfd), bfd_asymbol_name (asym_ptr));
d3631 1
a3631 1
	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n",
d3643 1
a3643 1
static bfd_boolean
d3648 12
a3659 13
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
  struct elf_backend_data *bed;
d3663 1
a3663 1
    return TRUE;
d3666 1
a3666 1
    return TRUE;
a3667 1
  bed = get_elf_backend_data (ibfd);
d3677 3
a3679 8
#define SEGMENT_END(segment, start)					\
  (start + (segment->p_memsz > segment->p_filesz			\
	    ? segment->p_memsz : segment->p_filesz))

#define SECTION_SIZE(section, segment)					\
  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\
    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\
   ? section->_raw_size : 0)
d3681 1
a3681 1
  /* Returns TRUE if the given section is contained within
d3683 4
a3686 4
#define IS_CONTAINED_BY_VMA(section, segment)				\
  (section->vma >= segment->p_vaddr					\
   && (section->vma + SECTION_SIZE (section, segment)			\
       <= (SEGMENT_END (segment, segment->p_vaddr))))
d3688 1
a3688 1
  /* Returns TRUE if the given section is contained within
d3690 4
a3693 4
#define IS_CONTAINED_BY_LMA(section, segment, base)			\
  (section->lma >= base							\
   && (section->lma + SECTION_SIZE (section, segment)			\
       <= SEGMENT_END (segment, base)))
d3696 7
a3702 7
#define IS_COREFILE_NOTE(p, s)						\
  (p->p_type == PT_NOTE							\
   && bfd_get_format (ibfd) == bfd_core					\
   && s->vma == 0 && s->lma == 0					\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))
d3707 8
a3714 10
#define IS_SOLARIS_PT_INTERP(p, s)					\
  (p->p_vaddr == 0							\
   && p->p_paddr == 0							\
   && p->p_memsz == 0							\
   && p->p_filesz > 0							\
   && (s->flags & SEC_HAS_CONTENTS) != 0				\
   && s->_raw_size > 0							\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))
d3718 1
a3718 2
       1. It is within the address space of the segment -- we use the LMA
          if that is set for the segment and the VMA otherwise,
d3721 16
a3736 32
       4. The section has not already been allocated to a previous segment.
       5. PT_TLS segment includes only SHF_TLS sections.
       6. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
  ((((segment->p_paddr							\
      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
      : IS_CONTAINED_BY_VMA (section, segment))				\
     && (section->flags & SEC_ALLOC) != 0)				\
    || IS_COREFILE_NOTE (segment, section))				\
   && section->output_section != NULL					\
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
   && ! section->segment_mark)

  /* Returns TRUE iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)			\
  (seg1->field >= SEGMENT_END (seg2, seg2->field))

  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both
     their VMA address ranges and their LMA address ranges overlap.
     It is possible to have overlapping VMA ranges without overlapping LMA
     ranges.  RedBoot images for example can have both .data and .bss mapped
     to the same VMA range, but with the .data section mapped to a different
     LMA.  */
#define SEGMENT_OVERLAPS(seg1, seg2)					\
  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\
   && !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))
d3740 1
a3740 1
    section->segment_mark = FALSE;
d3744 2
a3745 2
     in the loadable segments.  These can be created by weird
     parameters to objcopy.  Also, fix some solaris weirdness.  */
a3752 10
      if (segment->p_type == PT_INTERP)
	for (section = ibfd->sections; section; section = section->next)
	  if (IS_SOLARIS_PT_INTERP (segment, section))
	    {
	      /* Mininal change so that the normal section to segment
		 assigment code will work.  */
	      segment->p_vaddr = section->vma;
	      break;
	    }

a3817 1
      bfd_size_type amt;
d3823 3
a3825 4
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
d3828 6
a3833 5
      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
      amt = sizeof (struct elf_segment_map);
      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d3835 1
a3835 1
	return FALSE;
d3862 1
a3862 1
	    phdr_included = TRUE;
d3869 1
a3869 2
	     something.  They are allowed by the ELF spec however, so only
	     a warning is produced.  */
d3871 3
a3873 3
	    (*_bfd_error_handler)
	      (_("%s: warning: Empty loadable segment detected, is this intentional ?\n"),
	       bfd_archive_filename (ibfd));
d3901 1
a3901 1
	 4. The sections have been moved, but not by the same amount.
d3910 2
a3911 4
      /* Gcc 2.96 miscompiles this code on mips. Don't do casting here
	 to work around this long long bug.  */
      amt = section_count * sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
d3913 1
a3913 1
	return FALSE;
d3929 1
a3929 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
d3937 1
a3937 2
		 correct value.  Note - some backends require that
		 p_paddr be left as zero.  */
a3939 1
		  && (! bed->want_p_paddr_set_to_zero)
d3947 1
a3947 2
						 ? (iehdr->e_phnum
						    * iehdr->e_phentsize)
d3954 1
a3954 4
		  || IS_COREFILE_NOTE (segment, section)
		  || (bed->want_p_paddr_set_to_zero &&
		      IS_CONTAINED_BY_VMA (output_section, segment))
                )
d4023 1
a4023 1
	 those that fit to the current segment and removing them from the
d4072 3
a4074 5
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size,
				      maxpagesize)
			   < BFD_ALIGN (output_section->lma, maxpagesize))
			  || ((prev_sec->lma + prev_sec->_raw_size)
			      > output_section->lma))
d4086 1
a4086 1
		  section->segment_mark = TRUE;
d4103 5
a4107 3
	      amt = sizeof (struct elf_segment_map);
	      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
	      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d4109 1
a4109 4
		{
		  free (sections);
		  return FALSE;
		}
d4137 4
a4140 2
    for (map = map_first; map != NULL; map = map->next)
      map->p_paddr_valid = 0;
d4145 1
a4145 1
     going to be needed, then check our estimate now and adjust
a4184 1
#undef SECTION_SIZE
d4192 1
a4192 1
  return TRUE;
d4198 1
a4198 1
bfd_boolean
d4209 1
a4209 1
    return TRUE;
d4211 7
a4217 1
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
d4219 1
a4219 1
	asection *s;
d4221 12
a4232 12
	/* Only set up the segments if there are no more SEC_ALLOC
	   sections.  FIXME: This won't do the right thing if objcopy is
	   used to remove the last SEC_ALLOC section, since objcopy
	   won't call this routine in that case.  */
	for (s = isec->next; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) != 0)
	    break;
	if (s == NULL)
	  {
	    if (! copy_private_bfd_data (ibfd, obfd))
	      return FALSE;
	  }
d4246 2
a4247 5
  /* Set things up for objcopy.  The output SHT_GROUP section will
     have its elf_next_in_group pointing back to the input group
     members.  */
  elf_next_in_group (osec) = elf_next_in_group (isec);
  elf_group_name (osec) = elf_group_name (isec);
d4249 1
a4249 3
  osec->use_rela_p = isec->use_rela_p;

  return TRUE;
d4258 4
a4261 5
#define MAP_ONESYMTAB (SHN_HIOS + 1)
#define MAP_DYNSYMTAB (SHN_HIOS + 2)
#define MAP_STRTAB    (SHN_HIOS + 3)
#define MAP_SHSTRTAB  (SHN_HIOS + 4)
#define MAP_SYM_SHNDX (SHN_HIOS + 5)
d4263 1
a4263 1
bfd_boolean
d4274 1
a4274 1
    return TRUE;
a4293 2
      else if (shndx == elf_tdata (ibfd)->symtab_shndx_section)
	shndx = MAP_SYM_SHNDX;
d4297 1
a4297 1
  return TRUE;
d4302 1
a4302 1
static bfd_boolean
d4308 1
a4308 11
  struct elf_backend_data *bed;
  int symcount;
  asymbol **syms;
  struct bfd_strtab_hash *stt;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  char *outbound_syms;
  char *outbound_shndx;
  int idx;
  bfd_size_type amt;
d4311 1
a4311 1
    return FALSE;
d4314 28
a4341 15
  stt = _bfd_elf_stringtab_init ();
  if (stt == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);
  symcount = bfd_get_symcount (abfd);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  symtab_hdr->sh_type = SHT_SYMTAB;
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
  symtab_hdr->sh_info = elf_num_locals (abfd) + 1;
  symtab_hdr->sh_addralign = bed->s->file_align;

  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  symstrtab_hdr->sh_type = SHT_STRTAB;
d4343 1
a4343 3
  amt = (bfd_size_type) (1 + symcount) * bed->s->sizeof_sym;
  outbound_syms = bfd_alloc (abfd, amt);
  if (outbound_syms == NULL)
d4345 10
a4354 2
      _bfd_stringtab_free (stt);
      return FALSE;
d4356 21
a4376 1
  symtab_hdr->contents = (PTR) outbound_syms;
d4378 1
a4378 11
  outbound_shndx = NULL;
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      amt = (bfd_size_type) (1 + symcount) * sizeof (Elf_External_Sym_Shndx);
      outbound_shndx = bfd_zalloc (abfd, amt);
      if (outbound_shndx == NULL)
	{
	  _bfd_stringtab_free (stt);
	  return FALSE;
	}
d4380 19
a4398 6
      symtab_shndx_hdr->contents = outbound_shndx;
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_size = amt;
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
    }
d4400 40
a4439 15
  /* Now generate the data (for "contents").  */
  {
    /* Fill in zeroth symbol and swap it out.  */
    Elf_Internal_Sym sym;
    sym.st_name = 0;
    sym.st_value = 0;
    sym.st_size = 0;
    sym.st_info = 0;
    sym.st_other = 0;
    sym.st_shndx = SHN_UNDEF;
    bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
    outbound_syms += bed->s->sizeof_sym;
    if (outbound_shndx != NULL)
      outbound_shndx += sizeof (Elf_External_Sym_Shndx);
  }
d4441 3
a4443 8
  syms = bfd_get_outsymbols (abfd);
  for (idx = 0; idx < symcount; idx++)
    {
      Elf_Internal_Sym sym;
      bfd_vma value = syms[idx]->value;
      elf_symbol_type *type_ptr;
      flagword flags = syms[idx]->flags;
      int type;
d4445 13
a4457 16
      if ((flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
	{
	  /* Local section symbols have no name.  */
	  sym.st_name = 0;
	}
      else
	{
	  sym.st_name = (unsigned long) _bfd_stringtab_add (stt,
							    syms[idx]->name,
							    TRUE, FALSE);
	  if (sym.st_name == (unsigned long) -1)
	    {
	      _bfd_stringtab_free (stt);
	      return FALSE;
	    }
	}
d4459 2
a4460 1
      type_ptr = elf_symbol_from (abfd, syms[idx]);
d4462 6
a4467 19
      if ((flags & BSF_SECTION_SYM) == 0
	  && bfd_is_com_section (syms[idx]->section))
	{
	  /* ELF common symbols put the alignment into the `value' field,
	     and the size into the `size' field.  This is backwards from
	     how BFD handles it, so reverse it here.  */
	  sym.st_size = value;
	  if (type_ptr == NULL
	      || type_ptr->internal_elf_sym.st_value == 0)
	    sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
	  else
	    sym.st_value = type_ptr->internal_elf_sym.st_value;
	  sym.st_shndx = _bfd_elf_section_from_bfd_section
	    (abfd, syms[idx]->section);
	}
      else
	{
	  asection *sec = syms[idx]->section;
	  int shndx;
d4469 19
a4487 5
	  if (sec->output_section)
	    {
	      value += sec->output_offset;
	      sec = sec->output_section;
	    }
d4489 6
a4494 38
	  /* Don't add in the section vma for relocatable output.  */
	  if (! relocatable_p)
	    value += sec->vma;
	  sym.st_value = value;
	  sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

	  if (bfd_is_abs_section (sec)
	      && type_ptr != NULL
	      && type_ptr->internal_elf_sym.st_shndx != 0)
	    {
	      /* This symbol is in a real ELF section which we did
		 not create as a BFD section.  Undo the mapping done
		 by copy_private_symbol_data.  */
	      shndx = type_ptr->internal_elf_sym.st_shndx;
	      switch (shndx)
		{
		case MAP_ONESYMTAB:
		  shndx = elf_onesymtab (abfd);
		  break;
		case MAP_DYNSYMTAB:
		  shndx = elf_dynsymtab (abfd);
		  break;
		case MAP_STRTAB:
		  shndx = elf_tdata (abfd)->strtab_section;
		  break;
		case MAP_SHSTRTAB:
		  shndx = elf_tdata (abfd)->shstrtab_section;
		  break;
		case MAP_SYM_SHNDX:
		  shndx = elf_tdata (abfd)->symtab_shndx_section;
		  break;
		default:
		  break;
		}
	    }
	  else
	    {
	      shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d4496 2
a4497 3
	      if (shndx == -1)
		{
		  asection *sec2;
d4499 4
a4502 18
		  /* Writing this would be a hell of a lot easier if
		     we had some decent documentation on bfd, and
		     knew what to expect of the library, and what to
		     demand of applications.  For example, it
		     appears that `objcopy' might not set the
		     section of a symbol to be a section that is
		     actually in the output file.  */
		  sec2 = bfd_get_section_by_name (abfd, sec->name);
		  if (sec2 == NULL)
		    {
		      _bfd_error_handler (_("\
Unable to find equivalent output section for symbol '%s' from section '%s'"),
					  syms[idx]->name ? syms[idx]->name : "<Local sym>",
					  sec->name);
		      bfd_set_error (bfd_error_invalid_operation);
		      _bfd_stringtab_free (stt);
		      return FALSE;
		    }
d4504 3
a4506 4
		  shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
		  BFD_ASSERT (shndx != -1);
		}
	    }
d4508 11
a4518 47
	  sym.st_shndx = shndx;
	}

      if ((flags & BSF_THREAD_LOCAL) != 0)
	type = STT_TLS;
      else if ((flags & BSF_FUNCTION) != 0)
	type = STT_FUNC;
      else if ((flags & BSF_OBJECT) != 0)
	type = STT_OBJECT;
      else
	type = STT_NOTYPE;

      if (syms[idx]->section->flags & SEC_THREAD_LOCAL)
	type = STT_TLS;

      /* Processor-specific types.  */
      if (type_ptr != NULL
	  && bed->elf_backend_get_symbol_type)
	type = ((*bed->elf_backend_get_symbol_type)
		(&type_ptr->internal_elf_sym, type));

      if (flags & BSF_SECTION_SYM)
	{
	  if (flags & BSF_GLOBAL)
	    sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  else
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	}
      else if (bfd_is_com_section (syms[idx]->section))
	sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
      else if (bfd_is_und_section (syms[idx]->section))
	sym.st_info = ELF_ST_INFO (((flags & BSF_WEAK)
				    ? STB_WEAK
				    : STB_GLOBAL),
				   type);
      else if (flags & BSF_FILE)
	sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
      else
	{
	  int bind = STB_LOCAL;

	  if (flags & BSF_LOCAL)
	    bind = STB_LOCAL;
	  else if (flags & BSF_WEAK)
	    bind = STB_WEAK;
	  else if (flags & BSF_GLOBAL)
	    bind = STB_GLOBAL;
d4520 1
a4520 26
	  sym.st_info = ELF_ST_INFO (bind, type);
	}

      if (type_ptr != NULL)
	sym.st_other = type_ptr->internal_elf_sym.st_other;
      else
	sym.st_other = 0;

      bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
      outbound_syms += bed->s->sizeof_sym;
      if (outbound_shndx != NULL)
	outbound_shndx += sizeof (Elf_External_Sym_Shndx);
    }

  *sttp = stt;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (stt);
  symstrtab_hdr->sh_type = SHT_STRTAB;

  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  symstrtab_hdr->sh_addralign = 1;

  return TRUE;
d4538 1
a4538 3
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);
d4558 1
a4558 3
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);
a4581 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4583 4
a4586 1
  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
d4603 2
a4604 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, FALSE);
d4616 2
a4617 6
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, TRUE);

  if (symcount >= 0)
    bfd_get_dynamic_symcount (abfd) = symcount;
  return symcount;
d4664 1
a4664 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d4685 1
a4685 1
	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
d4702 1
a4702 1
bfd_boolean
a4706 1
  bfd_size_type amt;
d4724 1
a4724 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d4743 3
a4745 2
      amt = (bfd_size_type) maxidx * sizeof (Elf_Internal_Verdef);
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *) bfd_zalloc (abfd, amt);
d4766 4
a4769 2
	  amt = (bfd_size_type) iverdef->vd_cnt * sizeof (Elf_Internal_Verdaux);
	  iverdef->vd_auxptr = (Elf_Internal_Verdaux *) bfd_alloc (abfd, amt);
a4818 1
      amt = (bfd_size_type) hdr->sh_info * sizeof (Elf_Internal_Verneed);
d4820 2
a4821 1
	(Elf_Internal_Verneed *) bfd_zalloc (abfd, amt);
d4831 1
a4831 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d4852 4
a4855 3
	  amt = iverneed->vn_cnt;
	  amt *= sizeof (Elf_Internal_Vernaux);
	  iverneed->vn_auxptr = (Elf_Internal_Vernaux *) bfd_alloc (abfd, amt);
d4892 1
a4892 1
  return TRUE;
d4895 1
a4895 1
  if (contents != NULL)
d4897 1
a4897 1
  return FALSE;
a4904 1
  bfd_size_type amt = sizeof (elf_symbol_type);
d4906 1
a4906 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d4929 1
a4929 1
bfd_boolean
d4936 1
a4936 1
    return TRUE;
d4941 1
a4941 1
    return TRUE;
d4950 1
a4950 1
    return TRUE;
d4952 1
a4952 1
  return FALSE;
d4964 1
a4964 1
bfd_boolean
d4975 1
a4975 1
    return FALSE;
d4983 1
a4983 1
static bfd_boolean
d5032 1
a5032 1
    return FALSE;
d5039 1
a5039 1
  return TRUE;
d5045 1
a5045 1
bfd_boolean
d5056 1
a5056 1
  bfd_boolean found;
d5067 1
a5067 1
      return TRUE;
d5080 1
a5080 1
      return TRUE;
d5087 3
a5089 3
    return FALSE;
  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;
d5092 1
a5092 1
    return FALSE;
d5096 1
a5096 1
    return FALSE;
d5099 1
a5099 1
  return TRUE;
d5105 1
a5105 1
     bfd_boolean reloc;
d5115 1
a5115 1
bfd_boolean
a5123 1
  bfd_signed_vma pos;
d5126 3
a5128 3
      && ! (_bfd_elf_compute_section_file_positions
	    (abfd, (struct bfd_link_info *) NULL)))
    return FALSE;
a5130 4
  pos = hdr->sh_offset + offset;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;
d5132 6
a5137 1
  return TRUE;
d5149 11
d5162 1
a5162 1
bfd_boolean
d5248 1
a5248 1
  return TRUE;
d5253 1
a5253 1
     bfd_archive_filename (abfd), areloc->howto->name);
d5255 1
a5255 1
  return FALSE;
d5258 1
a5258 1
bfd_boolean
d5265 1
a5265 1
	_bfd_elf_strtab_free (elf_shstrtab (abfd));
d5298 6
d5319 1
a5319 1
static bfd_boolean
d5328 1
a5328 1
    return TRUE;
d5332 1
a5332 1
    return FALSE;
d5338 1
a5338 40
  return TRUE;
}

/* Create a pseudosection containing SIZE bytes at FILEPOS.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents. */
bfd_boolean
_bfd_elfcore_make_pseudosection (abfd, name, size, filepos)
     bfd *abfd;
     char *name;
     size_t size;
     ufile_ptr filepos;
{
  char buf[100];
  char *threaded_name;
  size_t len;
  asection *sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  threaded_name = bfd_alloc (abfd, (bfd_size_type) len);
  if (threaded_name == NULL)
    return FALSE;
  memcpy (threaded_name, buf, len);

  sect = bfd_make_section (abfd, threaded_name);
  if (sect == NULL)
    return FALSE;
  sect->_raw_size = size;
  sect->filepos = filepos;
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, name, sect);
d5348 1
a5348 4
static bfd_boolean elfcore_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

static bfd_boolean
d5353 4
a5356 1
  size_t raw_size;
d5367 1
a5367 4
      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
d5390 1
a5390 4
      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
d5408 1
a5408 1
      return TRUE;
d5411 22
a5432 3
  /* Make a ".reg/999" section and a ".reg" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
d5436 9
a5444 2
/* Create a pseudosection containing the exact contents of NOTE.  */
static bfd_boolean
d5450 24
a5473 2
  return _bfd_elfcore_make_pseudosection (abfd, name,
					  note->descsz, note->descpos);
d5480 1
a5480 1
static bfd_boolean
d5492 1
a5492 1
static bfd_boolean
d5514 2
d5520 2
a5521 2
char *
_bfd_elfcore_strndup (abfd, start, max)
d5524 1
a5524 1
     size_t max;
d5526 1
a5526 1
  char *dups;
d5528 1
a5528 1
  size_t len;
d5535 2
a5536 2
  dups = bfd_alloc (abfd, (bfd_size_type) len + 1);
  if (dups == NULL)
d5539 2
a5540 2
  memcpy (dups, start, len);
  dups[len] = '\0';
d5542 1
a5542 1
  return dups;
d5545 1
a5545 5
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
static bfd_boolean elfcore_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));

static bfd_boolean
d5557 1
a5557 2
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));
d5560 1
a5560 2
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
d5571 1
a5571 2
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));
d5574 1
a5574 2
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
d5582 1
a5582 1
      return TRUE;
d5597 1
a5597 1
  return TRUE;
d5602 1
a5602 4
static bfd_boolean elfcore_grok_pstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

static bfd_boolean
d5634 1
a5634 1
  return TRUE;
d5639 1
a5639 4
static bfd_boolean elfcore_grok_lwpstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

static bfd_boolean
a5646 1
  size_t len;
d5654 1
a5654 1
    return TRUE;
d5664 1
a5664 2
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d5666 2
a5667 2
    return FALSE;
  memcpy (name, buf, len);
d5671 1
a5671 1
    return FALSE;
d5688 1
a5688 1
    return FALSE;
d5693 1
a5693 2
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d5695 2
a5696 2
    return FALSE;
  memcpy (name, buf, len);
d5700 1
a5700 1
    return FALSE;
d5716 4
a5719 1
  return elfcore_maybe_make_sect (abfd, ".reg2", sect);
d5724 1
a5724 1
static bfd_boolean
a5730 1
  size_t len;
d5735 1
a5735 1
    return TRUE;
d5737 1
a5737 1
  memcpy (&pstatus, note->descdata, sizeof (pstatus));
d5751 1
a5751 2
      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d5753 1
a5753 1
	return FALSE;
d5755 1
a5755 1
      memcpy (name, buf, len);
d5759 1
a5759 1
	return FALSE;
d5762 2
a5763 3
      sect->filepos = (note->descpos
		       + offsetof (struct win32_pstatus,
				   data.thread_info.thread_context));
d5769 1
a5769 1
	  return FALSE;
d5776 1
a5776 2
      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d5778 1
a5778 1
	return FALSE;
d5780 1
a5780 1
      memcpy (name, buf, len);
d5785 1
a5785 1
	return FALSE;
d5794 1
a5794 1
      return TRUE;
d5797 1
a5797 1
  return TRUE;
d5801 1
a5801 1
static bfd_boolean
a5805 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d5809 1
a5809 1
      return TRUE;
d5811 1
a5812 4
      if (bed->elf_backend_grok_prstatus)
	if ((*bed->elf_backend_grok_prstatus) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRSTATUS_T)
a5813 2
#else
      return TRUE;
d5835 2
a5836 2
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
d5839 1
a5839 1
	return TRUE;
d5841 1
a5843 4
      if (bed->elf_backend_grok_psinfo)
	if ((*bed->elf_backend_grok_psinfo) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
a5844 2
#else
      return TRUE;
d5849 1
a5849 395
static bfd_boolean
elfcore_netbsd_get_lwpid (note, lwpidp)
     Elf_Internal_Note *note;
     int *lwpidp;
{
  char *cp;

  cp = strchr (note->namedata, '@@');
  if (cp != NULL)
    {
      *lwpidp = atoi(cp + 1);
      return TRUE;
    }
  return FALSE;
}

static bfd_boolean
elfcore_grok_netbsd_procinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{

  /* Signal number at offset 0x08. */
  elf_tdata (abfd)->core_signal
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x08);

  /* Process ID at offset 0x50. */
  elf_tdata (abfd)->core_pid
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x50);

  /* Command name at 0x7c (max 32 bytes, including nul). */
  elf_tdata (abfd)->core_command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x7c, 31);

  return TRUE;
}

static bfd_boolean
elfcore_grok_netbsd_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int lwp;

  if (elfcore_netbsd_get_lwpid (note, &lwp))
    elf_tdata (abfd)->core_lwpid = lwp;

  if (note->type == NT_NETBSDCORE_PROCINFO)
    {
      /* NetBSD-specific core "procinfo".  Note that we expect to
         find this note before any of the others, which is fine,
         since the kernel writes this note out first when it
         creates a core file.  */

      return elfcore_grok_netbsd_procinfo (abfd, note);
    }

  /* As of Jan 2002 there are no other machine-independent notes
     defined for NetBSD core files.  If the note type is less
     than the start of the machine-dependent note types, we don't
     understand it.  */

  if (note->type < NT_NETBSDCORE_FIRSTMACH)
    return TRUE;


  switch (bfd_get_arch (abfd))
    {
    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0 and
       PT_GETFPREGS == mach+2.  */

    case bfd_arch_alpha:
    case bfd_arch_sparc:
      switch (note->type)
        {
        case NT_NETBSDCORE_FIRSTMACH+0:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+2:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }

    /* On all other arch's, PT_GETREGS == mach+1 and
       PT_GETFPREGS == mach+3.  */

    default:
      switch (note->type)
        {
        case NT_NETBSDCORE_FIRSTMACH+1:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+3:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }
    }
    /* NOTREACHED */
}

static bfd_boolean
elfcore_grok_nto_status (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t *tid;
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;

  /* nto_procfs_status 'pid' field is at offset 0.  */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, (bfd_byte *) ddata);

  /* nto_procfs_status 'tid' field is at offset 4.  */
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'what' field is at offset 14.  */
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, (bfd_byte *) ddata + 14);

  /* Pass tid back.  */
  *tid = elf_tdata (abfd)->core_lwpid;

  /* Make a ".qnx_core_status/%d" section.  */
  sprintf (buf, ".qnx_core_status/%d", *tid);

  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_gregs (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t tid;
{
  char buf[100];
  char *name;
  asection *sect;

  /* Make a ".reg/%d" section.  */
  sprintf (buf, ".reg/%d", tid);

  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, ".reg", sect);
}

#define BFD_QNT_CORE_INFO	7
#define BFD_QNT_CORE_STATUS	8
#define BFD_QNT_CORE_GREG	9
#define BFD_QNT_CORE_FPREG	10

static bfd_boolean
elfcore_grok_nto_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  /* Every GREG section has a STATUS section before it.  Store the
     tid from the previous call to pass down to the next gregs
     function.  */
  static pid_t tid = 1;

  switch (note->type)
    {
    case BFD_QNT_CORE_INFO:   return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS: return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:   return elfcore_grok_nto_gregs (abfd, note, tid);
    case BFD_QNT_CORE_FPREG:  return elfcore_grok_prfpreg (abfd, note);
    default:                  return TRUE;
    }
}

/* Function: elfcore_write_note

   Inputs:
     buffer to hold note
     name of note
     type of note
     data for note
     size of data for note

   Return:
   End of buffer containing note.  */

char *
elfcore_write_note (abfd, buf, bufsiz, name, type, input, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *name;
     int  type;
     const PTR input;
     int  size;
{
  Elf_External_Note *xnp;
  size_t namesz;
  size_t pad;
  size_t newspace;
  char *p, *dest;

  namesz = 0;
  pad = 0;
  if (name != NULL)
    {
      struct elf_backend_data *bed;

      namesz = strlen (name) + 1;
      bed = get_elf_backend_data (abfd);
      pad = -namesz & (bed->s->file_align - 1);
    }

  newspace = sizeof (Elf_External_Note) - 1 + namesz + pad + size;

  p = realloc (buf, *bufsiz + newspace);
  dest = p + *bufsiz;
  *bufsiz += newspace;
  xnp = (Elf_External_Note *) dest;
  H_PUT_32 (abfd, namesz, xnp->namesz);
  H_PUT_32 (abfd, size, xnp->descsz);
  H_PUT_32 (abfd, type, xnp->type);
  dest = xnp->name;
  if (name != NULL)
    {
      memcpy (dest, name, namesz);
      dest += namesz;
      while (pad != 0)
	{
	  *dest++ = '\0';
	  --pad;
	}
    }
  memcpy (dest, input, size);
  return p;
}

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
char *
elfcore_write_prpsinfo (abfd, buf, bufsiz, fname, psargs)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *fname;
     const char *psargs;
{
  int note_type;
  char *note_name = "CORE";

#if defined (HAVE_PSINFO_T)
  psinfo_t  data;
  note_type = NT_PSINFO;
#else
  prpsinfo_t data;
  note_type = NT_PRPSINFO;
#endif

  memset (&data, 0, sizeof (data));
  strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
  strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, note_type, &data, sizeof (data));
}
#endif	/* PSINFO_T or PRPSINFO_T */

#if defined (HAVE_PRSTATUS_T)
char *
elfcore_write_prstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
{
  prstatus_t prstat;
  char *note_name = "CORE";

  memset (&prstat, 0, sizeof (prstat));
  prstat.pr_pid = pid;
  prstat.pr_cursig = cursig;
  memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRSTATUS, &prstat, sizeof (prstat));
}
#endif /* HAVE_PRSTATUS_T */

#if defined (HAVE_LWPSTATUS_T)
char *
elfcore_write_lwpstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
{
  lwpstatus_t lwpstat;
  char *note_name = "CORE";

  memset (&lwpstat, 0, sizeof (lwpstat));
  lwpstat.pr_lwpid  = pid >> 16;
  lwpstat.pr_cursig = cursig;
#if defined (HAVE_LWPSTATUS_T_PR_REG)
  memcpy (lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
#elif defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
#if !defined(gregs)
  memcpy (lwpstat.pr_context.uc_mcontext.gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.gregs));
#else
  memcpy (lwpstat.pr_context.uc_mcontext.__gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.__gregs));
#endif
#endif
  return elfcore_write_note (abfd, buf, bufsiz, note_name,
			     NT_LWPSTATUS, &lwpstat, sizeof (lwpstat));
}
#endif /* HAVE_LWPSTATUS_T */

#if defined (HAVE_PSTATUS_T)
char *
elfcore_write_pstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
{
  pstatus_t pstat;
  char *note_name = "CORE";

  memset (&pstat, 0, sizeof (pstat));
  pstat.pr_pid = pid & 0xffff;
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
			    NT_PSTATUS, &pstat, sizeof (pstat));
  return buf;
}
#endif /* HAVE_PSTATUS_T */

char *
elfcore_write_prfpreg (abfd, buf, bufsiz, fpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR fpregs;
     int size;
{
  char *note_name = "CORE";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_FPREGSET, fpregs, size);
}

char *
elfcore_write_prxfpreg (abfd, buf, bufsiz, xfpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR xfpregs;
     int size;
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRXFPREG, xfpregs, size);
}

static bfd_boolean
d5852 2
a5853 2
     file_ptr offset;
     bfd_size_type size;
d5859 1
a5859 1
    return TRUE;
d5861 2
a5862 2
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;
d5864 1
a5864 1
  buf = bfd_malloc (size);
d5866 1
a5866 1
    return FALSE;
d5868 1
a5868 1
  if (bfd_bread (buf, size, abfd) != size)
d5872 1
a5872 1
      return FALSE;
d5882 1
a5882 1
      in.type = H_GET_32 (abfd, xnp->type);
d5884 1
a5884 1
      in.namesz = H_GET_32 (abfd, xnp->namesz);
d5887 1
a5887 1
      in.descsz = H_GET_32 (abfd, xnp->descsz);
d5891 2
a5892 15
      if (strncmp (in.namedata, "NetBSD-CORE", 11) == 0)
        {
          if (! elfcore_grok_netbsd_note (abfd, &in))
            goto error;
        }
      else if (strncmp (in.namedata, "QNX", 3) == 0)
	{
	  if (! elfcore_grok_nto_note (abfd, &in))
	    goto error;
	}
      else
        {
          if (! elfcore_grok_note (abfd, &in))
            goto error;
        }
d5898 16
a5913 1
  return TRUE;
d5932 2
a5933 1
  return elf_elfheader (abfd)->e_phnum * sizeof (Elf_Internal_Phdr);
a5961 143
}

void
_bfd_elf_sprintf_vma (abfd, buf, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     bfd_vma value;
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    sprintf_vma (buf, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  sprintf (buf, "%016lx", value);
#else
	  sprintf (buf, "%08lx%08lx", _bfd_int64_high (value),
		   _bfd_int64_low (value));
#endif
	}
      else
	sprintf (buf, "%08lx", (unsigned long) (value & 0xffffffff));
    }
#else
  sprintf_vma (buf, value);
#endif
}

void
_bfd_elf_fprintf_vma (abfd, stream, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR stream;
     bfd_vma value;
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    fprintf_vma ((FILE *) stream, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  fprintf ((FILE *) stream, "%016lx", value);
#else
	  fprintf ((FILE *) stream, "%08lx%08lx",
		   _bfd_int64_high (value), _bfd_int64_low (value));
#endif
	}
      else
	fprintf ((FILE *) stream, "%08lx",
		 (unsigned long) (value & 0xffffffff));
    }
#else
  fprintf_vma ((FILE *) stream, value);
#endif
}

enum elf_reloc_type_class
_bfd_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED;
{
  return reloc_class_normal;
}

/* For RELA architectures, return the relocation value for a
   relocation against a local symbol.  */

bfd_vma
_bfd_elf_rela_local_sym (abfd, sym, sec, rel)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection *sec;
     Elf_Internal_Rela *rel;
{
  bfd_vma relocation;

  relocation = (sec->output_section->vma
		+ sec->output_offset
		+ sym->st_value);
  if ((sec->flags & SEC_MERGE)
      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      asection *msec;

      msec = sec;
      rel->r_addend =
	_bfd_merged_section_offset (abfd, &msec,
				    elf_section_data (sec)->sec_info,
				    sym->st_value + rel->r_addend,
				    (bfd_vma) 0)
	- relocation;
      rel->r_addend += msec->output_section->vma + msec->output_offset;
    }
  return relocation;
}

bfd_vma
_bfd_elf_rel_local_sym (abfd, sym, psec, addend)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma addend;
{
  asection *sec = *psec;

  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
    return sym->st_value + addend;

  return _bfd_merged_section_offset (abfd, psec,
				     elf_section_data (sec)->sec_info,
				     sym->st_value + addend, (bfd_vma) 0);
}

bfd_vma
_bfd_elf_section_offset (abfd, info, sec, offset)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     bfd_vma offset;
{
  struct bfd_elf_section_data *sec_data;

  sec_data = elf_section_data (sec);
  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
      return _bfd_stab_section_offset (abfd,
				       &elf_hash_table (info)->merge_info,
				       sec, &sec_data->sec_info, offset);
    case ELF_INFO_TYPE_EH_FRAME:
      return _bfd_elf_eh_frame_section_offset (abfd, sec, offset);
    default:
      return offset;
    }
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
d43 63
a105 5
static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct bfd_strtab_hash **, int) ;
static bfd_boolean elfcore_read_notes (bfd *, file_ptr, bfd_size_type) ;
d114 4
a117 3
_bfd_elf_swap_verdef_in (bfd *abfd,
			 const Elf_External_Verdef *src,
			 Elf_Internal_Verdef *dst)
d131 4
a134 3
_bfd_elf_swap_verdef_out (bfd *abfd,
			  const Elf_Internal_Verdef *src,
			  Elf_External_Verdef *dst)
d148 4
a151 3
_bfd_elf_swap_verdaux_in (bfd *abfd,
			  const Elf_External_Verdaux *src,
			  Elf_Internal_Verdaux *dst)
d160 4
a163 3
_bfd_elf_swap_verdaux_out (bfd *abfd,
			   const Elf_Internal_Verdaux *src,
			   Elf_External_Verdaux *dst)
d172 4
a175 3
_bfd_elf_swap_verneed_in (bfd *abfd,
			  const Elf_External_Verneed *src,
			  Elf_Internal_Verneed *dst)
d187 4
a190 3
_bfd_elf_swap_verneed_out (bfd *abfd,
			   const Elf_Internal_Verneed *src,
			   Elf_External_Verneed *dst)
d202 4
a205 3
_bfd_elf_swap_vernaux_in (bfd *abfd,
			  const Elf_External_Vernaux *src,
			  Elf_Internal_Vernaux *dst)
d217 4
a220 3
_bfd_elf_swap_vernaux_out (bfd *abfd,
			   const Elf_Internal_Vernaux *src,
			   Elf_External_Vernaux *dst)
d232 4
a235 3
_bfd_elf_swap_versym_in (bfd *abfd,
			 const Elf_External_Versym *src,
			 Elf_Internal_Versym *dst)
d243 4
a246 3
_bfd_elf_swap_versym_out (bfd *abfd,
			  const Elf_Internal_Versym *src,
			  Elf_External_Versym *dst)
d255 2
a256 1
bfd_elf_hash (const char *namearg)
d282 4
a285 1
elf_read (bfd *abfd, file_ptr offset, bfd_size_type size)
d293 1
a293 1
  if (bfd_bread (buf, size, abfd) != size)
d303 2
a304 1
bfd_elf_mkobject (bfd *abfd)
d308 2
a309 1
  elf_tdata (abfd) = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
d319 2
a320 1
bfd_elf_mkcorefile (bfd *abfd)
d327 3
a329 1
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
d347 1
a347 1
      i_shdrp[shindex]->contents = shstrtab;
d353 4
a356 3
bfd_elf_string_from_elf_section (bfd *abfd,
				 unsigned int shindex,
				 unsigned int strindex)
d391 9
a399 7
bfd_elf_get_elf_syms (bfd *ibfd,
		      Elf_Internal_Shdr *symtab_hdr,
		      size_t symcount,
		      size_t symoffset,
		      Elf_Internal_Sym *intsym_buf,
		      void *extsym_buf,
		      Elf_External_Sym_Shndx *extshndx_buf)
d402 1
a402 1
  void *alloc_ext;
d408 1
a408 1
  const struct elf_backend_data *bed;
d449 1
a449 1
	  alloc_extshndx = bfd_malloc (amt);
d464 1
a464 1
      intsym_buf = bfd_malloc (amt);
d474 1
a474 1
    (*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym);
d487 3
a489 1
bfd_elf_local_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
d515 3
a517 1
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
d540 4
a543 1
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
d702 3
a704 1
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED, asection *group)
d724 4
a727 3
_bfd_elf_make_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name)
d731 1
a731 1
  const struct elf_backend_data *bed;
a743 4
  /* Always use the real type/flags.  */
  elf_section_type (newsect) = hdr->sh_type;
  elf_section_flags (newsect) = hdr->sh_flags;

d908 3
a910 1
bfd_elf_find_section (bfd *abfd, char *name)
d939 1
a939 1
/* ELF relocs are against symbols.  If we are producing relocatable
d947 1
a947 1
   relocatable output against an external symbol.  */
d950 14
a963 7
bfd_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol,
		       void *data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d965 1
a965 1
  if (output_bfd != NULL
d980 3
a982 2
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
d991 3
a993 1
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
d995 1
a995 1
  if (!is_elf_hash_table (info->hash))
d1004 3
a1006 1
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
d1010 1
a1010 1
  if (!is_elf_hash_table (info->hash))
d1020 3
a1022 1
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d1041 3
a1043 1
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
d1045 1
a1045 1
  FILE *f = farg;
a1072 1
	    case PT_GNU_STACK: pt = "STACK"; break;
d1103 1
a1103 1
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1107 1
a1107 1
      dynbuf = bfd_malloc (s->_raw_size);
d1110 2
a1111 1
      if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1131 1
a1131 1
	  (*swap_dyn_in) (abfd, extdyn, &dyn);
d1280 5
a1284 4
bfd_elf_print_symbol (bfd *abfd,
		      void *filep,
		      asymbol *symbol,
		      bfd_print_symbol_type how)
d1286 1
a1286 1
  FILE *file = filep;
d1301 1
a1301 1
	const struct elf_backend_data *bed;
d1314 1
a1314 1
	    bfd_print_symbol_vandf (abfd, file, symbol);
d1403 4
a1406 3
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
d1430 1
d1454 3
a1456 3
_bfd_elf_link_hash_copy_indirect (const struct elf_backend_data *bed,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
d1464 6
a1469 7
  dir->elf_link_hash_flags
    |= ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_NON_GOT_REF
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED);
d1506 4
a1509 3
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
d1528 6
a1533 6
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d1555 1
a1555 2
  table->tls_sec = NULL;
  table->tls_size = 0;
d1567 2
a1568 1
_bfd_elf_link_hash_table_create (bfd *abfd)
d1573 2
a1574 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d1588 2
a1589 1
   entry for a dynamic object.  */
d1592 3
a1594 1
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
d1602 3
a1604 1
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
d1608 1
a1608 1
    elf_dyn_lib_class (abfd) = lib_class;
d1615 3
a1617 2
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
d1619 1
a1619 1
  if (! is_elf_hash_table (info->hash))
d1628 3
a1630 2
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
d1632 1
a1632 1
  if (! is_elf_hash_table (info->hash))
d1642 2
a1643 1
bfd_elf_get_dt_soname (bfd *abfd)
d1655 3
a1657 2
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
d1665 1
a1665 1
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1677 1
a1677 1
  dynbuf = bfd_malloc (s->_raw_size);
d1681 2
a1682 1
  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1700 1
a1700 1
      (*swap_dyn_in) (abfd, extdyn, &dyn);
d1717 1
a1717 1
	  l = bfd_alloc (abfd, amt);
d1741 1
a1741 1
_bfd_elf_stringtab_init (void)
d1766 3
a1768 1
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
d1772 1
a1772 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1840 1
a1840 1
         set in a relocatable object file, which would confuse the
d2008 1
a2008 1
	    hdr2 = bfd_alloc (abfd, amt);
d2092 5
a2096 4
bfd_section_from_r_symndx (bfd *abfd,
			   struct sym_sec_cache *cache,
			   asection *sec,
			   unsigned long r_symndx)
d2119 1
a2119 2
  if ((isym.st_shndx != SHN_UNDEF && isym.st_shndx < SHN_LORESERVE)
      || isym.st_shndx > SHN_HIRESERVE)
d2133 3
a2135 1
bfd_section_from_elf_index (bfd *abfd, unsigned int index)
a2141 109
static struct bfd_elf_special_section const special_sections[] =
{
  { ".bss",            4, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".comment",        8,  0, SHT_PROGBITS, 0 },
  { ".data",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".data1",          6,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".debug",          6,  0, SHT_PROGBITS, 0 },
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".debug_line",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_info",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_abbrev",  13,  0, SHT_PROGBITS, 0 },
  { ".debug_aranges", 14,  0, SHT_PROGBITS, 0 },
  { ".dynamic",        8,  0, SHT_DYNAMIC,  SHF_ALLOC },
  { ".dynstr",         7,  0, SHT_STRTAB,   SHF_ALLOC },
  { ".dynsym",         7,  0, SHT_DYNSYM,   SHF_ALLOC },
  { ".got",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
  { ".gnu.version",   12,  0, SHT_GNU_versym, 0 },
  { ".gnu.version_d", 14,  0, SHT_GNU_verdef, 0 },
  { ".gnu.version_r", 14,  0, SHT_GNU_verneed, 0 },
  { ".note",           5, -1, SHT_NOTE,     0 },
  { ".rela",           5, -1, SHT_RELA,     0 },
  { ".rel",            4, -1, SHT_REL,      0 },
  { ".stabstr",        5,  3, SHT_STRTAB,   0 },
  { NULL,              0,  0, 0,            0 }
};

static const struct bfd_elf_special_section *
get_special_section (const char *name,
		     const struct bfd_elf_special_section *special_sections,
		     unsigned int rela)
{
  int i;
  int len = strlen (name);

  for (i = 0; special_sections[i].prefix != NULL; i++)
    {
      int suffix_len;
      int prefix_len = special_sections[i].prefix_length;

      if (len < prefix_len)
	continue;
      if (memcmp (name, special_sections[i].prefix, prefix_len) != 0)
	continue;

      suffix_len = special_sections[i].suffix_length;
      if (suffix_len <= 0)
	{
	  if (name[prefix_len] != 0)
	    {
	      if (suffix_len == 0)
		continue;
	      if (name[prefix_len] != '.'
		  && (suffix_len == -2
		      || (rela && special_sections[i].type == SHT_REL)))
		continue;
	    }
	}
      else
	{
	  if (len < prefix_len + suffix_len)
	    continue;
	  if (memcmp (name + len - suffix_len,
		      special_sections[i].prefix + prefix_len,
		      suffix_len) != 0)
	    continue;
	}
      return &special_sections[i];
    }

  return NULL;
}

const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct bfd_elf_special_section *ssect = NULL;

  /* See if this is one of the special sections.  */
  if (name)
    {
      unsigned int rela = bed->default_use_rela_p;

      if (bed->special_sections)
	ssect = get_special_section (name, bed->special_sections, rela);

      if (! ssect)
	ssect = get_special_section (name, special_sections, rela);
    }

  return ssect;
}

d2143 3
a2145 1
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
a2147 1
  const struct bfd_elf_special_section *ssect;
d2152 2
a2153 1
      sdata = bfd_zalloc (abfd, sizeof (*sdata));
d2156 1
a2156 9
      sec->used_by_bfd = sdata;
    }

  elf_section_type (sec) = SHT_NULL;
  ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
  if (ssect != NULL)
    {
      elf_section_type (sec) = ssect->type;
      elf_section_flags (sec) = ssect->attr;
d2188 5
a2192 4
_bfd_elf_make_section_from_phdr (bfd *abfd,
				 Elf_Internal_Phdr *hdr,
				 int index,
				 const char *typename)
d2205 1
a2205 1
  name = bfd_alloc (abfd, len);
a2216 1
  newsect->alignment_power = bfd_log2 (hdr->p_align);
d2237 1
a2237 1
      name = bfd_alloc (abfd, len);
d2261 4
a2264 1
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index)
d2266 1
a2266 1
  const struct elf_backend_data *bed;
d2285 1
a2285 1
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
a2298 3
    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");

d2315 5
a2319 4
_bfd_elf_init_reloc_shdr (bfd *abfd,
			  Elf_Internal_Shdr *rel_hdr,
			  asection *asect,
			  bfd_boolean use_rela_p)
d2322 1
a2322 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2338 1
a2338 1
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
d2350 4
a2353 1
elf_fake_sections (bfd *abfd, asection *asect, void *failedptrarg)
d2355 2
a2356 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean *failedptr = failedptrarg;
d2394 7
a2400 10
  /* If the section type is unspecified, we set it based on
     asect->flags.  */
  if (this_hdr->sh_type == SHT_NULL)
    {
      if ((asect->flags & SEC_ALLOC) != 0
	  && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      || (asect->flags & SEC_NEVER_LOAD) != 0))
	this_hdr->sh_type = SHT_NOBITS;
      else
	this_hdr->sh_type = SHT_PROGBITS;
d2402 1
a2402 2

  switch (this_hdr->sh_type)
d2404 1
a2404 17
    default:
      break;

    case SHT_STRTAB:
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
    case SHT_NOTE:
    case SHT_NOBITS:
    case SHT_PROGBITS:
      break;

    case SHT_HASH:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;

    case SHT_DYNSYM:
d2406 4
a2409 3
      break;

    case SHT_DYNAMIC:
d2411 27
a2437 13
      break;

    case SHT_RELA:
      if (get_elf_backend_data (abfd)->may_use_rela_p)
	this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case SHT_REL:
      if (get_elf_backend_data (abfd)->may_use_rel_p)
	this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case SHT_GNU_versym:
d2439 4
a2442 3
      break;

     case SHT_GNU_verdef:
d2452 4
a2455 3
      break;

    case SHT_GNU_verneed:
d2465 4
a2468 3
      break;

    case SHT_GROUP:
a2469 1
      break;
d2471 6
d2529 4
a2532 1
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
d2534 1
a2534 1
  bfd_boolean *failedptr = failedptrarg;
d2638 2
a2639 1
assign_section_numbers (bfd *abfd)
d2720 1
a2720 1
  i_shdrp = bfd_zalloc (abfd, amt);
d2725 1
a2725 1
  i_shdrp[0] = bfd_zalloc (abfd, amt);
d2811 1
a2811 1
	      alc = bfd_malloc (len - 2);
d2868 4
a2871 2
static int
sym_is_global (bfd *abfd, asymbol *sym)
d2874 3
a2876 3
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);
d2884 2
a2885 1
elf_map_symbols (bfd *abfd)
d2913 1
a2913 1
  sect_syms = bfd_zalloc (abfd, amt);
d2987 1
a2987 1
  new_syms = bfd_alloc (abfd, amt);
d3031 6
a3036 2
static inline file_ptr
align_file_position (file_ptr off, int align)
d3044 5
a3048 4
file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
					   file_ptr offset,
					   bfd_boolean align)
d3071 3
a3073 2
_bfd_elf_compute_section_file_positions (bfd *abfd,
					 struct bfd_link_info *link_info)
d3075 1
a3075 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3131 1
a3131 1
  if (!assign_file_positions_except_relocs (abfd, link_info))
d3168 7
a3174 6
static struct elf_segment_map *
make_mapping (bfd *abfd,
	      asection **sections,
	      unsigned int from,
	      unsigned int to,
	      bfd_boolean phdr)
d3183 1
a3183 1
  m = bfd_zalloc (abfd, amt);
d3205 2
a3206 1
map_sections_to_segments (bfd *abfd)
a3215 1
  bfd_vma last_size;
d3235 1
a3235 1
  sections = bfd_malloc (amt);
d3265 1
a3265 1
      m = bfd_zalloc (abfd, amt);
d3279 1
a3279 1
      m = bfd_zalloc (abfd, amt);
a3294 1
  last_size = 0;
d3343 1
a3343 1
      else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
d3350 2
a3351 2
      else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
	       && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
d3354 1
a3354 2
             nonloadable section in the same segment.
             Consider .tbss sections as loadable for this purpose.  */
d3366 1
a3366 1
	       && (((last_hdr->lma + last_size - 1)
a3389 5
	  /* .tbss sections effectively have zero size.  */
	  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	    last_size = hdr->_raw_size;
	  else
	    last_size = 0;
a3408 5
      /* .tbss sections effectively have zero size.  */
      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	last_size = hdr->_raw_size;
      else
	last_size = 0;
d3428 1
a3428 1
      m = bfd_zalloc (abfd, amt);
d3451 1
a3451 1
	  m = bfd_zalloc (abfd, amt);
d3477 1
a3477 1
      m = bfd_zalloc (abfd, amt);
d3504 1
a3504 1
      m = bfd_zalloc (abfd, amt);
a3515 15
  if (elf_tdata (abfd)->stack_flags)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_STACK;
      m->p_flags = elf_tdata (abfd)->stack_flags;
      m->p_flags_valid = 1;

      *pm = m;
      pm = &m->next;
    }

d3531 3
a3533 1
elf_sort_sections (const void *arg1, const void *arg2)
a3587 29
/* Ian Lance Taylor writes:

   We shouldn't be using % with a negative signed number.  That's just
   not good.  We have to make sure either that the number is not
   negative, or that the number has an unsigned type.  When the types
   are all the same size they wind up as unsigned.  When file_ptr is a
   larger signed type, the arithmetic winds up as signed long long,
   which is wrong.

   What we're trying to say here is something like ``increase OFF by
   the least amount that will cause it to be equal to the VMA modulo
   the page size.''  */
/* In other words, something like:

   vma_offset = m->sections[0]->vma % bed->maxpagesize;
   off_offset = off % bed->maxpagesize;
   if (vma_offset < off_offset)
     adjustment = vma_offset + bed->maxpagesize - off_offset;
   else
     adjustment = vma_offset - off_offset;
     
   which can can be collapsed into the expression below.  */

static file_ptr
vma_page_aligned_bias (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
{
  return ((vma - off) % maxpagesize);
}

d3593 2
a3594 1
assign_file_positions_for_segments (bfd *abfd, struct bfd_link_info *link_info)
d3646 1
a3646 1
      if (! (*bed->elf_backend_modify_segment_map) (abfd, link_info))
d3678 1
a3678 1
  phdrs = bfd_alloc (abfd, amt);
d3716 1
a3716 2
	    off += vma_page_aligned_bias (m->sections[0]->vma, off,
					  bed->maxpagesize);
d3731 1
a3731 2
	      off += vma_page_aligned_bias (m->sections[0]->vma, off,
					    1 << align);
d3751 1
a3751 1
	p->p_align = 1 << bed->s->log_file_align;
d3893 1
a3893 2
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    bed->maxpagesize);
d3895 1
a3895 2
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    align);
d4054 2
a4055 1
get_program_header_size (bfd *abfd)
d4059 1
a4059 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a4101 6
  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

d4149 2
a4150 2
assign_file_positions_except_relocs (bfd *abfd,
				     struct bfd_link_info *link_info)
d4157 1
a4157 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4201 1
a4201 1
      if (! assign_file_positions_for_segments (abfd, link_info))
d4224 1
a4224 2
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      bed->maxpagesize);
d4226 1
a4226 2
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      hdr->sh_addralign);
d4230 3
a4232 1
	  else if (hdr == i_shdrpp[tdata->symtab_section]
d4248 1
a4248 1
  off = align_file_position (off, 1 << bed->s->log_file_align);
d4258 2
a4259 1
prep_headers (bfd *abfd)
d4265 1
a4265 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4310 5
a4314 2
      i_ehdrp->e_machine = bed->elf_machine_code;
    }
d4367 2
a4368 1
_bfd_elf_assign_file_positions_for_relocs (bfd *abfd)
d4391 2
a4392 1
_bfd_elf_write_object_contents (bfd *abfd)
d4394 1
a4394 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4401 2
a4402 1
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
d4446 2
a4447 1
_bfd_elf_write_corefile_contents (bfd *abfd)
d4456 3
a4458 1
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
d4460 1
a4460 1
  const struct elf_backend_data *bed;
d4507 3
a4509 1
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
d4564 3
a4566 1
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d4580 1
a4580 1
  const struct elf_backend_data *bed;
d4652 2
a4653 3
       5. PT_GNU_STACK segments do not include any sections.
       6. PT_TLS segment includes only SHF_TLS sections.
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
a4660 1
   && segment->p_type != PT_GNU_STACK					\
d4704 1
a4704 1
		 assignment code will work.  */
d4790 1
a4790 1
      map = bfd_alloc (obfd, amt);
d4871 1
a4871 1
      sections = bfd_malloc (amt);
d5073 1
a5073 1
	      map = bfd_alloc (obfd, amt);
d5167 5
a5171 4
_bfd_elf_copy_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec)
d5232 5
a5236 4
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
				   asymbol *isymarg,
				   bfd *obfd,
				   asymbol *osymarg)
d5273 4
a5276 3
swap_out_syms (bfd *abfd,
	       struct bfd_strtab_hash **sttp,
	       int relocatable_p)
d5278 1
a5278 1
  const struct elf_backend_data *bed;
a5288 1
  bfd_boolean name_local_sections;
d5305 1
a5305 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d5317 1
a5317 1
  symtab_hdr->contents = outbound_syms;
a5353 4
  name_local_sections
    = (bed->elf_backend_name_local_section_symbols
       && bed->elf_backend_name_local_section_symbols (abfd));

d5363 1
a5363 2
      if (!name_local_sections
	  && (flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
d5558 2
a5559 1
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
d5574 2
a5575 1
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
d5596 3
a5598 2
_bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
				sec_ptr asect)
d5606 5
a5610 4
_bfd_elf_canonicalize_reloc (bfd *abfd,
			     sec_ptr section,
			     arelent **relptr,
			     asymbol **symbols)
d5614 1
a5614 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5629 3
a5631 1
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
d5633 2
a5634 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
d5642 3
a5644 2
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
				      asymbol **allocation)
d5646 2
a5647 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);
d5660 2
a5661 1
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
d5693 4
a5696 3
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
				     arelent **storage,
				     asymbol **syms)
d5698 2
a5699 1
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
d5738 2
a5739 1
_bfd_elf_slurp_version_tables (bfd *abfd)
d5756 1
a5756 1
      contents = bfd_malloc (hdr->sh_size);
d5760 1
a5760 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5780 1
a5780 1
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
d5802 1
a5802 1
	  iverdef->vd_auxptr = bfd_alloc (abfd, amt);
d5853 2
a5854 1
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
d5860 1
a5860 1
      contents = bfd_malloc (hdr->sh_size);
d5864 1
a5864 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5887 1
a5887 1
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);
d5933 2
a5934 1
_bfd_elf_make_empty_symbol (bfd *abfd)
d5939 1
a5939 1
  newsym = bfd_zalloc (abfd, amt);
d5950 4
a5953 3
_bfd_elf_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			  asymbol *symbol,
			  symbol_info *ret)
d5963 3
a5965 2
_bfd_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *name)
d5989 3
a5991 2
_bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol ATTRIBUTE_UNUSED)
d5998 4
a6001 3
_bfd_elf_set_arch_mach (bfd *abfd,
			enum bfd_architecture arch,
			unsigned long machine)
d6017 8
a6024 6
elf_find_function (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *section,
		   asymbol **symbols,
		   bfd_vma offset,
		   const char **filename_ptr,
		   const char **functionname_ptr)
d6079 9
a6087 7
_bfd_elf_find_nearest_line (bfd *abfd,
			    asection *section,
			    asymbol **symbols,
			    bfd_vma offset,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
d6136 3
a6138 1
_bfd_elf_sizeof_headers (bfd *abfd, bfd_boolean reloc)
d6149 6
a6154 5
_bfd_elf_set_section_contents (bfd *abfd,
			       sec_ptr section,
			       const void *location,
			       file_ptr offset,
			       bfd_size_type count)
d6160 2
a6161 1
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
d6174 4
a6177 3
_bfd_elf_no_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *cache_ptr ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d6185 3
a6187 1
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
d6281 2
a6282 1
_bfd_elf_close_and_cleanup (bfd *abfd)
d6299 8
a6306 5
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd ATTRIBUTE_UNUSED, arelent *re ATTRIBUTE_UNUSED,
   struct bfd_symbol *symbol ATTRIBUTE_UNUSED,
   void *data ATTRIBUTE_UNUSED, asection *is ATTRIBUTE_UNUSED,
   bfd *obfd ATTRIBUTE_UNUSED, char **errmsg ATTRIBUTE_UNUSED)
d6323 2
a6324 1
elfcore_make_pid (bfd *abfd)
d6336 4
a6339 1
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
d6365 5
a6369 4
_bfd_elfcore_make_pseudosection (bfd *abfd,
				 char *name,
				 size_t size,
				 ufile_ptr filepos)
d6380 1
a6380 1
  threaded_name = bfd_alloc (abfd, len);
d6385 1
a6385 1
  sect = bfd_make_section_anyway (abfd, threaded_name);
d6403 2
d6407 3
a6409 1
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d6480 4
a6483 3
elfcore_make_note_pseudosection (bfd *abfd,
				 char *name,
				 Elf_Internal_Note *note)
d6494 3
a6496 1
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
d6506 3
a6508 1
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
d6532 4
a6535 1
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
d6546 1
a6546 1
  dups = bfd_alloc (abfd, len + 1);
d6557 3
d6561 3
a6563 1
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d6621 3
d6625 3
a6627 1
elfcore_grok_pstatus (bfd *abfd, Elf_Internal_Note *note)
d6661 3
d6665 3
a6667 1
elfcore_grok_lwpstatus (bfd *abfd, Elf_Internal_Note *note)
d6691 1
a6691 1
  name = bfd_alloc (abfd, len);
d6696 1
a6696 1
  sect = bfd_make_section_anyway (abfd, name);
d6721 1
a6721 1
  name = bfd_alloc (abfd, len);
d6726 1
a6726 1
  sect = bfd_make_section_anyway (abfd, name);
d6750 3
a6752 1
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
d6778 1
a6778 1
      name = bfd_alloc (abfd, len);
d6784 1
a6784 1
      sect = bfd_make_section_anyway (abfd, name);
d6805 1
a6805 1
      name = bfd_alloc (abfd, len);
d6811 1
a6811 1
      sect = bfd_make_section_anyway (abfd, name);
d6831 3
a6833 1
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
d6835 1
a6835 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a6886 14

    case NT_AUXV:
      {
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");

	if (sect == NULL)
	  return FALSE;
	sect->_raw_size = note->descsz;
	sect->filepos = note->descpos;
	sect->flags = SEC_HAS_CONTENTS;
	sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

	return TRUE;
      }
d6891 3
a6893 1
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
d6907 3
a6909 1
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
d6924 1
a6924 2
  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
					  note);
d6928 3
a6930 1
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
d6995 4
a6998 1
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, pid_t *tid)
a7003 2
  short sig;
  unsigned flags;
d7008 2
a7009 5
  /* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
  *tid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'flags' field is at offset 8.  */
  flags = bfd_get_32 (abfd, (bfd_byte *) ddata + 8);
d7012 1
a7012 5
  if ((sig = bfd_get_16 (abfd, (bfd_byte *) ddata + 14)) > 0)
    {
      elf_tdata (abfd)->core_signal = sig;
      elf_tdata (abfd)->core_lwpid = *tid;
    }
d7014 2
a7015 5
  /* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores
     do not come from signals so we make sure we set the current
     thread just in case.  */
  if (flags & 0x00000080)
    elf_tdata (abfd)->core_lwpid = *tid;
d7020 1
a7020 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d7025 1
a7025 1
  sect = bfd_make_section_anyway (abfd, name);
d7038 4
a7041 1
elfcore_grok_nto_gregs (bfd *abfd, Elf_Internal_Note *note, pid_t tid)
d7050 1
a7050 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d7055 1
a7055 1
  sect = bfd_make_section_anyway (abfd, name);
d7064 1
a7064 5
  /* This is the current thread.  */
  if (elf_tdata (abfd)->core_lwpid == tid)
    return elfcore_maybe_make_sect (abfd, ".reg", sect);

  return TRUE;
d7073 3
a7075 1
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
d7105 8
a7112 7
elfcore_write_note (bfd  *abfd,
		    char *buf,
		    int  *bufsiz,
		    const char *name,
		    int  type,
		    const void *input,
		    int  size)
d7124 1
a7124 1
      const struct elf_backend_data *bed;
d7128 1
a7128 1
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
d7131 1
a7131 1
  newspace = 12 + namesz + pad + size;
d7157 6
a7162 5
elfcore_write_prpsinfo (bfd  *abfd,
			char *buf,
			int  *bufsiz,
			const char *fname,
			const char *psargs)
d7185 7
a7191 6
elfcore_write_prstatus (bfd *abfd,
			char *buf,
			int *bufsiz,
			long pid,
			int cursig,
			const void *gregs)
d7207 7
a7213 6
elfcore_write_lwpstatus (bfd *abfd,
			 char *buf,
			 int *bufsiz,
			 long pid,
			 int cursig,
			 const void *gregs)
d7239 7
a7245 6
elfcore_write_pstatus (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       long pid,
		       int cursig,
		       const void *gregs)
d7259 6
a7264 5
elfcore_write_prfpreg (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *fpregs,
		       int size)
d7272 6
a7277 5
elfcore_write_prxfpreg (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *xfpregs,
			int size)
d7285 4
a7288 1
elfcore_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
d7356 2
a7357 1
bfd_get_elf_phdr_upper_bound (bfd *abfd)
d7377 3
a7379 1
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
d7397 4
a7400 1
_bfd_elf_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
d7428 4
a7431 1
_bfd_elf_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
d7460 2
a7461 1
_bfd_elf_reloc_type_class (const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
d7470 5
a7474 4
_bfd_elf_rela_local_sym (bfd *abfd,
			 Elf_Internal_Sym *sym,
			 asection **psec,
			 Elf_Internal_Rela *rel)
a7475 1
  asection *sec = *psec;
d7485 3
d7489 1
a7489 1
	_bfd_merged_section_offset (abfd, psec,
d7492 3
a7494 4
				    0);
      sec = *psec;
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
d7500 5
a7504 4
_bfd_elf_rel_local_sym (bfd *abfd,
			Elf_Internal_Sym *sym,
			asection **psec,
			bfd_vma addend)
d7513 1
a7513 1
				     sym->st_value + addend, 0);
d7517 5
a7521 4
_bfd_elf_section_offset (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 bfd_vma offset)
a7536 24
}

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */

bfd *
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  return (*get_elf_backend_data (templ)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, loadbasep, target_read_memory);
@


