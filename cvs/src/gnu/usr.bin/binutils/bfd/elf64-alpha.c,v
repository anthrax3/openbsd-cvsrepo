head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.1.4.0.2
	OPENBSD_2_8_BASE:1.1.1.4
	BINUTILS-2_10:1.1.1.4
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.3.0.14
	OPENBSD_2_7_BASE:1.1.1.3
	new-binutils:1.1.1.3.0.12
	OPENBSD_2_6:1.1.1.3.0.10
	OPENBSD_2_6_BASE:1.1.1.3
	OPENBSD_2_5:1.1.1.3.0.8
	OPENBSD_2_5_BASE:1.1.1.3
	OPENBSD_2_4:1.1.1.3.0.6
	OPENBSD_2_4_BASE:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.4
	OPENBSD_2_3_BASE:1.1.1.3
	OPENBSD_2_2:1.1.1.3.0.2
	OPENBSD_2_2_BASE:1.1.1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.1.1.2.0.2
	OPENBSD_2_1_BASE:1.1.1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.12.22.14.09.58;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	mlKqkMkgtkgOcmHH;

1.8
date	2013.12.17.12.52.48;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.20.45.08;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.09.22.29.27;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.07.07.26.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.07.00.46.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.04.17.37.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.04.17.37.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.11.19.14.12.35;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.19.12;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.41;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2001.06.09.22.06.48;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.25.01;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.16;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Teach ld(1) not to add a PT_INTERP entry for -static -pie.

ok kurt@@
@
text
@/* Alpha specific support for 64-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Contributed by Richard Henderson <rth@@tamu.edu>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* We need a published ABI spec for this.  Until one comes out, don't
   assume this'll remain unchanged forever.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"

#include "elf/alpha.h"

#define ALPHAECOFF

#define NO_COFF_RELOCS
#define NO_COFF_SYMBOLS
#define NO_COFF_LINENOS

/* Get the ECOFF swapping routines.  Needed for the debug information.  */
#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "coff/alpha.h"
#include "aout/ar.h"
#include "libcoff.h"
#include "libecoff.h"
#define ECOFF_64
#include "ecoffswap.h"

static bfd_boolean alpha_elf_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
static struct bfd_hash_entry * elf64_alpha_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table * elf64_alpha_bfd_link_hash_table_create
  PARAMS ((bfd *));

static bfd_reloc_status_type elf64_alpha_reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_reloc_bad
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_do_reloc_gpdisp
  PARAMS ((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
static bfd_reloc_status_type elf64_alpha_reloc_gpdisp
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static reloc_howto_type * elf64_alpha_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf64_alpha_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));

static bfd_boolean elf64_alpha_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_object_p
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elf64_alpha_section_flags
  PARAMS ((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elf64_alpha_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static bfd_boolean elf64_alpha_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf64_alpha_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
static bfd_boolean elf64_alpha_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean elf64_alpha_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));

#if defined(__STDC__) || defined(ALMOST_STDC)
struct alpha_elf_link_hash_entry;
#endif

static bfd_boolean elf64_alpha_output_extsym
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));

static bfd_boolean elf64_alpha_can_merge_gots
  PARAMS ((bfd *, bfd *));
static void elf64_alpha_merge_gots
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf64_alpha_calc_got_offsets_for_symbol
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static void elf64_alpha_calc_got_offsets
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_got_sections
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section_1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static bfd_boolean elf64_alpha_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static int alpha_dynamic_entries_for_reloc
  PARAMS ((int, int, int));
static bfd_boolean elf64_alpha_calc_dynrel_sizes
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_rela_got_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_rela_got_1
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static struct alpha_elf_got_entry *get_got_entry
  PARAMS ((bfd *, struct alpha_elf_link_hash_entry *, unsigned long,
	   unsigned long, bfd_vma));
static bfd_boolean elf64_alpha_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
	  const Elf_Internal_Rela *));
static bfd_boolean elf64_alpha_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf64_alpha_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void elf64_alpha_emit_dynrel
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *,
	   bfd_vma, long, long, bfd_vma));
static bfd_boolean elf64_alpha_relocate_section_r
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf64_alpha_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_merge_ind_symbols
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static Elf_Internal_Rela * elf64_alpha_find_reloc_at_ofs
  PARAMS ((Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_vma, int));
static enum elf_reloc_type_class elf64_alpha_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));

struct alpha_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Cumulative flags for all the .got entries.  */
  int flags;

  /* Contexts in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR	0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	0x20
#define ALPHA_ELF_LINK_HASH_LU_FUNC	0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	0x40
#define ALPHA_ELF_LINK_HASH_PLT_LOC	0x80

  /* Used to undo the localization of a plt symbol.  */
  asection *plt_old_section;
  bfd_vma plt_old_value;

  /* Used to implement multiple .got subsections.  */
  struct alpha_elf_got_entry
  {
    struct alpha_elf_got_entry *next;

    /* Which .got subsection?  */
    bfd *gotobj;

    /* The addend in effect for this entry.  */
    bfd_vma addend;

    /* The .got offset for this entry.  */
    int got_offset;

    /* How many references to this entry?  */
    int use_count;

    /* The relocation type of this entry.  */
    unsigned char reloc_type;

    /* How a LITERAL is used.  */
    unsigned char flags;

    /* Have we initialized the dynamic relocation for this entry?  */
    unsigned char reloc_done;

    /* Have we adjusted this entry for SEC_MERGE?  */
    unsigned char reloc_xlated;
  } *got_entries;

  /* Used to count non-got, non-plt relocations for delayed sizing
     of relocation sections.  */
  struct alpha_elf_reloc_entry
  {
    struct alpha_elf_reloc_entry *next;

    /* Which .reloc section? */
    asection *srel;

    /* What kind of relocation? */
    unsigned int rtype;

    /* Is this against read-only section? */
    unsigned int reltext : 1;

    /* How many did we find?  */
    unsigned long count;
  } *reloc_entries;
};

/* Alpha ELF linker hash table.  */

struct alpha_elf_link_hash_table
{
  struct elf_link_hash_table root;

  /* The head of a list of .got subsections linked through
     alpha_elf_tdata(abfd)->got_link_next.  */
  bfd *got_list;
};

/* Look up an entry in a Alpha ELF linker hash table.  */

#define alpha_elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct alpha_elf_link_hash_entry *)					\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse a Alpha ELF linker hash table.  */

#define alpha_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
    (info)))

/* Get the Alpha ELF linker hash table from a link_info structure.  */

#define alpha_elf_hash_table(p) \
  ((struct alpha_elf_link_hash_table *) ((p)->hash))

/* Get the object's symbols as our own entry type.  */

#define alpha_elf_sym_hashes(abfd) \
  ((struct alpha_elf_link_hash_entry **)elf_sym_hashes(abfd))

/* Should we do dynamic things to this symbol?  This differs from the 
   generic version in that we never need to consider function pointer
   equality wrt PLT entries -- we don't create a PLT entry if a symbol's
   address is ever taken.  */

static inline bfd_boolean
alpha_elf_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  return _bfd_elf_dynamic_symbol_p (h, info, 0);
}

/* Create an entry in a Alpha ELF linker hash table.  */

static struct bfd_hash_entry *
elf64_alpha_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct alpha_elf_link_hash_entry *ret =
    (struct alpha_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct alpha_elf_link_hash_entry *) NULL)
    ret = ((struct alpha_elf_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct alpha_elf_link_hash_entry)));
  if (ret == (struct alpha_elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct alpha_elf_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct alpha_elf_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->flags = 0;
      ret->got_entries = NULL;
      ret->reloc_entries = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a Alpha ELF linker hash table.  */

static struct bfd_link_hash_table *
elf64_alpha_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct alpha_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct alpha_elf_link_hash_table);

  ret = (struct alpha_elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == (struct alpha_elf_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf64_alpha_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* We have some private fields hanging off of the elf_tdata structure.  */

struct alpha_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* For every input file, these are the got entries for that object's
     local symbols.  */
  struct alpha_elf_got_entry ** local_got_entries;

  /* For every input file, this is the object that owns the got that
     this input file uses.  */
  bfd *gotobj;

  /* For every got, this is a linked list through the objects using this got */
  bfd *in_got_link_next;

  /* For every got, this is a link to the next got subsegment.  */
  bfd *got_link_next;

  /* For every got, this is the section.  */
  asection *got;

  /* For every got, this is it's total number of words.  */
  int total_got_size;

  /* For every got, this is the sum of the number of words required
     to hold all of the member object's local got.  */
  int local_got_size;
};

#define alpha_elf_tdata(abfd) \
  ((struct alpha_elf_obj_tdata *) (abfd)->tdata.any)

static bfd_boolean
elf64_alpha_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

static bfd_boolean
elf64_alpha_object_p (abfd)
     bfd *abfd;
{
  /* Set the right machine number for an Alpha ELF file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_alpha, 0);
}

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

#define SKIP_HOWTO(N) \
  HOWTO(N, 0, 0, 0, 0, 0, 0, elf64_alpha_reloc_bad, 0, 0, 0, 0, 0)

static reloc_howto_type elf64_alpha_howto_table[] =
{
  HOWTO (R_ALPHA_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_nil,	/* special_function */
	 "NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit reference to a symbol.  */
  HOWTO (R_ALPHA_REFLONG,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "REFLONG",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit reference to a symbol.  */
  HOWTO (R_ALPHA_REFQUAD,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "REFQUAD",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit GP relative offset.  This is just like REFLONG except
     that when the value is used the value of the gp register will be
     added in.  */
  HOWTO (R_ALPHA_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPREL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used for an instruction that refers to memory off the GP register.  */
  HOWTO (R_ALPHA_LITERAL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "ELF_LITERAL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This reloc only appears immediately following an ELF_LITERAL reloc.
     It identifies a use of the literal.  The symbol index is special:
     1 means the literal address is in the base register of a memory
     format instruction; 2 means the literal address is in the byte
     offset register of a byte-manipulation instruction; 3 means the
     literal address is in the target register of a jsr instruction.
     This does not actually do any relocation.  */
  HOWTO (R_ALPHA_LITUSE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_nil,	/* special_function */
	 "LITUSE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Load the gp register.  This is always used for a ldah instruction
     which loads the upper 16 bits of the gp register.  The symbol
     index of the GPDISP instruction is an offset in bytes to the lda
     instruction that loads the lower 16 bits.  The value to use for
     the relocation is the difference between the GP value and the
     current location; the load will always be done against a register
     holding the current address.

     NOTE: Unlike ECOFF, partial in-place relocation is not done.  If
     any offset is present in the instructions, it is an offset from
     the register to the ldah instruction.  This lets us avoid any
     stupid hackery like inventing a gp value to do partial relocation
     against.  Also unlike ECOFF, we do the whole relocation off of
     the GPDISP rather than a GPDISP_HI16/GPDISP_LO16 pair.  An odd,
     space consuming bit, that, since all the information was present
     in the GPDISP_HI16 reloc.  */
  HOWTO (R_ALPHA_GPDISP,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_gpdisp, /* special_function */
	 "GPDISP",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 21 bit branch.  */
  HOWTO (R_ALPHA_BRADDR,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "BRADDR",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A hint for a jump to a register.  */
  HOWTO (R_ALPHA_HINT,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 14,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "HINT",		/* name */
	 FALSE,			/* partial_inplace */
	 0x3fff,		/* src_mask */
	 0x3fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 32 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 64 bit PC relative offset.  */
  HOWTO (R_ALPHA_SREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Skip 12 - 16; deprecated ECOFF relocs.  */
  SKIP_HOWTO (12),
  SKIP_HOWTO (13),
  SKIP_HOWTO (14),
  SKIP_HOWTO (15),
  SKIP_HOWTO (16),

  /* The high 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELHIGH,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPRELHIGH",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELLOW,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPRELLOW",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from the GP to the target.  */
  HOWTO (R_ALPHA_GPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Skip 20 - 23; deprecated ECOFF relocs.  */
  SKIP_HOWTO (20),
  SKIP_HOWTO (21),
  SKIP_HOWTO (22),
  SKIP_HOWTO (23),

  /* Misc ELF relocations.  */

  /* A dynamic relocation to copy the target into our .dynbss section.  */
  /* Not generated, as all Alpha objects use PIC, so it is not needed.  It
     is present because every other ELF has one, but should not be used
     because .dynbss is an ugly thing.  */
  HOWTO (R_ALPHA_COPY,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "COPY",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation for a .got entry.  */
  HOWTO (R_ALPHA_GLOB_DAT,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "GLOB_DAT",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation for a .plt entry.  */
  HOWTO (R_ALPHA_JMP_SLOT,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "JMP_SLOT",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A dynamic relocation to add the base of the DSO to a 64-bit field.  */
  HOWTO (R_ALPHA_RELATIVE,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfd_elf_generic_reloc,
	 "RELATIVE",
	 FALSE,
	 0,
	 0,
	 TRUE),

  /* A 21 bit branch that adjusts for gp loads.  */
  HOWTO (R_ALPHA_BRSGP,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "BRSGP",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Creates a tls_index for the symbol in the got.  */
  HOWTO (R_ALPHA_TLSGD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSGD",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a tls_index for the (current) module in the got.  */
  HOWTO (R_ALPHA_TLSLDM,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSLDM",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a DTP module entry.  */
  HOWTO (R_ALPHA_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPMOD64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from DTP to the target.  */
  HOWTO (R_ALPHA_GOTDTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTDTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from TP to the target.  */
  HOWTO (R_ALPHA_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* A relocation function which doesn't do anything.  */

static bfd_reloc_status_type
elf64_alpha_reloc_nil (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_ok;
}

/* A relocation function used for an unsupported reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_bad (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_notsupported;
}

/* Do the work of the GPDISP relocation.  */

static bfd_reloc_status_type
elf64_alpha_do_reloc_gpdisp (abfd, gpdisp, p_ldah, p_lda)
     bfd *abfd;
     bfd_vma gpdisp;
     bfd_byte *p_ldah;
     bfd_byte *p_lda;
{
  bfd_reloc_status_type ret = bfd_reloc_ok;
  bfd_vma addend;
  unsigned long i_ldah, i_lda;

  i_ldah = bfd_get_32 (abfd, p_ldah);
  i_lda = bfd_get_32 (abfd, p_lda);

  /* Complain if the instructions are not correct.  */
  if (((i_ldah >> 26) & 0x3f) != 0x09
      || ((i_lda >> 26) & 0x3f) != 0x08)
    ret = bfd_reloc_dangerous;

  /* Extract the user-supplied offset, mirroring the sign extensions
     that the instructions perform.  */
  addend = ((i_ldah & 0xffff) << 16) | (i_lda & 0xffff);
  addend = (addend ^ 0x80008000) - 0x80008000;

  gpdisp += addend;

  if ((bfd_signed_vma) gpdisp < -(bfd_signed_vma) 0x80000000
      || (bfd_signed_vma) gpdisp >= (bfd_signed_vma) 0x7fff8000)
    ret = bfd_reloc_overflow;

  /* compensate for the sign extension again.  */
  i_ldah = ((i_ldah & 0xffff0000)
	    | (((gpdisp >> 16) + ((gpdisp >> 15) & 1)) & 0xffff));
  i_lda = (i_lda & 0xffff0000) | (gpdisp & 0xffff);

  bfd_put_32 (abfd, (bfd_vma) i_ldah, p_ldah);
  bfd_put_32 (abfd, (bfd_vma) i_lda, p_lda);

  return ret;
}

/* The special function for the GPDISP reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_gpdisp (abfd, reloc_entry, sym, data, input_section,
			  output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
{
  bfd_reloc_status_type ret;
  bfd_vma gp, relocation;
  bfd_byte *p_ldah, *p_lda;

  /* Don't do anything if we're not doing a final link.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (reloc_entry->address > input_section->_cooked_size ||
      reloc_entry->address + reloc_entry->addend > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* The gp used in the portion of the output object to which this
     input object belongs is cached on the input bfd.  */
  gp = _bfd_get_gp_value (abfd);

  relocation = (input_section->output_section->vma
		+ input_section->output_offset
		+ reloc_entry->address);

  p_ldah = (bfd_byte *) data + reloc_entry->address;
  p_lda = p_ldah + reloc_entry->addend;

  ret = elf64_alpha_do_reloc_gpdisp (abfd, gp - relocation, p_ldah, p_lda);

  /* Complain if the instructions are not correct.  */
  if (ret == bfd_reloc_dangerous)
    *err_msg = _("GPDISP relocation did not find ldah and lda instructions");

  return ret;
}

/* A mapping from BFD reloc types to Alpha ELF reloc types.  */

struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  int elf_reloc_val;
};

static const struct elf_reloc_map elf64_alpha_reloc_map[] =
{
  {BFD_RELOC_NONE,			R_ALPHA_NONE},
  {BFD_RELOC_32,			R_ALPHA_REFLONG},
  {BFD_RELOC_64,			R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,			R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,			R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_ELF_LITERAL,		R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,		R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,		R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,		R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,			R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,			R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,			R_ALPHA_SREL64},
  {BFD_RELOC_ALPHA_GPREL_HI16,		R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_GPREL_LO16,		R_ALPHA_GPRELLOW},
  {BFD_RELOC_GPREL16,			R_ALPHA_GPREL16},
  {BFD_RELOC_ALPHA_BRSGP,		R_ALPHA_BRSGP},
  {BFD_RELOC_ALPHA_TLSGD,		R_ALPHA_TLSGD},
  {BFD_RELOC_ALPHA_TLSLDM,		R_ALPHA_TLSLDM},
  {BFD_RELOC_ALPHA_DTPMOD64,		R_ALPHA_DTPMOD64},
  {BFD_RELOC_ALPHA_GOTDTPREL16,		R_ALPHA_GOTDTPREL},
  {BFD_RELOC_ALPHA_DTPREL64,		R_ALPHA_DTPREL64},
  {BFD_RELOC_ALPHA_DTPREL_HI16,		R_ALPHA_DTPRELHI},
  {BFD_RELOC_ALPHA_DTPREL_LO16,		R_ALPHA_DTPRELLO},
  {BFD_RELOC_ALPHA_DTPREL16,		R_ALPHA_DTPREL16},
  {BFD_RELOC_ALPHA_GOTTPREL16,		R_ALPHA_GOTTPREL},
  {BFD_RELOC_ALPHA_TPREL64,		R_ALPHA_TPREL64},
  {BFD_RELOC_ALPHA_TPREL_HI16,		R_ALPHA_TPRELHI},
  {BFD_RELOC_ALPHA_TPREL_LO16,		R_ALPHA_TPRELLO},
  {BFD_RELOC_ALPHA_TPREL16,		R_ALPHA_TPREL16},
};

/* Given a BFD reloc type, return a HOWTO structure.  */

static reloc_howto_type *
elf64_alpha_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  const struct elf_reloc_map *i, *e;
  i = e = elf64_alpha_reloc_map;
  e += sizeof (elf64_alpha_reloc_map) / sizeof (struct elf_reloc_map);
  for (; i != e; ++i)
    {
      if (i->bfd_reloc_val == code)
	return &elf64_alpha_howto_table[i->elf_reloc_val];
    }
  return 0;
}

/* Given an Alpha ELF reloc type, fill in an arelent structure.  */

static void
elf64_alpha_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned r_type;

  r_type = ELF64_R_TYPE(dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_ALPHA_max);
  cache_ptr->howto = &elf64_alpha_howto_table[r_type];
}

/* These two relocations create a two-word entry in the got.  */
#define alpha_got_entry_size(r_type) \
  (r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)

/* This is PT_TLS segment p_vaddr.  */
#define alpha_get_dtprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma)

/* Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */
#define alpha_get_tprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma					\
   - align_power ((bfd_vma) 16,						\
		  elf_hash_table (info)->tls_sec->alignment_power))

/* These functions do relaxation for Alpha ELF.

   Currently I'm only handling what I can do with existing compiler
   and assembler support, which means no instructions are removed,
   though some may be nopped.  At this time GCC does not emit enough
   information to do all of the relaxing that is possible.  It will
   take some not small amount of work for that to happen.

   There are a couple of interesting papers that I once read on this
   subject, that I cannot find references to at the moment, that
   related to Alpha in particular.  They are by David Wall, then of
   DEC WRL.  */

#define OP_LDA		0x08
#define OP_LDAH		0x09
#define INSN_JSR	0x68004000
#define INSN_JSR_MASK	0xfc00c000
#define OP_LDQ		0x29
#define OP_BR		0x30
#define OP_BSR		0x34
#define INSN_UNOP	0x2ffe0000
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e

struct alpha_relax_info
{
  bfd *abfd;
  asection *sec;
  bfd_byte *contents;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *relocs, *relend;
  struct bfd_link_info *link_info;
  bfd_vma gp;
  bfd *gotobj;
  asection *tsec;
  struct alpha_elf_link_hash_entry *h;
  struct alpha_elf_got_entry **first_gotent;
  struct alpha_elf_got_entry *gotent;
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
  unsigned char other;
};

static bfd_boolean elf64_alpha_relax_with_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel));
static bfd_vma elf64_alpha_relax_opt_call
  PARAMS((struct alpha_relax_info *info, bfd_vma symval));
static bfd_boolean elf64_alpha_relax_got_load
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, unsigned long));
static bfd_boolean elf64_alpha_relax_gprelhilo
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_tls_get_addr
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_section
  PARAMS((bfd *abfd, asection *sec, struct bfd_link_info *link_info,
	  bfd_boolean *again));

static Elf_Internal_Rela *
elf64_alpha_find_reloc_at_ofs (rel, relend, offset, type)
     Elf_Internal_Rela *rel, *relend;
     bfd_vma offset;
     int type;
{
  while (rel < relend)
    {
      if (rel->r_offset == offset
	  && ELF64_R_TYPE (rel->r_info) == (unsigned int) type)
	return rel;
      ++rel;
    }
  return NULL;
}

static bfd_boolean
elf64_alpha_relax_with_lituse (info, symval, irel)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
{
  Elf_Internal_Rela *urel, *irelend = info->relend;
  int flags, count, i;
  bfd_signed_vma disp;
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
  unsigned int lit_insn;

  lit_insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);
  if (lit_insn >> 26 != OP_LDQ)
    {
      ((*_bfd_error_handler)
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
	bfd_archive_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset));
      return TRUE;
    }

  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

  /* Summarize how this particular LITERAL is used.  */
  for (urel = irel+1, flags = count = 0; urel < irelend; ++urel, ++count)
    {
      if (ELF64_R_TYPE (urel->r_info) != R_ALPHA_LITUSE)
	break;
      if (urel->r_addend <= 3)
	flags |= 1 << urel->r_addend;
    }

  /* A little preparation for the loop...  */
  disp = symval - info->gp;

  for (urel = irel+1, i = 0; i < count; ++i, ++urel)
    {
      unsigned int insn;
      int insn_disp;
      bfd_signed_vma xdisp;

      insn = bfd_get_32 (info->abfd, info->contents + urel->r_offset);

      switch (urel->r_addend)
	{
	case LITUSE_ALPHA_ADDR:
	default:
	  /* This type is really just a placeholder to note that all
	     uses cannot be optimized, but to still allow some.  */
	  all_optimized = FALSE;
	  break;

	case LITUSE_ALPHA_BASE:
	  /* We can always optimize 16-bit displacements.  */

	  /* Extract the displacement from the instruction, sign-extending
	     it if necessary, then test whether it is within 16 or 32 bits
	     displacement from GP.  */
	  insn_disp = ((insn & 0xffff) ^ 0x8000) - 0x8000;

	  xdisp = disp + insn_disp;
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);

	  if (fits16)
	    {
	      /* Take the op code and dest from this insn, take the base
		 register from the literal insn.  Leave the offset alone.  */
	      insn = (insn & 0xffe0ffff) | (lit_insn & 0x001f0000);
	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPREL16);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;

	      bfd_put_32 (info->abfd, (bfd_vma) insn,
			  info->contents + urel->r_offset);
	      info->changed_contents = TRUE;
	    }

	  /* If all mem+byte, we can optimize 32-bit mem displacements.  */
	  else if (fits32 && !(flags & ~6))
	    {
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb.  */

	      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELHIGH);
	      lit_insn = (OP_LDAH << 26) | (lit_insn & 0x03ff0000);
	      bfd_put_32 (info->abfd, (bfd_vma) lit_insn,
			  info->contents + irel->r_offset);
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;

	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELLOW);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = TRUE;
	    }
	  else
	    all_optimized = FALSE;
	  break;

	case LITUSE_ALPHA_BYTOFF:
	  /* We can always optimize byte instructions.  */

	  /* FIXME: sanity check the insn for byte op.  Check that the
	     literal dest reg is indeed Rb in the byte insn.  */

	  insn &= ~ (unsigned) 0x001ff000;
	  insn |= ((symval & 7) << 13) | 0x1000;

	  urel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  urel->r_addend = 0;
	  info->changed_relocs = TRUE;

	  bfd_put_32 (info->abfd, (bfd_vma) insn,
		      info->contents + urel->r_offset);
	  info->changed_contents = TRUE;
	  break;

	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
	  {
	    bfd_vma optdest, org;
	    bfd_signed_vma odisp;

	    /* For undefined weak symbols, we're mostly interested in getting
	       rid of the got entry whenever possible, so optimize this to a
	       use of the zero register.  */
	    if (info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	      {
		insn |= 31 << 16;
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);

		info->changed_contents = TRUE;
		break;
	      }

	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
	    odisp = (optdest ? optdest : symval) - org;

	    if (odisp >= -0x400000 && odisp < 0x400000)
	      {
		Elf_Internal_Rela *xrel;

		/* Preserve branch prediction call stack when possible.  */
		if ((insn & INSN_JSR_MASK) == INSN_JSR)
		  insn = (OP_BSR << 26) | (insn & 0x03e00000);
		else
		  insn = (OP_BR << 26) | (insn & 0x03e00000);

		urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					     R_ALPHA_BRADDR);
		urel->r_addend = irel->r_addend;

		if (optdest)
		  urel->r_addend += optdest - symval;
		else
		  all_optimized = FALSE;

		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);

		/* Kill any HINT reloc that might exist for this insn.  */
		xrel = (elf64_alpha_find_reloc_at_ofs
			(info->relocs, info->relend, urel->r_offset,
			 R_ALPHA_HINT));
		if (xrel)
		  xrel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
	      }
	    else
	      all_optimized = FALSE;

	    /* Even if the target is not in range for a direct branch,
	       if we share a GP, we can eliminate the gp reload.  */
	    if (optdest)
	      {
		Elf_Internal_Rela *gpdisp
		  = (elf64_alpha_find_reloc_at_ofs
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
		if (gpdisp)
		  {
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
		    bfd_byte *p_lda = p_ldah + gpdisp->r_addend;
		    unsigned int ldah = bfd_get_32 (info->abfd, p_ldah);
		    unsigned int lda = bfd_get_32 (info->abfd, p_lda);

		    /* Verify that the instruction is "ldah $29,0($26)".
		       Consider a function that ends in a noreturn call,
		       and that the next function begins with an ldgp,
		       and that by accident there is no padding between.
		       In that case the insn would use $27 as the base.  */
		    if (ldah == 0x27ba0000 && lda == 0x23bd0000)
		      {
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_ldah);
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_lda);

			gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
		      }
		  }
	      }
	  }
	  break;
	}
    }

  /* If all cases were optimized, we can reduce the use count on this
     got entry by one, possibly eliminating it.  */
  if (all_optimized)
    {
      if (--info->gotent->use_count == 0)
	{
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
	}

      /* If the literal instruction is no longer needed (it may have been
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
	 so just nop it out.  */
      if (!lit_reused)
	{
	  irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  info->changed_relocs = TRUE;

	  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP,
		      info->contents + irel->r_offset);
	  info->changed_contents = TRUE;
	}

      return TRUE;
    }
  else
    return elf64_alpha_relax_got_load (info, symval, irel, R_ALPHA_LITERAL);
}

static bfd_vma
elf64_alpha_relax_opt_call (info, symval)
     struct alpha_relax_info *info;
     bfd_vma symval;
{
  /* If the function has the same gp, and we can identify that the
     function does not use its function pointer, we can eliminate the
     address load.  */

  /* If the symbol is marked NOPV, we are being told the function never
     needs its procedure value.  */
  if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_NOPV)
    return symval;

  /* If the symbol is marked STD_GP, we are being told the function does
     a normal ldgp in the first two words.  */
  else if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_STD_GPLOAD)
    ;

  /* Otherwise, we may be able to identify a GP load in the first two
     words, which we can then skip.  */
  else
    {
      Elf_Internal_Rela *tsec_relocs, *tsec_relend, *tsec_free, *gpdisp;
      bfd_vma ofs;

      /* Load the relocations from the section that the target symbol is in.  */
      if (info->sec == info->tsec)
	{
	  tsec_relocs = info->relocs;
	  tsec_relend = info->relend;
	  tsec_free = NULL;
	}
      else
	{
	  tsec_relocs = (_bfd_elf_link_read_relocs
		         (info->abfd, info->tsec, (PTR) NULL,
			 (Elf_Internal_Rela *) NULL,
			 info->link_info->keep_memory));
	  if (tsec_relocs == NULL)
	    return 0;
	  tsec_relend = tsec_relocs + info->tsec->reloc_count;
	  tsec_free = (info->link_info->keep_memory ? NULL : tsec_relocs);
	}

      /* Recover the symbol's offset within the section.  */
      ofs = (symval - info->tsec->output_section->vma
	     - info->tsec->output_offset);

      /* Look for a GPDISP reloc.  */
      gpdisp = (elf64_alpha_find_reloc_at_ofs
		(tsec_relocs, tsec_relend, ofs, R_ALPHA_GPDISP));

      if (!gpdisp || gpdisp->r_addend != 4)
	{
	  if (tsec_free)
	    free (tsec_free);
	  return 0;
	}
      if (tsec_free)
        free (tsec_free);
    }

  /* We've now determined that we can skip an initial gp load.  Verify
     that the call and the target use the same gp.   */
  if (info->link_info->hash->creator != info->tsec->owner->xvec
      || info->gotobj != alpha_elf_tdata (info->tsec->owner)->gotobj)
    return 0;

  return symval + 8;
}

static bfd_boolean
elf64_alpha_relax_got_load (info, symval, irel, r_type)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     unsigned long r_type;
{
  unsigned int insn;
  bfd_signed_vma disp;

  /* Get the instruction.  */
  insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);

  if (insn >> 26 != OP_LDQ)
    {
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
      ((*_bfd_error_handler)
       ("%s: %s+0x%lx: warning: %s relocation against unexpected insn",
	bfd_archive_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset, howto->name));
      return TRUE;
    }

  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
    return TRUE;

  if (r_type == R_ALPHA_LITERAL)
    {
      /* Look for nice constant addresses.  This includes the not-uncommon
	 special case of 0 for undefweak symbols.  */
      if ((info->h && info->h->root.root.type == bfd_link_hash_undefweak)
	  || (!info->link_info->shared
	      && (symval >= (bfd_vma)-0x8000 || symval < 0x8000)))
	{
	  disp = 0;
	  insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
	  insn |= (symval & 0xffff);
	  r_type = R_ALPHA_NONE;
	}
      else
	{
	  disp = symval - info->gp;
	  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
	  r_type = R_ALPHA_GPREL16;
	}
    }
  else
    {
      bfd_vma dtp_base, tp_base;

      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);

      insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);

      switch (r_type)
	{
	case R_ALPHA_GOTDTPREL:
	  r_type = R_ALPHA_DTPREL16;
	  break;
	case R_ALPHA_GOTTPREL:
	  r_type = R_ALPHA_TPREL16;
	  break;
	default:
	  BFD_ASSERT (0);
	  return FALSE;
	}
    }

  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;

  bfd_put_32 (info->abfd, (bfd_vma) insn, info->contents + irel->r_offset);
  info->changed_contents = TRUE;

  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
  info->changed_relocs = TRUE;

  /* ??? Search forward through this basic block looking for insns
     that use the target register.  Stop after an insn modifying the
     register is seen, or after a branch or call.

     Any such memory load insn may be substituted by a load directly
     off the GP.  This allows the memory load insn to be issued before
     the calculated GP register would otherwise be ready.

     Any such jsr insn can be replaced by a bsr if it is in range.

     This would mean that we'd have to _add_ relocations, the pain of
     which gives one pause.  */

  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_gprelhilo (info, symval, irel, hi)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean hi;
{
  unsigned int insn;
  bfd_signed_vma disp;
  bfd_byte *pos = info->contents + irel->r_offset;

  /* ??? This assumes that the compiler doesn't render

	array[i]
     as
	ldah	t, array(gp)	!gprelhigh
	s8addl	i, t, t
	ldq	r, array(t)	!gprellow

     which would indeed be the most efficient way to implement this.  */

  return TRUE;

  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;

  if (hi)
    {
      /* Nop out the high instruction.  */

      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos);
      info->changed_contents = TRUE;

      irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      irel->r_addend = 0;
      info->changed_relocs = TRUE;
    }
  else
    {
      /* Adjust the low instruction to reference GP directly.  */

      insn = bfd_get_32 (info->abfd, pos);
      insn = (insn & 0xffe00000) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos);
      info->changed_contents = TRUE;

      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				   R_ALPHA_GPREL16);
      info->changed_relocs = TRUE;
    }

  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_tls_get_addr (info, symval, irel, is_gd)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean is_gd;
{
  bfd_byte *pos[5];
  unsigned int insn;
  Elf_Internal_Rela *gpdisp, *hint;
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
  unsigned long new_symndx;

  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);

  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;

  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;

  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return TRUE;

  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return TRUE;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return TRUE;

  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return TRUE;

  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;
  pos1_unusable = FALSE;

  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
    return TRUE;

  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;

    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];

    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;

    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);

    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }

  /* Change

	lda	$16,x($gp)		!tlsgd!1
	ldq	$27,__tls_get_addr($gp)	!literal!1
	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)		!gpdisp!2
	lda	$29,0($29)		!gpdisp!2
     to
	ldq	$16,x($gp)		!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)		!tprel
	unop
     or
	ldah	$16,x($gp)		!tprelhi
	lda	$16,x($16)		!tprello

     as appropriate.  */

  use_gottprel = FALSE;
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
  switch (!dynamic && !info->link_info->shared)
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
	disp = symval - tp_base;

	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && !pos1_unusable)
	  {
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */

    default:
      use_gottprel = TRUE;

      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
    }

  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);

  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);

  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);

  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;

  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;

      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
	{
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return FALSE;

	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;

	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }

	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
    }

  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isymbuf = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = FALSE;

  if (link_info->relocatable
      || ((sec->flags & (SEC_CODE | SEC_RELOC | SEC_ALLOC))
	  != (SEC_CODE | SEC_RELOC | SEC_ALLOC))
      || sec->reloc_count == 0)
    return TRUE;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    return FALSE;

  memset(&info, 0, sizeof (info));
  info.abfd = abfd;
  info.sec = sec;
  info.link_info = link_info;
  info.symtab_hdr = symtab_hdr;
  info.relocs = internal_relocs;
  info.relend = irelend = internal_relocs + sec->reloc_count;

  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
  info.gotobj = alpha_elf_tdata (abfd)->gotobj;
  if (info.gotobj)
    {
      asection *sgot = alpha_elf_tdata (info.gotobj)->got;
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
    }

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
  else
    {
      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (info.contents == NULL)
	goto error_return;

      if (! bfd_get_section_contents (abfd, sec, info.contents,
				      (file_ptr) 0, sec->_raw_size))
	goto error_return;
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      struct alpha_elf_got_entry *gotent;
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);

      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	  break;

	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  break;

	default:
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  isym = isymbuf + r_symndx;

	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.link_info);
	    }
	  else
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }

	  info.h = NULL;
	  info.other = isym->st_other;
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
	}
      else
	{
	  unsigned long indx;
	  struct alpha_elf_link_hash_entry *h;

	  indx = r_symndx - symtab_hdr->sh_info;
	  h = alpha_elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefined)
	    continue;

	  /* If the symbol isn't defined in the current module,
	     again we can't do anything.  */
	  if (h->root.root.type == bfd_link_hash_undefweak)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }

	  info.h = h;
	  info.other = h->root.other;
	  info.first_gotent = &h->got_entries;
	}

      /* Search for the got entry to be used by this relocation.  */
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
      info.gotent = gotent;

      symval += info.tsec->output_section->vma + info.tsec->output_offset;
      symval += irel->r_addend;

      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);

	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
	    }
	  break;

	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  if (!elf64_alpha_relax_gprelhilo (&info, symval, irel,
					    r_type == R_ALPHA_GPRELHIGH))
	    goto error_return;
	  break;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
	    goto error_return;
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
	    goto error_return;
	  break;
	}
    }

  if (!elf64_alpha_size_plt_section (link_info))
    return FALSE;
  if (!elf64_alpha_size_got_sections (link_info))
    return FALSE;
  if (!elf64_alpha_size_rela_got_section (link_info))
    return FALSE;

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    {
      if (!info.changed_contents && !link_info->keep_memory)
	free (info.contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = info.contents;
	}
    }

  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!info.changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

  *again = info.changed_contents || info.changed_relocs;

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    free (info.contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* PLT/GOT Stuff */
#define PLT_HEADER_SIZE 32
#define PLT_HEADER_WORD1	(bfd_vma) 0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	(bfd_vma) 0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	(bfd_vma) 0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	(bfd_vma) 0x6b7b0000	/* jmp  $27,($27)   */

#define PLT_ENTRY_SIZE 12
#define PLT_ENTRY_WORD1		0xc3800000	/* br   $28, plt0   */
#define PLT_ENTRY_WORD2		0
#define PLT_ENTRY_WORD3		0

#define MAX_GOT_SIZE		(64*1024)

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so"

/* Handle an Alpha specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.
   FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure
   how to.  */

static bfd_boolean
elf64_alpha_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
{
  asection *newsect;

  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_ALPHA_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return FALSE;
      break;
    default:
      return FALSE;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return FALSE;
  newsect = hdr->bfd_section;

  if (hdr->sh_type == SHT_ALPHA_DEBUG)
    {
      if (! bfd_set_section_flags (abfd, newsect,
				   (bfd_get_section_flags (abfd, newsect)
				    | SEC_DEBUGGING)))
	return FALSE;
    }

  return TRUE;
}

/* Convert Alpha specific section flags to bfd internal section flags.  */

static bfd_boolean
elf64_alpha_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_flags & SHF_ALPHA_GPREL)
    *flags |= SEC_SMALL_DATA;

  return TRUE;
}

/* Set the correct type for an Alpha ELF section.  We do this by the
   section name, which is a hack, but ought to work.  */

static bfd_boolean
elf64_alpha_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *sec;
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_ALPHA_DEBUG;
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if ((abfd->flags & DYNAMIC) != 0 )
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if ((sec->flags & SEC_SMALL_DATA)
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_ALPHA_GPREL;

  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */

static bfd_boolean
elf64_alpha_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && sym->st_size <= elf_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}

/* Create the .got section.  */

static bfd_boolean
elf64_alpha_create_got_section(abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  asection *s;

  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
    }

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED))
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  alpha_elf_tdata (abfd)->got = s;

  return TRUE;
}

/* Create all the dynamic sections.  */

static bfd_boolean
elf64_alpha_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;

  /* We need to create .plt, .rela.plt, .got, and .rela.got sections.  */

  s = bfd_make_section (abfd, ".plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					    | SEC_HAS_CONTENTS
					    | SEC_IN_MEMORY
					    | SEC_LINKER_CREATED
					    | SEC_CODE))
      || ! bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
     .plt section.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  s = bfd_make_section (abfd, ".rela.plt");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  /* We may or may not have created a .got section for this object, but
     we definitely havn't done the rest of the work.  */

  if (!elf64_alpha_create_got_section (abfd, info))
    return FALSE;

  s = bfd_make_section(abfd, ".rela.got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the
     dynobj's .got section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL,
	 alpha_elf_tdata(abfd)->got, (bfd_vma) 0, (const char *) NULL,
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  elf_hash_table (info)->hgot = h;

  return TRUE;
}

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */

static bfd_boolean
elf64_alpha_read_ecoff_info (abfd, section, debug)
     bfd *abfd;
     asection *section;
     struct ecoff_debug_info *debug;
{
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));

  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;

  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = (type) bfd_malloc (amt);				\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
	goto error_return;						\
    }

  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
#undef READ

  debug->fdr = NULL;
  debug->adjust = NULL;

  return TRUE;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return FALSE;
}

/* Alpha ELF local labels start with '$'.  */

static bfd_boolean
elf64_alpha_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return name[0] == '$';
}

/* Alpha ELF follows MIPS ELF in using a special find_nearest_line
   routine in order to handle the ECOFF debugging information.  We
   still call this mips_elf_find_line because of the slot
   find_line_info in elf_obj_tdata is declared that way.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

static bfd_boolean
elf64_alpha_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			       functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  asection *msec;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return TRUE;

  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct mips_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

      /* If we are called during a link, alpha_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;

      fi = elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);

	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  if (!elf64_alpha_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  /* Swap in the FDR information.  */
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);

	  elf_tdata (abfd)->find_line_info = fi;

	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}

      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
	{
	  msec->flags = origflags;
	  return TRUE;
	}

      msec->flags = origflags;
    }

  /* Fall back on the generic ELF find_nearest_line routine.  */

  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
}

/* Structure used to pass information to alpha_elf_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  bfd_boolean failed;
};

static bfd_boolean
elf64_alpha_output_extsym (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  struct extsym_info *einfo = (struct extsym_info *) data;
  bfd_boolean strip;
  asection *sec, *output_section;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  if (h->root.indx == -2)
    strip = FALSE;
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = TRUE;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
  else
    strip = FALSE;

  if (strip)
    return TRUE;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = bfd_get_section_by_name (einfo->abfd, ".plt");
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
	{
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
	  else
	    h->esym.asym.value = 0;
	}
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Search for and possibly create a got entry.  */

static struct alpha_elf_got_entry *
get_got_entry (abfd, h, r_type, r_symndx, r_addend)
     bfd *abfd;
     struct alpha_elf_link_hash_entry *h;
     unsigned long r_type, r_symndx;
     bfd_vma r_addend;
{
  struct alpha_elf_got_entry *gotent;
  struct alpha_elf_got_entry **slot;

  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */

      struct alpha_elf_got_entry **local_got_entries;

      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);

	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;

	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
    {
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
    }
  else
    gotent->use_count += 1;

  return gotent;
}

/* Handle dynamic relocations when doing an Alpha ELF link.  */

static bfd_boolean
elf64_alpha_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  bfd *dynobj;
  asection *sreloc;
  const char *rel_sec_name;
  Elf_Internal_Shdr *symtab_hdr;
  struct alpha_elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  bfd_boolean got_created;
  bfd_size_type amt;

  if (info->relocatable)
    return TRUE;

  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj == NULL)
    elf_hash_table(info)->dynobj = dynobj = abfd;

  sreloc = NULL;
  rel_sec_name = NULL;
  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
  sym_hashes = alpha_elf_sym_hashes(abfd);
  got_created = FALSE;

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; ++rel)
    {
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };

      unsigned long r_symndx, r_type;
      struct alpha_elf_link_hash_entry *h;
      unsigned int gotent_flags;
      bfd_boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  h->root.elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
	}

      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = FALSE;
      if (h && ((info->shared
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| ! (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = TRUE;

      need = 0;
      gotent_flags = 0;
      r_type = ELF64_R_TYPE (rel->r_info);
      addend = rel->r_addend;

      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  need = NEED_GOT | NEED_GOT_ENTRY;

	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;

	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;

	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL16:
	case R_ALPHA_GPREL32:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_BRSGP:
	  need = NEED_GOT;
	  break;

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;

	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;

	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_ALPHA_TPREL64:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
	}

      if (need & NEED_GOT)
	{
	  if (!got_created)
	    {
	      if (!elf64_alpha_create_got_section (abfd, info))
		return FALSE;

	      /* Make sure the object's gotobj is set to itself so
		 that we default to every object with its own .got.
		 We'll merge .gots later once we've collected each
		 object's info.  */
	      alpha_elf_tdata(abfd)->gotobj = abfd;

	      got_created = 1;
	    }
	}

      if (need & NEED_GOT_ENTRY)
	{
	  struct alpha_elf_got_entry *gotent;

	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
	    return FALSE;

	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;

		  /* Make a guess as to whether a .plt entry is needed.  */
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  else
		    h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	        }
	    }
	}

      if (need & NEED_DYNREL)
	{
	  if (rel_sec_name == NULL)
	    {
	      rel_sec_name = (bfd_elf_string_from_elf_section
			      (abfd, elf_elfheader(abfd)->e_shstrndx,
			       elf_section_data(sec)->rel_hdr.sh_name));
	      if (rel_sec_name == NULL)
		return FALSE;

	      BFD_ASSERT (strncmp (rel_sec_name, ".rela", 5) == 0
			  && strcmp (bfd_get_section_name (abfd, sec),
				     rel_sec_name+5) == 0);
	    }

	  /* We need to create the section here now whether we eventually
	     use it or not so that it gets mapped to an output section by
	     the linker.  If not used, we'll kill it in
	     size_dynamic_sections.  */
	  if (sreloc == NULL)
	    {
	      sreloc = bfd_get_section_by_name (dynobj, rel_sec_name);
	      if (sreloc == NULL)
		{
		  flagword flags;

		  sreloc = bfd_make_section (dynobj, rel_sec_name);
		  flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
			   | SEC_LINKER_CREATED | SEC_READONLY);
		  if (sec->flags & SEC_ALLOC)
		    flags |= SEC_ALLOC | SEC_LOAD;
		  if (sreloc == NULL
		      || !bfd_set_section_flags (dynobj, sreloc, flags)
		      || !bfd_set_section_alignment (dynobj, sreloc, 3))
		    return FALSE;
		}
	    }

	  if (h)
	    {
	      /* Since we havn't seen all of the input symbols yet, we
		 don't know whether we'll actually need a dynamic relocation
		 entry for this reloc.  So make a record of it.  Once we
		 find out if this thing needs dynamic relocation we'll
		 expand the relocation sections by the appropriate amount.  */

	      struct alpha_elf_reloc_entry *rent;

	      for (rent = h->reloc_entries; rent; rent = rent->next)
		if (rent->rtype == r_type && rent->srel == sreloc)
		  break;

	      if (!rent)
		{
		  amt = sizeof (struct alpha_elf_reloc_entry);
		  rent = (struct alpha_elf_reloc_entry *) bfd_alloc (abfd, amt);
		  if (!rent)
		    return FALSE;

		  rent->srel = sreloc;
		  rent->rtype = r_type;
		  rent->count = 1;
		  rent->reltext = (sec->flags & SEC_READONLY) != 0;

		  rent->next = h->reloc_entries;
		  h->reloc_entries = rent;
		}
	      else
		rent->count++;
	    }
	  else if (info->shared)
	    {
	      /* If this is a shared library, and the section is to be
		 loaded into memory, we need a RELATIVE reloc.  */
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
	      if (sec->flags & SEC_READONLY)
		info->flags |= DF_TEXTREL;
	    }
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf64_alpha_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  asection *s;
  struct alpha_elf_link_hash_entry *ah;

  dynobj = elf_hash_table(info)->dynobj;
  ah = (struct alpha_elf_link_hash_entry *)h;

  /* Now that we've seen all of the input symbols, finalize our decision
     about whether this symbol should get a .plt entry.  */

  if (alpha_elf_dynamic_symbol_p (h, info)
      && ((h->type == STT_FUNC
	   && !(ah->flags & ALPHA_ELF_LINK_HASH_LU_ADDR))
	  || (h->type == STT_NOTYPE
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
      /* Don't prevent otherwise valid programs from linking by attempting
	 to create a new .got entry somewhere.  A Correct Solution would be
	 to add a new .got section to a new object file and let it be merged
	 somewhere later.  But for now don't bother.  */
      && ah->got_entries)
    {
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

      s = bfd_get_section_by_name(dynobj, ".plt");
      if (!s && !elf64_alpha_create_dynamic_sections (dynobj, info))
	return FALSE;

      /* The first bit of the .plt is reserved.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_HEADER_SIZE;

      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are not
	 generating a shared library, then set the symbol to the location
	 in the .plt.  This is required to make function pointers compare
	 equal between the normal executable and the shared library.  */
      if (! info->shared
	  && h->root.type != bfd_link_hash_defweak)
	{
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
	  h->root.u.def.section = s;
	  h->root.u.def.value = h->plt.offset;
	}

      /* We also need a JMP_SLOT entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf64_External_Rela);

      return TRUE;
    }
  else
    h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  The Alpha, since it uses .got entries for all
     symbols even in regular objects, does not need the hackery of a
     .dynbss section and COPY dynamic relocations.  */

  return TRUE;
}

/* Symbol versioning can create new symbols, and make our old symbols
   indirect to the new ones.  Consolidate the got and reloc information
   in these situations.  */

static bfd_boolean
elf64_alpha_merge_ind_symbols (hi, dummy)
     struct alpha_elf_link_hash_entry *hi;
     PTR dummy ATTRIBUTE_UNUSED;
{
  struct alpha_elf_link_hash_entry *hs;

  if (hi->root.root.type != bfd_link_hash_indirect)
    return TRUE;
  hs = hi;
  do {
    hs = (struct alpha_elf_link_hash_entry *)hs->root.root.u.i.link;
  } while (hs->root.root.type == bfd_link_hash_indirect);

  /* Merge the flags.  Whee.  */

  hs->flags |= hi->flags;

  /* Merge the .got entries.  Cannibalize the old symbol's list in
     doing so, since we don't need it anymore.  */

  if (hs->got_entries == NULL)
    hs->got_entries = hi->got_entries;
  else
    {
      struct alpha_elf_got_entry *gi, *gs, *gin, *gsh;

      gsh = hs->got_entries;
      for (gi = hi->got_entries; gi ; gi = gin)
	{
	  gin = gi->next;
	  for (gs = gsh; gs ; gs = gs->next)
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
	  gi->next = hs->got_entries;
	  hs->got_entries = gi;
	got_found:;
	}
    }
  hi->got_entries = NULL;

  /* And similar for the reloc entries.  */

  if (hs->reloc_entries == NULL)
    hs->reloc_entries = hi->reloc_entries;
  else
    {
      struct alpha_elf_reloc_entry *ri, *rs, *rin, *rsh;

      rsh = hs->reloc_entries;
      for (ri = hi->reloc_entries; ri ; ri = rin)
	{
	  rin = ri->next;
	  for (rs = rsh; rs ; rs = rs->next)
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
	      {
		rs->count += ri->count;
		goto found_reloc;
	      }
	  ri->next = hs->reloc_entries;
	  hs->reloc_entries = ri;
	found_reloc:;
	}
    }
  hi->reloc_entries = NULL;

  return TRUE;
}

/* Is it possible to merge two object file's .got tables?  */

static bfd_boolean
elf64_alpha_can_merge_gots (a, b)
     bfd *a, *b;
{
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;

  /* Trivial quick fallout test.  */
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
    return TRUE;

  /* By their nature, local .got entries cannot be merged.  */
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
    return FALSE;

  /* Failing the common trivial comparison, we must effectively
     perform the merge.  Not actually performing the merge means that
     we don't have to store undo information in case we fail.  */
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes (bsub);
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (bsub)->symtab_hdr;
      int i, n;

      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
	{
	  struct alpha_elf_got_entry *ae, *be;
	  struct alpha_elf_link_hash_entry *h;

	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  for (be = h->got_entries; be ; be = be->next)
	    {
	      if (be->use_count == 0)
	        continue;
	      if (be->gotobj != b)
	        continue;

	      for (ae = h->got_entries; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  goto global_found;

	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
	        return FALSE;
	    global_found:;
	    }
	}
    }

  return TRUE;
}

/* Actually merge two .got tables.  */

static void
elf64_alpha_merge_gots (a, b)
     bfd *a, *b;
{
  int total = alpha_elf_tdata (a)->total_got_size;
  bfd *bsub;

  /* Remember local expansion.  */
  {
    int e = alpha_elf_tdata (b)->local_got_size;
    total += e;
    alpha_elf_tdata (a)->local_got_size += e;
  }

  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_got_entry **local_got_entries;
      struct alpha_elf_link_hash_entry **hashes;
      Elf_Internal_Shdr *symtab_hdr;
      int i, n;

      /* Let the local .got entries know they are part of a new subsegment.  */
      local_got_entries = alpha_elf_tdata (bsub)->local_got_entries;
      if (local_got_entries)
        {
	  n = elf_tdata (bsub)->symtab_hdr.sh_info;
	  for (i = 0; i < n; ++i)
	    {
	      struct alpha_elf_got_entry *ent;
	      for (ent = local_got_entries[i]; ent; ent = ent->next)
	        ent->gotobj = a;
	    }
        }

      /* Merge the global .got entries.  */
      hashes = alpha_elf_sym_hashes (bsub);
      symtab_hdr = &elf_tdata (bsub)->symtab_hdr;

      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
        {
	  struct alpha_elf_got_entry *ae, *be, **pbe, **start;
	  struct alpha_elf_link_hash_entry *h;

	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  start = &h->got_entries;
	  for (pbe = start, be = *start; be ; pbe = &be->next, be = be->next)
	    {
	      if (be->use_count == 0)
	        {
		  *pbe = be->next;
		  continue;
	        }
	      if (be->gotobj != b)
	        continue;

	      for (ae = *start; ae ; ae = ae->next)
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
		  {
		    ae->flags |= be->flags;
		    ae->use_count += be->use_count;
		    *pbe = be->next;
		    goto global_found;
		  }
	      be->gotobj = a;
	      total += alpha_got_entry_size (be->reloc_type);

	    global_found:;
	    }
        }

      alpha_elf_tdata (bsub)->gotobj = a;
    }
  alpha_elf_tdata (a)->total_got_size = total;

  /* Merge the two in_got chains.  */
  {
    bfd *next;

    bsub = a;
    while ((next = alpha_elf_tdata (bsub)->in_got_link_next) != NULL)
      bsub = next;

    alpha_elf_tdata (bsub)->in_got_link_next = b;
  }
}

/* Calculate the offsets for the got entries.  */

static bfd_boolean
elf64_alpha_calc_got_offsets_for_symbol (h, arg)
     struct alpha_elf_link_hash_entry *h;
     PTR arg ATTRIBUTE_UNUSED;
{
  bfd_boolean result = TRUE;
  struct alpha_elf_got_entry *gotent;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  for (gotent = h->got_entries; gotent; gotent = gotent->next)
    if (gotent->use_count > 0)
      {
	struct alpha_elf_obj_tdata *td;
	bfd_size_type *plge;

	td = alpha_elf_tdata (gotent->gotobj);
	if (td == NULL)
	  {
	    _bfd_error_handler (_("Symbol %s has no GOT subsection for offset 0x%x"),
				h->root.root.root.string, gotent->got_offset);
	    result = FALSE;
	    continue;
	  }
	plge = &td->got->_raw_size;
	gotent->got_offset = *plge;
	*plge += alpha_got_entry_size (gotent->reloc_type);
      }

  return result;
}

static void
elf64_alpha_calc_got_offsets (info)
     struct bfd_link_info *info;
{
  bfd *i, *got_list = alpha_elf_hash_table(info)->got_list;

  /* First, zero out the .got sizes, as we may be recalculating the
     .got after optimizing it.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    alpha_elf_tdata(i)->got->_raw_size = 0;

  /* Next, fill in the offsets for all the global entries.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_calc_got_offsets_for_symbol,
				NULL);

  /* Finally, fill in the offsets for the local entries.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->_raw_size;
      bfd *j;

      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k]; gotent; gotent = gotent->next)
	      if (gotent->use_count > 0)
	        {
		  gotent->got_offset = got_offset;
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
	        }
	}

      alpha_elf_tdata(i)->got->_raw_size = got_offset;
      alpha_elf_tdata(i)->got->_cooked_size = got_offset;
    }
}

/* Constructs the gots.  */

static bfd_boolean
elf64_alpha_size_got_sections (info)
     struct bfd_link_info *info;
{
  bfd *i, *got_list, *cur_got_obj = NULL;
  int something_changed = 0;

  got_list = alpha_elf_hash_table (info)->got_list;

  /* On the first time through, pretend we have an existing got list
     consisting of all of the input files.  */
  if (got_list == NULL)
    {
      for (i = info->input_bfds; i ; i = i->link_next)
	{
	  bfd *this_got = alpha_elf_tdata (i)->gotobj;
	  if (this_got == NULL)
	    continue;

	  /* We are assuming no merging has yet occurred.  */
	  BFD_ASSERT (this_got == i);

          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
	    {
	      /* Yikes! A single object file has too many entries.  */
	      (*_bfd_error_handler)
	        (_("%s: .got subsegment exceeds 64K (size %d)"),
	         bfd_archive_filename (i),
	         alpha_elf_tdata (this_got)->total_got_size);
	      return FALSE;
	    }

	  if (got_list == NULL)
	    got_list = this_got;
	  else
	    alpha_elf_tdata(cur_got_obj)->got_link_next = this_got;
	  cur_got_obj = this_got;
	}

      /* Strange degenerate case of no got references.  */
      if (got_list == NULL)
	return TRUE;

      alpha_elf_hash_table (info)->got_list = got_list;

      /* Force got offsets to be recalculated.  */
      something_changed = 1;
    }

  cur_got_obj = got_list;
  i = alpha_elf_tdata(cur_got_obj)->got_link_next;
  while (i != NULL)
    {
      if (elf64_alpha_can_merge_gots (cur_got_obj, i))
	{
	  elf64_alpha_merge_gots (cur_got_obj, i);
	  i = alpha_elf_tdata(i)->got_link_next;
	  alpha_elf_tdata(cur_got_obj)->got_link_next = i;
	  something_changed = 1;
	}
      else
	{
	  cur_got_obj = i;
	  i = alpha_elf_tdata(i)->got_link_next;
	}
    }

  /* Once the gots have been merged, fill in the got offsets for
     everything therein.  */
  if (1 || something_changed)
    elf64_alpha_calc_got_offsets (info);

  return TRUE;
}

/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */

static bfd_boolean
elf64_alpha_size_plt_section (info)
     struct bfd_link_info *info;
{
  asection *splt, *spltrel;
  unsigned long entries;
  bfd *dynobj;

  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_section_by_name(dynobj, ".plt");
  if (splt == NULL)
    return TRUE;

  splt->_raw_size = 0;

  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_plt_section_1, splt);

  splt->_cooked_size = splt->_raw_size;

  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
  if (splt->_raw_size)
    entries = (splt->_raw_size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
  else
    entries = 0;
  spltrel->_raw_size = entries * sizeof (Elf64_External_Rela);
  spltrel->_cooked_size = spltrel->_raw_size;

  return TRUE;
}

static bfd_boolean
elf64_alpha_size_plt_section_1 (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;

  /* If we didn't need an entry before, we still don't.  */
  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT))
    return TRUE;

  /* There must still be a LITERAL got entry for the function.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      break;

  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
    {
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->_raw_size;
      splt->_raw_size += PLT_ENTRY_SIZE;
    }
  else
    {
      h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->root.plt.offset = -1;

      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
    }

  return TRUE;
}

static bfd_boolean
elf64_alpha_always_size_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *i;

  if (info->relocatable)
    return TRUE;

  /* First, take care of the indirect symbols created by versioning.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_merge_ind_symbols,
				NULL);

  if (!elf64_alpha_size_got_sections (info))
    return FALSE;

  /* Allocate space for all of the .got subsections.  */
  i = alpha_elf_hash_table (info)->got_list;
  for ( ; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      asection *s = alpha_elf_tdata(i)->got;
      if (s->_raw_size > 0)
	{
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->_raw_size);
	  if (s->contents == NULL)
	    return FALSE;
	}
    }

  return TRUE;
}

/* The number of dynamic relocations required by a static relocation.  */

static int
alpha_dynamic_entries_for_reloc (r_type, dynamic, shared)
     int r_type, dynamic, shared;
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
    case R_ALPHA_GOTTPREL:
      return dynamic || shared;
    case R_ALPHA_GOTDTPREL:
      return dynamic;

    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
    case R_ALPHA_TPREL64:
      return dynamic || shared;

    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
    default:
      return 0;
    }
}

/* Work out the sizes of the dynamic relocation entries.  */

static bfd_boolean
elf64_alpha_calc_dynrel_sizes (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  bfd_boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  /* If the symbol was defined as a common symbol in a regular object
     file, and there was no definition in any dynamic object, then the
     linker will have allocated space for the symbol in a common
     section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been
     set.  This is done for dynamic symbols in
     elf_adjust_dynamic_symbol but this is not done for non-dynamic
     symbols, somehow.  */
  if (((h->root.elf_link_hash_flags
       & (ELF_LINK_HASH_DEF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_DEF_DYNAMIC))
       == ELF_LINK_HASH_REF_REGULAR)
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak)
      && !(h->root.root.u.def.section->owner->flags & DYNAMIC))
    h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

  for (relent = h->reloc_entries; relent; relent = relent->next)
    {
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared);
      if (entries)
	{
	  relent->srel->_raw_size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
	}
    }

  return TRUE;
}

/* Set the sizes of the dynamic relocation sections.  */

static bfd_boolean
elf64_alpha_size_rela_got_section (info)
     struct bfd_link_info *info;
{
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;

  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */

  entries = 0;
  for (i = alpha_elf_hash_table(info)->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;

      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared));
	}
    }

  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!srel)
    {
      BFD_ASSERT (entries == 0);
      return TRUE;
    }
  srel->_raw_size = sizeof (Elf64_External_Rela) * entries;

  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_rela_got_1, info);

  srel->_cooked_size = srel->_raw_size;

  return TRUE;
}

/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */

static bfd_boolean
elf64_alpha_size_rela_got_1 (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  bfd_boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  /* If the symbol is a hidden undefined weak, then we never have any
     relocations.  Avoid the loop which may want to add RELATIVE relocs
     based on info->shared.  */
  if (h->root.root.type == bfd_link_hash_undefweak && !dynamic)
    return TRUE;

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);

  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela) * entries;
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf64_alpha_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  bfd_boolean relplt;

  dynobj = elf_hash_table(info)->dynobj;
  BFD_ASSERT(dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable && !info->static_link)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Now that we've seen all of the input files, we can decide which
	 symbols need dynamic relocation entries and which don't.  We've
	 collected information in check_relocs that we can now apply to
	 size the dynamic relocation sections.  */
      alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				    elf64_alpha_calc_dynrel_sizes, info);

      elf64_alpha_size_rela_got_section (info);
    }
  /* else we're not dynamic and by definition we don't need such things.  */

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relplt = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip;

      if (!(s->flags & SEC_LINKER_CREATED))
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      /* If we don't need this section, strip it from the output file.
	 This is to handle .rela.bss and .rela.plt.  We must create it
	 in create_dynamic_sections, because it must be created before
	 the linker maps input sections to output sections.  The
	 linker does that before adjust_dynamic_symbol is called, and
	 it is that function which decides whether anything needs to
	 go into these sections.  */

      strip = FALSE;

      if (strncmp (name, ".rela", 5) == 0)
	{
	  strip = (s->_raw_size == 0);

	  if (!strip)
	    {
	      if (strcmp(name, ".rela.plt") == 0)
		relplt = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strcmp (name, ".plt") != 0)
	{
	  /* It's not one of our dynamic sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	_bfd_strip_section_from_output (info, s);
      else
	{
	  /* Allocate memory for the section contents.  */
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf64_alpha_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (relplt)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	return FALSE;

      if (info->flags & DF_TEXTREL)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)
   into the next available slot in SREL.  */

static void
elf64_alpha_emit_dynrel (abfd, info, sec, srel, offset, dynindx, rtype, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec, *srel;
     bfd_vma offset, addend;
     long dynindx, rtype;
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (srel != NULL);

  outrel.r_info = ELF64_R_INFO (dynindx, rtype);
  outrel.r_addend = addend;

  offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if ((offset | 1) != (bfd_vma) -1)
    outrel.r_offset = sec->output_section->vma + sec->output_offset + offset;
  else
    memset (&outrel, 0, sizeof (outrel));

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
}

/* Relocate an Alpha ELF section for a relocatable link.

   We don't have to change anything unless the reloc is against a section
   symbol, in which case we have to adjust according to where the section
   symbol winds up in the output section.  */

static bfd_boolean
elf64_alpha_relocate_section_r (output_bfd, info, input_bfd, input_section,
			        contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  unsigned long symtab_hdr_sh_info;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  bfd_boolean ret_val = TRUE;

  symtab_hdr_sh_info = elf_tdata (input_bfd)->symtab_hdr.sh_info;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
	}

      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol associated with GPDISP and LITUSE is
	 immaterial.  Only the addend is significant.  */
      if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	continue;

      if (r_symndx < symtab_hdr_sh_info)
	{
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
	    {
	      sec = local_sections[r_symndx];
	      rel->r_addend += sec->output_offset + sym->st_value;
	    }
	}
    }

  return ret_val;
}

/* Relocate an Alpha ELF section.  */

static bfd_boolean
elf64_alpha_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  asection *sgot, *srel, *srelgot;
  bfd *dynobj, *gotobj;
  bfd_vma gp, tp_base, dtp_base;
  struct alpha_elf_got_entry **local_got_entries;
  bfd_boolean ret_val;

  /* Handle relocatable links with a smaller loop.  */
  if (info->relocatable)
    return elf64_alpha_relocate_section_r (output_bfd, info, input_bfd,
					   input_section, contents, relocs,
					   local_syms, local_sections);

  /* This is a final link.  */

  ret_val = TRUE;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  else
    srelgot = NULL;

  if (input_section->flags & SEC_ALLOC)
    {
      const char *section_name;
      section_name = (bfd_elf_string_from_elf_section
		      (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		       elf_section_data(input_section)->rel_hdr.sh_name));
      BFD_ASSERT(section_name != NULL);
      srel = bfd_get_section_by_name (dynobj, section_name);
    }
  else
    srel = NULL;
 
  /* Find the gp value for this input bfd.  */
  gotobj = alpha_elf_tdata (input_bfd)->gotobj;
  if (gotobj)
    {
      sgot = alpha_elf_tdata (gotobj)->got;
      gp = _bfd_get_gp_value (gotobj);
      if (gp == 0)
	{
	  gp = (sgot->output_section->vma
		+ sgot->output_offset
		+ 0x8000);
	  _bfd_set_gp_value (gotobj, gp);
	}
    }
  else
    {
      sgot = NULL;
      gp = 0;
    }

  local_got_entries = alpha_elf_tdata(input_bfd)->local_got_entries;

  if (elf_hash_table (info)->tls_sec != NULL)
    {
      dtp_base = alpha_get_dtprel_base (info);
      tp_base = alpha_get_tprel_base (info);
    }
  else
    dtp_base = tp_base = 0;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;
      bfd_reloc_status_type r;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym = NULL;
      asection *sec = NULL;
      bfd_vma value;
      bfd_vma addend;
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref = FALSE;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
	}

      howto = elf64_alpha_howto_table + r_type;
      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	 reloc to the 0 symbol so that they all match.  */
      if (r_type == R_ALPHA_TLSLDM)
	r_symndx = 0;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  asection *msec;
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  msec = sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);

	  /* If this is a tp-relative relocation against sym 0,
	     this is hackery from relax_section.  Force the value to
	     be the tls base.  */
	  if (r_symndx == 0
	      && (r_type == R_ALPHA_TLSLDM
		  || r_type == R_ALPHA_GOTTPREL
		  || r_type == R_ALPHA_TPREL64
		  || r_type == R_ALPHA_TPRELHI
		  || r_type == R_ALPHA_TPRELLO
		  || r_type == R_ALPHA_TPREL16))
	    value = tp_base;

	  if (local_got_entries)
	    gotent = local_got_entries[r_symndx];
	  else
	    gotent = NULL;

	  /* Need to adjust local GOT entries' addends for SEC_MERGE
	     unless it has been done already.  */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && gotent
	      && !gotent->reloc_xlated)
	    {
	      struct alpha_elf_got_entry *ent;

	      for (ent = gotent; ent; ent = ent->next)
		{
		  ent->reloc_xlated = 1;
		  if (ent->use_count == 0)
		    continue;
		  msec = sec;
		  ent->addend =
		    _bfd_merged_section_offset (output_bfd, &msec,
						elf_section_data (sec)->
						  sec_info,
						sym->st_value + ent->addend,
						(bfd_vma) 0);
		  ent->addend -= sym->st_value;
		  ent->addend += msec->output_section->vma
				 + msec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset;
		}
	    }

	  dynamic_symbol_p = FALSE;
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry *hh;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sec, value,
				   unresolved_reloc, warned);

	  if (warned)
	    continue;

	  if (value == 0
	      && ! unresolved_reloc
	      && hh->root.type == bfd_link_hash_undefweak)
	    undef_weak_ref = TRUE;

	  h = (struct alpha_elf_link_hash_entry *) hh;
          dynamic_symbol_p = alpha_elf_dynamic_symbol_p (&h->root, info);
	  gotent = h->got_entries;
	}

      addend = rel->r_addend;
      value += addend;

      /* Search for the proper got entry.  */
      for (; gotent ; gotent = gotent->next)
	if (gotent->gotobj == gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == addend)
	  break;

      switch (r_type)
	{
	case R_ALPHA_GPDISP:
	  {
	    bfd_byte *p_ldah, *p_lda;

	    BFD_ASSERT(gp != 0);

	    value = (input_section->output_section->vma
		     + input_section->output_offset
		     + rel->r_offset);

	    p_ldah = contents + rel->r_offset;
	    p_lda = p_ldah + rel->r_addend;

	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - value,
					     p_ldah, p_lda);
	  }
	  break;

	case R_ALPHA_LITERAL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 RELATIVE reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p && !undef_weak_ref)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, value);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_GPREL32:
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

	case R_ALPHA_GPREL16:
	case R_ALPHA_GPRELLOW:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(gp != 0);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_GPRELHIGH:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(gp != 0);
	  value -= gp;
	  value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_HINT:
	  /* A call to a dynamic symbol is definitely out of range of
	     the 16-bit displacement.  Don't bother writing anything.  */
	  if (dynamic_symbol_p)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;

	case R_ALPHA_BRADDR:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;

	case R_ALPHA_BRSGP:
	  {
	    int other;
	    const char *name;

	    /* The regular PC-relative stuff measures from the start of
	       the instruction rather than the end.  */
	    value -= 4;

	    /* The source and destination gp must be the same.  Note that
	       the source will always have an assigned gp, since we forced
	       one in check_relocs, but that the destination may not, as
	       it might not have had any relocations at all.  Also take
	       care not to crash if H is an undefined symbol.  */
	    if (h != NULL && sec != NULL
		&& alpha_elf_tdata (sec->owner)->gotobj
		&& gotobj != alpha_elf_tdata (sec->owner)->gotobj)
	      {
		(*_bfd_error_handler)
		  (_("%s: change in gp: BRSGP %s"),
		   bfd_archive_filename (input_bfd), h->root.root.root.string);
		ret_val = FALSE;
	      }

	    /* The symbol should be marked either NOPV or STD_GPLOAD.  */
	    if (h != NULL)
	      other = h->root.other;
	    else
	      other = sym->st_other;
	    switch (other & STO_ALPHA_STD_GPLOAD)
	      {
	      case STO_ALPHA_NOPV:
	        break;
	      case STO_ALPHA_STD_GPLOAD:
		value += 8;
		break;
	      default:
		if (h != NULL)
		  name = h->root.root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      name = _("<unknown>");
		    else if (name[0] == 0)
		      name = bfd_section_name (input_bfd, sec);
		  }
		(*_bfd_error_handler)
		  (_("%s: !samegp reloc against symbol without .prologue: %s"),
		   bfd_archive_filename (input_bfd), name);
		ret_val = FALSE;
		break;
	      }

	    goto default_reloc;
	  }

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	case R_ALPHA_DTPREL64:
	case R_ALPHA_TPREL64:
	  {
	    long dynindx, dyntype = r_type;
	    bfd_vma dynaddend;

	    /* Careful here to remember RELATIVE relocations for global
	       variables for symbolic shared objects.  */

	    if (dynamic_symbol_p)
	      {
		BFD_ASSERT(h->root.dynindx != -1);
		dynindx = h->root.dynindx;
		dynaddend = addend;
		addend = 0, value = 0;
	      }
	    else if (r_type == R_ALPHA_DTPREL64)
	      {
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		value -= dtp_base;
		goto default_reloc;
	      }
	    else if (r_type == R_ALPHA_TPREL64)
	      {
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		if (!info->shared)
		  {
		    value -= tp_base;
		    goto default_reloc;
		  }
		dynindx = 0;
		dynaddend = value - dtp_base;
	      }
	    else if (info->shared
		     && r_symndx != 0
		     && (input_section->flags & SEC_ALLOC)
		     && !undef_weak_ref)
	      {
		if (r_type == R_ALPHA_REFLONG)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unhandled dynamic relocation against %s"),
		       bfd_archive_filename (input_bfd),
		       h->root.root.root.string);
		    ret_val = FALSE;
		  }
		dynindx = 0;
		dyntype = R_ALPHA_RELATIVE;
		dynaddend = value;
	      }
	    else
	      goto default_reloc;

	    if (input_section->flags & SEC_ALLOC)
	      elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				       srel, rel->r_offset, dynindx,
				       dyntype, dynaddend);
	  }
	  goto default_reloc;

	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  else if ((info->shared || info->pie) && undef_weak_ref)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against undefined weak symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }


	  /* ??? .eh_frame references to discarded sections will be smashed
	     to relocations against SHN_UNDEF.  The .eh_frame format allows
	     NULL to be encoded as 0 in any format, so this works here.  */
	  if (r_symndx == 0)
	    howto = (elf64_alpha_howto_table
		     + (r_type - R_ALPHA_SREL32 + R_ALPHA_REFLONG));
	  goto default_reloc;

	case R_ALPHA_TLSLDM:
	  /* Ignore the symbol for the relocation.  The result is always
	     the current module.  */
	  dynamic_symbol_p = 0;
	  /* FALLTHRU */

	case R_ALPHA_TLSGD:
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      /* Note that the module index for the main program is 1.  */
	      bfd_put_64 (output_bfd, !info->shared && !dynamic_symbol_p,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 DTPMOD64 reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_DTPMOD64, 0);

	      if (dynamic_symbol_p || r_type == R_ALPHA_TLSLDM)
		value = 0;
	      else
		{
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	          value -= dtp_base;
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset + 8);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	case R_ALPHA_DTPRELHI:
	case R_ALPHA_DTPRELLO:
	case R_ALPHA_DTPREL16:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: dtp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	  value -= dtp_base;
	  if (r_type == R_ALPHA_DTPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_TPRELHI:
	case R_ALPHA_TPRELLO:
	case R_ALPHA_TPREL16:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: TLS local exec code cannot be linked into shared objects"),
		bfd_archive_filename (input_bfd));
              ret_val = FALSE;
	    }
	  else if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: tp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
	  value -= tp_base;
	  if (r_type == R_ALPHA_TPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      if (dynamic_symbol_p)
		value = 0;
	      else
		{
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
		  if (r_type == R_ALPHA_GOTDTPREL)
		    value -= dtp_base;
		  else if (!info->shared)
		    value -= tp_base;
		  else
		    {
		      elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					       gotent->got_offset, 0,
					       R_ALPHA_TPREL64,
					       value - dtp_base);
		      value = 0;
		    }
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;

	default:
	default_reloc:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset, value, 0);
	  break;
	}

      switch (r)
	{
	case bfd_reloc_ok:
	  break;

	case bfd_reloc_overflow:
	  {
	    const char *name;

	    /* Don't warn if the overflow is due to pc relative reloc
	       against discarded section.  Section optimization code should
	       handle it.  */

	    if (r_symndx < symtab_hdr->sh_info
		&& sec != NULL && howto->pc_relative
		&& elf_discarded_section (sec))
	      break;

	    if (h != NULL)
	      name = h->root.root.root.string;
	    else
	      {
		name = (bfd_elf_string_from_elf_section
			(input_bfd, symtab_hdr->sh_link, sym->st_name));
		if (name == NULL)
		  return FALSE;
		if (*name == '\0')
		  name = bfd_section_name (input_bfd, sec);
	      }
	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto->name, (bfd_vma) 0,
		    input_bfd, input_section, rel->r_offset)))
	      ret_val = FALSE;
	  }
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();
	}
    }

  return ret_val;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf64_alpha_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  bfd *dynobj = elf_hash_table(info)->dynobj;

  if (h->plt.offset != MINUS_ONE)
    {
      /* Fill in the .plt entry for this symbol.  */
      asection *splt, *sgot, *srel;
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      bfd_vma got_addr, plt_addr;
      bfd_vma plt_index;
      struct alpha_elf_got_entry *gotent;

      BFD_ASSERT (h->dynindx != -1);

      /* The first .got entry will be updated by the .plt with the
	 address of the target function.  */
      gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
      BFD_ASSERT (gotent && gotent->addend == 0);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL);
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (srel != NULL);
      sgot = alpha_elf_tdata (gotent->gotobj)->got;
      BFD_ASSERT (sgot != NULL);

      got_addr = (sgot->output_section->vma
		  + sgot->output_offset
		  + gotent->got_offset);
      plt_addr = (splt->output_section->vma
		  + splt->output_offset
		  + h->plt.offset);

      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;

      /* Fill in the entry in the procedure linkage table.  */
      {
	bfd_vma insn1, insn2, insn3;

	insn1 = PLT_ENTRY_WORD1 | ((-(h->plt.offset + 4) >> 2) & 0x1fffff);
	insn2 = PLT_ENTRY_WORD2;
	insn3 = PLT_ENTRY_WORD3;

	bfd_put_32 (output_bfd, insn1, splt->contents + h->plt.offset);
	bfd_put_32 (output_bfd, insn2, splt->contents + h->plt.offset + 4);
	bfd_put_32 (output_bfd, insn3, splt->contents + h->plt.offset + 8);
      }

      /* Fill in the entry in the .rela.plt section.  */
      outrel.r_offset = got_addr;
      outrel.r_info = ELF64_R_INFO(h->dynindx, R_ALPHA_JMP_SLOT);
      outrel.r_addend = 0;

      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

      if (!(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  /* Mark the symbol as undefined, rather than as defined in the
	     .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}

      /* Fill in the entries in the .got.  */
      bfd_put_64 (output_bfd, plt_addr, sgot->contents + gotent->got_offset);

      /* Subsequent .got entries will continue to bounce through the .plt.  */
      if (gotent->next)
	{
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (! info->shared || srel != NULL);

	  gotent = gotent->next;
	  do
	    {
	      sgot = alpha_elf_tdata(gotent->gotobj)->got;
	      BFD_ASSERT(sgot != NULL);
	      BFD_ASSERT(gotent->addend == 0);

	      bfd_put_64 (output_bfd, plt_addr,
		          sgot->contents + gotent->got_offset);

	      if (info->shared)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, plt_addr);

	      gotent = gotent->next;
	    }
          while (gotent != NULL);
	}
    }
  else if (alpha_elf_dynamic_symbol_p (h, info))
    {
      /* Fill in the dynamic relocations for this symbol's .got entries.  */
      asection *srel;
      struct alpha_elf_got_entry *gotent;

      srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);

      for (gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
	   gotent != NULL;
	   gotent = gotent->next)
	{
	  asection *sgot;
	  long r_type;

	  if (gotent->use_count == 0)
	    continue;

	  sgot = alpha_elf_tdata (gotent->gotobj)->got;

	  r_type = gotent->reloc_type;
	  switch (r_type)
	    {
	    case R_ALPHA_LITERAL:
	      r_type = R_ALPHA_GLOB_DAT;
	      break;
	    case R_ALPHA_TLSGD:
	      r_type = R_ALPHA_DTPMOD64;
	      break;
	    case R_ALPHA_GOTDTPREL:
	      r_type = R_ALPHA_DTPREL64;
	      break;
	    case R_ALPHA_GOTTPREL:
	      r_type = R_ALPHA_TPREL64;
	      break;
	    case R_ALPHA_TLSLDM:
	    default:
	      abort ();
	    }

	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				   gotent->got_offset, h->dynindx,
				   r_type, gotent->addend);

	  if (gotent->reloc_type == R_ALPHA_TLSGD)
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				     gotent->got_offset + 8, h->dynindx,
				     R_ALPHA_DTPREL64, gotent->addend);
	}
    }

  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf64_alpha_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf64_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    case DT_PLTGOT:
	      name = ".plt";
	      goto get_vma;
	    case DT_PLTRELSZ:
	      name = ".rela.plt";
	      goto get_size;
	    case DT_JMPREL:
	      name = ".rela.plt";
	      goto get_vma;

	    case DT_RELASZ:
	      /* My interpretation of the TIS v1.1 ELF document indicates
		 that RELASZ should not include JMPREL.  This is not what
		 the rest of the BFD does.  It is, however, what the
		 glibc ld.so wants.  Do this fixup here until we found
		 out who is right.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s)
		{
		  dyn.d_un.d_val -=
		    (s->_cooked_size ? s->_cooked_size : s->_raw_size);
		}
	      break;

	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      dyn.d_un.d_ptr = (s ? s->vma : 0);
	      break;

	    get_size:
	      s = bfd_get_section_by_name (output_bfd, name);
	      dyn.d_un.d_val =
		(s->_cooked_size ? s->_cooked_size : s->_raw_size);
	      break;
	    }

	  bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	}

      /* Initialize the PLT0 entry.  */
      if (splt->_raw_size > 0)
	{
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD1, splt->contents);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD2, splt->contents + 4);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD3, splt->contents + 8);
	  bfd_put_32 (output_bfd, PLT_HEADER_WORD4, splt->contents + 12);

	  /* The next two words will be filled in by ld.so */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 16);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 24);

	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 0;
	}
    }

  return TRUE;
}

/* We need to use a special link routine to handle the .mdebug section.
   We need to merge all instances of these sections together, not write
   them all out sequentially.  */

static bfd_boolean
elf64_alpha_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *o;
  struct bfd_link_order *p;
  asection *mdebug_sec;
  struct ecoff_debug_info debug;
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  PTR mdebug_handle = NULL;

  /* Go through the sections and collect the mdebug information.  */
  mdebug_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == (PTR) NULL)
	    return FALSE;

	  if (1)
	    {
	      asection *s;
	      EXTR esym;
	      bfd_vma last = 0;
	      unsigned int i;
	      static const char * const name[] =
		{
		  ".text", ".init", ".fini", ".data",
		  ".rodata", ".sdata", ".sbss", ".bss"
		};
	      static const int sc[] = { scText, scInit, scFini, scData,
					  scRData, scSData, scSBss, scBss };

	      esym.jmptbl = 0;
	      esym.cobol_main = 0;
	      esym.weakext = 0;
	      esym.reserved = 0;
	      esym.ifd = ifdNil;
	      esym.asym.iss = issNil;
	      esym.asym.st = stLocal;
	      esym.asym.reserved = 0;
	      esym.asym.index = indexNil;
	      for (i = 0; i < 8; i++)
		{
		  esym.asym.sc = sc[i];
		  s = bfd_get_section_by_name (abfd, name[i]);
		  if (s != NULL)
		    {
		      esym.asym.value = s->vma;
		      last = s->vma + s->_raw_size;
		    }
		  else
		    esym.asym.value = last;

		  if (! bfd_ecoff_debug_one_external (abfd, &debug, swap,
						      name[i], &esym))
		    return FALSE;
		}
	    }

	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
		{
		  /* I don't know what a non ALPHA ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->_raw_size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (!elf64_alpha_read_ecoff_info (input_bfd, input_section,
						&input_debug))
		return FALSE;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return FALSE;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct alpha_elf_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = alpha_elf_link_hash_lookup (alpha_elf_hash_table (info),
						  name, FALSE, FALSE, TRUE);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = FALSE;
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf64_alpha_output_extsym,
				  (PTR) &einfo);
	  if (einfo.failed)
	    return FALSE;

	  /* Set the size of the .mdebug section.  */
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  mdebug_sec = o;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (! bfd_elf_final_link (abfd, info))
    return FALSE;

  /* Now write out the computed sections.  */

  /* The .got subsections...  */
  {
    bfd *i, *dynobj = elf_hash_table(info)->dynobj;
    for (i = alpha_elf_hash_table(info)->got_list;
	 i != NULL;
	 i = alpha_elf_tdata(i)->got_link_next)
      {
	asection *sgot;

	/* elf_bfd_final_link already did everything in dynobj.  */
	if (i == dynobj)
	  continue;

	sgot = alpha_elf_tdata(i)->got;
	if (! bfd_set_section_contents (abfd, sgot->output_section,
					sgot->contents,
					(file_ptr) sgot->output_offset,
					sgot->_raw_size))
	  return FALSE;
      }
  }

  if (mdebug_sec != (asection *) NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return FALSE;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }

  return TRUE;
}

static enum elf_reloc_type_class
elf64_alpha_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_ALPHA_RELATIVE:
      return reloc_class_relative;
    case R_ALPHA_JMP_SLOT:
      return reloc_class_plt;
    case R_ALPHA_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static struct bfd_elf_special_section const elf64_alpha_special_sections[]=
{
  { ".sdata", 6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,     0,  0, 0,            0 }
};

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  Copied
   from elf32-mips.c.  */
static const struct ecoff_debug_swap
elf64_alpha_ecoff_debug_swap =
{
  /* Symbol table magic number.  */
  magicSym2,
  /* Alignment of debugging information.  E.g., 4.  */
  8,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  elf64_alpha_read_ecoff_info
};

/* Use a non-standard hash bucket size of 8.  */

static const struct elf_size_info alpha_elf_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,
  1,
  64, 3,
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
};

#define TARGET_LITTLE_SYM	bfd_elf64_alpha_vec
#define TARGET_LITTLE_NAME	"elf64-alpha"
#define ELF_ARCH		bfd_arch_alpha
#define ELF_MACHINE_CODE	EM_ALPHA
#define ELF_MAXPAGESIZE	0x10000

#define bfd_elf64_bfd_link_hash_table_create \
  elf64_alpha_bfd_link_hash_table_create

#define bfd_elf64_bfd_reloc_type_lookup \
  elf64_alpha_bfd_reloc_type_lookup
#define elf_info_to_howto \
  elf64_alpha_info_to_howto

#define bfd_elf64_mkobject \
  elf64_alpha_mkobject
#define elf_backend_object_p \
  elf64_alpha_object_p

#define elf_backend_section_from_shdr \
  elf64_alpha_section_from_shdr
#define elf_backend_section_flags \
  elf64_alpha_section_flags
#define elf_backend_fake_sections \
  elf64_alpha_fake_sections

#define bfd_elf64_bfd_is_local_label_name \
  elf64_alpha_is_local_label_name
#define bfd_elf64_find_nearest_line \
  elf64_alpha_find_nearest_line
#define bfd_elf64_bfd_relax_section \
  elf64_alpha_relax_section

#define elf_backend_add_symbol_hook \
  elf64_alpha_add_symbol_hook
#define elf_backend_check_relocs \
  elf64_alpha_check_relocs
#define elf_backend_create_dynamic_sections \
  elf64_alpha_create_dynamic_sections
#define elf_backend_adjust_dynamic_symbol \
  elf64_alpha_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
  elf64_alpha_always_size_sections
#define elf_backend_size_dynamic_sections \
  elf64_alpha_size_dynamic_sections
#define elf_backend_relocate_section \
  elf64_alpha_relocate_section
#define elf_backend_finish_dynamic_symbol \
  elf64_alpha_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
  elf64_alpha_finish_dynamic_sections
#define bfd_elf64_bfd_final_link \
  elf64_alpha_final_link
#define elf_backend_reloc_type_class \
  elf64_alpha_reloc_type_class

#define elf_backend_ecoff_debug_swap \
  &elf64_alpha_ecoff_debug_swap

#define elf_backend_size_info \
  alpha_elf_size_info

#define elf_backend_special_sections \
  elf64_alpha_special_sections

/* A few constants that determine how the .plt section is set up.  */
#define elf_backend_want_got_plt 0
#define elf_backend_plt_readonly 0
#define elf_backend_want_plt_sym 1
#define elf_backend_got_header_size 0

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static void
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#undef  elf64_bed
#define elf64_bed elf64_alpha_fbsd_bed

#include "elf64-target.h"
@


1.8
log
@Backport the code from binutils 2.16 that makes weak undefined references
work on alpha.

tested by naddy@@, deraadt@@
@
text
@d4059 1
a4059 1
      if (info->executable)
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1303 1
a1303 3
	  insn_disp = insn & 0x0000ffff;
	  if (insn_disp & 0x8000)
	    insn_disp |= ~0xffff;  /* Negative: sign-extend.  */
d1372 13
d1488 2
d1491 2
a1492 2

  return TRUE;
d1599 19
a1617 1
    disp = symval - info->gp;
d1626 15
a1645 6
  /* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading
     a constant, so force the base register to be $31.  */
  if (r_type == R_ALPHA_LITERAL)
    insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  else
    insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
a1659 16
  switch (r_type)
    {
    case R_ALPHA_LITERAL:
      r_type = R_ALPHA_GPREL16;
      break;
    case R_ALPHA_GOTDTPREL:
      r_type = R_ALPHA_DTPREL16;
      break;
    case R_ALPHA_GOTTPREL:
      r_type = R_ALPHA_TPREL16;
      break;
    default:
      BFD_ASSERT (0);
      return FALSE;
    }

d1996 2
a1997 1
      || (sec->flags & SEC_RELOC) == 0
d2141 1
a2141 2
	  if (h->root.root.type == bfd_link_hash_undefweak
	      || h->root.root.type == bfd_link_hash_undefined)
d2144 8
a2151 3
	  /* If the symbol isn't defined in the current module, again
	     we can't do anything.  */
	  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3002 9
d3096 1
a3096 1
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
d3233 1
a3233 2
		  rent->reltext = ((sec->flags & (SEC_READONLY | SEC_ALLOC))
				   == (SEC_READONLY | SEC_ALLOC));
d3246 1
a3246 2
	      if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		  == (SEC_READONLY | SEC_ALLOC))
d3915 1
d3917 5
a3921 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d4012 1
d4014 5
a4018 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
a4294 1
  const char *section_name;
d4314 12
a4325 6
  section_name = (bfd_elf_string_from_elf_section
		  (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		   elf_section_data(input_section)->rel_hdr.sh_name));
  BFD_ASSERT(section_name != NULL);
  srel = bfd_get_section_by_name (dynobj, section_name);

d4519 1
a4519 1
	      if (info->shared && !dynamic_symbol_p)
d4691 2
a4692 1
		     && (input_section->flags & SEC_ALLOC))
d4709 4
a4712 3
	    elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				     srel, rel->r_offset, dynindx,
				     dyntype, dynaddend);
d4726 8
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d50 1
a50 1
static int alpha_elf_dynamic_symbol_p
d126 1
a126 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d272 4
a275 1
/* Should we do dynamic things to this symbol?  */
d277 1
a277 1
static int
d282 1
a282 36
  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return TRUE;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_DEFAULT:
      break;
    case STV_HIDDEN:
    case STV_INTERNAL:
      return FALSE;
    case STV_PROTECTED:
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
        return FALSE;
      break;
    }

  if ((info->shared && !info->symbolic)
      || ((h->elf_link_hash_flags
	   & (ELF_LINK_HASH_DEF_DYNAMIC
	      | ELF_LINK_HASH_DEF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR))
	  == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))
    return TRUE;

  return FALSE;
a395 9
  /* Allocate our special target data.  */
  struct alpha_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;

d1152 2
a1153 2
#define alpha_get_dtprel_base(tlss) \
  ((tlss)->start)
d1157 4
a1160 2
#define alpha_get_tprel_base(tlss) \
  ((tlss)->start - align_power ((bfd_vma) 16, (tlss)->align))
a1193 1
  struct elf_link_tls_segment *tls_segment;
a1218 2
static struct elf_link_tls_segment *elf64_alpha_relax_find_tls_segment
  PARAMS((struct alpha_relax_info *, struct elf_link_tls_segment *));
d1517 1
a1517 1
	  tsec_relocs = (_bfd_elf64_link_read_relocs
d1591 3
a1593 3
      BFD_ASSERT (info->tls_segment != NULL);
      dtp_base = alpha_get_dtprel_base (info->tls_segment);
      tp_base = alpha_get_tprel_base (info->tls_segment);
d1838 2
a1839 2
	BFD_ASSERT (info->tls_segment != NULL);
	tp_base = alpha_get_tprel_base (info->tls_segment);
a1953 47
static struct elf_link_tls_segment *
elf64_alpha_relax_find_tls_segment (info, seg)
     struct alpha_relax_info *info;
     struct elf_link_tls_segment *seg;
{
  bfd *output_bfd = info->sec->output_section->owner;
  asection *o;
  unsigned int align;
  bfd_vma base, end;

  for (o = output_bfd->sections; o ; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
        && (o->flags & SEC_LOAD) != 0)
      break;
  if (!o)
    return NULL;

  base = o->vma;
  align = 0;

  do
    {
      bfd_vma size;

      if (bfd_get_section_alignment (output_bfd, o) > align)
	align = bfd_get_section_alignment (output_bfd, o);

      size = o->_raw_size;
      if (size == 0 && (o->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *lo;
	  for (lo = o->link_order_head; lo ; lo = lo->next)
	    if (size < lo->offset + lo->size)
	      size = lo->offset + lo->size;
	}
      end = o->vma + size;
      o = o->next;
    }
  while (o && (o->flags & SEC_THREAD_LOCAL));

  seg->start = base;
  seg->size = end - base;
  seg->align = align;

  return seg;
}

a1966 1
  struct elf_link_tls_segment tls_segment;
d1971 1
a1971 1
  if (link_info->relocateable
d1985 1
a1985 1
  internal_relocs = (_bfd_elf64_link_read_relocs
a2023 5
  /* Compute the TLS segment information.  The version normally found in
     elf_hash_table (link_info)->tls_segment isn't built until final_link.
     ??? Probably should look into extracting this into a common function.  */
  info.tls_segment = elf64_alpha_relax_find_tls_segment (&info, &tls_segment);

d2077 1
a2077 1
	      symval = alpha_get_tprel_base (info.tls_segment);
d2366 1
a2366 1
     const Elf_Internal_Sym *sym;
d2373 1
a2373 1
      && !info->relocateable
d2407 7
a2413 2
  if (bfd_get_section_by_name (abfd, ".got"))
    return TRUE;
d2465 1
a2465 1
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d2509 1
a2509 1
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d2970 1
a2970 1
  if (info->relocateable)
d3019 1
a3019 1
		 && (!info->symbolic || info->allow_shlib_undefined))
d3550 1
d3559 2
a3560 2
	bfd_size_type *plge
	  = &alpha_elf_tdata (gotent->gotobj)->got->_raw_size;
d3562 9
d3575 1
a3575 1
  return TRUE;
d3644 1
a3644 1
	  /* We are assuming no merging has yet ocurred.  */
d3786 1
a3786 1
  if (info->relocateable)
d4013 1
a4013 1
      if (!info->shared)
d4097 1
a4097 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
d4099 1
a4099 1
      if (!info->shared)
a4243 1
  struct elf_link_tls_segment *tls_segment;
d4252 1
a4252 1
  if (info->relocateable)
d4297 1
a4297 2
  tls_segment = elf_hash_table (info)->tls_segment;
  if (tls_segment)
d4299 2
a4300 2
      dtp_base = alpha_get_dtprel_base (tls_segment);
      tp_base = alpha_get_tprel_base (tls_segment);
d4342 1
d4345 2
a4346 1
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
a4373 1
	      asection *msec;
d4399 9
a4407 1
	  h = alpha_elf_sym_hashes (input_bfd)[r_symndx - symtab_hdr->sh_info];
d4409 2
a4410 3
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d4412 3
a4414 20
	  value = 0;
	  if (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.root.u.def.section;

	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */

	      if (sec->output_section != NULL)
		value = (h->root.root.u.def.value
			 + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.root.type == bfd_link_hash_undefweak)
a4415 14
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->root.other)))))
		return FALSE;
	      continue;
	    }
d4417 1
d4623 1
a4623 1
		BFD_ASSERT(tls_segment != NULL);
d4629 1
a4629 1
		BFD_ASSERT(tls_segment != NULL);
d4709 1
a4709 1
		  BFD_ASSERT(tls_segment != NULL);
d4732 1
a4732 1
	  BFD_ASSERT(tls_segment != NULL);
d4755 1
a4755 1
	  BFD_ASSERT(tls_segment != NULL);
d4776 1
a4776 1
		  BFD_ASSERT(tls_segment != NULL);
d5338 1
a5338 1
  if (! bfd_elf64_bfd_final_link (abfd, info))
d5396 7
d5462 1
a5462 1
  64, 8,
d5541 3
a5548 1
#define elf_backend_plt_header_size PLT_HEADER_SIZE
@


1.5
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 1
a51 1
  PARAMS((struct elf_link_hash_entry *, struct bfd_link_info *));
d53 1
a53 1
  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d55 1
a55 1
  PARAMS((bfd *));
d58 1
a58 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 1
a60 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d62 1
a62 1
  PARAMS((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
d64 1
a64 1
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d67 1
a67 1
  PARAMS((bfd *, bfd_reloc_code_real_type));
d69 1
a69 1
  PARAMS((bfd *, arelent *, Elf64_Internal_Rela *));
d71 22
a92 20
static boolean elf64_alpha_mkobject
  PARAMS((bfd *));
static boolean elf64_alpha_object_p
  PARAMS((bfd *));
static boolean elf64_alpha_section_from_shdr
  PARAMS((bfd *, Elf64_Internal_Shdr *, char *));
static boolean elf64_alpha_fake_sections
  PARAMS((bfd *, Elf64_Internal_Shdr *, asection *));
static boolean elf64_alpha_create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_create_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));

static boolean elf64_alpha_read_ecoff_info
  PARAMS((bfd *, asection *, struct ecoff_debug_info *));
static boolean elf64_alpha_is_local_label_name
  PARAMS((bfd *, const char *));
static boolean elf64_alpha_find_nearest_line
  PARAMS((bfd *, asection *, asymbol **, bfd_vma, const char **,
	  const char **, unsigned int *));
d98 2
a99 2
static boolean elf64_alpha_output_extsym
  PARAMS((struct alpha_elf_link_hash_entry *, PTR));
d101 2
a102 2
static boolean elf64_alpha_can_merge_gots
  PARAMS((bfd *, bfd *));
d104 2
a105 2
  PARAMS((bfd *, bfd *));
static boolean elf64_alpha_calc_got_offsets_for_symbol
d107 9
a115 2
static void elf64_alpha_calc_got_offsets PARAMS ((struct bfd_link_info *));
static boolean elf64_alpha_size_got_sections
d117 7
a123 3
static boolean elf64_alpha_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_calc_dynrel_sizes
d125 1
a125 1
static boolean elf64_alpha_add_symbol_hook
d128 5
a132 2
static boolean elf64_alpha_check_relocs
  PARAMS((bfd *, struct bfd_link_info *, asection *sec,
d134 12
a145 6
static boolean elf64_alpha_adjust_dynamic_symbol
  PARAMS((struct bfd_link_info *, struct elf_link_hash_entry *));
static boolean elf64_alpha_size_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_relocate_section
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
d147 9
a155 9
static boolean elf64_alpha_finish_dynamic_symbol
  PARAMS((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	  Elf_Internal_Sym *));
static boolean elf64_alpha_finish_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_final_link
  PARAMS((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_merge_ind_symbols
  PARAMS((struct alpha_elf_link_hash_entry *, PTR));
d158 2
d171 14
a184 5
  /* Contexts (LITUSE) in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR 0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM  0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE 0x04
#define ALPHA_ELF_LINK_HASH_LU_FUNC 0x08
d191 1
a191 1
    /* which .got subsection?  */
d194 1
a194 1
    /* the addend in effect for this entry.  */
d197 1
a197 1
    /* the .got offset for this entry.  */
d200 8
a207 1
    int flags;
d209 2
a210 2
    /* An additional flag.  */
#define ALPHA_ELF_GOT_ENTRY_RELOCS_DONE 0x10
d212 2
a213 1
    int use_count;
d216 1
a216 1
  /* used to count non-got, non-plt relocations for delayed sizing
d222 1
a222 1
    /* which .reloc section? */
d225 5
a229 2
    /* what kind of relocation? */
    unsigned long rtype;
d231 1
a231 1
    /* how many did we find?  */
d259 1
a259 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d280 1
a280 1
    return false;
d287 1
a287 1
    return false;
d291 1
a291 1
    return true;
d299 1
a299 1
      return false;
d302 1
a302 1
        return false;
d308 3
a310 1
	   & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))
d312 1
a312 1
    return true;
d314 1
a314 1
  return false;
d363 1
d365 1
a365 2
  ret = ((struct alpha_elf_link_hash_table *)
	 bfd_zalloc (abfd, sizeof (struct alpha_elf_link_hash_table)));
d372 1
a372 1
      bfd_release (abfd, ret);
d402 2
a403 2
  /* For every got, this is it's total number of *entries*.  */
  int total_got_entries;
d405 1
a405 1
  /* For every got, this is the sum of the number of *entries* required
d407 1
a407 1
  int n_local_got_entries;
d413 1
a413 1
static boolean
d417 2
a418 1
  abfd->tdata.any = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
d420 2
a421 2
    return false;
  return true;
d424 1
a424 1
static boolean
d430 2
a431 1
  new_tdata = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
d433 1
a433 1
    return false;
d445 3
d454 1
a454 1
	 true,			/* pc_relative */
d459 1
a459 1
	 false,			/* partial_inplace */
d462 1
a462 1
	 true),			/* pcrel_offset */
d469 1
a469 1
	 false,			/* pc_relative */
d474 1
a474 1
	 false,			/* partial_inplace */
d477 1
a477 1
	 false),		/* pcrel_offset */
d484 1
a484 1
	 false,			/* pc_relative */
d489 1
a489 1
	 false,			/* partial_inplace */
d492 1
a492 1
	 false),		/* pcrel_offset */
d501 1
a501 1
	 false,			/* pc_relative */
d506 1
a506 1
	 false,			/* partial_inplace */
d509 1
a509 1
	 false),		/* pcrel_offset */
d514 1
a514 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d516 1
a516 1
	 false,			/* pc_relative */
d521 1
a521 1
	 false,			/* partial_inplace */
d524 1
a524 1
	 false),		/* pcrel_offset */
d535 1
a535 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d537 1
a537 1
	 false,			/* pc_relative */
d542 1
a542 1
	 false,			/* partial_inplace */
d545 1
a545 1
	 false),		/* pcrel_offset */
d567 1
a567 1
	 false,			/* pc_relative */
d572 1
a572 1
	 false,			/* partial_inplace */
d575 1
a575 1
	 true),			/* pcrel_offset */
d582 1
a582 1
	 true,			/* pc_relative */
d587 1
a587 1
	 false,			/* partial_inplace */
d590 1
a590 1
	 true),			/* pcrel_offset */
d595 1
a595 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d597 1
a597 1
	 true,			/* pc_relative */
d602 1
a602 1
	 false,			/* partial_inplace */
d605 1
a605 1
	 true),			/* pcrel_offset */
d612 1
a612 1
	 true,			/* pc_relative */
d617 1
a617 1
	 false,			/* partial_inplace */
d620 1
a620 1
	 true),			/* pcrel_offset */
d627 1
a627 1
	 true,			/* pc_relative */
d632 1
a632 1
	 false,			/* partial_inplace */
d635 1
a635 1
	 true),			/* pcrel_offset */
d642 1
a642 1
	 true,			/* pc_relative */
d647 1
a647 1
	 false,			/* partial_inplace */
d650 1
a650 68
	 true),			/* pcrel_offset */

  /* Push a value on the reloc evaluation stack.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PUSH,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PUSH",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* Store the value from the stack at the given address.  Store it in
     a bitfield of size r_size starting at bit position r_offset.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_STORE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_STORE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Subtract the reloc address from the value on the top of the
     relocation stack.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PSUB,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PSUB",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* Shift the value on the top of the relocation stack right by the
     given value.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PRSHIFT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "OP_PRSHIFT",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d652 6
a657 16
  /* Change the value of GP used by +r_addend until the next GPVALUE or the
     end of the input bfd.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_GPVALUE,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "GPVALUE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d662 1
a662 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d664 1
a664 1
	 false,			/* pc_relative */
d667 1
a667 1
	 elf64_alpha_reloc_bad, /* special_function */
d669 1
a669 1
	 false,			/* partial_inplace */
d672 1
a672 1
	 false),		/* pcrel_offset */
d677 1
a677 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d679 1
a679 1
	 false,			/* pc_relative */
d682 1
a682 1
	 elf64_alpha_reloc_bad, /* special_function */
d684 1
a684 1
	 false,			/* partial_inplace */
d687 1
a687 1
	 false),		/* pcrel_offset */
d690 1
a690 2
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_16,
d692 1
a692 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d694 1
a694 1
	 false,			/* pc_relative */
d698 2
a699 2
	 "IMMED_GP_16",		/* name */
	 false,			/* partial_inplace */
d702 1
a702 36
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement from the GP to the target; the
     low bits are supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_GP_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement to the starting address of the
     current section (the relocation target is ignored); the low bits are
     supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_SCN_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_SCN_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d704 5
a708 33
  /* The high bits of a 32-bit displacement from the previous br, bsr, jsr
     or jmp insn (as tagged by a BRADDR or HINT reloc) to the target; the
     low bits are supplied by subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_BR_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_BR_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of a displacement calculated in a previous HI32 reloc.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_LO32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_LO32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d720 1
a720 1
	 false,
d725 1
a725 1
	 false,
d728 1
a728 1
	 true),
d735 1
a735 1
	 false,
d740 1
a740 1
	 false,
d743 1
a743 1
	 true),
d750 1
a750 1
	 false,
d755 1
a755 1
	 false,
d758 1
a758 1
	 true),
d765 1
a765 1
	 false,
d770 1
a770 1
	 false,
d773 213
a985 1
	 true)
d1059 2
a1060 2
  bfd_put_32 (abfd, i_ldah, p_ldah);
  bfd_put_32 (abfd, i_lda, p_lda);
d1123 30
a1152 24
  {BFD_RELOC_NONE,		R_ALPHA_NONE},
  {BFD_RELOC_32,		R_ALPHA_REFLONG},
  {BFD_RELOC_64,		R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,		R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,		R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_ELF_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,	R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,	R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,	R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,		R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,		R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,		R_ALPHA_SREL64},

/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to process
   the explicit !<reloc>!sequence relocations, and are mapped into the normal
   relocations at the end of processing.  */
  {BFD_RELOC_ALPHA_USER_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_USER_LITUSE_BASE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_JSR,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_ALPHA_USER_GPRELHIGH,	R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_USER_GPRELLOW,	R_ALPHA_GPRELLOW},
d1179 1
a1179 1
     Elf64_Internal_Rela *dst;
d1187 13
d1221 3
a1223 1
#define INSN_UNOP	0x2fe00000
d1230 1
d1233 1
a1233 2
  boolean changed_contents;
  boolean changed_relocs;
d1238 1
d1240 2
d1245 1
a1245 5
static Elf_Internal_Rela * elf64_alpha_relax_with_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, Elf_Internal_Rela *irelend));

static boolean elf64_alpha_relax_without_lituse
a1247 1

d1250 12
a1261 2

static boolean elf64_alpha_relax_section
d1263 1
a1263 1
	  boolean *again));
d1273 2
a1274 1
      if (rel->r_offset == offset && ELF64_R_TYPE (rel->r_info) == type)
d1281 2
a1282 2
static Elf_Internal_Rela *
elf64_alpha_relax_with_lituse (info, symval, irel, irelend)
d1285 1
a1285 1
     Elf_Internal_Rela *irel, *irelend;
d1287 1
a1287 1
  Elf_Internal_Rela *urel;
d1290 4
a1293 4
  boolean fits16;
  boolean fits32;
  boolean lit_reused = false;
  boolean all_optimized = true;
d1301 3
a1303 3
	bfd_get_filename (info->abfd), info->sec->name,
	(unsigned long)irel->r_offset));
      return irel;
d1306 4
d1315 1
a1315 1
      if (urel->r_addend >= 0 && urel->r_addend <= 3)
d1332 2
a1333 1
	default: /* 0 = ADDRESS FORMAT */
d1336 1
a1336 1
	  all_optimized = false;
d1339 1
a1339 1
	case 1: /* MEM FORMAT */
d1346 2
a1347 2
	  if (insn_disp & 0x00008000)
	    insn_disp |= 0xffff0000;  /* Negative: sign-extend.  */
d1350 3
a1352 2
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x00008000 && xdisp < 0x00008000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000 && xdisp < 0x7fff8000);
d1360 1
a1360 1
					   R_ALPHA_GPRELLOW);
d1362 1
a1362 1
	      info->changed_relocs = true;
d1364 3
a1366 2
	      bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
	      info->changed_contents = true;
d1377 1
a1377 1
	      bfd_put_32 (info->abfd, lit_insn,
d1379 2
a1380 2
	      lit_reused = true;
	      info->changed_contents = true;
d1385 1
a1385 1
	      info->changed_relocs = true;
d1388 1
a1388 1
	    all_optimized = false;
d1391 1
a1391 1
	case 2: /* BYTE OFFSET FORMAT */
d1397 2
a1398 1
	  insn = (insn & ~0x001ff000) | ((symval & 7) << 13) | 0x1000;
d1402 1
a1402 1
	  info->changed_relocs = true;
d1404 3
a1406 2
	  bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
	  info->changed_contents = true;
d1409 3
a1411 1
	case 3: /* CALL FORMAT */
d1413 1
a1413 5
	    /* If not zero, place to jump without needing pv.  */
	    bfd_vma optdest = elf64_alpha_relax_opt_call (info, symval);
	    bfd_vma org = (info->sec->output_section->vma
			   + info->sec->output_offset
			   + urel->r_offset + 4);
d1416 5
d1422 1
d1440 1
a1440 1
		  all_optimized = false;
d1442 2
a1443 1
		bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
d1452 2
a1453 2
		info->changed_contents = true;
		info->changed_relocs = true;
d1456 1
a1456 1
	      all_optimized = false;
d1458 31
a1488 8
	    /* ??? If target gp == current gp we can eliminate the gp reload.
	       This does depend on every place a gp could be reloaded will
	       be, which currently happens for all code produced by gcc, but
	       not necessarily by hand-coded assembly, or if sibling calls
	       are enabled in gcc.

	       Perhaps conditionalize this on a flag being set in the target
	       object file's header, and have gcc set it?  */
d1498 7
a1504 4
      info->gotent->use_count -= 1;
      alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
      if (!info->h)
	alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;
d1507 2
a1508 2
	 reused.  We can eliminate it.
	 ??? For now, I don't want to deal with compacting the section,
d1513 1
a1513 1
	  info->changed_relocs = true;
d1515 3
a1517 2
	  bfd_put_32 (info->abfd, INSN_UNOP, info->contents + irel->r_offset);
	  info->changed_contents = true;
d1521 1
a1521 1
  return irel + count;
d1596 2
a1597 2
static boolean
elf64_alpha_relax_without_lituse (info, symval, irel)
d1601 1
d1611 1
d1613 24
a1636 4
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
	bfd_get_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset));
      return true;
a1638 5
  /* So we aren't told much.  Do what we can with the address load and
     fake the rest.  All of the optimizations here require that the
     offset from the GP fit in 16 bits.  */

  disp = symval - info->gp;
d1640 1
a1640 1
    return true;
d1642 8
a1649 9
  /* On the LITERAL instruction itself, consider exchanging
     `ldq R,X(gp)' for `lda R,Y(gp)'.  */

  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  bfd_put_32 (info->abfd, insn, info->contents + irel->r_offset);
  info->changed_contents = true;

  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), R_ALPHA_GPRELLOW);
  info->changed_relocs = true;
d1653 27
a1679 4
  info->gotent->use_count -= 1;
  alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
  if (!info->h)
    alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;
d1694 347
a2040 1
  return true;
d2043 1
a2043 1
static boolean
d2048 1
a2048 1
     boolean *again;
a2051 1
  Elf_Internal_Rela *free_relocs = NULL;
d2053 1
a2053 3
  bfd_byte *free_contents = NULL;
  Elf64_External_Sym *extsyms = NULL;
  Elf64_External_Sym *free_extsyms = NULL;
d2056 1
d2059 1
a2059 1
  *again = false;
d2064 1
a2064 1
    return true;
d2079 1
a2079 3
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
d2085 1
d2089 2
a2090 1
  /* Find the GP for this object.  */
d2095 17
a2111 8
      info.gp = _bfd_get_gp_value (info.gotobj);
      if (info.gp == 0)
	{
	  info.gp = (sgot->output_section->vma
		     + sgot->output_offset
		     + 0x8000);
	  _bfd_set_gp_value (info.gotobj, info.gp);
	}
d2114 5
a2121 1
      Elf_Internal_Sym isym;
d2123 2
d2126 10
a2135 2
      if (ELF64_R_TYPE (irel->r_info) != (int) R_ALPHA_LITERAL)
	continue;
d2137 5
a2141 11
      /* Get the section contents.  */
      if (info.contents == NULL)
	{
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    info.contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (info.contents == NULL)
		goto error_return;
	      free_contents = info.contents;
d2143 2
a2144 4
	      if (! bfd_get_section_contents (abfd, sec, info.contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
d2147 2
a2148 2
      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
d2150 5
a2154 3
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
	  else
d2156 6
a2161 8
	      extsyms = ((Elf64_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
a2163 1
	}
d2165 9
a2173 15
      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF64_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  bfd_elf64_swap_symbol_in (abfd,
				    extsyms + ELF64_R_SYM (irel->r_info),
				    &isym);
	  if (isym.st_shndx == SHN_UNDEF)
	    info.tsec = bfd_und_section_ptr;
	  else if (isym.st_shndx > 0 && isym.st_shndx < SHN_LORESERVE)
	    info.tsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  else if (isym.st_shndx == SHN_ABS)
	    info.tsec = bfd_abs_section_ptr;
	  else if (isym.st_shndx == SHN_COMMON)
	    info.tsec = bfd_com_section_ptr;
d2175 11
a2185 1
	    continue;	/* who knows.  */
d2188 8
a2195 3
	  info.other = isym.st_other;
	  gotent = local_got_entries[ELF64_R_SYM(irel->r_info)];
	  symval = isym.st_value;
d2202 1
a2202 1
	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
d2210 3
a2212 4
	  /* We can't do anthing with undefined or dynamic symbols.  */
	  if (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak
	      || alpha_elf_dynamic_symbol_p (&h->root, link_info))
d2215 17
a2232 2
	  info.gotent = gotent;
	  info.tsec = h->root.root.u.def.section;
d2234 1
a2234 2
	  gotent = h->got_entries;
	  symval = h->root.root.u.def.value;
d2238 5
a2242 2
      while (gotent->gotobj != info.gotobj || gotent->addend != irel->r_addend)
	gotent = gotent->next;
d2248 20
a2267 1
      BFD_ASSERT(info.gotent != NULL);
d2269 6
a2274 3
      /* If there exist LITUSE relocations immediately following, this
	 opens up all sorts of interesting optimizations, because we
	 now know every location that this address load is used.  */
d2276 4
a2279 4
      if (irel+1 < irelend && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	{
	  irel = elf64_alpha_relax_with_lituse (&info, symval, irel, irelend);
	  if (irel == NULL)
d2281 7
a2287 4
	}
      else
	{
	  if (!elf64_alpha_relax_without_lituse (&info, symval, irel))
d2289 1
d2293 6
a2298 2
  if (!elf64_alpha_size_got_sections (abfd, link_info))
    return false;
d2300 2
a2301 1
  if (info.changed_relocs)
d2303 7
a2309 5
      elf_section_data (sec)->relocs = internal_relocs;
    }
  else if (free_relocs != NULL)
    {
      free (free_relocs);
d2312 2
a2313 5
  if (info.changed_contents)
    {
      elf_section_data (sec)->this_hdr.contents = info.contents;
    }
  else if (free_contents != NULL)
d2315 2
a2316 2
      if (! link_info->keep_memory)
	free (free_contents);
d2324 1
a2324 1
  if (free_extsyms != NULL)
d2326 2
a2327 2
      if (! link_info->keep_memory)
	free (free_extsyms);
d2329 1
a2329 4
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = extsyms;
	}
d2334 1
a2334 1
  return true;
d2337 10
a2346 7
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  return false;
d2351 4
a2354 4
#define PLT_HEADER_WORD1	0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	0x6b7b0000	/* jmp  $27,($27)   */
d2361 1
a2361 1
#define MAX_GOT_ENTRIES		(64*1024 / 8)
d2370 1
a2370 1
static boolean
d2373 2
a2374 2
     Elf64_Internal_Shdr *hdr;
     char *name;
d2387 1
a2387 7
	return false;
      break;
#ifdef ERIC_neverdef
    case SHT_ALPHA_REGINFO:
      if (strcmp (name, ".reginfo") != 0
	  || hdr->sh_size != sizeof (Elf64_External_RegInfo))
	return false;
a2388 1
#endif
d2390 1
a2390 1
      return false;
d2394 1
a2394 1
    return false;
d2402 1
a2402 1
	return false;
d2405 12
a2416 16
#ifdef ERIC_neverdef
  /* For a .reginfo section, set the gp value in the tdata information
     from the contents of this section.  We need the gp value while
     processing relocs, so we just get it now.  */
  if (hdr->sh_type == SHT_ALPHA_REGINFO)
    {
      Elf64_External_RegInfo ext;
      Elf64_RegInfo s;

      if (! bfd_get_section_contents (abfd, newsect, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
      bfd_alpha_elf64_swap_reginfo_in (abfd, &ext, &s);
      elf_gp (abfd) = s.ri_gp_value;
    }
#endif
d2418 1
a2418 1
  return true;
d2424 1
a2424 1
static boolean
d2427 1
a2427 1
     Elf64_Internal_Shdr *hdr;
d2444 2
a2445 25
#ifdef ERIC_neverdef
  else if (strcmp (name, ".reginfo") == 0)
    {
      hdr->sh_type = SHT_ALPHA_REGINFO;
      /* In a shared object on Irix 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if ((abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = sizeof (Elf64_External_RegInfo);
      else
	hdr->sh_entsize = 1;

      /* Force the section size to the correct value, even if the
	 linker thinks it is larger.  The link routine below will only
	 write out this much data for .reginfo.  */
      hdr->sh_size = sec->_raw_size = sizeof (Elf64_External_RegInfo);
    }
  else if (strcmp (name, ".hash") == 0
	   || strcmp (name, ".dynamic") == 0
	   || strcmp (name, ".dynstr") == 0)
    {
      hdr->sh_entsize = 0;
      hdr->sh_info = SIZEOF_ALPHA_DYNSYM_SECNAMES;
    }
#endif
  else if (strcmp (name, ".sdata") == 0
d2451 1
a2451 1
  return true;
d2457 1
a2457 1
static boolean
d2469 1
a2469 1
      && sym->st_size <= bfd_get_gp_size (abfd))
d2483 1
a2483 1
	    return false;
d2490 1
a2490 1
  return true;
d2495 1
a2495 1
static boolean
d2503 1
a2503 1
    return true;
d2512 1
a2512 1
    return false;
d2516 1
a2516 1
  return true;
d2521 1
a2521 1
static boolean
d2528 1
d2540 1
a2540 1
    return false;
d2544 1
a2544 1
  h = NULL;
d2547 4
a2550 4
	  (bfd_vma) 0, (const char *) NULL, false,
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
    return false;
d2556 1
a2556 1
    return false;
d2566 1
a2566 1
    return false;
d2572 1
a2572 1
    return false;
d2582 1
a2582 1
    return false;
d2588 1
a2588 1
  h = NULL;
d2592 3
a2594 3
	 false, get_elf_backend_data (abfd)->collect,
	 (struct bfd_link_hash_entry **) &h)))
    return false;
d2600 1
a2600 1
    return false;
d2604 1
a2604 1
  return true;
d2610 1
a2610 1
static boolean
d2623 1
a2623 1
  ext_hdr = (char *) bfd_malloc ((size_t) swap->external_hdr_size);
d2627 2
a2628 3
  if (bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				swap->external_hdr_size)
      == false)
d2641 2
a2642 1
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
d2646 1
a2646 2
	  || (bfd_read (debug->ptr, size, symhdr->count,		\
			abfd) != size * symhdr->count))			\
d2667 1
a2667 1
  return true;
d2694 1
a2694 1
  return false;
d2699 1
a2699 1
static boolean
d2718 1
a2718 1
static boolean
d2735 1
a2735 1
    return true;
d2759 1
d2761 1
a2761 2
	  fi = ((struct mips_elf_find_line *)
		bfd_zalloc (abfd, sizeof (struct mips_elf_find_line)));
d2765 1
a2765 1
	      return false;
d2771 1
a2771 1
	      return false;
d2775 2
a2776 4
	  fi->d.fdr = ((struct fdr *)
		       bfd_alloc (abfd,
				  (fi->d.symbolic_header.ifdMax *
				   sizeof (struct fdr))));
d2780 1
a2780 1
	      return false;
d2805 1
a2805 1
	  return true;
d2826 1
a2826 1
  boolean failed;
d2829 1
a2829 1
static boolean
d2835 1
a2835 1
  boolean strip;
d2838 3
d2842 1
a2842 1
    strip = false;
d2844 4
a2847 4
           || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
          && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
          && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = true;
d2849 5
a2853 5
          || (einfo->info->strip == strip_some
              && bfd_hash_lookup (einfo->info->keep_hash,
                                  h->root.root.root.string,
                                  false, false) == NULL))
    strip = true;
d2855 1
a2855 1
    strip = false;
d2858 1
a2858 1
    return true;
d2871 2
a2872 2
         && h->root.root.type != bfd_link_hash_defweak)
       h->esym.asym.sc = scAbs;
d2874 2
a2875 2
       {
         const char *name;
d2877 10
a2886 2
         sec = h->root.root.u.def.section;
         output_section = sec->output_section;
d2888 21
a2908 29
         /* When making a shared library and symbol h is the one from
            the another shared library, OUTPUT_SECTION may be null.  */
         if (output_section == NULL)
           h->esym.asym.sc = scUndefined;
         else
           {
             name = bfd_section_name (output_section->owner, output_section);

             if (strcmp (name, ".text") == 0)
               h->esym.asym.sc = scText;
             else if (strcmp (name, ".data") == 0)
               h->esym.asym.sc = scData;
             else if (strcmp (name, ".sdata") == 0)
               h->esym.asym.sc = scSData;
             else if (strcmp (name, ".rodata") == 0
                      || strcmp (name, ".rdata") == 0)
               h->esym.asym.sc = scRData;
             else if (strcmp (name, ".bss") == 0)
               h->esym.asym.sc = scBss;
             else if (strcmp (name, ".sbss") == 0)
               h->esym.asym.sc = scSBss;
             else if (strcmp (name, ".init") == 0)
               h->esym.asym.sc = scInit;
             else if (strcmp (name, ".fini") == 0)
               h->esym.asym.sc = scFini;
             else
               h->esym.asym.sc = scAbs;
           }
       }
d2920 1
a2920 1
       h->esym.asym.sc = scBss;
d2922 1
a2922 1
       h->esym.asym.sc = scSBss;
d2927 3
a2929 3
       h->esym.asym.value = (h->root.root.u.def.value
                             + sec->output_offset
                             + output_section->vma);
d2931 1
a2931 1
       h->esym.asym.value = 0;
a2949 3
#if 0 /* FIXME?  */
      h->esym.ifd = 0;
#endif
d2953 2
a2954 2
                                     h->root.root.root.string,
                                     &h->esym))
d2956 2
a2957 2
      einfo->failed = true;
      return false;
d2960 1
a2960 1
  return true;
d2962 12
d2975 66
a3040 1
/* FIXME:  Create a runtime procedure table from the .mdebug section.
a3041 9
static boolean
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
*/

d3044 1
a3044 1
static boolean
a3055 1
  struct alpha_elf_got_entry **local_got_entries;
d3057 2
a3058 1
  int got_created;
d3061 1
a3061 1
    return true;
d3071 1
a3071 2
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
  got_created = 0;
d3076 6
d3084 4
d3102 14
d3117 1
d3122 1
a3122 3
	  {
	    struct alpha_elf_got_entry *gotent;
	    int flags = 0;
d3124 12
a3135 7
	    if (h)
	      {
		/* Search for and possibly create a got entry.  */
		for (gotent = h->got_entries; gotent ; gotent = gotent->next)
		  if (gotent->gotobj == abfd &&
		      gotent->addend == rel->r_addend)
		    break;
d3137 8
a3144 13
		if (!gotent)
		  {
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
		    if (!gotent)
		      return false;

		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;
		    gotent->use_count = 1;
d3146 5
a3150 2
		    gotent->next = h->got_entries;
		    h->got_entries = gotent;
d3152 7
a3158 23
		    alpha_elf_tdata (abfd)->total_got_entries++;
		  }
		else
		  gotent->use_count += 1;
	      }
	    else
	      {
		/* This is a local .got entry -- record for merge.  */
		if (!local_got_entries)
		  {
		    size_t size;
		    size = (symtab_hdr->sh_info
			    * sizeof (struct alpha_elf_got_entry *));

		    local_got_entries = ((struct alpha_elf_got_entry **)
					 bfd_alloc (abfd, size));
		    if (!local_got_entries)
		      return false;

		    memset (local_got_entries, 0, size);
		    alpha_elf_tdata (abfd)->local_got_entries =
		      local_got_entries;
		  }
d3160 4
a3163 17
		for (gotent = local_got_entries[ELF64_R_SYM(rel->r_info)];
		     gotent != NULL && gotent->addend != rel->r_addend;
		     gotent = gotent->next)
		  continue;
		if (!gotent)
		  {
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
		    if (!gotent)
		      return false;

		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;
		    gotent->use_count = 1;
d3165 6
a3170 2
		    gotent->next = local_got_entries[ELF64_R_SYM(rel->r_info)];
		    local_got_entries[ELF64_R_SYM(rel->r_info)] = gotent;
d3172 7
a3178 6
		    alpha_elf_tdata(abfd)->total_got_entries++;
		    alpha_elf_tdata(abfd)->n_local_got_entries++;
		  }
		else
		  gotent->use_count += 1;
	      }
d3180 2
a3181 41
	    /* Remember how this literal is used from its LITUSEs.
	       This will be important when it comes to decide if we can
	       create a .plt entry for a function symbol.  */
	    if (rel+1 < relend
		&& ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE)
	      {
		do
		  {
		    ++rel;
		    if (rel->r_addend >= 1 && rel->r_addend <= 3)
		      flags |= 1 << rel->r_addend;
		  }
		while (rel+1 < relend &&
		       ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE);
	      }
	    else
	      {
		/* No LITUSEs -- presumably the address is not being
		   loaded for nothing.  */
		flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	      }

	    gotent->flags |= flags;
	    if (h)
	      {
		/* Make a guess as to whether a .plt entry will be needed.  */
		if ((h->flags |= flags) == ALPHA_ELF_LINK_HASH_LU_FUNC)
		  h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		else
		  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	      }
	  }
	  /* FALLTHRU */

	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL32:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  /* We don't actually use the .got here, but the sections must
	     be created before the linker maps input sections to output
	     sections.  */
d3185 1
a3185 1
		return false;
d3195 17
a3211 1
	  break;
d3213 9
a3221 6
	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (h == NULL)
	    break;
	  /* FALLTHRU */
d3223 2
a3224 2
	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
d3231 1
a3231 1
		return false;
d3247 2
d3250 4
d3255 1
a3255 7
		      || !bfd_set_section_flags (dynobj, sreloc,
						 ((sec->flags & (SEC_ALLOC
								 | SEC_LOAD))
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
d3257 1
a3257 1
		    return false;
d3277 2
a3278 3
		  rent = ((struct alpha_elf_reloc_entry *)
			  bfd_alloc (abfd,
				     sizeof (struct alpha_elf_reloc_entry)));
d3280 1
a3280 1
		    return false;
d3285 2
d3294 1
a3294 1
	  else if (info->shared && (sec->flags & SEC_ALLOC))
d3299 3
a3302 1
	  break;
d3306 1
a3306 1
  return true;
d3315 1
a3315 1
static boolean
d3330 1
a3330 2
  if (h->root.type != bfd_link_hash_undefweak
      && alpha_elf_dynamic_symbol_p (h, info)
d3334 2
a3335 1
	      && ah->flags == ALPHA_ELF_LINK_HASH_LU_FUNC))
d3346 1
a3346 1
	return false;
d3362 3
d3374 1
a3374 1
      return true;
d3388 1
a3388 1
      return true;
d3396 1
a3396 1
  return true;
d3403 1
a3403 1
static boolean
d3411 1
a3411 1
    return true;
d3435 7
a3441 2
	    if (gi->gotobj == gs->gotobj && gi->addend == gs->addend)
	      goto got_found;
d3462 1
a3462 1
	    if (ri->rtype == rs->rtype)
d3474 1
a3474 1
  return true;
d3479 1
a3479 1
static boolean
d3483 1
a3483 1
  int total = alpha_elf_tdata (a)->total_got_entries;
d3487 2
a3488 2
  if (total + alpha_elf_tdata (b)->total_got_entries <= MAX_GOT_ENTRIES)
    return true;
d3491 2
a3492 2
  if ((total += alpha_elf_tdata (b)->n_local_got_entries) > MAX_GOT_ENTRIES)
    return false;
d3522 3
a3524 1
	        if (ae->gotobj == a && ae->addend == be->addend)
d3527 3
a3529 2
	      if (++total > MAX_GOT_ENTRIES)
	        return false;
d3535 1
a3535 1
  return true;
d3544 1
a3544 1
  int total = alpha_elf_tdata (a)->total_got_entries;
d3549 1
a3549 1
    int e = alpha_elf_tdata (b)->n_local_got_entries;
d3551 1
a3551 1
    alpha_elf_tdata (a)->n_local_got_entries += e;
d3601 3
a3603 1
	        if (ae->gotobj == a && ae->addend == be->addend)
d3611 1
a3611 1
	      total += 1;
d3619 1
a3619 1
  alpha_elf_tdata (a)->total_got_entries = total;
d3635 1
a3635 1
static boolean
d3638 1
a3638 1
     PTR arg;
d3642 3
d3652 1
a3652 1
	*plge += 8;
d3655 1
a3655 1
  return true;
d3694 1
a3694 1
		  got_offset += 8;
d3705 2
a3706 3
static boolean
elf64_alpha_size_got_sections (output_bfd, info)
     bfd *output_bfd;
d3709 1
a3709 1
  bfd *i, *got_list, *cur_got_obj;
d3727 1
a3727 1
          if (alpha_elf_tdata (this_got)->total_got_entries > MAX_GOT_ENTRIES)
d3732 3
a3734 3
	         bfd_get_filename (i),
	         alpha_elf_tdata (this_got)->total_got_entries * 8);
	      return false;
d3746 1
a3746 1
	return true;
d3777 80
a3856 1
  return true;
d3859 1
a3859 1
static boolean
d3861 1
a3861 1
     bfd *output_bfd;
d3867 1
a3867 1
    return true;
d3874 2
a3875 2
  if (!elf64_alpha_size_got_sections (output_bfd, info))
    return false;
d3886 1
a3886 1
	    return false;
d3890 33
a3922 1
  return true;
d3927 1
a3927 1
static boolean
d3932 7
d3954 1
a3954 3
    {
      h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }
d3960 3
a3962 1
  if (alpha_elf_dynamic_symbol_p (&h->root, info) || info->shared)
d3964 13
a3976 5
      struct alpha_elf_reloc_entry *relent;
      bfd *dynobj;
      struct alpha_elf_got_entry *gotent;
      bfd_size_type count;
      asection *srel;
d3978 1
a3978 7
      for (relent = h->reloc_entries; relent; relent = relent->next)
	if (relent->rtype == R_ALPHA_REFLONG
	    || relent->rtype == R_ALPHA_REFQUAD)
	  {
	    relent->srel->_raw_size +=
	      sizeof (Elf64_External_Rela) * relent->count;
	  }
d3980 16
a3995 2
      dynobj = elf_hash_table(info)->dynobj;
      count = 0;
d3997 4
a4000 2
      for (gotent = h->got_entries; gotent ; gotent = gotent->next)
	count++;
d4002 3
a4004 4
      /* If we are using a .plt entry, subtract one, as the first
	 reference uses a .rela.plt entry instead.  */
      if (h->root.plt.offset != MINUS_ONE)
	count--;
d4006 6
a4011 5
      if (count > 0)
	{
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);
	  srel->_raw_size += sizeof (Elf64_External_Rela) * count;
d4015 59
a4073 1
  return true;
d4078 1
a4078 1
static boolean
d4080 1
a4080 1
     bfd *output_bfd;
d4085 1
a4085 2
  boolean reltext;
  boolean relplt;
d4106 1
a4106 10
				    elf64_alpha_calc_dynrel_sizes,
				    info);

      /* When building shared libraries, each local .got entry needs a
	 RELATIVE reloc.  */
      if (info->shared)
	{
	  bfd *i;
	  asection *srel;
	  bfd_size_type count;
d4108 1
a4108 10
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);

	  for (i = alpha_elf_hash_table(info)->got_list, count = 0;
	       i != NULL;
	       i = alpha_elf_tdata(i)->got_link_next)
	    count += alpha_elf_tdata(i)->n_local_got_entries;

	  srel->_raw_size += count * sizeof (Elf64_External_Rela);
	}
d4115 1
a4115 2
  reltext = false;
  relplt = false;
d4119 1
a4119 1
      boolean strip;
d4136 1
a4136 1
      strip = false;
a4143 13
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

d4145 1
a4145 1
		relplt = true;
d4163 1
a4163 1
	  s->contents = (bfd_byte *) bfd_zalloc(dynobj, s->_raw_size);
d4165 1
a4165 1
	    return false;
d4176 3
d4181 22
a4202 2
	  if (!bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
d4204 62
d4267 7
a4273 2
      if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0))
	return false;
d4275 2
a4276 1
      if (relplt)
d4278 6
a4283 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
	    return false;
d4286 6
a4291 5
      if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (Elf64_External_Rela)))
	return false;
d4293 1
a4293 1
      if (reltext)
d4295 6
a4300 3
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
d4304 1
a4304 1
  return true;
d4309 1
a4309 1
static boolean
d4324 2
a4325 1
  asection *sec, *sgot, *srel, *srelgot;
d4327 14
a4340 1
  bfd_vma gp;
a4341 1
  srelgot = srel = NULL;
d4343 1
d4346 9
a4354 3
    {
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
    }
a4356 2
  sgot = NULL;
  gp = 0;
d4370 16
a4386 1
  rel = relocs;
d4388 1
a4388 1
  for (; rel < relend; rel++)
d4390 3
a4392 1
      int r_type;
d4395 3
a4397 3
      struct alpha_elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      bfd_vma relocation;
d4399 3
a4401 1
      bfd_reloc_status_type r;
d4404 1
a4404 1
      if (r_type < 0 || r_type >= (int) R_ALPHA_max)
d4406 3
d4410 2
a4411 1
	  return false;
d4413 1
d4415 1
d4417 4
a4420 1
      r_symndx = ELF64_R_SYM(rel->r_info);
d4422 1
a4422 1
      if (info->relocateable)
d4424 20
a4443 9
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */

	  /* The symbol associated with GPDISP and LITUSE is
	     immaterial.  Only the addend is significant.  */
	  if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	    continue;
d4445 7
a4451 1
	  if (r_symndx < symtab_hdr->sh_info)
d4453 4
a4456 2
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
d4458 15
a4472 2
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
d4476 1
a4476 16
	  continue;
	}

      /* This is a final link.  */

      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
d4486 1
d4492 12
a4503 33
#if rth_notdef
	      if ((r_type == R_ALPHA_LITERAL
		   && elf_hash_table(info)->dynamic_sections_created
		   && (!info->shared
		       || !info->symbolic
		       || !(h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR)))
		  || (info->shared
		      && (!info->symbolic
			  || !(h->root.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR))
		      && (input_section->flags & SEC_ALLOC)
		      && (r_type == R_ALPHA_REFLONG
			  || r_type == R_ALPHA_REFQUAD
			  || r_type == R_ALPHA_LITERAL)))
		{
		  /* In these cases, we don't need the relocation value.
		     We check specially because in some obscure cases
		     sec->output_section will be NULL.  */
		  relocation = 0;
		}
#else
	      /* FIXME: Are not these obscure cases simply bugs?  Let's
		 get something working and come back to this.  */
	      if (sec->output_section == NULL)
		relocation = 0;
#endif /* rth_notdef */
	      else
		{
		  relocation = (h->root.root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		}
d4506 2
a4507 2
	    relocation = 0;
	  else if (info->shared && !info->symbolic
d4510 1
a4510 1
	    relocation = 0;
d4518 2
a4519 2
		return false;
	      relocation = 0;
d4521 3
d4525 1
d4527 8
d4544 3
a4546 38
	    relocation = (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->r_offset);

	    p_ldah = contents + rel->r_offset - input_section->vma;
	    p_lda = p_ldah + rel->r_addend;

	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - relocation,
					     p_ldah, p_lda);
	  }
	  break;

	case R_ALPHA_OP_PUSH:
	case R_ALPHA_OP_STORE:
	case R_ALPHA_OP_PSUB:
	case R_ALPHA_OP_PRSHIFT:
	  /* We hate these silly beasts.  */
	  abort ();

	case R_ALPHA_LITERAL:
	  {
	    struct alpha_elf_got_entry *gotent;
	    boolean dynamic_symbol;

	    BFD_ASSERT(sgot != NULL);
	    BFD_ASSERT(gp != 0);

	    if (h != NULL)
	      {
		gotent = h->got_entries;
		dynamic_symbol = alpha_elf_dynamic_symbol_p (&h->root, info);
	      }
	    else
	      {
		gotent = (alpha_elf_tdata(input_bfd)->
			  local_got_entries[r_symndx]);
		dynamic_symbol = false;
	      }
d4548 2
a4549 1
	    BFD_ASSERT(gotent != NULL);
d4551 4
a4554 2
	    while (gotent->gotobj != gotobj || gotent->addend != addend)
	      gotent = gotent->next;
d4556 5
a4560 1
	    BFD_ASSERT(gotent->use_count >= 1);
d4562 3
a4564 12
	    /* Initialize the .got entry's value.  */
	    if (!(gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_DONE))
	      {
		bfd_put_64 (output_bfd, relocation+addend,
			    sgot->contents + gotent->got_offset);

		/* If the symbol has been forced local, output a
		   RELATIVE reloc, otherwise it will be handled in
		   finish_dynamic_symbol.  */
		if (info->shared && !dynamic_symbol)
		  {
		    Elf_Internal_Rela outrel;
d4566 2
a4567 1
		    BFD_ASSERT(srelgot != NULL);
d4569 8
a4576 17
		    outrel.r_offset = (sgot->output_section->vma
				       + sgot->output_offset
				       + gotent->got_offset);
		    outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		    outrel.r_addend = 0;

		    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					       ((Elf64_External_Rela *)
					        srelgot->contents)
					       + srelgot->reloc_count++);
		    BFD_ASSERT (sizeof (Elf64_External_Rela)
				* srelgot->reloc_count
				<= srelgot->_cooked_size);
		  }

		gotent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_DONE;
	      }
d4578 4
a4581 8
	    /* Figure the gprel relocation.  */
	    addend = 0;
	    relocation = (sgot->output_section->vma
			  + sgot->output_offset
			  + gotent->got_offset);
	    relocation -= gp;
	  }
	  /* overflow handled by _bfd_final_link_relocate */
d4585 13
d4599 7
d4607 1
a4607 1
	  relocation -= gp;
d4611 7
d4619 15
a4633 5
	  relocation -= gp;
	  relocation += addend;
	  addend = 0;
	  relocation = (((bfd_signed_vma) relocation >> 16)
			+ ((relocation >> 15) & 1));
d4637 7
a4643 1
	case R_ALPHA_HINT:
d4646 1
a4646 1
	  addend -= 4;
d4649 58
d4709 2
d4712 2
a4713 2
	    Elf_Internal_Rela outrel;
	    boolean skip;
d4718 1
a4718 1
	    if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
d4721 20
a4740 3
		outrel.r_info = ELF64_R_INFO(h->root.dynindx, r_type);
		outrel.r_addend = addend;
		addend = 0, relocation = 0;
d4742 3
a4744 1
	    else if (info->shared && (input_section->flags & SEC_ALLOC))
d4746 11
a4756 2
		outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		outrel.r_addend = 0;
d4761 58
a4818 3
	    if (!srel)
	      {
		const char *name;
d4820 5
a4824 4
		name = (bfd_elf_string_from_elf_section
			(input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
			 elf_section_data(input_section)->rel_hdr.sh_name));
		BFD_ASSERT(name != NULL);
d4826 15
a4840 3
		srel = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT(srel != NULL);
	      }
d4842 22
a4863 1
	    skip = false;
d4865 6
a4870 5
	    if (elf_section_data (input_section)->stab_info == NULL)
	      outrel.r_offset = rel->r_offset;
	    else
	      {
		bfd_vma off;
d4872 3
a4874 9
		off = (_bfd_stab_section_offset
		       (output_bfd, &elf_hash_table (info)->stab_info,
			input_section,
			&elf_section_data (input_section)->stab_info,
			rel->r_offset));
		if (off == (bfd_vma) -1)
		  skip = true;
		outrel.r_offset = off;
	      }
d4876 21
a4896 5
	    if (! skip)
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
	    else
	      memset (&outrel, 0, sizeof outrel);
d4898 4
a4901 7
	    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				       ((Elf64_External_Rela *)
					srel->contents)
				       + srel->reloc_count++);
	    BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
			<= srel->_cooked_size);
	  }
d4907 1
a4907 2
					contents, rel->r_offset, relocation,
					addend);
d4920 9
d4936 1
a4936 1
		  return false;
d4943 1
a4943 1
	      return false;
d4953 1
a4953 1
  return true;
d4959 1
a4959 1
static boolean
d4973 1
d5003 1
a5003 1
	unsigned insn1, insn2, insn3;
d5019 2
a5020 3
      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				 ((Elf64_External_Rela *)srel->contents
				  + plt_index));
d5049 3
a5051 14
		{
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		  outrel.r_addend = 0;

		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srel->contents)
					     + srel->reloc_count++);
		  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
			      <= srel->_cooked_size);
		}
a5061 1
      Elf_Internal_Rela outrel;
a5066 1
      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_GLOB_DAT);
d5071 36
a5106 11
	  asection *sgot = alpha_elf_tdata (gotent->gotobj)->got;
	  outrel.r_offset = (sgot->output_section->vma
			     + sgot->output_offset
			     + gotent->got_offset);
	  outrel.r_addend = gotent->addend;

	  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				     ((Elf64_External_Rela *)srel->contents
				      + srel->reloc_count++));
	  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
		      <= srel->_cooked_size);
d5116 1
a5116 1
  return true;
d5121 1
a5121 1
static boolean
d5191 1
a5191 1
      /* Initialize the PLT0 entry */
d5200 2
a5201 2
	  bfd_put_64 (output_bfd, 0, splt->contents + 16);
	  bfd_put_64 (output_bfd, 0, splt->contents + 24);
d5203 1
a5203 2
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize =
	    PLT_HEADER_SIZE;
d5207 1
a5207 1
  return true;
d5210 3
a5212 3
/* We need to use a special link routine to handle the .reginfo and
   the .mdebug sections.  We need to merge all instances of these
   sections together, not write them all out sequentially.  */
d5214 1
a5214 1
static boolean
d5221 1
a5221 1
  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
d5228 1
a5228 12
#if 0
	      if (++ngots == 2)
		{
		  (*info->callbacks->warning)
		    (info, _("using multiple gp values"), (char *) NULL,
		     output_bfd, (asection *) NULL, (bfd_vma) 0);
		}
#endif

  /* Go through the sections and collect the .reginfo and .mdebug
     information.  */
  reginfo_sec = NULL;
a5229 2
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
a5231 66
#ifdef ERIC_neverdef
      if (strcmp (o->name, ".reginfo") == 0)
	{
	  memset (&reginfo, 0, sizeof reginfo);

	  /* We have found the .reginfo section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      Elf64_External_RegInfo ext;
	      Elf64_RegInfo sub;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* The linker emulation code has probably clobbered the
                 size to be zero bytes.  */
	      if (input_section->_raw_size == 0)
		input_section->_raw_size = sizeof (Elf64_External_RegInfo);

	      if (! bfd_get_section_contents (input_bfd, input_section,
					      (PTR) &ext,
					      (file_ptr) 0,
					      sizeof ext))
		return false;

	      bfd_alpha_elf64_swap_reginfo_in (input_bfd, &ext, &sub);

	      reginfo.ri_gprmask |= sub.ri_gprmask;
	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];

	      /* ri_gp_value is set by the function
		 alpha_elf_section_processing when the section is
		 finally written out.  */

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* Force the section size to the value we want.  */
	  o->_raw_size = sizeof (Elf64_External_RegInfo);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  reginfo_sec = o;
	}
#endif

d5271 1
a5271 1
	    return false;
d5277 1
a5277 1
	      bfd_vma last;
d5310 1
a5310 1
		    return false;
d5327 1
a5327 1
		  if (p->type == bfd_fill_link_order)
d5355 1
a5355 1
		return false;
d5360 1
a5360 1
		return false;
d5386 1
a5386 1
						  name, false, false, true);
a5417 25
#ifdef ERIC_neverdef
	  if (info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY);

		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 12))
		    return false;
		}

	      if (! alpha_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec, &debug))
		return false;
	    }
#endif

d5423 1
a5423 1
	  einfo.failed = false;
d5428 1
a5428 1
	    return false;
a5438 223

#ifdef ERIC_neverdef
      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
	{
	  const char *subname;
	  unsigned int c;
	  Elf64_gptab *tab;
	  Elf64_External_gptab *ext_tab;
	  unsigned int i;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocateable)
	    {
	      asection **secpp;

	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_fill_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &=~ SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->link_order_head = (struct bfd_link_order *) NULL;

	      /* Really remove the section.  */
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      *secpp = (*secpp)->next;
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_get_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  tab = (Elf64_gptab *) bfd_malloc (c * sizeof (Elf64_gptab));
	  if (tab == NULL)
	    return false;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = bfd_section_size (input_bfd, input_section);
	      last = 0;
	      for (gpentry = sizeof (Elf64_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf64_External_gptab))
		{
		  Elf64_External_gptab ext_gptab;
		  Elf64_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  gpentry, sizeof (Elf64_External_gptab))))
		    {
		      free (tab);
		      return false;
		    }

		  bfd_alpha_elf64_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = false;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = true;
		    }

		  if (! exact)
		    {
		      Elf64_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      new_tab = ((Elf64_gptab *)
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf64_gptab)));
		      if (new_tab == NULL)
			{
			  free (tab);
			  return false;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  ext_tab = ((Elf64_External_gptab *)
		     bfd_alloc (abfd, c * sizeof (Elf64_External_gptab)));
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return false;
	    }

	  for (i = 0; i < c; i++)
	    bfd_alpha_elf64_swap_gptab_out (abfd, tab + i, ext_tab + i);
	  free (tab);

	  o->_raw_size = c * sizeof (Elf64_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;
	}
#endif

d5443 1
a5443 1
    return false;
d5462 2
a5463 1
					sgot->contents, sgot->output_offset,
d5465 1
a5465 1
	  return false;
a5468 12
#ifdef ERIC_neverdef
  if (reginfo_sec != (asection *) NULL)
    {
      Elf64_External_RegInfo ext;

      bfd_alpha_elf64_swap_reginfo_out (abfd, &reginfo, &ext);
      if (! bfd_set_section_contents (abfd, reginfo_sec, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
    }
#endif

d5475 1
a5475 1
	return false;
d5480 2
a5481 8
  if (gptab_data_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
	return false;
    }
d5483 14
a5496 7
  if (gptab_bss_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
	return false;
a5497 2

  return true;
d5547 1
a5547 1
const struct elf_size_info alpha_elf_size_info =
d5564 1
d5570 4
a5573 4
  NULL,
  NULL,
  NULL,
  NULL
d5597 2
d5629 2
d5644 40
@


1.4
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1996, 97, 98, 1999 Free Software Foundation, Inc.
d38 1
a38 1
/* Get the ECOFF swapping routines.  Needed for the debug information. */
d50 2
a51 1
static boolean elf64_alpha_mkobject PARAMS ((bfd *));
d71 2
a135 1

d230 40
a269 8
#define alpha_elf_dynamic_symbol_p(h, info) 				\
  ((((info)->shared && !(info)->symbolic)				\
    || (((h)->elf_link_hash_flags					\
	 & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
        == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
    || (h)->root.type == bfd_link_hash_undefweak			\
    || (h)->root.type == bfd_link_hash_defweak)				\
   && (h)->dynindx != -1)
d569 1
a569 1
	 false),		/* pcrel_offset */
d584 1
a584 1
	 false),		/* pcrel_offset */
d599 1
a599 1
	 false),		/* pcrel_offset */
d749 1
a749 1
     current section (the relocation target is ignored); the low bits are 
d800 1
a800 1
  /* Misc ELF relocations. */
d870 1
a870 1
     bfd *abfd;
d872 2
a873 2
     asymbol *sym;
     PTR data;
d876 1
a876 1
     char **error_message;
d887 1
a887 1
     bfd *abfd;
d889 2
a890 2
     asymbol *sym;
     PTR data;
d893 1
a893 1
     char **error_message;
d950 1
a950 1
     asymbol *sym;
d1017 1
a1017 1
   relocations at the end of processing. */
d1031 1
a1031 1
     bfd *abfd;
d1049 1
a1049 1
     bfd *abfd;
d1060 1
a1060 1
/* These functions do relaxation for Alpha ELF. 
d1100 1
a1100 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
d1104 1
a1104 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
d1163 1
a1163 1
  /* A little preparation for the loop... */
a1164 2
  fits16 = (disp >= -(bfd_signed_vma)0x8000 && disp < 0x8000);
  fits32 = (disp >= -(bfd_signed_vma)0x80000000 && disp < 0x7fff8000);
d1169 3
d1184 12
d1198 1
a1198 4
	      /* FIXME: sanity check the insn for mem format with
		 zero addend.  */

	      /* Take the op code and dest from this insn, take the base 
d1200 1
a1200 1
	      insn = (insn & 0xffe00000) | (lit_insn & 0x001f0000);
d1213 1
a1213 2
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb, and
		 that mem_insn disp is zero.  */
d1262 1
a1262 1
		/* Preserve branch prediction call stack when possible. */
d1267 1
a1267 1
		  
d1281 1
a1281 1
			(info->relocs, info->relend, urel->r_offset, 
d1296 1
a1296 1
	       are enabled in gcc. 
d1342 1
a1342 1
  if (info->other == STO_ALPHA_NOPV)
d1346 2
a1347 2
     a normal ldgp in the first two words.  */ 
  else if (info->other == STO_ALPHA_STD_GPLOAD)
d1352 1
a1352 1
  else 
d1357 1
a1357 1
      /* Load the relocations from the section that the target symbol is in. */
d1379 1
a1379 1
  
d1394 1
a1394 1
  /* We've now determined that we can skip an initial gp load.  Verify 
d1455 1
a1455 1
     the calculated GP register would otherwise be ready. 
d1507 1
a1507 1
  memset(&info, 0, sizeof(info));
d1590 2
a1591 2
	  else 
	    continue;	/* who knows. */
d1851 2
a1852 2
     const char **namep;
     flagword *flagsp;
d1887 1
a1887 1
     struct bfd_link_info *info;
d2009 1
a2009 1
  memset (debug, 0, sizeof(*debug));
d2090 1
a2090 1
     bfd *abfd;
d2120 6
d2592 2
a2593 1
						 (SEC_ALLOC|SEC_LOAD
d2609 1
a2609 1
		 expand the relocation sections by the appropriate amount. */
d2742 1
a2742 1
     PTR dummy;
d2834 1
a2834 1
      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
d2906 1
a2906 1
      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
d3181 1
a3181 1
	      sizeof(Elf64_External_Rela) * relent->count;
d3256 1
a3256 1
	  srel->_raw_size += count * sizeof(Elf64_External_Rela);
d3359 1
a3359 1
					    sizeof(Elf64_External_Rela)))
d3366 1
d3449 1
a3449 1
	  /* The symbol associated with GPDISP and LITUSE is 
d3572 1
a3572 1
	  abort();
d3626 1
a3626 1
		    BFD_ASSERT (sizeof(Elf64_External_Rela)
d3731 1
a3731 1
	    BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
d3884 1
a3884 1
		  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
d3917 1
a3917 1
	  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
a4334 1

d4654 1
a4654 1
   from elf32-mips.c. */
d4697 30
d4730 2
a4731 2
#define ELF_MACHINE_CODE 	EM_ALPHA
#define ELF_MAXPAGESIZE 	0x10000
d4782 4
a4785 3
/*
 * A few constants that determine how the .plt section is set up.
 */
@


1.3
log
@Revert my bfd change, and instead make ld match bfd, which is
the way Red hat choose.  Both ways work, the important thing is that
things match.  However if we use the red hat solution we will not need
to merge local changes when importing new binutils releases; espie made
me aware of the import issues which I forgot due to lack of sleep :-).
@
text
@d3478 3
a3480 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d3487 2
a3488 1
		     (!info->shared || info->no_undefined))))
@


1.2
log
@1st bug on the road to shlibs on alpha:
match the maxpagesize between bfd and ld.
@
text
@d4647 1
a4647 1
#define ELF_MAXPAGESIZE 	0x100000
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* ALPHA-specific support for 64-bit ELF
   Copyright 1996 Free Software Foundation, Inc.
d49 1
d57 2
a62 8
static bfd_reloc_status_type elf64_alpha_reloc_op_push
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_reloc_op_store
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_reloc_op_psub
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type elf64_alpha_reloc_op_prshift
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a74 2
static int elf64_alpha_additional_program_headers
  PARAMS((bfd *));
d82 2
a83 2
static boolean elf64_alpha_is_local_label
  PARAMS((bfd *, asymbol *));
d95 16
a117 2
static boolean elf64_alpha_adjust_dynindx
  PARAMS((struct elf_link_hash_entry *, PTR));
d128 4
a133 3
#define alpha_elf_tdata(bfd) \
	((struct alpha_elf_obj_tdata *)elf_tdata(bfd)->tdata)

d141 3
a143 1
  unsigned char flags;
d145 42
a186 3
#define ALPHA_ELF_LINK_HASH_LU_ADDR 01
#define ALPHA_ELF_LINK_HASH_LU_MEM 02
#define ALPHA_ELF_LINK_HASH_LU_FUNC 04
d194 4
d220 16
d268 2
d298 22
d321 37
d434 1
a434 1
	 "LITERAL",		/* name */
d440 1
a440 1
  /* This reloc only appears immediately following a LITERAL reloc.
d469 1
a469 1
     NOTE: Unlike ECOFF, partial inplace relocation is not done.  If
d567 2
a568 1
  HOWTO (ALPHA_R_OP_PUSH,	/* type */
d575 1
a575 1
	 elf64_alpha_reloc_op_push, /* special_function */
d584 2
a585 1
  HOWTO (ALPHA_R_OP_STORE,	/* type */
d592 1
a592 1
	 elf64_alpha_reloc_op_store, /* special_function */
d601 2
a602 1
  HOWTO (ALPHA_R_OP_PSUB,	/* type */
d609 1
a609 1
	 elf64_alpha_reloc_op_psub, /* special_function */
d618 2
a619 1
  HOWTO (ALPHA_R_OP_PRSHIFT,	/* type */
d626 1
a626 1
	 elf64_alpha_reloc_op_prshift, /* special_function */
d633 132
d766 5
d782 1
a782 1
	 0, 
d785 1
d797 1
a797 1
	 0, 
d800 1
d815 1
d824 1
a824 1
	 "RELATIVE", 
d831 2
d848 19
d871 2
a872 1
     bfd_byte *p_ldah, *p_lda;
d878 2
a879 2
  i_ldah = bfd_get_32(abfd, p_ldah);
  i_lda = bfd_get_32(abfd, p_lda);
d893 2
a894 2
  if ((bfd_signed_vma)gpdisp < -(bfd_signed_vma)0x80000000
      || gpdisp >= 0x7fff8000)
d908 2
d936 1
a936 1
  /* The gp used in the portion of the output object to which this 
d944 1
a944 1
  p_ldah = (bfd_byte *)data + reloc_entry->address;
d951 1
a951 3
    {
      *err_msg = "GPDISP relocation did not find ldah and lda instructions";
    }
d956 7
a962 7
/* Due to the nature of the stack operations, I don't think more
   that one entry is useful.  Test this theory by setting the
   stack size to a minimum.  */
/* FIXME: BFD should not use static variables.  */
#define OP_STACK_SIZE 1
static bfd_vma elf64_alpha_op_stack[OP_STACK_SIZE];
static int elf64_alpha_op_tos;
d964 1
a964 10
static bfd_reloc_status_type
elf64_alpha_reloc_op_push (abfd, reloc_entry, sym, data, input_section,
			   output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
d966 25
a990 2
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma value;
d992 1
a992 6
  /* Don't do anything if we're not doing a final link.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d994 9
a1002 1
  if (elf64_alpha_op_tos >= OP_STACK_SIZE)
d1004 2
a1005 2
      *err_msg = "operation stack overflow";
      return bfd_reloc_dangerous;
d1007 2
d1010 1
a1010 11
  /* Get the symbol value.  */
  /* FIXME: We should fail if this is a dynamic symbol.  Check on that.  */
  if (bfd_is_und_section (sym->section))
    r = bfd_reloc_undefined;
  if (bfd_is_com_section (sym->section))
    value = 0;
  else
    value = sym->value;
  value += sym->section->output_section->vma;
  value += sym->section->output_offset;
  value += reloc_entry->addend;
d1012 7
a1018 1
  elf64_alpha_op_stack[elf64_alpha_op_tos++] = value;
d1020 3
a1022 1
  return r;
d1024 2
d1027 21
a1047 10
static bfd_reloc_status_type
elf64_alpha_reloc_op_store (abfd, reloc_entry, sym, data, input_section,
			    output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
d1049 14
a1062 2
  int size, offset;
  bfd_vma value;
d1064 22
a1085 8
  /* Don't do anything before the final link.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (elf64_alpha_op_tos <= 0)
d1087 3
a1089 2
      *err_msg = "operation stack underflow";
      return bfd_reloc_dangerous;
d1091 1
a1091 13

  /* The offset and size for this reloc are encoded into the addend
     field by alpha_adjust_reloc_in.  */
  offset = (reloc_entry->addend >> 8) & 0xff;
  size = reloc_entry->addend & 0xff;

  value = bfd_get_64 (abfd, data + reloc_entry->address);
  value &= ~((((bfd_vma)1 << size) - 1) << offset);
  value |= (elf64_alpha_op_stack[--elf64_alpha_op_tos] 
	    & (((bfd_vma)1 << size) - 1)) << offset;
  bfd_put_64 (abfd, value, data + reloc_entry->address);

  return bfd_reloc_ok;
d1094 5
a1098 10
static bfd_reloc_status_type
elf64_alpha_reloc_op_psub (abfd, reloc_entry, sym, data, input_section,
			   output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
d1100 8
a1107 2
  bfd_reloc_status_type r;
  bfd_vma value;
d1109 2
a1110 2
  /* Don't do anything before the final link.  */
  if (output_bfd)
d1112 5
a1116 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d1119 2
a1120 1
  if (elf64_alpha_op_tos <= 0)
d1122 4
a1125 2
      *err_msg = "operation stack underflow";
      return bfd_reloc_dangerous;
d1128 4
a1131 9
  if (bfd_is_und_section (sym->section))
    r = bfd_reloc_undefined;
  if (bfd_is_com_section (sym->section))
    value = 0;
  else
    value = sym->value;
  value += sym->section->output_section->vma;
  value += sym->section->output_offset;
  value += reloc_entry->addend;
d1133 4
a1136 1
  elf64_alpha_op_stack[elf64_alpha_op_tos-1] -= value;
d1138 147
a1284 1
  return r;
d1287 4
a1290 10
static bfd_reloc_status_type
elf64_alpha_reloc_op_prshift (abfd, reloc_entry, sym, data, input_section,
			      output_bfd, err_msg)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *sym;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **err_msg;
d1292 17
a1308 2
  /* Don't do anything before the final link.  */
  if (output_bfd)
d1310 38
a1347 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d1350 22
a1371 1
  if (elf64_alpha_op_tos <= 0)
d1373 5
a1377 2
      *err_msg = "operation stack underflow";
      return bfd_reloc_dangerous;
d1380 7
a1386 1
  elf64_alpha_op_stack[elf64_alpha_op_tos-1] >>= reloc_entry->addend;
d1388 2
a1389 2
  return bfd_reloc_ok;
}
d1391 21
a1411 1
/* A mapping from BFD reloc types to Alpha ELF reloc types.  */
d1413 1
a1413 5
struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  int elf_reloc_val;
};
d1415 2
a1416 22
static const struct elf_reloc_map elf64_alpha_reloc_map[] =
{
  {BFD_RELOC_NONE,		R_ALPHA_NONE},
  {BFD_RELOC_32,		R_ALPHA_REFLONG},
  {BFD_RELOC_64,		R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,		R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,		R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,	R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,	R_ALPHA_BRADDR},  
  {BFD_RELOC_ALPHA_HINT,	R_ALPHA_HINT},  
  {BFD_RELOC_16_PCREL,		R_ALPHA_SREL16},  
  {BFD_RELOC_32_PCREL,		R_ALPHA_SREL32},  
  {BFD_RELOC_64_PCREL,		R_ALPHA_SREL64},  
#if 0
  {BFD_RELOC_ALPHA_OP_PUSH,	R_ALPHA_OP_PUSH},
  {BFD_RELOC_ALPHA_OP_STORE,	R_ALPHA_OP_STORE},
  {BFD_RELOC_ALPHA_OP_PSUB,	R_ALPHA_OP_PSUB},
  {BFD_RELOC_ALPHA_OP_PRSHIFT,	R_ALPHA_OP_PRSHIFT}
#endif
};
d1418 2
a1419 1
/* Given a BFD reloc type, return a HOWTO structure.  */
d1421 2
a1422 2
static reloc_howto_type *
elf64_alpha_bfd_reloc_type_lookup (abfd, code)
d1424 3
a1426 1
     bfd_reloc_code_real_type code;
d1428 208
a1635 4
  const struct elf_reloc_map *i, *e;
  i = e = elf64_alpha_reloc_map;
  e += sizeof (elf64_alpha_reloc_map) / sizeof (struct elf_reloc_map);
  for (; i != e; ++i)
d1637 7
a1643 2
      if (i->bfd_reloc_val == code)
	return &elf64_alpha_howto_table[i->elf_reloc_val];
a1644 2
  return 0;
}
d1646 1
a1646 1
/* Given an Alpha ELF reloc type, fill in an arelent structure.  */
d1648 1
a1648 7
static void
elf64_alpha_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf64_Internal_Rela *dst;
{
  unsigned r_type;
d1650 8
a1657 3
  r_type = ELF64_R_TYPE(dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_ALPHA_max);
  cache_ptr->howto = &elf64_alpha_howto_table[r_type];
d1668 3
a1670 3
#define PLT_ENTRY_WORD1		0x279f0000	/* ldah $28, 0($31) */
#define PLT_ENTRY_WORD2		0x239c0000	/* lda  $28, 0($28) */
#define PLT_ENTRY_WORD3		0xc3e00000	/* br   $31, plt0   */
d1672 1
a1672 1
#define RESERVED_GOT_ENTRIES 1
d1676 1
a1676 10
/* Set the right machine number for an Alpha ELF file.  */

static boolean
elf64_alpha_object_p (abfd)
     bfd *abfd;
{
  return bfd_default_set_arch_mach (abfd, bfd_arch_alpha, 0);
}

/* Handle a alpha specific section when reading an object file.  This
d1678 1
a1678 1
   FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure
d1789 1
a1794 1
#endif
d1799 5
a1803 2
static int
elf64_alpha_additional_program_headers (abfd)
d1805 6
d1812 6
a1817 2
  asection *s;
  int ret;
d1819 1
a1819 1
  ret = 0;
d1821 9
a1829 6
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* We need a PT_ALPHA_REGINFO segment.  */
      ++ret;
    }
d1831 2
a1832 5
  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
    {
      /* We need a PT_ALPHA_RTPROC segment.  */
      ++ret;
d1835 1
a1835 1
  return ret;
d1838 2
a1845 1
  struct elf_link_hash_entry *h;
d1850 1
a1850 9
  s = bfd_make_section(abfd, ".rela.got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS | SEC_IN_MEMORY
					   | SEC_READONLY))
      || !bfd_set_section_alignment (abfd, s, 3))
    return false;

  s = bfd_make_section(abfd, ".got");
d1853 3
a1855 1
					   | SEC_HAS_CONTENTS | SEC_IN_MEMORY))
d1859 1
a1859 20
  s->_raw_size = RESERVED_GOT_ENTRIES * 8;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
     (or .got.plt) section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  h = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s, (bfd_vma) 0,
	 (const char *) NULL, false, get_elf_backend_data (abfd)->collect,
	 (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return false;

  elf_hash_table (info)->hgot = h;
d1864 2
d1871 1
a1871 1
  register asection *s;
d1879 3
a1881 1
					    | SEC_HAS_CONTENTS | SEC_IN_MEMORY
d1905 4
a1908 2
					  | SEC_HAS_CONTENTS | SEC_IN_MEMORY
					  | SEC_READONLY))
d1912 3
d1918 23
a1940 2
  return true;
}
d1942 3
a1944 2
/* The structure of the runtile procedure descriptor created by the
   loader for use by the static exception system.  */
d1946 4
a1949 1
/* FIXME */
d1965 1
d2045 1
a2045 1
elf64_alpha_is_local_label (abfd, symbol)
d2047 1
a2047 1
     asymbol *symbol;
d2049 1
a2049 1
  return symbol->name[0] == '$';
d2225 1
a2225 1
       
d2282 1
a2282 1
	    h->esym.asym.value = (h->root.plt_offset
d2291 1
a2291 1
    }      
d2313 3
a2315 1
 */
a2316 1

a2324 2
  asection *sgot;
  asection *srelgot;
d2326 1
d2328 2
a2329 1
  struct elf_link_hash_entry **sym_hashes;
d2331 1
d2336 6
a2341 1
  sgot = srelgot = sreloc = NULL;
d2343 3
a2345 7
  sym_hashes = elf_sym_hashes(abfd);
  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj)
    {
      sgot = bfd_get_section_by_name(dynobj, ".got");
      srelgot = bfd_get_section_by_name(dynobj, ".rela.got");
    }
d2350 1
a2350 1
      unsigned long r_symndx;
d2357 6
a2362 2
	h = ((struct alpha_elf_link_hash_entry *)
	     sym_hashes[r_symndx - symtab_hdr->sh_info]);
d2364 5
a2368 1
      switch (ELF64_R_TYPE (rel->r_info))
d2371 80
a2450 15
	  /* If this is a load of a function symbol and we are building a
	     shared library or calling a shared library, then we need a
	     .plt entry as well. 

	     We can tell if it is a function either by noticing the
	     type of the symbol, or, if the type is undefined, by
	     noticing that we have a LITUSE(3) reloc next.

	     Note that it is not fatal to be wrong guessing that a symbol
	     is an object, but it is fatal to be wrong guessing that a 
	     symbol is a function.

	     Furthermore, the .plt trampoline does not give constant 
	     function addresses, so if we ever see a function's address
	     taken, we cannot do lazy binding on that function. */
d2452 42
a2493 1
	  if (h)
d2495 8
a2502 15
	      if (rel+1 < relend
		  && ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE)
		{
		  switch (rel[1].r_addend)
		    {
		    case 1: /* Memory reference */
		      h->flags |= ALPHA_ELF_LINK_HASH_LU_MEM;
		      break;
		    case 3: /* Call reference */
		      h->flags |= ALPHA_ELF_LINK_HASH_LU_FUNC;
		      break;
		    }
		}
	      else
		h->flags |= ALPHA_ELF_LINK_HASH_LU_ADDR;
d2504 1
a2504 10
	      if (h->root.root.type != bfd_link_hash_undefweak
		  && (info->shared 
		      || !(h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR))
		  && (h->root.type == STT_FUNC
		      || (h->root.type == STT_NOTYPE
			  && (h->flags & ALPHA_ELF_LINK_HASH_LU_FUNC))))
		{
		  h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		}
d2506 1
d2508 10
a2517 1
	  if (dynobj == NULL)
d2519 4
a2522 4
	      elf_hash_table(info)->dynobj = dynobj = abfd;

	      /* Create the .got section.  */
	      if (!elf64_alpha_create_got_section(dynobj, info))
d2525 3
a2527 2
	      sgot = bfd_get_section_by_name(dynobj, ".got");
	      srelgot = bfd_get_section_by_name(dynobj, ".rela.got");
d2530 5
a2534 1
	  if (h != NULL)
d2536 2
a2537 1
	      if (h->root.got_offset != MINUS_ONE)
d2539 25
a2563 1
		  /* We have already allocated space in this .got.  */
d2565 15
d2581 72
d2654 160
a2813 4
	      /* Make sure this becomes a dynamic symbol.  */
	      if (h->root.dynindx == -1
		  && ! _bfd_elf_link_record_dynamic_symbol (info, &h->root))
		return false;
d2815 1
a2815 2
	      /* Reserve space for a reloc even if we won't use it.  */
	      srelgot->_raw_size += sizeof(Elf64_External_Rela);
d2817 6
a2822 1
	      /* Create the relocation in adjust_dynamic_symbol */
d2824 24
a2847 2
	      h->root.got_offset = sgot->_raw_size;
	      sgot->_raw_size += 8;
d2849 19
a2867 1
	  else
d2869 115
a2983 4
	      bfd_vma *lgotoff = elf_local_got_offsets(abfd);
	      if (lgotoff == NULL)
		{
		  size_t size;
d2985 1
a2985 4
		  size = elf_tdata(abfd)->symtab_hdr.sh_info * sizeof(bfd_vma);
		  lgotoff = (bfd_vma *)bfd_alloc(abfd, size);
		  if (lgotoff == NULL)
		    return false;
d2987 9
a2995 3
		  elf_local_got_offsets(abfd) = lgotoff;
		  memset(lgotoff, -1, size);
		}
d2997 2
a2998 7
	      if (lgotoff[ELF64_R_SYM(rel->r_info)] != MINUS_ONE)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      lgotoff[ELF64_R_SYM(rel->r_info)] = sgot->_raw_size;
	      sgot->_raw_size += 8;
d3000 8
a3007 7
	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
		     output a R_ALPHA_RELATIVE reloc so that the dynamic
		     linker can adjust this GOT entry.  */
		  srelgot->_raw_size += sizeof(Elf64_External_Rela);
		}
a3008 1
	  break;
d3010 10
a3019 6
	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (h == NULL)
	    break;
	  /* FALLTHRU */
d3021 1
a3021 19
	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (info->shared
	      || (h != NULL
		  && !(h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      /* When creating a shared object or referring to a symbol in
		 a shared object, we must copy these relocs into the
		 object file.  We create a reloc section in dynobj and
		 make room for the reloc.  */
	      if (sreloc == NULL)
		{
		  const char *name;
		  name = (bfd_elf_string_from_elf_section
			  (abfd, elf_elfheader(abfd)->e_shstrndx,
			   elf_section_data(sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
d3023 3
a3025 3
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name+5) == 0);
d3027 15
a3041 17
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section (dynobj, name);
		      if (sreloc == NULL
			  || !bfd_set_section_flags (dynobj, sreloc,
						     (SEC_ALLOC|SEC_LOAD
						      |SEC_HAS_CONTENTS
						      |SEC_IN_MEMORY
						      |SEC_READONLY))
			  || !bfd_set_section_alignment (dynobj, sreloc, 3))
			return false;
		    }
		}
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
	    }
	  break;
d3045 5
a3052 6
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

d3054 2
a3055 1
elf64_alpha_adjust_dynamic_symbol (info, h)
a3056 1
     struct elf_link_hash_entry *h;
d3058 12
a3069 4
  bfd *dynobj;
  asection *s;
  
  dynobj = elf_hash_table(info)->dynobj;
d3071 6
a3076 12
  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later, 
     though we could actually do it here.  */

  if (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
    {
      /* We hadn't seen all of the input symbols or all of the relocations
	 when we guessed that we needed a .plt entry.  Revise our decision.  */
      if ((!info->shared
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	  || (((struct alpha_elf_link_hash_entry *) h)->flags
	      & ALPHA_ELF_LINK_HASH_LU_ADDR))
d3078 3
a3080 2
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	  return true;
d3082 1
d3084 2
a3085 6
      s = bfd_get_section_by_name(dynobj, ".plt");
      BFD_ASSERT(s != NULL);

      /* The first bit of the .plt is reserved.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_HEADER_SIZE;
d3087 1
a3087 1
      h->plt_offset = s->_raw_size;
d3089 43
a3131 9
      /* If this symbol is not defined in a regular file, and we are not
	 generating a shared library, then set the symbol to the location
	 in the .plt.  This is required to make function pointers compare
	 equal between the normal executable and the shared library.  */
      if (!info->shared)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	}
d3133 2
a3134 1
      s->_raw_size += PLT_ENTRY_SIZE;
d3136 2
a3137 4
      /* We also need an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name(dynobj, ".rela.plt");
      BFD_ASSERT(s != NULL);
      s->_raw_size += sizeof(Elf64_External_Rela);
d3139 4
a3142 2
      return true;
    }
d3144 6
a3149 10
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
a3151 5
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  The Alpha, since it uses .got entries for
     symbols even in regular objects, does not need the hackery of a
     .dynbss section and COPY dynamic relocations.  */

d3170 1
a3170 1
  if (elf_hash_table(info)->dynamic_sections_created)
d3175 2
a3176 2
	  s = bfd_get_section_by_name(dynobj, ".interp");
	  BFD_ASSERT(s != NULL);
d3178 28
a3205 1
	  s->contents = (unsigned char *)ELF_DYNAMIC_INTERPRETER;
d3208 1
a3208 11
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rel.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
    }
d3220 1
a3220 1
      if (!(s->flags & SEC_IN_MEMORY))
d3225 1
a3225 1
      name = bfd_get_section_name(dynobj, s);
d3237 1
a3237 1
      if (strncmp(name, ".rela", 5) == 0)
d3243 1
d3248 3
a3250 1
	      target = bfd_get_section_by_name (output_bfd, name + 5);
d3252 2
a3253 1
		  && (target->flags & SEC_READONLY) != 0)
a3263 30
      else if (strcmp(name, ".got") == 0)
	{
	  /* If we are generating a shared library, we generate a
	     section symbol for each output section.  These are local
	     symbols, which means that they must come first in the
	     dynamic symbol table.  That means we must increment the
	     dynamic symbol index of every other dynamic symbol.  */
	  if (info->shared)
	    {
	      long c[2], i;
	      asection *p;

	      c[0] = 0;
	      c[1] = bfd_count_sections(output_bfd);

	      elf_link_hash_traverse (elf_hash_table(info),
				      elf64_alpha_adjust_dynindx,
				      (PTR)c);
	      elf_hash_table (info)->dynsymcount += c[1];

	      for (i = 1, p = output_bfd->sections;
		   p != NULL;
		   p = p->next, i++)
		{
		  elf_section_data (p)->dynindx = i;
		  /* These symbols will have no names, so we don't need to
		     fiddle with dynstr_index.  */
		}
	    }
	}
d3266 1
a3266 1
	  /* It's not one of our sections, so don't allocate space.  */
d3271 2
d3274 4
a3277 10
	  asection **spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    continue;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

	  continue;
a3278 5

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc(dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return false;
a3320 16
/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
elf64_alpha_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  long *cp = (long *)cparg;

  if (h->dynindx >= cp[0])
    h->dynindx += cp[1];

  return true;
}

d3338 2
a3339 2
  asection *sec, *sgot, *splt;
  bfd *dynobj;
d3342 7
a3348 1
  symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
d3353 2
a3354 2
  dynobj = elf_hash_table(info)->dynobj;
  if (dynobj)
d3356 2
a3357 4
      sgot = bfd_get_section_by_name (dynobj, ".got");
      splt = bfd_get_section_by_name (dynobj, ".plt");

      gp = _bfd_get_gp_value(dynobj);
d3363 1
a3363 1
	  _bfd_set_gp_value(dynobj, gp);
d3374 1
a3374 1
      struct elf_link_hash_entry *h;
d3396 6
d3431 1
a3431 1
	  h = elf_sym_hashes(input_bfd)[r_symndx - symtab_hdr->sh_info];
d3433 8
a3440 24
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;

	      /* If the symbol was defined as a common symbol in a
		 regular object file, and there was no definition in
		 any dynamic object, then the linker will have
		 allocated space for the symbol in a common section
		 but the ELF_LINK_HASH_DEF_REGULAR flag will not have
		 been set.  This is done for dynamic symbols in
		 elf_adjust_dynamic_symbol but this is not done for
		 non-dynamic symbols, somehow.  */
	      if ((h->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_REGULAR
		      | ELF_LINK_HASH_REF_REGULAR
		      | ELF_LINK_HASH_DEF_DYNAMIC))
		  == ELF_LINK_HASH_REF_REGULAR
		  && !(sec->owner->flags & DYNAMIC))
		h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3447 1
a3447 1
		       || !(h->elf_link_hash_flags
d3451 1
a3451 1
			  || !(h->elf_link_hash_flags
d3471 1
a3471 1
		  relocation = (h->root.u.def.value
d3476 1
a3476 1
	  else if (h->root.type == bfd_link_hash_undefweak)
d3478 1
a3478 1
	  else if (info->shared && !info->symbolic)
d3483 3
a3485 2
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset)))
d3498 2
d3516 1
a3516 1
	  /* FIXME */
d3521 2
a3522 1
	    bfd_vma gotoff;
d3524 1
d3526 1
a3526 1
	    BFD_ASSERT(sgot != NULL);
d3529 2
a3530 1
		gotoff = h->got_offset;
d3534 9
a3542 1
		gotoff = elf_local_got_offsets (input_bfd)[r_symndx];
d3544 1
a3544 9
		/* Use the lsb as a flag indicating that we've already
		   output the relocation entry.  */
		if (info->shared)
		  if (gotoff & 1)
		    gotoff &= ~(bfd_vma)1;
		  else
		    {
		      asection *srel;
		      Elf_Internal_Rela outrel;
d3546 5
a3550 2
		      srel = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT(srel != NULL);
d3552 23
a3574 9
		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset + gotoff);
		      outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		      outrel.r_addend = 0;

		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 ((Elf64_External_Rela *)
						  srel->contents)
						 + srel->reloc_count++);
d3576 1
a3576 2
		      elf_local_got_offsets (input_bfd)[r_symndx] |= 1;
		    }
a3578 3
	    /* Initialize the .got entry.  */
	    bfd_put_64 (output_bfd, relocation, sgot->contents + gotoff);

d3583 1
a3583 1
			  + gotoff);
d3588 1
a3588 1
	  
d3590 6
d3598 4
d3610 1
a3610 1
	  
d3613 58
a3670 29
	  if (info->shared
	      || (h && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      asection *srel;
	      const char *name;
	      Elf_Internal_Rela outrel;

	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		       elf_section_data(input_section)->rel_hdr.sh_name));
	      BFD_ASSERT(name != NULL);

	      srel = bfd_get_section_by_name(dynobj, name);
	      BFD_ASSERT(srel != NULL);

	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_addend = 0;
	      if (h)
		{
		  BFD_ASSERT(h->dynindx != -1);
		  outrel.r_info = ELF64_R_INFO(h->dynindx, r_type);
		  relocation = 0;
		}
	      else
		{
		  outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		}
d3672 7
a3678 5
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					 ((Elf64_External_Rela *)
					  srel->contents)
					 + srel->reloc_count++);
	    }
d3699 1
a3699 1
	      name = h->root.root.string;
d3737 1
a3737 1
  if (h->plt_offset != MINUS_ONE)
d3739 1
d3744 1
d3746 1
a3746 1
      /* This symbol has an entry in the procedure linkage table.  */
d3748 4
a3751 2
      BFD_ASSERT(h->dynindx != -1);
      BFD_ASSERT(h->got_offset != MINUS_ONE);
d3753 6
a3758 6
      splt = bfd_get_section_by_name(dynobj, ".plt");
      BFD_ASSERT(splt != NULL);
      srel = bfd_get_section_by_name(dynobj, ".rela.plt");
      BFD_ASSERT(srel != NULL);
      sgot = bfd_get_section_by_name(dynobj, ".got");
      BFD_ASSERT(sgot != NULL);
d3761 2
a3762 2
		  + sgot->output_offset 
		  + h->got_offset);
d3765 1
a3765 1
		  + h->plt_offset);
d3767 1
a3767 1
      plt_index = (h->plt_offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
a3771 1
	long hi, lo;
d3773 7
a3779 12
	/* decompose the reloc offset for the plt for ldah+lda */
	hi = plt_index * sizeof(Elf64_External_Rela);
	lo = ((hi & 0xffff) ^ 0x8000) - 0x8000;
	hi = (hi - lo) >> 16;

	insn1 = PLT_ENTRY_WORD1 | (hi & 0xffff);
	insn2 = PLT_ENTRY_WORD2 | (lo & 0xffff);
	insn3 = PLT_ENTRY_WORD3 | ((-(h->plt_offset + 12) >> 2) & 0x1fffff);
	
	bfd_put_32 (output_bfd, insn1, splt->contents + h->plt_offset);
	bfd_put_32 (output_bfd, insn2, splt->contents + h->plt_offset + 4);
	bfd_put_32 (output_bfd, insn3, splt->contents + h->plt_offset + 8);
d3798 39
a3836 2
      /* Fill in the entry in the global offset table.  */
      bfd_put_64 (output_bfd, plt_addr, sgot->contents + h->got_offset);
d3838 1
a3838 1
  else if (h->got_offset != MINUS_ONE)
d3840 2
a3841 1
      asection *sgot, *srel;
d3843 1
a3844 4
      BFD_ASSERT(h->dynindx != -1);

      sgot = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (sgot != NULL);
d3848 4
a3851 9
      outrel.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + h->got_offset);
      outrel.r_addend = 0;
      if (info->shared
	  && info->symbolic
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
      else
d3853 11
a3863 2
	  bfd_put_64(output_bfd, (bfd_vma)0, sgot->contents + h->got_offset);
	  outrel.r_info = ELF64_R_INFO(h->dynindx, R_ALPHA_GLOB_DAT);
a3864 4

      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				 ((Elf64_External_Rela *)srel->contents
				  + srel->reloc_count++));
a3884 1
  asection *sgot;
d3922 2
a3923 2
		 the rest of the BFD does.  It is, however, what the 
		 glibc ld.so wants.  Do this fixup here until we found 
d3955 1
a3955 1
	  
d3960 1
a3960 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 
a3964 54
  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  sgot = bfd_get_section_by_name (dynobj, ".got");
  if (sgot && sgot->_raw_size > 0)
    {
      if (sdyn == NULL)
        bfd_put_64 (output_bfd, (bfd_vma)0, sgot->contents);
      else
        bfd_put_64 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 
	8 * RESERVED_GOT_ENTRIES;
    }

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;

      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  BFD_ASSERT (indx > 0);
	  sym.st_shndx = indx;

	  bfd_elf64_swap_symbol_out (output_bfd, &sym,
				     (PTR) (((Elf64_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));
	}

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	bfd_count_sections (output_bfd) + 1;
    }

d3986 9
d4144 1
a4144 1
		
d4262 3
a4264 1
		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
d4364 1
a4364 1
		("%s: illegal section name `%s'",
d4533 21
d4657 2
d4660 2
a4661 1
  elf64_alpha_object_p 
a4665 2
#define elf_backend_additional_program_headers \
  elf64_alpha_additional_program_headers
d4667 2
a4668 2
#define bfd_elf64_bfd_is_local_label \
  elf64_alpha_is_local_label
d4671 2
d4674 2
d4682 2
d4704 2
@


1.1.1.1
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@@


1.1.1.2
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d304 1
a304 1
	 "ELF_LITERAL",		/* name */
d310 1
a310 1
  /* This reloc only appears immediately following an ELF_LITERAL reloc.
d511 1
a511 1
	 0,
d525 1
a525 1
	 0,
d550 1
a550 1
	 "RELATIVE",
d638 1
a638 1
  /* The gp used in the portion of the output object to which this
d746 1
a746 1
  value |= (elf64_alpha_op_stack[--elf64_alpha_op_tos]
d839 1
a839 1
  {BFD_RELOC_ALPHA_ELF_LITERAL,	R_ALPHA_LITERAL},
d842 5
a846 5
  {BFD_RELOC_23_PCREL_S2,	R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,	R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,		R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,		R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,		R_ALPHA_SREL64},
d1438 1
a1438 1

d1504 1
a1504 1
    }
d1575 1
a1575 1
	     .plt entry as well.
d1582 1
a1582 1
	     is an object, but it is fatal to be wrong guessing that a
d1585 1
a1585 1
	     Furthermore, the .plt trampoline does not give constant
d1608 1
a1608 1
		  && (info->shared
d1753 1
a1753 1

d1757 1
a1757 1
     will fill in the contents of the procedure linkage table later,
a1938 12

	  /* For now, bitch a lot if we exceed the .got size limit.  We
	     should eventually allocate multiple independent .got
	     subsections as necessary.  */
	  if (s->_raw_size > 64*1024)
	    {
	      (*_bfd_error_handler)
		("%s: .got segment overflow (size %lu, max %lu)",
		 bfd_get_filename (output_bfd), s->_raw_size, 64*1024);
	      bfd_set_error (bfd_error_file_too_big);
	      return false;
	    }
d2276 1
a2276 1

d2288 1
a2288 1

d2292 1
a2292 4
	      || (h && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  /* Undef weak symbols in static executables shouldn't
		     trigger a dynamic reloc.  */
		  && elf_hash_table(info)->dynamic_sections_created))
d2404 1
a2404 1
		  + sgot->output_offset
d2425 1
a2425 1

d2537 2
a2538 2
		 the rest of the BFD does.  It is, however, what the
		 glibc ld.so wants.  Do this fixup here until we found
d2570 1
a2570 1

d2575 1
a2575 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize =
d2592 1
a2592 1
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize =
d2804 1
a2804 1

d3295 1
a3295 1
  elf64_alpha_object_p
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1 2
a2 2
/* Alpha specific support for 64-bit ELF
   Copyright 1996, 1997 Free Software Foundation, Inc.
a48 1
static boolean elf64_alpha_mkobject PARAMS ((bfd *));
a55 2
static bfd_reloc_status_type elf64_alpha_reloc_bad
  PARAMS((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 8
d89 2
a90 2
static boolean elf64_alpha_is_local_label_name
  PARAMS((bfd *, const char *));
a101 12
static boolean elf64_alpha_can_merge_gots
  PARAMS((bfd *, bfd *));
static void elf64_alpha_merge_gots
  PARAMS((bfd *, bfd *));
static boolean elf64_alpha_calc_got_offsets_for_symbol
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static void elf64_alpha_calc_got_offsets PARAMS ((struct bfd_link_info *));
static void elf64_alpha_strip_section_from_output PARAMS ((asection *));
static boolean elf64_alpha_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean elf64_alpha_calc_dynrel_sizes
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
d123 3
d133 1
a133 3
  /* Cumulative flags for all the .got entries.  */
  int flags;

d135 3
a137 40
#define ALPHA_ELF_LINK_HASH_LU_ADDR 0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM  0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE 0x04
#define ALPHA_ELF_LINK_HASH_LU_FUNC 0x08

  /* Used to implement multiple .got subsections.  */
  struct alpha_elf_got_entry
  {
    struct alpha_elf_got_entry *next;

    /* which .got subsection?  */
    bfd *gotobj;

    /* the addend in effect for this entry.  */
    bfd_vma addend;

    /* the .got offset for this entry.  */
    int got_offset;

    int flags;

    /* An additional flag.  */
#define ALPHA_ELF_GOT_ENTRY_RELOCS_DONE 0x10
  } *got_entries;

  /* used to count non-got, non-plt relocations for delayed sizing
     of relocation sections.  */
  struct alpha_elf_reloc_entry
  {
    struct alpha_elf_reloc_entry *next;

    /* which .reloc section? */
    asection *srel;

    /* what kind of relocation? */
    unsigned long rtype;

    /* how many did we find?  */
    unsigned long count;
  } *reloc_entries;
a144 4

  /* The head of a list of .got subsections linked through
     alpha_elf_tdata(abfd)->got_link_next.  */
  bfd *got_list;
a166 13
/* Get the object's symbols as our own entry type.  */

#define alpha_elf_sym_hashes(abfd) \
  ((struct alpha_elf_link_hash_entry **)elf_sym_hashes(abfd))

/* Should we do dynamic things to this symbol?  */

#define alpha_elf_dynamic_symbol_p(h, info) 				\
  (((info)->shared && !(info)->symbolic && (h)->dynindx != -1)		\
   || (((h)->elf_link_hash_flags					\
	& (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
       == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))

a198 2
      ret->got_entries = NULL;
      ret->reloc_entries = NULL;
a226 43
/* We have some private fields hanging off of the elf_tdata structure.  */

struct alpha_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* For every input file, these are the got entries for that object's
     local symbols.  */
  struct alpha_elf_got_entry ** local_got_entries;

  /* For every input file, this is the object that owns the got that
     this input file uses.  */
  bfd *gotobj;

  /* For every got, this is a linked list through the objects using this got */
  bfd *in_got_link_next;

  /* For every got, this is a link to the next got subsegment.  */
  bfd *got_link_next;

  /* For every got, this is the section.  */
  asection *got;

  /* For every got, this is it's total number of *entries*.  */
  int total_got_entries;

  /* For every got, this is the sum of the number of *entries* required
     to hold all of the member object's local got.  */
  int n_local_got_entries;
};

#define alpha_elf_tdata(abfd) \
  ((struct alpha_elf_obj_tdata *) (abfd)->tdata.any)

static boolean
elf64_alpha_mkobject (abfd)
     bfd *abfd;
{
  abfd->tdata.any = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}
a227 16
static boolean
elf64_alpha_object_p (abfd)
     bfd *abfd;
{
  /* Allocate our special target data.  */
  struct alpha_elf_obj_tdata *new_tdata;
  new_tdata = bfd_zalloc (abfd, sizeof (struct alpha_elf_obj_tdata));
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;

  /* Set the right machine number for an Alpha ELF file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_alpha, 0);
}

d339 1
a339 1
     NOTE: Unlike ECOFF, partial in-place relocation is not done.  If
d444 1
a444 1
	 elf64_alpha_reloc_bad, /* special_function */
d460 1
a460 1
	 elf64_alpha_reloc_bad, /* special_function */
d476 1
a476 1
	 elf64_alpha_reloc_bad, /* special_function */
d492 1
a492 1
	 elf64_alpha_reloc_bad, /* special_function */
a556 2
/* A relocation function which doesn't do anything.  */

a571 19
/* A relocation function used for an unsupported reloc.  */

static bfd_reloc_status_type
elf64_alpha_reloc_bad (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc;
     asymbol *sym;
     PTR data;
     asection *sec;
     bfd *output_bfd;
     char **error_message;
{
  if (output_bfd)
    reloc->address += sec->output_offset;
  return bfd_reloc_notsupported;
}

/* Do the work of the GPDISP relocation.  */

d576 1
a576 2
     bfd_byte *p_ldah;
     bfd_byte *p_lda;
d582 2
a583 2
  i_ldah = bfd_get_32 (abfd, p_ldah);
  i_lda = bfd_get_32 (abfd, p_lda);
d597 1
a597 1
  if ((bfd_signed_vma) gpdisp < -(bfd_signed_vma)0x80000000
a611 2
/* The special function for the GPDISP reloc.  */

d646 1
a646 1
  p_ldah = (bfd_byte *) data + reloc_entry->address;
d653 3
a655 1
    *err_msg = "GPDISP relocation did not find ldah and lda instructions";
d660 164
d847 6
d900 1
a900 1
#define MAX_GOT_ENTRIES		(64*1024 / 8)
d904 10
a913 1
/* Handle an Alpha specific section when reading an object file.  This
a1025 1
#endif
d1031 1
a1035 2
/* Return the number of additional phdrs we will need.  */

a1061 2
/* Create the .got section.  */

d1068 1
d1073 9
a1081 1
  s = bfd_make_section (abfd, ".got");
d1084 1
a1084 3
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED))
d1088 20
a1107 1
  alpha_elf_tdata (abfd)->got = s;
a1111 2
/* Create all the dynamic sections.  */

d1117 1
a1117 1
  asection *s;
d1125 1
a1125 3
					    | SEC_HAS_CONTENTS
					    | SEC_IN_MEMORY
					    | SEC_LINKER_CREATED
d1149 2
a1150 4
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
a1153 3
  /* We may or may not have created a .got section for this object, but
     we definitely havn't done the rest of the work.  */

d1157 2
a1158 9
  s = bfd_make_section(abfd, ".rela.got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
      || !bfd_set_section_alignment (abfd, s, 3))
    return false;
d1160 2
a1161 13
  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the
     dynobj's .got section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  h = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL,
	 alpha_elf_tdata(abfd)->got, (bfd_vma) 0, (const char *) NULL,
	 false, get_elf_backend_data (abfd)->collect,
	 (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;
d1163 1
a1163 8
  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return false;

  elf_hash_table (info)->hgot = h;

  return true;
}
d1258 1
a1258 1
elf64_alpha_is_local_label_name (abfd, name)
d1260 1
a1260 1
     const char *name;
d1262 1
a1262 1
  return name[0] == '$';
d1526 2
a1527 1
*/
a1528 2
/* Handle dynamic relocations when doing an Alpha ELF link.  */

d1537 2
a1539 1
  const char *rel_sec_name;
d1541 1
a1541 2
  struct alpha_elf_link_hash_entry **sym_hashes;
  struct alpha_elf_got_entry **local_got_entries;
a1542 1
  int got_created;
d1547 3
d1551 5
a1555 9
  if (dynobj == NULL)
    elf_hash_table(info)->dynobj = dynobj = abfd;

  sreloc = NULL;
  rel_sec_name = NULL;
  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
  sym_hashes = alpha_elf_sym_hashes(abfd);
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
  got_created = 0;
d1560 1
a1560 1
      unsigned long r_symndx, r_type;
d1567 2
a1568 5
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  h->root.elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
	}
      r_type = ELF64_R_TYPE (rel->r_info);
d1570 1
a1570 1
      switch (r_type)
d1573 15
a1587 3
	  {
	    struct alpha_elf_got_entry *gotent;
	    int flags = 0;
d1589 17
a1605 15
	    if (h)
	      {
		/* Search for and possibly create a got entry.  */
		for (gotent = h->got_entries; gotent ; gotent = gotent->next)
		  if (gotent->gotobj == abfd &&
		      gotent->addend == rel->r_addend)
		    break;

		if (!gotent)
		  {
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
		    if (!gotent)
		      return false;
d1607 8
a1614 82
		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;

		    gotent->next = h->got_entries;
		    h->got_entries = gotent;

		    alpha_elf_tdata (abfd)->total_got_entries++;
		  }
	      }
	    else
	      {
		/* This is a local .got entry -- record for merge.  */
		if (!local_got_entries)
		  {
		    size_t size;
		    size = (symtab_hdr->sh_info
			    * sizeof (struct alpha_elf_got_entry *));

		    local_got_entries = ((struct alpha_elf_got_entry **)
					 bfd_alloc (abfd, size));
		    if (!local_got_entries)
		      return false;

		    memset (local_got_entries, 0, size);
		    alpha_elf_tdata (abfd)->local_got_entries =
		      local_got_entries;
		  }

		for (gotent = local_got_entries[ELF64_R_SYM(rel->r_info)];
		     gotent != NULL && gotent->addend != rel->r_addend;
		     gotent = gotent->next)
		  continue;
		if (!gotent)
		  {
		    gotent = ((struct alpha_elf_got_entry *)
			      bfd_alloc (abfd,
					 sizeof (struct alpha_elf_got_entry)));
		    if (!gotent)
		      return false;

		    gotent->gotobj = abfd;
		    gotent->addend = rel->r_addend;
		    gotent->got_offset = -1;
		    gotent->flags = 0;

		    gotent->next = local_got_entries[ELF64_R_SYM(rel->r_info)];
		    local_got_entries[ELF64_R_SYM(rel->r_info)] = gotent;

		    alpha_elf_tdata(abfd)->total_got_entries++;
		    alpha_elf_tdata(abfd)->n_local_got_entries++;
		  }
	      }

	    /* Remember how this literal is used from its LITUSEs.
	       This will be important when it comes to decide if we can
	       create a .plt entry for a function symbol.  */
	    if (rel+1 < relend
		&& ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE)
	      {
		do
		  {
		    ++rel;
		    if (rel->r_addend >= 1 && rel->r_addend <= 3)
		      flags |= 1 << rel->r_addend;
		  }
		while (rel+1 < relend &&
		       ELF64_R_TYPE (rel[1].r_info) == R_ALPHA_LITUSE);
	      }
	    else
	      {
		/* No LITUSEs -- presumably the address is not being
		   loaded for nothing.  */
		flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	      }

	    gotent->flags |= flags;
	    if (h)
	      {
		/* Make a guess as to whether a .plt entry will be needed.  */
		if ((h->flags |= flags) == ALPHA_ELF_LINK_HASH_LU_FUNC)
d1616 2
a1617 5
		else
		  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	      }
	  }
	  /* FALLTHRU */
d1619 1
a1619 6
	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL32:
	  /* We don't actually use the .got here, but the sections must
	     be created before the linker maps input sections to output
	     sections.  */
	  if (!got_created)
d1621 1
a1621 12
	      if (!elf64_alpha_create_got_section (abfd, info))
		return false;

	      /* Make sure the object's gotobj is set to itself so
		 that we default to every object with its own .got.
		 We'll merge .gots later once we've collected each
		 object's info.  */
	      alpha_elf_tdata(abfd)->gotobj = abfd;

	      got_created = 1;
	    }
	  break;
d1623 2
a1624 15
	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (h == NULL)
	    break;
	  /* FALLTHRU */

	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if (rel_sec_name == NULL)
	    {
	      rel_sec_name = (bfd_elf_string_from_elf_section
			      (abfd, elf_elfheader(abfd)->e_shstrndx,
			       elf_section_data(sec)->rel_hdr.sh_name));
	      if (rel_sec_name == NULL)
d1627 2
a1628 3
	      BFD_ASSERT (strncmp (rel_sec_name, ".rela", 5) == 0
			  && strcmp (bfd_get_section_name (abfd, sec),
				     rel_sec_name+5) == 0);
d1631 1
a1631 5
	  /* We need to create the section here now whether we eventually
	     use it or not so that it gets mapped to an output section by
	     the linker.  If not used, we'll kill it in
	     size_dynamic_sections.  */
	  if (sreloc == NULL)
d1633 1
a1633 2
	      sreloc = bfd_get_section_by_name (dynobj, rel_sec_name);
	      if (sreloc == NULL)
d1635 1
a1635 25
		  sreloc = bfd_make_section (dynobj, rel_sec_name);
		  if (sreloc == NULL
		      || !bfd_set_section_flags (dynobj, sreloc,
						 (SEC_ALLOC|SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
		      || !bfd_set_section_alignment (dynobj, sreloc, 3))
		    return false;
		}
	    }

	  if (h)
	    {
	      /* Since we havn't seen all of the input symbols yet, we
		 don't know whether we'll actually need a dynamic relocation
		 entry for this reloc.  So make a record of it.  Once we
		 find out if this thing needs dynamic relocation we'll
		 expand the relocation sections by the appropriate amount. */

	      struct alpha_elf_reloc_entry *rent;

	      for (rent = h->reloc_entries; rent; rent = rent->next)
		if (rent->rtype == r_type && rent->srel == sreloc)
a1636 219

	      if (!rent)
		{
		  rent = ((struct alpha_elf_reloc_entry *)
			  bfd_alloc (abfd,
				     sizeof (struct alpha_elf_reloc_entry)));
		  if (!rent)
		    return false;

		  rent->srel = sreloc;
		  rent->rtype = r_type;
		  rent->count = 1;

		  rent->next = h->reloc_entries;
		  h->reloc_entries = rent;
		}
	      else
		rent->count++;
	    }
	  else if (info->shared)
	    {
	      /* If this is a shared library, we need a RELATIVE reloc.  */
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
	    }
	  break;
	}
    }

  return true;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static boolean
elf64_alpha_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  asection *s;
  struct alpha_elf_link_hash_entry *ah;

  dynobj = elf_hash_table(info)->dynobj;
  ah = (struct alpha_elf_link_hash_entry *)h;

  /* Now that we've seen all of the input symbols, finalize our decision
     about whether this symbol should get a .plt entry.  */

  if (h->root.type != bfd_link_hash_undefweak
      && alpha_elf_dynamic_symbol_p (h, info)
      && ((h->type == STT_FUNC
	   && !(ah->flags & ALPHA_ELF_LINK_HASH_LU_ADDR))
	  || (h->type == STT_NOTYPE
	      && ah->flags == ALPHA_ELF_LINK_HASH_LU_FUNC))
      /* Don't prevent otherwise valid programs from linking by attempting
	 to create a new .got entry somewhere.  A Correct Solution would be
	 to add a new .got section to a new object file and let it be merged
	 somewhere later.  But for now don't bother.  */
      && ah->got_entries)
    {
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

      s = bfd_get_section_by_name(dynobj, ".plt");
      if (!s && !elf64_alpha_create_dynamic_sections (dynobj, info))
	return false;

      /* The first bit of the .plt is reserved.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_HEADER_SIZE;

      h->plt_offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are not
	 generating a shared library, then set the symbol to the location
	 in the .plt.  This is required to make function pointers compare
	 equal between the normal executable and the shared library.  */
      if (!info->shared)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = h->plt_offset;
	}

      /* We also need a JMP_SLOT entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf64_External_Rela);

      return true;
    }
  else
    h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  The Alpha, since it uses .got entries for all
     symbols even in regular objects, does not need the hackery of a
     .dynbss section and COPY dynamic relocations.  */

  return true;
}

/* Is it possible to merge two object file's .got tables?  */

static boolean
elf64_alpha_can_merge_gots (a, b)
     bfd *a, *b;
{
  int total = alpha_elf_tdata (a)->total_got_entries;

  /* Trivial quick fallout test.  */
  if (total + alpha_elf_tdata (b)->total_got_entries <= MAX_GOT_ENTRIES)
    return true;

  /* By their nature, local .got entries cannot be merged.  */
  if ((total += alpha_elf_tdata (b)->n_local_got_entries) > MAX_GOT_ENTRIES)
    return false;

  /* Failing the common trivial comparison, we must effectively
     perform the merge.  Not actually performing the merge means that
     we don't have to store undo information in case we fail.  */
  {
    struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes(b);
    Elf_Internal_Shdr *symtab_hdr = &elf_tdata(b)->symtab_hdr;
    int i, n;

    n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
    for (i = 0; i < n; ++i)
      {
	struct alpha_elf_got_entry *ae, *be;
	for (be = hashes[i]->got_entries; be ; be = be->next)
	  {
	    if (be->gotobj != b)
	      continue;

	    for (ae = hashes[i]->got_entries; ae ; ae = ae->next)
	      if (ae->gotobj == a && ae->addend == be->addend)
		goto global_found;

	    if (++total > MAX_GOT_ENTRIES)
	      return false;
	  global_found:;
	  }
      }
  }

  return true;
}

/* Actually merge two .got tables.  */

static void
elf64_alpha_merge_gots (a, b)
     bfd *a, *b;
{
  int total = alpha_elf_tdata(a)->total_got_entries;

  /* Remember local expansion.  */
  {
    int e = alpha_elf_tdata(b)->n_local_got_entries;
    total += e;
    alpha_elf_tdata(a)->n_local_got_entries += e;
  }

  /* Let the local .got entries know they are part of a new subsegment.  */
  {
    struct alpha_elf_got_entry **local_got_entries;
    local_got_entries = alpha_elf_tdata(b)->local_got_entries;
    if (local_got_entries)
      {
	int i, n;

	n = elf_tdata(b)->symtab_hdr.sh_info;
	for (i = 0; i < n; ++i)
	  {
	    struct alpha_elf_got_entry *gotent;
	    for (gotent = local_got_entries[i]; gotent; gotent = gotent->next)
	      gotent->gotobj = a;
	  }
      }
  }

  /* Merge the global .got entries.  */
  {
    struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes(b);
    Elf_Internal_Shdr *symtab_hdr = &elf_tdata(b)->symtab_hdr;
    int i, n;

    n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
    for (i = 0; i < n; ++i)
      {
	struct alpha_elf_got_entry *ae, *be, **pbe, **start;
	start = &hashes[i]->got_entries;
	for (pbe = start, be = *start; be ; pbe = &be->next, be = be->next)
	  {
	    if (be->gotobj != b)
	      continue;

	    for (ae = *start; ae ; ae = ae->next)
	      if (ae->gotobj == a && ae->addend == be->addend)
		{
		  ae->flags |= be->flags;
		  *pbe = be->next;
		  goto global_found;
a1637 7
	    be->gotobj = a;
	    total += 1;

	  global_found:;
	  }
      }
  }
d1639 4
a1642 3
  alpha_elf_tdata(a)->total_got_entries = total;
  alpha_elf_tdata(b)->gotobj = a;
}
d1644 2
a1645 1
/* Calculate the offsets for the got entries.  */
d1647 1
a1647 6
static boolean
elf64_alpha_calc_got_offsets_for_symbol (h, arg)
     struct alpha_elf_link_hash_entry *h;
     PTR arg;
{
  struct alpha_elf_got_entry *gotent;
d1649 9
a1657 6
  for (gotent = h->got_entries; gotent; gotent = gotent->next)
    {
      bfd_size_type *plge = &alpha_elf_tdata (gotent->gotobj)->got->_raw_size;
      gotent->got_offset = *plge;
      *plge += 8;
    }
d1659 4
a1662 2
  return true;
}
d1664 3
a1666 5
static void
elf64_alpha_calc_got_offsets (info)
     struct bfd_link_info *info;
{
  bfd *i, *got_list = alpha_elf_hash_table(info)->got_list;
d1668 7
a1674 4
  /* First, zero out the .got sizes, as we may be recalculating the
     .got after optimizing it.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    alpha_elf_tdata(i)->got->_raw_size = 0;
d1676 9
a1684 4
  /* Next, fill in the offsets for all the global entries.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_calc_got_offsets_for_symbol,
				NULL);
d1686 6
a1691 5
  /* Finally, fill in the offsets for the local entries.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd_size_type got_offset = alpha_elf_tdata(i)->got->_raw_size;
      bfd *j;
d1693 19
a1711 4
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
	{
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;
d1713 3
a1715 3
	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;
d1717 17
a1733 6
	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k]; gotent; gotent = gotent->next)
	      {
		gotent->got_offset = got_offset;
		got_offset += 8;
	      }
a1734 2

      alpha_elf_tdata(i)->got->_raw_size = got_offset;
a1735 1
}
d1737 1
a1737 14
/* Remove a section from the output BFD.  */

static void
elf64_alpha_strip_section_from_output (s)
     asection *s;
{
  asection **spp;

  for (spp = &s->output_section->owner->sections;
       *spp != s->output_section;
       spp = &(*spp)->next)
    continue;
  *spp = s->output_section->next;
  --s->output_section->owner->section_count;
d1740 5
a1744 1
/* Constructs the gots.  */
d1747 1
a1747 2
elf64_alpha_always_size_sections (output_bfd, info)
     bfd *output_bfd;
d1749 1
d1751 2
a1752 2
  bfd *i, *got_list, *cur_got_obj, **cur_got_tail;
  int ngots;
d1754 1
a1754 10
  if (info->relocateable)
    return true;

  ngots = 0;
  got_list = NULL;
  cur_got_obj = NULL;
  cur_got_tail = NULL;
  for (i = info->input_bfds; i ; i = i->link_next)
    {
      bfd *this_got = alpha_elf_tdata (i)->gotobj;
d1756 12
a1767 5
      /* Don't play if there is no .got for this input file.  */
      if (this_got == NULL)
	continue;

      if (alpha_elf_tdata (this_got)->total_got_entries > MAX_GOT_ENTRIES)
d1769 2
a1770 6
	  /* Yikes! A single object file has too many entries.  */
	  (*_bfd_error_handler)
	    ("%s: .got subsegment exceeds 64K (size %d)",
	     bfd_get_filename(i),
	     alpha_elf_tdata(this_got)->total_got_entries * 8);
	  return false;
d1773 2
a1774 28
      if (cur_got_obj)
	{
	  if (elf64_alpha_can_merge_gots (cur_got_obj, i))
	    {
	      elf64_alpha_merge_gots (cur_got_obj, i);
	      *cur_got_tail = i;
	    }
	  else
	    {
	      if (++ngots == 2)
		{
		  (*info->callbacks->warning)
		    (info, "using multiple gp values", (char *) NULL,
		     output_bfd, (asection *) NULL, (bfd_vma) 0);
		}
	      *cur_got_tail = NULL;
	      alpha_elf_tdata(cur_got_obj)->got_link_next = got_list;
	      got_list = cur_got_obj;
	      cur_got_obj = i;
	    }
	}
      else
	{
	  ++ngots;
	  cur_got_obj = i;
	}
      cur_got_tail = &alpha_elf_tdata(i)->in_got_link_next;
    }
d1776 3
a1778 3
  if (cur_got_obj)
    alpha_elf_tdata (cur_got_obj)->got_link_next = got_list;
  alpha_elf_hash_table (info)->got_list = got_list = cur_got_obj;
d1780 1
a1780 3
  /* Once the gots have been merged, fill in the got offsets for everything
     therein.  */
  elf64_alpha_calc_got_offsets (info);
d1782 5
a1786 5
  /* Allocate space for all of the .got subsections.  */
  for (i = got_list; i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      asection *s = alpha_elf_tdata(i)->got;
      if (s->_raw_size > 0)
d1788 2
a1789 3
	  s->contents = (bfd_byte *) bfd_zalloc (i, s->_raw_size);
	  if (s->contents == NULL)
	    return false;
a1790 1
    }
d1792 1
a1792 2
  return true;
}
d1794 4
a1797 1
/* Work out the sizes of the dynamic relocation entries.  */
d1799 1
a1799 22
static boolean
elf64_alpha_calc_dynrel_sizes (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  /* If the symbol was defined as a common symbol in a regular object
     file, and there was no definition in any dynamic object, then the
     linker will have allocated space for the symbol in a common
     section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been
     set.  This is done for dynamic symbols in
     elf_adjust_dynamic_symbol but this is not done for non-dynamic
     symbols, somehow.  */
  if (((h->root.elf_link_hash_flags
       & (ELF_LINK_HASH_DEF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_DEF_DYNAMIC))
       == ELF_LINK_HASH_REF_REGULAR)
      && (h->root.root.type == bfd_link_hash_defined
	  || h->root.root.type == bfd_link_hash_defweak)
      && !(h->root.root.u.def.section->owner->flags & DYNAMIC))
    {
      h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d1802 4
a1805 3
  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  */
  if (alpha_elf_dynamic_symbol_p (&h->root, info))
d1807 5
a1811 25
      struct alpha_elf_reloc_entry *relent;

      for (relent = h->reloc_entries; relent; relent = relent->next)
	{
	  relent->srel->_raw_size +=
	    sizeof (Elf64_External_Rela) * relent->count;
	}

      /* Only add a .rela.got entry if we're not using a .plt entry.  */
      if (h->root.plt_offset == MINUS_ONE)
	{
	  bfd *dynobj = elf_hash_table(info)->dynobj;
	  struct alpha_elf_got_entry *gotent;
	  bfd_size_type count = 0;
	  asection *srel;

	  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
	    count++;
	  if (count > 0)
	    {
	      srel = bfd_get_section_by_name (dynobj, ".rela.got");
	      BFD_ASSERT (srel != NULL);
	      srel->_raw_size += sizeof (Elf64_External_Rela) * count;
	    }
	}
a1812 5
  /* Otherwise, shared objects require RELATIVE relocs for all REFQUAD
     and REFLONG relocations.  */
  else if (info->shared)
    {
      struct alpha_elf_reloc_entry *relent;
d1814 4
a1817 8
      for (relent = h->reloc_entries; relent; relent = relent->next)
	if (relent->rtype == R_ALPHA_REFLONG
	    || relent->rtype == R_ALPHA_REFQUAD)
	  {
	    relent->srel->_raw_size +=
	      sizeof(Elf64_External_Rela) * relent->count;
	  }
    }
d1837 1
a1837 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1842 2
a1843 2
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
d1845 1
a1845 28
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Now that we've seen all of the input files, we can decide which
	 symbols need dynamic relocation entries and which don't.  We've
	 collected information in check_relocs that we can now apply to
	 size the dynamic relocation sections.  */
      alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				    elf64_alpha_calc_dynrel_sizes,
				    info);

      /* When building shared libraries, each local .got entry needs a
	 RELATIVE reloc.  */
      if (info->shared)
	{
	  bfd *i;
	  asection *srel;
	  bfd_size_type count;

	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);

	  for (i = alpha_elf_hash_table(info)->got_list, count = 0;
	       i != NULL;
	       i = alpha_elf_tdata(i)->got_link_next)
	    count += alpha_elf_tdata(i)->n_local_got_entries;

	  srel->_raw_size += count * sizeof(Elf64_External_Rela);
d1848 11
a1858 1
  /* else we're not dynamic and by definition we don't need such things.  */
d1870 1
a1870 1
      if (!(s->flags & SEC_LINKER_CREATED))
d1875 1
a1875 1
      name = bfd_get_section_name (dynobj, s);
d1887 1
a1887 1
      if (strncmp (name, ".rela", 5) == 0)
a1892 1
	      const char *outname;
d1897 1
a1897 3
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
d1910 42
d1954 1
a1954 1
	  /* It's not one of our dynamic sections, so don't allocate space.  */
a1958 2
	elf64_alpha_strip_section_from_output (s);
      else
d1960 1
a1960 6
	  /* Allocate memory for the section contents.  */
	  s->contents = (bfd_byte *) bfd_zalloc(dynobj, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
	    return false;
	}
    }
d1962 6
a1967 9
  /* If we are generating a shared library, we generate a section
     symbol for each output section.  These are local symbols, which
     means that they must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.  */
  if (info->shared)
    {
      long c[2], i;
      asection *p;
d1969 2
a1970 2
      c[0] = 0;
      c[1] = bfd_count_sections (output_bfd);
d1972 4
a1975 13
      elf_hash_table (info)->dynsymcount += c[1];
      elf_link_hash_traverse (elf_hash_table(info),
			      elf64_alpha_adjust_dynindx,
			      (PTR) c);

      for (i = 1, p = output_bfd->sections;
	   p != NULL;
	   p = p->next, i++)
	{
	  elf_section_data (p)->dynindx = i;
	  /* These symbols will have no names, so we don't need to
	     fiddle with dynstr_index.  */
	}
d2051 2
a2052 2
  asection *sec, *sgot, *srel, *srelgot;
  bfd *dynobj, *gotobj;
d2055 1
a2055 7
  srelgot = srel = NULL;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    {
      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
    }
d2060 2
a2061 2
  gotobj = alpha_elf_tdata (input_bfd)->gotobj;
  if (gotobj)
d2063 4
a2066 2
      sgot = alpha_elf_tdata (gotobj)->got;
      gp = _bfd_get_gp_value (gotobj);
d2072 1
a2072 1
	  _bfd_set_gp_value (gotobj, gp);
d2083 1
a2083 1
      struct alpha_elf_link_hash_entry *h;
d2134 1
a2134 1
	  h = alpha_elf_sym_hashes (input_bfd)[r_symndx - symtab_hdr->sh_info];
d2136 24
a2159 8
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  if (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.root.u.def.section;
d2166 1
a2166 1
		       || !(h->root.elf_link_hash_flags
d2170 1
a2170 1
			  || !(h->root.elf_link_hash_flags
d2190 1
a2190 1
		  relocation = (h->root.root.u.def.value
d2195 1
a2195 1
	  else if (h->root.root.type == bfd_link_hash_undefweak)
d2202 1
a2202 1
		    (info, h->root.root.root.string, input_bfd,
a2215 2
	    BFD_ASSERT(gp != 0);

d2232 1
a2232 1
	  /* We hate these silly beasts.  */
d2237 1
a2237 1
	    struct alpha_elf_got_entry *gotent;
d2239 1
a2240 2
	    BFD_ASSERT(gp != 0);

d2243 1
a2243 15
		gotent = h->got_entries;
		while (gotent->gotobj != gotobj || gotent->addend != addend)
		  gotent = gotent->next;

		/* Initialize the .got entry's value.  */
		if (!(gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_DONE))
		  {
		    bfd_put_64 (output_bfd, relocation+addend,
				sgot->contents + gotent->got_offset);

		    /* The dynamic relocations for the .got entries are
		       done in finish_dynamic_symbol.  */

		    gotent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_DONE;
		  }
d2247 24
a2270 29
		gotent = (alpha_elf_tdata(input_bfd)->
			  local_got_entries[r_symndx]);
		while (gotent->addend != addend)
		  gotent = gotent->next;

		if (!(gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_DONE))
		  {
		    bfd_put_64 (output_bfd, relocation+addend,
				sgot->contents + gotent->got_offset);

		    /* Local got entries need RELATIVE relocs in shared
		       libraries.  */
		    if (info->shared)
		      {
			Elf_Internal_Rela outrel;

			BFD_ASSERT(srelgot != NULL);

			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + gotent->got_offset);
			outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
			outrel.r_addend = 0;

			bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						   ((Elf64_External_Rela *)
						    srelgot->contents)
						   + srelgot->reloc_count++);
		      }
d2272 2
a2273 2
		    gotent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_DONE;
		  }
d2276 3
d2283 1
a2283 1
			  + gotent->got_offset);
d2303 32
a2334 3
	  {
	    Elf_Internal_Rela outrel;
	    boolean skip;
d2336 5
a2340 60
	    /* Careful here to remember RELATIVE relocations for global
	       variables for symbolic shared objects.  */

	    if (h && alpha_elf_dynamic_symbol_p (&h->root, info))
	      {
		BFD_ASSERT(h->root.dynindx != -1);
		outrel.r_info = ELF64_R_INFO(h->root.dynindx, r_type);
		outrel.r_addend = addend;
		addend = 0, relocation = 0;
	      }
	    else if (info->shared)
	      {
		outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		outrel.r_addend = 0;
	      }
	    else
	      goto default_reloc;

	    if (!srel)
	      {
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
			 elf_section_data(input_section)->rel_hdr.sh_name));
		BFD_ASSERT(name != NULL);

		srel = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT(srel != NULL);
	      }

	    skip = false;

	    if (elf_section_data (input_section)->stab_info == NULL)
	      outrel.r_offset = rel->r_offset;
	    else
	      {
		bfd_vma off;

		off = (_bfd_stab_section_offset
		       (output_bfd, &elf_hash_table (info)->stab_info,
			input_section,
			&elf_section_data (input_section)->stab_info,
			rel->r_offset));
		if (off == (bfd_vma) -1)
		  skip = true;
		outrel.r_offset = off;
	      }

	    if (! skip)
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
	    else
	      memset (&outrel, 0, sizeof outrel);

	    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				       ((Elf64_External_Rela *)
					srel->contents)
				       + srel->reloc_count++);
	  }
d2361 1
a2361 1
	      name = h->root.root.root.string;
a2400 1
      /* Fill in the .plt entry for this symbol.  */
a2404 1
      struct alpha_elf_got_entry *gotent;
d2406 1
a2406 1
      BFD_ASSERT (h->dynindx != -1);
d2408 2
a2409 4
      /* The first .got entry will be updated by the .plt with the
	 address of the target function.  */
      gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
      BFD_ASSERT (gotent && gotent->addend == 0);
d2411 6
a2416 6
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL);
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (srel != NULL);
      sgot = alpha_elf_tdata (gotent->gotobj)->got;
      BFD_ASSERT (sgot != NULL);
d2420 1
a2420 1
		  + gotent->got_offset);
d2462 2
a2463 13
      /* Fill in the entries in the .got.  */
      bfd_put_64 (output_bfd, plt_addr, sgot->contents + gotent->got_offset);

      /* Subsequent .got entries will continue to bounce through the .plt.  */
      while ((gotent = gotent->next) != NULL)
	{
	  sgot = alpha_elf_tdata(gotent->gotobj)->got;
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gotent->addend == 0);

	  bfd_put_64 (output_bfd, plt_addr,
		      sgot->contents + gotent->got_offset);
	}
d2465 1
a2465 1
  else if (alpha_elf_dynamic_symbol_p (h, info))
d2467 1
a2467 2
      /* Fill in the dynamic relocations for this symbol's .got entries.  */
      asection *srel;
a2468 1
      struct alpha_elf_got_entry *gotent;
d2470 4
d2477 12
a2488 14
      outrel.r_info = ELF64_R_INFO (h->dynindx, R_ALPHA_GLOB_DAT);
      for (gotent = ((struct alpha_elf_link_hash_entry *) h)->got_entries;
	   gotent != NULL;
	   gotent = gotent->next)
	{
	  asection *sgot = alpha_elf_tdata (gotent->gotobj)->got;
	  outrel.r_offset = (sgot->output_section->vma
			     + sgot->output_offset
			     + gotent->got_offset);
	  outrel.r_addend = gotent->addend;

	  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
				     ((Elf64_External_Rela *)srel->contents
				      + srel->reloc_count++));
d2490 4
d2514 1
d2595 16
d2937 1
a2937 3
		  flagword flags = (SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
a3205 21
  /* The .got subsections...  */
  {
    bfd *i, *dynobj = elf_hash_table(info)->dynobj;
    for (i = alpha_elf_hash_table(info)->got_list;
	 i != NULL;
	 i = alpha_elf_tdata(i)->got_link_next)
      {
	asection *sgot;

	/* elf_bfd_final_link already did everything in dynobj.  */
	if (i == dynobj)
	  continue;

	sgot = alpha_elf_tdata(i)->got;
	if (! bfd_set_section_contents (abfd, sgot->output_section,
					sgot->contents, sgot->output_offset,
					sgot->_raw_size))
	  return false;
      }
  }

a3308 2
#define bfd_elf64_mkobject \
  elf64_alpha_mkobject
a3310 1

d3318 2
a3319 2
#define bfd_elf64_bfd_is_local_label_name \
  elf64_alpha_is_local_label_name
a3328 2
#define elf_backend_always_size_sections \
  elf64_alpha_always_size_sections
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 97, 98, 1999 Free Software Foundation, Inc.
d75 2
d104 1
a104 2
static boolean elf64_alpha_size_got_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a108 3
static boolean elf64_alpha_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d116 2
a127 4
static boolean elf64_alpha_merge_ind_symbols
  PARAMS((struct alpha_elf_link_hash_entry *, PTR));
static Elf_Internal_Rela * elf64_alpha_find_reloc_at_ofs
  PARAMS ((Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_vma, int));
a163 2

    int use_count;
d222 4
a225 7
  ((((info)->shared && !(info)->symbolic)				\
    || (((h)->elf_link_hash_flags					\
	 & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
        == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))	\
    || (h)->root.type == bfd_link_hash_undefweak			\
    || (h)->root.type == bfd_link_hash_defweak)				\
   && (h)->dynindx != -1)
d558 1
a558 2
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PUSH,	/* type */
d574 1
a574 2
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_STORE,	/* type */
d590 1
a590 2
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PSUB,	/* type */
d606 1
a606 2
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_OP_PRSHIFT,	/* type */
a619 132
  /* Change the value of GP used by +r_addend until the next GPVALUE or the
     end of the input bfd.  */
  /* Not implemented -- it's dumb.  */
  HOWTO (R_ALPHA_GPVALUE,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "GPVALUE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELHIGH,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "GPRELHIGH",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of the displacement from GP to the target.  */
  HOWTO (R_ALPHA_GPRELLOW,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "GPRELLOW",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 16-bit displacement from the GP to the target.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_16,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "IMMED_GP_16",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement from the GP to the target; the
     low bits are supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_GP_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_GP_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement to the starting address of the
     current section (the relocation target is ignored); the low bits are 
     supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_SCN_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_SCN_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The high bits of a 32-bit displacement from the previous br, bsr, jsr
     or jmp insn (as tagged by a BRADDR or HINT reloc) to the target; the
     low bits are supplied by subsequent R_ALPHA_IMMED_LO32 relocs.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_BR_HI32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_BR_HI32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* The low 16 bits of a displacement calculated in a previous HI32 reloc.  */
  /* XXX: Not implemented.  */
  HOWTO (R_ALPHA_IMMED_LO32,
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 elf64_alpha_reloc_bad, /* special_function */
	 "IMMED_LO32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

a620 5

  /* A dynamic relocation to copy the target into our .dynbss section.  */
  /* Not generated, as all Alpha objects use PIC, so it is not needed.  It
     is present because every other ELF has one, but should not be used
     because .dynbss is an ugly thing.  */
a634 1
  /* A dynamic relocation for a .got entry.  */
a648 1
  /* A dynamic relocation for a .plt entry.  */
a662 1
  /* A dynamic relocation to add the base of the DSO to a 64-bit field.  */
d740 2
a741 2
  if ((bfd_signed_vma) gpdisp < -(bfd_signed_vma) 0x80000000
      || (bfd_signed_vma) gpdisp >= (bfd_signed_vma) 0x7fff8000)
d798 1
a798 1
    *err_msg = _("GPDISP relocation did not find ldah and lda instructions");
a825 11

/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to process
   the explicit !<reloc>!sequence relocations, and are mapped into the normal
   relocations at the end of processing. */
  {BFD_RELOC_ALPHA_USER_LITERAL,	R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_USER_LITUSE_BASE,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_LITUSE_JSR,	R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_USER_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_ALPHA_USER_GPRELHIGH,	R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_USER_GPRELLOW,	R_ALPHA_GPRELLOW},
d856 3
a858 638
  r_type = ELF64_R_TYPE(dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_ALPHA_max);
  cache_ptr->howto = &elf64_alpha_howto_table[r_type];
}

/* These functions do relaxation for Alpha ELF. 

   Currently I'm only handling what I can do with existing compiler
   and assembler support, which means no instructions are removed,
   though some may be nopped.  At this time GCC does not emit enough
   information to do all of the relaxing that is possible.  It will
   take some not small amount of work for that to happen.

   There are a couple of interesting papers that I once read on this
   subject, that I cannot find references to at the moment, that
   related to Alpha in particular.  They are by David Wall, then of
   DEC WRL.  */

#define OP_LDA		0x08
#define OP_LDAH		0x09
#define INSN_JSR	0x68004000
#define INSN_JSR_MASK	0xfc00c000
#define OP_LDQ		0x29
#define OP_BR		0x30
#define OP_BSR		0x34
#define INSN_UNOP	0x2fe00000

struct alpha_relax_info
{
  bfd *abfd;
  asection *sec;
  bfd_byte *contents;
  Elf_Internal_Rela *relocs, *relend;
  struct bfd_link_info *link_info;
  boolean changed_contents;
  boolean changed_relocs;
  bfd_vma gp;
  bfd *gotobj;
  asection *tsec;
  struct alpha_elf_link_hash_entry *h;
  struct alpha_elf_got_entry *gotent;
  unsigned char other;
};

static Elf_Internal_Rela * elf64_alpha_relax_with_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
          Elf_Internal_Rela *irel, Elf_Internal_Rela *irelend));

static boolean elf64_alpha_relax_without_lituse
  PARAMS((struct alpha_relax_info *info, bfd_vma symval, 
          Elf_Internal_Rela *irel));

static bfd_vma elf64_alpha_relax_opt_call
  PARAMS((struct alpha_relax_info *info, bfd_vma symval));

static boolean elf64_alpha_relax_section
  PARAMS((bfd *abfd, asection *sec, struct bfd_link_info *link_info,
	  boolean *again));

static Elf_Internal_Rela *
elf64_alpha_find_reloc_at_ofs (rel, relend, offset, type)
     Elf_Internal_Rela *rel, *relend;
     bfd_vma offset;
     int type;
{
  while (rel < relend)
    {
      if (rel->r_offset == offset && ELF64_R_TYPE (rel->r_info) == type)
	return rel;
      ++rel;
    }
  return NULL;
}

static Elf_Internal_Rela *
elf64_alpha_relax_with_lituse (info, symval, irel, irelend)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel, *irelend;
{
  Elf_Internal_Rela *urel;
  int flags, count, i;
  bfd_signed_vma disp;
  boolean fits16;
  boolean fits32;
  boolean lit_reused = false;
  boolean all_optimized = true;
  unsigned int lit_insn;

  lit_insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);
  if (lit_insn >> 26 != OP_LDQ)
    {
      ((*_bfd_error_handler)
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
	bfd_get_filename (info->abfd), info->sec->name,
	(unsigned long)irel->r_offset));
      return irel;
    }

  /* Summarize how this particular LITERAL is used.  */
  for (urel = irel+1, flags = count = 0; urel < irelend; ++urel, ++count)
    {
      if (ELF64_R_TYPE (urel->r_info) != R_ALPHA_LITUSE)
	break;
      if (urel->r_addend >= 0 && urel->r_addend <= 3)
	flags |= 1 << urel->r_addend;
    }

  /* A little preparation for the loop... */
  disp = symval - info->gp;
  fits16 = (disp >= -(bfd_signed_vma)0x8000 && disp < 0x8000);
  fits32 = (disp >= -(bfd_signed_vma)0x80000000 && disp < 0x7fff8000);

  for (urel = irel+1, i = 0; i < count; ++i, ++urel)
    {
      unsigned int insn;
      insn = bfd_get_32 (info->abfd, info->contents + urel->r_offset);

      switch (urel->r_addend)
	{
	default: /* 0 = ADDRESS FORMAT */
	  /* This type is really just a placeholder to note that all
	     uses cannot be optimized, but to still allow some.  */
	  all_optimized = false;
	  break;

	case 1: /* MEM FORMAT */
	  /* We can always optimize 16-bit displacements.  */
	  if (fits16)
	    {
	      /* FIXME: sanity check the insn for mem format with
		 zero addend.  */

	      /* Take the op code and dest from this insn, take the base 
		 register from the literal insn.  Leave the offset alone.  */
	      insn = (insn & 0xffe00000) | (lit_insn & 0x001f0000);
	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELLOW);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = true;

	      bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
	      info->changed_contents = true;
	    }

	  /* If all mem+byte, we can optimize 32-bit mem displacements.  */
	  else if (fits32 && !(flags & ~6))
	    {
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb, and
		 that mem_insn disp is zero.  */

	      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELHIGH);
	      lit_insn = (OP_LDAH << 26) | (lit_insn & 0x03ff0000);
	      bfd_put_32 (info->abfd, lit_insn,
			  info->contents + irel->r_offset);
	      lit_reused = true;
	      info->changed_contents = true;

	      urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					   R_ALPHA_GPRELLOW);
	      urel->r_addend = irel->r_addend;
	      info->changed_relocs = true;
	    }
	  else
	    all_optimized = false;
	  break;

	case 2: /* BYTE OFFSET FORMAT */
	  /* We can always optimize byte instructions.  */

	  /* FIXME: sanity check the insn for byte op.  Check that the
	     literal dest reg is indeed Rb in the byte insn.  */

	  insn = (insn & ~0x001ff000) | ((symval & 7) << 13) | 0x1000;

	  urel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  urel->r_addend = 0;
	  info->changed_relocs = true;

	  bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);
	  info->changed_contents = true;
	  break;

	case 3: /* CALL FORMAT */
	  {
	    /* If not zero, place to jump without needing pv.  */
	    bfd_vma optdest = elf64_alpha_relax_opt_call (info, symval);
	    bfd_vma org = (info->sec->output_section->vma
			   + info->sec->output_offset
			   + urel->r_offset + 4);
	    bfd_signed_vma odisp;

	    odisp = (optdest ? optdest : symval) - org;
	    if (odisp >= -0x400000 && odisp < 0x400000)
	      {
		Elf_Internal_Rela *xrel;

		/* Preserve branch prediction call stack when possible. */
		if ((insn & INSN_JSR_MASK) == INSN_JSR)
		  insn = (OP_BSR << 26) | (insn & 0x03e00000);
		else
		  insn = (OP_BR << 26) | (insn & 0x03e00000);
		  
		urel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
					     R_ALPHA_BRADDR);
		urel->r_addend = irel->r_addend;

		if (optdest)
		  urel->r_addend += optdest - symval;
		else
		  all_optimized = false;

		bfd_put_32 (info->abfd, insn, info->contents + urel->r_offset);

		/* Kill any HINT reloc that might exist for this insn.  */
		xrel = (elf64_alpha_find_reloc_at_ofs
			(info->relocs, info->relend, urel->r_offset, 
			 R_ALPHA_HINT));
		if (xrel)
		  xrel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

		info->changed_contents = true;
		info->changed_relocs = true;
	      }
	    else
	      all_optimized = false;

	    /* ??? If target gp == current gp we can eliminate the gp reload.
	       This does depend on every place a gp could be reloaded will
	       be, which currently happens for all code produced by gcc, but
	       not necessarily by hand-coded assembly, or if sibling calls
	       are enabled in gcc. 

	       Perhaps conditionalize this on a flag being set in the target
	       object file's header, and have gcc set it?  */
	  }
	  break;
	}
    }

  /* If all cases were optimized, we can reduce the use count on this
     got entry by one, possibly eliminating it.  */
  if (all_optimized)
    {
      info->gotent->use_count -= 1;
      alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
      if (!info->h)
	alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;

      /* If the literal instruction is no longer needed (it may have been
	 reused.  We can eliminate it.
	 ??? For now, I don't want to deal with compacting the section,
	 so just nop it out.  */
      if (!lit_reused)
	{
	  irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	  info->changed_relocs = true;

	  bfd_put_32 (info->abfd, INSN_UNOP, info->contents + irel->r_offset);
	  info->changed_contents = true;
	}
    }

  return irel + count;
}

static bfd_vma
elf64_alpha_relax_opt_call (info, symval)
     struct alpha_relax_info *info;
     bfd_vma symval;
{
  /* If the function has the same gp, and we can identify that the
     function does not use its function pointer, we can eliminate the
     address load.  */

  /* If the symbol is marked NOPV, we are being told the function never
     needs its procedure value.  */
  if (info->other == STO_ALPHA_NOPV)
    return symval;

  /* If the symbol is marked STD_GP, we are being told the function does
     a normal ldgp in the first two words.  */ 
  else if (info->other == STO_ALPHA_STD_GPLOAD)
    ;

  /* Otherwise, we may be able to identify a GP load in the first two
     words, which we can then skip.  */
  else 
    {
      Elf_Internal_Rela *tsec_relocs, *tsec_relend, *tsec_free, *gpdisp;
      bfd_vma ofs;

      /* Load the relocations from the section that the target symbol is in. */
      if (info->sec == info->tsec)
	{
	  tsec_relocs = info->relocs;
	  tsec_relend = info->relend;
	  tsec_free = NULL;
	}
      else
	{
	  tsec_relocs = (_bfd_elf64_link_read_relocs
		         (info->abfd, info->tsec, (PTR) NULL,
			 (Elf_Internal_Rela *) NULL,
			 info->link_info->keep_memory));
	  if (tsec_relocs == NULL)
	    return 0;
	  tsec_relend = tsec_relocs + info->tsec->reloc_count;
	  tsec_free = (info->link_info->keep_memory ? NULL : tsec_relocs);
	}

      /* Recover the symbol's offset within the section.  */
      ofs = (symval - info->tsec->output_section->vma
	     - info->tsec->output_offset);
  
      /* Look for a GPDISP reloc.  */
      gpdisp = (elf64_alpha_find_reloc_at_ofs
		(tsec_relocs, tsec_relend, ofs, R_ALPHA_GPDISP));

      if (!gpdisp || gpdisp->r_addend != 4)
	{
	  if (tsec_free)
	    free (tsec_free);
	  return 0;
	}
      if (tsec_free)
        free (tsec_free);
    }

  /* We've now determined that we can skip an initial gp load.  Verify 
     that the call and the target use the same gp.   */
  if (info->link_info->hash->creator != info->tsec->owner->xvec
      || info->gotobj != alpha_elf_tdata (info->tsec->owner)->gotobj)
    return 0;

  return symval + 8;
}

static boolean
elf64_alpha_relax_without_lituse (info, symval, irel)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
{
  unsigned int insn;
  bfd_signed_vma disp;

  /* Get the instruction.  */
  insn = bfd_get_32 (info->abfd, info->contents + irel->r_offset);

  if (insn >> 26 != OP_LDQ)
    {
      ((*_bfd_error_handler)
       ("%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn",
	bfd_get_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset));
      return true;
    }

  /* So we aren't told much.  Do what we can with the address load and
     fake the rest.  All of the optimizations here require that the
     offset from the GP fit in 16 bits.  */

  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
    return true;

  /* On the LITERAL instruction itself, consider exchanging
     `ldq R,X(gp)' for `lda R,Y(gp)'.  */

  insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  bfd_put_32 (info->abfd, insn, info->contents + irel->r_offset);
  info->changed_contents = true;

  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), R_ALPHA_GPRELLOW);
  info->changed_relocs = true;

  /* Reduce the use count on this got entry by one, possibly
     eliminating it.  */
  info->gotent->use_count -= 1;
  alpha_elf_tdata (info->gotent->gotobj)->total_got_entries -= 1;
  if (!info->h)
    alpha_elf_tdata (info->gotent->gotobj)->n_local_got_entries -= 1;

  /* ??? Search forward through this basic block looking for insns
     that use the target register.  Stop after an insn modifying the
     register is seen, or after a branch or call.

     Any such memory load insn may be substituted by a load directly
     off the GP.  This allows the memory load insn to be issued before
     the calculated GP register would otherwise be ready. 

     Any such jsr insn can be replaced by a bsr if it is in range.

     This would mean that we'd have to _add_ relocations, the pain of
     which gives one pause.  */

  return true;
}

static boolean
elf64_alpha_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *free_contents = NULL;
  Elf64_External_Sym *extsyms = NULL;
  Elf64_External_Sym *free_extsyms = NULL;
  struct alpha_elf_got_entry **local_got_entries;
  struct alpha_relax_info info;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = false;

  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return true;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf64_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  memset(&info, 0, sizeof(info));
  info.abfd = abfd;
  info.sec = sec;
  info.link_info = link_info;
  info.relocs = internal_relocs;
  info.relend = irelend = internal_relocs + sec->reloc_count;

  /* Find the GP for this object.  */
  info.gotobj = alpha_elf_tdata (abfd)->gotobj;
  if (info.gotobj)
    {
      asection *sgot = alpha_elf_tdata (info.gotobj)->got;
      info.gp = _bfd_get_gp_value (info.gotobj);
      if (info.gp == 0)
	{
	  info.gp = (sgot->output_section->vma
		     + sgot->output_offset
		     + 0x8000);
	  _bfd_set_gp_value (info.gotobj, info.gp);
	}
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      Elf_Internal_Sym isym;
      struct alpha_elf_got_entry *gotent;

      if (ELF64_R_TYPE (irel->r_info) != (int) R_ALPHA_LITERAL)
	continue;

      /* Get the section contents.  */
      if (info.contents == NULL)
	{
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    info.contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (info.contents == NULL)
		goto error_return;
	      free_contents = info.contents;

	      if (! bfd_get_section_contents (abfd, sec, info.contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      extsyms = ((Elf64_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
		goto error_return;
	    }
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF64_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  bfd_elf64_swap_symbol_in (abfd,
				    extsyms + ELF64_R_SYM (irel->r_info),
				    &isym);
	  if (isym.st_shndx == SHN_UNDEF)
	    info.tsec = bfd_und_section_ptr;
	  else if (isym.st_shndx > 0 && isym.st_shndx < SHN_LORESERVE)
	    info.tsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  else if (isym.st_shndx == SHN_ABS)
	    info.tsec = bfd_abs_section_ptr;
	  else if (isym.st_shndx == SHN_COMMON)
	    info.tsec = bfd_com_section_ptr;
	  else 
	    continue;	/* who knows. */

	  info.h = NULL;
	  info.other = isym.st_other;
	  gotent = local_got_entries[ELF64_R_SYM(irel->r_info)];
	  symval = isym.st_value;
	}
      else
	{
	  unsigned long indx;
	  struct alpha_elf_link_hash_entry *h;

	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = alpha_elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

	  /* We can't do anthing with undefined or dynamic symbols.  */
	  if (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak
	      || alpha_elf_dynamic_symbol_p (&h->root, link_info))
	    continue;

	  info.h = h;
	  info.gotent = gotent;
	  info.tsec = h->root.root.u.def.section;
	  info.other = h->root.other;
	  gotent = h->got_entries;
	  symval = h->root.root.u.def.value;
	}

      /* Search for the got entry to be used by this relocation.  */
      while (gotent->gotobj != info.gotobj || gotent->addend != irel->r_addend)
	gotent = gotent->next;
      info.gotent = gotent;

      symval += info.tsec->output_section->vma + info.tsec->output_offset;
      symval += irel->r_addend;

      BFD_ASSERT(info.gotent != NULL);

      /* If there exist LITUSE relocations immediately following, this
	 opens up all sorts of interesting optimizations, because we
	 now know every location that this address load is used.  */

      if (irel+1 < irelend && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	{
	  irel = elf64_alpha_relax_with_lituse (&info, symval, irel, irelend);
	  if (irel == NULL)
	    goto error_return;
	}
      else
	{
	  if (!elf64_alpha_relax_without_lituse (&info, symval, irel))
	    goto error_return;
	}
    }

  if (!elf64_alpha_size_got_sections (abfd, link_info))
    return false;

  if (info.changed_relocs)
    {
      elf_section_data (sec)->relocs = internal_relocs;
    }
  else if (free_relocs != NULL)
    {
      free (free_relocs);
    }

  if (info.changed_contents)
    {
      elf_section_data (sec)->this_hdr.contents = info.contents;
    }
  else if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = info.contents;
	}
    }

  if (free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (free_extsyms);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = extsyms;
	}
    }

  *again = info.changed_contents || info.changed_relocs;

  return true;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  return false;
d869 3
a871 3
#define PLT_ENTRY_WORD1		0xc3800000	/* br   $28, plt0   */
#define PLT_ENTRY_WORD2		0
#define PLT_ENTRY_WORD3		0
d879 1
a879 1
   FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure
d1000 1
a1000 2
/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */
d1002 2
a1003 2
static boolean
elf64_alpha_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
d1005 3
a1007 13
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp;
     asection **secp;
     bfd_vma *valp;
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocateable
      && sym->st_size <= bfd_get_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */
d1009 1
a1009 1
      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");
d1011 6
a1016 9
      if (scomm == NULL)
	{
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
	    return false;
	}
d1018 5
a1022 2
      *secp = scomm;
      *valp = sym->st_size;
d1025 1
a1025 1
  return true;
a1154 1
  memset (debug, 0, sizeof(*debug));
d1471 1
a1471 1
	    h->esym.asym.value = (h->root.plt.offset
a1547 5

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;

a1578 1
		    gotent->use_count = 1;
a1584 2
		else
		  gotent->use_count += 1;
a1620 1
		    gotent->use_count = 1;
a1627 2
		else
		  gotent->use_count += 1;
a1665 2
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
d1760 1
a1760 1
	  else if (info->shared && (sec->flags & SEC_ALLOC))
d1762 1
a1762 2
	      /* If this is a shared library, and the section is to be
		 loaded into memory, we need a RELATIVE reloc.  */
d1815 1
a1815 1
      h->plt.offset = s->_raw_size;
d1822 1
a1822 2
      if (! info->shared
	  && h->root.type != bfd_link_hash_defweak)
d1825 1
a1825 1
	  h->root.u.def.value = h->plt.offset;
a1857 73
/* Symbol versioning can create new symbols, and make our old symbols
   indirect to the new ones.  Consolidate the got and reloc information
   in these situations.  */

static boolean
elf64_alpha_merge_ind_symbols (hi, dummy)
     struct alpha_elf_link_hash_entry *hi;
     PTR dummy;
{
  struct alpha_elf_link_hash_entry *hs;

  if (hi->root.root.type != bfd_link_hash_indirect)
    return true;
  hs = hi;
  do {
    hs = (struct alpha_elf_link_hash_entry *)hs->root.root.u.i.link;
  } while (hs->root.root.type == bfd_link_hash_indirect);

  /* Merge the flags.  Whee.  */

  hs->flags |= hi->flags;

  /* Merge the .got entries.  Cannibalize the old symbol's list in
     doing so, since we don't need it anymore.  */

  if (hs->got_entries == NULL)
    hs->got_entries = hi->got_entries;
  else
    {
      struct alpha_elf_got_entry *gi, *gs, *gin, *gsh;

      gsh = hs->got_entries;
      for (gi = hi->got_entries; gi ; gi = gin)
	{
	  gin = gi->next;
	  for (gs = gsh; gs ; gs = gs->next)
	    if (gi->gotobj == gs->gotobj && gi->addend == gs->addend)
	      goto got_found;
	  gi->next = hs->got_entries;
	  hs->got_entries = gi;
	got_found:;
	}
    }
  hi->got_entries = NULL;

  /* And similar for the reloc entries.  */

  if (hs->reloc_entries == NULL)
    hs->reloc_entries = hi->reloc_entries;
  else
    {
      struct alpha_elf_reloc_entry *ri, *rs, *rin, *rsh;

      rsh = hs->reloc_entries;
      for (ri = hi->reloc_entries; ri ; ri = rin)
	{
	  rin = ri->next;
	  for (rs = rsh; rs ; rs = rs->next)
	    if (ri->rtype == rs->rtype)
	      {
		rs->count += ri->count;
		goto found_reloc;
	      }
	  ri->next = hs->reloc_entries;
	  hs->reloc_entries = ri;
	found_reloc:;
	}
    }
  hi->reloc_entries = NULL;

  return true;
}

a1864 1
  bfd *bsub;
d1877 4
a1880 5
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_link_hash_entry **hashes = alpha_elf_sym_hashes (bsub);
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (bsub)->symtab_hdr;
      int i, n;
d1882 8
a1889 5
      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
	{
	  struct alpha_elf_got_entry *ae, *be;
	  struct alpha_elf_link_hash_entry *h;
d1891 3
a1893 4
	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d1895 6
a1900 17
	  for (be = h->got_entries; be ; be = be->next)
	    {
	      if (be->use_count == 0)
	        continue;
	      if (be->gotobj != b)
	        continue;

	      for (ae = h->got_entries; ae ; ae = ae->next)
	        if (ae->gotobj == a && ae->addend == be->addend)
		  goto global_found;

	      if (++total > MAX_GOT_ENTRIES)
	        return false;
	    global_found:;
	    }
	}
    }
d1911 1
a1911 2
  int total = alpha_elf_tdata (a)->total_got_entries;
  bfd *bsub;
d1915 1
a1915 1
    int e = alpha_elf_tdata (b)->n_local_got_entries;
d1917 1
a1917 1
    alpha_elf_tdata (a)->n_local_got_entries += e;
d1920 17
a1936 19
  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)
    {
      struct alpha_elf_got_entry **local_got_entries;
      struct alpha_elf_link_hash_entry **hashes;
      Elf_Internal_Shdr *symtab_hdr;
      int i, n;

      /* Let the local .got entries know they are part of a new subsegment.  */
      local_got_entries = alpha_elf_tdata (bsub)->local_got_entries;
      if (local_got_entries)
        {
	  n = elf_tdata (bsub)->symtab_hdr.sh_info;
	  for (i = 0; i < n; ++i)
	    {
	      struct alpha_elf_got_entry *ent;
	      for (ent = local_got_entries[i]; ent; ent = ent->next)
	        ent->gotobj = a;
	    }
        }
d1938 5
a1942 9
      /* Merge the global .got entries.  */
      hashes = alpha_elf_sym_hashes (bsub);
      symtab_hdr = &elf_tdata (bsub)->symtab_hdr;

      n = symtab_hdr->sh_size / symtab_hdr->sh_entsize - symtab_hdr->sh_info;
      for (i = 0; i < n; ++i)
        {
	  struct alpha_elf_got_entry *ae, *be, **pbe, **start;
	  struct alpha_elf_link_hash_entry *h;
d1944 9
a1952 4
	  h = hashes[i];
	  while (h->root.root.type == bfd_link_hash_indirect
	         || h->root.root.type == bfd_link_hash_warning)
	    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;
d1954 4
a1957 5
	  start = &h->got_entries;
	  for (pbe = start, be = *start; be ; pbe = &be->next, be = be->next)
	    {
	      if (be->use_count == 0)
	        {
d1959 4
a1962 4
		  continue;
	        }
	      if (be->gotobj != b)
	        continue;
d1964 4
a1967 22
	      for (ae = *start; ae ; ae = ae->next)
	        if (ae->gotobj == a && ae->addend == be->addend)
		  {
		    ae->flags |= be->flags;
		    ae->use_count += be->use_count;
		    *pbe = be->next;
		    goto global_found;
		  }
	      be->gotobj = a;
	      total += 1;

	    global_found:;
	    }
        }

      alpha_elf_tdata (bsub)->gotobj = a;
    }
  alpha_elf_tdata (a)->total_got_entries = total;

  /* Merge the two in_got chains.  */
  {
    bfd *next;
d1969 2
a1970 6
    bsub = a;
    while ((next = alpha_elf_tdata (bsub)->in_got_link_next) != NULL)
      bsub = next;

    alpha_elf_tdata (bsub)->in_got_link_next = b;
  }
d1983 5
a1987 8
    if (gotent->use_count > 0)
      {
	bfd_size_type *plge
	  = &alpha_elf_tdata (gotent->gotobj)->got->_raw_size;

	gotent->got_offset = *plge;
	*plge += 8;
      }
d2025 4
a2028 5
	      if (gotent->use_count > 0)
	        {
		  gotent->got_offset = got_offset;
		  got_offset += 8;
	        }
a2031 1
      alpha_elf_tdata(i)->got->_cooked_size = got_offset;
d2035 16
d2054 1
a2054 1
elf64_alpha_size_got_sections (output_bfd, info)
d2058 2
a2059 2
  bfd *i, *got_list, *cur_got_obj;
  int something_changed = 0;
d2061 2
a2062 1
  got_list = alpha_elf_hash_table (info)->got_list;
d2064 5
a2068 3
  /* On the first time through, pretend we have an existing got list
     consisting of all of the input files.  */
  if (got_list == NULL)
d2070 7
a2076 1
      for (i = info->input_bfds; i ; i = i->link_next)
d2078 7
a2084 3
	  bfd *this_got = alpha_elf_tdata (i)->gotobj;
	  if (this_got == NULL)
	    continue;
d2086 3
a2088 4
	  /* We are assuming no merging has yet ocurred.  */
	  BFD_ASSERT (this_got == i);

          if (alpha_elf_tdata (this_got)->total_got_entries > MAX_GOT_ENTRIES)
d2090 2
a2091 6
	      /* Yikes! A single object file has too many entries.  */
	      (*_bfd_error_handler)
	        (_("%s: .got subsegment exceeds 64K (size %d)"),
	         bfd_get_filename (i),
	         alpha_elf_tdata (this_got)->total_got_entries * 8);
	      return false;
a2092 3

	  if (got_list == NULL)
	    got_list = this_got;
d2094 12
a2105 24
	    alpha_elf_tdata(cur_got_obj)->got_link_next = this_got;
	  cur_got_obj = this_got;
	}

      /* Strange degenerate case of no got references.  */
      if (got_list == NULL)
	return true;

      alpha_elf_hash_table (info)->got_list = got_list;

      /* Force got offsets to be recalculated.  */
      something_changed = 1;
    }

  cur_got_obj = got_list;
  i = alpha_elf_tdata(cur_got_obj)->got_link_next;
  while (i != NULL)
    {
      if (elf64_alpha_can_merge_gots (cur_got_obj, i))
	{
	  elf64_alpha_merge_gots (cur_got_obj, i);
	  i = alpha_elf_tdata(i)->got_link_next;
	  alpha_elf_tdata(cur_got_obj)->got_link_next = i;
	  something_changed = 1;
d2109 1
a2110 1
	  i = alpha_elf_tdata(i)->got_link_next;
d2112 1
d2115 3
a2117 22
  /* Once the gots have been merged, fill in the got offsets for
     everything therein.  */
  if (1 || something_changed)
    elf64_alpha_calc_got_offsets (info);

  return true;
}

static boolean
elf64_alpha_always_size_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *i;

  if (info->relocateable)
    return true;

  /* First, take care of the indirect symbols created by versioning.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_merge_ind_symbols,
				NULL);
d2119 3
a2121 2
  if (!elf64_alpha_size_got_sections (output_bfd, info))
    return false;
d2124 1
a2124 2
  i = alpha_elf_hash_table (info)->got_list;
  for ( ; i ; i = alpha_elf_tdata(i)->got_link_next)
d2165 4
a2168 2
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */
d2170 27
a2196 1
  if (alpha_elf_dynamic_symbol_p (&h->root, info) || info->shared)
a2198 4
      bfd *dynobj;
      struct alpha_elf_got_entry *gotent;
      bfd_size_type count;
      asection *srel;
a2206 18

      dynobj = elf_hash_table(info)->dynobj;
      count = 0;

      for (gotent = h->got_entries; gotent ; gotent = gotent->next)
	count++;

      /* If we are using a .plt entry, subtract one, as the first
	 reference uses a .rela.plt entry instead.  */
      if (h->root.plt.offset != MINUS_ONE)
	count--;

      if (count > 0)
	{
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (srel != NULL);
	  srel->_raw_size += sizeof (Elf64_External_Rela) * count;
	}
d2309 1
a2309 2
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
d2327 1
a2327 1
	_bfd_strip_section_from_output (info, s);
d2337 28
d2405 16
a2495 6

	  /* The symbol associated with GPDISP and LITUSE is 
	     immaterial.  Only the addend is significant.  */
	  if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	    continue;

d2572 1
a2572 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d2578 1
a2578 2
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined))))
a2614 1
	    boolean dynamic_symbol;
d2622 14
a2635 1
		dynamic_symbol = alpha_elf_dynamic_symbol_p (&h->root, info);
d2641 2
a2642 7
		dynamic_symbol = false;
	      }

	    BFD_ASSERT(gotent != NULL);

	    while (gotent->gotobj != gotobj || gotent->addend != addend)
	      gotent = gotent->next;
d2644 1
a2644 12
	    BFD_ASSERT(gotent->use_count >= 1);

	    /* Initialize the .got entry's value.  */
	    if (!(gotent->flags & ALPHA_ELF_GOT_ENTRY_RELOCS_DONE))
	      {
		bfd_put_64 (output_bfd, relocation+addend,
			    sgot->contents + gotent->got_offset);

		/* If the symbol has been forced local, output a
		   RELATIVE reloc, otherwise it will be handled in
		   finish_dynamic_symbol.  */
		if (info->shared && !dynamic_symbol)
d2646 2
a2647 1
		    Elf_Internal_Rela outrel;
d2649 19
a2667 1
		    BFD_ASSERT(srelgot != NULL);
d2669 1
a2669 13
		    outrel.r_offset = (sgot->output_section->vma
				       + sgot->output_offset
				       + gotent->got_offset);
		    outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		    outrel.r_addend = 0;

		    bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					       ((Elf64_External_Rela *)
					        srelgot->contents)
					       + srelgot->reloc_count++);
		    BFD_ASSERT (sizeof(Elf64_External_Rela)
				* srelgot->reloc_count
				<= srelgot->_cooked_size);
a2670 2

		gotent->flags |= ALPHA_ELF_GOT_ENTRY_RELOCS_DONE;
a2683 1
	case R_ALPHA_GPRELLOW:
a2687 9
	case R_ALPHA_GPRELHIGH:
	  BFD_ASSERT(gp != 0);
	  relocation -= gp;
	  relocation += addend;
	  addend = 0;
	  relocation = (((bfd_signed_vma) relocation >> 16)
			+ ((relocation >> 15) & 1));
	  goto default_reloc;

d2711 1
a2711 1
	    else if (info->shared && (input_section->flags & SEC_ALLOC))
a2759 2
	    BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
			<= srel->_cooked_size);
d2819 1
a2819 1
  if (h->plt.offset != MINUS_ONE)
d2847 1
a2847 1
		  + h->plt.offset);
d2849 1
a2849 1
      plt_index = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
d2854 1
d2856 12
a2867 7
	insn1 = PLT_ENTRY_WORD1 | ((-(h->plt.offset + 4) >> 2) & 0x1fffff);
	insn2 = PLT_ENTRY_WORD2;
	insn3 = PLT_ENTRY_WORD3;

	bfd_put_32 (output_bfd, insn1, splt->contents + h->plt.offset);
	bfd_put_32 (output_bfd, insn2, splt->contents + h->plt.offset + 4);
	bfd_put_32 (output_bfd, insn3, splt->contents + h->plt.offset + 8);
d2890 1
a2890 1
      if (gotent->next)
d2892 3
a2894 12
	  srel = bfd_get_section_by_name (dynobj, ".rela.got");
	  BFD_ASSERT (! info->shared || srel != NULL);

	  gotent = gotent->next;
	  do
	    {
	      sgot = alpha_elf_tdata(gotent->gotobj)->got;
	      BFD_ASSERT(sgot != NULL);
	      BFD_ASSERT(gotent->addend == 0);

	      bfd_put_64 (output_bfd, plt_addr,
		          sgot->contents + gotent->got_offset);
d2896 2
a2897 19
	      if (info->shared)
		{
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + gotent->got_offset);
		  outrel.r_info = ELF64_R_INFO(0, R_ALPHA_RELATIVE);
		  outrel.r_addend = 0;

		  bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					     ((Elf64_External_Rela *)
					      srel->contents)
					     + srel->reloc_count++);
		  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
			      <= srel->_cooked_size);
		}

	      gotent = gotent->next;
	    }
          while (gotent != NULL);
a2923 2
	  BFD_ASSERT (sizeof(Elf64_External_Rela) * srel->reloc_count
		      <= srel->_cooked_size);
d3025 38
a3083 9
#if 0
	      if (++ngots == 2)
		{
		  (*info->callbacks->warning)
		    (info, _("using multiple gp values"), (char *) NULL,
		     output_bfd, (asection *) NULL, (bfd_vma) 0);
		}
#endif

d3453 1
a3453 1
		(_("%s: illegal section name `%s'"),
d3736 1
a3736 1
#define ELF_MAXPAGESIZE 	0x10000
d3755 2
a3761 2
#define bfd_elf64_bfd_relax_section \
  elf64_alpha_relax_section
a3762 2
#define elf_backend_add_symbol_hook \
  elf64_alpha_add_symbol_hook
a3790 2
#define elf_backend_got_header_size 0
#define elf_backend_plt_header_size PLT_HEADER_SIZE
@


1.1.1.5
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d3478 1
a3478 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
d3485 1
a3485 2
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->root.other)))))
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d37 1
a37 1
/* Get the ECOFF swapping routines.  Needed for the debug information.  */
d49 1
a49 2
static int alpha_elf_dynamic_symbol_p
  PARAMS((struct elf_link_hash_entry *, struct bfd_link_info *));
a68 2
static boolean elf64_alpha_mkobject
  PARAMS((bfd *));
d132 1
d227 8
a234 40
static int
alpha_elf_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  if (h == NULL)
    return false;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1)
    return false;

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return true;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_DEFAULT:
      break;
    case STV_HIDDEN:
    case STV_INTERNAL:
      return false;
    case STV_PROTECTED:
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
        return false;
      break;
    }

  if ((info->shared && !info->symbolic)
      || ((h->elf_link_hash_flags
	   & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))
	  == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))
    return true;

  return false;
}
d534 1
a534 1
	 true),			/* pcrel_offset */
d549 1
a549 1
	 true),			/* pcrel_offset */
d564 1
a564 1
	 true),			/* pcrel_offset */
d714 1
a714 1
     current section (the relocation target is ignored); the low bits are
d765 1
a765 1
  /* Misc ELF relocations.  */
d835 1
a835 1
     bfd *abfd ATTRIBUTE_UNUSED;
d837 2
a838 2
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d841 1
a841 1
     char **error_message ATTRIBUTE_UNUSED;
d852 1
a852 1
     bfd *abfd ATTRIBUTE_UNUSED;
d854 2
a855 2
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d858 1
a858 1
     char **error_message ATTRIBUTE_UNUSED;
d915 1
a915 1
     asymbol *sym ATTRIBUTE_UNUSED;
d982 1
a982 1
   relocations at the end of processing.  */
d996 1
a996 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1014 1
a1014 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1025 1
a1025 1
/* These functions do relaxation for Alpha ELF.
d1065 1
a1065 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
d1069 1
a1069 1
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
d1128 1
a1128 1
  /* A little preparation for the loop...  */
d1130 2
a1135 3
      int insn_disp;
      bfd_signed_vma xdisp;

a1147 12

	  /* Extract the displacement from the instruction, sign-extending
	     it if necessary, then test whether it is within 16 or 32 bits
	     displacement from GP.  */
	  insn_disp = insn & 0x0000ffff;
	  if (insn_disp & 0x00008000)
	    insn_disp |= 0xffff0000;  /* Negative: sign-extend.  */

	  xdisp = disp + insn_disp;
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x00008000 && xdisp < 0x00008000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000 && xdisp < 0x7fff8000);

d1150 4
a1153 1
	      /* Take the op code and dest from this insn, take the base
d1155 1
a1155 1
	      insn = (insn & 0xffe0ffff) | (lit_insn & 0x001f0000);
d1168 2
a1169 1
	      /* FIXME: sanity check that lit insn Ra is mem insn Rb.  */
d1218 1
a1218 1
		/* Preserve branch prediction call stack when possible.  */
d1223 1
a1223 1

d1237 1
a1237 1
			(info->relocs, info->relend, urel->r_offset,
d1252 1
a1252 1
	       are enabled in gcc.
d1298 1
a1298 1
  if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_NOPV)
d1302 2
a1303 2
     a normal ldgp in the first two words.  */
  else if ((info->other & STO_ALPHA_STD_GPLOAD) == STO_ALPHA_STD_GPLOAD)
d1308 1
a1308 1
  else
d1313 1
a1313 1
      /* Load the relocations from the section that the target symbol is in.  */
d1335 1
a1335 1

d1350 1
a1350 1
  /* We've now determined that we can skip an initial gp load.  Verify
d1411 1
a1411 1
     the calculated GP register would otherwise be ready.
d1463 1
a1463 1
  memset(&info, 0, sizeof (info));
d1546 2
a1547 2
	  else
	    continue;	/* who knows.  */
d1807 2
a1808 2
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
d1843 1
a1843 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1965 1
a1965 1
  memset (debug, 0, sizeof (*debug));
d2046 1
a2046 1
     bfd *abfd ATTRIBUTE_UNUSED;
a2075 6
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return true;

d2542 1
a2542 2
						 ((sec->flags & (SEC_ALLOC
								 | SEC_LOAD))
d2558 1
a2558 1
		 expand the relocation sections by the appropriate amount.  */
d2691 1
a2691 1
     PTR dummy ATTRIBUTE_UNUSED;
d2783 1
a2783 1
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
d2855 1
a2855 1
      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;
d3130 1
a3130 1
	      sizeof (Elf64_External_Rela) * relent->count;
d3205 1
a3205 1
	  srel->_raw_size += count * sizeof (Elf64_External_Rela);
d3308 1
a3308 1
					    sizeof (Elf64_External_Rela)))
a3314 1
	  info->flags |= DF_TEXTREL;
d3397 1
a3397 1
	  /* The symbol associated with GPDISP and LITUSE is
d3520 1
a3520 1
	  abort ();
d3574 1
a3574 1
		    BFD_ASSERT (sizeof (Elf64_External_Rela)
d3679 1
a3679 1
	    BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
d3832 1
a3832 1
		  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
d3865 1
a3865 1
	  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
d4283 1
d4603 1
a4603 1
   from elf32-mips.c.  */
a4645 30
/* Use a non-standard hash bucket size of 8.  */

const struct elf_size_info alpha_elf_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,
  1,
  64, 8,
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  NULL,
  NULL,
  NULL,
  NULL
};

d4649 2
a4650 2
#define ELF_MACHINE_CODE	EM_ALPHA
#define ELF_MAXPAGESIZE	0x10000
d4701 3
a4703 4
#define elf_backend_size_info \
  alpha_elf_size_info

/* A few constants that determine how the .plt section is set up.  */
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 1
a51 1
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d53 1
a53 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d55 1
a55 1
  PARAMS ((bfd *));
d58 1
a58 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d60 1
a60 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d62 1
a62 1
  PARAMS ((bfd *, bfd_vma, bfd_byte *, bfd_byte *));
d64 1
a64 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d67 1
a67 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d69 1
a69 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d71 20
a90 22
static bfd_boolean elf64_alpha_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_object_p
  PARAMS ((bfd *));
static bfd_boolean elf64_alpha_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elf64_alpha_section_flags
  PARAMS ((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elf64_alpha_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static bfd_boolean elf64_alpha_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf64_alpha_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
static bfd_boolean elf64_alpha_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean elf64_alpha_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d96 2
a97 2
static bfd_boolean elf64_alpha_output_extsym
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
d99 2
a100 2
static bfd_boolean elf64_alpha_can_merge_gots
  PARAMS ((bfd *, bfd *));
d102 2
a103 2
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf64_alpha_calc_got_offsets_for_symbol
d105 4
a108 9
static void elf64_alpha_calc_got_offsets
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_got_sections
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_plt_section_1
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
static bfd_boolean elf64_alpha_always_size_sections
d110 1
a110 3
static int alpha_dynamic_entries_for_reloc
  PARAMS ((int, int, int));
static bfd_boolean elf64_alpha_calc_dynrel_sizes
d112 1
a112 5
static bfd_boolean elf64_alpha_size_rela_got_section
  PARAMS ((struct bfd_link_info *));
static bfd_boolean elf64_alpha_size_rela_got_1
  PARAMS ((struct alpha_elf_link_hash_entry *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_add_symbol_hook
d115 2
a116 5
static struct alpha_elf_got_entry *get_got_entry
  PARAMS ((bfd *, struct alpha_elf_link_hash_entry *, unsigned long,
	   unsigned long, bfd_vma));
static bfd_boolean elf64_alpha_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
d118 6
a123 12
static bfd_boolean elf64_alpha_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf64_alpha_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void elf64_alpha_emit_dynrel
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *,
	   bfd_vma, long, long, bfd_vma));
static bfd_boolean elf64_alpha_relocate_section_r
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
d125 9
a133 9
static bfd_boolean elf64_alpha_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf64_alpha_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_alpha_merge_ind_symbols
  PARAMS ((struct alpha_elf_link_hash_entry *, PTR));
a135 2
static enum elf_reloc_type_class elf64_alpha_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d147 5
a151 14
  /* Contexts in which a literal was referenced.  */
#define ALPHA_ELF_LINK_HASH_LU_ADDR	0x01
#define ALPHA_ELF_LINK_HASH_LU_MEM	0x02
#define ALPHA_ELF_LINK_HASH_LU_BYTE	0x04
#define ALPHA_ELF_LINK_HASH_LU_JSR	0x08
#define ALPHA_ELF_LINK_HASH_LU_TLSGD	0x10
#define ALPHA_ELF_LINK_HASH_LU_TLSLDM	0x20
#define ALPHA_ELF_LINK_HASH_LU_FUNC	0x38
#define ALPHA_ELF_LINK_HASH_TLS_IE	0x40
#define ALPHA_ELF_LINK_HASH_PLT_LOC	0x80

  /* Used to undo the localization of a plt symbol.  */
  asection *plt_old_section;
  bfd_vma plt_old_value;
d158 1
a158 1
    /* Which .got subsection?  */
d161 1
a161 1
    /* The addend in effect for this entry.  */
d164 1
a164 1
    /* The .got offset for this entry.  */
d167 1
a167 5
    /* How many references to this entry?  */
    int use_count;

    /* The relocation type of this entry.  */
    unsigned char reloc_type;
d169 2
a170 2
    /* How a LITERAL is used.  */
    unsigned char flags;
d172 1
a172 5
    /* Have we initialized the dynamic relocation for this entry?  */
    unsigned char reloc_done;

    /* Have we adjusted this entry for SEC_MERGE?  */
    unsigned char reloc_xlated;
d175 1
a175 1
  /* Used to count non-got, non-plt relocations for delayed sizing
d181 1
a181 1
    /* Which .reloc section? */
d184 2
a185 5
    /* What kind of relocation? */
    unsigned int rtype;

    /* Is this against read-only section? */
    unsigned int reltext : 1;
d187 1
a187 1
    /* How many did we find?  */
d215 1
a215 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d236 1
a236 1
    return FALSE;
d243 1
a243 1
    return FALSE;
d247 1
a247 1
    return TRUE;
d255 1
a255 1
      return FALSE;
d258 1
a258 1
        return FALSE;
d264 1
a264 3
	   & (ELF_LINK_HASH_DEF_DYNAMIC
	      | ELF_LINK_HASH_DEF_REGULAR
	      | ELF_LINK_HASH_REF_REGULAR))
d266 1
a266 1
    return TRUE;
d268 1
a268 1
  return FALSE;
a316 1
  bfd_size_type amt = sizeof (struct alpha_elf_link_hash_table);
d318 2
a319 1
  ret = (struct alpha_elf_link_hash_table *) bfd_zmalloc (amt);
d326 1
a326 1
      free (ret);
d356 2
a357 2
  /* For every got, this is it's total number of words.  */
  int total_got_size;
d359 1
a359 1
  /* For every got, this is the sum of the number of words required
d361 1
a361 1
  int local_got_size;
d367 1
a367 1
static bfd_boolean
d371 1
a371 2
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d373 2
a374 2
    return FALSE;
  return TRUE;
d377 1
a377 1
static bfd_boolean
d383 1
a383 2
  bfd_size_type amt = sizeof (struct alpha_elf_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
d385 1
a385 1
    return FALSE;
a396 3
#define SKIP_HOWTO(N) \
  HOWTO(N, 0, 0, 0, 0, 0, 0, elf64_alpha_reloc_bad, 0, 0, 0, 0, 0)

d403 1
a403 1
	 TRUE,			/* pc_relative */
d408 1
a408 1
	 FALSE,			/* partial_inplace */
d411 1
a411 1
	 TRUE),			/* pcrel_offset */
d418 1
a418 1
	 FALSE,			/* pc_relative */
d423 1
a423 1
	 FALSE,			/* partial_inplace */
d426 1
a426 1
	 FALSE),		/* pcrel_offset */
d433 1
a433 1
	 FALSE,			/* pc_relative */
d438 1
a438 1
	 FALSE,			/* partial_inplace */
d441 1
a441 1
	 FALSE),		/* pcrel_offset */
d450 1
a450 1
	 FALSE,			/* pc_relative */
d455 1
a455 1
	 FALSE,			/* partial_inplace */
d458 1
a458 1
	 FALSE),		/* pcrel_offset */
d463 1
a463 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d465 1
a465 1
	 FALSE,			/* pc_relative */
d470 1
a470 1
	 FALSE,			/* partial_inplace */
d473 1
a473 1
	 FALSE),		/* pcrel_offset */
d484 1
a484 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d486 1
a486 1
	 FALSE,			/* pc_relative */
d491 1
a491 1
	 FALSE,			/* partial_inplace */
d494 1
a494 1
	 FALSE),		/* pcrel_offset */
d516 1
a516 1
	 FALSE,			/* pc_relative */
d521 1
a521 1
	 FALSE,			/* partial_inplace */
d524 1
a524 1
	 TRUE),			/* pcrel_offset */
d531 1
a531 1
	 TRUE,			/* pc_relative */
d536 1
a536 1
	 FALSE,			/* partial_inplace */
d539 1
a539 1
	 TRUE),			/* pcrel_offset */
d544 1
a544 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d546 1
a546 1
	 TRUE,			/* pc_relative */
d551 1
a551 1
	 FALSE,			/* partial_inplace */
d554 1
a554 1
	 TRUE),			/* pcrel_offset */
d561 1
a561 1
	 TRUE,			/* pc_relative */
d566 1
a566 1
	 FALSE,			/* partial_inplace */
d569 1
a569 1
	 TRUE),			/* pcrel_offset */
d576 1
a576 1
	 TRUE,			/* pc_relative */
d581 1
a581 1
	 FALSE,			/* partial_inplace */
d584 1
a584 1
	 TRUE),			/* pcrel_offset */
d591 1
a591 1
	 TRUE,			/* pc_relative */
d596 1
a596 1
	 FALSE,			/* partial_inplace */
d599 68
a666 1
	 TRUE),			/* pcrel_offset */
d668 16
a683 6
  /* Skip 12 - 16; deprecated ECOFF relocs.  */
  SKIP_HOWTO (12),
  SKIP_HOWTO (13),
  SKIP_HOWTO (14),
  SKIP_HOWTO (15),
  SKIP_HOWTO (16),
d688 1
a688 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d690 1
a690 1
	 FALSE,			/* pc_relative */
d693 1
a693 1
	 0,			/* special_function */
d695 1
a695 1
	 FALSE,			/* partial_inplace */
d698 1
a698 1
	 FALSE),		/* pcrel_offset */
d703 1
a703 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d705 1
a705 1
	 FALSE,			/* pc_relative */
d708 1
a708 1
	 0,			/* special_function */
d710 1
a710 1
	 FALSE,			/* partial_inplace */
d713 1
a713 1
	 FALSE),		/* pcrel_offset */
d716 2
a717 1
  HOWTO (R_ALPHA_GPREL16,
d719 1
a719 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d721 1
a721 1
	 FALSE,			/* pc_relative */
d725 2
a726 2
	 "GPREL16",		/* name */
	 FALSE,			/* partial_inplace */
d729 36
a764 1
	 FALSE),		/* pcrel_offset */
d766 33
a798 5
  /* Skip 20 - 23; deprecated ECOFF relocs.  */
  SKIP_HOWTO (20),
  SKIP_HOWTO (21),
  SKIP_HOWTO (22),
  SKIP_HOWTO (23),
d810 1
a810 1
	 FALSE,
d815 1
a815 1
	 FALSE,
d818 1
a818 1
	 TRUE),
d825 1
a825 1
	 FALSE,
d830 1
a830 1
	 FALSE,
d833 1
a833 1
	 TRUE),
d840 1
a840 1
	 FALSE,
d845 1
a845 1
	 FALSE,
d848 1
a848 1
	 TRUE),
d855 1
a855 1
	 FALSE,
d860 1
a860 1
	 FALSE,
d863 1
a863 213
	 TRUE),

  /* A 21 bit branch that adjusts for gp loads.  */
  HOWTO (R_ALPHA_BRSGP,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "BRSGP",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Creates a tls_index for the symbol in the got.  */
  HOWTO (R_ALPHA_TLSGD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSGD",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a tls_index for the (current) module in the got.  */
  HOWTO (R_ALPHA_TLSLDM,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TLSLDM",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a DTP module entry.  */
  HOWTO (R_ALPHA_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPMOD64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from DTP to the target.  */
  HOWTO (R_ALPHA_GOTDTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTDTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from DTP to the target.  */
  HOWTO (R_ALPHA_DTPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DTPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Creates a 64-bit offset in the got for the displacement
     from TP to the target.  */
  HOWTO (R_ALPHA_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "GOTTPREL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A dynamic relocation for a displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL64",		/* name */
	 FALSE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of the displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPRELLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPRELLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit displacement from TP to the target.  */
  HOWTO (R_ALPHA_TPREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "TPREL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d937 2
a938 2
  bfd_put_32 (abfd, (bfd_vma) i_ldah, p_ldah);
  bfd_put_32 (abfd, (bfd_vma) i_lda, p_lda);
d1001 24
a1024 30
  {BFD_RELOC_NONE,			R_ALPHA_NONE},
  {BFD_RELOC_32,			R_ALPHA_REFLONG},
  {BFD_RELOC_64,			R_ALPHA_REFQUAD},
  {BFD_RELOC_CTOR,			R_ALPHA_REFQUAD},
  {BFD_RELOC_GPREL32,			R_ALPHA_GPREL32},
  {BFD_RELOC_ALPHA_ELF_LITERAL,		R_ALPHA_LITERAL},
  {BFD_RELOC_ALPHA_LITUSE,		R_ALPHA_LITUSE},
  {BFD_RELOC_ALPHA_GPDISP,		R_ALPHA_GPDISP},
  {BFD_RELOC_23_PCREL_S2,		R_ALPHA_BRADDR},
  {BFD_RELOC_ALPHA_HINT,		R_ALPHA_HINT},
  {BFD_RELOC_16_PCREL,			R_ALPHA_SREL16},
  {BFD_RELOC_32_PCREL,			R_ALPHA_SREL32},
  {BFD_RELOC_64_PCREL,			R_ALPHA_SREL64},
  {BFD_RELOC_ALPHA_GPREL_HI16,		R_ALPHA_GPRELHIGH},
  {BFD_RELOC_ALPHA_GPREL_LO16,		R_ALPHA_GPRELLOW},
  {BFD_RELOC_GPREL16,			R_ALPHA_GPREL16},
  {BFD_RELOC_ALPHA_BRSGP,		R_ALPHA_BRSGP},
  {BFD_RELOC_ALPHA_TLSGD,		R_ALPHA_TLSGD},
  {BFD_RELOC_ALPHA_TLSLDM,		R_ALPHA_TLSLDM},
  {BFD_RELOC_ALPHA_DTPMOD64,		R_ALPHA_DTPMOD64},
  {BFD_RELOC_ALPHA_GOTDTPREL16,		R_ALPHA_GOTDTPREL},
  {BFD_RELOC_ALPHA_DTPREL64,		R_ALPHA_DTPREL64},
  {BFD_RELOC_ALPHA_DTPREL_HI16,		R_ALPHA_DTPRELHI},
  {BFD_RELOC_ALPHA_DTPREL_LO16,		R_ALPHA_DTPRELLO},
  {BFD_RELOC_ALPHA_DTPREL16,		R_ALPHA_DTPREL16},
  {BFD_RELOC_ALPHA_GOTTPREL16,		R_ALPHA_GOTTPREL},
  {BFD_RELOC_ALPHA_TPREL64,		R_ALPHA_TPREL64},
  {BFD_RELOC_ALPHA_TPREL_HI16,		R_ALPHA_TPRELHI},
  {BFD_RELOC_ALPHA_TPREL_LO16,		R_ALPHA_TPRELLO},
  {BFD_RELOC_ALPHA_TPREL16,		R_ALPHA_TPREL16},
d1051 1
a1051 1
     Elf_Internal_Rela *dst;
a1058 13

/* These two relocations create a two-word entry in the got.  */
#define alpha_got_entry_size(r_type) \
  (r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)

/* This is PT_TLS segment p_vaddr.  */
#define alpha_get_dtprel_base(tlss) \
  ((tlss)->start)

/* Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */
#define alpha_get_tprel_base(tlss) \
  ((tlss)->start - align_power ((bfd_vma) 16, (tlss)->align))
d1080 1
a1080 3
#define INSN_UNOP	0x2ffe0000
#define INSN_ADDQ	0x40000400
#define INSN_RDUNIQ	0x0000009e
a1086 1
  Elf_Internal_Shdr *symtab_hdr;
d1089 2
a1090 1
  struct elf_link_tls_segment *tls_segment;
a1094 1
  struct alpha_elf_got_entry **first_gotent;
a1095 2
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
d1099 5
a1103 1
static bfd_boolean elf64_alpha_relax_with_lituse
d1106 1
d1109 2
a1110 12
static bfd_boolean elf64_alpha_relax_got_load
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, unsigned long));
static bfd_boolean elf64_alpha_relax_gprelhilo
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static bfd_boolean elf64_alpha_relax_tls_get_addr
  PARAMS((struct alpha_relax_info *info, bfd_vma symval,
          Elf_Internal_Rela *irel, bfd_boolean));
static struct elf_link_tls_segment *elf64_alpha_relax_find_tls_segment
  PARAMS((struct alpha_relax_info *, struct elf_link_tls_segment *));
static bfd_boolean elf64_alpha_relax_section
d1112 1
a1112 1
	  bfd_boolean *again));
d1122 1
a1122 2
      if (rel->r_offset == offset
	  && ELF64_R_TYPE (rel->r_info) == (unsigned int) type)
d1129 2
a1130 2
static bfd_boolean
elf64_alpha_relax_with_lituse (info, symval, irel)
d1133 1
a1133 1
     Elf_Internal_Rela *irel;
d1135 1
a1135 1
  Elf_Internal_Rela *urel, *irelend = info->relend;
d1138 4
a1141 4
  bfd_boolean fits16;
  bfd_boolean fits32;
  bfd_boolean lit_reused = FALSE;
  bfd_boolean all_optimized = TRUE;
d1149 3
a1151 3
	bfd_archive_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset));
      return TRUE;
a1153 4
  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

d1159 1
a1159 1
      if (urel->r_addend <= 3)
d1176 1
a1176 2
	case LITUSE_ALPHA_ADDR:
	default:
d1179 1
a1179 1
	  all_optimized = FALSE;
d1182 1
a1182 1
	case LITUSE_ALPHA_BASE:
d1189 2
a1190 2
	  if (insn_disp & 0x8000)
	    insn_disp |= ~0xffff;  /* Negative: sign-extend.  */
d1193 2
a1194 3
	  fits16 = (xdisp >= - (bfd_signed_vma) 0x8000 && xdisp < 0x8000);
	  fits32 = (xdisp >= - (bfd_signed_vma) 0x80000000
		    && xdisp < 0x7fff8000);
d1202 1
a1202 1
					   R_ALPHA_GPREL16);
d1204 1
a1204 1
	      info->changed_relocs = TRUE;
d1206 2
a1207 3
	      bfd_put_32 (info->abfd, (bfd_vma) insn,
			  info->contents + urel->r_offset);
	      info->changed_contents = TRUE;
d1218 1
a1218 1
	      bfd_put_32 (info->abfd, (bfd_vma) lit_insn,
d1220 2
a1221 2
	      lit_reused = TRUE;
	      info->changed_contents = TRUE;
d1226 1
a1226 1
	      info->changed_relocs = TRUE;
d1229 1
a1229 1
	    all_optimized = FALSE;
d1232 1
a1232 1
	case LITUSE_ALPHA_BYTOFF:
d1238 1
a1238 2
	  insn &= ~ (unsigned) 0x001ff000;
	  insn |= ((symval & 7) << 13) | 0x1000;
d1242 1
a1242 1
	  info->changed_relocs = TRUE;
d1244 2
a1245 3
	  bfd_put_32 (info->abfd, (bfd_vma) insn,
		      info->contents + urel->r_offset);
	  info->changed_contents = TRUE;
d1248 1
a1248 3
	case LITUSE_ALPHA_JSR:
	case LITUSE_ALPHA_TLSGD:
	case LITUSE_ALPHA_TLSLDM:
d1250 5
a1254 1
	    bfd_vma optdest, org;
a1256 5
	    /* If not zero, place to jump without needing pv.  */
	    optdest = elf64_alpha_relax_opt_call (info, symval);
	    org = (info->sec->output_section->vma
		   + info->sec->output_offset
		   + urel->r_offset + 4);
a1257 1

d1275 1
a1275 1
		  all_optimized = FALSE;
d1277 1
a1277 2
		bfd_put_32 (info->abfd, (bfd_vma) insn,
			    info->contents + urel->r_offset);
d1286 2
a1287 2
		info->changed_contents = TRUE;
		info->changed_relocs = TRUE;
d1290 7
a1296 1
	      all_optimized = FALSE;
d1298 2
a1299 31
	    /* Even if the target is not in range for a direct branch,
	       if we share a GP, we can eliminate the gp reload.  */
	    if (optdest)
	      {
		Elf_Internal_Rela *gpdisp
		  = (elf64_alpha_find_reloc_at_ofs
		     (info->relocs, irelend, urel->r_offset + 4,
		      R_ALPHA_GPDISP));
		if (gpdisp)
		  {
		    bfd_byte *p_ldah = info->contents + gpdisp->r_offset;
		    bfd_byte *p_lda = p_ldah + gpdisp->r_addend;
		    unsigned int ldah = bfd_get_32 (info->abfd, p_ldah);
		    unsigned int lda = bfd_get_32 (info->abfd, p_lda);

		    /* Verify that the instruction is "ldah $29,0($26)".
		       Consider a function that ends in a noreturn call,
		       and that the next function begins with an ldgp,
		       and that by accident there is no padding between.
		       In that case the insn would use $27 as the base.  */
		    if (ldah == 0x27ba0000 && lda == 0x23bd0000)
		      {
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_ldah);
			bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, p_lda);

			gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
			info->changed_contents = TRUE;
			info->changed_relocs = TRUE;
		      }
		  }
	      }
d1309 4
a1312 7
      if (--info->gotent->use_count == 0)
	{
	  int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	  alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
	  if (!info->h)
	    alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
	}
d1315 2
a1316 2
	 reused.  We can eliminate it.  */
      /* ??? For now, I don't want to deal with compacting the section,
d1321 1
a1321 1
	  info->changed_relocs = TRUE;
d1323 2
a1324 3
	  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP,
		      info->contents + irel->r_offset);
	  info->changed_contents = TRUE;
d1328 1
a1328 1
  return TRUE;
d1403 2
a1404 2
static bfd_boolean
elf64_alpha_relax_got_load (info, symval, irel, r_type)
a1407 1
     unsigned long r_type;
a1416 1
      reloc_howto_type *howto = elf64_alpha_howto_table + r_type;
d1418 5
a1422 13
       ("%s: %s+0x%lx: warning: %s relocation against unexpected insn",
	bfd_archive_filename (info->abfd), info->sec->name,
	(unsigned long) irel->r_offset, howto->name));
      return TRUE;
    }

  /* Can't relax dynamic symbols.  */
  if (alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info))
    return TRUE;

  /* Can't use local-exec relocations in shared libraries.  */
  if (r_type == R_ALPHA_GOTTPREL && info->link_info->shared)
    return TRUE;
d1424 7
a1430 5
  if (r_type == R_ALPHA_LITERAL)
    disp = symval - info->gp;
  else
    {
      bfd_vma dtp_base, tp_base;
d1432 2
a1433 5
      BFD_ASSERT (info->tls_segment != NULL);
      dtp_base = alpha_get_dtprel_base (info->tls_segment);
      tp_base = alpha_get_tprel_base (info->tls_segment);
      disp = symval - (r_type == R_ALPHA_GOTDTPREL ? dtp_base : tp_base);
    }
d1435 3
a1437 2
  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;
d1439 2
a1440 8
  /* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading
     a constant, so force the base register to be $31.  */
  if (r_type == R_ALPHA_LITERAL)
    insn = (OP_LDA << 26) | (insn & 0x03ff0000);
  else
    insn = (OP_LDA << 26) | (insn & (31 << 21)) | (31 << 16);
  bfd_put_32 (info->abfd, (bfd_vma) insn, info->contents + irel->r_offset);
  info->changed_contents = TRUE;
d1444 4
a1447 27
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (r_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* Smash the existing GOT relocation for its 16-bit immediate pair.  */
  switch (r_type)
    {
    case R_ALPHA_LITERAL:
      r_type = R_ALPHA_GPREL16;
      break;
    case R_ALPHA_GOTDTPREL:
      r_type = R_ALPHA_DTPREL16;
      break;
    case R_ALPHA_GOTTPREL:
      r_type = R_ALPHA_TPREL16;
      break;
    default:
      BFD_ASSERT (0);
      return FALSE;
    }

  irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info), r_type);
  info->changed_relocs = TRUE;
d1462 1
a1462 347
  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_gprelhilo (info, symval, irel, hi)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean hi;
{
  unsigned int insn;
  bfd_signed_vma disp;
  bfd_byte *pos = info->contents + irel->r_offset;

  /* ??? This assumes that the compiler doesn't render

	array[i]
     as
	ldah	t, array(gp)	!gprelhigh
	s8addl	i, t, t
	ldq	r, array(t)	!gprellow

     which would indeed be the most efficient way to implement this.  */

  return TRUE;

  disp = symval - info->gp;
  if (disp < -0x8000 || disp >= 0x8000)
    return TRUE;

  if (hi)
    {
      /* Nop out the high instruction.  */

      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos);
      info->changed_contents = TRUE;

      irel->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      irel->r_addend = 0;
      info->changed_relocs = TRUE;
    }
  else
    {
      /* Adjust the low instruction to reference GP directly.  */

      insn = bfd_get_32 (info->abfd, pos);
      insn = (insn & 0xffe00000) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos);
      info->changed_contents = TRUE;

      irel->r_info = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				   R_ALPHA_GPREL16);
      info->changed_relocs = TRUE;
    }

  return TRUE;
}

static bfd_boolean
elf64_alpha_relax_tls_get_addr (info, symval, irel, is_gd)
     struct alpha_relax_info *info;
     bfd_vma symval;
     Elf_Internal_Rela *irel;
     bfd_boolean is_gd;
{
  bfd_byte *pos[5];
  unsigned int insn;
  Elf_Internal_Rela *gpdisp, *hint;
  bfd_boolean dynamic, use_gottprel, pos1_unusable;
  unsigned long new_symndx;

  dynamic = alpha_elf_dynamic_symbol_p (&info->h->root, info->link_info);

  /* If a TLS symbol is accessed using IE at least once, there is no point
     to use dynamic model for it.  */
  if (is_gd && info->h && (info->h->flags & ALPHA_ELF_LINK_HASH_TLS_IE))
    ;

  /* If the symbol is local, and we've already committed to DF_STATIC_TLS,
     then we might as well relax to IE.  */
  else if (info->link_info->shared && !dynamic
	   && (info->link_info->flags & DF_STATIC_TLS))
    ;

  /* Otherwise we must be building an executable to do anything.  */
  else if (info->link_info->shared)
    return TRUE;

  /* The TLSGD/TLSLDM relocation must be followed by a LITERAL and
     the matching LITUSE_TLS relocations.  */
  if (irel + 2 >= info->relend)
    return TRUE;
  if (ELF64_R_TYPE (irel[1].r_info) != R_ALPHA_LITERAL
      || ELF64_R_TYPE (irel[2].r_info) != R_ALPHA_LITUSE
      || irel[2].r_addend != (is_gd ? LITUSE_ALPHA_TLSGD : LITUSE_ALPHA_TLSLDM))
    return TRUE;

  /* There must be a GPDISP relocation positioned immediately after the
     LITUSE relocation.  */
  gpdisp = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					  irel[2].r_offset + 4, R_ALPHA_GPDISP);
  if (!gpdisp)
    return TRUE;

  pos[0] = info->contents + irel[0].r_offset;
  pos[1] = info->contents + irel[1].r_offset;
  pos[2] = info->contents + irel[2].r_offset;
  pos[3] = info->contents + gpdisp->r_offset;
  pos[4] = pos[3] + gpdisp->r_addend;
  pos1_unusable = FALSE;

  /* Generally, the positions are not allowed to be out of order, lest the
     modified insn sequence have different register lifetimes.  We can make
     an exception when pos 1 is adjacent to pos 0.  */
  if (pos[1] + 4 == pos[0])
    {
      bfd_byte *tmp = pos[0];
      pos[0] = pos[1];
      pos[1] = tmp;
    }
  else if (pos[1] < pos[0])
    pos1_unusable = TRUE;
  if (pos[1] >= pos[2] || pos[2] >= pos[3])
    return TRUE;

  /* Reduce the use count on the LITERAL relocation.  Do this before we
     smash the symndx when we adjust the relocations below.  */
  {
    struct alpha_elf_got_entry *lit_gotent;
    struct alpha_elf_link_hash_entry *lit_h;
    unsigned long indx;

    BFD_ASSERT (ELF64_R_SYM (irel[1].r_info) >= info->symtab_hdr->sh_info);
    indx = ELF64_R_SYM (irel[1].r_info) - info->symtab_hdr->sh_info;
    lit_h = alpha_elf_sym_hashes (info->abfd)[indx];

    while (lit_h->root.root.type == bfd_link_hash_indirect
	   || lit_h->root.root.type == bfd_link_hash_warning)
      lit_h = (struct alpha_elf_link_hash_entry *) lit_h->root.root.u.i.link;

    for (lit_gotent = lit_h->got_entries; lit_gotent ;
	 lit_gotent = lit_gotent->next)
      if (lit_gotent->gotobj == info->gotobj
	  && lit_gotent->reloc_type == R_ALPHA_LITERAL
	  && lit_gotent->addend == irel[1].r_addend)
	break;
    BFD_ASSERT (lit_gotent);

    if (--lit_gotent->use_count == 0)
      {
	int sz = alpha_got_entry_size (R_ALPHA_LITERAL);
	alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      }
  }

  /* Change

	lda	$16,x($gp)		!tlsgd!1
	ldq	$27,__tls_get_addr($gp)	!literal!1
	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1
	ldah	$29,0($26)		!gpdisp!2
	lda	$29,0($29)		!gpdisp!2
     to
	ldq	$16,x($gp)		!gottprel
	unop
	call_pal rduniq
	addq	$16,$0,$0
	unop
     or the first pair to
	lda	$16,x($gp)		!tprel
	unop
     or
	ldah	$16,x($gp)		!tprelhi
	lda	$16,x($16)		!tprello

     as appropriate.  */

  use_gottprel = FALSE;
  new_symndx = is_gd ? ELF64_R_SYM (irel->r_info) : 0;
  switch (!dynamic && !info->link_info->shared)
    {
    case 1:
      {
	bfd_vma tp_base;
	bfd_signed_vma disp;

	BFD_ASSERT (info->tls_segment != NULL);
	tp_base = alpha_get_tprel_base (info->tls_segment);
	disp = symval - tp_base;

	if (disp >= -0x8000 && disp < 0x8000)
	  {
	    insn = (OP_LDA << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPREL16);
	    irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
	    break;
	  }
	else if (disp >= -(bfd_signed_vma) 0x80000000
		 && disp < (bfd_signed_vma) 0x7fff8000
		 && !pos1_unusable)
	  {
	    insn = (OP_LDAH << 26) | (16 << 21) | (31 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
	    insn = (OP_LDA << 26) | (16 << 21) | (16 << 16);
	    bfd_put_32 (info->abfd, (bfd_vma) insn, pos[1]);

	    irel[0].r_offset = pos[0] - info->contents;
	    irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELHI);
	    irel[1].r_offset = pos[1] - info->contents;
	    irel[1].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_TPRELLO);
	    break;
	  }
      }
      /* FALLTHRU */

    default:
      use_gottprel = TRUE;

      insn = (OP_LDQ << 26) | (16 << 21) | (29 << 16);
      bfd_put_32 (info->abfd, (bfd_vma) insn, pos[0]);
      bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[1]);

      irel[0].r_offset = pos[0] - info->contents;
      irel[0].r_info = ELF64_R_INFO (new_symndx, R_ALPHA_GOTTPREL);
      irel[1].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
      break;
    }

  bfd_put_32 (info->abfd, (bfd_vma) INSN_RDUNIQ, pos[2]);

  insn = INSN_ADDQ | (16 << 21) | (0 << 16) | (0 << 0);
  bfd_put_32 (info->abfd, (bfd_vma) insn, pos[3]);

  bfd_put_32 (info->abfd, (bfd_vma) INSN_UNOP, pos[4]);

  irel[2].r_info = ELF64_R_INFO (0, R_ALPHA_NONE);
  gpdisp->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  hint = elf64_alpha_find_reloc_at_ofs (info->relocs, info->relend,
					irel[2].r_offset, R_ALPHA_HINT);
  if (hint)
    hint->r_info = ELF64_R_INFO (0, R_ALPHA_NONE);

  info->changed_contents = TRUE;
  info->changed_relocs = TRUE;

  /* Reduce the use count on the TLSGD/TLSLDM relocation.  */
  if (--info->gotent->use_count == 0)
    {
      int sz = alpha_got_entry_size (info->gotent->reloc_type);
      alpha_elf_tdata (info->gotobj)->total_got_size -= sz;
      if (!info->h)
	alpha_elf_tdata (info->gotobj)->local_got_size -= sz;
    }

  /* If we've switched to a GOTTPREL relocation, increment the reference
     count on that got entry.  */
  if (use_gottprel)
    {
      struct alpha_elf_got_entry *tprel_gotent;

      for (tprel_gotent = *info->first_gotent; tprel_gotent ;
	   tprel_gotent = tprel_gotent->next)
	if (tprel_gotent->gotobj == info->gotobj
	    && tprel_gotent->reloc_type == R_ALPHA_GOTTPREL
	    && tprel_gotent->addend == irel->r_addend)
	  break;
      if (tprel_gotent)
	tprel_gotent->use_count++;
      else
	{
	  if (info->gotent->use_count == 0)
	    tprel_gotent = info->gotent;
	  else
	    {
	      tprel_gotent = (struct alpha_elf_got_entry *)
		bfd_alloc (info->abfd, sizeof (struct alpha_elf_got_entry));
	      if (!tprel_gotent)
		return FALSE;

	      tprel_gotent->next = *info->first_gotent;
	      *info->first_gotent = tprel_gotent;

	      tprel_gotent->gotobj = info->gotobj;
	      tprel_gotent->addend = irel->r_addend;
	      tprel_gotent->got_offset = -1;
	      tprel_gotent->reloc_done = 0;
	      tprel_gotent->reloc_xlated = 0;
	    }

	  tprel_gotent->use_count = 1;
	  tprel_gotent->reloc_type = R_ALPHA_GOTTPREL;
	}
    }

  return TRUE;
}

static struct elf_link_tls_segment *
elf64_alpha_relax_find_tls_segment (info, seg)
     struct alpha_relax_info *info;
     struct elf_link_tls_segment *seg;
{
  bfd *output_bfd = info->sec->output_section->owner;
  asection *o;
  unsigned int align;
  bfd_vma base, end;

  for (o = output_bfd->sections; o ; o = o->next)
    if ((o->flags & SEC_THREAD_LOCAL) != 0
        && (o->flags & SEC_LOAD) != 0)
      break;
  if (!o)
    return NULL;

  base = o->vma;
  align = 0;

  do
    {
      bfd_vma size;

      if (bfd_get_section_alignment (output_bfd, o) > align)
	align = bfd_get_section_alignment (output_bfd, o);

      size = o->_raw_size;
      if (size == 0 && (o->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *lo;
	  for (lo = o->link_order_head; lo ; lo = lo->next)
	    if (size < lo->offset + lo->size)
	      size = lo->offset + lo->size;
	}
      end = o->vma + size;
      o = o->next;
    }
  while (o && (o->flags & SEC_THREAD_LOCAL));

  seg->start = base;
  seg->size = end - base;
  seg->align = align;

  return seg;
d1465 1
a1465 1
static bfd_boolean
d1470 1
a1470 1
     bfd_boolean *again;
d1474 1
d1476 3
a1478 1
  Elf_Internal_Sym *isymbuf = NULL;
a1480 1
  struct elf_link_tls_segment tls_segment;
d1483 1
a1483 1
  *again = FALSE;
d1488 1
a1488 1
    return TRUE;
d1503 3
a1505 1
    return FALSE;
a1510 1
  info.symtab_hdr = symtab_hdr;
d1514 1
a1514 2
  /* Find the GP for this object.  Do not store the result back via
     _bfd_set_gp_value, since this could change again before final.  */
d1519 8
a1526 17
      info.gp = (sgot->output_section->vma
		 + sgot->output_offset
		 + 0x8000);
    }

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    info.contents = elf_section_data (sec)->this_hdr.contents;
  else
    {
      info.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (info.contents == NULL)
	goto error_return;

      if (! bfd_get_section_contents (abfd, sec, info.contents,
				      (file_ptr) 0, sec->_raw_size))
	goto error_return;
a1528 5
  /* Compute the TLS segment information.  The version normally found in
     elf_hash_table (link_info)->tls_segment isn't built until final_link.
     ??? Probably should look into extracting this into a common function.  */
  info.tls_segment = elf64_alpha_relax_find_tls_segment (&info, &tls_segment);

d1532 1
a1533 2
      unsigned long r_type = ELF64_R_TYPE (irel->r_info);
      unsigned long r_symndx = ELF64_R_SYM (irel->r_info);
d1535 5
a1539 2
      /* Early exit for unhandled or unrelaxable relocations.  */
      switch (r_type)
d1541 8
a1548 7
	case R_ALPHA_LITERAL:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	case R_ALPHA_TLSGD:
	  break;
d1550 4
a1553 8
	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
             reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  break;

	default:
	  continue;
d1556 2
a1557 2
      /* Get the value of the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
d1559 3
a1561 5
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
d1563 8
a1570 6
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
d1573 1
d1575 15
a1589 9
	  isym = isymbuf + r_symndx;

	  /* Given the symbol for a TLSLDM reloc is ignored, this also
	     means forcing the symbol value to the tp base.  */
	  if (r_type == R_ALPHA_TLSLDM)
	    {
	      info.tsec = bfd_abs_section_ptr;
	      symval = alpha_get_tprel_base (info.tls_segment);
	    }
d1591 1
a1591 11
	    {
	      symval = isym->st_value;
	      if (isym->st_shndx == SHN_UNDEF)
	        continue;
	      else if (isym->st_shndx == SHN_ABS)
	        info.tsec = bfd_abs_section_ptr;
	      else if (isym->st_shndx == SHN_COMMON)
	        info.tsec = bfd_com_section_ptr;
	      else
	        info.tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    }
d1594 3
a1596 8
	  info.other = isym->st_other;
	  if (local_got_entries)
	    info.first_gotent = &local_got_entries[r_symndx];
	  else
	    {
	      info.first_gotent = &info.gotent;
	      info.gotent = NULL;
	    }
d1603 1
a1603 1
	  indx = r_symndx - symtab_hdr->sh_info;
d1611 4
a1614 3
	  /* If the symbol is undefined, we can't do anything with it.  */
	  if (h->root.root.type == bfd_link_hash_undefweak
	      || h->root.root.type == bfd_link_hash_undefined)
a1616 17
	  /* If the symbol isn't defined in the current module, again
	     we can't do anything.  */
	  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	    {
	      /* Except for TLSGD relocs, which can sometimes be
		 relaxed to GOTTPREL relocs.  */
	      if (r_type != R_ALPHA_TLSGD)
		continue;
	      info.tsec = bfd_abs_section_ptr;
	      symval = 0;
	    }
	  else
	    {
	      info.tsec = h->root.root.u.def.section;
	      symval = h->root.root.u.def.value;
	    }

d1618 2
d1621 2
a1622 1
	  info.first_gotent = &h->got_entries;
d1626 2
a1627 5
      for (gotent = *info.first_gotent; gotent ; gotent = gotent->next)
	if (gotent->gotobj == info.gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == irel->r_addend)
	  break;
d1633 1
a1633 20
      switch (r_type)
	{
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(info.gotent != NULL);

	  /* If there exist LITUSE relocations immediately following, this
	     opens up all sorts of interesting optimizations, because we
	     now know every location that this address load is used.  */
	  if (irel+1 < irelend
	      && ELF64_R_TYPE (irel[1].r_info) == R_ALPHA_LITUSE)
	    {
	      if (!elf64_alpha_relax_with_lituse (&info, symval, irel))
		goto error_return;
	    }
	  else
	    {
	      if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
		goto error_return;
	    }
	  break;
d1635 3
a1637 6
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	  if (!elf64_alpha_relax_gprelhilo (&info, symval, irel,
					    r_type == R_ALPHA_GPRELHIGH))
	    goto error_return;
	  break;
d1639 4
a1642 4
	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_got_load (&info, symval, irel, r_type))
d1644 4
a1647 7
	  break;

	case R_ALPHA_TLSGD:
	case R_ALPHA_TLSLDM:
	  BFD_ASSERT(info.gotent != NULL);
	  if (!elf64_alpha_relax_tls_get_addr (&info, symval, irel,
					       r_type == R_ALPHA_TLSGD))
a1648 1
	  break;
d1652 2
a1653 6
  if (!elf64_alpha_size_plt_section (link_info))
    return FALSE;
  if (!elf64_alpha_size_got_sections (link_info))
    return FALSE;
  if (!elf64_alpha_size_rela_got_section (link_info))
    return FALSE;
d1655 1
a1655 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1657 5
a1661 7
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
d1664 5
a1668 2
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
d1670 2
a1671 2
      if (!info.changed_contents && !link_info->keep_memory)
	free (info.contents);
d1679 1
a1679 1
  if (elf_section_data (sec)->relocs != internal_relocs)
d1681 2
a1682 2
      if (!info.changed_relocs)
	free (internal_relocs);
d1684 4
a1687 1
	elf_section_data (sec)->relocs = internal_relocs;
d1692 1
a1692 1
  return TRUE;
d1695 7
a1701 10
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (info.contents != NULL
      && elf_section_data (sec)->this_hdr.contents != info.contents)
    free (info.contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
d1706 4
a1709 4
#define PLT_HEADER_WORD1	(bfd_vma) 0xc3600000	/* br   $27,.+4     */
#define PLT_HEADER_WORD2	(bfd_vma) 0xa77b000c	/* ldq  $27,12($27) */
#define PLT_HEADER_WORD3	(bfd_vma) 0x47ff041f	/* nop              */
#define PLT_HEADER_WORD4	(bfd_vma) 0x6b7b0000	/* jmp  $27,($27)   */
d1716 1
a1716 1
#define MAX_GOT_SIZE		(64*1024)
d1725 1
a1725 1
static bfd_boolean
d1728 2
a1729 2
     Elf_Internal_Shdr *hdr;
     const char *name;
d1742 7
a1748 1
	return FALSE;
d1750 1
d1752 1
a1752 1
      return FALSE;
d1756 1
a1756 1
    return FALSE;
d1764 1
a1764 1
	return FALSE;
d1767 16
a1782 4
  return TRUE;
}

/* Convert Alpha specific section flags to bfd internal section flags.  */
d1784 1
a1784 9
static bfd_boolean
elf64_alpha_section_flags (flags, hdr)
     flagword *flags;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_flags & SHF_ALPHA_GPREL)
    *flags |= SEC_SMALL_DATA;

  return TRUE;
d1790 1
a1790 1
static bfd_boolean
d1793 1
a1793 1
     Elf_Internal_Shdr *hdr;
d1810 25
a1834 2
  else if ((sec->flags & SEC_SMALL_DATA)
	   || strcmp (name, ".sdata") == 0
d1840 1
a1840 1
  return TRUE;
d1846 1
a1846 1
static bfd_boolean
d1858 1
a1858 1
      && sym->st_size <= elf_gp_size (abfd))
d1872 1
a1872 1
	    return FALSE;
d1879 1
a1879 1
  return TRUE;
d1884 1
a1884 1
static bfd_boolean
d1892 1
a1892 1
    return TRUE;
d1901 1
a1901 1
    return FALSE;
d1905 1
a1905 1
  return TRUE;
d1910 1
a1910 1
static bfd_boolean
a1916 1
  struct bfd_link_hash_entry *bh;
d1928 1
a1928 1
    return FALSE;
d1932 1
a1932 1
  bh = NULL;
d1935 4
a1938 4
	  (bfd_vma) 0, (const char *) NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
d1944 1
a1944 1
    return FALSE;
d1954 1
a1954 1
    return FALSE;
d1960 1
a1960 1
    return FALSE;
d1970 1
a1970 1
    return FALSE;
d1976 1
a1976 1
  bh = NULL;
d1980 3
a1982 3
	 FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
d1988 1
a1988 1
    return FALSE;
d1992 1
a1992 1
  return TRUE;
d1998 1
a1998 1
static bfd_boolean
d2011 1
a2011 1
  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
d2015 3
a2017 2
  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
d2030 1
a2030 2
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = (type) bfd_malloc (amt);				\
d2034 2
a2035 1
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
d2056 1
a2056 1
  return TRUE;
d2083 1
a2083 1
  return FALSE;
d2088 1
a2088 1
static bfd_boolean
d2107 1
a2107 1
static bfd_boolean
d2124 1
a2124 1
    return TRUE;
a2147 1
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);
d2149 2
a2150 1
	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
d2154 1
a2154 1
	      return FALSE;
d2160 1
a2160 1
	      return FALSE;
d2164 4
a2167 2
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
d2171 1
a2171 1
	      return FALSE;
d2196 1
a2196 1
	  return TRUE;
d2217 1
a2217 1
  bfd_boolean failed;
d2220 1
a2220 1
static bfd_boolean
d2226 1
a2226 1
  bfd_boolean strip;
a2228 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

d2230 1
a2230 1
    strip = FALSE;
d2232 4
a2235 4
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = TRUE;
d2237 5
a2241 5
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d2243 1
a2243 1
    strip = FALSE;
d2246 1
a2246 1
    return TRUE;
d2259 2
a2260 2
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
d2262 2
a2263 2
	{
	  const char *name;
d2265 2
a2266 10
	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);
d2268 29
a2296 21
	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}
d2308 1
a2308 1
	h->esym.asym.sc = scBss;
d2310 1
a2310 1
	h->esym.asym.sc = scSBss;
d2315 3
a2317 3
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
d2319 1
a2319 1
	h->esym.asym.value = 0;
d2338 3
d2344 2
a2345 2
				      h->root.root.root.string,
				      &h->esym))
d2347 2
a2348 2
      einfo->failed = TRUE;
      return FALSE;
d2351 1
a2351 1
  return TRUE;
a2352 2

/* Search for and possibly create a got entry.  */
d2354 5
a2358 2
static struct alpha_elf_got_entry *
get_got_entry (abfd, h, r_type, r_symndx, r_addend)
d2360 5
a2364 74
     struct alpha_elf_link_hash_entry *h;
     unsigned long r_type, r_symndx;
     bfd_vma r_addend;
{
  struct alpha_elf_got_entry *gotent;
  struct alpha_elf_got_entry **slot;

  if (h)
    slot = &h->got_entries;
  else
    {
      /* This is a local .got entry -- record for merge.  */

      struct alpha_elf_got_entry **local_got_entries;

      local_got_entries = alpha_elf_tdata(abfd)->local_got_entries;
      if (!local_got_entries)
	{
	  bfd_size_type size;
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	  size = symtab_hdr->sh_info;
	  size *= sizeof (struct alpha_elf_got_entry *);

	  local_got_entries
	    = (struct alpha_elf_got_entry **) bfd_zalloc (abfd, size);
	  if (!local_got_entries)
	    return NULL;

	  alpha_elf_tdata (abfd)->local_got_entries = local_got_entries;
	}

      slot = &local_got_entries[r_symndx];
    }

  for (gotent = *slot; gotent ; gotent = gotent->next)
    if (gotent->gotobj == abfd
	&& gotent->reloc_type == r_type
	&& gotent->addend == r_addend)
      break;

  if (!gotent)
    {
      int entry_size;
      bfd_size_type amt;

      amt = sizeof (struct alpha_elf_got_entry);
      gotent = (struct alpha_elf_got_entry *) bfd_alloc (abfd, amt);
      if (!gotent)
	return NULL;

      gotent->gotobj = abfd;
      gotent->addend = r_addend;
      gotent->got_offset = -1;
      gotent->use_count = 1;
      gotent->reloc_type = r_type;
      gotent->reloc_done = 0;
      gotent->reloc_xlated = 0;

      gotent->next = *slot;
      *slot = gotent;

      entry_size = alpha_got_entry_size (r_type);
      alpha_elf_tdata (abfd)->total_got_size += entry_size;
      if (!h)
	alpha_elf_tdata(abfd)->local_got_size += entry_size;
    }
  else
    gotent->use_count += 1;

  return gotent;
}

d2367 1
a2367 1
static bfd_boolean
d2379 1
d2381 1
a2381 2
  bfd_boolean got_created;
  bfd_size_type amt;
d2384 1
a2384 1
    return TRUE;
d2394 2
a2395 1
  got_created = FALSE;
a2399 6
      enum {
	NEED_GOT = 1,
	NEED_GOT_ENTRY = 2,
	NEED_DYNREL = 4
      };

a2401 4
      unsigned int gotent_flags;
      bfd_boolean maybe_dynamic;
      unsigned int need;
      bfd_vma addend;
a2415 14

      /* We can only get preliminary data on whether a symbol is
         locally or externally defined, as not all of the input files
         have yet been processed.  Do something with what we know, as
         this may help reduce memory usage and processing time later.  */
      maybe_dynamic = FALSE;
      if (h && ((info->shared
		 && (!info->symbolic || info->allow_shlib_undefined))
		|| ! (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		|| h->root.root.type == bfd_link_hash_defweak))
        maybe_dynamic = TRUE;

      need = 0;
      gotent_flags = 0;
a2416 1
      addend = rel->r_addend;
d2421 25
a2445 1
	  need = NEED_GOT | NEED_GOT_ENTRY;
d2447 2
a2448 12
	  /* Remember how this literal is used from its LITUSEs.
	     This will be important when it comes to decide if we can
	     create a .plt entry for a function symbol.  */
	  while (++rel < relend && ELF64_R_TYPE (rel->r_info) == R_ALPHA_LITUSE)
	    if (rel->r_addend >= 1 && rel->r_addend <= 5)
	      gotent_flags |= 1 << rel->r_addend;
	  --rel;

	  /* No LITUSEs -- presumably the address is used somehow.  */
	  if (gotent_flags == 0)
	    gotent_flags = ALPHA_ELF_LINK_HASH_LU_ADDR;
	  break;
d2450 23
a2472 8
	case R_ALPHA_GPDISP:
	case R_ALPHA_GPREL16:
	case R_ALPHA_GPREL32:
	case R_ALPHA_GPRELHIGH:
	case R_ALPHA_GPRELLOW:
	case R_ALPHA_BRSGP:
	  need = NEED_GOT;
	  break;
d2474 17
a2490 5
	case R_ALPHA_REFLONG:
	case R_ALPHA_REFQUAD:
	  if ((info->shared && (sec->flags & SEC_ALLOC)) || maybe_dynamic)
	    need = NEED_DYNREL;
	  break;
d2492 2
a2493 7
	case R_ALPHA_TLSLDM:
	  /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	     reloc to the 0 symbol so that they all match.  */
	  r_symndx = 0;
	  h = 0;
	  maybe_dynamic = FALSE;
	  /* FALLTHRU */
d2495 6
a2500 4
	case R_ALPHA_TLSGD:
	case R_ALPHA_GOTDTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  break;
d2502 21
a2522 6
	case R_ALPHA_GOTTPREL:
	  need = NEED_GOT | NEED_GOT_ENTRY;
	  gotent_flags = ALPHA_ELF_LINK_HASH_TLS_IE;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
d2524 11
a2534 7
	case R_ALPHA_TPREL64:
	  if (info->shared || maybe_dynamic)
	    need = NEED_DYNREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;
	}
d2536 7
a2542 2
      if (need & NEED_GOT)
	{
d2546 1
a2546 1
		return FALSE;
d2556 1
a2556 1
	}
d2558 6
a2563 3
      if (need & NEED_GOT_ENTRY)
	{
	  struct alpha_elf_got_entry *gotent;
d2565 2
a2566 24
	  gotent = get_got_entry (abfd, h, r_type, r_symndx, addend);
	  if (!gotent)
	    return FALSE;

	  if (gotent_flags)
	    {
	      gotent->flags |= gotent_flags;
	      if (h)
		{
		  gotent_flags |= h->flags;
		  h->flags = gotent_flags;

		  /* Make a guess as to whether a .plt entry is needed.  */
		  if ((gotent_flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
		      && !(gotent_flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC))
		    h->root.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  else
		    h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	        }
	    }
	}

      if (need & NEED_DYNREL)
	{
d2573 1
a2573 1
		return FALSE;
a2588 2
		  flagword flags;

a2589 4
		  flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
			   | SEC_LINKER_CREATED | SEC_READONLY);
		  if (sec->flags & SEC_ALLOC)
		    flags |= SEC_ALLOC | SEC_LOAD;
d2591 7
a2597 1
		      || !bfd_set_section_flags (dynobj, sreloc, flags)
d2599 1
a2599 1
		    return FALSE;
d2619 3
a2621 2
		  amt = sizeof (struct alpha_elf_reloc_entry);
		  rent = (struct alpha_elf_reloc_entry *) bfd_alloc (abfd, amt);
d2623 1
a2623 1
		    return FALSE;
a2627 2
		  rent->reltext = ((sec->flags & (SEC_READONLY | SEC_ALLOC))
				   == (SEC_READONLY | SEC_ALLOC));
d2635 1
a2635 1
	  else if (info->shared)
a2639 3
	      if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		  == (SEC_READONLY | SEC_ALLOC))
		info->flags |= DF_TEXTREL;
d2641 1
d2645 1
a2645 1
  return TRUE;
d2654 1
a2654 1
static bfd_boolean
d2669 2
a2670 1
  if (alpha_elf_dynamic_symbol_p (h, info)
d2674 1
a2674 2
	      && (ah->flags & ALPHA_ELF_LINK_HASH_LU_FUNC)
	      && !(ah->flags & ~ALPHA_ELF_LINK_HASH_LU_FUNC)))
d2685 1
a2685 1
	return FALSE;
a2700 3
	  ah->plt_old_section = h->root.u.def.section;
	  ah->plt_old_value = h->root.u.def.value;
	  ah->flags |= ALPHA_ELF_LINK_HASH_PLT_LOC;
d2710 1
a2710 1
      return TRUE;
d2724 1
a2724 1
      return TRUE;
d2732 1
a2732 1
  return TRUE;
d2739 1
a2739 1
static bfd_boolean
d2747 1
a2747 1
    return TRUE;
d2771 2
a2772 7
	    if (gi->gotobj == gs->gotobj
		&& gi->reloc_type == gs->reloc_type
		&& gi->addend == gs->addend)
	      {
		gi->use_count += gs->use_count;
	        goto got_found;
	      }
d2793 1
a2793 1
	    if (ri->rtype == rs->rtype && ri->srel == rs->srel)
d2805 1
a2805 1
  return TRUE;
d2810 1
a2810 1
static bfd_boolean
d2814 1
a2814 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2818 2
a2819 2
  if (total + alpha_elf_tdata (b)->total_got_size <= MAX_GOT_SIZE)
    return TRUE;
d2822 2
a2823 2
  if ((total += alpha_elf_tdata (b)->local_got_size) > MAX_GOT_SIZE)
    return FALSE;
d2853 1
a2853 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2856 2
a2857 3
	      total += alpha_got_entry_size (be->reloc_type);
	      if (total > MAX_GOT_SIZE)
	        return FALSE;
d2863 1
a2863 1
  return TRUE;
d2872 1
a2872 1
  int total = alpha_elf_tdata (a)->total_got_size;
d2877 1
a2877 1
    int e = alpha_elf_tdata (b)->local_got_size;
d2879 1
a2879 1
    alpha_elf_tdata (a)->local_got_size += e;
d2929 1
a2929 3
	        if (ae->gotobj == a
		    && ae->reloc_type == be->reloc_type
		    && ae->addend == be->addend)
d2937 1
a2937 1
	      total += alpha_got_entry_size (be->reloc_type);
d2945 1
a2945 1
  alpha_elf_tdata (a)->total_got_size = total;
d2961 1
a2961 1
static bfd_boolean
d2964 1
a2964 1
     PTR arg ATTRIBUTE_UNUSED;
a2967 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

d2975 1
a2975 1
	*plge += alpha_got_entry_size (gotent->reloc_type);
d2978 1
a2978 1
  return TRUE;
d3017 1
a3017 1
		  got_offset += alpha_got_entry_size (gotent->reloc_type);
d3028 3
a3030 2
static bfd_boolean
elf64_alpha_size_got_sections (info)
d3033 1
a3033 1
  bfd *i, *got_list, *cur_got_obj = NULL;
d3051 1
a3051 1
          if (alpha_elf_tdata (this_got)->total_got_size > MAX_GOT_SIZE)
d3056 3
a3058 3
	         bfd_archive_filename (i),
	         alpha_elf_tdata (this_got)->total_got_size);
	      return FALSE;
d3070 1
a3070 1
	return TRUE;
d3101 1
a3101 80
  return TRUE;
}

/* Called from relax_section to rebuild the PLT in light of
   potential changes in the function's status.  */

static bfd_boolean
elf64_alpha_size_plt_section (info)
     struct bfd_link_info *info;
{
  asection *splt, *spltrel;
  unsigned long entries;
  bfd *dynobj;

  dynobj = elf_hash_table(info)->dynobj;
  splt = bfd_get_section_by_name(dynobj, ".plt");
  if (splt == NULL)
    return TRUE;

  splt->_raw_size = 0;

  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_plt_section_1, splt);

  splt->_cooked_size = splt->_raw_size;

  /* Every plt entry requires a JMP_SLOT relocation.  */
  spltrel = bfd_get_section_by_name (dynobj, ".rela.plt");
  if (splt->_raw_size)
    entries = (splt->_raw_size - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
  else
    entries = 0;
  spltrel->_raw_size = entries * sizeof (Elf64_External_Rela);
  spltrel->_cooked_size = spltrel->_raw_size;

  return TRUE;
}

static bfd_boolean
elf64_alpha_size_plt_section_1 (h, data)
     struct alpha_elf_link_hash_entry *h;
     PTR data;
{
  asection *splt = (asection *) data;
  struct alpha_elf_got_entry *gotent;

  /* If we didn't need an entry before, we still don't.  */
  if (!(h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT))
    return TRUE;

  /* There must still be a LITERAL got entry for the function.  */
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->reloc_type == R_ALPHA_LITERAL
	&& gotent->use_count > 0)
      break;

  /* If there is, reset the PLT offset.  If not, there's no longer
     a need for the PLT entry.  */
  if (gotent)
    {
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_HEADER_SIZE;
      h->root.plt.offset = splt->_raw_size;
      splt->_raw_size += PLT_ENTRY_SIZE;
    }
  else
    {
      h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->root.plt.offset = -1;

      /* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
      if (h->flags & ALPHA_ELF_LINK_HASH_PLT_LOC)
	{
	  h->root.root.u.def.section = h->plt_old_section;
	  h->root.root.u.def.value = h->plt_old_value;
	  h->flags &= ~ALPHA_ELF_LINK_HASH_PLT_LOC;
	}
    }

  return TRUE;
d3104 1
a3104 1
static bfd_boolean
d3106 1
a3106 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d3112 1
a3112 1
    return TRUE;
d3119 2
a3120 2
  if (!elf64_alpha_size_got_sections (info))
    return FALSE;
d3131 1
a3131 1
	    return FALSE;
d3135 1
a3135 33
  return TRUE;
}

/* The number of dynamic relocations required by a static relocation.  */

static int
alpha_dynamic_entries_for_reloc (r_type, dynamic, shared)
     int r_type, dynamic, shared;
{
  switch (r_type)
    {
    /* May appear in GOT entries.  */
    case R_ALPHA_TLSGD:
      return (dynamic ? 2 : shared ? 1 : 0);
    case R_ALPHA_TLSLDM:
      return shared;
    case R_ALPHA_LITERAL:
    case R_ALPHA_GOTTPREL:
      return dynamic || shared;
    case R_ALPHA_GOTDTPREL:
      return dynamic;

    /* May appear in data sections.  */
    case R_ALPHA_REFLONG:
    case R_ALPHA_REFQUAD:
    case R_ALPHA_TPREL64:
      return dynamic || shared;

    /* Everything else is illegal.  We'll issue an error during
       relocate_section.  */
    default:
      return 0;
    }
d3140 1
a3140 1
static bfd_boolean
a3144 7
  bfd_boolean dynamic;
  struct alpha_elf_reloc_entry *relent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

d3160 3
a3162 1
    h->root.elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3168 7
a3174 1
  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);
d3176 7
a3182 12
  for (relent = h->reloc_entries; relent; relent = relent->next)
    {
      entries = alpha_dynamic_entries_for_reloc (relent->rtype, dynamic,
						 info->shared);
      if (entries)
	{
	  relent->srel->_raw_size +=
	    entries * sizeof (Elf64_External_Rela) * relent->count;
	  if (relent->reltext)
	    info->flags |= DT_TEXTREL;
	}
    }
d3184 2
a3185 2
  return TRUE;
}
d3187 2
a3188 1
/* Set the sizes of the dynamic relocation sections.  */
d3190 4
a3193 16
static bfd_boolean
elf64_alpha_size_rela_got_section (info)
     struct bfd_link_info *info;
{
  unsigned long entries;
  bfd *i, *dynobj;
  asection *srel;

  /* Shared libraries often require RELATIVE relocs, and some relocs
     require attention for the main application as well.  */

  entries = 0;
  for (i = alpha_elf_hash_table(info)->got_list;
       i ; i = alpha_elf_tdata(i)->got_link_next)
    {
      bfd *j;
d3195 1
a3195 1
      for (j = i; j ; j = alpha_elf_tdata(j)->in_got_link_next)
d3197 3
a3199 13
	  struct alpha_elf_got_entry **local_got_entries, *gotent;
	  int k, n;

	  local_got_entries = alpha_elf_tdata(j)->local_got_entries;
	  if (!local_got_entries)
	    continue;

	  for (k = 0, n = elf_tdata(j)->symtab_hdr.sh_info; k < n; ++k)
	    for (gotent = local_got_entries[k];
		 gotent ; gotent = gotent->next)
	      if (gotent->use_count > 0)
		entries += (alpha_dynamic_entries_for_reloc
			    (gotent->reloc_type, 0, info->shared));
d3203 1
a3203 59
  dynobj = elf_hash_table(info)->dynobj;
  srel = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!srel)
    {
      BFD_ASSERT (entries == 0);
      return TRUE;
    }
  srel->_raw_size = sizeof (Elf64_External_Rela) * entries;

  /* Now do the non-local symbols.  */
  alpha_elf_link_hash_traverse (alpha_elf_hash_table (info),
				elf64_alpha_size_rela_got_1, info);

  srel->_cooked_size = srel->_raw_size;

  return TRUE;
}

/* Subroutine of elf64_alpha_size_rela_got_section for doing the
   global symbols.  */

static bfd_boolean
elf64_alpha_size_rela_got_1 (h, info)
     struct alpha_elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  bfd_boolean dynamic;
  struct alpha_elf_got_entry *gotent;
  unsigned long entries;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct alpha_elf_link_hash_entry *) h->root.root.u.i.link;

  /* If the symbol is dynamic, we'll need all the relocations in their
     natural form.  If this is a shared object, and it has been forced
     local, we'll need the same number of RELATIVE relocations.  */

  dynamic = alpha_elf_dynamic_symbol_p (&h->root, info);

  entries = 0;
  for (gotent = h->got_entries; gotent ; gotent = gotent->next)
    if (gotent->use_count > 0)
      entries += alpha_dynamic_entries_for_reloc (gotent->reloc_type,
						  dynamic, info->shared);

  /* If we are using a .plt entry, subtract one, as the first
     reference uses a .rela.plt entry instead.  */
  if (h->root.plt.offset != MINUS_ONE)
    entries--;

  if (entries > 0)
    {
      bfd *dynobj = elf_hash_table(info)->dynobj;
      asection *srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela) * entries;
    }

  return TRUE;
d3208 1
a3208 1
static bfd_boolean
d3210 1
a3210 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d3215 2
a3216 1
  bfd_boolean relplt;
d3237 10
a3246 1
				    elf64_alpha_calc_dynrel_sizes, info);
d3248 10
a3257 1
      elf64_alpha_size_rela_got_section (info);
d3264 2
a3265 1
  relplt = FALSE;
d3269 1
a3269 1
      bfd_boolean strip;
d3286 1
a3286 1
      strip = FALSE;
d3294 13
d3308 1
a3308 1
		relplt = TRUE;
d3326 1
a3326 1
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d3328 1
a3328 1
	    return FALSE;
a3338 3
#define add_dynamic_entry(TAG, VAL) \
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))

d3341 2
a3342 2
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
d3345 3
d3350 4
a3353 97
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	return FALSE;

      if (info->flags & DF_TEXTREL)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)
   into the next available slot in SREL.  */

static void
elf64_alpha_emit_dynrel (abfd, info, sec, srel, offset, dynindx, rtype, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec, *srel;
     bfd_vma offset, addend;
     long dynindx, rtype;
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (srel != NULL);

  outrel.r_info = ELF64_R_INFO (dynindx, rtype);
  outrel.r_addend = addend;

  offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if ((offset | 1) != (bfd_vma) -1)
    outrel.r_offset = sec->output_section->vma + sec->output_offset + offset;
  else
    memset (&outrel, 0, sizeof (outrel));

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (Elf64_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
}

/* Relocate an Alpha ELF section for a relocatable link.

   We don't have to change anything unless the reloc is against a section
   symbol, in which case we have to adjust according to where the section
   symbol winds up in the output section.  */

static bfd_boolean
elf64_alpha_relocate_section_r (output_bfd, info, input_bfd, input_section,
			        contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  unsigned long symtab_hdr_sh_info;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  bfd_boolean ret_val = TRUE;

  symtab_hdr_sh_info = elf_tdata (input_bfd)->symtab_hdr.sh_info;

  relend = relocs + input_section->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      unsigned long r_type;

      r_type = ELF64_R_TYPE(rel->r_info);
      if (r_type >= R_ALPHA_max)
	{
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
d3356 5
a3360 6
      r_symndx = ELF64_R_SYM(rel->r_info);

      /* The symbol associated with GPDISP and LITUSE is
	 immaterial.  Only the addend is significant.  */
      if (r_type == R_ALPHA_GPDISP || r_type == R_ALPHA_LITUSE)
	continue;
d3362 1
a3362 1
      if (r_symndx < symtab_hdr_sh_info)
d3364 3
a3366 6
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
	    {
	      sec = local_sections[r_symndx];
	      rel->r_addend += sec->output_offset + sym->st_value;
	    }
d3370 1
a3370 1
  return ret_val;
d3375 1
a3375 1
static bfd_boolean
d3390 1
a3390 2
  struct elf_link_tls_segment *tls_segment;
  asection *sgot, *srel, *srelgot;
d3392 1
a3392 14
  bfd_vma gp, tp_base, dtp_base;
  struct alpha_elf_got_entry **local_got_entries;
  bfd_boolean ret_val;
  const char *section_name;

  /* Handle relocatable links with a smaller loop.  */
  if (info->relocateable)
    return elf64_alpha_relocate_section_r (output_bfd, info, input_bfd,
					   input_section, contents, relocs,
					   local_syms, local_sections);

  /* This is a final link.  */

  ret_val = TRUE;
d3394 1
a3395 1

d3398 3
a3400 9
    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  else
    srelgot = NULL;

  section_name = (bfd_elf_string_from_elf_section
		  (input_bfd, elf_elfheader(input_bfd)->e_shstrndx,
		   elf_section_data(input_section)->rel_hdr.sh_name));
  BFD_ASSERT(section_name != NULL);
  srel = bfd_get_section_by_name (dynobj, section_name);
d3403 2
a3417 16
  else
    {
      sgot = NULL;
      gp = 0;
    }

  local_got_entries = alpha_elf_tdata(input_bfd)->local_got_entries;

  tls_segment = elf_hash_table (info)->tls_segment;
  if (tls_segment)
    {
      dtp_base = alpha_get_dtprel_base (tls_segment);
      tp_base = alpha_get_tprel_base (tls_segment);
    }
  else
    dtp_base = tp_base = 0;
d3419 1
d3421 1
a3421 1
  for (rel = relocs; rel < relend; rel++)
d3423 1
a3423 3
      struct alpha_elf_link_hash_entry *h = NULL;
      struct alpha_elf_got_entry *gotent;
      bfd_reloc_status_type r;
d3426 3
a3428 3
      Elf_Internal_Sym *sym = NULL;
      asection *sec = NULL;
      bfd_vma value;
d3430 1
a3430 3
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref = FALSE;
      unsigned long r_type;
d3433 1
a3433 1
      if (r_type >= R_ALPHA_max)
a3434 3
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d3436 1
a3436 2
	  ret_val = FALSE;
	  continue;
d3438 1
a3439 1
      howto = elf64_alpha_howto_table + r_type;
d3442 1
a3442 6
      /* The symbol for a TLSLDM reloc is ignored.  Collapse the
	 reloc to the 0 symbol so that they all match.  */
      if (r_type == R_ALPHA_TLSLDM)
	r_symndx = 0;

      if (r_symndx < symtab_hdr->sh_info)
d3444 9
a3452 3
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d3454 1
a3454 24
	  /* If this is a tp-relative relocation against sym 0,
	     this is hackery from relax_section.  Force the value to
	     be the tls base.  */
	  if (r_symndx == 0
	      && (r_type == R_ALPHA_TLSLDM
		  || r_type == R_ALPHA_GOTTPREL
		  || r_type == R_ALPHA_TPREL64
		  || r_type == R_ALPHA_TPRELHI
		  || r_type == R_ALPHA_TPRELLO
		  || r_type == R_ALPHA_TPREL16))
	    value = tp_base;

	  if (local_got_entries)
	    gotent = local_got_entries[r_symndx];
	  else
	    gotent = NULL;

	  /* Need to adjust local GOT entries' addends for SEC_MERGE
	     unless it has been done already.  */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && gotent
	      && !gotent->reloc_xlated)
d3456 2
a3457 4
	      struct alpha_elf_got_entry *ent;
	      asection *msec;

	      for (ent = gotent; ent; ent = ent->next)
d3459 2
a3460 15
		  ent->reloc_xlated = 1;
		  if (ent->use_count == 0)
		    continue;
		  msec = sec;
		  ent->addend =
		    _bfd_merged_section_offset (output_bfd, &msec,
						elf_section_data (sec)->
						  sec_info,
						sym->st_value + ent->addend,
						(bfd_vma) 0);
		  ent->addend -= sym->st_value;
		  ent->addend += msec->output_section->vma
				 + msec->output_offset
				 - sec->output_section->vma
				 - sec->output_offset;
d3464 16
a3479 1
	  dynamic_symbol_p = FALSE;
a3488 1
	  value = 0;
d3494 33
a3526 12
	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */

	      if (sec->output_section != NULL)
		value = (h->root.root.u.def.value
			 + sec->output_section->vma
			      + sec->output_offset);
d3529 2
a3530 2
	    undef_weak_ref = TRUE;
	  else if (info->shared
d3533 1
a3533 1
	    ;
d3541 2
a3542 2
		return FALSE;
	      continue;
a3543 3

          dynamic_symbol_p = alpha_elf_dynamic_symbol_p (&h->root, info);
	  gotent = h->got_entries;
a3544 1

a3545 8
      value += addend;

      /* Search for the proper got entry.  */
      for (; gotent ; gotent = gotent->next)
	if (gotent->gotobj == gotobj
	    && gotent->reloc_type == r_type
	    && gotent->addend == addend)
	  break;
d3555 43
a3597 3
	    value = (input_section->output_section->vma
		     + input_section->output_offset
		     + rel->r_offset);
d3599 1
a3599 2
	    p_ldah = contents + rel->r_offset;
	    p_lda = p_ldah + rel->r_addend;
d3601 5
a3605 4
	    r = elf64_alpha_do_reloc_gpdisp (input_bfd, gp - value,
					     p_ldah, p_lda);
	  }
	  break;
d3607 6
a3612 5
	case R_ALPHA_LITERAL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);
d3614 1
a3614 3
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;
d3616 14
a3629 2
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
d3631 2
a3632 8
	      /* If the symbol has been forced local, output a
		 RELATIVE reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, value);
	    }
d3634 8
a3641 4
	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
a3644 13
	  /* If the target section was a removed linkonce section,
	     r_symndx will be zero.  In this case, assume that the
	     switch will not be used, so don't fill it in.  If we
	     do nothing here, we'll get relocation truncated messages,
	     due to the placement of the application above 4GB.  */
	  if (r_symndx == 0)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* FALLTHRU */

	case R_ALPHA_GPREL16:
a3645 7
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
d3647 1
a3647 1
	  value -= gp;
a3650 7
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: gp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
d3652 5
a3656 2
	  value -= gp;
	  value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
d3659 1
a3660 20
	  /* A call to a dynamic symbol is definitely out of range of
	     the 16-bit displacement.  Don't bother writing anything.  */
	  if (dynamic_symbol_p)
	    {
	      r = bfd_reloc_ok;
	      break;
	    }
	  /* The regular PC-relative stuff measures from the start of
	     the instruction rather than the end.  */
	  value -= 4;
	  goto default_reloc;

	case R_ALPHA_BRADDR:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
d3663 1
a3663 1
	  value -= 4;
a3665 58
	case R_ALPHA_BRSGP:
	  {
	    int other;
	    const char *name;

	    /* The regular PC-relative stuff measures from the start of
	       the instruction rather than the end.  */
	    value -= 4;

	    /* The source and destination gp must be the same.  Note that
	       the source will always have an assigned gp, since we forced
	       one in check_relocs, but that the destination may not, as
	       it might not have had any relocations at all.  Also take
	       care not to crash if H is an undefined symbol.  */
	    if (h != NULL && sec != NULL
		&& alpha_elf_tdata (sec->owner)->gotobj
		&& gotobj != alpha_elf_tdata (sec->owner)->gotobj)
	      {
		(*_bfd_error_handler)
		  (_("%s: change in gp: BRSGP %s"),
		   bfd_archive_filename (input_bfd), h->root.root.root.string);
		ret_val = FALSE;
	      }

	    /* The symbol should be marked either NOPV or STD_GPLOAD.  */
	    if (h != NULL)
	      other = h->root.other;
	    else
	      other = sym->st_other;
	    switch (other & STO_ALPHA_STD_GPLOAD)
	      {
	      case STO_ALPHA_NOPV:
	        break;
	      case STO_ALPHA_STD_GPLOAD:
		value += 8;
		break;
	      default:
		if (h != NULL)
		  name = h->root.root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      name = _("<unknown>");
		    else if (name[0] == 0)
		      name = bfd_section_name (input_bfd, sec);
		  }
		(*_bfd_error_handler)
		  (_("%s: !samegp reloc against symbol without .prologue: %s"),
		   bfd_archive_filename (input_bfd), name);
		ret_val = FALSE;
		break;
	      }

	    goto default_reloc;
	  }

a3667 2
	case R_ALPHA_DTPREL64:
	case R_ALPHA_TPREL64:
d3669 2
a3670 2
	    long dynindx, dyntype = r_type;
	    bfd_vma dynaddend;
d3675 1
a3675 1
	    if (dynamic_symbol_p)
d3678 3
a3680 20
		dynindx = h->root.dynindx;
		dynaddend = addend;
		addend = 0, value = 0;
	      }
	    else if (r_type == R_ALPHA_DTPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		value -= dtp_base;
		goto default_reloc;
	      }
	    else if (r_type == R_ALPHA_TPREL64)
	      {
		BFD_ASSERT(tls_segment != NULL);
		if (!info->shared)
		  {
		    value -= tp_base;
		    goto default_reloc;
		  }
		dynindx = 0;
		dynaddend = value - dtp_base;
d3682 1
a3682 3
	    else if (info->shared
		     && r_symndx != 0
		     && (input_section->flags & SEC_ALLOC))
d3684 2
a3685 11
		if (r_type == R_ALPHA_REFLONG)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unhandled dynamic relocation against %s"),
		       bfd_archive_filename (input_bfd),
		       h->root.root.root.string);
		    ret_val = FALSE;
		  }
		dynindx = 0;
		dyntype = R_ALPHA_RELATIVE;
		dynaddend = value;
d3690 3
a3692 5
	    elf64_alpha_emit_dynrel (output_bfd, info, input_section,
				     srel, rel->r_offset, dynindx,
				     dyntype, dynaddend);
	  }
	  goto default_reloc;
d3694 4
a3697 18
	case R_ALPHA_SREL16:
	case R_ALPHA_SREL32:
	case R_ALPHA_SREL64:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: pc-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }

	  /* ??? .eh_frame references to discarded sections will be smashed
	     to relocations against SHN_UNDEF.  The .eh_frame format allows
	     NULL to be encoded as 0 in any format, so this works here.  */
	  if (r_symndx == 0)
	    howto = (elf64_alpha_howto_table
		     + (r_type - R_ALPHA_SREL32 + R_ALPHA_REFLONG));
	  goto default_reloc;
d3699 3
a3701 5
	case R_ALPHA_TLSLDM:
	  /* Ignore the symbol for the relocation.  The result is always
	     the current module.  */
	  dynamic_symbol_p = 0;
	  /* FALLTHRU */
d3703 1
a3703 4
	case R_ALPHA_TLSGD:
	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;
d3705 5
a3709 11
	      /* Note that the module index for the main program is 1.  */
	      bfd_put_64 (output_bfd, !info->shared && !dynamic_symbol_p,
			  sgot->contents + gotent->got_offset);

	      /* If the symbol has been forced local, output a
		 DTPMOD64 reloc, otherwise it will be handled in
		 finish_dynamic_symbol.  */
	      if (info->shared && !dynamic_symbol_p)
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					 gotent->got_offset, 0,
					 R_ALPHA_DTPMOD64, 0);
d3711 9
a3719 10
	      if (dynamic_symbol_p || r_type == R_ALPHA_TLSLDM)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
	          value -= dtp_base;
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset + 8);
	    }
d3721 5
a3725 5
	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
	  goto default_reloc;
d3727 7
a3733 76
	case R_ALPHA_DTPRELHI:
	case R_ALPHA_DTPRELLO:
	case R_ALPHA_DTPREL16:
	  if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: dtp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= dtp_base;
	  if (r_type == R_ALPHA_DTPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_TPRELHI:
	case R_ALPHA_TPRELLO:
	case R_ALPHA_TPREL16:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: TLS local exec code cannot be linked into shared objects"),
		bfd_archive_filename (input_bfd));
              ret_val = FALSE;
	    }
	  else if (dynamic_symbol_p)
            {
              (*_bfd_error_handler)
                (_("%s: tp-relative relocation against dynamic symbol %s"),
                 bfd_archive_filename (input_bfd), h->root.root.root.string);
              ret_val = FALSE;
            }
	  BFD_ASSERT(tls_segment != NULL);
	  value -= tp_base;
	  if (r_type == R_ALPHA_TPRELHI)
	    value = ((bfd_signed_vma) value >> 16) + ((value >> 15) & 1);
	  goto default_reloc;

	case R_ALPHA_GOTDTPREL:
	case R_ALPHA_GOTTPREL:
	  BFD_ASSERT(sgot != NULL);
	  BFD_ASSERT(gp != 0);
	  BFD_ASSERT(gotent != NULL);
	  BFD_ASSERT(gotent->use_count >= 1);

	  if (!gotent->reloc_done)
	    {
	      gotent->reloc_done = 1;

	      if (dynamic_symbol_p)
		value = 0;
	      else
		{
		  BFD_ASSERT(tls_segment != NULL);
		  if (r_type == R_ALPHA_GOTDTPREL)
		    value -= dtp_base;
		  else if (!info->shared)
		    value -= tp_base;
		  else
		    {
		      elf64_alpha_emit_dynrel (output_bfd, info, sgot, srelgot,
					       gotent->got_offset, 0,
					       R_ALPHA_TPREL64,
					       value - dtp_base);
		      value = 0;
		    }
		}
	      bfd_put_64 (output_bfd, value,
			  sgot->contents + gotent->got_offset);
	    }

	  value = (sgot->output_section->vma
		   + sgot->output_offset
		   + gotent->got_offset);
	  value -= gp;
d3739 2
a3740 1
					contents, rel->r_offset, value, 0);
a3752 9
	    /* Don't warn if the overflow is due to pc relative reloc
	       against discarded section.  Section optimization code should
	       handle it.  */

	    if (r_symndx < symtab_hdr->sh_info
		&& sec != NULL && howto->pc_relative
		&& elf_discarded_section (sec))
	      break;

d3760 1
a3760 1
		  return FALSE;
d3767 1
a3767 1
	      ret_val = FALSE;
d3777 1
a3777 1
  return ret_val;
d3783 1
a3783 1
static bfd_boolean
a3796 1
      bfd_byte *loc;
d3826 1
a3826 1
	bfd_vma insn1, insn2, insn3;
d3842 3
a3844 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d3873 14
a3886 3
		elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel,
					 gotent->got_offset, 0,
					 R_ALPHA_RELATIVE, plt_addr);
d3897 1
d3903 1
d3908 11
a3918 36
	  asection *sgot;
	  long r_type;

	  if (gotent->use_count == 0)
	    continue;

	  sgot = alpha_elf_tdata (gotent->gotobj)->got;

	  r_type = gotent->reloc_type;
	  switch (r_type)
	    {
	    case R_ALPHA_LITERAL:
	      r_type = R_ALPHA_GLOB_DAT;
	      break;
	    case R_ALPHA_TLSGD:
	      r_type = R_ALPHA_DTPMOD64;
	      break;
	    case R_ALPHA_GOTDTPREL:
	      r_type = R_ALPHA_DTPREL64;
	      break;
	    case R_ALPHA_GOTTPREL:
	      r_type = R_ALPHA_TPREL64;
	      break;
	    case R_ALPHA_TLSLDM:
	    default:
	      abort ();
	    }

	  elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				   gotent->got_offset, h->dynindx,
				   r_type, gotent->addend);

	  if (gotent->reloc_type == R_ALPHA_TLSGD)
	    elf64_alpha_emit_dynrel (output_bfd, info, sgot, srel, 
				     gotent->got_offset + 8, h->dynindx,
				     R_ALPHA_DTPREL64, gotent->addend);
d3928 1
a3928 1
  return TRUE;
d3933 1
a3933 1
static bfd_boolean
d4003 1
a4003 1
      /* Initialize the PLT0 entry.  */
d4012 2
a4013 2
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 16);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, splt->contents + 24);
d4015 2
a4016 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 0;
d4020 1
a4020 1
  return TRUE;
d4023 3
a4025 3
/* We need to use a special link routine to handle the .mdebug section.
   We need to merge all instances of these sections together, not write
   them all out sequentially.  */
d4027 1
a4027 1
static bfd_boolean
d4034 1
a4034 1
  asection *mdebug_sec;
d4041 12
a4052 1
  /* Go through the sections and collect the mdebug information.  */
d4054 2
d4058 66
d4163 1
a4163 1
	    return FALSE;
d4169 1
a4169 1
	      bfd_vma last = 0;
d4202 1
a4202 1
		    return FALSE;
d4219 1
a4219 1
		  if (p->type == bfd_data_link_order)
d4247 1
a4247 1
		return FALSE;
d4252 1
a4252 1
		return FALSE;
d4278 1
a4278 1
						  name, FALSE, FALSE, TRUE);
d4310 25
d4340 1
a4340 1
	  einfo.failed = FALSE;
d4345 1
a4345 1
	    return FALSE;
d4356 223
d4583 1
a4583 1
    return FALSE;
d4602 1
a4602 2
					sgot->contents,
					(file_ptr) sgot->output_offset,
d4604 1
a4604 1
	  return FALSE;
d4608 12
d4626 1
a4626 1
	return FALSE;
d4631 8
a4638 2
  return TRUE;
}
d4640 7
a4646 14
static enum elf_reloc_type_class
elf64_alpha_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_ALPHA_RELATIVE:
      return reloc_class_relative;
    case R_ALPHA_JMP_SLOT:
      return reloc_class_plt;
    case R_ALPHA_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
d4648 2
d4699 1
a4699 1
static const struct elf_size_info alpha_elf_size_info =
a4715 1
  bfd_elf64_swap_symbol_in,
d4721 4
a4724 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
a4747 2
#define elf_backend_section_flags \
  elf64_alpha_section_flags
a4777 2
#define elf_backend_reloc_type_class \
  elf64_alpha_reloc_type_class
a4790 40

#include "elf64-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM	bfd_elf64_alpha_freebsd_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME	"elf64-alpha-freebsd"

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void elf64_alpha_fbsd_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static void
elf64_alpha_fbsd_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#ifdef OLD_FREEBSD_ABI_LABEL
  /* The ABI label supported by FreeBSD <= 4.0 is quite nonstandard.  */
  memcpy (&i_ehdrp->e_ident[EI_ABIVERSION], "FreeBSD", 8);
#endif
}

#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers \
  elf64_alpha_fbsd_post_process_headers

#undef  elf64_bed
#define elf64_bed elf64_alpha_fbsd_bed
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d50 1
a50 1
static bfd_boolean alpha_elf_dynamic_symbol_p
d126 1
a126 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d272 1
a272 4
/* Should we do dynamic things to this symbol?  This differs from the 
   generic version in that we never need to consider function pointer
   equality wrt PLT entries -- we don't create a PLT entry if a symbol's
   address is ever taken.  */
d274 1
a274 1
static inline bfd_boolean
d279 36
a314 1
  return _bfd_elf_dynamic_symbol_p (h, info, 0);
d428 9
d1193 2
a1194 2
#define alpha_get_dtprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma)
d1198 2
a1199 4
#define alpha_get_tprel_base(info) \
  (elf_hash_table (info)->tls_sec->vma					\
   - align_power ((bfd_vma) 16,						\
		  elf_hash_table (info)->tls_sec->alignment_power))
d1233 1
d1259 2
d1559 1
a1559 1
	  tsec_relocs = (_bfd_elf_link_read_relocs
d1633 3
a1635 3
      BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
      dtp_base = alpha_get_dtprel_base (info->link_info);
      tp_base = alpha_get_tprel_base (info->link_info);
d1880 2
a1881 2
	BFD_ASSERT (elf_hash_table (info->link_info)->tls_sec != NULL);
	tp_base = alpha_get_tprel_base (info->link_info);
d1996 47
d2056 1
d2061 1
a2061 1
  if (link_info->relocatable
d2075 1
a2075 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2114 5
d2172 1
a2172 1
	      symval = alpha_get_tprel_base (info.link_info);
d2461 1
a2461 1
     Elf_Internal_Sym *sym;
d2468 1
a2468 1
      && !info->relocatable
d2502 2
a2503 7
  if ((s = bfd_get_section_by_name (abfd, ".got")))
    {
      /* Check for a non-linker created .got?  */
      if (alpha_elf_tdata (abfd)->got == NULL)
	alpha_elf_tdata (abfd)->got = s;
      return TRUE;
    }
d2555 1
a2555 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2599 1
a2599 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d3060 1
a3060 1
  if (info->relocatable)
d3109 1
a3109 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
a3639 1
  bfd_boolean result = TRUE;
d3648 2
a3649 2
	struct alpha_elf_obj_tdata *td;
	bfd_size_type *plge;
a3650 9
	td = alpha_elf_tdata (gotent->gotobj);
	if (td == NULL)
	  {
	    _bfd_error_handler (_("Symbol %s has no GOT subsection for offset 0x%x"),
				h->root.root.root.string, gotent->got_offset);
	    result = FALSE;
	    continue;
	  }
	plge = &td->got->_raw_size;
d3655 1
a3655 1
  return result;
d3724 1
a3724 1
	  /* We are assuming no merging has yet occurred.  */
d3866 1
a3866 1
  if (info->relocatable)
d4093 1
a4093 1
      if (info->executable)
d4177 1
a4177 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4179 1
a4179 1
      if (info->executable)
d4324 1
d4333 1
a4333 1
  if (info->relocatable)
d4378 2
a4379 1
  if (elf_hash_table (info)->tls_sec != NULL)
d4381 2
a4382 2
      dtp_base = alpha_get_dtprel_base (info);
      tp_base = alpha_get_tprel_base (info);
a4423 1
	  asection *msec;
d4426 1
a4426 2
	  msec = sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
d4454 1
d4480 1
a4480 9
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry *hh;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sec, value,
				   unresolved_reloc, warned);
d4482 9
a4490 2
	  if (warned)
	    continue;
d4492 14
a4505 3
	  if (value == 0
	      && ! unresolved_reloc
	      && hh->root.type == bfd_link_hash_undefweak)
d4507 14
a4521 1
	  h = (struct alpha_elf_link_hash_entry *) hh;
d4727 1
a4727 1
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4733 1
a4733 1
		BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4813 1
a4813 1
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4836 1
a4836 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4859 1
a4859 1
	  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4880 1
a4880 1
		  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d5442 1
a5442 1
  if (! bfd_elf_final_link (abfd, info))
a5499 7
static struct bfd_elf_special_section const elf64_alpha_special_sections[]=
{
  { ".sdata", 6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { ".sbss",  5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_ALPHA_GPREL },
  { NULL,     0,  0, 0,            0 }
};

d5559 1
a5559 1
  64, 3,
a5637 3
#define elf_backend_special_sections \
  elf64_alpha_special_sections

d5643 1
@


