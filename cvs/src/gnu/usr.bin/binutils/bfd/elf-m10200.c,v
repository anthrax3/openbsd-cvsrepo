head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.18.56;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.18.56;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.45.36;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.22.51;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.14;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.20;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Matsushita 10200 specific support for 32-bit ELF
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"

static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void mn10200_info_to_howto
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
static boolean mn10200_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
static boolean mn10200_elf_symbol_address_p
  PARAMS ((bfd *, asection *, Elf32_External_Sym *, bfd_vma));

/* We have to use RELA instructions since md_apply_fix3 in the assembler
   does absolutely nothing.  */
#define USE_RELA

enum reloc_type
{
  R_MN10200_NONE = 0,
  R_MN10200_32,
  R_MN10200_16,
  R_MN10200_8,
  R_MN10200_24,
  R_MN10200_PCREL8,
  R_MN10200_PCREL16,
  R_MN10200_PCREL24,
  R_MN10200_MAX
};

static reloc_howto_type elf_mn10200_howto_table[] =
{
  /* Dummy relocation.  Does nothing.  */
  HOWTO (R_MN10200_NONE,
	 0,
	 2,
	 16,
	 false,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_NONE",
	 false,
	 0,
	 0,
	 false),
  /* Standard 32 bit reloc.  */
  HOWTO (R_MN10200_32,
	 0,
	 2,
	 32,
	 false,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_32",
	 false,
	 0xffffffff,
	 0xffffffff,
	 false),
  /* Standard 16 bit reloc.  */
  HOWTO (R_MN10200_16,
	 0,
	 1,
	 16,
	 false,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_16",
	 false,
	 0xffff,
	 0xffff,
	 false),
  /* Standard 8 bit reloc.  */
  HOWTO (R_MN10200_8,
	 0,
	 0,
	 8,
	 false,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_8",
	 false,
	 0xff,
	 0xff,
	 false),
  /* Standard 24 bit reloc.  */
  HOWTO (R_MN10200_24,
	 0,
	 2,
	 24,
	 false,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_24",
	 false,
	 0xffffff,
	 0xffffff,
	 false),
  /* Simple 8 pc-relative reloc.  */
  HOWTO (R_MN10200_PCREL8,
	 0,
	 0,
	 8,
	 true,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_PCREL8",
	 false,
	 0xff,
	 0xff,
	 true),
  /* Simple 16 pc-relative reloc.  */
  HOWTO (R_MN10200_PCREL16,
	 0,
	 1,
	 16,
	 true,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_PCREL16",
	 false,
	 0xffff,
	 0xffff,
	 true),
  /* Simple 32bit pc-relative reloc with a 1 byte adjustment
     to get the pc-relative offset correct.  */
  HOWTO (R_MN10200_PCREL24,
	 0,
	 2,
	 24,
	 true,
	 0,
	 complain_overflow_bitfield,
	 bfd_elf_generic_reloc,
	 "R_MN10200_PCREL24",
	 false,
	 0xffffff,
	 0xffffff,
	 true),
};

struct mn10200_reloc_map
{
  unsigned char bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct mn10200_reloc_map mn10200_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MN10200_NONE, },
  { BFD_RELOC_32, R_MN10200_32, },
  { BFD_RELOC_16, R_MN10200_16, },
  { BFD_RELOC_8, R_MN10200_8, },
  { BFD_RELOC_24, R_MN10200_24, },
  { BFD_RELOC_8_PCREL, R_MN10200_PCREL8, },
  { BFD_RELOC_16_PCREL, R_MN10200_PCREL16, },
  { BFD_RELOC_24_PCREL, R_MN10200_PCREL24, },
};

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = 0;
       i < sizeof (mn10200_reloc_map) / sizeof (struct mn10200_reloc_map);
       i++)
    {
      if (mn10200_reloc_map[i].bfd_reloc_val == code)
	return &elf_mn10200_howto_table[mn10200_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

/* Set the howto pointer for an MN10200 ELF reloc.  */

static void
mn10200_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_MN10200_MAX);
  cache_ptr->howto = &elf_mn10200_howto_table[r_type];
}

/* Perform a relocation as part of a final link.  */
static bfd_reloc_status_type
mn10200_elf_final_link_relocate (howto, input_bfd, output_bfd,
				 input_section, contents, offset, value,
				 addend, info, sym_sec, is_local)
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     int is_local;
{
  unsigned long r_type = howto->type;
  bfd_byte *hit_data = contents + offset;

  switch (r_type)
    {

    case R_MN10200_NONE:
      return bfd_reloc_ok;

    case R_MN10200_32:
      value += addend;
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_16:
      value += addend;

      if ((long)value > 0x7fff || (long)value < -0x8000)
	return bfd_reloc_overflow;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_8:
      value += addend;

      if ((long)value > 0x7fff || (long)value < -0x8000)
	return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_24:
      value += addend;

      if ((long)value > 0x7fffff || (long)value < -0x800000)
	return bfd_reloc_overflow;

      value &= 0xffffff;
      value |= (bfd_get_32 (input_bfd, hit_data) & 0xff000000);
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_PCREL8:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      value += addend;

      if ((long)value > 0xff || (long)value < -0x100)
        return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_PCREL16:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      value += addend;

      if ((long)value > 0xffff || (long)value < -0x10000)
        return bfd_reloc_overflow;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_MN10200_PCREL24:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      value += addend;

      if ((long)value > 0xffffff || (long)value < -0x1000000)
        return bfd_reloc_overflow;

      value &= 0xffffff;
      value |= (bfd_get_32 (input_bfd, hit_data) & 0xff000000);
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    default:
      return bfd_reloc_notsupported;
    }
}


/* Relocate an MN10200 ELF section.  */
static boolean
mn10200_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
      howto = elf_mn10200_howto_table + r_type;

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset)))
		return false;
	      relocation = 0;
	    }
	}

      r = mn10200_elf_final_link_relocate (howto, input_bfd, output_bfd,
					   input_section,
					   contents, rel->r_offset,
					   relocation, rel->r_addend,
					   info, sec, h == NULL);

      if (r != bfd_reloc_ok)
	{
	  const char *name;
	  const char *msg = (const char *)0;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
	      if (name == NULL || *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
	      break;

	    case bfd_reloc_undefined:
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, name, input_bfd, input_section,
		      rel->r_offset)))
		return false;
	      break;

	    case bfd_reloc_outofrange:
	      msg = "internal error: out of range error";
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = "internal error: unsupported relocation error";
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = "internal error: dangerous error";
	      goto common_error;

	    default:
	      msg = "internal error: unknown error";
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return false;
	      break;
	    }
	}
    }

  return true;
}

/* This function handles relaxing for the mn10200.

   There's quite a few relaxing opportunites available on the mn10200:

	* jsr:24 -> jsr:16 					   2 bytes

	* jmp:24 -> jmp:16					   2 bytes
	* jmp:16 -> bra:8					   1 byte

		* If the previous instruction is a conditional branch
		around the jump/bra, we may be able to reverse its condition
		and change its target to the jump's target.  The jump/bra
		can then be deleted.				   2 bytes

	* mov abs24 -> mov abs16	2 byte savings

	* Most instructions which accept imm24 can relax to imm16  2 bytes
	- Most instructions which accept imm16 can relax to imm8   1 byte

	* Most instructions which accept d24 can relax to d16	   2 bytes
	- Most instructions which accept d16 can relax to d8	   1 byte

	abs24, imm24, d24 all look the same at the reloc level.  It
	might make the code simpler if we had different relocs for
	the various relaxable operand types.
   
	We don't handle imm16->imm8 or d16->d8 as they're very rare
	and somewhat more difficult to support.  */

static boolean 
mn10200_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;

  /* Assume nothing changes.  */
  *again = false;

  /* We don't have to do anything for a relocateable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return true;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf32_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      /* If this isn't something that can be relaxed, then ignore
	 this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_NONE
	  || ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_8
	  || ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_MAX)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      /* Read the local symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      /* Go get them off disk.  */
	      extsyms = ((Elf32_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_info
				     * sizeof (Elf32_External_Sym)));
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || (bfd_read (extsyms, sizeof (Elf32_External_Sym),
				symtab_hdr->sh_info, abfd)
		      != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
		goto error_return;
	    }
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  Elf_Internal_Sym isym;
	  asection *sym_sec;

	  /* A local symbol.  */
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irel->r_info),
				    &isym);

	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */


      /* Try to turn a 24bit pc-relative branch/call into a 16bit pc-relative
	 branch/call.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_PCREL24)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 16 bits, note the high value is
	     0x7fff + 2 as the target will be two bytes closer if we are
	     able to relax.  */
	  if ((long)value < 0x8001 && (long)value > -0x8000)
	    {
	      unsigned char code;

	      /* Get the opcode.  */
	      code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

	      if (code != 0xe0 && code != 0xe1)
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      free_relocs = NULL;

	      elf_section_data (sec)->this_hdr.contents = contents;
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;

	      /* Fix the opcode.  */
	      if (code == 0xe0)
		bfd_put_8 (abfd, 0xfc, contents + irel->r_offset - 2);
	      else if (code == 0xe1)
		bfd_put_8 (abfd, 0xfd, contents + irel->r_offset - 2);

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MN10200_PCREL16);

	      /* The opcode got shorter too, so we have to fix the
		 addend and offset too!  */
	      irel->r_addend -= 1;
	      irel->r_offset -= 1;

	      /* Delete two bytes of data.  */
	      if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						   irel->r_offset + 1, 2))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = true;
	    }
	}

      /* Try to turn a 16bit pc-relative branch into a 8bit pc-relative
	 branch.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_PCREL16)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 8 bits, note the high value is
	     0x7f + 1 as the target will be one bytes closer if we are
	     able to relax.  */
	  if ((long)value < 0x80 && (long)value > -0x80)
	    {
	      unsigned char code;

	      /* Get the opcode.  */
	      code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

	      if (code != 0xfc)
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      free_relocs = NULL;

	      elf_section_data (sec)->this_hdr.contents = contents;
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;

	      /* Fix the opcode.  */
	      bfd_put_8 (abfd, 0xea, contents + irel->r_offset - 1);

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MN10200_PCREL8);

	      /* Delete one byte of data.  */
	      if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						   irel->r_offset + 1, 1))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = true;
	    }
	}

      /* Try to eliminate an unconditional 8 bit pc-relative branch
	 which immediately follows a conditional 8 bit pc-relative
	 branch around the unconditional branch.

	    original:		new:
	    bCC lab1		bCC' lab2
	    bra lab2
	   lab1:	       lab1:


	 This happens when the bCC can't reach lab2 at assembly time,
	 but due to other relaxations it can reach at link time.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_PCREL8)
	{
	  Elf_Internal_Rela *nrel;
	  bfd_vma value = symval;
	  unsigned char code;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* Do nothing if this reloc is the last byte in the section.  */
	  if (irel->r_offset == sec->_cooked_size)
	    continue;

	  /* See if the next instruction is an unconditional pc-relative
	     branch, more often than not this test will fail, so we
	     test it first to speed things up.  */
	  code = bfd_get_8 (abfd, contents + irel->r_offset + 1);
	  if (code != 0xea)
	    continue;

	  /* Also make sure the next relocation applies to the next
	     instruction and that it's a pc-relative 8 bit branch.  */
	  nrel = irel + 1;
	  if (nrel == irelend
	      || irel->r_offset + 2 != nrel->r_offset
	      || ELF32_R_TYPE (nrel->r_info) != (int) R_MN10200_PCREL8)
	    continue;

	  /* Make sure our destination immediately follows the
	     unconditional branch.  */
	  if (symval != (sec->output_section->vma + sec->output_offset
			 + irel->r_offset + 3))
	    continue;

	  /* Now make sure we are a conditional branch.  This may not
	     be necessary, but why take the chance. 

	     Note these checks assume that R_MN10200_PCREL8 relocs
	     only occur on bCC and bCCx insns.  If they occured
	     elsewhere, we'd need to know the start of this insn
	     for this check to be accurate.  */
	  code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
	  if (code != 0xe0 && code != 0xe1 && code != 0xe2
	      && code != 0xe3 && code != 0xe4 && code != 0xe5
	      && code != 0xe6 && code != 0xe7 && code != 0xe8
	      && code != 0xe9 && code != 0xec && code != 0xed
	      && code != 0xee && code != 0xef && code != 0xfc
	      && code != 0xfd && code != 0xfe && code != 0xff)
	    continue;

	  /* We also have to be sure there is no symbol/label
	     at the unconditional branch.  */
	  if (mn10200_elf_symbol_address_p (abfd, sec, extsyms,
					    irel->r_offset + 1))
	    continue;

	  /* Note that we've changed the relocs, section contents, etc.  */
	  elf_section_data (sec)->relocs = internal_relocs;
	  free_relocs = NULL;

	  elf_section_data (sec)->this_hdr.contents = contents;
	  free_contents = NULL;

	  symtab_hdr->contents = (bfd_byte *) extsyms;
	  free_extsyms = NULL;

	  /* Reverse the condition of the first branch.  */
	  switch (code)
	    {
	      case 0xfc:
		code = 0xfd;
		break;
	      case 0xfd:
		code = 0xfc;
		break;
	      case 0xfe:
		code = 0xff;
		break;
	      case 0xff:
		code = 0xfe;
		break;
	      case 0xe8:
		code = 0xe9;
		break;
	      case 0xe9:
		code = 0xe8;
		break;
	      case 0xe0:
		code = 0xe2;
		break;
	      case 0xe2:
		code = 0xe0;
		break;
	      case 0xe3:
		code = 0xe1;
		break;
	      case 0xe1:
		code = 0xe3;
		break;
	      case 0xe4:
		code = 0xe6;
		break;
	      case 0xe6:
		code = 0xe4;
		break;
	      case 0xe7:
		code = 0xe5;
		break;
	      case 0xe5:
		code = 0xe7;
		break;
	      case 0xec:
		code = 0xed;
		break;
	      case 0xed:
		code = 0xec;
		break;
	      case 0xee:
		code = 0xef;
		break;
	      case 0xef:
		code = 0xee;
		break;
	    }
	  bfd_put_8 (abfd, code, contents + irel->r_offset - 1);
	  
	  /* Set the reloc type and symbol for the first branch
	     from the second branch.  */
	  irel->r_info = nrel->r_info;

	  /* Make the reloc for the second branch a null reloc.  */
	  nrel->r_info = ELF32_R_INFO (ELF32_R_SYM (nrel->r_info),
				       R_MN10200_NONE);

	  /* Delete two bytes of data.  */
	  if (!mn10200_elf_relax_delete_bytes (abfd, sec,
					       irel->r_offset + 1, 2))
	    goto error_return;

	  /* That will change things, so, we should relax again.
	     Note that this is not required, and it may be slow.  */
	  *again = true;
	}

      /* Try to turn a 24bit immediate, displacement or absolute address
	 into a 16bit immediate, displacement or absolute address.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MN10200_24)
	{
	  bfd_vma value = symval;

	  /* See if the value will fit in 16 bits. 
	     We allow any 16bit match here.  We prune those we can't
	     handle below.  */
	  if ((long)value < 0x7fff && (long)value > -0x8000)
	    {
	      unsigned char code;

	      /* All insns which have 24bit operands are 5 bytes long,
		 the first byte will always be 0xf4, but we double check
		 it just in case.  */

	      /* Get the first opcode.  */
	      code = bfd_get_8 (abfd, contents + irel->r_offset - 2);

	      if (code != 0xf4)
		continue;

	      /* Get the second opcode.  */
	      code = bfd_get_8 (abfd, contents + irel->r_offset - 1);

	      switch (code & 0xfc)
		{
		/* mov imm24,dn -> mov imm16,dn */
		case 0x70:
		  /* Not safe if the high bit is on as relaxing may
		     move the value out of high mem and thus not fit
		     in a signed 16bit value.  */
		  if (value & 0x8000)
		    continue;

		  /* Note that we've changed the reldection contents, etc.  */
		  elf_section_data (sec)->relocs = internal_relocs;
		  free_relocs = NULL;

		  elf_section_data (sec)->this_hdr.contents = contents;
		  free_contents = NULL;

		  symtab_hdr->contents = (bfd_byte *) extsyms;
		  free_extsyms = NULL;

		  /* Fix the opcode.  */
		  bfd_put_8 (abfd, 0xf8 + (code & 0x03),
			     contents + irel->r_offset - 2);

		  /* Fix the relocation's type.  */
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_MN10200_16);

		  /* The opcode got shorter too, so we have to fix the
		     addend and offset too!  */
		  irel->r_offset -= 1;

		  /* Delete two bytes of data.  */
		  if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						       irel->r_offset + 1, 2))
		    goto error_return;

		  /* That will change things, so, we should relax again.
		     Note that this is not required, and it may be slow.  */
		  *again = true;
		  break;

		/* mov imm24,an -> mov imm16,an 
		   cmp imm24,an -> cmp imm16,an
		   mov (abs24),dn -> mov (abs16),dn
		   mov dn,(abs24) -> mov dn,(abs16)
		   movb dn,(abs24) -> movb dn,(abs16)
		   movbu (abs24),dn -> movbu (abs16),dn */
		case 0x74:
		case 0x7c:
		case 0xc0:
		case 0x40:
		case 0x44:
		case 0xc8:
		  /* Note that we've changed the reldection contents, etc.  */
		  elf_section_data (sec)->relocs = internal_relocs;
		  free_relocs = NULL;

		  elf_section_data (sec)->this_hdr.contents = contents;
		  free_contents = NULL;

		  symtab_hdr->contents = (bfd_byte *) extsyms;
		  free_extsyms = NULL;

		  if ((code & 0xfc) == 0x74)
		    code = 0xdc + (code & 0x03);
		  else if ((code & 0xfc) == 0x7c)
		    code = 0xec + (code & 0x03);
		  else if ((code & 0xfc) == 0xc0)
		    code = 0xc8 + (code & 0x03);
		  else if ((code & 0xfc) == 0x40)
		    code = 0xc0 + (code & 0x03);
		  else if ((code & 0xfc) == 0x44)
		    code = 0xc4 + (code & 0x03);
		  else if ((code & 0xfc) == 0xc8)
		    code = 0xcc + (code & 0x03);

		  /* Fix the opcode.  */
		  bfd_put_8 (abfd, code, contents + irel->r_offset - 2);

		  /* Fix the relocation's type.  */
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_MN10200_16);

		  /* The opcode got shorter too, so we have to fix the
		     addend and offset too!  */
		  irel->r_offset -= 1;

		  /* Delete two bytes of data.  */
		  if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						       irel->r_offset + 1, 2))
		    goto error_return;

		  /* That will change things, so, we should relax again.
		     Note that this is not required, and it may be slow.  */
		  *again = true;
		  break;

		/* cmp imm24,dn -> cmp imm16,dn
		   mov (abs24),an -> mov (abs16),an
		   mov an,(abs24) -> mov an,(abs16)
		   add imm24,dn -> add imm16,dn
		   add imm24,an -> add imm16,an
		   sub imm24,dn -> sub imm16,dn
		   sub imm24,an -> sub imm16,an 
		   And all d24->d16 in memory ops.  */
		case 0x78:
		case 0xd0:
		case 0x50:
		case 0x60:
		case 0x64:
		case 0x68:
		case 0x6c:
		case 0x80:
		case 0xf0:
		case 0x00:
		case 0x10:
		case 0xb0:
		case 0x30:
		case 0xa0:
		case 0x20:
		case 0x90:
		  /* Not safe if the high bit is on as relaxing may
		     move the value out of high mem and thus not fit
		     in a signed 16bit value.  */
		  if (((code & 0xfc) == 0x78
			|| (code & 0xfc) == 0x60
			|| (code & 0xfc) == 0x64
			|| (code & 0xfc) == 0x68
			|| (code & 0xfc) == 0x6c
			|| (code & 0xfc) == 0x80
			|| (code & 0xfc) == 0xf0
			|| (code & 0xfc) == 0x00
			|| (code & 0xfc) == 0x10
			|| (code & 0xfc) == 0xb0
			|| (code & 0xfc) == 0x30
			|| (code & 0xfc) == 0xa0
			|| (code & 0xfc) == 0x20
			|| (code & 0xfc) == 0x90)
		       && (value & 0x8000) != 0)
		    continue;

		  /* Note that we've changed the reldection contents, etc.  */
		  elf_section_data (sec)->relocs = internal_relocs;
		  free_relocs = NULL;

		  elf_section_data (sec)->this_hdr.contents = contents;
		  free_contents = NULL;

		  symtab_hdr->contents = (bfd_byte *) extsyms;
		  free_extsyms = NULL;

		  /* Fix the opcode.  */
		  bfd_put_8 (abfd, 0xf7, contents + irel->r_offset - 2);

		  if ((code & 0xfc) == 0x78)
		    code = 0x48 + (code & 0x03);
		  else if ((code & 0xfc) == 0xd0)
		    code = 0x30 + (code & 0x03);
		  else if ((code & 0xfc) == 0x50)
		    code = 0x20 + (code & 0x03);
		  else if ((code & 0xfc) == 0x60)
		    code = 0x18 + (code & 0x03);
		  else if ((code & 0xfc) == 0x64)
		    code = 0x08 + (code & 0x03);
		  else if ((code & 0xfc) == 0x68)
		    code = 0x1c + (code & 0x03);
		  else if ((code & 0xfc) == 0x6c)
		    code = 0x0c + (code & 0x03);
		  else if ((code & 0xfc) == 0x80)
		    code = 0xc0 + (code & 0x07);
		  else if ((code & 0xfc) == 0xf0)
		    code = 0xb0 + (code & 0x07);
		  else if ((code & 0xfc) == 0x00)
		    code = 0x80 + (code & 0x07);
		  else if ((code & 0xfc) == 0x10)
		    code = 0xa0 + (code & 0x07);
		  else if ((code & 0xfc) == 0xb0)
		    code = 0x70 + (code & 0x07);
		  else if ((code & 0xfc) == 0x30)
		    code = 0x60 + (code & 0x07);
		  else if ((code & 0xfc) == 0xa0)
		    code = 0xd0 + (code & 0x07);
		  else if ((code & 0xfc) == 0x20)
		    code = 0x90 + (code & 0x07);
		  else if ((code & 0xfc) == 0x90)
		    code = 0x50 + (code & 0x07);

		  bfd_put_8 (abfd, code, contents + irel->r_offset - 1);

		  /* Fix the relocation's type.  */
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_MN10200_16);

		  /* Delete one bytes of data.  */
		  if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						       irel->r_offset + 2, 1))
		    goto error_return;

		  /* That will change things, so, we should relax again.
		     Note that this is not required, and it may be slow.  */
		  *again = true;
		  break;

		/* movb (abs24),dn ->movbu (abs16),dn extxb bn */
		case 0xc4:
		  /* Note that we've changed the reldection contents, etc.  */
		  elf_section_data (sec)->relocs = internal_relocs;
		  free_relocs = NULL;

		  elf_section_data (sec)->this_hdr.contents = contents;
		  free_contents = NULL;

		  symtab_hdr->contents = (bfd_byte *) extsyms;
		  free_extsyms = NULL;

		  bfd_put_8 (abfd, 0xcc + (code & 0x03),
			     contents + irel->r_offset - 2);

		  bfd_put_8 (abfd, 0xb8 + (code & 0x03),
			     contents + irel->r_offset - 1);

		  /* Fix the relocation's type.  */
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_MN10200_16);

		  /* The reloc will be applied one byte in front of its
		     current location.  */
		  irel->r_offset -= 1;

		  /* Delete one bytes of data.  */
		  if (!mn10200_elf_relax_delete_bytes (abfd, sec,
						       irel->r_offset + 2, 1))
		    goto error_return;

		  /* That will change things, so, we should relax again.
		     Note that this is not required, and it may be slow.  */
		  *again = true;
		  break;
		}
	    }
	}
    }

  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
      free_contents = NULL;
    }

  if (free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (free_extsyms);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = extsyms;
	}
      free_extsyms = NULL;
    }

  return true;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  return false;
}

/* Delete some bytes from a section while relaxing.  */

static boolean
mn10200_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf32_External_Sym *extsyms;
  int shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Rela *irelalign;
  bfd_vma toaddr;
  Elf32_External_Sym *esym, *esymend;
  struct elf_link_hash_entry **sym_hash, **sym_hash_end;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->_cooked_size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
  sec->_cooked_size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr))
	irel->r_offset -= count;
    }

  /* Adjust all the symbols.  */
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++)
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);

      if (isym.st_shndx == shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym);
	}
    }

  sym_hash = elf_sym_hashes (abfd);
  sym_hash_end = (sym_hash
		  + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		     - symtab_hdr->sh_info));
  for (; sym_hash < sym_hash_end; sym_hash++)
    {
      if (((*sym_hash)->root.type == bfd_link_hash_defined
	   || (*sym_hash)->root.type == bfd_link_hash_defweak)
	  && (*sym_hash)->root.u.def.section == sec
	  && (*sym_hash)->root.u.def.value > addr
	  && (*sym_hash)->root.u.def.value < toaddr)
	{
	  (*sym_hash)->root.u.def.value -= count;
	}
    }

  return true;
}

/* Return true if a symbol exists at the given address, else return
   false.  */
static boolean
mn10200_elf_symbol_address_p (abfd, sec, extsyms, addr)
     bfd *abfd;
     asection *sec;
     Elf32_External_Sym *extsyms;
     bfd_vma addr;
{
  Elf_Internal_Shdr *symtab_hdr;
  int shndx;
  Elf32_External_Sym *esym, *esymend;
  struct elf_link_hash_entry **sym_hash, **sym_hash_end;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  /* Examine all the symbols.  */
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++)
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);

      if (isym.st_shndx == shndx
	  && isym.st_value == addr)
	return true;
    }

  sym_hash = elf_sym_hashes (abfd);
  sym_hash_end = (sym_hash
		  + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		     - symtab_hdr->sh_info));
  for (; sym_hash < sym_hash_end; sym_hash++)
    {
      if (((*sym_hash)->root.type == bfd_link_hash_defined
	   || (*sym_hash)->root.type == bfd_link_hash_defweak)
	  && (*sym_hash)->root.u.def.section == sec
	  && (*sym_hash)->root.u.def.value == addr)
	return true;
    }
  return false;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses mn10200_elf_relocate_section.  */

static bfd_byte *
mn10200_elf_get_relocated_section_contents (output_bfd, link_info, link_order,
					    data, relocateable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf32_External_Sym *external_syms = NULL;
  Elf_Internal_Sym *internal_syms = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocateable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocateable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  input_section->_raw_size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      Elf_Internal_Sym *isymp;
      asection **secpp;
      Elf32_External_Sym *esym, *esymend;

      if (symtab_hdr->contents != NULL)
	external_syms = (Elf32_External_Sym *) symtab_hdr->contents;
      else
	{
	  external_syms = ((Elf32_External_Sym *)
			   bfd_malloc (symtab_hdr->sh_info
				       * sizeof (Elf32_External_Sym)));
	  if (external_syms == NULL && symtab_hdr->sh_info > 0)
	    goto error_return;
	  if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || (bfd_read (external_syms, sizeof (Elf32_External_Sym),
			    symtab_hdr->sh_info, input_bfd)
		  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
	    goto error_return;
	}

      internal_relocs = (_bfd_elf32_link_read_relocs
			 (input_bfd, input_section, (PTR) NULL,
			  (Elf_Internal_Rela *) NULL, false));
      if (internal_relocs == NULL)
	goto error_return;

      internal_syms = ((Elf_Internal_Sym *)
		       bfd_malloc (symtab_hdr->sh_info
				   * sizeof (Elf_Internal_Sym)));
      if (internal_syms == NULL && symtab_hdr->sh_info > 0)
	goto error_return;

      sections = (asection **) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (asection *));
      if (sections == NULL && symtab_hdr->sh_info > 0)
	goto error_return;

      isymp = internal_syms;
      secpp = sections;
      esym = external_syms;
      esymend = esym + symtab_hdr->sh_info;
      for (; esym < esymend; ++esym, ++isymp, ++secpp)
	{
	  asection *isec;

	  bfd_elf32_swap_symbol_in (input_bfd, esym, isymp);

	  if (isymp->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isymp->st_shndx > 0 && isymp->st_shndx < SHN_LORESERVE)
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
	  else if (isymp->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isymp->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else
	    {
	      /* Who knows?  */
	      isec = NULL;
	    }

	  *secpp = isec;
	}

      if (! mn10200_elf_relocate_section (output_bfd, link_info, input_bfd,
				     input_section, data, internal_relocs,
				     internal_syms, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      sections = NULL;
      if (internal_syms != NULL)
	free (internal_syms);
      internal_syms = NULL;
      if (external_syms != NULL && symtab_hdr->contents == NULL)
	free (external_syms);
      external_syms = NULL;
      if (internal_relocs != elf_section_data (input_section)->relocs)
	free (internal_relocs);
      internal_relocs = NULL;
    }

  return data;

 error_return:
  if (internal_relocs != NULL
      && internal_relocs != elf_section_data (input_section)->relocs)
    free (internal_relocs);
  if (external_syms != NULL && symtab_hdr->contents == NULL)
    free (external_syms);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
  return NULL;
}


#define TARGET_LITTLE_SYM	bfd_elf32_mn10200_vec
#define TARGET_LITTLE_NAME	"elf32-mn10200"
#define ELF_ARCH		bfd_arch_mn10200
#define ELF_MACHINE_CODE	EM_CYGNUS_MN10200
#define ELF_MAXPAGESIZE		0x1000

#define elf_info_to_howto	mn10200_info_to_howto
#define elf_info_to_howto_rel	0
#define elf_backend_relocate_section mn10200_elf_relocate_section
#define bfd_elf32_bfd_relax_section	mn10200_elf_relax_section
#define bfd_elf32_bfd_get_relocated_section_contents \
				mn10200_elf_get_relocated_section_contents

#define elf_symbol_leading_char '_'

#include "elf32-target.h"
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d170 1
a170 1
  bfd_reloc_code_real_type bfd_reloc_val;
d188 1
a188 1
     bfd *abfd ATTRIBUTE_UNUSED;
d208 1
a208 1
     bfd *abfd ATTRIBUTE_UNUSED;
d226 1
a226 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d232 3
a234 3
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sym_sec ATTRIBUTE_UNUSED;
     int is_local ATTRIBUTE_UNUSED;
d262 1
a262 1
      if ((long)value > 0x7f || (long)value < -0x80)
d282 1
a282 1
      value -= (offset + 1);
d294 1
a294 1
      value -= (offset + 2);
d306 1
a306 1
      value -= (offset + 3);
d411 1
a411 1
		      input_section, rel->r_offset, true)))
d450 1
a450 1
		      rel->r_offset, true)))
d455 1
a455 1
	      msg = _("internal error: out of range error");
d459 1
a459 1
	      msg = _("internal error: unsupported relocation error");
d463 1
a463 1
	      msg = _("internal error: dangerous error");
d467 1
a467 1
	      msg = _("internal error: unknown error");
d589 1
a589 1
      /* Read this BFD's symbols if we haven't done so already.  */
d599 2
a600 1
			 bfd_malloc (symtab_hdr->sh_size));
d605 3
a607 2
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
d668 1
a668 1
	  value -= (irel->r_offset + 3);
d704 3
a706 1
	      /* The opcode got shorter too, so we have to fix the offset.  */
d728 1
a728 1
	  value -= (irel->r_offset + 2);
d792 1
a792 1
	  value -= (irel->r_offset + 1);
d985 1
a985 1
		     offset.  */
d1041 1
a1041 1
		     offset.  */
d1253 1
a1253 1
  int shndx, index;
d1259 1
a1259 1
  struct elf_link_hash_entry *sym_hash;
d1290 1
a1290 1
  /* Adjust the local symbols defined in this section.  */
d1308 5
a1312 4
  /* Now adjust the global symbols defined in this section.  */
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
  for (index = 0; esym < esymend; esym++, index++)
d1314 5
a1318 10
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
      sym_hash = elf_sym_hashes (abfd)[index];
      if (isym.st_shndx == shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value > addr
	  && (sym_hash)->root.u.def.value < toaddr)
d1320 1
a1320 1
	  (sym_hash)->root.u.def.value -= count;
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d38 2
a39 1
enum reloc_type {
d51 2
a52 1
static reloc_howto_type elf_mn10200_howto_table[] = {
d168 2
a169 1
struct mn10200_reloc_map {
d174 8
a181 7
static const struct mn10200_reloc_map mn10200_reloc_map[] = {
  { BFD_RELOC_NONE    , R_MN10200_NONE   , },
  { BFD_RELOC_32      , R_MN10200_32     , },
  { BFD_RELOC_16      , R_MN10200_16     , },
  { BFD_RELOC_8       , R_MN10200_8      , },
  { BFD_RELOC_24      , R_MN10200_24     , },
  { BFD_RELOC_8_PCREL , R_MN10200_PCREL8 , },
d253 1
a253 1
      if ((long) value > 0x7fff || (long) value < -0x8000)
d262 1
a262 1
      if ((long) value > 0x7f || (long) value < -0x80)
d271 1
a271 1
      if ((long) value > 0x7fffff || (long) value < -0x800000)
d285 2
a286 2
      if ((long) value > 0xff || (long) value < -0x100)
	return bfd_reloc_overflow;
d297 2
a298 2
      if ((long) value > 0xffff || (long) value < -0x10000)
	return bfd_reloc_overflow;
d309 2
a310 2
      if ((long) value > 0xffffff || (long) value < -0x1000000)
	return bfd_reloc_overflow;
d321 1
d426 1
a426 1
	  const char *msg = (const char *) 0;
d508 1
a508 1

d512 1
a512 1
static boolean
d657 1
d672 1
a672 1
	  if ((long) value < 0x8001 && (long) value > -0x8000)
d730 1
a730 1
	  if ((long) value < 0x80 && (long) value > -0x80)
d777 1
d817 1
a817 1
	     be necessary, but why take the chance.
d851 54
a904 54
	    case 0xfc:
	      code = 0xfd;
	      break;
	    case 0xfd:
	      code = 0xfc;
	      break;
	    case 0xfe:
	      code = 0xff;
	      break;
	    case 0xff:
	      code = 0xfe;
	      break;
	    case 0xe8:
	      code = 0xe9;
	      break;
	    case 0xe9:
	      code = 0xe8;
	      break;
	    case 0xe0:
	      code = 0xe2;
	      break;
	    case 0xe2:
	      code = 0xe0;
	      break;
	    case 0xe3:
	      code = 0xe1;
	      break;
	    case 0xe1:
	      code = 0xe3;
	      break;
	    case 0xe4:
	      code = 0xe6;
	      break;
	    case 0xe6:
	      code = 0xe4;
	      break;
	    case 0xe7:
	      code = 0xe5;
	      break;
	    case 0xe5:
	      code = 0xe7;
	      break;
	    case 0xec:
	      code = 0xed;
	      break;
	    case 0xed:
	      code = 0xec;
	      break;
	    case 0xee:
	      code = 0xef;
	      break;
	    case 0xef:
	      code = 0xee;
	      break;
d907 1
a907 1

d932 1
a932 1
	  /* See if the value will fit in 16 bits.
d935 1
a935 1
	  if ((long) value < 0x7fff && (long) value > -0x8000)
d994 1
a994 1
		/* mov imm24,an -> mov imm16,an
d1056 1
a1056 1
		   sub imm24,an -> sub imm16,an
d1078 14
a1091 14
		       || (code & 0xfc) == 0x60
		       || (code & 0xfc) == 0x64
		       || (code & 0xfc) == 0x68
		       || (code & 0xfc) == 0x6c
		       || (code & 0xfc) == 0x80
		       || (code & 0xfc) == 0xf0
		       || (code & 0xfc) == 0x00
		       || (code & 0xfc) == 0x10
		       || (code & 0xfc) == 0xb0
		       || (code & 0xfc) == 0x30
		       || (code & 0xfc) == 0xa0
		       || (code & 0xfc) == 0x20
		       || (code & 0xfc) == 0x90)
		      && (value & 0x8000) != 0)
d1508 1
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d29 2
a30 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean mn10200_elf_relax_delete_bytes
d32 6
a37 15
static bfd_boolean mn10200_elf_symbol_address_p
  PARAMS ((bfd *, asection *, Elf_Internal_Sym *, bfd_vma));
static bfd_reloc_status_type mn10200_elf_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *,
	   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
	   struct bfd_link_info *, asection *, int));
static bfd_boolean mn10200_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *,
	   asection **));
static bfd_boolean mn10200_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_byte * mn10200_elf_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
d57 1
a57 1
	 FALSE,
d62 1
a62 1
	 FALSE,
d65 1
a65 1
	 FALSE),
d71 1
a71 1
	 FALSE,
d76 1
a76 1
	 FALSE,
d79 1
a79 1
	 FALSE),
d85 1
a85 1
	 FALSE,
d90 1
a90 1
	 FALSE,
d93 1
a93 1
	 FALSE),
d99 1
a99 1
	 FALSE,
d104 1
a104 1
	 FALSE,
d107 1
a107 1
	 FALSE),
d113 1
a113 1
	 FALSE,
d118 1
a118 1
	 FALSE,
d121 1
a121 1
	 FALSE),
d127 1
a127 1
	 TRUE,
d132 1
a132 1
	 FALSE,
d135 1
a135 1
	 TRUE),
d141 1
a141 1
	 TRUE,
d146 1
a146 1
	 FALSE,
d149 1
a149 1
	 TRUE),
d156 1
a156 1
	 TRUE,
d161 1
a161 1
	 FALSE,
d164 1
a164 1
	 TRUE),
d207 1
a207 1
     Elf_Internal_Rela *dst;
a216 1

d320 1
a320 1
static bfd_boolean
a335 3
  if (info->relocateable)
    return TRUE;

d356 20
d383 3
a385 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d407 2
a408 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d440 1
a440 1
		return FALSE;
d446 2
a447 2
		      rel->r_offset, TRUE)))
		return FALSE;
d470 1
a470 1
		return FALSE;
d476 1
a476 1
  return TRUE;
d508 1
a508 1
static bfd_boolean
d513 1
a513 1
     bfd_boolean *again;
d517 1
d520 3
a522 1
  Elf_Internal_Sym *isymbuf = NULL;
d525 1
a525 1
  *again = FALSE;
d534 1
a534 1
    return TRUE;
d549 2
d577 1
d585 2
a586 2
      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d588 16
a603 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d609 3
d613 3
a615 2
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;
d617 2
a618 10
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
d679 2
d682 4
a685 1
	      symtab_hdr->contents = (unsigned char *) isymbuf;
d707 1
a707 1
	      *again = TRUE;
d737 2
d740 4
a743 1
	      symtab_hdr->contents = (unsigned char *) isymbuf;
d759 1
a759 1
	      *again = TRUE;
d828 1
a828 1
	  if (mn10200_elf_symbol_address_p (abfd, sec, isymbuf,
d834 2
d837 4
a840 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d917 1
a917 1
	  *again = TRUE;
d958 2
d961 4
a964 1
		  symtab_hdr->contents = (unsigned char *) isymbuf;
d985 1
a985 1
		  *again = TRUE;
d1002 2
d1005 4
a1008 1
		  symtab_hdr->contents = (unsigned char *) isymbuf;
d1041 1
a1041 1
		  *again = TRUE;
d1090 2
d1093 4
a1096 1
		  symtab_hdr->contents = (unsigned char *) isymbuf;
d1147 1
a1147 1
		  *again = TRUE;
d1154 2
d1157 4
a1160 1
		  symtab_hdr->contents = (unsigned char *) isymbuf;
d1183 1
a1183 1
		  *again = TRUE;
d1190 7
a1196 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1199 1
a1199 1
	free (isymbuf);
d1202 2
a1203 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1205 1
d1208 1
a1208 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d1211 1
a1211 1
	free (contents);
d1214 2
a1215 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
d1217 1
d1220 1
a1220 5
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;
d1223 7
a1229 11
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
d1234 1
a1234 1
static bfd_boolean
d1242 2
a1243 1
  unsigned int sec_shndx;
d1248 5
a1252 5
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
d1254 1
a1254 1
  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1268 1
a1268 2
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
d1281 3
a1283 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
d1285 11
a1295 4
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
d1299 3
a1301 5
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
d1303 10
a1312 6
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
d1314 1
a1314 1
	  sym_hash->root.u.def.value -= count;
d1318 1
a1318 1
  return TRUE;
d1321 4
a1324 4
/* Return TRUE if a symbol exists at the given address, else return
   FALSE.  */
static bfd_boolean
mn10200_elf_symbol_address_p (abfd, sec, isym, addr)
d1327 1
a1327 1
     Elf_Internal_Sym *isym;
d1331 3
a1333 5
  unsigned int sec_shndx;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
d1335 2
a1336 1
  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1338 4
a1341 3
  /* Examine all the local symbols.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
d1343 7
a1349 3
      if (isym->st_shndx == sec_shndx
	  && isym->st_value == addr)
	return TRUE;
d1352 5
a1356 5
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
d1358 5
a1362 6
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value == addr)
	return TRUE;
d1364 1
a1364 2

  return FALSE;
d1377 1
a1377 1
     bfd_boolean relocateable;
d1385 2
a1386 1
  Elf_Internal_Sym *isymbuf = NULL;
d1400 1
a1400 1
	  (size_t) input_section->_raw_size);
d1405 1
a1405 2
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
d1407 17
a1423 1
      bfd_size_type amt;
d1427 1
a1427 1
			  (Elf_Internal_Rela *) NULL, FALSE));
d1431 5
a1435 10
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}
d1437 3
a1439 4
      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL && amt != 0)
d1442 5
a1446 2
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
d1450 3
a1452 1
	  if (isym->st_shndx == SHN_UNDEF)
d1454 3
a1456 1
	  else if (isym->st_shndx == SHN_ABS)
d1458 1
a1458 1
	  else if (isym->st_shndx == SHN_COMMON)
d1461 4
a1464 1
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
d1471 1
a1471 1
				     isymbuf, sections))
d1476 8
a1483 4
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
d1485 1
d1491 7
a1499 6
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
d1506 1
a1506 2
#define ELF_MACHINE_CODE	EM_MN10200
#define ELF_MACHINE_ALT1	EM_CYGNUS_MN10200
a1508 1
#define elf_backend_rela_normal 1
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d346 1
a346 1
  if (info->relocatable)
d376 1
a376 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d380 22
a401 6
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d472 1
a472 1
   There are quite a few relaxing opportunities available on the mn10200:
d515 1
a515 1
  /* We don't have to do anything for a relocatable link, if
d518 1
a518 1
  if (link_info->relocatable
d532 1
a532 1
  internal_relocs = (_bfd_elf_link_read_relocs
d921 1
a921 1
		  /* Note that we've changed the relocation contents, etc.  */
d960 1
a960 1
		  /* Note that we've changed the relocation contents, etc.  */
d1043 1
a1043 1
		  /* Note that we've changed the relocation contents, etc.  */
d1308 1
a1308 1
					    data, relocatable, symbols)
d1313 1
a1313 1
     bfd_boolean relocatable;
d1325 1
a1325 1
  if (relocatable
d1329 1
a1329 1
						       relocatable,
d1345 1
a1345 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


