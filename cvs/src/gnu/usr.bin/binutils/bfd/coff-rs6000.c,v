head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.20
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.18
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.14
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.10
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.04.19.23.20.53;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.08;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.33;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.33;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.06;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.18.13;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.28;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.21.15;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Use time_t instead of long for archive timestamps, and print them as long long;
prodding deraadt@@
@
text
@/* BFD back-end for IBM RS/6000 "XCOFF" files.
   Copyright 1990-1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   FIXME: Can someone provide a transliteration of this name into ASCII?
   Using the following chars caused a compiler warning on HIUX (so I replaced
   them with octal escapes), and isn't useful without an understanding of what
   character set it is.
   Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,
     and John Gilmore.
   Archive support from Damon A. Permezel.
   Contributed by IBM Corporation and Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/xcoff.h"
#include "coff/rs6000.h"
#include "libcoff.h"
#include "libxcoff.h"

extern bfd_boolean _bfd_xcoff_mkobject
  PARAMS ((bfd *));
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_xcoff_is_local_label_name
  PARAMS ((bfd *, const char *));
extern reloc_howto_type *_bfd_xcoff_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
extern bfd_boolean _bfd_xcoff_slurp_armap
  PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p
  PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr
  PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
extern bfd_boolean _bfd_xcoff_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
extern bfd_boolean _bfd_xcoff_write_archive_contents
  PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
extern void _bfd_xcoff_swap_sym_in
  PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out
  PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
extern unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in
  PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out
  PARAMS ((bfd *, PTR, PTR));

/* Forward declare xcoff_rtype2howto for coffcode.h macro.  */
void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));

/* coffcode.h needs these to be defined.  */
#define RS6000COFF_C 1

#define SELECT_RELOC(internal, howto)					\
  {									\
    internal.r_type = howto->type;					\
    internal.r_size =							\
      ((howto->complain_on_overflow == complain_overflow_signed		\
	? 0x80								\
	: 0)								\
       | (howto->bitsize - 1));						\
  }

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)
#define COFF_LONG_FILENAMES
#define NO_COFF_SYMBOLS
#define RTYPE2HOWTO(cache_ptr, dst) xcoff_rtype2howto (cache_ptr, dst)
#define coff_mkobject _bfd_xcoff_mkobject
#define coff_bfd_copy_private_bfd_data _bfd_xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup _bfd_xcoff_reloc_type_lookup
#ifdef AIX_CORE
extern const bfd_target * rs6000coff_core_p
  PARAMS ((bfd *abfd));
extern bfd_boolean rs6000coff_core_file_matches_executable_p
  PARAMS ((bfd *cbfd, bfd *ebfd));
extern char *rs6000coff_core_file_failing_command
  PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal
  PARAMS ((bfd *abfd));
#define CORE_FILE_P rs6000coff_core_p
#define coff_core_file_failing_command \
  rs6000coff_core_file_failing_command
#define coff_core_file_failing_signal \
  rs6000coff_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  rs6000coff_core_file_matches_executable_p
#else
#define CORE_FILE_P _bfd_dummy_target
#define coff_core_file_failing_command \
  _bfd_nocore_core_file_failing_command
#define coff_core_file_failing_signal \
  _bfd_nocore_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  _bfd_nocore_core_file_matches_executable_p
#endif
#define coff_SWAP_sym_in _bfd_xcoff_swap_sym_in
#define coff_SWAP_sym_out _bfd_xcoff_swap_sym_out
#define coff_SWAP_aux_in _bfd_xcoff_swap_aux_in
#define coff_SWAP_aux_out _bfd_xcoff_swap_aux_out
#define coff_swap_reloc_in xcoff_swap_reloc_in
#define coff_swap_reloc_out xcoff_swap_reloc_out
#define NO_COFF_RELOCS

#include "coffcode.h"

/* The main body of code is in coffcode.h.  */

static const char *normalize_filename
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_armap_old
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static bfd_boolean xcoff_write_armap_big
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static bfd_boolean xcoff_write_archive_contents_old
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_archive_contents_big
  PARAMS ((bfd *));
static void xcoff_swap_ldhdr_in
  PARAMS ((bfd *, const PTR, struct internal_ldhdr *));
static void xcoff_swap_ldhdr_out
  PARAMS ((bfd *, const struct internal_ldhdr *, PTR));
static void xcoff_swap_ldsym_in
  PARAMS ((bfd *, const PTR, struct internal_ldsym *));
static void xcoff_swap_ldsym_out
  PARAMS ((bfd *, const struct internal_ldsym *, PTR));
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const PTR, struct internal_ldrel *));
static void xcoff_swap_ldrel_out
  PARAMS ((bfd *, const struct internal_ldrel *, PTR));
static bfd_boolean xcoff_ppc_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean _bfd_xcoff_put_ldsymbol_name
  PARAMS ((bfd *, struct xcoff_loader_info *, struct internal_ldsym *,
	   const char *));
static asection *xcoff_create_csect_from_smclas
  PARAMS ((bfd *, union internal_auxent *, const char *));
static bfd_boolean xcoff_is_lineno_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean xcoff_is_reloc_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_vma xcoff_loader_symbol_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
static bfd_vma xcoff_loader_reloc_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
static bfd_boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
static bfd_boolean do_pad
  PARAMS ((bfd *, unsigned int));
static bfd_boolean do_copy
  PARAMS ((bfd *, bfd *));
static bfd_boolean do_shared_object_padding
  PARAMS ((bfd *, bfd *, ufile_ptr *, int));

/* Relocation functions */
static bfd_boolean xcoff_reloc_type_br
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));

static bfd_boolean xcoff_complain_overflow_dont_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_bitfield_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_signed_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_unsigned_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));

bfd_boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS)) =
{
  xcoff_reloc_type_pos,	 /* R_POS   (0x00) */
  xcoff_reloc_type_neg,	 /* R_NEG   (0x01) */
  xcoff_reloc_type_rel,	 /* R_REL   (0x02) */
  xcoff_reloc_type_toc,	 /* R_TOC   (0x03) */
  xcoff_reloc_type_fail, /* R_RTB   (0x04) */
  xcoff_reloc_type_toc,	 /* R_GL    (0x05) */
  xcoff_reloc_type_toc,	 /* R_TCL   (0x06) */
  xcoff_reloc_type_fail, /*	    (0x07) */
  xcoff_reloc_type_ba,	 /* R_BA    (0x08) */
  xcoff_reloc_type_fail, /*	    (0x09) */
  xcoff_reloc_type_br,	 /* R_BR    (0x0a) */
  xcoff_reloc_type_fail, /*	    (0x0b) */
  xcoff_reloc_type_pos,	 /* R_RL    (0x0c) */
  xcoff_reloc_type_pos,	 /* R_RLA   (0x0d) */
  xcoff_reloc_type_fail, /*	    (0x0e) */
  xcoff_reloc_type_noop, /* R_REF   (0x0f) */
  xcoff_reloc_type_fail, /*	    (0x10) */
  xcoff_reloc_type_fail, /*	    (0x11) */
  xcoff_reloc_type_toc,	 /* R_TRL   (0x12) */
  xcoff_reloc_type_toc,	 /* R_TRLA  (0x13) */
  xcoff_reloc_type_fail, /* R_RRTBI (0x14) */
  xcoff_reloc_type_fail, /* R_RRTBA (0x15) */
  xcoff_reloc_type_ba,	 /* R_CAI   (0x16) */
  xcoff_reloc_type_crel, /* R_CREL  (0x17) */
  xcoff_reloc_type_ba,	 /* R_RBA   (0x18) */
  xcoff_reloc_type_ba,	 /* R_RBAC  (0x19) */
  xcoff_reloc_type_br,	 /* R_RBR   (0x1a) */
  xcoff_reloc_type_ba,	 /* R_RBRC  (0x1b) */
};

bfd_boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS)) =
{
  xcoff_complain_overflow_dont_func,
  xcoff_complain_overflow_bitfield_func,
  xcoff_complain_overflow_signed_func,
  xcoff_complain_overflow_unsigned_func,
};

/* We use our own tdata type.  Its first field is the COFF tdata type,
   so the COFF routines are compatible.  */

bfd_boolean
_bfd_xcoff_mkobject (abfd)
     bfd *abfd;
{
  coff_data_type *coff;
  bfd_size_type amt = sizeof (struct xcoff_tdata);

  abfd->tdata.xcoff_obj_data = (struct xcoff_tdata *) bfd_zalloc (abfd, amt);
  if (abfd->tdata.xcoff_obj_data == NULL)
    return FALSE;
  coff = coff_data (abfd);
  coff->symbols = (coff_symbol_type *) NULL;
  coff->conversion_table = (unsigned int *) NULL;
  coff->raw_syments = (struct coff_ptr_struct *) NULL;
  coff->relocbase = 0;

  xcoff_data (abfd)->modtype = ('1' << 8) | 'L';

  /* We set cputype to -1 to indicate that it has not been
     initialized.  */
  xcoff_data (abfd)->cputype = -1;

  xcoff_data (abfd)->csects = NULL;
  xcoff_data (abfd)->debug_indices = NULL;

  /* text section alignment is different than the default */
  bfd_xcoff_text_align_power (abfd) = 2;

  return TRUE;
}

/* Copy XCOFF data from one BFD to another.  */

bfd_boolean
_bfd_xcoff_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  struct xcoff_tdata *ix, *ox;
  asection *sec;

  if (ibfd->xvec != obfd->xvec)
    return TRUE;
  ix = xcoff_data (ibfd);
  ox = xcoff_data (obfd);
  ox->full_aouthdr = ix->full_aouthdr;
  ox->toc = ix->toc;
  if (ix->sntoc == 0)
    ox->sntoc = 0;
  else
    {
      sec = coff_section_from_bfd_index (ibfd, ix->sntoc);
      if (sec == NULL)
	ox->sntoc = 0;
      else
	ox->sntoc = sec->output_section->target_index;
    }
  if (ix->snentry == 0)
    ox->snentry = 0;
  else
    {
      sec = coff_section_from_bfd_index (ibfd, ix->snentry);
      if (sec == NULL)
	ox->snentry = 0;
      else
	ox->snentry = sec->output_section->target_index;
    }
  bfd_xcoff_text_align_power (obfd) = bfd_xcoff_text_align_power (ibfd);
  bfd_xcoff_data_align_power (obfd) = bfd_xcoff_data_align_power (ibfd);
  ox->modtype = ix->modtype;
  ox->cputype = ix->cputype;
  ox->maxdata = ix->maxdata;
  ox->maxstack = ix->maxstack;
  return TRUE;
}

/* I don't think XCOFF really has a notion of local labels based on
   name.  This will mean that ld -X doesn't actually strip anything.
   The AIX native linker does not have a -X option, and it ignores the
   -x option.  */

bfd_boolean
_bfd_xcoff_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
{
  return FALSE;
}

void
_bfd_xcoff_swap_sym_in (abfd, ext1, in1)
     bfd *abfd;
     PTR ext1;
     PTR in1;
{
  SYMENT *ext = (SYMENT *)ext1;
  struct internal_syment * in = (struct internal_syment *)in1;

  if (ext->e.e_name[0] != 0)
    {
      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
    }
  else
    {
      in->_n._n_n._n_zeroes = 0;
      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
    }

  in->n_value = H_GET_32 (abfd, ext->e_value);
  in->n_scnum = H_GET_16 (abfd, ext->e_scnum);
  in->n_type = H_GET_16 (abfd, ext->e_type);
  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);
}

unsigned int
_bfd_xcoff_swap_sym_out (abfd, inp, extp)
     bfd *abfd;
     PTR inp;
     PTR extp;
{
  struct internal_syment *in = (struct internal_syment *)inp;
  SYMENT *ext =(SYMENT *)extp;

  if (in->_n._n_name[0] != 0)
    {
      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
    }
  else
    {
      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
    }

  H_PUT_32 (abfd, in->n_value, ext->e_value);
  H_PUT_16 (abfd, in->n_scnum, ext->e_scnum);
  H_PUT_16 (abfd, in->n_type, ext->e_type);
  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);
  return bfd_coff_symesz (abfd);
}

void
_bfd_xcoff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
     bfd *abfd;
     PTR ext1;
     int type;
     int class;
     int indx;
     int numaux;
     PTR in1;
{
  AUXENT * ext = (AUXENT *)ext1;
  union internal_auxent *in = (union internal_auxent *)in1;

  switch (class)
    {
    case C_FILE:
      if (ext->x_file.x_fname[0] == 0)
	{
	  in->x_file.x_n.x_zeroes = 0;
	  in->x_file.x_n.x_offset =
	    H_GET_32 (abfd, ext->x_file.x_n.x_offset);
	}
      else
	{
	  if (numaux > 1)
	    {
	      if (indx == 0)
		memcpy (in->x_file.x_fname, ext->x_file.x_fname,
			numaux * sizeof (AUXENT));
	    }
	  else
	    {
	      memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	    }
	}
      goto end;

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  in->x_csect.x_scnlen.l = H_GET_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = H_GET_32 (abfd, ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = H_GET_16 (abfd, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  in->x_csect.x_smtyp    = H_GET_8 (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = H_GET_8 (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = H_GET_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = H_GET_16 (abfd, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  in->x_scn.x_scnlen = H_GET_32 (abfd, ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = H_GET_16 (abfd, ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = H_GET_16 (abfd, ext->x_scn.x_nlinno);
	  /* PE defines some extra fields; we zero them out for
	     safety.  */
	  in->x_scn.x_checksum = 0;
	  in->x_scn.x_associated = 0;
	  in->x_scn.x_comdat = 0;

	  goto end;
	}
      break;
    }

  in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = H_GET_16 (abfd, ext->x_sym.x_tvndx);

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    {
      in->x_sym.x_misc.x_fsize = H_GET_32 (abfd, ext->x_sym.x_misc.x_fsize);
    }
  else
    {
      in->x_sym.x_misc.x_lnsz.x_lnno =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_lnno);
      in->x_sym.x_misc.x_lnsz.x_size =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_size);
    }

 end: ;
  /* The semicolon is because MSVC doesn't like labels at
     end of block.  */
}


unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));

unsigned int
_bfd_xcoff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
     bfd * abfd;
     PTR   inp;
     int   type;
     int   class;
     int   indx ATTRIBUTE_UNUSED;
     int   numaux ATTRIBUTE_UNUSED;
     PTR   extp;
{
  union internal_auxent *in = (union internal_auxent *)inp;
  AUXENT *ext = (AUXENT *)extp;

  memset ((PTR)ext, 0, bfd_coff_auxesz (abfd));
  switch (class)
    {
    case C_FILE:
      if (in->x_file.x_fname[0] == 0)
	{
	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_zeroes);
	  H_PUT_32 (abfd, in->x_file.x_n.x_offset, ext->x_file.x_n.x_offset);
	}
      else
	{
	  memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
	}
      goto end;

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  H_PUT_32 (abfd, in->x_csect.x_scnlen.l, ext->x_csect.x_scnlen);
	  H_PUT_32 (abfd, in->x_csect.x_parmhash, ext->x_csect.x_parmhash);
	  H_PUT_16 (abfd, in->x_csect.x_snhash, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  H_PUT_8 (abfd, in->x_csect.x_smtyp, ext->x_csect.x_smtyp);
	  H_PUT_8 (abfd, in->x_csect.x_smclas, ext->x_csect.x_smclas);
	  H_PUT_32 (abfd, in->x_csect.x_stab, ext->x_csect.x_stab);
	  H_PUT_16 (abfd, in->x_csect.x_snstab, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  H_PUT_32 (abfd, in->x_scn.x_scnlen, ext->x_scn.x_scnlen);
	  H_PUT_16 (abfd, in->x_scn.x_nreloc, ext->x_scn.x_nreloc);
	  H_PUT_16 (abfd, in->x_scn.x_nlinno, ext->x_scn.x_nlinno);
	  goto end;
	}
      break;
    }

  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
  H_PUT_16 (abfd, in->x_sym.x_tvndx, ext->x_sym.x_tvndx);

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
		ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_endndx.l,
		ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    H_PUT_32 (abfd, in->x_sym.x_misc.x_fsize, ext->x_sym.x_misc.x_fsize);
  else
    {
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
		ext->x_sym.x_misc.x_lnsz.x_lnno);
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_size,
		ext->x_sym.x_misc.x_lnsz.x_size);
    }

end:
  return bfd_coff_auxesz (abfd);
}



/* The XCOFF reloc table.  Actually, XCOFF relocations specify the
   bitsize and whether they are signed or not, along with a
   conventional type.  This table is for the types, which are used for
   different algorithms for putting in the reloc.  Many of these
   relocs need special_function entries, which I have not written.  */


reloc_howto_type xcoff_howto_table[] =
{
  /* Standard 32 bit relocation.  */
  HOWTO (R_POS,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_POS",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation, but store negative value.  */
  HOWTO (R_NEG,			/* type */
	 0,			/* rightshift */
	 -2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_NEG",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit PC relative relocation.  */
  HOWTO (R_REL,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit TOC relative relocation.  */
  HOWTO (R_TOC,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TOC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* I don't really know what this is.  */
  HOWTO (R_RTB,			/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RTB",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* External TOC relative symbol.  */
  HOWTO (R_GL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_GL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Local TOC relative symbol.	 */
  HOWTO (R_TCL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TCL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (7),

  /* Non modifiable absolute branch.  */
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BA_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (9),

  /* Non modifiable relative branch.  */
  HOWTO (R_BR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0xb),

  /* Indirect load.  */
  HOWTO (R_RL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Load address.  */
  HOWTO (R_RLA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0xe),

  /* Non-relocating reference.  */
  HOWTO (R_REF,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REF",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0x10),
  EMPTY_HOWTO (0x11),

  /* TOC relative indirect load.  */
  HOWTO (R_TRL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TRL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TOC relative load address.  */
  HOWTO (R_TRLA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TRLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable relative branch.  */
  HOWTO (R_RRTBI,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RRTBI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable absolute branch.  */
  HOWTO (R_RRTBA,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RRTBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable call absolute indirect.  */
  HOWTO (R_CAI,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_CAI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable call relative.  */
  HOWTO (R_CREL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_CREL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (R_RBAC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBAC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch relative.  */
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBR_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch absolute.  */
  HOWTO (R_RBRC,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBRC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit Non modifiable absolute branch.  */
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch relative.  */
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBR_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Modifiable branch relative.  */
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

};

void
xcoff_rtype2howto (relent, internal)
     arelent *relent;
     struct internal_reloc *internal;
{
  if (internal->r_type > R_RBRC)
    abort ();

  /* Default howto layout works most of the time */
  relent->howto = &xcoff_howto_table[internal->r_type];

  /* Special case some 16 bit reloc */
  if (15 == (internal->r_size & 0x1f))
    {
      if (R_BA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1c];
      else if (R_RBR == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1d];
      else if (R_RBA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1e];
    }

  /* The r_size field of an XCOFF reloc encodes the bitsize of the
     relocation, as well as indicating whether it is signed or not.
     Doublecheck that the relocation information gathered from the
     type matches this information.  The bitsize is not significant
     for R_REF relocs.  */
  if (relent->howto->dst_mask != 0
      && (relent->howto->bitsize
	  != ((unsigned int) internal->r_size & 0x1f) + 1))
    abort ();
}

reloc_howto_type *
_bfd_xcoff_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  switch (code)
    {
    case BFD_RELOC_PPC_B26:
      return &xcoff_howto_table[0xa];
    case BFD_RELOC_PPC_BA16:
      return &xcoff_howto_table[0x1c];
    case BFD_RELOC_PPC_BA26:
      return &xcoff_howto_table[8];
    case BFD_RELOC_PPC_TOC16:
      return &xcoff_howto_table[3];
    case BFD_RELOC_32:
    case BFD_RELOC_CTOR:
      return &xcoff_howto_table[0];
    default:
      return NULL;
    }
}


/* XCOFF archive support.  The original version of this code was by
   Damon A. Permezel.  It was enhanced to permit cross support, and
   writing archive files, by Ian Lance Taylor, Cygnus Support.

   XCOFF uses its own archive format.  Everything is hooked together
   with file offset links, so it is possible to rapidly update an
   archive in place.  Of course, we don't do that.  An XCOFF archive
   has a real file header, not just an ARMAG string.  The structure of
   the file header and of each archive header appear below.

   An XCOFF archive also has a member table, which is a list of
   elements in the archive (you can get that by looking through the
   linked list, but you have to read a lot more of the file).  The
   member table has a normal archive header with an empty name.  It is
   normally (and perhaps must be) the second to last entry in the
   archive.  The member table data is almost printable ASCII.  It
   starts with a 12 character decimal string which is the number of
   entries in the table.  For each entry it has a 12 character decimal
   string which is the offset in the archive of that member.  These
   entries are followed by a series of null terminated strings which
   are the member names for each entry.

   Finally, an XCOFF archive has a global symbol table, which is what
   we call the armap.  The global symbol table has a normal archive
   header with an empty name.  It is normally (and perhaps must be)
   the last entry in the archive.  The contents start with a four byte
   binary number which is the number of entries.  This is followed by
   a that many four byte binary numbers; each is the file offset of an
   entry in the archive.  These numbers are followed by a series of
   null terminated strings, which are symbol names.

   AIX 4.3 introduced a new archive format which can handle larger
   files and also 32- and 64-bit objects in the same archive.  The
   things said above remain true except that there is now more than
   one global symbol table.  The one is used to index 32-bit objects,
   the other for 64-bit objects.

   The new archives (recognizable by the new ARMAG string) has larger
   field lengths so that we cannot really share any code.  Also we have
   to take care that we are not generating the new form of archives
   on AIX 4.2 or earlier systems.  */

/* XCOFF archives use this as a magic string.  Note that both strings
   have the same length.  */

/* Set the magic for archive.  */

bfd_boolean
bfd_xcoff_ar_archive_set_magic (abfd, magic)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *magic ATTRIBUTE_UNUSED;
{
  /* Not supported yet.  */
  return FALSE;
 /* bfd_xcoff_archive_set_magic (abfd, magic); */
}

/* Read in the armap of an XCOFF archive.  */

bfd_boolean
_bfd_xcoff_slurp_armap (abfd)
     bfd *abfd;
{
  file_ptr off;
  size_t namlen;
  bfd_size_type sz;
  bfd_byte *contents, *cend;
  bfd_vma c, i;
  carsym *arsym;
  bfd_byte *p;

  if (xcoff_ardata (abfd) == NULL)
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  if (! xcoff_big_format_p (abfd))
    {
      /* This is for the old format.  */
      struct xcoff_ar_hdr hdr;

      off = strtol (xcoff_ardata (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
	}

      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return FALSE;

      /* The symbol table starts with a normal archive header.  */
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
	return FALSE;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;

      sz = strtol (hdr.size, (char **) NULL, 10);

      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return FALSE;
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
	return FALSE;

      /* The symbol table starts with a four byte count.  */
      c = H_GET_32 (abfd, contents);

      if (c * 4 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return FALSE;

      /* After the count comes a list of four byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;
	   i < c;
	   ++i, ++arsym, p += 4)
	arsym->file_offset = H_GET_32 (abfd, p);
    }
  else
    {
      /* This is for the new format.  */
      struct xcoff_ar_hdr_big hdr;

      off = strtol (xcoff_ardata_big (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
	}

      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return FALSE;

      /* The symbol table starts with a normal archive header.  */
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG)
	return FALSE;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;

      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      sz = strtol (hdr.size, (char **) NULL, 10);

      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return FALSE;
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
	return FALSE;

      /* The symbol table starts with an eight byte count.  */
      c = H_GET_64 (abfd, contents);

      if (c * 8 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return FALSE;

      /* After the count comes a list of eight byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;
	   i < c;
	   ++i, ++arsym, p += 8)
	arsym->file_offset = H_GET_64 (abfd, p);
    }

  /* After the file offsets come null terminated symbol names.  */
  cend = contents + sz;
  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;
       i < c;
       ++i, ++arsym, p += strlen ((char *) p) + 1)
    {
      if (p >= cend)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      arsym->name = (char *) p;
    }

  bfd_ardata (abfd)->symdef_count = c;
  bfd_has_map (abfd) = TRUE;

  return TRUE;
}

/* See if this is an XCOFF archive.  */

const bfd_target *
_bfd_xcoff_archive_p (abfd)
     bfd *abfd;
{
  struct artdata *tdata_hold;
  char magic[SXCOFFARMAG];
  bfd_size_type amt = SXCOFFARMAG;

  if (bfd_bread ((PTR) magic, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (strncmp (magic, XCOFFARMAG, SXCOFFARMAG) != 0
      && strncmp (magic, XCOFFARMAGBIG, SXCOFFARMAG) != 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  tdata_hold = bfd_ardata (abfd);

  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == (struct artdata *) NULL)
    goto error_ret_restore;

  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;

  /* Now handle the two formats.  */
  if (magic[1] != 'b')
    {
      /* This is the old format.  */
      struct xcoff_ar_file_hdr hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      amt = SIZEOF_AR_FILE_HDR - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  goto error_ret;
	}

      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);

      amt = SIZEOF_AR_FILE_HDR;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
      if (bfd_ardata (abfd)->tdata == NULL)
	goto error_ret;

      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR);
    }
  else
    {
      /* This is the new format.  */
      struct xcoff_ar_file_hdr_big hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      amt = SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  goto error_ret;
	}

      bfd_ardata (abfd)->first_file_filepos = bfd_scan_vma (hdr.firstmemoff,
							    (const char **) 0,
							    10);

      amt = SIZEOF_AR_FILE_HDR_BIG;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
      if (bfd_ardata (abfd)->tdata == NULL)
	goto error_ret;

      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR_BIG);
    }

  if (! _bfd_xcoff_slurp_armap (abfd))
    {
    error_ret:
      bfd_release (abfd, bfd_ardata (abfd));
    error_ret_restore:
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  return abfd->xvec;
}

/* Read the archive header in an XCOFF archive.  */

PTR
_bfd_xcoff_read_ar_hdr (abfd)
     bfd *abfd;
{
  bfd_size_type namlen;
  struct areltdata *ret;
  bfd_size_type amt = sizeof (struct areltdata);

  ret = (struct areltdata *) bfd_alloc (abfd, amt);
  if (ret == NULL)
    return NULL;

  if (! xcoff_big_format_p (abfd))
    {
      struct xcoff_ar_hdr hdr;
      struct xcoff_ar_hdr *hdrp;

      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      amt = SIZEOF_AR_HDR + namlen + 1;
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd, amt);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR;
    }
  else
    {
      struct xcoff_ar_hdr_big hdr;
      struct xcoff_ar_hdr_big *hdrp;

      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      amt = SIZEOF_AR_HDR_BIG + namlen + 1;
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd, amt);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR_BIG);
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR_BIG, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR_BIG + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR_BIG;
    }

  /* Skip over the XCOFFARFMAG at the end of the file name.  */
  if (bfd_seek (abfd, (file_ptr) ((namlen & 1) + SXCOFFARFMAG), SEEK_CUR) != 0)
    return NULL;

  return (PTR) ret;
}

/* Open the next element in an XCOFF archive.  */

bfd *
_bfd_xcoff_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
{
  file_ptr filestart;

  if (xcoff_ardata (archive) == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  if (! xcoff_big_format_p (archive))
    {
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	filestart = strtol (arch_xhdr (last_file)->nextoff, (char **) NULL,
			    10);

      if (filestart == 0
	  || filestart == strtol (xcoff_ardata (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }
  else
    {
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	/* XXX These actually have to be a calls to strtoll (at least
	   on 32-bit machines) since the fields's width is 20 and
	   there numbers with more than 32 bits can be represented.  */
	filestart = strtol (arch_xhdr_big (last_file)->nextoff, (char **) NULL,
			    10);

      /* XXX These actually have to be calls to strtoll (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      if (filestart == 0
	  || filestart == strtol (xcoff_ardata_big (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata_big (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }

  return _bfd_get_elt_at_filepos (archive, filestart);
}

/* Stat an element in an XCOFF archive.  */

int
_bfd_xcoff_stat_arch_elt (abfd, s)
     bfd *abfd;
     struct stat *s;
{
  if (abfd->arelt_data == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  if (! xcoff_big_format_p (abfd->my_archive))
    {
      struct xcoff_ar_hdr *hdrp = arch_xhdr (abfd);

      s->st_mtime = strtoll (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }
  else
    {
      struct xcoff_ar_hdr_big *hdrp = arch_xhdr_big (abfd);

      s->st_mtime = strtoll (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }

  return 0;
}

/* Normalize a file name for inclusion in an archive.  */

static const char *
normalize_filename (abfd)
     bfd *abfd;
{
  const char *file;
  const char *filename;

  file = bfd_get_filename (abfd);
  filename = strrchr (file, '/');
  if (filename != NULL)
    filename++;
  else
    filename = file;
  return filename;
}

/* Write out an XCOFF armap.  */

static bfd_boolean
xcoff_write_armap_old (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  struct xcoff_ar_hdr hdr;
  char *p;
  unsigned char buf[4];
  bfd *sub;
  file_ptr fileoff;
  unsigned int i;

  memset (&hdr, 0, sizeof hdr);
  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
  sprintf (hdr.nextoff, "%d", 0);
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, XCOFFARMAG_ELEMENT_SIZE);
  sprintf (hdr.date, "%d", 0);
  sprintf (hdr.uid, "%d", 0);
  sprintf (hdr.gid, "%d", 0);
  sprintf (hdr.mode, "%d", 0);
  sprintf (hdr.namlen, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &hdr; p < (char *) &hdr + SIZEOF_AR_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
      != SIZEOF_AR_HDR
      || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return FALSE;

  H_PUT_32 (abfd, orl_count, buf);
  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
    return FALSE;

  sub = abfd->archive_head;
  fileoff = SIZEOF_AR_FILE_HDR;
  i = 0;
  while (sub != NULL && i < orl_count)
    {
      size_t namlen;

      while (map[i].u.abfd == sub)
	{
	  H_PUT_32 (abfd, fileoff, buf);
	  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	    return FALSE;
	  ++i;
	}
      namlen = strlen (normalize_filename (sub));
      namlen = (namlen + 1) &~ (size_t) 1;
      fileoff += (SIZEOF_AR_HDR
		  + namlen
		  + SXCOFFARFMAG
		  + arelt_size (sub));
      fileoff = (fileoff + 1) &~ 1;
      sub = sub->next;
    }

  for (i = 0; i < orl_count; i++)
    {
      const char *name;
      size_t namlen;

      name = *map[i].name;
      namlen = strlen (name);
      if (bfd_bwrite (name, (bfd_size_type) (namlen + 1), abfd) != namlen + 1)
	return FALSE;
    }

  if ((stridx & 1) != 0)
    {
      char b;

      b = '\0';
      if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return FALSE;
    }

  return TRUE;
}

static char buff20[XCOFFARMAGBIG_ELEMENT_SIZE + 1];
#define FMT20  "%-20lld"
#define FMT12  "%-12d"
#define FMT12_LL "%-12lld"
#define FMT12_OCTAL  "%-12o"
#define FMT4  "%-4d"
#define PRINT20(d, v) \
  sprintf (buff20, FMT20, (long long)(v)), \
  memcpy ((void *) (d), buff20, 20)

#define PRINT12(d, v) \
  sprintf (buff20, FMT12, (int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT12_LL(d, v) \
  sprintf (buff20, FMT12_LL, (long long)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT12_OCTAL(d, v) \
  sprintf (buff20, FMT12_OCTAL, (unsigned int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT4(d, v) \
  sprintf (buff20, FMT4, (int)(v)), \
  memcpy ((void *) (d), buff20, 4)

#define READ20(d, v) \
  buff20[20] = 0, \
  memcpy (buff20, (d), 20), \
  (v) = bfd_scan_vma (buff20, (const char **) NULL, 10)

static bfd_boolean
do_pad (abfd, number)
     bfd *abfd;
     unsigned int number;
{
  bfd_byte b = 0;

  /* Limit pad to <= 4096.  */
  if (number > 4096)
    return FALSE;

  while (number--)
    if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
      return FALSE;

  return TRUE;
}

static bfd_boolean
do_copy (out_bfd, in_bfd)
     bfd *out_bfd;
     bfd *in_bfd;
{
  bfd_size_type remaining;
  bfd_byte buffer[DEFAULT_BUFFERSIZE];

  if (bfd_seek (in_bfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;

  remaining = arelt_size (in_bfd);

  while (remaining >= DEFAULT_BUFFERSIZE)
    {
      if (bfd_bread (buffer, DEFAULT_BUFFERSIZE, in_bfd) != DEFAULT_BUFFERSIZE
	  || bfd_bwrite (buffer, DEFAULT_BUFFERSIZE, out_bfd) != DEFAULT_BUFFERSIZE)
	return FALSE;

      remaining -= DEFAULT_BUFFERSIZE;
    }

  if (remaining)
    {
      if (bfd_bread (buffer, remaining, in_bfd) != remaining
	  || bfd_bwrite (buffer, remaining, out_bfd) != remaining)
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
do_shared_object_padding (out_bfd, in_bfd, offset, ar_header_size)
     bfd *out_bfd;
     bfd *in_bfd;
     ufile_ptr *offset;
     int ar_header_size;
{
  if (bfd_check_format (in_bfd, bfd_object)
      && bfd_get_flavour (in_bfd) == bfd_target_xcoff_flavour
      && (in_bfd->flags & DYNAMIC) != 0)
    {
      bfd_size_type pad = 0;
      int text_align_power;

      text_align_power = bfd_xcoff_text_align_power (in_bfd);

      pad = 1 << text_align_power;
      pad -= (*offset + ar_header_size) & (pad - 1);

      if (! do_pad (out_bfd, pad))
	return FALSE;

      *offset += pad;
    }

  return TRUE;
}

static bfd_boolean
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  struct xcoff_ar_file_hdr_big *fhdr;
  bfd_vma i, sym_32, sym_64, str_32, str_64;
  const bfd_arch_info_type *arch_info = NULL;
  bfd *current_bfd;
  size_t string_length;
  ufile_ptr nextoff, prevoff;

  /* First, we look through the symbols and work out which are
     from 32-bit objects and which from 64-bit ones.  */
  sym_32 = sym_64 = str_32 = str_64 = 0;

  current_bfd = abfd->archive_head;
  if (current_bfd != NULL)
    arch_info = bfd_get_arch_info (current_bfd);
    i = 0;
    while (current_bfd != NULL && i < orl_count)
    {
      while (map[i].u.abfd == current_bfd)
	{
	  string_length = strlen (*map[i].name) + 1;

	  if (arch_info->bits_per_address == 64)
	    {
	      sym_64++;
	      str_64 += string_length;
	    }
	  else
	    {
	      sym_32++;
	      str_32 += string_length;
	    }
	  i++;
	}
      current_bfd = current_bfd->next;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
    }

  /* A quick sanity check... */
  BFD_ASSERT (sym_64 + sym_32 == orl_count);
  /* Explicit cast to int for compiler.  */
  BFD_ASSERT ((int)(str_64 + str_32) == stridx);

  fhdr = xcoff_ardata_big (abfd);

  /* xcoff_write_archive_contents_big passes nextoff in symoff. */
  READ20 (fhdr->memoff, prevoff);
  READ20 (fhdr->symoff, nextoff);

  BFD_ASSERT (nextoff == bfd_tell (abfd));

  /* Write out the symbol table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[SXCOFFARFMAG]

     Symbol table
     0x0072		      num_syms	[0x08], binary
     0x0078		      offsets	[0x08 * num_syms], binary
     0x0086 + 0x08 * num_syms names	[??]
     ??			      pad to even bytes.
  */

  if (sym_32)
    {
      struct xcoff_ar_hdr_big *hdr;
      bfd_byte *symbol_table;
      bfd_byte *st;
      file_ptr fileoff;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_32
	+ str_32 + (str_32 & 1);

      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_32 + str_32 + (str_32 & 1));

      if (sym_64)
	PRINT20 (hdr->nextoff, nextoff + symbol_table_size);
      else
	PRINT20 (hdr->nextoff, 0);

      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0) ;

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_32, st);
      st += 8;

      /* loop over the 32 bit offsets */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  bfd_h_put_64 (abfd, fileoff, st);
		  st += 8;
		}
	      i++;
	    }
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      /* loop over the 32 bit symbol names */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);
      symbol_table = NULL;

      prevoff = nextoff;
      nextoff = nextoff + symbol_table_size;
    }
  else
    PRINT20 (fhdr->symoff, 0);

  if (sym_64)
    {
      struct xcoff_ar_hdr_big *hdr;
      bfd_byte *symbol_table;
      bfd_byte *st;
      file_ptr fileoff;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_64
	+ str_64 + (str_64 & 1);

      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_64 + str_64 + (str_64 & 1));
      PRINT20 (hdr->nextoff, 0);
      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0);

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_64, st);
      st += 8;

      /* loop over the 64 bit offsets */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  bfd_h_put_64 (abfd, fileoff, st);
		  st += 8;
		}
	      i++;
	    }
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      /* loop over the 64 bit symbol names */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);
      symbol_table = NULL;

      PRINT20 (fhdr->symoff64, nextoff);
    }
  else
    PRINT20 (fhdr->symoff64, 0);

  return TRUE;
}

bfd_boolean
_bfd_xcoff_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_armap_old (abfd, elength, map, orl_count, stridx);
  else
    return xcoff_write_armap_big (abfd, elength, map, orl_count, stridx);
}

/* Write out an XCOFF archive.  We always write an entire archive,
   rather than fussing with the freelist and so forth.  */

static bfd_boolean
xcoff_write_archive_contents_old (abfd)
     bfd *abfd;
{
  struct xcoff_ar_file_hdr fhdr;
  bfd_size_type count;
  bfd_size_type total_namlen;
  file_ptr *offsets;
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  ufile_ptr prevoff, nextoff;
  bfd *sub;
  size_t i;
  struct xcoff_ar_hdr ahdr;
  bfd_size_type size;
  char *p;
  char decbuf[XCOFFARMAG_ELEMENT_SIZE + 1];

  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR);
  sprintf (fhdr.freeoff, "%d", 0);

  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return FALSE;

  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR;
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
    {
      const char *name;
      bfd_size_type namlen;
      struct xcoff_ar_hdr *ahdrp;
      bfd_size_type remaining;

      if (makemap && ! hasobjects)
	{
	  if (bfd_check_format (sub, bfd_object))
	    hasobjects = TRUE;
	}

      name = normalize_filename (sub);
      namlen = strlen (name);

      if (sub->arelt_data != NULL)
	ahdrp = arch_xhdr (sub);
      else
	ahdrp = NULL;

      if (ahdrp == NULL)
	{
	  struct stat s;

	  memset (&ahdr, 0, sizeof ahdr);
	  ahdrp = &ahdr;
	  if (stat (bfd_get_filename (sub), &s) != 0)
	    {
	      bfd_set_error (bfd_error_system_call);
	      return FALSE;
	    }

	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
	  sprintf (ahdrp->date, "%lld", (long long) s.st_mtime);
	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);

	  if (sub->arelt_data == NULL)
	    {
	      size = sizeof (struct areltdata);
	      sub->arelt_data = bfd_alloc (sub, size);
	      if (sub->arelt_data == NULL)
		return FALSE;
	    }

	  arch_eltdata (sub)->parsed_size = s.st_size;
	}

      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) namlen);

      /* If the length of the name is odd, we write out the null byte
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;

      remaining = arelt_size (sub);
      size = (SIZEOF_AR_HDR
	      + namlen
	      + SXCOFFARFMAG
	      + remaining);

      BFD_ASSERT (nextoff == bfd_tell (abfd));

      offsets[i] = nextoff;

      prevoff = nextoff;
      nextoff += size + (size & 1);

      sprintf (ahdrp->nextoff, "%ld", (long) nextoff);

      /* We need spaces, not null bytes, in the header.  */
      for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR; p++)
	if (*p == '\0')
	  *p = ' ';

      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	   != SIZEOF_AR_HDR)
	  || bfd_bwrite ((PTR) name, namlen, abfd) != namlen
	  || bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			 abfd) != SXCOFFARFMAG)
	return FALSE;

      if (bfd_seek (sub, (file_ptr) 0, SEEK_SET) != 0)
	return FALSE;

      if (! do_copy (abfd, sub))
	return FALSE;

      if (! do_pad (abfd, size & 1))
	return FALSE;
    }

  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);

  /* Write out the member table.  */

  BFD_ASSERT (nextoff == bfd_tell (abfd));
  sprintf (fhdr.memoff, "%ld", (long) nextoff);

  memset (&ahdr, 0, sizeof ahdr);
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
				     + count * XCOFFARMAG_ELEMENT_SIZE
				     + total_namlen));
  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
  sprintf (ahdr.date, "%d", 0);
  sprintf (ahdr.uid, "%d", 0);
  sprintf (ahdr.gid, "%d", 0);
  sprintf (ahdr.mode, "%d", 0);
  sprintf (ahdr.namlen, "%d", 0);

  size = (SIZEOF_AR_HDR
	  + XCOFFARMAG_ELEMENT_SIZE
	  + count * XCOFFARMAG_ELEMENT_SIZE
	  + total_namlen
	  + SXCOFFARFMAG);

  prevoff = nextoff;
  nextoff += size + (size & 1);

  if (makemap && hasobjects)
    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
  else
    sprintf (ahdr.nextoff, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &ahdr; p < (char *) &ahdr + SIZEOF_AR_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if ((bfd_bwrite ((PTR) &ahdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
       != SIZEOF_AR_HDR)
      || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return FALSE;

  sprintf (decbuf, "%-12ld", (long) count);
  if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)
      != XCOFFARMAG_ELEMENT_SIZE)
    return FALSE;
  for (i = 0; i < (size_t) count; i++)
    {
      sprintf (decbuf, "%-12ld", (long) offsets[i]);
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
		      abfd) != XCOFFARMAG_ELEMENT_SIZE)
	return FALSE;
    }
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      const char *name;
      bfd_size_type namlen;

      name = normalize_filename (sub);
      namlen = strlen (name);
      if (bfd_bwrite ((PTR) name, namlen + 1, abfd) != namlen + 1)
	return FALSE;
    }

  if (! do_pad (abfd, size & 1))
    return FALSE;

  /* Write out the armap, if appropriate.  */
  if (! makemap || ! hasobjects)
    sprintf (fhdr.symoff, "%d", 0);
  else
    {
      BFD_ASSERT (nextoff == bfd_tell (abfd));
      sprintf (fhdr.symoff, "%ld", (long) nextoff);
      bfd_ardata (abfd)->tdata = (PTR) &fhdr;
      if (! _bfd_compute_and_write_armap (abfd, 0))
	return FALSE;
    }

  /* Write out the archive file header.  */

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &fhdr; p < (char *) &fhdr + SIZEOF_AR_FILE_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR, abfd)
	  != SIZEOF_AR_FILE_HDR))
    return FALSE;

  return TRUE;
}

static bfd_boolean
xcoff_write_archive_contents_big (abfd)
     bfd *abfd;
{
  struct xcoff_ar_file_hdr_big fhdr;
  bfd_size_type count;
  bfd_size_type total_namlen;
  file_ptr *offsets;
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  ufile_ptr prevoff, nextoff;
  bfd *current_bfd;
  size_t i;
  struct xcoff_ar_hdr_big *hdr, ahdr;
  bfd_size_type size;
  bfd_byte *member_table, *mt;
  bfd_vma member_table_size;

  memset (&fhdr, 0, SIZEOF_AR_FILE_HDR_BIG);
  memcpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);

  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return FALSE;

  /* Calculate count and total_namlen.  */
  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->next, count++)
    {
      total_namlen += strlen (normalize_filename (current_bfd)) + 1;

      if (makemap
	  && ! hasobjects
	  && bfd_check_format (current_bfd, bfd_object))
	hasobjects = TRUE;
    }

  offsets = NULL;
  if (count)
    {
      offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));
      if (offsets == NULL)
	return FALSE;
    }

  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR_BIG;
  for (current_bfd = abfd->archive_head, i = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->next, i++)
    {
      const char *name;
      bfd_size_type namlen;
      struct xcoff_ar_hdr_big *ahdrp;
      bfd_size_type remaining;

      name = normalize_filename (current_bfd);
      namlen = strlen (name);

      if (current_bfd->arelt_data != NULL)
	ahdrp = arch_xhdr_big (current_bfd);
      else
	ahdrp = NULL;

      if (ahdrp == NULL)
	{
	  struct stat s;

	  ahdrp = &ahdr;
	  /* XXX This should actually be a call to stat64 (at least on
	     32-bit machines).
	     XXX This call will fail if the original object is not found.  */
	  if (stat (bfd_get_filename (current_bfd), &s) != 0)
	    {
	      bfd_set_error (bfd_error_system_call);
	      return FALSE;
	    }

	  PRINT20 (ahdrp->size, s.st_size);
	  PRINT12_LL (ahdrp->date, s.st_mtime);
	  PRINT12 (ahdrp->uid,  s.st_uid);
	  PRINT12 (ahdrp->gid,  s.st_gid);
	  PRINT12_OCTAL (ahdrp->mode, s.st_mode);

	  if (current_bfd->arelt_data == NULL)
	    {
	      size = sizeof (struct areltdata);
	      current_bfd->arelt_data = bfd_alloc (current_bfd, size);
	      if (current_bfd->arelt_data == NULL)
		return FALSE;
	    }

	  arch_eltdata (current_bfd)->parsed_size = s.st_size;
	}

      PRINT20 (ahdrp->prevoff, prevoff);
      PRINT4 (ahdrp->namlen, namlen);

      /* If the length of the name is odd, we write out the null byte
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;

      remaining = arelt_size (current_bfd);
      size = (SIZEOF_AR_HDR_BIG
	      + namlen
	      + SXCOFFARFMAG
	      + remaining);

      BFD_ASSERT (nextoff == bfd_tell (abfd));

      /* Check for xcoff shared objects.
	 Their text section needs to be aligned wrt the archive file position.
	 This requires extra padding before the archive header.  */
      if (! do_shared_object_padding (abfd, current_bfd, & nextoff,
				      SIZEOF_AR_HDR_BIG + namlen
				      + SXCOFFARFMAG))
	return FALSE;

      offsets[i] = nextoff;

      prevoff = nextoff;
      nextoff += size + (size & 1);

      PRINT20 (ahdrp->nextoff, nextoff);

      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	   != SIZEOF_AR_HDR_BIG)
	  || bfd_bwrite ((PTR) name, (bfd_size_type) namlen, abfd) != namlen
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			  abfd) != SXCOFFARFMAG))
	return FALSE;

      if (bfd_seek (current_bfd, (file_ptr) 0, SEEK_SET) != 0)
	return FALSE;

      if (! do_copy (abfd, current_bfd))
	return FALSE;

      if (! do_pad (abfd, size & 1))
	return FALSE;
    }

  if (count)
    {
      PRINT20 (fhdr.firstmemoff, offsets[0]);
      PRINT20 (fhdr.lastmemoff, prevoff);
    }

  /* Write out the member table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[0x02]

     Member table
     0x0072		      count	[0x14]
     0x0086		      offsets	[0x14 * counts]
     0x0086 + 0x14 * counts   names	[??]
     ??			      pad to even bytes.
   */

  BFD_ASSERT (nextoff == bfd_tell (abfd));

  member_table_size = (SIZEOF_AR_HDR_BIG
		       + SXCOFFARFMAG
		       + XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen);

  member_table_size += member_table_size & 1;
  member_table = NULL;
  member_table = (bfd_byte *) bfd_zmalloc (member_table_size);
  if (member_table == NULL)
    return FALSE;

  hdr = (struct xcoff_ar_hdr_big *) member_table;

  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen + (total_namlen & 1)));
  if (makemap && hasobjects)
    PRINT20 (hdr->nextoff, nextoff + member_table_size);
  else
    PRINT20 (hdr->nextoff, 0);
  PRINT20 (hdr->prevoff, prevoff);
  PRINT12 (hdr->date, 0);
  PRINT12 (hdr->uid, 0);
  PRINT12 (hdr->gid, 0);
  PRINT12 (hdr->mode, 0);
  PRINT4 (hdr->namlen, 0);

  mt = member_table + SIZEOF_AR_HDR_BIG;
  memcpy (mt, XCOFFARFMAG, SXCOFFARFMAG);
  mt += SXCOFFARFMAG;

  PRINT20 (mt, count);
  mt += XCOFFARMAGBIG_ELEMENT_SIZE;
  for (i = 0; i < (size_t) count; i++)
    {
      PRINT20 (mt, offsets[i]);
      mt += XCOFFARMAGBIG_ELEMENT_SIZE;
    }

  if (count)
    {
      free (offsets);
      offsets = NULL;
    }

  for (current_bfd = abfd->archive_head; current_bfd != NULL;
       current_bfd = current_bfd->next)
    {
      const char *name;
      size_t namlen;

      name = normalize_filename (current_bfd);
      namlen = sprintf (mt, "%s", name);
      mt += namlen + 1;
    }

  if (bfd_bwrite (member_table, member_table_size, abfd) != member_table_size)
    return FALSE;

  free (member_table);
  member_table = NULL;

  PRINT20 (fhdr.memoff, nextoff);

  prevoff = nextoff;
  nextoff += member_table_size;

  /* Write out the armap, if appropriate.  */

  if (! makemap || ! hasobjects)
    PRINT20 (fhdr.symoff, 0);
  else
    {
      BFD_ASSERT (nextoff == bfd_tell (abfd));

      /* Save nextoff in fhdr.symoff so the armap routine can use it.  */
      PRINT20 (fhdr.symoff, nextoff);

      bfd_ardata (abfd)->tdata = (PTR) &fhdr;
      if (! _bfd_compute_and_write_armap (abfd, 0))
	return FALSE;
    }

  /* Write out the archive file header.  */

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,
		      abfd) != SIZEOF_AR_FILE_HDR_BIG))
    return FALSE;

  return TRUE;
}

bfd_boolean
_bfd_xcoff_write_archive_contents (abfd)
     bfd *abfd;
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_archive_contents_old (abfd);
  else
    return xcoff_write_archive_contents_big (abfd);
}

/* We can't use the usual coff_sizeof_headers routine, because AIX
   always uses an a.out header.  */

int
_bfd_xcoff_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
{
  int size;

  size = FILHSZ;
  if (xcoff_data (abfd)->full_aouthdr)
    size += AOUTSZ;
  else
    size += SMALL_AOUTSZ;
  size += abfd->section_count * SCNHSZ;
  return size;
}

/* Routines to swap information in the XCOFF .loader section.  If we
   ever need to write an XCOFF loader, this stuff will need to be
   moved to another file shared by the linker (which XCOFF calls the
   ``binder'') and the loader.  */

/* Swap in the ldhdr structure.  */

static void
xcoff_swap_ldhdr_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldhdr *dst;
{
  const struct external_ldhdr *src = (const struct external_ldhdr *) s;

  dst->l_version = bfd_get_32 (abfd, src->l_version);
  dst->l_nsyms = bfd_get_32 (abfd, src->l_nsyms);
  dst->l_nreloc = bfd_get_32 (abfd, src->l_nreloc);
  dst->l_istlen = bfd_get_32 (abfd, src->l_istlen);
  dst->l_nimpid = bfd_get_32 (abfd, src->l_nimpid);
  dst->l_impoff = bfd_get_32 (abfd, src->l_impoff);
  dst->l_stlen = bfd_get_32 (abfd, src->l_stlen);
  dst->l_stoff = bfd_get_32 (abfd, src->l_stoff);
}

/* Swap out the ldhdr structure.  */

static void
xcoff_swap_ldhdr_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldhdr *src;
     PTR d;
{
  struct external_ldhdr *dst = (struct external_ldhdr *) d;

  bfd_put_32 (abfd, (bfd_vma) src->l_version, dst->l_version);
  bfd_put_32 (abfd, src->l_nsyms, dst->l_nsyms);
  bfd_put_32 (abfd, src->l_nreloc, dst->l_nreloc);
  bfd_put_32 (abfd, src->l_istlen, dst->l_istlen);
  bfd_put_32 (abfd, src->l_nimpid, dst->l_nimpid);
  bfd_put_32 (abfd, src->l_impoff, dst->l_impoff);
  bfd_put_32 (abfd, src->l_stlen, dst->l_stlen);
  bfd_put_32 (abfd, src->l_stoff, dst->l_stoff);
}

/* Swap in the ldsym structure.  */

static void
xcoff_swap_ldsym_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldsym *dst;
{
  const struct external_ldsym *src = (const struct external_ldsym *) s;

  if (bfd_get_32 (abfd, src->_l._l_l._l_zeroes) != 0) {
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  } else {
    dst->_l._l_l._l_zeroes = 0;
    dst->_l._l_l._l_offset = bfd_get_32 (abfd, src->_l._l_l._l_offset);
  }
  dst->l_value = bfd_get_32 (abfd, src->l_value);
  dst->l_scnum = bfd_get_16 (abfd, src->l_scnum);
  dst->l_smtype = bfd_get_8 (abfd, src->l_smtype);
  dst->l_smclas = bfd_get_8 (abfd, src->l_smclas);
  dst->l_ifile = bfd_get_32 (abfd, src->l_ifile);
  dst->l_parm = bfd_get_32 (abfd, src->l_parm);
}

/* Swap out the ldsym structure.  */

static void
xcoff_swap_ldsym_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldsym *src;
     PTR d;
{
  struct external_ldsym *dst = (struct external_ldsym *) d;

  if (src->_l._l_l._l_zeroes != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      bfd_put_32 (abfd, (bfd_vma) 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, (bfd_vma) src->_l._l_l._l_offset,
		  dst->_l._l_l._l_offset);
    }
  bfd_put_32 (abfd, src->l_value, dst->l_value);
  bfd_put_16 (abfd, (bfd_vma) src->l_scnum, dst->l_scnum);
  bfd_put_8 (abfd, src->l_smtype, dst->l_smtype);
  bfd_put_8 (abfd, src->l_smclas, dst->l_smclas);
  bfd_put_32 (abfd, src->l_ifile, dst->l_ifile);
  bfd_put_32 (abfd, src->l_parm, dst->l_parm);
}

static void
xcoff_swap_reloc_in (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
{
  struct external_reloc *src = (struct external_reloc *) s;
  struct internal_reloc *dst = (struct internal_reloc *) d;

  memset (dst, 0, sizeof (struct internal_reloc));

  dst->r_vaddr = bfd_get_32 (abfd, src->r_vaddr);
  dst->r_symndx = bfd_get_32 (abfd, src->r_symndx);
  dst->r_size = bfd_get_8 (abfd, src->r_size);
  dst->r_type = bfd_get_8 (abfd, src->r_type);
}

static unsigned int
xcoff_swap_reloc_out (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
{
  struct internal_reloc *src = (struct internal_reloc *) s;
  struct external_reloc *dst = (struct external_reloc *) d;

  bfd_put_32 (abfd, src->r_vaddr, dst->r_vaddr);
  bfd_put_32 (abfd, src->r_symndx, dst->r_symndx);
  bfd_put_8 (abfd, src->r_type, dst->r_type);
  bfd_put_8 (abfd, src->r_size, dst->r_size);

  return bfd_coff_relsz (abfd);
}

/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldrel *dst;
{
  const struct external_ldrel *src = (const struct external_ldrel *) s;

  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}

/* Swap out the ldrel structure.  */

static void
xcoff_swap_ldrel_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldrel *src;
     PTR d;
{
  struct external_ldrel *dst = (struct external_ldrel *) d;

  bfd_put_32 (abfd, src->l_vaddr, dst->l_vaddr);
  bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);
  bfd_put_16 (abfd, (bfd_vma) src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, (bfd_vma) src->l_rsecnm, dst->l_rsecnm);
}


bfd_boolean
xcoff_reloc_type_noop (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_fail (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  (*_bfd_error_handler)
    (_("%s: unsupported relocation type 0x%02x"),
     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

bfd_boolean
xcoff_reloc_type_pos (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  *relocation = val + addend;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_neg (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  *relocation = addend - val;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_rel (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->pc_relative = TRUE;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_toc (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     struct internal_reloc *rel;
     struct internal_syment *sym;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  struct xcoff_link_hash_entry *h;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];

  if (h != NULL && h->smclas != XMC_TD)
    {
      if (h->toc_section == NULL)
	{
	  (*_bfd_error_handler)
	    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
	     bfd_get_filename (input_bfd), rel->r_vaddr,
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
      val = (h->toc_section->output_section->vma
	      + h->toc_section->output_offset);
    }

  *relocation = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_ba (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  *relocation = val + addend;

  return TRUE;
}

static bfd_boolean
xcoff_reloc_type_br (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents;
{
  struct xcoff_link_hash_entry *h;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];

  /* If we see an R_BR or R_RBR reloc which is jumping to global
     linkage code, and it is followed by an appropriate cror nop
     instruction, we replace the cror with lwz r2,20(r1).  This
     restores the TOC after the glink code.  Contrariwise, if the
     call is followed by a lwz r2,20(r1), but the call is not
     going to global linkage code, we can replace the load with a
     cror.  */
  if (NULL != h
      && bfd_link_hash_defined == h->root.type
      && (rel->r_vaddr - input_section->vma + 8
	  <= input_section->_cooked_size))
    {
      bfd_byte *pnext;
      unsigned long next;

      pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
      next = bfd_get_32 (input_bfd, pnext);

      /* The _ptrgl function is magic.  It is used by the AIX
	 compiler to call a function through a pointer.  */
      if (h->smclas == XMC_GL || strcmp (h->root.root.string, "._ptrgl") == 0)
	{
	  if (next == 0x4def7b82			/* cror 15,15,15 */
	      || next == 0x4ffffb82			/* cror 31,31,31 */
	      || next == 0x60000000)			/* ori r0,r0,0 */
	    bfd_put_32 (input_bfd, 0x80410014, pnext);	/* lwz r1,20(r1) */

	}
      else
	{
	  if (next == 0x80410014)			/* lwz r1,20(r1) */
	    bfd_put_32 (input_bfd, 0x60000000, pnext);	/* ori r0,r0,0 */
	}
    }
  else if (NULL != h && bfd_link_hash_undefined == h->root.type)
    {
      /* Normally, this relocation is against a defined symbol.  In the
	 case where this is a partial link and the output section offset
	 is greater than 2^25, the linker will return an invalid error
	 message that the relocation has been truncated.  Yes it has been
	 truncated but no it not important.  For this case, disable the
	 overflow checking. */

      howto->complain_on_overflow = complain_overflow_dont;
    }

  howto->pc_relative = TRUE;
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_crel (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->pc_relative = TRUE;
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

static bfd_boolean
xcoff_complain_overflow_dont_func (input_bfd, val, relocation, howto)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma relocation ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
{
  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_bitfield_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  /* Much like unsigned, except no trimming with addrmask.  In
     addition, the sum overflows if there is a carry out of
     the bfd_vma, i.e., the sum is less than either input
     operand.  */
  a >>= howto->rightshift;
  b >>= howto->bitpos;

  /* Bitfields are sometimes used for signed numbers; for
     example, a 13-bit field sometimes represents values in
     0..8191 and sometimes represents values in -4096..4095.
     If the field is signed and a is -4095 (0x1001) and b is
     -1 (0x1fff), the sum is -4096 (0x1000), but (0x1001 +
     0x1fff is 0x3000).  It's not clear how to handle this
     everywhere, since there is not way to know how many bits
     are significant in the relocation, but the original code
     assumed that it was fully sign extended, and we will keep
     that assumption.  */
  signmask = (fieldmask >> 1) + 1;

  if ((a & ~ fieldmask) != 0)
    {
      /* Some bits out of the field are set.  This might not
	 be a problem: if this is a signed bitfield, it is OK
	 iff all the high bits are set, including the sign
	 bit.  We'll try setting all but the most significant
	 bit in the original relocation value: if this is all
	 ones, we are OK, assuming a signed bitfield.  */
      ss = (signmask << howto->rightshift) - 1;
      if ((ss | relocation) != ~ (bfd_vma) 0)
	return TRUE;
      a &= fieldmask;
    }

  /* We just assume (b & ~ fieldmask) == 0.  */

  /* We explicitly permit wrap around if this relocation
     covers the high bit of an address.  The Linux kernel
     relies on it, and it is the only way to write assembler
     code which can run when loaded at a location 0x80000000
     away from the location at which it is linked.  */
  if (howto->bitsize + howto->rightshift
      == bfd_arch_bits_per_address (input_bfd))
    return FALSE;

  sum = a + b;
  if (sum < a || (sum & ~ fieldmask) != 0)
    {
      /* There was a carry out, or the field overflow.  Test
	 for signed operands again.  Here is the overflow test
	 is as for complain_overflow_signed.  */
      if (((~ (a ^ b)) & (a ^ sum)) & signmask)
	return TRUE;
    }

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_signed_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  a = (a & addrmask) >> howto->rightshift;

  /* If any sign bits are set, all sign bits must be set.
     That is, A must be a valid negative address after
     shifting.  */
  signmask = ~ (fieldmask >> 1);
  ss = a & signmask;
  if (ss != 0 && ss != ((addrmask >> howto->rightshift) & signmask))
    return TRUE;

  /* We only need this next bit of code if the sign bit of B
     is below the sign bit of A.  This would only happen if
     SRC_MASK had fewer bits than BITSIZE.  Note that if
     SRC_MASK has more bits than BITSIZE, we can get into
     trouble; we would need to verify that B is in range, as
     we do for A above.  */
  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;
  if ((b & signmask) != 0)
    {
      /* Set all the bits above the sign bit.  */
      b -= signmask <<= 1;
    }

  b = (b & addrmask) >> howto->bitpos;

  /* Now we can do the addition.  */
  sum = a + b;

  /* See if the result has the correct sign.  Bits above the
     sign bit are junk now; ignore them.  If the sum is
     positive, make sure we did not have all negative inputs;
     if the sum is negative, make sure we did not have all
     positive inputs.  The test below looks only at the sign
     bits, and it really just
     SIGN (A) == SIGN (B) && SIGN (A) != SIGN (SUM)
  */
  signmask = (fieldmask >> 1) + 1;
  if (((~ (a ^ b)) & (a ^ sum)) & signmask)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_unsigned_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  /* Checking for an unsigned overflow is relatively easy:
     trim the addresses and add, and trim the result as well.
     Overflow is normally indicated when the result does not
     fit in the field.  However, we also need to consider the
     case when, e.g., fieldmask is 0x7fffffff or smaller, an
     input is 0x80000000, and bfd_vma is only 32 bits; then we
     will get sum == 0, but there is an overflow, since the
     inputs did not fit in the field.  Instead of doing a
     separate test, we can check for this by or-ing in the
     operands when testing for the sum overflowing its final
     field.  */
  a = (a & addrmask) >> howto->rightshift;
  b = (b & addrmask) >> howto->bitpos;
  sum = (a + b) & addrmask;
  if ((a | b | sum) & ~ fieldmask)
    return TRUE;

  return FALSE;
}

/* This is the relocation function for the RS/6000/POWER/PowerPC.
   This is currently the only processor which uses XCOFF; I hope that
   will never change.

   I took the relocation type definitions from two documents:
   the PowerPC AIX Version 4 Application Binary Interface, First
   Edition (April 1992), and the PowerOpen ABI, Big-Endian
   32-Bit Hardware Implementation (June 30, 1994).  Differences
   between the documents are noted below.

   Unsupported r_type's

   R_RTB:
   R_RRTBI:
   R_RRTBA:

   These relocs are defined by the PowerPC ABI to be
   relative branches which use half of the difference
   between the symbol and the program counter.  I can't
   quite figure out when this is useful.  These relocs are
   not defined by the PowerOpen ABI.

   Supported r_type's

   R_POS:
   Simple positive relocation.

   R_NEG:
   Simple negative relocation.

   R_REL:
   Simple PC relative relocation.

   R_TOC:
   TOC relative relocation.  The value in the instruction in
   the input file is the offset from the input file TOC to
   the desired location.  We want the offset from the final
   TOC to the desired location.  We have:
   isym = iTOC + in
   iinsn = in + o
   osym = oTOC + on
   oinsn = on + o
   so we must change insn by on - in.

   R_GL:
   GL linkage relocation.  The value of this relocation
   is the address of the entry in the TOC section.

   R_TCL:
   Local object TOC address.  I can't figure out the
   difference between this and case R_GL.

   R_TRL:
   TOC relative relocation.  A TOC relative load instruction
   which may be changed to a load address instruction.
   FIXME: We don't currently implement this optimization.

   R_TRLA:
   TOC relative relocation.  This is a TOC relative load
   address instruction which may be changed to a load
   instruction.  FIXME: I don't know if this is the correct
   implementation.

   R_BA:
   Absolute branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CAI:
   The PowerPC ABI defines this as an absolute call which
   may be modified to become a relative call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBA:
   Absolute branch which may be modified to become a
   relative branch.

   R_RBAC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to an absolute branch
   to a symbol.  The PowerOpen ABI does not define this
   relocation type.

   R_RBRC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to a relative branch.
   The PowerOpen ABI does not define this relocation type.

   R_BR:
   Relative branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CREL:
   The PowerPC ABI defines this as a relative call which may
   be modified to become an absolute call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBR:
   A relative branch which may be modified to become an
   absolute branch.  FIXME: We don't implement this,
   although we should for symbols of storage mapping class
   XMC_XO.

   R_RL:
   The PowerPC AIX ABI describes this as a load which may be
   changed to a load address.  The PowerOpen ABI says this
   is the same as case R_POS.

   R_RLA:
   The PowerPC AIX ABI describes this as a load address
   which may be changed to a load.  The PowerOpen ABI says
   this is the same as R_POS.
*/

bfd_boolean
xcoff_ppc_relocate_section (output_bfd, info, input_bfd,
			    input_section, contents, relocs, syms,
			    sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct xcoff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      struct reloc_howto_struct howto;
      bfd_vma relocation;
      bfd_vma value_to_relocate;
      bfd_vma address;
      bfd_byte *location;

      /* Relocation type R_REF is a special relocation type which is
	 merely used to prevent garbage collection from occurring for
	 the csect including the symbol which it references.  */
      if (rel->r_type == R_REF)
	continue;

      /* howto */
      howto.type = rel->r_type;
      howto.rightshift = 0;
      howto.bitsize = (rel->r_size & 0x1f) + 1;
      howto.size = howto.bitsize > 16 ? 2 : 1;
      howto.pc_relative = FALSE;
      howto.bitpos = 0;
      howto.complain_on_overflow = (rel->r_size & 0x80
				    ? complain_overflow_signed
				    : complain_overflow_bitfield);
      howto.special_function = NULL;
      howto.name = "internal";
      howto.partial_inplace = TRUE;
      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);
      howto.pcrel_offset = FALSE;

      /* symbol */
      val = 0;
      addend = 0;
      h = NULL;
      sym = NULL;
      symndx = rel->r_symndx;

      if (-1 != symndx)
	{
	  asection *sec;

	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;

	  if (NULL == h)
	    {
	      sec = sections[symndx];
	      /* Hack to make sure we use the right TOC anchor value
		 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
	    }
	  else
	    {
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  val = (h->root.u.def.value
			 + sec->output_section->vma
			 + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_common)
		{
		  sec = h->root.u.c.p->section;
		  val = (sec->output_section->vma
			 + sec->output_offset);

		}
	      else if ((0 == (h->flags & (XCOFF_DEF_DYNAMIC | XCOFF_IMPORT)))
		       && ! info->relocatable)
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd, input_section,
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;

		  /* Don't try to process the reloc.  It can't help, and
		     it may generate another error.  */
		  continue;
		}
	    }
	}

      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION
	  || !((*xcoff_calculate_relocation[rel->r_type])
	       (input_bfd, input_section, output_bfd, rel, sym, &howto, val,
		addend, &relocation, contents)))
	return FALSE;

      /* address */
      address = rel->r_vaddr - input_section->vma;
      location = contents + address;

      if (address > input_section->_raw_size)
	abort ();

      /* Get the value we are going to relocate.  */
      if (1 == howto.size)
	value_to_relocate = bfd_get_16 (input_bfd, location);
      else
	value_to_relocate = bfd_get_32 (input_bfd, location);

      /* overflow.

	 FIXME: We may drop bits during the addition
	 which we don't check for.  We must either check at every single
	 operation, which would be tedious, or we must do the computations
	 in a type larger than bfd_vma, which would be inefficient.  */

      if ((unsigned int) howto.complain_on_overflow
	  >= XCOFF_MAX_COMPLAIN_OVERFLOW)
	abort ();

      if (((*xcoff_complain_overflow[howto.complain_on_overflow])
	   (input_bfd, value_to_relocate, relocation, &howto)))
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  char reloc_type_name[10];

	  if (symndx == -1)
	    {
	      name = "*ABS*";
	    }
	  else if (h != NULL)
	    {
	      name = h->root.root.string;
	    }
	  else
	    {
	      name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
	      if (name == NULL)
		name = "UNKNOWN";
	    }
	  sprintf (reloc_type_name, "0x%02x", rel->r_type);

	  if (! ((*info->callbacks->reloc_overflow)
		 (info, name, reloc_type_name, (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
	    return FALSE;
	}

      /* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)
			   | (((value_to_relocate & howto.src_mask)
			       + relocation) & howto.dst_mask));

      /* Put the value back in the object file.  */
      if (1 == howto.size)
	bfd_put_16 (input_bfd, value_to_relocate, location);
      else
	bfd_put_32 (input_bfd, value_to_relocate, location);
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_ldsymbol_name (abfd, ldinfo, ldsym, name)
     bfd *abfd ATTRIBUTE_UNUSED;
	 struct xcoff_loader_info *ldinfo;
	 struct internal_ldsym *ldsym;
	 const char *name;
{
  size_t len;
  len = strlen (name);

  if (len <= SYMNMLEN)
    strncpy (ldsym->_l._l_name, name, SYMNMLEN);
  else
    {
      if (ldinfo->string_size + len + 3 > ldinfo->string_alc)
	{
	  bfd_size_type newalc;
	  bfd_byte *newstrings;

	  newalc = ldinfo->string_alc * 2;
	  if (newalc == 0)
	    newalc = 32;
	  while (ldinfo->string_size + len + 3 > newalc)
	    newalc *= 2;

	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
	  if (newstrings == NULL)
	    {
	      ldinfo->failed = TRUE;
	      return FALSE;
	    }
	  ldinfo->string_alc = newalc;
	  ldinfo->strings = newstrings;
	}

      bfd_put_16 (ldinfo->output_bfd, (bfd_vma) (len + 1),
		  ldinfo->strings + ldinfo->string_size);
      strcpy (ldinfo->strings + ldinfo->string_size + 2, name);
      ldsym->_l._l_l._l_zeroes = 0;
      ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;
      ldinfo->string_size += len + 3;
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_symbol_name (bfd *abfd, struct bfd_strtab_hash *strtab,
			    struct internal_syment *sym,
			    const char *name)
{
  if (strlen (name) <= SYMNMLEN)
    {
      strncpy (sym->_n._n_name, name, SYMNMLEN);
    }
  else
    {
      bfd_boolean hash;
      bfd_size_type indx;

      hash = TRUE;
      if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = FALSE;
      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);
      if (indx == (bfd_size_type) -1)
	return FALSE;
      sym->_n._n_n._n_zeroes = 0;
      sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }
  return TRUE;
}

static asection *
xcoff_create_csect_from_smclas (abfd, aux, symbol_name)
     bfd *abfd;
     union internal_auxent *aux;
     const char *symbol_name;
{
  asection *return_value = NULL;

  /* .sv64 = x_smclas == 17
     This is an invalid csect for 32 bit apps.  */
  static const char *names[19] =
  {
    ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
    ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
    ".td", NULL, ".sv3264"
  };

  if ((19 >= aux->x_csect.x_smclas)
      && (NULL != names[aux->x_csect.x_smclas]))
    {
      return_value = bfd_make_section_anyway
	(abfd, names[aux->x_csect.x_smclas]);
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: symbol `%s' has unrecognized smclas %d"),
	 bfd_archive_filename (abfd), symbol_name, aux->x_csect.x_smclas);
      bfd_set_error (bfd_error_bad_value);
    }

  return return_value;
}

static bfd_boolean
xcoff_is_lineno_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_is_reloc_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_vma
xcoff_loader_symbol_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr ATTRIBUTE_UNUSED;
{
  return bfd_xcoff_ldhdrsz (abfd);
}

static bfd_vma
xcoff_loader_reloc_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr;
{
  return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);
}

static bfd_boolean
xcoff_generate_rtinit  (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
{
  bfd_byte filehdr_ext[FILHSZ];
  bfd_byte scnhdr_ext[SCNHSZ];
  bfd_byte syment_ext[SYMESZ * 10];
  bfd_byte reloc_ext[RELSZ * 3];
  bfd_byte *data_buffer;
  bfd_size_type data_buffer_size;
  bfd_byte *string_table = NULL, *st_tmp = NULL;
  bfd_size_type string_table_size;
  bfd_vma val;
  size_t initsz, finisz;
  struct internal_filehdr filehdr;
  struct internal_scnhdr scnhdr;
  struct internal_syment syment;
  union internal_auxent auxent;
  struct internal_reloc reloc;

  char *data_name = ".data";
  char *rtinit_name = "__rtinit";
  char *rtld_name = "__rtld";

  if (! bfd_xcoff_rtinit_size (abfd))
    return FALSE;

  initsz = (init == NULL ? 0 : 1 + strlen (init));
  finisz = (fini == NULL ? 0 : 1 + strlen (fini));

  /* file header */
  memset (filehdr_ext, 0, FILHSZ);
  memset (&filehdr, 0, sizeof (struct internal_filehdr));
  filehdr.f_magic = bfd_xcoff_magic_number (abfd);
  filehdr.f_nscns = 1;
  filehdr.f_timdat = 0;
  filehdr.f_nsyms = 0;  /* at least 6, no more than 10 */
  filehdr.f_symptr = 0; /* set below */
  filehdr.f_opthdr = 0;
  filehdr.f_flags = 0;

  /* section header */
  memset (scnhdr_ext, 0, SCNHSZ);
  memset (&scnhdr, 0, sizeof (struct internal_scnhdr));
  memcpy (scnhdr.s_name, data_name, strlen (data_name));
  scnhdr.s_paddr = 0;
  scnhdr.s_vaddr = 0;
  scnhdr.s_size = 0;    /* set below */
  scnhdr.s_scnptr = FILHSZ + SCNHSZ;
  scnhdr.s_relptr = 0;  /* set below */
  scnhdr.s_lnnoptr = 0;
  scnhdr.s_nreloc = 0;  /* either 1 or 2 */
  scnhdr.s_nlnno = 0;
  scnhdr.s_flags = STYP_DATA;

  /* .data
     0x0000	      0x00000000 : rtl
     0x0004	      0x00000010 : offset to init, or 0
     0x0008	      0x00000028 : offset to fini, or 0
     0x000C	      0x0000000C : size of descriptor
     0x0010	      0x00000000 : init, needs a reloc
     0x0014	      0x00000040 : offset to init name
     0x0018	      0x00000000 : flags, padded to a word
     0x001C	      0x00000000 : empty init
     0x0020	      0x00000000 :
     0x0024	      0x00000000 :
     0x0028	      0x00000000 : fini, needs a reloc
     0x002C	      0x00000??? : offset to fini name
     0x0030	      0x00000000 : flags, padded to a word
     0x0034	      0x00000000 : empty fini
     0x0038	      0x00000000 :
     0x003C	      0x00000000 :
     0x0040	      init name
     0x0040 + initsz  fini name */

  data_buffer_size = 0x0040 + initsz + finisz;
  data_buffer_size = (data_buffer_size + 7) &~ (bfd_size_type) 7;
  data_buffer = NULL;
  data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);
  if (data_buffer == NULL)
    return FALSE;

  if (initsz)
    {
      val = 0x10;
      bfd_h_put_32 (abfd, val, &data_buffer[0x04]);
      val = 0x40;
      bfd_h_put_32 (abfd, val, &data_buffer[0x14]);
      memcpy (&data_buffer[val], init, initsz);
    }

  if (finisz)
    {
      val = 0x28;
      bfd_h_put_32 (abfd, val, &data_buffer[0x08]);
      val = 0x40 + initsz;
      bfd_h_put_32 (abfd, val, &data_buffer[0x2C]);
      memcpy (&data_buffer[val], fini, finisz);
    }

  val = 0x0C;
  bfd_h_put_32 (abfd, val, &data_buffer[0x0C]);

  scnhdr.s_size = data_buffer_size;

  /* string table */
  string_table_size = 0;
  if (initsz > 9)
    string_table_size += initsz;
  if (finisz > 9)
    string_table_size += finisz;
  if (string_table_size)
    {
      string_table_size += 4;
      string_table = (bfd_byte *) bfd_zmalloc (string_table_size);
      if (string_table == NULL)
	return FALSE;

      val = string_table_size;
      bfd_h_put_32 (abfd, val, &string_table[0]);
      st_tmp = string_table + 4;
    }

  /* symbols
     0. .data csect
     2. __rtinit
     4. init function
     6. fini function
     8. __rtld  */
  memset (syment_ext, 0, 10 * SYMESZ);
  memset (reloc_ext, 0, 3 * RELSZ);

  /* .data csect */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, data_name, strlen (data_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_HIDEXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_scnlen.l = data_buffer_size;
  auxent.x_csect.x_smtyp = 3 << 3 | XTY_SD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* __rtinit */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, rtinit_name, strlen (rtinit_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_EXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_smtyp = XTY_LD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* init */
  if (initsz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (initsz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, init, initsz);
	  st_tmp += initsz;
	}
      else
	memcpy (syment._n._n_name, init, initsz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0010;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc, &reloc_ext[0]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  /* fini */
  if (finisz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (finisz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, fini, finisz);
	  st_tmp += finisz;
	}
      else
	memcpy (syment._n._n_name, fini, finisz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0028;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  if (rtld)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));
      memcpy (syment._n._n_name, rtld_name, strlen (rtld_name));
      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0000;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  scnhdr.s_relptr = scnhdr.s_scnptr + data_buffer_size;
  filehdr.f_symptr = scnhdr.s_relptr + scnhdr.s_nreloc * RELSZ;

  bfd_coff_swap_filehdr_out (abfd, &filehdr, filehdr_ext);
  bfd_bwrite (filehdr_ext, FILHSZ, abfd);
  bfd_coff_swap_scnhdr_out (abfd, &scnhdr, scnhdr_ext);
  bfd_bwrite (scnhdr_ext, SCNHSZ, abfd);
  bfd_bwrite (data_buffer, data_buffer_size, abfd);
  bfd_bwrite (reloc_ext, scnhdr.s_nreloc * RELSZ, abfd);
  bfd_bwrite (syment_ext, filehdr.f_nsyms * SYMESZ, abfd);
  bfd_bwrite (string_table, string_table_size, abfd);

  free (data_buffer);
  data_buffer = NULL;

  return TRUE;
}


static reloc_howto_type xcoff_dynamic_reloc =
HOWTO (0,			/* type */
       0,			/* rightshift */
       2,			/* size (0 = byte, 1 = short, 2 = long) */
       32,			/* bitsize */
       FALSE,			/* pc_relative */
       0,			/* bitpos */
       complain_overflow_bitfield, /* complain_on_overflow */
       0,			/* special_function */
       "R_POS",			/* name */
       TRUE,			/* partial_inplace */
       0xffffffff,		/* src_mask */
       0xffffffff,		/* dst_mask */
       FALSE);			/* pcrel_offset */

/*  glink

   The first word of global linkage code must be modified by filling in
   the correct TOC offset.  */

static unsigned long xcoff_glink_code[9] =
  {
    0x81820000,	/* lwz r12,0(r2) */
    0x90410014,	/* stw r2,20(r1) */
    0x800c0000,	/* lwz r0,0(r12) */
    0x804c0004,	/* lwz r2,4(r12) */
    0x7c0903a6,	/* mtctr r0 */
    0x4e800420,	/* bctr */
    0x00000000,	/* start of traceback table */
    0x000c8000,	/* traceback table */
    0x00000000,	/* traceback table */
  };


static const struct xcoff_backend_data_rec bfd_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
    },

    0x01DF,			/* magic number */
    bfd_arch_rs6000,
    bfd_mach_rs6k,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    64,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target rs6000coff_vec =
  {
    "aixcoff-rs6000",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,

    /* Archive */
    _bfd_xcoff_slurp_armap,
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_canonicalize_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    (void *) &bfd_xcoff_backend_data,
  };

/* xcoff-powermac target
   Old target.
   Only difference between this target and the rs6000 target is the
   the default architecture and machine type used in coffcode.h

   PowerPC Macs use the same magic numbers as RS/6000
   (because that's how they were bootstrapped originally),
   but they are always PowerPC architecture.  */
static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
    },

    0x01DF,			/* magic number */
    bfd_arch_powerpc,
    bfd_mach_ppc,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    0,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target pmac_xcoff_vec =
  {
    "xcoff-powermac",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,

    /* Archive */
    _bfd_xcoff_slurp_armap,
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_canonicalize_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    (void *) &bfd_pmac_xcoff_backend_data,
  };
@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1538 1
a1538 1
      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
d1548 1
a1548 1
      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
d1668 1
d1679 4
d2149 1
a2149 1
	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
d2385 1
a2385 1
	  PRINT12 (ahdrp->date, s.st_mtime);
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002
d1009 1
a1009 1
  /* Special case some 16 bit reoloc */
a1577 1
/*ARGSUSED*/
d3428 1
a3428 1
		       && ! info->relocateable)
d4167 1
a4167 1
    coff_get_symtab,
d4409 1
a4409 1
    coff_get_symtab,
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d31 1
d34 1
d37 98
a134 3
#define TARGET_NAME "aixcoff-rs6000"
#define TARGET_SYM rs6000coff_vec
#include "xcoff-target.h"
d138 101
a238 1
static const char *normalize_filename PARAMS ((bfd *));
d243 1
a243 1
boolean
d248 1
d250 1
a250 3
  abfd->tdata.xcoff_obj_data =
    ((struct xcoff_tdata *)
     bfd_zalloc (abfd, sizeof (struct xcoff_tdata)));
d252 1
a252 1
    return false;
d268 4
a271 1
  return true;
d276 1
a276 1
boolean
d285 1
a285 1
    return true;
d310 2
a311 2
  ox->text_align_power = ix->text_align_power;
  ox->data_align_power = ix->data_align_power;
d316 1
a316 1
  return true;
d324 1
a324 1
boolean
d329 1
a329 1
  return false;
d334 1
a334 1
     bfd            *abfd;
d339 1
a339 1
  struct internal_syment      *in = (struct internal_syment *)in1;
d343 1
a343 1
      memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
d348 1
a348 2
      in->_n._n_n._n_offset =
	  bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
d351 5
a355 5
  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value);
  in->n_scnum = bfd_h_get_16(abfd, (bfd_byte *) ext->e_scnum);
  in->n_type = bfd_h_get_16(abfd, (bfd_byte *) ext->e_type);
  in->n_sclass = bfd_h_get_8(abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8(abfd, ext->e_numaux);
d360 3
a362 3
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
d369 1
a369 1
      memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
d373 2
a374 3
      bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
      bfd_h_put_32(abfd, in->_n._n_n._n_offset,
	      (bfd_byte *)  ext->e.e.e_offset);
d377 5
a381 5
  bfd_h_put_32(abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16(abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  bfd_h_put_16(abfd,  in->n_type , (bfd_byte *) ext->e_type);
  bfd_h_put_8(abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8(abfd,  in->n_numaux , ext->e_numaux);
a384 7
#define PUTWORD bfd_h_put_32
#define PUTHALF bfd_h_put_16
#define PUTBYTE bfd_h_put_8
#define GETWORD bfd_h_get_32
#define GETHALF bfd_h_get_16
#define GETBYTE bfd_h_get_8

d387 7
a393 7
     bfd            *abfd;
     PTR 	      ext1;
     int             type;
     int             class;
     int	      indx;
     int	      numaux;
     PTR 	      in1;
d395 1
a395 1
  AUXENT    *ext = (AUXENT *)ext1;
d398 2
a399 1
  switch (class) {
d401 2
a402 1
      if (ext->x_file.x_fname[0] == 0) {
d405 15
a419 13
	   bfd_h_get_32(abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
	} else {
	    if (numaux > 1)
	      {
		if (indx == 0)
		  memcpy (in->x_file.x_fname, ext->x_file.x_fname,
			  numaux * sizeof (AUXENT));
	      }
	    else
	      {
		memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	      }
	  }
d427 3
a429 5
	  in->x_csect.x_scnlen.l =
	      bfd_h_get_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = bfd_h_get_32 (abfd,
						 ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = bfd_h_get_16 (abfd, ext->x_csect.x_snhash);
d433 4
a436 4
	  in->x_csect.x_smtyp    = bfd_h_get_8  (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = bfd_h_get_8  (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = bfd_h_get_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = bfd_h_get_16 (abfd, ext->x_csect.x_snstab);
d444 5
a448 7
      if (type == T_NULL) {
	  in->x_scn.x_scnlen = bfd_h_get_32(abfd,
		  (bfd_byte *) ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = bfd_h_get_16(abfd,
		  (bfd_byte *) ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = bfd_h_get_16(abfd,
		  (bfd_byte *) ext->x_scn.x_nlinno);
d450 1
a450 1
             safety.  */
d460 2
a461 2
  in->x_sym.x_tagndx.l = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_tvndx);
d465 4
a468 4
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_endndx);
d473 1
a473 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
d475 1
a475 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
d477 1
a477 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
d479 13
a491 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
a492 9
  if (ISFCN(type)) {
    in->x_sym.x_misc.x_fsize = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
  }
  else {
    in->x_sym.x_misc.x_lnsz.x_lnno = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_lnno);
    in->x_sym.x_misc.x_lnsz.x_size = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_size);
  }
d494 2
a495 2
end: ;
  /* the semicolon is because MSVC doesn't like labels at
d497 1
d499 3
a501 1
}
d505 2
a506 2
     bfd   *abfd;
     PTR 	inp;
d511 1
a511 1
     PTR	extp;
d516 1
a516 1
  memset((PTR)ext, 0, bfd_coff_auxesz (abfd));
d519 10
a528 40
  case C_FILE:
    if (in->x_file.x_fname[0] == 0)
      {
      PUTWORD(abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
      PUTWORD(abfd,
	      in->x_file.x_n.x_offset,
	      (bfd_byte *) ext->x_file.x_n.x_offset);
    }
    else
      {
      memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
      }
    goto end;

  /* RS/6000 "csect" auxents */
  case C_EXT:
  case C_HIDEXT:
    if (indx + 1 == numaux)
      {
	PUTWORD (abfd, in->x_csect.x_scnlen.l,ext->x_csect.x_scnlen);
	PUTWORD (abfd, in->x_csect.x_parmhash,	ext->x_csect.x_parmhash);
	PUTHALF (abfd, in->x_csect.x_snhash,	ext->x_csect.x_snhash);
	/* We don't have to hack bitfields in x_smtyp because it's
	   defined by shifts-and-ands, which are equivalent on all
	   byte orders.  */
	PUTBYTE (abfd, in->x_csect.x_smtyp,	ext->x_csect.x_smtyp);
	PUTBYTE (abfd, in->x_csect.x_smclas,	ext->x_csect.x_smclas);
	PUTWORD (abfd, in->x_csect.x_stab,	ext->x_csect.x_stab);
	PUTHALF (abfd, in->x_csect.x_snstab,	ext->x_csect.x_snstab);
	goto end;
      }
    break;

  case C_STAT:
  case C_LEAFSTAT:
  case C_HIDDEN:
    if (type == T_NULL) {
      bfd_h_put_32(abfd, in->x_scn.x_scnlen, (bfd_byte *) ext->x_scn.x_scnlen);
      bfd_h_put_16(abfd, in->x_scn.x_nreloc, (bfd_byte *) ext->x_scn.x_nreloc);
      bfd_h_put_16(abfd, in->x_scn.x_nlinno, (bfd_byte *) ext->x_scn.x_nlinno);
d530 31
a561 2
    break;
  }
d563 2
a564 2
  PUTWORD(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
  bfd_h_put_16 (abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);
d568 4
a571 4
      bfd_h_put_32(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      PUTWORD(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l,
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx);
d575 8
a582 8
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d586 1
a586 2
    PUTWORD (abfd, in->x_sym.x_misc.x_fsize,
	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
d589 4
a592 4
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno);
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_size,
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_size);
d598 2
a606 3
/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE       (((bfd_vma)0) - 1)
d611 6
a616 6
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d618 6
a623 6
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d626 6
a631 6
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d633 6
a638 6
	 0,		        /* special_function */
	 "R_NEG",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d641 6
a646 6
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d648 6
a653 6
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d656 6
a661 6
  HOWTO (3,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d663 6
a668 6
	 0,		        /* special_function */
	 "R_TOC",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d671 6
a676 6
  HOWTO (4,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d678 6
a683 6
	 0,		        /* special_function */
	 "R_RTB",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d686 6
a691 6
  HOWTO (5,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d693 14
a706 14
	 0,		        /* special_function */
	 "R_GL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */

  /* Local TOC relative symbol.  */
  HOWTO (6,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d708 6
a713 6
	 0,		        /* special_function */
	 "R_TCL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d718 6
a723 6
  HOWTO (8,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d725 6
a730 6
	 0,		        /* special_function */
	 "R_BA",                /* name */
	 true,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 false),                /* pcrel_offset */
d735 6
a740 6
  HOWTO (0xa,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d742 6
a747 6
	 0,		        /* special_function */
	 "R_BR",                /* name */
	 true,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 false),                /* pcrel_offset */
d752 6
a757 6
  HOWTO (0xc,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d759 6
a764 6
	 0,		        /* special_function */
	 "R_RL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d767 6
a772 6
  HOWTO (0xd,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d774 6
a779 6
	 0,		        /* special_function */
	 "R_RLA",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d784 13
a796 13
  HOWTO (0xf,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REF",               /* name */
	 false,	                /* partial_inplace */
	 0,		        /* src_mask */
	 0,     	   	/* dst_mask */
	 false),                /* pcrel_offset */
d802 6
a807 6
  HOWTO (0x12,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d809 6
a814 6
	 0,		        /* special_function */
	 "R_TRL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d817 6
a822 6
  HOWTO (0x13,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d824 6
a829 6
	 0,		        /* special_function */
	 "R_TRLA",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d832 6
a837 6
  HOWTO (0x14,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d839 6
a844 6
	 0,		        /* special_function */
	 "R_RRTBI",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d847 6
a852 6
  HOWTO (0x15,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d854 6
a859 6
	 0,		        /* special_function */
	 "R_RRTBA",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d862 6
a867 6
  HOWTO (0x16,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d869 6
a874 6
	 0,		        /* special_function */
	 "R_CAI",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d877 6
a882 6
  HOWTO (0x17,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d884 6
a889 6
	 0,		        /* special_function */
	 "R_CREL",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d892 6
a897 6
  HOWTO (0x18,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d899 6
a904 6
	 0,		        /* special_function */
	 "R_RBA",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d907 6
a912 6
  HOWTO (0x19,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d914 6
a919 6
	 0,		        /* special_function */
	 "R_RBAC",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d922 6
a927 6
  HOWTO (0x1a,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d929 6
a934 6
	 0,		        /* special_function */
	 "R_RBR",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d937 6
a942 6
  HOWTO (0x1b,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d944 21
a964 19
	 0,		        /* special_function */
	 "R_RBRC",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
  HOWTO (0,                     /* type */
         0,                     /* rightshift */
         4,                     /* size (0 = byte, 1 = short, 2 = long) */
         64,                    /* bitsize */
         false,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield, /* complain_on_overflow */
         0,                     /* special_function */
         "R_POS",               /* name */
         true,                  /* partial_inplace */
         MINUS_ONE,             /* src_mask */
	 MINUS_ONE,             /* dst_mask */
	 false)                 /* pcrel_offset */
d966 14
a979 1
};
d981 7
a987 40
/* These are the first two like the above but for 16-bit relocs.  */
static reloc_howto_type xcoff_howto_table_16[] =
{
  /* Standard 16 bit relocation.  */
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */

  /* 16 bit relocation, but store negative value.  */
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_NEG_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */

  /* 16 bit PC relative relocation.  */
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d989 8
a996 7
	 0,		        /* special_function */
	 "R_REL_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false)                /* pcrel_offset */
  };
d999 1
a999 1
_bfd_xcoff_rtype2howto (relent, internal)
d1003 2
a1004 1
  relent->howto = xcoff_howto_table + internal->r_type;
d1006 13
a1018 4
  if (relent->howto->bitsize != ((unsigned int) internal->r_size & 0x1f) + 1
      && (internal->r_type
	  < sizeof (xcoff_howto_table_16)/sizeof (xcoff_howto_table_16[0])))
    relent->howto = xcoff_howto_table_16 + internal->r_type;
d1027 1
a1027 6
	  != ((unsigned int) internal->r_size & 0x3f) + 1))
    abort ();
#if 0
  if ((internal->r_size & 0x80) != 0
      ? (relent->howto->complain_on_overflow != complain_overflow_signed)
      : (relent->howto->complain_on_overflow != complain_overflow_bitfield))
a1028 1
#endif
d1040 2
a1048 2
    case BFD_RELOC_64:
      return &xcoff_howto_table[0x1c];
d1053 1
d1100 1
a1100 3
#define XCOFFARMAG    "<aiaff>\012"
#define XCOFFARMAGBIG "<bigaf>\012"
#define SXCOFFARMAG   8
d1102 4
a1105 8
/* This terminates an XCOFF archive member name.  */

#define XCOFFARFMAG "`\012"
#define SXCOFFARFMAG 2

/* XCOFF archives start with this (printable) structure.  */

struct xcoff_ar_file_hdr
d1107 4
a1110 149
  /* Magic string.  */
  char magic[SXCOFFARMAG];

  /* Offset of the member table (decimal ASCII string).  */
  char memoff[12];

  /* Offset of the global symbol table (decimal ASCII string).  */
  char symoff[12];

  /* Offset of the first member in the archive (decimal ASCII string).  */
  char firstmemoff[12];

  /* Offset of the last member in the archive (decimal ASCII string).  */
  char lastmemoff[12];

  /* Offset of the first member on the free list (decimal ASCII
     string).  */
  char freeoff[12];
};

#define SIZEOF_AR_FILE_HDR (5 * 12 + SXCOFFARMAG)

/* This is the equivalent data structure for the big archive format.  */

struct xcoff_ar_file_hdr_big
{
  /* Magic string.  */
  char magic[SXCOFFARMAG];

  /* Offset of the member table (decimal ASCII string).  */
  char memoff[20];

  /* Offset of the global symbol table for 32-bit objects (decimal ASCII
     string).  */
  char symoff[20];

  /* Offset of the global symbol table for 64-bit objects (decimal ASCII
     string).  */
  char symoff64[20];

  /* Offset of the first member in the archive (decimal ASCII string).  */
  char firstmemoff[20];

  /* Offset of the last member in the archive (decimal ASCII string).  */
  char lastmemoff[20];

  /* Offset of the first member on the free list (decimal ASCII
     string).  */
  char freeoff[20];
};

#define SIZEOF_AR_FILE_HDR_BIG (6 * 20 + SXCOFFARMAG)

/* Each XCOFF archive member starts with this (printable) structure.  */

struct xcoff_ar_hdr
{
  /* File size not including the header (decimal ASCII string).  */
  char size[12];

  /* File offset of next archive member (decimal ASCII string).  */
  char nextoff[12];

  /* File offset of previous archive member (decimal ASCII string).  */
  char prevoff[12];

  /* File mtime (decimal ASCII string).  */
  char date[12];

  /* File UID (decimal ASCII string).  */
  char uid[12];

  /* File GID (decimal ASCII string).  */
  char gid[12];

  /* File mode (octal ASCII string).  */
  char mode[12];

  /* Length of file name (decimal ASCII string).  */
  char namlen[4];

  /* This structure is followed by the file name.  The length of the
     name is given in the namlen field.  If the length of the name is
     odd, the name is followed by a null byte.  The name and optional
     null byte are followed by XCOFFARFMAG, which is not included in
     namlen.  The contents of the archive member follow; the number of
     bytes is given in the size field.  */
};

#define SIZEOF_AR_HDR (7 * 12 + 4)

/* The equivalent for the big archive format.  */

struct xcoff_ar_hdr_big
{
  /* File size not including the header (decimal ASCII string).  */
  char size[20];

  /* File offset of next archive member (decimal ASCII string).  */
  char nextoff[20];

  /* File offset of previous archive member (decimal ASCII string).  */
  char prevoff[20];

  /* File mtime (decimal ASCII string).  */
  char date[12];

  /* File UID (decimal ASCII string).  */
  char uid[12];

  /* File GID (decimal ASCII string).  */
  char gid[12];

  /* File mode (octal ASCII string).  */
  char mode[12];

  /* Length of file name (decimal ASCII string).  */
  char namlen[4];

  /* This structure is followed by the file name.  The length of the
     name is given in the namlen field.  If the length of the name is
     odd, the name is followed by a null byte.  The name and optional
     null byte are followed by XCOFFARFMAG, which is not included in
     namlen.  The contents of the archive member follow; the number of
     bytes is given in the size field.  */
};

#define SIZEOF_AR_HDR_BIG (3 * 20 + 4 * 12 + 4)

/* We often have to distinguish between the old and big file format.
   Make it a bit cleaner.  We can use `xcoff_ardata' here because the
   `hdr' member has the same size and position in both formats.  */
#define xcoff_big_format_p(abfd) \
  (xcoff_ardata (abfd)->magic[1] == 'b')

/* We store a copy of the xcoff_ar_file_hdr in the tdata field of the
   artdata structure.  Similar for the big archive.  */
#define xcoff_ardata(abfd) \
  ((struct xcoff_ar_file_hdr *) bfd_ardata (abfd)->tdata)
#define xcoff_ardata_big(abfd) \
  ((struct xcoff_ar_file_hdr_big *) bfd_ardata (abfd)->tdata)

/* We store a copy of the xcoff_ar_hdr in the arelt_data field of an
   archive element.  Similar for the big archive.  */
#define arch_eltdata(bfd) ((struct areltdata *) ((bfd)->arelt_data))
#define arch_xhdr(bfd) \
  ((struct xcoff_ar_hdr *) arch_eltdata (bfd)->arch_header)
#define arch_xhdr_big(bfd) \
  ((struct xcoff_ar_hdr_big *) arch_eltdata (bfd)->arch_header)
d1114 1
a1114 1
boolean
d1128 2
a1129 2
      bfd_has_map (abfd) = false;
      return true;
d1140 2
a1141 2
	  bfd_has_map (abfd) = false;
	  return true;
d1145 1
a1145 1
	return false;
d1148 3
a1150 2
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
	return false;
d1154 3
a1156 2
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
	return false;
d1163 3
a1165 3
	return false;
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
	return false;
d1168 1
a1168 1
      c = bfd_h_get_32 (abfd, contents);
d1173 1
a1173 1
	  return false;
d1176 2
a1177 2
      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
d1179 1
a1179 1
	return false;
d1185 1
a1185 1
	arsym->file_offset = bfd_h_get_32 (abfd, p);
d1195 2
a1196 2
	  bfd_has_map (abfd) = false;
	  return true;
d1200 1
a1200 1
	return false;
d1203 1
a1203 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
d1205 1
a1205 1
	return false;
d1209 3
a1211 2
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
	return false;
d1221 3
a1223 3
	return false;
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
	return false;
d1226 1
a1226 1
      c = bfd_h_get_64 (abfd, contents);
d1231 1
a1231 1
	  return false;
d1234 2
a1235 2
      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
d1237 1
a1237 1
	return false;
d1243 1
a1243 1
	arsym->file_offset = bfd_h_get_64 (abfd, p);
d1255 1
a1255 1
	  return false;
d1261 1
a1261 1
  bfd_has_map (abfd) = true;
d1263 1
a1263 1
  return true;
d1272 1
d1274 1
d1276 1
a1276 1
  if (bfd_read ((PTR) magic, SXCOFFARMAG, 1, abfd) != SXCOFFARMAG)
d1290 1
a1290 5
  /* We are setting bfd_ardata(abfd) here, but since bfd_ardata
     involves a cast, we can't do it as the left operand of
     assignment.  */
  abfd->tdata.aout_ar_data =
    (struct artdata *) bfd_zalloc (abfd, sizeof (struct artdata));
d1292 2
d1295 1
a1295 1
    return NULL;
d1312 2
a1313 2
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR - SXCOFFARMAG)
d1317 1
a1317 1
	  return NULL;
d1323 2
a1324 1
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR);
d1326 1
a1326 1
	return NULL;
d1339 2
a1340 2
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG)
d1344 1
a1344 1
	  return NULL;
d1347 3
a1349 5
      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);
d1351 2
a1352 1
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR_BIG);
d1354 1
a1354 1
	return NULL;
d1361 1
d1363 2
a1364 1
      abfd->tdata.aout_ar_data = (struct artdata *) NULL;
d1377 1
a1377 1
  size_t namlen;
d1379 1
d1381 1
a1381 1
  ret = (struct areltdata *) bfd_alloc (abfd, sizeof (struct areltdata));
d1390 2
a1391 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
d1398 2
a1399 2
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd,
						SIZEOF_AR_HDR + namlen + 1);
d1406 1
a1406 1
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR, 1, namlen, abfd) != namlen)
d1422 1
a1422 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
d1430 2
a1431 3
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd,
						    SIZEOF_AR_HDR_BIG
						    + namlen + 1);
d1438 1
a1438 1
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR_BIG, 1, namlen, abfd) != namlen)
d1454 1
a1454 1
  if (bfd_seek (abfd, (namlen & 1) + SXCOFFARFMAG, SEEK_CUR) != 0)
d1524 1
a1524 1
_bfd_xcoff_generic_stat_arch_elt (abfd, s)
d1534 1
a1534 1
  if (! xcoff_big_format_p (abfd))
d1578 2
a1579 1
static boolean
d1597 1
a1597 1
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, 12);
d1609 9
a1617 7
  if (bfd_write ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR
      || bfd_write (XCOFFARFMAG, 1, SXCOFFARFMAG, abfd) != SXCOFFARFMAG)
    return false;

  bfd_h_put_32 (abfd, orl_count, buf);
  if (bfd_write (buf, 1, 4, abfd) != 4)
    return false;
d1626 1
a1626 1
      while (((bfd *) (map[i]).pos) == sub)
d1628 3
a1630 3
	  bfd_h_put_32 (abfd, fileoff, buf);
	  if (bfd_write (buf, 1, 4, abfd) != 4)
	    return false;
d1634 1
a1634 1
      namlen = (namlen + 1) &~ 1;
d1650 2
a1651 2
      if (bfd_write (name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
d1659 2
a1660 2
      if (bfd_write (&b, 1, 1, abfd) != 1)
	return false;
d1663 1
a1663 1
  return true;
d1666 28
a1693 4
/* Write a single armap in the big format.  */
static boolean
xcoff_write_one_armap_big (abfd, map, orl_count, orl_ccount, stridx, bits64,
			   prevoff, nextoff)
d1695 1
a1695 7
     struct orl *map;
     unsigned int orl_count;
     unsigned int orl_ccount;
     unsigned int stridx;
     int bits64;
     const char *prevoff;
     char *nextoff;
d1697 9
a1705 8
  struct xcoff_ar_hdr_big hdr;
  char *p;
  unsigned char buf[4];
  const bfd_arch_info_type *arch_info = NULL;
  bfd *sub;
  file_ptr fileoff;
  bfd *object_bfd;
  unsigned int i;
d1707 2
a1708 16
  memset (&hdr, 0, sizeof hdr);
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (hdr.size, "%ld", (long) (4 + orl_ccount * 4 + stridx));
  if (bits64)
    sprintf (hdr.nextoff, "%d", 0);
  else
    sprintf (hdr.nextoff, "%ld", (strtol (prevoff, (char **) NULL, 10)
				 + 4 + orl_ccount * 4 + stridx));
  memcpy (hdr.prevoff, prevoff, sizeof (hdr.prevoff));
  sprintf (hdr.date, "%d", 0);
  sprintf (hdr.uid, "%d", 0);
  sprintf (hdr.gid, "%d", 0);
  sprintf (hdr.mode, "%d", 0);
  sprintf (hdr.namlen, "%d", 0);
d1710 7
a1716 4
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &hdr; p < (char *) &hdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';
d1718 2
a1719 1
  memcpy (nextoff, hdr.nextoff, sizeof (hdr.nextoff));
d1721 1
a1721 7
  if (bfd_write ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd) != SIZEOF_AR_HDR_BIG
      || bfd_write (XCOFFARFMAG, 1, SXCOFFARFMAG, abfd) != SXCOFFARFMAG)
    return false;

  bfd_h_put_32 (abfd, orl_ccount, buf);
  if (bfd_write (buf, 1, 4, abfd) != 4)
    return false;
d1723 1
a1723 4
  sub = abfd->archive_head;
  fileoff = SIZEOF_AR_FILE_HDR_BIG;
  i = 0;
  while (sub != NULL && i < orl_count)
d1725 3
a1727 1
      size_t namlen;
d1729 2
a1730 11
      if ((bfd_arch_bits_per_address ((bfd *) map[i].pos) == 64) == bits64)
	while (((bfd *) (map[i]).pos) == sub)
	  {
	    bfd_h_put_32 (abfd, fileoff, buf);
	    if (bfd_write (buf, 1, 4, abfd) != 4)
	      return false;
	    i++;
	  }
      else
	while (((bfd *) (map[i]).pos) == sub)
	  i++;
d1732 5
a1736 8
      namlen = strlen (normalize_filename (sub));
      namlen = (namlen + 1) &~ 1;
      fileoff += (SIZEOF_AR_HDR_BIG
		  + namlen
		  + SXCOFFARFMAG
		  + arelt_size (sub));
      fileoff = (fileoff + 1) &~ 1;
      sub = sub->next;
d1739 13
a1751 2
  object_bfd = NULL;
  for (i = 0; i < orl_count; i++)
d1753 2
a1754 3
      const char *name;
      size_t namlen;
      bfd *ob = (bfd *)map[i].pos;
d1756 1
a1756 5
      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);

      if (arch_info && (arch_info->bits_per_address == 64) != bits64)
	continue;
d1758 2
a1759 5
      name = *map[i].name;
      namlen = strlen (name);
      if (bfd_write (name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
    }
d1761 2
a1762 3
  if ((stridx & 1) != 0)
    {
      char b;
d1764 1
a1764 3
      b = '\0';
      if (bfd_write (&b, 1, 1, abfd) != 1)
	return false;
d1767 1
a1767 1
  return true;
d1770 1
a1770 1
static boolean
d1778 2
a1779 3
  unsigned int i;
  unsigned int orl_count_32, orl_count_64;
  unsigned int stridx_32, stridx_64;
d1781 3
a1783 1
  bfd *object_bfd;
d1787 7
a1793 6
  orl_count_32 = 0;
  orl_count_64 = 0;
  stridx_32 = 0;
  stridx_64 = 0;
  object_bfd = NULL;
  for (i = 0; i < orl_count; i++)
d1795 1
a1795 6
      bfd *ob = (bfd *)map[i].pos;
      unsigned int len;
      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);
      len = strlen (*map[i].name) + 1;
      if (arch_info && arch_info->bits_per_address == 64)
d1797 13
a1809 2
	  orl_count_64++;
	  stridx_64 += len;
d1811 64
d1876 23
d1900 138
a2037 2
	  orl_count_32++;
	  stridx_32 += len;
d2039 7
a2045 1
      object_bfd = ob;
d2047 2
a2048 15
  /* A quick sanity check...  */
  BFD_ASSERT (orl_count_64 + orl_count_32 == orl_count);
  BFD_ASSERT (stridx_64 + stridx_32 == stridx);

  /* Now write out each map.  */
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_32,
				   stridx_32, false,
				   xcoff_ardata_big (abfd)->memoff,
				   xcoff_ardata_big (abfd)->symoff))
    return false;
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_64,
				   stridx_64, true,
				   xcoff_ardata_big (abfd)->symoff,
				   xcoff_ardata_big (abfd)->symoff64))
    return false;
d2050 1
a2050 1
  return true;
d2053 1
a2053 1
boolean
d2070 1
a2070 1
static boolean
d2075 2
a2076 2
  size_t count;
  size_t total_namlen;
d2078 3
a2080 3
  boolean makemap;
  boolean hasobjects;
  file_ptr prevoff, nextoff;
d2082 1
a2082 1
  unsigned int i;
d2086 1
a2086 1
  char decbuf[13];
d2102 1
a2102 1
    return false;
d2104 2
a2105 2
  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return false;
d2108 1
a2108 1
  hasobjects = false;
d2114 1
a2114 1
      size_t namlen;
d2121 1
a2121 1
	    hasobjects = true;
d2141 1
a2141 1
	      return false;
d2152 2
a2153 1
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
d2155 1
a2155 1
		return false;
d2165 2
a2166 2
         after the name as well.  */
      namlen = (namlen + 1) &~ 1;
d2188 6
a2193 5
      if (bfd_write ((PTR) ahdrp, 1, SIZEOF_AR_HDR, abfd) != SIZEOF_AR_HDR
	  || bfd_write ((PTR) name, 1, namlen, abfd) != namlen
	  || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
	      != SXCOFFARFMAG))
	return false;
d2196 1
a2196 5
	return false;
      while (remaining != 0)
	{
	  bfd_size_type amt;
	  bfd_byte buffer[DEFAULT_BUFFERSIZE];
d2198 2
a2199 8
	  amt = sizeof buffer;
	  if (amt > remaining)
	    amt = remaining;
	  if (bfd_read (buffer, 1, amt, sub) != amt
	      || bfd_write (buffer, 1, amt, abfd) != amt)
	    return false;
	  remaining -= amt;
	}
d2201 2
a2202 8
      if ((size & 1) != 0)
	{
	  bfd_byte b;

	  b = '\0';
	  if (bfd_write (&b, 1, 1, abfd) != 1)
	    return false;
	}
d2213 3
a2215 1
  sprintf (ahdr.size, "%ld", (long) (12 + count * 12 + total_namlen));
d2224 2
a2225 2
	  + 12
	  + count * 12
d2242 3
a2244 2
  if (bfd_write ((PTR) &ahdr, 1, SIZEOF_AR_HDR, abfd) != SIZEOF_AR_HDR
      || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
d2246 1
a2246 1
    return false;
d2249 4
a2252 3
  if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
    return false;
  for (i = 0; i < count; i++)
d2255 3
a2257 2
      if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
	return false;
d2262 1
a2262 1
      size_t namlen;
d2266 2
a2267 2
      if (bfd_write ((PTR) name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
a2268 3
  if ((size & 1) != 0)
    {
      bfd_byte b;
d2270 2
a2271 4
      b = '\0';
      if (bfd_write ((PTR) &b, 1, 1, abfd) != 1)
	return false;
    }
a2273 1

d2282 1
a2282 1
	return false;
d2293 3
a2295 3
      || (bfd_write ((PTR) &fhdr, SIZEOF_AR_FILE_HDR, 1, abfd) !=
	  SIZEOF_AR_FILE_HDR))
    return false;
d2297 1
a2297 1
  return true;
d2300 1
a2300 1
static boolean
d2305 2
a2306 2
  size_t count;
  size_t total_namlen;
d2308 6
a2313 6
  boolean makemap;
  boolean hasobjects;
  file_ptr prevoff, nextoff;
  bfd *sub;
  unsigned int i;
  struct xcoff_ar_hdr_big ahdr;
d2315 5
a2319 2
  char *p;
  char decbuf[13];
d2321 2
a2322 4
  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR_BIG);
  sprintf (fhdr.freeoff, "%d", 0);
d2324 6
a2329 3
  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2331 6
a2336 2
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
a2337 3
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return false;
d2339 7
a2345 2
  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return false;
a2346 2
  makemap = bfd_has_map (abfd);
  hasobjects = false;
d2349 3
a2351 1
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
d2354 1
a2354 1
      size_t namlen;
d2358 1
a2358 7
      if (makemap && ! hasobjects)
	{
	  if (bfd_check_format (sub, bfd_object))
	    hasobjects = true;
	}

      name = normalize_filename (sub);
d2361 2
a2362 2
      if (sub->arelt_data != NULL)
	ahdrp = arch_xhdr_big (sub);
a2369 1
	  memset (&ahdr, 0, sizeof ahdr);
d2372 3
a2374 2
	     32-bit machines).  */
	  if (stat (bfd_get_filename (sub), &s) != 0)
d2377 1
a2377 1
	      return false;
d2380 5
a2384 8
	  /* XXX This call actually should use %lld (at least on 32-bit
	     machines) since the fields's width is 20 and there numbers with
	     more than 32 bits can be represented.  */
	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);
d2386 1
a2386 1
	  if (sub->arelt_data == NULL)
d2388 4
a2391 3
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
	      if (sub->arelt_data == NULL)
		return false;
d2394 1
a2394 1
	  arch_eltdata (sub)->parsed_size = s.st_size;
d2397 2
a2398 5
      /* XXX These calls actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) namlen);
d2401 2
a2402 2
         after the name as well.  */
      namlen = (namlen + 1) &~ 1;
d2404 1
a2404 1
      remaining = arelt_size (sub);
d2412 8
d2425 1
a2425 13
      sprintf (ahdrp->nextoff, "%ld", (long) nextoff);

      /* We need spaces, not null bytes, in the header.  */
      for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR_BIG; p++)
	if (*p == '\0')
	  *p = ' ';

      if (bfd_write ((PTR) ahdrp, 1, SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG
	  || bfd_write ((PTR) name, 1, namlen, abfd) != namlen
	  || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
	      != SXCOFFARFMAG))
	return false;
d2427 43
a2469 32
      if (bfd_seek (sub, (file_ptr) 0, SEEK_SET) != 0)
	return false;
      while (remaining != 0)
	{
	  bfd_size_type amt;
	  bfd_byte buffer[DEFAULT_BUFFERSIZE];

	  amt = sizeof buffer;
	  if (amt > remaining)
	    amt = remaining;
	  if (bfd_read (buffer, 1, amt, sub) != amt
	      || bfd_write (buffer, 1, amt, abfd) != amt)
	    return false;
	  remaining -= amt;
	}

      if ((size & 1) != 0)
	{
	  bfd_byte b;

	  b = '\0';
	  if (bfd_write (&b, 1, 1, abfd) != 1)
	    return false;
	}
    }

  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);

  /* Write out the member table.  */
a2471 25
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.memoff, "%ld", (long) nextoff);

  memset (&ahdr, 0, sizeof ahdr);
  /* XXX The next two calls actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (ahdr.size, "%ld", (long) (12 + count * 12 + total_namlen));
  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
  sprintf (ahdr.date, "%d", 0);
  sprintf (ahdr.uid, "%d", 0);
  sprintf (ahdr.gid, "%d", 0);
  sprintf (ahdr.mode, "%d", 0);
  sprintf (ahdr.namlen, "%d", 0);

  size = (SIZEOF_AR_HDR_BIG
	  + 12
	  + count * 12
	  + total_namlen
	  + SXCOFFARFMAG);

  prevoff = nextoff;
  nextoff += size + (size & 1);
d2473 17
d2491 1
a2491 4
    /* XXX This call actually should use %lld (at least on 32-bit
       machines) since the fields's width is 20 and there numbers with
       more than 32 bits can be represented.  */
    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
d2493 7
a2499 1
    sprintf (ahdr.nextoff, "%d", 0);
d2501 3
a2503 4
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &ahdr; p < (char *) &ahdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';
d2505 7
a2511 4
  if (bfd_write ((PTR) &ahdr, 1, SIZEOF_AR_HDR_BIG, abfd) != SIZEOF_AR_HDR_BIG
      || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return false;
d2513 1
a2513 4
  sprintf (decbuf, "%-12ld", (long) count);
  if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
    return false;
  for (i = 0; i < count; i++)
d2515 2
a2516 3
      sprintf (decbuf, "%-12ld", (long) offsets[i]);
      if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
	return false;
d2518 3
a2520 1
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2525 3
a2527 4
      name = normalize_filename (sub);
      namlen = strlen (name);
      if (bfd_write ((PTR) name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
a2528 3
  if ((size & 1) != 0)
    {
      bfd_byte b;
d2530 10
a2539 4
      b = '\0';
      if (bfd_write ((PTR) &b, 1, 1, abfd) != 1)
	return false;
    }
d2544 1
a2544 1
    sprintf (fhdr.symoff, "%d", 0);
d2548 4
a2551 3
      /* XXX This call actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
d2554 1
a2554 1
	return false;
a2558 5
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &fhdr; p < (char *) &fhdr + SIZEOF_AR_FILE_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

d2560 3
a2562 3
      || (bfd_write ((PTR) &fhdr, SIZEOF_AR_FILE_HDR_BIG, 1, abfd) !=
	  SIZEOF_AR_FILE_HDR_BIG))
    return false;
d2564 1
a2564 1
  return true;
d2567 1
a2567 1
boolean
d2583 1
a2583 1
     boolean reloc ATTRIBUTE_UNUSED;
d2595 1860
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d9 1
a9 1
   Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365, 
a29 3
/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
#define RS6000COFF_C 1

d36 3
a41 12
static boolean xcoff_mkobject PARAMS ((bfd *));
static boolean xcoff_copy_private_bfd_data PARAMS ((bfd *, bfd *));
static boolean xcoff_is_local_label_name PARAMS ((bfd *, const char *));
static void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
static reloc_howto_type *xcoff_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static boolean xcoff_slurp_armap PARAMS ((bfd *));
static const bfd_target *xcoff_archive_p PARAMS ((bfd *));
static PTR xcoff_read_ar_hdr PARAMS ((bfd *));
static bfd *xcoff_openr_next_archived_file PARAMS ((bfd *, bfd *));
static int xcoff_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
d43 1
a43 5
static boolean xcoff_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static boolean xcoff_write_archive_contents PARAMS ((bfd *));
static int _bfd_xcoff_sizeof_headers PARAMS ((bfd *, boolean));

d47 2
a48 2
static boolean
xcoff_mkobject (abfd)
d78 2
a79 2
static boolean
xcoff_copy_private_bfd_data (ibfd, obfd)
d126 2
a127 2
static boolean
xcoff_is_local_label_name (abfd, name)
d134 272
d412 5
a416 1
static reloc_howto_type xcoff_howto_table[] =
d419 12
a430 12
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d434 12
a445 12
  HOWTO (1,	                /* type */                                 
	 0,	                /* rightshift */                           
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_NEG",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d449 6
a454 6
  HOWTO (2,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d456 5
a460 5
	 0,		        /* special_function */                     
	 "R_REL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d462 1
a462 1
  
d464 12
a475 12
  HOWTO (3,	                /* type */                                 
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TOC",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d477 1
a477 1
  
d479 12
a490 12
  HOWTO (4,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RTB",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d492 1
a492 1
  
d494 12
a505 12
  HOWTO (5,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_GL",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d507 1
a507 1
  
d509 12
a520 12
  HOWTO (6,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TCL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d522 1
a522 1
  
d524 1
a524 1
  
d526 12
a537 12
  HOWTO (8,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_BA",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d539 1
a539 1
  
d543 6
a548 6
  HOWTO (0xa,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d550 5
a554 5
	 0,		        /* special_function */                     
	 "R_BR",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d556 1
a556 1
  
d560 12
a571 12
  HOWTO (0xc,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RL",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d573 1
a573 1
  
d575 12
a586 12
  HOWTO (0xd,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RLA",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d588 1
a588 1
  
d590 1
a590 1
  
d592 12
a603 12
  HOWTO (0xf,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_REF",               /* name */                                 
	 false,	                /* partial_inplace */                      
	 0,		        /* src_mask */                             
	 0,     	   	/* dst_mask */                             
d605 1
a605 1
  
d608 1
a608 1
  
d610 12
a621 12
  HOWTO (0x12,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TRL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d623 1
a623 1
  
d625 12
a636 12
  HOWTO (0x13,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TRLA",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d638 1
a638 1
  
d640 12
a651 12
  HOWTO (0x14,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RRTBI",             /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d653 1
a653 1
  
d655 12
a666 12
  HOWTO (0x15,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RRTBA",             /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d668 1
a668 1
  
d670 12
a681 12
  HOWTO (0x16,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_CAI",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d683 1
a683 1
  
d685 12
a696 12
  HOWTO (0x17,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_CREL",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d698 1
a698 1
  
d700 12
a711 12
  HOWTO (0x18,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBA",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d713 1
a713 1
  
d715 12
a726 12
  HOWTO (0x19,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBAC",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d728 1
a728 1
  
d730 6
a735 6
  HOWTO (0x1a,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d737 5
a741 5
	 0,		        /* special_function */                     
	 "R_RBR",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d743 1
a743 1
  
d745 25
a769 12
  HOWTO (0x1b,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBRC",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d771 1
d778 12
a789 12
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d793 12
a804 12
  HOWTO (1,	                /* type */                                 
	 0,	                /* rightshift */                           
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_NEG_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d808 6
a813 6
  HOWTO (2,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d815 10
a824 10
	 0,		        /* special_function */                     
	 "R_REL_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */
};
  
static void
xcoff_rtype2howto (relent, internal)
d831 2
a832 2
      && (internal->r_type 
	  < sizeof(xcoff_howto_table_16)/sizeof(xcoff_howto_table_16[0])))
d838 5
a842 2
     type matches this information.  */
  if (relent->howto->bitsize != ((unsigned int) internal->r_size & 0x1f) + 1)
d852 2
a853 2
static reloc_howto_type *
xcoff_reloc_type_lookup (abfd, code)
d868 2
a873 24

#define SELECT_RELOC(internal, howto)					\
  {									\
    internal.r_type = howto->type;					\
    internal.r_size =							\
      ((howto->complain_on_overflow == complain_overflow_signed		\
	? 0x80								\
	: 0)								\
       | (howto->bitsize - 1));						\
  }

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)

#define COFF_LONG_FILENAMES

#define RTYPE2HOWTO(cache_ptr, dst) xcoff_rtype2howto (cache_ptr, dst)

#define coff_mkobject xcoff_mkobject
#define coff_bfd_copy_private_bfd_data xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup xcoff_reloc_type_lookup
#define coff_relocate_section _bfd_ppc_xcoff_relocate_section

#include "coffcode.h"
a985 1

a1061 1

a1082 17
/* XCOFF archives do not have anything which corresponds to an
   extended name table.  */

#define xcoff_slurp_extended_name_table bfd_false
#define xcoff_construct_extended_name_table \
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
   bfd_false)
#define xcoff_truncate_arname bfd_dont_truncate_arname

/* We can use the standard get_elt_at_index routine.  */

#define xcoff_get_elt_at_index _bfd_generic_get_elt_at_index

/* XCOFF archives do not have a timestamp.  */

#define xcoff_update_armap_timestamp bfd_true

d1085 2
a1086 2
static boolean
xcoff_slurp_armap (abfd)
d1093 1
a1093 1
  unsigned int c, i;
d1128 27
a1184 1
    }
d1186 6
a1191 6
  /* Read in the entire symbol table.  */
  contents = (bfd_byte *) bfd_alloc (abfd, sz);
  if (contents == NULL)
    return false;
  if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
    return false;
d1193 2
a1194 2
  /* The symbol table starts with a four byte count.  */
  c = bfd_h_get_32 (abfd, contents);
d1196 5
a1200 5
  if (c * 4 >= sz)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
    }
d1202 4
a1205 4
  bfd_ardata (abfd)->symdefs = ((carsym *)
				bfd_alloc (abfd, c * sizeof (carsym)));
  if (bfd_ardata (abfd)->symdefs == NULL)
    return false;
d1207 6
a1212 5
  /* After the count comes a list of four byte file offsets.  */
  for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;
       i < c;
       ++i, ++arsym, p += 4)
    arsym->file_offset = bfd_h_get_32 (abfd, p);
d1236 2
a1237 2
static const bfd_target *
xcoff_archive_p (abfd)
d1327 1
a1327 1
  if (! xcoff_slurp_armap (abfd))
d1339 2
a1340 2
static PTR
xcoff_read_ar_hdr (abfd)
d1427 2
a1428 2
static bfd *
xcoff_openr_next_archived_file (archive, last_file)
d1488 2
a1489 2
static int
xcoff_generic_stat_arch_elt (abfd, s)
a1542 1
/*ARGSUSED*/
d1628 1
a1628 1
/*ARGSUSED*/
d1630 2
a1631 1
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
a1632 1
     unsigned int elength ATTRIBUTE_UNUSED;
d1635 5
a1639 1
     int stridx;
d1644 1
d1647 1
d1654 7
a1660 3
  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
  sprintf (hdr.nextoff, "%d", 0);
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, 12);
d1672 2
d1678 1
a1678 1
  bfd_h_put_32 (abfd, orl_count, buf);
d1689 12
a1700 7
      while (((bfd *) (map[i]).pos) == sub)
	{
	  bfd_h_put_32 (abfd, fileoff, buf);
	  if (bfd_write (buf, 1, 4, abfd) != 4)
	    return false;
	  ++i;
	}
d1711 1
d1716 7
a1741 1
/*ARGSUSED*/
d1743 60
a1802 1
xcoff_write_armap (abfd, elength, map, orl_count, stridx)
a2310 1
      sprintf (fhdr.symoff, "%ld", (long) nextoff);
d2331 2
a2332 2
static boolean
xcoff_write_archive_contents (abfd)
d2344 1
a2344 2
/*ARGSUSED*/
static int
a2358 113

#define CORE_FILE_P _bfd_dummy_target

#define coff_core_file_failing_command _bfd_nocore_core_file_failing_command
#define coff_core_file_failing_signal _bfd_nocore_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  _bfd_nocore_core_file_matches_executable_p

#ifdef AIX_CORE
#undef CORE_FILE_P
#define CORE_FILE_P rs6000coff_core_p
extern const bfd_target * rs6000coff_core_p ();
extern boolean rs6000coff_get_section_contents ();
extern boolean rs6000coff_core_file_matches_executable_p ();

#undef	coff_core_file_matches_executable_p
#define coff_core_file_matches_executable_p  \
				     rs6000coff_core_file_matches_executable_p

extern char *rs6000coff_core_file_failing_command PARAMS ((bfd *abfd));
#undef coff_core_file_failing_command
#define coff_core_file_failing_command rs6000coff_core_file_failing_command

extern int rs6000coff_core_file_failing_signal PARAMS ((bfd *abfd));
#undef coff_core_file_failing_signal
#define coff_core_file_failing_signal rs6000coff_core_file_failing_signal

#undef	coff_get_section_contents
#define	coff_get_section_contents	rs6000coff_get_section_contents
#endif /* AIX_CORE */

#ifdef LYNX_CORE

#undef CORE_FILE_P
#define CORE_FILE_P lynx_core_file_p
extern const bfd_target *lynx_core_file_p PARAMS ((bfd *abfd));

extern boolean lynx_core_file_matches_executable_p PARAMS ((bfd *core_bfd,
							    bfd *exec_bfd));
#undef	coff_core_file_matches_executable_p
#define coff_core_file_matches_executable_p lynx_core_file_matches_executable_p

extern char *lynx_core_file_failing_command PARAMS ((bfd *abfd));
#undef coff_core_file_failing_command
#define coff_core_file_failing_command lynx_core_file_failing_command

extern int lynx_core_file_failing_signal PARAMS ((bfd *abfd));
#undef coff_core_file_failing_signal
#define coff_core_file_failing_signal lynx_core_file_failing_signal

#endif /* LYNX_CORE */

#define _bfd_xcoff_bfd_get_relocated_section_contents \
  coff_bfd_get_relocated_section_contents
#define _bfd_xcoff_bfd_relax_section coff_bfd_relax_section
#define _bfd_xcoff_bfd_gc_sections coff_bfd_gc_sections
#define _bfd_xcoff_bfd_link_split_section coff_bfd_link_split_section

/* The transfer vector that leads the outside world to all of the above. */

const bfd_target
#ifdef TARGET_SYM
  TARGET_SYM =
#else
  rs6000coff_vec =
#endif
{
#ifdef TARGET_NAME
  TARGET_NAME,
#else
  "aixcoff-rs6000",		/* name */
#endif
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG | DYNAMIC |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     xcoff_archive_p, CORE_FILE_P},
  {bfd_false, coff_mkobject,		/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     xcoff_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (coff),
     BFD_JUMP_TABLE_ARCHIVE (xcoff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (_bfd_xcoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_xcoff),

  NULL,
  
  COFF_SWAP_TABLE
};
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a34 1
#include "obstack.h"
d43 1
d57 1
d135 13
d262 1
a262 1
  { 7 },
d279 1
a279 1
  { 9 },
d296 1
a296 1
  { 0xb },
d328 1
a328 1
  { 0xe },
d345 2
a346 2
  { 0x10 },
  { 0x11 },
d499 49
d555 5
d576 1
a576 1
     bfd *abfd;
d613 1
d648 1
a648 1
   null terminated strings, which are symbol names.  */
d650 17
a666 4
/* XCOFF archives use this as a magic string.  */

#define XCOFFARMAG "<aiaff>\012"
#define SXCOFFARMAG 8
d699 32
d769 45
d815 1
a815 1
   artdata structure.  */
d818 2
d822 1
a822 1
   archive element.  */
d826 2
a852 1
  struct xcoff_ar_hdr hdr;
d866 1
a866 2
  off = strtol (xcoff_ardata (abfd)->symoff, (char **) NULL, 10);
  if (off == 0)
d868 23
a890 2
      bfd_has_map (abfd) = false;
      return true;
d892 14
d907 4
a910 2
  if (bfd_seek (abfd, off, SEEK_SET) != 0)
    return false;
d912 4
a915 3
  /* The symbol table starts with a normal archive header.  */
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
    return false;
d917 5
a921 4
  /* Skip the name (normally empty).  */
  namlen = strtol (hdr.namlen, (char **) NULL, 10);
  if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
    return false;
a923 1
  sz = strtol (hdr.size, (char **) NULL, 10);
d976 1
a976 1
  struct xcoff_ar_file_hdr hdr;
d978 1
a978 2
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_FILE_HDR, 1, abfd)
      != SIZEOF_AR_FILE_HDR)
d985 2
a986 1
  if (strncmp (hdr.magic, XCOFFARMAG, SXCOFFARMAG) != 0)
a1000 2
  bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						  (char **) NULL, 10);
d1006 53
a1058 3
  bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR);
  if (bfd_ardata (abfd)->tdata == NULL)
    return NULL;
d1060 2
a1061 1
  memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR);
a1078 1
  struct xcoff_ar_hdr hdr;
a1079 1
  struct xcoff_ar_hdr *hdrp;
d1082 2
a1083 1
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
d1086 59
a1144 8
  namlen = strtol (hdr.namlen, (char **) NULL, 10);
  hdrp = bfd_alloc (abfd, SIZEOF_AR_HDR + namlen + 1);
  if (hdrp == NULL)
    return NULL;
  memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
  if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR, 1, namlen, abfd) != namlen)
    return NULL;
  ((char *) hdrp)[SIZEOF_AR_HDR + namlen] = '\0';
d1146 7
a1152 6
  ret = (struct areltdata *) bfd_alloc (abfd, sizeof (struct areltdata));
  if (ret == NULL)
    return NULL;
  ret->arch_header = (char *) hdrp;
  ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
  ret->filename = (char *) hdrp + SIZEOF_AR_HDR;
d1176 18
a1193 2
  if (last_file == NULL)
    filestart = bfd_ardata (archive)->first_file_filepos;
a1194 7
    filestart = strtol (arch_xhdr (last_file)->nextoff, (char **) NULL, 10);

  if (filestart == 0
      || filestart == strtol (xcoff_ardata (archive)->memoff,
			      (char **) NULL, 10)
      || filestart == strtol (xcoff_ardata (archive)->symoff,
			      (char **) NULL, 10))
d1196 21
a1216 2
      bfd_set_error (bfd_error_no_more_archived_files);
      return NULL;
a1228 2
  struct xcoff_ar_hdr *hdrp;

d1235 13
a1247 1
  hdrp = arch_xhdr (abfd);
d1249 6
a1254 5
  s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
  s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
  s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
  s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
  s->st_size = arch_eltdata (abfd)->parsed_size;
d1281 1
a1281 1
xcoff_write_armap (abfd, elength, map, orl_count, stridx)
d1283 1
a1283 1
     unsigned int elength;
d1313 1
a1313 1
  
d1365 1
a1365 3
/* Write out an XCOFF archive.  We always write an entire archive,
   rather than fussing with the freelist and so forth.  */

d1367 1
a1367 1
xcoff_write_archive_contents (abfd)
d1369 4
d1374 3
a1376 7
  struct xcoff_ar_file_hdr fhdr;
  size_t count;
  size_t total_namlen;
  file_ptr *offsets;
  boolean makemap;
  boolean hasobjects;
  file_ptr prevoff, nextoff;
d1378 1
a1379 4
  struct xcoff_ar_hdr ahdr;
  bfd_size_type size;
  char *p;
  char decbuf[13];
d1381 17
a1397 4
  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR);
  sprintf (fhdr.freeoff, "%d", 0);
d1399 2
a1400 9
  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
d1403 104
a1506 1
  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
d1554 1
a1554 2
	      sub->arelt_data = ((struct areltdata *)
				 bfd_alloc (sub, sizeof (struct areltdata)));
d1716 279
d2003 1
a2003 1
     boolean reloc;
d2070 1
d2087 1
a2087 1
  bfd_target_coff_flavour,	
d2124 3
a2126 1
  COFF_SWAP_TABLE,
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d70 1
a70 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d97 1
d105 2
a106 2
  if (ix->toc_section == NULL)
    ox->toc_section = NULL;
d108 9
a116 3
    ox->toc_section = ix->toc_section->output_section;
  if (ix->entry_section == NULL)
    ox->entry_section = NULL;
d118 7
a124 1
    ox->entry_section = ix->entry_section->output_section;
d674 4
d726 1
a726 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d742 1
a742 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d799 1
a799 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d810 1
a810 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d841 1
a841 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d849 1
a849 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1061 1
a1061 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1114 1
a1114 4
		{
		  bfd_set_error (bfd_error_no_memory);
		  return false;
		}
d1366 2
a1367 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
d1400 1
a1400 1
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d70 4
a73 1
    return false;
a99 1
  asection *sec;
d107 2
a108 2
  if (ix->sntoc == 0)
    ox->sntoc = 0;
d110 3
a112 9
    {
      sec = coff_section_from_bfd_index (ibfd, ix->sntoc);
      if (sec == NULL)
	ox->sntoc = 0;
      else
	ox->sntoc = sec->output_section->target_index;
    }
  if (ix->snentry == 0)
    ox->snentry = 0;
d114 1
a114 7
    {
      sec = coff_section_from_bfd_index (ibfd, ix->snentry);
      if (sec == NULL)
	ox->snentry = 0;
      else
	ox->snentry = sec->output_section->target_index;
    }
a663 4
/* We can use the standard get_elt_at_index routine.  */

#define xcoff_get_elt_at_index _bfd_generic_get_elt_at_index

d712 4
a715 1
    return false;
d731 4
a734 1
    return false;
d791 4
a794 1
    return NULL;
d805 4
a808 1
    return NULL;
d839 4
a842 1
    return NULL;
d850 4
a853 1
    return NULL;
d1065 4
a1068 1
    return false;
d1121 4
a1124 1
		return false;
d1376 2
a1377 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
d1410 1
a1410 1
     BFD_JUMP_TABLE_DYNAMIC (_bfd_xcoff),
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d34 1
a42 1
static boolean xcoff_is_local_label_name PARAMS ((bfd *, const char *));
a55 1
static int _bfd_xcoff_sizeof_headers PARAMS ((bfd *, boolean));
a132 13

/* I don't think XCOFF really has a notion of local labels based on
   name.  This will mean that ld -X doesn't actually strip anything.
   The AIX native linker does not have a -X option, and it ignores the
   -x option.  */

static boolean
xcoff_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  return false;
}
a543 1
#define coff_bfd_is_local_label_name xcoff_is_local_label_name
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d142 2
a143 2
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
d261 1
a261 1
  EMPTY_HOWTO (7),
d278 1
a278 1
  EMPTY_HOWTO (9),
d295 1
a295 1
  EMPTY_HOWTO (0xb),
d327 1
a327 1
  EMPTY_HOWTO (0xe),
d344 2
a345 2
  EMPTY_HOWTO (0x10),
  EMPTY_HOWTO (0x11),
a497 49
/* These are the first two like the above but for 16-bit relocs.  */
static reloc_howto_type xcoff_howto_table_16[] =
{
  /* Standard 16 bit relocation.  */
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */

  /* 16 bit relocation, but store negative value.  */
  HOWTO (1,	                /* type */                                 
	 0,	                /* rightshift */                           
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_NEG_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */

  /* 16 bit PC relative relocation.  */
  HOWTO (2,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_REL_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */
};
  
a504 5
  if (relent->howto->bitsize != ((unsigned int) internal->r_size & 0x1f) + 1
      && (internal->r_type 
	  < sizeof(xcoff_howto_table_16)/sizeof(xcoff_howto_table_16[0])))
    relent->howto = xcoff_howto_table_16 + internal->r_type;

d521 1
a521 1
     bfd *abfd ATTRIBUTE_UNUSED;
d593 1
a593 1
   null terminated strings, which are symbol names.
d595 4
a598 17
   AIX 4.3 introduced a new archive format which can handle larger
   files and also 32- and 64-bit objects in the same archive.  The
   things said above remain true except that there is now more than
   one global symbol table.  The one is used to index 32-bit objects,
   the other for 64-bit objects.

   The new archives (recognizable by the new ARMAG string) has larger
   field lengths so that we cannot really share any code.  Also we have
   to take care that we are not generating the new form of archives
   on AIX 4.2 or earlier systems.  */

/* XCOFF archives use this as a magic string.  Note that both strings
   have the same length.  */

#define XCOFFARMAG    "<aiaff>\012"
#define XCOFFARMAGBIG "<bigaf>\012"
#define SXCOFFARMAG   8
a630 32
/* This is the equivalent data structure for the big archive format.  */

struct xcoff_ar_file_hdr_big
{
  /* Magic string.  */
  char magic[SXCOFFARMAG];

  /* Offset of the member table (decimal ASCII string).  */
  char memoff[20];

  /* Offset of the global symbol table for 32-bit objects (decimal ASCII
     string).  */
  char symoff[20];

  /* Offset of the global symbol table for 64-bit objects (decimal ASCII
     string).  */
  char symoff64[20];

  /* Offset of the first member in the archive (decimal ASCII string).  */
  char firstmemoff[20];

  /* Offset of the last member in the archive (decimal ASCII string).  */
  char lastmemoff[20];

  /* Offset of the first member on the free list (decimal ASCII
     string).  */
  char freeoff[20];
};

#define SIZEOF_AR_FILE_HDR_BIG (6 * 20 + SXCOFFARMAG)


a668 45
/* The equivalent for the big archive format.  */

struct xcoff_ar_hdr_big
{
  /* File size not including the header (decimal ASCII string).  */
  char size[20];

  /* File offset of next archive member (decimal ASCII string).  */
  char nextoff[20];

  /* File offset of previous archive member (decimal ASCII string).  */
  char prevoff[20];

  /* File mtime (decimal ASCII string).  */
  char date[12];

  /* File UID (decimal ASCII string).  */
  char uid[12];

  /* File GID (decimal ASCII string).  */
  char gid[12];

  /* File mode (octal ASCII string).  */
  char mode[12];

  /* Length of file name (decimal ASCII string).  */
  char namlen[4];

  /* This structure is followed by the file name.  The length of the
     name is given in the namlen field.  If the length of the name is
     odd, the name is followed by a null byte.  The name and optional
     null byte are followed by XCOFFARFMAG, which is not included in
     namlen.  The contents of the archive member follow; the number of
     bytes is given in the size field.  */
};

#define SIZEOF_AR_HDR_BIG (3 * 20 + 4 * 12 + 4)


/* We often have to distinguish between the old and big file format.
   Make it a bit cleaner.  We can use `xcoff_ardata' here because the
   `hdr' member has the same size and position in both formats.  */
#define xcoff_big_format_p(abfd) \
  (xcoff_ardata (abfd)->magic[1] == 'b')

d670 1
a670 1
   artdata structure.  Similar for the big archive.  */
a672 2
#define xcoff_ardata_big(abfd) \
  ((struct xcoff_ar_file_hdr_big *) bfd_ardata (abfd)->tdata)
d675 1
a675 1
   archive element.  Similar for the big archive.  */
a678 2
#define arch_xhdr_big(bfd) \
  ((struct xcoff_ar_hdr_big *) arch_eltdata (bfd)->arch_header)
d704 1
d718 2
a719 1
  if (! xcoff_big_format_p (abfd))
d721 2
a722 23
      /* This is for the old format.  */
      struct xcoff_ar_hdr hdr;

      off = strtol (xcoff_ardata (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = false;
	  return true;
	}

      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return false;

      /* The symbol table starts with a normal archive header.  */
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
	return false;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
	return false;

      sz = strtol (hdr.size, (char **) NULL, 10);
a723 4
  else
    {
      /* This is for the new format.  */
      struct xcoff_ar_hdr_big hdr;
d725 2
a726 6
      off = strtol (xcoff_ardata_big (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = false;
	  return true;
	}
d728 3
a730 2
      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return false;
d732 4
a735 15
      /* The symbol table starts with a normal archive header.  */
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
	  != SIZEOF_AR_HDR_BIG)
	return false;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
	return false;

      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      sz = strtol (hdr.size, (char **) NULL, 10);
    }
d738 1
d791 1
a791 1
  char magic[SXCOFFARMAG];
d793 2
a794 1
  if (bfd_read ((PTR) magic, SXCOFFARMAG, 1, abfd) != SXCOFFARMAG)
d801 1
a801 2
  if (strncmp (magic, XCOFFARMAG, SXCOFFARMAG) != 0
      && strncmp (magic, XCOFFARMAGBIG, SXCOFFARMAG) != 0)
d816 2
d823 3
a825 53
  /* Now handle the two formats.  */
  if (magic[1] != 'b')
    {
      /* This is the old format.  */
      struct xcoff_ar_file_hdr hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR - SXCOFFARMAG)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);

      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR);
      if (bfd_ardata (abfd)->tdata == NULL)
	return NULL;

      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR);
    }
  else
    {
      /* This is the new format.  */
      struct xcoff_ar_file_hdr_big hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);

      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR_BIG);
      if (bfd_ardata (abfd)->tdata == NULL)
	return NULL;
d827 1
a827 2
      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR_BIG);
    }
d845 1
d847 1
d850 12
d865 3
a867 68

  if (! xcoff_big_format_p (abfd))
    {
      struct xcoff_ar_hdr hdr;
      struct xcoff_ar_hdr *hdrp;

      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd,
						SIZEOF_AR_HDR + namlen + 1);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR, 1, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR;
    }
  else
    {
      struct xcoff_ar_hdr_big hdr;
      struct xcoff_ar_hdr_big *hdrp;

      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
	  != SIZEOF_AR_HDR_BIG)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd,
						    SIZEOF_AR_HDR_BIG
						    + namlen + 1);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR_BIG);
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR_BIG, 1, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR_BIG + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR_BIG;
    }
d891 4
a894 7
  if (! xcoff_big_format_p (archive))
    {
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	filestart = strtol (arch_xhdr (last_file)->nextoff, (char **) NULL,
			    10);
d896 5
a900 11
      if (filestart == 0
	  || filestart == strtol (xcoff_ardata (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }
  else
d902 2
a903 21
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	/* XXX These actually have to be a calls to strtoll (at least
	   on 32-bit machines) since the fields's width is 20 and
	   there numbers with more than 32 bits can be represented.  */
	filestart = strtol (arch_xhdr_big (last_file)->nextoff, (char **) NULL,
			    10);

      /* XXX These actually have to be calls to strtoll (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      if (filestart == 0
	  || filestart == strtol (xcoff_ardata_big (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata_big (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
d916 2
d924 1
a924 13
  if (! xcoff_big_format_p (abfd))
    {
      struct xcoff_ar_hdr *hdrp = arch_xhdr (abfd);

      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }
  else
    {
      struct xcoff_ar_hdr_big *hdrp = arch_xhdr_big (abfd);
d926 5
a930 6
      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }
d957 1
a957 1
xcoff_write_armap_old (abfd, elength, map, orl_count, stridx)
d959 1
a959 1
     unsigned int elength ATTRIBUTE_UNUSED;
d989 1
a989 1

d1041 3
a1043 1
/*ARGSUSED*/
d1045 1
a1045 1
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
a1046 4
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d1048 7
a1054 3
  struct xcoff_ar_hdr_big hdr;
  char *p;
  unsigned char buf[4];
a1055 1
  file_ptr fileoff;
d1057 4
d1062 4
a1065 12
  memset (&hdr, 0, sizeof hdr);
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
  sprintf (hdr.nextoff, "%d", 0);
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, 12);
  sprintf (hdr.date, "%d", 0);
  sprintf (hdr.uid, "%d", 0);
  sprintf (hdr.gid, "%d", 0);
  sprintf (hdr.mode, "%d", 0);
  sprintf (hdr.namlen, "%d", 0);
d1067 9
a1075 7
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &hdr; p < (char *) &hdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_write ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd) != SIZEOF_AR_HDR_BIG
      || bfd_write (XCOFFARFMAG, 1, SXCOFFARFMAG, abfd) != SXCOFFARFMAG)
d1078 1
a1078 2
  bfd_h_put_32 (abfd, orl_count, buf);
  if (bfd_write (buf, 1, 4, abfd) != 4)
d1081 5
a1085 107
  sub = abfd->archive_head;
  fileoff = SIZEOF_AR_FILE_HDR_BIG;
  i = 0;
  while (sub != NULL && i < orl_count)
    {
      size_t namlen;

      while (((bfd *) (map[i]).pos) == sub)
	{
	  bfd_h_put_32 (abfd, fileoff, buf);
	  if (bfd_write (buf, 1, 4, abfd) != 4)
	    return false;
	  ++i;
	}
      namlen = strlen (normalize_filename (sub));
      namlen = (namlen + 1) &~ 1;
      fileoff += (SIZEOF_AR_HDR_BIG
		  + namlen
		  + SXCOFFARFMAG
		  + arelt_size (sub));
      fileoff = (fileoff + 1) &~ 1;
      sub = sub->next;
    }

  for (i = 0; i < orl_count; i++)
    {
      const char *name;
      size_t namlen;

      name = *map[i].name;
      namlen = strlen (name);
      if (bfd_write (name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
    }

  if ((stridx & 1) != 0)
    {
      char b;

      b = '\0';
      if (bfd_write (&b, 1, 1, abfd) != 1)
	return false;
    }

  return true;
}

/*ARGSUSED*/
static boolean
xcoff_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_armap_old (abfd, elength, map, orl_count, stridx);
  else
    return xcoff_write_armap_big (abfd, elength, map, orl_count, stridx);
}

/* Write out an XCOFF archive.  We always write an entire archive,
   rather than fussing with the freelist and so forth.  */

static boolean
xcoff_write_archive_contents_old (abfd)
     bfd *abfd;
{
  struct xcoff_ar_file_hdr fhdr;
  size_t count;
  size_t total_namlen;
  file_ptr *offsets;
  boolean makemap;
  boolean hasobjects;
  file_ptr prevoff, nextoff;
  bfd *sub;
  unsigned int i;
  struct xcoff_ar_hdr ahdr;
  bfd_size_type size;
  char *p;
  char decbuf[13];

  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR);
  sprintf (fhdr.freeoff, "%d", 0);

  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return false;

  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return false;

  makemap = bfd_has_map (abfd);
  hasobjects = false;
  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR;
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
d1126 2
a1127 1
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
a1288 279

static boolean
xcoff_write_archive_contents_big (abfd)
     bfd *abfd;
{
  struct xcoff_ar_file_hdr_big fhdr;
  size_t count;
  size_t total_namlen;
  file_ptr *offsets;
  boolean makemap;
  boolean hasobjects;
  file_ptr prevoff, nextoff;
  bfd *sub;
  unsigned int i;
  struct xcoff_ar_hdr_big ahdr;
  bfd_size_type size;
  char *p;
  char decbuf[13];

  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR_BIG);
  sprintf (fhdr.freeoff, "%d", 0);

  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return false;

  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return false;

  makemap = bfd_has_map (abfd);
  hasobjects = false;
  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR_BIG;
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
    {
      const char *name;
      size_t namlen;
      struct xcoff_ar_hdr_big *ahdrp;
      bfd_size_type remaining;

      if (makemap && ! hasobjects)
	{
	  if (bfd_check_format (sub, bfd_object))
	    hasobjects = true;
	}

      name = normalize_filename (sub);
      namlen = strlen (name);

      if (sub->arelt_data != NULL)
	ahdrp = arch_xhdr_big (sub);
      else
	ahdrp = NULL;

      if (ahdrp == NULL)
	{
	  struct stat s;

	  memset (&ahdr, 0, sizeof ahdr);
	  ahdrp = &ahdr;
	  /* XXX This should actually be a call to stat64 (at least on
	     32-bit machines).  */
	  if (stat (bfd_get_filename (sub), &s) != 0)
	    {
	      bfd_set_error (bfd_error_system_call);
	      return false;
	    }

	  /* XXX This call actually should use %lld (at least on 32-bit
	     machines) since the fields's width is 20 and there numbers with
	     more than 32 bits can be represented.  */
	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);

	  if (sub->arelt_data == NULL)
	    {
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
	      if (sub->arelt_data == NULL)
		return false;
	    }

	  arch_eltdata (sub)->parsed_size = s.st_size;
	}

      /* XXX These calls actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) namlen);

      /* If the length of the name is odd, we write out the null byte
         after the name as well.  */
      namlen = (namlen + 1) &~ 1;

      remaining = arelt_size (sub);
      size = (SIZEOF_AR_HDR_BIG
	      + namlen
	      + SXCOFFARFMAG
	      + remaining);

      BFD_ASSERT (nextoff == bfd_tell (abfd));

      offsets[i] = nextoff;

      prevoff = nextoff;
      nextoff += size + (size & 1);

      sprintf (ahdrp->nextoff, "%ld", (long) nextoff);

      /* We need spaces, not null bytes, in the header.  */
      for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR_BIG; p++)
	if (*p == '\0')
	  *p = ' ';

      if (bfd_write ((PTR) ahdrp, 1, SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG
	  || bfd_write ((PTR) name, 1, namlen, abfd) != namlen
	  || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
	      != SXCOFFARFMAG))
	return false;

      if (bfd_seek (sub, (file_ptr) 0, SEEK_SET) != 0)
	return false;
      while (remaining != 0)
	{
	  bfd_size_type amt;
	  bfd_byte buffer[DEFAULT_BUFFERSIZE];

	  amt = sizeof buffer;
	  if (amt > remaining)
	    amt = remaining;
	  if (bfd_read (buffer, 1, amt, sub) != amt
	      || bfd_write (buffer, 1, amt, abfd) != amt)
	    return false;
	  remaining -= amt;
	}

      if ((size & 1) != 0)
	{
	  bfd_byte b;

	  b = '\0';
	  if (bfd_write (&b, 1, 1, abfd) != 1)
	    return false;
	}
    }

  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);

  /* Write out the member table.  */

  BFD_ASSERT (nextoff == bfd_tell (abfd));
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.memoff, "%ld", (long) nextoff);

  memset (&ahdr, 0, sizeof ahdr);
  /* XXX The next two calls actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (ahdr.size, "%ld", (long) (12 + count * 12 + total_namlen));
  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
  sprintf (ahdr.date, "%d", 0);
  sprintf (ahdr.uid, "%d", 0);
  sprintf (ahdr.gid, "%d", 0);
  sprintf (ahdr.mode, "%d", 0);
  sprintf (ahdr.namlen, "%d", 0);

  size = (SIZEOF_AR_HDR_BIG
	  + 12
	  + count * 12
	  + total_namlen
	  + SXCOFFARFMAG);

  prevoff = nextoff;
  nextoff += size + (size & 1);

  if (makemap && hasobjects)
    /* XXX This call actually should use %lld (at least on 32-bit
       machines) since the fields's width is 20 and there numbers with
       more than 32 bits can be represented.  */
    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
  else
    sprintf (ahdr.nextoff, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &ahdr; p < (char *) &ahdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_write ((PTR) &ahdr, 1, SIZEOF_AR_HDR_BIG, abfd) != SIZEOF_AR_HDR_BIG
      || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return false;

  sprintf (decbuf, "%-12ld", (long) count);
  if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
    return false;
  for (i = 0; i < count; i++)
    {
      sprintf (decbuf, "%-12ld", (long) offsets[i]);
      if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
	return false;
    }
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
    {
      const char *name;
      size_t namlen;

      name = normalize_filename (sub);
      namlen = strlen (name);
      if (bfd_write ((PTR) name, 1, namlen + 1, abfd) != namlen + 1)
	return false;
    }
  if ((size & 1) != 0)
    {
      bfd_byte b;

      b = '\0';
      if (bfd_write ((PTR) &b, 1, 1, abfd) != 1)
	return false;
    }

  /* Write out the armap, if appropriate.  */

  if (! makemap || ! hasobjects)
    sprintf (fhdr.symoff, "%d", 0);
  else
    {
      BFD_ASSERT (nextoff == bfd_tell (abfd));
      /* XXX This call actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
      sprintf (fhdr.symoff, "%ld", (long) nextoff);
      bfd_ardata (abfd)->tdata = (PTR) &fhdr;
      if (! _bfd_compute_and_write_armap (abfd, 0))
	return false;
    }

  /* Write out the archive file header.  */

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &fhdr; p < (char *) &fhdr + SIZEOF_AR_FILE_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || (bfd_write ((PTR) &fhdr, SIZEOF_AR_FILE_HDR_BIG, 1, abfd) !=
	  SIZEOF_AR_FILE_HDR_BIG))
    return false;

  return true;
}

static boolean
xcoff_write_archive_contents (abfd)
     bfd *abfd;
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_archive_contents_old (abfd);
  else
    return xcoff_write_archive_contents_big (abfd);
}
d1297 1
a1297 1
     boolean reloc ATTRIBUTE_UNUSED;
a1363 1
#define _bfd_xcoff_bfd_gc_sections coff_bfd_gc_sections
d1380 1
a1380 1
  bfd_target_coff_flavour,
d1417 1
a1417 3
  NULL,
  
  COFF_SWAP_TABLE
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d8 1
a8 1
   Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,
d29 3
a37 3
#define TARGET_NAME "aixcoff-rs6000"
#define TARGET_SYM rs6000coff_vec
#include "xcoff-target.h"
d41 12
d54 5
a58 1

d62 2
a63 2
boolean
_bfd_xcoff_mkobject (abfd)
d93 2
a94 2
boolean
_bfd_xcoff_copy_private_bfd_data (ibfd, obfd)
d141 2
a142 2
boolean
_bfd_xcoff_is_local_label_name (abfd, name)
a148 272
void
_bfd_xcoff_swap_sym_in (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1;
     PTR in1;
{
  SYMENT *ext = (SYMENT *)ext1;
  struct internal_syment      *in = (struct internal_syment *)in1;

  if (ext->e.e_name[0] != 0)
    {
      memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
    }
  else
    {
      in->_n._n_n._n_zeroes = 0;
      in->_n._n_n._n_offset =
	  bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
    }

  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value);
  in->n_scnum = bfd_h_get_16(abfd, (bfd_byte *) ext->e_scnum);
  in->n_type = bfd_h_get_16(abfd, (bfd_byte *) ext->e_type);
  in->n_sclass = bfd_h_get_8(abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8(abfd, ext->e_numaux);
}

unsigned int
_bfd_xcoff_swap_sym_out (abfd, inp, extp)
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
{
  struct internal_syment *in = (struct internal_syment *)inp;
  SYMENT *ext =(SYMENT *)extp;

  if (in->_n._n_name[0] != 0)
    {
      memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
    }
  else
    {
      bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
      bfd_h_put_32(abfd, in->_n._n_n._n_offset,
	      (bfd_byte *)  ext->e.e.e_offset);
    }

  bfd_h_put_32(abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16(abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  bfd_h_put_16(abfd,  in->n_type , (bfd_byte *) ext->e_type);
  bfd_h_put_8(abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8(abfd,  in->n_numaux , ext->e_numaux);
  return bfd_coff_symesz (abfd);
}

#define PUTWORD bfd_h_put_32
#define PUTHALF bfd_h_put_16
#define PUTBYTE bfd_h_put_8
#define GETWORD bfd_h_get_32
#define GETHALF bfd_h_get_16
#define GETBYTE bfd_h_get_8

void
_bfd_xcoff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
     bfd            *abfd;
     PTR 	      ext1;
     int             type;
     int             class;
     int	      indx;
     int	      numaux;
     PTR 	      in1;
{
  AUXENT    *ext = (AUXENT *)ext1;
  union internal_auxent *in = (union internal_auxent *)in1;

  switch (class) {
    case C_FILE:
      if (ext->x_file.x_fname[0] == 0) {
	  in->x_file.x_n.x_zeroes = 0;
	  in->x_file.x_n.x_offset =
	   bfd_h_get_32(abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
	} else {
	    if (numaux > 1)
	      {
		if (indx == 0)
		  memcpy (in->x_file.x_fname, ext->x_file.x_fname,
			  numaux * sizeof (AUXENT));
	      }
	    else
	      {
		memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	      }
	  }
      goto end;

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  in->x_csect.x_scnlen.l =
	      bfd_h_get_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = bfd_h_get_32 (abfd,
						 ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = bfd_h_get_16 (abfd, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  in->x_csect.x_smtyp    = bfd_h_get_8  (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = bfd_h_get_8  (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = bfd_h_get_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = bfd_h_get_16 (abfd, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL) {
	  in->x_scn.x_scnlen = bfd_h_get_32(abfd,
		  (bfd_byte *) ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = bfd_h_get_16(abfd,
		  (bfd_byte *) ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = bfd_h_get_16(abfd,
		  (bfd_byte *) ext->x_scn.x_nlinno);
	  /* PE defines some extra fields; we zero them out for
             safety.  */
	  in->x_scn.x_checksum = 0;
	  in->x_scn.x_associated = 0;
	  in->x_scn.x_comdat = 0;

	  goto end;
	}
      break;
    }

  in->x_sym.x_tagndx.l = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_tvndx);

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }
  if (ISFCN(type)) {
    in->x_sym.x_misc.x_fsize = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
  }
  else {
    in->x_sym.x_misc.x_lnsz.x_lnno = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_lnno);
    in->x_sym.x_misc.x_lnsz.x_size = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_size);
  }

end: ;
  /* the semicolon is because MSVC doesn't like labels at
     end of block.  */

}

unsigned int
_bfd_xcoff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
     bfd   *abfd;
     PTR 	inp;
     int   type;
     int   class;
     int   indx ATTRIBUTE_UNUSED;
     int   numaux ATTRIBUTE_UNUSED;
     PTR	extp;
{
  union internal_auxent *in = (union internal_auxent *)inp;
  AUXENT *ext = (AUXENT *)extp;

  memset((PTR)ext, 0, bfd_coff_auxesz (abfd));
  switch (class)
    {
  case C_FILE:
    if (in->x_file.x_fname[0] == 0)
      {
      PUTWORD(abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
      PUTWORD(abfd,
	      in->x_file.x_n.x_offset,
	      (bfd_byte *) ext->x_file.x_n.x_offset);
    }
    else
      {
      memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
      }
    goto end;

  /* RS/6000 "csect" auxents */
  case C_EXT:
  case C_HIDEXT:
    if (indx + 1 == numaux)
      {
	PUTWORD (abfd, in->x_csect.x_scnlen.l,ext->x_csect.x_scnlen);
	PUTWORD (abfd, in->x_csect.x_parmhash,	ext->x_csect.x_parmhash);
	PUTHALF (abfd, in->x_csect.x_snhash,	ext->x_csect.x_snhash);
	/* We don't have to hack bitfields in x_smtyp because it's
	   defined by shifts-and-ands, which are equivalent on all
	   byte orders.  */
	PUTBYTE (abfd, in->x_csect.x_smtyp,	ext->x_csect.x_smtyp);
	PUTBYTE (abfd, in->x_csect.x_smclas,	ext->x_csect.x_smclas);
	PUTWORD (abfd, in->x_csect.x_stab,	ext->x_csect.x_stab);
	PUTHALF (abfd, in->x_csect.x_snstab,	ext->x_csect.x_snstab);
	goto end;
      }
    break;

  case C_STAT:
  case C_LEAFSTAT:
  case C_HIDDEN:
    if (type == T_NULL) {
      bfd_h_put_32(abfd, in->x_scn.x_scnlen, (bfd_byte *) ext->x_scn.x_scnlen);
      bfd_h_put_16(abfd, in->x_scn.x_nreloc, (bfd_byte *) ext->x_scn.x_nreloc);
      bfd_h_put_16(abfd, in->x_scn.x_nlinno, (bfd_byte *) ext->x_scn.x_nlinno);
      goto end;
    }
    break;
  }

  PUTWORD(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
  bfd_h_put_16 (abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      bfd_h_put_32(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      PUTWORD(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l,
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    PUTWORD (abfd, in->x_sym.x_misc.x_fsize,
	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
  else
    {
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno);
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_size,
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_size);
    }

end:
  return bfd_coff_auxesz (abfd);
}

d155 1
a155 5
/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE       (((bfd_vma)0) - 1)

reloc_howto_type xcoff_howto_table[] =
d158 12
a169 12
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d173 12
a184 12
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_NEG",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d188 6
a193 6
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d195 5
a199 5
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d201 1
a201 1

d203 12
a214 12
  HOWTO (3,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TOC",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d216 1
a216 1

d218 12
a229 12
  HOWTO (4,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RTB",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d231 1
a231 1

d233 12
a244 12
  HOWTO (5,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_GL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d246 1
a246 1

d248 12
a259 12
  HOWTO (6,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TCL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d261 1
a261 1

d263 1
a263 1

d265 12
a276 12
  HOWTO (8,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_BA",                /* name */
	 true,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
d278 1
a278 1

d282 6
a287 6
  HOWTO (0xa,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d289 5
a293 5
	 0,		        /* special_function */
	 "R_BR",                /* name */
	 true,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
d295 1
a295 1

d299 12
a310 12
  HOWTO (0xc,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d312 1
a312 1

d314 12
a325 12
  HOWTO (0xd,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RLA",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d327 1
a327 1

d329 1
a329 1

d331 12
a342 12
  HOWTO (0xf,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REF",               /* name */
	 false,	                /* partial_inplace */
	 0,		        /* src_mask */
	 0,     	   	/* dst_mask */
d344 1
a344 1

d347 1
a347 1

d349 12
a360 12
  HOWTO (0x12,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TRL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d362 1
a362 1

d364 12
a375 12
  HOWTO (0x13,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_TRLA",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d377 1
a377 1

d379 12
a390 12
  HOWTO (0x14,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RRTBI",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d392 1
a392 1

d394 12
a405 12
  HOWTO (0x15,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RRTBA",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d407 1
a407 1

d409 12
a420 12
  HOWTO (0x16,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_CAI",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d422 1
a422 1

d424 12
a435 12
  HOWTO (0x17,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_CREL",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d437 1
a437 1

d439 12
a450 12
  HOWTO (0x18,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBA",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d452 1
a452 1

d454 12
a465 12
  HOWTO (0x19,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBAC",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d467 1
a467 1

d469 6
a474 6
  HOWTO (0x1a,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d476 5
a480 5
	 0,		        /* special_function */
	 "R_RBR",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d482 1
a482 1

d484 12
a495 25
  HOWTO (0x1b,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBRC",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
  HOWTO (0,                     /* type */
         0,                     /* rightshift */
         4,                     /* size (0 = byte, 1 = short, 2 = long) */
         64,                    /* bitsize */
         false,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield, /* complain_on_overflow */
         0,                     /* special_function */
         "R_POS",               /* name */
         true,                  /* partial_inplace */
         MINUS_ONE,             /* src_mask */
	 MINUS_ONE,             /* dst_mask */
a496 1

d503 12
a514 12
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d518 12
a529 12
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_NEG_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d533 6
a538 6
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d540 10
a549 10
	 0,		        /* special_function */
	 "R_REL_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false)                /* pcrel_offset */
  };

void
_bfd_xcoff_rtype2howto (relent, internal)
d556 2
a557 2
      && (internal->r_type
	  < sizeof (xcoff_howto_table_16)/sizeof (xcoff_howto_table_16[0])))
d563 2
a564 5
     type matches this information.  The bitsize is not significant
     for R_REF relocs.  */
  if (relent->howto->dst_mask != 0
      && (relent->howto->bitsize
	  != ((unsigned int) internal->r_size & 0x3f) + 1))
d574 2
a575 2
reloc_howto_type *
_bfd_xcoff_reloc_type_lookup (abfd, code)
a589 2
    case BFD_RELOC_64:
      return &xcoff_howto_table[0x1c];
d594 24
d730 1
d807 1
d829 17
d848 2
a849 2
boolean
_bfd_xcoff_slurp_armap (abfd)
d856 1
a856 1
  bfd_vma c, i;
a890 27

      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return false;
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
	return false;

      /* The symbol table starts with a four byte count.  */
      c = bfd_h_get_32 (abfd, contents);

      if (c * 4 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return false;

      /* After the count comes a list of four byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;
	   i < c;
	   ++i, ++arsym, p += 4)
	arsym->file_offset = bfd_h_get_32 (abfd, p);
d921 1
d923 6
a928 6
      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return false;
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
	return false;
d930 2
a931 2
      /* The symbol table starts with an eight byte count.  */
      c = bfd_h_get_64 (abfd, contents);
d933 5
a937 5
      if (c * 8 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
d939 4
a942 4
      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return false;
d944 5
a948 6
      /* After the count comes a list of eight byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;
	   i < c;
	   ++i, ++arsym, p += 8)
	arsym->file_offset = bfd_h_get_64 (abfd, p);
    }
d972 2
a973 2
const bfd_target *
_bfd_xcoff_archive_p (abfd)
d1063 1
a1063 1
  if (! _bfd_xcoff_slurp_armap (abfd))
d1075 2
a1076 2
PTR
_bfd_xcoff_read_ar_hdr (abfd)
d1163 2
a1164 2
bfd *
_bfd_xcoff_openr_next_archived_file (archive, last_file)
d1224 2
a1225 2
int
_bfd_xcoff_generic_stat_arch_elt (abfd, s)
d1279 1
d1365 1
a1365 1
/* Write a single armap in the big format.  */
d1367 1
a1367 2
xcoff_write_one_armap_big (abfd, map, orl_count, orl_ccount, stridx, bits64,
			   prevoff, nextoff)
d1369 1
d1372 1
a1372 5
     unsigned int orl_ccount;
     unsigned int stridx;
     int bits64;
     const char *prevoff;
     char *nextoff;
a1376 1
  const bfd_arch_info_type *arch_info = NULL;
a1378 1
  bfd *object_bfd;
d1385 3
a1387 7
  sprintf (hdr.size, "%ld", (long) (4 + orl_ccount * 4 + stridx));
  if (bits64)
    sprintf (hdr.nextoff, "%d", 0);
  else
    sprintf (hdr.nextoff, "%ld", (strtol (prevoff, (char **) NULL, 10)
				 + 4 + orl_ccount * 4 + stridx));
  memcpy (hdr.prevoff, prevoff, sizeof (hdr.prevoff));
a1398 2
  memcpy (nextoff, hdr.nextoff, sizeof (hdr.nextoff));

d1403 1
a1403 1
  bfd_h_put_32 (abfd, orl_ccount, buf);
d1414 7
a1420 12
      if ((bfd_arch_bits_per_address ((bfd *) map[i].pos) == 64) == bits64)
	while (((bfd *) (map[i]).pos) == sub)
	  {
	    bfd_h_put_32 (abfd, fileoff, buf);
	    if (bfd_write (buf, 1, 4, abfd) != 4)
	      return false;
	    i++;
	  }
      else
	while (((bfd *) (map[i]).pos) == sub)
	  i++;

a1430 1
  object_bfd = NULL;
a1434 7
      bfd *ob = (bfd *)map[i].pos;

      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);

      if (arch_info && (arch_info->bits_per_address == 64) != bits64)
	continue;
d1454 1
d1456 1
a1456 60
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  unsigned int i;
  unsigned int orl_count_32, orl_count_64;
  unsigned int stridx_32, stridx_64;
  const bfd_arch_info_type *arch_info = NULL;
  bfd *object_bfd;

  /* First, we look through the symbols and work out which are
     from 32-bit objects and which from 64-bit ones.  */
  orl_count_32 = 0;
  orl_count_64 = 0;
  stridx_32 = 0;
  stridx_64 = 0;
  object_bfd = NULL;
  for (i = 0; i < orl_count; i++)
    {
      bfd *ob = (bfd *)map[i].pos;
      unsigned int len;
      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);
      len = strlen (*map[i].name) + 1;
      if (arch_info && arch_info->bits_per_address == 64)
	{
	  orl_count_64++;
	  stridx_64 += len;
	}
      else
	{
	  orl_count_32++;
	  stridx_32 += len;
	}
      object_bfd = ob;
    }
  /* A quick sanity check...  */
  BFD_ASSERT (orl_count_64 + orl_count_32 == orl_count);
  BFD_ASSERT (stridx_64 + stridx_32 == stridx);

  /* Now write out each map.  */
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_32,
				   stridx_32, false,
				   xcoff_ardata_big (abfd)->memoff,
				   xcoff_ardata_big (abfd)->symoff))
    return false;
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_64,
				   stridx_64, true,
				   xcoff_ardata_big (abfd)->symoff,
				   xcoff_ardata_big (abfd)->symoff64))
    return false;

  return true;
}

boolean
_bfd_xcoff_write_armap (abfd, elength, map, orl_count, stridx)
d1965 1
d1986 2
a1987 2
boolean
_bfd_xcoff_write_archive_contents (abfd)
d1999 2
a2000 1
int
d2015 113
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 1
   Copyright 1990-1999, 2000, 2001, 2002
a31 1
#include "bfdlink.h"
a33 1
#include "coff/xcoff.h"
d36 3
a38 98
#include "libxcoff.h"

extern bfd_boolean _bfd_xcoff_mkobject
  PARAMS ((bfd *));
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_xcoff_is_local_label_name
  PARAMS ((bfd *, const char *));
extern reloc_howto_type *_bfd_xcoff_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
extern bfd_boolean _bfd_xcoff_slurp_armap
  PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p
  PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr
  PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
extern bfd_boolean _bfd_xcoff_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
extern bfd_boolean _bfd_xcoff_write_archive_contents
  PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
extern void _bfd_xcoff_swap_sym_in
  PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out
  PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
extern unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in
  PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out
  PARAMS ((bfd *, PTR, PTR));

/* Forward declare xcoff_rtype2howto for coffcode.h macro.  */
void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));

/* coffcode.h needs these to be defined.  */
#define RS6000COFF_C 1

#define SELECT_RELOC(internal, howto)					\
  {									\
    internal.r_type = howto->type;					\
    internal.r_size =							\
      ((howto->complain_on_overflow == complain_overflow_signed		\
	? 0x80								\
	: 0)								\
       | (howto->bitsize - 1));						\
  }

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)
#define COFF_LONG_FILENAMES
#define NO_COFF_SYMBOLS
#define RTYPE2HOWTO(cache_ptr, dst) xcoff_rtype2howto (cache_ptr, dst)
#define coff_mkobject _bfd_xcoff_mkobject
#define coff_bfd_copy_private_bfd_data _bfd_xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup _bfd_xcoff_reloc_type_lookup
#ifdef AIX_CORE
extern const bfd_target * rs6000coff_core_p
  PARAMS ((bfd *abfd));
extern bfd_boolean rs6000coff_core_file_matches_executable_p
  PARAMS ((bfd *cbfd, bfd *ebfd));
extern char *rs6000coff_core_file_failing_command
  PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal
  PARAMS ((bfd *abfd));
#define CORE_FILE_P rs6000coff_core_p
#define coff_core_file_failing_command \
  rs6000coff_core_file_failing_command
#define coff_core_file_failing_signal \
  rs6000coff_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  rs6000coff_core_file_matches_executable_p
#else
#define CORE_FILE_P _bfd_dummy_target
#define coff_core_file_failing_command \
  _bfd_nocore_core_file_failing_command
#define coff_core_file_failing_signal \
  _bfd_nocore_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  _bfd_nocore_core_file_matches_executable_p
#endif
#define coff_SWAP_sym_in _bfd_xcoff_swap_sym_in
#define coff_SWAP_sym_out _bfd_xcoff_swap_sym_out
#define coff_SWAP_aux_in _bfd_xcoff_swap_aux_in
#define coff_SWAP_aux_out _bfd_xcoff_swap_aux_out
#define coff_swap_reloc_in xcoff_swap_reloc_in
#define coff_swap_reloc_out xcoff_swap_reloc_out
#define NO_COFF_RELOCS

#include "coffcode.h"
d42 1
a42 101
static const char *normalize_filename
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_armap_old
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static bfd_boolean xcoff_write_armap_big
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static bfd_boolean xcoff_write_archive_contents_old
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_archive_contents_big
  PARAMS ((bfd *));
static void xcoff_swap_ldhdr_in
  PARAMS ((bfd *, const PTR, struct internal_ldhdr *));
static void xcoff_swap_ldhdr_out
  PARAMS ((bfd *, const struct internal_ldhdr *, PTR));
static void xcoff_swap_ldsym_in
  PARAMS ((bfd *, const PTR, struct internal_ldsym *));
static void xcoff_swap_ldsym_out
  PARAMS ((bfd *, const struct internal_ldsym *, PTR));
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const PTR, struct internal_ldrel *));
static void xcoff_swap_ldrel_out
  PARAMS ((bfd *, const struct internal_ldrel *, PTR));
static bfd_boolean xcoff_ppc_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean _bfd_xcoff_put_ldsymbol_name
  PARAMS ((bfd *, struct xcoff_loader_info *, struct internal_ldsym *,
	   const char *));
static asection *xcoff_create_csect_from_smclas
  PARAMS ((bfd *, union internal_auxent *, const char *));
static bfd_boolean xcoff_is_lineno_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean xcoff_is_reloc_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_vma xcoff_loader_symbol_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
static bfd_vma xcoff_loader_reloc_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
static bfd_boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
static bfd_boolean do_pad
  PARAMS ((bfd *, unsigned int));
static bfd_boolean do_copy
  PARAMS ((bfd *, bfd *));
static bfd_boolean do_shared_object_padding
  PARAMS ((bfd *, bfd *, ufile_ptr *, int));

/* Relocation functions */
static bfd_boolean xcoff_reloc_type_br
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));

static bfd_boolean xcoff_complain_overflow_dont_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_bitfield_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_signed_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
static bfd_boolean xcoff_complain_overflow_unsigned_func
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));

bfd_boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS)) =
{
  xcoff_reloc_type_pos,	 /* R_POS   (0x00) */
  xcoff_reloc_type_neg,	 /* R_NEG   (0x01) */
  xcoff_reloc_type_rel,	 /* R_REL   (0x02) */
  xcoff_reloc_type_toc,	 /* R_TOC   (0x03) */
  xcoff_reloc_type_fail, /* R_RTB   (0x04) */
  xcoff_reloc_type_toc,	 /* R_GL    (0x05) */
  xcoff_reloc_type_toc,	 /* R_TCL   (0x06) */
  xcoff_reloc_type_fail, /*	    (0x07) */
  xcoff_reloc_type_ba,	 /* R_BA    (0x08) */
  xcoff_reloc_type_fail, /*	    (0x09) */
  xcoff_reloc_type_br,	 /* R_BR    (0x0a) */
  xcoff_reloc_type_fail, /*	    (0x0b) */
  xcoff_reloc_type_pos,	 /* R_RL    (0x0c) */
  xcoff_reloc_type_pos,	 /* R_RLA   (0x0d) */
  xcoff_reloc_type_fail, /*	    (0x0e) */
  xcoff_reloc_type_noop, /* R_REF   (0x0f) */
  xcoff_reloc_type_fail, /*	    (0x10) */
  xcoff_reloc_type_fail, /*	    (0x11) */
  xcoff_reloc_type_toc,	 /* R_TRL   (0x12) */
  xcoff_reloc_type_toc,	 /* R_TRLA  (0x13) */
  xcoff_reloc_type_fail, /* R_RRTBI (0x14) */
  xcoff_reloc_type_fail, /* R_RRTBA (0x15) */
  xcoff_reloc_type_ba,	 /* R_CAI   (0x16) */
  xcoff_reloc_type_crel, /* R_CREL  (0x17) */
  xcoff_reloc_type_ba,	 /* R_RBA   (0x18) */
  xcoff_reloc_type_ba,	 /* R_RBAC  (0x19) */
  xcoff_reloc_type_br,	 /* R_RBR   (0x1a) */
  xcoff_reloc_type_ba,	 /* R_RBRC  (0x1b) */
};

bfd_boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS)) =
{
  xcoff_complain_overflow_dont_func,
  xcoff_complain_overflow_bitfield_func,
  xcoff_complain_overflow_signed_func,
  xcoff_complain_overflow_unsigned_func,
};
d47 1
a47 1
bfd_boolean
a51 1
  bfd_size_type amt = sizeof (struct xcoff_tdata);
d53 3
a55 1
  abfd->tdata.xcoff_obj_data = (struct xcoff_tdata *) bfd_zalloc (abfd, amt);
d57 1
a57 1
    return FALSE;
d73 1
a73 4
  /* text section alignment is different than the default */
  bfd_xcoff_text_align_power (abfd) = 2;

  return TRUE;
d78 1
a78 1
bfd_boolean
d87 1
a87 1
    return TRUE;
d112 2
a113 2
  bfd_xcoff_text_align_power (obfd) = bfd_xcoff_text_align_power (ibfd);
  bfd_xcoff_data_align_power (obfd) = bfd_xcoff_data_align_power (ibfd);
d118 1
a118 1
  return TRUE;
d126 1
a126 1
bfd_boolean
d131 1
a131 1
  return FALSE;
d136 1
a136 1
     bfd *abfd;
d141 1
a141 1
  struct internal_syment * in = (struct internal_syment *)in1;
d145 1
a145 1
      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
d150 2
a151 1
      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
d154 5
a158 5
  in->n_value = H_GET_32 (abfd, ext->e_value);
  in->n_scnum = H_GET_16 (abfd, ext->e_scnum);
  in->n_type = H_GET_16 (abfd, ext->e_type);
  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);
d163 3
a165 3
     bfd *abfd;
     PTR inp;
     PTR extp;
d172 1
a172 1
      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
d176 3
a178 2
      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
d181 5
a185 5
  H_PUT_32 (abfd, in->n_value, ext->e_value);
  H_PUT_16 (abfd, in->n_scnum, ext->e_scnum);
  H_PUT_16 (abfd, in->n_type, ext->e_type);
  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);
d189 7
d198 7
a204 7
     bfd *abfd;
     PTR ext1;
     int type;
     int class;
     int indx;
     int numaux;
     PTR in1;
d206 1
a206 1
  AUXENT * ext = (AUXENT *)ext1;
d209 1
a209 2
  switch (class)
    {
d211 1
a211 2
      if (ext->x_file.x_fname[0] == 0)
	{
d214 13
a226 15
	    H_GET_32 (abfd, ext->x_file.x_n.x_offset);
	}
      else
	{
	  if (numaux > 1)
	    {
	      if (indx == 0)
		memcpy (in->x_file.x_fname, ext->x_file.x_fname,
			numaux * sizeof (AUXENT));
	    }
	  else
	    {
	      memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	    }
	}
d234 5
a238 3
	  in->x_csect.x_scnlen.l = H_GET_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = H_GET_32 (abfd, ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = H_GET_16 (abfd, ext->x_csect.x_snhash);
d242 4
a245 4
	  in->x_csect.x_smtyp    = H_GET_8 (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = H_GET_8 (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = H_GET_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = H_GET_16 (abfd, ext->x_csect.x_snstab);
d253 7
a259 5
      if (type == T_NULL)
	{
	  in->x_scn.x_scnlen = H_GET_32 (abfd, ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = H_GET_16 (abfd, ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = H_GET_16 (abfd, ext->x_scn.x_nlinno);
d261 1
a261 1
	     safety.  */
d271 2
a272 2
  in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = H_GET_16 (abfd, ext->x_sym.x_tvndx);
d276 4
a279 4
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_endndx);
d284 1
a284 1
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
d286 1
a286 1
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
d288 1
a288 1
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
d290 1
a290 1
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d292 9
d302 3
a304 11
  if (ISFCN (type))
    {
      in->x_sym.x_misc.x_fsize = H_GET_32 (abfd, ext->x_sym.x_misc.x_fsize);
    }
  else
    {
      in->x_sym.x_misc.x_lnsz.x_lnno =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_lnno);
      in->x_sym.x_misc.x_lnsz.x_size =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_size);
    }
a305 3
 end: ;
  /* The semicolon is because MSVC doesn't like labels at
     end of block.  */
a307 4

unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));

d310 2
a311 2
     bfd * abfd;
     PTR   inp;
d316 1
a316 1
     PTR   extp;
d321 1
a321 1
  memset ((PTR)ext, 0, bfd_coff_auxesz (abfd));
d324 40
a363 10
    case C_FILE:
      if (in->x_file.x_fname[0] == 0)
	{
	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_zeroes);
	  H_PUT_32 (abfd, in->x_file.x_n.x_offset, ext->x_file.x_n.x_offset);
	}
      else
	{
	  memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
	}
a364 31

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  H_PUT_32 (abfd, in->x_csect.x_scnlen.l, ext->x_csect.x_scnlen);
	  H_PUT_32 (abfd, in->x_csect.x_parmhash, ext->x_csect.x_parmhash);
	  H_PUT_16 (abfd, in->x_csect.x_snhash, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  H_PUT_8 (abfd, in->x_csect.x_smtyp, ext->x_csect.x_smtyp);
	  H_PUT_8 (abfd, in->x_csect.x_smclas, ext->x_csect.x_smclas);
	  H_PUT_32 (abfd, in->x_csect.x_stab, ext->x_csect.x_stab);
	  H_PUT_16 (abfd, in->x_csect.x_snstab, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  H_PUT_32 (abfd, in->x_scn.x_scnlen, ext->x_scn.x_scnlen);
	  H_PUT_16 (abfd, in->x_scn.x_nreloc, ext->x_scn.x_nreloc);
	  H_PUT_16 (abfd, in->x_scn.x_nlinno, ext->x_scn.x_nlinno);
	  goto end;
	}
      break;
d366 2
d369 2
a370 2
  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
  H_PUT_16 (abfd, in->x_sym.x_tvndx, ext->x_sym.x_tvndx);
d374 4
a377 4
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
		ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_endndx.l,
		ext->x_sym.x_fcnary.x_fcn.x_endndx);
d381 8
a388 8
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d392 2
a393 1
    H_PUT_32 (abfd, in->x_sym.x_misc.x_fsize, ext->x_sym.x_misc.x_fsize);
d396 4
a399 4
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
		ext->x_sym.x_misc.x_lnsz.x_lnno);
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_size,
		ext->x_sym.x_misc.x_lnsz.x_size);
a404 2


d412 3
d419 6
a424 6
  HOWTO (R_POS,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d426 6
a431 6
	 0,			/* special_function */
	 "R_POS",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d434 6
a439 6
  HOWTO (R_NEG,			/* type */
	 0,			/* rightshift */
	 -2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d441 6
a446 6
	 0,			/* special_function */
	 "R_NEG",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d449 6
a454 6
  HOWTO (R_REL,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
d456 6
a461 6
	 0,			/* special_function */
	 "R_REL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d464 6
a469 6
  HOWTO (R_TOC,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d471 6
a476 6
	 0,			/* special_function */
	 "R_TOC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d479 6
a484 6
  HOWTO (R_RTB,			/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d486 6
a491 6
	 0,			/* special_function */
	 "R_RTB",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d494 6
a499 6
  HOWTO (R_GL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d501 14
a514 14
	 0,			/* special_function */
	 "R_GL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Local TOC relative symbol.	 */
  HOWTO (R_TCL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d516 6
a521 6
	 0,			/* special_function */
	 "R_TCL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d526 6
a531 6
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d533 6
a538 6
	 0,			/* special_function */
	 "R_BA_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d543 6
a548 6
  HOWTO (R_BR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
d550 6
a555 6
	 0,			/* special_function */
	 "R_BR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d560 6
a565 6
  HOWTO (R_RL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d567 6
a572 6
	 0,			/* special_function */
	 "R_RL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d575 6
a580 6
  HOWTO (R_RLA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d582 6
a587 6
	 0,			/* special_function */
	 "R_RLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d592 13
a604 13
  HOWTO (R_REF,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REF",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d610 6
a615 6
  HOWTO (R_TRL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d617 6
a622 6
	 0,			/* special_function */
	 "R_TRL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d625 6
a630 6
  HOWTO (R_TRLA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d632 6
a637 6
	 0,			/* special_function */
	 "R_TRLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d640 6
a645 6
  HOWTO (R_RRTBI,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d647 6
a652 6
	 0,			/* special_function */
	 "R_RRTBI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d655 6
a660 6
  HOWTO (R_RRTBA,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d662 6
a667 6
	 0,			/* special_function */
	 "R_RRTBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d670 6
a675 6
  HOWTO (R_CAI,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d677 6
a682 6
	 0,			/* special_function */
	 "R_CAI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d685 6
a690 6
  HOWTO (R_CREL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d692 6
a697 6
	 0,			/* special_function */
	 "R_CREL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d700 6
a705 6
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d707 6
a712 6
	 0,			/* special_function */
	 "R_RBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d715 6
a720 6
  HOWTO (R_RBAC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d722 6
a727 6
	 0,			/* special_function */
	 "R_RBAC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d730 6
a735 6
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d737 6
a742 6
	 0,			/* special_function */
	 "R_RBR_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d745 6
a750 6
  HOWTO (R_RBRC,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d752 19
a770 21
	 0,			/* special_function */
	 "R_RBRC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit Non modifiable absolute branch.  */
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d772 1
a772 14
  /* Modifiable branch relative.  */
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBR_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d774 40
a813 7
  /* Modifiable branch relative.  */
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d815 7
a821 8
	 0,			/* special_function */
	 "R_RBA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

};
d824 1
a824 1
xcoff_rtype2howto (relent, internal)
d828 1
a828 2
  if (internal->r_type > R_RBRC)
    abort ();
d830 4
a833 13
  /* Default howto layout works most of the time */
  relent->howto = &xcoff_howto_table[internal->r_type];

  /* Special case some 16 bit reoloc */
  if (15 == (internal->r_size & 0x1f))
    {
      if (R_BA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1c];
      else if (R_RBR == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1d];
      else if (R_RBA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1e];
    }
d842 6
a847 1
	  != ((unsigned int) internal->r_size & 0x1f) + 1))
d849 1
a860 2
    case BFD_RELOC_PPC_BA16:
      return &xcoff_howto_table[0x1c];
d868 2
a873 1

d920 63
a982 1
/* Set the magic for archive.  */
d984 43
a1026 4
bfd_boolean
bfd_xcoff_ar_archive_set_magic (abfd, magic)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *magic ATTRIBUTE_UNUSED;
d1028 54
a1081 4
  /* Not supported yet.  */
  return FALSE;
 /* bfd_xcoff_archive_set_magic (abfd, magic); */
}
d1085 1
a1085 1
bfd_boolean
d1099 2
a1100 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d1111 2
a1112 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1116 1
a1116 1
	return FALSE;
d1119 2
a1120 3
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
	return FALSE;
d1124 2
a1125 3
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;
d1132 3
a1134 3
	return FALSE;
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
	return FALSE;
d1137 1
a1137 1
      c = H_GET_32 (abfd, contents);
d1142 1
a1142 1
	  return FALSE;
d1145 2
a1146 2
      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
d1148 1
a1148 1
	return FALSE;
d1154 1
a1154 1
	arsym->file_offset = H_GET_32 (abfd, p);
d1164 2
a1165 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1169 1
a1169 1
	return FALSE;
d1172 1
a1172 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
d1174 1
a1174 1
	return FALSE;
d1178 2
a1179 3
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;
d1189 3
a1191 3
	return FALSE;
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
	return FALSE;
d1194 1
a1194 1
      c = H_GET_64 (abfd, contents);
d1199 1
a1199 1
	  return FALSE;
d1202 2
a1203 2
      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
d1205 1
a1205 1
	return FALSE;
d1211 1
a1211 1
	arsym->file_offset = H_GET_64 (abfd, p);
d1223 1
a1223 1
	  return FALSE;
d1229 1
a1229 1
  bfd_has_map (abfd) = TRUE;
d1231 1
a1231 1
  return TRUE;
a1239 1
  struct artdata *tdata_hold;
a1240 1
  bfd_size_type amt = SXCOFFARMAG;
d1242 1
a1242 1
  if (bfd_bread ((PTR) magic, amt, abfd) != amt)
d1256 5
a1260 1
  tdata_hold = bfd_ardata (abfd);
a1261 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d1263 1
a1263 1
    goto error_ret_restore;
d1280 2
a1281 2
      amt = SIZEOF_AR_FILE_HDR - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1285 1
a1285 1
	  goto error_ret;
d1291 1
a1291 2
      amt = SIZEOF_AR_FILE_HDR;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
d1293 1
a1293 1
	goto error_ret;
d1306 2
a1307 2
      amt = SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1311 1
a1311 1
	  goto error_ret;
d1314 5
a1318 3
      bfd_ardata (abfd)->first_file_filepos = bfd_scan_vma (hdr.firstmemoff,
							    (const char **) 0,
							    10);
d1320 1
a1320 2
      amt = SIZEOF_AR_FILE_HDR_BIG;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
d1322 1
a1322 1
	goto error_ret;
a1328 1
    error_ret:
d1330 1
a1330 2
    error_ret_restore:
      bfd_ardata (abfd) = tdata_hold;
d1343 1
a1343 1
  bfd_size_type namlen;
a1344 1
  bfd_size_type amt = sizeof (struct areltdata);
d1346 1
a1346 1
  ret = (struct areltdata *) bfd_alloc (abfd, amt);
d1355 1
a1355 2
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
d1362 2
a1363 2
      amt = SIZEOF_AR_HDR + namlen + 1;
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd, amt);
d1370 1
a1370 1
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR, namlen, abfd) != namlen)
d1386 1
a1386 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
d1394 3
a1396 2
      amt = SIZEOF_AR_HDR_BIG + namlen + 1;
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd, amt);
d1403 1
a1403 1
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR_BIG, namlen, abfd) != namlen)
d1419 1
a1419 1
  if (bfd_seek (abfd, (file_ptr) ((namlen & 1) + SXCOFFARFMAG), SEEK_CUR) != 0)
d1489 1
a1489 1
_bfd_xcoff_stat_arch_elt (abfd, s)
d1499 1
a1499 1
  if (! xcoff_big_format_p (abfd->my_archive))
d1543 1
a1543 2
/*ARGSUSED*/
static bfd_boolean
d1561 1
a1561 1
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, XCOFFARMAG_ELEMENT_SIZE);
d1573 7
a1579 9
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
      != SIZEOF_AR_HDR
      || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return FALSE;

  H_PUT_32 (abfd, orl_count, buf);
  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
    return FALSE;
d1588 1
a1588 1
      while (map[i].u.abfd == sub)
d1590 3
a1592 3
	  H_PUT_32 (abfd, fileoff, buf);
	  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	    return FALSE;
d1596 1
a1596 1
      namlen = (namlen + 1) &~ (size_t) 1;
d1612 2
a1613 2
      if (bfd_bwrite (name, (bfd_size_type) (namlen + 1), abfd) != namlen + 1)
	return FALSE;
d1621 2
a1622 2
      if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return FALSE;
d1625 1
a1625 1
  return TRUE;
d1628 4
a1631 28
static char buff20[XCOFFARMAGBIG_ELEMENT_SIZE + 1];
#define FMT20  "%-20lld"
#define FMT12  "%-12d"
#define FMT12_OCTAL  "%-12o"
#define FMT4  "%-4d"
#define PRINT20(d, v) \
  sprintf (buff20, FMT20, (long long)(v)), \
  memcpy ((void *) (d), buff20, 20)

#define PRINT12(d, v) \
  sprintf (buff20, FMT12, (int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT12_OCTAL(d, v) \
  sprintf (buff20, FMT12_OCTAL, (unsigned int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT4(d, v) \
  sprintf (buff20, FMT4, (int)(v)), \
  memcpy ((void *) (d), buff20, 4)

#define READ20(d, v) \
  buff20[20] = 0, \
  memcpy (buff20, (d), 20), \
  (v) = bfd_scan_vma (buff20, (const char **) NULL, 10)

static bfd_boolean
do_pad (abfd, number)
d1633 7
a1639 1
     unsigned int number;
d1641 8
a1648 1
  bfd_byte b = 0;
d1650 16
a1665 3
  /* Limit pad to <= 4096.  */
  if (number > 4096)
    return FALSE;
d1667 4
a1670 3
  while (number--)
    if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
      return FALSE;
d1672 1
a1672 2
  return TRUE;
}
d1674 7
a1680 7
static bfd_boolean
do_copy (out_bfd, in_bfd)
     bfd *out_bfd;
     bfd *in_bfd;
{
  bfd_size_type remaining;
  bfd_byte buffer[DEFAULT_BUFFERSIZE];
d1682 6
a1687 2
  if (bfd_seek (in_bfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
d1689 11
a1699 1
  remaining = arelt_size (in_bfd);
d1701 8
a1708 7
  while (remaining >= DEFAULT_BUFFERSIZE)
    {
      if (bfd_bread (buffer, DEFAULT_BUFFERSIZE, in_bfd) != DEFAULT_BUFFERSIZE
	  || bfd_bwrite (buffer, DEFAULT_BUFFERSIZE, out_bfd) != DEFAULT_BUFFERSIZE)
	return FALSE;

      remaining -= DEFAULT_BUFFERSIZE;
d1711 2
a1712 1
  if (remaining)
d1714 3
a1716 7
      if (bfd_bread (buffer, remaining, in_bfd) != remaining
	  || bfd_bwrite (buffer, remaining, out_bfd) != remaining)
	return FALSE;
    }

  return TRUE;
}
d1718 2
a1719 13
static bfd_boolean
do_shared_object_padding (out_bfd, in_bfd, offset, ar_header_size)
     bfd *out_bfd;
     bfd *in_bfd;
     ufile_ptr *offset;
     int ar_header_size;
{
  if (bfd_check_format (in_bfd, bfd_object)
      && bfd_get_flavour (in_bfd) == bfd_target_xcoff_flavour
      && (in_bfd->flags & DYNAMIC) != 0)
    {
      bfd_size_type pad = 0;
      int text_align_power;
d1721 2
a1722 1
      text_align_power = bfd_xcoff_text_align_power (in_bfd);
d1724 5
a1728 2
      pad = 1 << text_align_power;
      pad -= (*offset + ar_header_size) & (pad - 1);
d1730 3
a1732 2
      if (! do_pad (out_bfd, pad))
	return FALSE;
d1734 3
a1736 1
      *offset += pad;
d1739 1
a1739 1
  return TRUE;
d1742 1
a1742 1
static bfd_boolean
d1750 3
a1752 2
  struct xcoff_ar_file_hdr_big *fhdr;
  bfd_vma i, sym_32, sym_64, str_32, str_64;
d1754 1
a1754 3
  bfd *current_bfd;
  size_t string_length;
  ufile_ptr nextoff, prevoff;
d1758 6
a1763 7
  sym_32 = sym_64 = str_32 = str_64 = 0;

  current_bfd = abfd->archive_head;
  if (current_bfd != NULL)
    arch_info = bfd_get_arch_info (current_bfd);
    i = 0;
    while (current_bfd != NULL && i < orl_count)
d1765 6
a1770 1
      while (map[i].u.abfd == current_bfd)
d1772 2
a1773 13
	  string_length = strlen (*map[i].name) + 1;

	  if (arch_info->bits_per_address == 64)
	    {
	      sym_64++;
	      str_64 += string_length;
	    }
	  else
	    {
	      sym_32++;
	      str_32 += string_length;
	    }
	  i++;
a1774 64
      current_bfd = current_bfd->next;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
    }

  /* A quick sanity check... */
  BFD_ASSERT (sym_64 + sym_32 == orl_count);
  /* Explicit cast to int for compiler.  */
  BFD_ASSERT ((int)(str_64 + str_32) == stridx);

  fhdr = xcoff_ardata_big (abfd);

  /* xcoff_write_archive_contents_big passes nextoff in symoff. */
  READ20 (fhdr->memoff, prevoff);
  READ20 (fhdr->symoff, nextoff);

  BFD_ASSERT (nextoff == bfd_tell (abfd));

  /* Write out the symbol table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[SXCOFFARFMAG]

     Symbol table
     0x0072		      num_syms	[0x08], binary
     0x0078		      offsets	[0x08 * num_syms], binary
     0x0086 + 0x08 * num_syms names	[??]
     ??			      pad to even bytes.
  */

  if (sym_32)
    {
      struct xcoff_ar_hdr_big *hdr;
      bfd_byte *symbol_table;
      bfd_byte *st;
      file_ptr fileoff;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_32
	+ str_32 + (str_32 & 1);

      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_32 + str_32 + (str_32 & 1));

      if (sym_64)
	PRINT20 (hdr->nextoff, nextoff + symbol_table_size);
a1775 23
	PRINT20 (hdr->nextoff, 0);

      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0) ;

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_32, st);
      st += 8;

      /* loop over the 32 bit offsets */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
      i = 0;
      while (current_bfd != NULL && i < orl_count)
d1777 2
a1778 138
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  bfd_h_put_64 (abfd, fileoff, st);
		  st += 8;
		}
	      i++;
	    }
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      /* loop over the 32 bit symbol names */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);
      symbol_table = NULL;

      prevoff = nextoff;
      nextoff = nextoff + symbol_table_size;
    }
  else
    PRINT20 (fhdr->symoff, 0);

  if (sym_64)
    {
      struct xcoff_ar_hdr_big *hdr;
      bfd_byte *symbol_table;
      bfd_byte *st;
      file_ptr fileoff;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_64
	+ str_64 + (str_64 & 1);

      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_64 + str_64 + (str_64 & 1));
      PRINT20 (hdr->nextoff, 0);
      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0);

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_64, st);
      st += 8;

      /* loop over the 64 bit offsets */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  bfd_h_put_64 (abfd, fileoff, st);
		  st += 8;
		}
	      i++;
	    }
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
	}

      /* loop over the 64 bit symbol names */
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      i = 0;
      while (current_bfd != NULL && i < orl_count)
	{
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	  current_bfd = current_bfd->next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
d1780 1
a1780 7

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);
      symbol_table = NULL;

      PRINT20 (fhdr->symoff64, nextoff);
d1782 15
a1796 2
  else
    PRINT20 (fhdr->symoff64, 0);
d1798 1
a1798 1
  return TRUE;
d1801 1
a1801 1
bfd_boolean
d1818 1
a1818 1
static bfd_boolean
d1823 2
a1824 2
  bfd_size_type count;
  bfd_size_type total_namlen;
d1826 3
a1828 3
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  ufile_ptr prevoff, nextoff;
d1830 1
a1830 1
  size_t i;
d1834 1
a1834 1
  char decbuf[XCOFFARMAG_ELEMENT_SIZE + 1];
d1850 1
a1850 1
    return FALSE;
d1852 2
a1853 2
  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return FALSE;
d1856 1
a1856 1
  hasobjects = FALSE;
d1862 1
a1862 1
      bfd_size_type namlen;
d1869 1
a1869 1
	    hasobjects = TRUE;
d1889 1
a1889 1
	      return FALSE;
d1900 1
a1900 2
	      size = sizeof (struct areltdata);
	      sub->arelt_data = bfd_alloc (sub, size);
d1902 1
a1902 1
		return FALSE;
d1912 2
a1913 2
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;
d1935 5
a1939 6
      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	   != SIZEOF_AR_HDR)
	  || bfd_bwrite ((PTR) name, namlen, abfd) != namlen
	  || bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			 abfd) != SXCOFFARFMAG)
	return FALSE;
d1942 5
a1946 1
	return FALSE;
d1948 8
a1955 2
      if (! do_copy (abfd, sub))
	return FALSE;
d1957 8
a1964 2
      if (! do_pad (abfd, size & 1))
	return FALSE;
d1975 1
a1975 3
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
				     + count * XCOFFARMAG_ELEMENT_SIZE
				     + total_namlen));
d1984 2
a1985 2
	  + XCOFFARMAG_ELEMENT_SIZE
	  + count * XCOFFARMAG_ELEMENT_SIZE
d2002 2
a2003 3
  if ((bfd_bwrite ((PTR) &ahdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
       != SIZEOF_AR_HDR)
      || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
d2005 1
a2005 1
    return FALSE;
d2008 3
a2010 4
  if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)
      != XCOFFARMAG_ELEMENT_SIZE)
    return FALSE;
  for (i = 0; i < (size_t) count; i++)
d2013 2
a2014 3
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
		      abfd) != XCOFFARMAG_ELEMENT_SIZE)
	return FALSE;
d2019 1
a2019 1
      bfd_size_type namlen;
d2023 2
a2024 2
      if (bfd_bwrite ((PTR) name, namlen + 1, abfd) != namlen + 1)
	return FALSE;
d2026 3
d2030 4
a2033 2
  if (! do_pad (abfd, size & 1))
    return FALSE;
d2036 1
d2045 1
a2045 1
	return FALSE;
d2056 3
a2058 3
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR, abfd)
	  != SIZEOF_AR_FILE_HDR))
    return FALSE;
d2060 1
a2060 1
  return TRUE;
d2063 1
a2063 1
static bfd_boolean
d2068 2
a2069 2
  bfd_size_type count;
  bfd_size_type total_namlen;
d2071 6
a2076 6
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  ufile_ptr prevoff, nextoff;
  bfd *current_bfd;
  size_t i;
  struct xcoff_ar_hdr_big *hdr, ahdr;
d2078 2
a2079 2
  bfd_byte *member_table, *mt;
  bfd_vma member_table_size;
d2081 4
a2084 2
  memset (&fhdr, 0, SIZEOF_AR_FILE_HDR_BIG);
  memcpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);
d2086 3
a2088 9
  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return FALSE;

  /* Calculate count and total_namlen.  */
  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->next, count++)
d2090 2
a2091 6
      total_namlen += strlen (normalize_filename (current_bfd)) + 1;

      if (makemap
	  && ! hasobjects
	  && bfd_check_format (current_bfd, bfd_object))
	hasobjects = TRUE;
d2093 3
d2097 2
a2098 7
  offsets = NULL;
  if (count)
    {
      offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));
      if (offsets == NULL)
	return FALSE;
    }
d2100 2
d2104 1
a2104 3
  for (current_bfd = abfd->archive_head, i = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->next, i++)
d2107 1
a2107 1
      bfd_size_type namlen;
d2111 7
a2117 1
      name = normalize_filename (current_bfd);
d2120 2
a2121 2
      if (current_bfd->arelt_data != NULL)
	ahdrp = arch_xhdr_big (current_bfd);
d2129 1
d2132 2
a2133 3
	     32-bit machines).
	     XXX This call will fail if the original object is not found.  */
	  if (stat (bfd_get_filename (current_bfd), &s) != 0)
d2136 1
a2136 1
	      return FALSE;
d2139 8
a2146 5
	  PRINT20 (ahdrp->size, s.st_size);
	  PRINT12 (ahdrp->date, s.st_mtime);
	  PRINT12 (ahdrp->uid,  s.st_uid);
	  PRINT12 (ahdrp->gid,  s.st_gid);
	  PRINT12_OCTAL (ahdrp->mode, s.st_mode);
d2148 1
a2148 1
	  if (current_bfd->arelt_data == NULL)
d2150 3
a2152 4
	      size = sizeof (struct areltdata);
	      current_bfd->arelt_data = bfd_alloc (current_bfd, size);
	      if (current_bfd->arelt_data == NULL)
		return FALSE;
d2155 1
a2155 1
	  arch_eltdata (current_bfd)->parsed_size = s.st_size;
d2158 5
a2162 2
      PRINT20 (ahdrp->prevoff, prevoff);
      PRINT4 (ahdrp->namlen, namlen);
d2165 2
a2166 2
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;
d2168 1
a2168 1
      remaining = arelt_size (current_bfd);
a2175 8
      /* Check for xcoff shared objects.
	 Their text section needs to be aligned wrt the archive file position.
	 This requires extra padding before the archive header.  */
      if (! do_shared_object_padding (abfd, current_bfd, & nextoff,
				      SIZEOF_AR_HDR_BIG + namlen
				      + SXCOFFARFMAG))
	return FALSE;

d2181 13
a2193 1
      PRINT20 (ahdrp->nextoff, nextoff);
d2195 32
a2226 43
      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	   != SIZEOF_AR_HDR_BIG)
	  || bfd_bwrite ((PTR) name, (bfd_size_type) namlen, abfd) != namlen
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			  abfd) != SXCOFFARFMAG))
	return FALSE;

      if (bfd_seek (current_bfd, (file_ptr) 0, SEEK_SET) != 0)
	return FALSE;

      if (! do_copy (abfd, current_bfd))
	return FALSE;

      if (! do_pad (abfd, size & 1))
	return FALSE;
    }

  if (count)
    {
      PRINT20 (fhdr.firstmemoff, offsets[0]);
      PRINT20 (fhdr.lastmemoff, prevoff);
    }

  /* Write out the member table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[0x02]

     Member table
     0x0072		      count	[0x14]
     0x0086		      offsets	[0x14 * counts]
     0x0086 + 0x14 * counts   names	[??]
     ??			      pad to even bytes.
   */
d2229 25
a2254 17
  member_table_size = (SIZEOF_AR_HDR_BIG
		       + SXCOFFARFMAG
		       + XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen);

  member_table_size += member_table_size & 1;
  member_table = NULL;
  member_table = (bfd_byte *) bfd_zmalloc (member_table_size);
  if (member_table == NULL)
    return FALSE;

  hdr = (struct xcoff_ar_hdr_big *) member_table;

  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen + (total_namlen & 1)));
d2256 4
a2259 1
    PRINT20 (hdr->nextoff, nextoff + member_table_size);
d2261 1
a2261 7
    PRINT20 (hdr->nextoff, 0);
  PRINT20 (hdr->prevoff, prevoff);
  PRINT12 (hdr->date, 0);
  PRINT12 (hdr->uid, 0);
  PRINT12 (hdr->gid, 0);
  PRINT12 (hdr->mode, 0);
  PRINT4 (hdr->namlen, 0);
d2263 4
a2266 3
  mt = member_table + SIZEOF_AR_HDR_BIG;
  memcpy (mt, XCOFFARFMAG, SXCOFFARFMAG);
  mt += SXCOFFARFMAG;
d2268 4
a2271 7
  PRINT20 (mt, count);
  mt += XCOFFARMAGBIG_ELEMENT_SIZE;
  for (i = 0; i < (size_t) count; i++)
    {
      PRINT20 (mt, offsets[i]);
      mt += XCOFFARMAGBIG_ELEMENT_SIZE;
    }
d2273 4
a2276 1
  if (count)
d2278 3
a2280 2
      free (offsets);
      offsets = NULL;
d2282 1
a2282 3

  for (current_bfd = abfd->archive_head; current_bfd != NULL;
       current_bfd = current_bfd->next)
d2287 4
a2290 3
      name = normalize_filename (current_bfd);
      namlen = sprintf (mt, "%s", name);
      mt += namlen + 1;
d2292 3
d2296 4
a2299 10
  if (bfd_bwrite (member_table, member_table_size, abfd) != member_table_size)
    return FALSE;

  free (member_table);
  member_table = NULL;

  PRINT20 (fhdr.memoff, nextoff);

  prevoff = nextoff;
  nextoff += member_table_size;
d2304 1
a2304 1
    PRINT20 (fhdr.symoff, 0);
d2308 3
a2310 4

      /* Save nextoff in fhdr.symoff so the armap routine can use it.  */
      PRINT20 (fhdr.symoff, nextoff);

d2313 1
a2313 1
	return FALSE;
d2318 5
d2324 3
a2326 3
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,
		      abfd) != SIZEOF_AR_FILE_HDR_BIG))
    return FALSE;
d2328 1
a2328 1
  return TRUE;
d2331 1
a2331 1
bfd_boolean
d2347 1
a2347 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
a2358 1860

/* Routines to swap information in the XCOFF .loader section.  If we
   ever need to write an XCOFF loader, this stuff will need to be
   moved to another file shared by the linker (which XCOFF calls the
   ``binder'') and the loader.  */

/* Swap in the ldhdr structure.  */

static void
xcoff_swap_ldhdr_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldhdr *dst;
{
  const struct external_ldhdr *src = (const struct external_ldhdr *) s;

  dst->l_version = bfd_get_32 (abfd, src->l_version);
  dst->l_nsyms = bfd_get_32 (abfd, src->l_nsyms);
  dst->l_nreloc = bfd_get_32 (abfd, src->l_nreloc);
  dst->l_istlen = bfd_get_32 (abfd, src->l_istlen);
  dst->l_nimpid = bfd_get_32 (abfd, src->l_nimpid);
  dst->l_impoff = bfd_get_32 (abfd, src->l_impoff);
  dst->l_stlen = bfd_get_32 (abfd, src->l_stlen);
  dst->l_stoff = bfd_get_32 (abfd, src->l_stoff);
}

/* Swap out the ldhdr structure.  */

static void
xcoff_swap_ldhdr_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldhdr *src;
     PTR d;
{
  struct external_ldhdr *dst = (struct external_ldhdr *) d;

  bfd_put_32 (abfd, (bfd_vma) src->l_version, dst->l_version);
  bfd_put_32 (abfd, src->l_nsyms, dst->l_nsyms);
  bfd_put_32 (abfd, src->l_nreloc, dst->l_nreloc);
  bfd_put_32 (abfd, src->l_istlen, dst->l_istlen);
  bfd_put_32 (abfd, src->l_nimpid, dst->l_nimpid);
  bfd_put_32 (abfd, src->l_impoff, dst->l_impoff);
  bfd_put_32 (abfd, src->l_stlen, dst->l_stlen);
  bfd_put_32 (abfd, src->l_stoff, dst->l_stoff);
}

/* Swap in the ldsym structure.  */

static void
xcoff_swap_ldsym_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldsym *dst;
{
  const struct external_ldsym *src = (const struct external_ldsym *) s;

  if (bfd_get_32 (abfd, src->_l._l_l._l_zeroes) != 0) {
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  } else {
    dst->_l._l_l._l_zeroes = 0;
    dst->_l._l_l._l_offset = bfd_get_32 (abfd, src->_l._l_l._l_offset);
  }
  dst->l_value = bfd_get_32 (abfd, src->l_value);
  dst->l_scnum = bfd_get_16 (abfd, src->l_scnum);
  dst->l_smtype = bfd_get_8 (abfd, src->l_smtype);
  dst->l_smclas = bfd_get_8 (abfd, src->l_smclas);
  dst->l_ifile = bfd_get_32 (abfd, src->l_ifile);
  dst->l_parm = bfd_get_32 (abfd, src->l_parm);
}

/* Swap out the ldsym structure.  */

static void
xcoff_swap_ldsym_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldsym *src;
     PTR d;
{
  struct external_ldsym *dst = (struct external_ldsym *) d;

  if (src->_l._l_l._l_zeroes != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      bfd_put_32 (abfd, (bfd_vma) 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, (bfd_vma) src->_l._l_l._l_offset,
		  dst->_l._l_l._l_offset);
    }
  bfd_put_32 (abfd, src->l_value, dst->l_value);
  bfd_put_16 (abfd, (bfd_vma) src->l_scnum, dst->l_scnum);
  bfd_put_8 (abfd, src->l_smtype, dst->l_smtype);
  bfd_put_8 (abfd, src->l_smclas, dst->l_smclas);
  bfd_put_32 (abfd, src->l_ifile, dst->l_ifile);
  bfd_put_32 (abfd, src->l_parm, dst->l_parm);
}

static void
xcoff_swap_reloc_in (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
{
  struct external_reloc *src = (struct external_reloc *) s;
  struct internal_reloc *dst = (struct internal_reloc *) d;

  memset (dst, 0, sizeof (struct internal_reloc));

  dst->r_vaddr = bfd_get_32 (abfd, src->r_vaddr);
  dst->r_symndx = bfd_get_32 (abfd, src->r_symndx);
  dst->r_size = bfd_get_8 (abfd, src->r_size);
  dst->r_type = bfd_get_8 (abfd, src->r_type);
}

static unsigned int
xcoff_swap_reloc_out (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
{
  struct internal_reloc *src = (struct internal_reloc *) s;
  struct external_reloc *dst = (struct external_reloc *) d;

  bfd_put_32 (abfd, src->r_vaddr, dst->r_vaddr);
  bfd_put_32 (abfd, src->r_symndx, dst->r_symndx);
  bfd_put_8 (abfd, src->r_type, dst->r_type);
  bfd_put_8 (abfd, src->r_size, dst->r_size);

  return bfd_coff_relsz (abfd);
}

/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldrel *dst;
{
  const struct external_ldrel *src = (const struct external_ldrel *) s;

  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}

/* Swap out the ldrel structure.  */

static void
xcoff_swap_ldrel_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldrel *src;
     PTR d;
{
  struct external_ldrel *dst = (struct external_ldrel *) d;

  bfd_put_32 (abfd, src->l_vaddr, dst->l_vaddr);
  bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);
  bfd_put_16 (abfd, (bfd_vma) src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, (bfd_vma) src->l_rsecnm, dst->l_rsecnm);
}


bfd_boolean
xcoff_reloc_type_noop (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_fail (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  (*_bfd_error_handler)
    (_("%s: unsupported relocation type 0x%02x"),
     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

bfd_boolean
xcoff_reloc_type_pos (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  *relocation = val + addend;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_neg (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  *relocation = addend - val;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_rel (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->pc_relative = TRUE;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_toc (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     struct internal_reloc *rel;
     struct internal_syment *sym;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  struct xcoff_link_hash_entry *h;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];

  if (h != NULL && h->smclas != XMC_TD)
    {
      if (h->toc_section == NULL)
	{
	  (*_bfd_error_handler)
	    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
	     bfd_get_filename (input_bfd), rel->r_vaddr,
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
      val = (h->toc_section->output_section->vma
	      + h->toc_section->output_offset);
    }

  *relocation = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_ba (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  *relocation = val + addend;

  return TRUE;
}

static bfd_boolean
xcoff_reloc_type_br (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents;
{
  struct xcoff_link_hash_entry *h;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];

  /* If we see an R_BR or R_RBR reloc which is jumping to global
     linkage code, and it is followed by an appropriate cror nop
     instruction, we replace the cror with lwz r2,20(r1).  This
     restores the TOC after the glink code.  Contrariwise, if the
     call is followed by a lwz r2,20(r1), but the call is not
     going to global linkage code, we can replace the load with a
     cror.  */
  if (NULL != h
      && bfd_link_hash_defined == h->root.type
      && (rel->r_vaddr - input_section->vma + 8
	  <= input_section->_cooked_size))
    {
      bfd_byte *pnext;
      unsigned long next;

      pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
      next = bfd_get_32 (input_bfd, pnext);

      /* The _ptrgl function is magic.  It is used by the AIX
	 compiler to call a function through a pointer.  */
      if (h->smclas == XMC_GL || strcmp (h->root.root.string, "._ptrgl") == 0)
	{
	  if (next == 0x4def7b82			/* cror 15,15,15 */
	      || next == 0x4ffffb82			/* cror 31,31,31 */
	      || next == 0x60000000)			/* ori r0,r0,0 */
	    bfd_put_32 (input_bfd, 0x80410014, pnext);	/* lwz r1,20(r1) */

	}
      else
	{
	  if (next == 0x80410014)			/* lwz r1,20(r1) */
	    bfd_put_32 (input_bfd, 0x60000000, pnext);	/* ori r0,r0,0 */
	}
    }
  else if (NULL != h && bfd_link_hash_undefined == h->root.type)
    {
      /* Normally, this relocation is against a defined symbol.  In the
	 case where this is a partial link and the output section offset
	 is greater than 2^25, the linker will return an invalid error
	 message that the relocation has been truncated.  Yes it has been
	 truncated but no it not important.  For this case, disable the
	 overflow checking. */

      howto->complain_on_overflow = complain_overflow_dont;
    }

  howto->pc_relative = TRUE;
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_crel (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
{
  howto->pc_relative = TRUE;
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

static bfd_boolean
xcoff_complain_overflow_dont_func (input_bfd, val, relocation, howto)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma relocation ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
{
  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_bitfield_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  /* Much like unsigned, except no trimming with addrmask.  In
     addition, the sum overflows if there is a carry out of
     the bfd_vma, i.e., the sum is less than either input
     operand.  */
  a >>= howto->rightshift;
  b >>= howto->bitpos;

  /* Bitfields are sometimes used for signed numbers; for
     example, a 13-bit field sometimes represents values in
     0..8191 and sometimes represents values in -4096..4095.
     If the field is signed and a is -4095 (0x1001) and b is
     -1 (0x1fff), the sum is -4096 (0x1000), but (0x1001 +
     0x1fff is 0x3000).  It's not clear how to handle this
     everywhere, since there is not way to know how many bits
     are significant in the relocation, but the original code
     assumed that it was fully sign extended, and we will keep
     that assumption.  */
  signmask = (fieldmask >> 1) + 1;

  if ((a & ~ fieldmask) != 0)
    {
      /* Some bits out of the field are set.  This might not
	 be a problem: if this is a signed bitfield, it is OK
	 iff all the high bits are set, including the sign
	 bit.  We'll try setting all but the most significant
	 bit in the original relocation value: if this is all
	 ones, we are OK, assuming a signed bitfield.  */
      ss = (signmask << howto->rightshift) - 1;
      if ((ss | relocation) != ~ (bfd_vma) 0)
	return TRUE;
      a &= fieldmask;
    }

  /* We just assume (b & ~ fieldmask) == 0.  */

  /* We explicitly permit wrap around if this relocation
     covers the high bit of an address.  The Linux kernel
     relies on it, and it is the only way to write assembler
     code which can run when loaded at a location 0x80000000
     away from the location at which it is linked.  */
  if (howto->bitsize + howto->rightshift
      == bfd_arch_bits_per_address (input_bfd))
    return FALSE;

  sum = a + b;
  if (sum < a || (sum & ~ fieldmask) != 0)
    {
      /* There was a carry out, or the field overflow.  Test
	 for signed operands again.  Here is the overflow test
	 is as for complain_overflow_signed.  */
      if (((~ (a ^ b)) & (a ^ sum)) & signmask)
	return TRUE;
    }

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_signed_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  a = (a & addrmask) >> howto->rightshift;

  /* If any sign bits are set, all sign bits must be set.
     That is, A must be a valid negative address after
     shifting.  */
  signmask = ~ (fieldmask >> 1);
  ss = a & signmask;
  if (ss != 0 && ss != ((addrmask >> howto->rightshift) & signmask))
    return TRUE;

  /* We only need this next bit of code if the sign bit of B
     is below the sign bit of A.  This would only happen if
     SRC_MASK had fewer bits than BITSIZE.  Note that if
     SRC_MASK has more bits than BITSIZE, we can get into
     trouble; we would need to verify that B is in range, as
     we do for A above.  */
  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;
  if ((b & signmask) != 0)
    {
      /* Set all the bits above the sign bit.  */
      b -= signmask <<= 1;
    }

  b = (b & addrmask) >> howto->bitpos;

  /* Now we can do the addition.  */
  sum = a + b;

  /* See if the result has the correct sign.  Bits above the
     sign bit are junk now; ignore them.  If the sum is
     positive, make sure we did not have all negative inputs;
     if the sum is negative, make sure we did not have all
     positive inputs.  The test below looks only at the sign
     bits, and it really just
     SIGN (A) == SIGN (B) && SIGN (A) != SIGN (SUM)
  */
  signmask = (fieldmask >> 1) + 1;
  if (((~ (a ^ b)) & (a ^ sum)) & signmask)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_unsigned_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
{
  bfd_vma addrmask, fieldmask;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  /* Checking for an unsigned overflow is relatively easy:
     trim the addresses and add, and trim the result as well.
     Overflow is normally indicated when the result does not
     fit in the field.  However, we also need to consider the
     case when, e.g., fieldmask is 0x7fffffff or smaller, an
     input is 0x80000000, and bfd_vma is only 32 bits; then we
     will get sum == 0, but there is an overflow, since the
     inputs did not fit in the field.  Instead of doing a
     separate test, we can check for this by or-ing in the
     operands when testing for the sum overflowing its final
     field.  */
  a = (a & addrmask) >> howto->rightshift;
  b = (b & addrmask) >> howto->bitpos;
  sum = (a + b) & addrmask;
  if ((a | b | sum) & ~ fieldmask)
    return TRUE;

  return FALSE;
}

/* This is the relocation function for the RS/6000/POWER/PowerPC.
   This is currently the only processor which uses XCOFF; I hope that
   will never change.

   I took the relocation type definitions from two documents:
   the PowerPC AIX Version 4 Application Binary Interface, First
   Edition (April 1992), and the PowerOpen ABI, Big-Endian
   32-Bit Hardware Implementation (June 30, 1994).  Differences
   between the documents are noted below.

   Unsupported r_type's

   R_RTB:
   R_RRTBI:
   R_RRTBA:

   These relocs are defined by the PowerPC ABI to be
   relative branches which use half of the difference
   between the symbol and the program counter.  I can't
   quite figure out when this is useful.  These relocs are
   not defined by the PowerOpen ABI.

   Supported r_type's

   R_POS:
   Simple positive relocation.

   R_NEG:
   Simple negative relocation.

   R_REL:
   Simple PC relative relocation.

   R_TOC:
   TOC relative relocation.  The value in the instruction in
   the input file is the offset from the input file TOC to
   the desired location.  We want the offset from the final
   TOC to the desired location.  We have:
   isym = iTOC + in
   iinsn = in + o
   osym = oTOC + on
   oinsn = on + o
   so we must change insn by on - in.

   R_GL:
   GL linkage relocation.  The value of this relocation
   is the address of the entry in the TOC section.

   R_TCL:
   Local object TOC address.  I can't figure out the
   difference between this and case R_GL.

   R_TRL:
   TOC relative relocation.  A TOC relative load instruction
   which may be changed to a load address instruction.
   FIXME: We don't currently implement this optimization.

   R_TRLA:
   TOC relative relocation.  This is a TOC relative load
   address instruction which may be changed to a load
   instruction.  FIXME: I don't know if this is the correct
   implementation.

   R_BA:
   Absolute branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CAI:
   The PowerPC ABI defines this as an absolute call which
   may be modified to become a relative call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBA:
   Absolute branch which may be modified to become a
   relative branch.

   R_RBAC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to an absolute branch
   to a symbol.  The PowerOpen ABI does not define this
   relocation type.

   R_RBRC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to a relative branch.
   The PowerOpen ABI does not define this relocation type.

   R_BR:
   Relative branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CREL:
   The PowerPC ABI defines this as a relative call which may
   be modified to become an absolute call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBR:
   A relative branch which may be modified to become an
   absolute branch.  FIXME: We don't implement this,
   although we should for symbols of storage mapping class
   XMC_XO.

   R_RL:
   The PowerPC AIX ABI describes this as a load which may be
   changed to a load address.  The PowerOpen ABI says this
   is the same as case R_POS.

   R_RLA:
   The PowerPC AIX ABI describes this as a load address
   which may be changed to a load.  The PowerOpen ABI says
   this is the same as R_POS.
*/

bfd_boolean
xcoff_ppc_relocate_section (output_bfd, info, input_bfd,
			    input_section, contents, relocs, syms,
			    sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct xcoff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      struct reloc_howto_struct howto;
      bfd_vma relocation;
      bfd_vma value_to_relocate;
      bfd_vma address;
      bfd_byte *location;

      /* Relocation type R_REF is a special relocation type which is
	 merely used to prevent garbage collection from occurring for
	 the csect including the symbol which it references.  */
      if (rel->r_type == R_REF)
	continue;

      /* howto */
      howto.type = rel->r_type;
      howto.rightshift = 0;
      howto.bitsize = (rel->r_size & 0x1f) + 1;
      howto.size = howto.bitsize > 16 ? 2 : 1;
      howto.pc_relative = FALSE;
      howto.bitpos = 0;
      howto.complain_on_overflow = (rel->r_size & 0x80
				    ? complain_overflow_signed
				    : complain_overflow_bitfield);
      howto.special_function = NULL;
      howto.name = "internal";
      howto.partial_inplace = TRUE;
      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);
      howto.pcrel_offset = FALSE;

      /* symbol */
      val = 0;
      addend = 0;
      h = NULL;
      sym = NULL;
      symndx = rel->r_symndx;

      if (-1 != symndx)
	{
	  asection *sec;

	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;

	  if (NULL == h)
	    {
	      sec = sections[symndx];
	      /* Hack to make sure we use the right TOC anchor value
		 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
	    }
	  else
	    {
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  val = (h->root.u.def.value
			 + sec->output_section->vma
			 + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_common)
		{
		  sec = h->root.u.c.p->section;
		  val = (sec->output_section->vma
			 + sec->output_offset);

		}
	      else if ((0 == (h->flags & (XCOFF_DEF_DYNAMIC | XCOFF_IMPORT)))
		       && ! info->relocateable)
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd, input_section,
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;

		  /* Don't try to process the reloc.  It can't help, and
		     it may generate another error.  */
		  continue;
		}
	    }
	}

      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION
	  || !((*xcoff_calculate_relocation[rel->r_type])
	       (input_bfd, input_section, output_bfd, rel, sym, &howto, val,
		addend, &relocation, contents)))
	return FALSE;

      /* address */
      address = rel->r_vaddr - input_section->vma;
      location = contents + address;

      if (address > input_section->_raw_size)
	abort ();

      /* Get the value we are going to relocate.  */
      if (1 == howto.size)
	value_to_relocate = bfd_get_16 (input_bfd, location);
      else
	value_to_relocate = bfd_get_32 (input_bfd, location);

      /* overflow.

	 FIXME: We may drop bits during the addition
	 which we don't check for.  We must either check at every single
	 operation, which would be tedious, or we must do the computations
	 in a type larger than bfd_vma, which would be inefficient.  */

      if ((unsigned int) howto.complain_on_overflow
	  >= XCOFF_MAX_COMPLAIN_OVERFLOW)
	abort ();

      if (((*xcoff_complain_overflow[howto.complain_on_overflow])
	   (input_bfd, value_to_relocate, relocation, &howto)))
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  char reloc_type_name[10];

	  if (symndx == -1)
	    {
	      name = "*ABS*";
	    }
	  else if (h != NULL)
	    {
	      name = h->root.root.string;
	    }
	  else
	    {
	      name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
	      if (name == NULL)
		name = "UNKNOWN";
	    }
	  sprintf (reloc_type_name, "0x%02x", rel->r_type);

	  if (! ((*info->callbacks->reloc_overflow)
		 (info, name, reloc_type_name, (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
	    return FALSE;
	}

      /* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)
			   | (((value_to_relocate & howto.src_mask)
			       + relocation) & howto.dst_mask));

      /* Put the value back in the object file.  */
      if (1 == howto.size)
	bfd_put_16 (input_bfd, value_to_relocate, location);
      else
	bfd_put_32 (input_bfd, value_to_relocate, location);
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_ldsymbol_name (abfd, ldinfo, ldsym, name)
     bfd *abfd ATTRIBUTE_UNUSED;
	 struct xcoff_loader_info *ldinfo;
	 struct internal_ldsym *ldsym;
	 const char *name;
{
  size_t len;
  len = strlen (name);

  if (len <= SYMNMLEN)
    strncpy (ldsym->_l._l_name, name, SYMNMLEN);
  else
    {
      if (ldinfo->string_size + len + 3 > ldinfo->string_alc)
	{
	  bfd_size_type newalc;
	  bfd_byte *newstrings;

	  newalc = ldinfo->string_alc * 2;
	  if (newalc == 0)
	    newalc = 32;
	  while (ldinfo->string_size + len + 3 > newalc)
	    newalc *= 2;

	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
	  if (newstrings == NULL)
	    {
	      ldinfo->failed = TRUE;
	      return FALSE;
	    }
	  ldinfo->string_alc = newalc;
	  ldinfo->strings = newstrings;
	}

      bfd_put_16 (ldinfo->output_bfd, (bfd_vma) (len + 1),
		  ldinfo->strings + ldinfo->string_size);
      strcpy (ldinfo->strings + ldinfo->string_size + 2, name);
      ldsym->_l._l_l._l_zeroes = 0;
      ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;
      ldinfo->string_size += len + 3;
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_symbol_name (bfd *abfd, struct bfd_strtab_hash *strtab,
			    struct internal_syment *sym,
			    const char *name)
{
  if (strlen (name) <= SYMNMLEN)
    {
      strncpy (sym->_n._n_name, name, SYMNMLEN);
    }
  else
    {
      bfd_boolean hash;
      bfd_size_type indx;

      hash = TRUE;
      if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = FALSE;
      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);
      if (indx == (bfd_size_type) -1)
	return FALSE;
      sym->_n._n_n._n_zeroes = 0;
      sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }
  return TRUE;
}

static asection *
xcoff_create_csect_from_smclas (abfd, aux, symbol_name)
     bfd *abfd;
     union internal_auxent *aux;
     const char *symbol_name;
{
  asection *return_value = NULL;

  /* .sv64 = x_smclas == 17
     This is an invalid csect for 32 bit apps.  */
  static const char *names[19] =
  {
    ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
    ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
    ".td", NULL, ".sv3264"
  };

  if ((19 >= aux->x_csect.x_smclas)
      && (NULL != names[aux->x_csect.x_smclas]))
    {
      return_value = bfd_make_section_anyway
	(abfd, names[aux->x_csect.x_smclas]);
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: symbol `%s' has unrecognized smclas %d"),
	 bfd_archive_filename (abfd), symbol_name, aux->x_csect.x_smclas);
      bfd_set_error (bfd_error_bad_value);
    }

  return return_value;
}

static bfd_boolean
xcoff_is_lineno_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_is_reloc_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_vma
xcoff_loader_symbol_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr ATTRIBUTE_UNUSED;
{
  return bfd_xcoff_ldhdrsz (abfd);
}

static bfd_vma
xcoff_loader_reloc_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr;
{
  return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);
}

static bfd_boolean
xcoff_generate_rtinit  (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
{
  bfd_byte filehdr_ext[FILHSZ];
  bfd_byte scnhdr_ext[SCNHSZ];
  bfd_byte syment_ext[SYMESZ * 10];
  bfd_byte reloc_ext[RELSZ * 3];
  bfd_byte *data_buffer;
  bfd_size_type data_buffer_size;
  bfd_byte *string_table = NULL, *st_tmp = NULL;
  bfd_size_type string_table_size;
  bfd_vma val;
  size_t initsz, finisz;
  struct internal_filehdr filehdr;
  struct internal_scnhdr scnhdr;
  struct internal_syment syment;
  union internal_auxent auxent;
  struct internal_reloc reloc;

  char *data_name = ".data";
  char *rtinit_name = "__rtinit";
  char *rtld_name = "__rtld";

  if (! bfd_xcoff_rtinit_size (abfd))
    return FALSE;

  initsz = (init == NULL ? 0 : 1 + strlen (init));
  finisz = (fini == NULL ? 0 : 1 + strlen (fini));

  /* file header */
  memset (filehdr_ext, 0, FILHSZ);
  memset (&filehdr, 0, sizeof (struct internal_filehdr));
  filehdr.f_magic = bfd_xcoff_magic_number (abfd);
  filehdr.f_nscns = 1;
  filehdr.f_timdat = 0;
  filehdr.f_nsyms = 0;  /* at least 6, no more than 10 */
  filehdr.f_symptr = 0; /* set below */
  filehdr.f_opthdr = 0;
  filehdr.f_flags = 0;

  /* section header */
  memset (scnhdr_ext, 0, SCNHSZ);
  memset (&scnhdr, 0, sizeof (struct internal_scnhdr));
  memcpy (scnhdr.s_name, data_name, strlen (data_name));
  scnhdr.s_paddr = 0;
  scnhdr.s_vaddr = 0;
  scnhdr.s_size = 0;    /* set below */
  scnhdr.s_scnptr = FILHSZ + SCNHSZ;
  scnhdr.s_relptr = 0;  /* set below */
  scnhdr.s_lnnoptr = 0;
  scnhdr.s_nreloc = 0;  /* either 1 or 2 */
  scnhdr.s_nlnno = 0;
  scnhdr.s_flags = STYP_DATA;

  /* .data
     0x0000	      0x00000000 : rtl
     0x0004	      0x00000010 : offset to init, or 0
     0x0008	      0x00000028 : offset to fini, or 0
     0x000C	      0x0000000C : size of descriptor
     0x0010	      0x00000000 : init, needs a reloc
     0x0014	      0x00000040 : offset to init name
     0x0018	      0x00000000 : flags, padded to a word
     0x001C	      0x00000000 : empty init
     0x0020	      0x00000000 :
     0x0024	      0x00000000 :
     0x0028	      0x00000000 : fini, needs a reloc
     0x002C	      0x00000??? : offset to fini name
     0x0030	      0x00000000 : flags, padded to a word
     0x0034	      0x00000000 : empty fini
     0x0038	      0x00000000 :
     0x003C	      0x00000000 :
     0x0040	      init name
     0x0040 + initsz  fini name */

  data_buffer_size = 0x0040 + initsz + finisz;
  data_buffer_size = (data_buffer_size + 7) &~ (bfd_size_type) 7;
  data_buffer = NULL;
  data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);
  if (data_buffer == NULL)
    return FALSE;

  if (initsz)
    {
      val = 0x10;
      bfd_h_put_32 (abfd, val, &data_buffer[0x04]);
      val = 0x40;
      bfd_h_put_32 (abfd, val, &data_buffer[0x14]);
      memcpy (&data_buffer[val], init, initsz);
    }

  if (finisz)
    {
      val = 0x28;
      bfd_h_put_32 (abfd, val, &data_buffer[0x08]);
      val = 0x40 + initsz;
      bfd_h_put_32 (abfd, val, &data_buffer[0x2C]);
      memcpy (&data_buffer[val], fini, finisz);
    }

  val = 0x0C;
  bfd_h_put_32 (abfd, val, &data_buffer[0x0C]);

  scnhdr.s_size = data_buffer_size;

  /* string table */
  string_table_size = 0;
  if (initsz > 9)
    string_table_size += initsz;
  if (finisz > 9)
    string_table_size += finisz;
  if (string_table_size)
    {
      string_table_size += 4;
      string_table = (bfd_byte *) bfd_zmalloc (string_table_size);
      if (string_table == NULL)
	return FALSE;

      val = string_table_size;
      bfd_h_put_32 (abfd, val, &string_table[0]);
      st_tmp = string_table + 4;
    }

  /* symbols
     0. .data csect
     2. __rtinit
     4. init function
     6. fini function
     8. __rtld  */
  memset (syment_ext, 0, 10 * SYMESZ);
  memset (reloc_ext, 0, 3 * RELSZ);

  /* .data csect */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, data_name, strlen (data_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_HIDEXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_scnlen.l = data_buffer_size;
  auxent.x_csect.x_smtyp = 3 << 3 | XTY_SD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* __rtinit */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, rtinit_name, strlen (rtinit_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_EXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_smtyp = XTY_LD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* init */
  if (initsz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (initsz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, init, initsz);
	  st_tmp += initsz;
	}
      else
	memcpy (syment._n._n_name, init, initsz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0010;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc, &reloc_ext[0]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  /* fini */
  if (finisz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (finisz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, fini, finisz);
	  st_tmp += finisz;
	}
      else
	memcpy (syment._n._n_name, fini, finisz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0028;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  if (rtld)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));
      memcpy (syment._n._n_name, rtld_name, strlen (rtld_name));
      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0000;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  scnhdr.s_relptr = scnhdr.s_scnptr + data_buffer_size;
  filehdr.f_symptr = scnhdr.s_relptr + scnhdr.s_nreloc * RELSZ;

  bfd_coff_swap_filehdr_out (abfd, &filehdr, filehdr_ext);
  bfd_bwrite (filehdr_ext, FILHSZ, abfd);
  bfd_coff_swap_scnhdr_out (abfd, &scnhdr, scnhdr_ext);
  bfd_bwrite (scnhdr_ext, SCNHSZ, abfd);
  bfd_bwrite (data_buffer, data_buffer_size, abfd);
  bfd_bwrite (reloc_ext, scnhdr.s_nreloc * RELSZ, abfd);
  bfd_bwrite (syment_ext, filehdr.f_nsyms * SYMESZ, abfd);
  bfd_bwrite (string_table, string_table_size, abfd);

  free (data_buffer);
  data_buffer = NULL;

  return TRUE;
}


static reloc_howto_type xcoff_dynamic_reloc =
HOWTO (0,			/* type */
       0,			/* rightshift */
       2,			/* size (0 = byte, 1 = short, 2 = long) */
       32,			/* bitsize */
       FALSE,			/* pc_relative */
       0,			/* bitpos */
       complain_overflow_bitfield, /* complain_on_overflow */
       0,			/* special_function */
       "R_POS",			/* name */
       TRUE,			/* partial_inplace */
       0xffffffff,		/* src_mask */
       0xffffffff,		/* dst_mask */
       FALSE);			/* pcrel_offset */

/*  glink

   The first word of global linkage code must be modified by filling in
   the correct TOC offset.  */

static unsigned long xcoff_glink_code[9] =
  {
    0x81820000,	/* lwz r12,0(r2) */
    0x90410014,	/* stw r2,20(r1) */
    0x800c0000,	/* lwz r0,0(r12) */
    0x804c0004,	/* lwz r2,4(r12) */
    0x7c0903a6,	/* mtctr r0 */
    0x4e800420,	/* bctr */
    0x00000000,	/* start of traceback table */
    0x000c8000,	/* traceback table */
    0x00000000,	/* traceback table */
  };


static const struct xcoff_backend_data_rec bfd_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
    },

    0x01DF,			/* magic number */
    bfd_arch_rs6000,
    bfd_mach_rs6k,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    64,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target rs6000coff_vec =
  {
    "aixcoff-rs6000",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,

    /* Archive */
    _bfd_xcoff_slurp_armap,
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    (void *) &bfd_xcoff_backend_data,
  };

/* xcoff-powermac target
   Old target.
   Only difference between this target and the rs6000 target is the
   the default architecture and machine type used in coffcode.h

   PowerPC Macs use the same magic numbers as RS/6000
   (because that's how they were bootstrapped originally),
   but they are always PowerPC architecture.  */
static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
    },

    0x01DF,			/* magic number */
    bfd_arch_powerpc,
    bfd_mach_ppc,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    0,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target pmac_xcoff_vec =
  {
    "xcoff-powermac",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,

    /* Archive */
    _bfd_xcoff_slurp_armap,
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    (void *) &bfd_pmac_xcoff_backend_data,
  };
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003
d1009 1
a1009 1
  /* Special case some 16 bit reloc */
d1578 1
d3429 1
a3429 1
		       && ! info->relocatable)
d4168 1
a4168 1
    coff_canonicalize_symtab,
d4410 1
a4410 1
    coff_canonicalize_symtab,
@


