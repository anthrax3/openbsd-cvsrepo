head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.07;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.32.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.31;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.31;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.02;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.12.05;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.18.07;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.27;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.20.54;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Motorola 68000 COFF binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/m68k.h"
#include "coff/internal.h"
#include "libcoff.h"

/* This source file is compiled multiple times for various m68k COFF
   variants.  The following macros control its behaviour:

   TARGET_SYM
     The C name of the BFD target vector.  The default is m68kcoff_vec.
   TARGET_NAME
     The user visible target name.  The default is "coff-m68k".
   NAMES_HAVE_UNDERSCORE
     Whether symbol names have an underscore.
   ONLY_DECLARE_RELOCS
     Only declare the relocation howto array.  Don't actually compile
     it.  The actual array will be picked up in another version of the
     file.
   STATIC_RELOCS
     Make the relocation howto array, and associated functions, static.
   COFF_COMMON_ADDEND
     If this is defined, then, for a relocation against a common
     symbol, the object file holds the value (the size) of the common
     symbol.  If this is not defined, then, for a relocation against a
     common symbol, the object file holds zero.  */

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)

#ifndef COFF_PAGE_SIZE
/* The page size is a guess based on ELF.  */
#define COFF_PAGE_SIZE 0x2000
#endif

#ifndef COFF_COMMON_ADDEND
#define RELOC_SPECIAL_FN 0
#else
static bfd_reloc_status_type m68kcoff_common_addend_special_fn
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type *m68kcoff_common_addend_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
#define RELOC_SPECIAL_FN m68kcoff_common_addend_special_fn
#endif

static bfd_boolean m68k_coff_is_local_label_name
  PARAMS ((bfd *, const char *));

/* On the delta, a symbol starting with L% is local.  We won't see
   such a symbol on other platforms, so it should be safe to always
   consider it local here.  */

static bfd_boolean
m68k_coff_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == 'L' && name[1] == '%')
    return TRUE;

  return _bfd_coff_is_local_label_name (abfd, name);
}

#ifndef STATIC_RELOCS
/* Clean up namespace.  */
#define m68kcoff_howto_table	_bfd_m68kcoff_howto_table
#define m68k_rtype2howto	_bfd_m68kcoff_rtype2howto
#define m68k_howto2rtype	_bfd_m68kcoff_howto2rtype
#define m68k_reloc_type_lookup	_bfd_m68kcoff_reloc_type_lookup
#endif

#ifdef ONLY_DECLARE_RELOCS
extern reloc_howto_type m68kcoff_howto_table[];
#else
#ifdef STATIC_RELOCS
static
#endif
reloc_howto_type m68kcoff_howto_table[] =
  {
    HOWTO (R_RELBYTE,	       0,  0,  	8,  FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "8",	TRUE, 0x000000ff,0x000000ff, FALSE),
    HOWTO (R_RELWORD,	       0,  1, 	16, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
    HOWTO (R_RELLONG,	       0,  2, 	32, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "32",	TRUE, 0xffffffff,0xffffffff, FALSE),
    HOWTO (R_PCRBYTE,	       0,  0, 	8,  TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP8",    TRUE, 0x000000ff,0x000000ff, FALSE),
    HOWTO (R_PCRWORD,	       0,  1, 	16, TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP16",   TRUE, 0x0000ffff,0x0000ffff, FALSE),
    HOWTO (R_PCRLONG,	       0,  2, 	32, TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP32",   TRUE, 0xffffffff,0xffffffff, FALSE),
    HOWTO (R_RELLONG_NEG,      0, -2, 	32, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "-32",	TRUE, 0xffffffff,0xffffffff, FALSE),
  };
#endif /* not ONLY_DECLARE_RELOCS */

#ifndef BADMAG
#define BADMAG(x) M68KBADMAG(x)
#endif
#define M68 1		/* Customize coffcode.h */

/* Turn a howto into a reloc number */

#ifdef ONLY_DECLARE_RELOCS
extern void m68k_rtype2howto PARAMS ((arelent *internal, int relocentry));
extern int m68k_howto2rtype PARAMS ((reloc_howto_type *));
extern reloc_howto_type *m68k_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
#else

#ifdef STATIC_RELOCS
#define STAT_REL static
#else
#define STAT_REL
#endif

STAT_REL reloc_howto_type * m68k_reloc_type_lookup PARAMS ((bfd *, bfd_reloc_code_real_type));
STAT_REL int m68k_howto2rtype PARAMS ((reloc_howto_type *));
STAT_REL void m68k_rtype2howto PARAMS ((arelent *, int));


STAT_REL void
m68k_rtype2howto(internal, relocentry)
     arelent *internal;
     int relocentry;
{
  switch (relocentry)
    {
    case R_RELBYTE:	internal->howto = m68kcoff_howto_table + 0; break;
    case R_RELWORD:	internal->howto = m68kcoff_howto_table + 1; break;
    case R_RELLONG:	internal->howto = m68kcoff_howto_table + 2; break;
    case R_PCRBYTE:	internal->howto = m68kcoff_howto_table + 3; break;
    case R_PCRWORD:	internal->howto = m68kcoff_howto_table + 4; break;
    case R_PCRLONG:	internal->howto = m68kcoff_howto_table + 5; break;
    case R_RELLONG_NEG:	internal->howto = m68kcoff_howto_table + 6; break;
    }
}

STAT_REL int
m68k_howto2rtype (internal)
     reloc_howto_type *internal;
{
  if (internal->pc_relative)
    {
      switch (internal->bitsize)
	{
	case 32: return R_PCRLONG;
	case 16: return R_PCRWORD;
	case 8: return R_PCRBYTE;
	}
    }
  else
    {
      switch (internal->bitsize)
	{
	case 32: return R_RELLONG;
	case 16: return R_RELWORD;
	case 8: return R_RELBYTE;
	}
    }
  return R_RELLONG;
}

STAT_REL reloc_howto_type *
m68k_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  switch (code)
    {
    default:			return NULL;
    case BFD_RELOC_8:		return m68kcoff_howto_table + 0;
    case BFD_RELOC_16:		return m68kcoff_howto_table + 1;
    case BFD_RELOC_CTOR:
    case BFD_RELOC_32:		return m68kcoff_howto_table + 2;
    case BFD_RELOC_8_PCREL:	return m68kcoff_howto_table + 3;
    case BFD_RELOC_16_PCREL:	return m68kcoff_howto_table + 4;
    case BFD_RELOC_32_PCREL:	return m68kcoff_howto_table + 5;
      /* FIXME: There doesn't seem to be a code for R_RELLONG_NEG.  */
    }
  /*NOTREACHED*/
}

#endif /* not ONLY_DECLARE_RELOCS */

#define RTYPE2HOWTO(internal, relocentry) \
  m68k_rtype2howto(internal, (relocentry)->r_type)

#define SELECT_RELOC(external, internal) \
  external.r_type = m68k_howto2rtype (internal)

#define coff_bfd_reloc_type_lookup m68k_reloc_type_lookup

#ifndef COFF_COMMON_ADDEND
#ifndef coff_rtype_to_howto

#define coff_rtype_to_howto m68kcoff_rtype_to_howto

static reloc_howto_type *m68kcoff_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));

static reloc_howto_type *
m68kcoff_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp;
{
  arelent relent;
  reloc_howto_type *howto;

  RTYPE2HOWTO (&relent, rel);

  howto = relent.howto;

  if (howto->pc_relative)
    *addendp += sec->vma;

  return howto;
}

#endif /* ! defined (coff_rtype_to_howto) */
#endif /* ! defined (COFF_COMMON_ADDEND) */

#ifdef COFF_COMMON_ADDEND

/* If COFF_COMMON_ADDEND is defined, then when using m68k COFF the
   value stored in the .text section for a reference to a common
   symbol is the value itself plus any desired offset.  (taken from
   work done by Ian Taylor, Cygnus Support, for I386 COFF).  */

/* If we are producing relocatable output, we need to do some
   adjustments to the object file that are not done by the
   bfd_perform_relocation function.  This function is called by every
   reloc type to make any required adjustments.  */

static bfd_reloc_status_type
m68kcoff_common_addend_special_fn (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  symvalue diff;

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  if (bfd_is_com_section (symbol->section))
    {
      /* We are relocating a common symbol.  The current value in the
	 object file is ORIG + OFFSET, where ORIG is the value of the
	 common symbol as seen by the object file when it was compiled
	 (this may be zero if the symbol was undefined) and OFFSET is
	 the offset into the common symbol (normally zero, but may be
	 non-zero when referring to a field in a common structure).
	 ORIG is the negative of reloc_entry->addend, which is set by
	 the CALC_ADDEND macro below.  We want to replace the value in
	 the object file with NEW + OFFSET, where NEW is the value of
	 the common symbol which we are going to put in the final
	 object file.  NEW is symbol->value.  */
      diff = symbol->value + reloc_entry->addend;
    }
  else
    {
      /* For some reason bfd_perform_relocation always effectively
	 ignores the addend for a COFF target when producing
	 relocatable output.  This seems to be always wrong for 386
	 COFF, so we handle the addend here instead.  */
      diff = reloc_entry->addend;
    }

#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))

  if (diff != 0)
    {
      reloc_howto_type *howto = reloc_entry->howto;
      unsigned char *addr = (unsigned char *) data + reloc_entry->address;

      switch (howto->size)
	{
	case 0:
	  {
	    char x = bfd_get_8 (abfd, addr);
	    DOIT (x);
	    bfd_put_8 (abfd, x, addr);
	  }
	  break;

	case 1:
	  {
	    short x = bfd_get_16 (abfd, addr);
	    DOIT (x);
	    bfd_put_16 (abfd, (bfd_vma) x, addr);
	  }
	  break;

	case 2:
	  {
	    long x = bfd_get_32 (abfd, addr);
	    DOIT (x);
	    bfd_put_32 (abfd, (bfd_vma) x, addr);
	  }
	  break;

	default:
	  abort ();
	}
    }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}

/* Compute the addend of a reloc.  If the reloc is to a common symbol,
   the object file contains the value of the common symbol.  By the
   time this is called, the linker may be using a different symbol
   from a different object file with a different value.  Therefore, we
   hack wildly to locate the original symbol from this file so that we
   can make the correct adjustment.  This macro sets coffsym to the
   symbol from the original file, and uses it to set the addend value
   correctly.  If this is not a common symbol, the usual addend
   calculation is done, except that an additional tweak is needed for
   PC relative relocs.
   FIXME: This macro refers to symbols and asect; these are from the
   calling function, not the macro arguments.  */

#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
  {								\
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
      coffsym = (obj_symbols (abfd)				\
	         + (cache_ptr->sym_ptr_ptr - symbols));		\
    else if (ptr)						\
      coffsym = coff_symbol_from (abfd, ptr);			\
    if (coffsym != (coff_symbol_type *) NULL			\
	&& coffsym->native->u.syment.n_scnum == 0)		\
      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
	     && ptr->section != (asection *) NULL)		\
      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
    else							\
      cache_ptr->addend = 0;					\
    if (ptr && (reloc.r_type == R_PCRBYTE			\
		|| reloc.r_type == R_PCRWORD			\
		|| reloc.r_type == R_PCRLONG))			\
      cache_ptr->addend += asect->vma;				\
  }

#ifndef coff_rtype_to_howto

/* coff-m68k.c uses the special COFF backend linker.  We need to
   adjust common symbols.  */

static reloc_howto_type *
m68kcoff_common_addend_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
{
  arelent relent;
  reloc_howto_type *howto;

  RTYPE2HOWTO (&relent, rel);

  howto = relent.howto;

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
      *addendp -= sym->n_value;
    }

  /* If the output symbol is common (in which case this must be a
     relocatable link), we need to add in the final size of the
     common symbol.  */
  if (h != NULL && h->root.type == bfd_link_hash_common)
    *addendp += h->root.u.c.size;

  return howto;
}

#define coff_rtype_to_howto m68kcoff_common_addend_rtype_to_howto

#endif /* ! defined (coff_rtype_to_howto) */

#endif /* COFF_COMMON_ADDEND */

#if !defined ONLY_DECLARE_RELOCS && ! defined STATIC_RELOCS
/* Given a .data section and a .emreloc in-memory section, store
   relocation information into the .emreloc section which can be
   used at runtime to relocate the section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_m68k_coff_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
{
  char *extsyms;
  bfd_size_type symesz;
  struct internal_reloc *irel, *irelend;
  bfd_byte *p;
  bfd_size_type amt;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  extsyms = obj_coff_external_syms (abfd);
  symesz = bfd_coff_symesz (abfd);

  irel = _bfd_coff_read_internal_relocs (abfd, datasec, TRUE, NULL, FALSE,
					 NULL);
  irelend = irel + datasec->reloc_count;

  amt = (bfd_size_type) datasec->reloc_count * 12;
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, amt);
  if (relsec->contents == NULL)
    return FALSE;

  p = relsec->contents;

  for (; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
       reloc section.  The longword will be the address in the data
       section which must be relocated.  It is followed by the name
       of the target section NUL-padded or truncated to 8
       characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if (irel->r_type != R_RELLONG)
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (irel->r_symndx == -1)
	targetsec = bfd_abs_section_ptr;
      else
	{
	  struct coff_link_hash_entry *h;

	  h = obj_coff_sym_hashes (abfd)[irel->r_symndx];
	  if (h == NULL)
	    {
	      struct internal_syment isym;

	      bfd_coff_swap_sym_in (abfd, extsyms + symesz * irel->r_symndx,
				    &isym);
	      targetsec = coff_section_from_bfd_index (abfd, isym.n_scnum);
	    }
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	  else
	    targetsec = NULL;
	}

      bfd_put_32 (abfd,
		  (irel->r_vaddr - datasec->vma + datasec->output_offset), p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy (p + 4, targetsec->output_section->name, 8);
    }

  return TRUE;
}
#endif /* neither ONLY_DECLARE_RELOCS not STATIC_RELOCS  */

#define coff_bfd_is_local_label_name m68k_coff_is_local_label_name

#define coff_relocate_section _bfd_coff_generic_relocate_section

#include "coffcode.h"

#ifndef TARGET_SYM
#define TARGET_SYM m68kcoff_vec
#endif

#ifndef TARGET_NAME
#define TARGET_NAME "coff-m68k"
#endif

#ifdef NAMES_HAVE_UNDERSCORE
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, '_', NULL, COFF_SWAP_TABLE)
#else
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, 0, NULL, COFF_SWAP_TABLE)
#endif
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d253 1
a253 1
/* If we are producing relocateable output, we need to do some
d293 1
a293 1
	 relocateable output.  This seems to be always wrong for 386
d412 1
a412 1
     relocateable link), we need to add in the final size of the
d448 1
a448 1
  BFD_ASSERT (! info->relocateable);
d535 1
a535 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, '_', NULL)
d537 1
a537 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, 0, NULL)
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000
d70 2
a71 1
static boolean m68k_coff_is_local_label_name PARAMS ((bfd *, const char *));
d77 1
a77 1
static boolean
d83 1
a83 1
    return true;
d103 9
a111 9
{
  HOWTO(R_RELBYTE,	       0,  0,  	8,  false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "8",	true, 0x000000ff,0x000000ff, false),
  HOWTO(R_RELWORD,	       0,  1, 	16, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "16",	true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_RELLONG,	       0,  2, 	32, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "32",	true, 0xffffffff,0xffffffff, false),
  HOWTO(R_PCRBYTE,	       0,  0, 	8,  true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP8",    true, 0x000000ff,0x000000ff, false),
  HOWTO(R_PCRWORD,	       0,  1, 	16, true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP16",   true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_PCRLONG,	       0,  2, 	32, true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP32",   true, 0xffffffff,0xffffffff, false),
  HOWTO(R_RELLONG_NEG,	       0,  -2, 	32, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "-32",	true, 0xffffffff,0xffffffff, false),
};
d127 1
d129 3
a131 1
static
d133 7
a139 1
void
d145 9
a153 9
  {
   case R_RELBYTE:	internal->howto = m68kcoff_howto_table + 0; break;
   case R_RELWORD:	internal->howto = m68kcoff_howto_table + 1; break;
   case R_RELLONG:	internal->howto = m68kcoff_howto_table + 2; break;
   case R_PCRBYTE:	internal->howto = m68kcoff_howto_table + 3; break;
   case R_PCRWORD:	internal->howto = m68kcoff_howto_table + 4; break;
   case R_PCRLONG:	internal->howto = m68kcoff_howto_table + 5; break;
   case R_RELLONG_NEG:	internal->howto = m68kcoff_howto_table + 6; break;
  }
d156 1
a156 4
#ifdef STATIC_RELOCS
static
#endif
int
a160 2
  {
    switch (internal->bitsize)
d162 6
a167 3
     case 32: return R_PCRLONG;
     case 16: return R_PCRWORD;
     case 8: return R_PCRBYTE;
a168 1
  }
d170 8
a177 8
  {
    switch (internal->bitsize)
     {
      case 32: return R_RELLONG;
      case 16: return R_RELWORD;
      case 8: return R_RELBYTE;
     }
  }
d181 1
a181 4
#ifdef STATIC_RELOCS
static
#endif
reloc_howto_type *
d320 1
a320 1
	    bfd_put_16 (abfd, x, addr);
d328 1
a328 1
	    bfd_put_32 (abfd, x, addr);
d434 1
a434 1
boolean
d446 1
d453 1
a453 1
    return true;
d458 1
a458 1
  irel = _bfd_coff_read_internal_relocs (abfd, datasec, true, NULL, false,
d462 2
a463 1
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
d465 1
a465 1
    return false;
d484 1
a484 1
	  return false;
d516 1
a516 1
  return true;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1999
d100 1
a100 1
reloc_howto_type m68kcoff_howto_table[] = 
d133 1
a133 1
  switch (relocentry) 
d148 1
a148 1
int 
d152 1
a152 1
  if (internal->pc_relative) 
d154 1
a154 1
    switch (internal->bitsize) 
d161 1
a161 1
  else 
d163 1
a163 1
    switch (internal->bitsize) 
d170 1
a170 1
  return R_RELLONG;    
a215 1
/*ARGSUSED*/
a375 1
/*ARGSUSED*/
d420 92
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a24 1
#include "obstack.h"
d29 20
a48 3
#ifndef LYNX_SPECIAL_FN
#define LYNX_SPECIAL_FN 0
#endif
d57 30
d92 1
d97 3
d102 7
a108 7
  HOWTO(R_RELBYTE,	       0,  0,  	8,  false, 0, complain_overflow_bitfield, LYNX_SPECIAL_FN, "8",	true, 0x000000ff,0x000000ff, false),
  HOWTO(R_RELWORD,	       0,  1, 	16, false, 0, complain_overflow_bitfield, LYNX_SPECIAL_FN, "16",	true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_RELLONG,	       0,  2, 	32, false, 0, complain_overflow_bitfield, LYNX_SPECIAL_FN, "32",	true, 0xffffffff,0xffffffff, false),
  HOWTO(R_PCRBYTE,	       0,  0, 	8,  true,  0, complain_overflow_signed, LYNX_SPECIAL_FN, "DISP8",    true, 0x000000ff,0x000000ff, false),
  HOWTO(R_PCRWORD,	       0,  1, 	16, true,  0, complain_overflow_signed, LYNX_SPECIAL_FN, "DISP16",   true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_PCRLONG,	       0,  2, 	32, true,  0, complain_overflow_signed, LYNX_SPECIAL_FN, "DISP32",   true, 0xffffffff,0xffffffff, false),
  HOWTO(R_RELLONG_NEG,	       0,  -2, 	32, false, 0, complain_overflow_bitfield, LYNX_SPECIAL_FN, "-32",	true, 0xffffffff,0xffffffff, false),
d125 3
d145 3
d173 3
d178 1
a178 1
     bfd *abfd;
d202 1
a202 1
  external.r_type = m68k_howto2rtype(internal);
d206 1
d219 38
d258 123
d397 17
d417 2
d421 4
d429 2
a430 5
const bfd_target 
#ifdef TARGET_SYM
  TARGET_SYM =
#else
  m68kcoff_vec =
d432 3
a434 5
{
#ifdef TARGET_NAME
  TARGET_NAME,
#else
  "coff-m68k",			/* name */
a435 3
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
a436 5
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d438 1
a438 1
  '_',
d440 1
a440 1
  0,				/* leading underscore */
a441 28
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

 {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
   bfd_generic_archive_p, _bfd_dummy_target},
 {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
   bfd_false},
 {bfd_false, coff_write_object_contents, /* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE
 };
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d146 34
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d35 1
d38 1
d163 2
a164 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a34 1
#ifndef COFF_PAGE_SIZE
a36 1
#endif
d161 2
a162 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a145 34
#ifndef coff_rtype_to_howto

#define coff_rtype_to_howto m68kcoff_rtype_to_howto

static reloc_howto_type *m68kcoff_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));

/*ARGSUSED*/
static reloc_howto_type *
m68kcoff_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
{
  arelent relent;
  reloc_howto_type *howto;

  RTYPE2HOWTO (&relent, rel);

  howto = relent.howto;

  if (howto->pc_relative)
    *addendp += sec->vma;

  return howto;
}

#endif /* ! defined (coff_rtype_to_howto) */

@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d24 1
d29 3
a31 20
/* This source file is compiled multiple times for various m68k COFF
   variants.  The following macros control its behaviour:

   TARGET_SYM
     The C name of the BFD target vector.  The default is m68kcoff_vec.
   TARGET_NAME
     The user visible target name.  The default is "coff-m68k".
   NAMES_HAVE_UNDERSCORE
     Whether symbol names have an underscore.
   ONLY_DECLARE_RELOCS
     Only declare the relocation howto array.  Don't actually compile
     it.  The actual array will be picked up in another version of the
     file.
   STATIC_RELOCS
     Make the relocation howto array, and associated functions, static.
   COFF_COMMON_ADDEND
     If this is defined, then, for a relocation against a common
     symbol, the object file holds the value (the size) of the common
     symbol.  If this is not defined, then, for a relocation against a
     common symbol, the object file holds zero.  */
a39 30
#ifndef COFF_COMMON_ADDEND
#define RELOC_SPECIAL_FN 0
#else
static bfd_reloc_status_type m68kcoff_common_addend_special_fn
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type *m68kcoff_common_addend_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
#define RELOC_SPECIAL_FN m68kcoff_common_addend_special_fn
#endif

static boolean m68k_coff_is_local_label_name PARAMS ((bfd *, const char *));

/* On the delta, a symbol starting with L% is local.  We won't see
   such a symbol on other platforms, so it should be safe to always
   consider it local here.  */

static boolean
m68k_coff_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == 'L' && name[1] == '%')
    return true;

  return _bfd_coff_is_local_label_name (abfd, name);
}

#ifndef STATIC_RELOCS
a44 1
#endif
a48 3
#ifdef STATIC_RELOCS
static
#endif
d51 7
a57 7
  HOWTO(R_RELBYTE,	       0,  0,  	8,  false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "8",	true, 0x000000ff,0x000000ff, false),
  HOWTO(R_RELWORD,	       0,  1, 	16, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "16",	true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_RELLONG,	       0,  2, 	32, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "32",	true, 0xffffffff,0xffffffff, false),
  HOWTO(R_PCRBYTE,	       0,  0, 	8,  true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP8",    true, 0x000000ff,0x000000ff, false),
  HOWTO(R_PCRWORD,	       0,  1, 	16, true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP16",   true, 0x0000ffff,0x0000ffff, false),
  HOWTO(R_PCRLONG,	       0,  2, 	32, true,  0, complain_overflow_signed, RELOC_SPECIAL_FN, "DISP32",   true, 0xffffffff,0xffffffff, false),
  HOWTO(R_RELLONG_NEG,	       0,  -2, 	32, false, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "-32",	true, 0xffffffff,0xffffffff, false),
a73 3
#ifdef STATIC_RELOCS
static
#endif
a90 3
#ifdef STATIC_RELOCS
static
#endif
a115 3
#ifdef STATIC_RELOCS
static
#endif
d142 1
a142 1
  external.r_type = m68k_howto2rtype (internal)
a145 1
#ifndef COFF_COMMON_ADDEND
a178 184
#endif /* ! defined (COFF_COMMON_ADDEND) */

#ifdef COFF_COMMON_ADDEND

/* If COFF_COMMON_ADDEND is defined, then when using m68k COFF the
   value stored in the .text section for a reference to a common
   symbol is the value itself plus any desired offset.  (taken from
   work done by Ian Taylor, Cygnus Support, for I386 COFF).  */

/* If we are producing relocateable output, we need to do some
   adjustments to the object file that are not done by the
   bfd_perform_relocation function.  This function is called by every
   reloc type to make any required adjustments.  */

static bfd_reloc_status_type
m68kcoff_common_addend_special_fn (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  symvalue diff;

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  if (bfd_is_com_section (symbol->section))
    {
      /* We are relocating a common symbol.  The current value in the
	 object file is ORIG + OFFSET, where ORIG is the value of the
	 common symbol as seen by the object file when it was compiled
	 (this may be zero if the symbol was undefined) and OFFSET is
	 the offset into the common symbol (normally zero, but may be
	 non-zero when referring to a field in a common structure).
	 ORIG is the negative of reloc_entry->addend, which is set by
	 the CALC_ADDEND macro below.  We want to replace the value in
	 the object file with NEW + OFFSET, where NEW is the value of
	 the common symbol which we are going to put in the final
	 object file.  NEW is symbol->value.  */
      diff = symbol->value + reloc_entry->addend;
    }
  else
    {
      /* For some reason bfd_perform_relocation always effectively
	 ignores the addend for a COFF target when producing
	 relocateable output.  This seems to be always wrong for 386
	 COFF, so we handle the addend here instead.  */
      diff = reloc_entry->addend;
    }

#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))

  if (diff != 0)
    {
      reloc_howto_type *howto = reloc_entry->howto;
      unsigned char *addr = (unsigned char *) data + reloc_entry->address;

      switch (howto->size)
	{
	case 0:
	  {
	    char x = bfd_get_8 (abfd, addr);
	    DOIT (x);
	    bfd_put_8 (abfd, x, addr);
	  }
	  break;

	case 1:
	  {
	    short x = bfd_get_16 (abfd, addr);
	    DOIT (x);
	    bfd_put_16 (abfd, x, addr);
	  }
	  break;

	case 2:
	  {
	    long x = bfd_get_32 (abfd, addr);
	    DOIT (x);
	    bfd_put_32 (abfd, x, addr);
	  }
	  break;

	default:
	  abort ();
	}
    }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}

/* Compute the addend of a reloc.  If the reloc is to a common symbol,
   the object file contains the value of the common symbol.  By the
   time this is called, the linker may be using a different symbol
   from a different object file with a different value.  Therefore, we
   hack wildly to locate the original symbol from this file so that we
   can make the correct adjustment.  This macro sets coffsym to the
   symbol from the original file, and uses it to set the addend value
   correctly.  If this is not a common symbol, the usual addend
   calculation is done, except that an additional tweak is needed for
   PC relative relocs.
   FIXME: This macro refers to symbols and asect; these are from the
   calling function, not the macro arguments.  */

#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
  {								\
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
      coffsym = (obj_symbols (abfd)				\
	         + (cache_ptr->sym_ptr_ptr - symbols));		\
    else if (ptr)						\
      coffsym = coff_symbol_from (abfd, ptr);			\
    if (coffsym != (coff_symbol_type *) NULL			\
	&& coffsym->native->u.syment.n_scnum == 0)		\
      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
	     && ptr->section != (asection *) NULL)		\
      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
    else							\
      cache_ptr->addend = 0;					\
    if (ptr && (reloc.r_type == R_PCRBYTE			\
		|| reloc.r_type == R_PCRWORD			\
		|| reloc.r_type == R_PCRLONG))			\
      cache_ptr->addend += asect->vma;				\
  }

#ifndef coff_rtype_to_howto

/* coff-m68k.c uses the special COFF backend linker.  We need to
   adjust common symbols.  */

/*ARGSUSED*/
static reloc_howto_type *
m68kcoff_common_addend_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
{
  arelent relent;
  reloc_howto_type *howto;

  RTYPE2HOWTO (&relent, rel);

  howto = relent.howto;

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
      *addendp -= sym->n_value;
    }

  /* If the output symbol is common (in which case this must be a
     relocateable link), we need to add in the final size of the
     common symbol.  */
  if (h != NULL && h->root.type == bfd_link_hash_common)
    *addendp += h->root.u.c.size;

  return howto;
}

#define coff_rtype_to_howto m68kcoff_common_addend_rtype_to_howto

#endif /* ! defined (coff_rtype_to_howto) */

#endif /* COFF_COMMON_ADDEND */

#define coff_bfd_is_local_label_name m68k_coff_is_local_label_name
d184 5
a188 6
#ifndef TARGET_SYM
#define TARGET_SYM m68kcoff_vec
#endif

#ifndef TARGET_NAME
#define TARGET_NAME "coff-m68k"
a189 2

const bfd_target TARGET_SYM =
d191 1
d193 3
d237 1
a237 1
};
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1999
   Free Software Foundation, Inc.
d177 1
a177 1
     bfd *abfd ATTRIBUTE_UNUSED;
d218 1
a218 1
     bfd *abfd ATTRIBUTE_UNUSED;
d221 2
a222 2
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
d260 1
a260 1
     asection *input_section ATTRIBUTE_UNUSED;
d262 1
a262 1
     char **error_message ATTRIBUTE_UNUSED;
d379 1
a379 1
     bfd *abfd ATTRIBUTE_UNUSED;
d436 12
d449 1
a449 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, '_', NULL)
d451 1
a451 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, 0, NULL)
d453 28
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000
d100 1
a100 1
reloc_howto_type m68kcoff_howto_table[] =
d133 1
a133 1
  switch (relocentry)
d148 1
a148 1
int
d152 1
a152 1
  if (internal->pc_relative)
d154 1
a154 1
    switch (internal->bitsize)
d161 1
a161 1
  else
d163 1
a163 1
    switch (internal->bitsize)
d170 1
a170 1
  return R_RELLONG;
d216 1
d377 1
a421 92

#if !defined ONLY_DECLARE_RELOCS && ! defined STATIC_RELOCS
/* Given a .data section and a .emreloc in-memory section, store
   relocation information into the .emreloc section which can be
   used at runtime to relocate the section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

boolean
bfd_m68k_coff_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
{
  char *extsyms;
  bfd_size_type symesz;
  struct internal_reloc *irel, *irelend;
  bfd_byte *p;

  BFD_ASSERT (! info->relocateable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return true;

  extsyms = obj_coff_external_syms (abfd);
  symesz = bfd_coff_symesz (abfd);

  irel = _bfd_coff_read_internal_relocs (abfd, datasec, true, NULL, false,
					 NULL);
  irelend = irel + datasec->reloc_count;

  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
  if (relsec->contents == NULL)
    return false;

  p = relsec->contents;

  for (; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
       reloc section.  The longword will be the address in the data
       section which must be relocated.  It is followed by the name
       of the target section NUL-padded or truncated to 8
       characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if (irel->r_type != R_RELLONG)
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      if (irel->r_symndx == -1)
	targetsec = bfd_abs_section_ptr;
      else
	{
	  struct coff_link_hash_entry *h;

	  h = obj_coff_sym_hashes (abfd)[irel->r_symndx];
	  if (h == NULL)
	    {
	      struct internal_syment isym;

	      bfd_coff_swap_sym_in (abfd, extsyms + symesz * irel->r_symndx,
				    &isym);
	      targetsec = coff_section_from_bfd_index (abfd, isym.n_scnum);
	    }
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	  else
	    targetsec = NULL;
	}

      bfd_put_32 (abfd,
		  (irel->r_vaddr - datasec->vma + datasec->output_offset), p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy (p + 4, targetsec->output_section->name, 8);
    }

  return true;
}
#endif /* neither ONLY_DECLARE_RELOCS not STATIC_RELOCS  */
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000, 2001, 2002
d69 1
a69 2
static bfd_boolean m68k_coff_is_local_label_name
  PARAMS ((bfd *, const char *));
d75 1
a75 1
static bfd_boolean
d81 1
a81 1
    return TRUE;
d101 9
a109 9
  {
    HOWTO (R_RELBYTE,	       0,  0,  	8,  FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "8",	TRUE, 0x000000ff,0x000000ff, FALSE),
    HOWTO (R_RELWORD,	       0,  1, 	16, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
    HOWTO (R_RELLONG,	       0,  2, 	32, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "32",	TRUE, 0xffffffff,0xffffffff, FALSE),
    HOWTO (R_PCRBYTE,	       0,  0, 	8,  TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP8",    TRUE, 0x000000ff,0x000000ff, FALSE),
    HOWTO (R_PCRWORD,	       0,  1, 	16, TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP16",   TRUE, 0x0000ffff,0x0000ffff, FALSE),
    HOWTO (R_PCRLONG,	       0,  2, 	32, TRUE,  0, complain_overflow_signed,   RELOC_SPECIAL_FN, "DISP32",   TRUE, 0xffffffff,0xffffffff, FALSE),
    HOWTO (R_RELLONG_NEG,      0, -2, 	32, FALSE, 0, complain_overflow_bitfield, RELOC_SPECIAL_FN, "-32",	TRUE, 0xffffffff,0xffffffff, FALSE),
  };
a124 1

d126 1
a126 3
#define STAT_REL static
#else
#define STAT_REL
d128 1
a128 7

STAT_REL reloc_howto_type * m68k_reloc_type_lookup PARAMS ((bfd *, bfd_reloc_code_real_type));
STAT_REL int m68k_howto2rtype PARAMS ((reloc_howto_type *));
STAT_REL void m68k_rtype2howto PARAMS ((arelent *, int));


STAT_REL void
d134 9
a142 9
    {
    case R_RELBYTE:	internal->howto = m68kcoff_howto_table + 0; break;
    case R_RELWORD:	internal->howto = m68kcoff_howto_table + 1; break;
    case R_RELLONG:	internal->howto = m68kcoff_howto_table + 2; break;
    case R_PCRBYTE:	internal->howto = m68kcoff_howto_table + 3; break;
    case R_PCRWORD:	internal->howto = m68kcoff_howto_table + 4; break;
    case R_PCRLONG:	internal->howto = m68kcoff_howto_table + 5; break;
    case R_RELLONG_NEG:	internal->howto = m68kcoff_howto_table + 6; break;
    }
d145 4
a148 1
STAT_REL int
d153 2
d156 3
a158 6
      switch (internal->bitsize)
	{
	case 32: return R_PCRLONG;
	case 16: return R_PCRWORD;
	case 8: return R_PCRBYTE;
	}
d160 1
d162 8
a169 8
    {
      switch (internal->bitsize)
	{
	case 32: return R_RELLONG;
	case 16: return R_RELWORD;
	case 8: return R_RELBYTE;
	}
    }
d173 4
a176 1
STAT_REL reloc_howto_type *
d315 1
a315 1
	    bfd_put_16 (abfd, (bfd_vma) x, addr);
d323 1
a323 1
	    bfd_put_32 (abfd, (bfd_vma) x, addr);
d429 1
a429 1
bfd_boolean
a440 1
  bfd_size_type amt;
d447 1
a447 1
    return TRUE;
d452 1
a452 1
  irel = _bfd_coff_read_internal_relocs (abfd, datasec, TRUE, NULL, FALSE,
d456 1
a456 2
  amt = (bfd_size_type) datasec->reloc_count * 12;
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, amt);
d458 1
a458 1
    return FALSE;
d477 1
a477 1
	  return FALSE;
d509 1
a509 1
  return TRUE;
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d253 1
a253 1
/* If we are producing relocatable output, we need to do some
d293 1
a293 1
	 relocatable output.  This seems to be always wrong for 386
d412 1
a412 1
     relocatable link), we need to add in the final size of the
d448 1
a448 1
  BFD_ASSERT (! info->relocatable);
d535 1
a535 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, '_', NULL, COFF_SWAP_TABLE)
d537 1
a537 1
CREATE_BIG_COFF_TARGET_VEC (TARGET_SYM, TARGET_NAME, D_PAGED, 0, 0, NULL, COFF_SWAP_TABLE)
@


