head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.02;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.19;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.04;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.32.35;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.42.45;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.20;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.20;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.40;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.11.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.20;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.19.32;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.09;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.11;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for a.out.adobe binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.  Based on bout.c.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#include "aout/adobe.h"

#include "aout/stab_gnu.h"
#include "libaout.h"		/* BFD a.out internal data structures.  */

/* Forward decl.  */
extern const bfd_target a_out_adobe_vec;

static const bfd_target *aout_adobe_callback
  PARAMS ((bfd *));
extern bfd_boolean aout_32_slurp_symbol_table
  PARAMS ((bfd *abfd));
extern bfd_boolean aout_32_write_syms
  PARAMS ((bfd *));
static void aout_adobe_write_section
  PARAMS ((bfd *abfd, sec_ptr sect));
static const bfd_target * aout_adobe_object_p
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_mkobject
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_set_section_contents
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
static bfd_boolean aout_adobe_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static int     aout_adobe_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

/* Swaps the information in an executable header taken from a raw byte
   stream memory image, into the internal exec_header structure.  */

void aout_adobe_swap_exec_header_in
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));

void
aout_adobe_swap_exec_header_in (abfd, raw_bytes, execp)
     bfd *abfd;
     struct external_exec *raw_bytes;
     struct internal_exec *execp;
{
  struct external_exec *bytes = (struct external_exec *) raw_bytes;

  /* Now fill in fields in the execp, from the bytes in the raw data.  */
  execp->a_info   = H_GET_32 (abfd, bytes->e_info);
  execp->a_text   = GET_WORD (abfd, bytes->e_text);
  execp->a_data   = GET_WORD (abfd, bytes->e_data);
  execp->a_bss    = GET_WORD (abfd, bytes->e_bss);
  execp->a_syms   = GET_WORD (abfd, bytes->e_syms);
  execp->a_entry  = GET_WORD (abfd, bytes->e_entry);
  execp->a_trsize = GET_WORD (abfd, bytes->e_trsize);
  execp->a_drsize = GET_WORD (abfd, bytes->e_drsize);
}

/* Swaps the information in an internal exec header structure into the
   supplied buffer ready for writing to disk.  */

void aout_adobe_swap_exec_header_out
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));

void
aout_adobe_swap_exec_header_out (abfd, execp, raw_bytes)
     bfd *abfd;
     struct internal_exec *execp;
     struct external_exec *raw_bytes;
{
  struct external_exec *bytes = (struct external_exec *) raw_bytes;

  /* Now fill in fields in the raw data, from the fields in the exec
     struct.  */
  H_PUT_32 (abfd, execp->a_info  , bytes->e_info);
  PUT_WORD (abfd, execp->a_text  , bytes->e_text);
  PUT_WORD (abfd, execp->a_data  , bytes->e_data);
  PUT_WORD (abfd, execp->a_bss   , bytes->e_bss);
  PUT_WORD (abfd, execp->a_syms  , bytes->e_syms);
  PUT_WORD (abfd, execp->a_entry , bytes->e_entry);
  PUT_WORD (abfd, execp->a_trsize, bytes->e_trsize);
  PUT_WORD (abfd, execp->a_drsize, bytes->e_drsize);
}

static const bfd_target *
aout_adobe_object_p (abfd)
     bfd *abfd;
{
  struct internal_exec anexec;
  struct external_exec exec_bytes;
  char *targ;
  bfd_size_type amt = EXEC_BYTES_SIZE;

  if (bfd_bread ((PTR) &exec_bytes, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  anexec.a_info = H_GET_32 (abfd, exec_bytes.e_info);

  /* Normally we just compare for the magic number.
     However, a bunch of Adobe tools aren't fixed up yet; they generate
     files using ZMAGIC(!).
     If the environment variable GNUTARGET is set to "a.out.adobe", we will
     take just about any a.out file as an Adobe a.out file.  FIXME!  */

  if (N_BADMAG (anexec))
    {
      targ = getenv ("GNUTARGET");
      if (targ && !strcmp (targ, a_out_adobe_vec.name))
	/* Just continue anyway, if specifically set to this format.  */
	;
      else
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}
    }

  aout_adobe_swap_exec_header_in (abfd, &exec_bytes, &anexec);
  return aout_32_some_aout_object_p (abfd, &anexec, aout_adobe_callback);
}

/* Finish up the opening of a b.out file for reading.  Fill in all the
   fields that are not handled by common code.  */

static const bfd_target *
aout_adobe_callback (abfd)
     bfd *abfd;
{
  struct internal_exec *execp = exec_hdr (abfd);
  asection *sect;
  struct external_segdesc ext[1];
  char *section_name;
  char try_again[30];	/* Name and number.  */
  char *newname;
  int trynum;
  flagword flags;

  /* Architecture and machine type -- unknown in this format.  */
  bfd_set_arch_mach (abfd, bfd_arch_unknown, 0L);

  /* The positions of the string table and symbol table.  */
  obj_str_filepos (abfd) = N_STROFF (*execp);
  obj_sym_filepos (abfd) = N_SYMOFF (*execp);

  /* Suck up the section information from the file, one section at a time.  */
  for (;;)
    {
      bfd_size_type amt = sizeof (*ext);
      if (bfd_bread ((PTR) ext, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);

	  return 0;
	}
      switch (ext->e_type[0])
	{
	case N_TEXT:
	  section_name = ".text";
	  flags = SEC_CODE | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
	  break;

	case N_DATA:
	  section_name = ".data";
	  flags = SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
	  break;

	case N_BSS:
	  section_name = ".bss";
	  flags = SEC_DATA | SEC_HAS_CONTENTS;
	  break;

	case 0:
	  goto no_more_sections;

	default:
	  (*_bfd_error_handler)
	    (_("%s: Unknown section type in a.out.adobe file: %x\n"),
	     bfd_archive_filename (abfd), ext->e_type[0]);
	  goto no_more_sections;
	}

      /* First one is called ".text" or whatever; subsequent ones are
	 ".text1", ".text2", ...  */
      bfd_set_error (bfd_error_no_error);
      sect = bfd_make_section (abfd, section_name);
      trynum = 0;

      while (!sect)
	{
	  if (bfd_get_error () != bfd_error_no_error)
	    /* Some other error -- slide into the sunset.  */
	    return 0;
	  sprintf (try_again, "%s%d", section_name, ++trynum);
	  sect = bfd_make_section (abfd, try_again);
	}

      /* Fix the name, if it is a sprintf'd name.  */
      if (sect->name == try_again)
	{
	  amt = strlen (sect->name);
	  newname = (char *) bfd_zalloc (abfd, amt);
	  if (newname == NULL)
	    return 0;
	  strcpy (newname, sect->name);
	  sect->name = newname;
	}

      /* Now set the section's attributes.  */
      bfd_set_section_flags (abfd, sect, flags);
      /* Assumed big-endian.  */
      sect->_raw_size = ((ext->e_size[0] << 8)
			 | ext->e_size[1] << 8
			 | ext->e_size[2]);
      sect->_cooked_size = sect->_raw_size;
      sect->vma = H_GET_32 (abfd, ext->e_virtbase);
      sect->filepos = H_GET_32 (abfd, ext->e_filebase);
      /* FIXME XXX alignment?  */

      /* Set relocation information for first section of each type.  */
      if (trynum == 0)
	switch (ext->e_type[0])
	  {
	  case N_TEXT:
	    sect->rel_filepos = N_TRELOFF (*execp);
	    sect->reloc_count = execp->a_trsize;
	    break;

	  case N_DATA:
	    sect->rel_filepos = N_DRELOFF (*execp);
	    sect->reloc_count = execp->a_drsize;
	    break;

	  default:
	    break;
	  }
    }
 no_more_sections:

  adata (abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata (abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata (abfd).page_size = 1; /* Not applicable.  */
  adata (abfd).segment_size = 1; /* Not applicable.  */
  adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;

  return abfd->xvec;
}

struct bout_data_struct
  {
    struct aoutdata a;
    struct internal_exec e;
  };

static bfd_boolean
aout_adobe_mkobject (abfd)
     bfd *abfd;
{
  struct bout_data_struct *rawptr;
  bfd_size_type amt = sizeof (struct bout_data_struct);

  rawptr = (struct bout_data_struct *) bfd_zalloc (abfd, amt);
  if (rawptr == NULL)
    return FALSE;

  abfd->tdata.bout_data = rawptr;
  exec_hdr (abfd) = &rawptr->e;

  adata (abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata (abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata (abfd).page_size = 1; /* Not applicable.  */
  adata (abfd).segment_size = 1; /* Not applicable.  */
  adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;

  return TRUE;
}

static bfd_boolean
aout_adobe_write_object_contents (abfd)
     bfd *abfd;
{
  struct external_exec swapped_hdr;
  static struct external_segdesc sentinel[1];	/* Initialized to zero.  */
  asection *sect;
  bfd_size_type amt;

  exec_hdr (abfd)->a_info = ZMAGIC;

  /* Calculate text size as total of text sections, etc.  */

  exec_hdr (abfd)->a_text = 0;
  exec_hdr (abfd)->a_data = 0;
  exec_hdr (abfd)->a_bss  = 0;
  exec_hdr (abfd)->a_trsize = 0;
  exec_hdr (abfd)->a_drsize = 0;

  for (sect = abfd->sections; sect; sect = sect->next)
    {
      if (sect->flags & SEC_CODE)
	{
	  exec_hdr (abfd)->a_text += sect->_raw_size;
	  exec_hdr (abfd)->a_trsize += sect->reloc_count *
	    sizeof (struct reloc_std_external);
	}
      else if (sect->flags & SEC_DATA)
	{
	  exec_hdr (abfd)->a_data += sect->_raw_size;
	  exec_hdr (abfd)->a_drsize += sect->reloc_count *
	    sizeof (struct reloc_std_external);
	}
      else if (sect->flags & SEC_ALLOC && !(sect->flags & SEC_LOAD))
	{
	  exec_hdr (abfd)->a_bss += sect->_raw_size;
	}
    }

  exec_hdr (abfd)->a_syms = bfd_get_symcount (abfd)
    * sizeof (struct external_nlist);
  exec_hdr (abfd)->a_entry = bfd_get_start_address (abfd);

  aout_adobe_swap_exec_header_out (abfd, exec_hdr (abfd), &swapped_hdr);

  amt = EXEC_BYTES_SIZE;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bwrite ((PTR) &swapped_hdr, amt, abfd) != amt)
    return FALSE;

  /* Now write out the section information.  Text first, data next, rest
     afterward.  */

  for (sect = abfd->sections; sect; sect = sect->next)
    if (sect->flags & SEC_CODE)
      aout_adobe_write_section (abfd, sect);

  for (sect = abfd->sections; sect; sect = sect->next)
    if (sect->flags & SEC_DATA)
      aout_adobe_write_section (abfd, sect);

  for (sect = abfd->sections; sect; sect = sect->next)
    if (!(sect->flags & (SEC_CODE | SEC_DATA)))
      aout_adobe_write_section (abfd, sect);

  /* Write final `sentinel` section header (with type of 0).  */
  amt = sizeof (*sentinel);
  if (bfd_bwrite ((PTR) sentinel, amt, abfd) != amt)
    return FALSE;

  /* Now write out reloc info, followed by syms and strings.  */
  if (bfd_get_symcount (abfd) != 0)
    {
      if (bfd_seek (abfd, (file_ptr) (N_SYMOFF (*exec_hdr (abfd))), SEEK_SET)
	  != 0)
	return FALSE;

      if (! aout_32_write_syms (abfd))
	return FALSE;

      if (bfd_seek (abfd, (file_ptr) (N_TRELOFF (*exec_hdr (abfd))), SEEK_SET)
	  != 0)
	return FALSE;

      for (sect = abfd->sections; sect; sect = sect->next)
	if (sect->flags & SEC_CODE)
	  if (!aout_32_squirt_out_relocs (abfd, sect))
	    return FALSE;

      if (bfd_seek (abfd, (file_ptr) (N_DRELOFF (*exec_hdr (abfd))), SEEK_SET)
	  != 0)
	return FALSE;

      for (sect = abfd->sections; sect; sect = sect->next)
	if (sect->flags & SEC_DATA)
	  if (!aout_32_squirt_out_relocs (abfd, sect))
	    return FALSE;
    }

  return TRUE;
}

static void
aout_adobe_write_section (abfd, sect)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr sect ATTRIBUTE_UNUSED;
{
  /* FIXME XXX */
}

static bfd_boolean
aout_adobe_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  file_ptr section_start;
  sec_ptr sect;

  /* Set by bfd.c handler.  */
  if (! abfd->output_has_begun)
    {
      /* Assign file offsets to sections.  Text sections are first, and
	 are contiguous.  Then data sections.  Everything else at the end.  */
      section_start = N_TXTOFF (ignore<-->me);

      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_CODE)
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}

      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_DATA)
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}

      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_HAS_CONTENTS &&
	      !(sect->flags & (SEC_CODE | SEC_DATA)))
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}
    }

  /* Regardless, once we know what we're doing, we might as well get
     going.  */
  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0)
    return FALSE;

  if (count == 0)
    return TRUE;

  return bfd_bwrite ((PTR) location, count, abfd) == count;
}

static bfd_boolean
aout_adobe_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
{
  if (! bfd_default_set_arch_mach (abfd, arch, machine))
    return FALSE;

  if (arch == bfd_arch_unknown
      || arch == bfd_arch_m68k)
    return TRUE;

  return FALSE;
}

static int
aout_adobe_sizeof_headers (ignore_abfd, ignore)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     bfd_boolean ignore ATTRIBUTE_UNUSED;
{
  return sizeof (struct internal_exec);
}

/* Build the transfer vector for Adobe A.Out files.  */

#define aout_32_close_and_cleanup aout_32_bfd_free_cached_info

#define aout_32_bfd_make_debug_symbol \
  ((asymbol *(*) PARAMS ((bfd *, void *, unsigned long))) bfd_nullvoidptr)

#define aout_32_bfd_reloc_type_lookup \
  ((reloc_howto_type *(*) \
    PARAMS ((bfd *, bfd_reloc_code_real_type))) bfd_nullvoidptr)

#define	aout_32_set_arch_mach		aout_adobe_set_arch_mach
#define	aout_32_set_section_contents	aout_adobe_set_section_contents

#define	aout_32_sizeof_headers		aout_adobe_sizeof_headers
#define aout_32_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define aout_32_get_section_contents_in_window _bfd_generic_get_section_contents_in_window
#define aout_32_bfd_relax_section       bfd_generic_relax_section
#define aout_32_bfd_gc_sections         bfd_generic_gc_sections
#define aout_32_bfd_merge_sections	bfd_generic_merge_sections
#define aout_32_bfd_discard_group	bfd_generic_discard_group
#define aout_32_bfd_link_hash_table_create \
  _bfd_generic_link_hash_table_create
#define aout_32_bfd_link_hash_table_free \
  _bfd_generic_link_hash_table_free
#define aout_32_bfd_link_add_symbols	_bfd_generic_link_add_symbols
#define aout_32_bfd_link_just_syms	_bfd_generic_link_just_syms
#define aout_32_bfd_final_link		_bfd_generic_final_link
#define aout_32_bfd_link_split_section	_bfd_generic_link_split_section

const bfd_target a_out_adobe_vec =
  {
    "a.out.adobe",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is unknown (big assumed) */
    BFD_ENDIAN_BIG,		/* hdr byte order is big */
    (HAS_RELOC | EXEC_P |	/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT ),
    /* section flags */
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_DATA | SEC_RELOC),
    '_',				/*  symbol leading char */
    ' ',				/* ar_pad_char */
    16,					/* ar_max_namelen */

    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, aout_adobe_object_p,	/* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
    {bfd_false, aout_adobe_mkobject,		/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, aout_adobe_write_object_contents,/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (aout_32),
    BFD_JUMP_TABLE_COPY (_bfd_generic),
    BFD_JUMP_TABLE_CORE (_bfd_nocore),
    BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd),
    BFD_JUMP_TABLE_SYMBOLS (aout_32),
    BFD_JUMP_TABLE_RELOCS (aout_32),
    BFD_JUMP_TABLE_WRITE (aout_32),
    BFD_JUMP_TABLE_LINK (aout_32),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

    NULL,

    (PTR) 0
  };
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002
d50 1
a50 1
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
d418 1
a418 1
     PTR location;
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000
d30 1
a30 1
#include "libaout.h"		/* BFD a.out internal data structures */
d35 20
a54 5
static const bfd_target *aout_adobe_callback PARAMS ((bfd *));

extern boolean aout_32_slurp_symbol_table PARAMS ((bfd *abfd));
extern boolean aout_32_write_syms PARAMS ((bfd *));
static void aout_adobe_write_section PARAMS ((bfd *abfd, sec_ptr sect));
d60 1
a60 2
  PARAMS ((bfd *abfd, struct external_exec *raw_bytes,
	   struct internal_exec *execp));
d71 1
a71 1
  execp->a_info   = bfd_h_get_32 (abfd, bytes->e_info);
d84 3
a86 4
PROTO(void, aout_adobe_swap_exec_header_out,
	  (bfd *abfd,
	   struct internal_exec *execp,
	   struct external_exec *raw_bytes));
d97 1
a97 1
  bfd_h_put_32 (abfd, execp->a_info  , bytes->e_info);
d114 1
d116 1
a116 2
  if (bfd_read ((PTR) &exec_bytes, 1, EXEC_BYTES_SIZE, abfd)
      != EXEC_BYTES_SIZE)
d123 1
a123 1
  anexec.a_info = bfd_h_get_32 (abfd, exec_bytes.e_info);
d159 1
a159 1
  char try_again[30];	/* name and number */
d165 1
a165 1
  bfd_set_arch_mach (abfd, bfd_arch_unknown, 0);
a171 1

d174 2
a175 1
      if (bfd_read ((PTR) ext, 1, sizeof (*ext), abfd) != sizeof (*ext))
d179 1
d205 1
a205 1
	     bfd_get_filename (abfd), ext->e_type[0]);
a210 1

d214 1
d227 2
a228 1
	  newname = (char *) bfd_zalloc (abfd, strlen (sect->name));
d239 2
a240 2
			 | ext->e_size[1] << 8)
	| ext->e_size[2];
d242 2
a243 2
      sect->vma = bfd_h_get_32 (abfd, ext->e_virtbase);
      sect->filepos = bfd_h_get_32 (abfd, ext->e_filebase);
d259 3
d275 5
a279 4
struct bout_data_struct {
  struct aoutdata a;
  struct internal_exec e;
};
d281 1
a281 1
static boolean
d286 1
d288 1
a288 1
  rawptr = (struct bout_data_struct *) bfd_zalloc (abfd, sizeof (struct bout_data_struct));
d290 1
a290 1
    return false;
d301 1
a301 1
  return true;
d304 1
a304 1
static boolean
d311 1
d349 1
d351 2
a352 3
      || (bfd_write ((PTR) &swapped_hdr, 1, EXEC_BYTES_SIZE, abfd)
	  != EXEC_BYTES_SIZE))
    return false;
d358 3
a360 6
    {
      if (sect->flags & SEC_CODE)
	{
	  aout_adobe_write_section (abfd, sect);
	}
    }
d362 3
a364 6
    {
      if (sect->flags & SEC_DATA)
	{
	  aout_adobe_write_section (abfd, sect);
	}
    }
d366 2
a367 6
    {
      if (!(sect->flags & (SEC_CODE | SEC_DATA)))
	{
	  aout_adobe_write_section (abfd, sect);
	}
    }
d370 3
a372 3
  if (bfd_write ((PTR) sentinel, 1, sizeof (*sentinel), abfd)
      != sizeof (*sentinel))
    return false;
d379 1
a379 1
	return false;
d382 1
a382 1
	return false;
d386 1
a386 1
	return false;
d389 3
a391 7
	{
	  if (sect->flags & SEC_CODE)
	    {
	      if (!aout_32_squirt_out_relocs (abfd, sect))
		return false;
	    }
	}
d395 1
a395 1
	return false;
d398 3
a400 7
	{
	  if (sect->flags & SEC_DATA)
	    {
	      if (!aout_32_squirt_out_relocs (abfd, sect))
		return false;
	    }
	}
d402 2
a403 1
  return true;
d414 1
a414 1
static boolean
d426 1
a426 1
  if (abfd->output_has_begun == false)
a429 1

d467 4
a470 1
    return false;
d472 1
a472 5
  if (count != 0)
    {
      return (bfd_write ((PTR) location, 1, count, abfd) == count) ? true : false;
    }
  return true;
d475 1
a475 1
static boolean
d482 1
a482 1
    return false;
d486 1
a486 1
    return true;
d488 1
a488 1
  return false;
d494 1
a494 1
     boolean ignore ATTRIBUTE_UNUSED;
d519 2
d523 2
d526 1
d530 37
a566 36
const bfd_target a_out_adobe_vec = {
  "a.out.adobe",		/* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is unknown (big assumed) */
  BFD_ENDIAN_BIG,		/* hdr byte order is big */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT ),
  /* section flags */
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_DATA | SEC_RELOC),
  '_',				/*  symbol leading char */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
  {_bfd_dummy_target, aout_adobe_object_p,	/* bfd_check_format */
   bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, aout_adobe_mkobject,	/* bfd_set_format */
   _bfd_generic_mkarchive, bfd_false},
  {bfd_false, aout_adobe_write_object_contents,	/* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (aout_32),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd),
  BFD_JUMP_TABLE_SYMBOLS (aout_32),
  BFD_JUMP_TABLE_RELOCS (aout_32),
  BFD_JUMP_TABLE_WRITE (aout_32),
  BFD_JUMP_TABLE_LINK (aout_32),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d568 1
a568 1
  NULL,
d570 2
a571 2
  (PTR) 0
};
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999
d31 2
a32 1
extern const bfd_target a_out_adobe_vec;		/* Forward decl */
d46 1
a46 1
	 
d53 1
a53 1
  struct external_exec *bytes = (struct external_exec *)raw_bytes;
d79 1
a79 1
  struct external_exec *bytes = (struct external_exec *)raw_bytes;
d81 2
a82 1
  /* Now fill in fields in the raw data, from the fields in the exec struct. */
a92 1

d102 6
a107 5
      != EXEC_BYTES_SIZE) {
    if (bfd_get_error () != bfd_error_system_call)
      bfd_set_error (bfd_error_wrong_format);
    return 0;
  }
d117 12
a128 10
  if (N_BADMAG (anexec)) {
    targ = getenv ("GNUTARGET");
    if (targ && !strcmp (targ, a_out_adobe_vec.name))
      ;		/* Just continue anyway, if specifically set to this format */
    else
      {
	bfd_set_error (bfd_error_wrong_format);
	return 0;
      }
  }
a133 1

d151 1
a151 1
  bfd_set_arch_mach(abfd, bfd_arch_unknown, 0);
d159 93
a251 84
  for (;;) {
    if (bfd_read ((PTR) ext, 1, sizeof (*ext), abfd) != sizeof (*ext)) {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return 0;
    }
    switch (ext->e_type[0]) {
    case N_TEXT:
      section_name = ".text";
      flags = SEC_CODE | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
      break;

    case N_DATA:
      section_name = ".data";
      flags = SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
      break;

    case N_BSS:
      section_name = ".bss";
      flags = SEC_DATA | SEC_HAS_CONTENTS;
      break;

    case 0:
      goto no_more_sections;

    default:
      (*_bfd_error_handler)
	(_("%s: Unknown section type in a.out.adobe file: %x\n"), 
	 bfd_get_filename (abfd), ext->e_type[0]);
      goto no_more_sections;
    }

    /* First one is called ".text" or whatever; subsequent ones are
       ".text1", ".text2", ... */

    bfd_set_error (bfd_error_no_error);
    sect = bfd_make_section (abfd, section_name);
    trynum = 0;
    while (!sect) {
      if (bfd_get_error () != bfd_error_no_error)
	return 0;	/* Some other error -- slide into the sunset */
      sprintf (try_again, "%s%d", section_name, ++trynum);
      sect = bfd_make_section (abfd, try_again);
    }

    /* Fix the name, if it is a sprintf'd name.  */
    if (sect->name == try_again) {
      newname = (char *) bfd_zalloc(abfd, strlen (sect->name));
      if (newname == NULL)
	return 0;
      strcpy (newname, sect->name);
      sect->name = newname;
    }

    /* Now set the section's attributes.  */
    bfd_set_section_flags (abfd, sect, flags);
    sect->_raw_size = ((ext->e_size[0] << 8)	/* Assumed big-endian */
		      | ext->e_size[1] << 8)
		      | ext->e_size[2];
    sect->_cooked_size = sect->_raw_size;
    sect->vma = bfd_h_get_32 (abfd, ext->e_virtbase);
    sect->filepos = bfd_h_get_32 (abfd, ext->e_filebase);
    /* FIXME XXX alignment? */

    /* Set relocation information for first section of each type.  */
    if (trynum == 0) switch (ext->e_type[0]) {
    case N_TEXT:
      sect->rel_filepos = N_TRELOFF (*execp);
      sect->reloc_count = execp->a_trsize;
      break;

    case N_DATA:
      sect->rel_filepos = N_DRELOFF (*execp);
      sect->reloc_count = execp->a_drsize;
      break;
    }
  }
no_more_sections:  

  adata(abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata(abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata(abfd).page_size = 1; /* Not applicable. */
  adata(abfd).segment_size = 1; /* Not applicable. */
  adata(abfd).exec_bytes_size = EXEC_BYTES_SIZE;
d257 2
a258 2
    struct aoutdata a;
    struct internal_exec e;
d269 1
a269 1
      return false;
d274 5
a278 5
  adata(abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata(abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata(abfd).page_size = 1; /* Not applicable. */
  adata(abfd).segment_size = 1; /* Not applicable. */
  adata(abfd).exec_bytes_size = EXEC_BYTES_SIZE;
a282 1

d288 1
a288 1
  static struct external_segdesc sentinel[1];	/* Initialized to zero */
d293 1
a293 1
  /* Calculate text size as total of text sections, etc. */
d301 18
a318 11
  for (sect = abfd->sections; sect; sect = sect->next) {
    if (sect->flags & SEC_CODE)	{
      exec_hdr (abfd)->a_text += sect->_raw_size;
      exec_hdr (abfd)->a_trsize += sect->reloc_count *
                                   sizeof (struct reloc_std_external);
    } else if (sect->flags & SEC_DATA)	{
      exec_hdr (abfd)->a_data += sect->_raw_size;
      exec_hdr (abfd)->a_drsize += sect->reloc_count *
                                   sizeof (struct reloc_std_external);
    } else if (sect->flags & SEC_ALLOC && !(sect->flags & SEC_LOAD)) {
      exec_hdr (abfd)->a_bss  += sect->_raw_size;
a319 1
  }
d322 1
a322 1
    				* sizeof (struct external_nlist);
d335 6
a340 3
  for (sect = abfd->sections; sect; sect = sect->next) {
    if (sect->flags & SEC_CODE)	{
      aout_adobe_write_section (abfd, sect);
d342 6
a347 4
  }
  for (sect = abfd->sections; sect; sect = sect->next) {
    if (sect->flags & SEC_DATA)	{
      aout_adobe_write_section (abfd, sect);
d349 6
a354 4
  }
  for (sect = abfd->sections; sect; sect = sect->next) {
    if (!(sect->flags & (SEC_CODE|SEC_DATA))) {
      aout_adobe_write_section (abfd, sect);
a355 1
  }
d362 2
a363 2
  /* Now write out reloc info, followed by syms and strings */
  if (bfd_get_symcount (abfd) != 0) 
d365 1
a365 1
      if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*exec_hdr(abfd))), SEEK_SET)
d372 1
a372 1
      if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*exec_hdr(abfd))), SEEK_SET)
d376 8
a383 6
      for (sect = abfd->sections; sect; sect = sect->next) {
        if (sect->flags & SEC_CODE)	{
          if (!aout_32_squirt_out_relocs (abfd, sect))
            return false;
        }
      }
d385 1
a385 1
      if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*exec_hdr(abfd))), SEEK_SET)
d389 8
a396 6
      for (sect = abfd->sections; sect; sect = sect->next) {
        if (sect->flags & SEC_DATA)	{
          if (!aout_32_squirt_out_relocs (abfd, sect))
            return false;
        }
      }
d420 5
a424 4
  if (abfd->output_has_begun == false) { /* set by bfd.c handler */

    /* Assign file offsets to sections.  Text sections are first, and
       are contiguous.  Then data sections.  Everything else at the end.  */
d426 1
a426 1
    section_start = N_TXTOFF (ignore<-->me);
d428 30
a457 6
    for (sect = abfd->sections; sect; sect = sect->next) {
      if (sect->flags & SEC_CODE)	{
        sect->filepos = section_start;
	/* FIXME:  Round to alignment */
	section_start += sect->_raw_size;
      }
d460 2
a461 19
    for (sect = abfd->sections; sect; sect = sect->next) {
      if (sect->flags & SEC_DATA)	{
        sect->filepos = section_start;
	/* FIXME:  Round to alignment */
	section_start += sect->_raw_size;
      }
    }

    for (sect = abfd->sections; sect; sect = sect->next) {
      if (sect->flags & SEC_HAS_CONTENTS &&
	  !(sect->flags & (SEC_CODE|SEC_DATA)))	{
        sect->filepos = section_start;
	/* FIXME:  Round to alignment */
	section_start += sect->_raw_size;
      }
    }
  }

  /* regardless, once we know what we're doing, we might as well get going */
d465 4
a468 3
  if (count != 0) {
    return (bfd_write ((PTR)location, 1, count, abfd) == count) ?true:false;
  }
d488 1
a488 1
static int 
d493 1
a493 1
  return sizeof(struct internal_exec);
a495 3



d522 1
a522 2
const bfd_target a_out_adobe_vec =
{
d537 2
a538 2
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
d540 3
a542 3
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
 {_bfd_dummy_target, aout_adobe_object_p, /* bfd_check_format */
d544 1
a544 1
 {bfd_false, aout_adobe_mkobject, /* bfd_set_format */
d546 1
a546 1
 {bfd_false, aout_adobe_write_object_contents, /* bfd_write_contents */
d549 9
a557 9
     BFD_JUMP_TABLE_GENERIC (aout_32),
     BFD_JUMP_TABLE_COPY (_bfd_generic),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd),
     BFD_JUMP_TABLE_SYMBOLS (aout_32),
     BFD_JUMP_TABLE_RELOCS (aout_32),
     BFD_JUMP_TABLE_WRITE (aout_32),
     BFD_JUMP_TABLE_LINK (aout_32),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d560 1
a560 1
  
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d183 1
a183 1
	("%s: Unknown section type in a.out.adobe file: %x\n", 
d376 2
a377 2
     bfd *abfd;
     sec_ptr sect;
d454 2
a455 2
     bfd *ignore_abfd;
     boolean ignore;
d482 1
d527 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a114 2
    extern char *getenv ();

@


1.1
log
@Initial revision
@
text
@d205 1
a205 2
      if (newname == NULL) {
	bfd_set_error (bfd_error_no_memory);
a206 1
      }
d257 1
a257 2
  if (rawptr == NULL) {
      bfd_set_error (bfd_error_no_memory);
a258 1
    }
d493 2
a494 2
  true,				/* data byte order is unknown (big assumed) */
  true,				/* hdr byte order is big */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d205 2
a206 1
      if (newname == NULL)
d208 1
d259 2
a260 1
  if (rawptr == NULL)
d262 1
d497 2
a498 2
  BFD_ENDIAN_BIG,		/* data byte order is unknown (big assumed) */
  BFD_ENDIAN_BIG,		/* hdr byte order is big */
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d115 2
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999
   Free Software Foundation, Inc.
d182 1
a182 1
	(_("%s: Unknown section type in a.out.adobe file: %x\n"), 
d375 2
a376 2
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr sect ATTRIBUTE_UNUSED;
d453 2
a454 2
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     boolean ignore ATTRIBUTE_UNUSED;
a480 1
#define aout_32_bfd_gc_sections         bfd_generic_gc_sections
a524 2
  NULL,
  
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000
d31 1
a31 2
/* Forward decl.  */
extern const bfd_target a_out_adobe_vec;
d45 1
a45 1

d52 1
a52 1
  struct external_exec *bytes = (struct external_exec *) raw_bytes;
d78 1
a78 1
  struct external_exec *bytes = (struct external_exec *) raw_bytes;
d80 1
a80 2
  /* Now fill in fields in the raw data, from the fields in the exec
     struct.  */
d91 1
d101 5
a105 6
      != EXEC_BYTES_SIZE)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return 0;
    }
d115 10
a124 12
  if (N_BADMAG (anexec))
    {
      targ = getenv ("GNUTARGET");
      if (targ && !strcmp (targ, a_out_adobe_vec.name))
	/* Just continue anyway, if specifically set to this format.  */
	;
      else
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}
    }
d130 1
d148 1
a148 1
  bfd_set_arch_mach (abfd, bfd_arch_unknown, 0);
d156 84
a239 93
  for (;;)
    {
      if (bfd_read ((PTR) ext, 1, sizeof (*ext), abfd) != sizeof (*ext))
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}
      switch (ext->e_type[0])
	{
	case N_TEXT:
	  section_name = ".text";
	  flags = SEC_CODE | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
	  break;

	case N_DATA:
	  section_name = ".data";
	  flags = SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
	  break;

	case N_BSS:
	  section_name = ".bss";
	  flags = SEC_DATA | SEC_HAS_CONTENTS;
	  break;

	case 0:
	  goto no_more_sections;

	default:
	  (*_bfd_error_handler)
	    (_("%s: Unknown section type in a.out.adobe file: %x\n"),
	     bfd_get_filename (abfd), ext->e_type[0]);
	  goto no_more_sections;
	}

      /* First one is called ".text" or whatever; subsequent ones are
	 ".text1", ".text2", ...  */

      bfd_set_error (bfd_error_no_error);
      sect = bfd_make_section (abfd, section_name);
      trynum = 0;
      while (!sect)
	{
	  if (bfd_get_error () != bfd_error_no_error)
	    /* Some other error -- slide into the sunset.  */
	    return 0;
	  sprintf (try_again, "%s%d", section_name, ++trynum);
	  sect = bfd_make_section (abfd, try_again);
	}

      /* Fix the name, if it is a sprintf'd name.  */
      if (sect->name == try_again)
	{
	  newname = (char *) bfd_zalloc (abfd, strlen (sect->name));
	  if (newname == NULL)
	    return 0;
	  strcpy (newname, sect->name);
	  sect->name = newname;
	}

      /* Now set the section's attributes.  */
      bfd_set_section_flags (abfd, sect, flags);
      /* Assumed big-endian.  */
      sect->_raw_size = ((ext->e_size[0] << 8)
			 | ext->e_size[1] << 8)
	| ext->e_size[2];
      sect->_cooked_size = sect->_raw_size;
      sect->vma = bfd_h_get_32 (abfd, ext->e_virtbase);
      sect->filepos = bfd_h_get_32 (abfd, ext->e_filebase);
      /* FIXME XXX alignment?  */

      /* Set relocation information for first section of each type.  */
      if (trynum == 0)
	switch (ext->e_type[0])
	  {
	  case N_TEXT:
	    sect->rel_filepos = N_TRELOFF (*execp);
	    sect->reloc_count = execp->a_trsize;
	    break;

	  case N_DATA:
	    sect->rel_filepos = N_DRELOFF (*execp);
	    sect->reloc_count = execp->a_drsize;
	    break;
	  }
    }
 no_more_sections:

  adata (abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata (abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata (abfd).page_size = 1; /* Not applicable.  */
  adata (abfd).segment_size = 1; /* Not applicable.  */
  adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
d245 2
a246 2
  struct aoutdata a;
  struct internal_exec e;
d257 1
a257 1
    return false;
d262 5
a266 5
  adata (abfd).reloc_entry_size = sizeof (struct reloc_std_external);
  adata (abfd).symbol_entry_size = sizeof (struct external_nlist);
  adata (abfd).page_size = 1; /* Not applicable.  */
  adata (abfd).segment_size = 1; /* Not applicable.  */
  adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
d271 1
d277 1
a277 1
  static struct external_segdesc sentinel[1];	/* Initialized to zero.  */
d282 1
a282 1
  /* Calculate text size as total of text sections, etc.  */
d290 11
a300 18
  for (sect = abfd->sections; sect; sect = sect->next)
    {
      if (sect->flags & SEC_CODE)
	{
	  exec_hdr (abfd)->a_text += sect->_raw_size;
	  exec_hdr (abfd)->a_trsize += sect->reloc_count *
	    sizeof (struct reloc_std_external);
	}
      else if (sect->flags & SEC_DATA)
	{
	  exec_hdr (abfd)->a_data += sect->_raw_size;
	  exec_hdr (abfd)->a_drsize += sect->reloc_count *
	    sizeof (struct reloc_std_external);
	}
      else if (sect->flags & SEC_ALLOC && !(sect->flags & SEC_LOAD))
	{
	  exec_hdr (abfd)->a_bss += sect->_raw_size;
	}
d302 1
d305 1
a305 1
    * sizeof (struct external_nlist);
d318 3
a320 6
  for (sect = abfd->sections; sect; sect = sect->next)
    {
      if (sect->flags & SEC_CODE)
	{
	  aout_adobe_write_section (abfd, sect);
	}
d322 4
a325 6
  for (sect = abfd->sections; sect; sect = sect->next)
    {
      if (sect->flags & SEC_DATA)
	{
	  aout_adobe_write_section (abfd, sect);
	}
d327 4
a330 6
  for (sect = abfd->sections; sect; sect = sect->next)
    {
      if (!(sect->flags & (SEC_CODE | SEC_DATA)))
	{
	  aout_adobe_write_section (abfd, sect);
	}
d332 1
d339 2
a340 2
  /* Now write out reloc info, followed by syms and strings.  */
  if (bfd_get_symcount (abfd) != 0)
d342 1
a342 1
      if (bfd_seek (abfd, (file_ptr) (N_SYMOFF (*exec_hdr (abfd))), SEEK_SET)
d349 1
a349 1
      if (bfd_seek (abfd, (file_ptr) (N_TRELOFF (*exec_hdr (abfd))), SEEK_SET)
d353 6
a358 8
      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_CODE)
	    {
	      if (!aout_32_squirt_out_relocs (abfd, sect))
		return false;
	    }
	}
d360 1
a360 1
      if (bfd_seek (abfd, (file_ptr) (N_DRELOFF (*exec_hdr (abfd))), SEEK_SET)
d364 6
a369 8
      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_DATA)
	    {
	      if (!aout_32_squirt_out_relocs (abfd, sect))
		return false;
	    }
	}
d393 14
a406 5
  /* Set by bfd.c handler.  */
  if (abfd->output_has_begun == false)
    {
      /* Assign file offsets to sections.  Text sections are first, and
	 are contiguous.  Then data sections.  Everything else at the end.  */
d408 7
a414 1
      section_start = N_TXTOFF (ignore<-->me);
d416 7
a422 30
      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_CODE)
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}

      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_DATA)
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}

      for (sect = abfd->sections; sect; sect = sect->next)
	{
	  if (sect->flags & SEC_HAS_CONTENTS &&
	      !(sect->flags & (SEC_CODE | SEC_DATA)))
	    {
	      sect->filepos = section_start;
	      /* FIXME:  Round to alignment.  */
	      section_start += sect->_raw_size;
	    }
	}
d424 1
d426 1
a426 2
  /* Regardless, once we know what we're doing, we might as well get
     going.  */
d430 3
a432 4
  if (count != 0)
    {
      return (bfd_write ((PTR) location, 1, count, abfd) == count) ? true : false;
    }
d452 1
a452 1
static int
d457 1
a457 1
  return sizeof (struct internal_exec);
d460 3
d489 2
a490 1
const bfd_target a_out_adobe_vec = {
d505 2
a506 2
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
d508 3
a510 3
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
  {_bfd_dummy_target, aout_adobe_object_p,	/* bfd_check_format */
d512 1
a512 1
  {bfd_false, aout_adobe_mkobject,	/* bfd_set_format */
d514 1
a514 1
  {bfd_false, aout_adobe_write_object_contents,	/* bfd_write_contents */
d517 9
a525 9
  BFD_JUMP_TABLE_GENERIC (aout_32),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd),
  BFD_JUMP_TABLE_SYMBOLS (aout_32),
  BFD_JUMP_TABLE_RELOCS (aout_32),
  BFD_JUMP_TABLE_WRITE (aout_32),
  BFD_JUMP_TABLE_LINK (aout_32),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d528 1
a528 1

@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002
d29 1
a29 1
#include "libaout.h"		/* BFD a.out internal data structures.  */
d34 5
a38 20
static const bfd_target *aout_adobe_callback
  PARAMS ((bfd *));
extern bfd_boolean aout_32_slurp_symbol_table
  PARAMS ((bfd *abfd));
extern bfd_boolean aout_32_write_syms
  PARAMS ((bfd *));
static void aout_adobe_write_section
  PARAMS ((bfd *abfd, sec_ptr sect));
static const bfd_target * aout_adobe_object_p
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_mkobject
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean aout_adobe_set_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
static bfd_boolean aout_adobe_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static int     aout_adobe_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d44 2
a45 1
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));
d56 1
a56 1
  execp->a_info   = H_GET_32 (abfd, bytes->e_info);
d69 4
a72 3
void aout_adobe_swap_exec_header_out
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));

d83 1
a83 1
  H_PUT_32 (abfd, execp->a_info  , bytes->e_info);
a99 1
  bfd_size_type amt = EXEC_BYTES_SIZE;
d101 2
a102 1
  if (bfd_bread ((PTR) &exec_bytes, amt, abfd) != amt)
d109 1
a109 1
  anexec.a_info = H_GET_32 (abfd, exec_bytes.e_info);
d145 1
a145 1
  char try_again[30];	/* Name and number.  */
d151 1
a151 1
  bfd_set_arch_mach (abfd, bfd_arch_unknown, 0L);
d158 1
d161 1
a161 2
      bfd_size_type amt = sizeof (*ext);
      if (bfd_bread ((PTR) ext, amt, abfd) != amt)
a164 1

d190 1
a190 1
	     bfd_archive_filename (abfd), ext->e_type[0]);
d196 1
a199 1

d212 1
a212 2
	  amt = strlen (sect->name);
	  newname = (char *) bfd_zalloc (abfd, amt);
d223 2
a224 2
			 | ext->e_size[1] << 8
			 | ext->e_size[2]);
d226 2
a227 2
      sect->vma = H_GET_32 (abfd, ext->e_virtbase);
      sect->filepos = H_GET_32 (abfd, ext->e_filebase);
a242 3

	  default:
	    break;
d256 4
a259 5
struct bout_data_struct
  {
    struct aoutdata a;
    struct internal_exec e;
  };
d261 1
a261 1
static bfd_boolean
a265 1
  bfd_size_type amt = sizeof (struct bout_data_struct);
d267 1
a267 1
  rawptr = (struct bout_data_struct *) bfd_zalloc (abfd, amt);
d269 1
a269 1
    return FALSE;
d280 1
a280 1
  return TRUE;
d283 1
a283 1
static bfd_boolean
a289 1
  bfd_size_type amt;
a326 1
  amt = EXEC_BYTES_SIZE;
d328 3
a330 2
      || bfd_bwrite ((PTR) &swapped_hdr, amt, abfd) != amt)
    return FALSE;
d336 6
a341 3
    if (sect->flags & SEC_CODE)
      aout_adobe_write_section (abfd, sect);

d343 6
a348 3
    if (sect->flags & SEC_DATA)
      aout_adobe_write_section (abfd, sect);

d350 6
a355 2
    if (!(sect->flags & (SEC_CODE | SEC_DATA)))
      aout_adobe_write_section (abfd, sect);
d358 3
a360 3
  amt = sizeof (*sentinel);
  if (bfd_bwrite ((PTR) sentinel, amt, abfd) != amt)
    return FALSE;
d367 1
a367 1
	return FALSE;
d370 1
a370 1
	return FALSE;
d374 1
a374 1
	return FALSE;
d377 7
a383 3
	if (sect->flags & SEC_CODE)
	  if (!aout_32_squirt_out_relocs (abfd, sect))
	    return FALSE;
d387 1
a387 1
	return FALSE;
d390 7
a396 3
	if (sect->flags & SEC_DATA)
	  if (!aout_32_squirt_out_relocs (abfd, sect))
	    return FALSE;
d398 1
a398 2

  return TRUE;
d409 1
a409 1
static bfd_boolean
d421 1
a421 1
  if (! abfd->output_has_begun)
d425 1
d463 1
a463 1
    return FALSE;
d465 5
a469 4
  if (count == 0)
    return TRUE;

  return bfd_bwrite ((PTR) location, count, abfd) == count;
d472 1
a472 1
static bfd_boolean
d479 1
a479 1
    return FALSE;
d483 1
a483 1
    return TRUE;
d485 1
a485 1
  return FALSE;
d491 1
a491 1
     bfd_boolean ignore ATTRIBUTE_UNUSED;
a515 2
#define aout_32_bfd_merge_sections	bfd_generic_merge_sections
#define aout_32_bfd_discard_group	bfd_generic_discard_group
a517 2
#define aout_32_bfd_link_hash_table_free \
  _bfd_generic_link_hash_table_free
a518 1
#define aout_32_bfd_link_just_syms	_bfd_generic_link_just_syms
d522 36
a557 37
const bfd_target a_out_adobe_vec =
  {
    "a.out.adobe",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is unknown (big assumed) */
    BFD_ENDIAN_BIG,		/* hdr byte order is big */
    (HAS_RELOC | EXEC_P |	/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT ),
    /* section flags */
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_DATA | SEC_RELOC),
    '_',				/*  symbol leading char */
    ' ',				/* ar_pad_char */
    16,					/* ar_max_namelen */

    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, aout_adobe_object_p,	/* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
    {bfd_false, aout_adobe_mkobject,		/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, aout_adobe_write_object_contents,/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (aout_32),
    BFD_JUMP_TABLE_COPY (_bfd_generic),
    BFD_JUMP_TABLE_CORE (_bfd_nocore),
    BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_bsd),
    BFD_JUMP_TABLE_SYMBOLS (aout_32),
    BFD_JUMP_TABLE_RELOCS (aout_32),
    BFD_JUMP_TABLE_WRITE (aout_32),
    BFD_JUMP_TABLE_LINK (aout_32),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d559 1
a559 1
    NULL,
d561 2
a562 2
    (PTR) 0
  };
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003
d50 1
a50 1
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
d418 1
a418 1
     const PTR location;
@


