head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.52
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.48
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.44
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.46
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.38
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.42
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.40
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.36
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.34
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.32
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.30
	OPENBSD_5_0:1.13.0.28
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.26
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.24
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.20
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.22
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.18
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.16
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.14
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.12
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	new-binutils:1.8.0.14
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2004.11.02.20.45.07;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.09.22.29.26;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.12.19.11.13;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.03.33.06;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.29.20.26.45;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.06.20.51.11;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.09.04.19.00.43;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.15.17.12.22;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.14.20.41.26;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.44.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.47;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.47;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.39;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.53;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.28;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.19.04;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.39;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.06.46;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.24.21;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.15;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.24;	author miod;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* MIPS-specific support for 32-bit ELF
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.

   Most of the information added by Ian Lance Taylor, Cygnus Support,
   <ian@@cygnus.com>.
   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>
   Traditional MIPS targets support added by Koundinya.K, Dansk Data
   Elektronik & Operations Research Group. <kk@@ddeorg.soft.net>

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This file handles MIPS ELF targets.  SGI Irix 5 uses a slightly
   different MIPS ELF from other targets.  This matters when linking.
   This file supports both, switching at runtime.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"
#include "elf-bfd.h"
#include "elfxx-mips.h"
#include "elf/mips.h"

/* Get the ECOFF swapping routines.  */
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/internal.h"
#include "coff/ecoff.h"
#include "coff/mips.h"
#define ECOFF_SIGNED_32
#include "ecoffswap.h"

static bfd_reloc_status_type gprel32_with_gp
  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
static bfd_reloc_status_type mips_elf_gprel32_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips32_64bit_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static reloc_howto_type *mips_elf32_rtype_to_howto
  (unsigned int, bfd_boolean);
static void mips_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);
static void mips_info_to_howto_rela
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean mips_elf_sym_is_global
  (bfd *, asymbol *);
static bfd_boolean mips_elf32_object_p
  (bfd *);
static bfd_boolean mips_elf_is_local_label_name
  (bfd *, const char *);
static bfd_reloc_status_type mips16_jump_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips16_gprel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf_final_gp
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf_assign_gp
  (bfd *, bfd_vma *);
static bfd_boolean elf32_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf32_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);
static irix_compat_t elf32_mips_irix_compat
  (bfd *);

extern const bfd_target bfd_elf32_bigmips_vec;
extern const bfd_target bfd_elf32_littlemips_vec;

/* Nonzero if ABFD is using the N32 ABI.  */
#define ABI_N32_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI2) != 0)

/* Whether we are trying to be compatible with IRIX at all.  */
#define SGI_COMPAT(abfd) \
  (elf32_mips_irix_compat (abfd) != ict_none)

/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* The relocation table used for SHT_REL sections.  */

static reloc_howto_type elf_mips_howto_table_rel[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_REL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_HI16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The remaining relocs are defined on Irix 5, although they are
     not defined by the ABI.  */
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c0,		/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c4,		/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SUB",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used to cause the linker to insert and delete instructions?  */
  EMPTY_HOWTO (R_MIPS_INSERT_A),
  EMPTY_HOWTO (R_MIPS_INSERT_B),
  EMPTY_HOWTO (R_MIPS_DELETE),

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MIPS_SCN_DISP,       /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SCN_DISP",     /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_MIPS_REL16),
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),
  EMPTY_HOWTO (R_MIPS_RELGOT),

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_JALR",	        /* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
   is a hack to make the linker think that we need 64 bit values.  */
static reloc_howto_type elf_mips_ctor64_howto =
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extensions for embedded-pic.  */
/* High 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_hi16 =
  HOWTO (R_MIPS_GNU_REL_HI16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_GNU_REL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* Low 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_lo16 =
  HOWTO (R_MIPS_GNU_REL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_GNU_REL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 64 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel64 =
  HOWTO (R_MIPS_PC64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 32 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
mips_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
mips_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		   char **error_message, bfd_vma *pgp)
{
  if (bfd_is_und_section (symbol->section)
      && ! relocatable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocatable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma + 0x4000;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
   R_MIPS_LITERAL relocations, although those can be handled more
   cleverly because the entries in the .lit8 and .lit4 sections can be
   merged.  */

bfd_reloc_status_type
_bfd_mips_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
			       asymbol *symbol, void *data,
			       asection *input_section, bfd *output_bfd,
			       char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
}

/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			   error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocatable, data, gp);
}

static bfd_reloc_status_type
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
{
  bfd_vma relocation;
  bfd_vma val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are
   generated when addresses are 64 bits.  The upper 32 bits are a simple
   sign extension.  */

static bfd_reloc_status_type
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
		    asymbol *symbol ATTRIBUTE_UNUSED,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
{
  bfd_reloc_status_type r;
  arelent reloc32;
  unsigned long val;
  bfd_size_type addr;

  /* Do a normal 32 bit relocation on the lower 32 bits.  */
  reloc32 = *reloc_entry;
  if (bfd_big_endian (abfd))
    reloc32.address += 4;
  reloc32.howto = &elf_mips_howto_table_rel[R_MIPS_32];
  r = bfd_perform_relocation (abfd, &reloc32, data, input_section,
			      output_bfd, error_message);

  /* Sign extend into the upper 32 bits.  */
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc32.address);
  if ((val & 0x80000000) != 0)
    val = 0xffffffff;
  else
    val = 0;
  addr = reloc_entry->address;
  if (bfd_little_endian (abfd))
    addr += 4;
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);

  return r;
}

/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static bfd_boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = TRUE;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  /* There is no BFD reloc for R_MIPS_REL32.  */
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  unsigned int i;
  reloc_howto_type *howto_table = elf_mips_howto_table_rel;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }

  switch (code)
    {
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;

    case BFD_RELOC_CTOR:
      /* We need to handle BFD_RELOC_CTOR specially.
	 Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
	return &elf_mips_ctor64_howto;
      else
	return &howto_table[(int) R_MIPS_32];

    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_PCREL_HI16_S:
      return &elf_mips_gnu_rel_hi16;
    case BFD_RELOC_PCREL_LO16:
      return &elf_mips_gnu_rel_lo16;
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rel16_s2;
    case BFD_RELOC_64_PCREL:
      return &elf_mips_gnu_pcrel64;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
    }
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_elf32_rtype_to_howto (unsigned int r_type,
			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
{
  switch (r_type)
    {
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case R_MIPS_GNU_REL_HI16:
      return &elf_mips_gnu_rel_hi16;
    case R_MIPS_GNU_REL_LO16:
      return &elf_mips_gnu_rel_lo16;
    case R_MIPS_GNU_REL16_S2:
      return &elf_mips_gnu_rel16_s2;
    case R_MIPS_PC64:
      return &elf_mips_gnu_pcrel64;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
    default:
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      return &elf_mips_howto_table_rel[r_type];
    }
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static void
mips_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, FALSE);

  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
     value for the object file.  We get the addend now, rather than
     when we do the relocation, because the symbol manipulations done
     by the linker may cause us to lose track of the input BFD.  */
  if (((*cache_ptr->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
      && (r_type == (unsigned int) R_MIPS_GPREL16
	  || r_type == (unsigned int) R_MIPS_LITERAL))
    cache_ptr->addend = elf_gp (abfd);
}

/* Given a MIPS Elf_Internal_Rela, fill in an arelent structure.  */

static void
mips_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  mips_info_to_howto_rel (abfd, cache_ptr, dst);

  /* If we ever need to do any extra processing with dst->r_addend
     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
}

/* Determine whether a symbol is global for the purposes of splitting
   the symbol table into global symbols and local symbols.  At least
   on Irix 5, this split must be between section symbols and all other
   symbols.  On most ELF targets the split is between static symbols
   and externally visible symbols.  */

static bfd_boolean
mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
{
  if (SGI_COMPAT (abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
	    || bfd_is_und_section (bfd_get_section (sym))
	    || bfd_is_com_section (bfd_get_section (sym)));
}

/* Set the right machine number for a MIPS ELF file.  */

static bfd_boolean
mips_elf32_object_p (bfd *abfd)
{
  unsigned long mach;

  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (SGI_COMPAT (abfd))
    elf_bad_symtab (abfd) = TRUE;

  if (ABI_N32_P (abfd))
    return FALSE;

  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);

  return TRUE;
}

/* MIPS ELF local labels start with '$', not 'L'.  */

static bfd_boolean
mips_elf_is_local_label_name (bfd *abfd, const char *name)
{
  if (name[0] == '$')
    return TRUE;

  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf32_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 256:		/* Linux/MIPS */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 180;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
elf32_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 128:		/* Linux/MIPS elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf32_mips_irix_compat (bfd *abfd)
{
  if ((abfd->xvec == &bfd_elf32_bigmips_vec)
      || (abfd->xvec == &bfd_elf32_littlemips_vec))
    return ict_irix5;
  else
    return ict_none;
}

/* Given a data section and an in-memory embedded reloc section, store
   relocation information into the embedded reloc section which can be
   used at runtime to relocate the data section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_mips_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
				       asection *datasec, asection *relsec,
				       char **errmsg)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *p;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  /* Read this BFD's symbols if we haven't done so already, or get the cached
     copy if it exists.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (symtab_hdr->sh_info != 0)
    {
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
    }

  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, datasec, NULL, NULL,
					       info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  relsec->contents = bfd_alloc (abfd, datasec->reloc_count * 12);
  if (relsec->contents == NULL)
    goto error_return;

  p = relsec->contents;

  irelend = internal_relocs + datasec->reloc_count;

  for (irel = internal_relocs; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
	 reloc section.  The longword will be the address in the data
	 section which must be relocated.  It is followed by the name
	 of the target section NUL-padded or truncated to 8
	 characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if ((ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_32) &&
	  (ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_64))
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      /* Get the target section referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
          Elf_Internal_Sym *isym;

          /* A local symbol.  */
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info);
	  h = elf_sym_hashes (abfd)[indx];
	  targetsec = NULL;
	  /*
	     For some reason, in certain programs, the symbol will
	     not be in the hash table.  It seems to happen when you
	     declare a static table of pointers to const external structures.
	     In this case, the relocs are relative to data, not
	     text, so just treating it like an undefined link
	     should be sufficient.  */
	  BFD_ASSERT(h != NULL);
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	}


      /*
         Set the low bit of the relocation offset if it's a MIPS64 reloc.
         Relocations will always be on (at least) 32-bit boundaries.  */

      bfd_put_32 (abfd, ((irel->r_offset + datasec->output_offset) +
		  ((ELF32_R_TYPE (irel->r_info) == (int) R_MIPS_64) ? 1 : 0)),
		  p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy (p + 4, targetsec->output_section->name, 8);
    }

  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return TRUE;

 error_return:
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return FALSE;
}

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap = {
  /* Symbol table magic number.  */
  magicSym,
  /* Alignment of debugging information.  E.g., 4.  */
  4,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  _bfd_mips_elf_read_ecoff_info
};

#define ELF_ARCH			bfd_arch_mips
#define ELF_MACHINE_CODE		EM_MIPS

#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
#define elf_info_to_howto		mips_info_to_howto_rela
#define elf_info_to_howto_rel		mips_info_to_howto_rel
#define elf_backend_sym_is_global	mips_elf_sym_is_global
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
#define elf_backend_section_from_bfd_section \
					_bfd_mips_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_create_dynamic_sections \
					_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					_bfd_mips_elf_size_dynamic_sections
#define elf_backend_relocate_section	_bfd_mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
					_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol
#define elf_backend_grok_prstatus	elf32_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf32_mips_grok_psinfo
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap

#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	0
#define elf_backend_default_use_rela_p	0
#define elf_backend_sign_extend_vma	TRUE

#define elf_backend_discard_info	_bfd_mips_elf_discard_info
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_mips_irix_compat	elf32_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf32_rtype_to_howto
#define bfd_elf32_bfd_is_local_label_name \
					mips_elf_is_local_label_name
#define bfd_elf32_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf32_new_section_hook	_bfd_mips_elf_new_section_hook
#define bfd_elf32_set_section_contents	_bfd_mips_elf_set_section_contents
#define bfd_elf32_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
#define bfd_elf32_bfd_link_hash_table_create \
					_bfd_mips_elf_link_hash_table_create
#define bfd_elf32_bfd_final_link	_bfd_mips_elf_final_link
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_mips_elf_print_private_bfd_data

/* Support for SGI-ish mips targets.  */
#define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
#define TARGET_LITTLE_NAME		"elf32-littlemips"
#define TARGET_BIG_SYM			bfd_elf32_bigmips_vec
#define TARGET_BIG_NAME			"elf32-bigmips"

/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

#include "elf32-target.h"

/* Support for traditional mips targets.  */
#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#undef ELF_MAXPAGESIZE

#define TARGET_LITTLE_SYM               bfd_elf32_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf32-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf32_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf32-tradbigmips"

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf32_bed			elf32_tradbed

/* Include the target file again for this target.  */
#include "elf32-target.h"
@


1.12
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d50 2
a51 6
static bfd_reloc_status_type mips_elf_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf_lo16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d53 1
a53 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d55 1
a55 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d57 1
a57 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d59 1
a59 1
  PARAMS ((unsigned int, bfd_boolean));
d61 1
a61 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d63 1
a63 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d65 1
a65 1
  PARAMS ((bfd *, asymbol *));
d67 1
a67 1
  PARAMS ((bfd *));
d69 1
a69 1
  PARAMS ((bfd *, const char *));
d71 1
a71 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d73 1
a73 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d75 1
a75 1
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
d77 1
a77 1
  PARAMS ((bfd *, bfd_vma *));
d79 1
a79 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d81 1
a81 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d83 1
a83 1
  PARAMS ((bfd *));
d115 1
a115 1
	 bfd_elf_generic_reloc,	/* special_function */
d130 1
a130 1
	 bfd_elf_generic_reloc,	/* special_function */
d145 1
a145 1
	 bfd_elf_generic_reloc,	/* special_function */
d160 1
a160 1
	 bfd_elf_generic_reloc,	/* special_function */
d178 1
a178 1
	 bfd_elf_generic_reloc,	/* special_function */
d187 1
a187 1
	 0,			/* rightshift */
d193 1
a193 1
	 mips_elf_hi16_reloc,	/* special_function */
d208 1
a208 1
	 mips_elf_lo16_reloc,	/* special_function */
d253 1
a253 1
	 mips_elf_got16_reloc,	/* special_function */
d268 1
a268 1
	 bfd_elf_generic_reloc,	/* special_function */
d283 1
a283 1
	 bfd_elf_generic_reloc,	/* special_function */
d319 1
a319 1
	 bfd_elf_generic_reloc,	/* special_function */
d336 1
a336 1
	 bfd_elf_generic_reloc,	/* special_function */
d366 1
a366 1
	 bfd_elf_generic_reloc,	/* special_function */
d381 1
a381 1
	 bfd_elf_generic_reloc,	/* special_function */
d396 1
a396 1
	 bfd_elf_generic_reloc,	/* special_function */
d411 1
a411 1
	 bfd_elf_generic_reloc,	/* special_function */
d426 1
a426 1
	 bfd_elf_generic_reloc,	/* special_function */
d441 1
a441 1
	 bfd_elf_generic_reloc,	/* special_function */
d461 1
a461 1
	 bfd_elf_generic_reloc,	/* special_function */
d476 1
a476 1
	 bfd_elf_generic_reloc,	/* special_function */
d491 1
a491 1
	 bfd_elf_generic_reloc,	/* special_function */
d506 1
a506 1
	 bfd_elf_generic_reloc,	/* special_function */
d521 1
a521 1
	 bfd_elf_generic_reloc,	/* special_function */
d542 1
a542 1
	 bfd_elf_generic_reloc,	/* special_function */
d606 1
a606 1
	 0,			/* rightshift */
d612 1
a612 1
	 mips_elf_hi16_reloc,	/* special_function */
d628 1
a628 1
	 mips_elf_lo16_reloc,	/* special_function */
d644 1
a644 1
	 bfd_elf_generic_reloc,	/* special_function */
d660 1
a660 1
	 bfd_elf_generic_reloc,	/* special_function */
d676 1
a676 1
	 bfd_elf_generic_reloc,	/* special_function */
a714 256
/* Do a R_MIPS_HI16 relocation.  This has to be done in combination
   with a R_MIPS_LO16 reloc, because there is a carry from the LO16 to
   the HI16.  Here we just save the information we need; we do the
   actual relocation when we see the LO16.

   MIPS ELF requires that the LO16 immediately follow the HI16.  As a
   GNU extension, for non-pc-relative relocations, we permit an
   arbitrary number of HI16 relocs to be associated with a single LO16
   reloc.  This extension permits gcc to output the HI and LO relocs
   itself.

   This cannot be done for PC-relative relocations because both the HI16
   and LO16 parts of the relocations must be done relative to the LO16
   part, and there can be carry to or borrow from the HI16 part.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

static bfd_reloc_status_type
mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct mips_hi16 *n;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  ret = bfd_reloc_ok;

  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_boolean relocateable;
      bfd_vma gp;

      if (ret == bfd_reloc_undefined)
	abort ();

      if (output_bfd != NULL)
	relocateable = TRUE;
      else
	{
	  relocateable = FALSE;
	  output_bfd = symbol->section->output_section->owner;
	}

      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
    }
  else
    {
      if (bfd_is_und_section (symbol->section)
	  && output_bfd == (bfd *) NULL)
	ret = bfd_reloc_undefined;

      if (bfd_is_com_section (symbol->section))
	relocation = 0;
      else
	relocation = symbol->value;
    }

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Save the information, and let LO16 do the actual relocation.  */
  n = (struct mips_hi16 *) bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_hi16_list;
  mips_hi16_list = n;

  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Do a R_MIPS_LO16 relocation.  This is a straightforward 16 bit
   inplace relocation; this function exists in order to do the
   R_MIPS_HI16 relocation described above.  */

static bfd_reloc_status_type
mips_elf_lo16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  arelent gp_disp_relent;

  if (mips_hi16_list != NULL)
    {
      struct mips_hi16 *l;

      l = mips_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi16 *next;

	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

	  /* The low order 16 bits are always treated as a signed
	     value.  */
	  vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* If PC-relative, we need to subtract out the address of the LO
	     half of the HI/LO.  (The actual relocation is relative
	     to that instruction.)  */
	  if (reloc_entry->howto->pc_relative)
	    val -= reloc_entry->address;

	  /* At this point, "val" has the value of the combined HI/LO
	     pair.  If the low order 16 bits (which will be used for
	     the LO16 insn) are negative, then we will need an
	     adjustment for the high order 16 bits.  */
	  val += 0x8000;
	  val = (val >> 16) & 0xffff;

	  insn &= ~ (bfd_vma) 0xffff;
	  insn |= val;
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);

	  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
	    {
	      gp_disp_relent = *reloc_entry;
	      reloc_entry = &gp_disp_relent;
	      reloc_entry->addend = l->addend;
	    }

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_hi16_list = NULL;
    }
  else if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_reloc_status_type ret;
      bfd_vma gp, relocation;

      /* FIXME: Does this case ever occur?  */

      ret = mips_elf_final_gp (output_bfd, symbol, TRUE, error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
      relocation += reloc_entry->addend;

      if (reloc_entry->address > input_section->_cooked_size)
	return bfd_reloc_outofrange;

      gp_disp_relent = *reloc_entry;
      reloc_entry = &gp_disp_relent;
      reloc_entry->addend = relocation - 4;
    }

  /* Now do the LO16 reloc in the usual way.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

static bfd_reloc_status_type
mips_elf_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
		      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* If we're relocating, and this is a local symbol, we can handle it
     just like HI16.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) != 0)
    return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);

  abort ();
}

d719 1
a719 3
mips_elf_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
d735 1
a735 1
  if (sym == (asymbol **) NULL)
d768 1
a768 1
   external symbol if we are producing relocateable output.  */
d771 2
a772 6
mips_elf_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     bfd_boolean relocateable;
     char **error_message;
     bfd_vma *pgp;
d775 1
a775 1
      && ! relocateable)
d783 1
a783 1
      && (! relocateable
d786 1
a786 1
      if (relocateable)
d810 4
a813 9
_bfd_mips_elf32_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			       output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d815 1
a815 1
  bfd_boolean relocateable;
d819 2
a820 14
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocateable = TRUE;
d823 1
a823 1
      relocateable = FALSE;
d827 1
a827 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
d833 1
a833 1
					input_section, relocateable,
a839 4
static bfd_reloc_status_type gprel32_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));

d841 3
a843 9
mips_elf_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d845 1
a845 1
  bfd_boolean relocateable;
d849 2
a850 18
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != (bfd *) NULL)
    {
      relocateable = TRUE;
      gp = _bfd_get_gp_value (output_bfd);
    }
d853 1
a853 1
      relocateable = FALSE;
d855 1
d857 4
a860 5
      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }
d863 1
a863 1
			  relocateable, data, gp);
d867 3
a869 9
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     bfd_boolean relocateable;
     PTR data;
     bfd_vma gp;
d872 1
a872 1
  unsigned long val;
d885 2
a886 7
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d888 2
a889 2
  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;
d892 1
a892 1
     are producing relocateable output, we don't want to do this for
d894 1
a894 1
  if (! relocateable
d898 4
a901 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + reloc_entry->address);
d903 1
a903 1
  if (relocateable)
d914 4
a917 9
mips32_64bit_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
a923 5
  r = bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			     input_section, output_bfd, error_message);
  if (r != bfd_reloc_continue)
    return r;

d941 1
a941 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + addr);
d949 4
a952 9
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d954 1
a954 1
  if (output_bfd != (bfd *) NULL
d979 3
a981 9
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d983 1
a983 1
  bfd_boolean relocateable;
d986 4
a989 2
  unsigned short extend, insn;
  unsigned long final;
d991 2
a992 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d995 1
a995 1
      && reloc_entry->addend == 0)
d1002 1
a1002 1
    relocateable = TRUE;
d1005 1
a1005 1
      relocateable = FALSE;
d1009 1
a1009 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
d1017 20
a1036 25
  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);
d1038 25
a1062 1
  return ret;
d1101 1
a1101 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
d1153 2
a1154 3
mips_elf32_rtype_to_howto (r_type, rela_p)
     unsigned int r_type;
     bfd_boolean rela_p ATTRIBUTE_UNUSED;
d1185 1
a1185 4
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1205 1
a1205 4
mips_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1220 1
a1220 3
mips_elf_sym_is_global (abfd, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
d1233 1
a1233 2
mips_elf32_object_p (abfd)
     bfd *abfd;
d1255 1
a1255 3
mips_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d1267 1
a1267 3
elf32_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d1297 1
a1297 3
elf32_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d1329 1
a1329 2
elf32_mips_irix_compat (abfd)
     bfd *abfd;
d1346 3
a1348 6
bfd_mips_elf32_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
d1356 1
a1356 1
  BFD_ASSERT (! info->relocateable);
d1378 2
a1379 3
  internal_relocs = (_bfd_elf32_link_read_relocs
		     (abfd, datasec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      info->keep_memory));
d1383 1
a1383 1
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
a1515 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

a1560 1
#define elf_backend_plt_header_size	0
d1593 4
a1599 2
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */

d1605 2
d1611 5
@


1.11
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d38 1
d50 8
a57 57
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
};

/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */

struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against
     this symbol.  */
  unsigned int possibly_dynamic_relocs;

  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  boolean no_fn_stub;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
};

d62 2
a63 2
static reloc_howto_type *mips_rtype_to_howto
  PARAMS ((unsigned int));
d65 1
a65 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d67 6
a72 19
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
static void bfd_mips_elf32_swap_gptab_in
  PARAMS ((bfd *, const Elf32_External_gptab *, Elf32_gptab *));
static void bfd_mips_elf32_swap_gptab_out
  PARAMS ((bfd *, const Elf32_gptab *, Elf32_External_gptab *));
#if 0
static void bfd_mips_elf_swap_msym_in
  PARAMS ((bfd *, const Elf32_External_Msym *, Elf32_Internal_Msym *));
#endif
static void bfd_mips_elf_swap_msym_out
  PARAMS ((bfd *, const Elf32_Internal_Msym *, Elf32_External_Msym *));
static boolean mips_elf_sym_is_global PARAMS ((bfd *, asymbol *));
static boolean mips_elf_create_procedure_table
  PARAMS ((PTR, bfd *, struct bfd_link_info *, asection *,
	   struct ecoff_debug_info *));
static INLINE int elf_mips_isa PARAMS ((flagword));
static INLINE int elf_mips_mach PARAMS ((flagword));
static INLINE char* elf_mips_abi_name PARAMS ((bfd *));
static boolean mips_elf_is_local_label_name
a73 3
static struct bfd_hash_entry *mips_elf_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static int gptab_compare PARAMS ((const void *, const void *));
a77 4
static boolean mips_elf_create_compact_rel_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
d79 8
a86 5
  PARAMS ((bfd *, asymbol *, boolean, char **, bfd_vma *));
static bfd_byte *elf32_mips_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, boolean, asymbol **));
static asection *mips_elf_create_msym_section
a87 71
static void mips_elf_irix6_finish_dynamic_symbol
  PARAMS ((bfd *, const char *, Elf_Internal_Sym *));
static bfd_vma mips_elf_sign_extend PARAMS ((bfd_vma, int));
static boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
static bfd_vma mips_elf_high PARAMS ((bfd_vma));
static bfd_vma mips_elf_higher PARAMS ((bfd_vma));
static bfd_vma mips_elf_highest PARAMS ((bfd_vma));
static bfd_vma mips_elf_global_got_index
  PARAMS ((bfd *, struct elf_link_hash_entry *));
static bfd_vma mips_elf_local_got_index
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static bfd_vma mips_elf_got_offset_from_index
  PARAMS ((bfd *, bfd *, bfd_vma));
static boolean mips_elf_record_global_got_symbol
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *,
	   struct mips_got_info *));
static bfd_vma mips_elf_got_page
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
static const Elf_Internal_Rela *mips_elf_next_relocation
  PARAMS ((unsigned int, const Elf_Internal_Rela *,
	   const Elf_Internal_Rela *));
static bfd_reloc_status_type mips_elf_calculate_relocation
  PARAMS ((bfd *, bfd *, asection *, struct bfd_link_info *,
	   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
	   boolean *));
static bfd_vma mips_elf_obtain_contents
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *));
static boolean mips_elf_perform_relocation
  PARAMS ((struct bfd_link_info *, reloc_howto_type *,
	   const Elf_Internal_Rela *, bfd_vma,
	   bfd *, asection *, bfd_byte *, boolean));
static boolean mips_elf_assign_gp PARAMS ((bfd *, bfd_vma *));
static boolean mips_elf_sort_hash_table_f
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
static boolean mips_elf_sort_hash_table
  PARAMS ((struct bfd_link_info *, unsigned long));
static asection * mips_elf_got_section PARAMS ((bfd *));
static struct mips_got_info *mips_elf_got_info
  PARAMS ((bfd *, asection **));
static boolean mips_elf_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, boolean));
static bfd_vma mips_elf_create_local_got_entry
  PARAMS ((bfd *, struct mips_got_info *, asection *, bfd_vma));
static bfd_vma mips_elf_got16_entry
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, boolean));
static boolean mips_elf_create_dynamic_relocation
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
	   struct mips_elf_link_hash_entry *, asection *,
	   bfd_vma, bfd_vma *, asection *));
static void mips_elf_allocate_dynamic_relocations
  PARAMS ((bfd *, unsigned int));
static boolean mips_elf_stub_section_p
  PARAMS ((bfd *, asection *));
static int sort_dynamic_relocs
  PARAMS ((const void *, const void *));

extern const bfd_target bfd_elf32_tradbigmips_vec;
extern const bfd_target bfd_elf32_tradlittlemips_vec;
#ifdef BFD64
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
#endif

/* The level of IRIX compatibility we're striving for.  */

typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;
d89 2
a90 2
/* This will be used when we sort the dynamic relocation records.  */
static bfd *reldyn_sorting_bfd;
a92 1

a95 20
/* Nonzero if ABFD is using the 64-bit ABI. */
#define ABI_64_P(abfd) \
  ((elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64) != 0)

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
#ifdef BFD64
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf64_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf64_tradlittlemips_vec) || \
    (abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#else
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#endif

d98 1
a98 61
  (IRIX_COMPAT (abfd) != ict_none)

/* The name of the msym section.  */
#define MIPS_ELF_MSYM_SECTION_NAME(abfd) ".msym"

/* The name of the srdata section.  */
#define MIPS_ELF_SRDATA_SECTION_NAME(abfd) ".srdata"

/* The name of the options section.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.options" : ".options")

/* The name of the stub section.  */
#define MIPS_ELF_STUB_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.stubs" : ".stub")

/* The name of the dynamic relocation section.  */
#define MIPS_ELF_REL_DYN_SECTION_NAME(abfd) ".rel.dyn"

/* The size of an external REL relocation.  */
#define MIPS_ELF_REL_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rel)

/* The size of an external dynamic table entry.  */
#define MIPS_ELF_DYN_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_dyn)

/* The size of a GOT entry.  */
#define MIPS_ELF_GOT_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

/* The size of a symbol-table entry.  */
#define MIPS_ELF_SYM_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_sym)

/* The default alignment for sections, as a power of two.  */
#define MIPS_ELF_LOG_FILE_ALIGN(abfd)				\
  (get_elf_backend_data (abfd)->s->file_align == 8 ? 3 : 2)

/* Get word-sized data.  */
#define MIPS_ELF_GET_WORD(abfd, ptr) \
  (ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))

/* Put out word-sized data.  */
#define MIPS_ELF_PUT_WORD(abfd, val, ptr)	\
  (ABI_64_P (abfd) 				\
   ? bfd_put_64 (abfd, val, ptr) 		\
   : bfd_put_32 (abfd, val, ptr))

/* Add a dynamic symbol table-entry.  */
#ifdef BFD64
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? bfd_elf64_add_dynamic_entry (info, tag, val)  \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#else
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? (abort (), false)                             \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#endif
a102 156
/* Instructions which appear in a stub.  For some reason the stub is
   slightly different on an SGI system.  */
#define ELF_MIPS_GP_OFFSET(abfd) (SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
#define STUB_LW(abfd)						\
  (SGI_COMPAT (abfd)						\
   ? (ABI_64_P (abfd)  						\
      ? 0xdf998010		/* ld t9,0x8010(gp) */		\
      : 0x8f998010)             /* lw t9,0x8010(gp) */		\
   : 0x8f998010)		/* lw t9,0x8000(gp) */
#define STUB_MOVE(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x03e07825 : 0x03e07821)         /* move t7,ra */
#define STUB_JALR 0x0320f809				/* jal t9 */
#define STUB_LI16(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x34180000 : 0x24180000)         /* ori t8,zero,0 */
#define MIPS_FUNCTION_STUB_SIZE (16)

#if 0
/* We no longer try to identify particular sections for the .dynsym
   section.  When we do, we wind up crashing if there are other random
   sections with relocations.  */

/* Names of sections which appear in the .dynsym section in an Irix 5
   executable.  */

static const char * const mips_elf_dynsym_sec_names[] =
{
  ".text",
  ".init",
  ".fini",
  ".data",
  ".rodata",
  ".sdata",
  ".sbss",
  ".bss",
  NULL
};

#define SIZEOF_MIPS_DYNSYM_SECNAMES \
  (sizeof mips_elf_dynsym_sec_names / sizeof mips_elf_dynsym_sec_names[0])

/* The number of entries in mips_elf_dynsym_sec_names which go in the
   text segment.  */

#define MIPS_TEXT_DYNSYM_SECNO (3)

#endif /* 0 */

/* The names of the runtime procedure table symbols used on Irix 5.  */

static const char * const mips_elf_dynsym_rtproc_names[] =
{
  "_procedure_table",
  "_procedure_string_table",
  "_procedure_table_size",
  NULL
};

/* These structures are used to generate the .compact_rel section on
   Irix 5.  */

typedef struct
{
  unsigned long id1;		/* Always one?  */
  unsigned long num;		/* Number of compact relocation entries.  */
  unsigned long id2;		/* Always two?  */
  unsigned long offset;		/* The file offset of the first relocation.  */
  unsigned long reserved0;	/* Zero?  */
  unsigned long reserved1;	/* Zero?  */
} Elf32_compact_rel;

typedef struct
{
  bfd_byte id1[4];
  bfd_byte num[4];
  bfd_byte id2[4];
  bfd_byte offset[4];
  bfd_byte reserved0[4];
  bfd_byte reserved1[4];
} Elf32_External_compact_rel;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
  unsigned long vaddr;		/* VADDR to be relocated.  */
} Elf32_crinfo;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
} Elf32_crinfo2;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
  bfd_byte vaddr[4];
} Elf32_External_crinfo;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
} Elf32_External_crinfo2;

/* These are the constants used to swap the bitfields in a crinfo.  */

#define CRINFO_CTYPE (0x1)
#define CRINFO_CTYPE_SH (31)
#define CRINFO_RTYPE (0xf)
#define CRINFO_RTYPE_SH (27)
#define CRINFO_DIST2TO (0xff)
#define CRINFO_DIST2TO_SH (19)
#define CRINFO_RELVADDR (0x7ffff)
#define CRINFO_RELVADDR_SH (0)

/* A compact relocation info has long (3 words) or short (2 words)
   formats.  A short format doesn't have VADDR field and relvaddr
   fields contains ((VADDR - vaddr of the previous entry) >> 2).  */
#define CRF_MIPS_LONG			1
#define CRF_MIPS_SHORT			0

/* There are 4 types of compact relocation at least. The value KONST
   has different meaning for each type:

   (type)		(konst)
   CT_MIPS_REL32	Address in data
   CT_MIPS_WORD		Address in word (XXX)
   CT_MIPS_GPHI_LO	GP - vaddr
   CT_MIPS_JMPAD	Address to jump
   */

#define CRT_MIPS_REL32			0xa
#define CRT_MIPS_WORD			0xb
#define CRT_MIPS_GPHI_LO		0xc
#define CRT_MIPS_JMPAD			0xd

#define mips_elf_set_cr_format(x,format)	((x).ctype = (format))
#define mips_elf_set_cr_type(x,type)		((x).rtype = (type))
#define mips_elf_set_cr_dist2to(x,v)		((x).dist2to = (v))
#define mips_elf_set_cr_relvaddr(x,d)		((x).relvaddr = (d)<<2)

static void bfd_elf32_swap_compact_rel_out
  PARAMS ((bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *));
static void bfd_elf32_swap_crinfo_out
  PARAMS ((bfd *, const Elf32_crinfo *, Elf32_External_crinfo *));

#define USE_REL	1		/* MIPS uses REL relocations instead of RELA */

d107 3
a109 1
static reloc_howto_type elf_mips_howto_table[] =
d116 1
a116 1
	 false,			/* pc_relative */
d121 1
a121 1
	 false,			/* partial_inplace */
d124 1
a124 1
	 false),		/* pcrel_offset */
d129 1
a129 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d131 1
a131 1
	 false,			/* pc_relative */
d133 1
a133 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d136 4
a139 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d146 1
a146 1
	 false,			/* pc_relative */
d148 1
a148 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d151 1
a151 1
	 true,			/* partial_inplace */
d154 1
a154 1
	 false),		/* pcrel_offset */
d161 1
a161 1
	 false,			/* pc_relative */
d163 1
a163 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d166 1
a166 1
	 true,			/* partial_inplace */
d169 1
a169 1
	 false),		/* pcrel_offset */
d176 1
a176 1
	 false,			/* pc_relative */
d184 4
a187 4
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d194 1
a194 1
	 false,			/* pc_relative */
d197 1
a197 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d199 4
a202 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d209 1
a209 1
	 false,			/* pc_relative */
d212 1
a212 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d214 4
a217 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d224 1
a224 1
	 false,			/* pc_relative */
d227 1
a227 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d229 4
a232 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d239 1
a239 1
	 false,			/* pc_relative */
d242 1
a242 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d244 4
a247 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d254 1
a254 1
	 false,			/* pc_relative */
d257 1
a257 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d259 4
a262 4
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d269 1
a269 1
	 true,			/* pc_relative */
d274 4
a277 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true),			/* pcrel_offset */
d284 1
a284 1
	 false,			/* pc_relative */
d289 4
a292 4
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d299 1
a299 1
	 false,			/* pc_relative */
d301 2
a302 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d304 1
a304 1
	 true,			/* partial_inplace */
d307 1
a307 1
	 false),		/* pcrel_offset */
d309 5
a313 5
    /* The remaining relocs are defined on Irix 5, although they are
       not defined by the ABI.  */
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
d320 1
a320 1
	 false,			/* pc_relative */
d325 1
a325 1
	 true,			/* partial_inplace */
d328 1
a328 1
	 false),		/* pcrel_offset */
d337 1
a337 1
	 false,			/* pc_relative */
d342 1
a342 1
	 true,			/* partial_inplace */
d345 1
a345 1
	 false),		/* pcrel_offset */
d352 1
a352 1
	 false,			/* pc_relative */
d354 1
a354 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d357 1
a357 1
	 true,			/* partial_inplace */
d360 1
a360 1
	 false),		/* pcrel_offset */
d367 1
a367 1
	 false,			/* pc_relative */
d369 1
a369 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d372 1
a372 1
	 true,			/* partial_inplace */
d375 1
a375 1
	 false),		/* pcrel_offset */
d382 1
a382 1
	 false,			/* pc_relative */
d384 1
a384 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d387 1
a387 1
	 true,			/* partial_inplace */
d390 1
a390 1
	 false),		/* pcrel_offset */
d397 1
a397 1
	 false,			/* pc_relative */
d399 1
a399 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d402 1
a402 1
	 true,			/* partial_inplace */
d405 1
a405 1
	 false),		/* pcrel_offset */
d412 1
a412 1
	 false,			/* pc_relative */
d417 1
a417 1
	 true,			/* partial_inplace */
d420 1
a420 1
	 false),		/* pcrel_offset */
d427 1
a427 1
	 false,			/* pc_relative */
d432 1
a432 1
	 true,			/* partial_inplace */
d435 1
a435 1
	 false),		/* pcrel_offset */
d442 1
a442 1
	 false,			/* pc_relative */
d444 1
a444 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d447 1
a447 1
	 true,			/* partial_inplace */
d450 1
a450 1
	 false),		/* pcrel_offset */
d462 1
a462 1
	 false,			/* pc_relative */
d467 4
a470 4
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d477 1
a477 1
	 false,			/* pc_relative */
d482 4
a485 4
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d492 1
a492 1
	 false,			/* pc_relative */
d497 1
a497 1
	 true,			/* partial_inplace */
d500 1
a500 1
	 false),		/* pcrel_offset */
d507 1
a507 1
	 false,			/* pc_relative */
d512 1
a512 1
	 true,			/* partial_inplace */
d515 1
a515 1
	 false),		/* pcrel_offset */
d522 1
a522 1
	 false,			/* pc_relative */
d527 1
a527 1
	 false,			/* partial_inplace */
d530 1
a530 1
	 false),		/* pcrel_offset */
d541 3
a543 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d548 1
a548 1
	 false,			/* partial_inplace */
d551 1
a551 1
	 false),		/* pcrel_offset */
d561 1
a561 1
	 false,			/* pc_relative */
d566 1
a566 1
	 true,			/* partial_inplace */
d569 1
a569 1
	 false);		/* pcrel_offset */
d577 1
a577 1
	 false,			/* pc_relative */
d585 1
a585 1
	 true,			/* partial_inplace */
d588 1
a588 1
	 false);		/* pcrel_offset */
d596 1
a596 1
	 false,			/* pc_relative */
d601 1
a601 1
	 true,			/* partial_inplace */
d604 1
a604 1
	 false);		/* pcrel_offset */
d613 1
a613 1
	 true,			/* pc_relative */
d616 1
a616 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d618 1
a618 1
	 true,			/* partial_inplace */
d621 1
a621 1
	 true);			/* pcrel_offset */
d629 1
a629 1
	 true,			/* pc_relative */
d632 1
a632 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d634 1
a634 1
	 true,			/* partial_inplace */
d637 1
a637 1
	 true);			/* pcrel_offset */
d645 1
a645 1
	 true,			/* pc_relative */
d650 1
a650 1
	 true,			/* partial_inplace */
d653 1
a653 1
	 true);			/* pcrel_offset */
d661 1
a661 1
	 true,			/* pc_relative */
d666 1
a666 1
	 true,			/* partial_inplace */
d669 1
a669 1
	 true);			/* pcrel_offset */
d677 1
a677 1
	 true,			/* pc_relative */
d682 1
a682 1
	 true,			/* partial_inplace */
d685 1
a685 1
	 true);			/* pcrel_offset */
d693 1
a693 1
	 false,			/* pc_relative */
d698 1
a698 1
	 false,			/* partial_inplace */
d701 1
a701 1
	 false);		/* pcrel_offset */
d709 1
a709 1
	 false,			/* pc_relative */
d714 1
a714 1
	 false,			/* partial_inplace */
d717 1
a717 1
	 false);		/* pcrel_offset */
d722 4
a725 2
   actual relocation when we see the LO16.  MIPS ELF requires that the
   LO16 immediately follow the HI16.  As a GNU extension, we permit an
d728 5
a732 1
   itself.  */
d745 3
a747 8
bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (abfd,
		     reloc_entry,
		     symbol,
		     data,
		     input_section,
		     output_bfd,
		     error_message)
d760 1
a760 1
  /* If we're relocating, and this an external symbol, we don't want
d774 1
a774 1
      boolean relocateable;
d781 1
a781 1
	relocateable = true;
d784 1
a784 1
	  relocateable = false;
d815 1
a815 1
  n = (struct mips_hi16 *) bfd_malloc (sizeof *n);
d833 3
a835 8
bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (abfd,
		     reloc_entry,
		     symbol,
		     data,
		     input_section,
		     output_bfd,
		     error_message)
d862 5
a866 2
	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff);
d870 16
a885 13
	  /* The low order 16 bits are always treated as a signed
	     value.  Therefore, a negative value in the low order bits
	     requires an adjustment in the high order bits.  We need
	     to make this adjustment in two ways: once for the bits we
	     took from the data, and once for the bits we are putting
	     back in to the data.  */
	  if ((vallo & 0x8000) != 0)
	    val -= 0x10000;
	  if ((val & 0x8000) != 0)
	    val += 0x10000;

	  insn = (insn & ~0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, insn, l->addr);
d908 1
a908 1
      ret = mips_elf_final_gp (output_bfd, symbol, true, error_message, &gp);
d944 3
a946 8
bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (abfd,
		      reloc_entry,
		      symbol,
		      data,
		      input_section,
		      output_bfd,
		      error_message)
d955 1
a955 1
  /* If we're relocating, and this an external symbol, we don't want
d969 2
a970 2
    return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				     input_section, output_bfd, error_message);
d975 1
a975 1
/* Set the GP value for OUTPUT_BFD.  Returns false if this is a
d978 1
a978 1
static boolean
d990 1
a990 1
    return true;
d1003 1
a1003 1
	  register CONST char *name;
d1020 1
a1020 1
      return false;
d1023 1
a1023 1
  return true;
d1036 1
a1036 1
     boolean relocateable;
a1074 4
static bfd_reloc_status_type gprel16_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));

d1076 2
a1077 2
_bfd_mips_elf_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			     output_bfd, error_message)
d1086 1
a1086 1
  boolean relocateable;
d1103 1
a1103 1
    relocateable = true;
d1106 1
a1106 1
      relocateable = false;
d1115 3
a1117 2
  return gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocateable, data, gp);
d1120 2
a1121 25
static bfd_reloc_status_type
gprel16_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     boolean relocateable;
     PTR data;
     bfd_vma gp;
{
  bfd_vma relocation;
  unsigned long insn;
  unsigned long val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;
d1123 3
a1125 1
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1127 3
a1129 48
  /* Set val to the offset into the section or symbol.  */
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case occurs with the 64-bit MIPS ELF ABI.  */
      val = reloc_entry->addend;
    }
  else
    {
      val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
      if (val & 0x8000)
	val -= 0x10000;
    }

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  insn = (insn & ~0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  /* Make sure it fit in 16 bits.  */
  if ((long) val >= 0x8000 || (long) val < -0x8000)
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset
   from the gp register? XXX */

static bfd_reloc_status_type gprel32_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));

bfd_reloc_status_type
_bfd_mips_elf_gprel32_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
d1138 1
a1138 1
  boolean relocateable;
d1157 1
a1157 1
      relocateable = true;
d1162 1
a1162 1
      relocateable = false;
d1182 1
a1182 1
     boolean relocateable;
d1218 1
a1218 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
d1255 1
a1255 1
  reloc32.howto = &elf_mips_howto_table[R_MIPS_32];
d1268 1
a1268 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
d1296 1
a1296 1
    static boolean warned;
d1302 1
a1302 1
    warned = true;
d1321 1
a1321 1
  boolean relocateable;
d1340 1
a1340 1
    relocateable = true;
d1343 1
a1343 1
      relocateable = false;
d1362 3
a1364 3
	      (((extend & 0x1f) << 11)
	       | (extend & 0x7e0)
	       | (insn & 0x1f)),
d1367 2
a1368 2
  ret = gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			 relocateable, data, gp);
d1372 3
a1374 3
	      ((extend & 0xf800)
	       | ((final >> 11) & 0x1f)
	       | (final & 0x7e0)),
d1377 2
a1378 2
	      ((insn & 0xffe0)
	       | (final & 0x1f)),
a1383 123
/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    case E_MIPS_ARCH_5:
      return 5;
    case E_MIPS_ARCH_32:
      return 32;
    case E_MIPS_ARCH_64:
      return 64;
    }
  return 4;
}

/* Return the MACH for a MIPS e_flags value.  */

static INLINE int
elf_mips_mach (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_MACH)
    {
    case E_MIPS_MACH_3900:
      return bfd_mach_mips3900;

    case E_MIPS_MACH_4010:
      return bfd_mach_mips4010;

    case E_MIPS_MACH_4100:
      return bfd_mach_mips4100;

    case E_MIPS_MACH_4111:
      return bfd_mach_mips4111;

    case E_MIPS_MACH_4650:
      return bfd_mach_mips4650;

    case E_MIPS_MACH_MIPS32_4K:
      return bfd_mach_mips32_4k;

    case E_MIPS_MACH_SB1:
      return bfd_mach_mips_sb1;

    default:
      switch (flags & EF_MIPS_ARCH)
	{
	default:
	case E_MIPS_ARCH_1:
	  return bfd_mach_mips3000;
	  break;

	case E_MIPS_ARCH_2:
	  return bfd_mach_mips6000;
	  break;

	case E_MIPS_ARCH_3:
	  return bfd_mach_mips4000;
	  break;

	case E_MIPS_ARCH_4:
	  return bfd_mach_mips8000;
	  break;

	case E_MIPS_ARCH_5:
	  return bfd_mach_mips5;
	  break;

	case E_MIPS_ARCH_32:
	  return bfd_mach_mips32;
	  break;

	case E_MIPS_ARCH_64:
	  return bfd_mach_mips64;
	  break;
	}
    }

  return 0;
}

/* Return printable name for ABI.  */

static INLINE char *
elf_mips_abi_name (abfd)
     bfd *abfd;
{
  flagword flags;

  if (ABI_N32_P (abfd))
    return "N32";
  else if (ABI_64_P (abfd))
    return "64";

  flags = elf_elfheader (abfd)->e_flags;
  switch (flags & EF_MIPS_ABI)
    {
    case 0:
      return "none";
    case E_MIPS_ABI_O32:
      return "O32";
    case E_MIPS_ABI_O64:
      return "O64";
    case E_MIPS_ABI_EABI32:
      return "EABI32";
    case E_MIPS_ABI_EABI64:
      return "EABI64";
    default:
      return "unknown abi";
    }
}

d1387 2
a1388 2
  bfd_reloc_code_real_type bfd_reloc_val;
  enum elf_mips_reloc_type elf_reloc_val;
d1391 1
a1391 1
static CONST struct elf_reloc_map mips_reloc_map[] =
d1393 1
a1393 1
  { BFD_RELOC_NONE, R_MIPS_NONE, },
d1396 1
d1401 1
a1401 1
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
d1406 1
a1406 1
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 },
d1425 1
d1427 2
a1428 1
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
d1430 2
a1431 2
      if (mips_reloc_map[i].bfd_reloc_val == code)
	return &elf_mips_howto_table[(int) mips_reloc_map[i].elf_reloc_val];
d1443 4
a1446 3
	 size of addresses on this architecture.  */
      if (bfd_arch_bits_per_address (abfd) == 32)
	return &elf_mips_howto_table[(int) R_MIPS_32];
d1448 1
a1448 1
	return &elf_mips_ctor64_howto;
d1471 1
a1471 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1474 1
a1474 1
mips_rtype_to_howto (r_type)
d1476 1
a1481 1
      break;
a1483 1
      break;
a1485 1
      break;
a1487 1
      break;
a1489 1
      break;
a1491 1
      break;
a1493 1
      break;
a1495 1
      break;
a1497 2
      break;

d1500 1
a1500 2
      return &elf_mips_howto_table[r_type];
      break;
d1504 1
a1504 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1510 1
a1510 1
     Elf32_Internal_Rel *dst;
d1515 1
a1515 1
  cache_ptr->howto = mips_rtype_to_howto (r_type);
d1527 1
a1527 1
/* Given a MIPS Elf32_Internal_Rela, fill in an arelent structure.  */
d1533 1
a1533 1
     Elf32_Internal_Rela *dst;
d1535 1
a1535 4
  /* Since an Elf32_Internal_Rel is an initial prefix of an
     Elf32_Internal_Rela, we can just use mips_info_to_howto_rel
     above.  */
  mips_info_to_howto_rel (abfd, cache_ptr, (Elf32_Internal_Rel *) dst);
d1538 1
a1538 1
     (the field omitted in an Elf32_Internal_Rel) we can do it here.  */
d1541 5
a1545 3
/* A .reginfo section holds a single Elf32_RegInfo structure.  These
   routines swap this structure in and out.  They are used outside of
   BFD, so they are globally visible.  */
d1547 4
a1550 5
void
bfd_mips_elf32_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_RegInfo *ex;
     Elf32_RegInfo *in;
d1552 6
a1557 6
  in->ri_gprmask = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gprmask);
  in->ri_cprmask[0] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[0]);
  in->ri_cprmask[1] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[1]);
  in->ri_cprmask[2] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[2]);
  in->ri_cprmask[3] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[3]);
  in->ri_gp_value = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gp_value);
d1559 2
d1562 2
a1563 2
void
bfd_mips_elf32_swap_reginfo_out (abfd, in, ex)
a1564 2
     const Elf32_RegInfo *in;
     Elf32_External_RegInfo *ex;
d1566 10
a1575 13
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gprmask,
		(bfd_byte *) ex->ri_gprmask);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[0],
		(bfd_byte *) ex->ri_cprmask[0]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[1],
		(bfd_byte *) ex->ri_cprmask[1]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[2],
		(bfd_byte *) ex->ri_cprmask[2]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[3],
		(bfd_byte *) ex->ri_cprmask[3]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gp_value,
		(bfd_byte *) ex->ri_gp_value);
}
d1577 2
a1578 5
/* In the 64 bit ABI, the .MIPS.options section holds register
   information in an Elf64_Reginfo structure.  These routines swap
   them in and out.  They are globally visible because they are used
   outside of BFD.  These routines are here so that gas can call them
   without worrying about whether the 64 bit ABI has been included.  */
d1580 1
a1580 13
void
bfd_mips_elf64_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf64_External_RegInfo *ex;
     Elf64_Internal_RegInfo *in;
{
  in->ri_gprmask = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gprmask);
  in->ri_pad = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_pad);
  in->ri_cprmask[0] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[0]);
  in->ri_cprmask[1] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[1]);
  in->ri_cprmask[2] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[2]);
  in->ri_cprmask[3] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[3]);
  in->ri_gp_value = bfd_h_get_64 (abfd, (bfd_byte *) ex->ri_gp_value);
d1582 2
d1585 2
a1586 2
void
bfd_mips_elf64_swap_reginfo_out (abfd, in, ex)
d1588 1
a1588 2
     const Elf64_Internal_RegInfo *in;
     Elf64_External_RegInfo *ex;
d1590 2
a1591 15
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gprmask,
		(bfd_byte *) ex->ri_gprmask);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_pad,
		(bfd_byte *) ex->ri_pad);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[0],
		(bfd_byte *) ex->ri_cprmask[0]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[1],
		(bfd_byte *) ex->ri_cprmask[1]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[2],
		(bfd_byte *) ex->ri_cprmask[2]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[3],
		(bfd_byte *) ex->ri_cprmask[3]);
  bfd_h_put_64 (abfd, (bfd_vma) in->ri_gp_value,
		(bfd_byte *) ex->ri_gp_value);
}
d1593 3
a1595 11
/* Swap an entry in a .gptab section.  Note that these routines rely
   on the equivalence of the two elements of the union.  */

static void
bfd_mips_elf32_swap_gptab_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_gptab *ex;
     Elf32_gptab *in;
{
  in->gt_entry.gt_g_value = bfd_h_get_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = bfd_h_get_32 (abfd, ex->gt_entry.gt_bytes);
d1597 4
a1600 3

static void
bfd_mips_elf32_swap_gptab_out (abfd, in, ex)
d1602 1
a1602 2
     const Elf32_gptab *in;
     Elf32_External_gptab *ex;
d1604 2
a1605 5
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_g_value,
		ex->gt_entry.gt_g_value);
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_bytes,
		ex->gt_entry.gt_bytes);
}
d1607 1
a1607 6036
static void
bfd_elf32_swap_compact_rel_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_compact_rel *in;
     Elf32_External_compact_rel *ex;
{
  bfd_h_put_32 (abfd, (bfd_vma) in->id1, ex->id1);
  bfd_h_put_32 (abfd, (bfd_vma) in->num, ex->num);
  bfd_h_put_32 (abfd, (bfd_vma) in->id2, ex->id2);
  bfd_h_put_32 (abfd, (bfd_vma) in->offset, ex->offset);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved0, ex->reserved0);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved1, ex->reserved1);
}

static void
bfd_elf32_swap_crinfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_crinfo *in;
     Elf32_External_crinfo *ex;
{
  unsigned long l;

  l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
       | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
       | ((in->dist2to & CRINFO_DIST2TO) << CRINFO_DIST2TO_SH)
       | ((in->relvaddr & CRINFO_RELVADDR) << CRINFO_RELVADDR_SH));
  bfd_h_put_32 (abfd, (bfd_vma) l, ex->info);
  bfd_h_put_32 (abfd, (bfd_vma) in->konst, ex->konst);
  bfd_h_put_32 (abfd, (bfd_vma) in->vaddr, ex->vaddr);
}

/* Swap in an options header.  */

void
bfd_mips_elf_swap_options_in (abfd, ex, in)
     bfd *abfd;
     const Elf_External_Options *ex;
     Elf_Internal_Options *in;
{
  in->kind = bfd_h_get_8 (abfd, ex->kind);
  in->size = bfd_h_get_8 (abfd, ex->size);
  in->section = bfd_h_get_16 (abfd, ex->section);
  in->info = bfd_h_get_32 (abfd, ex->info);
}

/* Swap out an options header.  */

void
bfd_mips_elf_swap_options_out (abfd, in, ex)
     bfd *abfd;
     const Elf_Internal_Options *in;
     Elf_External_Options *ex;
{
  bfd_h_put_8 (abfd, in->kind, ex->kind);
  bfd_h_put_8 (abfd, in->size, ex->size);
  bfd_h_put_16 (abfd, in->section, ex->section);
  bfd_h_put_32 (abfd, in->info, ex->info);
}
#if 0
/* Swap in an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_Msym *ex;
     Elf32_Internal_Msym *in;
{
  in->ms_hash_value = bfd_h_get_32 (abfd, ex->ms_hash_value);
  in->ms_info = bfd_h_get_32 (abfd, ex->ms_info);
}
#endif
/* Swap out an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_Internal_Msym *in;
     Elf32_External_Msym *ex;
{
  bfd_h_put_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  bfd_h_put_32 (abfd, in->ms_info, ex->ms_info);
}

/* Determine whether a symbol is global for the purposes of splitting
   the symbol table into global symbols and local symbols.  At least
   on Irix 5, this split must be between section symbols and all other
   symbols.  On most ELF targets the split is between static symbols
   and externally visible symbols.  */

static boolean
mips_elf_sym_is_global (abfd, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
{
  if (SGI_COMPAT(abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
            || bfd_is_und_section (bfd_get_section (sym))
            || bfd_is_com_section (bfd_get_section (sym)));
}

/* Set the right machine number for a MIPS ELF file.  This is used for
   both the 32-bit and the 64-bit ABI.  */

boolean
_bfd_mips_elf_object_p (abfd)
     bfd *abfd;
{
  /* Irix 5 and 6 is broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  elf_bad_symtab (abfd) = true;

  bfd_default_set_arch_mach (abfd, bfd_arch_mips,
			     elf_mips_mach (elf_elfheader (abfd)->e_flags));
  return true;
}

/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     boolean linker ATTRIBUTE_UNUSED;
{
  unsigned long val;
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_mips3000:
      val = E_MIPS_ARCH_1;
      break;

    case bfd_mach_mips3900:
      val = E_MIPS_ARCH_1 | E_MIPS_MACH_3900;
      break;

    case bfd_mach_mips6000:
      val = E_MIPS_ARCH_2;
      break;

    case bfd_mach_mips4000:
    case bfd_mach_mips4300:
      val = E_MIPS_ARCH_3;
      break;

    case bfd_mach_mips4010:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4010;
      break;

    case bfd_mach_mips4100:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4100;
      break;

    case bfd_mach_mips4111:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4111;
      break;

    case bfd_mach_mips4650:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4650;
      break;

    case bfd_mach_mips8000:
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
      val = E_MIPS_ARCH_4;
      break;

    case bfd_mach_mips32:
      val = E_MIPS_ARCH_32;
      break;

    case bfd_mach_mips32_4k:
      val = E_MIPS_ARCH_32 | E_MIPS_MACH_MIPS32_4K;
      break;

    case bfd_mach_mips5:
      val = E_MIPS_ARCH_5;
      break;

    case bfd_mach_mips64:
      val = E_MIPS_ARCH_64;
      break;

    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;
    }

  elf_elfheader (abfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
  elf_elfheader (abfd)->e_flags |= val;

  /* Set the sh_info field for .gptab sections and other appropriate
     info for each special section.  */
  for (i = 1, hdrpp = elf_elfsections (abfd) + 1;
       i < elf_elfheader (abfd)->e_shnum;
       i++, hdrpp++)
    {
      switch ((*hdrpp)->sh_type)
	{
	case SHT_MIPS_MSYM:
	case SHT_MIPS_LIBLIST:
	  sec = bfd_get_section_by_name (abfd, ".dynstr");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_GPTAB:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0);
	  sec = bfd_get_section_by_name (abfd, name + sizeof ".gptab" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_CONTENT:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && strncmp (name, ".MIPS.content",
				  sizeof ".MIPS.content" - 1) == 0);
	  sec = bfd_get_section_by_name (abfd,
					 name + sizeof ".MIPS.content" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_SYMBOL_LIB:
	  sec = bfd_get_section_by_name (abfd, ".dynsym");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  sec = bfd_get_section_by_name (abfd, ".liblist");
	  if (sec != NULL)
	    (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_EVENTS:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL);
	  if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0)
	    sec = bfd_get_section_by_name (abfd,
					   name + sizeof ".MIPS.events" - 1);
	  else
	    {
	      BFD_ASSERT (strncmp (name, ".MIPS.post_rel",
				   sizeof ".MIPS.post_rel" - 1) == 0);
	      sec = bfd_get_section_by_name (abfd,
					     (name
					      + sizeof ".MIPS.post_rel" - 1));
	    }
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	}
    }
}

/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */

boolean
_bfd_mips_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

/* Copy backend specific data from one object module to another */

boolean
_bfd_mips_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

boolean
_bfd_mips_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  boolean ok;
  boolean null_input_bfd = true;
  asection *sec;

  /* Check if we have the same endianess */
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_NOREORDER;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return false;
	}

      return true;
    }

  /* Check flag compatibility.  */

  new_flags &= ~EF_MIPS_NOREORDER;
  old_flags &= ~EF_MIPS_NOREORDER;

  if (new_flags == old_flags)
    return true;

  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic sections and empty .text, .data and .bss sections
	  which are automatically generated by gas.  */
      if (strcmp (sec->name, ".reginfo")
	  && strcmp (sec->name, ".mdebug")
	  && ((!strcmp (sec->name, ".text")
	       || !strcmp (sec->name, ".data")
	       || !strcmp (sec->name, ".bss"))
	      && sec->_raw_size != 0))
	{
	  null_input_bfd = false;
	  break;
	}
    }
  if (null_input_bfd)
    return true;

  ok = true;

  if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
    {
      new_flags &= ~EF_MIPS_PIC;
      old_flags &= ~EF_MIPS_PIC;
      (*_bfd_error_handler)
	(_("%s: linking PIC files with non-PIC files"),
	 bfd_get_filename (ibfd));
      ok = false;
    }

  if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
    {
      new_flags &= ~EF_MIPS_CPIC;
      old_flags &= ~EF_MIPS_CPIC;
      (*_bfd_error_handler)
	(_("%s: linking abicalls files with non-abicalls files"),
	 bfd_get_filename (ibfd));
      ok = false;
    }

  /* Compare the ISA's.  */
  if ((new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH))
      != (old_flags & (EF_MIPS_ARCH | EF_MIPS_MACH)))
    {
      int new_mach = new_flags & EF_MIPS_MACH;
      int old_mach = old_flags & EF_MIPS_MACH;
      int new_isa = elf_mips_isa (new_flags);
      int old_isa = elf_mips_isa (old_flags);

      /* If either has no machine specified, just compare the general isa's.
	 Some combinations of machines are ok, if the isa's match.  */
      if (! new_mach
	  || ! old_mach
	  || new_mach == old_mach
	  )
	{
	  /* Don't warn about mixing code using 32-bit ISAs, or mixing code
	     using 64-bit ISAs.  They will normally use the same data sizes
	     and calling conventions.  */

	  if ((  (new_isa == 1 || new_isa == 2 || new_isa == 32)
	       ^ (old_isa == 1 || old_isa == 2 || old_isa == 32)) != 0)
	    {
	      (*_bfd_error_handler)
	       (_("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"),
		bfd_get_filename (ibfd), new_isa, old_isa);
	      ok = false;
	    }
	}

      else
	{
	  (*_bfd_error_handler)
	    (_("%s: ISA mismatch (%d) with previous modules (%d)"),
	     bfd_get_filename (ibfd),
	     elf_mips_mach (new_flags),
	     elf_mips_mach (old_flags));
	  ok = false;
	}

      new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
    }

  /* Compare ABI's.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
     does set EI_CLASS differently from any 32-bit ABI.  */
  if ((new_flags & EF_MIPS_ABI) != (old_flags & EF_MIPS_ABI)
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	  != elf_elfheader (obfd)->e_ident[EI_CLASS]))
    {
      /* Only error if both are set (to different values).  */
      if (((new_flags & EF_MIPS_ABI) && (old_flags & EF_MIPS_ABI))
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	      != elf_elfheader (obfd)->e_ident[EI_CLASS]))
	{
	  (*_bfd_error_handler)
	    (_("%s: ABI mismatch: linking %s module with previous %s modules"),
	     bfd_get_filename (ibfd),
	     elf_mips_abi_name (ibfd),
	     elf_mips_abi_name (obfd));
	  ok = false;
	}
      new_flags &= ~EF_MIPS_ABI;
      old_flags &= ~EF_MIPS_ABI;
    }

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_get_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = false;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
    }

  return true;
}

boolean
_bfd_mips_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O32)
    fprintf (file, _(" [abi=O32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O64)
    fprintf (file, _(" [abi=O64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32)
    fprintf (file, _(" [abi=EABI32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
    fprintf (file, _(" [abi=EABI64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI))
    fprintf (file, _(" [abi unknown]"));
  else if (ABI_N32_P (abfd))
    fprintf (file, _(" [abi=N32]"));
  else if (ABI_64_P (abfd))
    fprintf (file, _(" [abi=64]"));
  else
    fprintf (file, _(" [no abi set]"));

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1)
    fprintf (file, _(" [mips1]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2)
    fprintf (file, _(" [mips2]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_3)
    fprintf (file, _(" [mips3]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_4)
    fprintf (file, _(" [mips4]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_5)
    fprintf (file, _ (" [mips5]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32)
    fprintf (file, _ (" [mips32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64)
    fprintf (file, _ (" [mips64]"));
  else
    fprintf (file, _(" [unknown ISA]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_32BITMODE)
    fprintf (file, _(" [32bitmode]"));
  else
    fprintf (file, _(" [not 32bitmode]"));

  fputc ('\n', file);

  return true;
}

/* Handle a MIPS specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.
   This routine supports both the 32-bit and 64-bit ELF ABI.

   FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure
   how to.  */

boolean
_bfd_mips_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  flagword flags = 0;

  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_MIPS_LIBLIST:
      if (strcmp (name, ".liblist") != 0)
	return false;
      break;
    case SHT_MIPS_MSYM:
      if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) != 0)
	return false;
      break;
    case SHT_MIPS_CONFLICT:
      if (strcmp (name, ".conflict") != 0)
	return false;
      break;
    case SHT_MIPS_GPTAB:
      if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) != 0)
	return false;
      break;
    case SHT_MIPS_UCODE:
      if (strcmp (name, ".ucode") != 0)
	return false;
      break;
    case SHT_MIPS_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return false;
      flags = SEC_DEBUGGING;
      break;
    case SHT_MIPS_REGINFO:
      if (strcmp (name, ".reginfo") != 0
	  || hdr->sh_size != sizeof (Elf32_External_RegInfo))
	return false;
      flags = (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_SIZE);
      break;
    case SHT_MIPS_IFACE:
      if (strcmp (name, ".MIPS.interfaces") != 0)
	return false;
      break;
    case SHT_MIPS_CONTENT:
      if (strncmp (name, ".MIPS.content", sizeof ".MIPS.content" - 1) != 0)
	return false;
      break;
    case SHT_MIPS_OPTIONS:
      if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) != 0)
	return false;
      break;
    case SHT_MIPS_DWARF:
      if (strncmp (name, ".debug_", sizeof ".debug_" - 1) != 0)
	return false;
      break;
    case SHT_MIPS_SYMBOL_LIB:
      if (strcmp (name, ".MIPS.symlib") != 0)
	return false;
      break;
    case SHT_MIPS_EVENTS:
      if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) != 0
	  && strncmp (name, ".MIPS.post_rel",
		      sizeof ".MIPS.post_rel" - 1) != 0)
	return false;
      break;
    default:
      return false;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return false;

  if (flags)
    {
      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
				   (bfd_get_section_flags (abfd,
							   hdr->bfd_section)
				    | flags)))
	return false;
    }

  /* FIXME: We should record sh_info for a .gptab section.  */

  /* For a .reginfo section, set the gp value in the tdata information
     from the contents of this section.  We need the gp value while
     processing relocs, so we just get it now.  The .reginfo section
     is not used in the 64-bit MIPS ELF ABI.  */
  if (hdr->sh_type == SHT_MIPS_REGINFO)
    {
      Elf32_External_RegInfo ext;
      Elf32_RegInfo s;

      if (! bfd_get_section_contents (abfd, hdr->bfd_section, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
      bfd_mips_elf32_swap_reginfo_in (abfd, &ext, &s);
      elf_gp (abfd) = s.ri_gp_value;
    }

  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return false;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      (file_ptr) 0, hdr->sh_size))
	{
	  free (contents);
	  return false;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      Elf32_RegInfo intreg;

	      bfd_mips_elf32_swap_reginfo_in
		(abfd,
		 ((Elf32_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

  return true;
}

/* Set the correct type for a MIPS ELF section.  We do this by the
   section name, which is a hack, but ought to work.  This routine is
   used by both the 32-bit and the 64-bit ABI.  */

boolean
_bfd_mips_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
     asection *sec;
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".liblist") == 0)
    {
      hdr->sh_type = SHT_MIPS_LIBLIST;
      hdr->sh_info = sec->_raw_size / sizeof (Elf32_Lib);
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".conflict") == 0)
    hdr->sh_type = SHT_MIPS_CONFLICT;
  else if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0)
    {
      hdr->sh_type = SHT_MIPS_GPTAB;
      hdr->sh_entsize = sizeof (Elf32_External_gptab);
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".ucode") == 0)
    hdr->sh_type = SHT_MIPS_UCODE;
  else if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_MIPS_DEBUG;
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if (strcmp (name, ".reginfo") == 0)
    {
      hdr->sh_type = SHT_MIPS_REGINFO;
      /* In a shared object on Irix 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd))
	{
	  if ((abfd->flags & DYNAMIC) != 0)
	    hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
	  else
	    hdr->sh_entsize = 1;
	}
      else
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
    }
  else if (SGI_COMPAT (abfd)
	   && (strcmp (name, ".hash") == 0
	       || strcmp (name, ".dynamic") == 0
	       || strcmp (name, ".dynstr") == 0))
    {
      if (SGI_COMPAT (abfd))
	hdr->sh_entsize = 0;
#if 0
      /* This isn't how the Irix 6 linker behaves.  */
      hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
#endif
    }
  else if (strcmp (name, ".got") == 0
	   || strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_MIPS_GPREL;
  else if (strcmp (name, ".MIPS.interfaces") == 0)
    {
      hdr->sh_type = SHT_MIPS_IFACE;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strncmp (name, ".MIPS.content", strlen (".MIPS.content")) == 0)
    {
      hdr->sh_type = SHT_MIPS_CONTENT;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_OPTIONS;
      hdr->sh_entsize = 1;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strncmp (name, ".debug_", sizeof ".debug_" - 1) == 0)
    hdr->sh_type = SHT_MIPS_DWARF;
  else if (strcmp (name, ".MIPS.symlib") == 0)
    {
      hdr->sh_type = SHT_MIPS_SYMBOL_LIB;
      /* The sh_link and sh_info fields are set in
         final_write_processing.  */
    }
  else if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0
	   || strncmp (name, ".MIPS.post_rel",
		       sizeof ".MIPS.post_rel" - 1) == 0)
    {
      hdr->sh_type = SHT_MIPS_EVENTS;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_flags |= SHF_ALLOC;
      hdr->sh_entsize = 8;
    }

  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.  */
  if ((sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2
	= (Elf_Internal_Shdr *) bfd_zalloc (abfd, sizeof (Elf_Internal_Shdr));
      if (!esd->rel_hdr2)
	return false;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
				!elf_section_data (sec)->use_rela_p);
    }

  return true;
}

/* Given a BFD section, try to locate the corresponding ELF section
   index.  This is used by both the 32-bit and the 64-bit ABI.
   Actually, it's not clear to me that the 64-bit ABI supports these,
   but for non-PIC objects we will certainly want support for at least
   the .scommon section.  */

boolean
_bfd_mips_elf_section_from_bfd_section (abfd, hdr, sec, retval)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    {
      *retval = SHN_MIPS_SCOMMON;
      return true;
    }
  if (strcmp (bfd_get_section_name (abfd, sec), ".acommon") == 0)
    {
      *retval = SHN_MIPS_ACOMMON;
      return true;
    }
  return false;
}

/* When are writing out the .options or .MIPS.options section,
   remember the bytes we are writing out, so that we can install the
   GP value in the section_processing routine.  */

boolean
_bfd_mips_elf_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (strcmp (section->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
    {
      bfd_byte *c;

      if (elf_section_data (section) == NULL)
	{
	  section->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
	  if (elf_section_data (section) == NULL)
	    return false;
	}
      c = (bfd_byte *) elf_section_data (section)->tdata;
      if (c == NULL)
	{
	  bfd_size_type size;

	  if (section->_cooked_size != 0)
	    size = section->_cooked_size;
	  else
	    size = section->_raw_size;
	  c = (bfd_byte *) bfd_zalloc (abfd, size);
	  if (c == NULL)
	    return false;
	  elf_section_data (section)->tdata = (PTR) c;
	}

      memcpy (c + offset, location, count);
    }

  return _bfd_elf_set_section_contents (abfd, section, location, offset,
					count);
}

/* Work over a section just before writing it out.  This routine is
   used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize
   sections that need the SHF_MIPS_GPREL flag by name; there has to be
   a better way.  */

boolean
_bfd_mips_elf_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_REGINFO
      && hdr->sh_size > 0)
    {
      bfd_byte buf[4];

      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
      BFD_ASSERT (hdr->contents == NULL);

      if (bfd_seek (abfd,
		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
		    SEEK_SET) == -1)
	return false;
      bfd_h_put_32 (abfd, (bfd_vma) elf_gp (abfd), buf);
      if (bfd_write (buf, (bfd_size_type) 1, (bfd_size_type) 4, abfd) != 4)
	return false;
    }

  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) == -1)
		return false;
	      bfd_h_put_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 8, abfd) != 8)
		return false;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[4];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf32_External_RegInfo) - 4)),
			    SEEK_SET) == -1)
		return false;
	      bfd_h_put_32 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 4, abfd) != 4)
		return false;
	    }
	  l += intopt.size;
	}
    }

  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0
	  || strcmp (name, ".lit8") == 0
	  || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
      else if (strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return true;
}

/* MIPS ELF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
   section.  This approach is copied from ecoff.c.  */
static asection mips_elf_scom_section;
static asymbol mips_elf_scom_symbol;
static asymbol *mips_elf_scom_symbol_ptr;

/* MIPS ELF also uses an acommon section, which represents an
   allocated common symbol which may be overridden by a
   definition in a shared library.  */
static asection mips_elf_acom_section;
static asymbol mips_elf_acom_symbol;
static asymbol *mips_elf_acom_symbol_ptr;

/* Handle the special MIPS section numbers that a symbol may use.
   This is used for both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_symbol_processing (abfd, asym)
     bfd *abfd;
     asymbol *asym;
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_MIPS_ACOMMON:
      /* This section is used in a dynamically linked executable file.
	 It is an allocated common section.  The dynamic linker can
	 either resolve these symbols to something in a shared
	 library, or it can just leave them here.  For our purposes,
	 we can consider these symbols to be in a new section.  */
      if (mips_elf_acom_section.name == NULL)
	{
	  /* Initialize the acommon section.  */
	  mips_elf_acom_section.name = ".acommon";
	  mips_elf_acom_section.flags = SEC_ALLOC;
	  mips_elf_acom_section.output_section = &mips_elf_acom_section;
	  mips_elf_acom_section.symbol = &mips_elf_acom_symbol;
	  mips_elf_acom_section.symbol_ptr_ptr = &mips_elf_acom_symbol_ptr;
	  mips_elf_acom_symbol.name = ".acommon";
	  mips_elf_acom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_acom_symbol.section = &mips_elf_acom_section;
	  mips_elf_acom_symbol_ptr = &mips_elf_acom_symbol;
	}
      asym->section = &mips_elf_acom_section;
      break;

    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
      if (asym->value > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      if (mips_elf_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  mips_elf_scom_section.name = ".scommon";
	  mips_elf_scom_section.flags = SEC_IS_COMMON;
	  mips_elf_scom_section.output_section = &mips_elf_scom_section;
	  mips_elf_scom_section.symbol = &mips_elf_scom_symbol;
	  mips_elf_scom_section.symbol_ptr_ptr = &mips_elf_scom_symbol_ptr;
	  mips_elf_scom_symbol.name = ".scommon";
	  mips_elf_scom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_scom_symbol.section = &mips_elf_scom_section;
	  mips_elf_scom_symbol_ptr = &mips_elf_scom_symbol;
	}
      asym->section = &mips_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;

    case SHN_MIPS_SUNDEFINED:
      asym->section = bfd_und_section_ptr;
      break;

#if 0 /* for SGI_COMPAT */
    case SHN_MIPS_TEXT:
      asym->section = mips_elf_text_section_ptr;
      break;

    case SHN_MIPS_DATA:
      asym->section = mips_elf_data_section_ptr;
      break;
#endif
    }
}

/* When creating an Irix 5 executable, we need REGINFO and RTPROC
   segments.  */

int
_bfd_mips_elf_additional_program_headers (abfd)
     bfd *abfd;
{
  asection *s;
  int ret = 0;

  /* See if we need a PT_MIPS_REGINFO segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s && (s->flags & SEC_LOAD))
    ++ret;

  /* See if we need a PT_MIPS_OPTIONS segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && bfd_get_section_by_name (abfd,
				  MIPS_ELF_OPTIONS_SECTION_NAME (abfd)))
    ++ret;

  /* See if we need a PT_MIPS_RTPROC segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix5
      && bfd_get_section_by_name (abfd, ".dynamic")
      && bfd_get_section_by_name (abfd, ".mdebug"))
    ++ret;

  return ret;
}

/* Modify the segment map for an Irix 5 executable.  */

boolean
_bfd_mips_elf_modify_segment_map (abfd)
     bfd *abfd;
{
  asection *s;
  struct elf_segment_map *m, **pm;

  /* If there is a .reginfo section, we need a PT_MIPS_REGINFO
     segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_REGINFO)
	  break;
      if (m == NULL)
	{
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	  if (m == NULL)
	    return false;

	  m->p_type = PT_MIPS_REGINFO;
	  m->count = 1;
	  m->sections[0] = s;

	  /* We want to put it after the PHDR and INTERP segments.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }

  /* For IRIX 6, we don't have .mdebug sections, nor does anything but
     .dynamic end up in PT_DYNAMIC.  However, we do have to insert a
     PT_OPTIONS segement immediately following the program header
     table.  */
  if (IRIX_COMPAT (abfd) == ict_irix6)
    {
      asection *s;

      for (s = abfd->sections; s; s = s->next)
	if (elf_section_data (s)->this_hdr.sh_type == SHT_MIPS_OPTIONS)
	  break;

      if (s)
	{
	  struct elf_segment_map *options_segment;

	  /* Usually, there's a program header table.  But, sometimes
	     there's not (like when running the `ld' testsuite).  So,
	     if there's no program header table, we just put the
	     options segement at the end.  */
	  for (pm = &elf_tdata (abfd)->segment_map;
	       *pm != NULL;
	       pm = &(*pm)->next)
	    if ((*pm)->p_type == PT_PHDR)
	      break;

	  options_segment = bfd_zalloc (abfd,
					sizeof (struct elf_segment_map));
	  options_segment->next = *pm;
	  options_segment->p_type = PT_MIPS_OPTIONS;
	  options_segment->p_flags = PF_R;
	  options_segment->p_flags_valid = true;
	  options_segment->count = 1;
	  options_segment->sections[0] = s;
	  *pm = options_segment;
	}
    }
  else
    {
      if (IRIX_COMPAT (abfd) == ict_irix5)
	{
	  /* If there are .dynamic and .mdebug sections, we make a room
	     for the RTPROC header.  FIXME: Rewrite without section names.  */
	  if (bfd_get_section_by_name (abfd, ".interp") == NULL
	      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
	    {
	      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
		if (m->p_type == PT_MIPS_RTPROC)
		  break;
	      if (m == NULL)
		{
		  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
		  if (m == NULL)
		    return false;

		  m->p_type = PT_MIPS_RTPROC;

		  s = bfd_get_section_by_name (abfd, ".rtproc");
		  if (s == NULL)
		    {
		      m->count = 0;
		      m->p_flags = 0;
		      m->p_flags_valid = 1;
		    }
		  else
		    {
		      m->count = 1;
		      m->sections[0] = s;
		    }

		  /* We want to put it after the DYNAMIC segment.  */
		  pm = &elf_tdata (abfd)->segment_map;
		  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		    pm = &(*pm)->next;
		  if (*pm != NULL)
		    pm = &(*pm)->next;

		  m->next = *pm;
		  *pm = m;
		}
	    }
	}
      /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic,
	 .dynstr, .dynsym, and .hash sections, and everything in
	 between.  */
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL;
	   pm = &(*pm)->next)
	if ((*pm)->p_type == PT_DYNAMIC)
	  break;
      m = *pm;
      if (IRIX_COMPAT (abfd) == ict_none)
	{
	  /* For a normal mips executable the permissions for the PT_DYNAMIC
	     segment are read, write and execute. We do that here since
	     the code in elf.c sets only the read permission. This matters
	     sometimes for the dynamic linker.  */
	  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
	    {
	      m->p_flags = PF_R | PF_W | PF_X;
	      m->p_flags_valid = 1;
	    }
	}
      if (m != NULL
	  && m->count == 1 && strcmp (m->sections[0]->name, ".dynamic") == 0)
	{
	  static const char *sec_names[] =
	  {
	    ".dynamic", ".dynstr", ".dynsym", ".hash"
	  };
	  bfd_vma low, high;
	  unsigned int i, c;
	  struct elf_segment_map *n;

	  low = 0xffffffff;
	  high = 0;
	  for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
	    {
	      s = bfd_get_section_by_name (abfd, sec_names[i]);
	      if (s != NULL && (s->flags & SEC_LOAD) != 0)
		{
		  bfd_size_type sz;

		  if (low > s->vma)
		    low = s->vma;
		  sz = s->_cooked_size;
		  if (sz == 0)
		    sz = s->_raw_size;
		  if (high < s->vma + sz)
		    high = s->vma + sz;
		}
	    }

	  c = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    if ((s->flags & SEC_LOAD) != 0
		&& s->vma >= low
		&& ((s->vma
		     + (s->_cooked_size !=
			0 ? s->_cooked_size : s->_raw_size)) <= high))
	      ++c;

	  n = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
	  if (n == NULL)
	    return false;
	  *n = *m;
	  n->count = c;

	  i = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      if ((s->flags & SEC_LOAD) != 0
		  && s->vma >= low
		  && ((s->vma
		       + (s->_cooked_size != 0 ?
			  s->_cooked_size : s->_raw_size)) <= high))
		{
		  n->sections[i] = s;
		  ++i;
		}
	    }

	  *pm = n;
	}
    }

  return true;
}

/* The structure of the runtime procedure descriptor created by the
   loader for use by the static exception system.  */

typedef struct runtime_pdr {
	bfd_vma	adr;		/* memory address of start of procedure */
	long	regmask;	/* save register mask */
	long	regoffset;	/* save register offset */
	long	fregmask;	/* save floating point register mask */
	long	fregoffset;	/* save floating point register offset */
	long	frameoffset;	/* frame size */
	short	framereg;	/* frame pointer register */
	short	pcreg;		/* offset or reg of return pc */
	long	irpss;		/* index into the runtime string table */
	long	reserved;
	struct exception_info *exception_info;/* pointer to exception array */
} RPDR, *pRPDR;
#define cbRPDR sizeof (RPDR)
#define rpdNil ((pRPDR) 0)

/* Swap RPDR (runtime procedure table entry) for output.  */

static void ecoff_swap_rpdr_out
  PARAMS ((bfd *, const RPDR *, struct rpdr_ext *));

static void
ecoff_swap_rpdr_out (abfd, in, ex)
     bfd *abfd;
     const RPDR *in;
     struct rpdr_ext *ex;
{
  /* ecoff_put_off was defined in ecoffswap.h.  */
  ecoff_put_off (abfd, in->adr, (bfd_byte *) ex->p_adr);
  bfd_h_put_32 (abfd, in->regmask, (bfd_byte *) ex->p_regmask);
  bfd_h_put_32 (abfd, in->regoffset, (bfd_byte *) ex->p_regoffset);
  bfd_h_put_32 (abfd, in->fregmask, (bfd_byte *) ex->p_fregmask);
  bfd_h_put_32 (abfd, in->fregoffset, (bfd_byte *) ex->p_fregoffset);
  bfd_h_put_32 (abfd, in->frameoffset, (bfd_byte *) ex->p_frameoffset);

  bfd_h_put_16 (abfd, in->framereg, (bfd_byte *) ex->p_framereg);
  bfd_h_put_16 (abfd, in->pcreg, (bfd_byte *) ex->p_pcreg);

  bfd_h_put_32 (abfd, in->irpss, (bfd_byte *) ex->p_irpss);
#if 0 /* FIXME */
  ecoff_put_off (abfd, in->exception_info, (bfd_byte *) ex->p_exception_info);
#endif
}

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */

boolean
_bfd_mips_elf_read_ecoff_info (abfd, section, debug)
     bfd *abfd;
     asection *section;
     struct ecoff_debug_info *debug;
{
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));

  ext_hdr = (char *) bfd_malloc ((size_t) swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;

  if (bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				swap->external_hdr_size)
      == false)
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
	  || (bfd_read (debug->ptr, size, symhdr->count,		\
			abfd) != size * symhdr->count))			\
	goto error_return;						\
    }

  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
#undef READ

  debug->fdr = NULL;
  debug->adjust = NULL;

  return true;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return false;
}

/* MIPS ELF local labels start with '$', not 'L'.  */

static boolean
mips_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == '$')
    return true;

  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
}

/* MIPS ELF uses a special find_nearest_line routine in order the
   handle the ECOFF debugging information.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

boolean
_bfd_mips_elf_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
				 functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  asection *msec;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr,
				     ABI_64_P (abfd) ? 8 : 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return true;

  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct mips_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

      /* If we are called during a link, mips_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;

      fi = elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;

	  fi = ((struct mips_elf_find_line *)
		bfd_zalloc (abfd, sizeof (struct mips_elf_find_line)));
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return false;
	    }

	  if (! _bfd_mips_elf_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return false;
	    }

	  /* Swap in the FDR information.  */
	  fi->d.fdr = ((struct fdr *)
		       bfd_alloc (abfd,
				  (fi->d.symbolic_header.ifdMax *
				   sizeof (struct fdr))));
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return false;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);

	  elf_tdata (abfd)->find_line_info = fi;

	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}

      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
	{
	  msec->flags = origflags;
	  return true;
	}

      msec->flags = origflags;
    }

  /* Fall back on the generic ELF find_nearest_line routine.  */

  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
}

  /* The mips16 compiler uses a couple of special sections to handle
     floating point arguments.

     Section names that look like .mips16.fn.FNNAME contain stubs that
     copy floating point arguments from the fp regs to the gp regs and
     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
     call should be redirected to the stub instead.  If no 32 bit
     function calls FNNAME, the stub should be discarded.  We need to
     consider any reference to the function, not just a call, because
     if the address of the function is taken we will need the stub,
     since the address might be passed to a 32 bit function.

     Section names that look like .mips16.call.FNNAME contain stubs
     that copy floating point arguments from the gp regs to the fp
     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
     then any 16 bit function that calls FNNAME should be redirected
     to the stub instead.  If FNNAME is not a 32 bit function, the
     stub should be discarded.

     .mips16.call.fp.FNNAME sections are similar, but contain stubs
     which call FNNAME and then copy the return value from the fp regs
     to the gp regs.  These stubs store the return value in $18 while
     calling FNNAME; any function which might call one of these stubs
     must arrange to save $18 around the call.  (This case is not
     needed for 32 bit functions that call 16 bit functions, because
     16 bit functions always return floating point values in both
     $f0/$f1 and $2/$3.)

     Note that in all cases FNNAME might be defined statically.
     Therefore, FNNAME is not used literally.  Instead, the relocation
     information will indicate which symbol the section is for.

     We record any stubs that we find in the symbol table.  */

#define FN_STUB ".mips16.fn."
#define CALL_STUB ".mips16.call."
#define CALL_FP_STUB ".mips16.call.fp."

/* MIPS ELF linker hash table.  */

struct mips_elf_link_hash_table
{
  struct elf_link_hash_table root;
#if 0
  /* We no longer use this.  */
  /* String section indices for the dynamic section symbols.  */
  bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
#endif
  /* The number of .rtproc entries.  */
  bfd_size_type procedure_count;
  /* The size of the .compact_rel section (if SGI_COMPAT).  */
  bfd_size_type compact_rel_size;
  /* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic
     entry is set to the address of __rld_obj_head as in Irix 5.  */
  boolean use_rld_obj_head;
  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
  bfd_vma rld_value;
  /* This is set if we see any mips16 stub sections.  */
  boolean mips16_stubs_seen;
};

/* Look up an entry in a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct mips_elf_link_hash_entry *)					\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the MIPS ELF linker hash table from a link_info structure.  */

#define mips_elf_hash_table(p) \
  ((struct mips_elf_link_hash_table *) ((p)->hash))

static boolean mips_elf_output_extsym
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));

/* Create an entry in a MIPS ELF linker hash table.  */

static struct bfd_hash_entry *
mips_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct mips_elf_link_hash_entry *ret =
    (struct mips_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
    ret = ((struct mips_elf_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct mips_elf_link_hash_entry)));
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct mips_elf_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct mips_elf_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->possibly_dynamic_relocs = 0;
      ret->min_dyn_reloc_index = 0;
      ret->no_fn_stub = false;
      ret->fn_stub = NULL;
      ret->need_fn_stub = false;
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

void
_bfd_mips_elf_hide_symbol (info, h)
     struct bfd_link_info *info;
     struct mips_elf_link_hash_entry *h;
{
  bfd *dynobj;
  asection *got;
  struct mips_got_info *g;
  dynobj = elf_hash_table (info)->dynobj;
  got = bfd_get_section_by_name (dynobj, ".got");
  g = (struct mips_got_info *) elf_section_data (got)->tdata;

  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  h->root.plt.offset = (bfd_vma) -1;
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;

  /* FIXME: Do we allocate too much GOT space here?  */
  g->local_gotno++;
  got->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
}

/* Create a MIPS ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_mips_elf_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct mips_elf_link_hash_table *ret;

  ret = ((struct mips_elf_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct mips_elf_link_hash_table)));
  if (ret == (struct mips_elf_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       mips_elf_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

#if 0
  /* We no longer use this.  */
  for (i = 0; i < SIZEOF_MIPS_DYNSYM_SECNAMES; i++)
    ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
#endif
  ret->procedure_count = 0;
  ret->compact_rel_size = 0;
  ret->use_rld_obj_head = false;
  ret->rld_value = 0;
  ret->mips16_stubs_seen = false;

  return &ret->root.root;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special MIPS section numbers here.  */

boolean
_bfd_mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (SGI_COMPAT (abfd)
      && (abfd->flags & DYNAMIC) != 0
      && strcmp (*namep, "_rld_new_interface") == 0)
    {
      /* Skip Irix 5 rld entry name.  */
      *namep = NULL;
      return true;
    }

  switch (sym->st_shndx)
    {
    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols.  */
      if (sym->st_size > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_MIPS_TEXT:
      /* This section is used in a shared object.  */
      if (elf_tdata (abfd)->elf_text_section == NULL)
	{
	  asymbol *elf_text_symbol;
	  asection *elf_text_section;

	  elf_text_section = bfd_zalloc (abfd, sizeof (asection));
	  if (elf_text_section == NULL)
	    return false;

	  elf_text_symbol = bfd_zalloc (abfd, sizeof (asymbol));
	  if (elf_text_symbol == NULL)
	    return false;

	  /* Initialize the section.  */

	  elf_tdata (abfd)->elf_text_section = elf_text_section;
	  elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;

	  elf_text_section->symbol = elf_text_symbol;
	  elf_text_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_text_symbol;

	  elf_text_section->name = ".text";
	  elf_text_section->flags = SEC_NO_FLAGS;
	  elf_text_section->output_section = NULL;
	  elf_text_section->owner = abfd;
	  elf_text_symbol->name = ".text";
	  elf_text_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_text_symbol->section = elf_text_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = elf_tdata (abfd)->elf_text_section;
      break;

    case SHN_MIPS_ACOMMON:
      /* Fall through. XXX Can we treat this as allocated data?  */
    case SHN_MIPS_DATA:
      /* This section is used in a shared object.  */
      if (elf_tdata (abfd)->elf_data_section == NULL)
	{
	  asymbol *elf_data_symbol;
	  asection *elf_data_section;

	  elf_data_section = bfd_zalloc (abfd, sizeof (asection));
	  if (elf_data_section == NULL)
	    return false;

	  elf_data_symbol = bfd_zalloc (abfd, sizeof (asymbol));
	  if (elf_data_symbol == NULL)
	    return false;

	  /* Initialize the section.  */

	  elf_tdata (abfd)->elf_data_section = elf_data_section;
	  elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;

	  elf_data_section->symbol = elf_data_symbol;
	  elf_data_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_data_symbol;

	  elf_data_section->name = ".data";
	  elf_data_section->flags = SEC_NO_FLAGS;
	  elf_data_section->output_section = NULL;
	  elf_data_section->owner = abfd;
	  elf_data_symbol->name = ".data";
	  elf_data_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_data_symbol->section = elf_data_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = elf_tdata (abfd)->elf_data_section;
      break;

    case SHN_MIPS_SUNDEFINED:
      *secp = bfd_und_section_ptr;
      break;
    }

  if (SGI_COMPAT (abfd)
      && ! info->shared
      && info->hash->creator == abfd->xvec
      && strcmp (*namep, "__rld_obj_head") == 0)
    {
      struct elf_link_hash_entry *h;

      /* Mark __rld_obj_head as dynamic.  */
      h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, *namep, BSF_GLOBAL, *secp,
	      (bfd_vma) *valp, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
	return false;
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;

      mips_elf_hash_table (info)->use_rld_obj_head = true;
    }

  /* If this is a mips16 text symbol, add 1 to the value to make it
     odd.  This will cause something like .word SYM to come up with
     the right value when it is loaded into the PC.  */
  if (sym->st_other == STO_MIPS16)
    ++*valp;

  return true;
}

/* Structure used to pass information to mips_elf_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  boolean failed;
};

/* This routine is used to write out ECOFF debugging external symbol
   information.  It is called via mips_elf_link_hash_traverse.  The
   ECOFF external symbol information must match the ELF external
   symbol information.  Unfortunately, at this point we don't know
   whether a symbol is required by reloc information, so the two
   tables may wind up being different.  We must sort out the external
   symbol information before we can set the final size of the .mdebug
   section, and we must set the size of the .mdebug section before we
   can relocate any sections, and we can't know which symbols are
   required by relocation until we relocate the sections.
   Fortunately, it is relatively unlikely that any symbol will be
   stripped but required by a reloc.  In particular, it can not happen
   when generating a final executable.  */

static boolean
mips_elf_output_extsym (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  struct extsym_info *einfo = (struct extsym_info *) data;
  boolean strip;
  asection *sec, *output_section;

  if (h->root.indx == -2)
    strip = false;
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = true;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   false, false) == NULL))
    strip = true;
  else
    strip = false;

  if (strip)
    return true;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type == bfd_link_hash_undefined
	  || h->root.root.type == bfd_link_hash_undefweak)
	{
	  const char *name;

	  /* Use undefined class.  Also, set class and type for some
             special symbols.  */
	  name = h->root.root.root.string;
	  if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	      || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	    {
	      h->esym.asym.sc = scData;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = 0;
	    }
	  else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value =
		mips_elf_hash_table (einfo->info)->procedure_count;
	    }
	  else if (strcmp (name, "_gp_disp") == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = elf_gp (einfo->abfd);
	    }
	  else
	    h->esym.asym.sc = scUndefined;
	}
      else if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      struct mips_elf_link_hash_entry *hd = h;
      boolean no_fn_stub = h->no_fn_stub;

      while (hd->root.root.type == bfd_link_hash_indirect)
	{
	  hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
	}

      if (!no_fn_stub)
	{
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
#if 0 /* FIXME?  */
	  h->esym.ifd = 0;
#endif
	}
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = true;
      return false;
    }

  return true;
}

/* Create a runtime procedure table from the .mdebug section.  */

static boolean
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
{
  const struct ecoff_debug_swap *swap;
  HDRR *hdr = &debug->symbolic_header;
  RPDR *rpdr, *rp;
  struct rpdr_ext *erp;
  PTR rtproc;
  struct pdr_ext *epdr;
  struct sym_ext *esym;
  char *ss, **sv;
  char *str;
  unsigned long size, count;
  unsigned long sindex;
  unsigned long i;
  PDR pdr;
  SYMR sym;
  const char *no_name_func = _("static procedure (no name)");

  epdr = NULL;
  rpdr = NULL;
  esym = NULL;
  ss = NULL;
  sv = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

  sindex = strlen (no_name_func) + 1;
  count = hdr->ipdMax;
  if (count > 0)
    {
      size = swap->external_pdr_size;

      epdr = (struct pdr_ext *) bfd_malloc (size * count);
      if (epdr == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_pdr (handle, (PTR) epdr))
	goto error_return;

      size = sizeof (RPDR);
      rp = rpdr = (RPDR *) bfd_malloc (size * count);
      if (rpdr == NULL)
	goto error_return;

      sv = (char **) bfd_malloc (sizeof (char *) * count);
      if (sv == NULL)
	goto error_return;

      count = hdr->isymMax;
      size = swap->external_sym_size;
      esym = (struct sym_ext *) bfd_malloc (size * count);
      if (esym == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_sym (handle, (PTR) esym))
	goto error_return;

      count = hdr->issMax;
      ss = (char *) bfd_malloc (count);
      if (ss == NULL)
	goto error_return;
      if (! _bfd_ecoff_get_accumulated_ss (handle, (PTR) ss))
	goto error_return;

      count = hdr->ipdMax;
      for (i = 0; i < count; i++, rp++)
	{
	  (*swap->swap_pdr_in) (abfd, (PTR) (epdr + i), &pdr);
	  (*swap->swap_sym_in) (abfd, (PTR) &esym[pdr.isym], &sym);
	  rp->adr = sym.value;
	  rp->regmask = pdr.regmask;
	  rp->regoffset = pdr.regoffset;
	  rp->fregmask = pdr.fregmask;
	  rp->fregoffset = pdr.fregoffset;
	  rp->frameoffset = pdr.frameoffset;
	  rp->framereg = pdr.framereg;
	  rp->pcreg = pdr.pcreg;
	  rp->irpss = sindex;
	  sv[i] = ss + sym.iss;
	  sindex += strlen (sv[i]) + 1;
	}
    }

  size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
  size = BFD_ALIGN (size, 16);
  rtproc = (PTR) bfd_alloc (abfd, size);
  if (rtproc == NULL)
    {
      mips_elf_hash_table (info)->procedure_count = 0;
      goto error_return;
    }

  mips_elf_hash_table (info)->procedure_count = count + 2;

  erp = (struct rpdr_ext *) rtproc;
  memset (erp, 0, sizeof (struct rpdr_ext));
  erp++;
  str = (char *) rtproc + sizeof (struct rpdr_ext) * (count + 2);
  strcpy (str, no_name_func);
  str += strlen (no_name_func) + 1;
  for (i = 0; i < count; i++)
    {
      ecoff_swap_rpdr_out (abfd, rpdr + i, erp + i);
      strcpy (str, sv[i]);
      str += strlen (sv[i]) + 1;
    }
  ecoff_put_off (abfd, (bfd_vma) -1, (bfd_byte *) (erp + count)->p_adr);

  /* Set the size and contents of .rtproc section.  */
  s->_raw_size = size;
  s->contents = (bfd_byte *) rtproc;

  /* Skip this section later on (I don't think this currently
     matters, but someday it might).  */
  s->link_order_head = (struct bfd_link_order *) NULL;

  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);

  return true;

 error_return:
  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);
  return false;
}

/* A comparison routine used to sort .gptab entries.  */

static int
gptab_compare (p1, p2)
     const PTR p1;
     const PTR p2;
{
  const Elf32_gptab *a1 = (const Elf32_gptab *) p1;
  const Elf32_gptab *a2 = (const Elf32_gptab *) p2;

  return a1->gt_entry.gt_g_value - a2->gt_entry.gt_g_value;
}

/* We need to use a special link routine to handle the .reginfo and
   the .mdebug sections.  We need to merge all instances of these
   sections together, not write them all out sequentially.  */

boolean
_bfd_mips_elf_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection **secpp;
  asection *o;
  struct bfd_link_order *p;
  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
  asection *rtproc_sec;
  Elf32_RegInfo reginfo;
  struct ecoff_debug_info debug;
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  PTR mdebug_handle = NULL;
  asection *s;
  EXTR esym;
  bfd_vma last;
  unsigned int i;
  static const char * const name[] =
  {
    ".text", ".init", ".fini", ".data",
    ".rodata", ".sdata", ".sbss", ".bss"
  };
  static const int sc[] =
  {
    scText, scInit, scFini, scData,
    scRData, scSData, scSBss, scBss
  };

  /* If all the things we linked together were PIC, but we're
     producing an executable (rather than a shared object), then the
     resulting file is CPIC (i.e., it calls PIC code.)  */
  if (!info->shared
      && !info->relocateable
      && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    {
      elf_elfheader (abfd)->e_flags &= ~EF_MIPS_PIC;
      elf_elfheader (abfd)->e_flags |= EF_MIPS_CPIC;
    }

  /* We'd carefully arranged the dynamic symbol indices, and then the
     generic size_dynamic_sections renumbered them out from under us.
     Rather than trying somehow to prevent the renumbering, just do
     the sort again.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *got;
      struct mips_got_info *g;

      /* When we resort, we must tell mips_elf_sort_hash_table what
	 the lowest index it may use is.  That's the number of section
	 symbols we're going to add.  The generic ELF linker only
	 adds these symbols when building a shared object.  Note that
	 we count the sections after (possibly) removing the .options
	 section above.  */
      if (!mips_elf_sort_hash_table (info, (info->shared
					    ? bfd_count_sections (abfd) + 1
					    : 1)))
	return false;

      /* Make sure we didn't grow the global .got region.  */
      dynobj = elf_hash_table (info)->dynobj;
      got = bfd_get_section_by_name (dynobj, ".got");
      g = (struct mips_got_info *) elf_section_data (got)->tdata;

      if (g->global_gotsym != NULL)
	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		     - g->global_gotsym->dynindx)
		    <= g->global_gotno);
    }

  /* On IRIX5, we omit the .options section.  On IRIX6, however, we
     include it, even though we don't process it quite right.  (Some
     entries are supposed to be merged.)  Empirically, we seem to be
     better off including it then not.  */
  if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
    for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
      {
	if (strcmp ((*secpp)->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
	  {
	    for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	      if (p->type == bfd_indirect_link_order)
		p->u.indirect.section->flags &= ~SEC_HAS_CONTENTS;
	    (*secpp)->link_order_head = NULL;
	    *secpp = (*secpp)->next;
	    --abfd->section_count;

	    break;
	  }
      }

  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (info->relocateable)
	{
	  bfd_vma lo;

	  /* Find the GP-relative section with the lowest offset.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	    if (o->vma < lo
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (abfd);
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

  /* Go through the sections and collect the .reginfo and .mdebug
     information.  */
  reginfo_sec = NULL;
  mdebug_sec = NULL;
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      if (strcmp (o->name, ".reginfo") == 0)
	{
	  memset (&reginfo, 0, sizeof reginfo);

	  /* We have found the .reginfo section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      Elf32_External_RegInfo ext;
	      Elf32_RegInfo sub;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* The linker emulation code has probably clobbered the
                 size to be zero bytes.  */
	      if (input_section->_raw_size == 0)
		input_section->_raw_size = sizeof (Elf32_External_RegInfo);

	      if (! bfd_get_section_contents (input_bfd, input_section,
					      (PTR) &ext,
					      (file_ptr) 0,
					      sizeof ext))
		return false;

	      bfd_mips_elf32_swap_reginfo_in (input_bfd, &ext, &sub);

	      reginfo.ri_gprmask |= sub.ri_gprmask;
	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];

	      /* ri_gp_value is set by the function
		 mips_elf32_section_processing when the section is
		 finally written out.  */

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* Size has been set in mips_elf_always_size_sections  */
	  BFD_ASSERT(o->_raw_size == sizeof (Elf32_External_RegInfo));

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  reginfo_sec = o;
	}

      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == (PTR) NULL)
	    return false;

	  esym.jmptbl = 0;
	  esym.cobol_main = 0;
	  esym.weakext = 0;
	  esym.reserved = 0;
	  esym.ifd = ifdNil;
	  esym.asym.iss = issNil;
	  esym.asym.st = stLocal;
	  esym.asym.reserved = 0;
	  esym.asym.index = indexNil;
	  last = 0;
	  for (i = 0; i < 8; i++)
	    {
	      esym.asym.sc = sc[i];
	      s = bfd_get_section_by_name (abfd, name[i]);
	      if (s != NULL)
		{
		  esym.asym.value = s->vma;
		  last = s->vma + s->_raw_size;
		}
	      else
		esym.asym.value = last;
	      if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
						 name[i], &esym))
		return false;
	    }

	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
		{
		  /* I don't know what a non MIPS ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->_raw_size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (! _bfd_mips_elf_read_ecoff_info (input_bfd, input_section,
						   &input_debug))
		return false;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return false;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct mips_elf_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = mips_elf_link_hash_lookup (mips_elf_hash_table (info),
						 name, false, false, true);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  if (SGI_COMPAT (abfd) && info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED | SEC_READONLY);

		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))
		    return false;
		}

	      if (! mips_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec, &debug))
		return false;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = false;
	  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				       mips_elf_output_extsym,
				       (PTR) &einfo);
	  if (einfo.failed)
	    return false;

	  /* Set the size of the .mdebug section.  */
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  mdebug_sec = o;
	}

      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
	{
	  const char *subname;
	  unsigned int c;
	  Elf32_gptab *tab;
	  Elf32_External_gptab *ext_tab;
	  unsigned int i;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocateable)
	    {
	      asection **secpp;

	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_fill_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &= ~SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->link_order_head = (struct bfd_link_order *) NULL;

	      /* Really remove the section.  */
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      *secpp = (*secpp)->next;
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_get_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  tab = (Elf32_gptab *) bfd_malloc (c * sizeof (Elf32_gptab));
	  if (tab == NULL)
	    return false;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_fill_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = bfd_section_size (input_bfd, input_section);
	      last = 0;
	      for (gpentry = sizeof (Elf32_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf32_External_gptab))
		{
		  Elf32_External_gptab ext_gptab;
		  Elf32_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  gpentry, sizeof (Elf32_External_gptab))))
		    {
		      free (tab);
		      return false;
		    }

		  bfd_mips_elf32_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = false;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = true;
		    }

		  if (! exact)
		    {
		      Elf32_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      new_tab = ((Elf32_gptab *)
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf32_gptab)));
		      if (new_tab == NULL)
			{
			  free (tab);
			  return false;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  ext_tab = ((Elf32_External_gptab *)
		     bfd_alloc (abfd, c * sizeof (Elf32_External_gptab)));
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return false;
	    }

	  for (i = 0; i < c; i++)
	    bfd_mips_elf32_swap_gptab_out (abfd, tab + i, ext_tab + i);
	  free (tab);

	  o->_raw_size = c * sizeof (Elf32_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (ABI_64_P (abfd))
    {
#ifdef BFD64
      if (!bfd_elf64_bfd_final_link (abfd, info))
	return false;
#else
      abort ();
      return false;
#endif /* BFD64 */
    }
  else if (!bfd_elf32_bfd_final_link (abfd, info))
    return false;

  /* Now write out the computed sections.  */

  if (reginfo_sec != (asection *) NULL)
    {
      Elf32_External_RegInfo ext;

      bfd_mips_elf32_swap_reginfo_out (abfd, &reginfo, &ext);
      if (! bfd_set_section_contents (abfd, reginfo_sec, (PTR) &ext,
				      (file_ptr) 0, sizeof ext))
	return false;
    }

  if (mdebug_sec != (asection *) NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return false;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }

  if (gptab_data_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
	return false;
    }

  if (gptab_bss_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
	return false;
    }

  if (SGI_COMPAT (abfd))
    {
      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
      if (rtproc_sec != NULL)
	{
	  if (! bfd_set_section_contents (abfd, rtproc_sec,
					  rtproc_sec->contents,
					  (file_ptr) 0,
					  rtproc_sec->_raw_size))
	    return false;
	}
    }

  return true;
}

/* This function is called via qsort() to sort the dynamic relocation
   entries by increasing r_symndx value.  */

static int
sort_dynamic_relocs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  const Elf32_External_Rel *ext_reloc1 = (const Elf32_External_Rel *) arg1;
  const Elf32_External_Rel *ext_reloc2 = (const Elf32_External_Rel *) arg2;

  Elf_Internal_Rel int_reloc1;
  Elf_Internal_Rel int_reloc2;

  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc2, &int_reloc2);

  return (ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info));
}

/* Returns the GOT section for ABFD.  */

static asection *
mips_elf_got_section (abfd)
     bfd *abfd;
{
  return bfd_get_section_by_name (abfd, ".got");
}

/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT
   section.  */

static struct mips_got_info *
mips_elf_got_info (abfd, sgotp)
     bfd *abfd;
     asection **sgotp;
{
  asection *sgot;
  struct mips_got_info *g;

  sgot = mips_elf_got_section (abfd);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  if (sgotp)
    *sgotp = sgot;
  return g;
}

/* Return whether a relocation is against a local symbol.  */

static boolean
mips_elf_local_relocation_p (input_bfd, relocation, local_sections,
			     check_forced)
     bfd *input_bfd;
     const Elf_Internal_Rela *relocation;
     asection **local_sections;
     boolean check_forced;
{
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;
  struct mips_elf_link_hash_entry *h;
  size_t extsymoff;

  r_symndx = ELF32_R_SYM (relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return true;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return true;

  if (check_forced)
    {
      /* Look up the hash table to check whether the symbol
 	 was forced local.  */
      h = (struct mips_elf_link_hash_entry *)
	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
      if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return true;
    }

  return false;
}

/* Sign-extend VALUE, which has the indicated number of BITS.  */

static bfd_vma
mips_elf_sign_extend (value, bits)
     bfd_vma value;
     int bits;
{
  if (value & ((bfd_vma) 1 << (bits - 1)))
    /* VALUE is negative.  */
    value |= ((bfd_vma) - 1) << bits;

  return value;
}

/* Return non-zero if the indicated VALUE has overflowed the maximum
   range expressable by a signed number with the indicated number of
   BITS.  */

static boolean
mips_elf_overflow_p (value, bits)
     bfd_vma value;
     int bits;
{
  bfd_signed_vma svalue = (bfd_signed_vma) value;

  if (svalue > (1 << (bits - 1)) - 1)
    /* The value is too big.  */
    return true;
  else if (svalue < -(1 << (bits - 1)))
    /* The value is too small.  */
    return true;

  /* All is well.  */
  return false;
}

/* Calculate the %high function.  */

static bfd_vma
mips_elf_high (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}

/* Calculate the %higher function.  */

static bfd_vma
mips_elf_higher (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
}

/* Calculate the %highest function.  */

static bfd_vma
mips_elf_highest (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x800080008000) >> 48) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
}

/* Returns the GOT index for the global symbol indicated by H.  */

static bfd_vma
mips_elf_global_got_index (abfd, h)
     bfd *abfd;
     struct elf_link_hash_entry *h;
{
  bfd_vma index;
  asection *sgot;
  struct mips_got_info *g;

  g = mips_elf_got_info (abfd, &sgot);

  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= g->global_gotsym->dynindx);
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno)
	   * MIPS_ELF_GOT_SIZE (abfd));
  BFD_ASSERT (index < sgot->_raw_size);

  return index;
}

/* Returns the offset for the entry at the INDEXth position
   in the GOT.  */

static bfd_vma
mips_elf_got_offset_from_index (dynobj, output_bfd, index)
     bfd *dynobj;
     bfd *output_bfd;
     bfd_vma index;
{
  asection *sgot;
  bfd_vma gp;

  sgot = mips_elf_got_section (dynobj);
  gp = _bfd_get_gp_value (output_bfd);
  return (sgot->output_section->vma + sgot->output_offset + index -
	  gp);
}

/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */

static boolean
mips_elf_record_global_got_symbol (h, info, g)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     struct mips_got_info *g ATTRIBUTE_UNUSED;
{
  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1
      && !bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;

  /* If we've already marked this entry as need GOT space, we don't
     need to do it again.  */
  if (h->got.offset != (bfd_vma) - 1)
    return true;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  */
  h->got.offset = 0;

  return true;
}

/* This structure is passed to mips_elf_sort_hash_table_f when sorting
   the dynamic symbols.  */

struct mips_elf_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table
     index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a symbol
     with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic
   index.  */

static boolean
mips_elf_sort_hash_table_f (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  struct mips_elf_hash_sort_data *hsd
    = (struct mips_elf_hash_sort_data *) data;

  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return true;

  if (h->root.got.offset != 0)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }

  return true;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   mips_elf_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */

static boolean
mips_elf_sort_hash_table (info, max_local)
     struct bfd_link_info *info;
     unsigned long max_local;
{
  struct mips_elf_hash_sort_data hsd;
  struct mips_got_info *g;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  hsd.low = NULL;
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount;
  hsd.max_non_got_dynindx = max_local;
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *)
				elf_hash_table (info)),
			       mips_elf_sort_hash_table_f,
			       &hsd);

  /* There shoud have been enough room in the symbol table to
     accomodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  g = mips_elf_got_info (dynobj, NULL);
  g->global_gotsym = hsd.low;

  return true;
}

/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  */

static bfd_vma
mips_elf_create_local_got_entry (abfd, g, sgot, value)
     bfd *abfd;
     struct mips_got_info *g;
     asection *sgot;
     bfd_vma value;
{
  if (g->assigned_gotno >= g->local_gotno)
    {
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
	(_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return (bfd_vma) -1;
    }

  MIPS_ELF_PUT_WORD (abfd, value,
		     (sgot->contents
		      + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno));
  return MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
}

/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.  Returns
   -1 if no satisfactory GOT offset can be found.  */

static bfd_vma
mips_elf_local_got_index (abfd, info, value)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      bfd_vma address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	return entry - sgot->contents;
    }

  return mips_elf_create_local_got_entry (abfd, g, sgot, value);
}

/* Find a GOT entry that is within 32KB of the VALUE.  These entries
   are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index into the GOT for this page,
   and store the offset from this entry to the desired address in
   OFFSETP, if it is non-NULL.  */

static bfd_vma
mips_elf_got_page (abfd, info, value, offsetp)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_vma *offsetp;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we aleady have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);

      if (!mips_elf_overflow_p (value - address, 16))
	{
	  /* This entry will serve as the page pointer.  We can add a
	     16-bit number to it to get the actual address.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);

  if (offsetp)
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      *offsetp = value - address;
    }

  return index;
}

/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */

static bfd_vma
mips_elf_got16_entry (abfd, info, value, external)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     boolean external;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  if (! external)
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
      value = mips_elf_high (value) << 16;
    }

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	{
	  /* This entry has the right high-order 16 bits, and the low-order
	     16 bits are set to zero.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);

  return index;
}

/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */

static const Elf_Internal_Rela *
mips_elf_next_relocation (r_type, relocation, relend)
     unsigned int r_type;
     const Elf_Internal_Rela *relocation;
     const Elf_Internal_Rela *relend;
{
  /* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be
     immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.  */
  while (relocation < relend)
    {
      if (ELF32_R_TYPE (relocation->r_info) == r_type)
	return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  bfd_set_error (bfd_error_bad_value);
  return NULL;
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */

static boolean
mips_elf_create_dynamic_relocation (output_bfd, info, rel, h, sec,
				    symbol, addendp, input_section)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *rel;
     struct mips_elf_link_hash_entry *h;
     asection *sec;
     bfd_vma symbol;
     bfd_vma *addendp;
     asection *input_section;
{
  Elf_Internal_Rel outrel;
  boolean skip;
  asection *sreloc;
  bfd *dynobj;
  int r_type;

  r_type = ELF32_R_TYPE (rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc
    = bfd_get_section_by_name (dynobj,
			       MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd));
  BFD_ASSERT (sreloc != NULL);
  BFD_ASSERT (sreloc->contents != NULL);

  skip = false;

  /* We begin by assuming that the offset for the dynamic relocation
     is the same as for the original relocation.  We'll adjust this
     later to reflect the correct output offsets.  */
  if (elf_section_data (input_section)->stab_info == NULL)
    outrel.r_offset = rel->r_offset;
  else
    {
      /* Except that in a stab section things are more complex.
	 Because we compress stab information, the offset given in the
	 relocation may not be the one we want; we must let the stabs
	 machinery tell us the offset.  */
      outrel.r_offset
	= (_bfd_stab_section_offset
	   (output_bfd, &elf_hash_table (info)->stab_info,
	    input_section,
	    &elf_section_data (input_section)->stab_info,
	    rel->r_offset));
      /* If we didn't need the relocation at all, this value will be
	 -1.  */
      if (outrel.r_offset == (bfd_vma) -1)
	skip = true;
    }

  /* If we've decided to skip this relocation, just output an empty
     record.  Note that R_MIPS_NONE == 0, so that this call to memset
     is a way of setting R_TYPE to R_MIPS_NONE.  */
  if (skip)
    memset (&outrel, 0, sizeof (outrel));
  else
    {
      long indx;
      bfd_vma section_offset;

      /* We must now calculate the dynamic symbol table index to use
	 in the relocation.  */
      if (h != NULL
	  && (! info->symbolic || (h->root.elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	{
	  indx = h->root.dynindx;
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  if (indx == -1)
	    indx = 0;
	}
      else
	{
	  if (sec != NULL && bfd_is_abs_section (sec))
	    indx = 0;
	  else if (sec == NULL || sec->owner == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  else
	    {
	      indx = elf_section_data (sec->output_section)->dynindx;
	      if (indx == 0)
		abort ();
	    }

	  /* Figure out how far the target of the relocation is from
	     the beginning of its section.  */
	  section_offset = symbol - sec->output_section->vma;
	  /* The relocation we're building is section-relative.
	     Therefore, the original addend must be adjusted by the
	     section offset.  */
	  *addendp += section_offset;
	  /* Now, the relocation is just against the section.  */
	  symbol = sec->output_section->vma;
	}

      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (!indx && r_type != R_MIPS_REL32)
	*addendp += symbol;

      /* The relocation is always an REL32 relocation because we don't
	 know where the shared library will wind up at load-time.  */
      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);

      /* Adjust the output offset of the relocation to reference the
	 correct location in the output file.  */
      outrel.r_offset += (input_section->output_section->vma
			  + input_section->output_offset);
    }

  /* Put the relocation back out.  We have to use the special
     relocation outputter in the 64-bit case since the 64-bit
     relocation format is non-standard.  */
  if (ABI_64_P (output_bfd))
    {
      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
	(output_bfd, &outrel,
	 (sreloc->contents
	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
    }
  else
    bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			      (((Elf32_External_Rel *)
				sreloc->contents)
			       + sreloc->reloc_count));

  /* Record the index of the first relocation referencing H.  This
     information is later emitted in the .msym section.  */
  if (h != NULL
      && (h->min_dyn_reloc_index == 0
	  || sreloc->reloc_count < h->min_dyn_reloc_index))
    h->min_dyn_reloc_index = sreloc->reloc_count;

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags
    |= SHF_WRITE;

  /* On IRIX5, make an entry of compact relocation info.  */
  if (! skip && IRIX_COMPAT (output_bfd) == ict_irix5)
    {
      asection *scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
      bfd_byte *cr;

      if (scpt)
	{
	  Elf32_crinfo cptrel;

	  mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	  cptrel.vaddr = (rel->r_offset
			  + input_section->output_section->vma
			  + input_section->output_offset);
	  if (r_type == R_MIPS_REL32)
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
	  else
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
	  mips_elf_set_cr_dist2to (cptrel, 0);
	  cptrel.konst = *addendp;

	  cr = (scpt->contents
		+ sizeof (Elf32_External_compact_rel));
	  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
				     ((Elf32_External_crinfo *) cr
				      + scpt->reloc_count));
	  ++scpt->reloc_count;
	}
    }

  return true;
}

/* Calculate the value produced by the RELOCATION (which comes from
   the INPUT_BFD).  The ADDEND is the addend to use for this
   RELOCATION; RELOCATION->R_ADDEND is ignored.

   The result of the relocation calculation is stored in VALUEP.
   REQUIRE_JALXP indicates whether or not the opcode used with this
   relocation must be JALX.

   This function returns bfd_reloc_continue if the caller need take no
   further action regarding this relocation, bfd_reloc_notsupported if
   something goes dramatically wrong, bfd_reloc_overflow if an
   overflow occurs, and bfd_reloc_ok to indicate success.  */

static bfd_reloc_status_type
mips_elf_calculate_relocation (abfd,
			       input_bfd,
			       input_section,
			       info,
			       relocation,
			       addend,
			       howto,
			       local_syms,
			       local_sections,
			       valuep,
			       namep,
			       require_jalxp)
     bfd *abfd;
     bfd *input_bfd;
     asection *input_section;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *relocation;
     bfd_vma addend;
     reloc_howto_type *howto;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
     bfd_vma *valuep;
     const char **namep;
     boolean *require_jalxp;
{
  /* The eventual value we will return.  */
  bfd_vma value;
  /* The address of the symbol against which the relocation is
     occurring.  */
  bfd_vma symbol = 0;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp = (bfd_vma) - 1;
  /* The place (section offset or address) of the storage unit being
     relocated.  */
  bfd_vma p;
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0 = (bfd_vma) - 1;
  /* The offset into the global offset table at which the address of
     the relocation entry symbol, adjusted by the addend, resides
     during execution.  */
  bfd_vma g = (bfd_vma) - 1;
  /* The section in which the symbol referenced by the relocation is
     located.  */
  asection *sec = NULL;
  struct mips_elf_link_hash_entry *h = NULL;
  /* True if the symbol referred to by this relocation is a local
     symbol.  */
  boolean local_p;
  /* True if the symbol referred to by this relocation is "_gp_disp".  */
  boolean gp_disp_p = false;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;
  unsigned long r_symndx;
  int r_type;
  /* True if overflow occurred during the calculation of the
     relocation value.  */
  boolean overflowed_p;
  /* True if this relocation refers to a MIPS16 function.  */
  boolean target_is_16_bit_code_p = false;

  /* Parse the relocation.  */
  r_symndx = ELF32_R_SYM (relocation->r_info);
  r_type = ELF32_R_TYPE (relocation->r_info);
  p = (input_section->output_section->vma
       + input_section->output_offset
       + relocation->r_offset);

  /* Assume that there will be no overflow.  */
  overflowed_p = false;

  /* Figure out whether or not the symbol is local, and get the offset
     used in the array of hash table entries.  */
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, false);
  if (! elf_bad_symtab (input_bfd))
    extsymoff = symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      extsymoff = 0;
    }

  /* Figure out the value of the symbol.  */
  if (local_p)
    {
      Elf_Internal_Sym *sym;

      sym = local_syms + r_symndx;
      sec = local_sections[r_symndx];

      symbol = sec->output_section->vma + sec->output_offset;
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	symbol += sym->st_value;

      /* MIPS16 text labels should be treated as odd.  */
      if (sym->st_other == STO_MIPS16)
	++symbol;

      /* Record the name of this symbol, for our caller.  */
      *namep = bfd_elf_string_from_elf_section (input_bfd,
						symtab_hdr->sh_link,
						sym->st_name);
      if (*namep == '\0')
	*namep = bfd_section_name (input_bfd, sec);

      target_is_16_bit_code_p = (sym->st_other == STO_MIPS16);
    }
  else
    {
      /* For global symbols we look up the symbol in the hash-table.  */
      h = ((struct mips_elf_link_hash_entry *)
	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      /* Record the name of this symbol, for our caller.  */
      *namep = h->root.root.root.string;

      /* See if this is the special _gp_disp symbol.  Note that such a
	 symbol must always be a global symbol.  */
      if (strcmp (h->root.root.root.string, "_gp_disp") == 0)
	{
	  /* Relocations against _gp_disp are permitted only with
	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
	  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_LO16)
	    return bfd_reloc_notsupported;

	  gp_disp_p = true;
	}
      /* If this symbol is defined, calculate its address.  Note that
	 _gp_disp is a magic symbol, always implicitly defined by the
	 linker, so it's inappropriate to check to see whether or not
	 its defined.  */
      else if ((h->root.root.type == bfd_link_hash_defined
		|| h->root.root.type == bfd_link_hash_defweak)
	       && h->root.root.u.def.section)
	{
	  sec = h->root.root.u.def.section;
	  if (sec->output_section)
	    symbol = (h->root.root.u.def.value
		      + sec->output_section->vma
		      + sec->output_offset);
	  else
	    symbol = h->root.root.u.def.value;
	}
      else if (h->root.root.type == bfd_link_hash_undefweak)
	/* We allow relocations against undefined weak symbols, giving
	   it the value zero, so that you can undefined weak functions
	   and check to see if they exist by looking at their
	   addresses.  */
	symbol = 0;
      else if (info->shared && !info->symbolic && !info->no_undefined
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	symbol = 0;
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0 ||
              strcmp (h->root.root.root.string, "_DYNAMIC_LINKING") == 0)
	{
	  /* If this is a dynamic link, we should have created a
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol
	     in in mips_elf_create_dynamic_sections.
	     Otherwise, we should define the symbol with a value of 0.
	     FIXME: It should probably get into the symbol table
	     somehow as well.  */
	  BFD_ASSERT (! info->shared);
	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
	  symbol = 0;
	}
      else
	{
	  if (! ((*info->callbacks->undefined_symbol)
		 (info, h->root.root.root.string, input_bfd,
		  input_section, relocation->r_offset,
		  (!info->shared || info->no_undefined
		   || ELF_ST_VISIBILITY (h->root.other)))))
	    return bfd_reloc_undefined;
	  symbol = 0;
	}

      target_is_16_bit_code_p = (h->root.other == STO_MIPS16);
    }

  /* If this is a 32-bit call to a 16-bit function with a stub, we
     need to redirect the call to the stub, unless we're already *in*
     a stub.  */
  if (r_type != R_MIPS16_26 && !info->relocateable
      && ((h != NULL && h->fn_stub != NULL)
	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
      && !mips_elf_stub_section_p (input_bfd, input_section))
    {
      /* This is a 32-bit call to a 16-bit function.  We should
	 have already noticed that we were going to need the
	 stub.  */
      if (local_p)
	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
      else
	{
	  BFD_ASSERT (h->need_fn_stub);
	  sec = h->fn_stub;
	}

      symbol = sec->output_section->vma + sec->output_offset;
    }
  /* If this is a 16-bit call to a 32-bit function with a stub, we
     need to redirect the call to the stub.  */
  else if (r_type == R_MIPS16_26 && !info->relocateable
	   && h != NULL
	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
	   && !target_is_16_bit_code_p)
    {
      /* If both call_stub and call_fp_stub are defined, we can figure
	 out which one to use by seeing which one appears in the input
	 file.  */
      if (h->call_stub != NULL && h->call_fp_stub != NULL)
	{
	  asection *o;

	  sec = NULL;
	  for (o = input_bfd->sections; o != NULL; o = o->next)
	    {
	      if (strncmp (bfd_get_section_name (input_bfd, o),
			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
		{
		  sec = h->call_fp_stub;
		  break;
		}
	    }
	  if (sec == NULL)
	    sec = h->call_stub;
	}
      else if (h->call_stub != NULL)
	sec = h->call_stub;
      else
	sec = h->call_fp_stub;

      BFD_ASSERT (sec->_raw_size > 0);
      symbol = sec->output_section->vma + sec->output_offset;
    }

  /* Calls from 16-bit code to 32-bit code and vice versa require the
     special jalx instruction.  */
  *require_jalxp = (!info->relocateable
		    && ((r_type == R_MIPS16_26) != target_is_16_bit_code_p));

  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, true);

  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
  switch (r_type)
    {
    case R_MIPS_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_GOT_DISP:
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      /* Find the index into the GOT where this value is located.  */
      if (!local_p)
	{
	  BFD_ASSERT (addend == 0);
	  g = mips_elf_global_got_index
	    (elf_hash_table (info)->dynobj,
	     (struct elf_link_hash_entry *) h);
	  if (! elf_hash_table(info)->dynamic_sections_created
	      || (info->shared
		  && (info->symbolic || h->root.dynindx == -1)
		  && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      /* This is a static link or a -Bsymbolic link.  The
		 symbol is defined locally, or was forced to be local.
		 We must initialize this entry in the GOT.  */
	      asection *sgot = mips_elf_got_section(elf_hash_table
						    (info)->dynobj);
	      MIPS_ELF_PUT_WORD (elf_hash_table (info)->dynobj,
				 symbol + addend, sgot->contents + g);
	    }
	}
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
	/* There's no need to create a local GOT entry here; the
	   calculation for a local GOT16 entry does not involve G.  */
	break;
      else
	{
	  g = mips_elf_local_got_index (abfd, info, symbol + addend);
	  if (g == (bfd_vma) -1)
	    return false;
	}

      /* Convert GOT indices to actual offsets.  */
      g = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					  abfd, g);
      break;

    case R_MIPS_HI16:
    case R_MIPS_LO16:
    case R_MIPS_GPREL16:
    case R_MIPS_GPREL32:
    case R_MIPS_LITERAL:
      gp0 = _bfd_get_gp_value (input_bfd);
      gp = _bfd_get_gp_value (abfd);
      break;

    default:
      break;
    }

  /* Figure out what kind of relocation is being performed.  */
  switch (r_type)
    {
    case R_MIPS_NONE:
      return bfd_reloc_continue;

    case R_MIPS_16:
      value = symbol + mips_elf_sign_extend (addend, 16);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_32:
    case R_MIPS_REL32:
    case R_MIPS_64:
      if ((info->shared
	   || (elf_hash_table (info)->dynamic_sections_created
	       && h != NULL
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		   != 0)))
	  && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, or this relocation is
	     against a symbol in a shared library, then we can't know
	     where the symbol will end up.  So, we create a relocation
	     record in the output, and leave the job up to the dynamic
	     linker.  */
	  value = addend;
	  if (!mips_elf_create_dynamic_relocation (abfd,
						   info,
						   relocation,
						   h,
						   sec,
						   symbol,
						   &value,
						   input_section))
	    return false;
	}
      else
	{
	  if (r_type != R_MIPS_REL32)
	    value = symbol + addend;
	  else
	    value = addend;
	}
      value &= howto->dst_mask;
      break;

    case R_MIPS_PC32:
    case R_MIPS_PC64:
    case R_MIPS_GNU_REL_LO16:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;

    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

    case R_MIPS_GNU_REL_HI16:
      value = mips_elf_high (addend + symbol - p);
      value &= howto->dst_mask;
      break;

    case R_MIPS16_26:
      /* The calculation for R_MIPS16_26 is just the same as for an
	 R_MIPS_26.  It's only the storage of the relocated field into
	 the output file that's different.  That's handled in
	 mips_elf_perform_relocation.  So, we just fall through to the
	 R_MIPS_26 case here.  */
    case R_MIPS_26:
      if (local_p)
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
      else
	value = (mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HI16:
      if (!gp_disp_p)
	{
	  value = mips_elf_high (addend + symbol);
	  value &= howto->dst_mask;
	}
      else
	{
	  value = mips_elf_high (addend + gp - p);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	}
      break;

    case R_MIPS_LO16:
      if (!gp_disp_p)
	value = (symbol + addend) & howto->dst_mask;
      else
	{
	  value = addend + gp - p + 4;
	  /* The MIPS ABI requires checking the R_MIPS_LO16 relocation
	     for overflow.  But, on, say, Irix 5, relocations against
	     _gp_disp are normally generated from the .cpload
	     pseudo-op.  It generates code that normally looks like
	     this:

	       lui    $gp,%hi(_gp_disp)
	       addiu  $gp,$gp,%lo(_gp_disp)
	       addu   $gp,$gp,$t9

	     Here $t9 holds the address of the function being called,
	     as required by the MIPS ELF ABI.  The R_MIPS_LO16
	     relocation can easily overflow in this situation, but the
	     R_MIPS_HI16 relocation will handle the overflow.
	     Therefore, we consider this a bug in the MIPS ABI, and do
	     not check for overflow here.  */
	}
      break;

    case R_MIPS_LITERAL:
      /* Because we don't merge literal sections, we can handle this
	 just like R_MIPS_GPREL16.  In the long run, we should merge
	 shared literals, and then we will need to additional work
	 here.  */

      /* Fall through.  */

    case R_MIPS16_GPREL:
      /* The R_MIPS16_GPREL performs the same calculation as
	 R_MIPS_GPREL16, but stores the relocated bits in a different
	 order.  We don't need to do anything special here; the
	 differences are handled in mips_elf_perform_relocation.  */
    case R_MIPS_GPREL16:
      if (local_p)
	value = mips_elf_sign_extend (addend, 16) + symbol + gp0 - gp;
      else
	value = mips_elf_sign_extend (addend, 16) + symbol - gp;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT16:
    case R_MIPS_CALL16:
      if (local_p)
	{
	  boolean forced;

	  /* The special case is when the symbol is forced to be local.  We
	     need the full address in the GOT since no R_MIPS_LO16 relocation
	     follows.  */
	  forced = ! mips_elf_local_relocation_p (input_bfd, relocation,
						  local_sections, false);
	  value = mips_elf_got16_entry (abfd, info, symbol + addend, forced);
	  if (value == (bfd_vma) -1)
	    return false;
	  value
	    = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	  break;
	}

      /* Fall through.  */

    case R_MIPS_GOT_DISP:
      value = g;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GPREL32:
      value = (addend + symbol + gp0 - gp) & howto->dst_mask;
      break;

    case R_MIPS_PC16:
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      value = (bfd_vma) ((bfd_signed_vma) value / 4);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
      /* We're allowed to handle these two relocations identically.
	 The dynamic linker is allowed to handle the CALL relocations
	 differently by creating a lazy evaluation stub.  */
      value = g;
      value = mips_elf_high (value);
      value &= howto->dst_mask;
      break;

    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      value = g & howto->dst_mask;
      break;

    case R_MIPS_GOT_PAGE:
      value = mips_elf_got_page (abfd, info, symbol + addend, NULL);
      if (value == (bfd_vma) -1)
	return false;
      value = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT_OFST:
      mips_elf_got_page (abfd, info, symbol + addend, &value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_SUB:
      value = symbol - addend;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHER:
      value = mips_elf_higher (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHEST:
      value = mips_elf_highest (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_SCN_DISP:
      value = symbol + addend - sec->output_offset;
      value &= howto->dst_mask;
      break;

    case R_MIPS_PJUMP:
    case R_MIPS_JALR:
      /* Both of these may be ignored.  R_MIPS_JALR is an optimization
	 hint; we could improve performance by honoring that hint.  */
      return bfd_reloc_continue;

    case R_MIPS_GNU_VTINHERIT:
    case R_MIPS_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;

    default:
      /* An unrecognized relocation type.  */
      return bfd_reloc_notsupported;
    }

  /* Store the VALUE for our caller.  */
  *valuep = value;
  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
}

/* Obtain the field relocated by RELOCATION.  */

static bfd_vma
mips_elf_obtain_contents (howto, relocation, input_bfd, contents)
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd *input_bfd;
     bfd_byte *contents;
{
  bfd_vma x;
  bfd_byte *location = contents + relocation->r_offset;

  /* Obtain the bytes.  */
  x = bfd_get (8 * bfd_get_reloc_size (howto), input_bfd, location);

  if ((ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26
       || ELF32_R_TYPE (relocation->r_info) == R_MIPS16_GPREL)
      && bfd_little_endian (input_bfd))
    /* The two 16-bit words will be reversed on a little-endian
       system.  See mips_elf_perform_relocation for more details.  */
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

  return x;
}

/* It has been determined that the result of the RELOCATION is the
   VALUE.  Use HOWTO to place VALUE into the output file at the
   appropriate position.  The SECTION is the section to which the
   relocation applies.  If REQUIRE_JALX is true, then the opcode used
   for the relocation must be either JAL or JALX, and it is
   unconditionally converted to JALX.

   Returns false if anything goes wrong.  */

static boolean
mips_elf_perform_relocation (info, howto, relocation, value,
			     input_bfd, input_section,
			     contents, require_jalx)
     struct bfd_link_info *info;
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd_vma value;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     boolean require_jalx;
{
  bfd_vma x;
  bfd_byte *location;
  int r_type = ELF32_R_TYPE (relocation->r_info);

  /* Figure out where the relocation is occurring.  */
  location = contents + relocation->r_offset;

  /* Obtain the current value.  */
  x = mips_elf_obtain_contents (howto, relocation, input_bfd, contents);

  /* Clear the field we are setting.  */
  x &= ~howto->dst_mask;

  /* If this is the R_MIPS16_26 relocation, we must store the
     value in a funny way.  */
  if (r_type == R_MIPS16_26)
    {
      /* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
	 Most mips16 instructions are 16 bits, but these instructions
	 are 32 bits.

	 The format of these instructions is:

	 +--------------+--------------------------------+
	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  !
	 +--------------+--------------------------------+
	 !	  	  Immediate  15:0		    !
	 +-----------------------------------------------+

	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
	 Note that the immediate value in the first word is swapped.

	 When producing a relocateable object file, R_MIPS16_26 is
	 handled mostly like R_MIPS_26.  In particular, the addend is
	 stored as a straight 26-bit value in a 32-bit instruction.
	 (gas makes life simpler for itself by never adjusting a
	 R_MIPS16_26 reloc to be against a section, so the addend is
	 always zero).  However, the 32 bit instruction is stored as 2
	 16-bit values, rather than a single 32-bit value.  In a
	 big-endian file, the result is the same; in a little-endian
	 file, the two 16-bit halves of the 32 bit value are swapped.
	 This is so that a disassembler can recognize the jal
	 instruction.

	 When doing a final link, R_MIPS16_26 is treated as a 32 bit
	 instruction stored as two 16-bit values.  The addend A is the
	 contents of the targ26 field.  The calculation is the same as
	 R_MIPS_26.  When storing the calculated value, reorder the
	 immediate value as shown above, and don't forget to store the
	 value as two 16-bit values.

	 To put it in MIPS ABI terms, the relocation field is T-targ26-16,
	 defined as

	 big-endian:
	 +--------+----------------------+
	 |        |                      |
	 |        |    targ26-16         |
	 |31    26|25                   0|
	 +--------+----------------------+

	 little-endian:
	 +----------+------+-------------+
	 |          |      |             |
	 |  sub1    |      |     sub2    |
	 |0        9|10  15|16         31|
	 +----------+--------------------+
	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
	 ((sub1 << 16) | sub2)).

	 When producing a relocateable object file, the calculation is
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 When producing a fully linked file, the calculation is
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)  */

      if (!info->relocateable)
	/* Shuffle the bits according to the formula above.  */
	value = (((value & 0x1f0000) << 5)
		 | ((value & 0x3e00000) >> 5)
		 | (value & 0xffff));
    }
  else if (r_type == R_MIPS16_GPREL)
    {
      /* R_MIPS16_GPREL is used for GP-relative addressing in mips16
	 mode.  A typical instruction will have a format like this:

	 +--------------+--------------------------------+
	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  !
	 +--------------+--------------------------------+
	 !    Major     !   rx   !   ry   !   Imm  4:0   !
	 +--------------+--------------------------------+

	 EXTEND is the five bit value 11110.  Major is the instruction
	 opcode.

	 This is handled exactly like R_MIPS_GPREL16, except that the
	 addend is retrieved and stored as shown in this diagram; that
	 is, the Imm fields above replace the V-rel16 field.

         All we need to do here is shuffle the bits appropriately.  As
	 above, the two 16-bit halves must be swapped on a
	 little-endian system.  */
      value = (((value & 0x7e0) << 16)
	       | ((value & 0xf800) << 5)
	       | (value & 0x1f));
    }

  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* If required, turn JAL into JALX.  */
  if (require_jalx)
    {
      boolean ok;
      bfd_vma opcode = x >> 26;
      bfd_vma jalx_opcode;

      /* Check to see if the opcode is already JAL or JALX.  */
      if (r_type == R_MIPS16_26)
	{
	  ok = ((opcode == 0x6) || (opcode == 0x7));
	  jalx_opcode = 0x7;
	}
      else
	{
	  ok = ((opcode == 0x3) || (opcode == 0x1d));
	  jalx_opcode = 0x1d;
	}

      /* If the opcode is not JAL or JALX, there's a problem.  */
      if (!ok)
	{
	  (*_bfd_error_handler)
	    (_("%s: %s+0x%lx: jump to stub routine which is not jal"),
	     bfd_get_filename (input_bfd),
	     input_section->name,
	     (unsigned long) relocation->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      /* Make this the JALX opcode.  */
      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
    }

  /* Swap the high- and low-order 16 bits on little-endian systems
     when doing a MIPS16 relocation.  */
  if ((r_type == R_MIPS16_GPREL || r_type == R_MIPS16_26)
      && bfd_little_endian (input_bfd))
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

  /* Put the value into the output.  */
  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);
  return true;
}

/* Returns true if SECTION is a MIPS16 stub section.  */

static boolean
mips_elf_stub_section_p (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
{
  const char *name = bfd_get_section_name (abfd, section);

  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
}

/* Relocate a MIPS ELF section.  */

boolean
_bfd_mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
				contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *relend;
  bfd_vma addend = 0;
  boolean use_saved_addend_p = false;
  struct elf_backend_data *bed;

  bed = get_elf_backend_data (output_bfd);
  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < relend; ++rel)
    {
      const char *name;
      bfd_vma value;
      reloc_howto_type *howto;
      boolean require_jalx;
      /* True if the relocation is a RELA relocation, rather than a
         REL relocation.  */
      boolean rela_relocation_p = true;
      int r_type = ELF32_R_TYPE (rel->r_info);
      const char * msg = (const char *) NULL;

      /* Find the relocation howto for this relocation.  */
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	{
	  /* Some 32-bit code uses R_MIPS_64.  In particular, people use
	     64-bit code, but make sure all their addresses are in the
	     lowermost or uppermost 32-bit section of the 64-bit address
	     space.  Thus, when they use an R_MIPS_64 they mean what is
	     usually meant by R_MIPS_32, with the exception that the
	     stored value is sign-extended to 64 bits.  */
	  howto = elf_mips_howto_table + R_MIPS_32;

	  /* On big-endian systems, we need to lie about the position
	     of the reloc.  */
	  if (bfd_big_endian (input_bfd))
	    rel->r_offset += 4;
	}
      else
	howto = mips_rtype_to_howto (r_type);

      if (!use_saved_addend_p)
	{
	  Elf_Internal_Shdr *rel_hdr;

	  /* If these relocations were originally of the REL variety,
	     we must pull the addend out of the field that will be
	     relocated.  Otherwise, we simply use the contents of the
	     RELA relocation.  To determine which flavor or relocation
	     this is, we depend on the fact that the INPUT_SECTION's
	     REL_HDR is read before its REL_HDR2.  */
	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
	  if ((size_t) (rel - relocs)
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
	  if (rel_hdr->sh_entsize == MIPS_ELF_REL_SIZE (input_bfd))
	    {
	      /* Note that this is a REL relocation.  */
	      rela_relocation_p = false;

	      /* Get the addend, which is stored in the input file.  */
	      addend = mips_elf_obtain_contents (howto,
						 rel,
						 input_bfd,
						 contents);
	      addend &= howto->src_mask;

	      /* For some kinds of relocations, the ADDEND is a
		 combination of the addend stored in two different
		 relocations.   */
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GNU_REL_HI16
		  || (r_type == R_MIPS_GOT16
		      && mips_elf_local_relocation_p (input_bfd, rel,
						      local_sections, false)))
		{
		  bfd_vma l;
		  const Elf_Internal_Rela *lo16_relocation;
		  reloc_howto_type *lo16_howto;
		  int lo;

		  /* The combined value is the sum of the HI16 addend,
		     left-shifted by sixteen bits, and the LO16
		     addend, sign extended.  (Usually, the code does
		     a `lui' of the HI16 value, and then an `addiu' of
		     the LO16 value.)

		     Scan ahead to find a matching LO16 relocation.  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    lo = R_MIPS_GNU_REL_LO16;
		  else
		    lo = R_MIPS_LO16;
		  lo16_relocation
		    = mips_elf_next_relocation (lo, rel, relend);
		  if (lo16_relocation == NULL)
		    return false;

		  /* Obtain the addend kept there.  */
		  lo16_howto = mips_rtype_to_howto (lo);
		  l = mips_elf_obtain_contents (lo16_howto,
						lo16_relocation,
						input_bfd, contents);
		  l &= lo16_howto->src_mask;
		  l = mips_elf_sign_extend (l, 16);

		  addend <<= 16;

		  /* Compute the combined addend.  */
		  addend += l;
		}
	      else if (r_type == R_MIPS16_GPREL)
		{
		  /* The addend is scrambled in the object file.  See
		     mips_elf_perform_relocation for details on the
		     format.  */
		  addend = (((addend & 0x1f0000) >> 5)
			    | ((addend & 0x7e00000) >> 16)
			    | (addend & 0x1f));
		}
	    }
	  else
	    addend = rel->r_addend;
	}

      if (info->relocateable)
	{
	  Elf_Internal_Sym *sym;
	  unsigned long r_symndx;

	  if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd)
	      && bfd_big_endian (input_bfd))
	    rel->r_offset -= 4;

	  /* Since we're just relocating, all we need to do is copy
	     the relocations back out to the object file, unless
	     they're against a section symbol, in which case we need
	     to adjust by the section offset, or unless they're GP
	     relative in which case we need to adjust by the amount
	     that we're adjusting GP in this relocateable object.  */

	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections,
					    false))
	    /* There's nothing to do for non-local relocations.  */
	    continue;

	  if (r_type == R_MIPS16_GPREL
	      || r_type == R_MIPS_GPREL16
	      || r_type == R_MIPS_GPREL32
	      || r_type == R_MIPS_LITERAL)
	    addend -= (_bfd_get_gp_value (output_bfd)
		       - _bfd_get_gp_value (input_bfd));
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    /* The addend is stored without its two least
	       significant bits (which are always zero.)  In a
	       non-relocateable link, calculate_relocation will do
	       this shift; here, we must do it ourselves.  */
	    addend <<= 2;

	  r_symndx = ELF32_R_SYM (rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;

	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_GNU_REL_HI16)
	    addend = mips_elf_high (addend);
	  /* If the relocation is for an R_MIPS_26 relocation, then
	     the two low-order bits are not stored in the object file;
	     they are implicitly zero.  */
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    addend >>= 2;

	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.
	       We have to cast away constness for REL.  */
	    rel->r_addend = addend;
	  else
	    {
	      /* Otherwise, we have to write the value back out.  Note
		 that we use the source mask, rather than the
		 destination mask because the place to which we are
		 writing will be source of the addend in the final
		 link.  */
	      addend &= howto->src_mask;

	      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
		/* See the comment above about using R_MIPS_64 in the 32-bit
		   ABI.  Here, we need to update the addend.  It would be
		   possible to get away with just using the R_MIPS_32 reloc
		   but for endianness.  */
		{
		  bfd_vma sign_bits;
		  bfd_vma low_bits;
		  bfd_vma high_bits;

		  if (addend & ((bfd_vma) 1 << 31))
		    sign_bits = ((bfd_vma) 1 << 32) - 1;
		  else
		    sign_bits = 0;

		  /* If we don't know that we have a 64-bit type,
		     do two separate stores.  */
		  if (bfd_big_endian (input_bfd))
		    {
		      /* Store the sign-bits (which are most significant)
			 first.  */
		      low_bits = sign_bits;
		      high_bits = addend;
		    }
		  else
		    {
		      low_bits = addend;
		      high_bits = sign_bits;
		    }
		  bfd_put_32 (input_bfd, low_bits,
			      contents + rel->r_offset);
		  bfd_put_32 (input_bfd, high_bits,
			      contents + rel->r_offset + 4);
		  continue;
		}

	      if (!mips_elf_perform_relocation (info, howto, rel, addend,
						input_bfd,  input_section,
						contents, false))
		return false;
	    }

	  /* Go on to the next relocation.  */
	  continue;
	}

      /* In the N32 and 64-bit ABIs there may be multiple consecutive
	 relocations for the same offset.  In that case we are
	 supposed to treat the output of each relocation as the addend
	 for the next.  */
      if (rel + 1 < relend
	  && rel->r_offset == rel[1].r_offset
	  && ELF32_R_TYPE (rel[1].r_info) != R_MIPS_NONE)
	use_saved_addend_p = true;
      else
	use_saved_addend_p = false;

      /* Figure out what value we are supposed to relocate.  */
      switch (mips_elf_calculate_relocation (output_bfd,
					     input_bfd,
					     input_section,
					     info,
					     rel,
					     addend,
					     howto,
					     local_syms,
					     local_sections,
					     &value,
					     &name,
					     &require_jalx))
	{
	case bfd_reloc_continue:
	  /* There's nothing to do.  */
	  continue;

	case bfd_reloc_undefined:
	  /* mips_elf_calculate_relocation already called the
	     undefined_symbol callback.  There's no real point in
	     trying to perform the relocation at this point, so we
	     just skip ahead to the next relocation.  */
	  continue;

	case bfd_reloc_notsupported:
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return false;

	case bfd_reloc_overflow:
	  if (use_saved_addend_p)
	    /* Ignore overflow until we reach the last relocation for
	       a given location.  */
	    ;
	  else
	    {
	      BFD_ASSERT (name != NULL);
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
	    }
	  break;

	case bfd_reloc_ok:
	  break;

	default:
	  abort ();
	  break;
	}

      /* If we've got another relocation for the address, keep going
	 until we reach the last one.  */
      if (use_saved_addend_p)
	{
	  addend = value;
	  continue;
	}

      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	/* See the comment above about using R_MIPS_64 in the 32-bit
	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32;
	   that calculated the right value.  Now, however, we
	   sign-extend the 32-bit result to 64-bits, and store it as a
	   64-bit value.  We are especially generous here in that we
	   go to extreme lengths to support this usage on systems with
	   only a 32-bit VMA.  */
	{
	  bfd_vma sign_bits;
	  bfd_vma low_bits;
	  bfd_vma high_bits;

	  if (value & ((bfd_vma) 1 << 31))
	    sign_bits = ((bfd_vma) 1 << 32) - 1;
	  else
	    sign_bits = 0;

	  /* If we don't know that we have a 64-bit type,
	     do two separate stores.  */
	  if (bfd_big_endian (input_bfd))
	    {
	      /* Undo what we did above.  */
	      rel->r_offset -= 4;
	      /* Store the sign-bits (which are most significant)
		 first.  */
	      low_bits = sign_bits;
	      high_bits = value;
	    }
	  else
	    {
	      low_bits = value;
	      high_bits = sign_bits;
	    }
	  bfd_put_32 (input_bfd, low_bits,
		      contents + rel->r_offset);
	  bfd_put_32 (input_bfd, high_bits,
		      contents + rel->r_offset + 4);
	  continue;
	}

      /* Actually perform the relocation.  */
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd,
					input_section, contents,
					require_jalx))
	return false;
    }

  return true;
}

/* This hook function is called before the linker writes out a global
   symbol.  We mark symbols as small common if appropriate.  This is
   also where we undo the increment of the value for a mips16 symbol.  */

boolean
_bfd_mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
{
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was small common in an input file, mark it as small
     common in the output file.  */
  if (sym->st_shndx == SHN_COMMON
      && strcmp (input_sec->name, ".scommon") == 0)
    sym->st_shndx = SHN_MIPS_SCOMMON;

  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;

  return true;
}

/* Functions for the dynamic linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER(abfd) 		\
   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\
    : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\
    : "/usr/lib/libc.so.1")

/* Create dynamic sections when linking against a dynamic object.  */

boolean
_bfd_mips_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf_link_hash_entry *h;
  flagword flags;
  register asection *s;
  const char * const *namep;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);

  /* Mips ABI requests the .dynamic section to be read only.  */
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      if (! bfd_set_section_flags (abfd, s, flags))
	return false;
    }

  /* We need to create .got section.  */
  if (! mips_elf_create_got_section (abfd, info))
    return false;

  /* Create the .msym section on IRIX6.  It is used by the dynamic
     linker to speed up dynamic relocations, and to avoid computing
     the ELF hash for symbols.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && !mips_elf_create_msym_section (abfd))
    return false;

  /* Create .stub section.  */
  if (bfd_get_section_by_name (abfd,
			       MIPS_ELF_STUB_SECTION_NAME (abfd)) == NULL)
    {
      s = bfd_make_section (abfd, MIPS_ELF_STUB_SECTION_NAME (abfd));
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;
    }

  if ((IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
      && !info->shared
      && bfd_get_section_by_name (abfd, ".rld_map") == NULL)
    {
      s = bfd_make_section (abfd, ".rld_map");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags & ~SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;
    }

  /* On IRIX5, we adjust add some additional symbols and change the
     alignments of several sections.  There is no ABI documentation
     indicating that this is necessary on IRIX6, nor any evidence that
     the linker takes such action.  */
  if (IRIX_COMPAT (abfd) == ict_irix5)
    {
      for (namep = mips_elf_dynsym_rtproc_names; *namep != NULL; namep++)
	{
	  h = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	    return false;
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_SECTION;

	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      /* We need to create a .compact_rel section.  */
      if (SGI_COMPAT (abfd))
	{
	  if (!mips_elf_create_compact_rel_section (abfd, info))
	    return false;
	}

      /* Change aligments of some sections.  */
      s = bfd_get_section_by_name (abfd, ".hash");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynsym");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynstr");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".reginfo");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
    }

  if (!info->shared)
    {
      h = NULL;
      if (SGI_COMPAT (abfd))
	{
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      else
	{
	  /* For normal mips it is _DYNAMIC_LINKING.  */
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINKING", BSF_GLOBAL,
		 bfd_abs_section_ptr, (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_SECTION;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;

      if (! mips_elf_hash_table (info)->use_rld_obj_head)
	{
	  /* __rld_map is a four byte word located in the .data section
	     and is filled in by the rtld to contain a pointer to
	     the _r_debug structure. Its symbol value will be set in
	     mips_elf_finish_dynamic_symbol.  */
	  s = bfd_get_section_by_name (abfd, ".rld_map");
	  BFD_ASSERT (s != NULL);

	  h = NULL;
	  if (SGI_COMPAT (abfd))
	    {
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__rld_map", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  else
	    {
	      /* For normal mips the symbol is __RLD_MAP.  */
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__RLD_MAP", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;

	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}
    }

  return true;
}

/* Create the .compact_rel section.  */

static boolean
mips_elf_create_compact_rel_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  flagword flags;
  register asection *s;

  if (bfd_get_section_by_name (abfd, ".compact_rel") == NULL)
    {
      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED
	       | SEC_READONLY);

      s = bfd_make_section (abfd, ".compact_rel");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;

      s->_raw_size = sizeof (Elf32_External_compact_rel);
    }

  return true;
}

/* Create the .got section to hold the global offset table.  */

static boolean
mips_elf_create_got_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct mips_got_info *g;

  /* This function may be called more than once.  */
  if (mips_elf_got_section (abfd))
    return true;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 4))
    return false;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  h = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, false,
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;

  /* The first several global offset table entries are reserved.  */
  s->_raw_size = MIPS_RESERVED_GOTNO * MIPS_ELF_GOT_SIZE (abfd);

  g = (struct mips_got_info *) bfd_alloc (abfd,
					  sizeof (struct mips_got_info));
  if (g == NULL)
    return false;
  g->global_gotsym = NULL;
  g->local_gotno = MIPS_RESERVED_GOTNO;
  g->assigned_gotno = MIPS_RESERVED_GOTNO;
  if (elf_section_data (s) == NULL)
    {
      s->used_by_bfd =
	(PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
      if (elf_section_data (s) == NULL)
	return false;
    }
  elf_section_data (s)->tdata = (PTR) g;
  elf_section_data (s)->this_hdr.sh_flags
    |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;

  return true;
}

/* Returns the .msym section for ABFD, creating it if it does not
   already exist.  Returns NULL to indicate error.  */

static asection *
mips_elf_create_msym_section (abfd)
     bfd *abfd;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
  if (!s)
    {
      s = bfd_make_section (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
      if (!s
	  || !bfd_set_section_flags (abfd, s,
				     SEC_ALLOC
				     | SEC_LOAD
				     | SEC_HAS_CONTENTS
				     | SEC_LINKER_CREATED
				     | SEC_READONLY)
	  || !bfd_set_section_alignment (abfd, s,
					 MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return NULL;
    }

  return s;
}

/* Add room for N relocations to the .rel.dyn section in ABFD.  */

static void
mips_elf_allocate_dynamic_relocations (abfd, n)
     bfd *abfd;
     unsigned int n;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, MIPS_ELF_REL_DYN_SECTION_NAME (abfd));
  BFD_ASSERT (s != NULL);

  if (s->_raw_size == 0)
    {
      /* Make room for a null element.  */
      s->_raw_size += MIPS_ELF_REL_SIZE (abfd);
      ++s->reloc_count;
    }
  s->_raw_size += n * MIPS_ELF_REL_SIZE (abfd);
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table.  */

boolean
_bfd_mips_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  const char *name;
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct mips_got_info *g;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *sreloc;
  struct elf_backend_data *bed;

  if (info->relocateable)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  /* Check for the mips16 stub sections.  */

  name = bfd_get_section_name (abfd, sec);
  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
    {
      unsigned long r_symndx;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF32_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  asection *o;

	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation in this BFD, other
             than a 16 bit function call, which refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;

	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
			      sizeof FN_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
			      sizeof CALL_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
			      sizeof CALL_FP_STUB - 1) == 0)
		continue;

	      sec_relocs = (_bfd_elf32_link_read_relocs
			    (abfd, o, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL,
			     info->keep_memory));
	      if (sec_relocs == NULL)
		return false;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF32_R_SYM (r->r_info) == r_symndx
		    && ELF32_R_TYPE (r->r_info) != R_MIPS16_26)
		  break;

	      if (! info->keep_memory)
		free (sec_relocs);

	      if (r < rend)
		break;
	    }

	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return true;
	    }

	  /* Record this stub in an array of local symbol stubs for
             this BFD.  */
	  if (elf_tdata (abfd)->local_stubs == NULL)
	    {
	      unsigned long symcount;
	      asection **n;

	      if (elf_bad_symtab (abfd))
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
	      else
		symcount = symtab_hdr->sh_info;
	      n = (asection **) bfd_zalloc (abfd,
					    symcount * sizeof (asection *));
	      if (n == NULL)
		return false;
	      elf_tdata (abfd)->local_stubs = n;
	    }

	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
	}
      else
	{
	  struct mips_elf_link_hash_entry *h;

	  h = ((struct mips_elf_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  /* H is the symbol this stub is for.  */

	  h->fn_stub = sec;
	  mips_elf_hash_table (info)->mips16_stubs_seen = true;
	}
    }
  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
    {
      unsigned long r_symndx;
      struct mips_elf_link_hash_entry *h;
      asection **loc;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF32_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  /* This stub was actually built for a static symbol defined
	     in the same file.  We assume that all static symbols in
	     mips16 code are themselves mips16, so we can simply
	     discard this stub.  Since this function is called before
	     the linker maps input sections to output sections, we can
	     easily discard it by setting the SEC_EXCLUDE flag.  */
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      h = ((struct mips_elf_link_hash_entry *)
	   sym_hashes[r_symndx - extsymoff]);

      /* H is the symbol this stub is for.  */

      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
	loc = &h->call_fp_stub;
      else
	loc = &h->call_stub;

      /* If we already have an appropriate stub for this function, we
	 don't need another one, so we can discard this one.  Since
	 this function is called before the linker maps input sections
	 to output sections, we can easily discard it by setting the
	 SEC_EXCLUDE flag.  We can also discard this section if we
	 happen to already know that this is a mips16 function; it is
	 not necessary to check this here, as it is checked later, but
	 it is slightly faster to check now.  */
      if (*loc != NULL || h->root.other == STO_MIPS16)
	{
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      *loc = sec;
      mips_elf_hash_table (info)->mips16_stubs_seen = true;
    }

  if (dynobj == NULL)
    {
      sgot = NULL;
      g = NULL;
    }
  else
    {
      sgot = mips_elf_got_section (dynobj);
      if (sgot == NULL)
	g = NULL;
      else
	{
	  BFD_ASSERT (elf_section_data (sgot) != NULL);
	  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	  BFD_ASSERT (g != NULL);
	}
    }

  sreloc = NULL;
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < rel_end; ++rel)
    {
      unsigned long r_symndx;
      int r_type;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx < extsymoff)
	h = NULL;
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler)
	    (_("Malformed reloc detected for section %s"), name);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      else
	{
	  h = sym_hashes[r_symndx - extsymoff];

	  /* This may be an indirect symbol created because of a version.  */
	  if (h != NULL)
	    {
	      while (h->root.type == bfd_link_hash_indirect)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	}

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL || sgot == NULL)
	{
	  switch (r_type)
	    {
	    case R_MIPS_GOT16:
	    case R_MIPS_CALL16:
	    case R_MIPS_CALL_HI16:
	    case R_MIPS_CALL_LO16:
	    case R_MIPS_GOT_HI16:
	    case R_MIPS_GOT_LO16:
	    case R_MIPS_GOT_PAGE:
	    case R_MIPS_GOT_OFST:
	    case R_MIPS_GOT_DISP:
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! mips_elf_create_got_section (dynobj, info))
		return false;
	      g = mips_elf_got_info (dynobj, &sgot);
	      break;

	    case R_MIPS_32:
	    case R_MIPS_REL32:
	    case R_MIPS_64:
	      if (dynobj == NULL
		  && (info->shared || h != NULL)
		  && (sec->flags & SEC_ALLOC) != 0)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      break;

	    default:
	      break;
	    }
	}

      if (!h && (r_type == R_MIPS_CALL_LO16
		 || r_type == R_MIPS_GOT_LO16
		 || r_type == R_MIPS_GOT_DISP))
	{
	  /* We may need a local GOT entry for this relocation.  We
	     don't count R_MIPS_GOT_PAGE because we can estimate the
	     maximum number of pages needed by looking at the size of
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.

	     This estimation is very conservative since we can merge
	     duplicate entries in the GOT.  In order to be less
	     conservative, we could actually build the GOT here,
	     rather than in relocate_section.  */
	  g->local_gotno++;
	  sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
	}

      switch (r_type)
	{
	case R_MIPS_CALL16:
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s: CALL16 reloc at 0x%lx not against global symbol"),
		 bfd_get_filename (abfd), (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  /* Fall through.  */

	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  if (h != NULL)
	    {
	      /* This symbol requires a global offset table entry.  */
	      if (!mips_elf_record_global_got_symbol (h, info, g))
		return false;

	      /* We need a stub, not a plt entry for the undefined
		 function.  But we record it as if it needs plt.  See
		 elf_adjust_dynamic_symbol in elflink.h.  */
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->type = STT_FUNC;
	    }
	  break;

	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	case R_MIPS_GOT_DISP:
	  /* This symbol requires a global offset table entry.  */
	  if (h && !mips_elf_record_global_got_symbol (h, info, g))
	    return false;
	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	case R_MIPS_64:
	  if ((info->shared || h != NULL)
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      if (sreloc == NULL)
		{
		  const char *name = MIPS_ELF_REL_DYN_SECTION_NAME (dynobj);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section (dynobj, name);
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc,
						      (SEC_ALLOC
						       | SEC_LOAD
						       | SEC_HAS_CONTENTS
						       | SEC_IN_MEMORY
						       | SEC_LINKER_CREATED
						       | SEC_READONLY))
			  || ! bfd_set_section_alignment (dynobj, sreloc,
							  4))
			return false;
		    }
		}
	      if (info->shared)
		/* When creating a shared object, we must copy these
		   reloc types into the output file as R_MIPS_REL32
		   relocs.  We make room for this reloc in the
		   .rel.dyn reloc section.  */
		mips_elf_allocate_dynamic_relocations (dynobj, 1);
	      else
		{
		  struct mips_elf_link_hash_entry *hmips;

		  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
		  hmips = (struct mips_elf_link_hash_entry *) h;
		  ++hmips->possibly_dynamic_relocs;
		}

	      /* Even though we don't directly need a GOT entry for
		 this symbol, a symbol must have a dynamic symbol
		 table index greater that DT_MIPS_GOTSYM if there are
		 dynamic relocations against it.  */
	      if (h != NULL
		  && !mips_elf_record_global_got_symbol (h, info, g))
		return false;
	    }

	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	case R_MIPS_26:
	case R_MIPS_GPREL16:
	case R_MIPS_LITERAL:
	case R_MIPS_GPREL32:
	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_MIPS_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_MIPS_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	default:
	  break;
	}

      /* We must not create a stub for a symbol that has relocations
         related to taking the function's address.  */
      switch (r_type)
	{
	default:
	  if (h != NULL)
	    {
	      struct mips_elf_link_hash_entry *mh;

	      mh = (struct mips_elf_link_hash_entry *) h;
	      mh->no_fn_stub = true;
	    }
	  break;
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  break;
	}

      /* If this reloc is not a 16 bit call, and it has a global
         symbol, then we will need the fn_stub if there is one.
         References from a stub section do not count.  */
      if (h != NULL
	  && r_type != R_MIPS16_26
	  && strncmp (bfd_get_section_name (abfd, sec), FN_STUB,
		      sizeof FN_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_STUB,
		      sizeof CALL_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_FP_STUB,
		      sizeof CALL_FP_STUB - 1) != 0)
	{
	  struct mips_elf_link_hash_entry *mh;

	  mh = (struct mips_elf_link_hash_entry *) h;
	  mh->need_fn_stub = true;
	}
    }

  return true;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

asection *
_bfd_mips_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  /* ??? Do mips16 stub sections need to be handled special?  */

  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_MIPS_GNU_VTINHERIT:
	case R_MIPS_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

boolean
_bfd_mips_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
#if 0
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_MIPS_GOT16:
      case R_MIPS_CALL16:
      case R_MIPS_CALL_HI16:
      case R_MIPS_CALL_LO16:
      case R_MIPS_GOT_HI16:
      case R_MIPS_GOT_LO16:
	/* ??? It would seem that the existing MIPS code does no sort
	   of reference counting or whatnot on its GOT and PLT entries,
	   so it is not possible to garbage collect them at this time.  */
	break;

      default:
	break;
      }
#endif

  return true;
}

/* Copy data from a MIPS ELF indirect symbol to its direct symbol,
   hiding the old indirect symbol.  Process additional relocation
   information.  */

void
_bfd_mips_elf_copy_indirect_symbol (dir, ind)
     struct elf_link_hash_entry *dir, *ind;
{
  struct mips_elf_link_hash_entry *dirmips, *indmips;

  _bfd_elf_link_hash_copy_indirect (dir, ind);

  dirmips = (struct mips_elf_link_hash_entry *) dir;
  indmips = (struct mips_elf_link_hash_entry *) ind;
  dirmips->possibly_dynamic_relocs += indmips->possibly_dynamic_relocs;
  if (dirmips->min_dyn_reloc_index == 0
      || (indmips->min_dyn_reloc_index != 0
	  && indmips->min_dyn_reloc_index < dirmips->min_dyn_reloc_index))
    dirmips->min_dyn_reloc_index = indmips->min_dyn_reloc_index;
  if (indmips->no_fn_stub)
    dirmips->no_fn_stub = true;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

boolean
_bfd_mips_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this symbol is defined in a dynamic object, we need to copy
     any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output
     file.  */
  hmips = (struct mips_elf_link_hash_entry *) h;
  if (! info->relocateable
      && hmips->possibly_dynamic_relocs != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    mips_elf_allocate_dynamic_relocations (dynobj,
					   hmips->possibly_dynamic_relocs);

  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (! elf_hash_table (info)->dynamic_sections_created)
	return true;

      /* If this symbol is not defined in a regular file, then set
	 the symbol to the stub location.  This is required to make
	 function pointers compare as equal between the normal
	 executable and the shared library.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* We need .stub section.  */
	  s = bfd_get_section_by_name (dynobj,
				       MIPS_ELF_STUB_SECTION_NAME (dynobj));
	  BFD_ASSERT (s != NULL);

	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;

	  /* XXX Write this stub address somewhere.  */
	  h->plt.offset = s->_raw_size;

	  /* Make room for this stub code.  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;

	  /* The last half word of the stub will be filled with the index
	     of this symbol in .dynsym section.  */
	  return true;
	}
    }
  else if ((h->type == STT_FUNC)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return true;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  return true;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  We
   check for any mips16 stub sections that we can discard.  */

static boolean mips_elf_check_mips16_stubs
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));

boolean
_bfd_mips_elf_always_size_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  asection *ri;

  /* The .reginfo section has a fixed size.  */
  ri = bfd_get_section_by_name (output_bfd, ".reginfo");
  if (ri != NULL)
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));

  if (info->relocateable
      || ! mips_elf_hash_table (info)->mips16_stubs_seen)
    return true;

  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_check_mips16_stubs,
			       (PTR) NULL);

  return true;
}

/* Check the mips16 stubs for a particular symbol, and see if we can
   discard them.  */

static boolean
mips_elf_check_mips16_stubs (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data ATTRIBUTE_UNUSED;
{
  if (h->fn_stub != NULL
      && ! h->need_fn_stub)
    {
      /* We don't need the fn_stub; the only references to this symbol
         are 16 bit calls.  Clobber the size to 0 to prevent it from
         being included in the link.  */
      h->fn_stub->_raw_size = 0;
      h->fn_stub->_cooked_size = 0;
      h->fn_stub->flags &= ~SEC_RELOC;
      h->fn_stub->reloc_count = 0;
      h->fn_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_stub->_raw_size = 0;
      h->call_stub->_cooked_size = 0;
      h->call_stub->flags &= ~SEC_RELOC;
      h->call_stub->reloc_count = 0;
      h->call_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_fp_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_fp_stub->_raw_size = 0;
      h->call_fp_stub->_cooked_size = 0;
      h->call_fp_stub->flags &= ~SEC_RELOC;
      h->call_fp_stub->reloc_count = 0;
      h->call_fp_stub->flags |= SEC_EXCLUDE;
    }

  return true;
}

/* Set the sizes of the dynamic sections.  */

boolean
_bfd_mips_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  boolean reltext;
  struct mips_got_info *g = NULL;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
d1609 2
a1610 11
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size
	    = strlen (ELF_DYNAMIC_INTERPRETER (output_bfd)) + 1;
	  s->contents
	    = (bfd_byte *) ELF_DYNAMIC_INTERPRETER (output_bfd);
	}
    }
d1612 10
a1621 8
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;
d1623 1
a1623 279
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      strip = false;

      if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
	      if (s->output_section != NULL
		  && strcmp (name,
			     bfd_get_section_name (s->output_section->owner,
						   s->output_section)) == 0)
		strip = true;
	    }
	  else
	    {
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel.dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 4);
	      if ((target != NULL
		   && (target->flags & SEC_READONLY) != 0
		   && (target->flags & SEC_ALLOC) != 0)
		  || strcmp (outname,
			     MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) == 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      if (strcmp (name,
			  MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) != 0)
		s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) == 0)
	{
	  int i;
	  bfd_size_type loadable_size = 0;
	  bfd_size_type local_gotno;
	  bfd *sub;

	  BFD_ASSERT (elf_section_data (s) != NULL);
	  g = (struct mips_got_info *) elf_section_data (s)->tdata;
	  BFD_ASSERT (g != NULL);

	  /* Calculate the total loadable size of the output.  That
	     will give us the maximum number of GOT_PAGE entries
	     required.  */
	  for (sub = info->input_bfds; sub; sub = sub->link_next)
	    {
	      asection *subsection;

	      for (subsection = sub->sections;
		   subsection;
		   subsection = subsection->next)
		{
		  if ((subsection->flags & SEC_ALLOC) == 0)
		    continue;
		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
		}
	    }
	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

	  /* Assume there are two loadable segments consisting of
	     contiguous sections.  Is 5 enough?  */
	  local_gotno = (loadable_size >> 16) + 5;
	  if (IRIX_COMPAT (output_bfd) == ict_irix6)
	    /* It's possible we will need GOT_PAGE entries as well as
	       GOT16 entries.  Often, these will be able to share GOT
	       entries, but not always.  */
	    local_gotno *= 2;

	  g->local_gotno += local_gotno;
	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);

	  /* There has to be a global GOT entry for every symbol with
	     a dynamic symbol table index of DT_MIPS_GOTSYM or
	     higher.  Therefore, it make sense to put those symbols
	     that need GOT entries at the end of the symbol table.  We
	     do that here.  */
 	  if (!mips_elf_sort_hash_table (info, 1))
 	    return false;

	  if (g->global_gotsym != NULL)
	    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
	  else
	    /* If there are no global symbols, or none requiring
	       relocations, then GLOBAL_GOTSYM will be NULL.  */
	    i = 0;
	  g->global_gotno = i;
	  s->_raw_size += i * MIPS_ELF_GOT_SIZE (dynobj);
	}
      else if (strcmp (name, MIPS_ELF_STUB_SECTION_NAME (output_bfd)) == 0)
	{
	  /* Irix rld assumes that the function stub isn't at the end
	     of .text section. So put a dummy. XXX  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
	}
      else if (! info->shared
	       && ! mips_elf_hash_table (info)->use_rld_obj_head
	       && strncmp (name, ".rld_map", 8) == 0)
	{
	  /* We add a room for __rld_map. It will be filled in by the
	     rtld to contain a pointer to the _r_debug structure.  */
	  s->_raw_size += 4;
	}
      else if (SGI_COMPAT (output_bfd)
	       && strncmp (name, ".compact_rel", 12) == 0)
	s->_raw_size += mips_elf_hash_table (info)->compact_rel_size;
      else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (output_bfd))
	       == 0)
	s->_raw_size = (sizeof (Elf32_External_Msym)
			* (elf_hash_table (info)->dynsymcount
			   + bfd_count_sections (output_bfd)));
      else if (strncmp (name, ".init", 5) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_mips_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  /* SGI object has the equivalence of DT_DEBUG in the
	     DT_MIPS_RLD_MAP entry.  */
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
	    return false;
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return false;
	    }
	}
      else
	{
	  /* Shared libraries on traditional mips have DT_DEBUG.  */
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return false;
	    }
	}
      if (reltext && SGI_COMPAT (output_bfd))
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
	}

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
	return false;

      if (bfd_get_section_by_name (dynobj,
				   MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)))
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
	    return false;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
	    return false;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
	    return false;
	}

      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	    return false;
	}

      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	    return false;
	}

      if (bfd_get_section_by_name (dynobj, ".conflict") != NULL)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICT, 0))
	    return false;

	  s = bfd_get_section_by_name (dynobj, ".liblist");
	  BFD_ASSERT (s != NULL);

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLIST, 0))
	    return false;
	}

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
	return false;

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
	return false;

#if 0
      /* Time stamps in executable files are a bad idea.  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0))
	return false;
#endif

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
	return false;

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
	return false;

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
	return false;

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
	return false;

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
	return false;

      if (IRIX_COMPAT (dynobj) == ict_irix5
	  && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
	return false;

      if (IRIX_COMPAT (dynobj) == ict_irix6
	  && (bfd_get_section_by_name
	      (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	return false;

      if (bfd_get_section_by_name (dynobj,
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_MSYM, 0))
	return false;
d1626 3
a1628 1
  return true;
d1631 4
a1634 60
/* If NAME is one of the special IRIX6 symbols defined by the linker,
   adjust it appropriately now.  */

static void
mips_elf_irix6_finish_dynamic_symbol (abfd, name, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
     Elf_Internal_Sym *sym;
{
  /* The linker script takes care of providing names and values for
     these, but we must place them into the right sections.  */
  static const char* const text_section_symbols[] = {
    "_ftext",
    "_etext",
    "__dso_displacement",
    "__elf_header",
    "__program_header_table",
    NULL
  };

  static const char* const data_section_symbols[] = {
    "_fdata",
    "_edata",
    "_end",
    "_fbss",
    NULL
  };

  const char* const *p;
  int i;

  for (i = 0; i < 2; ++i)
    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
	 *p;
	 ++p)
      if (strcmp (*p, name) == 0)
	{
	  /* All of these symbols are given type STT_SECTION by the
	     IRIX6 linker.  */
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);

	  /* The IRIX linker puts these symbols in special sections.  */
	  if (i == 0)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else
	    sym->st_shndx = SHN_MIPS_DATA;

	  break;
	}
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

boolean
_bfd_mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1636 1
a1636 13
  bfd *dynobj;
  bfd_vma gval;
  asection *sgot;
  asection *smsym;
  struct mips_got_info *g;
  const char *name;
  struct mips_elf_link_hash_entry *mh;

  dynobj = elf_hash_table (info)->dynobj;
  gval = sym->st_value;
  mh = (struct mips_elf_link_hash_entry *) h;

  if (h->plt.offset != (bfd_vma) -1)
d1638 2
a1639 83
      asection *s;
      bfd_byte *p;
      bfd_byte stub[MIPS_FUNCTION_STUB_SIZE];

      /* This symbol has a stub.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (dynobj,
				   MIPS_ELF_STUB_SECTION_NAME (dynobj));
      BFD_ASSERT (s != NULL);

      /* Fill the stub.  */
      p = stub;
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), p);
      p += 4;
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), p);
      p += 4;

      /* FIXME: Can h->dynindex be more than 64K?  */
      if (h->dynindx & 0xffff0000)
	return false;

      bfd_put_32 (output_bfd, STUB_JALR, p);
      p += 4;
      bfd_put_32 (output_bfd, STUB_LI16 (output_bfd) + h->dynindx, p);

      BFD_ASSERT (h->plt.offset <= s->_raw_size);
      memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);

      /* Mark the symbol as undefined.  plt.offset != -1 occurs
	 only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
	 to reset the global offset table entry for this external
	 to its stub address when unlinking a shared object.  */
      gval = s->output_section->vma + s->output_offset + h->plt.offset;
      sym->st_value = gval;
    }

  BFD_ASSERT (h->dynindx != -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0);

  sgot = mips_elf_got_section (dynobj);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
    {
      bfd_vma offset;
      bfd_vma value;

      if (sym->st_value)
	value = sym->st_value;
      else
	{
	  /* For an entity defined in a shared object, this will be
	     NULL.  (For functions in shared objects for
	     which we have created stubs, ST_VALUE will be non-NULL.
	     That's because such the functions are now no longer defined
	     in a shared object.)  */

	  if (info->shared && h->root.type == bfd_link_hash_undefined)
	    value = 0;
	  else
	    value = h->root.u.def.value;
	}
      offset = mips_elf_global_got_index (dynobj, h);
      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);
    }

  /* Create a .msym entry, if appropriate.  */
  smsym = bfd_get_section_by_name (dynobj,
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj));
  if (smsym)
    {
      Elf32_Internal_Msym msym;
d1641 5
a1645 7
      msym.ms_hash_value = bfd_elf_hash (h->root.root.string);
      /* It is undocumented what the `1' indicates, but IRIX6 uses
	 this value.  */
      msym.ms_info = ELF32_MS_INFO (mh->min_dyn_reloc_index, 1);
      bfd_mips_elf_swap_msym_out
	(dynobj, &msym,
	 ((Elf32_External_Msym *) smsym->contents) + h->dynindx);
d1648 3
a1650 43
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (strcmp (name, "_DYNAMIC") == 0
      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0
	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (strcmp (name, "_gp_disp") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = elf_gp (output_bfd);
    }
  else if (SGI_COMPAT (output_bfd))
    {
      if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	  || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = 0;
	  sym->st_shndx = SHN_MIPS_DATA;
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = mips_elf_hash_table (info)->procedure_count;
	  sym->st_shndx = SHN_ABS;
	}
      else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
	{
	  if (h->type == STT_FUNC)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else if (h->type == STT_OBJECT)
	    sym->st_shndx = SHN_MIPS_DATA;
	}
    }
d1652 3
a1654 3
  /* Handle the IRIX6-specific symbols.  */
  if (IRIX_COMPAT (output_bfd) == ict_irix6)
    mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);
d1656 3
a1658 24
  if (! info->shared)
    {
      if (! mips_elf_hash_table (info)->use_rld_obj_head
	  && (strcmp (name, "__rld_map") == 0
	      || strcmp (name, "__RLD_MAP") == 0))
	{
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
	  sym->st_value = s->output_section->vma + s->output_offset;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, s->contents);
	  if (mips_elf_hash_table (info)->rld_value == 0)
	    mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
      else if (mips_elf_hash_table (info)->use_rld_obj_head
	       && strcmp (name, "__rld_obj_head") == 0)
	{
	  /* IRIX6 does not use a .rld_map section.  */
	  if (IRIX_COMPAT (output_bfd) == ict_irix5
              || IRIX_COMPAT (output_bfd) == ict_none)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
			!= NULL);
	  mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
    }
d1660 14
a1673 6
  /* If this is a mips16 symbol, force the value to be even.  */
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;

  return true;
d1675 11
a1685 6

/* Finish up the dynamic sections.  */

boolean
_bfd_mips_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
d1687 3
d1691 5
a1695 18
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  struct mips_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  sgot = mips_elf_got_section (dynobj);
  if (sgot == NULL)
    g = NULL;
  else
    {
      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);
    }
d1697 1
a1697 6
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;

      BFD_ASSERT (sdyn != NULL);
      BFD_ASSERT (g != NULL);
d1699 1
a1699 9
      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->_raw_size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  asection *s;
	  boolean swap_out_p;
d1701 2
a1702 2
	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);
d1704 4
a1707 150
	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = true;

	  switch (dyn.d_tag)
	    {
	    case DT_RELENT:
	      s = (bfd_get_section_by_name
		   (dynobj,
		    MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)));
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = MIPS_ELF_REL_SIZE (dynobj);
	      break;

	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val =
		_bfd_stringtab_size (elf_hash_table (info)->dynstr);
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_MIPS_CONFLICT:
	      name = ".conflict";
	      goto get_vma;
	    case DT_MIPS_LIBLIST:
	      name = ".liblist";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_RLD_VERSION:
	      dyn.d_un.d_val = 1; /* XXX */
	      break;

	    case DT_MIPS_FLAGS:
	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
	      break;

	    case DT_MIPS_CONFLICTNO:
	      name = ".conflict";
	      elemsize = sizeof (Elf32_Conflict);
	      goto set_elemno;

	    case DT_MIPS_LIBLISTNO:
	      name = ".liblist";
	      elemsize = sizeof (Elf32_Lib);
	    set_elemno:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val = s->_cooked_size / elemsize;
		  else
		    dyn.d_un.d_val = s->_raw_size / elemsize;
		}
	      else
		dyn.d_un.d_val = 0;
	      break;

	    case DT_MIPS_TIME_STAMP:
	      time ((time_t *) &dyn.d_un.d_val);
	      break;

	    case DT_MIPS_ICHECKSUM:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;

	    case DT_MIPS_IVERSION:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;

	    case DT_MIPS_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(0xffff);
	      break;

	    case DT_MIPS_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      if (g->global_gotsym)
		{
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		 to setting DT_MIPS_GOTSYM to the same value as
		 DT_MIPS_SYMTABNO, so we just fall through.  */

	    case DT_MIPS_SYMTABNO:
	      name = ".dynsym";
	      elemsize = MIPS_ELF_SYM_SIZE (output_bfd);
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size / elemsize;
	      else
		dyn.d_un.d_val = s->_raw_size / elemsize;
	      break;

	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
	      break;

	    case DT_MIPS_RLD_MAP:
	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
	      break;

	    case DT_MIPS_OPTIONS:
	      s = (bfd_get_section_by_name
		   (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_MSYM:
	      s = (bfd_get_section_by_name
		   (output_bfd, MIPS_ELF_MSYM_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    default:
	      swap_out_p = false;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b);
	}
    }

  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of Irix rld.  */
  if (sgot != NULL && sgot->_raw_size > 0)
d1709 7
a1715 3
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
			 sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
d1718 5
a1722 114
  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
      = MIPS_ELF_GOT_SIZE (output_bfd);

  {
    asection *smsym;
    asection *s;
    Elf32_compact_rel cpt;

    /* ??? The section symbols for the output sections were set up in
       _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these
       symbols.  Should we do so?  */

    smsym = bfd_get_section_by_name (dynobj,
				     MIPS_ELF_MSYM_SECTION_NAME (dynobj));
    if (smsym != NULL)
      {
	Elf32_Internal_Msym msym;

	msym.ms_hash_value = 0;
	msym.ms_info = ELF32_MS_INFO (0, 1);

	for (s = output_bfd->sections; s != NULL; s = s->next)
	  {
	    long dynindx = elf_section_data (s)->dynindx;

	    bfd_mips_elf_swap_msym_out
	      (output_bfd, &msym,
	       (((Elf32_External_Msym *) smsym->contents)
		+ dynindx));
	  }
      }

    if (SGI_COMPAT (output_bfd))
      {
	/* Write .compact_rel section out.  */
	s = bfd_get_section_by_name (dynobj, ".compact_rel");
	if (s != NULL)
	  {
	    cpt.id1 = 1;
	    cpt.num = s->reloc_count;
	    cpt.id2 = 2;
	    cpt.offset = (s->output_section->filepos
			  + sizeof (Elf32_External_compact_rel));
	    cpt.reserved0 = 0;
	    cpt.reserved1 = 0;
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt,
					    ((Elf32_External_compact_rel *)
					     s->contents));

	    /* Clean up a dummy stub function entry in .text.  */
	    s = bfd_get_section_by_name (dynobj,
					 MIPS_ELF_STUB_SECTION_NAME (dynobj));
	    if (s != NULL)
	      {
		file_ptr dummy_offset;

		BFD_ASSERT (s->_raw_size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->_raw_size - MIPS_FUNCTION_STUB_SIZE;
		memset (s->contents + dummy_offset, 0,
			MIPS_FUNCTION_STUB_SIZE);
	      }
	  }
      }

    /* We need to sort the entries of the dynamic relocation section.  */

    if (!ABI_64_P (output_bfd))
      {
	asection *reldyn;

	reldyn = bfd_get_section_by_name (dynobj,
					  MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
	if (reldyn != NULL && reldyn->reloc_count > 2)
	  {
	    reldyn_sorting_bfd = output_bfd;
	    qsort ((Elf32_External_Rel *) reldyn->contents + 1,
		   (size_t) reldyn->reloc_count - 1,
		   sizeof (Elf32_External_Rel), sort_dynamic_relocs);
	  }
      }

    /* Clean up a first relocation in .rel.dyn.  */
    s = bfd_get_section_by_name (dynobj,
				 MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
    if (s != NULL && s->_raw_size > 0)
      memset (s->contents, 0, MIPS_ELF_REL_SIZE (dynobj));
  }

  return true;
}

/* This is almost identical to bfd_generic_get_... except that some
   MIPS relocations need to be handled specially.  Sigh.  */

static bfd_byte *
elf32_mips_get_relocated_section_contents (abfd, link_info, link_order, data,
					   relocateable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  /* Get enough memory to hold the stuff */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;

  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  if (reloc_size < 0)
d1725 2
a1726 2
  reloc_vector = (arelent **) bfd_malloc (reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
d1729 1
a1729 7
  /* read in the section */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 (PTR) data,
				 0,
				 input_section->_raw_size))
    goto error_return;
d1731 1
a1731 10
  /* We're not relaxing the section, so just copy the size info */
  input_section->_cooked_size = input_section->_raw_size;
  input_section->reloc_done = true;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;
d1733 1
a1733 1
  if (reloc_count > 0)
d1735 1
a1735 51
      arelent **parent;
      /* for mips */
      int gp_found;
      bfd_vma gp = 0x12345678;	/* initialize just to shut gcc up */

      {
	struct bfd_hash_entry *h;
	struct bfd_link_hash_entry *lh;
	/* Skip all this stuff if we aren't mixing formats.  */
	if (abfd && input_bfd
	    && abfd->xvec == input_bfd->xvec)
	  lh = 0;
	else
	  {
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", false, false);
	    lh = (struct bfd_link_hash_entry *) h;
	  }
      lookup:
	if (lh)
	  {
	    switch (lh->type)
	      {
	      case bfd_link_hash_undefined:
	      case bfd_link_hash_undefweak:
	      case bfd_link_hash_common:
		gp_found = 0;
		break;
	      case bfd_link_hash_defined:
	      case bfd_link_hash_defweak:
		gp_found = 1;
		gp = lh->u.def.value;
		break;
	      case bfd_link_hash_indirect:
	      case bfd_link_hash_warning:
		lh = lh->u.i.link;
		/* @@@@FIXME  ignoring warning for now */
		goto lookup;
	      case bfd_link_hash_new:
	      default:
		abort ();
	      }
	  }
	else
	  gp_found = 0;
      }
      /* end mips */
      for (parent = reloc_vector; *parent != (arelent *) NULL;
	   parent++)
	{
	  char *error_message = (char *) NULL;
	  bfd_reloc_status_type r;
d1737 5
a1741 21
	  /* Specific to MIPS: Deal with relocation types that require
	     knowing the gp of the output bfd.  */
	  asymbol *sym = *(*parent)->sym_ptr_ptr;
	  if (bfd_is_abs_section (sym->section) && abfd)
	    {
	      /* The special_function wouldn't get called anyways.  */
	    }
	  else if (!gp_found)
	    {
	      /* The gp isn't there; let the special function code
		 fall over on its own.  */
	    }
	  else if ((*parent)->howto->special_function
		   == _bfd_mips_elf_gprel16_reloc)
	    {
	      /* bypass special_function call */
	      r = gprel16_with_gp (input_bfd, sym, *parent, input_section,
				   relocateable, (PTR) data, gp);
	      goto skip_bfd_perform_relocation;
	    }
	  /* end mips specific stuff */
d1743 12
a1754 7
	  r = bfd_perform_relocation (input_bfd,
				      *parent,
				      (PTR) data,
				      input_section,
				      relocateable ? abfd : (bfd *) NULL,
				      &error_message);
	skip_bfd_perform_relocation:
d1756 25
a1780 3
	  if (relocateable)
	    {
	      asection *os = input_section->output_section;
a1781 4
	      /* A partial link, so keep the relocs */
	      os->orelocation[os->reloc_count] = *parent;
	      os->reloc_count++;
	    }
d1783 19
a1801 30
	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		case bfd_reloc_undefined:
		  if (!((*link_info->callbacks->undefined_symbol)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 input_bfd, input_section, (*parent)->address,
			 true)))
		    goto error_return;
		  break;
		case bfd_reloc_dangerous:
		  BFD_ASSERT (error_message != (char *) NULL);
		  if (!((*link_info->callbacks->reloc_dangerous)
			(link_info, error_message, input_bfd, input_section,
			 (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_overflow:
		  if (!((*link_info->callbacks->reloc_overflow)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 (*parent)->howto->name, (*parent)->addend,
			 input_bfd, input_section, (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_outofrange:
		default:
		  abort ();
		  break;
		}
d1803 8
a1810 11
	    }
	}
    }
  if (reloc_vector != NULL)
    free (reloc_vector);
  return data;

error_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return NULL;
a1811 3

#define bfd_elf32_bfd_get_relocated_section_contents \
  elf32_mips_get_relocated_section_contents
a1854 4
#define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
#define TARGET_LITTLE_NAME		"elf32-littlemips"
#define TARGET_BIG_SYM			bfd_elf32_bigmips_vec
#define TARGET_BIG_NAME			"elf32-bigmips"
d1862 3
a1864 4
#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
#define elf_backend_sign_extend_vma	true
d1868 3
a1870 1
#define elf_backend_object_p		_bfd_mips_elf_object_p
a1874 8
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap
d1876 2
a1887 2
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
d1892 5
a1898 4

#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0

a1900 1

d1902 3
d1906 12
d1921 1
d1923 2
a1927 2
#define bfd_elf32_bfd_copy_private_bfd_data \
					_bfd_mips_elf_copy_private_bfd_data
d1933 7
d1942 2
a1943 3
/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */
d1955 1
a1955 1
/* Include the target file again for this target */
@


1.10
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d9 2
d46 1
a46 1
#define ECOFF_32
d76 1
a76 1
     this symbol.  */ 
d83 6
d121 1
a121 1
static void bfd_mips_elf_swap_msym_in 
d151 1
a151 1
static asection *mips_elf_create_msym_section 
d153 1
a153 1
static void mips_elf_irix6_finish_dynamic_symbol 
d166 1
a166 1
static boolean mips_elf_record_global_got_symbol 
d172 1
a172 1
  PARAMS ((unsigned int, const Elf_Internal_Rela *, 
d182 1
a182 1
  PARAMS ((struct bfd_link_info *, reloc_howto_type *, 
d186 1
a186 1
static boolean mips_elf_sort_hash_table_f 
d188 1
a188 1
static boolean mips_elf_sort_hash_table 
d191 1
a191 1
static struct mips_got_info *mips_elf_got_info 
d194 2
a195 2
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **));
static bfd_vma mips_elf_create_local_got_entry 
d197 3
a199 3
static bfd_vma mips_elf_got16_entry 
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static boolean mips_elf_create_dynamic_relocation 
d203 1
a203 1
static void mips_elf_allocate_dynamic_relocations 
d205 1
a205 1
static boolean mips_elf_stub_section_p 
d207 9
d225 3
d233 1
a233 2
/* Nonzero if ABFD is using the 64-bit ABI.  FIXME: This is never
   true, yet.  */
d237 10
a246 4
/* What version of Irix we are trying to be compatible with.  FIXME:
   At the moment, we never generate "normal" MIPS ELF ABI executables;
   we always use some version of Irix.  */

d248 4
a251 1
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5)
a253 1

d328 6
a333 4
   : 0x8f998000)		/* lw t9,0x8000(gp) */
#define STUB_MOVE 0x03e07825	/* move t7,ra */
#define STUB_JALR 0x0320f809	/* jal t9 */
#define STUB_LI16 0x34180000	/* ori t8,zero,0 */
d403 1
a403 1
  unsigned int rtype : 4;	/* Relocation types. See below. */
d413 1
a413 1
  unsigned int rtype : 4;	/* Relocation types. See below. */
d542 1
a542 1
  /* 26 bit branch address.  */
d552 1
a552 1
				   bits must match the PC.  */
d908 1
a908 1
  /* Protected jump conversion.  This is an optimization hint.  No 
a976 1

d1253 1
a1253 1
	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
d1545 1
a1545 1
  insn = (insn &~ 0xffff) | (val & 0xffff);
d1552 1
a1552 1
  if (val >= 0x8000 && val < 0xffff8000)
d1670 1
a1670 1
   generated when addreses are 64 bits.  The upper 32 bits are a simle
d1843 6
d1876 6
d1901 12
d1919 1
a1919 1
/* Return printable name for ABI. */
d1921 1
a1921 1
static INLINE char*
d1931 1
a1931 1
      
a2303 1

a2310 1
/*ARGSUSED*/
d2316 6
a2321 1
  return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
a2344 1
/*ARGSUSED*/
d2393 2
d2397 20
d2419 1
a2419 1
  elf_elfheader (abfd)->e_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
d2491 1
a2491 1
/* Function to keep MIPS specific file flags like as EF_MIPS_PIC. */
d2538 2
d2542 2
a2543 15
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
d2557 1
a2557 1
      elf_elfheader (obfd)->e_ident[EI_CLASS] 
d2579 21
d2622 1
a2622 1
  /* Compare the ISA's. */
d2632 2
a2633 2
	 Some combinations of machines are ok, if the isa's match. */
      if (! new_mach 
d2638 6
a2643 7
	  /* Don't warn about mixing -mips1 and -mips2 code, or mixing -mips3
	     and -mips4 code.  They will normally use the same data sizes and
	     calling conventions.  */

	  if ((new_isa == 1 || new_isa == 2)
	      ? (old_isa != 1 && old_isa != 2)
	      : (old_isa == 1 || old_isa == 2))
d2662 2
a2663 2
      new_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
d2669 1
a2669 1
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
d2672 1
a2672 1
      /* Only error if both are set (to different values). */
d2674 1
a2674 1
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
d2720 1
a2720 1
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2723 1
a2723 1
    fprintf (file, _ (" [abi=O32]"));
d2725 1
a2725 1
    fprintf (file, _ (" [abi=O64]"));
d2727 1
a2727 1
    fprintf (file, _ (" [abi=EABI32]"));
d2729 1
a2729 1
    fprintf (file, _ (" [abi=EABI64]"));
d2731 1
a2731 1
    fprintf (file, _ (" [abi unknown]"));
d2733 1
a2733 1
    fprintf (file, _ (" [abi=N32]"));
d2735 1
a2735 1
    fprintf (file, _ (" [abi=64]"));
d2737 1
a2737 1
    fprintf (file, _ (" [no abi set]"));
d2740 1
a2740 1
    fprintf (file, _ (" [mips1]"));
d2742 1
a2742 1
    fprintf (file, _ (" [mips2]"));
d2744 1
a2744 1
    fprintf (file, _ (" [mips3]"));
d2746 7
a2752 1
    fprintf (file, _ (" [mips4]"));
d2754 1
a2754 1
    fprintf (file, _ (" [unknown ISA]"));
d2757 1
a2757 1
    fprintf (file, _ (" [32bitmode]"));
d2759 1
a2759 1
    fprintf (file, _ (" [not 32bitmode]"));
d2979 8
a2986 1
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
a2987 2
      else
	hdr->sh_entsize = 1;
d2994 2
a2995 1
      hdr->sh_entsize = 0;
d3057 1
a3057 1
      esd->rel_hdr2 
d3077 1
a3077 1
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d3213 1
a3213 1
			     SEEK_SET) == -1)
a3263 1

a3280 12
/* The Irix 5 support uses two virtual sections, which represent
   text/data symbols defined in dynamic objects.  */
static asection mips_elf_text_section;
static asection *mips_elf_text_section_ptr;
static asymbol mips_elf_text_symbol;
static asymbol *mips_elf_text_symbol_ptr;

static asection mips_elf_data_section;
static asection *mips_elf_data_section_ptr;
static asymbol mips_elf_data_symbol;
static asymbol *mips_elf_data_symbol_ptr;

a3366 3
  if (!SGI_COMPAT (abfd))
    return 0;

d3374 1
a3374 1
      && bfd_get_section_by_name (abfd, 
a3395 3
  if (! SGI_COMPAT (abfd))
    return true;

d3446 1
a3446 1
	  for (pm = &elf_tdata (abfd)->segment_map; 
d3452 1
a3452 1
	  options_segment = bfd_zalloc (abfd, 
d3465 1
a3465 5
      /* If there are .dynamic and .mdebug sections, we make a room
	 for the RTPROC header.  FIXME: Rewrite without section names.  */
      if (bfd_get_section_by_name (abfd, ".interp") == NULL
	  && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	  && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d3467 5
a3471 4
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	    if (m->p_type == PT_MIPS_RTPROC)
	      break;
	  if (m == NULL)
d3473 3
a3475 1
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d3477 4
a3480 1
		return false;
d3482 1
a3482 1
	      m->p_type = PT_MIPS_RTPROC;
d3484 12
a3495 12
	      s = bfd_get_section_by_name (abfd, ".rtproc");
	      if (s == NULL)
		{
		  m->count = 0;
		  m->p_flags = 0;
		  m->p_flags_valid = 1;
		}
	      else
		{
		  m->count = 1;
		  m->sections[0] = s;
		}
d3497 6
a3502 6
	      /* We want to put it after the DYNAMIC segment.  */
	      pm = &elf_tdata (abfd)->segment_map;
	      while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		pm = &(*pm)->next;
	      if (*pm != NULL)
		pm = &(*pm)->next;
d3504 3
a3506 2
	      m->next = *pm;
	      *pm = m;
a3508 1

d3512 2
a3513 1
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
d3517 12
d3530 1
a3530 2
	  && m->count == 1
	  && strcmp (m->sections[0]->name, ".dynamic") == 0)
d3533 3
a3535 1
	  { ".dynamic", ".dynstr", ".dynsym", ".hash" };
d3564 2
a3565 2
		     + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		    <= high))
d3582 1
a3582 2
			  s->_cooked_size : s->_raw_size))
		      <= high))
d3612 1
a3612 1
#define cbRPDR sizeof(RPDR)
d3657 1
a3657 1
  memset (debug, 0, sizeof(*debug));
a3735 1
/*ARGSUSED*/
d3778 3
a3780 2
				     line_ptr, 
				     ABI_64_P (abfd) ? 8 : 0))
d3919 1
a3919 1
     entry is set to the address of __rld_obj_head as in Irix 5. */
d3923 1
a3923 1
  /* This is set if we see any mips16 stub sections. */
d3983 1
d3993 22
a4051 1
/*ARGSUSED*/
d4088 1
a4088 1
      if (mips_elf_text_section_ptr == NULL)
d4090 11
d4102 14
a4115 10
	  mips_elf_text_section.name = ".text";
	  mips_elf_text_section.flags = SEC_NO_FLAGS;
	  mips_elf_text_section.output_section = NULL;
	  mips_elf_text_section.symbol = &mips_elf_text_symbol;
	  mips_elf_text_section.symbol_ptr_ptr = &mips_elf_text_symbol_ptr;
	  mips_elf_text_symbol.name = ".text";
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  mips_elf_text_symbol.section = &mips_elf_text_section;
	  mips_elf_text_symbol_ptr = &mips_elf_text_symbol;
	  mips_elf_text_section_ptr = &mips_elf_text_section;
d4120 1
a4120 1
      *secp = mips_elf_text_section_ptr;
d4127 1
a4127 1
      if (mips_elf_data_section_ptr == NULL)
d4129 11
d4141 14
a4154 10
	  mips_elf_data_section.name = ".data";
	  mips_elf_data_section.flags = SEC_NO_FLAGS;
	  mips_elf_data_section.output_section = NULL;
	  mips_elf_data_section.symbol = &mips_elf_data_symbol;
	  mips_elf_data_section.symbol_ptr_ptr = &mips_elf_data_symbol_ptr;
	  mips_elf_data_symbol.name = ".data";
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  mips_elf_data_symbol.section = &mips_elf_data_section;
	  mips_elf_data_symbol_ptr = &mips_elf_data_symbol;
	  mips_elf_data_section_ptr = &mips_elf_data_section;
d4159 1
a4159 1
      *secp = mips_elf_data_section_ptr;
d4182 1
a4182 1
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d4264 2
a4265 3
      if (SGI_COMPAT (einfo->abfd)
	  && (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak))
d4360 10
a4369 6
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = h->root.root.u.def.section;
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
d4371 5
a4375 5
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
d4377 9
a4385 2
	    h->esym.asym.value = 0;
	}
d4387 1
a4387 1
      h->esym.ifd = 0;
d4389 1
d4587 14
d4629 1
a4629 1
      if (!mips_elf_sort_hash_table (info, (info->shared 
d4632 1
a4632 1
        return false;
d4649 1
a4649 1
  if (IRIX_COMPAT (abfd) == ict_irix5)
d4656 1
a4656 1
		p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
d4660 1
a4660 1
	    
d4683 1
a4683 1
	    if (o->vma < lo 
d4757 1
a4757 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d4811 11
a4821 1
	  if (SGI_COMPAT (abfd))
d4823 3
a4825 21
	      asection *s;
	      EXTR esym;
	      bfd_vma last;
	      unsigned int i;
	      static const char * const name[] =
		{ ".text", ".init", ".fini", ".data",
		    ".rodata", ".sdata", ".sbss", ".bss" };
	      static const int sc[] = { scText, scInit, scFini, scData,
					  scRData, scSData, scSBss, scBss };

	      esym.jmptbl = 0;
	      esym.cobol_main = 0;
	      esym.weakext = 0;
	      esym.reserved = 0;
	      esym.ifd = ifdNil;
	      esym.asym.iss = issNil;
	      esym.asym.st = stLocal;
	      esym.asym.reserved = 0;
	      esym.asym.index = indexNil;
	      last = 0;
	      for (i = 0; i < 8; i++)
d4827 2
a4828 13
		  esym.asym.sc = sc[i];
		  s = bfd_get_section_by_name (abfd, name[i]);
		  if (s != NULL)
		    {
		      esym.asym.value = s->vma;
		      last = s->vma + s->_raw_size;
		    }
		  else
		    esym.asym.value = last;

		  if (! bfd_ecoff_debug_one_external (abfd, &debug, swap,
						      name[i], &esym))
		    return false;
d4830 5
d4938 1
a4938 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d5017 1
a5017 1
		  input_section->flags &=~ SEC_HAS_CONTENTS;
d5176 1
a5176 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d5276 20
d5306 1
a5306 1
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT 
d5331 2
a5332 1
mips_elf_local_relocation_p (input_bfd, relocation, local_sections)
d5336 1
d5340 2
d5345 8
a5352 3
  if (! elf_bad_symtab (input_bfd))
    return r_symndx < symtab_hdr->sh_info;
  else
d5354 10
a5363 3
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      return local_sections[r_symndx] != NULL;
d5365 2
d5376 1
a5376 1
  if (value & ((bfd_vma)1 << (bits - 1)))
d5378 2
a5379 2
    value |= ((bfd_vma) - 1) << bits;      
  
d5400 1
a5400 1
    
d5430 1
a5430 1
static bfd_vma 
d5444 1
a5444 1
static bfd_vma 
d5460 1
a5460 1
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno) 
d5481 1
a5481 1
  return (sgot->output_section->vma + sgot->output_offset + index - 
d5500 1
a5500 1
  
d5515 1
a5515 1
     
d5530 1
a5530 1
   index.  Otherwise, assign it the lowest available dynamic 
d5538 1
a5538 1
  struct mips_elf_hash_sort_data *hsd 
d5578 3
a5580 3
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *) 
				elf_hash_table (info)), 
			       mips_elf_sort_hash_table_f, 
d5585 1
a5585 1
  BFD_ASSERT (hsd.min_got_dynindx == hsd.max_non_got_dynindx);
d5615 1
a5615 1
		     (sgot->contents 
d5637 2
a5638 2
  for (entry = (sgot->contents 
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO); 
d5674 1
a5674 1
  for (entry = (sgot->contents 
d5707 1
a5707 1
mips_elf_got16_entry (abfd, info, value)
d5711 1
d5720 9
a5728 5
  /* Although the ABI says that it is "the high-order 16 bits" that we
     want, it is really the %high value.  The complete value is
     calculated with a `addiu' of a LO16 relocation, just as with a
     HI16/LO16 pair.  */
  value = mips_elf_high (value) << 16;
d5733 1
a5733 1
  for (entry = (sgot->contents 
d5739 1
a5739 1
      if ((address & 0xffff0000) == value)
d5741 2
a5742 1
	  /* This entry has the right high-order 16 bits.  */
d5785 1
a5785 1
   dyanmic relocation.  The ADDENDP is adjusted if necessary; the
d5808 1
a5808 1
  sreloc 
d5812 1
d5827 1
a5827 1
      outrel.r_offset 
d5839 1
a5839 1
  /* If we've decided to skip this relocation, just output an emtpy
d5856 4
a5859 1
	  BFD_ASSERT (indx != -1);
d5883 1
a5883 1
	  *addendp += symbol - sec->output_section->vma;
d5887 6
a5892 5
      
      /* If the relocation was previously an absolute relocation, we
	 must adjust it by the value we give it in the dynamic symbol
	 table.  */
      if (r_type != R_MIPS_REL32)
d5912 1
a5912 1
	 (sreloc->contents 
d5924 1
a5924 1
      && (h->min_dyn_reloc_index == 0 
d5939 1
a5939 1
      asection* scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
d5983 1
a5983 1
mips_elf_calculate_relocation (abfd, 
d5994 1
a5994 1
			       require_jalxp) 
d6028 1
a6028 1
  struct mips_elf_link_hash_entry* h = NULL;
d6047 1
a6047 1
  p = (input_section->output_section->vma 
d6058 1
a6058 1
					 local_sections);
d6067 1
a6067 1
      
d6096 1
a6096 1
      h = ((struct mips_elf_link_hash_entry *) 
d6099 2
a6100 2
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
d6102 1
a6102 1
      
d6127 1
a6127 1
	    symbol = (h->root.root.u.def.value 
d6142 2
a6143 1
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0)
d6146 2
a6147 1
	     _DYNAMIC_LINK symbol in mips_elf_create_dynamic_sections.
d6168 1
a6168 1
  
d6194 1
a6194 1
	   && h != NULL 
d6232 3
d6250 1
a6250 1
	  g = mips_elf_global_got_index 
d6252 14
a6265 1
	     (struct elf_link_hash_entry*) h);
d6267 1
a6267 1
      else if (r_type == R_MIPS_GOT16)
d6282 1
a6282 1
      
d6313 2
a6314 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		   == 0)))
d6323 2
a6324 2
	  if (!mips_elf_create_dynamic_relocation (abfd, 
						   info, 
d6362 1
a6362 1
      /* The calculation for R_MIPS_26 is just the same as for an
d6369 1
a6369 1
	value = (((addend << 2) | (p & 0xf0000000)) + symbol) >> 2;
d6433 1
a6433 1
      
d6435 1
d6438 8
a6445 1
	  value = mips_elf_got16_entry (abfd, info, symbol + addend);
d6448 1
a6448 1
	  value 
a6457 1
    case R_MIPS_CALL16:
d6497 1
a6497 1
      
d6517 1
a6517 1
      
d6580 1
a6580 1
			     input_bfd, input_section, 
d6619 1
a6619 1
	 
d6644 1
a6644 1
	 
d6651 1
a6651 1
	 
d6660 1
a6660 1
	 
d6662 1
a6662 1
	 (((A < 2) | (P & 0xf0000000) + S) >> 2)
d6664 1
a6664 1
	 let R = (((A < 2) | (P & 0xf0000000) + S) >> 2)
d6669 2
a6670 2
	value = (((value & 0x1f0000) << 5) 
		 | ((value & 0x3e00000) >> 5) 
a6671 1
      
d6683 1
a6683 1
	 
d6686 1
a6686 1
	 
d6689 1
a6689 1
	 is, the Imm fields above replace the V-rel16 field.  
d6742 1
a6742 1
  
d6794 1
d6800 1
a6800 1
	     64-bit code, but make sure all their addresses are in the 
d6810 1
a6810 1
	      rel->r_offset += 4;
d6827 1
a6827 2
	      >= (rel_hdr->sh_size / rel_hdr->sh_entsize
		  * bed->s->int_rels_per_ext_rel))
d6835 1
a6835 1
	      addend = mips_elf_obtain_contents (howto, 
d6848 1
a6848 1
						      local_sections)))
d6859 1
a6859 1
		     the LO16 value.)  
d6866 2
a6867 2
		  lo16_relocation 
		    = mips_elf_next_relocation (lo, rel, relend); 
d6914 2
a6915 1
	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections))
d6919 1
a6919 1
	  if (r_type == R_MIPS16_GPREL 
d6938 1
a6938 1
	  
d6974 3
a6976 3
		  
		  if (addend & 0x80000000u)
		    sign_bits = 0xffffffffu;
d6979 1
a6979 1
		  
d6994 1
a6994 1
		  bfd_put_32 (input_bfd, low_bits, 
d6996 1
a6996 1
		  bfd_put_32 (input_bfd, high_bits, 
d7002 1
a7002 1
						input_bfd,  input_section, 
d7015 1
a7015 1
      if (rel + 1 < relend 
d7023 1
a7023 1
      switch (mips_elf_calculate_relocation (output_bfd, 
d7048 4
a7051 2
	  abort ();
	  break;
d7097 2
a7098 2
	  if (value & 0x80000000u)
	    sign_bits = 0xffffffffu;
d7118 1
a7118 1
	  bfd_put_32 (input_bfd, low_bits, 
d7120 1
a7120 1
	  bfd_put_32 (input_bfd, high_bits, 
d7126 1
a7126 1
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd, 
a7138 1
/*ARGSIGNORED*/
d7204 1
a7204 1
  
d7206 1
a7206 1
  if (bfd_get_section_by_name (abfd, 
d7217 1
a7217 1
  if (IRIX_COMPAT (abfd) == ict_irix5
d7244 1
a7244 1
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7253 5
a7257 2
      if (! mips_elf_create_compact_rel_section (abfd, info))
	return false;
d7280 20
a7299 7
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
	      (bfd_vma) 0, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
	return false;
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7316 20
a7335 7
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, "__rld_map", BSF_GLOBAL, s,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	    return false;
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7375 1
a7375 1
/* Create the .got section to hold the global offset table. */
d7410 1
a7410 1
  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7436 1
a7436 1
  elf_section_data (s)->this_hdr.sh_flags 
d7452 1
a7452 1
  if (!s) 
d7456 1
a7456 1
	  || !bfd_set_section_flags (abfd, s, 
d7460 1
a7460 1
				     | SEC_LINKER_CREATED 
d7481 1
a7481 1
  
d7484 1
a7484 1
      /* Make room for a null element. */
d7589 1
a7589 1
             this BFD. */
d7596 1
a7596 1
		symcount = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
d7711 7
d7772 4
a7775 4
	     the segment.  Similar comments apply to R_MIPS_GOT16.  We
	     don't count R_MIPS_GOT_HI16, or R_MIPS_CALL_HI16 because
	     these are always followed by an R_MIPS_GOT_LO16 or
	     R_MIPS_CALL_LO16.
d7865 1
a7865 1
	     
d7875 1
a7875 1
	  if (SGI_COMPAT (dynobj))
d7884 1
a7884 1
	  if (SGI_COMPAT (dynobj))
d7907 19
d7928 1
a7928 1
         References from a stub section do not count. */
d8032 1
a8032 1
        break;
d8042 22
d8100 1
a8100 1
    mips_elf_allocate_dynamic_relocations (dynobj, 
d8103 3
a8105 3
  /* For a function, create a stub, if needed. */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d8117 1
a8117 1
	  s = bfd_get_section_by_name (dynobj, 
d8135 8
a8194 1
/*ARGSUSED*/
d8208 1
a8208 1
      h->fn_stub->flags &= ~ SEC_RELOC;
d8221 1
a8221 1
      h->call_stub->flags &= ~ SEC_RELOC;
d8234 1
a8234 1
      h->call_fp_stub->flags &= ~ SEC_RELOC;
d8264 1
a8264 1
	  s->_raw_size 
d8266 1
a8266 1
	  s->contents 
d8321 1
a8321 1
		  || strcmp (outname, 
d8327 1
a8327 1
	      if (strcmp (name, 
d8335 3
a8337 3
 	  bfd_size_type loadable_size = 0;
 	  bfd_size_type local_gotno;
 	  struct _bfd *sub;
d8339 1
a8339 1
 	  BFD_ASSERT (elf_section_data (s) != NULL);
d8341 19
a8359 1
 	  BFD_ASSERT (g != NULL);
d8361 3
a8363 21
 	  /* Calculate the total loadable size of the output.  That
 	     will give us the maximum number of GOT_PAGE entries
 	     required.  */
 	  for (sub = info->input_bfds; sub; sub = sub->link_next)
 	    {
 	      asection *subsection;
 
 	      for (subsection = sub->sections; 
 		   subsection; 
 		   subsection = subsection->next)
 		{
 		  if ((subsection->flags & SEC_ALLOC) == 0)
 		    continue;
 		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
 		}
 	    }
 	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

 	  /* Assume there are two loadable segments consisting of
 	     contiguous sections.  Is 5 enough?  */
 	  local_gotno = (loadable_size >> 16) + 5;
d8370 2
a8371 2
 	  g->local_gotno += local_gotno;
 	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);
d8373 5
a8377 5
 	  /* There has to be a global GOT entry for every symbol with
 	     a dynamic symbol table index of DT_MIPS_GOTSYM or
 	     higher.  Therefore, it make sense to put those symbols
 	     that need GOT entries at the end of the symbol table.  We
 	     do that here.  */
d8409 1
a8409 1
	s->_raw_size = (sizeof (Elf32_External_Msym) 
d8442 14
a8455 1
	  if (SGI_COMPAT (output_bfd))
d8457 1
a8457 3
	      /* SGI object has the equivalence of DT_DEBUG in the
		 DT_MIPS_RLD_MAP entry.  */
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
a8459 3
	  else
	    if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
	      return false;
d8461 1
a8461 2

      if (reltext)
d8465 1
d8484 5
a8488 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	return false;
d8490 5
a8494 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	return false;
d8550 1
a8550 1
	  && (bfd_get_section_by_name 
d8555 1
a8555 1
      if (bfd_get_section_by_name (dynobj, 
d8596 1
a8596 1
    for (p = (i == 0) ? text_section_symbols : data_section_symbols; 
d8604 1
a8604 1
	  
d8610 1
a8610 1
	  
d8647 1
a8647 1
      s = bfd_get_section_by_name (dynobj, 
d8653 1
a8653 1
      bfd_put_32 (output_bfd, STUB_LW(output_bfd), p);
d8655 1
a8655 1
      bfd_put_32 (output_bfd, STUB_MOVE, p);
d8664 1
a8664 1
      bfd_put_32 (output_bfd, STUB_LI16 + h->dynindx, p);
d8680 2
a8681 1
  BFD_ASSERT (h->dynindx != -1);
d8700 6
a8705 6
	/* For an entity defined in a shared object, this will be
	   NULL.  (For functions in shared objects for
	   which we have created stubs, ST_VALUE will be non-NULL.
	   That's because such the functions are now no longer defined
	   in a shared object.)  */
	value = h->root.u.def.value;
d8707 5
d8717 1
a8717 1
  smsym = bfd_get_section_by_name (dynobj, 
d8727 1
a8727 1
      bfd_mips_elf_swap_msym_out 
d8737 2
a8738 1
  else if (strcmp (name, "_DYNAMIC_LINK") == 0)
d8744 6
d8752 2
a8753 8
      if (strcmp (name, "_gp_disp") == 0)
	{
	  sym->st_shndx = SHN_ABS;
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_value = elf_gp (output_bfd);
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	       || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
d8780 1
a8780 2
  if (SGI_COMPAT (output_bfd)
      && ! info->shared)
d8783 2
a8784 1
	  && strcmp (name, "__rld_map") == 0)
d8797 3
a8799 2
	  if (IRIX_COMPAT (output_bfd) == ict_irix5)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map") 
d8858 1
a8858 1
	  
d8865 1
a8865 1
	      s = (bfd_get_section_by_name 
d8918 1
a8918 1
		    dyn.d_un.d_val = 0;
d8983 1
a8983 1
	      s = (bfd_get_section_by_name 
d8989 1
a8989 1
	      s = (bfd_get_section_by_name 
d9000 1
a9000 1
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out) 
d9007 1
a9007 1
     This isn't the case of Irix rld. */
d9011 1
a9011 1
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, 
d9028 1
a9028 1
    smsym = bfd_get_section_by_name (dynobj, 
d9041 1
a9041 1
	    bfd_mips_elf_swap_msym_out 
d9066 1
a9066 1
	    s = bfd_get_section_by_name (dynobj, 
d9080 17
d9098 1
a9098 1
    s = bfd_get_section_by_name (dynobj, 
d9290 1
d9296 1
a9296 2
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap =
{
d9390 5
d9409 17
@


1.9
log
@Help stupid cvs fixing basic conflicts.
@
text
@d5933 2
a5934 1
      else if (info->shared && !info->symbolic && !info->no_undefined)
d5952 2
a5953 1
		  (!info->shared || info->no_undefined))))
@


1.8
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d6 2
d46 51
d101 2
d105 2
d111 6
a117 1
static boolean mips_elf32_object_p PARAMS ((bfd *));
a120 2
static int mips_elf_additional_program_headers PARAMS ((bfd *));
static boolean mips_elf_modify_segment_map PARAMS ((bfd *));
d122 4
a125 6
static boolean mips_elf32_section_from_shdr
  PARAMS ((bfd *, Elf32_Internal_Shdr *, char *));
static boolean mips_elf32_section_processing
  PARAMS ((bfd *, Elf32_Internal_Shdr *));
static boolean mips_elf_is_local_label
  PARAMS ((bfd *, asymbol *));
a127 2
static struct bfd_link_hash_table *mips_elf_link_hash_table_create
  PARAMS ((bfd *));
d129 4
a132 17
static boolean mips_elf_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
static void mips_elf_relocate_hi16
  PARAMS ((bfd *, Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_byte *,
	   bfd_vma));
static void mips_elf_relocate_got_local
  PARAMS ((bfd *, bfd *, asection *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static void mips_elf_relocate_global_got
   PARAMS ((bfd *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static boolean mips_elf_adjust_dynindx
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean mips_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static boolean mips_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a136 15
static boolean mips_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean mips_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static boolean mips_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static boolean mips_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d142 146
a287 17

/* This is true for Irix 5 executables, false for normal MIPS ELF ABI
   executables.  FIXME: At the moment, we default to always generating
   Irix 5 executables.  */

#define SGI_COMPAT(abfd) (1)

/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The symbol index of the first global .got symbol.  */
  unsigned long global_gotsym;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
};
d295 5
a299 3
#define STUB_LW(abfd)					\
  (SGI_COMPAT (abfd)					\
   ? 0x8f998010			/* lw t9,0x8010(gp) */	\
d306 5
d335 2
d446 3
a448 23
enum reloc_type
{
  R_MIPS_NONE = 0,
  R_MIPS_16,		R_MIPS_32,
  R_MIPS_REL32,		R_MIPS_26,
  R_MIPS_HI16,		R_MIPS_LO16,
  R_MIPS_GPREL16,	R_MIPS_LITERAL,
  R_MIPS_GOT16,		R_MIPS_PC16,
  R_MIPS_CALL16,	R_MIPS_GPREL32,
  /* The remaining relocs are defined on Irix, although they are not
     in the MIPS ELF ABI.  */
  R_MIPS_UNUSED1,	R_MIPS_UNUSED2,
  R_MIPS_UNUSED3,
  R_MIPS_SHIFT5,	R_MIPS_SHIFT6,
  R_MIPS_64,		R_MIPS_GOT_DISP,
  R_MIPS_GOT_PAGE,	R_MIPS_GOT_OFST,
  R_MIPS_GOT_HI16,	R_MIPS_GOT_LO16,
  R_MIPS_SUB,		R_MIPS_INSERT_A,
  R_MIPS_INSERT_B,	R_MIPS_DELETE,
  R_MIPS_HIGHER,	R_MIPS_HIGHEST,
  R_MIPS_CALL_HI16,	R_MIPS_CALL_LO16,
  R_MIPS_max
};
d601 1
a601 1
	 0,			/* src_mask */
d618 1
a618 1
	 false),		/* pcrel_offset */
a620 1
  /* FIXME: This is not handled correctly.  */
d631 1
a631 1
	 0,			/* src_mask */
d652 3
a654 3
    { 13 },
    { 14 },
    { 15 },
d688 1
a688 4
  /* A 64 bit relocation.  This is used in 32 bit ELF when addresses
     are 64 bits long; the upper 32 bits are simply a sign extension.
     The fields of the howto should be the same as for R_MIPS_32,
     other than the type, name, and special_function.  */
d691 2
a692 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d699 2
a700 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
a703 1
  /* FIXME: Not handled correctly.  */
a718 1
  /* FIXME: Not handled correctly.  */
a733 1
  /* FIXME: Not handled correctly.  */
a748 1
  /* FIXME: Not handled correctly.  */
a763 1
  /* FIXME: Not handled correctly.  */
d778 14
a791 2
  /* 64 bit subtraction.  Presumably not used in 32 bit ELF.  */
  { R_MIPS_SUB },
d794 33
a826 8
  { R_MIPS_INSERT_A },
  { R_MIPS_INSERT_B },
  { R_MIPS_DELETE },

  /* Get the higher values of a 64 bit addend.  Presumably not used in
     32 bit ELF.  */
  { R_MIPS_HIGHER },
  { R_MIPS_HIGHEST },
a828 1
  /* FIXME: Not handled correctly.  */
a843 1
  /* FIXME: Not handled correctly.  */
d856 37
a892 1
	 false)			/* pcrel_offset */
d895 166
d1089 1
a1089 1
     bfd *abfd;
d1320 51
d1403 1
a1403 1
      else
d1405 5
a1409 3
	  unsigned int count;
	  asymbol **sym;
	  unsigned int i;
d1411 2
a1412 2
	  count = bfd_get_symcount (output_bfd);
	  sym = bfd_get_outsymbols (output_bfd);
d1414 2
a1415 35
	  if (sym == (asymbol **) NULL)
	    i = count;
	  else
	    {
	      for (i = 0; i < count; i++, sym++)
		{
		  register CONST char *name;

		  name = bfd_asymbol_name (*sym);
		  if (*name == '_' && strcmp (name, "_gp") == 0)
		    {
		      *pgp = bfd_asymbol_value (*sym);
		      _bfd_set_gp_value (output_bfd, *pgp);
		      break;
		    }
		}
	    }

	  if (i >= count)
	    {
	      /* Only get the error once.  */
	      *pgp = 4;
	      _bfd_set_gp_value (output_bfd, *pgp);
	      *error_message =
		(char *) "GP relative relocation when _gp not defined";
	      return bfd_reloc_dangerous;
	    }
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
d1565 1
a1565 1
	"32bits gp relative relocation occurs for an external symbol";
d1687 210
d1901 1
a1901 1
  enum reloc_type elf_reloc_val;
a1908 1
  { BFD_RELOC_CTOR, R_MIPS_32 },
d1922 5
a1926 1
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 }
d1943 78
a2020 1
  return NULL;
d2023 1
a2023 1
/* Given a MIPS reloc type, fill in an arelent structure.  */
d2034 1
a2034 2
  BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
  cache_ptr->howto = &elf_mips_howto_table[r_type];
d2045 17
d2227 25
d2262 1
a2262 1
     bfd *abfd;
d2275 1
a2275 30
  switch (elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH)
    {
    default:
    case E_MIPS_ARCH_1:
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 3000);
      break;

    case E_MIPS_ARCH_2:
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 6000);
      break;

    case E_MIPS_ARCH_3:
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 4000);
      break;

    case E_MIPS_ARCH_4:
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 8000);
      break;
    }

  return true;
}

/* Set the right machine number for a 32-bit MIPS ELF file.  */

static boolean
mips_elf32_object_p (abfd)
     bfd *abfd;
{
  /* Irix 5 is broken.  Object file symbol tables are not always
d2280 3
a2282 1
  return _bfd_mips_elf_object_p (abfd);
d2293 1
a2293 1
     boolean linker;
d2303 2
a2304 1
    case 3000:
d2308 5
a2312 1
    case 6000:
d2316 2
a2317 1
    case 4000:
d2321 14
a2334 2
    case 8000:
      val = E_MIPS_ARCH_4;
d2337 2
a2338 2
    default:
      val = 0;
d2342 1
a2342 1
  elf_elfheader (abfd)->e_flags &=~ EF_MIPS_ARCH;
d2345 2
a2346 1
  /* Set the sh_info field for .gptab sections.  */
d2353 1
d2379 1
a2379 1
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
d2409 1
a2449 20
/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    }
  return 4;
}

d2460 1
d2466 8
a2473 5
      (*_bfd_error_handler)
	("%s: compiled for a %s endian system and target is %s endian",
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");
d2487 1
a2487 1
  if (!elf_flags_init (obfd))	/* First call, no flags set */
d2491 3
d2496 27
a2522 1
	bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
d2524 2
a2525 4
  else if (((new_flags ^ old_flags) & ~EF_MIPS_NOREORDER)
	   == 0)			/* Compatible flags are ok */
    ;
  else					/* Incompatible flags */
d2527 40
a2566 2
      /* Warn about -fPIC mismatch */
      if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
a2567 2
	  new_flags &= ~EF_MIPS_PIC;
	  old_flags &= ~EF_MIPS_PIC;
d2569 21
a2589 5
	    ("%s: needs all files compiled with -fPIC",
	     bfd_get_filename (ibfd));
	}

      if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
a2590 2
	  new_flags &= ~EF_MIPS_CPIC;
	  old_flags &= ~EF_MIPS_CPIC;
d2592 5
a2596 2
	    ("%s: needs all files compiled with -mabicalls",
	     bfd_get_filename (ibfd));
d2598 3
d2602 9
a2610 37
      /* Don't warn about mixing -mips1 and -mips2 code, or mixing
         -mips3 and -mips4 code.  They will normally use the same data
         sizes and calling conventions.  */
      if ((new_flags & EF_MIPS_ARCH) != (old_flags & EF_MIPS_ARCH))
	{
	  int new_isa, old_isa;

	  new_isa = elf_mips_isa (new_flags);
	  old_isa = elf_mips_isa (old_flags);
	  if ((new_isa == 1 || new_isa == 2)
	      ? (old_isa != 1 && old_isa != 2)
	      : (old_isa == 1 || old_isa == 2))
	    (*_bfd_error_handler)
	      ("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)",
	       bfd_get_filename (ibfd), new_isa, old_isa);

	  new_flags &= ~ EF_MIPS_ARCH;
	  old_flags &= ~ EF_MIPS_ARCH;
	}

      /* Warn about any other mismatches */
      if ((new_flags & ~(EF_MIPS_ARCH | EF_MIPS_NOREORDER)) !=
	  (old_flags & ~(EF_MIPS_ARCH | EF_MIPS_NOREORDER)))
	(*_bfd_error_handler)
	  ("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)",
	   bfd_get_filename (ibfd), (unsigned long) new_flags,
	   (unsigned long) old_flags);

      /* Warn about ISA LEVEL mismatch */
      if ((new_flags & EF_MIPS_ARCH) > (old_flags & EF_MIPS_ARCH)) {
	(*_bfd_error_handler)
	  ("%s: increases ISA level to ISA%d from ISA%d",
	   bfd_get_filename (ibfd), (unsigned long) new_flags >> 28,
	   (unsigned long) old_flags >> 28);
        elf_elfheader (obfd)->e_flags &= ~EF_MIPS_ARCH;
        elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ARCH;
      }
d2612 2
d2621 53
d2685 1
a2685 1
     const char *name;
d2687 2
d2701 1
a2701 1
      if (strcmp (name, ".msym") != 0)
d2719 1
d2725 1
d2736 1
a2736 2
      if (strcmp (name, ".options") != 0
	  && strcmp (name, ".MIPS.options") != 0)
d2760 1
a2760 1
  if (hdr->sh_type == SHT_MIPS_DEBUG)
d2765 1
a2765 1
				    | SEC_DEBUGGING)))
a2768 14
  return true;
}

/* Handle a 32-bit MIPS ELF specific section.  */

static boolean
mips_elf32_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  if (! _bfd_mips_elf_section_from_shdr (abfd, hdr, name))
    return false;

d2812 12
a2823 1
	  if (intopt.kind == ODK_REGINFO)
a2861 6
  else if (strcmp (name, ".msym") == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_entsize = 8;
      /* FIXME: Set the sh_info field.  */
    }
a2890 5

      /* Force the section size to the correct value, even if the
	 linker thinks it is larger.  The link routine below will only
	 write out this much data for .reginfo.  */
      hdr->sh_size = sec->_raw_size = sizeof (Elf32_External_RegInfo);
d2898 2
d2901 1
d2904 1
d2915 1
a2915 1
  else if (strcmp (name, ".MIPS.content") == 0)
d2918 1
d2921 1
a2921 2
  else if (strcmp (name, ".options") == 0
	   || strcmp (name, ".MIPS.options") == 0)
d2943 23
d2978 2
a2979 2
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
d3008 1
a3008 2
  if (strcmp (section->name, ".options") == 0
      || strcmp (section->name, ".MIPS.options") == 0)
d3028 1
a3028 1
	  c = (PTR) bfd_zalloc (abfd, size);
d3051 2
a3052 51
  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
      else if (strcmp (name, ".lit8") == 0
	       || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return true;
}

/* Work over a section just before writing it out.  We update the GP
   value in the SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS sections based
   on the value we are using.  */

static boolean
mips_elf32_section_processing (abfd, hdr)
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_REGINFO)
d3091 16
a3106 1
	  if (intopt.kind == ODK_REGINFO)
d3125 40
a3164 1
  return _bfd_mips_elf_section_processing (abfd, hdr);
d3166 1
d3178 1
a3178 1
   allocated common symbol which may be overridden by a 	
d3233 3
a3235 2
	 treated as SHN_MIPS_SCOMMON symbols.  */
      if (asym->value > elf_gp_size (abfd))
d3275 2
a3276 2
static int
mips_elf_additional_program_headers (abfd)
d3280 1
a3280 1
  int ret;
d3282 2
a3283 4
  ret = 0;

  if (! SGI_COMPAT (abfd))
    return ret;
d3285 1
d3287 2
a3288 5
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* We need a PT_MIPS_REGINFO segment.  */
      ++ret;
    }
d3290 11
a3300 6
  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
    {
      /* We need a PT_MIPS_RTPROC segment.  */
      ++ret;
    }
d3307 2
a3308 2
static boolean
mips_elf_modify_segment_map (abfd)
d3346 6
a3351 6
	  
  /* If there are .dynamic and .mdebug sections, we make a room for
     the RTPROC header.  FIXME: Rewrite without section names.  */
  if (bfd_get_section_by_name (abfd, ".interp") == NULL
      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d3353 4
a3356 2
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_RTPROC)
d3358 2
a3359 1
      if (m == NULL)
d3361 1
a3361 3
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	  if (m == NULL)
	    return false;
d3363 9
a3371 21
	  m->p_type = PT_MIPS_RTPROC;

	  s = bfd_get_section_by_name (abfd, ".rtproc");
	  if (s == NULL)
	    {
	      m->count = 0;
	      m->p_flags = 0;
	      m->p_flags_valid = 1;
	    }
	  else
	    {
	      m->count = 1;
	      m->sections[0] = s;
	    }

	  /* We want to put it after the DYNAMIC segment.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
	    pm = &(*pm)->next;
	  if (*pm != NULL)
	    pm = &(*pm)->next;
d3373 9
a3381 2
	  m->next = *pm;
	  *pm = m;
d3384 1
a3384 10

  /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic, .dynstr,
     .dynsym, and .hash sections, and everything in between.  */
  for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
    if ((*pm)->p_type == PT_DYNAMIC)
      break;
  m = *pm;
  if (m != NULL
      && m->count == 1
      && strcmp (m->sections[0]->name, ".dynamic") == 0)
d3386 5
a3390 9
      static const char *sec_names[] =
	{ ".dynamic", ".dynstr", ".dynsym", ".hash" };
      bfd_vma low, high;
      unsigned int i, c;
      struct elf_segment_map *n;

      low = 0xffffffff;
      high = 0;
      for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
d3392 4
a3395 2
	  s = bfd_get_section_by_name (abfd, sec_names[i]);
	  if (s != NULL && (s->flags & SEC_LOAD) != 0)
d3397 3
a3399 1
	      bfd_size_type sz;
d3401 24
a3424 7
	      if (low > s->vma)
		low = s->vma;
	      sz = s->_cooked_size;
	      if (sz == 0)
		sz = s->_raw_size;
	      if (high < s->vma + sz)
		high = s->vma + sz;
d3428 35
a3462 8
      c = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_LOAD) != 0
	    && s->vma >= low
	    && ((s->vma
		 + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		<= high))
	  ++c;
d3464 15
a3478 6
      n = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
      if (n == NULL)
	return false;
      *n = *m;
      n->count = c;
d3480 2
a3481 8
      i = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LOAD) != 0
	      && s->vma >= low
	      && ((s->vma
		   + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		  <= high))
d3483 10
a3492 2
	      n->sections[i] = s;
	      ++i;
d3494 2
a3496 2

      *pm = n;
d3563 1
d3644 1
a3644 1
mips_elf_is_local_label (abfd, symbol)
d3646 1
a3646 1
     asymbol *symbol;
d3648 6
a3653 1
  return symbol->name[0] == '$';
d3678 11
d3772 2
a3773 2
/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */
d3775 34
a3808 10
struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of MIPS_32 or MIPS_REL32 relocs against this symbol.  */
  unsigned int mips_32_relocs;
};
d3815 2
d3819 1
d3829 2
d3887 6
a3892 1
      ret->mips_32_relocs = 0;
d3900 2
a3901 2
static struct bfd_link_hash_table *
mips_elf_link_hash_table_create (abfd)
a3904 1
  unsigned int i;
d3918 2
d3922 1
d3927 1
d3936 2
a3937 2
static boolean
mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
d3942 1
a3942 1
     flagword *flagsp;
d3960 2
a3961 1
      if (sym->st_size > elf_gp_size (abfd))
a3977 1
	  mips_elf_text_section.owner = abfd;
d3981 1
a3981 1
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM;
d3986 4
a3989 4
      if (info->shared)
	*secp = bfd_und_section_ptr;
      else
	*secp = mips_elf_text_section_ptr;
a4001 1
	  mips_elf_data_section.owner = abfd;
d4005 1
a4005 1
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM;
d4010 4
a4013 4
      if (info->shared)
	*secp = bfd_und_section_ptr;
      else
	*secp = mips_elf_data_section_ptr;
d4046 6
d4167 1
a4167 1
	
d4224 1
a4224 1
	    h->esym.asym.value = (h->root.plt_offset
d4233 1
a4233 1
    }      
d4270 1
a4270 1
  const char *no_name_func = "static procedure (no name)";
d4364 1
a4364 1
  s->contents = rtproc;
d4414 2
a4415 2
static boolean
mips_elf_final_link (abfd, info)
d4431 9
a4439 14
  /* Drop the .options section, since it has special semantics which I
     haven't bothered to figure out.  */
  for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
    {
      if (strcmp ((*secpp)->name, ".options") == 0)
	{
	  for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
	  (*secpp)->link_order_head = NULL;
	  *secpp = (*secpp)->next;
	  --abfd->section_count;
	  break;
	}
d4442 52
d4509 1
a4509 1
	  /* Make up a value.  */
d4512 5
a4516 8
	    {
	      if (o->vma < lo
		  && (strcmp (o->name, ".sbss") == 0
		      || strcmp (o->name, ".sdata") == 0
		      || strcmp (o->name, ".lit4") == 0
		      || strcmp (o->name, ".lit8") == 0))
		lo = o->vma;
	    }
d4589 2
a4590 2
	  /* Force the section size to the value we want.  */
	  o->_raw_size = sizeof (Elf32_External_RegInfo);
d4661 1
d4673 1
a4673 1
		
d4791 1
a4791 1
				    | SEC_READONLY);
d4796 1
a4796 1
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 12))
d4887 1
a4887 1
		("%s: illegal section name `%s'",
d5049 11
a5059 1
  if (! bfd_elf32_bfd_final_link (abfd, info))
d5119 33
a5151 1
/* Handle a MIPS ELF HI16 reloc.  */
d5153 2
a5154 2
static void
mips_elf_relocate_hi16 (input_bfd, relhi, rello, contents, addend)
d5156 40
a5195 4
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
d5197 12
a5208 2
  bfd_vma insn;
  bfd_vma addlo;
d5210 8
a5217 1
  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);
d5219 1
a5219 2
  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  addlo &= 0xffff;
d5221 11
a5231 1
  addend += ((insn & 0xffff) << 16) + addlo;
d5233 1
a5233 4
  if ((addlo & 0x8000) != 0)
    addend -= 0x10000;
  if ((addend & 0x8000) != 0)
    addend += 0x10000;
d5235 10
a5244 3
  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | ((addend >> 16) & 0xffff),
	      contents + relhi->r_offset);
d5247 12
a5258 1
/* Handle a MIPS ELF local GOT16 reloc.  */
d5260 18
a5277 3
static void
mips_elf_relocate_got_local (output_bfd, input_bfd, sgot, relhi, rello,
			     contents, addend)
d5279 128
a5406 1
     bfd *input_bfd;
d5408 59
a5466 4
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
d5468 5
a5472 4
  int local_gotno;
  int i;
  bfd_vma insn;
  bfd_vma addlo;
a5473 3
  bfd_vma hipage;
  bfd_byte *got_contents;
  struct mips_got_info *g;
d5475 19
a5493 1
  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);
d5495 3
a5497 2
  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  addlo &= 0xffff;
d5499 5
a5503 1
  addend += ((insn & 0xffff) << 16) + addlo;
d5505 2
a5506 4
  if ((addlo & 0x8000) != 0)
    addend -= 0x10000;
  if ((addend & 0x8000) != 0)
    addend += 0x10000;
d5508 2
a5509 4
  /* Get a got entry representing requested hipage.  */
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);
d5511 12
a5522 3
  local_gotno = g->local_gotno;
  got_contents = sgot->contents;
  hipage = addend & 0xffff0000;
d5524 13
a5536 1
  for (i = MIPS_RESERVED_GOTNO; i < local_gotno; i++)
d5538 2
a5539 4
      address = bfd_get_32 (input_bfd, got_contents + i * 4);
      if (hipage == (address & 0xffff0000))
	break;
      if (address == (bfd_vma) 0)
d5541 2
a5542 1
	  bfd_put_32 (input_bfd, hipage, got_contents + i * 4);
d5547 3
a5549 7
  BFD_ASSERT (i < local_gotno);
#if 1
  if (i == local_gotno)
    (*_bfd_error_handler)
      ("ELF MIPS linker: more got entries are needed for hipage: %x",
       hipage);
#endif
d5551 1
a5551 3
  i = - ELF_MIPS_GP_OFFSET (output_bfd) + i * 4;
  bfd_put_32 (input_bfd, (insn & 0xffff0000) | (i & 0xffff),
	      contents + relhi->r_offset);
d5554 2
a5555 1
/* Handle MIPS ELF CALL16 reloc and global GOT16 reloc.  */
d5557 5
a5561 6
static void
mips_elf_relocate_global_got (input_bfd, rel, contents, offset)
     bfd *input_bfd;
     Elf_Internal_Rela *rel;
     bfd_byte *contents;
     bfd_vma offset;
d5563 13
a5575 1
  bfd_vma insn;
d5577 3
a5579 4
  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | (offset & 0xffff),
	      contents + rel->r_offset);
d5582 4
a5585 1
/* Relocate a MIPS ELF section.  */
d5588 2
a5589 2
mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
d5592 5
a5596 1
     bfd *input_bfd;
a5597 4
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d5599 3
a5601 4
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  asection *sgot, *sreloc, *scpt;
d5603 1
a5603 4
  bfd_vma gp;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct mips_got_info *g;
d5605 1
d5607 12
a5618 6
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  sgot = NULL;
  sreloc = NULL;
  if (dynobj == NULL || ! SGI_COMPAT (output_bfd))
    scpt = NULL;
a5619 4
    scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
  g = NULL;

  if (elf_bad_symtab (input_bfd))
d5621 21
a5641 3
      locsymcount = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
      extsymoff = 0;
    }
d5644 2
a5645 18
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  gp = _bfd_get_gp_value (output_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      bfd_vma addend;
      struct elf_link_hash_entry *h;
      asection *sec;
      Elf_Internal_Sym *sym;
      bfd_reloc_status_type r;
d5647 5
a5651 2
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_MIPS_max)
d5653 2
a5654 22
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      howto = elf_mips_howto_table + r_type;

      if (dynobj != NULL
	  && (r_type == R_MIPS_CALL16
	      || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_CALL_HI16
	      || r_type == R_MIPS_CALL_LO16
	      || r_type == R_MIPS_GOT_HI16
	      || r_type == R_MIPS_GOT_LO16))
	{
	  /* We need the .got section.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }
a5655 8

      r_symndx = ELF32_R_SYM (rel->r_info);

      /* Mix in the change in GP address for a GP relative reloc.  */
      if (r_type != R_MIPS_GPREL16
	  && r_type != R_MIPS_LITERAL
	  && r_type != R_MIPS_GPREL32)
	addend = 0;
d5658 3
a5660 1
	  if (gp == 0)
d5662 2
a5663 32
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info,
		      "GP relative relocation when GP not defined",
		      input_bfd, input_section,
		      rel->r_offset)))
		return false;
	      /* Only give the error once per link.  */
	      gp = 4;
	      _bfd_set_gp_value (output_bfd, gp);
	    }

	  if (r_symndx < extsymoff
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] != NULL))
	    {
	      /* This is a relocation against a section.  The current
		 addend in the instruction is the difference between
		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We
		 must change this to be the difference between the
		 final definition (which will end up in RELOCATION)
		 and the GP value of OUTPUT_BFD (which is in GP).  */
	      addend = elf_gp (input_bfd) - gp;
	    }
	  else if (! info->relocateable)
	    {
	      /* We are doing a final link.  The current addend in the
		 instruction is simply the desired offset into the
		 symbol (normally zero).  We want the instruction to
		 hold the difference between the final definition of
		 the symbol (which will end up in RELOCATION) and the
		 GP value of OUTPUT_BFD (which is in GP).  */
	      addend = - gp;
d5667 3
a5669 4
	      /* We are generating relocateable output, and we aren't
		 going to define this symbol, so we just leave the
		 instruction alone.  */
	      addend = 0;
a5670 1
	}
d5672 246
a5917 4
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (info->relocateable)
d5919 5
a5923 8
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx >= locsymcount
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] == NULL))
	    r = bfd_reloc_ok;
d5925 72
d5998 2
a5999 4
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
		r = bfd_reloc_ok;
	      else
d6001 2
a6002 49
		  sec = local_sections[r_symndx];

		  /* It would be logical to add sym->st_value here,
		     but Irix 5 sometimes generates a garbage symbol
		     value.  */
		  addend += sec->output_offset;

		  /* If this is HI16 or GOT16 with an associated LO16,
		     adjust the addend accordingly.  Otherwise, just
		     relocate.  */
		  if (r_type == R_MIPS_64 && bfd_big_endian (input_bfd))
		    r = _bfd_relocate_contents (howto, input_bfd,
						addend,
						contents + rel->r_offset + 4);
		  else if (r_type != R_MIPS_HI16 && r_type != R_MIPS_GOT16)
		    r = _bfd_relocate_contents (howto, input_bfd,
						addend,
						contents + rel->r_offset);
		  else
		    {
		      Elf_Internal_Rela *lorel;

		      /* As a GNU extension, permit an arbitrary
			 number of R_MIPS_HI16 relocs before the
			 R_MIPS_LO16 reloc.  This permits gcc to emit
			 the HI and LO relocs itself.  */
		      if (r_type == R_MIPS_GOT16)
			lorel = rel + 1;
		      else
			{
			  for (lorel = rel + 1;
			       (lorel < relend
				&& (ELF32_R_TYPE (lorel->r_info)
				    == R_MIPS_HI16));
			       lorel++)
			    ;
			}
		      if (lorel < relend
			  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
			{
			  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
						  contents, addend);
			  r = bfd_reloc_ok;
			}
		      else
			r = _bfd_relocate_contents (howto, input_bfd,
						    addend,
						    contents + rel->r_offset);
		    }
d6005 2
d6008 37
d6047 22
a6068 2
	  bfd_vma relocation;
	  boolean local;
d6070 41
a6110 18
	  /* This is a final link.  */
	  sym = NULL;
	  if (r_symndx < extsymoff
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] != NULL))
	    {
	      local = true;
	      sym = local_syms + r_symndx;
	      sec = local_sections[r_symndx];
	      relocation = (sec->output_section->vma
			    + sec->output_offset);

	      /* It would be logical to always add sym->st_value here,
		 but Irix 5 sometimes generates a garbage symbol
		 value.  */
	      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
		relocation += sym->st_value;
	    }
d6112 473
a6584 2
	    {
	      long indx;
d6586 31
a6616 7
	      local = false;
	      indx = r_symndx - extsymoff;
	      h = elf_sym_hashes (input_bfd)[indx];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (strcmp (h->root.root.string, "_gp_disp") == 0)
d6618 14
a6631 33
		  if (gp == 0)
		    {
		      if (! ((*info->callbacks->reloc_dangerous)
			     (info,
			      "_gp_disp used when GP not defined",
			      input_bfd, input_section,
			      rel->r_offset)))
			return false;
		      /* Only give the error once per link.  */
		      gp = 4;
		      _bfd_set_gp_value (output_bfd, gp);
		      relocation = 0;
		    }
		  else
		    {
		      sec = input_section;
		      if (sec->output_section != NULL)
			relocation = (gp
				      - (rel->r_offset
					 + sec->output_section->vma
					 + sec->output_offset));
		      else
			relocation = gp - rel->r_offset;
		      if (r_type == R_MIPS_LO16)
			relocation += 4;
		    }
		}
	      else if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  if (sec->output_section == NULL)
		    relocation = 0;
d6633 4
a6636 26
		    relocation = (h->root.u.def.value
				  + sec->output_section->vma
				  + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
	      else if (info->shared && ! info->symbolic)
		relocation = 0;
	      else if (strcmp (h->root.root.string, "_DYNAMIC_LINK") == 0)
		{
		  /* If this is a dynamic link, we should have created
                     a _DYNAMIC_LINK symbol in
                     mips_elf_create_dynamic_sections.  Otherwise, we
                     should define the symbol with a value of 0.
                     FIXME: It should probably get into the symbol
                     table somehow as well.  */
		  BFD_ASSERT (! info->shared);
		  BFD_ASSERT (bfd_get_section_by_name (output_bfd,
						       ".dynamic") == NULL);
		  relocation = 0;
		}
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd,
			  input_section, rel->r_offset)))
a6637 3
		  relocation = 0;
		}
	    }
d6639 9
a6647 3
	  if (r_type == R_MIPS_HI16)
	    {
	      Elf_Internal_Rela *lorel;
d6649 2
a6650 14
	      /* As a GNU extension, permit an arbitrary number of
		 R_MIPS_HI16 relocs before the R_MIPS_LO16 reloc.
		 This permits gcc to emit the HI and LO relocs itself.  */
	      for (lorel = rel + 1;
		   (lorel < relend
		    && ELF32_R_TYPE (lorel->r_info) == R_MIPS_HI16);
		   lorel++)
		;
	      if (lorel < relend
		  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
		{
		  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
					  contents, relocation + addend);
		  r = bfd_reloc_ok;
d6652 1
a6652 17
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else if (r_type == R_MIPS_GOT16 && local)
	    {
	      /* GOT16 must also have an associated LO16 in the local
		 case.  In this case, the addend is extracted and the
		 section in which the referenced object is determined.
		 Then the final address of the object is computed and
		 the GOT entry for the hipage (an aligned 64kb chunk)
		 is added to .got section if needed.  The offset field
		 of the GOT16-relocated instruction is replaced by the
		 index of this GOT entry for the hipage.  */
	      if ((rel + 1) < relend
		  && ELF32_R_TYPE ((rel + 1)->r_info) == R_MIPS_LO16)
d6654 6
a6659 5
		  mips_elf_relocate_got_local (output_bfd, input_bfd, sgot,
					       rel, rel + 1,
					       contents,
					       relocation + addend);
		  r = bfd_reloc_ok;
a6660 2
	      else
		r = bfd_reloc_outofrange;
d6662 75
a6736 60
	  else if (r_type == R_MIPS_CALL16
		   || r_type == R_MIPS_GOT16
		   || r_type == R_MIPS_CALL_LO16
		   || r_type == R_MIPS_GOT_LO16)
	    {
	      bfd_vma offset;

	      /* This symbol must be registered as a global symbol
		 having the corresponding got entry.  */
	      BFD_ASSERT (h->got_offset != (bfd_vma) -1);

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_global_got (input_bfd, rel, contents,
					    offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_CALL_HI16
		   || r_type == R_MIPS_GOT_HI16)
	    {
	      bfd_vma offset;

	      /* This must be a global symbol with a got entry.  The
                 next reloc must be the corresponding LO16 reloc.  */
	      BFD_ASSERT (h != NULL && h->got_offset != (bfd_vma) -1);
	      BFD_ASSERT ((rel + 1) < relend);
	      BFD_ASSERT (ELF32_R_TYPE ((rel + 1)->r_info)
			  == (r_type == R_MIPS_CALL_HI16
			      ? R_MIPS_CALL_LO16
			      : R_MIPS_GOT_LO16));

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_hi16 (input_bfd, rel, rel + 1, contents,
				      offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_REL32
		   || r_type == R_MIPS_32)
	    {
	      Elf_Internal_Rel outrel;
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;

	      if ((info->shared
		   || (elf_hash_table (info)->dynamic_sections_created
		       && h != NULL
		       && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
			   != 0)))
		  && (input_section->flags & SEC_ALLOC) != 0)
d6738 12
a6749 4
		  /* When generating a shared object, these
		     relocations are copied into the output file to be
		     resolved at run time.  */
		  if (sreloc == NULL)
d6751 4
a6754 2
		      sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
		      BFD_ASSERT (sreloc != NULL);
d6756 1
a6756 11

		  outrel.r_offset = (rel->r_offset
				     + input_section->output_section->vma
				     + input_section->output_offset);

		  addend = bfd_get_32 (input_bfd, contents + rel->r_offset);

		  if (h != NULL
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d6758 2
a6759 3
		      BFD_ASSERT (h->dynindx != -1);
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_REL32);
		      sec = input_section;
d6761 6
a6766 3
		  else
		    {
		      long indx;
d6768 5
a6772 19
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;
d6774 3
a6776 5
			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    abort ();
			}
d6778 10
a6787 3
		      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);
		      addend += relocation;
		    }
d6789 17
a6805 6
		  bfd_put_32 (output_bfd, addend, contents + rel->r_offset);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
					     (((Elf32_External_Rel *)
					       sreloc->contents)
					      + sreloc->reloc_count));
		  ++sreloc->reloc_count;
d6807 6
a6812 4
		  if (SGI_COMPAT (output_bfd))
		    {
		      if (scpt == NULL)
			continue;
d6814 3
a6816 19
		      /* Make an entry of compact relocation info.  */
		      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
		      cptrel.vaddr = (rel->r_offset
				      + input_section->output_section->vma
				      + input_section->output_offset);
		      if (r_type == R_MIPS_REL32)
			mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
		      else
			mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
		      mips_elf_set_cr_dist2to (cptrel, 0);
		      cptrel.konst = addend;

		      cr = (scpt->contents
			    + sizeof (Elf32_External_compact_rel));
		      bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
						 ((Elf32_External_crinfo *) cr
						  + scpt->reloc_count));
		      ++scpt->reloc_count;
		    }
d6818 12
a6829 30
		  /* This reloc will be computed at runtime, so
		     there's no need to do anything now.  */
		  continue;
		}
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else if (r_type == R_MIPS_64)
	    {
	      bfd_size_type addr;
	      unsigned long val;

	      /* Do a 32 bit relocation, and sign extend to 64 bits.  */
	      addr = rel->r_offset;
	      if (bfd_big_endian (input_bfd))
		addr += 4;
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, addr, relocation,
					    addend);
	      val = bfd_get_32 (input_bfd, contents + addr);
	      if ((val & 0x80000000) != 0)
		val = 0xffffffff;
	      else
		val = 0;
	      addr = rel->r_offset;
	      if (bfd_little_endian (input_bfd))
		addr += 4;
	      bfd_put_32 (input_bfd, val, contents + addr);
d6831 1
a6831 17
	  else
	    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					  contents, rel->r_offset,
					  relocation, addend);

	  if (SGI_COMPAT (abfd)
	      && scpt != NULL
	      && (input_section->flags & SEC_ALLOC) != 0)
	    {
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;

	      /* Make an entry of compact relocation info.  */
	      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	      cptrel.vaddr = (rel->r_offset
			      + input_section->output_section->vma
			      + input_section->output_offset);
d6833 2
a6834 13
	      switch (r_type)
		{
		case R_MIPS_26:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_JMPAD);
		  /* XXX How should we set dist2to in this case. */
		  mips_elf_set_cr_dist2to (cptrel, 8);
		  cptrel.konst = addend + relocation;
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;
d6836 4
a6839 12
		case R_MIPS_GPREL16:
		case R_MIPS_LITERAL:
		case R_MIPS_GPREL32:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_GPHI_LO);
		  cptrel.konst = gp - cptrel.vaddr;
		  mips_elf_set_cr_dist2to (cptrel, 4);
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;
d6841 6
a6846 4
		default:
		  break;
		}
	    }
d6849 30
a6878 3
      if (r != bfd_reloc_ok)
	{
	  switch (r)
d6880 2
a6881 25
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
d6883 5
d6889 6
d6899 27
d6932 4
a6935 1
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
d6939 2
a6940 2
static boolean
mips_elf_create_dynamic_sections (abfd, info)
d6950 1
a6950 1
	   | SEC_READONLY);
d6964 7
d6972 2
a6973 1
  if (bfd_get_section_by_name (abfd, ".stub") == NULL)
d6975 1
a6975 1
      s = bfd_make_section (abfd, ".stub");
d6977 3
a6979 2
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s, 2))
d6983 1
a6983 1
  if (SGI_COMPAT (abfd)
d6990 2
a6991 1
	  || ! bfd_set_section_alignment (abfd, s, 2))
d6995 5
a6999 1
  if (SGI_COMPAT (abfd))
d7049 1
a7049 1
      h->elf_link_hash_flags ^=~ ELF_LINK_NON_ELF;
d7089 1
a7089 1
     struct bfd_link_info *info;
d7096 2
a7097 1
      flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY;
d7102 2
a7103 1
	  || ! bfd_set_section_alignment (abfd, s, 2))
d7111 1
a7111 1
  
d7125 1
a7125 1
  if (bfd_get_section_by_name (abfd, ".got") != NULL)
d7128 2
a7129 1
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d7156 1
a7156 1
  s->_raw_size = MIPS_RESERVED_GOTNO * 4;
d7162 1
a7162 1
  g->global_gotsym = 0;
d7164 1
d7173 2
d7179 49
d7231 2
a7232 2
static boolean
mips_elf_check_relocs (abfd, info, sec, relocs)
d7238 1
d7248 1
d7258 158
d7423 1
a7423 1
      sgot = bfd_get_section_by_name (dynobj, ".got");
d7435 3
a7437 3

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
d7440 1
d7444 1
d7449 10
a7458 1
	h = sym_hashes[r_symndx - extsymoff];
d7463 1
a7463 1
	  switch (ELF32_R_TYPE (rel->r_info))
d7471 3
d7478 1
a7478 5
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
d7483 1
d7495 21
a7515 1
      switch (ELF32_R_TYPE (rel->r_info))
d7518 10
d7530 1
a7530 6
	  /* This symbol requires a global offset table entry.  */

	  BFD_ASSERT (h != NULL);

	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
d7532 2
a7533 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
a7534 1
	    }
d7536 5
a7540 4
	  if (h->got_offset != (bfd_vma) -1)
	    {
	      /* We have already allocated space in the .got.  */
	      break;
a7541 15

	  /* Note the index of the first global got symbol in .dynsym.  */
	  if (g->global_gotsym == 0
	      || g->global_gotsym > (unsigned long) h->dynindx)
	    g->global_gotsym = h->dynindx;

	  /* Make this symbol to have the corresponding got entry.  */
	  h->got_offset = 0;

	  /* We need a stub, not a plt entry for the undefined
	     function.  But we record it as if it needs plt.  See
	     elf_adjust_dynamic_symbol in elflink.h.  */
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->type = STT_FUNC;

d7547 1
d7549 2
a7550 25

	  if (h != NULL)
	    {
	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return false;
		}

	      if (h->got_offset != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      /* Note the index of the first global got symbol in
                 .dynsym.  */
	      if (g->global_gotsym == 0
		  || g->global_gotsym > (unsigned long) h->dynindx)
		g->global_gotsym = h->dynindx;

	      /* Make this symbol to be the global got symbol.  */
	      h->got_offset = 0;
	    }

d7555 1
d7561 1
a7561 1
		  const char *name = ".rel.dyn";
d7573 1
d7581 5
a7585 13
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section */
		  if (sreloc->_raw_size == 0)
		    {
		      /* Add a null element. */
		      sreloc->_raw_size += sizeof (Elf32_External_Rel);
		      ++sreloc->reloc_count;
		    }
		  sreloc->_raw_size += sizeof (Elf32_External_Rel);
		}
d7593 1
a7593 1
		  ++hmips->mips_32_relocs;
d7595 8
d7605 1
a7605 1
	  if (SGI_COMPAT (abfd))
a7607 1

d7614 1
a7614 1
	  if (SGI_COMPAT (abfd))
d7619 14
d7636 68
d7706 44
d7753 1
d7760 2
a7761 2
static boolean
mips_elf_adjust_dynamic_symbol (info, h)
d7787 1
a7787 1
      && hmips->mips_32_relocs != 0
d7789 2
a7790 12
    {
      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
      BFD_ASSERT (s != NULL);

      if (s->_raw_size == 0)
	{
	  /* Make room for a null element. */
	  s->_raw_size += sizeof (Elf32_External_Rel);
	  ++s->reloc_count;
	}
      s->_raw_size += hmips->mips_32_relocs * sizeof (Elf32_External_Rel);
    }
d7806 2
a7807 1
	  s = bfd_get_section_by_name (dynobj, ".stub");
d7814 1
a7814 1
	  h->plt_offset = s->_raw_size;
d7843 81
d7926 2
a7927 2
static boolean
mips_elf_size_dynamic_sections (output_bfd, info)
d7934 1
a7934 2
  asection *sgot;
  struct mips_got_info *g;
d7946 4
a7949 2
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
a7952 32
  /* Recompute the size of .got for local entires (reserved and
     hipages) if needed.  To estimate it, get the upper bound of total
     size of loadable sections.  */
  sgot = bfd_get_section_by_name (dynobj, ".got");

  if (sgot != NULL)
    {
      bfd_size_type loadable_size = 0;
      bfd_size_type local_gotno;
      struct _bfd *sub;

      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);

      for (sub = info->input_bfds; sub; sub = sub->link_next)
	for (s = sub->sections; s != NULL; s = s->next)
	  {
	    if ((s->flags & SEC_ALLOC) == 0)
	      continue;
	    loadable_size += (s->_raw_size + 0xf) & ~0xf;
	  }

      loadable_size += MIPS_FUNCTION_STUB_SIZE;

      /* Assume there are two loadable segments consisting of
	 contiguous sections.  Is 5 enough? */
      local_gotno = (loadable_size >> 16) + 5 + MIPS_RESERVED_GOTNO;
      g->local_gotno = local_gotno;
      sgot->_raw_size += local_gotno * 4;
    }

d7966 1
a7966 1
      if ((s->flags & SEC_IN_MEMORY) == 0)
d7974 12
a7985 1
	    strip = true;
d7988 1
d7997 8
a8004 3
	      target = bfd_get_section_by_name (output_bfd, name + 4);
	      if ((target != NULL && (target->flags & SEC_READONLY) != 0)
		  || strcmp (name, ".rel.dyn") == 0)
d8009 2
a8010 1
	      if (strcmp (name, ".rel.dyn") != 0)
d8017 3
d8021 1
a8021 1
	  BFD_ASSERT (elf_section_data (s) != NULL);
d8023 39
a8061 1
	  BFD_ASSERT (g != NULL);
d8063 8
a8070 5
	  /* Fix the size of .got section for the correspondence of
	     global symbols and got entries. This adds some useless
	     got entries. Is this required by ABI really?  */
	  i = elf_hash_table (info)->dynsymcount - g->global_gotsym;
	  s->_raw_size += i * 4;
d8072 1
a8072 1
      else if (strncmp (name, ".stub", 5) == 0)
d8089 5
d8102 1
a8102 9
	  asection **spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

d8107 1
a8107 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
a8112 1
      memset (s->contents, 0, s->_raw_size);
d8128 1
a8128 1
	      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_MAP, 0))
d8132 1
a8132 1
	    if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d8138 1
a8138 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d8142 1
a8142 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
d8145 2
a8146 1
      if (bfd_get_section_by_name (dynobj, ".rel.dyn"))
d8148 1
a8148 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0))
d8151 1
a8151 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0))
d8154 1
a8154 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELENT, 0))
d8158 1
a8158 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICTNO, 0))
d8161 1
a8161 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLISTNO, 0))
d8166 1
a8166 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICT, 0))
d8172 1
a8172 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLIST, 0))
d8176 1
a8176 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_VERSION, 0))
d8179 1
a8179 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_FLAGS, 0))
d8184 1
a8184 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0))
d8189 1
a8189 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0))
d8194 1
a8194 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_IVERSION, 0))
d8198 1
a8198 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_BASE_ADDRESS, 0))
d8201 1
a8201 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LOCAL_GOTNO, 0))
d8204 1
a8204 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_SYMTABNO, 0))
d8207 1
a8207 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_UNREFEXTNO, 0))
d8210 1
a8210 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_GOTSYM, 0))
d8213 2
a8214 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_HIPAGENO, 0))
d8217 5
a8221 4
#if 0 /* (SGI_COMPAT) */
      if (! bfd_get_section_by_name (dynobj, ".init"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_INIT, 0))
	  return false;
d8223 4
a8226 4
      if (! bfd_get_section_by_name (dynobj, ".fini"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_FINI, 0))
	  return false;
#endif
a8228 73
  /* If we use dynamic linking, we generate a section symbol for each
     output section.  These are local symbols, which means that they
     must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.  */
  {
    const char * const *namep;
    unsigned int c, i;
    bfd_size_type strindex;
    struct bfd_strtab_hash *dynstr;
    struct mips_got_info *g;

    c = 0;
    if (elf_hash_table (info)->dynamic_sections_created)
      {
	if (SGI_COMPAT (output_bfd))
	  {
	    c = SIZEOF_MIPS_DYNSYM_SECNAMES - 1;
	    elf_link_hash_traverse (elf_hash_table (info),
				    mips_elf_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    dynstr = elf_hash_table (info)->dynstr;
	    BFD_ASSERT (dynstr != NULL);

	    for (i = 1, namep = mips_elf_dynsym_sec_names;
		 *namep != NULL;
		 i++, namep++)
	      {
		s = bfd_get_section_by_name (output_bfd, *namep);
		if (s != NULL)
		  elf_section_data (s)->dynindx = i;

		strindex = _bfd_stringtab_add (dynstr, *namep, true, false);
		if (strindex == (bfd_size_type) -1)
		  return false;

		mips_elf_hash_table (info)->dynsym_sec_strindex[i] = strindex;
	      }
	  }
	else
	  {
	    c = bfd_count_sections (output_bfd);
	    elf_link_hash_traverse (elf_hash_table (info),
				    mips_elf_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    for (i = 1, s = output_bfd->sections; s != NULL; s = s->next, i++)
	      {
		elf_section_data (s)->dynindx = i;
		/* These symbols will have no names, so we don't need to
		   fiddle with dynstr_index.  */
	      }
	  }
      }

    if (sgot != NULL)
      {
	BFD_ASSERT (elf_section_data (sgot) != NULL);
	g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	BFD_ASSERT (g != NULL);

	/* If there are no global got symbols, fake the last symbol so
	   for safety.  */
	if (g->global_gotsym)
	  g->global_gotsym += c;
	else
	  g->global_gotsym = elf_hash_table (info)->dynsymcount - 1;
      }
  }

d8232 2
a8233 2
/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */
d8235 5
a8239 4
static boolean
mips_elf_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
d8241 21
a8261 1
  unsigned int *cp = (unsigned int *) cparg;
d8263 18
a8280 3
  if (h->dynindx != -1)
    h->dynindx += *cp;
  return true;
d8286 2
a8287 2
static boolean
mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
d8296 1
d8299 1
d8303 1
d8305 1
a8305 1
  if (h->plt_offset != (bfd_vma) -1)
d8315 2
a8316 1
      s = bfd_get_section_by_name (dynobj, ".stub");
d8334 2
a8335 2
      BFD_ASSERT (h->plt_offset <= s->_raw_size);
      memcpy (s->contents + h->plt_offset, stub, MIPS_FUNCTION_STUB_SIZE);
d8337 1
a8337 1
      /* Mark the symbol as undefined.  plt_offset != -1 occurs
d8344 1
a8344 1
      gval = s->output_section->vma + s->output_offset + h->plt_offset;
d8350 1
a8350 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d8356 4
a8359 1
  if ((unsigned long) h->dynindx >= g->global_gotsym)
d8361 2
a8362 1
      bfd_size_type offset;
d8364 28
a8391 9
      /* This symbol has an entry in the global offset table.  Set its
	 value to the corresponding got entry, if needed.  */
      if (h->got_offset == (bfd_vma) -1)
	{
	  offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	  BFD_ASSERT (g->local_gotno * 4 <= offset
		      && offset < sgot->_raw_size);
	  bfd_put_32 (output_bfd, gval, sgot->contents + offset);
	}
d8428 1
a8428 1
      else if (sym->st_shndx != SHN_UNDEF)
d8437 4
d8457 4
a8460 2
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
d8465 5
d8475 2
a8476 2
static boolean
mips_elf_finish_dynamic_sections (output_bfd, info)
d8489 1
a8489 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d8501 1
a8501 1
      Elf32_External_Dyn *dyncon, *dynconend;
d8506 3
a8508 3
      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
d8514 1
d8516 5
a8520 1
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
a8523 3
	    default:
	      break;

d8525 3
a8527 1
	      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
d8529 1
a8529 2
	      dyn.d_un.d_val = sizeof (Elf32_External_Rel);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8535 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8549 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8553 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8557 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8578 2

	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8582 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8584 1
a8584 1
	      
d8587 1
d8592 1
a8598 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8602 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8605 17
d8624 1
a8624 1
	      elemsize = sizeof (Elf32_External_Sym);
a8631 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8634 2
a8635 4
	    case DT_MIPS_UNREFEXTNO:
	      /* XXX FIXME: */
	      dyn.d_un.d_val = SIZEOF_MIPS_DYNSYM_SECNAMES;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8638 2
a8639 3
	    case DT_MIPS_GOTSYM:
	      dyn.d_un.d_val = g->global_gotsym;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8642 4
a8645 3
	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8648 4
a8651 3
	    case DT_MIPS_RLD_MAP:
	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8654 3
d8658 4
d8670 3
a8672 2
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0x80000000, sgot->contents + 4);
d8676 2
a8677 1
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d8680 1
a8680 1
    asection *sdynsym;
a8681 6
    unsigned int i;
    bfd_vma last;
    Elf_Internal_Sym sym;
    long dindx;
    const char *name;
    const char * const * namep = mips_elf_dynsym_sec_names;
d8684 7
a8690 5
    /* Set up the section symbols for the output sections. SGI sets
       the STT_NOTYPE attribute for these symbols.  Should we do so?  */

    sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
    if (sdynsym != NULL)
d8692 1
a8692 6
	if (SGI_COMPAT (output_bfd))
	  {
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
	    sym.st_other = 0;
d8694 2
a8695 28
	    i = 0;
	    while ((name = *namep++) != NULL)
	      {
		s = bfd_get_section_by_name (output_bfd, name);
		if (s != NULL)
		  {
		    sym.st_value = s->vma;
		    dindx = elf_section_data (s)->dynindx;
		    last = s->vma + s->_raw_size;
		  }
		else
		  {
		    sym.st_value = last;
		    dindx++;
		  }

		sym.st_shndx = (i < MIPS_TEXT_DYNSYM_SECNO
				? SHN_MIPS_TEXT
				: SHN_MIPS_DATA);
		++i;
		sym.st_name =
		  mips_elf_hash_table (info)->dynsym_sec_strindex[dindx];

		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + dindx));
	      }
d8697 1
a8697 6
	    /* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      SIZEOF_MIPS_DYNSYM_SECNAMES;
	  }
	else
d8699 1
a8699 8
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	    sym.st_other = 0;

	    for (s = output_bfd->sections; s != NULL; s = s->next)
	      {
		int indx;
d8701 4
a8704 16
		sym.st_value = s->vma;

		indx = elf_section_data (s)->this_idx;
		BFD_ASSERT (indx > 0);
		sym.st_shndx = indx;

		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));
	      }

	    /* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      bfd_count_sections (output_bfd) + 1;
d8721 1
a8721 1
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt, 
d8726 2
a8727 1
	    s = bfd_get_section_by_name (dynobj, ".stub");
d8741 2
a8742 1
    s = bfd_get_section_by_name (dynobj, ".rel.dyn");
d8744 1
a8744 1
      memset (s->contents, 0, sizeof (Elf32_External_Rel));
d8897 2
a8898 1
			 input_bfd, input_section, (*parent)->address)))
d8992 3
a8994 1
#define elf_info_to_howto		0
d8997 2
a8998 2
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_section_from_shdr	mips_elf32_section_from_shdr
d9002 1
a9002 1
#define elf_backend_section_processing	mips_elf32_section_processing
d9005 2
a9006 2
					mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	mips_elf_modify_segment_map
d9010 22
d9033 2
a9034 1
#define bfd_elf32_bfd_is_local_label	mips_elf_is_local_label
d9038 2
a9039 2
					mips_elf_link_hash_table_create
#define bfd_elf32_bfd_final_link	mips_elf_final_link
d9045 2
a9046 14
#define elf_backend_add_symbol_hook	mips_elf_add_symbol_hook
#define elf_backend_create_dynamic_sections \
					mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					mips_elf_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
					mips_elf_size_dynamic_sections
#define elf_backend_relocate_section	mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
					mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					mips_elf_finish_dynamic_sections

@


1.7
log
@On popular demand: annoying kernel link messages fixed :-)
@
text
@d44 2
d61 1
d543 17
a559 2
  /* A 64 bit relocation.  Presumably not used in 32 bit ELF.  */
  { R_MIPS_64 },
d1246 47
d1306 1
d1717 2
a1718 4
  /* This function is selected based on the input vector.  We only
     want to copy information over if the output BFD also uses Elf
     format.  */
  if (bfd_get_flavour (obfd) != bfd_target_elf_flavour)
d1731 20
d1776 2
a1777 4
  /* This function is selected based on the input vector.  We only
     want to copy information over if the output BFD also uses Elf
     format.  */
  if (bfd_get_flavour (obfd) != bfd_target_elf_flavour)
d1801 1
d1810 1
d1816 20
d4413 5
a4417 1
		  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_GOT16)
d4760 22
@


1.6
log
@Resolved import conflict
@
text
@d1733 2
a1734 1
      if (new_flags != old_flags)
d1739 10
@


1.5
log
@Merge the Cygnus 960904 sources
@
text
@d4539 2
a4540 2
		       && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
			   == 0)))
@


1.4
log
@A couple of more fixes. -static *IS* static...
@
text
@a1240 1
  { BFD_RELOC_32_PCREL, R_MIPS_REL32 },
d1488 1
a1488 1
      /* Just use the default, which was set in elfcode.h.  */
d1534 2
d1568 1
a1568 1
      if ((*hdrpp)->sh_type == SHT_MIPS_GPTAB)
d1570 5
a1574 2
	  const char *name;
	  asection *sec;
d1576 1
d1584 41
d1706 3
d1795 8
d1812 4
d1817 3
a1819 1
      if (strncmp (name, ".MIPS.events.", sizeof ".MIPS.events." - 1) != 0)
d1932 1
a1932 1
      /* FIXME: Set the sh_link field.  */
d1989 10
d2004 1
d2008 14
a2021 2
  else if (strncmp (name, ".MIPS.events.", sizeof ".MIPS.events." - 1) == 0)
    hdr->sh_type = SHT_MIPS_EVENTS;
d2787 5
d2879 2
d2975 25
d4537 2
a4538 1
		   || (h != NULL && !info->static_link
d4773 11
d4840 24
d4986 18
a5003 1
  sgot = NULL;
d5020 1
a5020 1
      if (dynobj == NULL)
d5030 2
a5031 1
	      elf_hash_table (info)->dynobj = dynobj = abfd;
d5034 13
a5059 8
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }
a5095 8
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }
a5127 4
	      /* When creating a shared object, we must copy these
                 reloc types into the output file as R_MIPS_REL32
		 relocs.  We create the .rel.dyn reloc section in
		 dynobj and make room for this reloc.  */
d5143 2
a5144 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 4))
d5146 10
a5155 1

d5160 1
a5161 3

	      if (info->shared)
		sreloc->_raw_size += sizeof (Elf32_External_Rel);
d5235 6
d5417 8
d5467 10
a5476 2
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
d5627 13
a5639 12
    s = bfd_get_section_by_name (dynobj, ".got");
    BFD_ASSERT (s != NULL);
    BFD_ASSERT (elf_section_data (s) != NULL);
    g = (struct mips_got_info *) elf_section_data (s)->tdata;
    BFD_ASSERT (g != NULL);

    /* If there are no global got symbols, fake the last symbol so for
       safety.  */
    if (g->global_gotsym)
      g->global_gotsym += c;
    else
      g->global_gotsym = elf_hash_table (info)->dynsymcount - 1;
d5787 22
d5829 8
a5836 5
  BFD_ASSERT (sgot != NULL);

  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);
d5843 1
d5977 5
d5989 1
a5989 1
  if (sgot->_raw_size > 0)
d5995 2
a5996 1
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d6119 1
a6119 1
    if (s != NULL)
d6360 5
a6364 1
#define ELF_MAXPAGESIZE			0x10000
@


1.3
log
@Fixes to make MIPS arc port to use in tree binutils.
@
text
@d4419 1
a4419 1
		   && (h != NULL
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d4419 1
a4419 1
		   || (h != NULL
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995 Free Software Foundation, Inc.
d23 4
a43 28
static bfd_reloc_status_type mips_elf_hi16_reloc PARAMS ((bfd *abfd,
							  arelent *reloc,
							  asymbol *symbol,
							  PTR data,
							  asection *section,
							  bfd *output_bfd,
							  char **error));
static bfd_reloc_status_type mips_elf_got16_reloc PARAMS ((bfd *abfd,
							   arelent *reloc,
							   asymbol *symbol,
							   PTR data,
							   asection *section,
							   bfd *output_bfd,
							   char **error));
static bfd_reloc_status_type mips_elf_lo16_reloc PARAMS ((bfd *abfd,
							  arelent *reloc,
							  asymbol *symbol,
							  PTR data,
							  asection *section,
							  bfd *output_bfd,
							  char **error));
static bfd_reloc_status_type mips_elf_gprel16_reloc PARAMS ((bfd *abfd,
							     arelent *reloc,
							     asymbol *symbol,
							     PTR data,
							     asection *section,
							     bfd *output_bfd,
							     char **error));
d48 4
d53 7
a59 4
static boolean mips_elf_object_p PARAMS ((bfd *));
static void mips_elf_final_write_processing
  PARAMS ((bfd *, boolean));
static boolean mips_elf_section_from_shdr
d61 1
a61 5
static boolean mips_elf_fake_sections
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));
static boolean mips_elf_section_from_bfd_section
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *, int *));
static boolean mips_elf_section_processing
a62 3
static void mips_elf_symbol_processing PARAMS ((bfd *, asymbol *));
static boolean mips_elf_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
a64 3
static boolean mips_elf_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d75 7
d85 18
d106 168
d389 1
a389 1
	 mips_elf_hi16_reloc,	/* special_function */
d404 1
a404 1
	 mips_elf_lo16_reloc,	/* special_function */
d419 1
a419 1
	 mips_elf_gprel16_reloc, /* special_function */
d434 1
a434 1
	 mips_elf_gprel16_reloc, /* special_function */
a441 1
  /* FIXME: This is not handled correctly.  */
d449 1
a449 1
	 mips_elf_got16_reloc,	/* special_function */
a487 1
  /* FIXME: This is not handled correctly.  */
d495 1
a495 1
	 bfd_elf_generic_reloc,	/* special_function */
d673 4
a676 1
   LO16 immediately follow the HI16, so this ought to work.  */
d678 10
a687 2
static bfd_byte *mips_hi16_addr;
static bfd_vma mips_hi16_addend;
d689 2
a690 2
static bfd_reloc_status_type
mips_elf_hi16_reloc (abfd,
d707 1
d719 2
a720 2
  /* FIXME: The symbol _gp_disp requires special handling, which we do
     not do.  */
d722 3
a724 1
    abort ();
d726 15
a740 4
  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    ret = bfd_reloc_undefined;
d742 2
a743 2
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
d745 10
a754 1
    relocation = symbol->value;
d764 7
a770 2
  mips_hi16_addr = (bfd_byte *) data + reloc_entry->address;
  mips_hi16_addend = relocation;
d782 2
a783 2
static bfd_reloc_status_type
mips_elf_lo16_reloc (abfd,
d798 66
a863 31
  /* FIXME: The symbol _gp_disp requires special handling, which we do
     not do.  */
  if (output_bfd == (bfd *) NULL
      && strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    abort ();

  if (mips_hi16_addr != (bfd_byte *) NULL)
    {
      unsigned long insn;
      unsigned long val;
      unsigned long vallo;

      /* Do the HI16 relocation.  Note that we actually don't need to
	 know anything about the LO16 itself, except where to find the
	 low 16 bits of the addend needed by the LO16.  */
      insn = bfd_get_32 (abfd, mips_hi16_addr);
      vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
	       & 0xffff);
      val = ((insn & 0xffff) << 16) + vallo;
      val += mips_hi16_addend;

      /* The low order 16 bits are always treated as a signed value.
	 Therefore, a negative value in the low order bits requires an
	 adjustment in the high order bits.  We need to make this
	 adjustment in two ways: once for the bits we took from the
	 data, and once for the bits we are putting back in to the
	 data.  */
      if ((vallo & 0x8000) != 0)
	val -= 0x10000;
      if ((val & 0x8000) != 0)
	val += 0x10000;
d865 2
a866 2
      insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
      bfd_put_32 (abfd, insn, mips_hi16_addr);
d868 3
a870 1
      mips_hi16_addr = (bfd_byte *) NULL;
d892 2
a893 2
static bfd_reloc_status_type
mips_elf_got16_reloc (abfd,
d922 2
a923 2
    return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
d928 5
a932 9
/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
   R_MIPS_LITERAL relocations, although those can be handled more
   cleverly because the entries in the .lit8 and .lit4 sections can be
   merged.  */

static bfd_reloc_status_type gprel16_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));
d935 2
a936 9
mips_elf_gprel16_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
     bfd *abfd;
     arelent *reloc_entry;
d938 1
a938 3
     PTR data;
     asection *input_section;
     bfd *output_bfd;
d940 1
d942 2
a943 17
  boolean relocateable;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocateable = true;
  else
d945 2
a946 2
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
d949 3
a951 15
  if (bfd_is_und_section (symbol->section)
      && relocateable == false)
    return bfd_reloc_undefined;

  /* Some of the code below assumes the output bfd is ELF too.  */
  if (output_bfd->xvec->flavour != bfd_target_elf_flavour)
    abort ();

  /* We have to figure out the gp value, so that we can adjust the
     symbol value correctly.  We look up the symbol _gp in the output
     BFD.  If we can't find it, we're stuck.  We cache it in the ELF
     target data.  We don't need to adjust the symbol value for an
     external symbol if we are producing relocateable output.  */
  if (elf_gp (output_bfd) == 0
      && (relocateable == false
d954 1
a954 1
      if (relocateable != false)
d957 2
a958 2
	  elf_gp (output_bfd) =
	    symbol->section->output_section->vma + 0x4000;
d980 2
a981 1
		      elf_gp (output_bfd) = bfd_asymbol_value (*sym);
d990 2
a991 1
	      elf_gp (output_bfd) = 4;
d999 53
d1053 1
a1053 1
			  relocateable, data, elf_gp (output_bfd));
d1085 11
a1095 3
  val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
  if (val & 0x8000)
    val -= 0x10000;
d1100 1
a1100 1
  if (relocateable == false
d1107 1
a1107 1
  if (relocateable != false)
d1117 2
a1118 1
/* A mapping from BFD reloc types to MIPS ELF reloc types.  */
d1120 3
a1122 4
struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_reloc_val;
  enum reloc_type elf_reloc_val;
};
d1124 8
a1131 22
static CONST struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE, },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  { BFD_RELOC_CTOR, R_MIPS_32 },
  { BFD_RELOC_32_PCREL, R_MIPS_REL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 }
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
d1133 6
a1138 1
     bfd_reloc_code_real_type code;
d1140 3
a1142 1
  unsigned int i;
d1144 7
a1150 1
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
d1152 3
a1154 2
      if (mips_reloc_map[i].bfd_reloc_val == code)
	return &elf_mips_howto_table[(int) mips_reloc_map[i].elf_reloc_val];
a1155 2
  return NULL;
}
d1157 9
a1165 1
/* Given a MIPS reloc type, fill in an arelent structure.  */
d1167 5
a1171 7
static void
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rel *dst;
{
  unsigned int r_type;
d1173 114
a1286 3
  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
  cache_ptr->howto = &elf_mips_howto_table[r_type];
d1336 43
d1403 59
d1478 2
a1479 1
/* Set the right machine number for a MIPS ELF file.  */
d1481 2
a1482 2
static boolean
mips_elf_object_p (abfd)
d1499 4
d1505 9
d1519 1
a1519 1
  return true;
d1524 1
a1524 1
   number.  */
d1527 2
a1528 2
static void
mips_elf_final_write_processing (abfd, linker)
d1550 4
d1555 2
a1556 1
      return;
d1583 114
d1699 2
d1704 2
a1705 2
static boolean
mips_elf_section_from_shdr (abfd, hdr, name)
d1707 2
a1708 2
     Elf32_Internal_Shdr *hdr;
     char *name;
a1709 2
  asection *newsect;

d1747 2
a1748 1
      if (strcmp (name, ".options") != 0)
a1764 1
  newsect = hdr->bfd_section;
d1768 3
a1770 2
      if (! bfd_set_section_flags (abfd, newsect,
				   (bfd_get_section_flags (abfd, newsect)
d1775 14
d1793 2
a1794 1
     processing relocs, so we just get it now.  */
d1800 1
a1800 1
      if (! bfd_get_section_contents (abfd, newsect, (PTR) &ext,
d1807 41
d1852 2
a1853 1
   section name, which is a hack, but ought to work.  */
d1855 2
a1856 2
static boolean
mips_elf_fake_sections (abfd, hdr, sec)
d1883 1
a1883 1
      /* The sh_info field is set in mips_elf_final_write_processing.  */
d1890 6
a1895 1
      hdr->sh_entsize = 1;
d1900 6
a1905 1
      hdr->sh_entsize = 1;
d1912 16
a1927 1
  else if (strcmp (name, ".options") == 0)
d1941 4
a1944 1
   index.  */
d1946 2
a1947 2
static boolean
mips_elf_section_from_bfd_section (abfd, hdr, sec, retval)
d1966 3
a1968 4
/* Work over a section just before writing it out.  We update the GP
   value in the .reginfo section based on the value we are using.
   FIXME: We recognize sections that need the SHF_MIPS_GPREL flag by
   name; there has to be a better way.  */
d1970 2
a1971 2
static boolean
mips_elf_section_processing (abfd, hdr)
d1973 4
a1976 1
     Elf32_Internal_Shdr *hdr;
d1978 2
a1979 1
  if (hdr->sh_type == SHT_MIPS_REGINFO)
d1981 13
a1993 1
      bfd_byte buf[4];
d1995 9
a2003 2
      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
      BFD_ASSERT (hdr->contents == NULL);
d2005 1
a2005 7
      if (bfd_seek (abfd,
		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
		    SEEK_SET) == -1)
	return false;
      bfd_h_put_32 (abfd, (bfd_vma) elf_gp (abfd), buf);
      if (bfd_write (buf, (bfd_size_type) 1, (bfd_size_type) 4, abfd) != 4)
	return false;
d2008 14
d2042 16
d2062 70
d2149 14
a2162 1
/* Handle the special MIPS section numbers that a symbol may use.  */
d2164 2
a2165 2
static void
mips_elf_symbol_processing (abfd, asym)
d2223 195
d2419 49
d2473 2
a2474 2
static boolean
mips_elf_read_ecoff_info (abfd, section, debug)
d2485 1
a2485 1
  ext_hdr = (char *) malloc ((size_t) swap->external_hdr_size);
d2487 1
a2487 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d2504 1
a2504 1
      debug->ptr = (type) malloc ((size_t) (size * symhdr->count));	\
d2506 1
a2506 4
	{								\
	  bfd_set_error (bfd_error_no_memory);				\
	  goto error_return;						\
	}								\
d2580 3
a2582 3
static boolean
mips_elf_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			    functionname_ptr, line_ptr)
d2617 1
a2617 1
		bfd_alloc (abfd, sizeof (struct mips_elf_find_line)));
a2619 1
	      bfd_set_error (bfd_error_no_memory);
d2624 1
a2624 3
	  memset (fi, 0, sizeof (struct mips_elf_find_line));

	  if (! mips_elf_read_ecoff_info (abfd, msec, &fi->d))
a2636 1
	      bfd_set_error (bfd_error_no_memory);
d2685 3
d2695 6
d2744 1
a2744 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_hash_entry *) ret;
    }
d2757 1
d2770 1
d2775 1
a2775 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d2784 5
d2806 9
d2829 48
d2917 1
d2948 33
a2980 1
      if (h->root.root.type != bfd_link_hash_defined
a2984 1
	  asection *output_section;
d2987 10
a2996 2
	  output_section = h->root.root.u.def.section->output_section;
	  name = bfd_section_name (output_section->owner, output_section);
d2998 20
a3017 19
	  if (strcmp (name, ".text") == 0)
	    h->esym.asym.sc = scText;
	  else if (strcmp (name, ".data") == 0)
	    h->esym.asym.sc = scData;
	  else if (strcmp (name, ".sdata") == 0)
	    h->esym.asym.sc = scSData;
	  else if (strcmp (name, ".rodata") == 0
		   || strcmp (name, ".rdata") == 0)
	    h->esym.asym.sc = scRData;
	  else if (strcmp (name, ".bss") == 0)
	    h->esym.asym.sc = scBss;
	  else if (strcmp (name, ".sbss") == 0)
	    h->esym.asym.sc = scSBss;
	  else if (strcmp (name, ".init") == 0)
	    h->esym.asym.sc = scInit;
	  else if (strcmp (name, ".fini") == 0)
	    h->esym.asym.sc = scFini;
	  else
	    h->esym.asym.sc = scAbs;
a3028 2
      asection *sec;

d3035 7
a3041 3
      h->esym.asym.value = (h->root.root.u.def.value
			    + sec->output_offset
			    + sec->output_section->vma);
d3043 21
d3076 151
d3253 1
d3277 36
d3367 1
a3367 1
		 mips_elf_section_processing when the section is
d3426 42
a3467 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d3504 2
a3505 2
	      if (! mips_elf_read_ecoff_info (input_bfd, input_section,
					      &input_debug))
d3569 21
d3696 1
a3696 1
	  tab = (Elf32_gptab *) malloc (c * sizeof (Elf32_gptab));
d3698 1
a3698 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d3769 2
a3770 2
				  realloc ((PTR) tab,
					   (c + 1) * sizeof (Elf32_gptab)));
a3772 1
			  bfd_set_error (bfd_error_no_memory);
a3815 1
	      bfd_set_error (bfd_error_no_memory);
a3832 36
  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (info->relocateable)
	{
	  bfd_vma lo;

	  /* Make up a value.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	    {
	      if (o->vma < lo
		  && (strcmp (o->name, ".sbss") == 0
		      || strcmp (o->name, ".sdata") == 0
		      || strcmp (o->name, ".lit4") == 0
		      || strcmp (o->name, ".lit8") == 0))
		lo = o->vma;
	    }
	  elf_gp (abfd) = lo + 0x8000;
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

d3878 13
d3924 85
d4026 3
d4031 1
d4033 1
d4036 8
d4055 2
d4078 19
d4106 1
a4106 1
	  if (elf_gp (output_bfd) == 0)
d4115 2
a4116 1
	      elf_gp (output_bfd) = 4;
d4129 1
a4129 1
	      addend = elf_gp (input_bfd) - elf_gp (output_bfd);
d4139 1
a4139 1
	      addend = - elf_gp (output_bfd);
d4177 2
a4178 2
		  /* If this is HI16 with an associated LO16, adjust
		     the addend accordingly.  Otherwise, just
d4180 1
a4180 3
		  if (r_type != R_MIPS_HI16
		      || (rel + 1) >= relend
		      || ELF32_R_TYPE ((rel + 1)->r_info) != R_MIPS_LO16)
d4186 28
a4213 3
		      mips_elf_relocate_hi16 (input_bfd, rel, rel + 1,
					      contents, addend);
		      r = bfd_reloc_ok;
d4221 1
d4229 1
d4245 1
d4248 33
a4280 1
	      if (h->root.type == bfd_link_hash_defined
d4284 6
a4289 3
		  relocation = (h->root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
d4293 15
d4318 206
a4523 3
	  if (r_type != R_MIPS_HI16
	      || (rel + 1) >= relend
	      || ELF32_R_TYPE ((rel + 1)->r_info) != R_MIPS_LO16)
d4527 4
a4530 1
	  else
d4532 39
a4570 3
	      mips_elf_relocate_hi16 (input_bfd, rel, rel + 1,
				      contents, relocation + addend);
	      r = bfd_reloc_ok;
d4610 11
a4620 5
/* This is almost identical to bfd_generic_get_... except that some
   MIPS relocations need to be handled specially.  Sigh.  */
static bfd_byte *
elf32_mips_get_relocated_section_contents (abfd, link_info, link_order, data,
					   relocateable, symbols)
d4622 1
a4622 5
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
d4624 15
a4638 3
  /* Get enough memory to hold the stuff */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;
d4640 3
a4642 3
  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;
d4644 9
a4652 2
  if (reloc_size < 0)
    goto error_return;
d4654 1
a4654 2
  reloc_vector = (arelent **) malloc (reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
d4656 12
a4667 3
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d4669 3
a4671 7
  /* read in the section */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 (PTR) data,
				 0,
				 input_section->_raw_size))
    goto error_return;
d4673 3
a4675 3
  /* We're not relaxing the section, so just copy the size info */
  input_section->_cooked_size = input_section->_raw_size;
  input_section->reloc_done = true;
d4677 17
a4693 6
  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;
d4695 1251
a5945 1
  if (reloc_count > 0)
d6011 2
a6012 1
	  else if ((*parent)->howto->special_function == mips_elf_gprel16_reloc)
d6080 2
a6081 1
#define bfd_elf32_bfd_get_relocated_section_contents elf32_mips_get_relocated_section_contents
d6085 1
a6085 1
static const struct ecoff_debug_swap mips_elf_ecoff_debug_swap =
d6123 1
a6123 1
  mips_elf_read_ecoff_info
d6134 1
d6138 3
a6140 3
#define elf_backend_object_p		mips_elf_object_p
#define elf_backend_section_from_shdr	mips_elf_section_from_shdr
#define elf_backend_fake_sections	mips_elf_fake_sections
d6142 6
a6147 3
					mips_elf_section_from_bfd_section
#define elf_backend_section_processing	mips_elf_section_processing
#define elf_backend_symbol_processing	mips_elf_symbol_processing
d6149 2
a6150 2
					mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf_ecoff_debug_swap
d6153 2
a6154 2
#define bfd_elf32_find_nearest_line	mips_elf_find_nearest_line

d6158 13
d6172 4
a6175 1
#define elf_backend_add_symbol_hook	mips_elf_add_symbol_hook
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
a22 4
/* This file handles MIPS ELF targets.  SGI Irix 5 uses a slightly
   different MIPS ELF from other targets.  This matters when linking.
   This file supports both, switching at runtime.  */

d40 28
a71 4
static void bfd_mips_elf32_swap_gptab_in
  PARAMS ((bfd *, const Elf32_External_gptab *, Elf32_gptab *));
static void bfd_mips_elf32_swap_gptab_out
  PARAMS ((bfd *, const Elf32_gptab *, Elf32_External_gptab *));
d73 4
a76 7
static boolean mips_elf32_object_p PARAMS ((bfd *));
static boolean mips_elf_create_procedure_table
  PARAMS ((PTR, bfd *, struct bfd_link_info *, asection *,
	   struct ecoff_debug_info *));
static int mips_elf_additional_program_headers PARAMS ((bfd *));
static boolean mips_elf_modify_segment_map PARAMS ((bfd *));
static boolean mips_elf32_section_from_shdr
d78 5
a82 1
static boolean mips_elf32_section_processing
d84 3
d89 3
a101 7
static void mips_elf_relocate_got_local
  PARAMS ((bfd *, bfd *, asection *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static void mips_elf_relocate_global_got
   PARAMS ((bfd *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static boolean mips_elf_adjust_dynindx
  PARAMS ((struct elf_link_hash_entry *, PTR));
a104 18
static boolean mips_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_create_compact_rel_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean mips_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static boolean mips_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static boolean mips_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a107 168
static bfd_reloc_status_type mips_elf_final_gp
  PARAMS ((bfd *, asymbol *, boolean, char **, bfd_vma *));
static bfd_byte *elf32_mips_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, boolean, asymbol **));

/* This is true for Irix 5 executables, false for normal MIPS ELF ABI
   executables.  FIXME: At the moment, we default to always generating
   Irix 5 executables.  */

#define SGI_COMPAT(abfd) (1)

/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The symbol index of the first global .got symbol.  */
  unsigned long global_gotsym;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
};

/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

/* Instructions which appear in a stub.  For some reason the stub is
   slightly different on an SGI system.  */
#define ELF_MIPS_GP_OFFSET(abfd) (SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
#define STUB_LW(abfd)					\
  (SGI_COMPAT (abfd)					\
   ? 0x8f998010			/* lw t9,0x8010(gp) */	\
   : 0x8f998000)		/* lw t9,0x8000(gp) */
#define STUB_MOVE 0x03e07825	/* move t7,ra */
#define STUB_JALR 0x0320f809	/* jal t9 */
#define STUB_LI16 0x34180000	/* ori t8,zero,0 */
#define MIPS_FUNCTION_STUB_SIZE (16)

/* Names of sections which appear in the .dynsym section in an Irix 5
   executable.  */

static const char * const mips_elf_dynsym_sec_names[] =
{
  ".text",
  ".init",
  ".fini",
  ".data",
  ".rodata",
  ".sdata",
  ".sbss",
  ".bss",
  NULL
};

#define SIZEOF_MIPS_DYNSYM_SECNAMES \
  (sizeof mips_elf_dynsym_sec_names / sizeof mips_elf_dynsym_sec_names[0])

/* The number of entries in mips_elf_dynsym_sec_names which go in the
   text segment.  */

#define MIPS_TEXT_DYNSYM_SECNO (3)

/* The names of the runtime procedure table symbols used on Irix 5.  */

static const char * const mips_elf_dynsym_rtproc_names[] =
{
  "_procedure_table",
  "_procedure_string_table",
  "_procedure_table_size",
  NULL
};

/* These structures are used to generate the .compact_rel section on
   Irix 5.  */

typedef struct
{
  unsigned long id1;		/* Always one?  */
  unsigned long num;		/* Number of compact relocation entries.  */
  unsigned long id2;		/* Always two?  */
  unsigned long offset;		/* The file offset of the first relocation.  */
  unsigned long reserved0;	/* Zero?  */
  unsigned long reserved1;	/* Zero?  */
} Elf32_compact_rel;

typedef struct
{
  bfd_byte id1[4];
  bfd_byte num[4];
  bfd_byte id2[4];
  bfd_byte offset[4];
  bfd_byte reserved0[4];
  bfd_byte reserved1[4];
} Elf32_External_compact_rel;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below. */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
  unsigned long vaddr;		/* VADDR to be relocated.  */
} Elf32_crinfo;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below. */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
} Elf32_crinfo2;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
  bfd_byte vaddr[4];
} Elf32_External_crinfo;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
} Elf32_External_crinfo2;

/* These are the constants used to swap the bitfields in a crinfo.  */

#define CRINFO_CTYPE (0x1)
#define CRINFO_CTYPE_SH (31)
#define CRINFO_RTYPE (0xf)
#define CRINFO_RTYPE_SH (27)
#define CRINFO_DIST2TO (0xff)
#define CRINFO_DIST2TO_SH (19)
#define CRINFO_RELVADDR (0x7ffff)
#define CRINFO_RELVADDR_SH (0)

/* A compact relocation info has long (3 words) or short (2 words)
   formats.  A short format doesn't have VADDR field and relvaddr
   fields contains ((VADDR - vaddr of the previous entry) >> 2).  */
#define CRF_MIPS_LONG			1
#define CRF_MIPS_SHORT			0

/* There are 4 types of compact relocation at least. The value KONST
   has different meaning for each type:

   (type)		(konst)
   CT_MIPS_REL32	Address in data
   CT_MIPS_WORD		Address in word (XXX)
   CT_MIPS_GPHI_LO	GP - vaddr
   CT_MIPS_JMPAD	Address to jump
   */

#define CRT_MIPS_REL32			0xa
#define CRT_MIPS_WORD			0xb
#define CRT_MIPS_GPHI_LO		0xc
#define CRT_MIPS_JMPAD			0xd

#define mips_elf_set_cr_format(x,format)	((x).ctype = (format))
#define mips_elf_set_cr_type(x,type)		((x).rtype = (type))
#define mips_elf_set_cr_dist2to(x,v)		((x).dist2to = (v))
#define mips_elf_set_cr_relvaddr(x,d)		((x).relvaddr = (d)<<2)

static void bfd_elf32_swap_compact_rel_out
  PARAMS ((bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *));
static void bfd_elf32_swap_crinfo_out
  PARAMS ((bfd *, const Elf32_crinfo *, Elf32_External_crinfo *));
d223 1
a223 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d238 1
a238 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d253 1
a253 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d268 1
a268 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d276 1
d284 1
a284 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d323 1
d331 1
a331 1
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d509 1
a509 4
   LO16 immediately follow the HI16.  As a GNU extension, we permit an
   arbitrary number of HI16 relocs to be associated with a single LO16
   reloc.  This extension permits gcc to output the HI and LO relocs
   itself.  */
d511 2
a512 6
struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};
d514 2
a515 6
/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (abfd,
a531 1
  struct mips_hi16 *n;
d543 2
a544 2
  ret = bfd_reloc_ok;

d546 1
a546 3
    {
      boolean relocateable;
      bfd_vma gp;
d548 4
a551 2
      if (ret == bfd_reloc_undefined)
	abort ();
d553 2
a554 15
      if (output_bfd != NULL)
	relocateable = true;
      else
	{
	  relocateable = false;
	  output_bfd = symbol->section->output_section->owner;
	}

      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
    }
d556 1
a556 10
    {
      if (bfd_is_und_section (symbol->section)
	  && output_bfd == (bfd *) NULL)
	ret = bfd_reloc_undefined;

      if (bfd_is_com_section (symbol->section))
	relocation = 0;
      else
	relocation = symbol->value;
    }
d566 2
a567 7
  n = (struct mips_hi16 *) bfd_malloc (sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_hi16_list;
  mips_hi16_list = n;
d579 2
a580 2
bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (abfd,
d595 31
a625 57
  arelent gp_disp_relent;

  if (mips_hi16_list != NULL)
    {
      struct mips_hi16 *l;

      l = mips_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi16 *next;

	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff);
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* The low order 16 bits are always treated as a signed
	     value.  Therefore, a negative value in the low order bits
	     requires an adjustment in the high order bits.  We need
	     to make this adjustment in two ways: once for the bits we
	     took from the data, and once for the bits we are putting
	     back in to the data.  */
	  if ((vallo & 0x8000) != 0)
	    val -= 0x10000;
	  if ((val & 0x8000) != 0)
	    val += 0x10000;

	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, insn, l->addr);

	  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
	    {
	      gp_disp_relent = *reloc_entry;
	      reloc_entry = &gp_disp_relent;
	      reloc_entry->addend = l->addend;
	    }

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_hi16_list = NULL;
    }
  else if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_reloc_status_type ret;
      bfd_vma gp, relocation;

      /* FIXME: Does this case ever occur?  */
d627 2
a628 3
      ret = mips_elf_final_gp (output_bfd, symbol, true, error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
d630 1
a630 11
      relocation = gp - reloc_entry->address;
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
      relocation += reloc_entry->addend;

      if (reloc_entry->address > input_section->_cooked_size)
	return bfd_reloc_outofrange;

      gp_disp_relent = *reloc_entry;
      reloc_entry = &gp_disp_relent;
      reloc_entry->addend = relocation - 4;
d652 2
a653 2
bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (abfd,
d682 2
a683 2
    return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				     input_section, output_bfd, error_message);
d688 9
a696 5
/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocateable output.  */
d699 12
a710 1
mips_elf_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
a711 2
     asymbol *symbol;
     boolean relocateable;
a712 1
     bfd_vma *pgp;
d714 17
a730 2
  if (bfd_is_und_section (symbol->section)
      && ! relocateable)
d732 2
a733 2
      *pgp = 0;
      return bfd_reloc_undefined;
d736 15
a750 3
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocateable
d753 1
a753 1
      if (relocateable)
d756 2
a757 2
	  *pgp = symbol->section->output_section->vma + 0x4000;
	  _bfd_set_gp_value (output_bfd, *pgp);
d779 1
a779 2
		      *pgp = bfd_asymbol_value (*sym);
		      _bfd_set_gp_value (output_bfd, *pgp);
d788 1
a788 2
	      *pgp = 4;
	      _bfd_set_gp_value (output_bfd, *pgp);
a795 53
  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
   R_MIPS_LITERAL relocations, although those can be handled more
   cleverly because the entries in the .lit8 and .lit4 sections can be
   merged.  */

static bfd_reloc_status_type gprel16_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));

bfd_reloc_status_type
_bfd_mips_elf_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocateable = true;
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

d797 1
a797 1
			  relocateable, data, gp);
d829 3
a831 11
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case occurs with the 64-bit MIPS ELF ABI.  */
      val = reloc_entry->addend;
    }
  else
    {
      val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
      if (val & 0x8000)
	val -= 0x10000;
    }
d836 1
a836 1
  if (! relocateable
d843 1
a843 1
  if (relocateable)
d853 24
a876 2
/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset
   from the gp register? XXX */
d878 1
a878 3
static bfd_reloc_status_type gprel32_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));
d880 2
a881 8
bfd_reloc_status_type
_bfd_mips_elf_gprel32_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
d883 1
a883 6
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d885 1
a885 3
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
d887 1
a887 7
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
d889 2
a890 3
      *error_message = (char *)
	"32bits gp relative relocation occurs for an external symbol";
      return bfd_reloc_outofrange;
d892 2
d895 1
a895 9
  if (output_bfd != (bfd *) NULL)
    {
      relocateable = true;
      gp = _bfd_get_gp_value (output_bfd);
    }
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
d897 7
a903 5
      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }
d905 3
a907 3
  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocateable, data, gp);
}
d909 1
a909 112
static bfd_reloc_status_type
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     boolean relocateable;
     PTR data;
     bfd_vma gp;
{
  bfd_vma relocation;
  unsigned long val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_reloc_val;
  enum reloc_type elf_reloc_val;
};

static CONST struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE, },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  { BFD_RELOC_CTOR, R_MIPS_32 },
  { BFD_RELOC_32_PCREL, R_MIPS_REL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 }
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (mips_reloc_map[i].bfd_reloc_val == code)
	return &elf_mips_howto_table[(int) mips_reloc_map[i].elf_reloc_val];
    }
  return NULL;
}

/* Given a MIPS reloc type, fill in an arelent structure.  */

static void
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rel *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
  cache_ptr->howto = &elf_mips_howto_table[r_type];

  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
a956 43
/* In the 64 bit ABI, the .MIPS.options section holds register
   information in an Elf64_Reginfo structure.  These routines swap
   them in and out.  They are globally visible because they are used
   outside of BFD.  These routines are here so that gas can call them
   without worrying about whether the 64 bit ABI has been included.  */

void
bfd_mips_elf64_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf64_External_RegInfo *ex;
     Elf64_Internal_RegInfo *in;
{
  in->ri_gprmask = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gprmask);
  in->ri_pad = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_pad);
  in->ri_cprmask[0] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[0]);
  in->ri_cprmask[1] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[1]);
  in->ri_cprmask[2] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[2]);
  in->ri_cprmask[3] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[3]);
  in->ri_gp_value = bfd_h_get_64 (abfd, (bfd_byte *) ex->ri_gp_value);
}

void
bfd_mips_elf64_swap_reginfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf64_Internal_RegInfo *in;
     Elf64_External_RegInfo *ex;
{
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gprmask,
		(bfd_byte *) ex->ri_gprmask);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_pad,
		(bfd_byte *) ex->ri_pad);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[0],
		(bfd_byte *) ex->ri_cprmask[0]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[1],
		(bfd_byte *) ex->ri_cprmask[1]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[2],
		(bfd_byte *) ex->ri_cprmask[2]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[3],
		(bfd_byte *) ex->ri_cprmask[3]);
  bfd_h_put_64 (abfd, (bfd_vma) in->ri_gp_value,
		(bfd_byte *) ex->ri_gp_value);
}

a980 59

static void
bfd_elf32_swap_compact_rel_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_compact_rel *in;
     Elf32_External_compact_rel *ex;
{
  bfd_h_put_32 (abfd, (bfd_vma) in->id1, ex->id1);
  bfd_h_put_32 (abfd, (bfd_vma) in->num, ex->num);
  bfd_h_put_32 (abfd, (bfd_vma) in->id2, ex->id2);
  bfd_h_put_32 (abfd, (bfd_vma) in->offset, ex->offset);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved0, ex->reserved0);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved1, ex->reserved1);
}

static void
bfd_elf32_swap_crinfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_crinfo *in;
     Elf32_External_crinfo *ex;
{
  unsigned long l;

  l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
       | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
       | ((in->dist2to & CRINFO_DIST2TO) << CRINFO_DIST2TO_SH)
       | ((in->relvaddr & CRINFO_RELVADDR) << CRINFO_RELVADDR_SH));
  bfd_h_put_32 (abfd, (bfd_vma) l, ex->info);
  bfd_h_put_32 (abfd, (bfd_vma) in->konst, ex->konst);
  bfd_h_put_32 (abfd, (bfd_vma) in->vaddr, ex->vaddr);
}

/* Swap in an options header.  */

void
bfd_mips_elf_swap_options_in (abfd, ex, in)
     bfd *abfd;
     const Elf_External_Options *ex;
     Elf_Internal_Options *in;
{
  in->kind = bfd_h_get_8 (abfd, ex->kind);
  in->size = bfd_h_get_8 (abfd, ex->size);
  in->section = bfd_h_get_16 (abfd, ex->section);
  in->info = bfd_h_get_32 (abfd, ex->info);
}

/* Swap out an options header.  */

void
bfd_mips_elf_swap_options_out (abfd, in, ex)
     bfd *abfd;
     const Elf_Internal_Options *in;
     Elf_External_Options *ex;
{
  bfd_h_put_8 (abfd, in->kind, ex->kind);
  bfd_h_put_8 (abfd, in->size, ex->size);
  bfd_h_put_16 (abfd, in->section, ex->section);
  bfd_h_put_32 (abfd, in->info, ex->info);
}
d997 1
a997 2
/* Set the right machine number for a MIPS ELF file.  This is used for
   both the 32-bit and the 64-bit ABI.  */
d999 2
a1000 2
boolean
_bfd_mips_elf_object_p (abfd)
a1016 4

    case E_MIPS_ARCH_4:
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 8000);
      break;
a1018 9
  return true;
}

/* Set the right machine number for a 32-bit MIPS ELF file.  */

static boolean
mips_elf32_object_p (abfd)
     bfd *abfd;
{
d1024 1
a1024 1
  return _bfd_mips_elf_object_p (abfd);
d1029 1
a1029 1
   number.  This is used by both the 32-bit and the 64-bit ABI.  */
d1032 2
a1033 2
void
_bfd_mips_elf_final_write_processing (abfd, linker)
a1054 4
    case 8000:
      val = E_MIPS_ARCH_4;
      break;

d1056 1
a1056 2
      val = 0;
      break;
a1082 114
/* Function to keep MIPS specific file flags like as EF_MIPS_PIC. */

boolean
_bfd_mips_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

/* Copy backend specific data from one object module to another */

boolean
_bfd_mips_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  /* This function is selected based on the input vector.  We only
     want to copy information over if the output BFD also uses Elf
     format.  */
  if (bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

boolean
_bfd_mips_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;

  /* Check if we have the same endianess */
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	("%s: compiled for a %s endian system and target is %s endian",
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }

  /* This function is selected based on the input vector.  We only
     want to copy information over if the output BFD also uses Elf
     format.  */
  if (bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_NOREORDER;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))	/* First call, no flags set */
    {
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
    }
  else if (((new_flags ^ old_flags) & ~EF_MIPS_NOREORDER)
	   == 0)			/* Compatible flags are ok */
    ;
  else					/* Incompatible flags */
    {
      /* Warn about -fPIC mismatch */
      if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
	{
	  new_flags &= ~EF_MIPS_PIC;
	  (*_bfd_error_handler)
	    ("%s: needs all files compiled with -fPIC",
	     bfd_get_filename (ibfd));
	}

      if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
	{
	  new_flags &= ~EF_MIPS_CPIC;
	  (*_bfd_error_handler)
	    ("%s: needs all files compiled with -mabicalls",
	     bfd_get_filename (ibfd));
	}

      /* Warn about any other mismatches */
      if (new_flags != old_flags)
	(*_bfd_error_handler)
	  ("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)",
	   bfd_get_filename (ibfd), (unsigned long) new_flags,
	   (unsigned long) old_flags);

      bfd_set_error (bfd_error_bad_value);
      return false;
    }

  return true;
}

a1084 2
   This routine supports both the 32-bit and 64-bit ELF ABI.

d1088 2
a1089 2
boolean
_bfd_mips_elf_section_from_shdr (abfd, hdr, name)
d1091 2
a1092 2
     Elf_Internal_Shdr *hdr;
     const char *name;
d1094 2
d1133 1
a1133 2
      if (strcmp (name, ".options") != 0
	  && strcmp (name, ".MIPS.options") != 0)
d1150 1
d1154 2
a1155 3
      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
				   (bfd_get_section_flags (abfd,
							   hdr->bfd_section)
a1159 14
  return true;
}

/* Handle a 32-bit MIPS ELF specific section.  */

static boolean
mips_elf32_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  if (! _bfd_mips_elf_section_from_shdr (abfd, hdr, name))
    return false;

d1164 1
a1164 2
     processing relocs, so we just get it now.  The .reginfo section
     is not used in the 64-bit MIPS ELF ABI.  */
d1170 1
a1170 1
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, (PTR) &ext,
a1176 41
  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return false;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      (file_ptr) 0, hdr->sh_size))
	{
	  free (contents);
	  return false;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      Elf32_RegInfo intreg;

	      bfd_mips_elf32_swap_reginfo_in
		(abfd,
		 ((Elf32_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

d1181 1
a1181 2
   section name, which is a hack, but ought to work.  This routine is
   used by both the 32-bit and the 64-bit ABI.  */
d1183 2
a1184 2
boolean
_bfd_mips_elf_fake_sections (abfd, hdr, sec)
d1211 1
a1211 1
      /* The sh_info field is set in final_write_processing.  */
d1218 1
a1218 6
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
d1223 1
a1223 6
      /* In a shared object on Irix 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
      else
	hdr->sh_entsize = 1;
d1230 1
a1230 16
  else if (SGI_COMPAT (abfd)
	   && (strcmp (name, ".hash") == 0
	       || strcmp (name, ".dynamic") == 0
	       || strcmp (name, ".dynstr") == 0))
    {
      hdr->sh_entsize = 0;
      hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
    }
  else if (strcmp (name, ".got") == 0
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_MIPS_GPREL;
  else if (strcmp (name, ".options") == 0
	   || strcmp (name, ".MIPS.options") == 0)
d1244 1
a1244 4
   index.  This is used by both the 32-bit and the 64-bit ABI.
   Actually, it's not clear to me that the 64-bit ABI supports these,
   but for non-PIC objects we will certainly want support for at least
   the .scommon section.  */
d1246 2
a1247 2
boolean
_bfd_mips_elf_section_from_bfd_section (abfd, hdr, sec, retval)
d1266 4
a1269 3
/* When are writing out the .options or .MIPS.options section,
   remember the bytes we are writing out, so that we can install the
   GP value in the section_processing routine.  */
d1271 2
a1272 2
boolean
_bfd_mips_elf_set_section_contents (abfd, section, location, offset, count)
d1274 1
a1274 4
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d1276 1
a1276 2
  if (strcmp (section->name, ".options") == 0
      || strcmp (section->name, ".MIPS.options") == 0)
d1278 4
a1281 1
      bfd_byte *c;
d1283 8
a1290 11
      if (elf_section_data (section) == NULL)
	{
	  section->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
	  if (elf_section_data (section) == NULL)
	    return false;
	}
      c = (bfd_byte *) elf_section_data (section)->tdata;
      if (c == NULL)
	{
	  bfd_size_type size;
a1291 27
	  if (section->_cooked_size != 0)
	    size = section->_cooked_size;
	  else
	    size = section->_raw_size;
	  c = (PTR) bfd_zalloc (abfd, size);
	  if (c == NULL)
	    return false;
	  elf_section_data (section)->tdata = (PTR) c;
	}

      memcpy (c + offset, location, count);
    }

  return _bfd_elf_set_section_contents (abfd, section, location, offset,
					count);
}

/* Work over a section just before writing it out.  This routine is
   used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize
   sections that need the SHF_MIPS_GPREL flag by name; there has to be
   a better way.  */

boolean
_bfd_mips_elf_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
{
a1311 16
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
a1315 70

/* Work over a section just before writing it out.  We update the GP
   value in the SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS sections based
   on the value we are using.  */

static boolean
mips_elf32_section_processing (abfd, hdr)
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_REGINFO)
    {
      bfd_byte buf[4];

      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
      BFD_ASSERT (hdr->contents == NULL);

      if (bfd_seek (abfd,
		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
		    SEEK_SET) == -1)
	return false;
      bfd_h_put_32 (abfd, (bfd_vma) elf_gp (abfd), buf);
      if (bfd_write (buf, (bfd_size_type) 1, (bfd_size_type) 4, abfd) != 4)
	return false;
    }

  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[4];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf32_External_RegInfo) - 4)),
			     SEEK_SET) == -1)
		return false;
	      bfd_h_put_32 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 4, abfd) != 4)
		return false;
	    }
	  l += intopt.size;
	}
    }

  return _bfd_mips_elf_section_processing (abfd, hdr);
}
d1333 1
a1333 11
/* The Irix 5 support uses two virtual sections, which represent
   text/data symbols defined in dynamic objects.  */
static asection mips_elf_text_section;
static asection *mips_elf_text_section_ptr;
static asymbol mips_elf_text_symbol;
static asymbol *mips_elf_text_symbol_ptr;

static asection mips_elf_data_section;
static asection *mips_elf_data_section_ptr;
static asymbol mips_elf_data_symbol;
static asymbol *mips_elf_data_symbol_ptr;
d1335 2
a1336 5
/* Handle the special MIPS section numbers that a symbol may use.
   This is used for both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_symbol_processing (abfd, asym)
a1393 195

#if 0 /* for SGI_COMPAT */
    case SHN_MIPS_TEXT:
      asym->section = mips_elf_text_section_ptr;
      break;

    case SHN_MIPS_DATA:
      asym->section = mips_elf_data_section_ptr;
      break;
#endif
    }
}

/* When creating an Irix 5 executable, we need REGINFO and RTPROC
   segments.  */

static int
mips_elf_additional_program_headers (abfd)
     bfd *abfd;
{
  asection *s;
  int ret;

  ret = 0;

  if (! SGI_COMPAT (abfd))
    return ret;

  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* We need a PT_MIPS_REGINFO segment.  */
      ++ret;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
    {
      /* We need a PT_MIPS_RTPROC segment.  */
      ++ret;
    }

  return ret;
}

/* Modify the segment map for an Irix 5 executable.  */

static boolean
mips_elf_modify_segment_map (abfd)
     bfd *abfd;
{
  asection *s;
  struct elf_segment_map *m, **pm;

  if (! SGI_COMPAT (abfd))
    return true;

  /* If there is a .reginfo section, we need a PT_MIPS_REGINFO
     segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_REGINFO)
	  break;
      if (m == NULL)
	{
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	  if (m == NULL)
	    return false;

	  m->p_type = PT_MIPS_REGINFO;
	  m->count = 1;
	  m->sections[0] = s;

	  /* We want to put it after the PHDR and INTERP segments.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }
	  
  /* If there are .dynamic and .mdebug sections, we make a room for
     the RTPROC header.  FIXME: Rewrite without section names.  */
  if (bfd_get_section_by_name (abfd, ".interp") == NULL
      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
    {
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_RTPROC)
	  break;
      if (m == NULL)
	{
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	  if (m == NULL)
	    return false;

	  m->p_type = PT_MIPS_RTPROC;

	  s = bfd_get_section_by_name (abfd, ".rtproc");
	  if (s == NULL)
	    {
	      m->count = 0;
	      m->p_flags = 0;
	      m->p_flags_valid = 1;
	    }
	  else
	    {
	      m->count = 1;
	      m->sections[0] = s;
	    }

	  /* We want to put it after the DYNAMIC segment.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
	    pm = &(*pm)->next;
	  if (*pm != NULL)
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }

  /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic, .dynstr,
     .dynsym, and .hash sections, and everything in between.  */
  for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
    if ((*pm)->p_type == PT_DYNAMIC)
      break;
  m = *pm;
  if (m != NULL
      && m->count == 1
      && strcmp (m->sections[0]->name, ".dynamic") == 0)
    {
      static const char *sec_names[] =
	{ ".dynamic", ".dynstr", ".dynsym", ".hash" };
      bfd_vma low, high;
      unsigned int i, c;
      struct elf_segment_map *n;

      low = 0xffffffff;
      high = 0;
      for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
	{
	  s = bfd_get_section_by_name (abfd, sec_names[i]);
	  if (s != NULL && (s->flags & SEC_LOAD) != 0)
	    {
	      bfd_size_type sz;

	      if (low > s->vma)
		low = s->vma;
	      sz = s->_cooked_size;
	      if (sz == 0)
		sz = s->_raw_size;
	      if (high < s->vma + sz)
		high = s->vma + sz;
	    }
	}

      c = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_LOAD) != 0
	    && s->vma >= low
	    && ((s->vma
		 + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		<= high))
	  ++c;

      n = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
      if (n == NULL)
	return false;
      *n = *m;
      n->count = c;

      i = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LOAD) != 0
	      && s->vma >= low
	      && ((s->vma
		   + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		  <= high))
	    {
	      n->sections[i] = s;
	      ++i;
	    }
	}

      *pm = n;
a1394 49

  return true;
}

/* The structure of the runtime procedure descriptor created by the
   loader for use by the static exception system.  */

typedef struct runtime_pdr {
	bfd_vma	adr;		/* memory address of start of procedure */
	long	regmask;	/* save register mask */
	long	regoffset;	/* save register offset */
	long	fregmask;	/* save floating point register mask */
	long	fregoffset;	/* save floating point register offset */
	long	frameoffset;	/* frame size */
	short	framereg;	/* frame pointer register */
	short	pcreg;		/* offset or reg of return pc */
	long	irpss;		/* index into the runtime string table */
	long	reserved;
	struct exception_info *exception_info;/* pointer to exception array */
} RPDR, *pRPDR;
#define cbRPDR sizeof(RPDR)
#define rpdNil ((pRPDR) 0)

/* Swap RPDR (runtime procedure table entry) for output.  */

static void ecoff_swap_rpdr_out
  PARAMS ((bfd *, const RPDR *, struct rpdr_ext *));

static void
ecoff_swap_rpdr_out (abfd, in, ex)
     bfd *abfd;
     const RPDR *in;
     struct rpdr_ext *ex;
{
  /* ecoff_put_off was defined in ecoffswap.h.  */
  ecoff_put_off (abfd, in->adr, (bfd_byte *) ex->p_adr);
  bfd_h_put_32 (abfd, in->regmask, (bfd_byte *) ex->p_regmask);
  bfd_h_put_32 (abfd, in->regoffset, (bfd_byte *) ex->p_regoffset);
  bfd_h_put_32 (abfd, in->fregmask, (bfd_byte *) ex->p_fregmask);
  bfd_h_put_32 (abfd, in->fregoffset, (bfd_byte *) ex->p_fregoffset);
  bfd_h_put_32 (abfd, in->frameoffset, (bfd_byte *) ex->p_frameoffset);

  bfd_h_put_16 (abfd, in->framereg, (bfd_byte *) ex->p_framereg);
  bfd_h_put_16 (abfd, in->pcreg, (bfd_byte *) ex->p_pcreg);

  bfd_h_put_32 (abfd, in->irpss, (bfd_byte *) ex->p_irpss);
#if 0 /* FIXME */
  ecoff_put_off (abfd, in->exception_info, (bfd_byte *) ex->p_exception_info);
#endif
d1400 2
a1401 2
boolean
_bfd_mips_elf_read_ecoff_info (abfd, section, debug)
d1412 1
a1412 1
  ext_hdr = (char *) bfd_malloc ((size_t) swap->external_hdr_size);
d1414 4
a1417 1
    goto error_return;
d1434 1
a1434 1
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
d1436 4
a1439 1
	goto error_return;						\
d1513 3
a1515 3
boolean
_bfd_mips_elf_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
				 functionname_ptr, line_ptr)
d1550 1
a1550 1
		bfd_zalloc (abfd, sizeof (struct mips_elf_find_line)));
d1553 1
d1558 3
a1560 1
	  if (! _bfd_mips_elf_read_ecoff_info (abfd, msec, &fi->d))
d1573 1
a1621 3

  /* Number of MIPS_32 or MIPS_REL32 relocs against this symbol.  */
  unsigned int mips_32_relocs;
a1628 6
  /* String section indices for the dynamic section symbols.  */
  bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
  /* The number of .rtproc entries.  */
  bfd_size_type procedure_count;
  /* The size of the .compact_rel section (if SGI_COMPAT).  */
  bfd_size_type compact_rel_size;
d1672 4
a1675 1
    return (struct bfd_hash_entry *) ret;
a1687 1
      ret->mips_32_relocs = 0;
a1699 1
  unsigned int i;
d1704 4
a1707 1
    return NULL;
a1715 5
  for (i = 0; i < SIZEOF_MIPS_DYNSYM_SECNAMES; i++)
    ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
  ret->procedure_count = 0;
  ret->compact_rel_size = 0;

a1732 9
  if (SGI_COMPAT (abfd)
      && (abfd->flags & DYNAMIC) != 0
      && strcmp (*namep, "_rld_new_interface") == 0)
    {
      /* Skip Irix 5 rld entry name.  */
      *namep = NULL;
      return true;
    }

a1746 48
    case SHN_MIPS_TEXT:
      /* This section is used in a shared object.  */
      if (mips_elf_text_section_ptr == NULL)
	{
	  /* Initialize the section.  */
	  mips_elf_text_section.name = ".text";
	  mips_elf_text_section.flags = SEC_NO_FLAGS;
	  mips_elf_text_section.output_section = NULL;
	  mips_elf_text_section.owner = abfd;
	  mips_elf_text_section.symbol = &mips_elf_text_symbol;
	  mips_elf_text_section.symbol_ptr_ptr = &mips_elf_text_symbol_ptr;
	  mips_elf_text_symbol.name = ".text";
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_text_symbol.section = &mips_elf_text_section;
	  mips_elf_text_symbol_ptr = &mips_elf_text_symbol;
	  mips_elf_text_section_ptr = &mips_elf_text_section;
	}
      if (info->shared)
	*secp = bfd_und_section_ptr;
      else
	*secp = mips_elf_text_section_ptr;
      break;

    case SHN_MIPS_ACOMMON:
      /* Fall through. XXX Can we treat this as allocated data?  */
    case SHN_MIPS_DATA:
      /* This section is used in a shared object.  */
      if (mips_elf_data_section_ptr == NULL)
	{
	  /* Initialize the section.  */
	  mips_elf_data_section.name = ".data";
	  mips_elf_data_section.flags = SEC_NO_FLAGS;
	  mips_elf_data_section.output_section = NULL;
	  mips_elf_data_section.owner = abfd;
	  mips_elf_data_section.symbol = &mips_elf_data_symbol;
	  mips_elf_data_section.symbol_ptr_ptr = &mips_elf_data_symbol_ptr;
	  mips_elf_data_symbol.name = ".data";
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_data_symbol.section = &mips_elf_data_section;
	  mips_elf_data_symbol_ptr = &mips_elf_data_symbol;
	  mips_elf_data_section_ptr = &mips_elf_data_section;
	}
      if (info->shared)
	*secp = bfd_und_section_ptr;
      else
	*secp = mips_elf_data_section_ptr;
      break;

a1786 1
  asection *sec, *output_section;
d1817 1
a1817 33
      if (SGI_COMPAT (einfo->abfd)
	  && (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak))
	{
	  const char *name;

	  /* Use undefined class.  Also, set class and type for some
             special symbols.  */
	  name = h->root.root.root.string;
	  if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	      || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	    {
	      h->esym.asym.sc = scData;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = 0;
	    }
	  else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value =
		mips_elf_hash_table (einfo->info)->procedure_count;
	    }
	  else if (strcmp (name, "_gp_disp") == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = elf_gp (einfo->abfd);
	    }
	  else
	    h->esym.asym.sc = scUndefined;
	}
      else if (h->root.root.type != bfd_link_hash_defined
d1822 1
d1825 20
a1844 7
	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
d1846 1
a1846 23
	    {
	      name = bfd_section_name (output_section->owner, output_section);
	
	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
d1858 2
d1866 3
a1868 7
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
a1869 21
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = h->root.root.u.def.section;
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
	{
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt_offset
				  + sec->output_offset
				  + output_section->vma);
	  else
	    h->esym.asym.value = 0;
	}
#if 0 /* FIXME?  */
      h->esym.ifd = 0;
#endif
    }      
a1881 151
/* Create a runtime procedure table from the .mdebug section.  */

static boolean
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
{
  const struct ecoff_debug_swap *swap;
  HDRR *hdr = &debug->symbolic_header;
  RPDR *rpdr, *rp;
  struct rpdr_ext *erp;
  PTR rtproc;
  struct pdr_ext *epdr;
  struct sym_ext *esym;
  char *ss, **sv;
  char *str;
  unsigned long size, count;
  unsigned long sindex;
  unsigned long i;
  PDR pdr;
  SYMR sym;
  const char *no_name_func = "static procedure (no name)";

  epdr = NULL;
  rpdr = NULL;
  esym = NULL;
  ss = NULL;
  sv = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

  sindex = strlen (no_name_func) + 1;
  count = hdr->ipdMax;
  if (count > 0)
    {
      size = swap->external_pdr_size;

      epdr = (struct pdr_ext *) bfd_malloc (size * count);
      if (epdr == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_pdr (handle, (PTR) epdr))
	goto error_return;

      size = sizeof (RPDR);
      rp = rpdr = (RPDR *) bfd_malloc (size * count);
      if (rpdr == NULL)
	goto error_return;

      sv = (char **) bfd_malloc (sizeof (char *) * count);
      if (sv == NULL)
	goto error_return;

      count = hdr->isymMax;
      size = swap->external_sym_size;
      esym = (struct sym_ext *) bfd_malloc (size * count);
      if (esym == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_sym (handle, (PTR) esym))
	goto error_return;

      count = hdr->issMax;
      ss = (char *) bfd_malloc (count);
      if (ss == NULL)
	goto error_return;
      if (! _bfd_ecoff_get_accumulated_ss (handle, (PTR) ss))
	goto error_return;

      count = hdr->ipdMax;
      for (i = 0; i < count; i++, rp++)
	{
	  (*swap->swap_pdr_in) (abfd, (PTR) (epdr + i), &pdr);
	  (*swap->swap_sym_in) (abfd, (PTR) &esym[pdr.isym], &sym);
	  rp->adr = sym.value;
	  rp->regmask = pdr.regmask;
	  rp->regoffset = pdr.regoffset;
	  rp->fregmask = pdr.fregmask;
	  rp->fregoffset = pdr.fregoffset;
	  rp->frameoffset = pdr.frameoffset;
	  rp->framereg = pdr.framereg;
	  rp->pcreg = pdr.pcreg;
	  rp->irpss = sindex;
	  sv[i] = ss + sym.iss;
	  sindex += strlen (sv[i]) + 1;
	}
    }

  size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
  size = BFD_ALIGN (size, 16);
  rtproc = (PTR) bfd_alloc (abfd, size);
  if (rtproc == NULL)
    {
      mips_elf_hash_table (info)->procedure_count = 0;
      goto error_return;
    }

  mips_elf_hash_table (info)->procedure_count = count + 2;

  erp = (struct rpdr_ext *) rtproc;
  memset (erp, 0, sizeof (struct rpdr_ext));
  erp++;
  str = (char *) rtproc + sizeof (struct rpdr_ext) * (count + 2);
  strcpy (str, no_name_func);
  str += strlen (no_name_func) + 1;
  for (i = 0; i < count; i++)
    {
      ecoff_swap_rpdr_out (abfd, rpdr + i, erp + i);
      strcpy (str, sv[i]);
      str += strlen (sv[i]) + 1;
    }
  ecoff_put_off (abfd, (bfd_vma) -1, (bfd_byte *) (erp + count)->p_adr);

  /* Set the size and contents of .rtproc section.  */
  s->_raw_size = size;
  s->contents = rtproc;

  /* Skip this section later on (I don't think this currently
     matters, but someday it might).  */
  s->link_order_head = (struct bfd_link_order *) NULL;

  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);

  return true;

 error_return:
  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);
  return false;
}

a1907 1
  asection *rtproc_sec;
a1930 36
  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (info->relocateable)
	{
	  bfd_vma lo;

	  /* Make up a value.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	    {
	      if (o->vma < lo
		  && (strcmp (o->name, ".sbss") == 0
		      || strcmp (o->name, ".sdata") == 0
		      || strcmp (o->name, ".lit4") == 0
		      || strcmp (o->name, ".lit8") == 0))
		lo = o->vma;
	    }
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (abfd);
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

d1985 1
a1985 1
		 mips_elf32_section_processing when the section is
d2044 2
a2045 41
	  if (SGI_COMPAT (abfd))
	    {
	      asection *s;
	      EXTR esym;
	      bfd_vma last;
	      unsigned int i;
	      static const char * const name[] =
		{ ".text", ".init", ".fini", ".data",
		    ".rodata", ".sdata", ".sbss", ".bss" };
	      static const int sc[] = { scText, scInit, scFini, scData,
					  scRData, scSData, scSBss, scBss };

	      esym.jmptbl = 0;
	      esym.cobol_main = 0;
	      esym.weakext = 0;
	      esym.reserved = 0;
	      esym.ifd = ifdNil;
	      esym.asym.iss = issNil;
	      esym.asym.st = stLocal;
	      esym.asym.reserved = 0;
	      esym.asym.index = indexNil;
	      for (i = 0; i < 8; i++)
		{
		  esym.asym.sc = sc[i];
		  s = bfd_get_section_by_name (abfd, name[i]);
		  if (s != NULL)
		    {
		      esym.asym.value = s->vma;
		      last = s->vma + s->_raw_size;
		    }
		  else
		    esym.asym.value = last;
		
		  if (! bfd_ecoff_debug_one_external (abfd, &debug, swap,
						      name[i], &esym))
		    return false;
		}
	    }

	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
d2083 2
a2084 2
	      if (! _bfd_mips_elf_read_ecoff_info (input_bfd, input_section,
						   &input_debug))
a2147 21
	  if (SGI_COMPAT (abfd) && info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
				    | SEC_READONLY);

		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 12))
		    return false;
		}

	      if (! mips_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec, &debug))
		return false;
	    }

d2254 1
a2254 1
	  tab = (Elf32_gptab *) bfd_malloc (c * sizeof (Elf32_gptab));
d2256 4
a2259 1
	    return false;
d2330 2
a2331 2
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf32_gptab)));
d2334 1
d2378 1
d2396 36
a2476 13
  if (SGI_COMPAT (abfd))
    {
      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
      if (rtproc_sec != NULL)
	{
	  if (! bfd_set_section_contents (abfd, rtproc_sec,
					  rtproc_sec->contents,
					  (file_ptr) 0,
					  rtproc_sec->_raw_size))
	    return false;
	}
    }

a2509 85
/* Handle a MIPS ELF local GOT16 reloc.  */

static void
mips_elf_relocate_got_local (output_bfd, input_bfd, sgot, relhi, rello,
			     contents, addend)
     bfd *output_bfd;
     bfd *input_bfd;
     asection *sgot;
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
{
  int local_gotno;
  int i;
  bfd_vma insn;
  bfd_vma addlo;
  bfd_vma address;
  bfd_vma hipage;
  bfd_byte *got_contents;
  struct mips_got_info *g;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  addlo &= 0xffff;

  addend += ((insn & 0xffff) << 16) + addlo;

  if ((addlo & 0x8000) != 0)
    addend -= 0x10000;
  if ((addend & 0x8000) != 0)
    addend += 0x10000;

  /* Get a got entry representing requested hipage.  */
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  local_gotno = g->local_gotno;
  got_contents = sgot->contents;
  hipage = addend & 0xffff0000;

  for (i = MIPS_RESERVED_GOTNO; i < local_gotno; i++)
    {
      address = bfd_get_32 (input_bfd, got_contents + i * 4);
      if (hipage == (address & 0xffff0000))
	break;
      if (address == (bfd_vma) 0)
	{
	  bfd_put_32 (input_bfd, hipage, got_contents + i * 4);
	  break;
	}
    }

  BFD_ASSERT (i < local_gotno);
#if 1
  if (i == local_gotno)
    (*_bfd_error_handler)
      ("ELF MIPS linker: more got entries are needed for hipage: %x",
       hipage);
#endif

  i = - ELF_MIPS_GP_OFFSET (output_bfd) + i * 4;
  bfd_put_32 (input_bfd, (insn & 0xffff0000) | (i & 0xffff),
	      contents + relhi->r_offset);
}

/* Handle MIPS ELF CALL16 reloc and global GOT16 reloc.  */

static void
mips_elf_relocate_global_got (input_bfd, rel, contents, offset)
     bfd *input_bfd;
     Elf_Internal_Rela *rel;
     bfd_byte *contents;
     bfd_vma offset;
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | (offset & 0xffff),
	      contents + rel->r_offset);
}

a2526 3
  asection *sgot, *sreloc, *scpt;
  bfd *dynobj;
  bfd_vma gp;
a2528 1
  struct mips_got_info *g;
a2529 1
  dynobj = elf_hash_table (info)->dynobj;
a2531 8
  sgot = NULL;
  sreloc = NULL;
  if (dynobj == NULL || ! SGI_COMPAT (output_bfd))
    scpt = NULL;
  else
    scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
  g = NULL;

a2542 2
  gp = _bfd_get_gp_value (output_bfd);

a2563 19
      if (dynobj != NULL
	  && (r_type == R_MIPS_CALL16
	      || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_CALL_HI16
	      || r_type == R_MIPS_CALL_LO16
	      || r_type == R_MIPS_GOT_HI16
	      || r_type == R_MIPS_GOT_LO16))
	{
	  /* We need the .got section.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }
	}

d2573 1
a2573 1
	  if (gp == 0)
d2582 1
a2582 2
	      gp = 4;
	      _bfd_set_gp_value (output_bfd, gp);
d2595 1
a2595 1
	      addend = elf_gp (input_bfd) - gp;
d2605 1
a2605 1
	      addend = - gp;
d2643 2
a2644 2
		  /* If this is HI16 or GOT16 with an associated LO16,
		     adjust the addend accordingly.  Otherwise, just
d2646 3
a2648 1
		  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_GOT16)
d2654 3
a2656 28
		      Elf_Internal_Rela *lorel;

		      /* As a GNU extension, permit an arbitrary
			 number of R_MIPS_HI16 relocs before the
			 R_MIPS_LO16 reloc.  This permits gcc to emit
			 the HI and LO relocs itself.  */
		      if (r_type == R_MIPS_GOT16)
			lorel = rel + 1;
		      else
			{
			  for (lorel = rel + 1;
			       (lorel < relend
				&& (ELF32_R_TYPE (lorel->r_info)
				    == R_MIPS_HI16));
			       lorel++)
			    ;
			}
		      if (lorel < relend
			  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
			{
			  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
						  contents, addend);
			  r = bfd_reloc_ok;
			}
		      else
			r = _bfd_relocate_contents (howto, input_bfd,
						    addend,
						    contents + rel->r_offset);
a2663 1
	  boolean local;
a2670 1
	      local = true;
a2685 1
	      local = false;
d2688 1
a2688 33
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (strcmp (h->root.root.string, "_gp_disp") == 0)
		{
		  if (gp == 0)
		    {
		      if (! ((*info->callbacks->reloc_dangerous)
			     (info,
			      "_gp_disp used when GP not defined",
			      input_bfd, input_section,
			      rel->r_offset)))
			return false;
		      /* Only give the error once per link.  */
		      gp = 4;
		      _bfd_set_gp_value (output_bfd, gp);
		      relocation = 0;
		    }
		  else
		    {
		      sec = input_section;
		      if (sec->output_section != NULL)
			relocation = (gp
				      - (rel->r_offset
					 + sec->output_section->vma
					 + sec->output_offset));
		      else
			relocation = gp - rel->r_offset;
		      if (r_type == R_MIPS_LO16)
			relocation += 4;
		    }
		}
	      else if (h->root.type == bfd_link_hash_defined
d2692 3
a2694 6
		  if (sec->output_section == NULL)
		    relocation = 0;
		  else
		    relocation = (h->root.u.def.value
				  + sec->output_section->vma
				  + sec->output_offset);
a2697 15
	      else if (info->shared && ! info->symbolic)
		relocation = 0;
	      else if (strcmp (h->root.root.string, "_DYNAMIC_LINK") == 0)
		{
		  /* If this is a dynamic link, we should have created
                     a _DYNAMIC_LINK symbol in
                     mips_elf_create_dynamic_sections.  Otherwise, we
                     should define the symbol with a value of 0.
                     FIXME: It should probably get into the symbol
                     table somehow as well.  */
		  BFD_ASSERT (! info->shared);
		  BFD_ASSERT (bfd_get_section_by_name (output_bfd,
						       ".dynamic") == NULL);
		  relocation = 0;
		}
d2708 3
a2710 206
	  if (r_type == R_MIPS_HI16)
	    {
	      Elf_Internal_Rela *lorel;

	      /* As a GNU extension, permit an arbitrary number of
		 R_MIPS_HI16 relocs before the R_MIPS_LO16 reloc.
		 This permits gcc to emit the HI and LO relocs itself.  */
	      for (lorel = rel + 1;
		   (lorel < relend
		    && ELF32_R_TYPE (lorel->r_info) == R_MIPS_HI16);
		   lorel++)
		;
	      if (lorel < relend
		  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
		{
		  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
					  contents, relocation + addend);
		  r = bfd_reloc_ok;
		}
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else if (r_type == R_MIPS_GOT16 && local)
	    {
	      /* GOT16 must also have an associated LO16 in the local
		 case.  In this case, the addend is extracted and the
		 section in which the referenced object is determined.
		 Then the final address of the object is computed and
		 the GOT entry for the hipage (an aligned 64kb chunk)
		 is added to .got section if needed.  The offset field
		 of the GOT16-relocated instruction is replaced by the
		 index of this GOT entry for the hipage.  */
	      if ((rel + 1) < relend
		  && ELF32_R_TYPE ((rel + 1)->r_info) == R_MIPS_LO16)
		{
		  mips_elf_relocate_got_local (output_bfd, input_bfd, sgot,
					       rel, rel + 1,
					       contents,
					       relocation + addend);
		  r = bfd_reloc_ok;
		}
	      else
		r = bfd_reloc_outofrange;
	    }
	  else if (r_type == R_MIPS_CALL16
		   || r_type == R_MIPS_GOT16
		   || r_type == R_MIPS_CALL_LO16
		   || r_type == R_MIPS_GOT_LO16)
	    {
	      bfd_vma offset;

	      /* This symbol must be registered as a global symbol
		 having the corresponding got entry.  */
	      BFD_ASSERT (h->got_offset != (bfd_vma) -1);

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_global_got (input_bfd, rel, contents,
					    offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_CALL_HI16
		   || r_type == R_MIPS_GOT_HI16)
	    {
	      bfd_vma offset;

	      /* This must be a global symbol with a got entry.  The
                 next reloc must be the corresponding LO16 reloc.  */
	      BFD_ASSERT (h != NULL && h->got_offset != (bfd_vma) -1);
	      BFD_ASSERT ((rel + 1) < relend);
	      BFD_ASSERT (ELF32_R_TYPE ((rel + 1)->r_info)
			  == (r_type == R_MIPS_CALL_HI16
			      ? R_MIPS_CALL_LO16
			      : R_MIPS_GOT_LO16));

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_hi16 (input_bfd, rel, rel + 1, contents,
				      offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_REL32
		   || r_type == R_MIPS_32)
	    {
	      Elf_Internal_Rel outrel;
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;

	      if ((info->shared
		   || (h != NULL
		       && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
			   == 0)))
		  && (input_section->flags & SEC_ALLOC) != 0)
		{
		  /* When generating a shared object, these
		     relocations are copied into the output file to be
		     resolved at run time.  */
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
		      BFD_ASSERT (sreloc != NULL);
		    }

		  outrel.r_offset = (rel->r_offset
				     + input_section->output_section->vma
				     + input_section->output_offset);

		  addend = bfd_get_32 (input_bfd, contents + rel->r_offset);

		  if (h != NULL
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_REL32);
		      sec = input_section;
		    }
		  else
		    {
		      long indx;

		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    abort ();
			}

		      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);
		      addend += relocation;
		    }

		  bfd_put_32 (output_bfd, addend, contents + rel->r_offset);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
					     (((Elf32_External_Rel *)
					       sreloc->contents)
					      + sreloc->reloc_count));
		  ++sreloc->reloc_count;

		  if (SGI_COMPAT (output_bfd))
		    {
		      if (scpt == NULL)
			continue;

		      /* Make an entry of compact relocation info.  */
		      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
		      cptrel.vaddr = (rel->r_offset
				      + input_section->output_section->vma
				      + input_section->output_offset);
		      if (r_type == R_MIPS_REL32)
			mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
		      else
			mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
		      mips_elf_set_cr_dist2to (cptrel, 0);
		      cptrel.konst = addend;

		      cr = (scpt->contents
			    + sizeof (Elf32_External_compact_rel));
		      bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
						 ((Elf32_External_crinfo *) cr
						  + scpt->reloc_count));
		      ++scpt->reloc_count;
		    }

		  /* This reloc will be computed at runtime, so
		     there's no need to do anything now.  */
		  continue;
		}
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else
d2714 1
a2714 4

	  if (SGI_COMPAT (abfd)
	      && scpt != NULL
	      && (input_section->flags & SEC_ALLOC) != 0)
d2716 3
a2718 39
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;

	      /* Make an entry of compact relocation info.  */
	      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	      cptrel.vaddr = (rel->r_offset
			      + input_section->output_section->vma
			      + input_section->output_offset);

	      switch (r_type)
		{
		case R_MIPS_26:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_JMPAD);
		  /* XXX How should we set dist2to in this case. */
		  mips_elf_set_cr_dist2to (cptrel, 8);
		  cptrel.konst = addend + relocation;
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;

		case R_MIPS_GPREL16:
		case R_MIPS_LITERAL:
		case R_MIPS_GPREL32:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_GPHI_LO);
		  cptrel.konst = gp - cptrel.vaddr;
		  mips_elf_set_cr_dist2to (cptrel, 4);
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;

		default:
		  break;
		}
d2758 5
a2762 11
/* Functions for the dynamic linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

/* Create dynamic sections when linking against a dynamic object.  */

static boolean
mips_elf_create_dynamic_sections (abfd, info)
d2764 5
a2768 1
     struct bfd_link_info *info;
d2770 7
a2776 15
  struct elf_link_hash_entry *h;
  flagword flags;
  register asection *s;
  const char * const *namep;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_READONLY);

  /* Mips ABI requests the .dynamic section to be read only.  */
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      if (! bfd_set_section_flags (abfd, s, flags))
	return false;
    }
d2778 2
a2779 3
  /* We need to create .got section.  */
  if (! mips_elf_create_got_section (abfd, info))
    return false;
d2781 2
a2782 2
  /* Create .stub section.  */
  if (bfd_get_section_by_name (abfd, ".stub") == NULL)
d2784 2
a2785 5
      s = bfd_make_section (abfd, ".stub");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return false;
d2788 7
a2794 14
  if (SGI_COMPAT (abfd))
    {
      for (namep = mips_elf_dynsym_rtproc_names; *namep != NULL; namep++)
	{
	  h = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	    return false;
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_SECTION;
d2796 3
a2798 3
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}
d2800 6
a2805 1271
      /* We need to create a .compact_rel section.  */
      if (! mips_elf_create_compact_rel_section (abfd, info))
	return false;

      /* Change aligments of some sections.  */
      s = bfd_get_section_by_name (abfd, ".hash");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynsym");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynstr");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".reginfo");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
    }

  if (!info->shared)
    {
      h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
	      (bfd_vma) 0, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
	return false;
      h->elf_link_hash_flags ^=~ ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_SECTION;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;
    }

  return true;
}

/* Create the .compact_rel section.  */

static boolean
mips_elf_create_compact_rel_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;

  if (bfd_get_section_by_name (abfd, ".compact_rel") == NULL)
    {
      flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY;

      s = bfd_make_section (abfd, ".compact_rel");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return false;

      s->_raw_size = sizeof (Elf32_External_compact_rel);
    }

  return true;
}
  
/* Create the .got section to hold the global offset table. */

static boolean
mips_elf_create_got_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct mips_got_info *g;

  /* This function may be called more than once.  */
  if (bfd_get_section_by_name (abfd, ".got") != NULL)
    return true;

  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 4))
    return false;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  h = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, false,
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;

  /* The first several global offset table entries are reserved.  */
  s->_raw_size = MIPS_RESERVED_GOTNO * 4;

  g = (struct mips_got_info *) bfd_alloc (abfd,
					  sizeof (struct mips_got_info));
  if (g == NULL)
    return false;
  g->global_gotsym = 0;
  g->local_gotno = MIPS_RESERVED_GOTNO;
  if (elf_section_data (s) == NULL)
    {
      s->used_by_bfd =
	(PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
      if (elf_section_data (s) == NULL)
	return false;
    }
  elf_section_data (s)->tdata = (PTR) g;

  return true;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table.  */

static boolean
mips_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct mips_got_info *g;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *sreloc;

  if (info->relocateable)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  sgot = NULL;
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < extsymoff)
	h = NULL;
      else
	h = sym_hashes[r_symndx - extsymoff];

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_MIPS_GOT16:
	    case R_MIPS_CALL16:
	    case R_MIPS_CALL_HI16:
	    case R_MIPS_CALL_LO16:
	    case R_MIPS_GOT_HI16:
	    case R_MIPS_GOT_LO16:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! mips_elf_create_got_section (dynobj, info))
		return false;
	      break;

	    default:
	      break;
	    }
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  /* This symbol requires a global offset table entry.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }

	  BFD_ASSERT (h != NULL);

	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }

	  if (h->got_offset != (bfd_vma) -1)
	    {
	      /* We have already allocated space in the .got.  */
	      break;
	    }

	  /* Note the index of the first global got symbol in .dynsym.  */
	  if (g->global_gotsym == 0
	      || g->global_gotsym > (unsigned long) h->dynindx)
	    g->global_gotsym = h->dynindx;

	  /* Make this symbol to have the corresponding got entry.  */
	  h->got_offset = 0;

	  /* We need a stub, not a plt entry for the undefined
	     function.  But we record it as if it needs plt.  See
	     elf_adjust_dynamic_symbol in elflink.h.  */
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->type = STT_FUNC;

	  break;

	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	  /* This symbol requires a global offset table entry.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }

	  if (h != NULL)
	    {
	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return false;
		}

	      if (h->got_offset != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      /* Note the index of the first global got symbol in
                 .dynsym.  */
	      if (g->global_gotsym == 0
		  || g->global_gotsym > (unsigned long) h->dynindx)
		g->global_gotsym = h->dynindx;

	      /* Make this symbol to be the global got symbol.  */
	      h->got_offset = 0;
	    }

	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	  if ((info->shared || h != NULL)
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      /* When creating a shared object, we must copy these
                 reloc types into the output file as R_MIPS_REL32
		 relocs.  We create the .rel.dyn reloc section in
		 dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  const char *name = ".rel.dyn";

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section (dynobj, name);
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc,
						      (SEC_ALLOC
						       | SEC_LOAD
						       | SEC_HAS_CONTENTS
						       | SEC_IN_MEMORY
						       | SEC_READONLY))
			  || ! bfd_set_section_alignment (dynobj, sreloc, 4))
			return false;

		      /* Add a null element. */
		      sreloc->_raw_size += sizeof (Elf32_External_Rel);
		      ++sreloc->reloc_count;
		    }
		}

	      if (info->shared)
		sreloc->_raw_size += sizeof (Elf32_External_Rel);
	      else
		{
		  struct mips_elf_link_hash_entry *hmips;

		  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
		  hmips = (struct mips_elf_link_hash_entry *) h;
		  ++hmips->mips_32_relocs;
		}
	    }

	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);

	  break;

	case R_MIPS_26:
	case R_MIPS_GPREL16:
	case R_MIPS_LITERAL:
	case R_MIPS_GPREL32:
	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	default:
	  break;
	}
    }

  return true;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static boolean
mips_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this symbol is defined in a dynamic object, we need to copy
     any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output
     file.  */
  hmips = (struct mips_elf_link_hash_entry *) h;
  if (! info->relocateable
      && hmips->mips_32_relocs != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    {
      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
      BFD_ASSERT (s != NULL);

      s->_raw_size += hmips->mips_32_relocs * sizeof (Elf32_External_Rel);
    }

  /* For a function, create a stub, if needed. */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (! elf_hash_table (info)->dynamic_sections_created)
	return true;

      /* If this symbol is not defined in a regular file, then set
	 the symbol to the stub location.  This is required to make
	 function pointers compare as equal between the normal
	 executable and the shared library.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* We need .stub section.  */
	  s = bfd_get_section_by_name (dynobj, ".stub");
	  BFD_ASSERT (s != NULL);

	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;

	  /* XXX Write this stub address somewhere.  */
	  h->plt_offset = s->_raw_size;

	  /* Make room for this stub code.  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;

	  /* The last half word of the stub will be filled with the index
	     of this symbol in .dynsym section.  */
	  return true;
	}
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  return true;
}

/* Set the sizes of the dynamic sections.  */

static boolean
mips_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  boolean reltext;
  asection *sgot;
  struct mips_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Recompute the size of .got for local entires (reserved and
     hipages) if needed.  To estimate it, get the upper bound of total
     size of loadable sections.  */
  sgot = bfd_get_section_by_name (dynobj, ".got");

  if (sgot != NULL)
    {
      bfd_size_type loadable_size = 0;
      bfd_size_type local_gotno;
      struct _bfd *sub;

      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);

      for (sub = info->input_bfds; sub; sub = sub->link_next)
	for (s = sub->sections; s != NULL; s = s->next)
	  {
	    if ((s->flags & SEC_ALLOC) == 0)
	      continue;
	    loadable_size += (s->_raw_size + 0xf) & ~0xf;
	  }

      loadable_size += MIPS_FUNCTION_STUB_SIZE;

      /* Assume there are two loadable segments consisting of
	 contiguous sections.  Is 5 enough? */
      local_gotno = (loadable_size >> 16) + 5 + MIPS_RESERVED_GOTNO;
      g->local_gotno = local_gotno;
      sgot->_raw_size += local_gotno * 4;
    }

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if ((s->flags & SEC_IN_MEMORY) == 0)
	continue;

      strip = false;

      if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    strip = true;
	  else
	    {
	      asection *target;

	      /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel.dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
	      target = bfd_get_section_by_name (output_bfd, name + 4);
	      if ((target != NULL && (target->flags & SEC_READONLY) != 0)
		  || strcmp (name, ".rel.dyn") == 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      if (strcmp (name, ".rel.dyn") != 0)
		s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) == 0)
	{
	  int i;

	  BFD_ASSERT (elf_section_data (s) != NULL);
	  g = (struct mips_got_info *) elf_section_data (s)->tdata;
	  BFD_ASSERT (g != NULL);

	  /* Fix the size of .got section for the correspondence of
	     global symbols and got entries. This adds some useless
	     got entries. Is this required by ABI really?  */
	  i = elf_hash_table (info)->dynsymcount - g->global_gotsym;
	  s->_raw_size += i * 4;
	}
      else if (strncmp (name, ".stub", 5) == 0)
	{
	  /* Irix rld assumes that the function stub isn't at the end
	     of .text section. So put a dummy. XXX  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
	}
      else if (SGI_COMPAT (output_bfd)
	       && strncmp (name, ".compact_rel", 12) == 0)
	s->_raw_size += mips_elf_hash_table (info)->compact_rel_size;
      else if (strncmp (name, ".init", 5) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  asection **spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
      memset (s->contents, 0, s->_raw_size);
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_mips_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
	}

      if (reltext)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
	}

      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
	return false;

      if (bfd_get_section_by_name (dynobj, ".rel.dyn"))
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0))
	    return false;

	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0))
	    return false;

	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELENT, 0))
	    return false;
	}

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICTNO, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLISTNO, 0))
	return false;

      if (bfd_get_section_by_name (dynobj, ".conflict") != NULL)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICT, 0))
	    return false;

	  s = bfd_get_section_by_name (dynobj, ".liblist");
	  BFD_ASSERT (s != NULL);

	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLIST, 0))
	    return false;
	}

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_VERSION, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_FLAGS, 0))
	return false;

#if 0
      /* Time stamps in executable files are a bad idea.  */
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_IVERSION, 0))
	return false;
#endif

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_BASE_ADDRESS, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LOCAL_GOTNO, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_SYMTABNO, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_UNREFEXTNO, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_GOTSYM, 0))
	return false;

      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_HIPAGENO, 0))
	return false;

#if 0 /* (SGI_COMPAT) */
      if (! bfd_get_section_by_name (dynobj, ".init"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_INIT, 0))
	  return false;

      if (! bfd_get_section_by_name (dynobj, ".fini"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_FINI, 0))
	  return false;
#endif
    }

  /* If we use dynamic linking, we generate a section symbol for each
     output section.  These are local symbols, which means that they
     must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.  */
  {
    const char * const *namep;
    unsigned int c, i;
    bfd_size_type strindex;
    struct bfd_strtab_hash *dynstr;
    struct mips_got_info *g;

    c = 0;
    if (elf_hash_table (info)->dynamic_sections_created)
      {
	if (SGI_COMPAT (output_bfd))
	  {
	    c = SIZEOF_MIPS_DYNSYM_SECNAMES - 1;
	    elf_link_hash_traverse (elf_hash_table (info),
				    mips_elf_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    dynstr = elf_hash_table (info)->dynstr;
	    BFD_ASSERT (dynstr != NULL);

	    for (i = 1, namep = mips_elf_dynsym_sec_names;
		 *namep != NULL;
		 i++, namep++)
	      {
		s = bfd_get_section_by_name (output_bfd, *namep);
		if (s != NULL)
		  elf_section_data (s)->dynindx = i;

		strindex = _bfd_stringtab_add (dynstr, *namep, true, false);
		if (strindex == (bfd_size_type) -1)
		  return false;

		mips_elf_hash_table (info)->dynsym_sec_strindex[i] = strindex;
	      }
	  }
	else
	  {
	    c = bfd_count_sections (output_bfd);
	    elf_link_hash_traverse (elf_hash_table (info),
				    mips_elf_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    for (i = 1, s = output_bfd->sections; s != NULL; s = s->next, i++)
	      {
		elf_section_data (s)->dynindx = i;
		/* These symbols will have no names, so we don't need to
		   fiddle with dynstr_index.  */
	      }
	  }
      }

    s = bfd_get_section_by_name (dynobj, ".got");
    BFD_ASSERT (s != NULL);
    BFD_ASSERT (elf_section_data (s) != NULL);
    g = (struct mips_got_info *) elf_section_data (s)->tdata;
    BFD_ASSERT (g != NULL);

    /* If there are no global got symbols, fake the last symbol so for
       safety.  */
    if (g->global_gotsym)
      g->global_gotsym += c;
    else
      g->global_gotsym = elf_hash_table (info)->dynsymcount - 1;
  }

  return true;
}

/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
mips_elf_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  unsigned int *cp = (unsigned int *) cparg;

  if (h->dynindx != -1)
    h->dynindx += *cp;
  return true;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static boolean
mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  bfd *dynobj;
  bfd_vma gval;
  asection *sgot;
  struct mips_got_info *g;
  const char *name;

  dynobj = elf_hash_table (info)->dynobj;
  gval = sym->st_value;

  if (h->plt_offset != (bfd_vma) -1)
    {
      asection *s;
      bfd_byte *p;
      bfd_byte stub[MIPS_FUNCTION_STUB_SIZE];

      /* This symbol has a stub.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (dynobj, ".stub");
      BFD_ASSERT (s != NULL);

      /* Fill the stub.  */
      p = stub;
      bfd_put_32 (output_bfd, STUB_LW(output_bfd), p);
      p += 4;
      bfd_put_32 (output_bfd, STUB_MOVE, p);
      p += 4;

      /* FIXME: Can h->dynindex be more than 64K?  */
      if (h->dynindx & 0xffff0000)
	return false;

      bfd_put_32 (output_bfd, STUB_JALR, p);
      p += 4;
      bfd_put_32 (output_bfd, STUB_LI16 + h->dynindx, p);

      BFD_ASSERT (h->plt_offset <= s->_raw_size);
      memcpy (s->contents + h->plt_offset, stub, MIPS_FUNCTION_STUB_SIZE);

      /* Mark the symbol as undefined.  plt_offset != -1 occurs
	 only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
	 to reset the global offset table entry for this external
	 to its stub address when unlinking a shared object.  */
      gval = s->output_section->vma + s->output_offset + h->plt_offset;
      sym->st_value = gval;
    }

  BFD_ASSERT (h->dynindx != -1);

  sgot = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  if ((unsigned long) h->dynindx >= g->global_gotsym)
    {
      bfd_size_type offset;

      /* This symbol has an entry in the global offset table.  Set its
	 value to the corresponding got entry, if needed.  */
      if (h->got_offset == (bfd_vma) -1)
	{
	  offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	  BFD_ASSERT (g->local_gotno * 4 <= offset
		      && offset < sgot->_raw_size);
	  bfd_put_32 (output_bfd, gval, sgot->contents + offset);
	}
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (strcmp (name, "_DYNAMIC") == 0
      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (SGI_COMPAT (output_bfd))
    {
      if (strcmp (name, "_gp_disp") == 0)
	{
	  sym->st_shndx = SHN_ABS;
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_value = elf_gp (output_bfd);
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	       || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = 0;
	  sym->st_shndx = SHN_MIPS_DATA;
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = mips_elf_hash_table (info)->procedure_count;
	  sym->st_shndx = SHN_ABS;
	}
      else if (sym->st_shndx != SHN_UNDEF)
	{
	  if (h->type == STT_FUNC)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else if (h->type == STT_OBJECT)
	    sym->st_shndx = SHN_MIPS_DATA;
	}
    }

  return true;
}

/* Finish up the dynamic sections.  */

static boolean
mips_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  struct mips_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  sgot = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (sgot != NULL);

  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_RELENT:
	      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = sizeof (Elf32_External_Rel);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val =
		_bfd_stringtab_size (elf_hash_table (info)->dynstr);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_MIPS_CONFLICT:
	      name = ".conflict";
	      goto get_vma;
	    case DT_MIPS_LIBLIST:
	      name = ".liblist";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_RLD_VERSION:
	      dyn.d_un.d_val = 1; /* XXX */
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_FLAGS:
	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_CONFLICTNO:
	      name = ".conflict";
	      elemsize = sizeof (Elf32_Conflict);
	      goto set_elemno;

	    case DT_MIPS_LIBLISTNO:
	      name = ".liblist";
	      elemsize = sizeof (Elf32_Lib);
	    set_elemno:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val = s->_cooked_size / elemsize;
		  else
		    dyn.d_un.d_val = s->_raw_size / elemsize;
		}
	      else
		    dyn.d_un.d_val = 0;

	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_TIME_STAMP:
	      time ((time_t *) &dyn.d_un.d_val);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	      
	    case DT_MIPS_ICHECKSUM:
	      /* XXX FIXME: */
	      break;

	    case DT_MIPS_IVERSION:
	      /* XXX FIXME: */
	      break;

	    case DT_MIPS_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(0xffff);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_SYMTABNO:
	      name = ".dynsym";
	      elemsize = sizeof (Elf32_External_Sym);
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size / elemsize;
	      else
		dyn.d_un.d_val = s->_raw_size / elemsize;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* XXX FIXME: */
	      dyn.d_un.d_val = SIZEOF_MIPS_DYNSYM_SECNAMES;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_GOTSYM:
	      dyn.d_un.d_val = g->global_gotsym;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    }
	}
    }

  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of Irix rld. */
  if (sgot->_raw_size > 0)
    {
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0x80000000, sgot->contents + 4);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

  {
    asection *sdynsym;
    asection *s;
    unsigned int i;
    bfd_vma last;
    Elf_Internal_Sym sym;
    long dindx;
    const char *name;
    const char * const * namep = mips_elf_dynsym_sec_names;
    Elf32_compact_rel cpt;

    /* Set up the section symbols for the output sections. SGI sets
       the STT_NOTYPE attribute for these symbols.  Should we do so?  */

    sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
    if (sdynsym != NULL)
      {
	if (SGI_COMPAT (output_bfd))
	  {
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
	    sym.st_other = 0;

	    i = 0;
	    while ((name = *namep++) != NULL)
	      {
		s = bfd_get_section_by_name (output_bfd, name);
		if (s != NULL)
		  {
		    sym.st_value = s->vma;
		    dindx = elf_section_data (s)->dynindx;
		    last = s->vma + s->_raw_size;
		  }
		else
		  {
		    sym.st_value = last;
		    dindx++;
		  }

		sym.st_shndx = (i < MIPS_TEXT_DYNSYM_SECNO
				? SHN_MIPS_TEXT
				: SHN_MIPS_DATA);
		++i;
		sym.st_name =
		  mips_elf_hash_table (info)->dynsym_sec_strindex[dindx];

		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + dindx));
	      }

	    /* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      SIZEOF_MIPS_DYNSYM_SECNAMES;
	  }
	else
	  {
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	    sym.st_other = 0;

	    for (s = output_bfd->sections; s != NULL; s = s->next)
	      {
		int indx;

		sym.st_value = s->vma;

		indx = elf_section_data (s)->this_idx;
		BFD_ASSERT (indx > 0);
		sym.st_shndx = indx;

		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));
	      }

	    /* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      bfd_count_sections (output_bfd) + 1;
	  }
      }

    if (SGI_COMPAT (output_bfd))
      {
	/* Write .compact_rel section out.  */
	s = bfd_get_section_by_name (dynobj, ".compact_rel");
	if (s != NULL)
	  {
	    cpt.id1 = 1;
	    cpt.num = s->reloc_count;
	    cpt.id2 = 2;
	    cpt.offset = (s->output_section->filepos
			  + sizeof (Elf32_External_compact_rel));
	    cpt.reserved0 = 0;
	    cpt.reserved1 = 0;
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt, 
					    ((Elf32_External_compact_rel *)
					     s->contents));

	    /* Clean up a dummy stub function entry in .text.  */
	    s = bfd_get_section_by_name (dynobj, ".stub");
	    if (s != NULL)
	      {
		file_ptr dummy_offset;

		BFD_ASSERT (s->_raw_size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->_raw_size - MIPS_FUNCTION_STUB_SIZE;
		memset (s->contents + dummy_offset, 0,
			MIPS_FUNCTION_STUB_SIZE);
	      }
	  }
      }

    /* Clean up a first relocation in .rel.dyn.  */
    s = bfd_get_section_by_name (dynobj, ".rel.dyn");
    if (s != NULL)
      memset (s->contents, 0, sizeof (Elf32_External_Rel));
  }

  return true;
}

/* This is almost identical to bfd_generic_get_... except that some
   MIPS relocations need to be handled specially.  Sigh.  */

static bfd_byte *
elf32_mips_get_relocated_section_contents (abfd, link_info, link_order, data,
					   relocateable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  /* Get enough memory to hold the stuff */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;

  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  if (reloc_size < 0)
    goto error_return;

  reloc_vector = (arelent **) bfd_malloc (reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
    goto error_return;

  /* read in the section */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 (PTR) data,
				 0,
				 input_section->_raw_size))
    goto error_return;

  /* We're not relaxing the section, so just copy the size info */
  input_section->_cooked_size = input_section->_raw_size;
  input_section->reloc_done = true;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;
d2873 1
a2873 2
	  else if ((*parent)->howto->special_function
		   == _bfd_mips_elf_gprel16_reloc)
d2941 1
a2941 2
#define bfd_elf32_bfd_get_relocated_section_contents \
  elf32_mips_get_relocated_section_contents
d2945 1
a2945 1
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap =
d2983 1
a2983 1
  _bfd_mips_elf_read_ecoff_info
a2993 1
#define elf_backend_type_change_ok	true
d2997 3
a2999 3
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_section_from_shdr	mips_elf32_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
d3001 3
a3003 6
					_bfd_mips_elf_section_from_bfd_section
#define elf_backend_section_processing	mips_elf32_section_processing
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_additional_program_headers \
					mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	mips_elf_modify_segment_map
d3005 2
a3006 2
					_bfd_mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap
d3009 2
a3010 2
#define bfd_elf32_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf32_set_section_contents	_bfd_mips_elf_set_section_contents
d3014 1
a3014 5
#define bfd_elf32_bfd_copy_private_bfd_data \
					_bfd_mips_elf_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
a3015 12
#define elf_backend_create_dynamic_sections \
					mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					mips_elf_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
					mips_elf_size_dynamic_sections
#define elf_backend_relocate_section	mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
					mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					mips_elf_finish_dynamic_sections
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d1241 1
d1489 1
a1489 1
      (void) bfd_default_set_arch_mach (abfd, bfd_arch_mips, 3000);
a1534 2
  const char *name;
  asection *sec;
d1567 1
a1567 1
      switch ((*hdrpp)->sh_type)
d1569 2
a1570 5
	case SHT_MIPS_LIBLIST:
	  sec = bfd_get_section_by_name (abfd, ".dynstr");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;
a1571 1
	case SHT_MIPS_GPTAB:
a1578 41
	  break;

	case SHT_MIPS_CONTENT:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && strncmp (name, ".MIPS.content",
				  sizeof ".MIPS.content" - 1) == 0);
	  sec = bfd_get_section_by_name (abfd,
					 name + sizeof ".MIPS.content" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_SYMBOL_LIB:
	  sec = bfd_get_section_by_name (abfd, ".dynsym");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  sec = bfd_get_section_by_name (abfd, ".liblist");
	  if (sec != NULL)
	    (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_EVENTS:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL);
	  if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0)
	    sec = bfd_get_section_by_name (abfd,
					   name + sizeof ".MIPS.events" - 1);
	  else
	    {
	      BFD_ASSERT (strncmp (name, ".MIPS.post_rel",
				   sizeof ".MIPS.post_rel" - 1) == 0);
	      sec = bfd_get_section_by_name (abfd,
					     (name
					      + sizeof ".MIPS.post_rel" - 1));
	    }
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;
a1659 3
      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
a1745 8
    case SHT_MIPS_IFACE:
      if (strcmp (name, ".MIPS.interfaces") != 0)
	return false;
      break;
    case SHT_MIPS_CONTENT:
      if (strncmp (name, ".MIPS.content", sizeof ".MIPS.content" - 1) != 0)
	return false;
      break;
a1754 4
    case SHT_MIPS_SYMBOL_LIB:
      if (strcmp (name, ".MIPS.symlib") != 0)
	return false;
      break;
d1756 1
a1756 3
      if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) != 0
	  && strncmp (name, ".MIPS.post_rel",
		      sizeof ".MIPS.post_rel" - 1) != 0)
d1869 1
a1869 1
      /* The sh_link field is set in final_write_processing.  */
a1925 10
  else if (strcmp (name, ".MIPS.interfaces") == 0)
    {
      hdr->sh_type = SHT_MIPS_IFACE;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strcmp (name, ".MIPS.content") == 0)
    {
      hdr->sh_type = SHT_MIPS_CONTENT;
      /* The sh_info field is set in final_write_processing.  */
    }
a1930 1
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
d1934 2
a1935 14
  else if (strcmp (name, ".MIPS.symlib") == 0)
    {
      hdr->sh_type = SHT_MIPS_SYMBOL_LIB;
      /* The sh_link and sh_info fields are set in
         final_write_processing.  */
    }
  else if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0
	   || strncmp (name, ".MIPS.post_rel",
		       sizeof ".MIPS.post_rel" - 1) == 0)
    {
      hdr->sh_type = SHT_MIPS_EVENTS;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_link field is set in final_write_processing.  */
    }
a2700 5
  /* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic
     entry is set to the address of __rld_obj_head as in Irix 5. */
  boolean use_rld_obj_head;
  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
  bfd_vma rld_value;
a2787 2
  ret->use_rld_obj_head = false;
  ret->rld_value = 0;
a2881 25
  if (SGI_COMPAT (abfd)
      && ! info->shared
      && info->hash->creator == abfd->xvec
      && strcmp (*namep, "__rld_obj_head") == 0)
    {
      struct elf_link_hash_entry *h;

      /* Mark __rld_obj_head as dynamic.  */
      h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, *namep, BSF_GLOBAL, *secp,
	      (bfd_vma) *valp, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
	return false;
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;

      mips_elf_hash_table (info)->use_rld_obj_head = true;
    }

d4419 1
a4419 2
		   || (elf_hash_table (info)->dynamic_sections_created
		       && h != NULL
a4653 11
  if (SGI_COMPAT (abfd)
      && !info->shared
      && bfd_get_section_by_name (abfd, ".rld_map") == NULL)
    {
      s = bfd_make_section (abfd, ".rld_map");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags & ~SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return false;
    }

a4709 24

      if (! mips_elf_hash_table (info)->use_rld_obj_head)
	{
	  /* __rld_map is a four byte word located in the .data section
	     and is filled in by the rtld to contain a pointer to
	     the _r_debug structure. Its symbol value will be set in
	     mips_elf_finish_dynamic_symbol.  */
	  s = bfd_get_section_by_name (abfd, ".rld_map");
	  BFD_ASSERT (s != NULL);

	  h = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, "__rld_map", BSF_GLOBAL, s,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	    return false;
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;

	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}
d4832 1
a4832 18
  if (dynobj == NULL)
    {
      sgot = NULL;
      g = NULL;
    }
  else
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      if (sgot == NULL)
	g = NULL;
      else
	{
	  BFD_ASSERT (elf_section_data (sgot) != NULL);
	  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	  BFD_ASSERT (g != NULL);
	}
    }

d4849 1
a4849 1
      if (dynobj == NULL || sgot == NULL)
d4859 1
a4859 2
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
a4861 13
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	      break;

	    case R_MIPS_32:
	    case R_MIPS_REL32:
	      if (dynobj == NULL
		  && (info->shared || h != NULL)
		  && (sec->flags & SEC_ALLOC) != 0)
		elf_hash_table (info)->dynobj = dynobj = abfd;
d4875 8
d4919 8
d4959 4
d4978 1
a4978 2
			  || ! bfd_set_section_alignment (dynobj, sreloc,
							  4))
d4980 1
a4980 10
		    }
		}
	      if (info->shared)
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section */
		  if (sreloc->_raw_size == 0)
		    {
a4984 1
		  sreloc->_raw_size += sizeof (Elf32_External_Rel);
d4986 3
a5061 6
      if (s->_raw_size == 0)
	{
	  /* Make room for a null element. */
	  s->_raw_size += sizeof (Elf32_External_Rel);
	  ++s->reloc_count;
	}
a5237 8
      else if (! info->shared
	       && ! mips_elf_hash_table (info)->use_rld_obj_head
	       && strncmp (name, ".rld_map", 8) == 0)
	{
	  /* We add a room for __rld_map. It will be filled in by the
	     rtld to contain a pointer to the _r_debug structure.  */
	  s->_raw_size += 4;
	}
d5280 2
a5281 10
	  if (SGI_COMPAT (output_bfd))
	    {
	      /* SGI object has the equivalence of DT_DEBUG in the
		 DT_MIPS_RLD_MAP entry.  */
	      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_MAP, 0))
		return false;
	    }
	  else
	    if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	      return false;
d5432 12
a5443 13
    if (sgot != NULL)
      {
	BFD_ASSERT (elf_section_data (sgot) != NULL);
	g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	BFD_ASSERT (g != NULL);

	/* If there are no global got symbols, fake the last symbol so
	   for safety.  */
	if (g->global_gotsym)
	  g->global_gotsym += c;
	else
	  g->global_gotsym = elf_hash_table (info)->dynsymcount - 1;
      }
a5590 22
  if (SGI_COMPAT (output_bfd)
      && ! info->shared)
    {
      if (! mips_elf_hash_table (info)->use_rld_obj_head
	  && strcmp (name, "__rld_map") == 0)
	{
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
	  sym->st_value = s->output_section->vma + s->output_offset;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, s->contents);
	  if (mips_elf_hash_table (info)->rld_value == 0)
	    mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
      else if (mips_elf_hash_table (info)->use_rld_obj_head
	       && strcmp (name, "__rld_obj_head") == 0)
	{
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
	  mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
    }

d5611 5
a5615 8
  if (sgot == NULL)
    g = NULL;
  else
    {
      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);
    }
a5621 1
      BFD_ASSERT (g != NULL);
a5754 5
	    case DT_MIPS_RLD_MAP:
	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

d5762 1
a5762 1
  if (sgot != NULL && sgot->_raw_size > 0)
d5768 1
a5768 2
  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d5891 1
a5891 1
    if (s != NULL && s->_raw_size > 0)
d6132 1
a6132 5

/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a43 2
static bfd_reloc_status_type mips32_64bit_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a58 1
static INLINE int elf_mips_isa PARAMS ((flagword));
d540 2
a541 17
  /* A 64 bit relocation.  This is used in 32 bit ELF when addresses
     are 64 bits long; the upper 32 bits are simply a sign extension.
     The fields of the howto should be the same as for R_MIPS_32,
     other than the type, name, and special_function.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a1227 47
/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are
   generated when addreses are 64 bits.  The upper 32 bits are a simle
   sign extension.  */

static bfd_reloc_status_type
mips32_64bit_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_reloc_status_type r;
  arelent reloc32;
  unsigned long val;
  bfd_size_type addr;

  r = bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			     input_section, output_bfd, error_message);
  if (r != bfd_reloc_continue)
    return r;

  /* Do a normal 32 bit relocation on the lower 32 bits.  */
  reloc32 = *reloc_entry;
  if (bfd_big_endian (abfd))
    reloc32.address += 4;
  reloc32.howto = &elf_mips_howto_table[R_MIPS_32];
  r = bfd_perform_relocation (abfd, &reloc32, data, input_section,
			      output_bfd, error_message);

  /* Sign extend into the upper 32 bits.  */
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc32.address);
  if ((val & 0x80000000) != 0)
    val = 0xffffffff;
  else
    val = 0;
  addr = reloc_entry->address;
  if (bfd_little_endian (abfd))
    addr += 4;
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);

  return r;
}

a1240 1
  { BFD_RELOC_64, R_MIPS_64 },
d1651 4
a1654 2
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
a1666 20
/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    }
  return 4;
}

d1692 4
a1695 2
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
a1718 1
	  old_flags &= ~EF_MIPS_PIC;
a1726 1
	  old_flags &= ~EF_MIPS_CPIC;
a1731 20
      /* Don't warn about mixing -mips1 and -mips2 code, or mixing
         -mips3 and -mips4 code.  They will normally use the same data
         sizes and calling conventions.  */
      if ((new_flags & EF_MIPS_ARCH) != (old_flags & EF_MIPS_ARCH))
	{
	  int new_isa, old_isa;

	  new_isa = elf_mips_isa (new_flags);
	  old_isa = elf_mips_isa (old_flags);
	  if ((new_isa == 1 || new_isa == 2)
	      ? (old_isa != 1 && old_isa != 2)
	      : (old_isa == 1 || old_isa == 2))
	    (*_bfd_error_handler)
	      ("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)",
	       bfd_get_filename (ibfd), new_isa, old_isa);

	  new_flags &= ~ EF_MIPS_ARCH;
	  old_flags &= ~ EF_MIPS_ARCH;
	}

d4298 1
a4298 5
		  if (r_type == R_MIPS_64 && bfd_big_endian (input_bfd))
		    r = _bfd_relocate_contents (howto, input_bfd,
						addend,
						contents + rel->r_offset + 4);
		  else if (r_type != R_MIPS_HI16 && r_type != R_MIPS_GOT16)
a4640 22
	    }
	  else if (r_type == R_MIPS_64)
	    {
	      bfd_size_type addr;
	      unsigned long val;

	      /* Do a 32 bit relocation, and sign extend to 64 bits.  */
	      addr = rel->r_offset;
	      if (bfd_big_endian (input_bfd))
		addr += 4;
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, addr, relocation,
					    addend);
	      val = bfd_get_32 (input_bfd, contents + addr);
	      if ((val & 0x80000000) != 0)
		val = 0xffffffff;
	      else
		val = 0;
	      addr = rel->r_offset;
	      if (bfd_little_endian (input_bfd))
		addr += 4;
	      bfd_put_32 (input_bfd, val, contents + addr);
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
d66 2
a67 2
static boolean mips_elf_is_local_label_name
  PARAMS ((bfd *, const char *));
d78 1
a78 1
static boolean mips_elf_relocate_got_local
a82 4
static bfd_reloc_status_type mips16_jump_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips16_gprel_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a87 3
static boolean mips_elf_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *));
a98 2
static boolean mips_elf_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a129 2
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
d301 1
a301 4
  R_MIPS_max,
  /* These relocs are used for the mips16.  */
  R_MIPS16_26 = 100,
  R_MIPS16_GPREL = 101
a686 55
/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
   is a hack to make the linker think that we need 64 bit values.  */
static reloc_howto_type elf_mips_ctor64_howto =
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false);		/* pcrel_offset */

/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 false);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  The src_mask and
   dsk_mask for this howto do not reflect the actual instruction, in
   which the value is not contiguous; the masks are for the
   convenience of the relocate_section routine.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false);		/* pcrel_offset */

a1292 131
/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	("Linking mips16 objects into %s format is not supported",
	 bfd_get_target (input_section->output_section->owner));
    warned = true;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend, insn;
  unsigned long final;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocateable = true;
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (((extend & 0x1f) << 11)
	       | (extend & 0x7e0)
	       | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			 relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      ((extend & 0xf800)
	       | ((final >> 11) & 0x1f)
	       | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      ((insn & 0xffe0)
	       | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);

  return ret;
}

/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    }
  return 4;
}

d1305 1
a1335 19

  /* We need to handle BFD_RELOC_CTOR specially.  If this is a mips3
     file, then we assume that we are using 64 bit addresses, and use
     R_MIPS_64.  Otherwise, we use R_MIPS_32.  */
  if (code == BFD_RELOC_CTOR)
    {
      if (elf_mips_isa (elf_elfheader (abfd)->e_flags) < 3)
	return &elf_mips_howto_table[(int) R_MIPS_32];
      else
	return &elf_mips_ctor64_howto;
    }

  /* Special handling for the MIPS16 relocs, since they are made up
     reloc types with a large value.  */
  if (code == BFD_RELOC_MIPS16_JMP)
    return &elf_mips16_jump_howto;
  else if (code == BFD_RELOC_MIPS16_GPREL)
    return &elf_mips16_gprel_howto;

d1350 2
a1351 9
  if (r_type == R_MIPS16_26)
    cache_ptr->howto = &elf_mips16_jump_howto;
  else if (r_type == R_MIPS16_GPREL)
    cache_ptr->howto = &elf_mips16_gprel_howto;
  else
    {
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      cache_ptr->howto = &elf_mips_howto_table[r_type];
    }
d1731 20
a1760 1
  boolean ok;
d1784 1
a1784 1
  if (! elf_flags_init (obfd))
a1787 1

d1790 9
d1800 5
a1804 3
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return false;
d1807 1
a1807 45
      return true;
    }

  /* Check flag compatibility.  */

  new_flags &= ~EF_MIPS_NOREORDER;
  old_flags &= ~EF_MIPS_NOREORDER;

  if (new_flags == old_flags)
    return true;

  ok = true;

  if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
    {
      new_flags &= ~EF_MIPS_PIC;
      old_flags &= ~EF_MIPS_PIC;
      (*_bfd_error_handler)
	("%s: linking PIC files with non-PIC files",
	 bfd_get_filename (ibfd));
      ok = false;
    }

  if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
    {
      new_flags &= ~EF_MIPS_CPIC;
      old_flags &= ~EF_MIPS_CPIC;
      (*_bfd_error_handler)
	("%s: linking abicalls files with non-abicalls files",
	 bfd_get_filename (ibfd));
      ok = false;
    }

  /* Don't warn about mixing -mips1 and -mips2 code, or mixing -mips3
     and -mips4 code.  They will normally use the same data sizes and
     calling conventions.  */
  if ((new_flags & EF_MIPS_ARCH) != (old_flags & EF_MIPS_ARCH))
    {
      int new_isa, old_isa;

      new_isa = elf_mips_isa (new_flags);
      old_isa = elf_mips_isa (old_flags);
      if ((new_isa == 1 || new_isa == 2)
	  ? (old_isa != 1 && old_isa != 2)
	  : (old_isa == 1 || old_isa == 2))
d1809 2
d1812 2
a1813 3
	    ("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)",
	     bfd_get_filename (ibfd), new_isa, old_isa);
	  ok = false;
d1816 26
a1841 13
      new_flags &= ~ EF_MIPS_ARCH;
      old_flags &= ~ EF_MIPS_ARCH;
    }

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)",
	 bfd_get_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = false;
    }
a1842 2
  if (! ok)
    {
d2333 1
a2333 1
   allocated common symbol which may be overridden by a
d2499 1
a2499 1

d2754 1
a2754 1
mips_elf_is_local_label_name (abfd, name)
d2756 1
a2756 1
     const char *name;
d2758 1
a2758 6
  if (name[0] == '$')
    return true;

  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
a2865 38
  /* The mips16 compiler uses a couple of special sections to handle
     floating point arguments.

     Section names that look like .mips16.fn.FNNAME contain stubs that
     copy floating point arguments from the fp regs to the gp regs and
     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
     call should be redirected to the stub instead.  If no 32 bit
     function calls FNNAME, the stub should be discarded.  We need to
     consider any reference to the function, not just a call, because
     if the address of the function is taken we will need the stub,
     since the address might be passed to a 32 bit function.

     Section names that look like .mips16.call.FNNAME contain stubs
     that copy floating point arguments from the gp regs to the fp
     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
     then any 16 bit function that calls FNNAME should be redirected
     to the stub instead.  If FNNAME is not a 32 bit function, the
     stub should be discarded.

     .mips16.call.fp.FNNAME sections are similar, but contain stubs
     which call FNNAME and then copy the return value from the fp regs
     to the gp regs.  These stubs store the return value in $18 while
     calling FNNAME; any function which might call one of these stubs
     must arrange to save $18 around the call.  (This case is not
     needed for 32 bit functions that call 16 bit functions, because
     16 bit functions always return floating point values in both
     $f0/$f1 and $2/$3.)

     Note that in all cases FNNAME might be defined statically.
     Therefore, FNNAME is not used literally.  Instead, the relocation
     information will indicate which symbol the section is for.

     We record any stubs that we find in the symbol table.  */

#define FN_STUB ".mips16.fn."
#define CALL_STUB ".mips16.call."
#define CALL_FP_STUB ".mips16.call.fp."

a2877 16

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
a2895 2
  /* This is set if we see any mips16 stub sections. */
  boolean mips16_stubs_seen;
a2952 4
      ret->fn_stub = NULL;
      ret->need_fn_stub = false;
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
a2984 1
  ret->mips16_stubs_seen = false;
d3034 1
d3043 4
a3046 4
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = mips_elf_text_section_ptr;
d3059 1
d3068 4
a3071 4
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = mips_elf_data_section_ptr;
a3103 6
  /* If this is a mips16 text symbol, add 1 to the value to make it
     odd.  This will cause something like .word SYM to come up with
     the right value when it is loaded into the PC.  */
  if (sym->st_other == STO_MIPS16)
    ++*valp;

d3219 1
a3219 1

d3285 1
a3285 1
    }
d3680 1
a3680 1

d3798 1
a3798 1
				    | SEC_LINKER_CREATED | SEC_READONLY);
d3803 1
a3803 1
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))
d4148 1
a4148 1
static boolean
d4159 2
a4160 2
  unsigned int assigned_gotno;
  unsigned int i;
d4185 1
a4185 1
  assigned_gotno = g->assigned_gotno;
d4189 1
a4189 1
  for (i = MIPS_RESERVED_GOTNO; i < assigned_gotno; i++)
d4194 1
a4194 5
    }

  if (i == assigned_gotno)
    {
      if (assigned_gotno >= g->local_gotno)
d4196 2
a4197 4
	  (*_bfd_error_handler)
	    ("more got entries are needed for hipage relocations");
	  bfd_set_error (bfd_error_bad_value);
	  return false;
d4199 1
d4201 7
a4207 3
      bfd_put_32 (input_bfd, hipage, got_contents + assigned_gotno * 4);
      ++g->assigned_gotno;
    }
a4211 2

  return true;
a4289 2
      struct mips_elf_link_hash_entry *mh;
      int other;
d4293 1
a4293 3
      if ((r_type < 0 || r_type >= (int) R_MIPS_max)
	  && r_type != R_MIPS16_26
	  && r_type != R_MIPS16_GPREL)
d4298 1
a4298 6
      if (r_type == R_MIPS16_26)
	howto = &elf_mips16_jump_howto;
      else if (r_type == R_MIPS16_GPREL)
	howto = &elf_mips16_gprel_howto;
      else
	howto = elf_mips_howto_table + r_type;
d4324 1
a4324 2
	  && r_type != R_MIPS_GPREL32
	  && r_type != R_MIPS16_GPREL)
a4465 4

	      /* mips16 text labels should be treated as odd.  */
	      if (sym->st_other == STO_MIPS16)
		++relocation;
a4543 92
	  mh = (struct mips_elf_link_hash_entry *) h;
	  if (h != NULL)
	    other = h->other;
	  else if (sym != NULL)
	    other = sym->st_other;
	  else
	    other = 0;

	  /* If this function has an fn_stub, then it is a mips16
	     function which needs a stub if it is called by a 32 bit
	     function.  If this reloc is anything other than a 16 bit
	     call, redirect the reloc to the stub.  We don't redirect
	     relocs from other stub functions.  */
	  if (r_type != R_MIPS16_26
	      && ((mh != NULL
		   && mh->fn_stub != NULL)
		  || (mh == NULL
		      && elf_tdata (input_bfd)->local_stubs != NULL
		      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  FN_STUB, sizeof FN_STUB - 1) != 0
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  CALL_STUB, sizeof CALL_STUB - 1) != 0
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  CALL_FP_STUB, sizeof CALL_FP_STUB - 1) != 0)
	    {
	      if (mh != NULL)
		{
		  BFD_ASSERT (mh->need_fn_stub);
		  relocation = (mh->fn_stub->output_section->vma
				+ mh->fn_stub->output_offset);
		}
	      else
		{
		  asection *fn_stub;

		  fn_stub = elf_tdata (input_bfd)->local_stubs[r_symndx];
		  relocation = (fn_stub->output_section->vma
				+ fn_stub->output_offset);
		}

	      /* RELOCATION now points to 32 bit code.  */
	      other = 0;
	    }

	  /* If this function has a call_stub, then it is called by a
             mips16 function; the call needs to go through a stub if
             this function is a 32 bit function.  If this reloc is a
             16 bit call, and the symbol is not a 16 bit function,
             then redirect the reloc to the stub.  Note that we don't
             need to worry about calling the function through a
             function pointer; such calls are handled by routing
             through a special mips16 routine.  We don't have to check
             whether this call is from a stub; it can't be, because a
             stub contains 32 bit code, and hence can not have a 16
             bit reloc.  */
	  if (r_type == R_MIPS16_26
	      && mh != NULL
	      && (mh->call_stub != NULL || mh->call_fp_stub != NULL)
	      && other != STO_MIPS16)
	    {
	      asection *stub;

	      /* If both call_stub and call_fp_stub are defined, we
                 can figure out which one to use by seeing which one
                 appears in the input file.  */
	      if (mh->call_stub != NULL && mh->call_fp_stub != NULL)
		{
		  asection *o;

		  stub = NULL;
		  for (o = input_bfd->sections; o != NULL; o = o->next)
		    {
		      if (strncmp (bfd_get_section_name (input_bfd, o),
				   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
			{
			  stub = mh->call_fp_stub;
			  break;
			}
		    }
		  if (stub == NULL)
		    stub = mh->call_stub;
		}
	      else if (mh->call_stub != NULL)
		stub = mh->call_stub;
	      else
		stub = mh->call_fp_stub;

	      BFD_ASSERT (stub->_raw_size > 0);
	      relocation = stub->output_section->vma + stub->output_offset;
	    }

d4581 4
a4584 5
		  if (! mips_elf_relocate_got_local (output_bfd, input_bfd,
						     sgot, rel, rel + 1,
						     contents,
						     relocation + addend))
		    return false;
a4650 2
		  boolean skip;

d4660 3
a4662 20
		  skip = false;

		  if (elf_section_data (input_section)->stab_info == NULL)
		    outrel.r_offset = rel->r_offset;
		  else
		    {
		      bfd_vma off;

		      off = (_bfd_stab_section_offset
			     (output_bfd, &elf_hash_table (info)->stab_info,
			      input_section,
			      &elf_section_data (input_section)->stab_info,
			      rel->r_offset));
		      if (off == (bfd_vma) -1)
			skip = true;
		      outrel.r_offset = off;
		    }

		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);
d4666 4
a4669 6
		  if (skip)
		    memset (&outrel, 0, sizeof outrel);
		  else if (h != NULL
			   && (! info->symbolic
			       || (h->elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
d4709 1
a4709 3
		  if (! skip)
		    bfd_put_32 (output_bfd, addend, contents + rel->r_offset);

d4716 1
a4716 1
		  if (! skip && SGI_COMPAT (output_bfd))
a4771 103
	  else if (r_type == R_MIPS_26 && other == STO_MIPS16)
	    {
	      unsigned long insn;

	      /* This is a jump to a mips16 routine from a mips32
                 routine.  We need to change jal into jalx.  */
	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if (((insn >> 26) & 0x3f) != 0x3
		  && ((insn >> 26) & 0x3f) != 0x1d)
		{
		  (*_bfd_error_handler)
		    ("%s: %s+0x%lx: jump to mips16 routine which is not jal",
		     bfd_get_filename (input_bfd),
		     input_section->name,
		     (unsigned long) rel->r_offset);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}
	      insn = (insn & 0x3ffffff) | (0x1d << 26);
	      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, rel->r_offset,
					    relocation, addend);
	    }
	  else if (r_type == R_MIPS16_26)
	    {
	      /* It's easiest to do the normal relocation, and then
                 dig out the instruction and swap the first word the
                 way the mips16 expects it.  If this is little endian,
                 though, we need to swap the two words first, and then
                 swap them back again later, so that the address looks
                 right.  */

	      if (bfd_little_endian (input_bfd))
		{
		  unsigned long insn;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn = ((insn >> 16) & 0xffff) | ((insn & 0xffff) << 16);
		  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
		}

	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, rel->r_offset,
					    relocation, addend);
	      if (r == bfd_reloc_ok)
		{
		  unsigned long insn;

		  if (bfd_little_endian (input_bfd))
		    {
		      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      insn = ((insn >> 16) & 0xffff) | ((insn & 0xffff) << 16);
		      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
		    }

		  insn = bfd_get_16 (input_bfd, contents + rel->r_offset);
		  insn = ((insn & 0xfc00)
			  | ((insn & 0x1f) << 5)
			  | ((insn & 0x3e0) >> 5));
		  /* If this is a jump to a 32 bit routine, then make
		     it jalx.  */
		  if (other != STO_MIPS16)
		    insn |= 0x400;
		  bfd_put_16 (input_bfd, insn, contents + rel->r_offset);
		}
	    }
	  else if (r_type == R_MIPS16_GPREL)
	    {
	      unsigned short extend, insn;
	      bfd_byte buf[4];
	      unsigned long final;

	      /* Extract the addend into buf, run the regular reloc,
                 and stuff the resulting value back into the
                 instructions.  */
	      if (rel->r_offset > input_section->_raw_size)
		r = bfd_reloc_outofrange;
	      else
		{
		  extend = bfd_get_16 (input_bfd, contents + rel->r_offset);
		  insn = bfd_get_16 (input_bfd, contents + rel->r_offset + 2);
		  bfd_put_32 (input_bfd,
			      (((extend & 0x1f) << 11)
			       | (extend & 0x7e0)
			       | (insn & 0x1f)),
			      buf);
		  r = _bfd_final_link_relocate (howto, input_bfd,
						input_section, buf,
						(bfd_vma) 0, relocation,
						addend);
		  final = bfd_get_32 (input_bfd, buf);
		  bfd_put_16 (input_bfd,
			      ((extend & 0xf800)
			       | ((final >> 11) & 0x1f)
			       | (final & 0x7e0)),
			      contents + rel->r_offset);
		  bfd_put_16 (input_bfd,
			      ((insn & 0xffe0)
			       | (final & 0x1f)),
			      contents + rel->r_offset + 2);
		}
	    }
a4776 21
	  /* The jal instruction can only jump to an address which is
             divisible by 4, and it can only jump to an address with
             the same upper 4 bits as the PC.  */
	  if (r == bfd_reloc_ok
	      && (r_type == R_MIPS16_26 || r_type == R_MIPS_26))
	    {
	      bfd_vma addr;

	      addr = relocation;
	      if (other == STO_MIPS16)
		addr &= ~ (bfd_vma) 1;
	      addr += addend;
	      if ((addr & 3) != 0
		  || ((addr & 0xf0000000)
		      != ((input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset)
			  & 0xf0000000)))
		r = bfd_reloc_overflow;
	    }

a4857 19

/* This hook function is called before the linker writes out a global
   symbol.  This is where we undo the increment of the value for a
   mips16 symbol.  */

/*ARGSIGNORED*/
static boolean
mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection *input_sec;
{
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;
  return true;
}
d4879 1
a4879 1
	   | SEC_LINKER_CREATED | SEC_READONLY);
d4964 1
a4964 1
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d5011 1
a5011 2
      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED
	       | SEC_READONLY);
d5024 1
a5024 1

d5041 1
a5041 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
a5075 1
  g->assigned_gotno = MIPS_RESERVED_GOTNO;
a5097 1
  const char *name;
a5115 158
  /* Check for the mips16 stub sections.  */

  name = bfd_get_section_name (abfd, sec);
  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
    {
      unsigned long r_symndx;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF32_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  asection *o;

	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation in this BFD, other
             than a 16 bit function call, which refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;

	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
			      sizeof FN_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
			      sizeof CALL_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
			      sizeof CALL_FP_STUB - 1) == 0)
		continue;

	      sec_relocs = (_bfd_elf32_link_read_relocs
			    (abfd, o, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL,
			     info->keep_memory));
	      if (sec_relocs == NULL)
		return false;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF32_R_SYM (r->r_info) == r_symndx
		    && ELF32_R_TYPE (r->r_info) != R_MIPS16_26)
		  break;

	      if (! info->keep_memory)
		free (sec_relocs);

	      if (r < rend)
		break;
	    }

	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return true;
	    }

	  /* Record this stub in an array of local symbol stubs for
             this BFD. */
	  if (elf_tdata (abfd)->local_stubs == NULL)
	    {
	      unsigned long symcount;
	      asection **n;

	      if (elf_bad_symtab (abfd))
		symcount = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
	      else
		symcount = symtab_hdr->sh_info;
	      n = (asection **) bfd_zalloc (abfd,
					    symcount * sizeof (asection *));
	      if (n == NULL)
		return false;
	      elf_tdata (abfd)->local_stubs = n;
	    }

	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
	}
      else
	{
	  struct mips_elf_link_hash_entry *h;

	  h = ((struct mips_elf_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  /* H is the symbol this stub is for.  */

	  h->fn_stub = sec;
	  mips_elf_hash_table (info)->mips16_stubs_seen = true;
	}
    }
  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
    {
      unsigned long r_symndx;
      struct mips_elf_link_hash_entry *h;
      asection **loc;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF32_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  /* This stub was actually built for a static symbol defined
	     in the same file.  We assume that all static symbols in
	     mips16 code are themselves mips16, so we can simply
	     discard this stub.  Since this function is called before
	     the linker maps input sections to output sections, we can
	     easily discard it by setting the SEC_EXCLUDE flag.  */
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      h = ((struct mips_elf_link_hash_entry *)
	   sym_hashes[r_symndx - extsymoff]);

      /* H is the symbol this stub is for.  */

      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
	loc = &h->call_fp_stub;
      else
	loc = &h->call_stub;

      /* If we already have an appropriate stub for this function, we
	 don't need another one, so we can discard this one.  Since
	 this function is called before the linker maps input sections
	 to output sections, we can easily discard it by setting the
	 SEC_EXCLUDE flag.  We can also discard this section if we
	 happen to already know that this is a mips16 function; it is
	 not necessary to check this here, as it is checked later, but
	 it is slightly faster to check now.  */
      if (*loc != NULL || h->root.other == STO_MIPS16)
	{
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      *loc = sec;
      mips_elf_hash_table (info)->mips16_stubs_seen = true;
    }

d5147 1
a5147 10
	{
	  h = sym_hashes[r_symndx - extsymoff];

	  /* This may be an indirect symbol created because of a version.  */
	  if (h != NULL)
	    {
	      while (h->root.type == bfd_link_hash_indirect)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	}
d5191 1
a5191 8
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		("%s: CALL16 reloc at 0x%lx not against global symbol",
		 bfd_get_filename (abfd), (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
a5271 1
						       | SEC_LINKER_CREATED
a5320 18

      /* If this reloc is not a 16 bit call, and it has a global
         symbol, then we will need the fn_stub if there is one.
         References from a stub section do not count. */
      if (h != NULL
	  && ELF32_R_TYPE (rel->r_info) != R_MIPS16_26
	  && strncmp (bfd_get_section_name (abfd, sec), FN_STUB,
		      sizeof FN_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_STUB,
		      sizeof CALL_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_FP_STUB,
		      sizeof CALL_FP_STUB - 1) != 0)
	{
	  struct mips_elf_link_hash_entry *mh;

	  mh = (struct mips_elf_link_hash_entry *) h;
	  mh->need_fn_stub = true;
	}
a5423 74
/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  We
   check for any mips16 stub sections that we can discard.  */

static boolean mips_elf_check_mips16_stubs
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));

static boolean
mips_elf_always_size_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  if (info->relocateable
      || ! mips_elf_hash_table (info)->mips16_stubs_seen)
    return true;

  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_check_mips16_stubs,
			       (PTR) NULL);

  return true;
}

/* Check the mips16 stubs for a particular symbol, and see if we can
   discard them.  */

/*ARGSUSED*/
static boolean
mips_elf_check_mips16_stubs (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  if (h->fn_stub != NULL
      && ! h->need_fn_stub)
    {
      /* We don't need the fn_stub; the only references to this symbol
         are 16 bit calls.  Clobber the size to 0 to prevent it from
         being included in the link.  */
      h->fn_stub->_raw_size = 0;
      h->fn_stub->_cooked_size = 0;
      h->fn_stub->flags &= ~ SEC_RELOC;
      h->fn_stub->reloc_count = 0;
      h->fn_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_stub->_raw_size = 0;
      h->call_stub->_cooked_size = 0;
      h->call_stub->flags &= ~ SEC_RELOC;
      h->call_stub->reloc_count = 0;
      h->call_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_fp_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_fp_stub->_raw_size = 0;
      h->call_fp_stub->_cooked_size = 0;
      h->call_fp_stub->flags &= ~ SEC_RELOC;
      h->call_fp_stub->reloc_count = 0;
      h->call_fp_stub->flags |= SEC_EXCLUDE;
    }

  return true;
}

d5497 1
a5497 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
a5507 1
	      const char *outname;
d5516 1
a5516 3
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 4);
d5518 1
a5518 1
		  || strcmp (outname, ".rel.dyn") == 0)
d5908 1
a5908 1
      else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
a5938 5
  /* If this is a mips16 symbol, force the value to be even.  */
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;

d6057 1
a6057 1

d6229 1
a6229 1
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt,
d6514 1
a6514 2
#define bfd_elf32_bfd_is_local_label_name \
					mips_elf_is_local_label_name
a6530 2
#define elf_backend_always_size_sections \
					mips_elf_always_size_sections
a6533 2
#define elf_backend_link_output_symbol_hook \
					mips_elf_link_output_symbol_hook
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
a5 2
   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>
a43 51
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
};

/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */

struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against
     this symbol.  */ 
  unsigned int possibly_dynamic_relocs;

  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
};

a47 2
static reloc_howto_type *mips_rtype_to_howto
  PARAMS ((unsigned int));
a49 2
static void mips_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
a53 6
#if 0
static void bfd_mips_elf_swap_msym_in 
  PARAMS ((bfd *, const Elf32_External_Msym *, Elf32_Internal_Msym *));
#endif
static void bfd_mips_elf_swap_msym_out
  PARAMS ((bfd *, const Elf32_Internal_Msym *, Elf32_External_Msym *));
d55 1
d59 2
d62 4
a65 2
static INLINE int elf_mips_mach PARAMS ((flagword));
static INLINE char* elf_mips_abi_name PARAMS ((bfd *));
d70 2
d73 10
d87 10
d101 17
d123 19
a141 146
static asection *mips_elf_create_msym_section 
  PARAMS ((bfd *));
static void mips_elf_irix6_finish_dynamic_symbol 
  PARAMS ((bfd *, const char *, Elf_Internal_Sym *));
static bfd_vma mips_elf_sign_extend PARAMS ((bfd_vma, int));
static boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
static bfd_vma mips_elf_high PARAMS ((bfd_vma));
static bfd_vma mips_elf_higher PARAMS ((bfd_vma));
static bfd_vma mips_elf_highest PARAMS ((bfd_vma));
static bfd_vma mips_elf_global_got_index
  PARAMS ((bfd *, struct elf_link_hash_entry *));
static bfd_vma mips_elf_local_got_index
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static bfd_vma mips_elf_got_offset_from_index
  PARAMS ((bfd *, bfd *, bfd_vma));
static boolean mips_elf_record_global_got_symbol 
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *,
	   struct mips_got_info *));
static bfd_vma mips_elf_got_page
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
static const Elf_Internal_Rela *mips_elf_next_relocation
  PARAMS ((unsigned int, const Elf_Internal_Rela *, 
	   const Elf_Internal_Rela *));
static bfd_reloc_status_type mips_elf_calculate_relocation
  PARAMS ((bfd *, bfd *, asection *, struct bfd_link_info *,
	   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
	   boolean *));
static bfd_vma mips_elf_obtain_contents
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *));
static boolean mips_elf_perform_relocation
  PARAMS ((struct bfd_link_info *, reloc_howto_type *, 
	   const Elf_Internal_Rela *, bfd_vma,
	   bfd *, asection *, bfd_byte *, boolean));
static boolean mips_elf_assign_gp PARAMS ((bfd *, bfd_vma *));
static boolean mips_elf_sort_hash_table_f 
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
static boolean mips_elf_sort_hash_table 
  PARAMS ((struct bfd_link_info *, unsigned long));
static asection * mips_elf_got_section PARAMS ((bfd *));
static struct mips_got_info *mips_elf_got_info 
  PARAMS ((bfd *, asection **));
static boolean mips_elf_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **));
static bfd_vma mips_elf_create_local_got_entry 
  PARAMS ((bfd *, struct mips_got_info *, asection *, bfd_vma));
static bfd_vma mips_elf_got16_entry 
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static boolean mips_elf_create_dynamic_relocation 
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
	   struct mips_elf_link_hash_entry *, asection *,
	   bfd_vma, bfd_vma *, asection *));
static void mips_elf_allocate_dynamic_relocations 
  PARAMS ((bfd *, unsigned int));
static boolean mips_elf_stub_section_p 
  PARAMS ((bfd *, asection *));

/* The level of IRIX compatibility we're striving for.  */

typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;

/* Nonzero if ABFD is using the N32 ABI.  */

#define ABI_N32_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI2) != 0)

/* Nonzero if ABFD is using the 64-bit ABI.  FIXME: This is never
   true, yet.  */
#define ABI_64_P(abfd) \
  ((elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64) != 0)

/* What version of Irix we are trying to be compatible with.  FIXME:
   At the moment, we never generate "normal" MIPS ELF ABI executables;
   we always use some version of Irix.  */

#define IRIX_COMPAT(abfd) \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5)

/* Whether we are trying to be compatible with IRIX at all.  */

#define SGI_COMPAT(abfd) \
  (IRIX_COMPAT (abfd) != ict_none)

/* The name of the msym section.  */
#define MIPS_ELF_MSYM_SECTION_NAME(abfd) ".msym"

/* The name of the srdata section.  */
#define MIPS_ELF_SRDATA_SECTION_NAME(abfd) ".srdata"

/* The name of the options section.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.options" : ".options")

/* The name of the stub section.  */
#define MIPS_ELF_STUB_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.stubs" : ".stub")

/* The name of the dynamic relocation section.  */
#define MIPS_ELF_REL_DYN_SECTION_NAME(abfd) ".rel.dyn"

/* The size of an external REL relocation.  */
#define MIPS_ELF_REL_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rel)

/* The size of an external dynamic table entry.  */
#define MIPS_ELF_DYN_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_dyn)

/* The size of a GOT entry.  */
#define MIPS_ELF_GOT_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

/* The size of a symbol-table entry.  */
#define MIPS_ELF_SYM_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_sym)

/* The default alignment for sections, as a power of two.  */
#define MIPS_ELF_LOG_FILE_ALIGN(abfd)				\
  (get_elf_backend_data (abfd)->s->file_align == 8 ? 3 : 2)

/* Get word-sized data.  */
#define MIPS_ELF_GET_WORD(abfd, ptr) \
  (ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))

/* Put out word-sized data.  */
#define MIPS_ELF_PUT_WORD(abfd, val, ptr)	\
  (ABI_64_P (abfd) 				\
   ? bfd_put_64 (abfd, val, ptr) 		\
   : bfd_put_32 (abfd, val, ptr))

/* Add a dynamic symbol table-entry.  */
#ifdef BFD64
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? bfd_elf64_add_dynamic_entry (info, tag, val)  \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#else
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? (abort (), false)                             \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#endif
d149 3
a151 5
#define STUB_LW(abfd)						\
  (SGI_COMPAT (abfd)						\
   ? (ABI_64_P (abfd)  						\
      ? 0xdf998010		/* ld t9,0x8010(gp) */		\
      : 0x8f998010)             /* lw t9,0x8010(gp) */		\
a157 5
#if 0
/* We no longer try to identify particular sections for the .dynsym
   section.  When we do, we wind up crashing if there are other random
   sections with relocations.  */

a181 2
#endif /* 0 */

d291 26
a316 3
/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)
d469 1
a469 1
	 0xffff,		/* src_mask */
d486 1
a486 1
	 true),			/* pcrel_offset */
d489 1
d500 1
a500 1
	 0xffff,		/* src_mask */
d521 3
a523 3
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
d557 4
a560 1
  /* A 64 bit relocation.  */
d563 2
a564 2
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
d571 2
a572 2
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
d576 1
d592 1
d608 1
d624 1
d640 1
d655 2
a656 14
  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 true,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */
d659 8
a666 33
  EMPTY_HOWTO (R_MIPS_INSERT_A),
  EMPTY_HOWTO (R_MIPS_INSERT_B),
  EMPTY_HOWTO (R_MIPS_DELETE),

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d669 1
d685 1
d698 1
a698 37
	 false),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MIPS_SCN_DISP,       /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",     /* name */
	 false,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  EMPTY_HOWTO (R_MIPS_REL16),
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),
  EMPTY_HOWTO (R_MIPS_RELGOT),

  /* Protected jump conversion.  This is an optimization hint.  No 
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 false,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 false),		/* pcrel_offset */
d710 1
a710 1
	 complain_overflow_signed, /* complain_on_overflow */
d737 4
a740 1
/* The reloc used for the mips16 gprel instruction.  */
a751 50
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 false);		/* pcrel_offset */


/* GNU extensions for embedded-pic.  */
/* High 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_hi16 =
  HOWTO (R_MIPS_GNU_REL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
	 "R_MIPS_GNU_REL_HI16",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* Low 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_lo16 =
  HOWTO (R_MIPS_GNU_REL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
	 "R_MIPS_GNU_REL_LO16",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 true,			/* partial_inplace */
a753 64
	 true);			/* pcrel_offset */

/* 64 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel64 =
  HOWTO (R_MIPS_PC64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC64",		/* name */
	 true,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 true);			/* pcrel_offset */

/* 32 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d784 1
a784 1
     bfd *abfd ATTRIBUTE_UNUSED;
a1014 51
/* Set the GP value for OUTPUT_BFD.  Returns false if this is a
   dangerous relocation.  */

static boolean
mips_elf_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return true;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == (asymbol **) NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register CONST char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return false;
    }

  return true;
}

d1047 1
a1047 1
      else if (!mips_elf_assign_gp (output_bfd, pgp))
d1049 34
a1082 3
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
d1240 1
a1240 1
	_("32bits gp relative relocation occurs for an external symbol");
d1367 1
a1367 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1370 1
a1370 1
     PTR data ATTRIBUTE_UNUSED;
d1373 1
a1373 1
     char **error_message ATTRIBUTE_UNUSED;
d1389 1
a1389 1
	(_("Linking mips16 objects into %s format is not supported"),
a1492 79
/* Return the MACH for a MIPS e_flags value.  */

static INLINE int
elf_mips_mach (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_MACH)
    {
    case E_MIPS_MACH_3900:
      return bfd_mach_mips3900;

    case E_MIPS_MACH_4010:
      return bfd_mach_mips4010;

    case E_MIPS_MACH_4100:
      return bfd_mach_mips4100;

    case E_MIPS_MACH_4111:
      return bfd_mach_mips4111;

    case E_MIPS_MACH_4650:
      return bfd_mach_mips4650;

    default:
      switch (flags & EF_MIPS_ARCH)
	{
	default:
	case E_MIPS_ARCH_1:
	  return bfd_mach_mips3000;
	  break;

	case E_MIPS_ARCH_2:
	  return bfd_mach_mips6000;
	  break;

	case E_MIPS_ARCH_3:
	  return bfd_mach_mips4000;
	  break;

	case E_MIPS_ARCH_4:
	  return bfd_mach_mips8000;
	  break;
	}
    }

  return 0;
}

/* Return printable name for ABI. */

static INLINE char*
elf_mips_abi_name (abfd)
     bfd *abfd;
{
  flagword flags;

  if (ABI_N32_P (abfd))
    return "N32";
  else if (ABI_64_P (abfd))
    return "64";
      
  flags = elf_elfheader (abfd)->e_flags;
  switch (flags & EF_MIPS_ABI)
    {
    case 0:
      return "none";
    case E_MIPS_ABI_O32:
      return "O32";
    case E_MIPS_ABI_O64:
      return "O64";
    case E_MIPS_ABI_EABI32:
      return "EABI32";
    case E_MIPS_ABI_EABI64:
      return "EABI64";
    default:
      return "unknown abi";
    }
}

d1497 1
a1497 1
  enum elf_mips_reloc_type elf_reloc_val;
d1518 1
a1518 5
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
d1536 4
a1539 1
  switch (code)
d1541 1
a1541 9
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;

    case BFD_RELOC_CTOR:
      /* We need to handle BFD_RELOC_CTOR specially.
	 Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the
	 size of addresses on this architecture.  */
      if (bfd_arch_bits_per_address (abfd) == 32)
a1544 19

    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_PCREL_HI16_S:
      return &elf_mips_gnu_rel_hi16;
    case BFD_RELOC_PCREL_LO16:
      return &elf_mips_gnu_rel_lo16;
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rel16_s2;
    case BFD_RELOC_64_PCREL:
      return &elf_mips_gnu_pcrel64;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
a1545 1
}
d1547 6
a1552 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1554 1
a1554 39
static reloc_howto_type *
mips_rtype_to_howto (r_type)
     unsigned int r_type;
{
  switch (r_type)
    {
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
      break;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
      break;
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
      break;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
      break;
    case R_MIPS_GNU_REL_HI16:
      return &elf_mips_gnu_rel_hi16;
      break;
    case R_MIPS_GNU_REL_LO16:
      return &elf_mips_gnu_rel_lo16;
      break;
    case R_MIPS_GNU_REL16_S2:
      return &elf_mips_gnu_rel16_s2;
      break;
    case R_MIPS_PC64:
      return &elf_mips_gnu_pcrel64;
      break;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
      break;

    default:
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      return &elf_mips_howto_table[r_type];
      break;
    }
d1557 1
a1557 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1568 9
a1576 1
  cache_ptr->howto = mips_rtype_to_howto (r_type);
a1586 17

/* Given a MIPS Elf32_Internal_Rela, fill in an arelent structure.  */

static void
mips_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rela *dst;
{
  /* Since an Elf32_Internal_Rel is an initial prefix of an
     Elf32_Internal_Rela, we can just use mips_info_to_howto_rel
     above.  */
  mips_info_to_howto_rel (abfd, cache_ptr, (Elf32_Internal_Rel *) dst);

  /* If we ever need to do any extra processing with dst->r_addend
     (the field omitted in an Elf32_Internal_Rel) we can do it here.  */
}
a1751 25
#if 0
/* Swap in an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_Msym *ex;
     Elf32_Internal_Msym *in;
{
  in->ms_hash_value = bfd_h_get_32 (abfd, ex->ms_hash_value);
  in->ms_info = bfd_h_get_32 (abfd, ex->ms_info);
}
#endif
/* Swap out an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_Internal_Msym *in;
     Elf32_External_Msym *ex;
{
  bfd_h_put_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  bfd_h_put_32 (abfd, in->ms_info, ex->ms_info);
}

d1762 1
a1762 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1775 30
a1804 1
  /* Irix 5 and 6 is broken.  Object file symbol tables are not always
d1809 1
a1809 3
  bfd_default_set_arch_mach (abfd, bfd_arch_mips,
			     elf_mips_mach (elf_elfheader (abfd)->e_flags));
  return true;
d1820 1
a1820 1
     boolean linker ATTRIBUTE_UNUSED;
d1830 1
a1830 2
    default:
    case bfd_mach_mips3000:
d1834 1
a1834 5
    case bfd_mach_mips3900:
      val = E_MIPS_ARCH_1 | E_MIPS_MACH_3900;
      break;

    case bfd_mach_mips6000:
d1838 1
a1838 2
    case bfd_mach_mips4000:
    case bfd_mach_mips4300:
d1842 2
a1843 2
    case bfd_mach_mips4010:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4010;
d1846 2
a1847 14
    case bfd_mach_mips4100:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4100;
      break;

    case bfd_mach_mips4111:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4111;
      break;

    case bfd_mach_mips4650:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4650;
      break;

    case bfd_mach_mips8000:
      val = E_MIPS_ARCH_4;
d1851 1
a1851 1
  elf_elfheader (abfd)->e_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
d1854 1
a1854 2
  /* Set the sh_info field for .gptab sections and other appropriate
     info for each special section.  */
a1860 1
	case SHT_MIPS_MSYM:
d1886 1
a1886 1
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
a1915 1

d1972 5
a1976 8
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));
a1993 2
      elf_elfheader (obfd)->e_ident[EI_CLASS] 
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];
d2021 1
a2021 1
	(_("%s: linking PIC files with non-PIC files"),
d2031 1
a2031 1
	(_("%s: linking abicalls files with non-abicalls files"),
d2036 12
a2047 32
  /* Compare the ISA's. */
  if ((new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH))
      != (old_flags & (EF_MIPS_ARCH | EF_MIPS_MACH)))
    {
      int new_mach = new_flags & EF_MIPS_MACH;
      int old_mach = old_flags & EF_MIPS_MACH;
      int new_isa = elf_mips_isa (new_flags);
      int old_isa = elf_mips_isa (old_flags);

      /* If either has no machine specified, just compare the general isa's.
	 Some combinations of machines are ok, if the isa's match. */
      if (! new_mach 
	  || ! old_mach
	  || new_mach == old_mach
	  )
	{
	  /* Don't warn about mixing -mips1 and -mips2 code, or mixing -mips3
	     and -mips4 code.  They will normally use the same data sizes and
	     calling conventions.  */

	  if ((new_isa == 1 || new_isa == 2)
	      ? (old_isa != 1 && old_isa != 2)
	      : (old_isa == 1 || old_isa == 2))
	    {
	      (*_bfd_error_handler)
	       (_("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"),
		bfd_get_filename (ibfd), new_isa, old_isa);
	      ok = false;
	    }
	}

      else
d2050 2
a2051 4
	    (_("%s: ISA mismatch (%d) with previous modules (%d)"),
	     bfd_get_filename (ibfd),
	     elf_mips_mach (new_flags),
	     elf_mips_mach (old_flags));
d2055 2
a2056 24
      new_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
    }

  /* Compare ABI's.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
     does set EI_CLASS differently from any 32-bit ABI.  */
  if ((new_flags & EF_MIPS_ABI) != (old_flags & EF_MIPS_ABI)
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
	  != elf_elfheader (obfd)->e_ident[EI_CLASS]))
    {
      /* Only error if both are set (to different values). */
      if (((new_flags & EF_MIPS_ABI) && (old_flags & EF_MIPS_ABI))
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
	      != elf_elfheader (obfd)->e_ident[EI_CLASS]))
	{
	  (*_bfd_error_handler)
	    (_("%s: ABI mismatch: linking %s module with previous %s modules"),
	     bfd_get_filename (ibfd),
	     elf_mips_abi_name (ibfd),
	     elf_mips_abi_name (obfd));
	  ok = false;
	}
      new_flags &= ~EF_MIPS_ABI;
      old_flags &= ~EF_MIPS_ABI;
d2063 1
a2063 1
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
a2077 53
boolean
_bfd_mips_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O32)
    fprintf (file, _ (" [abi=O32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O64)
    fprintf (file, _ (" [abi=O64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32)
    fprintf (file, _ (" [abi=EABI32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
    fprintf (file, _ (" [abi=EABI64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI))
    fprintf (file, _ (" [abi unknown]"));
  else if (ABI_N32_P (abfd))
    fprintf (file, _ (" [abi=N32]"));
  else if (ABI_64_P (abfd))
    fprintf (file, _ (" [abi=64]"));
  else
    fprintf (file, _ (" [no abi set]"));

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1)
    fprintf (file, _ (" [mips1]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2)
    fprintf (file, _ (" [mips2]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_3)
    fprintf (file, _ (" [mips3]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_4)
    fprintf (file, _ (" [mips4]"));
  else
    fprintf (file, _ (" [unknown ISA]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_32BITMODE)
    fprintf (file, _ (" [32bitmode]"));
  else
    fprintf (file, _ (" [not 32bitmode]"));

  fputc ('\n', file);

  return true;
}

d2089 1
a2089 1
     char *name;
a2090 2
  flagword flags = 0;

d2103 1
a2103 1
      if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) != 0)
a2120 1
      flags = SEC_DEBUGGING;
a2125 1
      flags = (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_SIZE);
d2136 2
a2137 1
      if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) != 0)
d2161 1
a2161 1
  if (flags)
d2166 1
a2166 1
				    | flags)))
d2170 14
d2227 1
a2227 12
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  else if (intopt.kind == ODK_REGINFO)
d2266 6
d2301 5
a2312 2
#if 0
      /* This isn't how the Irix 6 linker behaves.  */
a2313 1
#endif
a2315 1
	   || strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0
d2326 1
a2326 1
  else if (strncmp (name, ".MIPS.content", strlen (".MIPS.content")) == 0)
a2328 1
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
d2331 2
a2332 1
  else if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
a2353 23
  else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_flags |= SHF_ALLOC;
      hdr->sh_entsize = 8;
    }

  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.  */
  if ((sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 
	= (Elf_Internal_Shdr *) bfd_zalloc (abfd, sizeof (Elf_Internal_Shdr));
      if (!esd->rel_hdr2)
	return false;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
				!elf_section_data (sec)->use_rela_p);
    }
d2366 2
a2367 2
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d2396 2
a2397 1
  if (strcmp (section->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
d2417 1
a2417 1
	  c = (bfd_byte *) bfd_zalloc (abfd, size);
d2440 51
a2490 2
  if (hdr->sh_type == SHT_MIPS_REGINFO
      && hdr->sh_size > 0)
d2529 1
a2529 16
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) == -1)
		return false;
	      bfd_h_put_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 8, abfd) != 8)
		return false;
	    }
	  else if (intopt.kind == ODK_REGINFO)
d2548 7
a2554 47
  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0
	  || strcmp (name, ".lit8") == 0
	  || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
      else if (strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return true;
}


/* MIPS ELF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
d2616 2
a2617 3
	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
      if (asym->value > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
d2657 2
a2658 2
int
_bfd_mips_elf_additional_program_headers (abfd)
d2662 1
a2662 1
  int ret = 0;
d2664 4
a2667 2
  if (!SGI_COMPAT (abfd))
    return 0;
a2668 1
  /* See if we need a PT_MIPS_REGINFO segment.  */
d2670 5
a2674 2
  if (s && (s->flags & SEC_LOAD))
    ++ret;
d2676 6
a2681 11
  /* See if we need a PT_MIPS_OPTIONS segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && bfd_get_section_by_name (abfd, 
				  MIPS_ELF_OPTIONS_SECTION_NAME (abfd)))
    ++ret;

  /* See if we need a PT_MIPS_RTPROC segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix5
      && bfd_get_section_by_name (abfd, ".dynamic")
      && bfd_get_section_by_name (abfd, ".mdebug"))
    ++ret;
d2688 2
a2689 2
boolean
_bfd_mips_elf_modify_segment_map (abfd)
d2728 5
a2732 5
  /* For IRIX 6, we don't have .mdebug sections, nor does anything but
     .dynamic end up in PT_DYNAMIC.  However, we do have to insert a
     PT_OPTIONS segement immediately following the program header
     table.  */
  if (IRIX_COMPAT (abfd) == ict_irix6)
d2734 8
a2741 1
      asection *s;
d2743 1
a2743 3
      for (s = abfd->sections; s; s = s->next)
	if (elf_section_data (s)->this_hdr.sh_type == SHT_MIPS_OPTIONS)
	  break;
d2745 12
a2756 3
      if (s)
	{
	  struct elf_segment_map *options_segment;
d2758 6
a2763 9
	  /* Usually, there's a program header table.  But, sometimes
	     there's not (like when running the `ld' testsuite).  So,
	     if there's no program header table, we just put the
	     options segement at the end.  */
	  for (pm = &elf_tdata (abfd)->segment_map; 
	       *pm != NULL;
	       pm = &(*pm)->next)
	    if ((*pm)->p_type == PT_PHDR)
	      break;
d2765 2
a2766 9
	  options_segment = bfd_zalloc (abfd, 
					sizeof (struct elf_segment_map));
	  options_segment->next = *pm;
	  options_segment->p_type = PT_MIPS_OPTIONS;
	  options_segment->p_flags = PF_R;
	  options_segment->p_flags_valid = true;
	  options_segment->count = 1;
	  options_segment->sections[0] = s;
	  *pm = options_segment;
d2769 10
a2778 1
  else
d2780 9
a2788 5
      /* If there are .dynamic and .mdebug sections, we make a room
	 for the RTPROC header.  FIXME: Rewrite without section names.  */
      if (bfd_get_section_by_name (abfd, ".interp") == NULL
	  && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	  && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d2790 2
a2791 4
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	    if (m->p_type == PT_MIPS_RTPROC)
	      break;
	  if (m == NULL)
d2793 1
a2793 18
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	      if (m == NULL)
		return false;

	      m->p_type = PT_MIPS_RTPROC;

	      s = bfd_get_section_by_name (abfd, ".rtproc");
	      if (s == NULL)
		{
		  m->count = 0;
		  m->p_flags = 0;
		  m->p_flags_valid = 1;
		}
	      else
		{
		  m->count = 1;
		  m->sections[0] = s;
		}
d2795 7
a2801 9
	      /* We want to put it after the DYNAMIC segment.  */
	      pm = &elf_tdata (abfd)->segment_map;
	      while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		pm = &(*pm)->next;
	      if (*pm != NULL)
		pm = &(*pm)->next;

	      m->next = *pm;
	      *pm = m;
d2805 8
a2812 25
      /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic,
	 .dynstr, .dynsym, and .hash sections, and everything in
	 between.  */
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
	if ((*pm)->p_type == PT_DYNAMIC)
	  break;
      m = *pm;
      if (m != NULL
	  && m->count == 1
	  && strcmp (m->sections[0]->name, ".dynamic") == 0)
	{
	  static const char *sec_names[] =
	  { ".dynamic", ".dynstr", ".dynsym", ".hash" };
	  bfd_vma low, high;
	  unsigned int i, c;
	  struct elf_segment_map *n;

	  low = 0xffffffff;
	  high = 0;
	  for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
	    {
	      s = bfd_get_section_by_name (abfd, sec_names[i]);
	      if (s != NULL && (s->flags & SEC_LOAD) != 0)
		{
		  bfd_size_type sz;
d2814 6
a2819 9
		  if (low > s->vma)
		    low = s->vma;
		  sz = s->_cooked_size;
		  if (sz == 0)
		    sz = s->_raw_size;
		  if (high < s->vma + sz)
		    high = s->vma + sz;
		}
	    }
d2821 8
a2828 18
	  c = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    if ((s->flags & SEC_LOAD) != 0
		&& s->vma >= low
		&& ((s->vma
		     + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		    <= high))
	      ++c;

	  n = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
	  if (n == NULL)
	    return false;
	  *n = *m;
	  n->count = c;

	  i = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
d2830 2
a2831 10
	      if ((s->flags & SEC_LOAD) != 0
		  && s->vma >= low
		  && ((s->vma
		       + (s->_cooked_size != 0 ?
			  s->_cooked_size : s->_raw_size))
		      <= high))
		{
		  n->sections[i] = s;
		  ++i;
		}
d2833 1
d2835 1
a2835 2
	  *pm = n;
	}
a2901 1
  memset (debug, 0, sizeof(*debug));
a3015 11
  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 
				     ABI_64_P (abfd) ? 8 : 0))
    return true;

d3137 30
a3171 2
#if 0
  /* We no longer use this.  */
a3173 1
#endif
d3241 1
a3241 2
      ret->possibly_dynamic_relocs = 0;
      ret->min_dyn_reloc_index = 0;
d3253 2
a3254 2
struct bfd_link_hash_table *
_bfd_mips_elf_link_hash_table_create (abfd)
d3258 1
a3271 2
#if 0
  /* We no longer use this.  */
a3273 1
#endif
d3287 2
a3288 2
boolean
_bfd_mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
d3293 1
a3293 1
     flagword *flagsp ATTRIBUTE_UNUSED;
d3311 1
a3311 2
      if (sym->st_size > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
d3331 1
a3331 1
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
d3355 1
a3355 1
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
d3574 1
a3574 1
	    h->esym.asym.value = (h->root.plt.offset
d3620 1
a3620 1
  const char *no_name_func = _("static procedure (no name)");
d3714 1
a3714 1
  s->contents = (bfd_byte *) rtproc;
d3764 2
a3765 2
boolean
_bfd_mips_elf_final_link (abfd, info)
d3781 14
a3794 9
  /* If all the things we linked together were PIC, but we're
     producing an executable (rather than a shared object), then the
     resulting file is CPIC (i.e., it calls PIC code.)  */
  if (!info->shared
      && !info->relocateable
      && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    {
      elf_elfheader (abfd)->e_flags &= ~EF_MIPS_PIC;
      elf_elfheader (abfd)->e_flags |= EF_MIPS_CPIC;
a3796 52
  /* We'd carefully arranged the dynamic symbol indices, and then the
     generic size_dynamic_sections renumbered them out from under us.
     Rather than trying somehow to prevent the renumbering, just do
     the sort again.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *got;
      struct mips_got_info *g;

      /* When we resort, we must tell mips_elf_sort_hash_table what
	 the lowest index it may use is.  That's the number of section
	 symbols we're going to add.  The generic ELF linker only
	 adds these symbols when building a shared object.  Note that
	 we count the sections after (possibly) removing the .options
	 section above.  */
      if (!mips_elf_sort_hash_table (info, (info->shared 
					    ? bfd_count_sections (abfd) + 1
					    : 1)))
        return false;

      /* Make sure we didn't grow the global .got region.  */
      dynobj = elf_hash_table (info)->dynobj;
      got = bfd_get_section_by_name (dynobj, ".got");
      g = (struct mips_got_info *) elf_section_data (got)->tdata;

      if (g->global_gotsym != NULL)
	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		     - g->global_gotsym->dynindx)
		    <= g->global_gotno);
    }

  /* On IRIX5, we omit the .options section.  On IRIX6, however, we
     include it, even though we don't process it quite right.  (Some
     entries are supposed to be merged.)  Empirically, we seem to be
     better off including it then not.  */
  if (IRIX_COMPAT (abfd) == ict_irix5)
    for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
      {
	if (strcmp ((*secpp)->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
	  {
	    for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	      if (p->type == bfd_indirect_link_order)
		p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
	    (*secpp)->link_order_head = NULL;
	    *secpp = (*secpp)->next;
	    --abfd->section_count;
	    
	    break;
	  }
      }

d3812 1
a3812 1
	  /* Find the GP-relative section with the lowest offset.  */
d3815 8
a3822 5
	    if (o->vma < lo 
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
d3895 2
a3896 2
	  /* Size has been set in mips_elf_always_size_sections  */
	  BFD_ASSERT(o->_raw_size == sizeof (Elf32_External_RegInfo));
a3966 1
	      last = 0;
d4192 1
a4192 1
		(_("%s: illegal section name `%s'"),
d4354 1
a4354 11
  if (ABI_64_P (abfd))
    {
#ifdef BFD64
      if (!bfd_elf64_bfd_final_link (abfd, info))
	return false;
#else
      abort ();
      return false;
#endif /* BFD64 */
    }
  else if (!bfd_elf32_bfd_final_link (abfd, info))
d4414 1
a4414 1
/* Returns the GOT section for ABFD.  */
d4416 7
a4422 3
static asection *
mips_elf_got_section (abfd)
     bfd *abfd;
d4424 4
a4427 2
  return bfd_get_section_by_name (abfd, ".got");
}
d4429 2
a4430 3
/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT 
   section.  */
d4432 1
a4432 7
static struct mips_got_info *
mips_elf_got_info (abfd, sgotp)
     bfd *abfd;
     asection **sgotp;
{
  asection *sgot;
  struct mips_got_info *g;
d4434 4
a4437 5
  sgot = mips_elf_got_section (abfd);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);
d4439 3
a4441 3
  if (sgotp)
    *sgotp = sgot;
  return g;
d4444 1
a4444 1
/* Return whether a relocation is against a local symbol.  */
d4447 3
a4449 1
mips_elf_local_relocation_p (input_bfd, relocation, local_sections)
d4451 5
a4455 2
     const Elf_Internal_Rela *relocation;
     asection **local_sections;
d4457 8
a4464 14
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;

  r_symndx = ELF32_R_SYM (relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  if (! elf_bad_symtab (input_bfd))
    return r_symndx < symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      return local_sections[r_symndx] != NULL;
    }
}
d4466 1
a4466 1
/* Sign-extend VALUE, which has the indicated number of BITS.  */
d4468 2
a4469 11
static bfd_vma
mips_elf_sign_extend (value, bits)
     bfd_vma value;
     int bits;
{
  if (value & ((bfd_vma)1 << (bits - 1)))
    /* VALUE is negative.  */
    value |= ((bfd_vma) - 1) << bits;      
  
  return value;
}
d4471 1
a4471 3
/* Return non-zero if the indicated VALUE has overflowed the maximum
   range expressable by a signed number with the indicated number of
   BITS.  */
d4473 4
a4476 6
static boolean
mips_elf_overflow_p (value, bits)
     bfd_vma value;
     int bits;
{
  bfd_signed_vma svalue = (bfd_signed_vma) value;
d4478 4
a4481 10
  if (svalue > (1 << (bits - 1)) - 1)
    /* The value is too big.  */
    return true;
  else if (svalue < -(1 << (bits - 1)))
    /* The value is too small.  */
    return true;
    
  /* All is well.  */
  return false;
}
d4483 3
a4485 1
/* Calculate the %high function.  */
d4487 6
a4492 6
static bfd_vma
mips_elf_high (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}
d4494 9
a4502 1
/* Calculate the %higher function.  */
d4504 3
a4506 11
static bfd_vma
mips_elf_higher (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
}
d4508 3
a4510 1
/* Calculate the %highest function.  */
d4512 1
a4512 10
static bfd_vma 
mips_elf_highest (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x800080008000) >> 48) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
d4515 1
a4515 1
/* Returns the GOT index for the global symbol indicated by H.  */
d4517 6
a4522 4
static bfd_vma 
mips_elf_global_got_index (abfd, h)
     bfd *abfd;
     struct elf_link_hash_entry *h;
d4524 7
a4530 3
  bfd_vma index;
  asection *sgot;
  struct mips_got_info *g;
d4532 1
a4532 1
  g = mips_elf_got_info (abfd, &sgot);
d4534 3
a4536 18
  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= g->global_gotsym->dynindx);
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno) 
	   * MIPS_ELF_GOT_SIZE (abfd));
  BFD_ASSERT (index < sgot->_raw_size);

  return index;
}

/* Returns the offset for the entry at the INDEXth position
   in the GOT.  */

static bfd_vma
mips_elf_got_offset_from_index (dynobj, output_bfd, index)
     bfd *dynobj;
d4538 7
a4544 1
     bfd_vma index;
d4546 5
a4550 1
  asection *sgot;
d4552 3
d4556 2
a4557 5
  sgot = mips_elf_got_section (dynobj);
  gp = _bfd_get_gp_value (output_bfd);
  return (sgot->output_section->vma + sgot->output_offset + index - 
	  gp);
}
d4559 4
a4562 63
/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */

static boolean
mips_elf_record_global_got_symbol (h, info, g)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     struct mips_got_info *g ATTRIBUTE_UNUSED;
{
  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1
      && !bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;
  
  /* If we've already marked this entry as need GOT space, we don't
     need to do it again.  */
  if (h->got.offset != (bfd_vma) - 1)
    return true;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  */
  h->got.offset = 0;

  return true;
}

/* This structure is passed to mips_elf_sort_hash_table_f when sorting
   the dynamic symbols.  */
     
struct mips_elf_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table
     index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a symbol
     with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic 
   index.  */

static boolean
mips_elf_sort_hash_table_f (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  struct mips_elf_hash_sort_data *hsd 
    = (struct mips_elf_hash_sort_data *) data;

  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return true;

  if (h->root.got.offset != 0)
    h->root.dynindx = hsd->max_non_got_dynindx++;
d4564 2
a4565 4
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }
d4567 1
a4567 52
  return true;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   mips_elf_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */

static boolean
mips_elf_sort_hash_table (info, max_local)
     struct bfd_link_info *info;
     unsigned long max_local;
{
  struct mips_elf_hash_sort_data hsd;
  struct mips_got_info *g;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  hsd.low = NULL;
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount;
  hsd.max_non_got_dynindx = max_local;
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *) 
				elf_hash_table (info)), 
			       mips_elf_sort_hash_table_f, 
			       &hsd);

  /* There shoud have been enough room in the symbol table to
     accomodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.min_got_dynindx == hsd.max_non_got_dynindx);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  g = mips_elf_got_info (dynobj, NULL);
  g->global_gotsym = hsd.low;

  return true;
}

/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  */

static bfd_vma
mips_elf_create_local_got_entry (abfd, g, sgot, value)
     bfd *abfd;
     struct mips_got_info *g;
     asection *sgot;
     bfd_vma value;
{
  if (g->assigned_gotno >= g->local_gotno)
d4569 2
a4570 5
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
	(_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return (bfd_vma) -1;
d4572 1
a4572 28

  MIPS_ELF_PUT_WORD (abfd, value,
		     (sgot->contents 
		      + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno));
  return MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
}

/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.  Returns
   -1 if no satisfactory GOT offset can be found.  */

static bfd_vma
mips_elf_local_got_index (abfd, info, value)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  for (entry = (sgot->contents 
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO); 
       entry != sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
       entry += MIPS_ELF_GOT_SIZE (abfd))
d4574 2
a4575 3
      bfd_vma address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	return entry - sgot->contents;
d4578 1
a4578 46
  return mips_elf_create_local_got_entry (abfd, g, sgot, value);
}

/* Find a GOT entry that is within 32KB of the VALUE.  These entries
   are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index into the GOT for this page,
   and store the offset from this entry to the desired address in
   OFFSETP, if it is non-NULL.  */

static bfd_vma
mips_elf_got_page (abfd, info, value, offsetp)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_vma *offsetp;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we aleady have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents 
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);

      if (!mips_elf_overflow_p (value - address, 16))
	{
	  /* This entry will serve as the page pointer.  We can add a
	     16-bit number to it to get the actual address.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);
d4580 3
a4582 1
  if (offsetp)
d4584 10
a4593 3
      address = MIPS_ELF_GET_WORD (abfd, entry);
      *offsetp = value - address;
    }
d4595 4
a4598 35
  return index;
}

/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */

static bfd_vma
mips_elf_got16_entry (abfd, info, value)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  /* Although the ABI says that it is "the high-order 16 bits" that we
     want, it is really the %high value.  The complete value is
     calculated with a `addiu' of a LO16 relocation, just as with a
     HI16/LO16 pair.  */
  value = mips_elf_high (value) << 16;
  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents 
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      if ((address & 0xffff0000) == value)
d4600 2
a4601 3
	  /* This entry has the right high-order 16 bits.  */
	  index = entry - sgot->contents;
	  break;
d4603 6
a4608 1
    }
d4610 18
a4627 3
  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);
d4629 1
a4629 95
  return index;
}

/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */

static const Elf_Internal_Rela *
mips_elf_next_relocation (r_type, relocation, relend)
     unsigned int r_type;
     const Elf_Internal_Rela *relocation;
     const Elf_Internal_Rela *relend;
{
  /* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be
     immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.  */
  while (relocation < relend)
    {
      if (ELF32_R_TYPE (relocation->r_info) == r_type)
	return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  bfd_set_error (bfd_error_bad_value);
  return NULL;
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dyanmic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */

static boolean
mips_elf_create_dynamic_relocation (output_bfd, info, rel, h, sec,
				    symbol, addendp, input_section)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *rel;
     struct mips_elf_link_hash_entry *h;
     asection *sec;
     bfd_vma symbol;
     bfd_vma *addendp;
     asection *input_section;
{
  Elf_Internal_Rel outrel;
  boolean skip;
  asection *sreloc;
  bfd *dynobj;
  int r_type;

  r_type = ELF32_R_TYPE (rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc 
    = bfd_get_section_by_name (dynobj,
			       MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd));
  BFD_ASSERT (sreloc != NULL);

  skip = false;

  /* We begin by assuming that the offset for the dynamic relocation
     is the same as for the original relocation.  We'll adjust this
     later to reflect the correct output offsets.  */
  if (elf_section_data (input_section)->stab_info == NULL)
    outrel.r_offset = rel->r_offset;
  else
    {
      /* Except that in a stab section things are more complex.
	 Because we compress stab information, the offset given in the
	 relocation may not be the one we want; we must let the stabs
	 machinery tell us the offset.  */
      outrel.r_offset 
	= (_bfd_stab_section_offset
	   (output_bfd, &elf_hash_table (info)->stab_info,
	    input_section,
	    &elf_section_data (input_section)->stab_info,
	    rel->r_offset));
      /* If we didn't need the relocation at all, this value will be
	 -1.  */
      if (outrel.r_offset == (bfd_vma) -1)
	skip = true;
    }

  /* If we've decided to skip this relocation, just output an emtpy
     record.  Note that R_MIPS_NONE == 0, so that this call to memset
     is a way of setting R_TYPE to R_MIPS_NONE.  */
  if (skip)
    memset (&outrel, 0, sizeof (outrel));
  else
    {
      long indx;
      bfd_vma section_offset;
d4631 6
a4636 9
      /* We must now calculate the dynamic symbol table index to use
	 in the relocation.  */
      if (h != NULL
	  && (! info->symbolic || (h->root.elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	{
	  indx = h->root.dynindx;
	  BFD_ASSERT (indx != -1);
	}
d4639 1
a4639 3
	  if (sec != NULL && bfd_is_abs_section (sec))
	    indx = 0;
	  else if (sec == NULL || sec->owner == NULL)
d4641 32
a4672 2
	      bfd_set_error (bfd_error_bad_value);
	      return false;
d4676 4
a4679 3
	      indx = elf_section_data (sec->output_section)->dynindx;
	      if (indx == 0)
		abort ();
a4680 86

	  /* Figure out how far the target of the relocation is from
	     the beginning of its section.  */
	  section_offset = symbol - sec->output_section->vma;
	  /* The relocation we're building is section-relative.
	     Therefore, the original addend must be adjusted by the
	     section offset.  */
	  *addendp += symbol - sec->output_section->vma;
	  /* Now, the relocation is just against the section.  */
	  symbol = sec->output_section->vma;
	}
      
      /* If the relocation was previously an absolute relocation, we
	 must adjust it by the value we give it in the dynamic symbol
	 table.  */
      if (r_type != R_MIPS_REL32)
	*addendp += symbol;

      /* The relocation is always an REL32 relocation because we don't
	 know where the shared library will wind up at load-time.  */
      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);

      /* Adjust the output offset of the relocation to reference the
	 correct location in the output file.  */
      outrel.r_offset += (input_section->output_section->vma
			  + input_section->output_offset);
    }

  /* Put the relocation back out.  We have to use the special
     relocation outputter in the 64-bit case since the 64-bit
     relocation format is non-standard.  */
  if (ABI_64_P (output_bfd))
    {
      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
	(output_bfd, &outrel,
	 (sreloc->contents 
	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
    }
  else
    bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			      (((Elf32_External_Rel *)
				sreloc->contents)
			       + sreloc->reloc_count));

  /* Record the index of the first relocation referencing H.  This
     information is later emitted in the .msym section.  */
  if (h != NULL
      && (h->min_dyn_reloc_index == 0 
	  || sreloc->reloc_count < h->min_dyn_reloc_index))
    h->min_dyn_reloc_index = sreloc->reloc_count;

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags
    |= SHF_WRITE;

  /* On IRIX5, make an entry of compact relocation info.  */
  if (! skip && IRIX_COMPAT (output_bfd) == ict_irix5)
    {
      asection* scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
      bfd_byte *cr;

      if (scpt)
	{
	  Elf32_crinfo cptrel;

	  mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	  cptrel.vaddr = (rel->r_offset
			  + input_section->output_section->vma
			  + input_section->output_offset);
	  if (r_type == R_MIPS_REL32)
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
	  else
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
	  mips_elf_set_cr_dist2to (cptrel, 0);
	  cptrel.konst = *addendp;

	  cr = (scpt->contents
		+ sizeof (Elf32_External_compact_rel));
	  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
				     ((Elf32_External_crinfo *) cr
				      + scpt->reloc_count));
	  ++scpt->reloc_count;
a4681 1
    }
d4683 4
a4686 158
  return true;
}

/* Calculate the value produced by the RELOCATION (which comes from
   the INPUT_BFD).  The ADDEND is the addend to use for this
   RELOCATION; RELOCATION->R_ADDEND is ignored.

   The result of the relocation calculation is stored in VALUEP.
   REQUIRE_JALXP indicates whether or not the opcode used with this
   relocation must be JALX.

   This function returns bfd_reloc_continue if the caller need take no
   further action regarding this relocation, bfd_reloc_notsupported if
   something goes dramatically wrong, bfd_reloc_overflow if an
   overflow occurs, and bfd_reloc_ok to indicate success.  */

static bfd_reloc_status_type
mips_elf_calculate_relocation (abfd, 
			       input_bfd,
			       input_section,
			       info,
			       relocation,
			       addend,
			       howto,
			       local_syms,
			       local_sections,
			       valuep,
			       namep,
			       require_jalxp) 
     bfd *abfd;
     bfd *input_bfd;
     asection *input_section;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *relocation;
     bfd_vma addend;
     reloc_howto_type *howto;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
     bfd_vma *valuep;
     const char **namep;
     boolean *require_jalxp;
{
  /* The eventual value we will return.  */
  bfd_vma value;
  /* The address of the symbol against which the relocation is
     occurring.  */
  bfd_vma symbol = 0;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp = (bfd_vma) - 1;
  /* The place (section offset or address) of the storage unit being
     relocated.  */
  bfd_vma p;
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0 = (bfd_vma) - 1;
  /* The offset into the global offset table at which the address of
     the relocation entry symbol, adjusted by the addend, resides
     during execution.  */
  bfd_vma g = (bfd_vma) - 1;
  /* The section in which the symbol referenced by the relocation is
     located.  */
  asection *sec = NULL;
  struct mips_elf_link_hash_entry* h = NULL;
  /* True if the symbol referred to by this relocation is a local
     symbol.  */
  boolean local_p;
  /* True if the symbol referred to by this relocation is "_gp_disp".  */
  boolean gp_disp_p = false;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;
  unsigned long r_symndx;
  int r_type;
  /* True if overflow occurred during the calculation of the
     relocation value.  */
  boolean overflowed_p;
  /* True if this relocation refers to a MIPS16 function.  */
  boolean target_is_16_bit_code_p = false;

  /* Parse the relocation.  */
  r_symndx = ELF32_R_SYM (relocation->r_info);
  r_type = ELF32_R_TYPE (relocation->r_info);
  p = (input_section->output_section->vma 
       + input_section->output_offset
       + relocation->r_offset);

  /* Assume that there will be no overflow.  */
  overflowed_p = false;

  /* Figure out whether or not the symbol is local, and get the offset
     used in the array of hash table entries.  */
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections);
  if (! elf_bad_symtab (input_bfd))
    extsymoff = symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      extsymoff = 0;
    }
      
  /* Figure out the value of the symbol.  */
  if (local_p)
    {
      Elf_Internal_Sym *sym;

      sym = local_syms + r_symndx;
      sec = local_sections[r_symndx];

      symbol = sec->output_section->vma + sec->output_offset;
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	symbol += sym->st_value;

      /* MIPS16 text labels should be treated as odd.  */
      if (sym->st_other == STO_MIPS16)
	++symbol;

      /* Record the name of this symbol, for our caller.  */
      *namep = bfd_elf_string_from_elf_section (input_bfd,
						symtab_hdr->sh_link,
						sym->st_name);
      if (*namep == '\0')
	*namep = bfd_section_name (input_bfd, sec);

      target_is_16_bit_code_p = (sym->st_other == STO_MIPS16);
    }
  else
    {
      /* For global symbols we look up the symbol in the hash-table.  */
      h = ((struct mips_elf_link_hash_entry *) 
	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
      
      /* Record the name of this symbol, for our caller.  */
      *namep = h->root.root.root.string;

      /* See if this is the special _gp_disp symbol.  Note that such a
	 symbol must always be a global symbol.  */
      if (strcmp (h->root.root.root.string, "_gp_disp") == 0)
	{
	  /* Relocations against _gp_disp are permitted only with
	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
	  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_LO16)
	    return bfd_reloc_notsupported;

	  gp_disp_p = true;
	}
      /* If this symbol is defined, calculate its address.  Note that
	 _gp_disp is a magic symbol, always implicitly defined by the
	 linker, so it's inappropriate to check to see whether or not
	 its defined.  */
      else if ((h->root.root.type == bfd_link_hash_defined
		|| h->root.root.type == bfd_link_hash_defweak)
	       && h->root.root.u.def.section)
d4688 8
a4695 5
	  sec = h->root.root.u.def.section;
	  if (sec->output_section)
	    symbol = (h->root.root.u.def.value 
		      + sec->output_section->vma
		      + sec->output_offset);
d4697 7
a4703 53
	    symbol = h->root.root.u.def.value;
	}
      else if (h->root.root.type == bfd_link_hash_undefweak)
	/* We allow relocations against undefined weak symbols, giving
	   it the value zero, so that you can undefined weak functions
	   and check to see if they exist by looking at their
	   addresses.  */
	symbol = 0;
      else if (info->shared && !info->symbolic && !info->no_undefined)
	symbol = 0;
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0)
	{
	  /* If this is a dynamic link, we should have created a
	     _DYNAMIC_LINK symbol in mips_elf_create_dynamic_sections.
	     Otherwise, we should define the symbol with a value of 0.
	     FIXME: It should probably get into the symbol table
	     somehow as well.  */
	  BFD_ASSERT (! info->shared);
	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
	  symbol = 0;
	}
      else
	{
	  if (! ((*info->callbacks->undefined_symbol)
		 (info, h->root.root.root.string, input_bfd,
		  input_section, relocation->r_offset,
		  (!info->shared || info->no_undefined))))
	    return bfd_reloc_undefined;
	  symbol = 0;
	}

      target_is_16_bit_code_p = (h->root.other == STO_MIPS16);
    }
  
  /* If this is a 32-bit call to a 16-bit function with a stub, we
     need to redirect the call to the stub, unless we're already *in*
     a stub.  */
  if (r_type != R_MIPS16_26 && !info->relocateable
      && ((h != NULL && h->fn_stub != NULL)
	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
      && !mips_elf_stub_section_p (input_bfd, input_section))
    {
      /* This is a 32-bit call to a 16-bit function.  We should
	 have already noticed that we were going to need the
	 stub.  */
      if (local_p)
	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
      else
	{
	  BFD_ASSERT (h->need_fn_stub);
	  sec = h->fn_stub;
	}
d4705 19
a4723 15
      symbol = sec->output_section->vma + sec->output_offset;
    }
  /* If this is a 16-bit call to a 32-bit function with a stub, we
     need to redirect the call to the stub.  */
  else if (r_type == R_MIPS16_26 && !info->relocateable
	   && h != NULL 
	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
	   && !target_is_16_bit_code_p)
    {
      /* If both call_stub and call_fp_stub are defined, we can figure
	 out which one to use by seeing which one appears in the input
	 file.  */
      if (h->call_stub != NULL && h->call_fp_stub != NULL)
	{
	  asection *o;
d4725 27
a4751 8
	  sec = NULL;
	  for (o = input_bfd->sections; o != NULL; o = o->next)
	    {
	      if (strncmp (bfd_get_section_name (input_bfd, o),
			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
		{
		  sec = h->call_fp_stub;
		  break;
a4753 2
	  if (sec == NULL)
	    sec = h->call_stub;
a4754 37
      else if (h->call_stub != NULL)
	sec = h->call_stub;
      else
	sec = h->call_fp_stub;

      BFD_ASSERT (sec->_raw_size > 0);
      symbol = sec->output_section->vma + sec->output_offset;
    }

  /* Calls from 16-bit code to 32-bit code and vice versa require the
     special jalx instruction.  */
  *require_jalxp = (!info->relocateable
		    && ((r_type == R_MIPS16_26) != target_is_16_bit_code_p));

  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
  switch (r_type)
    {
    case R_MIPS_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_GOT_DISP:
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      /* Find the index into the GOT where this value is located.  */
      if (!local_p)
	{
	  BFD_ASSERT (addend == 0);
	  g = mips_elf_global_got_index 
	    (elf_hash_table (info)->dynobj,
	     (struct elf_link_hash_entry*) h);
	}
      else if (r_type == R_MIPS_GOT16)
	/* There's no need to create a local GOT entry here; the
	   calculation for a local GOT16 entry does not involve G.  */
	break;
d4757 2
a4758 4
	  g = mips_elf_local_got_index (abfd, info, symbol + addend);
	  if (g == (bfd_vma) -1)
	    return false;
	}
d4760 25
a4784 13
      /* Convert GOT indices to actual offsets.  */
      g = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					  abfd, g);
      break;
      
    case R_MIPS_HI16:
    case R_MIPS_LO16:
    case R_MIPS_GPREL16:
    case R_MIPS_GPREL32:
    case R_MIPS_LITERAL:
      gp0 = _bfd_get_gp_value (input_bfd);
      gp = _bfd_get_gp_value (abfd);
      break;
d4786 72
a4857 3
    default:
      break;
    }
d4859 5
a4863 41
  /* Figure out what kind of relocation is being performed.  */
  switch (r_type)
    {
    case R_MIPS_NONE:
      return bfd_reloc_continue;

    case R_MIPS_16:
      value = symbol + mips_elf_sign_extend (addend, 16);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_32:
    case R_MIPS_REL32:
    case R_MIPS_64:
      if ((info->shared
	   || (elf_hash_table (info)->dynamic_sections_created
	       && h != NULL
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		   == 0)))
	  && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, or this relocation is
	     against a symbol in a shared library, then we can't know
	     where the symbol will end up.  So, we create a relocation
	     record in the output, and leave the job up to the dynamic
	     linker.  */
	  value = addend;
	  if (!mips_elf_create_dynamic_relocation (abfd, 
						   info, 
						   relocation,
						   h,
						   sec,
						   symbol,
						   &value,
						   input_section))
	    return false;
	}
      else
	{
	  if (r_type != R_MIPS_REL32)
	    value = symbol + addend;
d4865 1
a4865 4
	    value = addend;
	}
      value &= howto->dst_mask;
      break;
d4867 27
a4893 6
    case R_MIPS_PC32:
    case R_MIPS_PC64:
    case R_MIPS_GNU_REL_LO16:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;
d4895 4
a4898 5
    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;
d4900 3
a4902 4
    case R_MIPS_GNU_REL_HI16:
      value = mips_elf_high (addend + symbol - p);
      value &= howto->dst_mask;
      break;
d4904 24
a4927 13
    case R_MIPS16_26:
      /* The calculation for R_MIPS_26 is just the same as for an
	 R_MIPS_26.  It's only the storage of the relocated field into
	 the output file that's different.  That's handled in
	 mips_elf_perform_relocation.  So, we just fall through to the
	 R_MIPS_26 case here.  */
    case R_MIPS_26:
      if (local_p)
	value = (((addend << 2) | (p & 0xf0000000)) + symbol) >> 2;
      else
	value = (mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
      value &= howto->dst_mask;
      break;
d4929 17
a4945 12
    case R_MIPS_HI16:
      if (!gp_disp_p)
	{
	  value = mips_elf_high (addend + symbol);
	  value &= howto->dst_mask;
	}
      else
	{
	  value = mips_elf_high (addend + gp - p);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	}
      break;
d4947 3
a4949 24
    case R_MIPS_LO16:
      if (!gp_disp_p)
	value = (symbol + addend) & howto->dst_mask;
      else
	{
	  value = addend + gp - p + 4;
	  /* The MIPS ABI requires checking the R_MIPS_LO16 relocation
	     for overflow.  But, on, say, Irix 5, relocations against
	     _gp_disp are normally generated from the .cpload
	     pseudo-op.  It generates code that normally looks like
	     this:

	       lui    $gp,%hi(_gp_disp)
	       addiu  $gp,$gp,%lo(_gp_disp)
	       addu   $gp,$gp,$t9

	     Here $t9 holds the address of the function being called,
	     as required by the MIPS ELF ABI.  The R_MIPS_LO16
	     relocation can easily overflow in this situation, but the
	     R_MIPS_HI16 relocation will handle the overflow.
	     Therefore, we consider this a bug in the MIPS ABI, and do
	     not check for overflow here.  */
	}
      break;
d4951 3
a4953 5
    case R_MIPS_LITERAL:
      /* Because we don't merge literal sections, we can handle this
	 just like R_MIPS_GPREL16.  In the long run, we should merge
	 shared literals, and then we will need to additional work
	 here.  */
d4955 105
a5059 1
      /* Fall through.  */
d5061 8
a5068 26
    case R_MIPS16_GPREL:
      /* The R_MIPS16_GPREL performs the same calculation as
	 R_MIPS_GPREL16, but stores the relocated bits in a different
	 order.  We don't need to do anything special here; the
	 differences are handled in mips_elf_perform_relocation.  */
    case R_MIPS_GPREL16:
      if (local_p)
	value = mips_elf_sign_extend (addend, 16) + symbol + gp0 - gp;
      else
	value = mips_elf_sign_extend (addend, 16) + symbol - gp;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;
      
    case R_MIPS_GOT16:
      if (local_p)
	{
	  value = mips_elf_got16_entry (abfd, info, symbol + addend);
	  if (value == (bfd_vma) -1)
	    return false;
	  value 
	    = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	  break;
	}
d5070 1
a5070 1
      /* Fall through.  */
d5072 5
a5076 5
    case R_MIPS_CALL16:
    case R_MIPS_GOT_DISP:
      value = g;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;
d5078 9
a5086 3
    case R_MIPS_GPREL32:
      value = (addend + symbol + gp0 - gp) & howto->dst_mask;
      break;
d5088 2
a5089 5
    case R_MIPS_PC16:
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      value = (bfd_vma) ((bfd_signed_vma) value / 4);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;
d5091 1
a5091 9
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
      /* We're allowed to handle these two relocations identically.
	 The dynamic linker is allowed to handle the CALL relocations
	 differently by creating a lazy evaluation stub.  */
      value = g;
      value = mips_elf_high (value);
      value &= howto->dst_mask;
      break;
d5093 14
a5106 4
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      value = g & howto->dst_mask;
      break;
d5108 19
a5126 14
    case R_MIPS_GOT_PAGE:
      value = mips_elf_got_page (abfd, info, symbol + addend, NULL);
      if (value == (bfd_vma) -1)
	return false;
      value = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;
      
    case R_MIPS_GOT_OFST:
      mips_elf_got_page (abfd, info, symbol + addend, &value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;
d5128 5
a5132 4
    case R_MIPS_SUB:
      value = symbol - addend;
      value &= howto->dst_mask;
      break;
d5134 3
a5136 4
    case R_MIPS_HIGHER:
      value = mips_elf_higher (addend + symbol);
      value &= howto->dst_mask;
      break;
d5138 2
a5139 9
    case R_MIPS_HIGHEST:
      value = mips_elf_highest (addend + symbol);
      value &= howto->dst_mask;
      break;
      
    case R_MIPS_SCN_DISP:
      value = symbol + addend - sec->output_offset;
      value &= howto->dst_mask;
      break;
d5141 5
a5145 10
    case R_MIPS_PJUMP:
    case R_MIPS_JALR:
      /* Both of these may be ignored.  R_MIPS_JALR is an optimization
	 hint; we could improve performance by honoring that hint.  */
      return bfd_reloc_continue;

    case R_MIPS_GNU_VTINHERIT:
    case R_MIPS_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;
d5147 4
a5150 4
    default:
      /* An unrecognized relocation type.  */
      return bfd_reloc_notsupported;
    }
d5152 19
a5170 4
  /* Store the VALUE for our caller.  */
  *valuep = value;
  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
}
d5172 63
a5234 1
/* Obtain the field relocated by RELOCATION.  */
d5236 3
a5238 9
static bfd_vma
mips_elf_obtain_contents (howto, relocation, input_bfd, contents)
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd *input_bfd;
     bfd_byte *contents;
{
  bfd_vma x;
  bfd_byte *location = contents + relocation->r_offset;
d5240 4
a5243 19
  /* Obtain the bytes.  */
  x = bfd_get (8 * bfd_get_reloc_size (howto), input_bfd, location);

  if ((ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26
       || ELF32_R_TYPE (relocation->r_info) == R_MIPS16_GPREL)
      && bfd_little_endian (input_bfd))
    /* The two 16-bit words will be reversed on a little-endian
       system.  See mips_elf_perform_relocation for more details.  */
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

  return x;
}

/* It has been determined that the result of the RELOCATION is the
   VALUE.  Use HOWTO to place VALUE into the output file at the
   appropriate position.  The SECTION is the section to which the
   relocation applies.  If REQUIRE_JALX is true, then the opcode used
   for the relocation must be either JAL or JALX, and it is
   unconditionally converted to JALX.
d5245 4
a5248 274
   Returns false if anything goes wrong.  */

static boolean
mips_elf_perform_relocation (info, howto, relocation, value,
			     input_bfd, input_section, 
			     contents, require_jalx)
     struct bfd_link_info *info;
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd_vma value;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     boolean require_jalx;
{
  bfd_vma x;
  bfd_byte *location;
  int r_type = ELF32_R_TYPE (relocation->r_info);

  /* Figure out where the relocation is occurring.  */
  location = contents + relocation->r_offset;

  /* Obtain the current value.  */
  x = mips_elf_obtain_contents (howto, relocation, input_bfd, contents);

  /* Clear the field we are setting.  */
  x &= ~howto->dst_mask;

  /* If this is the R_MIPS16_26 relocation, we must store the
     value in a funny way.  */
  if (r_type == R_MIPS16_26)
    {
      /* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
	 Most mips16 instructions are 16 bits, but these instructions
	 are 32 bits.

	 The format of these instructions is:

	 +--------------+--------------------------------+
	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  !
	 +--------------+--------------------------------+
	 !	  	  Immediate  15:0		    !
	 +-----------------------------------------------+
	 
	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
	 Note that the immediate value in the first word is swapped.

	 When producing a relocateable object file, R_MIPS16_26 is
	 handled mostly like R_MIPS_26.  In particular, the addend is
	 stored as a straight 26-bit value in a 32-bit instruction.
	 (gas makes life simpler for itself by never adjusting a
	 R_MIPS16_26 reloc to be against a section, so the addend is
	 always zero).  However, the 32 bit instruction is stored as 2
	 16-bit values, rather than a single 32-bit value.  In a
	 big-endian file, the result is the same; in a little-endian
	 file, the two 16-bit halves of the 32 bit value are swapped.
	 This is so that a disassembler can recognize the jal
	 instruction.

	 When doing a final link, R_MIPS16_26 is treated as a 32 bit
	 instruction stored as two 16-bit values.  The addend A is the
	 contents of the targ26 field.  The calculation is the same as
	 R_MIPS_26.  When storing the calculated value, reorder the
	 immediate value as shown above, and don't forget to store the
	 value as two 16-bit values.

	 To put it in MIPS ABI terms, the relocation field is T-targ26-16,
	 defined as
	 
	 big-endian:
	 +--------+----------------------+
	 |        |                      |
	 |        |    targ26-16         |
	 |31    26|25                   0|
	 +--------+----------------------+
	 
	 little-endian:
	 +----------+------+-------------+
	 |          |      |             |
	 |  sub1    |      |     sub2    |
	 |0        9|10  15|16         31|
	 +----------+--------------------+
	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
	 ((sub1 << 16) | sub2)).
	 
	 When producing a relocateable object file, the calculation is
	 (((A < 2) | (P & 0xf0000000) + S) >> 2)
	 When producing a fully linked file, the calculation is
	 let R = (((A < 2) | (P & 0xf0000000) + S) >> 2)
	 ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)  */

      if (!info->relocateable)
	/* Shuffle the bits according to the formula above.  */
	value = (((value & 0x1f0000) << 5) 
		 | ((value & 0x3e00000) >> 5) 
		 | (value & 0xffff));
      
    }
  else if (r_type == R_MIPS16_GPREL)
    {
      /* R_MIPS16_GPREL is used for GP-relative addressing in mips16
	 mode.  A typical instruction will have a format like this:

	 +--------------+--------------------------------+
	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  !
	 +--------------+--------------------------------+
	 !    Major     !   rx   !   ry   !   Imm  4:0   !
	 +--------------+--------------------------------+
	 
	 EXTEND is the five bit value 11110.  Major is the instruction
	 opcode.
	 
	 This is handled exactly like R_MIPS_GPREL16, except that the
	 addend is retrieved and stored as shown in this diagram; that
	 is, the Imm fields above replace the V-rel16 field.  

         All we need to do here is shuffle the bits appropriately.  As
	 above, the two 16-bit halves must be swapped on a
	 little-endian system.  */
      value = (((value & 0x7e0) << 16)
	       | ((value & 0xf800) << 5)
	       | (value & 0x1f));
    }

  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* If required, turn JAL into JALX.  */
  if (require_jalx)
    {
      boolean ok;
      bfd_vma opcode = x >> 26;
      bfd_vma jalx_opcode;

      /* Check to see if the opcode is already JAL or JALX.  */
      if (r_type == R_MIPS16_26)
	{
	  ok = ((opcode == 0x6) || (opcode == 0x7));
	  jalx_opcode = 0x7;
	}
      else
	{
	  ok = ((opcode == 0x3) || (opcode == 0x1d));
	  jalx_opcode = 0x1d;
	}

      /* If the opcode is not JAL or JALX, there's a problem.  */
      if (!ok)
	{
	  (*_bfd_error_handler)
	    (_("%s: %s+0x%lx: jump to stub routine which is not jal"),
	     bfd_get_filename (input_bfd),
	     input_section->name,
	     (unsigned long) relocation->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      /* Make this the JALX opcode.  */
      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
    }

  /* Swap the high- and low-order 16 bits on little-endian systems
     when doing a MIPS16 relocation.  */
  if ((r_type == R_MIPS16_GPREL || r_type == R_MIPS16_26)
      && bfd_little_endian (input_bfd))
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));
  
  /* Put the value into the output.  */
  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);
  return true;
}

/* Returns true if SECTION is a MIPS16 stub section.  */

static boolean
mips_elf_stub_section_p (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
{
  const char *name = bfd_get_section_name (abfd, section);

  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
}

/* Relocate a MIPS ELF section.  */

boolean
_bfd_mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
				contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *relend;
  bfd_vma addend = 0;
  boolean use_saved_addend_p = false;
  struct elf_backend_data *bed;

  bed = get_elf_backend_data (output_bfd);
  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < relend; ++rel)
    {
      const char *name;
      bfd_vma value;
      reloc_howto_type *howto;
      boolean require_jalx;
      /* True if the relocation is a RELA relocation, rather than a
         REL relocation.  */
      boolean rela_relocation_p = true;
      int r_type = ELF32_R_TYPE (rel->r_info);

      /* Find the relocation howto for this relocation.  */
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	{
	  /* Some 32-bit code uses R_MIPS_64.  In particular, people use
	     64-bit code, but make sure all their addresses are in the 
	     lowermost or uppermost 32-bit section of the 64-bit address
	     space.  Thus, when they use an R_MIPS_64 they mean what is
	     usually meant by R_MIPS_32, with the exception that the
	     stored value is sign-extended to 64 bits.  */
	  howto = elf_mips_howto_table + R_MIPS_32;

	  /* On big-endian systems, we need to lie about the position
	     of the reloc.  */
	  if (bfd_big_endian (input_bfd))
	      rel->r_offset += 4;
	}
      else
	howto = mips_rtype_to_howto (r_type);

      if (!use_saved_addend_p)
	{
	  Elf_Internal_Shdr *rel_hdr;

	  /* If these relocations were originally of the REL variety,
	     we must pull the addend out of the field that will be
	     relocated.  Otherwise, we simply use the contents of the
	     RELA relocation.  To determine which flavor or relocation
	     this is, we depend on the fact that the INPUT_SECTION's
	     REL_HDR is read before its REL_HDR2.  */
	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
	  if ((size_t) (rel - relocs)
	      >= (rel_hdr->sh_size / rel_hdr->sh_entsize
		  * bed->s->int_rels_per_ext_rel))
	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
	  if (rel_hdr->sh_entsize == MIPS_ELF_REL_SIZE (input_bfd))
	    {
	      /* Note that this is a REL relocation.  */
	      rela_relocation_p = false;

	      /* Get the addend, which is stored in the input file.  */
	      addend = mips_elf_obtain_contents (howto, 
						 rel,
						 input_bfd,
						 contents);
	      addend &= howto->src_mask;

	      /* For some kinds of relocations, the ADDEND is a
		 combination of the addend stored in two different
		 relocations.   */
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GNU_REL_HI16
		  || (r_type == R_MIPS_GOT16
		      && mips_elf_local_relocation_p (input_bfd, rel,
						      local_sections)))
d5250 1
a5250 20
		  bfd_vma l;
		  const Elf_Internal_Rela *lo16_relocation;
		  reloc_howto_type *lo16_howto;
		  int lo;

		  /* The combined value is the sum of the HI16 addend,
		     left-shifted by sixteen bits, and the LO16
		     addend, sign extended.  (Usually, the code does
		     a `lui' of the HI16 value, and then an `addiu' of
		     the LO16 value.)  

		     Scan ahead to find a matching LO16 relocation.  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    lo = R_MIPS_GNU_REL_LO16;
		  else
		    lo = R_MIPS_LO16;
		  lo16_relocation 
		    = mips_elf_next_relocation (lo, rel, relend); 
		  if (lo16_relocation == NULL)
		    return false;
d5252 6
a5257 9
		  /* Obtain the addend kept there.  */
		  lo16_howto = mips_rtype_to_howto (lo);
		  l = mips_elf_obtain_contents (lo16_howto,
						lo16_relocation,
						input_bfd, contents);
		  l &= lo16_howto->src_mask;
		  l = mips_elf_sign_extend (l, 16);

		  addend <<= 16;
d5259 9
a5267 11
		  /* Compute the combined addend.  */
		  addend += l;
		}
	      else if (r_type == R_MIPS16_GPREL)
		{
		  /* The addend is scrambled in the object file.  See
		     mips_elf_perform_relocation for details on the
		     format.  */
		  addend = (((addend & 0x1f0000) >> 5)
			    | ((addend & 0x7e00000) >> 16)
			    | (addend & 0x1f));
d5270 5
a5274 3
	  else
	    addend = rel->r_addend;
	}
d5276 6
a5281 71
      if (info->relocateable)
	{
	  Elf_Internal_Sym *sym;
	  unsigned long r_symndx;

	  if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd)
	      && bfd_big_endian (input_bfd))
	    rel->r_offset -= 4;

	  /* Since we're just relocating, all we need to do is copy
	     the relocations back out to the object file, unless
	     they're against a section symbol, in which case we need
	     to adjust by the section offset, or unless they're GP
	     relative in which case we need to adjust by the amount
	     that we're adjusting GP in this relocateable object.  */

	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections))
	    /* There's nothing to do for non-local relocations.  */
	    continue;

	  if (r_type == R_MIPS16_GPREL 
	      || r_type == R_MIPS_GPREL16
	      || r_type == R_MIPS_GPREL32
	      || r_type == R_MIPS_LITERAL)
	    addend -= (_bfd_get_gp_value (output_bfd)
		       - _bfd_get_gp_value (input_bfd));
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    /* The addend is stored without its two least
	       significant bits (which are always zero.)  In a
	       non-relocateable link, calculate_relocation will do
	       this shift; here, we must do it ourselves.  */
	    addend <<= 2;

	  r_symndx = ELF32_R_SYM (rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;
	  
	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_GNU_REL_HI16)
	    addend = mips_elf_high (addend);
	  /* If the relocation is for an R_MIPS_26 relocation, then
	     the two low-order bits are not stored in the object file;
	     they are implicitly zero.  */
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    addend >>= 2;

	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.
	       We have to cast away constness for REL.  */
	    rel->r_addend = addend;
	  else
	    {
	      /* Otherwise, we have to write the value back out.  Note
		 that we use the source mask, rather than the
		 destination mask because the place to which we are
		 writing will be source of the addend in the final
		 link.  */
	      addend &= howto->src_mask;

	      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
		/* See the comment above about using R_MIPS_64 in the 32-bit
		   ABI.  Here, we need to update the addend.  It would be
		   possible to get away with just using the R_MIPS_32 reloc
		   but for endianness.  */
d5283 16
a5298 24
		  bfd_vma sign_bits;
		  bfd_vma low_bits;
		  bfd_vma high_bits;
		  
		  if (addend & 0x80000000u)
		    sign_bits = 0xffffffffu;
		  else
		    sign_bits = 0;
		  
		  /* If we don't know that we have a 64-bit type,
		     do two separate stores.  */
		  if (bfd_big_endian (input_bfd))
		    {
		      /* Store the sign-bits (which are most significant)
			 first.  */
		      low_bits = sign_bits;
		      high_bits = addend;
		    }
		  else
		    {
		      low_bits = addend;
		      high_bits = sign_bits;
		    }
		  bfd_put_32 (input_bfd, low_bits, 
d5300 4
a5303 3
		  bfd_put_32 (input_bfd, high_bits, 
			      contents + rel->r_offset + 4);
		  continue;
a5304 5

	      if (!mips_elf_perform_relocation (info, howto, rel, addend,
						input_bfd,  input_section, 
						contents, false))
		return false;
d5306 38
d5345 13
a5357 3
	  /* Go on to the next relocation.  */
	  continue;
	}
d5359 12
a5370 10
      /* In the N32 and 64-bit ABIs there may be multiple consecutive
	 relocations for the same offset.  In that case we are
	 supposed to treat the output of each relocation as the addend
	 for the next.  */
      if (rel + 1 < relend 
	  && rel->r_offset == rel[1].r_offset
	  && ELF32_R_TYPE (rel[1].r_info) != R_MIPS_NONE)
	use_saved_addend_p = true;
      else
	use_saved_addend_p = false;
d5372 3
a5374 41
      /* Figure out what value we are supposed to relocate.  */
      switch (mips_elf_calculate_relocation (output_bfd, 
					     input_bfd,
					     input_section,
					     info,
					     rel,
					     addend,
					     howto,
					     local_syms,
					     local_sections,
					     &value,
					     &name,
					     &require_jalx))
	{
	case bfd_reloc_continue:
	  /* There's nothing to do.  */
	  continue;

	case bfd_reloc_undefined:
	  /* mips_elf_calculate_relocation already called the
	     undefined_symbol callback.  There's no real point in
	     trying to perform the relocation at this point, so we
	     just skip ahead to the next relocation.  */
	  continue;

	case bfd_reloc_notsupported:
	  abort ();
	  break;

	case bfd_reloc_overflow:
	  if (use_saved_addend_p)
	    /* Ignore overflow until we reach the last relocation for
	       a given location.  */
	    ;
	  else
	    {
	      BFD_ASSERT (name != NULL);
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
a5375 8
	  break;

	case bfd_reloc_ok:
	  break;

	default:
	  abort ();
	  break;
d5378 1
a5378 3
      /* If we've got another relocation for the address, keep going
	 until we reach the last one.  */
      if (use_saved_addend_p)
d5380 8
a5387 3
	  addend = value;
	  continue;
	}
d5389 18
a5406 33
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	/* See the comment above about using R_MIPS_64 in the 32-bit
	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32;
	   that calculated the right value.  Now, however, we
	   sign-extend the 32-bit result to 64-bits, and store it as a
	   64-bit value.  We are especially generous here in that we
	   go to extreme lengths to support this usage on systems with
	   only a 32-bit VMA.  */
	{
	  bfd_vma sign_bits;
	  bfd_vma low_bits;
	  bfd_vma high_bits;

	  if (value & 0x80000000u)
	    sign_bits = 0xffffffffu;
	  else
	    sign_bits = 0;

	  /* If we don't know that we have a 64-bit type,
	     do two separate stores.  */
	  if (bfd_big_endian (input_bfd))
	    {
	      /* Undo what we did above.  */
	      rel->r_offset -= 4;
	      /* Store the sign-bits (which are most significant)
		 first.  */
	      low_bits = sign_bits;
	      high_bits = value;
	    }
	  else
	    {
	      low_bits = value;
	      high_bits = sign_bits;
a5407 5
	  bfd_put_32 (input_bfd, low_bits, 
		      contents + rel->r_offset);
	  bfd_put_32 (input_bfd, high_bits, 
		      contents + rel->r_offset + 4);
	  continue;
a5408 6

      /* Actually perform the relocation.  */
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd, 
					input_section, contents,
					require_jalx))
	return false;
d5415 2
a5416 2
   symbol.  We mark symbols as small common if appropriate.  This is
   also where we undo the increment of the value for a mips16 symbol.  */
d5419 5
a5423 5
boolean
_bfd_mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
a5426 7
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was small common in an input file, mark it as small
     common in the output file.  */
  if (sym->st_shndx == SHN_COMMON
      && strcmp (input_sec->name, ".scommon") == 0)
    sym->st_shndx = SHN_MIPS_SCOMMON;

a5429 1

d5438 1
a5438 4
#define ELF_DYNAMIC_INTERPRETER(abfd) 		\
   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\
    : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\
    : "/usr/lib/libc.so.1")
d5442 2
a5443 2
boolean
_bfd_mips_elf_create_dynamic_sections (abfd, info)
a5466 7
  /* Create the .msym section on IRIX6.  It is used by the dynamic
     linker to speed up dynamic relocations, and to avoid computing
     the ELF hash for symbols.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && !mips_elf_create_msym_section (abfd))
    return false;
  
d5468 1
a5468 2
  if (bfd_get_section_by_name (abfd, 
			       MIPS_ELF_STUB_SECTION_NAME (abfd)) == NULL)
d5470 1
a5470 1
      s = bfd_make_section (abfd, MIPS_ELF_STUB_SECTION_NAME (abfd));
d5472 2
a5473 3
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
d5477 1
a5477 1
  if (IRIX_COMPAT (abfd) == ict_irix5
d5484 1
a5484 2
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
d5488 1
a5488 5
  /* On IRIX5, we adjust add some additional symbols and change the
     alignments of several sections.  There is no ABI documentation
     indicating that this is necessary on IRIX6, nor any evidence that
     the linker takes such action.  */
  if (IRIX_COMPAT (abfd) == ict_irix5)
d5578 1
a5578 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d5591 1
a5591 2
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
d5613 1
a5613 1
  if (mips_elf_got_section (abfd))
d5644 1
a5644 1
  s->_raw_size = MIPS_RESERVED_GOTNO * MIPS_ELF_GOT_SIZE (abfd);
d5650 1
a5650 1
  g->global_gotsym = NULL;
a5660 33
  elf_section_data (s)->this_hdr.sh_flags 
    |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;

  return true;
}

/* Returns the .msym section for ABFD, creating it if it does not
   already exist.  Returns NULL to indicate error.  */

static asection *
mips_elf_create_msym_section (abfd)
     bfd *abfd;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
  if (!s) 
    {
      s = bfd_make_section (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
      if (!s
	  || !bfd_set_section_flags (abfd, s, 
				     SEC_ALLOC
				     | SEC_LOAD
				     | SEC_HAS_CONTENTS
				     | SEC_LINKER_CREATED 
				     | SEC_READONLY)
	  || !bfd_set_section_alignment (abfd, s,
					 MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return NULL;
    }

  return s;
}
d5662 1
a5662 19
/* Add room for N relocations to the .rel.dyn section in ABFD.  */

static void
mips_elf_allocate_dynamic_relocations (abfd, n)
     bfd *abfd;
     unsigned int n;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, MIPS_ELF_REL_DYN_SECTION_NAME (abfd));
  BFD_ASSERT (s != NULL);
  
  if (s->_raw_size == 0)
    {
      /* Make room for a null element. */
      s->_raw_size += MIPS_ELF_REL_SIZE (abfd);
      ++s->reloc_count;
    }
  s->_raw_size += n * MIPS_ELF_REL_SIZE (abfd);
d5668 2
a5669 2
boolean
_bfd_mips_elf_check_relocs (abfd, info, sec, relocs)
a5684 1
  struct elf_backend_data *bed;
d5769 1
a5769 1
		symcount = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
d5859 1
a5859 1
      sgot = mips_elf_got_section (dynobj);
d5871 3
a5873 3
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < rel_end; ++rel)
a5875 1
      int r_type;
a5878 1
      r_type = ELF32_R_TYPE (rel->r_info);
d5897 1
a5897 1
	  switch (r_type)
a5904 3
	    case R_MIPS_GOT_PAGE:
	    case R_MIPS_GOT_OFST:
	    case R_MIPS_GOT_DISP:
d5909 5
a5913 1
	      g = mips_elf_got_info (dynobj, &sgot);
a5917 1
	    case R_MIPS_64:
d5929 1
a5929 21
      if (!h && (r_type == R_MIPS_CALL_LO16
		 || r_type == R_MIPS_GOT_LO16
		 || r_type == R_MIPS_GOT_DISP))
	{
	  /* We may need a local GOT entry for this relocation.  We
	     don't count R_MIPS_GOT_PAGE because we can estimate the
	     maximum number of pages needed by looking at the size of
	     the segment.  Similar comments apply to R_MIPS_GOT16.  We
	     don't count R_MIPS_GOT_HI16, or R_MIPS_CALL_HI16 because
	     these are always followed by an R_MIPS_GOT_LO16 or
	     R_MIPS_CALL_LO16.

	     This estimation is very conservative since we can merge
	     duplicate entries in the GOT.  In order to be less
	     conservative, we could actually build the GOT here,
	     rather than in relocate_section.  */
	  g->local_gotno++;
	  sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
	}

      switch (r_type)
d5932 4
d5939 1
a5939 1
		(_("%s: CALL16 reloc at 0x%lx not against global symbol"),
a5943 1
	  /* Fall through.  */
d5945 2
a5946 3
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  if (h != NULL)
d5948 1
a5948 2
	      /* This symbol requires a global offset table entry.  */
	      if (!mips_elf_record_global_got_symbol (h, info, g))
d5950 1
d5952 4
a5955 5
	      /* We need a stub, not a plt entry for the undefined
		 function.  But we record it as if it needs plt.  See
		 elf_adjust_dynamic_symbol in elflink.h.  */
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->type = STT_FUNC;
d5957 15
a5976 1
	case R_MIPS_GOT_DISP:
d5978 25
a6002 2
	  if (h && !mips_elf_record_global_got_symbol (h, info, g))
	    return false;
a6006 1
	case R_MIPS_64:
d6012 1
a6012 1
		  const char *name = MIPS_ELF_REL_DYN_SECTION_NAME (dynobj);
d6032 13
a6044 5
		/* When creating a shared object, we must copy these
		   reloc types into the output file as R_MIPS_REL32
		   relocs.  We make room for this reloc in the
		   .rel.dyn reloc section.  */
		mips_elf_allocate_dynamic_relocations (dynobj, 1);
d6052 1
a6052 1
		  ++hmips->possibly_dynamic_relocs;
a6053 8
	     
	      /* Even though we don't directly need a GOT entry for
		 this symbol, a symbol must have a dynamic symbol
		 table index greater that DT_MIPS_GOTSYM if there are
		 dynamic relocations against it.  */
	      if (h != NULL
		  && !mips_elf_record_global_got_symbol (h, info, g))
		return false;
d6056 1
a6056 1
	  if (SGI_COMPAT (dynobj))
d6059 1
d6066 1
a6066 1
	  if (SGI_COMPAT (dynobj))
a6070 14
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_MIPS_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_MIPS_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

d6079 1
a6079 1
	  && r_type != R_MIPS16_26
a6096 95
/* Return the section that should be marked against GC for a given
   relocation.  */

asection *
_bfd_mips_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  /* ??? Do mips16 stub sections need to be handled special?  */

  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_MIPS_GNU_VTINHERIT:
	case R_MIPS_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

boolean
_bfd_mips_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
#if 0
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_MIPS_GOT16:
      case R_MIPS_CALL16:
      case R_MIPS_CALL_HI16:
      case R_MIPS_CALL_LO16:
      case R_MIPS_GOT_HI16:
      case R_MIPS_GOT_LO16:
	/* ??? It would seem that the existing MIPS code does no sort
	   of reference counting or whatnot on its GOT and PLT entries,
	   so it is not possible to garbage collect them at this time.  */
        break;

      default:
	break;
      }
#endif

  return true;
}


d6103 2
a6104 2
boolean
_bfd_mips_elf_adjust_dynamic_symbol (info, h)
d6130 1
a6130 1
      && hmips->possibly_dynamic_relocs != 0
d6132 12
a6143 2
    mips_elf_allocate_dynamic_relocations (dynobj, 
					   hmips->possibly_dynamic_relocs);
d6159 1
a6159 2
	  s = bfd_get_section_by_name (dynobj, 
				       MIPS_ELF_STUB_SECTION_NAME (dynobj));
d6166 1
a6166 1
	  h->plt.offset = s->_raw_size;
d6202 2
a6203 2
boolean
_bfd_mips_elf_always_size_sections (output_bfd, info)
a6206 7
  asection *ri;

  /* The .reginfo section has a fixed size.  */
  ri = bfd_get_section_by_name (output_bfd, ".reginfo");
  if (ri != NULL)
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));

d6225 1
a6225 1
     PTR data ATTRIBUTE_UNUSED;
d6271 2
a6272 2
boolean
_bfd_mips_elf_size_dynamic_sections (output_bfd, info)
d6279 2
a6280 1
  struct mips_got_info *g = NULL;
d6292 2
a6293 4
	  s->_raw_size 
	    = strlen (ELF_DYNAMIC_INTERPRETER (output_bfd)) + 1;
	  s->contents 
	    = (bfd_byte *) ELF_DYNAMIC_INTERPRETER (output_bfd);
d6297 32
d6350 1
a6350 12
	    {
	      /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
	      if (s->output_section != NULL
		  && strcmp (name,
			     bfd_get_section_name (s->output_section->owner,
						   s->output_section)) == 0)
		strip = true;
	    }
d6365 2
a6366 5
	      if ((target != NULL
		   && (target->flags & SEC_READONLY) != 0
		   && (target->flags & SEC_ALLOC) != 0)
		  || strcmp (outname, 
			     MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) == 0)
d6371 1
a6371 2
	      if (strcmp (name, 
			  MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) != 0)
a6377 3
 	  bfd_size_type loadable_size = 0;
 	  bfd_size_type local_gotno;
 	  struct _bfd *sub;
d6379 1
a6379 1
 	  BFD_ASSERT (elf_section_data (s) != NULL);
d6381 1
a6381 1
 	  BFD_ASSERT (g != NULL);
d6383 5
a6387 46
 	  /* Calculate the total loadable size of the output.  That
 	     will give us the maximum number of GOT_PAGE entries
 	     required.  */
 	  for (sub = info->input_bfds; sub; sub = sub->link_next)
 	    {
 	      asection *subsection;
 
 	      for (subsection = sub->sections; 
 		   subsection; 
 		   subsection = subsection->next)
 		{
 		  if ((subsection->flags & SEC_ALLOC) == 0)
 		    continue;
 		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
 		}
 	    }
 	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

 	  /* Assume there are two loadable segments consisting of
 	     contiguous sections.  Is 5 enough?  */
 	  local_gotno = (loadable_size >> 16) + 5;
	  if (IRIX_COMPAT (output_bfd) == ict_irix6)
	    /* It's possible we will need GOT_PAGE entries as well as
	       GOT16 entries.  Often, these will be able to share GOT
	       entries, but not always.  */
	    local_gotno *= 2;

 	  g->local_gotno += local_gotno;
 	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);

 	  /* There has to be a global GOT entry for every symbol with
 	     a dynamic symbol table index of DT_MIPS_GOTSYM or
 	     higher.  Therefore, it make sense to put those symbols
 	     that need GOT entries at the end of the symbol table.  We
 	     do that here.  */
 	  if (!mips_elf_sort_hash_table (info, 1))
 	    return false;

	  if (g->global_gotsym != NULL)
	    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
	  else
	    /* If there are no global symbols, or none requiring
	       relocations, then GLOBAL_GOTSYM will be NULL.  */
	    i = 0;
	  g->global_gotno = i;
	  s->_raw_size += i * MIPS_ELF_GOT_SIZE (dynobj);
d6389 1
a6389 1
      else if (strcmp (name, MIPS_ELF_STUB_SECTION_NAME (output_bfd)) == 0)
a6405 5
      else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (output_bfd))
	       == 0)
	s->_raw_size = (sizeof (Elf32_External_Msym) 
			* (elf_hash_table (info)->dynsymcount
			   + bfd_count_sections (output_bfd)));
d6414 9
a6422 1
	  _bfd_strip_section_from_output (info, s);
d6427 1
a6427 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d6433 1
d6449 1
a6449 1
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
d6453 1
a6453 1
	    if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
d6459 1
a6459 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
d6463 1
a6463 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
d6466 1
a6466 2
      if (bfd_get_section_by_name (dynobj,
				   MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)))
d6468 1
a6468 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
d6471 1
a6471 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
d6474 1
a6474 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
d6478 1
a6478 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
d6481 1
a6481 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
d6486 1
a6486 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICT, 0))
d6492 1
a6492 1
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLIST, 0))
d6496 1
a6496 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
d6499 1
a6499 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
d6504 1
a6504 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0))
d6509 1
a6509 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0))
d6514 1
a6514 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0))
d6518 1
a6518 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
d6521 1
a6521 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
d6524 1
a6524 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
d6527 1
a6527 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
d6530 1
a6530 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
d6533 1
a6533 2
      if (IRIX_COMPAT (dynobj) == ict_irix5
	  && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
d6536 4
a6539 5
      if (IRIX_COMPAT (dynobj) == ict_irix6
	  && (bfd_get_section_by_name 
	      (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	return false;
d6541 4
a6544 4
      if (bfd_get_section_by_name (dynobj, 
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_MSYM, 0))
	return false;
d6547 73
d6623 2
a6624 2
/* If NAME is one of the special IRIX6 symbols defined by the linker,
   adjust it appropriately now.  */
d6626 4
a6629 5
static void
mips_elf_irix6_finish_dynamic_symbol (abfd, name, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
     Elf_Internal_Sym *sym;
d6631 5
a6635 40
  /* The linker script takes care of providing names and values for
     these, but we must place them into the right sections.  */
  static const char* const text_section_symbols[] = {
    "_ftext",
    "_etext",
    "__dso_displacement",
    "__elf_header",
    "__program_header_table",
    NULL
  };

  static const char* const data_section_symbols[] = {
    "_fdata",
    "_edata",
    "_end",
    "_fbss",
    NULL
  };

  const char* const *p;
  int i;

  for (i = 0; i < 2; ++i)
    for (p = (i == 0) ? text_section_symbols : data_section_symbols; 
	 *p;
	 ++p)
      if (strcmp (*p, name) == 0)
	{
	  /* All of these symbols are given type STT_SECTION by the
	     IRIX6 linker.  */
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  
	  /* The IRIX linker puts these symbols in special sections.  */
	  if (i == 0)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else
	    sym->st_shndx = SHN_MIPS_DATA;
	  
	  break;
	}
d6641 2
a6642 2
boolean
_bfd_mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
a6650 1
  asection *smsym;
a6652 1
  struct mips_elf_link_hash_entry *mh;
a6655 1
  mh = (struct mips_elf_link_hash_entry *) h;
d6657 1
a6657 1
  if (h->plt.offset != (bfd_vma) -1)
d6667 1
a6667 2
      s = bfd_get_section_by_name (dynobj, 
				   MIPS_ELF_STUB_SECTION_NAME (dynobj));
d6685 2
a6686 2
      BFD_ASSERT (h->plt.offset <= s->_raw_size);
      memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);
d6688 1
a6688 1
      /* Mark the symbol as undefined.  plt.offset != -1 occurs
d6695 1
a6695 1
      gval = s->output_section->vma + s->output_offset + h->plt.offset;
d6701 1
a6701 1
  sgot = mips_elf_got_section (dynobj);
d6707 1
a6707 4
  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
d6709 1
a6709 2
      bfd_vma offset;
      bfd_vma value;
d6711 9
a6719 28
      if (sym->st_value)
	value = sym->st_value;
      else
	/* For an entity defined in a shared object, this will be
	   NULL.  (For functions in shared objects for
	   which we have created stubs, ST_VALUE will be non-NULL.
	   That's because such the functions are now no longer defined
	   in a shared object.)  */
	value = h->root.u.def.value;

      offset = mips_elf_global_got_index (dynobj, h);
      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);
    }

  /* Create a .msym entry, if appropriate.  */
  smsym = bfd_get_section_by_name (dynobj, 
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj));
  if (smsym)
    {
      Elf32_Internal_Msym msym;

      msym.ms_hash_value = bfd_elf_hash (h->root.root.string);
      /* It is undocumented what the `1' indicates, but IRIX6 uses
	 this value.  */
      msym.ms_info = ELF32_MS_INFO (mh->min_dyn_reloc_index, 1);
      bfd_mips_elf_swap_msym_out 
	(dynobj, &msym,
	 ((Elf32_External_Msym *) smsym->contents) + h->dynindx);
a6764 4
  /* Handle the IRIX6-specific symbols.  */
  if (IRIX_COMPAT (output_bfd) == ict_irix6)
    mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);

d6781 2
a6782 4
	  /* IRIX6 does not use a .rld_map section.  */
	  if (IRIX_COMPAT (output_bfd) == ict_irix5)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map") 
			!= NULL);
d6797 2
a6798 2
boolean
_bfd_mips_elf_finish_dynamic_sections (output_bfd, info)
d6811 1
a6811 1
  sgot = mips_elf_got_section (dynobj);
d6823 1
a6823 1
      bfd_byte *b;
d6828 3
a6830 3
      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->_raw_size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
a6835 1
	  boolean swap_out_p;
d6837 1
a6837 5
	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);
	  
	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = true;
d6841 3
d6845 1
a6845 3
	      s = (bfd_get_section_by_name 
		   (dynobj,
		    MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)));
d6847 2
a6848 1
	      dyn.d_un.d_val = MIPS_ELF_REL_SIZE (dynobj);
d6855 1
d6870 1
d6875 1
d6880 1
d6902 2
d6908 1
a6912 1
	      swap_out_p = false;
a6916 1
	      swap_out_p = false;
d6923 1
d6928 1
a6930 17
	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      if (g->global_gotsym)
		{
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		 to setting DT_MIPS_GOTSYM to the same value as
		 DT_MIPS_SYMTABNO, so we just fall through.  */

d6933 1
a6933 1
	      elemsize = MIPS_ELF_SYM_SIZE (output_bfd);
d6941 12
d6957 1
d6962 1
a6964 15
	    case DT_MIPS_OPTIONS:
	      s = (bfd_get_section_by_name 
		   (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_MSYM:
	      s = (bfd_get_section_by_name 
		   (output_bfd, MIPS_ELF_MSYM_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    default:
	      swap_out_p = false;
	      break;
a6965 4

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out) 
	      (dynobj, &dyn, b);
d6974 2
a6975 3
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, 
			 sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
d6979 1
a6979 2
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
      = MIPS_ELF_GOT_SIZE (output_bfd);
d6982 1
a6982 1
    asection *smsym;
d6984 6
d6992 5
a6996 7
    /* ??? The section symbols for the output sections were set up in
       _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these
       symbols.  Should we do so?  */

    smsym = bfd_get_section_by_name (dynobj, 
				     MIPS_ELF_MSYM_SECTION_NAME (dynobj));
    if (smsym != NULL)
d6998 6
a7003 1
	Elf32_Internal_Msym msym;
d7005 28
a7032 2
	msym.ms_hash_value = 0;
	msym.ms_info = ELF32_MS_INFO (0, 1);
d7034 6
a7039 1
	for (s = output_bfd->sections; s != NULL; s = s->next)
d7041 8
a7048 1
	    long dynindx = elf_section_data (s)->dynindx;
d7050 16
a7065 4
	    bfd_mips_elf_swap_msym_out 
	      (output_bfd, &msym,
	       (((Elf32_External_Msym *) smsym->contents)
		+ dynindx));
d7087 1
a7087 2
	    s = bfd_get_section_by_name (dynobj, 
					 MIPS_ELF_STUB_SECTION_NAME (dynobj));
d7101 1
a7101 2
    s = bfd_get_section_by_name (dynobj, 
				 MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
d7103 1
a7103 1
      memset (s->contents, 0, MIPS_ELF_REL_SIZE (dynobj));
d7256 1
a7256 2
			 input_bfd, input_section, (*parent)->address,
			 true)))
d7350 1
a7350 3
#define elf_backend_can_gc_sections	true
#define elf_backend_sign_extend_vma	true
#define elf_info_to_howto		mips_info_to_howto_rela
d7353 2
a7354 2
#define elf_backend_object_p		_bfd_mips_elf_object_p
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
d7358 1
a7358 1
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
d7361 2
a7362 2
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
a7365 22
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_create_dynamic_sections \
					_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					_bfd_mips_elf_size_dynamic_sections
#define elf_backend_relocate_section	_bfd_mips_elf_relocate_section
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_finish_dynamic_symbol \
					_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook

#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0
d7372 2
a7373 2
					_bfd_mips_elf_link_hash_table_create
#define bfd_elf32_bfd_final_link	_bfd_mips_elf_final_link
d7379 18
a7396 2
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_mips_elf_print_private_bfd_data
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d5933 1
a5933 2
      else if (info->shared && !info->symbolic && !info->no_undefined
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
d5951 1
a5951 2
		  (!info->shared || info->no_undefined
		   || ELF_ST_VISIBILITY (h->root.other)))))
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a7 2
   Traditional MIPS targets support added by Koundinya.K, Dansk Data
   Elektronik & Operations Research Group. <kk@@ddeorg.soft.net>
d43 1
a43 1
#define ECOFF_SIGNED_32
d73 1
a73 1
     this symbol.  */
a79 6
  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  boolean no_fn_stub;

d112 1
a112 1
static void bfd_mips_elf_swap_msym_in
d142 1
a142 1
static asection *mips_elf_create_msym_section
d144 1
a144 1
static void mips_elf_irix6_finish_dynamic_symbol
d157 1
a157 1
static boolean mips_elf_record_global_got_symbol
d163 1
a163 1
  PARAMS ((unsigned int, const Elf_Internal_Rela *,
d173 1
a173 1
  PARAMS ((struct bfd_link_info *, reloc_howto_type *,
d177 1
a177 1
static boolean mips_elf_sort_hash_table_f
d179 1
a179 1
static boolean mips_elf_sort_hash_table
d182 1
a182 1
static struct mips_got_info *mips_elf_got_info
d185 2
a186 2
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, boolean));
static bfd_vma mips_elf_create_local_got_entry
d188 3
a190 3
static bfd_vma mips_elf_got16_entry
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, boolean));
static boolean mips_elf_create_dynamic_relocation
d194 1
a194 1
static void mips_elf_allocate_dynamic_relocations
d196 1
a196 1
static boolean mips_elf_stub_section_p
a197 9
static int sort_dynamic_relocs
  PARAMS ((const void *, const void *));

extern const bfd_target bfd_elf32_tradbigmips_vec;
extern const bfd_target bfd_elf32_tradlittlemips_vec;
#ifdef BFD64
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
#endif
a206 3
/* This will be used when we sort the dynamic relocation records.  */
static bfd *reldyn_sorting_bfd;

d212 2
a213 1
/* Nonzero if ABFD is using the 64-bit ABI. */
d217 4
a220 3
/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
#ifdef BFD64
d222 1
a222 11
  (((abfd->xvec == &bfd_elf64_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf64_tradlittlemips_vec) || \
    (abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#else
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#endif
d225 1
d300 4
a303 6
   : 0x8f998010)		/* lw t9,0x8000(gp) */
#define STUB_MOVE(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x03e07825 : 0x03e07821)         /* move t7,ra */
#define STUB_JALR 0x0320f809				/* jal t9 */
#define STUB_LI16(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x34180000 : 0x24180000)         /* ori t8,zero,0 */
d373 1
a373 1
  unsigned int rtype : 4;	/* Relocation types. See below.  */
d383 1
a383 1
  unsigned int rtype : 4;	/* Relocation types. See below.  */
d512 1
a512 1
  /* 26 bit jump address.  */
d522 1
a522 1
				   bits must match the PC + 4.  */
d878 1
a878 1
  /* Protected jump conversion.  This is an optimization hint.  No
d947 1
d1224 1
a1224 1
	  insn = (insn & ~0xffff) | ((val >> 16) & 0xffff);
d1516 1
a1516 1
  insn = (insn & ~0xffff) | (val & 0xffff);
d1523 1
a1523 1
  if ((long) val >= 0x8000 || (long) val < -0x8000)
d1641 1
a1641 1
   generated when addresses are 64 bits.  The upper 32 bits are a simple
a1813 6
    case E_MIPS_ARCH_5:
      return 5;
    case E_MIPS_ARCH_32:
      return 32;
    case E_MIPS_ARCH_64:
      return 64;
a1840 6
    case E_MIPS_MACH_MIPS32_4K:
      return bfd_mach_mips32_4k;

    case E_MIPS_MACH_SB1:
      return bfd_mach_mips_sb1;

a1859 12

	case E_MIPS_ARCH_5:
	  return bfd_mach_mips5;
	  break;

	case E_MIPS_ARCH_32:
	  return bfd_mach_mips32;
	  break;

	case E_MIPS_ARCH_64:
	  return bfd_mach_mips64;
	  break;
d1866 1
a1866 1
/* Return printable name for ABI.  */
d1868 1
a1868 1
static INLINE char *
d1878 1
a1878 1

d2251 1
d2259 1
d2265 1
a2265 6
  if (SGI_COMPAT(abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
            || bfd_is_und_section (bfd_get_section (sym))
            || bfd_is_com_section (bfd_get_section (sym)));
d2289 1
a2337 2
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
a2339 20

    case bfd_mach_mips32:
      val = E_MIPS_ARCH_32;
      break;

    case bfd_mach_mips32_4k:
      val = E_MIPS_ARCH_32 | E_MIPS_MACH_MIPS32_4K;
      break;

    case bfd_mach_mips5:
      val = E_MIPS_ARCH_5;
      break;

    case bfd_mach_mips64:
      val = E_MIPS_ARCH_64;
      break;

    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;
d2342 1
a2342 1
  elf_elfheader (abfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
d2414 1
a2414 1
/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */
a2460 2
  boolean null_input_bfd = true;
  asection *sec;
d2463 15
a2477 2
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;
d2491 1
a2491 1
      elf_elfheader (obfd)->e_ident[EI_CLASS]
a2512 21
  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic sections and empty .text, .data and .bss sections
	  which are automatically generated by gas.  */
      if (strcmp (sec->name, ".reginfo")
	  && strcmp (sec->name, ".mdebug")
	  && ((!strcmp (sec->name, ".text")
	       || !strcmp (sec->name, ".data")
	       || !strcmp (sec->name, ".bss"))
	      && sec->_raw_size != 0))
	{
	  null_input_bfd = false;
	  break;
	}
    }
  if (null_input_bfd)
    return true;

d2535 1
a2535 1
  /* Compare the ISA's.  */
d2545 2
a2546 2
	 Some combinations of machines are ok, if the isa's match.  */
      if (! new_mach
d2551 7
a2557 6
	  /* Don't warn about mixing code using 32-bit ISAs, or mixing code
	     using 64-bit ISAs.  They will normally use the same data sizes
	     and calling conventions.  */

	  if ((  (new_isa == 1 || new_isa == 2 || new_isa == 32)
	       ^ (old_isa == 1 || old_isa == 2 || old_isa == 32)) != 0)
d2576 2
a2577 2
      new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
d2583 1
a2583 1
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
d2586 1
a2586 1
      /* Only error if both are set (to different values).  */
d2588 1
a2588 1
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
d2634 1
a2634 1
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2637 1
a2637 1
    fprintf (file, _(" [abi=O32]"));
d2639 1
a2639 1
    fprintf (file, _(" [abi=O64]"));
d2641 1
a2641 1
    fprintf (file, _(" [abi=EABI32]"));
d2643 1
a2643 1
    fprintf (file, _(" [abi=EABI64]"));
d2645 1
a2645 1
    fprintf (file, _(" [abi unknown]"));
d2647 1
a2647 1
    fprintf (file, _(" [abi=N32]"));
d2649 1
a2649 1
    fprintf (file, _(" [abi=64]"));
d2651 1
a2651 1
    fprintf (file, _(" [no abi set]"));
d2654 1
a2654 1
    fprintf (file, _(" [mips1]"));
d2656 1
a2656 1
    fprintf (file, _(" [mips2]"));
d2658 1
a2658 1
    fprintf (file, _(" [mips3]"));
d2660 1
a2660 7
    fprintf (file, _(" [mips4]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_5)
    fprintf (file, _ (" [mips5]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32)
    fprintf (file, _ (" [mips32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64)
    fprintf (file, _ (" [mips64]"));
d2662 1
a2662 1
    fprintf (file, _(" [unknown ISA]"));
d2665 1
a2665 1
    fprintf (file, _(" [32bitmode]"));
d2667 1
a2667 1
    fprintf (file, _(" [not 32bitmode]"));
d2887 2
a2888 7
      if (SGI_COMPAT (abfd))
	{
	  if ((abfd->flags & DYNAMIC) != 0)
	    hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
	  else
	    hdr->sh_entsize = 1;
	}
d2890 1
a2890 1
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
d2897 1
a2897 2
      if (SGI_COMPAT (abfd))
	hdr->sh_entsize = 0;
d2959 1
a2959 1
      esd->rel_hdr2
d2979 1
a2979 1
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
d3115 1
a3115 1
			    SEEK_SET) == -1)
d3166 1
d3184 12
d3282 3
d3292 1
a3292 1
      && bfd_get_section_by_name (abfd,
d3314 3
d3367 1
a3367 1
	  for (pm = &elf_tdata (abfd)->segment_map;
d3373 1
a3373 1
	  options_segment = bfd_zalloc (abfd,
d3386 5
a3390 1
      if (IRIX_COMPAT (abfd) == ict_irix5)
d3392 4
a3395 5
	  /* If there are .dynamic and .mdebug sections, we make a room
	     for the RTPROC header.  FIXME: Rewrite without section names.  */
	  if (bfd_get_section_by_name (abfd, ".interp") == NULL
	      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d3397 1
a3397 3
	      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
		if (m->p_type == PT_MIPS_RTPROC)
		  break;
d3399 1
a3399 4
		{
		  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
		  if (m == NULL)
		    return false;
d3401 1
a3401 1
		  m->p_type = PT_MIPS_RTPROC;
d3403 12
a3414 12
		  s = bfd_get_section_by_name (abfd, ".rtproc");
		  if (s == NULL)
		    {
		      m->count = 0;
		      m->p_flags = 0;
		      m->p_flags_valid = 1;
		    }
		  else
		    {
		      m->count = 1;
		      m->sections[0] = s;
		    }
d3416 6
a3421 6
		  /* We want to put it after the DYNAMIC segment.  */
		  pm = &elf_tdata (abfd)->segment_map;
		  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		    pm = &(*pm)->next;
		  if (*pm != NULL)
		    pm = &(*pm)->next;
d3423 2
a3424 3
		  m->next = *pm;
		  *pm = m;
		}
d3427 1
d3431 1
a3431 2
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL;
	   pm = &(*pm)->next)
a3434 12
      if (IRIX_COMPAT (abfd) == ict_none)
	{
	  /* For a normal mips executable the permissions for the PT_DYNAMIC
	     segment are read, write and execute. We do that here since
	     the code in elf.c sets only the read permission. This matters
	     sometimes for the dynamic linker.  */
	  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
	    {
	      m->p_flags = PF_R | PF_W | PF_X;
	      m->p_flags_valid = 1;
	    }
	}
d3436 2
a3437 1
	  && m->count == 1 && strcmp (m->sections[0]->name, ".dynamic") == 0)
d3440 1
a3440 3
	  {
	    ".dynamic", ".dynstr", ".dynsym", ".hash"
	  };
d3469 2
a3470 2
		     + (s->_cooked_size !=
			0 ? s->_cooked_size : s->_raw_size)) <= high))
d3487 2
a3488 1
			  s->_cooked_size : s->_raw_size)) <= high))
d3518 1
a3518 1
#define cbRPDR sizeof (RPDR)
d3563 1
a3563 1
  memset (debug, 0, sizeof (*debug));
d3642 1
d3685 2
a3686 3
				     line_ptr,
				     ABI_64_P (abfd) ? 8 : 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
d3825 1
a3825 1
     entry is set to the address of __rld_obj_head as in Irix 5.  */
d3829 1
a3829 1
  /* This is set if we see any mips16 stub sections.  */
a3888 1
      ret->no_fn_stub = false;
a3897 22
void
_bfd_mips_elf_hide_symbol (info, h)
     struct bfd_link_info *info;
     struct mips_elf_link_hash_entry *h;
{
  bfd *dynobj;
  asection *got;
  struct mips_got_info *g;
  dynobj = elf_hash_table (info)->dynobj;
  got = bfd_get_section_by_name (dynobj, ".got");
  g = (struct mips_got_info *) elf_section_data (got)->tdata;

  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  h->root.plt.offset = (bfd_vma) -1;
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;

  /* FIXME: Do we allocate too much GOT space here?  */
  g->local_gotno++;
  got->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
}

d3935 1
d3972 1
a3972 1
      if (elf_tdata (abfd)->elf_text_section == NULL)
a3973 11
	  asymbol *elf_text_symbol;
	  asection *elf_text_section;

	  elf_text_section = bfd_zalloc (abfd, sizeof (asection));
	  if (elf_text_section == NULL)
	    return false;

	  elf_text_symbol = bfd_zalloc (abfd, sizeof (asymbol));
	  if (elf_text_symbol == NULL)
	    return false;

d3975 10
a3984 14

	  elf_tdata (abfd)->elf_text_section = elf_text_section;
	  elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;

	  elf_text_section->symbol = elf_text_symbol;
	  elf_text_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_text_symbol;

	  elf_text_section->name = ".text";
	  elf_text_section->flags = SEC_NO_FLAGS;
	  elf_text_section->output_section = NULL;
	  elf_text_section->owner = abfd;
	  elf_text_symbol->name = ".text";
	  elf_text_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_text_symbol->section = elf_text_section;
d3989 1
a3989 1
      *secp = elf_tdata (abfd)->elf_text_section;
d3996 1
a3996 1
      if (elf_tdata (abfd)->elf_data_section == NULL)
a3997 11
	  asymbol *elf_data_symbol;
	  asection *elf_data_section;

	  elf_data_section = bfd_zalloc (abfd, sizeof (asection));
	  if (elf_data_section == NULL)
	    return false;

	  elf_data_symbol = bfd_zalloc (abfd, sizeof (asymbol));
	  if (elf_data_symbol == NULL)
	    return false;

d3999 10
a4008 14

	  elf_tdata (abfd)->elf_data_section = elf_data_section;
	  elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;

	  elf_data_section->symbol = elf_data_symbol;
	  elf_data_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_data_symbol;

	  elf_data_section->name = ".data";
	  elf_data_section->flags = SEC_NO_FLAGS;
	  elf_data_section->output_section = NULL;
	  elf_data_section->owner = abfd;
	  elf_data_symbol->name = ".data";
	  elf_data_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_data_symbol->section = elf_data_section;
d4013 1
a4013 1
      *secp = elf_tdata (abfd)->elf_data_section;
d4036 1
a4036 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d4118 3
a4120 2
      if (h->root.root.type == bfd_link_hash_undefined
	  || h->root.root.type == bfd_link_hash_undefweak)
d4215 6
a4220 4
      struct mips_elf_link_hash_entry *hd = h;
      boolean no_fn_stub = h->no_fn_stub;

      while (hd->root.root.type == bfd_link_hash_indirect)
d4222 7
a4228 2
	  hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
a4229 18

      if (!no_fn_stub)
	{
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
d4231 1
a4231 1
	  h->esym.ifd = 0;
a4232 1
	}
a4429 14
  asection *s;
  EXTR esym;
  bfd_vma last;
  unsigned int i;
  static const char * const name[] =
  {
    ".text", ".init", ".fini", ".data",
    ".rodata", ".sdata", ".sbss", ".bss"
  };
  static const int sc[] =
  {
    scText, scInit, scFini, scData,
    scRData, scSData, scSBss, scBss
  };
d4458 1
a4458 1
      if (!mips_elf_sort_hash_table (info, (info->shared
d4461 1
a4461 1
	return false;
d4478 1
a4478 1
  if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
d4485 1
a4485 1
		p->u.indirect.section->flags &= ~SEC_HAS_CONTENTS;
d4489 1
a4489 1

d4512 1
a4512 1
	    if (o->vma < lo
d4586 1
a4586 1
	      input_section->flags &= ~SEC_HAS_CONTENTS;
d4640 1
a4640 11
	  esym.jmptbl = 0;
	  esym.cobol_main = 0;
	  esym.weakext = 0;
	  esym.reserved = 0;
	  esym.ifd = ifdNil;
	  esym.asym.iss = issNil;
	  esym.asym.st = stLocal;
	  esym.asym.reserved = 0;
	  esym.asym.index = indexNil;
	  last = 0;
	  for (i = 0; i < 8; i++)
d4642 21
a4662 3
	      esym.asym.sc = sc[i];
	      s = bfd_get_section_by_name (abfd, name[i]);
	      if (s != NULL)
d4664 13
a4676 2
		  esym.asym.value = s->vma;
		  last = s->vma + s->_raw_size;
a4677 5
	      else
		esym.asym.value = last;
	      if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
						 name[i], &esym))
		return false;
d4781 1
a4781 1
	      input_section->flags &= ~SEC_HAS_CONTENTS;
d4860 1
a4860 1
		  input_section->flags &= ~SEC_HAS_CONTENTS;
d5019 1
a5019 1
	      input_section->flags &= ~SEC_HAS_CONTENTS;
a5118 20
/* This function is called via qsort() to sort the dynamic relocation
   entries by increasing r_symndx value.  */

static int
sort_dynamic_relocs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  const Elf32_External_Rel *ext_reloc1 = (const Elf32_External_Rel *) arg1;
  const Elf32_External_Rel *ext_reloc2 = (const Elf32_External_Rel *) arg2;

  Elf_Internal_Rel int_reloc1;
  Elf_Internal_Rel int_reloc2;

  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc2, &int_reloc2);

  return (ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info));
}

d5129 1
a5129 1
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT
d5154 1
a5154 2
mips_elf_local_relocation_p (input_bfd, relocation, local_sections,
			     check_forced)
a5157 1
     boolean check_forced;
a5160 2
  struct mips_elf_link_hash_entry *h;
  size_t extsymoff;
d5164 3
a5166 8
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return true;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return true;

  if (check_forced)
d5168 3
a5170 10
      /* Look up the hash table to check whether the symbol
 	 was forced local.  */
      h = (struct mips_elf_link_hash_entry *)
	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
      if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return true;
a5171 2

  return false;
d5181 1
a5181 1
  if (value & ((bfd_vma) 1 << (bits - 1)))
d5183 2
a5184 2
    value |= ((bfd_vma) - 1) << bits;

d5205 1
a5205 1

d5235 1
a5235 1
static bfd_vma
d5249 1
a5249 1
static bfd_vma
d5265 1
a5265 1
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno)
d5286 1
a5286 1
  return (sgot->output_section->vma + sgot->output_offset + index -
d5305 1
a5305 1

d5320 1
a5320 1

d5335 1
a5335 1
   index.  Otherwise, assign it the lowest available dynamic
d5343 1
a5343 1
  struct mips_elf_hash_sort_data *hsd
d5383 3
a5385 3
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *)
				elf_hash_table (info)),
			       mips_elf_sort_hash_table_f,
d5390 1
a5390 1
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
d5420 1
a5420 1
		     (sgot->contents
d5442 2
a5443 2
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
d5479 1
a5479 1
  for (entry = (sgot->contents
d5512 1
a5512 1
mips_elf_got16_entry (abfd, info, value, external)
a5515 1
     boolean external;
d5524 5
a5528 9
  if (! external)
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
      value = mips_elf_high (value) << 16;
    }

d5533 1
a5533 1
  for (entry = (sgot->contents
d5539 1
a5539 1
      if (address == value)
d5541 1
a5541 2
	  /* This entry has the right high-order 16 bits, and the low-order
	     16 bits are set to zero.  */
d5584 1
a5584 1
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
d5607 1
a5607 1
  sreloc
a5610 1
  BFD_ASSERT (sreloc->contents != NULL);
d5625 1
a5625 1
      outrel.r_offset
d5637 1
a5637 1
  /* If we've decided to skip this relocation, just output an empty
d5654 1
a5654 4
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  if (indx == -1)
	    indx = 0;
d5678 1
a5678 1
	  *addendp += section_offset;
d5682 5
a5686 6

      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (!indx && r_type != R_MIPS_REL32)
d5706 1
a5706 1
	 (sreloc->contents
d5718 1
a5718 1
      && (h->min_dyn_reloc_index == 0
d5733 1
a5733 1
      asection *scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
d5777 1
a5777 1
mips_elf_calculate_relocation (abfd,
d5788 1
a5788 1
			       require_jalxp)
d5822 1
a5822 1
  struct mips_elf_link_hash_entry *h = NULL;
d5841 1
a5841 1
  p = (input_section->output_section->vma
d5852 1
a5852 1
					 local_sections, false);
d5861 1
a5861 1

d5890 1
a5890 1
      h = ((struct mips_elf_link_hash_entry *)
d5893 2
a5894 2
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
d5896 1
a5896 1

d5921 1
a5921 1
	    symbol = (h->root.root.u.def.value
d5936 1
a5936 2
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0 ||
              strcmp (h->root.root.root.string, "_DYNAMIC_LINKING") == 0)
d5939 1
a5939 2
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol
	     in in mips_elf_create_dynamic_sections.
d5960 1
a5960 1

d5986 1
a5986 1
	   && h != NULL
a6023 3
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, true);

d6039 1
a6039 1
	  g = mips_elf_global_got_index
d6041 1
a6041 14
	     (struct elf_link_hash_entry *) h);
	  if (! elf_hash_table(info)->dynamic_sections_created
	      || (info->shared
		  && (info->symbolic || h->root.dynindx == -1)
		  && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      /* This is a static link or a -Bsymbolic link.  The
		 symbol is defined locally, or was forced to be local.
		 We must initialize this entry in the GOT.  */
	      asection *sgot = mips_elf_got_section(elf_hash_table
						    (info)->dynobj);
	      MIPS_ELF_PUT_WORD (elf_hash_table (info)->dynobj,
				 symbol + addend, sgot->contents + g);
	    }
d6043 1
a6043 1
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
d6058 1
a6058 1

d6089 2
a6090 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		   != 0)))
d6099 2
a6100 2
	  if (!mips_elf_create_dynamic_relocation (abfd,
						   info,
d6138 1
a6138 1
      /* The calculation for R_MIPS16_26 is just the same as for an
d6145 1
a6145 1
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
d6209 1
a6209 1

a6210 1
    case R_MIPS_CALL16:
d6213 1
a6213 8
	  boolean forced;

	  /* The special case is when the symbol is forced to be local.  We
	     need the full address in the GOT since no R_MIPS_LO16 relocation
	     follows.  */
	  forced = ! mips_elf_local_relocation_p (input_bfd, relocation,
						  local_sections, false);
	  value = mips_elf_got16_entry (abfd, info, symbol + addend, forced);
d6216 1
a6216 1
	  value
d6226 1
d6266 1
a6266 1

d6286 1
a6286 1

d6349 1
a6349 1
			     input_bfd, input_section,
d6388 1
a6388 1

d6413 1
a6413 1

d6420 1
a6420 1

d6429 1
a6429 1

d6431 1
a6431 1
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
d6433 1
a6433 1
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
d6438 2
a6439 2
	value = (((value & 0x1f0000) << 5)
		 | ((value & 0x3e00000) >> 5)
d6441 1
d6453 1
a6453 1

d6456 1
a6456 1

d6459 1
a6459 1
	 is, the Imm fields above replace the V-rel16 field.
d6512 1
a6512 1

a6563 1
      const char * msg = (const char *) NULL;
d6569 1
a6569 1
	     64-bit code, but make sure all their addresses are in the
d6579 1
a6579 1
	    rel->r_offset += 4;
d6596 2
a6597 1
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
d6605 1
a6605 1
	      addend = mips_elf_obtain_contents (howto,
d6618 1
a6618 1
						      local_sections, false)))
d6629 1
a6629 1
		     the LO16 value.)
d6636 2
a6637 2
		  lo16_relocation
		    = mips_elf_next_relocation (lo, rel, relend);
d6684 1
a6684 2
	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections,
					    false))
d6688 1
a6688 1
	  if (r_type == R_MIPS16_GPREL
d6707 1
a6707 1

d6743 3
a6745 3

		  if (addend & ((bfd_vma) 1 << 31))
		    sign_bits = ((bfd_vma) 1 << 32) - 1;
d6748 1
a6748 1

d6763 1
a6763 1
		  bfd_put_32 (input_bfd, low_bits,
d6765 1
a6765 1
		  bfd_put_32 (input_bfd, high_bits,
d6771 1
a6771 1
						input_bfd,  input_section,
d6784 1
a6784 1
      if (rel + 1 < relend
d6792 1
a6792 1
      switch (mips_elf_calculate_relocation (output_bfd,
d6817 2
a6818 4
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return false;
d6864 2
a6865 2
	  if (value & ((bfd_vma) 1 << 31))
	    sign_bits = ((bfd_vma) 1 << 32) - 1;
d6885 1
a6885 1
	  bfd_put_32 (input_bfd, low_bits,
d6887 1
a6887 1
	  bfd_put_32 (input_bfd, high_bits,
d6893 1
a6893 1
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd,
d6906 1
d6972 1
a6972 1

d6974 1
a6974 1
  if (bfd_get_section_by_name (abfd,
d6985 1
a6985 1
  if ((IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
d7012 1
a7012 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d7021 2
a7022 5
      if (SGI_COMPAT (abfd))
	{
	  if (!mips_elf_create_compact_rel_section (abfd, info))
	    return false;
	}
d7045 7
a7051 20
      if (SGI_COMPAT (abfd))
	{
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      else
	{
	  /* For normal mips it is _DYNAMIC_LINKING.  */
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINKING", BSF_GLOBAL,
		 bfd_abs_section_ptr, (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d7068 7
a7074 20
	  if (SGI_COMPAT (abfd))
	    {
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__rld_map", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  else
	    {
	      /* For normal mips the symbol is __RLD_MAP.  */
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__RLD_MAP", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d7114 1
a7114 1
/* Create the .got section to hold the global offset table.  */
d7149 1
a7149 1
  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d7175 1
a7175 1
  elf_section_data (s)->this_hdr.sh_flags
d7191 1
a7191 1
  if (!s)
d7195 1
a7195 1
	  || !bfd_set_section_flags (abfd, s,
d7199 1
a7199 1
				     | SEC_LINKER_CREATED
d7220 1
a7220 1

d7223 1
a7223 1
      /* Make room for a null element.  */
d7328 1
a7328 1
             this BFD.  */
d7335 1
a7335 1
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
a7449 7
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler)
	    (_("Malformed reloc detected for section %s"), name);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
d7504 4
a7507 4
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.
d7597 1
a7597 1

d7607 1
a7607 1
	  if (SGI_COMPAT (abfd))
d7616 1
a7616 1
	  if (SGI_COMPAT (abfd))
a7638 19
      /* We must not create a stub for a symbol that has relocations
         related to taking the function's address.  */
      switch (r_type)
	{
	default:
	  if (h != NULL)
	    {
	      struct mips_elf_link_hash_entry *mh;

	      mh = (struct mips_elf_link_hash_entry *) h;
	      mh->no_fn_stub = true;
	    }
	  break;
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  break;
	}

d7641 1
a7641 1
         References from a stub section do not count.  */
d7745 1
a7745 1
	break;
a7754 22
/* Copy data from a MIPS ELF indirect symbol to its direct symbol,
   hiding the old indirect symbol.  Process additional relocation
   information.  */

void
_bfd_mips_elf_copy_indirect_symbol (dir, ind)
     struct elf_link_hash_entry *dir, *ind;
{
  struct mips_elf_link_hash_entry *dirmips, *indmips;

  _bfd_elf_link_hash_copy_indirect (dir, ind);

  dirmips = (struct mips_elf_link_hash_entry *) dir;
  indmips = (struct mips_elf_link_hash_entry *) ind;
  dirmips->possibly_dynamic_relocs += indmips->possibly_dynamic_relocs;
  if (dirmips->min_dyn_reloc_index == 0
      || (indmips->min_dyn_reloc_index != 0
	  && indmips->min_dyn_reloc_index < dirmips->min_dyn_reloc_index))
    dirmips->min_dyn_reloc_index = indmips->min_dyn_reloc_index;
  if (indmips->no_fn_stub)
    dirmips->no_fn_stub = true;
}
d7791 1
a7791 1
    mips_elf_allocate_dynamic_relocations (dynobj,
d7794 3
a7796 3
  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d7808 1
a7808 1
	  s = bfd_get_section_by_name (dynobj,
a7825 8
  else if ((h->type == STT_FUNC)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return true;
    }
d7878 1
d7892 1
a7892 1
      h->fn_stub->flags &= ~SEC_RELOC;
d7905 1
a7905 1
      h->call_stub->flags &= ~SEC_RELOC;
d7918 1
a7918 1
      h->call_fp_stub->flags &= ~SEC_RELOC;
d7948 1
a7948 1
	  s->_raw_size
d7950 1
a7950 1
	  s->contents
d8005 1
a8005 1
		  || strcmp (outname,
d8011 1
a8011 1
	      if (strcmp (name,
d8019 3
a8021 3
	  bfd_size_type loadable_size = 0;
	  bfd_size_type local_gotno;
	  bfd *sub;
d8023 1
a8023 1
	  BFD_ASSERT (elf_section_data (s) != NULL);
d8025 1
a8025 19
	  BFD_ASSERT (g != NULL);

	  /* Calculate the total loadable size of the output.  That
	     will give us the maximum number of GOT_PAGE entries
	     required.  */
	  for (sub = info->input_bfds; sub; sub = sub->link_next)
	    {
	      asection *subsection;

	      for (subsection = sub->sections;
		   subsection;
		   subsection = subsection->next)
		{
		  if ((subsection->flags & SEC_ALLOC) == 0)
		    continue;
		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
		}
	    }
	  loadable_size += MIPS_FUNCTION_STUB_SIZE;
d8027 21
a8047 3
	  /* Assume there are two loadable segments consisting of
	     contiguous sections.  Is 5 enough?  */
	  local_gotno = (loadable_size >> 16) + 5;
d8054 2
a8055 2
	  g->local_gotno += local_gotno;
	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);
d8057 5
a8061 5
	  /* There has to be a global GOT entry for every symbol with
	     a dynamic symbol table index of DT_MIPS_GOTSYM or
	     higher.  Therefore, it make sense to put those symbols
	     that need GOT entries at the end of the symbol table.  We
	     do that here.  */
d8093 1
a8093 1
	s->_raw_size = (sizeof (Elf32_External_Msym)
d8126 1
a8126 5
	  /* SGI object has the equivalence of DT_DEBUG in the
	     DT_MIPS_RLD_MAP entry.  */
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
	    return false;
	  if (!SGI_COMPAT (output_bfd))
d8128 3
a8130 1
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
d8133 3
d8137 2
a8138 10
      else
	{
	  /* Shared libraries on traditional mips have DT_DEBUG.  */
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return false;
	    }
	}
      if (reltext && SGI_COMPAT (output_bfd))
a8141 1
	  info->flags |= DF_TEXTREL;
d8160 2
a8161 5
      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	    return false;
	}
d8163 2
a8164 5
      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	    return false;
	}
d8220 1
a8220 1
	  && (bfd_get_section_by_name
d8225 1
a8225 1
      if (bfd_get_section_by_name (dynobj,
d8266 1
a8266 1
    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
d8274 1
a8274 1

d8280 1
a8280 1

d8317 1
a8317 1
      s = bfd_get_section_by_name (dynobj,
d8323 1
a8323 1
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), p);
d8325 1
a8325 1
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), p);
d8334 1
a8334 1
      bfd_put_32 (output_bfd, STUB_LI16 (output_bfd) + h->dynindx, p);
d8350 1
a8350 2
  BFD_ASSERT (h->dynindx != -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0);
d8369 6
a8374 6
	{
	  /* For an entity defined in a shared object, this will be
	     NULL.  (For functions in shared objects for
	     which we have created stubs, ST_VALUE will be non-NULL.
	     That's because such the functions are now no longer defined
	     in a shared object.)  */
a8375 5
	  if (info->shared && h->root.type == bfd_link_hash_undefined)
	    value = 0;
	  else
	    value = h->root.u.def.value;
	}
d8381 1
a8381 1
  smsym = bfd_get_section_by_name (dynobj,
d8391 1
a8391 1
      bfd_mips_elf_swap_msym_out
d8401 1
a8401 2
  else if (strcmp (name, "_DYNAMIC_LINK") == 0
	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
a8406 6
  else if (strcmp (name, "_gp_disp") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = elf_gp (output_bfd);
    }
d8409 8
a8416 2
      if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	  || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
d8443 2
a8444 1
  if (! info->shared)
d8447 1
a8447 2
	  && (strcmp (name, "__rld_map") == 0
	      || strcmp (name, "__RLD_MAP") == 0))
d8460 2
a8461 3
	  if (IRIX_COMPAT (output_bfd) == ict_irix5
              || IRIX_COMPAT (output_bfd) == ict_none)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
d8520 1
a8520 1

d8527 1
a8527 1
	      s = (bfd_get_section_by_name
d8580 1
a8580 1
		dyn.d_un.d_val = 0;
d8645 1
a8645 1
	      s = (bfd_get_section_by_name
d8651 1
a8651 1
	      s = (bfd_get_section_by_name
d8662 1
a8662 1
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
d8669 1
a8669 1
     This isn't the case of Irix rld.  */
d8673 1
a8673 1
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
d8690 1
a8690 1
    smsym = bfd_get_section_by_name (dynobj,
d8703 1
a8703 1
	    bfd_mips_elf_swap_msym_out
d8728 1
a8728 1
	    s = bfd_get_section_by_name (dynobj,
a8741 17
    /* We need to sort the entries of the dynamic relocation section.  */

    if (!ABI_64_P (output_bfd))
      {
	asection *reldyn;

	reldyn = bfd_get_section_by_name (dynobj,
					  MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
	if (reldyn != NULL && reldyn->reloc_count > 2)
	  {
	    reldyn_sorting_bfd = output_bfd;
	    qsort ((Elf32_External_Rel *) reldyn->contents + 1,
		   (size_t) reldyn->reloc_count - 1,
		   sizeof (Elf32_External_Rel), sort_dynamic_relocs);
	  }
      }

d8743 1
a8743 1
    s = bfd_get_section_by_name (dynobj,
a8934 1

d8940 2
a8941 1
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap = {
a9034 5
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol

#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol

a9048 17
#include "elf32-target.h"

/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define TARGET_LITTLE_SYM               bfd_elf32_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf32-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf32_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf32-tradbigmips"

/* Include the target file again for this target */
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a37 1
#include "elfxx-mips.h"
d49 57
a105 8
static bfd_reloc_status_type mips_elf_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf_lo16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf_gprel32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d110 2
a111 2
static reloc_howto_type *mips_elf32_rtype_to_howto
  PARAMS ((unsigned int, bfd_boolean));
d113 1
a113 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d115 19
a133 6
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean mips_elf_sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean mips_elf32_object_p
  PARAMS ((bfd *));
static bfd_boolean mips_elf_is_local_label_name
d135 3
d142 4
d147 5
a151 8
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
static bfd_boolean mips_elf_assign_gp
  PARAMS ((bfd *, bfd_vma *));
static bfd_boolean elf32_mips_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf32_mips_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static irix_compat_t elf32_mips_irix_compat
d153 71
d225 2
a226 2
extern const bfd_target bfd_elf32_bigmips_vec;
extern const bfd_target bfd_elf32_littlemips_vec;
d229 1
d233 20
d255 61
a315 1
  (elf32_mips_irix_compat (abfd) != ict_none)
d320 156
d480 1
a480 3
/* The relocation table used for SHT_REL sections.  */

static reloc_howto_type elf_mips_howto_table_rel[] =
d487 1
a487 1
	 FALSE,			/* pc_relative */
d492 1
a492 1
	 FALSE,			/* partial_inplace */
d495 1
a495 1
	 FALSE),		/* pcrel_offset */
d500 1
a500 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d502 1
a502 1
	 FALSE,			/* pc_relative */
d504 1
a504 1
	 complain_overflow_signed, /* complain_on_overflow */
d507 4
a510 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d517 1
a517 1
	 FALSE,			/* pc_relative */
d519 1
a519 1
	 complain_overflow_dont, /* complain_on_overflow */
d522 1
a522 1
	 TRUE,			/* partial_inplace */
d525 1
a525 1
	 FALSE),		/* pcrel_offset */
d532 1
a532 1
	 FALSE,			/* pc_relative */
d534 1
a534 1
	 complain_overflow_dont, /* complain_on_overflow */
d537 1
a537 1
	 TRUE,			/* partial_inplace */
d540 1
a540 1
	 FALSE),		/* pcrel_offset */
d547 1
a547 1
	 FALSE,			/* pc_relative */
d555 4
a558 4
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d565 1
a565 1
	 FALSE,			/* pc_relative */
d568 1
a568 1
	 mips_elf_hi16_reloc,	/* special_function */
d570 4
a573 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d580 1
a580 1
	 FALSE,			/* pc_relative */
d583 1
a583 1
	 mips_elf_lo16_reloc,	/* special_function */
d585 4
a588 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d595 1
a595 1
	 FALSE,			/* pc_relative */
d598 1
a598 1
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
d600 4
a603 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d610 1
a610 1
	 FALSE,			/* pc_relative */
d613 1
a613 1
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
d615 4
a618 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d625 1
a625 1
	 FALSE,			/* pc_relative */
d628 1
a628 1
	 mips_elf_got16_reloc,	/* special_function */
d630 4
a633 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d640 1
a640 1
	 TRUE,			/* pc_relative */
d645 4
a648 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d655 1
a655 1
	 FALSE,			/* pc_relative */
d660 4
a663 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d670 1
a670 1
	 FALSE,			/* pc_relative */
d672 2
a673 2
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf_gprel32_reloc, /* special_function */
d675 1
a675 1
	 TRUE,			/* partial_inplace */
d678 1
a678 1
	 FALSE),		/* pcrel_offset */
d680 5
a684 5
  /* The remaining relocs are defined on Irix 5, although they are
     not defined by the ABI.  */
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
d691 1
a691 1
	 FALSE,			/* pc_relative */
d696 1
a696 1
	 TRUE,			/* partial_inplace */
d699 1
a699 1
	 FALSE),		/* pcrel_offset */
d708 1
a708 1
	 FALSE,			/* pc_relative */
d713 1
a713 1
	 TRUE,			/* partial_inplace */
d716 1
a716 1
	 FALSE),		/* pcrel_offset */
d723 1
a723 1
	 FALSE,			/* pc_relative */
d725 1
a725 1
	 complain_overflow_dont, /* complain_on_overflow */
d728 1
a728 1
	 TRUE,			/* partial_inplace */
d731 1
a731 1
	 FALSE),		/* pcrel_offset */
d738 1
a738 1
	 FALSE,			/* pc_relative */
d740 1
a740 1
	 complain_overflow_signed, /* complain_on_overflow */
d743 1
a743 1
	 TRUE,			/* partial_inplace */
d746 1
a746 1
	 FALSE),		/* pcrel_offset */
d753 1
a753 1
	 FALSE,			/* pc_relative */
d755 1
a755 1
	 complain_overflow_signed, /* complain_on_overflow */
d758 1
a758 1
	 TRUE,			/* partial_inplace */
d761 1
a761 1
	 FALSE),		/* pcrel_offset */
d768 1
a768 1
	 FALSE,			/* pc_relative */
d770 1
a770 1
	 complain_overflow_signed, /* complain_on_overflow */
d773 1
a773 1
	 TRUE,			/* partial_inplace */
d776 1
a776 1
	 FALSE),		/* pcrel_offset */
d783 1
a783 1
	 FALSE,			/* pc_relative */
d788 1
a788 1
	 TRUE,			/* partial_inplace */
d791 1
a791 1
	 FALSE),		/* pcrel_offset */
d798 1
a798 1
	 FALSE,			/* pc_relative */
d803 1
a803 1
	 TRUE,			/* partial_inplace */
d806 1
a806 1
	 FALSE),		/* pcrel_offset */
d813 1
a813 1
	 FALSE,			/* pc_relative */
d815 1
a815 1
	 complain_overflow_dont, /* complain_on_overflow */
d818 1
a818 1
	 TRUE,			/* partial_inplace */
d821 1
a821 1
	 FALSE),		/* pcrel_offset */
d833 1
a833 1
	 FALSE,			/* pc_relative */
d838 4
a841 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d848 1
a848 1
	 FALSE,			/* pc_relative */
d853 4
a856 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d863 1
a863 1
	 FALSE,			/* pc_relative */
d868 1
a868 1
	 TRUE,			/* partial_inplace */
d871 1
a871 1
	 FALSE),		/* pcrel_offset */
d878 1
a878 1
	 FALSE,			/* pc_relative */
d883 1
a883 1
	 TRUE,			/* partial_inplace */
d886 1
a886 1
	 FALSE),		/* pcrel_offset */
d893 1
a893 1
	 FALSE,			/* pc_relative */
d898 1
a898 1
	 TRUE,			/* partial_inplace */
d901 1
a901 1
	 FALSE),		/* pcrel_offset */
d912 3
a914 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d919 1
a919 1
	 FALSE,			/* partial_inplace */
d922 1
a922 1
	 FALSE),		/* pcrel_offset */
d932 1
a932 1
	 FALSE,			/* pc_relative */
d937 1
a937 1
	 TRUE,			/* partial_inplace */
d940 1
a940 1
	 FALSE);		/* pcrel_offset */
d948 1
a948 1
	 FALSE,			/* pc_relative */
d956 1
a956 1
	 TRUE,			/* partial_inplace */
d959 1
a959 1
	 FALSE);		/* pcrel_offset */
d967 1
a967 1
	 FALSE,			/* pc_relative */
d972 1
a972 1
	 TRUE,			/* partial_inplace */
d975 1
a975 1
	 FALSE);		/* pcrel_offset */
d984 1
a984 1
	 TRUE,			/* pc_relative */
d987 1
a987 1
	 mips_elf_hi16_reloc,	/* special_function */
d989 1
a989 1
	 TRUE,			/* partial_inplace */
d992 1
a992 1
	 TRUE);			/* pcrel_offset */
d1000 1
a1000 1
	 TRUE,			/* pc_relative */
d1003 1
a1003 1
	 mips_elf_lo16_reloc,	/* special_function */
d1005 1
a1005 1
	 TRUE,			/* partial_inplace */
d1008 1
a1008 1
	 TRUE);			/* pcrel_offset */
d1016 1
a1016 1
	 TRUE,			/* pc_relative */
d1021 1
a1021 1
	 TRUE,			/* partial_inplace */
d1024 1
a1024 1
	 TRUE);			/* pcrel_offset */
d1032 1
a1032 1
	 TRUE,			/* pc_relative */
d1037 1
a1037 1
	 TRUE,			/* partial_inplace */
d1040 1
a1040 1
	 TRUE);			/* pcrel_offset */
d1048 1
a1048 1
	 TRUE,			/* pc_relative */
d1053 1
a1053 1
	 TRUE,			/* partial_inplace */
d1056 1
a1056 1
	 TRUE);			/* pcrel_offset */
d1064 1
a1064 1
	 FALSE,			/* pc_relative */
d1069 1
a1069 1
	 FALSE,			/* partial_inplace */
d1072 1
a1072 1
	 FALSE);		/* pcrel_offset */
d1080 1
a1080 1
	 FALSE,			/* pc_relative */
d1085 1
a1085 1
	 FALSE,			/* partial_inplace */
d1088 1
a1088 1
	 FALSE);		/* pcrel_offset */
d1093 2
a1094 4
   actual relocation when we see the LO16.

   MIPS ELF requires that the LO16 immediately follow the HI16.  As a
   GNU extension, for non-pc-relative relocations, we permit an
d1097 1
a1097 5
   itself.

   This cannot be done for PC-relative relocations because both the HI16
   and LO16 parts of the relocations must be done relative to the LO16
   part, and there can be carry to or borrow from the HI16 part.  */
d1110 8
a1117 3
static bfd_reloc_status_type
mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
d1130 1
a1130 1
  /* If we're relocating, and this is an external symbol, we don't want
d1144 1
a1144 1
      bfd_boolean relocateable;
d1151 1
a1151 1
	relocateable = TRUE;
d1154 1
a1154 1
	  relocateable = FALSE;
d1185 1
a1185 1
  n = (struct mips_hi16 *) bfd_malloc ((bfd_size_type) sizeof *n);
d1203 8
a1210 3
static bfd_reloc_status_type
mips_elf_lo16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
d1237 4
a1240 1
	  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1243 9
a1251 4
	     value.  */
	  vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;
d1253 2
a1254 16
	  /* If PC-relative, we need to subtract out the address of the LO
	     half of the HI/LO.  (The actual relocation is relative
	     to that instruction.)  */
	  if (reloc_entry->howto->pc_relative)
	    val -= reloc_entry->address;

	  /* At this point, "val" has the value of the combined HI/LO
	     pair.  If the low order 16 bits (which will be used for
	     the LO16 insn) are negative, then we will need an
	     adjustment for the high order 16 bits.  */
	  val += 0x8000;
	  val = (val >> 16) & 0xffff;

	  insn &= ~ (bfd_vma) 0xffff;
	  insn |= val;
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);
d1277 1
a1277 1
      ret = mips_elf_final_gp (output_bfd, symbol, TRUE, error_message, &gp);
d1313 8
a1320 3
static bfd_reloc_status_type
mips_elf_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
		      output_bfd, error_message)
d1329 1
a1329 1
  /* If we're relocating, and this is an external symbol, we don't want
d1343 2
a1344 2
    return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
d1349 1
a1349 1
/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
d1352 1
a1352 1
static bfd_boolean
d1364 1
a1364 1
    return TRUE;
d1377 1
a1377 1
	  register const char *name;
d1394 1
a1394 1
      return FALSE;
d1397 1
a1397 1
  return TRUE;
d1410 1
a1410 1
     bfd_boolean relocateable;
d1449 4
d1454 2
a1455 2
_bfd_mips_elf32_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			       output_bfd, error_message)
d1464 1
a1464 1
  bfd_boolean relocateable;
d1481 1
a1481 1
    relocateable = TRUE;
d1484 1
a1484 1
      relocateable = FALSE;
d1493 63
a1555 3
  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocateable,
					data, gp);
d1558 2
a1559 2
/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */
d1561 3
a1563 3
static bfd_reloc_status_type gprel32_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));
d1565 8
a1572 3
static bfd_reloc_status_type
mips_elf_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
d1581 1
a1581 1
  bfd_boolean relocateable;
d1600 1
a1600 1
      relocateable = TRUE;
d1605 1
a1605 1
      relocateable = FALSE;
d1625 1
a1625 1
     bfd_boolean relocateable;
d1661 1
a1661 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + reloc_entry->address);
d1698 1
a1698 1
  reloc32.howto = &elf_mips_howto_table_rel[R_MIPS_32];
d1711 1
a1711 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + addr);
d1739 1
a1739 1
    static bfd_boolean warned;
d1745 1
a1745 1
    warned = TRUE;
d1764 1
a1764 1
  bfd_boolean relocateable;
d1783 1
a1783 1
    relocateable = TRUE;
d1786 1
a1786 1
      relocateable = FALSE;
d1805 3
a1807 3
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
d1810 2
a1811 2
  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);
d1815 3
a1817 3
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
d1820 2
a1821 2
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
d1827 123
d1953 2
a1954 2
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
d1957 1
a1957 1
static const struct elf_reloc_map mips_reloc_map[] =
d1959 1
a1959 1
  { BFD_RELOC_NONE, R_MIPS_NONE },
a1961 1
  /* There is no BFD reloc for R_MIPS_REL32.  */
d1966 1
a1966 1
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
d1971 1
a1971 1
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
a1989 1
  reloc_howto_type *howto_table = elf_mips_howto_table_rel;
d1991 1
a1991 2
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
d1993 2
a1994 2
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
d2006 4
a2009 3
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
a2010 2
      else
	return &howto_table[(int) R_MIPS_32];
d2033 1
a2033 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d2036 1
a2036 1
mips_elf32_rtype_to_howto (r_type, rela_p)
a2037 1
     bfd_boolean rela_p ATTRIBUTE_UNUSED;
d2043 1
d2046 1
d2049 1
d2052 1
d2055 1
d2058 1
d2061 1
d2064 1
d2067 2
d2071 2
a2072 1
      return &elf_mips_howto_table_rel[r_type];
d2076 1
a2076 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d2082 1
a2082 1
     Elf_Internal_Rela *dst;
d2087 1
a2087 1
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, FALSE);
d2099 1
a2099 1
/* Given a MIPS Elf_Internal_Rela, fill in an arelent structure.  */
d2105 1
a2105 1
     Elf_Internal_Rela *dst;
d2107 4
a2110 1
  mips_info_to_howto_rel (abfd, cache_ptr, dst);
d2113 1
a2113 1
     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
d2116 3
a2118 5
/* Determine whether a symbol is global for the purposes of splitting
   the symbol table into global symbols and local symbols.  At least
   on Irix 5, this split must be between section symbols and all other
   symbols.  On most ELF targets the split is between static symbols
   and externally visible symbols.  */
d2120 5
a2124 4
static bfd_boolean
mips_elf_sym_is_global (abfd, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
d2126 6
a2131 6
  if (SGI_COMPAT (abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
	    || bfd_is_und_section (bfd_get_section (sym))
	    || bfd_is_com_section (bfd_get_section (sym)));
a2132 2

/* Set the right machine number for a MIPS ELF file.  */
d2134 2
a2135 2
static bfd_boolean
mips_elf32_object_p (abfd)
d2137 2
d2140 13
a2152 1
  unsigned long mach;
d2154 5
a2158 5
  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (SGI_COMPAT (abfd))
    elf_bad_symtab (abfd) = TRUE;
d2160 14
a2173 2
  if (ABI_N32_P (abfd))
    return FALSE;
d2175 21
a2195 2
  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);
d2197 2
a2198 4
  return TRUE;
}

/* MIPS ELF local labels start with '$', not 'L'.  */
d2200 2
a2201 2
static bfd_boolean
mips_elf_is_local_label_name (abfd, name)
d2203 2
a2204 1
     const char *name;
d2206 3
a2208 2
  if (name[0] == '$')
    return TRUE;
d2210 2
a2211 8
  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf32_mips_grok_prstatus (abfd, note)
d2213 2
a2214 1
     Elf_Internal_Note *note;
d2216 5
a2220 2
  int offset;
  unsigned int raw_size;
d2222 6212
a8433 1
  switch (note->descsz)
d8435 75
a8509 2
      default:
	return FALSE;
d8511 2
a8512 10
      case 256:		/* Linux/MIPS */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 180;
d8514 45
a8558 1
	break;
d8561 52
a8612 3
  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
d8615 9
a8623 4
static bfd_boolean
elf32_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d8625 95
a8719 1
  switch (note->descsz)
d8721 10
a8730 2
      default:
	return FALSE;
d8732 42
a8773 5
      case 128:		/* Linux/MIPS elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
d8776 3
a8778 3
  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
d8780 24
a8803 3
  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);
d8805 4
a8808 3
    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }
d8810 1
a8810 1
  return TRUE;
d8812 7
a8818 6

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf32_mips_irix_compat (abfd)
     bfd *abfd;
d8820 12
a8831 3
  if ((abfd->xvec == &bfd_elf32_bigmips_vec)
      || (abfd->xvec == &bfd_elf32_littlemips_vec))
    return ict_irix5;
d8833 154
a8986 23
    return ict_none;
}

/* Given a data section and an in-memory embedded reloc section, store
   relocation information into the embedded reloc section which can be
   used at runtime to relocate the data section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_mips_elf32_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *p;
d8988 5
a8992 1
  BFD_ASSERT (! info->relocateable);
d8994 4
a8997 1
  *errmsg = NULL;
d8999 5
a9003 2
  if (datasec->reloc_count == 0)
    return TRUE;
d9005 4
a9008 4
  /* Read this BFD's symbols if we haven't done so already, or get the cached
     copy if it exists.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (symtab_hdr->sh_info != 0)
d9010 3
a9012 7
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
d9015 114
a9128 5
  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf32_link_read_relocs
		     (abfd, datasec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      info->keep_memory));
  if (internal_relocs == NULL)
d9131 2
a9132 2
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
  if (relsec->contents == NULL)
d9135 7
a9141 1
  p = relsec->contents;
d9143 10
a9152 1
  irelend = internal_relocs + datasec->reloc_count;
d9154 1
a9154 1
  for (irel = internal_relocs; irel < irelend; irel++, p += 12)
d9156 51
a9206 1
      asection *targetsec;
d9208 21
a9228 5
      /* We are going to write a four byte longword into the runtime
	 reloc section.  The longword will be the address in the data
	 section which must be relocated.  It is followed by the name
	 of the target section NUL-padded or truncated to 8
	 characters.  */
d9230 7
a9236 12
      /* We can only relocate absolute longword relocs at run time.  */
      if ((ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_32) &&
	  (ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_64))
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      /* Get the target section referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
          Elf_Internal_Sym *isym;
d9238 3
a9240 25
          /* A local symbol.  */
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info);
	  h = elf_sym_hashes (abfd)[indx];
	  targetsec = NULL;
	  /*
	     For some reason, in certain programs, the symbol will
	     not be in the hash table.  It seems to happen when you
	     declare a static table of pointers to const external structures.
	     In this case, the relocs are relative to data, not
	     text, so just treating it like an undefined link
	     should be sufficient.  */
	  BFD_ASSERT(h != NULL);
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	}
d9242 4
d9247 30
a9276 19
      /*
         Set the low bit of the relocation offset if it's a MIPS64 reloc.
         Relocations will always be on (at least) 32-bit boundaries.  */

      bfd_put_32 (abfd, ((irel->r_offset + datasec->output_offset) +
		  ((ELF32_R_TYPE (irel->r_info) == (int) R_MIPS_64) ? 1 : 0)),
		  p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy (p + 4, targetsec->output_section->name, 8);
    }

  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return TRUE;
d9278 11
a9288 8
 error_return:
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return FALSE;
d9290 3
d9336 4
d9347 4
a9350 3
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
d9354 1
a9354 3
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
d9359 8
a9367 2
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
d9378 2
a9383 5
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
d9386 4
d9392 1
a9393 3
#define elf_backend_grok_prstatus	elf32_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf32_mips_grok_psinfo
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap
a9394 12
#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	0
#define elf_backend_default_use_rela_p	0
#define elf_backend_sign_extend_vma	TRUE

#define elf_backend_discard_info	_bfd_mips_elf_discard_info
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_mips_irix_compat	elf32_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf32_rtype_to_howto
a9397 1
#define bfd_elf32_new_section_hook	_bfd_mips_elf_new_section_hook
a9398 2
#define bfd_elf32_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
d9402 2
d9409 1
d9411 1
a9411 7
/* Support for SGI-ish mips targets.  */
#define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
#define TARGET_LITTLE_NAME		"elf32-littlemips"
#define TARGET_BIG_SYM			bfd_elf32_bigmips_vec
#define TARGET_BIG_NAME			"elf32-bigmips"

#include "elf32-target.h"
d9413 1
a9413 2
/* Support for traditional mips targets.  */
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */
d9425 1
a9425 1
/* Include the target file again for this target.  */
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d50 6
a55 2
static bfd_reloc_status_type gprel32_with_gp
  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
d57 1
a57 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d59 1
a59 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d61 1
a61 1
  (bfd *, bfd_reloc_code_real_type);
d63 1
a63 1
  (unsigned int, bfd_boolean);
d65 1
a65 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d67 1
a67 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d69 1
a69 1
  (bfd *, asymbol *);
d71 1
a71 1
  (bfd *);
d73 1
a73 1
  (bfd *, const char *);
d75 1
a75 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d77 1
a77 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d79 1
a79 1
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
d81 1
a81 1
  (bfd *, bfd_vma *);
d83 1
a83 1
  (bfd *, Elf_Internal_Note *);
d85 1
a85 1
  (bfd *, Elf_Internal_Note *);
d87 1
a87 1
  (bfd *);
d119 1
a119 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d134 1
a134 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d149 1
a149 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d164 1
a164 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d182 1
a182 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d191 1
a191 1
	 16,			/* rightshift */
d197 1
a197 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d212 1
a212 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d257 1
a257 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d272 1
a272 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d287 1
a287 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d323 1
a323 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d340 1
a340 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d370 1
a370 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d385 1
a385 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d400 1
a400 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d415 1
a415 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d430 1
a430 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d445 1
a445 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d465 1
a465 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d480 1
a480 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d495 1
a495 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d510 1
a510 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d525 1
a525 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d546 1
a546 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d610 1
a610 1
	 16,			/* rightshift */
d616 1
a616 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d632 1
a632 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d648 1
a648 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d664 1
a664 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d680 1
a680 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d719 256
d979 3
a981 1
mips_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d997 1
a997 1
  if (sym == NULL)
d1030 1
a1030 1
   external symbol if we are producing relocatable output.  */
d1033 6
a1038 2
mips_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		   char **error_message, bfd_vma *pgp)
d1041 1
a1041 1
      && ! relocatable)
d1049 1
a1049 1
      && (! relocatable
d1052 1
a1052 1
      if (relocatable)
d1076 9
a1084 4
_bfd_mips_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
			       asymbol *symbol, void *data,
			       asection *input_section, bfd *output_bfd,
			       char **error_message)
d1086 1
a1086 1
  bfd_boolean relocatable;
d1090 14
a1103 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1106 1
a1106 1
      relocatable = FALSE;
d1110 1
a1110 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1116 1
a1116 1
					input_section, relocatable,
d1123 4
d1128 9
a1136 3
mips_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d1138 1
a1138 1
  bfd_boolean relocatable;
d1142 18
a1159 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1162 1
a1162 1
      relocatable = FALSE;
d1164 5
a1170 5
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			   error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

d1172 1
a1172 1
			  relocatable, data, gp);
d1176 9
a1184 3
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
d1187 1
a1187 1
  bfd_vma val;
d1200 8
d1209 1
a1209 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1212 1
a1212 1
     are producing relocatable output, we don't want to do this for
d1214 1
a1214 1
  if (! relocatable
d1218 1
a1218 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1220 1
a1220 1
  if (relocatable)
d1231 9
a1239 4
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
		    asymbol *symbol ATTRIBUTE_UNUSED,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
d1246 5
d1268 1
a1268 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
d1276 9
a1284 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1286 1
a1286 1
  if (output_bfd != NULL
d1311 9
a1319 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1321 1
a1321 1
  bfd_boolean relocatable;
d1324 2
a1325 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1327 4
a1330 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1333 1
a1333 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1340 1
a1340 1
    relocatable = TRUE;
d1343 1
a1343 1
      relocatable = FALSE;
d1347 1
a1347 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1355 25
a1379 20
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);
d1381 1
a1381 25
  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1420 3
a1422 1
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
d1474 3
a1476 2
mips_elf32_rtype_to_howto (unsigned int r_type,
			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
d1507 4
a1510 1
mips_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
d1530 4
a1533 1
mips_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
d1548 3
a1550 1
mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
d1563 2
a1564 1
mips_elf32_object_p (bfd *abfd)
d1586 3
a1588 1
mips_elf_is_local_label_name (bfd *abfd, const char *name)
d1600 3
a1602 1
elf32_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d1632 3
a1634 1
elf32_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d1666 2
a1667 1
elf32_mips_irix_compat (bfd *abfd)
d1684 6
a1689 3
bfd_mips_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
				       asection *datasec, asection *relsec,
				       char **errmsg)
d1697 1
a1697 1
  BFD_ASSERT (! info->relocatable);
d1719 3
a1721 2
  internal_relocs = _bfd_elf_link_read_relocs (abfd, datasec, NULL, NULL,
					       info->keep_memory);
d1725 1
a1725 1
  relsec->contents = bfd_alloc (abfd, datasec->reloc_count * 12);
d1858 4
d1907 1
a1939 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

d1943 2
a1949 2
#undef ELF_MAXPAGESIZE

a1953 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf32_bed			elf32_tradbed
@


