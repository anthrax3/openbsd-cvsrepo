head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.22.24.27;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.04.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.04.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.17.58;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.20.35;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* BFD back-end for Apple M68K COFF A/UX 3.x files.
   Copyright 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
   Written by Richard Henderson <rth@@tamu.edu>.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_SYM	m68kaux_coff_vec
#define TARGET_NAME	"coff-m68k-aux"

#ifndef TARG_AUX
#define TARG_AUX
#endif

#define COFF_LONG_FILENAMES

/* 4k pages */
#define COFF_PAGE_SIZE 0x1000

/* On AUX, a STYP_NOLOAD|STYP_BSS section is part of a shared library.  */
#define BSS_NOLOAD_IS_SHARED_LIBRARY

#define STATIC_RELOCS

#define COFF_COMMON_ADDEND

#include "bfd.h"
#include "sysdep.h"

static bfd_boolean coff_m68k_aux_link_add_one_symbol
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
           asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
           struct bfd_link_hash_entry **));

#define coff_link_add_one_symbol coff_m68k_aux_link_add_one_symbol

#include "coff/aux-coff.h"  /* override coff/internal.h and coff/m68k.h */
#include "coff-m68k.c"

/* We need non-absolute symbols to override absolute symbols.  This
   mirrors Apple's "solution" to let a static library symbol override
   a shared library symbol.  On the whole not a good thing, given how
   shared libraries work here, but can work if you are careful with
   what you include in the shared object.  */

static bfd_boolean
coff_m68k_aux_link_add_one_symbol (info, abfd, name, flags, section, value,
				   string, copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
{
  struct bfd_link_hash_entry *h;

  if ((flags & (BSF_WARNING | BSF_CONSTRUCTOR | BSF_WEAK)) == 0 &&
      !bfd_is_und_section (section) &&
      !bfd_is_com_section (section))
    {
      /* The new symbol is a definition or an indirect definition */

      /* This bit copied from linker.c */
      if (hashp != NULL && *hashp != NULL)
	{
	  h = *hashp;
	  BFD_ASSERT (strcmp (h->root.string, name) == 0);
	}
      else
	{
	  h = bfd_link_hash_lookup (info->hash, name, TRUE, copy, FALSE);
	  if (h == NULL)
	    {
	      if (hashp != NULL)
		*hashp = NULL;
	      return FALSE;
	    }
	}

      if (info->notice_hash != (struct bfd_hash_table *) NULL
	  && (bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE)
	      != (struct bfd_hash_entry *) NULL))
	{
	  if (! (*info->callbacks->notice) (info, name, abfd, section, value))
	    return FALSE;
	}

      if (hashp != (struct bfd_link_hash_entry **) NULL)
	*hashp = h;
      /* end duplication from linker.c */

      if (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_indirect)
	{
	  asection *msec;

	  if (h->type == bfd_link_hash_defined)
	    msec = h->u.def.section;
	  else
	    msec = bfd_ind_section_ptr;

	  if (bfd_is_abs_section (msec) && !bfd_is_abs_section (section))
	    {
	      h->u.def.section = section;
	      h->u.def.value = value;
	      return TRUE;
	    }
	  else if (bfd_is_abs_section (section) && !bfd_is_abs_section (msec))
	    return TRUE;
	}
    }

  /* If we didn't exit early, finish processing in the generic routine */
  return _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,
					   value, string, copy, collect,
					   hashp);
}
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 2000 Free Software Foundation, Inc.
d43 1
a43 1
static boolean coff_m68k_aux_link_add_one_symbol
d45 1
a45 1
           asection *, bfd_vma, const char *, boolean, boolean,
d59 1
a59 1
static boolean
d69 2
a70 2
     boolean copy;
     boolean collect;
d89 1
a89 1
	  h = bfd_link_hash_lookup (info->hash, name, true, copy, false);
d94 1
a94 1
	      return false;
d99 1
a99 1
	  && (bfd_hash_lookup (info->notice_hash, name, false, false)
d103 1
a103 1
	    return false;
d124 1
a124 1
	      return true;
d127 1
a127 1
	    return true;
@


1.2
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@d2 1
a2 1
   Copyright 1996, 1997 Free Software Foundation, Inc.
d33 1
a33 1
/* On AUX, a STYP_NOLOAD|STYP_BSS section is part of a shared library. */
d44 2
a45 2
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, 
           asection *, bfd_vma, const char *, boolean, boolean, 
d57 1
a57 1
   what you include in the shared object. */
@


1.1
log
@Initial revision
@
text
@d2 2
a3 4
   Copyright 1996 Free Software Foundation, Inc.
   Portions written by Richard Henderson <rth@@tamu.edu>,
   COMMON symbol munging cribbed from cf-m68klynx.c which was
   written by Cygnus Support.
d36 1
a36 4
#define _bfd_m68kcoff_howto_table _bfd_m68kaux_howto_table	
#define _bfd_m68kcoff_rtype2howto _bfd_m68kaux_rtype2howto	
#define _bfd_m68kcoff_howto2rtype _bfd_m68kaux_howto2rtype	
#define _bfd_m68kcoff_reloc_type_lookup _bfd_m68kaux_reloc_type_lookup
d38 1
a38 2
/* Rather than change names lots of places, reuse the same hack */
#define LYNX_SPECIAL_FN _bfd_m68kaux_special_fn
a42 13
#ifdef ANSI_PROTOTYPES
struct internal_reloc;
struct coff_link_hash_entry;
struct internal_syment;
#endif


static bfd_reloc_status_type _bfd_m68kaux_special_fn
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type *coff_m68k_aux_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
a47 2

#define coff_rtype_to_howto coff_m68k_aux_rtype_to_howto
a49 38

/* Compute the addend of a reloc.  If the reloc is to a common symbol,
   the object file contains the value of the common symbol.  By the
   time this is called, the linker may be using a different symbol
   from a different object file with a different value.  Therefore, we
   hack wildly to locate the original symbol from this file so that we
   can make the correct adjustment.  This macro sets coffsym to the
   symbol from the original file, and uses it to set the addend value
   correctly.  If this is not a common symbol, the usual addend
   calculation is done, except that an additional tweak is needed for
   PC relative relocs.
   FIXME: This macro refers to symbols and asect; these are from the
   calling function, not the macro arguments.  */

#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
  {								\
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
      coffsym = (obj_symbols (abfd)				\
	         + (cache_ptr->sym_ptr_ptr - symbols));		\
    else if (ptr)						\
      coffsym = coff_symbol_from (abfd, ptr);			\
    if (coffsym != (coff_symbol_type *) NULL			\
	&& coffsym->native->u.syment.n_scnum == 0)		\
      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
	     && ptr->section != (asection *) NULL)		\
      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
    else							\
      cache_ptr->addend = 0;					\
    if (ptr && (reloc.r_type == R_PCRBYTE			\
		|| reloc.r_type == R_PCRWORD			\
		|| reloc.r_type == R_PCRLONG))			\
      cache_ptr->addend += asect->vma;				\
  }



a52 138


/* For some reason when using m68k COFF the value stored in the .text
   section for a reference to a common symbol is the value itself plus
   any desired offset.  (taken from work done by Ian Taylor, Cygnus Support,
   for I386 COFF).  */

/* If we are producing relocateable output, we need to do some
   adjustments to the object file that are not done by the
   bfd_perform_relocation function.  This function is called by every
   reloc type to make any required adjustments.  */

static bfd_reloc_status_type
_bfd_m68kaux_special_fn (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  symvalue diff;

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  if (bfd_is_com_section (symbol->section))
    {
      /* We are relocating a common symbol.  The current value in the
	 object file is ORIG + OFFSET, where ORIG is the value of the
	 common symbol as seen by the object file when it was compiled
	 (this may be zero if the symbol was undefined) and OFFSET is
	 the offset into the common symbol (normally zero, but may be
	 non-zero when referring to a field in a common structure).
	 ORIG is the negative of reloc_entry->addend, which is set by
	 the CALC_ADDEND macro below.  We want to replace the value in
	 the object file with NEW + OFFSET, where NEW is the value of
	 the common symbol which we are going to put in the final
	 object file.  NEW is symbol->value.  */
      diff = symbol->value + reloc_entry->addend;
    }
  else
    {
      /* For some reason bfd_perform_relocation always effectively
	 ignores the addend for a COFF target when producing
	 relocateable output.  This seems to be always wrong for 386
	 COFF, so we handle the addend here instead.  */
      diff = reloc_entry->addend;
    }

#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | \
       (((x & howto->src_mask) + diff) & howto->dst_mask))

  if (diff != 0)
    {
      reloc_howto_type *howto = reloc_entry->howto;
      unsigned char *addr = (unsigned char *) data + reloc_entry->address;

      switch (howto->size)
	{
	case 0:
	  {
	    char x = bfd_get_8 (abfd, addr);
	    DOIT (x);
	    bfd_put_8 (abfd, x, addr);
	  }
	  break;

	case 1:
	  {
	    short x = bfd_get_16 (abfd, addr);
	    DOIT (x);
	    bfd_put_16 (abfd, x, addr);
	  }
	  break;

	case 2:
	  {
	    long x = bfd_get_32 (abfd, addr);
	    DOIT (x);
	    bfd_put_32 (abfd, x, addr);
	  }
	  break;

	default:
	  abort ();
	}
    }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}


/* coff-m68k.c uses the special COFF backend linker.  We need to
   adjust common symbols.  */

/*ARGSUSED*/
static reloc_howto_type *
coff_m68k_aux_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
{
  arelent relent;
  reloc_howto_type *howto;

  RTYPE2HOWTO (&relent, rel);

  howto = relent.howto;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
      *addendp -= sym->n_value;
    }

  /* If the output symbol is common (in which case this must be a
     relocateable link), we need to add in the final size of the
     common symbol.  */
  if (h != NULL && h->root.type == bfd_link_hash_common)
    *addendp += h->root.u.c.size;

  return howto;
}


d59 1
a59 1
boolean
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 4
a5 2
   Copyright 1996, 1997 Free Software Foundation, Inc.
   Written by Richard Henderson <rth@@tamu.edu>.
d38 4
a41 1
#define STATIC_RELOCS
d43 2
a44 1
#define COFF_COMMON_ADDEND
d49 13
d67 2
d71 38
d112 138
d256 1
a256 1
static boolean
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 2000 Free Software Foundation, Inc.
d33 1
a33 1
/* On AUX, a STYP_NOLOAD|STYP_BSS section is part of a shared library.  */
d44 2
a45 2
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
           asection *, bfd_vma, const char *, boolean, boolean,
d57 1
a57 1
   what you include in the shared object.  */
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
d43 1
a43 1
static bfd_boolean coff_m68k_aux_link_add_one_symbol
d45 1
a45 1
           asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
d59 1
a59 1
static bfd_boolean
d69 2
a70 2
     bfd_boolean copy;
     bfd_boolean collect;
d89 1
a89 1
	  h = bfd_link_hash_lookup (info->hash, name, TRUE, copy, FALSE);
d94 1
a94 1
	      return FALSE;
d99 1
a99 1
	  && (bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE)
d103 1
a103 1
	    return FALSE;
d124 1
a124 1
	      return TRUE;
d127 1
a127 1
	    return TRUE;
@


