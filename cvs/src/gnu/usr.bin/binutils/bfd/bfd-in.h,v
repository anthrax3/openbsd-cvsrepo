head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.08.09.22.32.08;	author guenther;	state Exp;
branches;
next	1.8;
commitid	DhxW93170rFyMMXC;

1.8
date	2004.12.27.10.37.55;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.20.45.03;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.19;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.05;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.24;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.24;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.48;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.36.53;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.17.43;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.22;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.20.05;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.12;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@bfd-in2.h is generated from this; merge back a change that was made there
@
text
@/* Main header file for the bfd library -- portable access to object files.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef __BFD_H_SEEN__
#define __BFD_H_SEEN__

#ifdef __cplusplus
extern "C" {
#endif

#include "ansidecl.h"
#include "symcat.h"
#include <time.h>	/* time_t */
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#ifndef SABER
/* This hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
   cause the inner CONCAT2 macros to be evaluated first, producing
   still-valid pp-tokens.  Then the final concatenation can be done.  */
#undef CONCAT4
#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
#endif
#endif

/* The word size used by BFD on the host.  This may be 64 with a 32
   bit target if the host is 64 bit, or if other 64 bit targets have
   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
#define BFD_ARCH_SIZE @@wordsize@@

/* The word size of the default bfd target.  */
#define BFD_DEFAULT_TARGET_SIZE @@bfd_default_target_size@@

#define BFD_HOST_64BIT_LONG @@BFD_HOST_64BIT_LONG@@
#define BFD_HOST_LONG_LONG @@BFD_HOST_LONG_LONG@@
#if @@BFD_HOST_64_BIT_DEFINED@@
#define BFD_HOST_64_BIT @@BFD_HOST_64_BIT@@
#define BFD_HOST_U_64_BIT @@BFD_HOST_U_64_BIT@@
typedef BFD_HOST_64_BIT bfd_int64_t;
typedef BFD_HOST_U_64_BIT bfd_uint64_t;
#endif

#if BFD_ARCH_SIZE >= 64
#define BFD64
#endif

#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

/* Forward declaration.  */
typedef struct bfd bfd;

/* Boolean type used in bfd.  Too many systems define their own
   versions of "boolean" for us to safely typedef a "boolean" of
   our own.  Using an enum for "bfd_boolean" has its own set of
   problems, with strange looking casts required to avoid warnings
   on some older compilers.  Thus we just use an int.

   General rule: Functions which are bfd_boolean return TRUE on
   success and FALSE on failure (unless they're a predicate).  */

typedef int bfd_boolean;
#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE 1

#if 0
/* Poison.  */
#undef false
#undef true
#define false dont_use_false_in_bfd
#define true dont_use_true_in_bfd
#endif

#ifdef BFD64

#ifndef BFD_HOST_64_BIT
 #error No 64 bit integer type available
#endif /* ! defined (BFD_HOST_64_BIT) */

typedef BFD_HOST_U_64_BIT bfd_vma;
typedef BFD_HOST_64_BIT bfd_signed_vma;
typedef BFD_HOST_U_64_BIT bfd_size_type;
typedef BFD_HOST_U_64_BIT symvalue;

#ifndef fprintf_vma
#if BFD_HOST_64BIT_LONG
#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
#else
#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
#define fprintf_vma(s,x) \
  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
#define sprintf_vma(s,x) \
  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
#endif
#endif

#else /* not BFD64  */

/* Represent a target address.  Also used as a generic unsigned type
   which is guaranteed to be big enough to hold any arithmetic types
   we need to deal with.  */
typedef unsigned long bfd_vma;

/* A generic signed type which is guaranteed to be big enough to hold any
   arithmetic types we need to deal with.  Can be assumed to be compatible
   with bfd_vma in the same way that signed and unsigned ints are compatible
   (as parameters, in assignment, etc).  */
typedef long bfd_signed_vma;

typedef unsigned long symvalue;
typedef unsigned long bfd_size_type;

/* Print a bfd_vma x on stream s.  */
#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
#define sprintf_vma(s,x) sprintf (s, "%08lx", x)

#endif /* not BFD64  */

#ifndef BFD_HOST_64_BIT
/* Fall back on a 32 bit type.  The idea is to make these types always
   available for function return types, but in the case that
   BFD_HOST_64_BIT is undefined such a function should abort or
   otherwise signal an error.  */
typedef bfd_signed_vma bfd_int64_t;
typedef bfd_vma bfd_uint64_t;
#endif

/* An offset into a file.  BFD always uses the largest possible offset
   based on the build time availability of fseek, fseeko, or fseeko64.  */
typedef @@bfd_file_ptr@@ file_ptr;
typedef unsigned @@bfd_file_ptr@@ ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);

#define printf_vma(x) fprintf_vma(stdout,x)
#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)

typedef unsigned int flagword;	/* 32 bits of flags */
typedef unsigned char bfd_byte;

/* File formats.  */

typedef enum bfd_format
{
  bfd_unknown = 0,	/* File format is unknown.  */
  bfd_object,		/* Linker/assembler/compiler output.  */
  bfd_archive,		/* Object archive file.  */
  bfd_core,		/* Core dump.  */
  bfd_type_end		/* Marks the end; don't use it!  */
}
bfd_format;

/* Values that may appear in the flags field of a BFD.  These also
   appear in the object_flags field of the bfd_target structure, where
   they indicate the set of flags used by that backend (not all flags
   are meaningful for all object file formats) (FIXME: at the moment,
   the object_flags values have mostly just been copied from backend
   to another, and are not necessarily correct).  */

/* No flags.  */
#define BFD_NO_FLAGS   	0x00

/* BFD contains relocation entries.  */
#define HAS_RELOC   	0x01

/* BFD is directly executable.  */
#define EXEC_P      	0x02

/* BFD has line number information (basically used for F_LNNO in a
   COFF header).  */
#define HAS_LINENO  	0x04

/* BFD has debugging information.  */
#define HAS_DEBUG   	0x08

/* BFD has symbols.  */
#define HAS_SYMS    	0x10

/* BFD has local symbols (basically used for F_LSYMS in a COFF
   header).  */
#define HAS_LOCALS  	0x20

/* BFD is a dynamic object.  */
#define DYNAMIC     	0x40

/* Text section is write protected (if D_PAGED is not set, this is
   like an a.out NMAGIC file) (the linker sets this by default, but
   clears it for -r or -N).  */
#define WP_TEXT     	0x80

/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
   linker sets this by default, but clears it for -r or -n or -N).  */
#define D_PAGED     	0x100

/* BFD is relaxable (this means that bfd_relax_section may be able to
   do something) (sometimes bfd_relax_section can do something even if
   this is not set).  */
#define BFD_IS_RELAXABLE 0x200

/* This may be set before writing out a BFD to request using a
   traditional format.  For example, this is used to request that when
   writing out an a.out object the symbols not be hashed to eliminate
   duplicates.  */
#define BFD_TRADITIONAL_FORMAT 0x400

/* This flag indicates that the BFD contents are actually cached in
   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
#define BFD_IN_MEMORY 0x800

/* The sections in this BFD specify a memory page.  */
#define HAS_LOAD_PAGE 0x1000

/* Symbols and relocation.  */

/* A count of carsyms (canonical archive symbols).  */
typedef unsigned long symindex;

/* How to perform a relocation.  */
typedef const struct reloc_howto_struct reloc_howto_type;

#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)

/* General purpose part of a symbol X;
   target specific parts are in libcoff.h, libaout.h, etc.  */

#define bfd_get_section(x) ((x)->section)
#define bfd_get_output_section(x) ((x)->section->output_section)
#define bfd_set_section(x,y) ((x)->section) = (y)
#define bfd_asymbol_base(x) ((x)->section->vma)
#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
#define bfd_asymbol_name(x) ((x)->name)
/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
#define bfd_asymbol_bfd(x) ((x)->the_bfd)
#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)

/* A canonical archive symbol.  */
/* This is a type pun with struct ranlib on purpose!  */
typedef struct carsym
{
  char *name;
  file_ptr file_offset;	/* Look here to find the file.  */
}
carsym;			/* To make these you call a carsymogen.  */

/* Used in generating armaps (archive tables of contents).
   Perhaps just a forward definition would do?  */
struct orl 			/* Output ranlib.  */
{
  char **name;		/* Symbol name.  */
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;			/* bfd* or file position.  */
  int namidx;		/* Index into string table.  */
};

/* Linenumber stuff.  */
typedef struct lineno_cache_entry
{
  unsigned int line_number;	/* Linenumber from start of function.  */
  union
  {
    struct bfd_symbol *sym;	/* Function name.  */
    bfd_vma offset;	    		/* Offset into section.  */
  } u;
}
alent;

/* Object and core file sections.  */

#define	align_power(addr, align)	\
  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))

typedef struct bfd_section *sec_ptr;

#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
#define bfd_section_name(bfd, ptr) ((ptr)->name)
#define bfd_section_size(bfd, ptr) ((ptr)->_raw_size)
#define bfd_get_section_size(ptr) ((ptr)->_raw_size)
#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)

#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)

#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)

typedef struct stat stat_type;

typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;

/* Information about a symbol that nm needs.  */

typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;            /* Symbol name.  */
  unsigned char stab_type;     /* Stab type.  */
  char stab_other;             /* Stab other.  */
  short stab_desc;             /* Stab desc.  */
  const char *stab_name;       /* String for stab type.  */
} symbol_info;

/* Get the name of a stabs type code.  */

extern const char *bfd_get_stab_name (int);

/* Hash table routines.  There is no way to free up a hash table.  */

/* An element in the hash table.  Most uses will actually use a larger
   structure, and an instance of this will be the first field.  */

struct bfd_hash_entry
{
  /* Next entry for this hash code.  */
  struct bfd_hash_entry *next;
  /* String being hashed.  */
  const char *string;
  /* Hash code.  This is the full hash code, not the index into the
     table.  */
  unsigned long hash;
};

/* A hash table.  */

struct bfd_hash_table
{
  /* The hash array.  */
  struct bfd_hash_entry **table;
  /* The number of slots in the hash table.  */
  unsigned int size;
  /* A function used to create new elements in the hash table.  The
     first entry is itself a pointer to an element.  When this
     function is first invoked, this pointer will be NULL.  However,
     having the pointer permits a hierarchy of method functions to be
     built each of which calls the function in the superclass.  Thus
     each function should be written to allocate a new block of memory
     only if the argument is NULL.  */
  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
   /* An objalloc for this hash table.  This is a struct objalloc *,
     but we use void * to avoid requiring the inclusion of objalloc.h.  */
  void *memory;
};

/* Initialize a hash table.  */
extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));

/* Initialize a hash table specifying a size.  */
extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *),
   unsigned int size);

/* Free up a hash table.  */
extern void bfd_hash_table_free
  (struct bfd_hash_table *);

/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
   will be created for this string if one does not already exist.  The
   COPY argument must be TRUE if this routine should copy the string
   into newly allocated memory when adding an entry.  */
extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);

/* Replace an entry in a hash table.  */
extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);

/* Base method for creating a hash table entry.  */
extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

/* Grab some space for a hash table entry.  */
extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);

/* Traverse a hash table in a random order, calling a function on each
   element.  If the function returns FALSE, the traversal stops.  The
   INFO argument is passed to the function.  */
extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);

#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table

/* User program access to BFD facilities.  */

/* Direct I/O routines, for programs which know more about the object
   file than BFD does.  Use higher level routines if possible.  */

extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);

/* Deprecated old routines.  */
#if __GNUC__
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#else
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#endif
extern void warn_deprecated (const char *, const char *, int, const char *);

/* Cast from const char * to char * so that caller can assign to
   a char * without a warning.  */
#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
#define bfd_get_format(abfd) ((abfd)->format)
#define bfd_get_target(abfd) ((abfd)->xvec->name)
#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
#define bfd_family_coff(abfd) \
  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
#define bfd_header_big_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
#define bfd_header_little_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
#define bfd_get_file_flags(abfd) ((abfd)->flags)
#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
#define bfd_my_archive(abfd) ((abfd)->my_archive)
#define bfd_has_map(abfd) ((abfd)->has_armap)

#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
#define bfd_usrdata(abfd) ((abfd)->usrdata)

#define bfd_get_start_address(abfd) ((abfd)->start_address)
#define bfd_get_symcount(abfd) ((abfd)->symcount)
#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
#define bfd_count_sections(abfd) ((abfd)->section_count)

#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)

#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)

#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)

extern bfd_boolean bfd_cache_close
  (bfd *abfd);
/* NB: This declaration should match the autogenerated one in libbfd.h.  */

extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);

/* Byte swapping routines.  */

bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);

/* Byte swapping routines which take size and endiannes as arguments.  */

bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);

/* Externally visible ECOFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_elf_version_tree;
#endif
extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);
extern bfd_boolean bfd_mips_ecoff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* Externally visible ELF routines.  */

struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char * const *,
   struct bfd_link_info *, struct bfd_section **, struct bfd_elf_version_tree *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, int);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);

/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */
extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));

/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
extern int bfd_get_arch_size
  (bfd *);

/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma
  (bfd *);

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
extern bfd_boolean bfd_mips_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* SunOS shared library support routines for the linker.  */

extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **, struct bfd_section **, struct bfd_section **);

/* Linux shared library support routines for the linker.  */

extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);

/* mmap hacks */

struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{
  /* What the user asked for.  */
  void *data;
  bfd_size_type size;
  /* The actual window used by BFD.  Small user-requested read-only
     regions sharing a page may share a single window into the object
     file.  Read-write versions shouldn't until I've fixed things to
     keep track of which portions have been claimed by the
     application; don't want to give the same region back when the
     application wants two writable copies!  */
  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);

/* XCOFF support routines for the linker.  */

extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);

/* XCOFF support routines for ar.  */
extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);

/* Externally visible COFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct internal_syment;
union internal_auxent;
#endif

extern bfd_boolean bfd_coff_get_syment
  (bfd *, struct bfd_symbol *, struct internal_syment *);

extern bfd_boolean bfd_coff_get_auxent
  (bfd *, struct bfd_symbol *, int, union internal_auxent *);

extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

/* PE ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

/* ELF ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

/* ARM Note section processing.  */
extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);

/* TI COFF load page support.  */
extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);

/* H8/300 functions.  */
extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);

/* IA64 Itanium code generation.  Called from linker.  */
extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);

@


1.8
log
@Some post bintuils-2.15 changes for gdb-6.3.
@
text
@d33 1
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d311 2
a312 1
#define bfd_section_size(bfd, ptr) (bfd_get_section_size_before_reloc(ptr))
d508 2
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d54 1
d58 2
a99 20
/* Support for different sizes of target format ints and addresses.
   If the type `long' is at least 64 bits, BFD_HOST_64BIT_LONG will be
   set to 1 above.  Otherwise, if gcc is being used, this code will
   use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be
   defined above.  */

#ifndef BFD_HOST_64_BIT
# if BFD_HOST_64BIT_LONG
#  define BFD_HOST_64_BIT long
#  define BFD_HOST_U_64_BIT unsigned long
# else
#  ifdef __GNUC__
#   if __GNUC__ >= 2
#    define BFD_HOST_64_BIT long long
#    define BFD_HOST_U_64_BIT unsigned long long
#   endif /* __GNUC__ >= 2 */
#  endif /* ! defined (__GNUC__) */
# endif /* ! BFD_HOST_64BIT_LONG */
#endif /* ! defined (BFD_HOST_64_BIT) */

d147 16
a162 15
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef bfd_signed_vma file_ptr;
typedef bfd_vma ufile_ptr;

extern void bfd_sprintf_vma
  PARAMS ((bfd *, char *, bfd_vma));
extern void bfd_fprintf_vma
  PARAMS ((bfd *, PTR, bfd_vma));
d175 1
a175 1
  bfd_object,		/* Linker/assember/compiler output.  */
d293 1
a293 1
    struct symbol_cache_entry *sym;	/* Function name.  */
d304 1
a304 1
typedef struct sec *sec_ptr;
d348 1
a348 2
extern const char *bfd_get_stab_name
  PARAMS ((int));
d382 1
a382 1
    PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d384 2
a385 2
     but we use PTR to avoid requiring the inclusion of objalloc.h.  */
  PTR memory;
d390 4
a393 4
  PARAMS ((struct bfd_hash_table *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d397 5
a401 5
  PARAMS ((struct bfd_hash_table *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *),
	   unsigned int size));
d405 1
a405 1
  PARAMS ((struct bfd_hash_table *));
d412 2
a413 2
  PARAMS ((struct bfd_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy));
d417 2
a418 2
  PARAMS ((struct bfd_hash_table *, struct bfd_hash_entry *old,
	   struct bfd_hash_entry *nw));
d422 1
a422 2
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *));
d425 2
a426 2
extern PTR bfd_hash_allocate
  PARAMS ((struct bfd_hash_table *, unsigned int));
d432 3
a434 3
  PARAMS ((struct bfd_hash_table *,
	   bfd_boolean (*) (struct bfd_hash_entry *, PTR),
	   PTR info));
d436 1
a436 1
#define COFF_SWAP_TABLE (PTR) &bfd_coff_std_swap_table
d443 6
a448 12
extern bfd_size_type bfd_bread
  PARAMS ((PTR, bfd_size_type, bfd *));
extern bfd_size_type bfd_bwrite
  PARAMS ((const PTR, bfd_size_type, bfd *));
extern int bfd_seek
  PARAMS ((bfd *, file_ptr, int));
extern ufile_ptr bfd_tell
  PARAMS ((bfd *));
extern int bfd_flush
  PARAMS ((bfd *));
extern int bfd_stat
  PARAMS ((bfd *, struct stat *));
d466 1
a466 2
extern void warn_deprecated
  PARAMS ((const char *, const char *, int, const char *));
d505 1
a505 1
  PARAMS ((bfd *abfd));
d509 2
a510 2
  PARAMS ((bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
	   bfd_boolean, bfd_boolean, unsigned int, struct sec **));
d514 18
a531 36
bfd_vma bfd_getb64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb16
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_16
  PARAMS ((const unsigned char *));
void bfd_putb64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb16
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl16
  PARAMS ((bfd_vma, unsigned char *));
d535 2
a536 4
bfd_vma bfd_get_bits
  PARAMS ((bfd_byte *, int, bfd_boolean));
void bfd_put_bits
  PARAMS ((bfd_vma, bfd_byte *, int, bfd_boolean));
d544 1
a544 1
struct symbol_cache_entry;
d550 1
a550 1
  PARAMS ((bfd * abfd));
d552 1
a552 1
  PARAMS ((bfd *abfd, bfd_vma gp_value));
d554 5
a558 6
  PARAMS ((bfd *abfd, unsigned long gprmask, unsigned long fprmask,
	   unsigned long *cprmask));
extern PTR bfd_ecoff_debug_init
  PARAMS ((bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   struct bfd_link_info *));
d560 2
a561 3
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   struct bfd_link_info *));
d563 4
a566 5
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   bfd *input_bfd, struct ecoff_debug_info *input_debug,
	   const struct ecoff_debug_swap *input_swap,
	   struct bfd_link_info *));
d568 3
a570 3
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
	   struct bfd_link_info *));
d572 4
a575 7
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   bfd_boolean relocateable,
	   bfd_boolean (*get_extr) (struct symbol_cache_entry *,
				    struct ecoff_extr *),
	   void (*set_index) (struct symbol_cache_entry *,
			      bfd_size_type)));
d577 3
a579 3
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   const char *name, struct ecoff_extr *esym));
d581 2
a582 2
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap));
d584 2
a585 2
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap, file_ptr where));
d587 3
a589 3
  PARAMS ((PTR handle, bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   struct bfd_link_info *info, file_ptr where));
d591 1
a591 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d602 8
a609 4
extern bfd_boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
extern bfd_boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
d611 1
a611 1
  PARAMS ((bfd *, struct bfd_link_info *));
d613 4
a616 9
  PARAMS ((bfd *, struct bfd_link_needed_list **));
extern bfd_boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
extern bfd_boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
d618 1
a618 3
  PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname
  PARAMS ((bfd *, const char *));
d620 3
a622 1
  PARAMS ((bfd *));
d624 3
a626 5
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf32_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf64_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
d632 1
a632 1
  PARAMS ((bfd *abfd));
d642 17
a658 1
  PARAMS ((bfd *abfd, void *phdrs));
d662 1
a662 1
  PARAMS ((bfd *));
d666 4
a669 1
  PARAMS ((bfd *));
d672 1
a672 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d674 1
a674 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d679 1
a679 1
  PARAMS ((bfd *, struct bfd_link_info *));
d681 1
a681 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d683 1
a683 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec **, struct sec **,
	   struct sec **));
d688 1
a688 1
  PARAMS ((bfd *, struct bfd_link_info *));
d690 1
a690 1
  PARAMS ((bfd *, struct bfd_link_info *));
d692 1
a692 1
  PARAMS ((bfd *, struct bfd_link_info *));
d702 1
a702 1
  PTR data;
d715 1
a715 1
  PARAMS ((bfd_window *));
d717 1
a717 1
  PARAMS ((bfd_window *));
d719 1
a719 1
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean));
d724 1
a724 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_size_type));
d726 2
a727 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_vma, const char *, const char *, const char *, unsigned int));
d729 1
a729 1
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *));
d731 1
a731 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d733 1
a733 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d735 3
a737 3
  PARAMS ((bfd *, struct bfd_link_info *, const char *, const char *,
	   unsigned long, unsigned long, unsigned long, bfd_boolean,
	   int, bfd_boolean, bfd_boolean, struct sec **, bfd_boolean));
d739 1
a739 1
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
d743 1
a743 1
  PARAMS ((bfd *, char *));
d753 1
a753 1
  PARAMS ((bfd *, struct symbol_cache_entry *, struct internal_syment *));
d756 1
a756 1
  PARAMS ((bfd *, struct symbol_cache_entry *, int, union internal_auxent *));
d759 1
a759 1
  PARAMS ((bfd *, struct symbol_cache_entry *, unsigned int));
d762 1
a762 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d766 1
a766 1
  PARAMS ((struct bfd_link_info *));
d769 1
a769 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d772 1
a772 1
  PARAMS ((bfd *, struct bfd_link_info *));
d776 1
a776 1
  PARAMS ((struct bfd_link_info *));
d779 1
a779 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d782 1
a782 1
  PARAMS ((bfd *, struct bfd_link_info *));
d786 1
a786 1
  PARAMS ((struct bfd_link_info *));
d789 1
a789 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d792 1
a792 1
  PARAMS ((bfd *, struct bfd_link_info *));
d795 1
a795 1
  PARAMS ((bfd *, struct bfd_link_info *));
d799 1
a799 1
  PARAMS ((bfd *, bfd *));
d802 1
a802 1
  PARAMS ((bfd *, const char *));
d805 1
a805 1
  PARAMS ((bfd *, const char *));
d809 1
a809 1
  PARAMS ((struct sec *, int));
d812 12
a823 1
  PARAMS ((struct sec *));
@


1.5
log
@resolve conflicts.
@
text
@d2 4
a5 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
   Free Software Foundation, Inc.
d8 15
a22 38
** NOTE: bfd.h and bfd-in2.h are GENERATED files.  Don't change them;
** instead, change bfd-in.h or the other BFD source files processed to
** generate these files.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* bfd.h -- The only header file required by users of the bfd library

The bfd.h file is generated from bfd-in.h and various .c files; if you
change it, your changes will probably be lost.

All the prototypes and definitions following the comment "THE FOLLOWING
IS EXTRACTED FROM THE SOURCE" are extracted from the source files for
BFD.  If you change it, someone oneday will extract it from the source
again, and your changes will be lost.  To save yourself from this bind,
change the definitions in the source in the bfd directory.  Type "make
docs" and then "make headers" in that directory, and magically this file
will change to reflect your changes.

If you don't have the tools to perform the extraction, then you are
safe from someone on your system trampling over your header files.
You should still maintain the equivalence between the source and this
file though; every change you make to the .c file should be reflected
here.  */
d32 12
d45 3
a47 2
/* These two lines get substitutions done by commands in Makefile.in.  */
#define BFD_VERSION  "@@VERSION@@"
d49 4
d71 2
a72 2
/* forward declaration */
typedef struct _bfd bfd;
d74 21
a94 28
/* To squelch erroneous compiler warnings ("illegal pointer
   combination") from the SVR3 compiler, we would like to typedef
   boolean to int (it doesn't like functions which return boolean.
   Making sure they are never implicitly declared to return int
   doesn't seem to help).  But this file is not configured based on
   the host.  */
/* General rules: functions which are boolean return true on success
   and false on failure (unless they're a predicate).   -- bfd.doc */
/* I'm sure this is going to break something and someone is going to
   force me to change it.  */
/* typedef enum boolean {false, true} boolean; */
/* Yup, SVR4 has a "typedef enum boolean" in <sys/types.h>  -fnf */
/* It gets worse if the host also defines a true/false enum... -sts */
/* And even worse if your compiler has built-in boolean types... -law */
#if defined (__GNUG__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6))
#define TRUE_FALSE_ALREADY_DEFINED
#endif
#ifdef MPW
/* Pre-emptive strike - get the file with the enum.  */
#include <Types.h>
#define TRUE_FALSE_ALREADY_DEFINED
#endif /* MPW */
#ifndef TRUE_FALSE_ALREADY_DEFINED
typedef enum bfd_boolean {false, true} boolean;
#define BFD_TRUE_FALSE
#else
/* Use enum names that will appear nowhere else.  */
typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;
a96 10
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef long int file_ptr;

d164 16
d181 1
d186 1
a186 1
/** File formats */
d188 9
a196 7
typedef enum bfd_format {
	      bfd_unknown = 0,	/* file format is unknown */
	      bfd_object,	/* linker/assember/compiler output */
	      bfd_archive,	/* object archive file */
	      bfd_core,		/* core dump */
	      bfd_type_end}	/* marks the end; don't use it! */
         bfd_format;
d254 3
d258 1
a258 1
/* symbols and relocation */
d282 3
a284 2
/* This is a type pun with struct ranlib on purpose! */
typedef struct carsym {
d286 3
a288 2
  file_ptr file_offset;		/* look here to find the file */
} carsym;			/* to make these you call a carsymogen */
d291 10
a300 5
   Perhaps just a forward definition would do? */
struct orl {			/* output ranlib */
  char **name;			/* symbol name */
  file_ptr pos;			/* bfd* or file position */
  int namidx;			/* index into string table */
d303 8
a310 6
/* Linenumber stuff */
typedef struct lineno_cache_entry {
  unsigned int line_number;	/* Linenumber from start of function*/
  union {
    struct symbol_cache_entry *sym; /* Function name */
    unsigned long offset;	/* Offset into section */
d312 2
a313 1
} alent;
d315 1
a315 1
/* object and core file sections */
d318 1
a318 1
	( ((addr) + ((1<<(align))-1)) & (-1 << (align)))
d324 1
d336 3
a338 3
#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma= (val)), ((ptr)->user_set_vma = (boolean)true), true)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),true)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),true)
d355 1
a355 1
  CONST char *name;            /* Symbol name.  */
d359 1
a359 1
  CONST char *stab_name;       /* String for stab type.  */
d364 2
a365 1
extern const char *bfd_get_stab_name PARAMS ((int));
d398 2
a399 3
  struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
					     struct bfd_hash_table *,
					     const char *));
d406 1
a406 1
extern boolean bfd_hash_table_init
d413 1
a413 1
extern boolean bfd_hash_table_init_n
d421 2
a422 1
extern void bfd_hash_table_free PARAMS ((struct bfd_hash_table *));
d424 1
a424 1
/* Look up a string in a hash table.  If CREATE is true, a new entry
d426 1
a426 1
   COPY argument must be true if this routine should copy the string
d429 2
a430 2
  PARAMS ((struct bfd_hash_table *, const char *, boolean create,
	   boolean copy));
d443 2
a444 2
extern PTR bfd_hash_allocate PARAMS ((struct bfd_hash_table *,
				      unsigned int));
d447 1
a447 1
   element.  If the function returns false, the traversal stops.  The
d449 4
a452 29
extern void bfd_hash_traverse PARAMS ((struct bfd_hash_table *,
				       boolean (*) (struct bfd_hash_entry *,
						    PTR),
				       PTR info));

/* Semi-portable string concatenation in cpp.
   The CAT4 hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCAT2 macro will cause the
   inner CAT macros to be evaluated first, producing still-valid pp-tokens.
   Then the final concatenation can be done.  (Sigh.)  */
#ifndef CAT
#ifdef SABER
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#define CAT4(a,b,c,d)	a##b##c##d
#else
#if defined(__STDC__) || defined(ALMOST_STDC)
#define CAT(a,b) a##b
#define CAT3(a,b,c) a##b##c
#define XCAT2(a,b)	CAT(a,b)
#define CAT4(a,b,c,d)	XCAT2(CAT(a,b),CAT(c,d))
#else
#define CAT(a,b) a/**/b
#define CAT3(a,b,c) a/**/b/**/c
#define CAT4(a,b,c,d)	a/**/b/**/c/**/d
#endif
#endif
#endif
d455 2
a456 2

/* User program access to BFD facilities */
d461 31
a491 8
extern bfd_size_type bfd_read
  PARAMS ((PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
extern bfd_size_type bfd_write
  PARAMS ((const PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
extern int bfd_seek PARAMS ((bfd *abfd, file_ptr fp, int direction));
extern long bfd_tell PARAMS ((bfd *abfd));
extern int bfd_flush PARAMS ((bfd *abfd));
extern int bfd_stat PARAMS ((bfd *abfd, struct stat *));
d523 2
d527 1
a527 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean) (bool)), true)
d529 7
a535 3
extern boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, boolean, flagword, boolean, bfd_vma,
	   boolean, boolean, unsigned int, struct sec **));
d539 36
a574 18
bfd_vma		bfd_getb64	   PARAMS ((const unsigned char *));
bfd_vma 	bfd_getl64	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_64 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_64 PARAMS ((const unsigned char *));
bfd_vma		bfd_getb32	   PARAMS ((const unsigned char *));
bfd_vma		bfd_getl32	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_32 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_32 PARAMS ((const unsigned char *));
bfd_vma		bfd_getb16	   PARAMS ((const unsigned char *));
bfd_vma		bfd_getl16	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_16 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_16 PARAMS ((const unsigned char *));
void		bfd_putb64	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl64	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putb32	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl32	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putb16	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl16	   PARAMS ((bfd_vma, unsigned char *));
d578 4
a581 2
bfd_vma         bfd_get_bits       PARAMS ((bfd_byte *, int, boolean));
void            bfd_put_bits       PARAMS ((bfd_vma, bfd_byte *, int, boolean));
d594 5
a598 3
extern bfd_vma bfd_ecoff_get_gp_value PARAMS ((bfd * abfd));
extern boolean bfd_ecoff_set_gp_value PARAMS ((bfd *abfd, bfd_vma gp_value));
extern boolean bfd_ecoff_set_regmasks
d609 1
a609 1
extern boolean bfd_ecoff_debug_accumulate
d615 1
a615 1
extern boolean bfd_ecoff_debug_accumulate_other
d619 1
a619 1
extern boolean bfd_ecoff_debug_externals
d622 3
a624 3
	   boolean relocateable,
	   boolean (*get_extr) (struct symbol_cache_entry *,
				struct ecoff_extr *),
d627 1
a627 1
extern boolean bfd_ecoff_debug_one_external
d634 1
a634 1
extern boolean bfd_ecoff_write_debug
d637 1
a637 1
extern boolean bfd_ecoff_write_accumulated_debug
d641 1
a641 1
extern boolean bfd_mips_ecoff_create_embedded_relocs
d654 4
a657 4
extern boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
extern boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
d660 1
a660 1
extern boolean bfd_elf_get_bfd_needed_list
d662 2
a663 2
extern boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
d666 2
a667 2
extern boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
d670 6
a675 3
extern void bfd_elf_set_dt_needed_name PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname PARAMS ((bfd *, const char *));
extern const char *bfd_elf_get_dt_soname PARAMS ((bfd *));
d678 4
d686 2
a687 1
extern long bfd_get_elf_phdr_upper_bound PARAMS ((bfd *abfd));
d696 2
a697 1
extern int bfd_get_elf_phdrs PARAMS ((bfd *abfd, void *phdrs));
d700 2
a701 1
extern int bfd_get_arch_size PARAMS ((bfd *));
d703 3
a705 2
/* Return true if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma PARAMS ((bfd *));
d707 4
a710 1
extern boolean bfd_m68k_elf32_create_embedded_relocs
d718 1
a718 1
extern boolean bfd_sunos_record_link_assignment
d720 1
a720 1
extern boolean bfd_sunos_size_dynamic_sections
d726 1
a726 1
extern boolean bfd_i386linux_size_dynamic_sections
d728 1
a728 1
extern boolean bfd_m68klinux_size_dynamic_sections
d730 1
a730 1
extern boolean bfd_sparclinux_size_dynamic_sections
d738 2
a739 1
typedef struct _bfd_window {
d750 2
a751 1
} bfd_window;
d753 6
a758 4
extern void bfd_init_window PARAMS ((bfd_window *));
extern void bfd_free_window PARAMS ((bfd_window *));
extern boolean bfd_get_file_window
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, boolean));
d762 1
a762 1
extern boolean bfd_xcoff_link_record_set
d765 1
a765 4
extern boolean bfd_xcoff_import_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_vma, const char *, const char *, const char *));
extern boolean bfd_xcoff_export_symbol
d767 4
a770 2
	   boolean));
extern boolean bfd_xcoff_link_count_reloc
d772 1
a772 1
extern boolean bfd_xcoff_record_link_assignment
d774 1
a774 1
extern boolean bfd_xcoff_size_dynamic_sections
d776 8
a783 2
	   unsigned long, unsigned long, unsigned long, boolean,
	   int, boolean, boolean, struct sec **));
d792 1
a792 1
extern boolean bfd_coff_get_syment
d795 1
a795 1
extern boolean bfd_coff_get_auxent
d798 1
a798 1
extern boolean bfd_coff_set_symbol_class
d801 1
a801 1
extern boolean bfd_m68k_coff_create_embedded_relocs
d806 1
a806 1
extern boolean bfd_arm_allocate_interworking_sections
d809 1
a809 1
extern boolean bfd_arm_process_before_allocation
d812 1
a812 1
extern boolean bfd_arm_get_bfd_for_interworking
d816 1
a816 1
extern boolean bfd_arm_pe_allocate_interworking_sections
d819 1
a819 1
extern boolean bfd_arm_pe_process_before_allocation
d822 1
a822 1
extern boolean bfd_arm_pe_get_bfd_for_interworking
d826 1
a826 1
extern boolean bfd_elf32_arm_allocate_interworking_sections
d829 1
a829 1
extern boolean bfd_elf32_arm_process_before_allocation
d832 4
a835 1
extern boolean bfd_elf32_arm_get_bfd_for_interworking
d838 10
a854 1
/* And more from the source.  */
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d27 1
a27 1
/* bfd.h -- The only header file required by users of the bfd library 
d88 1
a88 1
   force me to change it. */
d97 1
a97 1
/* Pre-emptive strike - get the file with the enum. */
d113 1
a113 1
   Probably the best long-term answer is to avoid using file_ptr AND off_t 
d181 2
a182 2
#define fprintf_vma(s,x) fprintf(s, "%08lx", x)
#define sprintf_vma(s,x) sprintf(s, "%08lx", x)
a287 1
  
d291 1
a291 1
  char **name;			/* symbol name */ 
a295 1

d298 1
a298 1
  unsigned int line_number;	/* Linenumber from start of function*/  
d329 1
a329 1
typedef struct stat stat_type; 
d332 1
a332 1
{ 
d337 1
a337 1
    
d346 1
a346 1
  char stab_other;             /* Stab other. */
a482 1

d490 3
d515 1
a515 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean)(bool)), true)
d541 5
d633 1
d635 2
d652 10
d740 4
d773 7
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a52 1
#include "obstack.h"
d92 1
a92 1
#if defined (__GNUG__) && (__GNUC_MINOR__ > 5)
d124 14
a140 8
#if BFD_HOST_64BIT_LONG
#define BFD_HOST_64_BIT long
#define BFD_HOST_U_64_BIT unsigned long
#else
#ifdef __GNUC__
#define BFD_HOST_64_BIT long long
#define BFD_HOST_U_64_BIT unsigned long long
#else /* ! defined (__GNUC__) */
a141 2
#endif /* ! defined (__GNUC__) */
#endif /* ! BFD_HOST_64BIT_LONG */
d182 1
d184 1
d319 1
d390 3
a392 2
  /* An obstack for this hash table.  */
  struct obstack memory;
d550 1
d616 2
d619 3
a621 2
  PARAMS ((bfd *, const char *, const char *, boolean,
	   struct bfd_link_info *, struct sec **));
d623 3
a625 2
  PARAMS ((bfd *, const char *, const char *, boolean,
	   struct bfd_link_info *, struct sec **));
d629 14
d659 2
d714 1
d717 33
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d56 1
a56 1
#define BFD_ARCH_SIZE @@WORDSIZE@@
d58 4
d121 2
a122 2
   use gcc's "long long" type.  Otherwise, the compilation will fail
   if 64-bit targets are requested.  */
d129 1
d133 1
d140 1
a140 1
typedef unsigned BFD_HOST_64_BIT bfd_vma;
d142 2
a143 2
typedef unsigned BFD_HOST_64_BIT bfd_size_type;
typedef unsigned BFD_HOST_64_BIT symvalue;
d202 1
a202 1
#define NO_FLAGS    	0x00
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d128 3
a130 1
#endif /* defined (__GNUC__) */
d240 4
d333 4
a336 3
  char stab_other;             /* Unused. */
  short stab_desc;             /* Info for N_TYPE.  */
  CONST char *stab_name;
d338 4
d478 6
d502 4
d608 1
d622 3
a624 1
extern boolean bfd_linux_size_dynamic_sections
d668 13
a680 1
	   int, boolean, struct sec **));
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d128 1
a128 3
#else /* ! defined (__GNUC__) */
 #error No 64 bit integer type available
#endif /* ! defined (__GNUC__) */
a237 4

/* This flag indicates that the BFD contents are actually cached in
   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
#define BFD_IN_MEMORY 0x800
d327 3
a329 4
  unsigned char stab_type;     /* Stab type.  */
  char stab_other;             /* Stab other. */
  short stab_desc;             /* Stab desc.  */
  CONST char *stab_name;       /* String for stab type.  */
a330 4

/* Get the name of a stabs type code.  */

extern const char *bfd_get_stab_name PARAMS ((int));
a466 6
#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
#define bfd_header_big_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
#define bfd_header_little_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
a484 4
extern boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, boolean, flagword, boolean, bfd_vma,
	   boolean, boolean, unsigned int, struct sec **));

a586 1
extern const char *bfd_elf_get_dt_soname PARAMS ((bfd *));
d600 1
a600 3
extern boolean bfd_i386linux_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean bfd_m68klinux_size_dynamic_sections
d644 1
a644 13
	   int, boolean, boolean, struct sec **));

/* Externally visible COFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct internal_syment;
union internal_auxent;
#endif

extern boolean bfd_coff_get_syment
  PARAMS ((bfd *, struct symbol_cache_entry *, struct internal_syment *));
extern boolean bfd_coff_get_auxent
  PARAMS ((bfd *, struct symbol_cache_entry *, int, union internal_auxent *));
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d56 1
a56 1
#define BFD_ARCH_SIZE @@wordsize@@
a57 4
#if @@BFD_HOST_64_BIT_DEFINED@@
#define BFD_HOST_64_BIT @@BFD_HOST_64_BIT@@
#define BFD_HOST_U_64_BIT @@BFD_HOST_U_64_BIT@@
#endif
d117 2
a118 2
   use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be
   defined above.  */
a124 1
#define BFD_HOST_U_64_BIT unsigned long
a127 1
#define BFD_HOST_U_64_BIT unsigned long long
d134 1
a134 1
typedef BFD_HOST_U_64_BIT bfd_vma;
d136 2
a137 2
typedef BFD_HOST_U_64_BIT bfd_size_type;
typedef BFD_HOST_U_64_BIT symvalue;
d196 1
a196 1
#define BFD_NO_FLAGS   	0x00
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d52 1
d383 2
a384 3
   /* An objalloc for this hash table.  This is a struct objalloc *,
     but we use PTR to avoid requiring the inclusion of objalloc.h.  */
  PTR memory;
a541 1
struct bfd_elf_version_tree;
d608 2
a609 3
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
d611 2
a612 3
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
a630 2
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean bfd_sparclinux_size_dynamic_sections
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d91 1
a91 1
#if defined (__GNUG__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6))
a122 14
#ifndef BFD_HOST_64_BIT
# if BFD_HOST_64BIT_LONG
#  define BFD_HOST_64_BIT long
#  define BFD_HOST_U_64_BIT unsigned long
# else
#  ifdef __GNUC__
#   if __GNUC__ >= 2
#    define BFD_HOST_64_BIT long long
#    define BFD_HOST_U_64_BIT unsigned long long
#   endif /* __GNUC__ >= 2 */
#  endif /* ! defined (__GNUC__) */
# endif /* ! BFD_HOST_64BIT_LONG */
#endif /* ! defined (BFD_HOST_64_BIT) */

d126 8
d135 2
a176 1

a177 1

a311 1
#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
a607 2
extern boolean bfd_elf_get_bfd_needed_list
  PARAMS ((bfd *, struct bfd_link_needed_list **));
a618 14
/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */
extern long bfd_get_elf_phdr_upper_bound PARAMS ((bfd *abfd));

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */
extern int bfd_get_elf_phdrs PARAMS ((bfd *abfd, void *phdrs));

a689 1

a691 33

extern boolean bfd_coff_set_symbol_class
  PARAMS ((bfd *, struct symbol_cache_entry *, unsigned int));

/* ARM Interworking support.  Called from linker.  */
extern boolean bfd_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

/* PE ARM Interworking support.  Called from linker.  */
extern boolean bfd_arm_pe_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_arm_pe_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_arm_pe_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

/* ELF ARM Interworking support.  Called from linker.  */
extern boolean bfd_elf32_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_elf32_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d26 1
a26 1
/* bfd.h -- The only header file required by users of the bfd library
d87 1
a87 1
   force me to change it.  */
d96 1
a96 1
/* Pre-emptive strike - get the file with the enum.  */
d112 1
a112 1
   Probably the best long-term answer is to avoid using file_ptr AND off_t
d180 2
a181 2
#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
d287 1
d291 1
a291 1
  char **name;			/* symbol name */
d296 1
d299 1
a299 1
  unsigned int line_number;	/* Linenumber from start of function*/
d330 1
a330 1
typedef struct stat stat_type;
d333 1
a333 1
{
d338 1
a338 1

d347 1
a347 1
  char stab_other;             /* Stab other.  */
d484 1
a491 3
#define bfd_family_coff(abfd) \
  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
d514 1
a514 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean) (bool)), true)
a539 5

/* Byte swapping routines which take size and endiannes as arguments.  */

bfd_vma         bfd_get_bits       PARAMS ((bfd_byte *, int, boolean));
void            bfd_put_bits       PARAMS ((bfd_vma, bfd_byte *, int, boolean));
a626 1
extern void bfd_elf_set_dt_needed_soname PARAMS ((bfd *, const char *));
a627 2
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  PARAMS ((bfd *, struct bfd_link_info *));
a642 10
/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
extern int bfd_get_arch_size PARAMS ((bfd *));

/* Return true if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma PARAMS ((bfd *));

extern boolean bfd_m68k_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));

a720 4
extern boolean bfd_m68k_coff_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));

a749 7

/* TI COFF load page support.  */
extern void bfd_ticoff_set_section_load_page
  PARAMS ((struct sec *, int));

extern int bfd_ticoff_get_section_load_page
  PARAMS ((struct sec *));
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 3
a4 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

d7 38
a44 15
   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a53 12
#include "symcat.h"
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#ifndef SABER
/* This hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
   cause the inner CONCAT2 macros to be evaluated first, producing
   still-valid pp-tokens.  Then the final concatenation can be done.  */
#undef CONCAT4
#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
#endif
#endif
d55 2
a56 3
/* The word size used by BFD on the host.  This may be 64 with a 32
   bit target if the host is 64 bit, or if other 64 bit targets have
   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
a57 4

/* The word size of the default bfd target.  */
#define BFD_DEFAULT_TARGET_SIZE @@bfd_default_target_size@@

d76 2
a77 2
/* Forward declaration.  */
typedef struct bfd bfd;
d79 28
a106 21
/* Boolean type used in bfd.  Too many systems define their own
   versions of "boolean" for us to safely typedef a "boolean" of
   our own.  Using an enum for "bfd_boolean" has its own set of
   problems, with strange looking casts required to avoid warnings
   on some older compilers.  Thus we just use an int.

   General rule: Functions which are bfd_boolean return TRUE on
   success and FALSE on failure (unless they're a predicate).  */

typedef int bfd_boolean;
#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE 1

#if 0
/* Poison.  */
#undef false
#undef true
#define false dont_use_false_in_bfd
#define true dont_use_true_in_bfd
d109 10
a185 16
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef bfd_signed_vma file_ptr;
typedef bfd_vma ufile_ptr;

extern void bfd_sprintf_vma
  PARAMS ((bfd *, char *, bfd_vma));
extern void bfd_fprintf_vma
  PARAMS ((bfd *, PTR, bfd_vma));

a186 1
#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
d191 1
a191 1
/* File formats.  */
d193 7
a199 9
typedef enum bfd_format
{
  bfd_unknown = 0,	/* File format is unknown.  */
  bfd_object,		/* Linker/assember/compiler output.  */
  bfd_archive,		/* Object archive file.  */
  bfd_core,		/* Core dump.  */
  bfd_type_end		/* Marks the end; don't use it!  */
}
bfd_format;
a256 3

/* The sections in this BFD specify a memory page.  */
#define HAS_LOAD_PAGE 0x1000
d258 1
a258 1
/* Symbols and relocation.  */
d282 2
a283 3
/* This is a type pun with struct ranlib on purpose!  */
typedef struct carsym
{
d285 2
a286 3
  file_ptr file_offset;	/* Look here to find the file.  */
}
carsym;			/* To make these you call a carsymogen.  */
d289 5
a293 10
   Perhaps just a forward definition would do?  */
struct orl 			/* Output ranlib.  */
{
  char **name;		/* Symbol name.  */
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;			/* bfd* or file position.  */
  int namidx;		/* Index into string table.  */
d296 6
a301 8
/* Linenumber stuff.  */
typedef struct lineno_cache_entry
{
  unsigned int line_number;	/* Linenumber from start of function.  */
  union
  {
    struct symbol_cache_entry *sym;	/* Function name.  */
    bfd_vma offset;	    		/* Offset into section.  */
d303 1
a303 2
}
alent;
d305 1
a305 1
/* Object and core file sections.  */
d308 1
a308 1
  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
a313 1
#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
d325 3
a327 3
#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
d344 1
a344 1
  const char *name;            /* Symbol name.  */
d348 1
a348 1
  const char *stab_name;       /* String for stab type.  */
d353 1
a353 2
extern const char *bfd_get_stab_name
  PARAMS ((int));
d386 3
a388 2
  struct bfd_hash_entry *(*newfunc)
    PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d395 1
a395 1
extern bfd_boolean bfd_hash_table_init
d402 1
a402 1
extern bfd_boolean bfd_hash_table_init_n
d410 1
a410 2
extern void bfd_hash_table_free
  PARAMS ((struct bfd_hash_table *));
d412 1
a412 1
/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
d414 1
a414 1
   COPY argument must be TRUE if this routine should copy the string
d417 2
a418 2
  PARAMS ((struct bfd_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy));
d431 2
a432 2
extern PTR bfd_hash_allocate
  PARAMS ((struct bfd_hash_table *, unsigned int));
d435 1
a435 1
   element.  If the function returns FALSE, the traversal stops.  The
d437 29
a465 4
extern void bfd_hash_traverse
  PARAMS ((struct bfd_hash_table *,
	   bfd_boolean (*) (struct bfd_hash_entry *, PTR),
	   PTR info));
d468 2
a469 2

/* User program access to BFD facilities.  */
d474 8
a481 31
extern bfd_size_type bfd_bread
  PARAMS ((PTR, bfd_size_type, bfd *));
extern bfd_size_type bfd_bwrite
  PARAMS ((const PTR, bfd_size_type, bfd *));
extern int bfd_seek
  PARAMS ((bfd *, file_ptr, int));
extern ufile_ptr bfd_tell
  PARAMS ((bfd *));
extern int bfd_flush
  PARAMS ((bfd *));
extern int bfd_stat
  PARAMS ((bfd *, struct stat *));

/* Deprecated old routines.  */
#if __GNUC__
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#else
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#endif
extern void warn_deprecated
  PARAMS ((const char *, const char *, int, const char *));
a512 2
#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)

d515 1
a515 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
d517 3
a519 7
extern bfd_boolean bfd_cache_close
  PARAMS ((bfd *abfd));
/* NB: This declaration should match the autogenerated one in libbfd.h.  */

extern bfd_boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
	   bfd_boolean, bfd_boolean, unsigned int, struct sec **));
d523 18
a540 36
bfd_vma bfd_getb64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb16
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_16
  PARAMS ((const unsigned char *));
void bfd_putb64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb16
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl16
  PARAMS ((bfd_vma, unsigned char *));
d544 2
a545 4
bfd_vma bfd_get_bits
  PARAMS ((bfd_byte *, int, bfd_boolean));
void bfd_put_bits
  PARAMS ((bfd_vma, bfd_byte *, int, bfd_boolean));
d558 3
a560 5
extern bfd_vma bfd_ecoff_get_gp_value
  PARAMS ((bfd * abfd));
extern bfd_boolean bfd_ecoff_set_gp_value
  PARAMS ((bfd *abfd, bfd_vma gp_value));
extern bfd_boolean bfd_ecoff_set_regmasks
d571 1
a571 1
extern bfd_boolean bfd_ecoff_debug_accumulate
d577 1
a577 1
extern bfd_boolean bfd_ecoff_debug_accumulate_other
d581 1
a581 1
extern bfd_boolean bfd_ecoff_debug_externals
d584 3
a586 3
	   bfd_boolean relocateable,
	   bfd_boolean (*get_extr) (struct symbol_cache_entry *,
				    struct ecoff_extr *),
d589 1
a589 1
extern bfd_boolean bfd_ecoff_debug_one_external
d596 1
a596 1
extern bfd_boolean bfd_ecoff_write_debug
d599 1
a599 1
extern bfd_boolean bfd_ecoff_write_accumulated_debug
d603 1
a603 1
extern bfd_boolean bfd_mips_ecoff_create_embedded_relocs
d616 4
a619 4
extern bfd_boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
extern bfd_boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
d622 1
a622 1
extern bfd_boolean bfd_elf_get_bfd_needed_list
d624 2
a625 2
extern bfd_boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
d628 2
a629 2
extern bfd_boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
d632 3
a634 6
extern void bfd_elf_set_dt_needed_name
  PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname
  PARAMS ((bfd *, const char *));
extern const char *bfd_elf_get_dt_soname
  PARAMS ((bfd *));
a636 4
extern bfd_boolean bfd_elf32_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf64_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
d641 1
a641 2
extern long bfd_get_elf_phdr_upper_bound
  PARAMS ((bfd *abfd));
d650 1
a650 2
extern int bfd_get_elf_phdrs
  PARAMS ((bfd *abfd, void *phdrs));
d653 1
a653 2
extern int bfd_get_arch_size
  PARAMS ((bfd *));
d655 2
a656 3
/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma
  PARAMS ((bfd *));
d658 1
a658 4
extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
extern bfd_boolean bfd_mips_elf32_create_embedded_relocs
d666 1
a666 1
extern bfd_boolean bfd_sunos_record_link_assignment
d668 1
a668 1
extern bfd_boolean bfd_sunos_size_dynamic_sections
d674 1
a674 1
extern bfd_boolean bfd_i386linux_size_dynamic_sections
d676 1
a676 1
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
d678 1
a678 1
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
d686 1
a686 2
typedef struct _bfd_window
{
d697 1
a697 2
}
bfd_window;
d699 4
a702 6
extern void bfd_init_window
  PARAMS ((bfd_window *));
extern void bfd_free_window
  PARAMS ((bfd_window *));
extern bfd_boolean bfd_get_file_window
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean));
d706 1
a706 1
extern bfd_boolean bfd_xcoff_link_record_set
d709 4
a712 1
extern bfd_boolean bfd_xcoff_import_symbol
d714 2
a715 4
	   bfd_vma, const char *, const char *, const char *, unsigned int));
extern bfd_boolean bfd_xcoff_export_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *));
extern bfd_boolean bfd_xcoff_link_count_reloc
d717 1
a717 1
extern bfd_boolean bfd_xcoff_record_link_assignment
d719 1
a719 1
extern bfd_boolean bfd_xcoff_size_dynamic_sections
d721 2
a722 8
	   unsigned long, unsigned long, unsigned long, bfd_boolean,
	   int, bfd_boolean, bfd_boolean, struct sec **, bfd_boolean));
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));

/* XCOFF support routines for ar.  */
extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  PARAMS ((bfd *, char *));
d731 1
a731 1
extern bfd_boolean bfd_coff_get_syment
d734 1
a734 1
extern bfd_boolean bfd_coff_get_auxent
d737 1
a737 1
extern bfd_boolean bfd_coff_set_symbol_class
d740 1
a740 1
extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
d745 1
a745 1
extern bfd_boolean bfd_arm_allocate_interworking_sections
d748 1
a748 1
extern bfd_boolean bfd_arm_process_before_allocation
d751 1
a751 1
extern bfd_boolean bfd_arm_get_bfd_for_interworking
d755 1
a755 1
extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
d758 1
a758 1
extern bfd_boolean bfd_arm_pe_process_before_allocation
d761 1
a761 1
extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
d765 1
a765 1
extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
d768 1
a768 1
extern bfd_boolean bfd_elf32_arm_process_before_allocation
d771 1
a771 4
extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
a773 10
/* ARM Note section processing.  */
extern bfd_boolean bfd_arm_merge_machines
  PARAMS ((bfd *, bfd *));

extern bfd_boolean bfd_arm_update_notes
  PARAMS ((bfd *, const char *));

extern unsigned int bfd_arm_get_mach_from_notes
  PARAMS ((bfd *, const char *));

d781 1
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a53 1
#define BFD_HOST_LONG_LONG @@BFD_HOST_LONG_LONG@@
a56 2
typedef BFD_HOST_64_BIT bfd_int64_t;
typedef BFD_HOST_U_64_BIT bfd_uint64_t;
d97 20
d164 15
a178 16
#ifndef BFD_HOST_64_BIT
/* Fall back on a 32 bit type.  The idea is to make these types always
   available for function return types, but in the case that
   BFD_HOST_64_BIT is undefined such a function should abort or
   otherwise signal an error.  */
typedef bfd_signed_vma bfd_int64_t;
typedef bfd_vma bfd_uint64_t;
#endif

/* An offset into a file.  BFD always uses the largest possible offset
   based on the build time availability of fseek, fseeko, or fseeko64.  */
typedef @@bfd_file_ptr@@ file_ptr;
typedef unsigned @@bfd_file_ptr@@ ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
d191 1
a191 1
  bfd_object,		/* Linker/assembler/compiler output.  */
d309 1
a309 1
    struct bfd_symbol *sym;	/* Function name.  */
d320 1
a320 1
typedef struct bfd_section *sec_ptr;
d364 2
a365 1
extern const char *bfd_get_stab_name (int);
d399 1
a399 1
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d401 2
a402 2
     but we use void * to avoid requiring the inclusion of objalloc.h.  */
  void *memory;
d407 4
a410 4
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));
d414 5
a418 5
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *),
   unsigned int size);
d422 1
a422 1
  (struct bfd_hash_table *);
d429 2
a430 2
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);
d434 2
a435 2
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);
d439 2
a440 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d443 2
a444 2
extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);
d450 3
a452 3
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);
d454 1
a454 1
#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
d461 12
a472 6
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
d490 2
a491 1
extern void warn_deprecated (const char *, const char *, int, const char *);
d530 1
a530 1
  (bfd *abfd);
d534 2
a535 2
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
d539 36
a574 18
bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);
d578 4
a581 2
bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
d589 1
a589 1
struct bfd_symbol;
d595 1
a595 1
  (bfd * abfd);
d597 1
a597 1
  (bfd *abfd, bfd_vma gp_value);
d599 6
a604 5
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
d606 3
a608 2
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
d610 5
a614 4
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
d616 3
a618 3
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
d620 7
a626 4
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
d628 3
a630 3
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
d632 2
a633 2
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
d635 2
a636 2
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
d638 3
a640 3
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);
d642 2
a643 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d654 4
a657 8
enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean);
d659 1
a659 1
  (bfd *, struct bfd_link_info *);
d661 9
a669 4
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char * const *,
   struct bfd_link_info *, struct bfd_section **, struct bfd_elf_version_tree *);
d671 3
a673 1
  (bfd *, const char *);
d675 1
a675 3
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, int);
d677 5
a681 3
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
d687 1
a687 1
  (bfd *abfd);
d697 1
a697 17
  (bfd *abfd, void *phdrs);

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));
d701 1
a701 1
  (bfd *);
d705 1
a705 4
  (bfd *);

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);
d708 2
a709 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d711 2
a712 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d717 1
a717 1
  (bfd *, struct bfd_link_info *);
d719 1
a719 1
  (bfd *, struct bfd_link_info *, const char *);
d721 2
a722 1
  (bfd *, struct bfd_link_info *, struct bfd_section **, struct bfd_section **, struct bfd_section **);
d727 1
a727 1
  (bfd *, struct bfd_link_info *);
d729 1
a729 1
  (bfd *, struct bfd_link_info *);
d731 1
a731 1
  (bfd *, struct bfd_link_info *);
d741 1
a741 1
  void *data;
d754 1
a754 1
  (bfd_window *);
d756 1
a756 1
  (bfd_window *);
d758 1
a758 1
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
d763 2
a764 1
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
d766 2
a767 2
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
d769 1
a769 1
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
d771 1
a771 1
  (bfd *, struct bfd_link_info *, const char *);
d773 1
a773 1
  (bfd *, struct bfd_link_info *, const char *);
d775 3
a777 3
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
d779 1
a779 1
  (bfd *, const char *, const char *, bfd_boolean);
d783 1
a783 1
  (bfd *, char *);
d793 1
a793 1
  (bfd *, struct bfd_symbol *, struct internal_syment *);
d796 1
a796 1
  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
d799 1
a799 1
  (bfd *, struct bfd_symbol *, unsigned int);
d802 2
a803 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d807 1
a807 1
  (struct bfd_link_info *);
d810 1
a810 1
  (bfd *, struct bfd_link_info *, int);
d813 1
a813 1
  (bfd *, struct bfd_link_info *);
d817 1
a817 1
  (struct bfd_link_info *);
d820 1
a820 1
  (bfd *, struct bfd_link_info *, int);
d823 1
a823 1
  (bfd *, struct bfd_link_info *);
d827 1
a827 1
  (struct bfd_link_info *);
d830 1
a830 1
  (bfd *, struct bfd_link_info *, int);
d833 1
a833 1
  (bfd *, struct bfd_link_info *);
d836 1
a836 1
  (bfd *, struct bfd_link_info *);
d840 1
a840 1
  (bfd *, bfd *);
d843 1
a843 1
  (bfd *, const char *);
d846 1
a846 1
  (bfd *, const char *);
d850 1
a850 1
  (struct bfd_section *, int);
d853 1
a853 12
  (struct bfd_section *);

/* H8/300 functions.  */
extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);

/* IA64 Itanium code generation.  Called from linker.  */
extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);
@


