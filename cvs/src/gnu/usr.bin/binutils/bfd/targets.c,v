head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.10
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.30
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.34
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.32
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.28
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.26
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.24
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.22
	OPENBSD_5_0:1.13.0.20
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	new-binutils:1.7.0.6
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.04.06.18.29.27;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	DQNigUiY2QvUNxoT;

1.13
date	2006.10.08.21.12.37;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.02.20.45.13;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.20.21.33.53;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.12.19.11.24;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.02.09.04.01.37;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	97.07.03.14.39.23;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.03.33.32;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.06.19.40.27;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.02.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.47.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.34;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.03;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.20.48;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.58;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.28.08;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Add support for an efi-app-x86_64 target.  Needed for UEFI bootloader work.

ok mlarkin@@
@
text
@/* Generic target-file-type support for the BFD library.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "fnmatch.h"

/*
SECTION
	Targets

DESCRIPTION
	Each port of BFD to a different machine requires the creation
	of a target back end. All the back end provides to the root
	part of BFD is a structure containing pointers to functions
	which perform certain low level operations on files. BFD
	translates the applications's requests through a pointer into
	calls to the back end routines.

	When a file is opened with <<bfd_openr>>, its format and
	target are unknown. BFD uses various mechanisms to determine
	how to interpret the file. The operations performed are:

	o Create a BFD by calling the internal routine
	<<_bfd_new_bfd>>, then call <<bfd_find_target>> with the
	target string supplied to <<bfd_openr>> and the new BFD pointer.

	o If a null target string was provided to <<bfd_find_target>>,
	look up the environment variable <<GNUTARGET>> and use
	that as the target string.

	o If the target string is still <<NULL>>, or the target string is
	<<default>>, then use the first item in the target vector
	as the target type, and set <<target_defaulted>> in the BFD to
	cause <<bfd_check_format>> to loop through all the targets.
	@@xref{bfd_target}.  @@xref{Formats}.

	o Otherwise, inspect the elements in the target vector
	one by one, until a match on target name is found. When found,
	use it.

	o Otherwise return the error <<bfd_error_invalid_target>> to
	<<bfd_openr>>.

	o <<bfd_openr>> attempts to open the file using
	<<bfd_open_file>>, and returns the BFD.

	Once the BFD has been opened and the target selected, the file
	format may be determined. This is done by calling
	<<bfd_check_format>> on the BFD with a suggested format.
	If <<target_defaulted>> has been set, each possible target
	type is tried to see if it recognizes the specified format.
	<<bfd_check_format>> returns <<TRUE>> when the caller guesses right.
@@menu
@@* bfd_target::
@@end menu
*/

/*

INODE
	bfd_target,  , Targets, Targets
DOCDD
SUBSECTION
	bfd_target

DESCRIPTION
	This structure contains everything that BFD knows about a
	target. It includes things like its byte order, name, and which
	routines to call to do various operations.

	Every BFD points to a target structure with its <<xvec>>
	member.

	The macros below are used to dispatch to functions through the
	<<bfd_target>> vector. They are used in a number of macros further
	down in @@file{bfd.h}, and are also used when calling various
	routines by hand inside the BFD implementation.  The @@var{arglist}
	argument must be parenthesized; it contains all the arguments
	to the called function.

	They make the documentation (more) unpleasant to read, so if
	someone wants to fix this and not break the above, please do.

.#define BFD_SEND(bfd, message, arglist) \
.  ((*((bfd)->xvec->message)) arglist)
.
.#ifdef DEBUG_BFD_SEND
.#undef BFD_SEND
.#define BFD_SEND(bfd, message, arglist) \
.  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
.    ((*((bfd)->xvec->message)) arglist) : \
.    (bfd_assert (__FILE__,__LINE__), NULL))
.#endif

	For operations which index on the BFD format:

.#define BFD_SEND_FMT(bfd, message, arglist) \
.  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
.
.#ifdef DEBUG_BFD_SEND
.#undef BFD_SEND_FMT
.#define BFD_SEND_FMT(bfd, message, arglist) \
.  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
.   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
.   (bfd_assert (__FILE__,__LINE__), NULL))
.#endif
.
	This is the structure which defines the type of BFD this is.  The
	<<xvec>> member of the struct <<bfd>> itself points here.  Each
	module that implements access to a different target under BFD,
	defines one of these.

	FIXME, these names should be rationalised with the names of
	the entry points which call them. Too bad we can't have one
	macro to define them both!

.enum bfd_flavour
.{
.  bfd_target_unknown_flavour,
.  bfd_target_aout_flavour,
.  bfd_target_coff_flavour,
.  bfd_target_ecoff_flavour,
.  bfd_target_xcoff_flavour,
.  bfd_target_elf_flavour,
.  bfd_target_ieee_flavour,
.  bfd_target_nlm_flavour,
.  bfd_target_oasys_flavour,
.  bfd_target_tekhex_flavour,
.  bfd_target_srec_flavour,
.  bfd_target_ihex_flavour,
.  bfd_target_som_flavour,
.  bfd_target_os9k_flavour,
.  bfd_target_versados_flavour,
.  bfd_target_msdos_flavour,
.  bfd_target_ovax_flavour,
.  bfd_target_evax_flavour,
.  bfd_target_mmo_flavour,
.  bfd_target_mach_o_flavour,
.  bfd_target_pef_flavour,
.  bfd_target_pef_xlib_flavour,
.  bfd_target_sym_flavour
.};
.
.enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
.
.{* Forward declaration.  *}
.typedef struct bfd_link_info _bfd_link_info;
.
.typedef struct bfd_target
.{
.  {* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  *}
.  char *name;
.
. {* The "flavour" of a back end is a general indication about
.    the contents of a file.  *}
.  enum bfd_flavour flavour;
.
.  {* The order of bytes within the data area of a file.  *}
.  enum bfd_endian byteorder;
.
. {* The order of bytes within the header parts of a file.  *}
.  enum bfd_endian header_byteorder;
.
.  {* A mask of all the flags which an executable may have set -
.     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  *}
.  flagword object_flags;
.
. {* A mask of all the flags which a section may have set - from
.    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  *}
.  flagword section_flags;
.
. {* The character normally found at the front of a symbol.
.    (if any), perhaps `_'.  *}
.  char symbol_leading_char;
.
. {* The pad character for file names within an archive header.  *}
.  char ar_pad_char;
.
.  {* The maximum number of characters in an archive header.  *}
.  unsigned short ar_max_namelen;
.
.  {* Entries for byte swapping for data. These are different from the
.     other entry points, since they don't take a BFD asthe first argument.
.     Certain other handlers could do the same.  *}
.  bfd_uint64_t   (*bfd_getx64) (const void *);
.  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
.  void           (*bfd_putx64) (bfd_uint64_t, void *);
.  bfd_vma        (*bfd_getx32) (const void *);
.  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
.  void           (*bfd_putx32) (bfd_vma, void *);
.  bfd_vma        (*bfd_getx16) (const void *);
.  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
.  void           (*bfd_putx16) (bfd_vma, void *);
.
.  {* Byte swapping for the headers.  *}
.  bfd_uint64_t   (*bfd_h_getx64) (const void *);
.  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
.  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
.  bfd_vma        (*bfd_h_getx32) (const void *);
.  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
.  void           (*bfd_h_putx32) (bfd_vma, void *);
.  bfd_vma        (*bfd_h_getx16) (const void *);
.  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
.  void           (*bfd_h_putx16) (bfd_vma, void *);
.
.  {* Format dependent routines: these are vectors of entry points
.     within the target vector structure, one for each format to check.  *}
.
.  {* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  *}
.  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
.
.  {* Set the format of a file being written.  *}
.  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
.
.  {* Write cached information into a file being written, at <<bfd_close>>.  *}
.  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
.
The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.
.
.  {* Generic entry points.  *}
.#define BFD_JUMP_TABLE_GENERIC(NAME) \
.  NAME##_close_and_cleanup, \
.  NAME##_bfd_free_cached_info, \
.  NAME##_new_section_hook, \
.  NAME##_get_section_contents, \
.  NAME##_get_section_contents_in_window
.
.  {* Called when the BFD is being closed to do any necessary cleanup.  *}
.  bfd_boolean (*_close_and_cleanup) (bfd *);
.  {* Ask the BFD to free all cached information.  *}
.  bfd_boolean (*_bfd_free_cached_info) (bfd *);
.  {* Called when a new section is created.  *}
.  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
.  {* Read the contents of a section.  *}
.  bfd_boolean (*_bfd_get_section_contents)
.    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
.  bfd_boolean (*_bfd_get_section_contents_in_window)
.    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
.
.  {* Entry points to copy private data.  *}
.#define BFD_JUMP_TABLE_COPY(NAME) \
.  NAME##_bfd_copy_private_bfd_data, \
.  NAME##_bfd_merge_private_bfd_data, \
.  NAME##_bfd_copy_private_section_data, \
.  NAME##_bfd_copy_private_symbol_data, \
.  NAME##_bfd_set_private_flags, \
.  NAME##_bfd_print_private_bfd_data
.
.  {* Called to copy BFD general private data from one object file
.     to another.  *}
.  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
.  {* Called to merge BFD general private data from one object file
.     to a common output file when linking.  *}
.  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
.  {* Called to copy BFD private section data from one object file
.     to another.  *}
.  bfd_boolean (*_bfd_copy_private_section_data)
.    (bfd *, sec_ptr, bfd *, sec_ptr);
.  {* Called to copy BFD private symbol data from one symbol
.     to another.  *}
.  bfd_boolean (*_bfd_copy_private_symbol_data)
.    (bfd *, asymbol *, bfd *, asymbol *);
.  {* Called to set private backend flags.  *}
.  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
.
.  {* Called to print private BFD data.  *}
.  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
.
.  {* Core file entry points.  *}
.#define BFD_JUMP_TABLE_CORE(NAME) \
.  NAME##_core_file_failing_command, \
.  NAME##_core_file_failing_signal, \
.  NAME##_core_file_matches_executable_p
.
.  char *      (*_core_file_failing_command) (bfd *);
.  int         (*_core_file_failing_signal) (bfd *);
.  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
.
.  {* Archive entry points.  *}
.#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
.  NAME##_slurp_armap, \
.  NAME##_slurp_extended_name_table, \
.  NAME##_construct_extended_name_table, \
.  NAME##_truncate_arname, \
.  NAME##_write_armap, \
.  NAME##_read_ar_hdr, \
.  NAME##_openr_next_archived_file, \
.  NAME##_get_elt_at_index, \
.  NAME##_generic_stat_arch_elt, \
.  NAME##_update_armap_timestamp
.
.  bfd_boolean (*_bfd_slurp_armap) (bfd *);
.  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
.  bfd_boolean (*_bfd_construct_extended_name_table)
.    (bfd *, char **, bfd_size_type *, const char **);
.  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
.  bfd_boolean (*write_armap)
.    (bfd *, unsigned int, struct orl *, unsigned int, int);
.  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
.  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
.#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
.  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
.  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
.  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
.
.  {* Entry points used for symbols.  *}
.#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
.  NAME##_get_symtab_upper_bound, \
.  NAME##_canonicalize_symtab, \
.  NAME##_make_empty_symbol, \
.  NAME##_print_symbol, \
.  NAME##_get_symbol_info, \
.  NAME##_bfd_is_local_label_name, \
.  NAME##_get_lineno, \
.  NAME##_find_nearest_line, \
.  NAME##_bfd_make_debug_symbol, \
.  NAME##_read_minisymbols, \
.  NAME##_minisymbol_to_symbol
.
.  long        (*_bfd_get_symtab_upper_bound) (bfd *);
.  long        (*_bfd_canonicalize_symtab)
.    (bfd *, struct bfd_symbol **);
.  struct bfd_symbol *
.              (*_bfd_make_empty_symbol) (bfd *);
.  void        (*_bfd_print_symbol)
.    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
.#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
.  void        (*_bfd_get_symbol_info)
.    (bfd *, struct bfd_symbol *, symbol_info *);
.#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
.  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
.
.  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
.  bfd_boolean (*_bfd_find_nearest_line)
.    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
.     const char **, const char **, unsigned int *);
. {* Back-door to allow format-aware applications to create debug symbols
.    while using BFD for everything else.  Currently used by the assembler
.    when creating COFF files.  *}
.  asymbol *   (*_bfd_make_debug_symbol)
.    (bfd *, void *, unsigned long size);
.#define bfd_read_minisymbols(b, d, m, s) \
.  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
.  long        (*_read_minisymbols)
.    (bfd *, bfd_boolean, void **, unsigned int *);
.#define bfd_minisymbol_to_symbol(b, d, m, f) \
.  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
.  asymbol *   (*_minisymbol_to_symbol)
.    (bfd *, bfd_boolean, const void *, asymbol *);
.
.  {* Routines for relocs.  *}
.#define BFD_JUMP_TABLE_RELOCS(NAME) \
.  NAME##_get_reloc_upper_bound, \
.  NAME##_canonicalize_reloc, \
.  NAME##_bfd_reloc_type_lookup
.
.  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
.  long        (*_bfd_canonicalize_reloc)
.    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
.  {* See documentation on reloc types.  *}
.  reloc_howto_type *
.              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
.
.  {* Routines used when writing an object file.  *}
.#define BFD_JUMP_TABLE_WRITE(NAME) \
.  NAME##_set_arch_mach, \
.  NAME##_set_section_contents
.
.  bfd_boolean (*_bfd_set_arch_mach)
.    (bfd *, enum bfd_architecture, unsigned long);
.  bfd_boolean (*_bfd_set_section_contents)
.    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
.
.  {* Routines used by the linker.  *}
.#define BFD_JUMP_TABLE_LINK(NAME) \
.  NAME##_sizeof_headers, \
.  NAME##_bfd_get_relocated_section_contents, \
.  NAME##_bfd_relax_section, \
.  NAME##_bfd_link_hash_table_create, \
.  NAME##_bfd_link_hash_table_free, \
.  NAME##_bfd_link_add_symbols, \
.  NAME##_bfd_link_just_syms, \
.  NAME##_bfd_final_link, \
.  NAME##_bfd_link_split_section, \
.  NAME##_bfd_gc_sections, \
.  NAME##_bfd_merge_sections, \
.  NAME##_bfd_discard_group
.
.  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
.  bfd_byte *  (*_bfd_get_relocated_section_contents)
.    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
.     bfd_byte *, bfd_boolean, struct bfd_symbol **);
.
.  bfd_boolean (*_bfd_relax_section)
.    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
.
.  {* Create a hash table for the linker.  Different backends store
.     different information in this table.  *}
.  struct bfd_link_hash_table *
.              (*_bfd_link_hash_table_create) (bfd *);
.
.  {* Release the memory associated with the linker hash table.  *}
.  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
.
.  {* Add symbols from this object file into the hash table.  *}
.  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
.
.  {* Indicate that we are only retrieving symbol values from this section.  *}
.  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
.
.  {* Do a link based on the link_order structures attached to each
.     section of the BFD.  *}
.  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
.
.  {* Should this section be split up into smaller pieces during linking.  *}
.  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
.
.  {* Remove sections that are not referenced from the output.  *}
.  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
.
.  {* Attempt to merge SEC_MERGE sections.  *}
.  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
.
.  {* Discard members of a group.  *}
.  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
.
.  {* Routines to handle dynamic symbols and relocs.  *}
.#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
.  NAME##_get_dynamic_symtab_upper_bound, \
.  NAME##_canonicalize_dynamic_symtab, \
.  NAME##_get_dynamic_reloc_upper_bound, \
.  NAME##_canonicalize_dynamic_reloc
.
.  {* Get the amount of memory required to hold the dynamic symbols.  *}
.  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
.  {* Read in the dynamic symbols.  *}
.  long        (*_bfd_canonicalize_dynamic_symtab)
.    (bfd *, struct bfd_symbol **);
.  {* Get the amount of memory required to hold the dynamic relocs.  *}
.  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
.  {* Read in the dynamic relocs.  *}
.  long        (*_bfd_canonicalize_dynamic_reloc)
.    (bfd *, arelent **, struct bfd_symbol **);
.

A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.

.  {* Opposite endian version of this target.  *}
.  const struct bfd_target * alternative_target;
.

.  {* Data for use by back-end routines, which isn't
.     generic enough to belong in this structure.  *}
.  const void *backend_data;
.
.} bfd_target;
.
*/

/* All known xvecs (even those that don't compile on all systems).
   Alphabetized for easy reference.
   They are listed a second time below, since
   we can't intermix extern's and initializers.  */
extern const bfd_target a29kcoff_big_vec;
extern const bfd_target a_out_adobe_vec;
extern const bfd_target aix5coff64_vec;
extern const bfd_target aout0_big_vec;
extern const bfd_target aout_arm_big_vec;
extern const bfd_target aout_arm_little_vec;
extern const bfd_target aout_mips_big_vec;
extern const bfd_target aout_mips_little_vec;
extern const bfd_target apollocoff_vec;
extern const bfd_target arm_epoc_pe_big_vec;
extern const bfd_target arm_epoc_pe_little_vec;
extern const bfd_target arm_epoc_pei_big_vec;
extern const bfd_target arm_epoc_pei_little_vec;
extern const bfd_target armcoff_big_vec;
extern const bfd_target armcoff_little_vec;
extern const bfd_target armnetbsd_vec;
extern const bfd_target armpe_big_vec;
extern const bfd_target armpe_little_vec;
extern const bfd_target armpei_big_vec;
extern const bfd_target armpei_little_vec;
extern const bfd_target b_out_vec_big_host;
extern const bfd_target b_out_vec_little_host;
extern const bfd_target bfd_efi_app_ia32_vec;
extern const bfd_target bfd_efi_app_x86_64_vec;
extern const bfd_target bfd_efi_app_ia64_vec;
extern const bfd_target bfd_elf32_avr_vec;
extern const bfd_target bfd_elf32_big_generic_vec;
extern const bfd_target bfd_elf32_bigarc_vec;
extern const bfd_target bfd_elf32_bigarm_oabi_vec;
extern const bfd_target bfd_elf32_bigarm_vec;
extern const bfd_target bfd_elf32_bigmips_vec;
extern const bfd_target bfd_elf32_cris_vec;
extern const bfd_target bfd_elf32_d10v_vec;
extern const bfd_target bfd_elf32_d30v_vec;
extern const bfd_target bfd_elf32_dlx_big_vec;
extern const bfd_target bfd_elf32_fr30_vec;
extern const bfd_target bfd_elf32_frv_vec;
extern const bfd_target bfd_elf32_frvfdpic_vec;
extern const bfd_target bfd_elf32_h8300_vec;
extern const bfd_target bfd_elf32_hppa_linux_vec;
extern const bfd_target bfd_elf32_hppa_vec;
extern const bfd_target bfd_elf32_i370_vec;
extern const bfd_target bfd_elf32_i386_freebsd_vec;
extern const bfd_target bfd_elf32_i386_vec;
extern const bfd_target bfd_elf32_i860_little_vec;
extern const bfd_target bfd_elf32_i860_vec;
extern const bfd_target bfd_elf32_i960_vec;
extern const bfd_target bfd_elf32_ia64_big_vec;
extern const bfd_target bfd_elf32_ia64_hpux_big_vec;
extern const bfd_target bfd_elf32_ip2k_vec;
extern const bfd_target bfd_elf32_iq2000_vec;
extern const bfd_target bfd_elf32_little_generic_vec;
extern const bfd_target bfd_elf32_littlearc_vec;
extern const bfd_target bfd_elf32_littlearm_oabi_vec;
extern const bfd_target bfd_elf32_littlearm_vec;
extern const bfd_target bfd_elf32_littlemips_vec;
extern const bfd_target bfd_elf32_m32r_vec;
extern const bfd_target bfd_elf32_m32rle_vec;
extern const bfd_target bfd_elf32_m32rlin_vec;
extern const bfd_target bfd_elf32_m32rlelin_vec;
extern const bfd_target bfd_elf32_m68hc11_vec;
extern const bfd_target bfd_elf32_m68hc12_vec;
extern const bfd_target bfd_elf32_m68k_vec;
extern const bfd_target bfd_elf32_m88k_vec;
extern const bfd_target bfd_elf32_mcore_big_vec;
extern const bfd_target bfd_elf32_mcore_little_vec;
extern const bfd_target bfd_elf32_mn10200_vec;
extern const bfd_target bfd_elf32_mn10300_vec;
extern const bfd_target bfd_elf32_msp430_vec;
extern const bfd_target bfd_elf32_nbigmips_vec;
extern const bfd_target bfd_elf32_nlittlemips_vec;
extern const bfd_target bfd_elf32_ntradbigmips_vec;
extern const bfd_target bfd_elf32_ntradlittlemips_vec;
extern const bfd_target bfd_elf32_openrisc_vec;
extern const bfd_target bfd_elf32_or32_big_vec;
extern const bfd_target bfd_elf32_pj_vec;
extern const bfd_target bfd_elf32_pjl_vec;
extern const bfd_target bfd_elf32_powerpc_vec;
extern const bfd_target bfd_elf32_powerpcle_vec;
extern const bfd_target bfd_elf32_s390_vec;
extern const bfd_target bfd_elf32_sh64_vec;
extern const bfd_target bfd_elf32_sh64l_vec;
extern const bfd_target bfd_elf32_sh64lin_vec;
extern const bfd_target bfd_elf32_sh64blin_vec;
extern const bfd_target bfd_elf32_sh64lnbsd_vec;
extern const bfd_target bfd_elf32_sh64nbsd_vec;
extern const bfd_target bfd_elf32_sh_vec;
extern const bfd_target bfd_elf32_shblin_vec;
extern const bfd_target bfd_elf32_shl_vec;
extern const bfd_target bfd_elf32_shlin_vec;
extern const bfd_target bfd_elf32_shlnbsd_vec;
extern const bfd_target bfd_elf32_shlobsd_vec;
extern const bfd_target bfd_elf32_shnbsd_vec;
extern const bfd_target bfd_elf32_shobsd_vec;
extern const bfd_target bfd_elf32_sparc_vec;
extern const bfd_target bfd_elf32_tradbigmips_vec;
extern const bfd_target bfd_elf32_tradlittlemips_vec;
extern const bfd_target bfd_elf32_us_cris_vec;
extern const bfd_target bfd_elf32_v850_vec;
extern const bfd_target bfd_elf32_vax_vec;
extern const bfd_target bfd_elf32_xstormy16_vec;
extern const bfd_target bfd_elf32_xtensa_be_vec;
extern const bfd_target bfd_elf32_xtensa_le_vec;
extern const bfd_target bfd_elf64_alpha_freebsd_vec;
extern const bfd_target bfd_elf64_alpha_vec;
extern const bfd_target bfd_elf64_big_generic_vec;
extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_hppa_linux_vec;
extern const bfd_target bfd_elf64_hppa_vec;
extern const bfd_target bfd_elf64_ia64_big_vec;
extern const bfd_target bfd_elf64_ia64_hpux_big_vec;
extern const bfd_target bfd_elf64_ia64_little_vec;
extern const bfd_target bfd_elf64_little_generic_vec;
extern const bfd_target bfd_elf64_littlemips_vec;
extern const bfd_target bfd_elf64_mmix_vec;
extern const bfd_target bfd_elf64_powerpc_vec;
extern const bfd_target bfd_elf64_powerpcle_vec;
extern const bfd_target bfd_elf64_s390_vec;
extern const bfd_target bfd_elf64_sh64_vec;
extern const bfd_target bfd_elf64_sh64l_vec;
extern const bfd_target bfd_elf64_sh64lin_vec;
extern const bfd_target bfd_elf64_sh64blin_vec;
extern const bfd_target bfd_elf64_sh64lnbsd_vec;
extern const bfd_target bfd_elf64_sh64nbsd_vec;
extern const bfd_target bfd_elf64_sparc_vec;
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
extern const bfd_target bfd_elf64_x86_64_vec;
extern const bfd_target bfd_mmo_vec;
extern const bfd_target bfd_powerpc_pe_vec;
extern const bfd_target bfd_powerpc_pei_vec;
extern const bfd_target bfd_powerpcle_pe_vec;
extern const bfd_target bfd_powerpcle_pei_vec;
extern const bfd_target cris_aout_vec;
extern const bfd_target demo_64_vec;
extern const bfd_target ecoff_big_vec;
extern const bfd_target ecoff_biglittle_vec;
extern const bfd_target ecoff_little_vec;
extern const bfd_target ecoffalpha_little_vec;
extern const bfd_target go32coff_vec;
extern const bfd_target go32stubbedcoff_vec;
extern const bfd_target h8300coff_vec;
extern const bfd_target h8500coff_vec;
extern const bfd_target host_aout_vec;
extern const bfd_target hp300bsd_vec;
extern const bfd_target hp300hpux_vec;
extern const bfd_target i386aout_vec;
extern const bfd_target i386bsd_vec;
extern const bfd_target i386coff_vec;
extern const bfd_target i386dynix_vec;
extern const bfd_target i386freebsd_vec;
extern const bfd_target i386linux_vec;
extern const bfd_target i386lynx_aout_vec;
extern const bfd_target i386lynx_coff_vec;
extern const bfd_target i386mach3_vec;
extern const bfd_target i386msdos_vec;
extern const bfd_target i386netbsd_vec;
extern const bfd_target i386os9k_vec;
extern const bfd_target i386pe_vec;
extern const bfd_target i386pei_vec;
extern const bfd_target i860coff_vec;
extern const bfd_target icoff_big_vec;
extern const bfd_target icoff_little_vec;
extern const bfd_target ieee_vec;
extern const bfd_target m68k4knetbsd_vec;
extern const bfd_target m68kaux_coff_vec;
extern const bfd_target m68kcoff_vec;
extern const bfd_target m68kcoffun_vec;
extern const bfd_target m68klinux_vec;
extern const bfd_target m68klynx_aout_vec;
extern const bfd_target m68klynx_coff_vec;
extern const bfd_target m68knetbsd_vec;
extern const bfd_target m68ksysvcoff_vec;
extern const bfd_target m88kbcs_vec;
extern const bfd_target m88kmach3_vec;
extern const bfd_target m88kopenbsd_vec;
extern const bfd_target mach_o_be_vec;
extern const bfd_target mach_o_le_vec;
extern const bfd_target mach_o_fat_vec;
extern const bfd_target mcore_pe_big_vec;
extern const bfd_target mcore_pe_little_vec;
extern const bfd_target mcore_pei_big_vec;
extern const bfd_target mcore_pei_little_vec;
extern const bfd_target mipslpe_vec;
extern const bfd_target mipslpei_vec;
extern const bfd_target newsos3_vec;
extern const bfd_target nlm32_alpha_vec;
extern const bfd_target nlm32_i386_vec;
extern const bfd_target nlm32_powerpc_vec;
extern const bfd_target nlm32_sparc_vec;
extern const bfd_target oasys_vec;
extern const bfd_target or32coff_big_vec;
extern const bfd_target pc532machaout_vec;
extern const bfd_target pc532netbsd_vec;
extern const bfd_target pdp11_aout_vec;
extern const bfd_target pef_vec;
extern const bfd_target pef_xlib_vec;
extern const bfd_target pmac_xcoff_vec;
extern const bfd_target ppcboot_vec;
extern const bfd_target riscix_vec;
extern const bfd_target rs6000coff64_vec;
extern const bfd_target rs6000coff_vec;
extern const bfd_target shcoff_small_vec;
extern const bfd_target shcoff_vec;
extern const bfd_target shlcoff_small_vec;
extern const bfd_target shlcoff_vec;
extern const bfd_target shlpe_vec;
extern const bfd_target shlpei_vec;
extern const bfd_target som_vec;
extern const bfd_target sparccoff_vec;
extern const bfd_target sparcle_aout_vec;
extern const bfd_target sparclinux_vec;
extern const bfd_target sparclynx_aout_vec;
extern const bfd_target sparclynx_coff_vec;
extern const bfd_target sparcnetbsd_vec;
extern const bfd_target sunos_big_vec;
extern const bfd_target sym_vec;
extern const bfd_target tic30_aout_vec;
extern const bfd_target tic30_coff_vec;
extern const bfd_target tic4x_coff0_beh_vec;
extern const bfd_target tic4x_coff0_vec;
extern const bfd_target tic4x_coff1_beh_vec;
extern const bfd_target tic4x_coff1_vec;
extern const bfd_target tic4x_coff2_beh_vec;
extern const bfd_target tic4x_coff2_vec;
extern const bfd_target tic54x_coff0_beh_vec;
extern const bfd_target tic54x_coff0_vec;
extern const bfd_target tic54x_coff1_beh_vec;
extern const bfd_target tic54x_coff1_vec;
extern const bfd_target tic54x_coff2_beh_vec;
extern const bfd_target tic54x_coff2_vec;
extern const bfd_target tic80coff_vec;
extern const bfd_target vaxbsd_vec;
extern const bfd_target vaxnetbsd_vec;
extern const bfd_target vax1knetbsd_vec;
extern const bfd_target versados_vec;
extern const bfd_target vms_alpha_vec;
extern const bfd_target vms_vax_vec;
extern const bfd_target w65_vec;
extern const bfd_target we32kcoff_vec;
extern const bfd_target z8kcoff_vec;

/* These are always included.  */
extern const bfd_target srec_vec;
extern const bfd_target symbolsrec_vec;
extern const bfd_target tekhex_vec;
extern const bfd_target binary_vec;
extern const bfd_target ihex_vec;

/* All of the xvecs for core files.  */
extern const bfd_target aix386_core_vec;
extern const bfd_target cisco_core_big_vec;
extern const bfd_target cisco_core_little_vec;
extern const bfd_target hppabsd_core_vec;
extern const bfd_target hpux_core_vec;
extern const bfd_target irix_core_vec;
extern const bfd_target netbsd_core_vec;
extern const bfd_target osf_core_vec;
extern const bfd_target ptrace_core_vec;
extern const bfd_target sco5_core_vec;
extern const bfd_target trad_core_vec;

extern const bfd_target bfd_elf32_am33lin_vec;
static const bfd_target * const _bfd_target_vector[] = {

#ifdef SELECT_VECS

	SELECT_VECS,

#else /* not SELECT_VECS */

#ifdef DEFAULT_VECTOR
	&DEFAULT_VECTOR,
#endif
	/* This list is alphabetized to make it easy to compare
	   with other vector lists -- the decls above and
	   the case statement in configure.in.
	   Vectors that don't compile on all systems, or aren't finished,
	   should have an entry here with #if 0 around it, to show that
	   it wasn't omitted by mistake.  */
	&a29kcoff_big_vec,
	&a_out_adobe_vec,
#ifdef BFD64
	&aix5coff64_vec,
#endif
	&aout0_big_vec,
#if 0
	/* We have no way of distinguishing these from other a.out variants.  */
	&aout_arm_big_vec,
	&aout_arm_little_vec,
	/* No one seems to use this.  */
	&aout_mips_big_vec,
#endif
	&aout_mips_little_vec,
#if 0
	&apollocoff_vec,
#endif
	&arm_epoc_pe_big_vec,
	&arm_epoc_pe_little_vec,
	&arm_epoc_pei_big_vec,
	&arm_epoc_pei_little_vec,
	&armcoff_big_vec,
	&armcoff_little_vec,
	&armnetbsd_vec,
	&armpe_big_vec,
	&armpe_little_vec,
	&armpei_big_vec,
	&armpei_little_vec,
	&b_out_vec_big_host,
	&b_out_vec_little_host,
	&bfd_efi_app_ia32_vec,
	&bfd_efi_app_x86_64_vec,
#ifdef BFD64
	&bfd_efi_app_ia64_vec,
#endif
	&bfd_elf32_avr_vec,

	/* This, and other vectors, may not be used in any *.mt configuration.
	   But that does not mean they are unnecessary.  If configured with
	   --enable-targets=all, objdump or gdb should be able to examine
	   the file even if we don't recognize the machine type.  */
	&bfd_elf32_big_generic_vec,
	&bfd_elf32_bigarc_vec,
	&bfd_elf32_bigarm_oabi_vec,
	&bfd_elf32_bigarm_vec,
	&bfd_elf32_bigmips_vec,
	&bfd_elf32_cris_vec,
	&bfd_elf32_d10v_vec,
	&bfd_elf32_d30v_vec,
	&bfd_elf32_dlx_big_vec,
	&bfd_elf32_fr30_vec,
	&bfd_elf32_frv_vec,
	&bfd_elf32_frvfdpic_vec,
	&bfd_elf32_h8300_vec,
	&bfd_elf32_hppa_linux_vec,
	&bfd_elf32_hppa_vec,
	&bfd_elf32_i370_vec,
	&bfd_elf32_i386_freebsd_vec,
	&bfd_elf32_i386_vec,
	&bfd_elf32_i860_little_vec,
	&bfd_elf32_i860_vec,
	&bfd_elf32_i960_vec,
#if 0
	&bfd_elf32_ia64_big_vec,
#endif
	&bfd_elf32_ia64_hpux_big_vec,
	&bfd_elf32_ip2k_vec,
	&bfd_elf32_iq2000_vec,
	&bfd_elf32_little_generic_vec,
	&bfd_elf32_littlearc_vec,
	&bfd_elf32_littlearm_oabi_vec,
	&bfd_elf32_littlearm_vec,
	&bfd_elf32_littlemips_vec,
	&bfd_elf32_m32r_vec,
        &bfd_elf32_m32rle_vec,
        &bfd_elf32_m32rlin_vec,
        &bfd_elf32_m32rlelin_vec,
	&bfd_elf32_m68hc11_vec,
	&bfd_elf32_m68hc12_vec,
	&bfd_elf32_m68k_vec,
	&bfd_elf32_m88k_vec,
	&bfd_elf32_mcore_big_vec,
	&bfd_elf32_mcore_little_vec,
	&bfd_elf32_mn10200_vec,
	&bfd_elf32_mn10300_vec,
	&bfd_elf32_msp430_vec,
#ifdef BFD64
	&bfd_elf32_nbigmips_vec,
	&bfd_elf32_nlittlemips_vec,
	&bfd_elf32_ntradbigmips_vec,
	&bfd_elf32_ntradlittlemips_vec,
#endif
	&bfd_elf32_openrisc_vec,
	&bfd_elf32_or32_big_vec,
	&bfd_elf32_pj_vec,
	&bfd_elf32_pjl_vec,
	&bfd_elf32_powerpc_vec,
	&bfd_elf32_powerpcle_vec,
	&bfd_elf32_s390_vec,
        &bfd_elf32_sh_vec,
        &bfd_elf32_shblin_vec,
        &bfd_elf32_shl_vec,
        &bfd_elf32_shlin_vec,
	&bfd_elf32_shlnbsd_vec,
	&bfd_elf32_shlobsd_vec,
	&bfd_elf32_shnbsd_vec,
	&bfd_elf32_shobsd_vec,
#ifdef BFD64
	&bfd_elf32_sh64_vec,
	&bfd_elf32_sh64l_vec,
	&bfd_elf32_sh64lnbsd_vec,
	&bfd_elf32_sh64nbsd_vec,
	&bfd_elf32_sh64lin_vec,
	&bfd_elf32_sh64blin_vec,
#endif
	&bfd_elf32_sparc_vec,
	&bfd_elf32_tradbigmips_vec,
	&bfd_elf32_tradlittlemips_vec,
	&bfd_elf32_us_cris_vec,
	&bfd_elf32_v850_vec,
	&bfd_elf32_vax_vec,
	&bfd_elf32_xstormy16_vec,
	&bfd_elf32_xtensa_be_vec,
	&bfd_elf32_xtensa_le_vec,
#ifdef BFD64
	&bfd_elf64_alpha_freebsd_vec,
	&bfd_elf64_alpha_vec,
	&bfd_elf64_big_generic_vec,
	&bfd_elf64_bigmips_vec,
	&bfd_elf64_hppa_linux_vec,
	&bfd_elf64_hppa_vec,
	&bfd_elf64_ia64_big_vec,
	&bfd_elf64_ia64_hpux_big_vec,
	&bfd_elf64_ia64_little_vec,
	&bfd_elf64_little_generic_vec,
	&bfd_elf64_littlemips_vec,
	&bfd_elf64_mmix_vec,
	&bfd_elf64_powerpc_vec,
	&bfd_elf64_powerpcle_vec,
	&bfd_elf64_s390_vec,
	&bfd_elf64_sh64_vec,
	&bfd_elf64_sh64l_vec,
	&bfd_elf64_sh64lnbsd_vec,
	&bfd_elf64_sh64nbsd_vec,
	&bfd_elf64_sh64lin_vec,
	&bfd_elf64_sh64blin_vec,
	&bfd_elf64_sparc_vec,
	&bfd_elf64_tradbigmips_vec,
	&bfd_elf64_tradlittlemips_vec,
	&bfd_elf64_x86_64_vec,
	&bfd_mmo_vec, 
#endif
	&bfd_powerpc_pe_vec,
	&bfd_powerpc_pei_vec,
	&bfd_powerpcle_pe_vec,
	&bfd_powerpcle_pei_vec,
	&cris_aout_vec,
#ifdef BFD64
	&demo_64_vec,	/* Only compiled if host has long-long support.  */
#endif
	&ecoff_big_vec,
	&ecoff_biglittle_vec,
	&ecoff_little_vec,
#ifdef BFD64
	&ecoffalpha_little_vec,
#endif
	&go32coff_vec,
	&go32stubbedcoff_vec,
	&h8300coff_vec,
	&h8500coff_vec,
#if 0
	/* Since a.out files lack decent magic numbers, no way to recognize
	   which kind of a.out file it is.  */
	&host_aout_vec,
	/* Clashes with sunos_big_vec magic no.  */
	&hp300bsd_vec,
#endif
	&hp300hpux_vec,
	&i386aout_vec,
	&i386bsd_vec,
	&i386coff_vec,
#if 0
	&i386dynix_vec,
#endif
	&i386freebsd_vec,
#if 0
	/* Since a.out files lack decent magic numbers, no way to recognize
	   which kind of a.out file it is.  */
	&i386linux_vec,
#endif
	&i386lynx_aout_vec,
	&i386lynx_coff_vec,
#if 0
	/* No distinguishing features for Mach 3 executables.  */
	&i386mach3_vec,
#endif
	&i386msdos_vec,
	&i386netbsd_vec,
	&i386os9k_vec,
	&i386pe_vec,
	&i386pei_vec,
	&i860coff_vec,
	&icoff_big_vec,
	&icoff_little_vec,
	&ieee_vec,
#if 0
	&m68k4knetbsd_vec,
	&m68kaux_coff_vec,
#endif
	&m68kcoff_vec,
	&m68kcoffun_vec,
#if 0
	/* Since a.out files lack decent magic numbers, no way to recognize
	   which kind of a.out file it is.  */
	&m68klinux_vec,
#endif
	&m68klynx_aout_vec,
	&m68klynx_coff_vec,
	&m68knetbsd_vec,
	&m68ksysvcoff_vec,
	&m88kbcs_vec,
	&m88kmach3_vec,
	&m88kopenbsd_vec,
	&mach_o_be_vec,
	&mach_o_le_vec,
	&mach_o_fat_vec,
	&mcore_pe_big_vec,
	&mcore_pe_little_vec,
	&mcore_pei_big_vec,
	&mcore_pei_little_vec,
	&mipslpe_vec,
	&mipslpei_vec,
	&newsos3_vec,
#ifdef BFD64
	&nlm32_alpha_vec,
#endif
	&nlm32_i386_vec,
	&nlm32_powerpc_vec,
	&nlm32_sparc_vec,
#if 0
	/* We have no oasys tools anymore, so we can't test any of this
	   anymore. If you want to test the stuff yourself, go ahead...
	   steve@@cygnus.com
	   Worse, since there is no magic number for archives, there
	   can be annoying target mis-matches.  */
	&oasys_vec,
#endif
	/* Entry for the OpenRISC family.  */
	&or32coff_big_vec,

	&pc532machaout_vec,
	&pc532netbsd_vec,
	&pdp11_aout_vec,
	&pef_vec,
	&pef_xlib_vec,
#if 0
	/* This has the same magic number as RS/6000.  */
	&pmac_xcoff_vec,
#endif
	&ppcboot_vec,
#if 0
	/* We have no way of distinguishing these from other a.out variants.  */
	&riscix_vec,
#endif
#ifdef BFD64
	&rs6000coff64_vec,
#endif
	&rs6000coff_vec,
	&shcoff_small_vec,
	&shcoff_vec,
	&shlcoff_small_vec,
	&shlcoff_vec,
	&shlpe_vec,
	&shlpei_vec,
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF)
	&som_vec,
#endif
	&sparccoff_vec,
	&sparcle_aout_vec,
	&sparclinux_vec,
	&sparclynx_aout_vec,
	&sparclynx_coff_vec,
	&sparcnetbsd_vec,
	&sunos_big_vec,
	&sym_vec,
	&tic30_aout_vec,
	&tic30_coff_vec,
	&tic54x_coff0_beh_vec,
	&tic54x_coff0_vec,
	&tic54x_coff1_beh_vec,
	&tic54x_coff1_vec,
	&tic54x_coff2_beh_vec,
	&tic54x_coff2_vec,
	&tic80coff_vec,
	&vaxbsd_vec,
	&vaxnetbsd_vec,
	&vax1knetbsd_vec,
	&versados_vec,
#ifdef BFD64
	&vms_alpha_vec,
#endif
	&vms_vax_vec,
	&w65_vec,
	&we32kcoff_vec,
	&z8kcoff_vec,
	&bfd_elf32_am33lin_vec,
#endif /* not SELECT_VECS */

/* Always support S-records, for convenience.  */
	&srec_vec,
	&symbolsrec_vec,
/* And tekhex */
	&tekhex_vec,
/* Likewise for binary output.  */
	&binary_vec,
/* Likewise for ihex.  */
	&ihex_vec,

/* Add any required traditional-core-file-handler.  */

#ifdef AIX386_CORE
	&aix386_core_vec,
#endif
#if 0
	/* We don't include cisco_core_*_vec.  Although it has a magic number,
	   the magic number isn't at the beginning of the file, and thus
	   might spuriously match other kinds of files.  */
	&cisco_core_big_vec,
	&cisco_core_little_vec,
#endif
#ifdef HPPABSD_CORE
	&hppabsd_core_vec,
#endif
#ifdef HPUX_CORE
	&hpux_core_vec,
#endif
#ifdef IRIX_CORE
	&irix_core_vec,
#endif
#ifdef NETBSD_CORE
	&netbsd_core_vec,
#endif
#ifdef OSF_CORE
	&osf_core_vec,
#endif
#ifdef PTRACE_CORE
	&ptrace_core_vec,
#endif
#ifdef SCO5_CORE
	&sco5_core_vec,
#endif
#ifdef TRAD_CORE
	&trad_core_vec,
#endif

	NULL /* end of list marker */
};
const bfd_target * const *bfd_target_vector = _bfd_target_vector;

/* bfd_default_vector[0] contains either the address of the default vector,
   if there is one, or zero if there isn't.  */

const bfd_target *bfd_default_vector[] = {
#ifdef DEFAULT_VECTOR
	&DEFAULT_VECTOR,
#endif
	NULL
};

/* bfd_associated_vector[] contains the associated target vectors used
   to reduce the ambiguity in bfd_check_format_matches.  */

static const bfd_target *_bfd_associated_vector[] = {
#ifdef ASSOCIATED_VECS
	ASSOCIATED_VECS,
#endif
	NULL
};
const bfd_target * const *bfd_associated_vector = _bfd_associated_vector;

/* When there is an ambiguous match, bfd_check_format_matches puts the
   names of the matching targets in an array.  This variable is the maximum
   number of entries that the array could possibly need.  */
const size_t _bfd_target_vector_entries = sizeof (_bfd_target_vector)/sizeof (*_bfd_target_vector);

/* This array maps configuration triplets onto BFD vectors.  */

struct targmatch
{
  /* The configuration triplet.  */
  const char *triplet;
  /* The BFD vector.  If this is NULL, then the vector is found by
     searching forward for the next structure with a non NULL vector
     field.  */
  const bfd_target *vector;
};

/* targmatch.h is built by Makefile out of config.bfd.  */
static const struct targmatch bfd_target_match[] = {
#include "targmatch.h"
  { NULL, NULL }
};

/* Find a target vector, given a name or configuration triplet.  */

static const bfd_target *
find_target (const char *name)
{
  const bfd_target * const *target;
  const struct targmatch *match;

  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    if (strcmp (name, (*target)->name) == 0)
      return *target;

  /* If we couldn't match on the exact name, try matching on the
     configuration triplet.  FIXME: We should run the triplet through
     config.sub first, but that is hard.  */
  for (match = &bfd_target_match[0]; match->triplet != NULL; match++)
    {
      if (fnmatch (match->triplet, name, 0) == 0)
	{
	  while (match->vector == NULL)
	    ++match;
	  return match->vector;
	  break;
	}
    }

  bfd_set_error (bfd_error_invalid_target);
  return NULL;
}

/*
FUNCTION
	bfd_set_default_target

SYNOPSIS
	bfd_boolean bfd_set_default_target (const char *name);

DESCRIPTION
	Set the default target vector to use when recognizing a BFD.
	This takes the name of the target, which may be a BFD target
	name or a configuration triplet.
*/

bfd_boolean
bfd_set_default_target (const char *name)
{
  const bfd_target *target;

  if (bfd_default_vector[0] != NULL
      && strcmp (name, bfd_default_vector[0]->name) == 0)
    return TRUE;

  target = find_target (name);
  if (target == NULL)
    return FALSE;

  bfd_default_vector[0] = target;
  return TRUE;
}

/*
FUNCTION
	bfd_find_target

SYNOPSIS
	const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

DESCRIPTION
	Return a pointer to the transfer vector for the object target
	named @@var{target_name}.  If @@var{target_name} is <<NULL>>, choose the
	one in the environment variable <<GNUTARGET>>; if that is null or not
	defined, then choose the first entry in the target list.
	Passing in the string "default" or setting the environment
	variable to "default" will cause the first entry in the target
	list to be returned, and "target_defaulted" will be set in the
	BFD.  This causes <<bfd_check_format>> to loop over all the
	targets to find the one that matches the file being read.
*/

const bfd_target *
bfd_find_target (const char *target_name, bfd *abfd)
{
  const char *targname;
  const bfd_target *target;

  if (target_name != NULL)
    targname = target_name;
  else
    targname = getenv ("GNUTARGET");

  /* This is safe; the vector cannot be null.  */
  if (targname == NULL || strcmp (targname, "default") == 0)
    {
      abfd->target_defaulted = TRUE;
      if (bfd_default_vector[0] != NULL)
	abfd->xvec = bfd_default_vector[0];
      else
	abfd->xvec = bfd_target_vector[0];
      return abfd->xvec;
    }

  abfd->target_defaulted = FALSE;

  target = find_target (targname);
  if (target == NULL)
    return NULL;

  abfd->xvec = target;
  return target;
}

/*
FUNCTION
	bfd_target_list

SYNOPSIS
	const char ** bfd_target_list (void);

DESCRIPTION
	Return a freshly malloced NULL-terminated
	vector of the names of all the valid BFD targets. Do not
	modify the names.

*/

const char **
bfd_target_list (void)
{
  int vec_length = 0;
  bfd_size_type amt;
#if defined (HOST_HPPAHPUX) && ! defined (__STDC__)
  /* The native compiler on the HP9000/700 has a bug which causes it
     to loop endlessly when compiling this file.  This avoids it.  */
  volatile
#endif
  const bfd_target * const *target;
  const  char **name_list, **name_ptr;

  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    vec_length++;

  amt = (vec_length + 1) * sizeof (char **);
  name_ptr = name_list = bfd_malloc (amt);

  if (name_list == NULL)
    return NULL;

  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    if (target == &bfd_target_vector[0]
	|| *target != bfd_target_vector[0])
      *name_ptr++ = (*target)->name;

  *name_ptr = NULL;
  return name_list;
}

/*
FUNCTION
	bfd_seach_for_target

SYNOPSIS
	const bfd_target *bfd_search_for_target
	  (int (*search_func) (const bfd_target *, void *),
	   void *);

DESCRIPTION
	Return a pointer to the first transfer vector in the list of
	transfer vectors maintained by BFD that produces a non-zero
	result when passed to the function @@var{search_func}.  The
	parameter @@var{data} is passed, unexamined, to the search
	function.
*/

const bfd_target *
bfd_search_for_target (int (*search_func) (const bfd_target *, void *),
		       void *data)
{
  const bfd_target * const *target;

  for (target = bfd_target_vector; *target != NULL; target ++)
    if (search_func (*target, data))
      return *target;

  return NULL;
}
@


1.13
log
@Define superH obsd-specific emulations for ld, and use it by default.
@
text
@d513 1
d801 1
@


1.12
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d580 1
d582 1
d872 1
d874 1
@


1.11
log
@bfd support for OpenBSD/m88k a.out binaries, glueing existing bits together.
Gives us working objcopy, objdump, etc, and the ability to process core files
to some extent.

ok and pushed upstream kettenis@@
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d33 1
a33 1
	Each port of BFD to a different machine requries the creation
d106 1
a106 1
.               ((*((bfd)->xvec->message)) arglist)
d119 1
a119 1
.            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d206 9
a214 9
.  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
.  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
.  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
.  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
d217 9
a225 9
.  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
.  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
.  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
.  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
.  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
d231 1
a231 1
.  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));
d234 1
a234 1
.  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
d237 1
a237 1
.  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
a242 3
Do not "beautify" the CONCAT* macro args.  Traditional C will not
remove whitespace added here, and thus will fail to concatenate
the tokens.
d244 5
a248 5
.CONCAT2 (NAME,_close_and_cleanup), \
.CONCAT2 (NAME,_bfd_free_cached_info), \
.CONCAT2 (NAME,_new_section_hook), \
.CONCAT2 (NAME,_get_section_contents), \
.CONCAT2 (NAME,_get_section_contents_in_window)
d251 1
a251 1
.  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d253 1
a253 1
.  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d255 1
a255 1
.  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d258 1
a258 1
.    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d260 1
a260 1
.    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d264 7
a270 6
.CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
.CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
.CONCAT2 (NAME,_bfd_copy_private_section_data), \
.CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
.CONCAT2 (NAME,_bfd_set_private_flags), \
.CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d273 1
a273 1
.  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d276 1
a276 1
.  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d280 1
a280 1
.    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d284 1
a284 1
.    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
d286 1
a286 1
.  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d289 1
a289 1
.  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d293 7
a299 6
.CONCAT2 (NAME,_core_file_failing_command), \
.CONCAT2 (NAME,_core_file_failing_signal), \
.CONCAT2 (NAME,_core_file_matches_executable_p)
.  char *      (*_core_file_failing_command) PARAMS ((bfd *));
.  int         (*_core_file_failing_signal) PARAMS ((bfd *));
.  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d303 13
a315 12
.CONCAT2 (NAME,_slurp_armap), \
.CONCAT2 (NAME,_slurp_extended_name_table), \
.CONCAT2 (NAME,_construct_extended_name_table), \
.CONCAT2 (NAME,_truncate_arname), \
.CONCAT2 (NAME,_write_armap), \
.CONCAT2 (NAME,_read_ar_hdr), \
.CONCAT2 (NAME,_openr_next_archived_file), \
.CONCAT2 (NAME,_get_elt_at_index), \
.CONCAT2 (NAME,_generic_stat_arch_elt), \
.CONCAT2 (NAME,_update_armap_timestamp)
.  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
.  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
d317 2
a318 2
.    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
.  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
d320 7
a326 7
.    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
.  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
.  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
.#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
.  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
.  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
.  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d330 17
a346 16
.CONCAT2 (NAME,_get_symtab_upper_bound), \
.CONCAT2 (NAME,_get_symtab), \
.CONCAT2 (NAME,_make_empty_symbol), \
.CONCAT2 (NAME,_print_symbol), \
.CONCAT2 (NAME,_get_symbol_info), \
.CONCAT2 (NAME,_bfd_is_local_label_name), \
.CONCAT2 (NAME,_get_lineno), \
.CONCAT2 (NAME,_find_nearest_line), \
.CONCAT2 (NAME,_bfd_make_debug_symbol), \
.CONCAT2 (NAME,_read_minisymbols), \
.CONCAT2 (NAME,_minisymbol_to_symbol)
.  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
.  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
.                                                struct symbol_cache_entry **));
.  struct symbol_cache_entry *
.              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
d348 2
a349 2
.    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
.#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
d351 3
a353 3
.    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
.#define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
.  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d355 1
a355 1
.  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
d357 2
a358 2
.    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
.             const char **, const char **, unsigned int *));
d363 1
a363 1
.    PARAMS ((bfd *, void *, unsigned long size));
d367 1
a367 1
.    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d371 1
a371 1
.    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d375 5
a379 4
.CONCAT2 (NAME,_get_reloc_upper_bound), \
.CONCAT2 (NAME,_canonicalize_reloc), \
.CONCAT2 (NAME,_bfd_reloc_type_lookup)
.  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
d381 1
a381 1
.    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d384 1
a384 1
.              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d388 3
a390 2
.CONCAT2 (NAME,_set_arch_mach), \
.CONCAT2 (NAME,_set_section_contents)
d392 1
a392 1
.    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d394 1
a394 1
.    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d398 14
a411 13
.CONCAT2 (NAME,_sizeof_headers), \
.CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
.CONCAT2 (NAME,_bfd_relax_section), \
.CONCAT2 (NAME,_bfd_link_hash_table_create), \
.CONCAT2 (NAME,_bfd_link_hash_table_free), \
.CONCAT2 (NAME,_bfd_link_add_symbols), \
.CONCAT2 (NAME,_bfd_link_just_syms), \
.CONCAT2 (NAME,_bfd_final_link), \
.CONCAT2 (NAME,_bfd_link_split_section), \
.CONCAT2 (NAME,_bfd_gc_sections), \
.CONCAT2 (NAME,_bfd_merge_sections), \
.CONCAT2 (NAME,_bfd_discard_group)
.  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
d413 2
a414 2
.    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
.             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d417 1
a417 1
.    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d422 1
a422 1
.              (*_bfd_link_hash_table_create) PARAMS ((bfd *));
d425 1
a425 2
.  void        (*_bfd_link_hash_table_free)
.    PARAMS ((struct bfd_link_hash_table *));
d428 1
a428 2
.  bfd_boolean (*_bfd_link_add_symbols)
.    PARAMS ((bfd *, struct bfd_link_info *));
d431 1
a431 2
.  void        (*_bfd_link_just_syms)
.    PARAMS ((asection *, struct bfd_link_info *));
d435 1
a435 1
.  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d438 1
a438 1
.  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d441 1
a441 1
.  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
d444 1
a444 1
.  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));
d447 1
a447 1
.  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d451 5
a455 4
.CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
.CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
.CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
.CONCAT2 (NAME,_canonicalize_dynamic_reloc)
d457 1
a457 1
.  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d460 1
a460 1
.    PARAMS ((bfd *, struct symbol_cache_entry **));
d462 1
a462 1
.  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d465 1
a465 1
.    PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));
d480 1
a480 1
.  PTR backend_data;
d526 1
d546 3
a595 2
extern const bfd_target bfd_elf64_ia64_aix_big_vec;
extern const bfd_target bfd_elf64_ia64_aix_little_vec;
d749 1
d818 1
d840 3
a894 2
	&bfd_elf64_ia64_aix_big_vec,
	&bfd_elf64_ia64_aix_little_vec,
a909 1
#if 0
a910 1
#endif
d1069 1
a1166 2
static const bfd_target *find_target PARAMS ((const char *));

d1170 1
a1170 2
find_target (name)
     const char *name;
d1211 1
a1211 2
bfd_set_default_target (name)
     const char *name;
d1247 1
a1247 3
bfd_find_target (target_name, abfd)
     const char *target_name;
     bfd *abfd;
d1293 1
a1293 1
bfd_target_list ()
d1295 1
a1295 1
  int vec_length= 0;
d1309 1
a1309 1
  name_ptr = name_list = (const char **) bfd_malloc (amt);
d1328 3
a1330 3
	const bfd_target * bfd_search_for_target (int (* search_func)
						  (const bfd_target *, void *),
						  void *);
d1341 2
a1342 3
bfd_search_for_target (search_func, data)
     int (* search_func) PARAMS ((const bfd_target * target, void * data));
     void * data;
d1344 1
a1344 1
  const bfd_target * const * target;
d1346 3
a1348 3
  for (target = bfd_target_vector; * target != NULL; target ++)
    if (search_func (* target, data))
      return * target;
@


1.10
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d658 1
d981 1
@


1.9
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d73 1
a73 1
	<<bfd_check_format>> returns <<true>> when the caller guesses right.
d128 1
a128 1

d138 2
a139 1
.enum bfd_flavour {
d157 6
a162 1
.  bfd_target_evax_flavour
d172 1
a172 3

Identifies the kind of target, e.g., SunOS4, Ultrix, etc.

d174 3
a176 4

The "flavour" of a back end is a general indication about the contents
of a file.

d178 2
a179 3

The order of bytes within the data area of a file.

d181 2
a182 3

The order of bytes within the header parts of a file.

d184 3
a186 4

A mask of all the flags which an executable may have set -
from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.

d188 3
a190 4

A mask of all the flags which a section may have set - from
the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.

d192 3
a194 4

The character normally found at the front of a symbol
(if any), perhaps `_'.

d196 2
a197 3

The pad character for file names within an archive header.

d199 2
a200 3

The maximum number of characters in an archive header.

d202 5
a206 6

Entries for byte swapping for data. These are different from the other
entry points, since they don't take a BFD asthe first argument.
Certain other handlers could do the same.

.  bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
d208 2
a209 2
.  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
d211 2
a212 2
.  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
d214 4
a217 5
.  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));

Byte swapping for the headers

.  bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d219 2
a220 2
.  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d222 2
a223 2
.  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d225 6
a230 7
.  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));

Format dependent routines: these are vectors of entry points
within the target vector structure, one for each format to check.

Check the format of a file being read.  Return a <<bfd_target *>> or zero.

d232 7
a238 9

Set the format of a file being written.

.  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));

Write cached information into a file being written, at <<bfd_close>>.

.  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));

a240 1

d243 9
a251 6
.#define BFD_JUMP_TABLE_GENERIC(NAME)\
.CAT(NAME,_close_and_cleanup),\
.CAT(NAME,_bfd_free_cached_info),\
.CAT(NAME,_new_section_hook),\
.CAT(NAME,_get_section_contents),\
.CAT(NAME,_get_section_contents_in_window)
d254 1
a254 1
.  boolean       (*_close_and_cleanup) PARAMS ((bfd *));
d256 1
a256 1
.  boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d258 1
a258 1
.  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d260 4
a263 5
.  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
.                                            file_ptr, bfd_size_type));
.  boolean       (*_bfd_get_section_contents_in_window)
.                          PARAMS ((bfd *, sec_ptr, bfd_window *,
.                                   file_ptr, bfd_size_type));
d266 7
a272 7
.#define BFD_JUMP_TABLE_COPY(NAME)\
.CAT(NAME,_bfd_copy_private_bfd_data),\
.CAT(NAME,_bfd_merge_private_bfd_data),\
.CAT(NAME,_bfd_copy_private_section_data),\
.CAT(NAME,_bfd_copy_private_symbol_data),\
.CAT(NAME,_bfd_set_private_flags),\
.CAT(NAME,_bfd_print_private_bfd_data)\
d275 1
a275 1
.  boolean	 (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d278 1
a278 1
.  boolean	 (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d281 2
a282 2
.  boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
.                                                       bfd *, sec_ptr));
d285 4
a288 4
.  boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
.							   bfd *, asymbol *));
.  {* Called to set private backend flags *}
.  boolean	 (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d290 2
a291 2
.  {* Called to print private BFD data *}
.  boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d294 7
a300 7
.#define BFD_JUMP_TABLE_CORE(NAME)\
.CAT(NAME,_core_file_failing_command),\
.CAT(NAME,_core_file_failing_signal),\
.CAT(NAME,_core_file_matches_executable_p)
.  char *   (*_core_file_failing_command) PARAMS ((bfd *));
.  int      (*_core_file_failing_signal) PARAMS ((bfd *));
.  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d303 20
a322 23
.#define BFD_JUMP_TABLE_ARCHIVE(NAME)\
.CAT(NAME,_slurp_armap),\
.CAT(NAME,_slurp_extended_name_table),\
.CAT(NAME,_construct_extended_name_table),\
.CAT(NAME,_truncate_arname),\
.CAT(NAME,_write_armap),\
.CAT(NAME,_read_ar_hdr),\
.CAT(NAME,_openr_next_archived_file),\
.CAT(NAME,_get_elt_at_index),\
.CAT(NAME,_generic_stat_arch_elt),\
.CAT(NAME,_update_armap_timestamp)
.  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
.  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
.  boolean  (*_bfd_construct_extended_name_table)
.             PARAMS ((bfd *, char **, bfd_size_type *, const char **));
.  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
.  boolean  (*write_armap) PARAMS ((bfd *arch,
.                              unsigned int elength,
.                              struct orl *map,
.                              unsigned int orl_count,
.                              int stridx));
.  PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
.  bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
d324 3
a326 3
.  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
.  int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
.  boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d329 19
a347 20
.#define BFD_JUMP_TABLE_SYMBOLS(NAME)\
.CAT(NAME,_get_symtab_upper_bound),\
.CAT(NAME,_get_symtab),\
.CAT(NAME,_make_empty_symbol),\
.CAT(NAME,_print_symbol),\
.CAT(NAME,_get_symbol_info),\
.CAT(NAME,_bfd_is_local_label_name),\
.CAT(NAME,_get_lineno),\
.CAT(NAME,_find_nearest_line),\
.CAT(NAME,_bfd_make_debug_symbol),\
.CAT(NAME,_read_minisymbols),\
.CAT(NAME,_minisymbol_to_symbol)
.  long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
.  long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
.                                             struct symbol_cache_entry **));
.  struct symbol_cache_entry  *
.                (*_bfd_make_empty_symbol) PARAMS ((bfd *));
.  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
.                                      struct symbol_cache_entry *,
.                                      bfd_print_symbol_type));
d349 2
a350 3
.  void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
.                                      struct symbol_cache_entry *,
.                                      symbol_info *));
d352 1
a352 1
.  boolean	 (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d354 4
a357 5
.  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
.  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
.                    struct sec *section, struct symbol_cache_entry **symbols,
.                    bfd_vma offset, CONST char **file, CONST char **func,
.                    unsigned int *line));
d361 2
a362 4
.  asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
.       bfd *abfd,
.       void *ptr,
.       unsigned long size));
d365 2
a366 2
.  long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
.                                      unsigned int *));
d369 2
a370 2
.  asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
.                                             asymbol *));
d373 7
a379 7
.#define BFD_JUMP_TABLE_RELOCS(NAME)\
.CAT(NAME,_get_reloc_upper_bound),\
.CAT(NAME,_canonicalize_reloc),\
.CAT(NAME,_bfd_reloc_type_lookup)
.  long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
.  long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
.                                            struct symbol_cache_entry **));
d382 1
a382 2
.       (*reloc_type_lookup) PARAMS ((bfd *abfd,
.                                     bfd_reloc_code_real_type code));
d385 7
a391 7
.#define BFD_JUMP_TABLE_WRITE(NAME)\
.CAT(NAME,_set_arch_mach),\
.CAT(NAME,_set_section_contents)
.  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
.                    unsigned long));
.  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
.                                            file_ptr, bfd_size_type));
d394 17
a410 14
.#define BFD_JUMP_TABLE_LINK(NAME)\
.CAT(NAME,_sizeof_headers),\
.CAT(NAME,_bfd_get_relocated_section_contents),\
.CAT(NAME,_bfd_relax_section),\
.CAT(NAME,_bfd_link_hash_table_create),\
.CAT(NAME,_bfd_link_add_symbols),\
.CAT(NAME,_bfd_final_link),\
.CAT(NAME,_bfd_link_split_section),\
.CAT(NAME,_bfd_gc_sections)
.  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
.  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
.                    struct bfd_link_info *, struct bfd_link_order *,
.                    bfd_byte *data, boolean relocateable,
.                    struct symbol_cache_entry **));
d412 2
a413 2
.  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
.                    struct bfd_link_info *, boolean *again));
d417 6
a422 1
.  struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
d425 6
a430 1
.  boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
d434 1
a434 1
.  boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d437 1
a437 1
.  boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d440 7
a446 1
.  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
d449 7
a455 7
.#define BFD_JUMP_TABLE_DYNAMIC(NAME)\
.CAT(NAME,_get_dynamic_symtab_upper_bound),\
.CAT(NAME,_canonicalize_dynamic_symtab),\
.CAT(NAME,_get_dynamic_reloc_upper_bound),\
.CAT(NAME,_canonicalize_dynamic_reloc)
.  {* Get the amount of memory required to hold the dynamic symbols. *}
.  long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d457 1
a457 1
.  long  (*_bfd_canonicalize_dynamic_symtab)
d460 1
a460 1
.  long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d462 1
a462 1
.  long  (*_bfd_canonicalize_dynamic_reloc)
d472 2
a473 2
. {* Opposite endian version of this target.  *}
. const struct bfd_target * alternative_target;
d476 3
a478 4
Data for use by back-end routines, which isn't generic enough to belong
in this structure.

. PTR backend_data;
d481 1
a481 1

d490 1
d521 1
d523 2
d528 1
d534 3
d551 7
d562 7
d573 2
d580 5
d590 2
d593 1
d597 11
a609 1
extern const bfd_target bfd_elf64_sparc_vec;
d611 1
d658 3
d673 1
d676 3
d698 1
a698 1
extern const bfd_target tekhex_vec;
d701 6
d714 1
d716 1
d724 1
a724 1
/* srec is always included.  */
d727 1
a727 2

/* binary is always included.  */
a728 2

/* ihex is always included.  */
d735 1
a736 1
extern const bfd_target hppabsd_core_vec;
d740 1
a742 1
extern const bfd_target ptrace_core_vec;
d763 9
a771 1
#if 0				/* No one seems to use this.  */
d775 14
a790 1

d795 1
a801 8
#ifdef BFD64
	&bfd_elf64_alpha_vec,
	&bfd_elf64_hppa_vec,
	&bfd_elf64_hppa_linux_vec,
	&bfd_elf64_ia64_little_vec,
	&bfd_elf64_ia64_big_vec,
#endif
	&bfd_elf32_avr_vec,
d803 2
a804 2
        &bfd_elf32_bigarm_vec,
        &bfd_elf32_bigarm_oabi_vec,
a805 3
#ifdef BFD64
	&bfd_elf64_bigmips_vec,
#endif
a806 1
	&bfd_elf32_us_cris_vec,
d809 5
a814 1
	&bfd_elf32_hppa_linux_vec,
d816 1
d818 1
a818 3
#ifdef BFD64
        &bfd_elf64_x86_64_vec,
#endif
a819 1
	&bfd_elf32_i860_little_vec,
d821 6
d829 2
a830 2
        &bfd_elf32_littlearm_vec,
        &bfd_elf32_littlearm_oabi_vec,
a831 3
#ifdef BFD64
	&bfd_elf64_littlemips_vec,
#endif
a832 2
	&bfd_elf32_mn10200_vec,
	&bfd_elf32_mn10300_vec,
d837 13
d854 15
a869 4
	&bfd_elf32_v850_vec,
	&bfd_elf32_fr30_vec,
	&bfd_elf32_mcore_big_vec,
	&bfd_elf32_mcore_little_vec,
d872 6
d879 2
a880 3
	&bfd_elf64_tradbigmips_vec,
	&bfd_elf64_tradlittlemips_vec,
	/* No one seems to use this.  */
d882 8
d891 11
a901 1
#endif
d905 10
a914 5
	/* We don't include cisco_core_*_vec.  Although it has a magic number,
	   the magic number isn't at the beginning of the file, and thus
	   might spuriously match other kinds of files.  */

        &cris_aout_vec,
d916 1
a916 1
	&demo_64_vec,	/* Only compiled if host has long-long support */
d919 1
a920 1
	&ecoff_biglittle_vec,
d924 2
d932 1
a932 2
#endif
#if 0				/* Clashes with sunos_big_vec magic no.  */
a935 3
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF)
        &som_vec,
#endif
d939 3
a942 7
	&i860coff_vec,
	&bfd_powerpc_pe_vec,
	&bfd_powerpcle_pe_vec,
	&bfd_powerpc_pei_vec,
	&bfd_powerpcle_pei_vec,
	&go32coff_vec,
	&go32stubbedcoff_vec,
d959 1
a959 11
	&armcoff_little_vec,
	&armcoff_big_vec,
	&armnetbsd_vec,
	&armpe_little_vec,
	&armpe_big_vec,
	&armpei_little_vec,
	&armpei_big_vec,
	&arm_epoc_pe_little_vec,
	&arm_epoc_pe_big_vec,
	&arm_epoc_pei_little_vec,
	&arm_epoc_pei_big_vec,
d963 4
d980 3
d987 2
a989 2
	&nlm32_i386_vec,
	&nlm32_sparc_vec,
d993 3
a995 1
	&pc532netbsd_vec,
d1004 3
d1008 4
d1013 2
a1014 4
	/* We have no way of distinguishing these from other a.out variants */
	&aout_arm_big_vec,
	&aout_arm_little_vec,
	&riscix_vec,
d1016 1
d1018 2
a1019 2
	/* This has the same magic number as RS/6000.  */
	&pmac_xcoff_vec,
a1020 1
	&rs6000coff_vec,
d1024 2
a1025 1
	&ppcboot_vec,
d1027 1
d1029 6
a1034 2
	&shcoff_small_vec,
	&shlcoff_small_vec,
d1041 1
a1041 1
	&aout0_big_vec,
d1044 1
d1046 1
a1046 1
	&tic54x_coff0_beh_vec,
d1048 1
a1048 1
	&tic54x_coff1_beh_vec,
a1049 1
	&tic54x_coff2_beh_vec,
d1051 1
d1053 1
d1059 1
a1061 1

d1079 6
a1084 2
#ifdef HPUX_CORE
	&hpux_core_vec,
d1089 3
d1101 3
d1107 1
a1107 1
#ifdef	TRAD_CORE
a1110 4
#ifdef	PTRACE_CORE
	&ptrace_core_vec,
#endif

d1125 11
d1197 1
a1197 1
	boolean bfd_set_default_target (const char *name);
d1205 1
a1205 1
boolean
d1213 1
a1213 1
    return true;
d1217 1
a1217 1
    return false;
d1220 1
a1220 1
  return true;
d1228 1
a1228 1
	const bfd_target *bfd_find_target(CONST char *target_name, bfd *abfd);
d1255 1
a1255 1
  /* This is safe; the vector cannot be null */
d1258 1
a1258 1
      abfd->target_defaulted = true;
d1266 1
a1266 1
  abfd->target_defaulted = false;
d1281 1
a1281 1
	const char **bfd_target_list(void);
d1294 1
d1300 2
a1301 2
    const bfd_target * const *target;
  CONST  char **name_list, **name_ptr;
d1306 2
a1307 2
  name_ptr = name_list = (CONST char **)
    bfd_zmalloc ((vec_length + 1) * sizeof (char **));
d1313 3
a1315 1
    *(name_ptr++) = (*target)->name;
d1317 1
d1326 3
a1328 1
	const bfd_target * bfd_search_for_target (int (* search_func) (const bfd_target *, void *), void *);
@


1.8
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d29 1
a29 1
SECTION 
d38 1
a38 1
	calls to the back end routines. 
d46 1
a46 1
	target string supplied to <<bfd_openr>> and the new BFD pointer. 
d50 1
a50 1
	that as the target string. 
d60 1
a60 1
	use it. 
d70 1
a70 1
	<<bfd_check_format>> on the BFD with a suggested format. 
a78 1

d90 1
a90 1
	routines to call to do various operations.   
d93 1
a93 1
	member. 
d100 1
a100 1
	to the called function. 
d119 1
a119 1
.            (((bfd)->xvec->message[(int)((bfd)->format)]) arglist)
d125 1
a125 1
.   (((bfd)->xvec->message[(int)((bfd)->format)]) arglist) : \
a133 1

d136 1
a136 1
	macro to define them both! 
d143 1
d187 1
a187 1
.  flagword object_flags;       
d194 1
a194 1
The character normally found at the front of a symbol 
d201 1
a201 1
.  char ar_pad_char;            
d236 1
a236 1
Check the format of a file being read.  Return a <<bfd_target *>> or zero. 
d240 1
a240 1
Set the format of a file being written.  
d244 1
a244 1
Write cached information into a file being written, at <<bfd_close>>. 
d267 1
a267 1
.  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR, 
d291 1
a291 1
.  {* Called to copy BFD private symbol data from one symbol 
d327 1
a327 1
.  boolean  (*write_armap) PARAMS ((bfd *arch, 
d330 1
a330 1
.                              unsigned int orl_count, 
d470 1
a470 1
. {* Opposite endian version of this target.  *}  
d472 1
a472 1
. 
d478 1
a478 1
. 
d489 1
a493 1
extern const bfd_target aout0_big_vec;
d495 5
a500 1
extern const bfd_target armcoff_big_vec;
d502 1
d504 1
a504 1
extern const bfd_target armpe_big_vec;
a505 5
extern const bfd_target armpei_big_vec;
extern const bfd_target arm_epoc_pe_little_vec;
extern const bfd_target arm_epoc_pe_big_vec;
extern const bfd_target arm_epoc_pei_little_vec;
extern const bfd_target arm_epoc_pei_big_vec;
d508 2
a509 1
extern const bfd_target bfd_elf64_alpha_vec;
d511 1
d513 1
a514 5
extern const bfd_target bfd_elf32_bigarm_oabi_vec;
extern const bfd_target bfd_elf32_littlearc_vec;
extern const bfd_target bfd_elf32_littlearm_vec;
extern const bfd_target bfd_elf32_littlearm_oabi_vec;
extern const bfd_target bfd_elf32_big_generic_vec;
d516 1
a516 1
extern const bfd_target bfd_elf64_bigmips_vec;
d519 2
d524 1
d527 1
d529 3
a532 1
extern const bfd_target bfd_elf64_littlemips_vec;
d534 2
d538 2
d547 1
d549 1
d551 3
d555 1
a555 3
extern const bfd_target bfd_elf32_fr30_vec;
extern const bfd_target bfd_elf32_mcore_big_vec;
extern const bfd_target bfd_elf32_mcore_little_vec;
d557 5
d563 3
d567 6
d575 1
a576 1
extern const bfd_target ecoff_biglittle_vec;
d578 2
a584 1
extern const bfd_target som_vec;
d587 1
a589 10
extern const bfd_target i386os9k_vec;
extern const bfd_target i386coff_vec;
extern const bfd_target bfd_powerpc_pe_vec;
extern const bfd_target bfd_powerpcle_pe_vec;
extern const bfd_target bfd_powerpc_pei_vec;
extern const bfd_target bfd_powerpcle_pei_vec;
extern const bfd_target i386pe_vec;
extern const bfd_target i386pei_vec;
extern const bfd_target go32coff_vec;
extern const bfd_target go32stubbedcoff_vec;
d596 3
d603 1
a611 1
extern const bfd_target m68k4knetbsd_vec;
a613 2
extern const bfd_target mipslpe_vec;
extern const bfd_target mipslpei_vec;
d618 2
d621 1
d623 1
a624 3
extern const bfd_target nlm32_alpha_vec;
extern const bfd_target nlm32_powerpc_vec;
extern const bfd_target pc532netbsd_vec;
d627 2
d631 1
a631 1
extern const bfd_target pmac_xcoff_vec;
d633 1
d635 1
a636 2
extern const bfd_target shcoff_small_vec;
extern const bfd_target shlcoff_small_vec;
d639 2
a645 1
extern const bfd_target sparccoff_vec;
d650 6
d661 1
a662 1
extern const bfd_target w65_vec;
d688 1
a688 1
const bfd_target * const bfd_target_vector[] = {
d714 5
d726 4
d739 2
a742 1
#if 0
d744 1
a744 1
#endif
d747 3
d751 1
d764 2
a767 1
	&bfd_elf32_sparc_vec,
d772 1
d777 6
a782 1
#ifdef BFD64			/* No one seems to use this.  */
d792 2
d898 1
a898 1
	/* This has the same magic number as RS/6000. */
d902 3
d919 6
d980 1
d995 1
a995 1
const size_t _bfd_target_vector_entries = sizeof(bfd_target_vector)/sizeof(*bfd_target_vector);
d1095 1
a1095 1
	targets to find the one that matches the file being read.   
d1178 1
a1178 1
	const bfd_target * bfd_search_for_target (int (* search_func)(const bfd_target *, void *), void *);
@


1.7
log
@Adding support for Motorola mvme88k
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d155 1
d248 2
a249 1
The general target vector.
d346 1
a346 1
.CAT(NAME,_bfd_is_local_label),\
d365 1
a365 1
.  boolean	 (*_bfd_is_local_label) PARAMS ((bfd *, asymbol *));
d418 2
a419 1
.CAT(NAME,_bfd_link_split_section)
d443 4
a446 1
. {* Routines to handle dynamic symbols and relocs.  *}
d464 10
d478 1
d497 1
d502 4
d509 7
d519 2
d522 1
d525 1
d529 1
d534 2
d541 4
a547 1
extern const bfd_target bsd_ecoffalpha_little_vec;
d551 1
a552 1
extern const bfd_target evax_alpha_vec;
d572 1
d590 1
d594 6
a599 1
extern const bfd_target m88knetbsd_vec;
d614 4
d619 1
d626 4
d631 2
d649 2
a650 1
extern const bfd_target cisco_core_vec;
d656 1
a656 1
extern const bfd_target sco_core_vec;
d694 4
d702 3
d706 2
d710 1
d712 3
d719 1
d725 2
d728 5
d740 1
a740 4
#if 0
	&bsd_ecoffalpha_little_vec,
#endif
	/* We don't include cisco_core_vec.  Although it has a magic number,
d748 1
a750 1
	&evax_alpha_vec,
d776 1
d795 1
d800 4
d817 1
d820 4
a823 1
	&m88knetbsd_vec,
d854 2
d857 1
d863 9
a871 1
	&tekhex_vec,
a872 1
	&versados_vec,
d907 3
d924 1
a924 1
const bfd_target * const bfd_default_vector[] = {
d935 1
a935 1

d944 1
a944 2
     field.  If this is UNSUPPORTED_TARGET, then the target is not
     supported.  */
a947 2
#define UNSUPPORTED_TARGET ((const bfd_target *) 1)

d954 64
a1041 1
  const bfd_target * const *target;
d1043 1
a1043 1
  const struct targmatch *match;
d1054 5
a1058 2
      abfd->xvec = bfd_target_vector[0];
      return bfd_target_vector[0];
d1063 3
a1065 8
  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    {
      if (strcmp (targname, (*target)->name) == 0)
	{
	  abfd->xvec = *target;
	  return *target;
	}
    }
d1067 2
a1068 21
  /* If we couldn't match on the exact name, try matching on the
     configuration triplet.  FIXME: We should run the triplet through
     config.sub first, but that is hard.  */
  for (match = &bfd_target_match[0]; match->triplet != NULL; match++)
    {
      if (fnmatch (match->triplet, targname, 0) == 0)
	{
	  while (match->vector == NULL)
	    ++match;
	  if (match->vector != UNSUPPORTED_TARGET)
	    {
	      abfd->xvec = match->vector;
	      return match->vector;
	    }
	  break;
	}
    }

  bfd_set_error (bfd_error_invalid_target);

  return NULL;
a1070 1

d1110 29
@


1.6
log
@support coredump parsing on alpha
@
text
@d552 1
d736 1
@


1.5
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d594 1
d801 3
@


1.4
log
@Alpha support based on Chris Demetriou's <cgd@@cs.cmu.edu> work
@
text
@d24 1
d497 2
d645 2
d830 21
d872 1
a872 1
     CONST char *target_name;
d876 7
a882 3
  extern char *getenv ();
  CONST char *targname = (target_name ? target_name : 
			  (CONST char *) getenv ("GNUTARGET"));
d885 6
a890 4
  if (targname == NULL || !strcmp (targname, "default")) {
    abfd->target_defaulted = true;
    return abfd->xvec = bfd_target_vector[0];
  }
d894 26
a919 4
  for (target = &bfd_target_vector[0]; *target != NULL; target++) {
    if (!strcmp (targname, (*target)->name))
      return abfd->xvec = *target;
  }
d922 1
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d504 1
d652 3
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d152 2
a153 1
.  bfd_target_msdos_flavour
d182 1
a182 1
from the set <<NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.
d484 1
d498 2
d508 1
d562 1
d626 3
d660 1
a660 1
#if 0
d662 1
d755 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d148 1
d155 2
d174 1
a174 1
.  boolean byteorder_big_p;
d178 1
a178 1
.  boolean header_byteorder_big_p;
d314 1
d329 2
d485 1
d491 1
d513 1
d533 1
d536 1
d551 1
d575 3
d621 3
d629 3
d671 1
d705 5
d742 1
d764 2
d889 1
a889 2
  if (name_list == NULL) {
    bfd_set_error (bfd_error_no_memory);
a890 1
  }
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a147 1
.  bfd_target_ihex_flavour,
a153 2
.enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
.
d171 1
a171 1
.  enum bfd_endian byteorder;
d175 1
a175 1
.  enum bfd_endian header_byteorder;
a310 1
.CAT(NAME,_get_elt_at_index),\
a324 2
.#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
.  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
a478 1
extern const bfd_target bfd_elf64_bigmips_vec;
a483 1
extern const bfd_target bfd_elf64_littlemips_vec;
a504 1
extern const bfd_target i386freebsd_vec;
a523 1
extern const bfd_target m68kaux_coff_vec;
a525 1
extern const bfd_target m68klinux_vec;
a539 1
extern const bfd_target ppcboot_vec;
a562 3
/* ihex is always included.  */
extern const bfd_target ihex_vec;

a605 3
#ifdef BFD64
	&bfd_elf64_bigmips_vec,
#endif
a610 3
#ifdef BFD64
	&bfd_elf64_littlemips_vec,
#endif
a649 1
	&i386freebsd_vec,
a682 5
#if 0
	/* Since a.out files lack decent magic numbers, no way to recognize
	   which kind of a.out file it is.  */
	&m68klinux_vec,
#endif
a714 1
	&ppcboot_vec,
a735 2
/* Likewise for ihex.  */
	&ihex_vec,
d859 2
a860 1
  if (name_list == NULL)
d862 1
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d152 1
a152 2
.  bfd_target_msdos_flavour,
.  bfd_target_evax_flavour
d181 1
a181 1
from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.
a482 1
extern const bfd_target bfd_elf64_alpha_vec;
a495 2
extern const bfd_target bfd_elf32_sh_vec;
extern const bfd_target bfd_elf32_shl_vec;
a503 1
extern const bfd_target evax_alpha_vec;
a556 1
extern const bfd_target sparcle_aout_vec;
a619 3
#ifdef BFD64
	&bfd_elf64_alpha_vec,
#endif
d651 1
a651 1
#ifdef BFD64
a652 1
	&evax_alpha_vec,
a744 1
	&sparcle_aout_vec,
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a23 1
#include "fnmatch.h"
a495 2
extern const bfd_target bfd_elf32_mn10200_vec;
extern const bfd_target bfd_elf32_mn10300_vec;
a640 2
	&bfd_elf32_mn10200_vec,
	&bfd_elf32_mn10300_vec,
a820 21
/* This array maps configuration triplets onto BFD vectors.  */

struct targmatch
{
  /* The configuration triplet.  */
  const char *triplet;
  /* The BFD vector.  If this is NULL, then the vector is found by
     searching forward for the next structure with a non NULL vector
     field.  If this is UNSUPPORTED_TARGET, then the target is not
     supported.  */
  const bfd_target *vector;
};

#define UNSUPPORTED_TARGET ((const bfd_target *) 1)

/* targmatch.h is built by Makefile out of config.bfd.  */
static const struct targmatch bfd_target_match[] = {
#include "targmatch.h"
  { NULL, NULL }
};

d842 1
a842 1
     const char *target_name;
d846 3
a848 7
  const char *targname;
  const struct targmatch *match;

  if (target_name != NULL)
    targname = target_name;
  else
    targname = getenv ("GNUTARGET");
d851 4
a854 6
  if (targname == NULL || strcmp (targname, "default") == 0)
    {
      abfd->target_defaulted = true;
      abfd->xvec = bfd_target_vector[0];
      return bfd_target_vector[0];
    }
d858 4
a861 26
  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    {
      if (strcmp (targname, (*target)->name) == 0)
	{
	  abfd->xvec = *target;
	  return *target;
	}
    }

  /* If we couldn't match on the exact name, try matching on the
     configuration triplet.  FIXME: We should run the triplet through
     config.sub first, but that is hard.  */
  for (match = &bfd_target_match[0]; match->triplet != NULL; match++)
    {
      if (fnmatch (match->triplet, targname, 0) == 0)
	{
	  while (match->vector == NULL)
	    ++match;
	  if (match->vector != UNSUPPORTED_TARGET)
	    {
	      abfd->xvec = match->vector;
	      return match->vector;
	    }
	  break;
	}
    }
a863 1

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d343 1
a343 1
.CAT(NAME,_bfd_is_local_label_name),\
d362 1
a362 1
.  boolean	 (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
a488 1
extern const bfd_target bfd_elf32_d10v_vec;
a494 1
extern const bfd_target bfd_elf32_m32r_vec;
a509 1
extern const bfd_target ecoff_biglittle_vec;
a547 1
extern const bfd_target m68ksysvcoff_vec;
a565 1
extern const bfd_target sparclinux_vec;
a592 1
extern const bfd_target netbsd_core_vec;
a635 1
	&bfd_elf32_d10v_vec,
a643 1
	&bfd_elf32_m32r_vec,
a664 1
	&ecoff_biglittle_vec,
a727 1
	&m68ksysvcoff_vec,
a760 1
	&sparclinux_vec,
d814 1
a814 1
const bfd_target *bfd_default_vector[] = {
d825 1
a825 1

d834 2
a835 1
     field.  */
d839 2
a846 64
static const bfd_target *find_target PARAMS ((const char *));

/* Find a target vector, given a name or configuration triplet.  */

static const bfd_target *
find_target (name)
     const char *name;
{
  const bfd_target * const *target;
  const struct targmatch *match;

  for (target = &bfd_target_vector[0]; *target != NULL; target++)
    if (strcmp (name, (*target)->name) == 0)
      return *target;

  /* If we couldn't match on the exact name, try matching on the
     configuration triplet.  FIXME: We should run the triplet through
     config.sub first, but that is hard.  */
  for (match = &bfd_target_match[0]; match->triplet != NULL; match++)
    {
      if (fnmatch (match->triplet, name, 0) == 0)
	{
	  while (match->vector == NULL)
	    ++match;
	  return match->vector;
	  break;
	}
    }

  bfd_set_error (bfd_error_invalid_target);
  return NULL;
}

/*
FUNCTION
	bfd_set_default_target

SYNOPSIS
	boolean bfd_set_default_target (const char *name);

DESCRIPTION
	Set the default target vector to use when recognizing a BFD.
	This takes the name of the target, which may be a BFD target
	name or a configuration triplet.
*/

boolean
bfd_set_default_target (name)
     const char *name;
{
  const bfd_target *target;

  if (bfd_default_vector[0] != NULL
      && strcmp (name, bfd_default_vector[0]->name) == 0)
    return true;

  target = find_target (name);
  if (target == NULL)
    return false;

  bfd_default_vector[0] = target;
  return true;
}

d871 1
d873 1
a873 1
  const bfd_target *target;
d884 2
a885 5
      if (bfd_default_vector[0] != NULL)
	abfd->xvec = bfd_default_vector[0];
      else
	abfd->xvec = bfd_target_vector[0];
      return abfd->xvec;
d890 8
a897 3
  target = find_target (targname);
  if (target == NULL)
    return NULL;
d899 21
a919 2
  abfd->xvec = target;
  return target;
d921 1
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a153 1
.  bfd_target_ovax_flavour,
d246 1
a246 2
The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.
d415 1
a415 2
.CAT(NAME,_bfd_link_split_section),\
.CAT(NAME,_bfd_gc_sections)
d439 1
a439 4
.  {* Remove sections that are not referenced from the output.  *}
.  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
.
.  {* Routines to handle dynamic symbols and relocs.  *}
a456 10
A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.

. {* Opposite endian version of this target.  *}  
. const struct bfd_target * alternative_target;
. 

a460 1
. 
a478 1
extern const bfd_target armnetbsd_vec;
a482 4
extern const bfd_target arm_epoc_pe_little_vec;
extern const bfd_target arm_epoc_pe_big_vec;
extern const bfd_target arm_epoc_pei_little_vec;
extern const bfd_target arm_epoc_pei_big_vec;
a485 7
extern const bfd_target bfd_elf32_avr_vec;
extern const bfd_target bfd_elf32_bigarc_vec;
extern const bfd_target bfd_elf32_bigarm_vec;
extern const bfd_target bfd_elf32_bigarm_oabi_vec;
extern const bfd_target bfd_elf32_littlearc_vec;
extern const bfd_target bfd_elf32_littlearm_vec;
extern const bfd_target bfd_elf32_littlearm_oabi_vec;
a489 1
extern const bfd_target bfd_elf32_d30v_vec;
a490 1
extern const bfd_target bfd_elf32_i370_vec;
a492 1
extern const bfd_target bfd_elf32_i960_vec;
a500 2
extern const bfd_target bfd_elf32_pj_vec;
extern const bfd_target bfd_elf32_pjl_vec;
a505 4
extern const bfd_target bfd_elf32_v850_vec;
extern const bfd_target bfd_elf32_fr30_vec;
extern const bfd_target bfd_elf32_mcore_big_vec;
extern const bfd_target bfd_elf32_mcore_little_vec;
d514 1
a533 1
extern const bfd_target go32stubbedcoff_vec;
a554 6
extern const bfd_target mipslpe_vec;
extern const bfd_target mipslpei_vec;
extern const bfd_target mcore_pe_big_vec;
extern const bfd_target mcore_pe_little_vec;
extern const bfd_target mcore_pei_big_vec;
extern const bfd_target mcore_pei_little_vec;
a568 4
extern const bfd_target shcoff_small_vec;
extern const bfd_target shlcoff_small_vec;
extern const bfd_target shlpe_vec;
extern const bfd_target shlpei_vec;
a576 4
extern const bfd_target tic30_aout_vec;
extern const bfd_target tic30_coff_vec;
extern const bfd_target tic80coff_vec;
extern const bfd_target vaxnetbsd_vec;
a577 2
extern const bfd_target vms_alpha_vec;
extern const bfd_target vms_vax_vec;
d594 1
a594 2
extern const bfd_target cisco_core_big_vec;
extern const bfd_target cisco_core_little_vec;
d600 1
a600 1
extern const bfd_target sco5_core_vec;
a637 4
	&bfd_elf32_avr_vec,
	&bfd_elf32_bigarc_vec,
        &bfd_elf32_bigarm_vec,
        &bfd_elf32_bigarm_oabi_vec,
a642 2
	&bfd_elf32_d30v_vec,
#if 0
a643 2
#endif
	&bfd_elf32_i370_vec,
a645 1
	&bfd_elf32_i960_vec,
a646 3
	&bfd_elf32_littlearc_vec,
        &bfd_elf32_littlearm_vec,
        &bfd_elf32_littlearm_oabi_vec,
a656 2
	&bfd_elf32_pj_vec,
	&bfd_elf32_pjl_vec,
a657 5
	&bfd_elf32_powerpcle_vec,
	&bfd_elf32_v850_vec,
	&bfd_elf32_fr30_vec,
	&bfd_elf32_mcore_big_vec,
	&bfd_elf32_mcore_little_vec,
d665 1
a665 1
	/* We don't include cisco_core_*_vec.  Although it has a magic number,
d676 1
a701 1
	&go32stubbedcoff_vec,
a719 1
	&armnetbsd_vec,
a723 4
	&arm_epoc_pe_little_vec,
	&arm_epoc_pe_big_vec,
	&arm_epoc_pei_little_vec,
	&arm_epoc_pei_big_vec,
a739 4
	&mcore_pe_big_vec,
	&mcore_pe_little_vec,
	&mcore_pei_big_vec,
	&mcore_pei_little_vec,
a769 2
	&shcoff_small_vec,
	&shlcoff_small_vec,
d777 2
a778 4
	&tic30_aout_vec,
	&tic30_coff_vec,
	&tic80coff_vec,
	&vaxnetbsd_vec,
a779 5
#ifdef BFD64
	&vms_alpha_vec,
#endif
	&vms_vax_vec,
	&we32kcoff_vec,
a807 3
#ifdef NETBSD_CORE
	&netbsd_core_vec,
#endif
a810 3
#ifdef SCO5_CORE
	&sco5_core_vec,
#endif
a1010 29
}

/*
FUNCTION
	bfd_seach_for_target

SYNOPSIS
	const bfd_target * bfd_search_for_target (int (* search_func)(const bfd_target *, void *), void *);

DESCRIPTION
	Return a pointer to the first transfer vector in the list of
	transfer vectors maintained by BFD that produces a non-zero
	result when passed to the function @@var{search_func}.  The
	parameter @@var{data} is passed, unexamined, to the search
	function.
*/

const bfd_target *
bfd_search_for_target (search_func, data)
     int (* search_func) PARAMS ((const bfd_target * target, void * data));
     void * data;
{
  const bfd_target * const * target;

  for (target = bfd_target_vector; * target != NULL; target ++)
    if (search_func (* target, data))
      return * target;

  return NULL;
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d28 1
a28 1
SECTION
d37 1
a37 1
	calls to the back end routines.
d45 1
a45 1
	target string supplied to <<bfd_openr>> and the new BFD pointer.
d49 1
a49 1
	that as the target string.
d59 1
a59 1
	use it.
d69 1
a69 1
	<<bfd_check_format>> on the BFD with a suggested format.
d78 1
d90 1
a90 1
	routines to call to do various operations.
d93 1
a93 1
	member.
d100 1
a100 1
	to the called function.
d119 1
a119 1
.            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d125 1
a125 1
.   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
d134 1
d137 1
a137 1
	macro to define them both!
a143 1
.  bfd_target_xcoff_flavour,
d187 1
a187 1
.  flagword object_flags;
d194 1
a194 1
The character normally found at the front of a symbol
d201 1
a201 1
.  char ar_pad_char;
d236 1
a236 1
Check the format of a file being read.  Return a <<bfd_target *>> or zero.
d240 1
a240 1
Set the format of a file being written.
d244 1
a244 1
Write cached information into a file being written, at <<bfd_close>>.
d267 1
a267 1
.  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
d291 1
a291 1
.  {* Called to copy BFD private symbol data from one symbol
d327 1
a327 1
.  boolean  (*write_armap) PARAMS ((bfd *arch,
d330 1
a330 1
.                              unsigned int orl_count,
d470 1
a470 1
. {* Opposite endian version of this target.  *}
d472 1
a472 1
.
d478 1
a478 1
.
a488 1
extern const bfd_target aout0_big_vec;
d493 1
d495 1
a495 4
extern const bfd_target arm_epoc_pe_big_vec;
extern const bfd_target arm_epoc_pe_little_vec;
extern const bfd_target arm_epoc_pei_big_vec;
extern const bfd_target arm_epoc_pei_little_vec;
a496 1
extern const bfd_target armcoff_little_vec;
d498 1
d500 1
a500 1
extern const bfd_target armpe_little_vec;
d502 4
a505 1
extern const bfd_target armpei_little_vec;
d508 1
a508 2
extern const bfd_target bfd_efi_app_ia32_vec;
extern const bfd_target bfd_efi_app_ia64_vec;
a509 1
extern const bfd_target bfd_elf32_big_generic_vec;
d511 1
d513 4
a516 1
extern const bfd_target bfd_elf32_bigarm_vec;
d518 1
a518 1
extern const bfd_target bfd_elf32_cris_vec;
a520 2
extern const bfd_target bfd_elf32_fr30_vec;
extern const bfd_target bfd_elf32_hppa_linux_vec;
a523 1
extern const bfd_target bfd_elf32_i860_little_vec;
a525 1
extern const bfd_target bfd_elf32_ia64_big_vec;
a526 3
extern const bfd_target bfd_elf32_littlearc_vec;
extern const bfd_target bfd_elf32_littlearm_oabi_vec;
extern const bfd_target bfd_elf32_littlearm_vec;
d528 1
a529 2
extern const bfd_target bfd_elf32_m68hc11_vec;
extern const bfd_target bfd_elf32_m68hc12_vec;
a531 2
extern const bfd_target bfd_elf32_mcore_big_vec;
extern const bfd_target bfd_elf32_mcore_little_vec;
a538 1
extern const bfd_target bfd_elf32_shblin_vec;
a539 1
extern const bfd_target bfd_elf32_shlin_vec;
a540 3
extern const bfd_target bfd_elf32_tradbigmips_vec;
extern const bfd_target bfd_elf32_tradlittlemips_vec;
extern const bfd_target bfd_elf32_us_cris_vec;
d542 3
a544 1
extern const bfd_target bfd_elf64_alpha_vec;
a545 5
extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_hppa_linux_vec;
extern const bfd_target bfd_elf64_hppa_vec;
extern const bfd_target bfd_elf64_ia64_big_vec;
extern const bfd_target bfd_elf64_ia64_little_vec;
a546 3
extern const bfd_target bfd_elf64_littlemips_vec;
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
a547 6
extern const bfd_target bfd_elf64_x86_64_vec;
extern const bfd_target bfd_powerpc_pe_vec;
extern const bfd_target bfd_powerpc_pei_vec;
extern const bfd_target bfd_powerpcle_pe_vec;
extern const bfd_target bfd_powerpcle_pei_vec;
extern const bfd_target cris_aout_vec;
d550 1
a551 1
extern const bfd_target ecoff_little_vec;
a552 2
extern const bfd_target go32coff_vec;
extern const bfd_target go32stubbedcoff_vec;
d558 1
a560 1
extern const bfd_target i386coff_vec;
d563 10
a578 3
extern const bfd_target i386os9k_vec;
extern const bfd_target i386pe_vec;
extern const bfd_target i386pei_vec;
a582 1
extern const bfd_target m68k4knetbsd_vec;
d591 1
d594 2
a599 2
extern const bfd_target mipslpe_vec;
extern const bfd_target mipslpei_vec;
d601 2
a603 1
extern const bfd_target nlm32_i386_vec;
d605 1
a605 1
extern const bfd_target nlm32_sparc_vec;
a607 2
extern const bfd_target pc532netbsd_vec;
extern const bfd_target pmac_xcoff_vec;
d610 1
a610 1
extern const bfd_target rs6000coff64_vec;
d612 2
a614 1
extern const bfd_target shcoff_vec;
a615 1
extern const bfd_target shlcoff_vec;
a617 2
extern const bfd_target som_vec;
extern const bfd_target sparccoff_vec;
d623 1
a627 6
extern const bfd_target tic54x_coff0_beh_vec;
extern const bfd_target tic54x_coff0_vec;
extern const bfd_target tic54x_coff1_beh_vec;
extern const bfd_target tic54x_coff1_vec;
extern const bfd_target tic54x_coff2_beh_vec;
extern const bfd_target tic54x_coff2_vec;
d633 1
a634 1
extern const bfd_target we32kcoff_vec;
d660 1
a660 1
static const bfd_target * const _bfd_target_vector[] = {
a685 5
	&bfd_efi_app_ia32_vec,
#ifdef BFD64
	&bfd_efi_app_ia64_vec,
#endif

a692 4
	&bfd_elf64_hppa_vec,
	&bfd_elf64_hppa_linux_vec,
	&bfd_elf64_ia64_little_vec,
	&bfd_elf64_ia64_big_vec,
a701 2
	&bfd_elf32_cris_vec,
	&bfd_elf32_us_cris_vec,
d704 1
d706 1
a706 1
	&bfd_elf32_hppa_linux_vec,
a708 3
#ifdef BFD64
        &bfd_elf64_x86_64_vec,
#endif
a709 1
	&bfd_elf32_i860_little_vec,
a721 2
	&bfd_elf32_m68hc11_vec,
	&bfd_elf32_m68hc12_vec,
d724 1
a728 1
	&bfd_elf32_sparc_vec,
d733 1
a733 6
	&bfd_elf32_tradbigmips_vec,
	&bfd_elf32_tradlittlemips_vec,
#ifdef BFD64
	&bfd_elf64_tradbigmips_vec,
	&bfd_elf64_tradlittlemips_vec,
	/* No one seems to use this.  */
a742 2

        &cris_aout_vec,
d847 1
a847 1
	/* This has the same magic number as RS/6000.  */
a850 3
#ifdef BFD64
	&rs6000coff64_vec,
#endif
a864 6
	&tic54x_coff0_vec,
	&tic54x_coff0_beh_vec,
	&tic54x_coff1_vec,
	&tic54x_coff1_beh_vec,
	&tic54x_coff2_vec,
	&tic54x_coff2_beh_vec,
a919 1
const bfd_target * const *bfd_target_vector = _bfd_target_vector;
d934 1
a934 1
const size_t _bfd_target_vector_entries = sizeof (_bfd_target_vector)/sizeof (*_bfd_target_vector);
d1034 1
a1034 1
	targets to find the one that matches the file being read.
d1117 1
a1117 1
	const bfd_target * bfd_search_for_target (int (* search_func) (const bfd_target *, void *), void *);
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d73 1
a73 1
	<<bfd_check_format>> returns <<TRUE>> when the caller guesses right.
d128 1
a128 1
.
d138 1
a138 2
.enum bfd_flavour
.{
d156 1
a156 6
.  bfd_target_evax_flavour,
.  bfd_target_mmo_flavour,
.  bfd_target_mach_o_flavour,
.  bfd_target_pef_flavour,
.  bfd_target_pef_xlib_flavour,
.  bfd_target_sym_flavour
d166 3
a168 1
.  {* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  *}
d170 4
a173 3
.
. {* The "flavour" of a back end is a general indication about
.    the contents of a file.  *}
d175 3
a177 2
.
.  {* The order of bytes within the data area of a file.  *}
d179 3
a181 2
.
. {* The order of bytes within the header parts of a file.  *}
d183 4
a186 3
.
.  {* A mask of all the flags which an executable may have set -
.     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  *}
d188 4
a191 3
.
. {* A mask of all the flags which a section may have set - from
.    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  *}
d193 4
a196 3
.
. {* The character normally found at the front of a symbol.
.    (if any), perhaps `_'.  *}
d198 3
a200 2
.
. {* The pad character for file names within an archive header.  *}
d202 3
a204 2
.
.  {* The maximum number of characters in an archive header.  *}
d206 6
a211 5
.
.  {* Entries for byte swapping for data. These are different from the
.     other entry points, since they don't take a BFD asthe first argument.
.     Certain other handlers could do the same.  *}
.  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
d213 2
a214 2
.  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
d216 2
a217 2
.  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
d219 5
a223 4
.  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
.
.  {* Byte swapping for the headers.  *}
.  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d225 2
a226 2
.  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d228 2
a229 2
.  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
.  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d231 7
a237 6
.  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
.
.  {* Format dependent routines: these are vectors of entry points
.     within the target vector structure, one for each format to check.  *}
.
.  {* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  *}
d239 9
a247 7
.
.  {* Set the format of a file being written.  *}
.  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
.
.  {* Write cached information into a file being written, at <<bfd_close>>.  *}
.  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
.
d250 1
d253 6
a258 9
Do not "beautify" the CONCAT* macro args.  Traditional C will not
remove whitespace added here, and thus will fail to concatenate
the tokens.
.#define BFD_JUMP_TABLE_GENERIC(NAME) \
.CONCAT2 (NAME,_close_and_cleanup), \
.CONCAT2 (NAME,_bfd_free_cached_info), \
.CONCAT2 (NAME,_new_section_hook), \
.CONCAT2 (NAME,_get_section_contents), \
.CONCAT2 (NAME,_get_section_contents_in_window)
d261 1
a261 1
.  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d263 1
a263 1
.  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d265 1
a265 1
.  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d267 5
a271 4
.  bfd_boolean (*_bfd_get_section_contents)
.    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
.  bfd_boolean (*_bfd_get_section_contents_in_window)
.    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d274 7
a280 7
.#define BFD_JUMP_TABLE_COPY(NAME) \
.CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
.CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
.CONCAT2 (NAME,_bfd_copy_private_section_data), \
.CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
.CONCAT2 (NAME,_bfd_set_private_flags), \
.CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d283 1
a283 1
.  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d286 1
a286 1
.  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d289 2
a290 2
.  bfd_boolean (*_bfd_copy_private_section_data)
.    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d293 4
a296 4
.  bfd_boolean (*_bfd_copy_private_symbol_data)
.    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
.  {* Called to set private backend flags.  *}
.  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d298 2
a299 2
.  {* Called to print private BFD data.  *}
.  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d302 7
a308 7
.#define BFD_JUMP_TABLE_CORE(NAME) \
.CONCAT2 (NAME,_core_file_failing_command), \
.CONCAT2 (NAME,_core_file_failing_signal), \
.CONCAT2 (NAME,_core_file_matches_executable_p)
.  char *      (*_core_file_failing_command) PARAMS ((bfd *));
.  int         (*_core_file_failing_signal) PARAMS ((bfd *));
.  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d311 23
a333 20
.#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
.CONCAT2 (NAME,_slurp_armap), \
.CONCAT2 (NAME,_slurp_extended_name_table), \
.CONCAT2 (NAME,_construct_extended_name_table), \
.CONCAT2 (NAME,_truncate_arname), \
.CONCAT2 (NAME,_write_armap), \
.CONCAT2 (NAME,_read_ar_hdr), \
.CONCAT2 (NAME,_openr_next_archived_file), \
.CONCAT2 (NAME,_get_elt_at_index), \
.CONCAT2 (NAME,_generic_stat_arch_elt), \
.CONCAT2 (NAME,_update_armap_timestamp)
.  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
.  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
.  bfd_boolean (*_bfd_construct_extended_name_table)
.    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
.  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
.  bfd_boolean (*write_armap)
.    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
.  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
.  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
d335 3
a337 3
.  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
.  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
.  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d340 20
a359 19
.#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
.CONCAT2 (NAME,_get_symtab_upper_bound), \
.CONCAT2 (NAME,_get_symtab), \
.CONCAT2 (NAME,_make_empty_symbol), \
.CONCAT2 (NAME,_print_symbol), \
.CONCAT2 (NAME,_get_symbol_info), \
.CONCAT2 (NAME,_bfd_is_local_label_name), \
.CONCAT2 (NAME,_get_lineno), \
.CONCAT2 (NAME,_find_nearest_line), \
.CONCAT2 (NAME,_bfd_make_debug_symbol), \
.CONCAT2 (NAME,_read_minisymbols), \
.CONCAT2 (NAME,_minisymbol_to_symbol)
.  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
.  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
.                                                struct symbol_cache_entry **));
.  struct symbol_cache_entry *
.              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
.  void        (*_bfd_print_symbol)
.    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
d361 3
a363 2
.  void        (*_bfd_get_symbol_info)
.    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
d365 1
a365 1
.  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d367 5
a371 4
.  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
.  bfd_boolean (*_bfd_find_nearest_line)
.    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
.             const char **, const char **, unsigned int *));
d375 4
a378 2
.  asymbol *   (*_bfd_make_debug_symbol)
.    PARAMS ((bfd *, void *, unsigned long size));
d381 2
a382 2
.  long        (*_read_minisymbols)
.    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d385 2
a386 2
.  asymbol *   (*_minisymbol_to_symbol)
.    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d389 7
a395 7
.#define BFD_JUMP_TABLE_RELOCS(NAME) \
.CONCAT2 (NAME,_get_reloc_upper_bound), \
.CONCAT2 (NAME,_canonicalize_reloc), \
.CONCAT2 (NAME,_bfd_reloc_type_lookup)
.  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
.  long        (*_bfd_canonicalize_reloc)
.    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d398 2
a399 1
.              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d402 7
a408 7
.#define BFD_JUMP_TABLE_WRITE(NAME) \
.CONCAT2 (NAME,_set_arch_mach), \
.CONCAT2 (NAME,_set_section_contents)
.  bfd_boolean (*_bfd_set_arch_mach)
.    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
.  bfd_boolean (*_bfd_set_section_contents)
.    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d411 14
a424 17
.#define BFD_JUMP_TABLE_LINK(NAME) \
.CONCAT2 (NAME,_sizeof_headers), \
.CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
.CONCAT2 (NAME,_bfd_relax_section), \
.CONCAT2 (NAME,_bfd_link_hash_table_create), \
.CONCAT2 (NAME,_bfd_link_hash_table_free), \
.CONCAT2 (NAME,_bfd_link_add_symbols), \
.CONCAT2 (NAME,_bfd_link_just_syms), \
.CONCAT2 (NAME,_bfd_final_link), \
.CONCAT2 (NAME,_bfd_link_split_section), \
.CONCAT2 (NAME,_bfd_gc_sections), \
.CONCAT2 (NAME,_bfd_merge_sections), \
.CONCAT2 (NAME,_bfd_discard_group)
.  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
.  bfd_byte *  (*_bfd_get_relocated_section_contents)
.    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
.             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d426 2
a427 2
.  bfd_boolean (*_bfd_relax_section)
.    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d431 1
a431 6
.  struct bfd_link_hash_table *
.              (*_bfd_link_hash_table_create) PARAMS ((bfd *));
.
.  {* Release the memory associated with the linker hash table.  *}
.  void        (*_bfd_link_hash_table_free)
.    PARAMS ((struct bfd_link_hash_table *));
d434 1
a434 6
.  bfd_boolean (*_bfd_link_add_symbols)
.    PARAMS ((bfd *, struct bfd_link_info *));
.
.  {* Indicate that we are only retrieving symbol values from this section.  *}
.  void        (*_bfd_link_just_syms)
.    PARAMS ((asection *, struct bfd_link_info *));
d438 1
a438 1
.  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d441 1
a441 1
.  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d444 1
a444 7
.  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
.
.  {* Attempt to merge SEC_MERGE sections.  *}
.  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));
.
.  {* Discard members of a group.  *}
.  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d447 7
a453 7
.#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
.CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
.CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
.CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
.CONCAT2 (NAME,_canonicalize_dynamic_reloc)
.  {* Get the amount of memory required to hold the dynamic symbols.  *}
.  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d455 1
a455 1
.  long        (*_bfd_canonicalize_dynamic_symtab)
d458 1
a458 1
.  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d460 1
a460 1
.  long        (*_bfd_canonicalize_dynamic_reloc)
d470 2
a471 2
.  {* Opposite endian version of this target.  *}
.  const struct bfd_target * alternative_target;
d474 4
a477 3
.  {* Data for use by back-end routines, which isn't
.     generic enough to belong in this structure.  *}
.  PTR backend_data;
d480 1
a480 1
.
a488 1
extern const bfd_target aix5coff64_vec;
a518 1
extern const bfd_target bfd_elf32_dlx_big_vec;
a519 2
extern const bfd_target bfd_elf32_frv_vec;
extern const bfd_target bfd_elf32_h8300_vec;
a522 1
extern const bfd_target bfd_elf32_i386_freebsd_vec;
a527 3
extern const bfd_target bfd_elf32_ia64_hpux_big_vec;
extern const bfd_target bfd_elf32_ip2k_vec;
extern const bfd_target bfd_elf32_iq2000_vec;
a541 7
extern const bfd_target bfd_elf32_msp430_vec;
extern const bfd_target bfd_elf32_nbigmips_vec;
extern const bfd_target bfd_elf32_nlittlemips_vec;
extern const bfd_target bfd_elf32_ntradbigmips_vec;
extern const bfd_target bfd_elf32_ntradlittlemips_vec;
extern const bfd_target bfd_elf32_openrisc_vec;
extern const bfd_target bfd_elf32_or32_big_vec;
a545 7
extern const bfd_target bfd_elf32_s390_vec;
extern const bfd_target bfd_elf32_sh64_vec;
extern const bfd_target bfd_elf32_sh64l_vec;
extern const bfd_target bfd_elf32_sh64lin_vec;
extern const bfd_target bfd_elf32_sh64blin_vec;
extern const bfd_target bfd_elf32_sh64lnbsd_vec;
extern const bfd_target bfd_elf32_sh64nbsd_vec;
a549 2
extern const bfd_target bfd_elf32_shlnbsd_vec;
extern const bfd_target bfd_elf32_shnbsd_vec;
a554 5
extern const bfd_target bfd_elf32_vax_vec;
extern const bfd_target bfd_elf32_xstormy16_vec;
extern const bfd_target bfd_elf32_xtensa_be_vec;
extern const bfd_target bfd_elf32_xtensa_le_vec;
extern const bfd_target bfd_elf64_alpha_freebsd_vec;
a559 2
extern const bfd_target bfd_elf64_ia64_aix_big_vec;
extern const bfd_target bfd_elf64_ia64_aix_little_vec;
a560 1
extern const bfd_target bfd_elf64_ia64_hpux_big_vec;
a563 11
extern const bfd_target bfd_elf64_mmix_vec;
extern const bfd_target bfd_elf64_powerpc_vec;
extern const bfd_target bfd_elf64_powerpcle_vec;
extern const bfd_target bfd_elf64_s390_vec;
extern const bfd_target bfd_elf64_sh64_vec;
extern const bfd_target bfd_elf64_sh64l_vec;
extern const bfd_target bfd_elf64_sh64lin_vec;
extern const bfd_target bfd_elf64_sh64blin_vec;
extern const bfd_target bfd_elf64_sh64lnbsd_vec;
extern const bfd_target bfd_elf64_sh64nbsd_vec;
extern const bfd_target bfd_elf64_sparc_vec;
d566 1
a567 1
extern const bfd_target bfd_mmo_vec;
a613 3
extern const bfd_target mach_o_be_vec;
extern const bfd_target mach_o_le_vec;
extern const bfd_target mach_o_fat_vec;
a625 1
extern const bfd_target or32coff_big_vec;
a627 3
extern const bfd_target pdp11_aout_vec;
extern const bfd_target pef_vec;
extern const bfd_target pef_xlib_vec;
d647 1
a647 1
extern const bfd_target sym_vec;
a649 6
extern const bfd_target tic4x_coff0_beh_vec;
extern const bfd_target tic4x_coff0_vec;
extern const bfd_target tic4x_coff1_beh_vec;
extern const bfd_target tic4x_coff1_vec;
extern const bfd_target tic4x_coff2_beh_vec;
extern const bfd_target tic4x_coff2_vec;
a656 1
extern const bfd_target vaxbsd_vec;
a657 1
extern const bfd_target vax1knetbsd_vec;
d665 1
a665 1
/* These are always included.  */
d668 2
a669 1
extern const bfd_target tekhex_vec;
d671 2
d679 1
a680 1
extern const bfd_target hpux_core_vec;
a683 1
extern const bfd_target ptrace_core_vec;
d686 1
d707 1
a707 9
#ifdef BFD64
	&aix5coff64_vec,
#endif
	&aout0_big_vec,
#if 0
	/* We have no way of distinguishing these from other a.out variants.  */
	&aout_arm_big_vec,
	&aout_arm_little_vec,
	/* No one seems to use this.  */
a710 14
#if 0
	&apollocoff_vec,
#endif
	&arm_epoc_pe_big_vec,
	&arm_epoc_pe_little_vec,
	&arm_epoc_pei_big_vec,
	&arm_epoc_pei_little_vec,
	&armcoff_big_vec,
	&armcoff_little_vec,
	&armnetbsd_vec,
	&armpe_big_vec,
	&armpe_little_vec,
	&armpei_big_vec,
	&armpei_little_vec,
d713 1
a717 1
	&bfd_elf32_avr_vec,
d724 8
d733 2
a734 2
	&bfd_elf32_bigarm_oabi_vec,
	&bfd_elf32_bigarm_vec,
d736 3
d740 1
d743 1
a743 4
	&bfd_elf32_dlx_big_vec,
	&bfd_elf32_fr30_vec,
	&bfd_elf32_frv_vec,
	&bfd_elf32_h8300_vec,
a744 1
	&bfd_elf32_hppa_vec,
a745 1
	&bfd_elf32_i386_freebsd_vec,
d747 4
a751 1
	&bfd_elf32_i860_vec,
a752 6
#if 0
	&bfd_elf32_ia64_big_vec,
#endif
	&bfd_elf32_ia64_hpux_big_vec,
	&bfd_elf32_ip2k_vec,
	&bfd_elf32_iq2000_vec,
d755 2
a756 2
	&bfd_elf32_littlearm_oabi_vec,
	&bfd_elf32_littlearm_vec,
d758 3
d762 2
a767 13
	&bfd_elf32_mcore_big_vec,
	&bfd_elf32_mcore_little_vec,
	&bfd_elf32_mn10200_vec,
	&bfd_elf32_mn10300_vec,
	&bfd_elf32_msp430_vec,
#ifdef BFD64
	&bfd_elf32_nbigmips_vec,
	&bfd_elf32_nlittlemips_vec,
	&bfd_elf32_ntradbigmips_vec,
	&bfd_elf32_ntradlittlemips_vec,
#endif
	&bfd_elf32_openrisc_vec,
	&bfd_elf32_or32_big_vec,
a771 15
	&bfd_elf32_s390_vec,
        &bfd_elf32_sh_vec,
        &bfd_elf32_shblin_vec,
        &bfd_elf32_shl_vec,
        &bfd_elf32_shlin_vec,
	&bfd_elf32_shlnbsd_vec,
	&bfd_elf32_shnbsd_vec,
#ifdef BFD64
	&bfd_elf32_sh64_vec,
	&bfd_elf32_sh64l_vec,
	&bfd_elf32_sh64lnbsd_vec,
	&bfd_elf32_sh64nbsd_vec,
	&bfd_elf32_sh64lin_vec,
	&bfd_elf32_sh64blin_vec,
#endif
d773 4
a778 6
	&bfd_elf32_us_cris_vec,
	&bfd_elf32_v850_vec,
	&bfd_elf32_vax_vec,
	&bfd_elf32_xstormy16_vec,
	&bfd_elf32_xtensa_be_vec,
	&bfd_elf32_xtensa_le_vec,
d780 3
a782 2
	&bfd_elf64_alpha_freebsd_vec,
	&bfd_elf64_alpha_vec,
a783 8
	&bfd_elf64_bigmips_vec,
	&bfd_elf64_hppa_linux_vec,
	&bfd_elf64_hppa_vec,
	&bfd_elf64_ia64_aix_big_vec,
	&bfd_elf64_ia64_aix_little_vec,
	&bfd_elf64_ia64_big_vec,
	&bfd_elf64_ia64_hpux_big_vec,
	&bfd_elf64_ia64_little_vec,
d785 1
a785 11
	&bfd_elf64_littlemips_vec,
	&bfd_elf64_mmix_vec,
	&bfd_elf64_powerpc_vec,
	&bfd_elf64_powerpcle_vec,
	&bfd_elf64_s390_vec,
	&bfd_elf64_sh64_vec,
	&bfd_elf64_sh64l_vec,
	&bfd_elf64_sh64lnbsd_vec,
	&bfd_elf64_sh64nbsd_vec,
	&bfd_elf64_sh64lin_vec,
	&bfd_elf64_sh64blin_vec,
d789 5
a793 10
	&bfd_elf64_tradbigmips_vec,
	&bfd_elf64_tradlittlemips_vec,
	&bfd_elf64_x86_64_vec,
	&bfd_mmo_vec, 
#endif
	&bfd_powerpc_pe_vec,
	&bfd_powerpc_pei_vec,
	&bfd_powerpcle_pe_vec,
	&bfd_powerpcle_pei_vec,
	&cris_aout_vec,
d795 1
a795 1
	&demo_64_vec,	/* Only compiled if host has long-long support.  */
d798 1
a799 1
	&ecoff_little_vec,
a802 2
	&go32coff_vec,
	&go32stubbedcoff_vec,
d809 2
a810 1
	/* Clashes with sunos_big_vec magic no.  */
d814 3
a819 3
#if 0
	&i386dynix_vec,
#endif
d821 7
d844 11
a854 1
	&i860coff_vec,
a857 4
#if 0
	&m68k4knetbsd_vec,
	&m68kaux_coff_vec,
#endif
a870 3
	&mach_o_be_vec,
	&mach_o_le_vec,
	&mach_o_fat_vec,
a874 2
	&mipslpe_vec,
	&mipslpei_vec,
d876 2
d881 1
a881 3
	&nlm32_i386_vec,
	&nlm32_powerpc_vec,
	&nlm32_sparc_vec,
a889 3
	/* Entry for the OpenRISC family.  */
	&or32coff_big_vec,

d891 6
a896 4
	&pc532netbsd_vec,
	&pdp11_aout_vec,
	&pef_vec,
	&pef_xlib_vec,
d901 1
a901 5
	&ppcboot_vec,
#if 0
	/* We have no way of distinguishing these from other a.out variants.  */
	&riscix_vec,
#endif
d905 3
a907 1
	&rs6000coff_vec,
a908 1
	&shcoff_vec,
a909 7
	&shlcoff_vec,
	&shlpe_vec,
	&shlpei_vec,
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF)
	&som_vec,
#endif
	&sparccoff_vec,
d916 1
a916 1
	&sym_vec,
d919 1
d921 1
a921 1
	&tic54x_coff0_vec,
d923 1
a923 1
	&tic54x_coff1_vec,
a924 1
	&tic54x_coff2_vec,
a925 1
	&vaxbsd_vec,
a926 1
	&vax1knetbsd_vec,
a931 1
	&w65_vec,
d934 1
d952 2
a953 6
#if 0
	/* We don't include cisco_core_*_vec.  Although it has a magic number,
	   the magic number isn't at the beginning of the file, and thus
	   might spuriously match other kinds of files.  */
	&cisco_core_big_vec,
	&cisco_core_little_vec,
a957 3
#ifdef HPUX_CORE
	&hpux_core_vec,
#endif
a966 3
#ifdef PTRACE_CORE
	&ptrace_core_vec,
#endif
d970 1
a970 1
#ifdef TRAD_CORE
d974 4
a991 11
/* bfd_associated_vector[] contains the associated target vectors used
   to reduce the ambiguity in bfd_check_format_matches.  */

static const bfd_target *_bfd_associated_vector[] = {
#ifdef ASSOCIATED_VECS
	ASSOCIATED_VECS,
#endif
	NULL
};
const bfd_target * const *bfd_associated_vector = _bfd_associated_vector;

d1053 1
a1053 1
	bfd_boolean bfd_set_default_target (const char *name);
d1061 1
a1061 1
bfd_boolean
d1069 1
a1069 1
    return TRUE;
d1073 1
a1073 1
    return FALSE;
d1076 1
a1076 1
  return TRUE;
d1084 1
a1084 1
	const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
d1111 1
a1111 1
  /* This is safe; the vector cannot be null.  */
d1114 1
a1114 1
      abfd->target_defaulted = TRUE;
d1122 1
a1122 1
  abfd->target_defaulted = FALSE;
d1137 1
a1137 1
	const char ** bfd_target_list (void);
a1149 1
  bfd_size_type amt;
d1155 2
a1156 2
  const bfd_target * const *target;
  const  char **name_list, **name_ptr;
d1161 2
a1162 2
  amt = (vec_length + 1) * sizeof (char **);
  name_ptr = name_list = (const char **) bfd_malloc (amt);
d1168 1
a1168 3
    if (target == &bfd_target_vector[0]
	|| *target != bfd_target_vector[0])
      *name_ptr++ = (*target)->name;
a1169 1
  *name_ptr = NULL;
d1178 1
a1178 3
	const bfd_target * bfd_search_for_target (int (* search_func)
						  (const bfd_target *, void *),
						  void *);
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d33 1
a33 1
	Each port of BFD to a different machine requires the creation
d106 1
a106 1
.  ((*((bfd)->xvec->message)) arglist)
d119 1
a119 1
.  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d206 9
a214 9
.  bfd_uint64_t   (*bfd_getx64) (const void *);
.  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
.  void           (*bfd_putx64) (bfd_uint64_t, void *);
.  bfd_vma        (*bfd_getx32) (const void *);
.  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
.  void           (*bfd_putx32) (bfd_vma, void *);
.  bfd_vma        (*bfd_getx16) (const void *);
.  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
.  void           (*bfd_putx16) (bfd_vma, void *);
d217 9
a225 9
.  bfd_uint64_t   (*bfd_h_getx64) (const void *);
.  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
.  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
.  bfd_vma        (*bfd_h_getx32) (const void *);
.  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
.  void           (*bfd_h_putx32) (bfd_vma, void *);
.  bfd_vma        (*bfd_h_getx16) (const void *);
.  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
.  void           (*bfd_h_putx16) (bfd_vma, void *);
d231 1
a231 1
.  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
d234 1
a234 1
.  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
d237 1
a237 1
.  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
d243 3
d247 5
a251 5
.  NAME##_close_and_cleanup, \
.  NAME##_bfd_free_cached_info, \
.  NAME##_new_section_hook, \
.  NAME##_get_section_contents, \
.  NAME##_get_section_contents_in_window
d254 1
a254 1
.  bfd_boolean (*_close_and_cleanup) (bfd *);
d256 1
a256 1
.  bfd_boolean (*_bfd_free_cached_info) (bfd *);
d258 1
a258 1
.  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
d261 1
a261 1
.    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
d263 1
a263 1
.    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
d267 6
a272 7
.  NAME##_bfd_copy_private_bfd_data, \
.  NAME##_bfd_merge_private_bfd_data, \
.  NAME##_bfd_copy_private_section_data, \
.  NAME##_bfd_copy_private_symbol_data, \
.  NAME##_bfd_set_private_flags, \
.  NAME##_bfd_print_private_bfd_data
.
d275 1
a275 1
.  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
d278 1
a278 1
.  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
d282 1
a282 1
.    (bfd *, sec_ptr, bfd *, sec_ptr);
d286 1
a286 1
.    (bfd *, asymbol *, bfd *, asymbol *);
d288 1
a288 1
.  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
d291 1
a291 1
.  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
d295 6
a300 7
.  NAME##_core_file_failing_command, \
.  NAME##_core_file_failing_signal, \
.  NAME##_core_file_matches_executable_p
.
.  char *      (*_core_file_failing_command) (bfd *);
.  int         (*_core_file_failing_signal) (bfd *);
.  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
d304 12
a315 13
.  NAME##_slurp_armap, \
.  NAME##_slurp_extended_name_table, \
.  NAME##_construct_extended_name_table, \
.  NAME##_truncate_arname, \
.  NAME##_write_armap, \
.  NAME##_read_ar_hdr, \
.  NAME##_openr_next_archived_file, \
.  NAME##_get_elt_at_index, \
.  NAME##_generic_stat_arch_elt, \
.  NAME##_update_armap_timestamp
.
.  bfd_boolean (*_bfd_slurp_armap) (bfd *);
.  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
d317 2
a318 2
.    (bfd *, char **, bfd_size_type *, const char **);
.  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
d320 7
a326 7
.    (bfd *, unsigned int, struct orl *, unsigned int, int);
.  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
.  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
.#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
.  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
.  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
.  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
d330 16
a345 17
.  NAME##_get_symtab_upper_bound, \
.  NAME##_canonicalize_symtab, \
.  NAME##_make_empty_symbol, \
.  NAME##_print_symbol, \
.  NAME##_get_symbol_info, \
.  NAME##_bfd_is_local_label_name, \
.  NAME##_get_lineno, \
.  NAME##_find_nearest_line, \
.  NAME##_bfd_make_debug_symbol, \
.  NAME##_read_minisymbols, \
.  NAME##_minisymbol_to_symbol
.
.  long        (*_bfd_get_symtab_upper_bound) (bfd *);
.  long        (*_bfd_canonicalize_symtab)
.    (bfd *, struct bfd_symbol **);
.  struct bfd_symbol *
.              (*_bfd_make_empty_symbol) (bfd *);
d347 2
a348 2
.    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
.#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
d350 3
a352 3
.    (bfd *, struct bfd_symbol *, symbol_info *);
.#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
.  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
d354 1
a354 1
.  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
d356 2
a357 2
.    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
.     const char **, const char **, unsigned int *);
d362 1
a362 1
.    (bfd *, void *, unsigned long size);
d366 1
a366 1
.    (bfd *, bfd_boolean, void **, unsigned int *);
d370 1
a370 1
.    (bfd *, bfd_boolean, const void *, asymbol *);
d374 4
a377 5
.  NAME##_get_reloc_upper_bound, \
.  NAME##_canonicalize_reloc, \
.  NAME##_bfd_reloc_type_lookup
.
.  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
d379 1
a379 1
.    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
d382 1
a382 1
.              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
d386 2
a387 3
.  NAME##_set_arch_mach, \
.  NAME##_set_section_contents
.
d389 1
a389 1
.    (bfd *, enum bfd_architecture, unsigned long);
d391 1
a391 1
.    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
d395 13
a407 14
.  NAME##_sizeof_headers, \
.  NAME##_bfd_get_relocated_section_contents, \
.  NAME##_bfd_relax_section, \
.  NAME##_bfd_link_hash_table_create, \
.  NAME##_bfd_link_hash_table_free, \
.  NAME##_bfd_link_add_symbols, \
.  NAME##_bfd_link_just_syms, \
.  NAME##_bfd_final_link, \
.  NAME##_bfd_link_split_section, \
.  NAME##_bfd_gc_sections, \
.  NAME##_bfd_merge_sections, \
.  NAME##_bfd_discard_group
.
.  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
d409 2
a410 2
.    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
.     bfd_byte *, bfd_boolean, struct bfd_symbol **);
d413 1
a413 1
.    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
d418 1
a418 1
.              (*_bfd_link_hash_table_create) (bfd *);
d421 2
a422 1
.  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
d425 2
a426 1
.  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
d429 2
a430 1
.  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
d434 1
a434 1
.  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
d437 1
a437 1
.  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
d440 1
a440 1
.  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
d443 1
a443 1
.  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
d446 1
a446 1
.  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
d450 4
a453 5
.  NAME##_get_dynamic_symtab_upper_bound, \
.  NAME##_canonicalize_dynamic_symtab, \
.  NAME##_get_dynamic_reloc_upper_bound, \
.  NAME##_canonicalize_dynamic_reloc
.
d455 1
a455 1
.  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
d458 1
a458 1
.    (bfd *, struct bfd_symbol **);
d460 1
a460 1
.  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
d463 1
a463 1
.    (bfd *, arelent **, struct bfd_symbol **);
d478 1
a478 1
.  const void *backend_data;
a523 1
extern const bfd_target bfd_elf32_frvfdpic_vec;
a542 3
extern const bfd_target bfd_elf32_m32rle_vec;
extern const bfd_target bfd_elf32_m32rlin_vec;
extern const bfd_target bfd_elf32_m32rlelin_vec;
d590 2
a743 1
extern const bfd_target bfd_elf32_am33lin_vec;
a811 1
	&bfd_elf32_frvfdpic_vec,
a832 3
        &bfd_elf32_m32rle_vec,
        &bfd_elf32_m32rlin_vec,
        &bfd_elf32_m32rlelin_vec,
d885 2
d902 1
d904 1
a1061 1
	&bfd_elf32_am33lin_vec,
d1159 2
d1164 2
a1165 1
find_target (const char *name)
d1206 2
a1207 1
bfd_set_default_target (const char *name)
d1243 3
a1245 1
bfd_find_target (const char *target_name, bfd *abfd)
d1291 1
a1291 1
bfd_target_list (void)
d1293 1
a1293 1
  int vec_length = 0;
d1307 1
a1307 1
  name_ptr = name_list = bfd_malloc (amt);
d1326 3
a1328 3
	const bfd_target *bfd_search_for_target
	  (int (*search_func) (const bfd_target *, void *),
	   void *);
d1339 3
a1341 2
bfd_search_for_target (int (*search_func) (const bfd_target *, void *),
		       void *data)
d1343 1
a1343 1
  const bfd_target * const *target;
d1345 3
a1347 3
  for (target = bfd_target_vector; *target != NULL; target ++)
    if (search_func (*target, data))
      return *target;
@


