head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.09;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.15;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.12;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.00.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.43;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.00;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.36;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.19.18;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.42;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.25.30;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.17;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.28;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ELF executable support for BFD.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.

   Written by Fred Fish @@ Cygnus Support, from information published
   in "UNIX System V Release 4, Programmers Guide: ANSI C and
   Programming Support Tools".  Sufficient support for gdb.

   Rewritten by Mark Eichin @@ Cygnus Support, from information
   published in "System V Application Binary Interface", chapters 4
   and 5, as well as the various "Processor Supplement" documents
   derived from it. Added support for assembler and other object file
   utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael
   Meissner (Open Software Foundation), and Peter Hoogenboom (University
   of Utah) to finish and extend this.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Problems and other issues to resolve.

   (1)	BFD expects there to be some fixed number of "sections" in
        the object file.  I.E. there is a "section_count" variable in the
	bfd structure which contains the number of sections.  However, ELF
	supports multiple "views" of a file.  In particular, with current
	implementations, executable files typically have two tables, a
	program header table and a section header table, both of which
	partition the executable.

	In ELF-speak, the "linking view" of the file uses the section header
	table to access "sections" within the file, and the "execution view"
	uses the program header table to access "segments" within the file.
	"Segments" typically may contain all the data from one or more
	"sections".

	Note that the section header table is optional in ELF executables,
	but it is this information that is most useful to gdb.  If the
	section header table is missing, then gdb should probably try
	to make do with the program header table.  (FIXME)

   (2)  The code in this file is compiled twice, once in 32-bit mode and
	once in 64-bit mode.  More of it should be made size-independent
	and moved into elf.c.

   (3)	ELF section symbols are handled rather sloppily now.  This should
	be cleaned up, and ELF section symbols reconciled with BFD section
	symbols.

   (4)  We need a published spec for 64-bit ELF.  We've got some stuff here
	that we're using for SPARC V9 64-bit chips, but don't assume that
	it's cast in stone.
 */

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"

/* Renaming structures, typedefs, macros and functions to be size-specific.  */
#define Elf_External_Ehdr	NAME(Elf,External_Ehdr)
#define Elf_External_Sym	NAME(Elf,External_Sym)
#define Elf_External_Shdr	NAME(Elf,External_Shdr)
#define Elf_External_Phdr	NAME(Elf,External_Phdr)
#define Elf_External_Rel	NAME(Elf,External_Rel)
#define Elf_External_Rela	NAME(Elf,External_Rela)
#define Elf_External_Dyn	NAME(Elf,External_Dyn)

#define elf_core_file_failing_command	NAME(bfd_elf,core_file_failing_command)
#define elf_core_file_failing_signal	NAME(bfd_elf,core_file_failing_signal)
#define elf_core_file_matches_executable_p \
  NAME(bfd_elf,core_file_matches_executable_p)
#define elf_object_p			NAME(bfd_elf,object_p)
#define elf_core_file_p			NAME(bfd_elf,core_file_p)
#define elf_get_symtab_upper_bound	NAME(bfd_elf,get_symtab_upper_bound)
#define elf_get_dynamic_symtab_upper_bound \
  NAME(bfd_elf,get_dynamic_symtab_upper_bound)
#define elf_swap_reloc_in		NAME(bfd_elf,swap_reloc_in)
#define elf_swap_reloca_in		NAME(bfd_elf,swap_reloca_in)
#define elf_swap_reloc_out		NAME(bfd_elf,swap_reloc_out)
#define elf_swap_reloca_out		NAME(bfd_elf,swap_reloca_out)
#define elf_swap_symbol_in		NAME(bfd_elf,swap_symbol_in)
#define elf_swap_symbol_out		NAME(bfd_elf,swap_symbol_out)
#define elf_swap_phdr_in		NAME(bfd_elf,swap_phdr_in)
#define elf_swap_phdr_out		NAME(bfd_elf,swap_phdr_out)
#define elf_swap_dyn_in			NAME(bfd_elf,swap_dyn_in)
#define elf_swap_dyn_out		NAME(bfd_elf,swap_dyn_out)
#define elf_get_reloc_upper_bound	NAME(bfd_elf,get_reloc_upper_bound)
#define elf_canonicalize_reloc		NAME(bfd_elf,canonicalize_reloc)
#define elf_slurp_symbol_table		NAME(bfd_elf,slurp_symbol_table)
#define elf_canonicalize_symtab		NAME(bfd_elf,canonicalize_symtab)
#define elf_canonicalize_dynamic_symtab \
  NAME(bfd_elf,canonicalize_dynamic_symtab)
#define elf_make_empty_symbol		NAME(bfd_elf,make_empty_symbol)
#define elf_get_symbol_info		NAME(bfd_elf,get_symbol_info)
#define elf_get_lineno			NAME(bfd_elf,get_lineno)
#define elf_set_arch_mach		NAME(bfd_elf,set_arch_mach)
#define elf_find_nearest_line		NAME(bfd_elf,find_nearest_line)
#define elf_sizeof_headers		NAME(bfd_elf,sizeof_headers)
#define elf_set_section_contents	NAME(bfd_elf,set_section_contents)
#define elf_no_info_to_howto		NAME(bfd_elf,no_info_to_howto)
#define elf_no_info_to_howto_rel	NAME(bfd_elf,no_info_to_howto_rel)
#define elf_find_section		NAME(bfd_elf,find_section)
#define elf_write_shdrs_and_ehdr	NAME(bfd_elf,write_shdrs_and_ehdr)
#define elf_write_out_phdrs		NAME(bfd_elf,write_out_phdrs)
#define elf_write_relocs		NAME(bfd_elf,write_relocs)
#define elf_slurp_reloc_table		NAME(bfd_elf,slurp_reloc_table)

#if ARCH_SIZE == 64
#define ELF_R_INFO(X,Y)	ELF64_R_INFO(X,Y)
#define ELF_R_SYM(X)	ELF64_R_SYM(X)
#define ELF_R_TYPE(X)	ELF64_R_TYPE(X)
#define ELFCLASS	ELFCLASS64
#define FILE_ALIGN	8
#define LOG_FILE_ALIGN	3
#endif
#if ARCH_SIZE == 32
#define ELF_R_INFO(X,Y)	ELF32_R_INFO(X,Y)
#define ELF_R_SYM(X)	ELF32_R_SYM(X)
#define ELF_R_TYPE(X)	ELF32_R_TYPE(X)
#define ELFCLASS	ELFCLASS32
#define FILE_ALIGN	4
#define LOG_FILE_ALIGN	2
#endif

#ifdef DEBUG
static void elf_debug_section (int, Elf_Internal_Shdr *);
static void elf_debug_file (Elf_Internal_Ehdr *);
static char *elf_symbol_flags (flagword);
#endif

/* Structure swapping routines */

/* Should perhaps use put_offset, put_word, etc.  For now, the two versions
   can be handled by explicitly specifying 32 bits or "the long type".  */
#if ARCH_SIZE == 64
#define H_PUT_WORD		H_PUT_64
#define H_PUT_SIGNED_WORD	H_PUT_S64
#define H_GET_WORD		H_GET_64
#define H_GET_SIGNED_WORD	H_GET_S64
#endif
#if ARCH_SIZE == 32
#define H_PUT_WORD		H_PUT_32
#define H_PUT_SIGNED_WORD	H_PUT_S32
#define H_GET_WORD		H_GET_32
#define H_GET_SIGNED_WORD	H_GET_S32
#endif

/* Translate an ELF symbol in external format into an ELF symbol in internal
   format.  */

void
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
{
  const Elf_External_Sym *src = psrc;
  const Elf_External_Sym_Shndx *shndx = pshn;
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->st_name = H_GET_32 (abfd, src->st_name);
  if (signed_vma)
    dst->st_value = H_GET_SIGNED_WORD (abfd, src->st_value);
  else
    dst->st_value = H_GET_WORD (abfd, src->st_value);
  dst->st_size = H_GET_WORD (abfd, src->st_size);
  dst->st_info = H_GET_8 (abfd, src->st_info);
  dst->st_other = H_GET_8 (abfd, src->st_other);
  dst->st_shndx = H_GET_16 (abfd, src->st_shndx);
  if (dst->st_shndx == SHN_XINDEX)
    {
      if (shndx == NULL)
	abort ();
      dst->st_shndx = H_GET_32 (abfd, shndx->est_shndx);
    }
}

/* Translate an ELF symbol in internal format into an ELF symbol in external
   format.  */

void
elf_swap_symbol_out (bfd *abfd,
		     const Elf_Internal_Sym *src,
		     void *cdst,
		     void *shndx)
{
  unsigned int tmp;
  Elf_External_Sym *dst = cdst;
  H_PUT_32 (abfd, src->st_name, dst->st_name);
  H_PUT_WORD (abfd, src->st_value, dst->st_value);
  H_PUT_WORD (abfd, src->st_size, dst->st_size);
  H_PUT_8 (abfd, src->st_info, dst->st_info);
  H_PUT_8 (abfd, src->st_other, dst->st_other);
  tmp = src->st_shndx;
  if (tmp > SHN_HIRESERVE)
    {
      if (shndx == NULL)
	abort ();
      H_PUT_32 (abfd, tmp, shndx);
      tmp = SHN_XINDEX;
    }
  H_PUT_16 (abfd, tmp, dst->st_shndx);
}

/* Translate an ELF file header in external format into an ELF file header in
   internal format.  */

static void
elf_swap_ehdr_in (bfd *abfd,
		  const Elf_External_Ehdr *src,
		  Elf_Internal_Ehdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
  memcpy (dst->e_ident, src->e_ident, EI_NIDENT);
  dst->e_type = H_GET_16 (abfd, src->e_type);
  dst->e_machine = H_GET_16 (abfd, src->e_machine);
  dst->e_version = H_GET_32 (abfd, src->e_version);
  if (signed_vma)
    dst->e_entry = H_GET_SIGNED_WORD (abfd, src->e_entry);
  else
    dst->e_entry = H_GET_WORD (abfd, src->e_entry);
  dst->e_phoff = H_GET_WORD (abfd, src->e_phoff);
  dst->e_shoff = H_GET_WORD (abfd, src->e_shoff);
  dst->e_flags = H_GET_32 (abfd, src->e_flags);
  dst->e_ehsize = H_GET_16 (abfd, src->e_ehsize);
  dst->e_phentsize = H_GET_16 (abfd, src->e_phentsize);
  dst->e_phnum = H_GET_16 (abfd, src->e_phnum);
  dst->e_shentsize = H_GET_16 (abfd, src->e_shentsize);
  dst->e_shnum = H_GET_16 (abfd, src->e_shnum);
  dst->e_shstrndx = H_GET_16 (abfd, src->e_shstrndx);
}

/* Translate an ELF file header in internal format into an ELF file header in
   external format.  */

static void
elf_swap_ehdr_out (bfd *abfd,
		   const Elf_Internal_Ehdr *src,
		   Elf_External_Ehdr *dst)
{
  unsigned int tmp;
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
  memcpy (dst->e_ident, src->e_ident, EI_NIDENT);
  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_16 (abfd, src->e_type, dst->e_type);
  H_PUT_16 (abfd, src->e_machine, dst->e_machine);
  H_PUT_32 (abfd, src->e_version, dst->e_version);
  if (signed_vma)
    H_PUT_SIGNED_WORD (abfd, src->e_entry, dst->e_entry);
  else
    H_PUT_WORD (abfd, src->e_entry, dst->e_entry);
  H_PUT_WORD (abfd, src->e_phoff, dst->e_phoff);
  H_PUT_WORD (abfd, src->e_shoff, dst->e_shoff);
  H_PUT_32 (abfd, src->e_flags, dst->e_flags);
  H_PUT_16 (abfd, src->e_ehsize, dst->e_ehsize);
  H_PUT_16 (abfd, src->e_phentsize, dst->e_phentsize);
  H_PUT_16 (abfd, src->e_phnum, dst->e_phnum);
  H_PUT_16 (abfd, src->e_shentsize, dst->e_shentsize);
  tmp = src->e_shnum;
  if (tmp >= SHN_LORESERVE)
    tmp = SHN_UNDEF;
  H_PUT_16 (abfd, tmp, dst->e_shnum);
  tmp = src->e_shstrndx;
  if (tmp >= SHN_LORESERVE)
    tmp = SHN_XINDEX;
  H_PUT_16 (abfd, tmp, dst->e_shstrndx);
}

/* Translate an ELF section header table entry in external format into an
   ELF section header table entry in internal format.  */

static void
elf_swap_shdr_in (bfd *abfd,
		  const Elf_External_Shdr *src,
		  Elf_Internal_Shdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->sh_name = H_GET_32 (abfd, src->sh_name);
  dst->sh_type = H_GET_32 (abfd, src->sh_type);
  dst->sh_flags = H_GET_WORD (abfd, src->sh_flags);
  if (signed_vma)
    dst->sh_addr = H_GET_SIGNED_WORD (abfd, src->sh_addr);
  else
    dst->sh_addr = H_GET_WORD (abfd, src->sh_addr);
  dst->sh_offset = H_GET_WORD (abfd, src->sh_offset);
  dst->sh_size = H_GET_WORD (abfd, src->sh_size);
  dst->sh_link = H_GET_32 (abfd, src->sh_link);
  dst->sh_info = H_GET_32 (abfd, src->sh_info);
  dst->sh_addralign = H_GET_WORD (abfd, src->sh_addralign);
  dst->sh_entsize = H_GET_WORD (abfd, src->sh_entsize);
  dst->bfd_section = NULL;
  dst->contents = NULL;
}

/* Translate an ELF section header table entry in internal format into an
   ELF section header table entry in external format.  */

static void
elf_swap_shdr_out (bfd *abfd,
		   const Elf_Internal_Shdr *src,
		   Elf_External_Shdr *dst)
{
  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_32 (abfd, src->sh_name, dst->sh_name);
  H_PUT_32 (abfd, src->sh_type, dst->sh_type);
  H_PUT_WORD (abfd, src->sh_flags, dst->sh_flags);
  H_PUT_WORD (abfd, src->sh_addr, dst->sh_addr);
  H_PUT_WORD (abfd, src->sh_offset, dst->sh_offset);
  H_PUT_WORD (abfd, src->sh_size, dst->sh_size);
  H_PUT_32 (abfd, src->sh_link, dst->sh_link);
  H_PUT_32 (abfd, src->sh_info, dst->sh_info);
  H_PUT_WORD (abfd, src->sh_addralign, dst->sh_addralign);
  H_PUT_WORD (abfd, src->sh_entsize, dst->sh_entsize);
}

/* Translate an ELF program header table entry in external format into an
   ELF program header table entry in internal format.  */

void
elf_swap_phdr_in (bfd *abfd,
		  const Elf_External_Phdr *src,
		  Elf_Internal_Phdr *dst)
{
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

  dst->p_type = H_GET_32 (abfd, src->p_type);
  dst->p_flags = H_GET_32 (abfd, src->p_flags);
  dst->p_offset = H_GET_WORD (abfd, src->p_offset);
  if (signed_vma)
    {
      dst->p_vaddr = H_GET_SIGNED_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_SIGNED_WORD (abfd, src->p_paddr);
    }
  else
    {
      dst->p_vaddr = H_GET_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_WORD (abfd, src->p_paddr);
    }
  dst->p_filesz = H_GET_WORD (abfd, src->p_filesz);
  dst->p_memsz = H_GET_WORD (abfd, src->p_memsz);
  dst->p_align = H_GET_WORD (abfd, src->p_align);
}

void
elf_swap_phdr_out (bfd *abfd,
		   const Elf_Internal_Phdr *src,
		   Elf_External_Phdr *dst)
{
  /* note that all elements of dst are *arrays of unsigned char* already...  */
  H_PUT_32 (abfd, src->p_type, dst->p_type);
  H_PUT_WORD (abfd, src->p_offset, dst->p_offset);
  H_PUT_WORD (abfd, src->p_vaddr, dst->p_vaddr);
  H_PUT_WORD (abfd, src->p_paddr, dst->p_paddr);
  H_PUT_WORD (abfd, src->p_filesz, dst->p_filesz);
  H_PUT_WORD (abfd, src->p_memsz, dst->p_memsz);
  H_PUT_32 (abfd, src->p_flags, dst->p_flags);
  H_PUT_WORD (abfd, src->p_align, dst->p_align);
}

/* Translate an ELF reloc from external format to internal format.  */
void
elf_swap_reloc_in (bfd *abfd,
		   const bfd_byte *s,
		   Elf_Internal_Rela *dst)
{
  const Elf_External_Rel *src = (const Elf_External_Rel *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = 0;
}

void
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
{
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = H_GET_SIGNED_WORD (abfd, src->r_addend);
}

/* Translate an ELF reloc from internal format to external format.  */
void
elf_swap_reloc_out (bfd *abfd,
		    const Elf_Internal_Rela *src,
		    bfd_byte *d)
{
  Elf_External_Rel *dst = (Elf_External_Rel *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
}

void
elf_swap_reloca_out (bfd *abfd,
		     const Elf_Internal_Rela *src,
		     bfd_byte *d)
{
  Elf_External_Rela *dst = (Elf_External_Rela *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
  H_PUT_SIGNED_WORD (abfd, src->r_addend, dst->r_addend);
}

void
elf_swap_dyn_in (bfd *abfd,
		 const void *p,
		 Elf_Internal_Dyn *dst)
{
  const Elf_External_Dyn *src = p;

  dst->d_tag = H_GET_WORD (abfd, src->d_tag);
  dst->d_un.d_val = H_GET_WORD (abfd, src->d_un.d_val);
}

void
elf_swap_dyn_out (bfd *abfd,
		  const Elf_Internal_Dyn *src,
		  void *p)
{
  Elf_External_Dyn *dst = p;

  H_PUT_WORD (abfd, src->d_tag, dst->d_tag);
  H_PUT_WORD (abfd, src->d_un.d_val, dst->d_un.d_val);
}

/* ELF .o/exec file reading */

/* Begin processing a given object.

   First we validate the file by reading in the ELF header and checking
   the magic number.  */

static inline bfd_boolean
elf_file_p (Elf_External_Ehdr *x_ehdrp)
{
  return ((x_ehdrp->e_ident[EI_MAG0] == ELFMAG0)
	  && (x_ehdrp->e_ident[EI_MAG1] == ELFMAG1)
	  && (x_ehdrp->e_ident[EI_MAG2] == ELFMAG2)
	  && (x_ehdrp->e_ident[EI_MAG3] == ELFMAG3));
}

/* Check to see if the file associated with ABFD matches the target vector
   that ABFD points to.

   Note that we may be called several times with the same ABFD, but different
   target vectors, most of which will not match.  We have to avoid leaving
   any side effects in ABFD, or any data it points to (like tdata), if the
   file does not match the target vector.  */

const bfd_target *
elf_object_p (bfd *abfd)
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_External_Shdr x_shdr;	/* Section header table entry, external form */
  Elf_Internal_Shdr i_shdr;
  Elf_Internal_Shdr *i_shdrp;	/* Section header table, internal form */
  unsigned int shindex;
  char *shstrtab;		/* Internal copy of section header stringtab */
  const struct elf_backend_data *ebd;
  struct bfd_preserve preserve;
  asection *s;
  bfd_size_type amt;

  preserve.marker = NULL;

  /* Read in the ELF header in external format.  */

  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry, and it must have a
     section header table (FIXME: See comments re sections at top of this
     file).  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    goto got_wrong_format_error;

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (abfd))
	goto got_wrong_format_error;
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (abfd))
	goto got_wrong_format_error;
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      goto got_wrong_format_error;
    }

  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

  /* Allocate an instance of the elf_obj_tdata structure and hook it up to
     the tdata pointer in the bfd.  */

  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
    goto got_no_match;
  preserve.marker = elf_tdata (abfd);

  /* Now that we know the byte order, swap in the rest of the header */
  i_ehdrp = elf_elfheader (abfd);
  elf_swap_ehdr_in (abfd, &x_ehdr, i_ehdrp);
#if DEBUG & 1
  elf_debug_file (i_ehdrp);
#endif

  /* Reject ET_CORE (header indicates core file, not object file) */
  if (i_ehdrp->e_type == ET_CORE)
    goto got_wrong_format_error;

  /* If this is a relocatable file and there is no section header
     table, then we're hosed.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_type == ET_REL)
    goto got_wrong_format_error;

  /* As a simple sanity check, verify that the what BFD thinks is the
     size of each section header table entry actually matches the size
     recorded in the file, but only if there are any sections.  */
  if (i_ehdrp->e_shentsize != sizeof (x_shdr) && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

  /* Further sanity check.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

  ebd = get_elf_backend_data (abfd);

  /* Check that the ELF e_machine field matches what this particular
     BFD format expects.  */
  if (ebd->elf_machine_code != i_ehdrp->e_machine
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
    {
      const bfd_target * const *target_ptr;

      if (ebd->elf_machine_code != EM_NONE)
	goto got_wrong_format_error;

      /* This is the generic ELF target.  Let it match any ELF target
	 for which we do not have a specific backend.  */
      for (target_ptr = bfd_target_vector; *target_ptr != NULL; target_ptr++)
	{
	  const struct elf_backend_data *back;

	  if ((*target_ptr)->flavour != bfd_target_elf_flavour)
	    continue;
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
		  && back->elf_machine_alt1 == i_ehdrp->e_machine)
	      || (back->elf_machine_alt2 != 0
		  && back->elf_machine_alt2 == i_ehdrp->e_machine))
	    {
	      /* target_ptr is an ELF backend which matches this
		 object file, so reject the generic ELF target.  */
	      goto got_wrong_format_error;
	    }
	}
    }

  if (i_ehdrp->e_type == ET_EXEC)
    abfd->flags |= EXEC_P;
  else if (i_ehdrp->e_type == ET_DYN)
    abfd->flags |= DYNAMIC;

  if (i_ehdrp->e_phnum > 0)
    abfd->flags |= D_PAGED;

  if (! bfd_default_set_arch_mach (abfd, ebd->arch, 0))
    {
      /* It's OK if this fails for the generic target.  */
      if (ebd->elf_machine_code != EM_NONE)
	goto got_no_match;
    }

  /* Remember the entry point specified in the ELF file header.  */
  bfd_set_start_address (abfd, i_ehdrp->e_entry);

  if (i_ehdrp->e_shoff != 0)
    {
      /* Seek to the section header table in the file.  */
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
	goto got_no_match;

      /* Read the first section header at index 0, and convert to internal
	 form.  */
      if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);

      /* If the section count is zero, the actual count is in the first
	 section header.  */
      if (i_ehdrp->e_shnum == SHN_UNDEF)
	i_ehdrp->e_shnum = i_shdr.sh_size;

      /* And similarly for the string table index.  */
      if (i_ehdrp->e_shstrndx == SHN_XINDEX)
	i_ehdrp->e_shstrndx = i_shdr.sh_link;
    }

  /* Allocate space for a copy of the section header table in
     internal form.  */
  if (i_ehdrp->e_shnum != 0)
    {
      Elf_Internal_Shdr *shdrp;
      unsigned int num_sec;

      amt = sizeof (*i_shdrp) * i_ehdrp->e_shnum;
      i_shdrp = bfd_alloc (abfd, amt);
      if (!i_shdrp)
	goto got_no_match;
      num_sec = i_ehdrp->e_shnum;
      if (num_sec > SHN_LORESERVE)
	num_sec += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      elf_numsections (abfd) = num_sec;
      amt = sizeof (i_shdrp) * num_sec;
      elf_elfsections (abfd) = bfd_alloc (abfd, amt);
      if (!elf_elfsections (abfd))
	goto got_no_match;

      memcpy (i_shdrp, &i_shdr, sizeof (*i_shdrp));
      shdrp = i_shdrp;
      shindex = 0;
      if (num_sec > SHN_LORESERVE)
	{
	  for ( ; shindex < SHN_LORESERVE; shindex++)
	    elf_elfsections (abfd)[shindex] = shdrp++;
	  for ( ; shindex < SHN_HIRESERVE + 1; shindex++)
	    elf_elfsections (abfd)[shindex] = i_shdrp;
	}
      for ( ; shindex < num_sec; shindex++)
	elf_elfsections (abfd)[shindex] = shdrp++;

      /* Read in the rest of the section header table and convert it
	 to internal form.  */
      for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
	{
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
	    goto got_no_match;
	  elf_swap_shdr_in (abfd, &x_shdr, i_shdrp + shindex);

	  /* If the section is loaded, but not page aligned, clear
	     D_PAGED.  */
	  if (i_shdrp[shindex].sh_size != 0
	      && (i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	      && i_shdrp[shindex].sh_type != SHT_NOBITS
	      && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
		   % ebd->maxpagesize)
		  != 0))
	    abfd->flags &= ~D_PAGED;
	}
    }

  if (i_ehdrp->e_shstrndx && i_ehdrp->e_shoff)
    {
      if (! bfd_section_from_shdr (abfd, i_ehdrp->e_shstrndx))
	goto got_no_match;
    }

  /* Read in the program headers.  */
  if (i_ehdrp->e_phnum == 0)
    elf_tdata (abfd)->phdr = NULL;
  else
    {
      Elf_Internal_Phdr *i_phdr;
      unsigned int i;

      amt = i_ehdrp->e_phnum * sizeof (Elf_Internal_Phdr);
      elf_tdata (abfd)->phdr = bfd_alloc (abfd, amt);
      if (elf_tdata (abfd)->phdr == NULL)
	goto got_no_match;
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
	goto got_no_match;
      i_phdr = elf_tdata (abfd)->phdr;
      for (i = 0; i < i_ehdrp->e_phnum; i++, i_phdr++)
	{
	  Elf_External_Phdr x_phdr;

	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
	    goto got_no_match;
	  elf_swap_phdr_in (abfd, &x_phdr, i_phdr);
	}
    }

  /* Read in the string table containing the names of the sections.  We
     will need the base pointer to this table later.  */
  /* We read this inline now, so that we don't have to go through
     bfd_section_from_shdr with it (since this particular strtab is
     used to find all of the ELF section names.) */

  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff)
    {
      unsigned int num_sec;

      shstrtab = bfd_elf_get_str_section (abfd, i_ehdrp->e_shstrndx);
      if (!shstrtab)
	goto got_no_match;

      /* Once all of the section headers have been read and converted, we
	 can start processing them.  Note that the first section header is
	 a dummy placeholder entry, so we ignore it.  */
      num_sec = elf_numsections (abfd);
      for (shindex = 1; shindex < num_sec; shindex++)
	{
	  if (! bfd_section_from_shdr (abfd, shindex))
	    goto got_no_match;
	  if (shindex == SHN_LORESERVE - 1)
	    shindex += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
    }

  /* Let the backend double check the format and override global
     information.  */
  if (ebd->elf_backend_object_p)
    {
      if (! (*ebd->elf_backend_object_p) (abfd))
	goto got_wrong_format_error;
    }

  /* If we have created any reloc sections that are associated with
     debugging sections, mark the reloc sections as debugging as well.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((elf_section_data (s)->this_hdr.sh_type == SHT_REL
	   || elf_section_data (s)->this_hdr.sh_type == SHT_RELA)
	  && elf_section_data (s)->this_hdr.sh_info > 0)
	{
	  unsigned long targ_index;
	  asection *targ_sec;

	  targ_index = elf_section_data (s)->this_hdr.sh_info;
	  targ_sec = bfd_section_from_elf_index (abfd, targ_index);
	  if (targ_sec != NULL
	      && (targ_sec->flags & SEC_DEBUGGING) != 0)
	    s->flags |= SEC_DEBUGGING;
	}
    }

  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;

 got_wrong_format_error:
  /* There is way too much undoing of half-known state here.  The caller,
     bfd_check_format_matches, really shouldn't iterate on live bfd's to
     check match/no-match like it does.  We have to rely on that a call to
     bfd_default_set_arch_mach with the previously known mach, undoes what
     was done by the first bfd_default_set_arch_mach (with mach 0) here.
     For this to work, only elf-data and the mach may be changed by the
     target-specific elf_backend_object_p function.  Note that saving the
     whole bfd here and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
  bfd_set_error (bfd_error_wrong_format);

 got_no_match:
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
  return NULL;
}

/* ELF .o/exec file writing */

/* Write out the relocs.  */

void
elf_write_relocs (bfd *abfd, asection *sec, void *data)
{
  bfd_boolean *failedp = data;
  Elf_Internal_Shdr *rela_hdr;
  bfd_vma addr_offset;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  size_t extsize;
  bfd_byte *dst_rela;
  unsigned int idx;
  asymbol *last_sym;
  int last_sym_idx;

  /* If we have already failed, don't do anything.  */
  if (*failedp)
    return;

  if ((sec->flags & SEC_RELOC) == 0)
    return;

  /* The linker backend writes the relocs out itself, and sets the
     reloc_count field to zero to inhibit writing them here.  Also,
     sometimes the SEC_RELOC flag gets set even when there aren't any
     relocs.  */
  if (sec->reloc_count == 0)
    return;

  rela_hdr = &elf_section_data (sec)->rel_hdr;

  rela_hdr->sh_size = rela_hdr->sh_entsize * sec->reloc_count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  /* Figure out whether the relocations are RELA or REL relocations.  */
  if (rela_hdr->sh_type == SHT_RELA)
    {
      swap_out = elf_swap_reloca_out;
      extsize = sizeof (Elf_External_Rela);
    }
  else if (rela_hdr->sh_type == SHT_REL)
    {
      swap_out = elf_swap_reloc_out;
      extsize = sizeof (Elf_External_Rel);
    }
  else
    /* Every relocation section should be either an SHT_RELA or an
       SHT_REL section.  */
    abort ();

  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;

  /* orelocation has the data, reloc_count has the count...  */
  last_sym = 0;
  last_sym_idx = 0;
  dst_rela = rela_hdr->contents;

  for (idx = 0; idx < sec->reloc_count; idx++, dst_rela += extsize)
    {
      Elf_Internal_Rela src_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      src_rela.r_offset = ptr->address + addr_offset;
      src_rela.r_info = ELF_R_INFO (n, ptr->howto->type);
      src_rela.r_addend = ptr->addend;
      (*swap_out) (abfd, &src_rela, dst_rela);
    }
}

/* Write out the program headers.  */

int
elf_write_out_phdrs (bfd *abfd,
		     const Elf_Internal_Phdr *phdr,
		     unsigned int count)
{
  while (count--)
    {
      Elf_External_Phdr extphdr;
      elf_swap_phdr_out (abfd, phdr, &extphdr);
      if (bfd_bwrite (&extphdr, sizeof (Elf_External_Phdr), abfd)
	  != sizeof (Elf_External_Phdr))
	return -1;
      phdr++;
    }
  return 0;
}

/* Write out the section headers and the ELF file header.  */

bfd_boolean
elf_write_shdrs_and_ehdr (bfd *abfd)
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_External_Shdr *x_shdrp;	/* Section header table, external form */
  Elf_Internal_Shdr **i_shdrp;	/* Section header table, internal form */
  unsigned int count;
  bfd_size_type amt;

  i_ehdrp = elf_elfheader (abfd);
  i_shdrp = elf_elfsections (abfd);

  /* swap the header before spitting it out...  */

#if DEBUG & 1
  elf_debug_file (i_ehdrp);
#endif
  elf_swap_ehdr_out (abfd, i_ehdrp, &x_ehdr);
  amt = sizeof (x_ehdr);
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)
    return FALSE;

  /* Some fields in the first section header handle overflow of ehdr
     fields.  */
  if (i_ehdrp->e_shnum >= SHN_LORESERVE)
    i_shdrp[0]->sh_size = i_ehdrp->e_shnum;
  if (i_ehdrp->e_shstrndx >= SHN_LORESERVE)
    i_shdrp[0]->sh_link = i_ehdrp->e_shstrndx;

  /* at this point we've concocted all the ELF sections...  */
  amt = i_ehdrp->e_shnum;
  amt *= sizeof (*x_shdrp);
  x_shdrp = bfd_alloc (abfd, amt);
  if (!x_shdrp)
    return FALSE;

  for (count = 0; count < i_ehdrp->e_shnum; i_shdrp++, count++)
    {
#if DEBUG & 2
      elf_debug_section (count, *i_shdrp);
#endif
      elf_swap_shdr_out (abfd, *i_shdrp, x_shdrp + count);

      if (count == SHN_LORESERVE - 1)
	i_shdrp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
    }
  if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0
      || bfd_bwrite (x_shdrp, amt, abfd) != amt)
    return FALSE;

  /* need to dump the string table too...  */

  return TRUE;
}

long
elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
{
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Shdr *verhdr;
  unsigned long symcount;	/* Number of external ELF symbols */
  elf_symbol_type *sym;		/* Pointer to current bfd symbol */
  elf_symbol_type *symbase;	/* Buffer for generated bfd symbols */
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_External_Versym *xver;
  Elf_External_Versym *xverbuf = NULL;
  const struct elf_backend_data *ebd;
  bfd_size_type amt;

  /* Read each raw ELF symbol, converting from external ELF form to
     internal ELF form, and then using the information to create a
     canonical bfd symbol table entry.

     Note that we allocate the initial bfd canonical symbol buffer
     based on a one-to-one mapping of the ELF symbols to canonical
     symbols.  We actually use all the ELF symbols, so there will be no
     space left over at the end.  When we have all the symbols, we
     build the caller's pointer vector.  */

  if (! dynamic)
    {
      hdr = &elf_tdata (abfd)->symtab_hdr;
      verhdr = NULL;
    }
  else
    {
      hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      if (elf_dynversym (abfd) == 0)
	verhdr = NULL;
      else
	verhdr = &elf_tdata (abfd)->dynversym_hdr;
      if ((elf_tdata (abfd)->dynverdef_section != 0
	   && elf_tdata (abfd)->verdef == NULL)
	  || (elf_tdata (abfd)->dynverref_section != 0
	      && elf_tdata (abfd)->verref == NULL))
	{
	  if (! _bfd_elf_slurp_version_tables (abfd))
	    return -1;
	}
    }

  ebd = get_elf_backend_data (abfd);
  symcount = hdr->sh_size / sizeof (Elf_External_Sym);
  if (symcount == 0)
    sym = symbase = NULL;
  else
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return -1;

      amt = symcount;
      amt *= sizeof (elf_symbol_type);
      symbase = bfd_zalloc (abfd, amt);
      if (symbase == (elf_symbol_type *) NULL)
	goto error_return;

      /* Read the raw ELF version symbol information.  */
      if (verhdr != NULL
	  && verhdr->sh_size / sizeof (Elf_External_Versym) != symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s: version count (%ld) does not match symbol count (%ld)"),
	     abfd->filename,
	     (long) (verhdr->sh_size / sizeof (Elf_External_Versym)),
	     symcount);

	  /* Slurp in the symbols without the version information,
             since that is more helpful than just quitting.  */
	  verhdr = NULL;
	}

      if (verhdr != NULL)
	{
	  if (bfd_seek (abfd, verhdr->sh_offset, SEEK_SET) != 0)
	    goto error_return;

	  xverbuf = bfd_malloc (verhdr->sh_size);
	  if (xverbuf == NULL && verhdr->sh_size != 0)
	    goto error_return;

	  if (bfd_bread (xverbuf, verhdr->sh_size, abfd) != verhdr->sh_size)
	    goto error_return;
	}

      /* Skip first symbol, which is a null dummy.  */
      xver = xverbuf;
      if (xver != NULL)
	++xver;
      isymend = isymbuf + symcount;
      for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
	{
	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));
	  sym->symbol.the_bfd = abfd;

	  sym->symbol.name = bfd_elf_string_from_elf_section (abfd,
							      hdr->sh_link,
							      isym->st_name);

	  sym->symbol.value = isym->st_value;

	  if (isym->st_shndx == SHN_UNDEF)
	    {
	      sym->symbol.section = bfd_und_section_ptr;
	    }
	  else if (isym->st_shndx < SHN_LORESERVE
		   || isym->st_shndx > SHN_HIRESERVE)
	    {
	      sym->symbol.section = bfd_section_from_elf_index (abfd,
								isym->st_shndx);
	      if (sym->symbol.section == NULL)
		{
		  /* This symbol is in a section for which we did not
		     create a BFD section.  Just use bfd_abs_section,
		     although it is wrong.  FIXME.  */
		  sym->symbol.section = bfd_abs_section_ptr;
		}
	    }
	  else if (isym->st_shndx == SHN_ABS)
	    {
	      sym->symbol.section = bfd_abs_section_ptr;
	    }
	  else if (isym->st_shndx == SHN_COMMON)
	    {
	      sym->symbol.section = bfd_com_section_ptr;
	      /* Elf puts the alignment into the `value' field, and
		 the size into the `size' field.  BFD wants to see the
		 size in the value field, and doesn't care (at the
		 moment) about the alignment.  */
	      sym->symbol.value = isym->st_size;
	    }
	  else
	    sym->symbol.section = bfd_abs_section_ptr;

	  /* If this is a relocatable file, then the symbol value is
             already section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    sym->symbol.value -= sym->symbol.section->vma;

	  switch (ELF_ST_BIND (isym->st_info))
	    {
	    case STB_LOCAL:
	      sym->symbol.flags |= BSF_LOCAL;
	      break;
	    case STB_GLOBAL:
	      if (isym->st_shndx != SHN_UNDEF && isym->st_shndx != SHN_COMMON)
		sym->symbol.flags |= BSF_GLOBAL;
	      break;
	    case STB_WEAK:
	      sym->symbol.flags |= BSF_WEAK;
	      break;
	    }

	  switch (ELF_ST_TYPE (isym->st_info))
	    {
	    case STT_SECTION:
	      sym->symbol.flags |= BSF_SECTION_SYM | BSF_DEBUGGING;
	      break;
	    case STT_FILE:
	      sym->symbol.flags |= BSF_FILE | BSF_DEBUGGING;
	      break;
	    case STT_FUNC:
	      sym->symbol.flags |= BSF_FUNCTION;
	      break;
	    case STT_OBJECT:
	      sym->symbol.flags |= BSF_OBJECT;
	      break;
	    }

	  if (dynamic)
	    sym->symbol.flags |= BSF_DYNAMIC;

	  if (xver != NULL)
	    {
	      Elf_Internal_Versym iversym;

	      _bfd_elf_swap_versym_in (abfd, xver, &iversym);
	      sym->version = iversym.vs_vers;
	      xver++;
	    }

	  /* Do some backend-specific processing on this symbol.  */
	  if (ebd->elf_backend_symbol_processing)
	    (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
	}
    }

  /* Do some backend-specific processing on this symbol table.  */
  if (ebd->elf_backend_symbol_table_processing)
    (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);

  /* We rely on the zalloc to clear out the final symbol entry.  */

  symcount = sym - symbase;

  /* Fill in the user's symbol pointer vector if needed.  */
  if (symptrs)
    {
      long l = symcount;

      sym = symbase;
      while (l-- > 0)
	{
	  *symptrs++ = &sym->symbol;
	  sym++;
	}
      *symptrs = 0;		/* Final null pointer */
    }

  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return symcount;

error_return:
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return -1;
}

/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
   them.  */

static bfd_boolean
elf_slurp_reloc_table_from_section (bfd *abfd,
				    asection *asect,
				    Elf_Internal_Shdr *rel_hdr,
				    bfd_size_type reloc_count,
				    arelent *relents,
				    asymbol **symbols,
				    bfd_boolean dynamic)
{
  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
  void *allocated = NULL;
  bfd_byte *native_relocs;
  arelent *relent;
  unsigned int i;
  int entsize;
  unsigned int symcount;

  allocated = bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    goto error_return;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
    goto error_return;

  native_relocs = allocated;

  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf_External_Rel)
	      || entsize == sizeof (Elf_External_Rela));

  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

  for (i = 0, relent = relents;
       i < reloc_count;
       i++, relent++, native_relocs += entsize)
    {
      Elf_Internal_Rela rela;

      if (entsize == sizeof (Elf_External_Rela))
	elf_swap_reloca_in (abfd, native_relocs, &rela);
      else
	elf_swap_reloc_in (abfd, native_relocs, &rela);

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a normal BFD reloc is always section relative,
	 and the address of a dynamic reloc is absolute..  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
	relent->address = rela.r_offset;
      else
	relent->address = rela.r_offset - asect->vma;

      if (ELF_R_SYM (rela.r_info) == 0)
	relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
      else if (ELF_R_SYM (rela.r_info) > symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): relocation %d has invalid symbol index %ld"),
	     abfd->filename, asect->name, i, ELF_R_SYM (rela.r_info));
	  relent->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;
	}
      else
	{
	  asymbol **ps, *s;

	  ps = symbols + ELF_R_SYM (rela.r_info) - 1;
	  s = *ps;

	  /* Canonicalize ELF section symbols.  FIXME: Why?  */
	  if ((s->flags & BSF_SECTION_SYM) == 0)
	    relent->sym_ptr_ptr = ps;
	  else
	    relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
	}

      relent->addend = rela.r_addend;

      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
	(*ebd->elf_info_to_howto) (abfd, relent, &rela);
      else
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rela);
    }

  if (allocated != NULL)
    free (allocated);

  return TRUE;

 error_return:
  if (allocated != NULL)
    free (allocated);
  return FALSE;
}

/* Read in and swap the external relocs.  */

bfd_boolean
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));

    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }

  amt = (reloc_count + reloc_count2) * sizeof (arelent);
  relents = bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;

  if (!elf_slurp_reloc_table_from_section (abfd, asect,
					   rel_hdr, reloc_count,
					   relents,
					   symbols, dynamic))
    return FALSE;

  if (rel_hdr2
      && !elf_slurp_reloc_table_from_section (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count,
					      symbols, dynamic))
    return FALSE;

  asect->relocation = relents;
  return TRUE;
}

#ifdef DEBUG
static void
elf_debug_section (int num, Elf_Internal_Shdr *hdr)
{
  fprintf (stderr, "\nSection#%d '%s' 0x%.8lx\n", num,
	   hdr->bfd_section != NULL ? hdr->bfd_section->name : "",
	   (long) hdr);
  fprintf (stderr,
	   "sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n",
	   (long) hdr->sh_name,
	   (long) hdr->sh_type,
	   (long) hdr->sh_flags);
  fprintf (stderr,
	   "sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n",
	   (long) hdr->sh_addr,
	   (long) hdr->sh_offset,
	   (long) hdr->sh_size);
  fprintf (stderr,
	   "sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n",
	   (long) hdr->sh_link,
	   (long) hdr->sh_info,
	   (long) hdr->sh_addralign);
  fprintf (stderr, "sh_entsize   = %ld\n",
	   (long) hdr->sh_entsize);
  fflush (stderr);
}

static void
elf_debug_file (Elf_Internal_Ehdr *ehdrp)
{
  fprintf (stderr, "e_entry      = 0x%.8lx\n", (long) ehdrp->e_entry);
  fprintf (stderr, "e_phoff      = %ld\n", (long) ehdrp->e_phoff);
  fprintf (stderr, "e_phnum      = %ld\n", (long) ehdrp->e_phnum);
  fprintf (stderr, "e_phentsize  = %ld\n", (long) ehdrp->e_phentsize);
  fprintf (stderr, "e_shoff      = %ld\n", (long) ehdrp->e_shoff);
  fprintf (stderr, "e_shnum      = %ld\n", (long) ehdrp->e_shnum);
  fprintf (stderr, "e_shentsize  = %ld\n", (long) ehdrp->e_shentsize);
}

static char *
elf_symbol_flags (flagword flags)
{
  static char buffer[1024];

  buffer[0] = '\0';
  if (flags & BSF_LOCAL)
    strcat (buffer, " local");

  if (flags & BSF_GLOBAL)
    strcat (buffer, " global");

  if (flags & BSF_DEBUGGING)
    strcat (buffer, " debug");

  if (flags & BSF_FUNCTION)
    strcat (buffer, " function");

  if (flags & BSF_KEEP)
    strcat (buffer, " keep");

  if (flags & BSF_KEEP_G)
    strcat (buffer, " keep_g");

  if (flags & BSF_WEAK)
    strcat (buffer, " weak");

  if (flags & BSF_SECTION_SYM)
    strcat (buffer, " section-sym");

  if (flags & BSF_OLD_COMMON)
    strcat (buffer, " old-common");

  if (flags & BSF_NOT_AT_END)
    strcat (buffer, " not-at-end");

  if (flags & BSF_CONSTRUCTOR)
    strcat (buffer, " constructor");

  if (flags & BSF_WARNING)
    strcat (buffer, " warning");

  if (flags & BSF_INDIRECT)
    strcat (buffer, " indirect");

  if (flags & BSF_FILE)
    strcat (buffer, " file");

  if (flags & DYNAMIC)
    strcat (buffer, " dynamic");

  if (flags & ~(BSF_LOCAL
		| BSF_GLOBAL
		| BSF_DEBUGGING
		| BSF_FUNCTION
		| BSF_KEEP
		| BSF_KEEP_G
		| BSF_WEAK
		| BSF_SECTION_SYM
		| BSF_OLD_COMMON
		| BSF_NOT_AT_END
		| BSF_CONSTRUCTOR
		| BSF_WARNING
		| BSF_INDIRECT
		| BSF_FILE
		| BSF_DYNAMIC))
    strcat (buffer, " unknown-bits");

  return buffer;
}
#endif

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for a target with the word size and byte order found in the
   remote memory.  */

bfd *
NAME(_bfd_elf,bfd_from_remote_memory)
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
  Elf_External_Phdr *x_phdrs;
  Elf_Internal_Phdr *i_phdrs, *last_phdr;
  bfd *nbfd;
  struct bfd_in_memory *bim;
  int contents_size;
  char *contents;
  int err;
  unsigned int i;
  bfd_vma loadbase;

  /* Read in the ELF header in external format.  */
  err = target_read_memory (ehdr_vma, (char *) &x_ehdr, sizeof x_ehdr);
  if (err)
    {
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry.  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  elf_swap_ehdr_in (templ, &x_ehdr, &i_ehdr);

  /* The file header tells where to find the program headers.
     These are what we use to actually choose what to read.  */

  if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  x_phdrs = bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
  if (x_phdrs == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (char *) x_phdrs,
			    i_ehdr.e_phnum * sizeof x_phdrs[0]);
  if (err)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }
  i_phdrs = (Elf_Internal_Phdr *) &x_phdrs[i_ehdr.e_phnum];

  contents_size = 0;
  last_phdr = NULL;
  loadbase = ehdr_vma;
  for (i = 0; i < i_ehdr.e_phnum; ++i)
    {
      elf_swap_phdr_in (templ, &x_phdrs[i], &i_phdrs[i]);
      if (i_phdrs[i].p_type == PT_LOAD)
	{
	  bfd_vma segment_end;
	  segment_end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
			 + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	  if (segment_end > (bfd_vma) contents_size)
	    contents_size = segment_end;

	  if ((i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);

	  last_phdr = &i_phdrs[i];
	}
    }
  if (last_phdr == NULL)
    {
      /* There were no PT_LOAD segments, so we don't have anything to read.  */
      free (x_phdrs);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Trim the last segment so we don't bother with zeros in the last page
     that are off the end of the file.  However, if the extra bit in that
     page includes the section headers, keep them.  */
  if ((bfd_vma) contents_size > last_phdr->p_offset + last_phdr->p_filesz
      && (bfd_vma) contents_size >= (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      contents_size = last_phdr->p_offset + last_phdr->p_filesz;
      if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
	contents_size = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;
    }
  else
    contents_size = last_phdr->p_offset + last_phdr->p_filesz;

  /* Now we know the size of the whole image we want read in.  */
  contents = bfd_zmalloc (contents_size);
  if (contents == NULL)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  for (i = 0; i < i_ehdr.e_phnum; ++i)
    if (i_phdrs[i].p_type == PT_LOAD)
      {
	bfd_vma start = i_phdrs[i].p_offset & -i_phdrs[i].p_align;
	bfd_vma end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
		       + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	if (end > (bfd_vma) contents_size)
	  end = contents_size;
	err = target_read_memory ((loadbase + i_phdrs[i].p_vaddr)
				  & -i_phdrs[i].p_align,
				  contents + start, end - start);
	if (err)
	  {
	    free (x_phdrs);
	    free (contents);
	    bfd_set_error (bfd_error_system_call);
	    errno = err;
	    return NULL;
	  }
      }
  free (x_phdrs);

  /* If the segments visible in memory didn't include the section headers,
     then clear them from the file header.  */
  if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				 + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      memset (&x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);
      memset (&x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);
      memset (&x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);
    }

  /* This will normally have been in the first PT_LOAD segment.  But it
     conceivably could be missing, and we might have just changed it.  */
  memcpy (contents, &x_ehdr, sizeof x_ehdr);

  /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  if (bim == NULL)
    {
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      free (bim);
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd->filename = "<in-memory>";
  nbfd->xvec = templ->xvec;
  bim->size = contents_size;
  bim->buffer = contents;
  nbfd->iostream = bim;
  nbfd->flags = BFD_IN_MEMORY;
  nbfd->direction = read_direction;
  nbfd->mtime = time (NULL);
  nbfd->mtime_set = TRUE;

  if (loadbasep)
    *loadbasep = loadbase;
  return nbfd;
}

#include "elfcore.h"

/* Size-dependent data and functions.  */
const struct elf_size_info NAME(_bfd_elf,size_info) = {
  sizeof (Elf_External_Ehdr),
  sizeof (Elf_External_Phdr),
  sizeof (Elf_External_Shdr),
  sizeof (Elf_External_Rel),
  sizeof (Elf_External_Rela),
  sizeof (Elf_External_Sym),
  sizeof (Elf_External_Dyn),
  sizeof (Elf_External_Note),
  4,
  1,
  ARCH_SIZE, LOG_FILE_ALIGN,
  ELFCLASS, EV_CURRENT,
  elf_write_out_phdrs,
  elf_write_shdrs_and_ehdr,
  elf_write_relocs,
  elf_swap_symbol_in,
  elf_swap_symbol_out,
  elf_slurp_reloc_table,
  elf_slurp_symbol_table,
  elf_swap_dyn_in,
  elf_swap_dyn_out,
  elf_swap_reloc_in,
  elf_swap_reloc_out,
  elf_swap_reloca_in,
  elf_swap_reloca_out
};
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
d105 1
a105 1
#define elf_get_symtab			NAME(bfd_elf,get_symtab)
a117 2
#define elf_bfd_link_add_symbols	NAME(bfd_elf,bfd_link_add_symbols)
#define elf_add_dynamic_entry		NAME(bfd_elf,add_dynamic_entry)
a121 16
#define elf_link_create_dynamic_sections \
  NAME(bfd_elf,link_create_dynamic_sections)
#define elf_bfd_discard_info		NAME(bfd_elf,discard_info)
#define elf_reloc_symbol_deleted_p	NAME(_bfd_elf,reloc_symbol_deleted_p)
#define elf_link_record_dynamic_symbol  _bfd_elf_link_record_dynamic_symbol
#define elf_bfd_final_link		NAME(bfd_elf,bfd_final_link)
#define elf_create_pointer_linker_section NAME(bfd_elf,create_pointer_linker_section)
#define elf_finish_pointer_linker_section NAME(bfd_elf,finish_pointer_linker_section)
#define elf_gc_sections			NAME(_bfd_elf,gc_sections)
#define elf_gc_common_finalize_got_offsets \
  NAME(_bfd_elf,gc_common_finalize_got_offsets)
#define elf_gc_common_final_link	NAME(_bfd_elf,gc_common_final_link)
#define elf_gc_record_vtinherit		NAME(_bfd_elf,gc_record_vtinherit)
#define elf_gc_record_vtentry		NAME(_bfd_elf,gc_record_vtentry)
#define elf_link_record_local_dynamic_symbol \
  NAME(_bfd_elf,link_record_local_dynamic_symbol)
a139 21
/* Static functions */

static void elf_swap_ehdr_in
  PARAMS ((bfd *, const Elf_External_Ehdr *, Elf_Internal_Ehdr *));
static void elf_swap_ehdr_out
  PARAMS ((bfd *, const Elf_Internal_Ehdr *, Elf_External_Ehdr *));
static void elf_swap_shdr_in
  PARAMS ((bfd *, const Elf_External_Shdr *, Elf_Internal_Shdr *));
static void elf_swap_shdr_out
  PARAMS ((bfd *, const Elf_Internal_Shdr *, Elf_External_Shdr *));

#define elf_stringtab_init _bfd_elf_stringtab_init

#define section_from_elf_index bfd_section_from_elf_index

static bfd_boolean elf_slurp_reloc_table_from_section
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));

static bfd_boolean elf_file_p PARAMS ((Elf_External_Ehdr *));

d141 3
a143 3
static void elf_debug_section PARAMS ((int, Elf_Internal_Shdr *));
static void elf_debug_file PARAMS ((Elf_Internal_Ehdr *));
static char *elf_symbol_flags PARAMS ((flagword));
d167 4
a170 5
elf_swap_symbol_in (abfd, psrc, pshn, dst)
     bfd *abfd;
     const PTR psrc;
     const PTR pshn;
     Elf_Internal_Sym *dst;
d172 2
a173 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
d197 4
a200 5
elf_swap_symbol_out (abfd, src, cdst, shndx)
     bfd *abfd;
     const Elf_Internal_Sym *src;
     PTR cdst;
     PTR shndx;
d203 1
a203 1
  Elf_External_Sym *dst = (Elf_External_Sym *) cdst;
d224 3
a226 4
elf_swap_ehdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Ehdr *src;
     Elf_Internal_Ehdr *dst;
d252 3
a254 4
elf_swap_ehdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Ehdr *src;
     Elf_External_Ehdr *dst;
d288 3
a290 4
elf_swap_shdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Shdr *src;
     Elf_Internal_Shdr *dst;
d315 3
a317 4
elf_swap_shdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Shdr *src;
     Elf_External_Shdr *dst;
d336 3
a338 4
elf_swap_phdr_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Phdr *src;
     Elf_Internal_Phdr *dst;
d361 3
a363 4
elf_swap_phdr_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Phdr *src;
     Elf_External_Phdr *dst;
d378 3
a380 4
elf_swap_reloc_in (abfd, s, dst)
     bfd *abfd;
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
d389 3
a391 4
elf_swap_reloca_in (abfd, s, dst)
     bfd *abfd;
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
d401 3
a403 4
elf_swap_reloc_out (abfd, src, d)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *d;
d411 3
a413 4
elf_swap_reloca_out (abfd, src, d)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *d;
d421 4
a424 5
INLINE void
elf_swap_dyn_in (abfd, p, dst)
     bfd *abfd;
     const PTR p;
     Elf_Internal_Dyn *dst;
d426 1
a426 1
  const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;
d432 4
a435 5
INLINE void
elf_swap_dyn_out (abfd, src, p)
     bfd *abfd;
     const Elf_Internal_Dyn *src;
     PTR p;
d437 1
a437 1
  Elf_External_Dyn *dst = (Elf_External_Dyn *) p;
d450 2
a451 3
static INLINE bfd_boolean
elf_file_p (x_ehdrp)
     Elf_External_Ehdr *x_ehdrp;
d468 1
a468 2
elf_object_p (abfd)
     bfd *abfd;
d477 1
a477 1
  struct elf_backend_data *ebd;
d486 1
a486 2
  if (bfd_bread ((PTR) & x_ehdr, (bfd_size_type) sizeof (x_ehdr), abfd)
      != sizeof (x_ehdr))
d521 3
d527 1
a527 3
  amt = sizeof (struct elf_obj_tdata);
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
d529 1
a529 4
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

  elf_tdata (abfd) = preserve.marker;
d576 1
a576 1
	  struct elf_backend_data *back;
d580 1
a580 1
	  back = (struct elf_backend_data *) (*target_ptr)->backend_data;
d620 1
a620 2
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
d642 1
a642 1
      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d650 1
a650 1
      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
d671 1
a671 2
	  if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	      != sizeof (x_shdr))
d702 1
a702 1
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d712 1
a712 2
	  if (bfd_bread ((PTR) &x_phdr, (bfd_size_type) sizeof x_phdr, abfd)
	      != sizeof x_phdr)
d798 1
a798 4
elf_write_relocs (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d800 1
a800 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d803 1
a803 1
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d827 1
a827 1
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
d905 3
a907 4
elf_write_out_phdrs (abfd, phdr, count)
     bfd *abfd;
     const Elf_Internal_Phdr *phdr;
     unsigned int count;
d913 2
a914 2
      if (bfd_bwrite (&extphdr, (bfd_size_type) sizeof (Elf_External_Phdr),
		     abfd) != sizeof (Elf_External_Phdr))
d924 1
a924 2
elf_write_shdrs_and_ehdr (abfd)
     bfd *abfd;
d944 1
a944 1
      || bfd_bwrite ((PTR) & x_ehdr, amt, abfd) != amt)
d957 1
a957 1
  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);
d972 1
a972 1
      || bfd_bwrite ((PTR) x_shdrp, amt, abfd) != amt)
d981 1
a981 4
elf_slurp_symbol_table (abfd, symptrs, dynamic)
     bfd *abfd;
     asymbol **symptrs;		/* Buffer for generated bfd symbols */
     bfd_boolean dynamic;
d993 1
a993 1
  struct elf_backend_data *ebd;
d1041 1
a1041 1
      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d1065 1
a1065 1
	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
d1069 1
a1069 2
	  if (bfd_bread ((PTR) xverbuf, verhdr->sh_size, abfd)
	      != verhdr->sh_size)
d1096 2
a1097 2
	      sym->symbol.section = section_from_elf_index (abfd,
							    isym->st_shndx);
d1122 1
a1122 1
	  /* If this is a relocateable file, then the symbol value is
d1215 7
a1221 9
elf_slurp_reloc_table_from_section (abfd, asect, rel_hdr, reloc_count,
				    relents, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
     asymbol **symbols;
     bfd_boolean dynamic;
d1223 2
a1224 2
  struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
  PTR allocated = NULL;
d1231 1
a1231 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d1240 1
a1240 1
  native_relocs = (bfd_byte *) allocated;
d1318 4
a1321 5
elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     bfd_boolean dynamic;
d1366 1
a1366 1
  relents = (arelent *) bfd_alloc (abfd, amt);
d1389 1
a1389 3
elf_debug_section (num, hdr)
     int num;
     Elf_Internal_Shdr *hdr;
d1415 1
a1415 2
elf_debug_file (ehdrp)
     Elf_Internal_Ehdr *ehdrp;
d1427 1
a1427 2
elf_symbol_flags (flags)
     flagword flags;
d1498 223
a1721 1
#include "elflink.h"
d1735 1
a1735 1
  ARCH_SIZE, FILE_ALIGN,
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001 Free Software Foundation, Inc.
d69 1
d126 2
d173 1
a173 1
static boolean elf_slurp_reloc_table_from_section
d175 1
a175 1
	   arelent *, asymbol **, boolean));
d177 1
a177 1
static boolean elf_file_p PARAMS ((Elf_External_Ehdr *));
d190 4
a193 4
#define put_word	bfd_h_put_64
#define put_signed_word	bfd_h_put_signed_64
#define get_word	bfd_h_get_64
#define get_signed_word	bfd_h_get_signed_64
d196 4
a199 4
#define put_word	bfd_h_put_32
#define put_signed_word	bfd_h_put_signed_32
#define get_word	bfd_h_get_32
#define get_signed_word	bfd_h_get_signed_32
d206 1
a206 1
elf_swap_symbol_in (abfd, src, dst)
d208 2
a209 1
     const Elf_External_Sym *src;
d212 2
d216 1
a216 1
  dst->st_name = bfd_h_get_32 (abfd, (bfd_byte *) src->st_name);
d218 1
a218 1
    dst->st_value = get_signed_word (abfd, (bfd_byte *) src->st_value);
d220 11
a230 5
    dst->st_value = get_word (abfd, (bfd_byte *) src->st_value);
  dst->st_size = get_word (abfd, (bfd_byte *) src->st_size);
  dst->st_info = bfd_h_get_8 (abfd, (bfd_byte *) src->st_info);
  dst->st_other = bfd_h_get_8 (abfd, (bfd_byte *) src->st_other);
  dst->st_shndx = bfd_h_get_16 (abfd, (bfd_byte *) src->st_shndx);
d237 1
a237 1
elf_swap_symbol_out (abfd, src, cdst)
d241 1
d243 1
d245 14
a258 6
  bfd_h_put_32 (abfd, src->st_name, dst->st_name);
  put_word (abfd, src->st_value, dst->st_value);
  put_word (abfd, src->st_size, dst->st_size);
  bfd_h_put_8 (abfd, src->st_info, dst->st_info);
  bfd_h_put_8 (abfd, src->st_other, dst->st_other);
  bfd_h_put_16 (abfd, src->st_shndx, dst->st_shndx);
d272 3
a274 3
  dst->e_type = bfd_h_get_16 (abfd, (bfd_byte *) src->e_type);
  dst->e_machine = bfd_h_get_16 (abfd, (bfd_byte *) src->e_machine);
  dst->e_version = bfd_h_get_32 (abfd, (bfd_byte *) src->e_version);
d276 1
a276 1
    dst->e_entry = get_signed_word (abfd, (bfd_byte *) src->e_entry);
d278 10
a287 10
    dst->e_entry = get_word (abfd, (bfd_byte *) src->e_entry);
  dst->e_phoff = get_word (abfd, (bfd_byte *) src->e_phoff);
  dst->e_shoff = get_word (abfd, (bfd_byte *) src->e_shoff);
  dst->e_flags = bfd_h_get_32 (abfd, (bfd_byte *) src->e_flags);
  dst->e_ehsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_ehsize);
  dst->e_phentsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_phentsize);
  dst->e_phnum = bfd_h_get_16 (abfd, (bfd_byte *) src->e_phnum);
  dst->e_shentsize = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shentsize);
  dst->e_shnum = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shnum);
  dst->e_shstrndx = bfd_h_get_16 (abfd, (bfd_byte *) src->e_shstrndx);
d299 1
d303 3
a305 3
  bfd_h_put_16 (abfd, src->e_type, dst->e_type);
  bfd_h_put_16 (abfd, src->e_machine, dst->e_machine);
  bfd_h_put_32 (abfd, src->e_version, dst->e_version);
d307 1
a307 1
    put_signed_word (abfd, src->e_entry, dst->e_entry);
d309 16
a324 10
    put_word (abfd, src->e_entry, dst->e_entry);
  put_word (abfd, src->e_phoff, dst->e_phoff);
  put_word (abfd, src->e_shoff, dst->e_shoff);
  bfd_h_put_32 (abfd, src->e_flags, dst->e_flags);
  bfd_h_put_16 (abfd, src->e_ehsize, dst->e_ehsize);
  bfd_h_put_16 (abfd, src->e_phentsize, dst->e_phentsize);
  bfd_h_put_16 (abfd, src->e_phnum, dst->e_phnum);
  bfd_h_put_16 (abfd, src->e_shentsize, dst->e_shentsize);
  bfd_h_put_16 (abfd, src->e_shnum, dst->e_shnum);
  bfd_h_put_16 (abfd, src->e_shstrndx, dst->e_shstrndx);
d338 3
a340 3
  dst->sh_name = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_name);
  dst->sh_type = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_type);
  dst->sh_flags = get_word (abfd, (bfd_byte *) src->sh_flags);
d342 1
a342 1
    dst->sh_addr = get_signed_word (abfd, (bfd_byte *) src->sh_addr);
d344 7
a350 7
    dst->sh_addr = get_word (abfd, (bfd_byte *) src->sh_addr);
  dst->sh_offset = get_word (abfd, (bfd_byte *) src->sh_offset);
  dst->sh_size = get_word (abfd, (bfd_byte *) src->sh_size);
  dst->sh_link = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_link);
  dst->sh_info = bfd_h_get_32 (abfd, (bfd_byte *) src->sh_info);
  dst->sh_addralign = get_word (abfd, (bfd_byte *) src->sh_addralign);
  dst->sh_entsize = get_word (abfd, (bfd_byte *) src->sh_entsize);
d365 10
a374 10
  bfd_h_put_32 (abfd, src->sh_name, dst->sh_name);
  bfd_h_put_32 (abfd, src->sh_type, dst->sh_type);
  put_word (abfd, src->sh_flags, dst->sh_flags);
  put_word (abfd, src->sh_addr, dst->sh_addr);
  put_word (abfd, src->sh_offset, dst->sh_offset);
  put_word (abfd, src->sh_size, dst->sh_size);
  bfd_h_put_32 (abfd, src->sh_link, dst->sh_link);
  bfd_h_put_32 (abfd, src->sh_info, dst->sh_info);
  put_word (abfd, src->sh_addralign, dst->sh_addralign);
  put_word (abfd, src->sh_entsize, dst->sh_entsize);
d388 3
a390 3
  dst->p_type = bfd_h_get_32 (abfd, (bfd_byte *) src->p_type);
  dst->p_flags = bfd_h_get_32 (abfd, (bfd_byte *) src->p_flags);
  dst->p_offset = get_word (abfd, (bfd_byte *) src->p_offset);
d393 2
a394 2
      dst->p_vaddr = get_signed_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_signed_word (abfd, (bfd_byte *) src->p_paddr);
d398 2
a399 2
      dst->p_vaddr = get_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_word (abfd, (bfd_byte *) src->p_paddr);
d401 3
a403 3
  dst->p_filesz = get_word (abfd, (bfd_byte *) src->p_filesz);
  dst->p_memsz = get_word (abfd, (bfd_byte *) src->p_memsz);
  dst->p_align = get_word (abfd, (bfd_byte *) src->p_align);
d413 8
a420 8
  bfd_h_put_32 (abfd, src->p_type, dst->p_type);
  put_word (abfd, src->p_offset, dst->p_offset);
  put_word (abfd, src->p_vaddr, dst->p_vaddr);
  put_word (abfd, src->p_paddr, dst->p_paddr);
  put_word (abfd, src->p_filesz, dst->p_filesz);
  put_word (abfd, src->p_memsz, dst->p_memsz);
  bfd_h_put_32 (abfd, src->p_flags, dst->p_flags);
  put_word (abfd, src->p_align, dst->p_align);
d424 2
a425 2
INLINE void
elf_swap_reloc_in (abfd, src, dst)
d427 2
a428 2
     const Elf_External_Rel *src;
     Elf_Internal_Rel *dst;
d430 4
a433 2
  dst->r_offset = get_word (abfd, (bfd_byte *) src->r_offset);
  dst->r_info = get_word (abfd, (bfd_byte *) src->r_info);
d436 2
a437 2
INLINE void
elf_swap_reloca_in (abfd, src, dst)
d439 1
a439 1
     const Elf_External_Rela *src;
d442 4
a445 3
  dst->r_offset = get_word (abfd, (bfd_byte *) src->r_offset);
  dst->r_info = get_word (abfd, (bfd_byte *) src->r_info);
  dst->r_addend = get_signed_word (abfd, (bfd_byte *) src->r_addend);
d449 2
a450 2
INLINE void
elf_swap_reloc_out (abfd, src, dst)
d452 2
a453 2
     const Elf_Internal_Rel *src;
     Elf_External_Rel *dst;
d455 3
a457 2
  put_word (abfd, src->r_offset, dst->r_offset);
  put_word (abfd, src->r_info, dst->r_info);
d460 2
a461 2
INLINE void
elf_swap_reloca_out (abfd, src, dst)
d464 1
a464 1
     Elf_External_Rela *dst;
d466 4
a469 3
  put_word (abfd, src->r_offset, dst->r_offset);
  put_word (abfd, src->r_info, dst->r_info);
  put_signed_word (abfd, src->r_addend, dst->r_addend);
d480 2
a481 2
  dst->d_tag = get_word (abfd, src->d_tag);
  dst->d_un.d_val = get_word (abfd, src->d_un.d_val);
d492 2
a493 2
  put_word (abfd, src->d_tag, dst->d_tag);
  put_word (abfd, src->d_un.d_val, dst->d_un.d_val);
d503 1
a503 1
static INLINE boolean
d528 2
a529 1
  Elf_Internal_Shdr *i_shdrp = NULL; /* Section header table, internal form */
d533 1
a533 6
  struct elf_obj_tdata *preserved_tdata = elf_tdata (abfd);
  struct sec *preserved_sections = abfd->sections;
  unsigned int preserved_section_count = abfd->section_count;
  enum bfd_architecture previous_arch = bfd_get_arch (abfd);
  unsigned long previous_mach = bfd_get_mach (abfd);
  struct elf_obj_tdata *new_tdata = NULL;
d535 1
d537 1
a537 4
  /* Clear section information, since there might be a recognized bfd that
     we now check if we can replace, and we don't want to append to it.  */
  abfd->sections = NULL;
  abfd->section_count = 0;
d541 2
a542 1
  if (bfd_read ((PTR) & x_ehdr, sizeof (x_ehdr), 1, abfd) != sizeof (x_ehdr))
d556 3
a558 3
  if ((elf_file_p (&x_ehdr) == false) ||
      (x_ehdr.e_ident[EI_VERSION] != EV_CURRENT) ||
      (x_ehdr.e_ident[EI_CLASS] != ELFCLASS))
d580 5
a584 3
  new_tdata = ((struct elf_obj_tdata *)
	       bfd_zalloc (abfd, sizeof (struct elf_obj_tdata)));
  if (new_tdata == NULL)
d586 2
a587 1
  elf_tdata (abfd) = new_tdata;
d600 3
a602 2
  /* If there is no section header table, we're hosed.  */
  if (i_ehdrp->e_shoff == 0)
d607 6
a612 2
     recorded in the file.  */
  if (i_ehdrp->e_shentsize != sizeof (x_shdr))
d620 4
a623 2
      && (ebd->elf_machine_alt1 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0 || i_ehdrp->e_machine != ebd->elf_machine_alt2))
d670 23
d694 2
a695 12
     internal form, seek to the section header table in the file,
     read it in, and convert it to internal form.  */
  i_shdrp = ((Elf_Internal_Shdr *)
	     bfd_alloc (abfd, sizeof (*i_shdrp) * i_ehdrp->e_shnum));
  elf_elfsections (abfd) = ((Elf_Internal_Shdr **)
			    bfd_alloc (abfd,
				       sizeof (i_shdrp) * i_ehdrp->e_shnum));
  if (!i_shdrp || !elf_elfsections (abfd))
    goto got_no_match;
  if (bfd_seek (abfd, i_ehdrp->e_shoff, SEEK_SET) != 0)
    goto got_no_match;
  for (shindex = 0; shindex < i_ehdrp->e_shnum; shindex++)
d697 14
a710 1
      if (bfd_read ((PTR) & x_shdr, sizeof x_shdr, 1, abfd) != sizeof (x_shdr))
a711 2
      elf_swap_shdr_in (abfd, &x_shdr, i_shdrp + shindex);
      elf_elfsections (abfd)[shindex] = i_shdrp + shindex;
d713 32
a744 8
      /* If the section is loaded, but not page aligned, clear
         D_PAGED.  */
      if ((i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	  && i_shdrp[shindex].sh_type != SHT_NOBITS
	  && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
	       % ebd->maxpagesize)
	      != 0))
	abfd->flags &= ~D_PAGED;
d746 2
a747 1
  if (i_ehdrp->e_shstrndx)
d761 2
a762 4
      elf_tdata (abfd)->phdr = ((Elf_Internal_Phdr *)
				bfd_alloc (abfd,
					   (i_ehdrp->e_phnum
					    * sizeof (Elf_Internal_Phdr))));
d765 1
a765 1
      if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0)
d772 1
a772 1
	  if (bfd_read ((PTR) &x_phdr, sizeof x_phdr, 1, abfd)
d785 3
a787 3
  shstrtab = bfd_elf_get_str_section (abfd, i_ehdrp->e_shstrndx);
  if (!shstrtab)
    goto got_no_match;
d789 3
a791 3
  /* Once all of the section headers have been read and converted, we
     can start processing them.  Note that the first section header is
     a dummy placeholder entry, so we ignore it.  */
d793 11
a803 4
  for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
    {
      if (! bfd_section_from_shdr (abfd, shindex))
	goto got_no_match;
d810 1
a810 1
      if ((*ebd->elf_backend_object_p) (abfd) == false)
d833 2
a834 1
  return (abfd->xvec);
a845 1
  bfd_default_set_arch_mach (abfd, previous_arch, previous_mach);
d847 1
d849 3
a851 11
  if (new_tdata != NULL
      && new_tdata->elf_sect_ptr != NULL)
    bfd_release (abfd, new_tdata->elf_sect_ptr);
  if (i_shdrp != NULL)
    bfd_release (abfd, i_shdrp);
  if (new_tdata != NULL)
    bfd_release (abfd, new_tdata);
  elf_tdata (abfd) = preserved_tdata;
  abfd->sections = preserved_sections;
  abfd->section_count = preserved_section_count;
  return (NULL);
d864 1
a864 1
  boolean *failedp = (boolean *) data;
d866 4
a869 2
  Elf_External_Rela *outbound_relocas;
  Elf_External_Rel *outbound_relocs;
d871 2
a872 3
  int use_rela_p;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;
d894 1
a894 1
      *failedp = true;
d900 4
a903 1
    use_rela_p = true;
d905 4
a908 1
    use_rela_p = false;
d914 7
d922 18
a939 5
  if (use_rela_p)
    {
      outbound_relocas = (Elf_External_Rela *) rela_hdr->contents;

      for (idx = 0; idx < sec->reloc_count; idx++)
d941 3
a943 23
	  Elf_Internal_Rela dst_rela;
	  Elf_External_Rela *src_rela;
	  arelent *ptr;
	  asymbol *sym;
	  int n;

	  ptr = sec->orelocation[idx];
	  src_rela = outbound_relocas + idx;

	  /* The address of an ELF reloc is section relative for an object
	     file, and absolute for an executable file or shared library.
	     The address of a BFD reloc is always section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	    dst_rela.r_offset = ptr->address;
	  else
	    dst_rela.r_offset = ptr->address + sec->vma;

	  sym = *ptr->sym_ptr_ptr;
	  if (sym == last_sym)
	    n = last_sym_idx;
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
	  else
d945 1
a945 15
	      last_sym = sym;
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
	    }

	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
	    {
	      *failedp = true;
d948 1
a948 5

	  dst_rela.r_info = ELF_R_INFO (n, ptr->howto->type);

	  dst_rela.r_addend = ptr->addend;
	  elf_swap_reloca_out (abfd, &dst_rela, src_rela);
a949 5
    }
  else
    /* REL relocations */
    {
      outbound_relocs = (Elf_External_Rel *) rela_hdr->contents;
d951 3
a953 1
      for (idx = 0; idx < sec->reloc_count; idx++)
d955 3
a957 43
	  Elf_Internal_Rel dst_rel;
	  Elf_External_Rel *src_rel;
	  arelent *ptr;
	  int n;
	  asymbol *sym;

	  ptr = sec->orelocation[idx];
	  sym = *ptr->sym_ptr_ptr;
	  src_rel = outbound_relocs + idx;

	  /* The address of an ELF reloc is section relative for an object
	     file, and absolute for an executable file or shared library.
	     The address of a BFD reloc is always section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	    dst_rel.r_offset = ptr->address;
	  else
	    dst_rel.r_offset = ptr->address + sec->vma;

	  if (sym == last_sym)
	    n = last_sym_idx;
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
	  else
	    {
	      last_sym = sym;
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
	    }

	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
	    {
	      *failedp = true;
	      return;
	    }

	  dst_rel.r_info = ELF_R_INFO (n, ptr->howto->type);
d959 4
a962 2
	  elf_swap_reloc_out (abfd, &dst_rel, src_rel);
	}
d972 1
a972 1
     int count;
d978 2
a979 2
      if (bfd_write (&extphdr, sizeof (Elf_External_Phdr), 1, abfd)
	  != sizeof (Elf_External_Phdr))
d988 1
a988 1
boolean
d997 1
d1008 1
d1010 9
a1018 3
      || (bfd_write ((PTR) & x_ehdr, sizeof (x_ehdr), 1, abfd)
	  != sizeof (x_ehdr)))
    return false;
d1021 3
a1023 2
  x_shdrp = (Elf_External_Shdr *)
    bfd_alloc (abfd, sizeof (*x_shdrp) * (i_ehdrp->e_shnum));
d1025 1
a1025 1
    return false;
d1027 1
a1027 1
  for (count = 0; count < i_ehdrp->e_shnum; count++)
d1030 1
a1030 1
      elf_debug_section (count, i_shdrp[count]);
d1032 4
a1035 1
      elf_swap_shdr_out (abfd, i_shdrp[count], x_shdrp + count);
d1038 2
a1039 3
      || (bfd_write ((PTR) x_shdrp, sizeof (*x_shdrp), i_ehdrp->e_shnum, abfd)
	  != sizeof (*x_shdrp) * i_ehdrp->e_shnum))
    return false;
d1043 1
a1043 1
  return true;
d1050 1
a1050 1
     boolean dynamic;
d1057 7
a1063 3
  Elf_Internal_Sym i_sym;
  Elf_External_Sym *x_symp = NULL;
  Elf_External_Versym *x_versymp = NULL;
d1097 1
a1097 3
  if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) == -1)
    return -1;

a1098 1

d1103 3
a1105 3
      unsigned long i;

      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) == -1)
d1108 3
a1110 2
      symbase = ((elf_symbol_type *)
		 bfd_zalloc (abfd, symcount * sizeof (elf_symbol_type)));
a1111 11
	return -1;
      sym = symbase;

      /* Temporarily allocate room for the raw ELF symbols.  */
      x_symp = ((Elf_External_Sym *)
		bfd_malloc (symcount * sizeof (Elf_External_Sym)));
      if (x_symp == NULL && symcount != 0)
	goto error_return;

      if (bfd_read ((PTR) x_symp, sizeof (Elf_External_Sym), symcount, abfd)
	  != symcount * sizeof (Elf_External_Sym))
a1114 1

d1134 2
a1135 2
	  x_versymp = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (x_versymp == NULL && verhdr->sh_size != 0)
d1138 1
a1138 1
	  if (bfd_read ((PTR) x_versymp, 1, verhdr->sh_size, abfd)
d1144 5
a1148 1
      for (i = 1; i < symcount; i++)
d1150 1
a1150 5
	  elf_swap_symbol_in (abfd, x_symp + i, &i_sym);
	  memcpy (&sym->internal_elf_sym, &i_sym, sizeof (Elf_Internal_Sym));
#ifdef ELF_KEEP_EXTSYM
	  memcpy (&sym->native_elf_sym, x_symp + i, sizeof (Elf_External_Sym));
#endif
d1155 1
a1155 1
							      i_sym.st_name);
d1157 1
a1157 1
	  sym->symbol.value = i_sym.st_value;
d1159 6
a1164 1
	  if (i_sym.st_shndx > 0 && i_sym.st_shndx < SHN_LORESERVE)
d1167 1
a1167 1
							    i_sym.st_shndx);
d1176 1
a1176 1
	  else if (i_sym.st_shndx == SHN_ABS)
d1180 1
a1180 1
	  else if (i_sym.st_shndx == SHN_COMMON)
d1187 1
a1187 5
	      sym->symbol.value = i_sym.st_size;
	    }
	  else if (i_sym.st_shndx == SHN_UNDEF)
	    {
	      sym->symbol.section = bfd_und_section_ptr;
d1197 1
a1197 1
	  switch (ELF_ST_BIND (i_sym.st_info))
d1203 1
a1203 2
	      if (i_sym.st_shndx != SHN_UNDEF
		  && i_sym.st_shndx != SHN_COMMON)
d1211 1
a1211 1
	  switch (ELF_ST_TYPE (i_sym.st_info))
d1230 1
a1230 1
	  if (x_versymp != NULL)
d1234 1
a1234 1
	      _bfd_elf_swap_versym_in (abfd, x_versymp + i, &iversym);
d1236 1
d1240 2
a1241 7
	  {
	    struct elf_backend_data *ebd = get_elf_backend_data (abfd);
	    if (ebd->elf_backend_symbol_processing)
	      (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
	  }

	  sym++;
d1246 2
a1247 5
  {
    struct elf_backend_data *ebd = get_elf_backend_data (abfd);
    if (ebd->elf_backend_symbol_table_processing)
      (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);
  }
d1267 4
a1270 4
  if (x_versymp != NULL)
    free (x_versymp);
  if (x_symp != NULL)
    free (x_symp);
d1272 1
d1274 4
a1277 4
  if (x_versymp != NULL)
    free (x_versymp);
  if (x_symp != NULL)
    free (x_symp);
d1284 1
a1284 1
static boolean
d1293 1
a1293 1
     boolean dynamic;
d1301 1
d1303 1
a1303 1
  allocated = (PTR) bfd_malloc ((size_t) rel_hdr->sh_size);
d1308 1
a1308 1
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd)
d1318 5
a1327 1
      Elf_Internal_Rel rel;
d1330 1
a1330 1
	elf_swap_reloca_in (abfd, (Elf_External_Rela *) native_relocs, &rela);
d1332 1
a1332 6
	{
	  elf_swap_reloc_in (abfd, (Elf_External_Rel *) native_relocs, &rel);
	  rela.r_offset = rel.r_offset;
	  rela.r_info = rel.r_info;
	  rela.r_addend = 0;
	}
d1345 7
d1368 3
a1370 1
      if (entsize == sizeof (Elf_External_Rela))
d1373 1
a1373 1
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rel);
d1379 1
a1379 1
  return true;
d1384 1
a1384 1
  return false;
d1389 1
a1389 1
boolean
d1394 1
a1394 1
     boolean dynamic;
d1402 1
d1405 1
a1405 1
    return true;
d1411 1
a1411 1
	return true;
d1430 1
a1430 1
	return true;
d1438 2
a1439 3
  relents = ((arelent *)
	     bfd_alloc (abfd,
			(reloc_count + reloc_count2) * sizeof (arelent)));
d1441 1
a1441 1
    return false;
d1447 1
a1447 1
    return false;
d1454 1
a1454 1
    return false;
d1457 1
a1457 1
  return true;
d1595 1
d1601 4
a1604 4
  NULL,
  NULL,
  NULL,
  NULL
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999 Free Software
   Foundation, Inc.
d121 2
d170 1
a170 1
static boolean elf_slurp_reloc_table_from_section 
a172 4
static boolean elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));

static void write_relocs PARAMS ((bfd *, asection *, PTR));
d200 1
a200 1
   format. */
d222 1
a222 1
   format. */
a238 1

d240 1
a240 1
   internal format. */
d248 1
d253 4
a256 1
  dst->e_entry = get_word (abfd, (bfd_byte *) src->e_entry);
d269 1
a269 1
   external format. */
d277 1
d279 1
a279 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
d283 4
a286 1
  put_word (abfd, src->e_entry, dst->e_entry);
a297 1

d299 1
a299 1
   ELF section header table entry in internal format. */
d327 1
a327 1
   ELF section header table entry in external format. */
d335 1
a335 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
a347 1

d349 1
a349 1
   ELF program header table entry in internal format. */
d383 1
a383 1
  /* note that all elements of dst are *arrays of unsigned char* already... */
d394 1
a394 1
/* Translate an ELF reloc from external format to internal format. */
d416 1
a416 1
/* Translate an ELF reloc from internal format to external format. */
a463 1

d499 4
d506 5
d525 1
a525 1
     file). */
d568 1
a568 1
  /* If there is no section header table, we're hosed. */
d574 1
a574 1
     recorded in the file. */
d628 2
a629 2
  /* Remember the entry point specified in the ELF file header. */
  bfd_get_start_address (abfd) = i_ehdrp->e_entry;
d694 1
a694 1
     will need the base pointer to this table later. */
d743 10
d763 2
d772 2
a773 2
static void
write_relocs (abfd, sec, data)
d821 1
a821 1
  /* orelocation has the data, reloc_count has the count... */
d967 1
a967 1
  /* swap the header before spitting it out... */
d978 1
a978 1
  /* at this point we've concocted all the ELF sections... */
d996 1
a996 1
  /* need to dump the string table too... */
d1024 1
a1024 1
     build the caller's pointer vector. */
d1252 1
a1252 1
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of 
d1351 1
a1351 1
static boolean
d1375 1
a1375 1
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
d1377 1
a1377 3
      reloc_count2 = (rel_hdr2 
		      ? (rel_hdr2->sh_size / rel_hdr2->sh_entsize)
		      : 0);
d1394 1
a1394 1
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
d1399 2
a1400 2
  relents = ((arelent *) 
	     bfd_alloc (abfd, 
d1410 2
a1411 2
  
  if (rel_hdr2 
a1417 1
  
d1550 1
a1550 1
  ARCH_SIZE / 8,
d1556 1
a1556 1
  write_relocs,
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d127 8
d153 1
a153 1
/* Forward declarations of static functions */
d168 5
a172 1
static boolean elf_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **));
d176 2
d190 1
d192 1
d196 1
d198 1
d210 2
d213 4
a216 1
  dst->st_value = get_word (abfd, (bfd_byte *) src->st_value);
d303 2
d308 4
a311 1
  dst->sh_addr = get_word (abfd, (bfd_byte *) src->sh_addr);
d354 2
d359 10
a368 2
  dst->p_vaddr = get_word (abfd, (bfd_byte *) src->p_vaddr);
  dst->p_paddr = get_word (abfd, (bfd_byte *) src->p_paddr);
d410 1
a410 1
  dst->r_addend = get_word (abfd, (bfd_byte *) src->r_addend);
d432 1
a432 1
  put_word (abfd, src->r_addend, dst->r_addend);
d448 1
a448 1
elf_swap_dyn_out (abfd, src, dst)
d451 1
a451 1
     Elf_External_Dyn *dst;
d453 2
d498 1
d553 4
d611 5
a615 1
    goto got_no_match;
d710 19
d731 1
a731 1
got_wrong_format_error:
d733 1
a733 2
  goto got_no_match;
got_no_match:
d760 1
a760 1
  int use_rela_p = get_elf_backend_data (abfd)->use_rela_p;
d788 10
d880 2
d894 2
a895 1
	  if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
d985 2
a986 1
  long symcount;		/* Number of external ELF symbols */
d991 1
d1003 5
a1007 2
  if (dynamic)
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;
d1009 16
a1024 1
    hdr = &elf_tdata (abfd)->symtab_hdr;
d1034 1
a1034 1
      long i;
d1054 31
d1133 4
a1136 1
	  sym->symbol.value -= sym->symbol.section->vma;
d1172 8
d1216 2
d1222 2
d1229 2
a1230 1
/* Read in and swap the external relocs.  */
d1233 2
a1234 1
elf_slurp_reloc_table (abfd, asect, symbols)
d1237 3
d1241 1
a1243 1
  struct bfd_elf_section_data * const d = elf_section_data (asect);
a1245 1
  arelent *relents;
d1250 1
a1250 10
  if (asect->relocation != NULL
      || (asect->flags & SEC_RELOC) == 0
      || asect->reloc_count == 0)
    return true;

  BFD_ASSERT (asect->rel_filepos == d->rel_hdr.sh_offset
	      && (asect->reloc_count
		  == d->rel_hdr.sh_size / d->rel_hdr.sh_entsize));

  allocated = (PTR) bfd_malloc ((size_t) d->rel_hdr.sh_size);
d1254 3
a1256 3
  if (bfd_seek (abfd, asect->rel_filepos, SEEK_SET) != 0
      || (bfd_read (allocated, 1, d->rel_hdr.sh_size, abfd)
	  != d->rel_hdr.sh_size))
d1261 1
a1261 6
  relents = ((arelent *)
	     bfd_alloc (abfd, asect->reloc_count * sizeof (arelent)));
  if (relents == NULL)
    goto error_return;

  entsize = d->rel_hdr.sh_entsize;
d1266 1
a1266 1
       i < asect->reloc_count;
d1284 3
a1286 2
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
a1314 2
  asect->relocation = relents;

d1326 76
d1530 2
a1531 1

d1540 6
a1545 1
  elf_swap_dyn_in
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a156 1
extern struct bfd_strtab_hash *_bfd_elf_stringtab_init PARAMS ((void));
a157 2
extern boolean bfd_section_from_phdr PARAMS ((bfd *, Elf_Internal_Phdr *,
					      int));
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d591 9
d750 2
d764 2
a765 1
	  if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
a65 1
#include <string.h>		/* For strrchr and friends */
d102 1
d118 2
d124 2
d146 9
a161 4
 int _bfd_elf_section_from_bfd_section PARAMS ((bfd *, struct sec *));

static long elf_slurp_symbol_table PARAMS ((bfd *, asymbol **, boolean));

a163 3
 int _bfd_elf_symbol_from_bfd_symbol PARAMS ((bfd *,
					     struct symbol_cache_entry **));

a165 2
 boolean bfd_section_from_shdr PARAMS ((bfd *, unsigned int shindex));

d191 1
a191 1
     Elf_External_Sym *src;
d208 1
a208 1
     Elf_Internal_Sym *src;
d227 1
a227 1
     Elf_External_Ehdr *src;
d252 1
a252 1
     Elf_Internal_Ehdr *src;
d279 1
a279 1
     Elf_External_Shdr *src;
d302 1
a302 1
     Elf_Internal_Shdr *src;
d325 1
a325 1
     Elf_External_Phdr *src;
d341 1
a341 1
     Elf_Internal_Phdr *src;
d359 1
a359 1
     Elf_External_Rel *src;
d369 1
a369 1
     Elf_External_Rela *src;
d381 1
a381 1
     Elf_Internal_Rel *src;
d391 1
a391 1
     Elf_Internal_Rela *src;
d400 1
a400 1
elf_swap_dyn_in (abfd, src, dst)
d402 1
a402 1
     const Elf_External_Dyn *src;
d405 2
d486 1
a486 1
      if (!abfd->xvec->header_byteorder_big_p)
d490 1
a490 1
      if (abfd->xvec->header_byteorder_big_p)
d504 1
a504 1
    goto got_no_memory_error;
d546 5
a550 1
	  if (back->elf_machine_code == i_ehdrp->e_machine)
d582 1
a582 1
    goto got_no_memory_error;
d611 1
a611 1
	goto got_no_memory_error;
a658 3
got_no_memory_error:
  bfd_set_error (bfd_error_no_memory);
  goto got_no_match;
d671 1
d673 1
a673 1
/* ELF .o/exec file writing */
d688 1
a688 1
  int last_sym_idx = 9999999;	/* should always be written before use */
a709 1
      bfd_set_error (bfd_error_no_memory);
d744 14
a757 1
	      last_sym_idx = n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
d759 1
d796 7
a802 1
	      last_sym_idx = n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
d804 8
d819 4
a822 2
static int
write_out_phdrs (abfd, phdr, count)
d824 1
a824 1
     Elf_Internal_Phdr *phdr;
d839 4
a842 2
static boolean
write_shdrs_and_ehdr (abfd)
d869 1
a869 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d888 1
a888 1
static long
d932 1
a932 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return -1;
	}
d937 1
a937 1
		malloc (symcount * sizeof (Elf_External_Sym)));
d939 1
a939 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d1020 3
d1099 1
a1099 1
  allocated = (PTR) malloc ((size_t) d->rel_hdr.sh_size);
d1101 1
a1101 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d1113 1
a1113 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d1312 2
a1313 2
  write_out_phdrs,
  write_shdrs_and_ehdr,
d1318 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d66 1
a102 1
#define elf_slurp_symbol_table		NAME(bfd_elf,slurp_symbol_table)
a117 2
#define elf_write_shdrs_and_ehdr	NAME(bfd_elf,write_shdrs_and_ehdr)
#define elf_write_out_phdrs		NAME(bfd_elf,write_out_phdrs)
a121 2
#define elf_create_pointer_linker_section NAME(bfd_elf,create_pointer_linker_section)
#define elf_finish_pointer_linker_section NAME(bfd_elf,finish_pointer_linker_section)
a141 9
static void elf_swap_ehdr_in
  PARAMS ((bfd *, const Elf_External_Ehdr *, Elf_Internal_Ehdr *));
static void elf_swap_ehdr_out
  PARAMS ((bfd *, const Elf_Internal_Ehdr *, Elf_External_Ehdr *));
static void elf_swap_shdr_in
  PARAMS ((bfd *, const Elf_External_Shdr *, Elf_Internal_Shdr *));
static void elf_swap_shdr_out
  PARAMS ((bfd *, const Elf_Internal_Shdr *, Elf_External_Shdr *));

d149 4
d155 3
d160 2
d187 1
a187 1
     const Elf_External_Sym *src;
d204 1
a204 1
     const Elf_Internal_Sym *src;
d223 1
a223 1
     const Elf_External_Ehdr *src;
d248 1
a248 1
     const Elf_Internal_Ehdr *src;
d275 1
a275 1
     const Elf_External_Shdr *src;
d298 1
a298 1
     const Elf_Internal_Shdr *src;
d321 1
a321 1
     const Elf_External_Phdr *src;
d337 1
a337 1
     const Elf_Internal_Phdr *src;
d355 1
a355 1
     const Elf_External_Rel *src;
d365 1
a365 1
     const Elf_External_Rela *src;
d377 1
a377 1
     const Elf_Internal_Rel *src;
d387 1
a387 1
     const Elf_Internal_Rela *src;
d396 1
a396 1
elf_swap_dyn_in (abfd, p, dst)
d398 1
a398 1
     const PTR p;
a400 2
  const Elf_External_Dyn *src = (const Elf_External_Dyn *) p;

d480 1
a480 1
      if (! bfd_header_big_endian (abfd))
d484 1
a484 1
      if (! bfd_header_little_endian (abfd))
d498 1
a498 1
    goto got_no_match;
d540 1
a540 5
	  if (back->elf_machine_code == i_ehdrp->e_machine
	      || (back->elf_machine_alt1 != 0
		  && back->elf_machine_alt1 == i_ehdrp->e_machine)
	      || (back->elf_machine_alt2 != 0
		  && back->elf_machine_alt2 == i_ehdrp->e_machine))
d572 1
a572 1
    goto got_no_match;
d601 1
a601 1
	goto got_no_match;
d649 3
d664 1
a666 2
/* Write out the relocs.  */

d680 1
a680 1
  int last_sym_idx = 0;
d702 1
d737 1
a737 14
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
	    }

	  if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
	    {
	      *failedp = true;
	      return;
a738 1

d775 1
a775 7
	      n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	      if (n < 0)
		{
		  *failedp = true;
		  return;
		}
	      last_sym_idx = n;
a776 8

	  if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	      && ! _bfd_elf_validate_reloc (abfd, ptr))
	    {
	      *failedp = true;
	      return;
	    }

d784 2
a785 4
/* Write out the program headers.  */

int
elf_write_out_phdrs (abfd, phdr, count)
d787 1
a787 1
     const Elf_Internal_Phdr *phdr;
d802 2
a803 4
/* Write out the section headers and the ELF file header.  */

boolean
elf_write_shdrs_and_ehdr (abfd)
d830 4
a833 1
    return false;
d852 1
a852 1
long
d896 4
a899 1
	return -1;
d904 1
a904 1
		bfd_malloc (symcount * sizeof (Elf_External_Sym)));
d906 4
a909 1
	goto error_return;
a989 3
	    case STT_OBJECT:
	      sym->symbol.flags |= BSF_OBJECT;
	      break;
d1066 1
a1066 1
  allocated = (PTR) bfd_malloc ((size_t) d->rel_hdr.sh_size);
d1068 4
a1071 1
    goto error_return;
d1083 4
a1086 1
    goto error_return;
d1285 2
a1286 2
  elf_write_out_phdrs,
  elf_write_shdrs_and_ehdr,
a1290 1
  elf_swap_dyn_in
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a590 9

      /* If the section is loaded, but not page aligned, clear
         D_PAGED.  */
      if ((i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	  && i_shdrp[shindex].sh_type != SHT_NOBITS
	  && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
	       % ebd->maxpagesize)
	      != 0))
	abfd->flags &= ~D_PAGED;
a740 2
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
d753 1
a753 2
	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d157 1
d159 2
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a70 1
#include "fnmatch.h"
d144 1
a144 1
/* Static functions */
d159 1
a159 2
static boolean elf_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
a162 2
static boolean elf_file_p PARAMS ((Elf_External_Ehdr *));

a456 1
  asection *s;
a659 19
  /* If we have created any reloc sections that are associated with
     debugging sections, mark the reloc sections as debugging as well.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((elf_section_data (s)->this_hdr.sh_type == SHT_REL
	   || elf_section_data (s)->this_hdr.sh_type == SHT_RELA)
	  && elf_section_data (s)->this_hdr.sh_info > 0)
	{
	  unsigned long targ_index;
	  asection *targ_sec;

	  targ_index = elf_section_data (s)->this_hdr.sh_info;
	  targ_sec = bfd_section_from_elf_index (abfd, targ_index);
	  if (targ_sec != NULL
	      && (targ_sec->flags & SEC_DEBUGGING) != 0)
	    s->flags |= SEC_DEBUGGING;
	}
    }

a903 1
  Elf_Internal_Shdr *verhdr;
a908 1
  Elf_External_Versym *x_versymp = NULL;
d920 2
a921 5
  if (! dynamic)
    {
      hdr = &elf_tdata (abfd)->symtab_hdr;
      verhdr = NULL;
    }
d923 1
a923 16
    {
      hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      if (elf_dynversym (abfd) == 0)
	verhdr = NULL;
      else
	verhdr = &elf_tdata (abfd)->dynversym_hdr;
      if ((elf_tdata (abfd)->dynverdef_section != 0
	   && elf_tdata (abfd)->verdef == NULL)
	  || (elf_tdata (abfd)->dynverref_section != 0
	      && elf_tdata (abfd)->verref == NULL))
	{
	  if (! _bfd_elf_slurp_version_tables (abfd))
	    return -1;
	}
    }

a952 31

      /* Read the raw ELF version symbol information.  */

      if (verhdr != NULL
	  && verhdr->sh_size / sizeof (Elf_External_Versym) != symcount)
	{
	  (*_bfd_error_handler)
	    ("%s: version count (%ld) does not match symbol count (%ld)",
	     abfd->filename,
	     (long) (verhdr->sh_size / sizeof (Elf_External_Versym)),
	     symcount);

	  /* Slurp in the symbols without the version information,
             since that is more helpful than just quitting.  */
	  verhdr = NULL;
	}

      if (verhdr != NULL)
	{
	  if (bfd_seek (abfd, verhdr->sh_offset, SEEK_SET) != 0)
	    goto error_return;

	  x_versymp = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (x_versymp == NULL && verhdr->sh_size != 0)
	    goto error_return;

	  if (bfd_read ((PTR) x_versymp, 1, verhdr->sh_size, abfd)
	      != verhdr->sh_size)
	    goto error_return;
	}

d1001 1
a1001 4
	  /* If this is a relocateable file, then the symbol value is
             already section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    sym->symbol.value -= sym->symbol.section->vma;
a1036 8
	  if (x_versymp != NULL)
	    {
	      Elf_Internal_Versym iversym;

	      _bfd_elf_swap_versym_in (abfd, x_versymp + i, &iversym);
	      sym->version = iversym.vs_vers;
	    }

a1072 2
  if (x_versymp != NULL)
    free (x_versymp);
a1076 2
  if (x_versymp != NULL)
    free (x_versymp);
d1085 1
a1085 1
elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
a1088 1
     boolean dynamic;
a1091 2
  Elf_Internal_Shdr *rel_hdr;
  bfd_size_type reloc_count;
d1099 3
a1101 1
  if (asect->relocation != NULL)
d1104 3
a1106 20
  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return true;

      rel_hdr = &d->rel_hdr;
      reloc_count = asect->reloc_count;

      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  && reloc_count == rel_hdr->sh_size / rel_hdr->sh_entsize);
    }
  else
    {
      if (asect->_raw_size == 0)
	return true;

      rel_hdr = &d->this_hdr;
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
    }
d1108 1
a1108 1
  allocated = (PTR) bfd_malloc ((size_t) rel_hdr->sh_size);
d1112 3
a1114 3
  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d1119 2
a1120 1
  relents = (arelent *) bfd_alloc (abfd, reloc_count * sizeof (arelent));
d1124 1
a1124 1
  entsize = rel_hdr->sh_entsize;
d1129 1
a1129 1
       i < reloc_count;
d1147 2
a1148 3
	 The address of a normal BFD reloc is always section relative,
	 and the address of a dynamic reloc is absolute..  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999 Free Software
   Foundation, Inc.
d71 1
a126 8
#define elf_gc_sections			NAME(_bfd_elf,gc_sections)
#define elf_gc_common_finalize_got_offsets \
  NAME(_bfd_elf,gc_common_finalize_got_offsets)
#define elf_gc_common_final_link	NAME(_bfd_elf,gc_common_final_link)
#define elf_gc_record_vtinherit		NAME(_bfd_elf,gc_record_vtinherit)
#define elf_gc_record_vtentry		NAME(_bfd_elf,gc_record_vtentry)
#define elf_link_record_local_dynamic_symbol \
  NAME(_bfd_elf,link_record_local_dynamic_symbol)
a159 3
static boolean elf_slurp_reloc_table_from_section 
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, boolean));
a178 1
#define put_signed_word	bfd_h_put_signed_64
a179 1
#define get_signed_word	bfd_h_get_signed_64
a182 1
#define put_signed_word	bfd_h_put_signed_32
a183 1
#define get_signed_word	bfd_h_get_signed_32
a194 2
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

d196 1
a196 4
  if (signed_vma)
    dst->st_value = get_signed_word (abfd, (bfd_byte *) src->st_value);
  else
    dst->st_value = get_word (abfd, (bfd_byte *) src->st_value);
a282 2
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

d286 1
a286 4
  if (signed_vma)
    dst->sh_addr = get_signed_word (abfd, (bfd_byte *) src->sh_addr);
  else
    dst->sh_addr = get_word (abfd, (bfd_byte *) src->sh_addr);
a328 2
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;

d332 2
a333 10
  if (signed_vma)
    {
      dst->p_vaddr = get_signed_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_signed_word (abfd, (bfd_byte *) src->p_paddr);
    }
  else
    {
      dst->p_vaddr = get_word (abfd, (bfd_byte *) src->p_vaddr);
      dst->p_paddr = get_word (abfd, (bfd_byte *) src->p_paddr);
    }
d375 1
a375 1
  dst->r_addend = get_signed_word (abfd, (bfd_byte *) src->r_addend);
d397 1
a397 1
  put_signed_word (abfd, src->r_addend, dst->r_addend);
d413 1
a413 1
elf_swap_dyn_out (abfd, src, p)
d416 1
a416 1
     PTR p;
a417 2
  Elf_External_Dyn *dst = (Elf_External_Dyn *) p;

a515 4
  /* Reject ET_CORE (header indicates core file, not object file) */
  if (i_ehdrp->e_type == ET_CORE)
    goto got_wrong_format_error;

d570 1
a570 5
    {
      /* It's OK if this fails for the generic target.  */
      if (ebd->elf_machine_code != EM_NONE)
	goto got_no_match;
    }
d686 1
a686 1
 got_wrong_format_error:
d688 2
a689 1
 got_no_match:
d716 1
a716 1
  int use_rela_p;
a743 10
  /* Figure out whether the relocations are RELA or REL relocations.  */
  if (rela_hdr->sh_type == SHT_RELA)
    use_rela_p = true;
  else if (rela_hdr->sh_type == SHT_REL)
    use_rela_p = false;
  else
    /* Every relocation section should be either an SHT_RELA or an
       SHT_REL section.  */
    abort ();

a825 2
	  else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	    n = STN_UNDEF;
d838 1
a838 2
	  if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	      && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
d929 1
a929 1
  unsigned long symcount;	/* Number of external ELF symbols */
d977 1
a977 1
      unsigned long i;
d1004 1
a1004 1
	    (_("%s: version count (%ld) does not match symbol count (%ld)"),
d1172 1
a1172 2
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of 
   them.  */
d1175 1
a1175 2
elf_slurp_reloc_table_from_section (abfd, asect, rel_hdr, reloc_count,
				    relents, symbols, dynamic)
a1177 3
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
d1182 3
d1187 1
d1192 24
d1227 4
d1285 2
a1297 76
/* Read in and swap the external relocs.  */

static boolean
elf_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     boolean dynamic;
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;

  if (asect->relocation != NULL)
    return true;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return true;

      rel_hdr = &d->rel_hdr;
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 
		      ? (rel_hdr2->sh_size / rel_hdr2->sh_entsize)
		      : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));

    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return true;

      rel_hdr = &d->this_hdr;
      reloc_count = rel_hdr->sh_size / rel_hdr->sh_entsize;
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }

  relents = ((arelent *) 
	     bfd_alloc (abfd, 
			(reloc_count + reloc_count2) * sizeof (arelent)));
  if (relents == NULL)
    return false;

  if (!elf_slurp_reloc_table_from_section (abfd, asect,
					   rel_hdr, reloc_count,
					   relents,
					   symbols, dynamic))
    return false;
  
  if (rel_hdr2 
      && !elf_slurp_reloc_table_from_section (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count,
					      symbols, dynamic))
    return false;

  
  asect->relocation = relents;
  return true;
}

d1426 1
a1426 2
  ARCH_SIZE / 8,
  1,
d1435 1
a1435 6
  elf_swap_dyn_in,
  elf_swap_dyn_out,
  NULL,
  NULL,
  NULL,
  NULL
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
a120 2
#define elf_write_relocs		NAME(bfd_elf,write_relocs)
#define elf_slurp_reloc_table		NAME(bfd_elf,slurp_reloc_table)
d168 1
a168 1
static boolean elf_slurp_reloc_table_from_section
d171 4
d202 1
a202 1
   format.  */
d224 1
a224 1
   format.  */
d241 1
d243 1
a243 1
   internal format.  */
a250 1
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
d255 1
a255 4
  if (signed_vma)
    dst->e_entry = get_signed_word (abfd, (bfd_byte *) src->e_entry);
  else
    dst->e_entry = get_word (abfd, (bfd_byte *) src->e_entry);
d268 1
a268 1
   external format.  */
a275 1
  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
d277 1
a277 1
  /* note that all elements of dst are *arrays of unsigned char* already...  */
d281 1
a281 4
  if (signed_vma)
    put_signed_word (abfd, src->e_entry, dst->e_entry);
  else
    put_word (abfd, src->e_entry, dst->e_entry);
d293 1
d295 1
a295 1
   ELF section header table entry in internal format.  */
d323 1
a323 1
   ELF section header table entry in external format.  */
d331 1
a331 1
  /* note that all elements of dst are *arrays of unsigned char* already...  */
d344 1
d346 1
a346 1
   ELF program header table entry in internal format.  */
d380 1
a380 1
  /* note that all elements of dst are *arrays of unsigned char* already...  */
d391 1
a391 1
/* Translate an ELF reloc from external format to internal format.  */
d413 1
a413 1
/* Translate an ELF reloc from internal format to external format.  */
d461 1
a496 4
  struct sec *preserved_sections = abfd->sections;
  unsigned int preserved_section_count = abfd->section_count;
  enum bfd_architecture previous_arch = bfd_get_arch (abfd);
  unsigned long previous_mach = bfd_get_mach (abfd);
a499 5
  /* Clear section information, since there might be a recognized bfd that
     we now check if we can replace, and we don't want to append to it.  */
  abfd->sections = NULL;
  abfd->section_count = 0;

d514 1
a514 1
     file).  */
d557 1
a557 1
  /* If there is no section header table, we're hosed.  */
d563 1
a563 1
     recorded in the file.  */
d617 2
a618 2
  /* Remember the entry point specified in the ELF file header.  */
  bfd_set_start_address (abfd, i_ehdrp->e_entry);
d683 1
a683 1
     will need the base pointer to this table later.  */
a731 10
  /* There is way too much undoing of half-known state here.  The caller,
     bfd_check_format_matches, really shouldn't iterate on live bfd's to
     check match/no-match like it does.  We have to rely on that a call to
     bfd_default_set_arch_mach with the previously known mach, undoes what
     was done by the first bfd_default_set_arch_mach (with mach 0) here.
     For this to work, only elf-data and the mach may be changed by the
     target-specific elf_backend_object_p function.  Note that saving the
     whole bfd here and restoring it would be even worse; the first thing
     you notice is that the cached bfd file position gets out of sync.  */
  bfd_default_set_arch_mach (abfd, previous_arch, previous_mach);
a741 2
  abfd->sections = preserved_sections;
  abfd->section_count = preserved_section_count;
d749 2
a750 2
void
elf_write_relocs (abfd, sec, data)
d798 1
a798 1
  /* orelocation has the data, reloc_count has the count...  */
d944 1
a944 1
  /* swap the header before spitting it out...  */
d955 1
a955 1
  /* at this point we've concocted all the ELF sections...  */
d973 1
a973 1
  /* need to dump the string table too...  */
d1001 1
a1001 1
     build the caller's pointer vector.  */
d1229 1
a1229 1
/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of
d1328 1
a1328 1
boolean
d1352 1
a1352 1
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
d1354 3
a1356 1
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);
d1373 1
a1373 1
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
d1378 2
a1379 2
  relents = ((arelent *)
	     bfd_alloc (abfd,
d1389 2
a1390 2

  if (rel_hdr2
d1397 1
d1530 1
a1530 1
  4,
d1536 1
a1536 1
  elf_write_relocs,
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
a68 1
#include "libiberty.h"
a124 2
#define elf_bfd_discard_info		NAME(bfd_elf,discard_info)
#define elf_reloc_symbol_deleted_p	NAME(_bfd_elf,reloc_symbol_deleted_p)
d170 1
a170 1
static bfd_boolean elf_slurp_reloc_table_from_section
d172 1
a172 1
	   arelent *, asymbol **, bfd_boolean));
d174 1
a174 1
static bfd_boolean elf_file_p PARAMS ((Elf_External_Ehdr *));
d187 4
a190 4
#define H_PUT_WORD		H_PUT_64
#define H_PUT_SIGNED_WORD	H_PUT_S64
#define H_GET_WORD		H_GET_64
#define H_GET_SIGNED_WORD	H_GET_S64
d193 4
a196 4
#define H_PUT_WORD		H_PUT_32
#define H_PUT_SIGNED_WORD	H_PUT_S32
#define H_GET_WORD		H_GET_32
#define H_GET_SIGNED_WORD	H_GET_S32
d203 1
a203 1
elf_swap_symbol_in (abfd, psrc, pshn, dst)
d205 1
a205 2
     const PTR psrc;
     const PTR pshn;
a207 2
  const Elf_External_Sym *src = (const Elf_External_Sym *) psrc;
  const Elf_External_Sym_Shndx *shndx = (const Elf_External_Sym_Shndx *) pshn;
d210 1
a210 1
  dst->st_name = H_GET_32 (abfd, src->st_name);
d212 1
a212 1
    dst->st_value = H_GET_SIGNED_WORD (abfd, src->st_value);
d214 5
a218 11
    dst->st_value = H_GET_WORD (abfd, src->st_value);
  dst->st_size = H_GET_WORD (abfd, src->st_size);
  dst->st_info = H_GET_8 (abfd, src->st_info);
  dst->st_other = H_GET_8 (abfd, src->st_other);
  dst->st_shndx = H_GET_16 (abfd, src->st_shndx);
  if (dst->st_shndx == SHN_XINDEX)
    {
      if (shndx == NULL)
	abort ();
      dst->st_shndx = H_GET_32 (abfd, shndx->est_shndx);
    }
d225 1
a225 1
elf_swap_symbol_out (abfd, src, cdst, shndx)
a228 1
     PTR shndx;
a229 1
  unsigned int tmp;
d231 6
a236 14
  H_PUT_32 (abfd, src->st_name, dst->st_name);
  H_PUT_WORD (abfd, src->st_value, dst->st_value);
  H_PUT_WORD (abfd, src->st_size, dst->st_size);
  H_PUT_8 (abfd, src->st_info, dst->st_info);
  H_PUT_8 (abfd, src->st_other, dst->st_other);
  tmp = src->st_shndx;
  if (tmp > SHN_HIRESERVE)
    {
      if (shndx == NULL)
	abort ();
      H_PUT_32 (abfd, tmp, shndx);
      tmp = SHN_XINDEX;
    }
  H_PUT_16 (abfd, tmp, dst->st_shndx);
d250 3
a252 3
  dst->e_type = H_GET_16 (abfd, src->e_type);
  dst->e_machine = H_GET_16 (abfd, src->e_machine);
  dst->e_version = H_GET_32 (abfd, src->e_version);
d254 1
a254 1
    dst->e_entry = H_GET_SIGNED_WORD (abfd, src->e_entry);
d256 10
a265 10
    dst->e_entry = H_GET_WORD (abfd, src->e_entry);
  dst->e_phoff = H_GET_WORD (abfd, src->e_phoff);
  dst->e_shoff = H_GET_WORD (abfd, src->e_shoff);
  dst->e_flags = H_GET_32 (abfd, src->e_flags);
  dst->e_ehsize = H_GET_16 (abfd, src->e_ehsize);
  dst->e_phentsize = H_GET_16 (abfd, src->e_phentsize);
  dst->e_phnum = H_GET_16 (abfd, src->e_phnum);
  dst->e_shentsize = H_GET_16 (abfd, src->e_shentsize);
  dst->e_shnum = H_GET_16 (abfd, src->e_shnum);
  dst->e_shstrndx = H_GET_16 (abfd, src->e_shstrndx);
a276 1
  unsigned int tmp;
d280 3
a282 3
  H_PUT_16 (abfd, src->e_type, dst->e_type);
  H_PUT_16 (abfd, src->e_machine, dst->e_machine);
  H_PUT_32 (abfd, src->e_version, dst->e_version);
d284 1
a284 1
    H_PUT_SIGNED_WORD (abfd, src->e_entry, dst->e_entry);
d286 10
a295 16
    H_PUT_WORD (abfd, src->e_entry, dst->e_entry);
  H_PUT_WORD (abfd, src->e_phoff, dst->e_phoff);
  H_PUT_WORD (abfd, src->e_shoff, dst->e_shoff);
  H_PUT_32 (abfd, src->e_flags, dst->e_flags);
  H_PUT_16 (abfd, src->e_ehsize, dst->e_ehsize);
  H_PUT_16 (abfd, src->e_phentsize, dst->e_phentsize);
  H_PUT_16 (abfd, src->e_phnum, dst->e_phnum);
  H_PUT_16 (abfd, src->e_shentsize, dst->e_shentsize);
  tmp = src->e_shnum;
  if (tmp >= SHN_LORESERVE)
    tmp = SHN_UNDEF;
  H_PUT_16 (abfd, tmp, dst->e_shnum);
  tmp = src->e_shstrndx;
  if (tmp >= SHN_LORESERVE)
    tmp = SHN_XINDEX;
  H_PUT_16 (abfd, tmp, dst->e_shstrndx);
d309 3
a311 3
  dst->sh_name = H_GET_32 (abfd, src->sh_name);
  dst->sh_type = H_GET_32 (abfd, src->sh_type);
  dst->sh_flags = H_GET_WORD (abfd, src->sh_flags);
d313 1
a313 1
    dst->sh_addr = H_GET_SIGNED_WORD (abfd, src->sh_addr);
d315 7
a321 7
    dst->sh_addr = H_GET_WORD (abfd, src->sh_addr);
  dst->sh_offset = H_GET_WORD (abfd, src->sh_offset);
  dst->sh_size = H_GET_WORD (abfd, src->sh_size);
  dst->sh_link = H_GET_32 (abfd, src->sh_link);
  dst->sh_info = H_GET_32 (abfd, src->sh_info);
  dst->sh_addralign = H_GET_WORD (abfd, src->sh_addralign);
  dst->sh_entsize = H_GET_WORD (abfd, src->sh_entsize);
d336 10
a345 10
  H_PUT_32 (abfd, src->sh_name, dst->sh_name);
  H_PUT_32 (abfd, src->sh_type, dst->sh_type);
  H_PUT_WORD (abfd, src->sh_flags, dst->sh_flags);
  H_PUT_WORD (abfd, src->sh_addr, dst->sh_addr);
  H_PUT_WORD (abfd, src->sh_offset, dst->sh_offset);
  H_PUT_WORD (abfd, src->sh_size, dst->sh_size);
  H_PUT_32 (abfd, src->sh_link, dst->sh_link);
  H_PUT_32 (abfd, src->sh_info, dst->sh_info);
  H_PUT_WORD (abfd, src->sh_addralign, dst->sh_addralign);
  H_PUT_WORD (abfd, src->sh_entsize, dst->sh_entsize);
d359 3
a361 3
  dst->p_type = H_GET_32 (abfd, src->p_type);
  dst->p_flags = H_GET_32 (abfd, src->p_flags);
  dst->p_offset = H_GET_WORD (abfd, src->p_offset);
d364 2
a365 2
      dst->p_vaddr = H_GET_SIGNED_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_SIGNED_WORD (abfd, src->p_paddr);
d369 2
a370 2
      dst->p_vaddr = H_GET_WORD (abfd, src->p_vaddr);
      dst->p_paddr = H_GET_WORD (abfd, src->p_paddr);
d372 3
a374 3
  dst->p_filesz = H_GET_WORD (abfd, src->p_filesz);
  dst->p_memsz = H_GET_WORD (abfd, src->p_memsz);
  dst->p_align = H_GET_WORD (abfd, src->p_align);
d384 8
a391 8
  H_PUT_32 (abfd, src->p_type, dst->p_type);
  H_PUT_WORD (abfd, src->p_offset, dst->p_offset);
  H_PUT_WORD (abfd, src->p_vaddr, dst->p_vaddr);
  H_PUT_WORD (abfd, src->p_paddr, dst->p_paddr);
  H_PUT_WORD (abfd, src->p_filesz, dst->p_filesz);
  H_PUT_WORD (abfd, src->p_memsz, dst->p_memsz);
  H_PUT_32 (abfd, src->p_flags, dst->p_flags);
  H_PUT_WORD (abfd, src->p_align, dst->p_align);
d395 2
a396 2
void
elf_swap_reloc_in (abfd, s, dst)
d398 2
a399 2
     const bfd_byte *s;
     Elf_Internal_Rela *dst;
d401 2
a402 4
  const Elf_External_Rel *src = (const Elf_External_Rel *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = 0;
d405 2
a406 2
void
elf_swap_reloca_in (abfd, s, dst)
d408 1
a408 1
     const bfd_byte *s;
d411 3
a413 4
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = H_GET_SIGNED_WORD (abfd, src->r_addend);
d417 2
a418 2
void
elf_swap_reloc_out (abfd, src, d)
d420 2
a421 2
     const Elf_Internal_Rela *src;
     bfd_byte *d;
d423 2
a424 3
  Elf_External_Rel *dst = (Elf_External_Rel *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
d427 2
a428 2
void
elf_swap_reloca_out (abfd, src, d)
d431 1
a431 1
     bfd_byte *d;
d433 3
a435 4
  Elf_External_Rela *dst = (Elf_External_Rela *) d;
  H_PUT_WORD (abfd, src->r_offset, dst->r_offset);
  H_PUT_WORD (abfd, src->r_info, dst->r_info);
  H_PUT_SIGNED_WORD (abfd, src->r_addend, dst->r_addend);
d446 2
a447 2
  dst->d_tag = H_GET_WORD (abfd, src->d_tag);
  dst->d_un.d_val = H_GET_WORD (abfd, src->d_un.d_val);
d458 2
a459 2
  H_PUT_WORD (abfd, src->d_tag, dst->d_tag);
  H_PUT_WORD (abfd, src->d_un.d_val, dst->d_un.d_val);
d469 1
a469 1
static INLINE bfd_boolean
d494 1
a494 2
  Elf_Internal_Shdr i_shdr;
  Elf_Internal_Shdr *i_shdrp;	/* Section header table, internal form */
d498 6
a503 1
  struct bfd_preserve preserve;
a504 1
  bfd_size_type amt;
d506 4
a509 1
  preserve.marker = NULL;
d513 1
a513 2
  if (bfd_bread ((PTR) & x_ehdr, (bfd_size_type) sizeof (x_ehdr), abfd)
      != sizeof (x_ehdr))
d527 3
a529 3
  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
d551 3
a553 5
  amt = sizeof (struct elf_obj_tdata);
  preserve.marker = bfd_zalloc (abfd, amt);
  if (preserve.marker == NULL)
    goto got_no_match;
  if (!bfd_preserve_save (abfd, &preserve))
d555 1
a555 2

  elf_tdata (abfd) = preserve.marker;
d568 2
a569 3
  /* If this is a relocatable file and there is no section header
     table, then we're hosed.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_type == ET_REL)
d574 2
a575 6
     recorded in the file, but only if there are any sections.  */
  if (i_ehdrp->e_shentsize != sizeof (x_shdr) && i_ehdrp->e_shnum != 0)
    goto got_wrong_format_error;

  /* Further sanity check.  */
  if (i_ehdrp->e_shoff == 0 && i_ehdrp->e_shnum != 0)
d583 2
a584 4
      && (ebd->elf_machine_alt1 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt1)
      && (ebd->elf_machine_alt2 == 0
	  || i_ehdrp->e_machine != ebd->elf_machine_alt2))
a630 23
  if (i_ehdrp->e_shoff != 0)
    {
      /* Seek to the section header table in the file.  */
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_shoff, SEEK_SET) != 0)
	goto got_no_match;

      /* Read the first section header at index 0, and convert to internal
	 form.  */
      if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	  != sizeof (x_shdr))
	goto got_no_match;
      elf_swap_shdr_in (abfd, &x_shdr, &i_shdr);

      /* If the section count is zero, the actual count is in the first
	 section header.  */
      if (i_ehdrp->e_shnum == SHN_UNDEF)
	i_ehdrp->e_shnum = i_shdr.sh_size;

      /* And similarly for the string table index.  */
      if (i_ehdrp->e_shstrndx == SHN_XINDEX)
	i_ehdrp->e_shstrndx = i_shdr.sh_link;
    }

d632 12
a643 2
     internal form.  */
  if (i_ehdrp->e_shnum != 0)
d645 1
a645 14
      Elf_Internal_Shdr *shdrp;
      unsigned int num_sec;

      amt = sizeof (*i_shdrp) * i_ehdrp->e_shnum;
      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
      if (!i_shdrp)
	goto got_no_match;
      num_sec = i_ehdrp->e_shnum;
      if (num_sec > SHN_LORESERVE)
	num_sec += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      elf_numsections (abfd) = num_sec;
      amt = sizeof (i_shdrp) * num_sec;
      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
      if (!elf_elfsections (abfd))
d647 2
d650 8
a657 32
      memcpy (i_shdrp, &i_shdr, sizeof (*i_shdrp));
      shdrp = i_shdrp;
      shindex = 0;
      if (num_sec > SHN_LORESERVE)
	{
	  for ( ; shindex < SHN_LORESERVE; shindex++)
	    elf_elfsections (abfd)[shindex] = shdrp++;
	  for ( ; shindex < SHN_HIRESERVE + 1; shindex++)
	    elf_elfsections (abfd)[shindex] = i_shdrp;
	}
      for ( ; shindex < num_sec; shindex++)
	elf_elfsections (abfd)[shindex] = shdrp++;

      /* Read in the rest of the section header table and convert it
	 to internal form.  */
      for (shindex = 1; shindex < i_ehdrp->e_shnum; shindex++)
	{
	  if (bfd_bread ((PTR) & x_shdr, (bfd_size_type) sizeof x_shdr, abfd)
	      != sizeof (x_shdr))
	    goto got_no_match;
	  elf_swap_shdr_in (abfd, &x_shdr, i_shdrp + shindex);

	  /* If the section is loaded, but not page aligned, clear
	     D_PAGED.  */
	  if (i_shdrp[shindex].sh_size != 0
	      && (i_shdrp[shindex].sh_flags & SHF_ALLOC) != 0
	      && i_shdrp[shindex].sh_type != SHT_NOBITS
	      && (((i_shdrp[shindex].sh_addr - i_shdrp[shindex].sh_offset)
		   % ebd->maxpagesize)
		  != 0))
	    abfd->flags &= ~D_PAGED;
	}
d659 1
a659 2

  if (i_ehdrp->e_shstrndx && i_ehdrp->e_shoff)
d673 4
a676 2
      amt = i_ehdrp->e_phnum * sizeof (Elf_Internal_Phdr);
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d679 1
a679 1
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
d686 1
a686 1
	  if (bfd_bread ((PTR) &x_phdr, (bfd_size_type) sizeof x_phdr, abfd)
d699 9
a707 1
  if (i_ehdrp->e_shstrndx != 0 && i_ehdrp->e_shoff)
d709 1
a709 4
      unsigned int num_sec;

      shstrtab = bfd_elf_get_str_section (abfd, i_ehdrp->e_shstrndx);
      if (!shstrtab)
a710 12

      /* Once all of the section headers have been read and converted, we
	 can start processing them.  Note that the first section header is
	 a dummy placeholder entry, so we ignore it.  */
      num_sec = elf_numsections (abfd);
      for (shindex = 1; shindex < num_sec; shindex++)
	{
	  if (! bfd_section_from_shdr (abfd, shindex))
	    goto got_no_match;
	  if (shindex == SHN_LORESERVE - 1)
	    shindex += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
d717 1
a717 1
      if (! (*ebd->elf_backend_object_p) (abfd))
d740 1
a740 2
  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;
d752 1
a753 1

d755 11
a765 3
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
  return NULL;
d778 1
a778 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d780 2
a781 4
  bfd_vma addr_offset;
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
  size_t extsize;
  bfd_byte *dst_rela;
d783 3
a785 2
  asymbol *last_sym;
  int last_sym_idx;
d807 1
a807 1
      *failedp = TRUE;
d813 1
a813 4
    {
      swap_out = elf_swap_reloca_out;
      extsize = sizeof (Elf_External_Rela);
    }
d815 1
a815 4
    {
      swap_out = elf_swap_reloc_out;
      extsize = sizeof (Elf_External_Rel);
    }
d821 4
a824 6
  /* The address of an ELF reloc is section relative for an object
     file, and absolute for an executable file or shared library.
     The address of a BFD reloc is always section relative.  */
  addr_offset = 0;
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    addr_offset = sec->vma;
d826 1
a826 19
  /* orelocation has the data, reloc_count has the count...  */
  last_sym = 0;
  last_sym_idx = 0;
  dst_rela = rela_hdr->contents;

  for (idx = 0; idx < sec->reloc_count; idx++, dst_rela += extsize)
    {
      Elf_Internal_Rela src_rela;
      arelent *ptr;
      asymbol *sym;
      int n;

      ptr = sec->orelocation[idx];
      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
d828 23
a850 3
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
d852 15
a866 1
	      *failedp = TRUE;
d869 5
a873 1
	  last_sym_idx = n;
d875 5
d881 1
a881 3
      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL
	  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
d883 45
a927 2
	  *failedp = TRUE;
	  return;
a928 5

      src_rela.r_offset = ptr->address + addr_offset;
      src_rela.r_info = ELF_R_INFO (n, ptr->howto->type);
      src_rela.r_addend = ptr->addend;
      (*swap_out) (abfd, &src_rela, dst_rela);
d938 1
a938 1
     unsigned int count;
d944 2
a945 2
      if (bfd_bwrite (&extphdr, (bfd_size_type) sizeof (Elf_External_Phdr),
		     abfd) != sizeof (Elf_External_Phdr))
d954 1
a954 1
bfd_boolean
a962 1
  bfd_size_type amt;
a972 1
  amt = sizeof (x_ehdr);
d974 3
a976 9
      || bfd_bwrite ((PTR) & x_ehdr, amt, abfd) != amt)
    return FALSE;

  /* Some fields in the first section header handle overflow of ehdr
     fields.  */
  if (i_ehdrp->e_shnum >= SHN_LORESERVE)
    i_shdrp[0]->sh_size = i_ehdrp->e_shnum;
  if (i_ehdrp->e_shstrndx >= SHN_LORESERVE)
    i_shdrp[0]->sh_link = i_ehdrp->e_shstrndx;
d979 2
a980 3
  amt = i_ehdrp->e_shnum;
  amt *= sizeof (*x_shdrp);
  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);
d982 1
a982 1
    return FALSE;
d984 1
a984 1
  for (count = 0; count < i_ehdrp->e_shnum; i_shdrp++, count++)
d987 1
a987 1
      elf_debug_section (count, *i_shdrp);
d989 1
a989 4
      elf_swap_shdr_out (abfd, *i_shdrp, x_shdrp + count);

      if (count == SHN_LORESERVE - 1)
	i_shdrp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
d992 3
a994 2
      || bfd_bwrite ((PTR) x_shdrp, amt, abfd) != amt)
    return FALSE;
d998 1
a998 1
  return TRUE;
d1005 1
a1005 1
     bfd_boolean dynamic;
d1012 3
a1014 7
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_External_Versym *xver;
  Elf_External_Versym *xverbuf = NULL;
  struct elf_backend_data *ebd;
  bfd_size_type amt;
d1048 3
a1050 1
  ebd = get_elf_backend_data (abfd);
d1052 1
d1057 3
a1059 3
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
d1062 2
a1063 3
      amt = symcount;
      amt *= sizeof (elf_symbol_type);
      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d1065 11
d1079 1
d1099 2
a1100 2
	  xverbuf = (Elf_External_Versym *) bfd_malloc (verhdr->sh_size);
	  if (xverbuf == NULL && verhdr->sh_size != 0)
d1103 1
a1103 1
	  if (bfd_bread ((PTR) xverbuf, verhdr->sh_size, abfd)
d1109 1
a1109 5
      xver = xverbuf;
      if (xver != NULL)
	++xver;
      isymend = isymbuf + symcount;
      for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
d1111 5
a1115 1
	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));
d1120 1
a1120 1
							      isym->st_name);
d1122 1
a1122 1
	  sym->symbol.value = isym->st_value;
d1124 1
a1124 6
	  if (isym->st_shndx == SHN_UNDEF)
	    {
	      sym->symbol.section = bfd_und_section_ptr;
	    }
	  else if (isym->st_shndx < SHN_LORESERVE
		   || isym->st_shndx > SHN_HIRESERVE)
d1127 1
a1127 1
							    isym->st_shndx);
d1136 1
a1136 1
	  else if (isym->st_shndx == SHN_ABS)
d1140 1
a1140 1
	  else if (isym->st_shndx == SHN_COMMON)
d1147 5
a1151 1
	      sym->symbol.value = isym->st_size;
d1161 1
a1161 1
	  switch (ELF_ST_BIND (isym->st_info))
d1167 2
a1168 1
	      if (isym->st_shndx != SHN_UNDEF && isym->st_shndx != SHN_COMMON)
d1176 1
a1176 1
	  switch (ELF_ST_TYPE (isym->st_info))
d1195 1
a1195 1
	  if (xver != NULL)
d1199 1
a1199 1
	      _bfd_elf_swap_versym_in (abfd, xver, &iversym);
a1200 1
	      xver++;
d1204 7
a1210 2
	  if (ebd->elf_backend_symbol_processing)
	    (*ebd->elf_backend_symbol_processing) (abfd, &sym->symbol);
d1215 5
a1219 2
  if (ebd->elf_backend_symbol_table_processing)
    (*ebd->elf_backend_symbol_table_processing) (abfd, symbase, symcount);
d1239 4
a1242 4
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
a1243 1

d1245 4
a1248 4
  if (xverbuf != NULL)
    free (xverbuf);
  if (isymbuf != NULL && hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
d1255 1
a1255 1
static bfd_boolean
d1264 1
a1264 1
     bfd_boolean dynamic;
a1271 1
  unsigned int symcount;
d1273 1
a1273 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d1278 1
a1278 1
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
a1287 5
  if (dynamic)
    symcount = bfd_get_dynamic_symcount (abfd);
  else
    symcount = bfd_get_symcount (abfd);

d1293 1
d1296 1
a1296 1
	elf_swap_reloca_in (abfd, native_relocs, &rela);
d1298 6
a1303 1
	elf_swap_reloc_in (abfd, native_relocs, &rela);
a1315 7
      else if (ELF_R_SYM (rela.r_info) > symcount)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s): relocation %d has invalid symbol index %ld"),
	     abfd->filename, asect->name, i, ELF_R_SYM (rela.r_info));
	  relent->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;
	}
d1332 1
a1332 3
      if ((entsize == sizeof (Elf_External_Rela)
	   && ebd->elf_info_to_howto != NULL)
	  || ebd->elf_info_to_howto_rel == NULL)
d1335 1
a1335 1
	(*ebd->elf_info_to_howto_rel) (abfd, relent, &rela);
d1341 1
a1341 1
  return TRUE;
d1346 1
a1346 1
  return FALSE;
d1351 1
a1351 1
bfd_boolean
d1356 1
a1356 1
     bfd_boolean dynamic;
a1363 1
  bfd_size_type amt;
d1366 1
a1366 1
    return TRUE;
d1372 1
a1372 1
	return TRUE;
d1391 1
a1391 1
	return TRUE;
d1399 3
a1401 2
  amt = (reloc_count + reloc_count2) * sizeof (arelent);
  relents = (arelent *) bfd_alloc (abfd, amt);
d1403 1
a1403 1
    return FALSE;
d1409 1
a1409 1
    return FALSE;
d1416 1
a1416 1
    return FALSE;
d1419 1
a1419 1
  return TRUE;
a1556 1
  elf_swap_symbol_in,
d1562 4
a1565 4
  elf_swap_reloc_in,
  elf_swap_reloc_out,
  elf_swap_reloca_in,
  elf_swap_reloca_out
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d105 1
a105 1
#define elf_canonicalize_symtab		NAME(bfd_elf,canonicalize_symtab)
d118 2
d124 16
d158 21
d180 3
a182 3
static void elf_debug_section (int, Elf_Internal_Shdr *);
static void elf_debug_file (Elf_Internal_Ehdr *);
static char *elf_symbol_flags (flagword);
d206 5
a210 4
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
d212 2
a213 2
  const Elf_External_Sym *src = psrc;
  const Elf_External_Sym_Shndx *shndx = pshn;
d237 5
a241 4
elf_swap_symbol_out (bfd *abfd,
		     const Elf_Internal_Sym *src,
		     void *cdst,
		     void *shndx)
d244 1
a244 1
  Elf_External_Sym *dst = cdst;
d265 4
a268 3
elf_swap_ehdr_in (bfd *abfd,
		  const Elf_External_Ehdr *src,
		  Elf_Internal_Ehdr *dst)
d294 4
a297 3
elf_swap_ehdr_out (bfd *abfd,
		   const Elf_Internal_Ehdr *src,
		   Elf_External_Ehdr *dst)
d331 4
a334 3
elf_swap_shdr_in (bfd *abfd,
		  const Elf_External_Shdr *src,
		  Elf_Internal_Shdr *dst)
d359 4
a362 3
elf_swap_shdr_out (bfd *abfd,
		   const Elf_Internal_Shdr *src,
		   Elf_External_Shdr *dst)
d381 4
a384 3
elf_swap_phdr_in (bfd *abfd,
		  const Elf_External_Phdr *src,
		  Elf_Internal_Phdr *dst)
d407 4
a410 3
elf_swap_phdr_out (bfd *abfd,
		   const Elf_Internal_Phdr *src,
		   Elf_External_Phdr *dst)
d425 4
a428 3
elf_swap_reloc_in (bfd *abfd,
		   const bfd_byte *s,
		   Elf_Internal_Rela *dst)
d437 4
a440 3
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
d450 4
a453 3
elf_swap_reloc_out (bfd *abfd,
		    const Elf_Internal_Rela *src,
		    bfd_byte *d)
d461 4
a464 3
elf_swap_reloca_out (bfd *abfd,
		     const Elf_Internal_Rela *src,
		     bfd_byte *d)
d472 5
a476 4
void
elf_swap_dyn_in (bfd *abfd,
		 const void *p,
		 Elf_Internal_Dyn *dst)
d478 1
a478 1
  const Elf_External_Dyn *src = p;
d484 5
a488 4
void
elf_swap_dyn_out (bfd *abfd,
		  const Elf_Internal_Dyn *src,
		  void *p)
d490 1
a490 1
  Elf_External_Dyn *dst = p;
d503 3
a505 2
static inline bfd_boolean
elf_file_p (Elf_External_Ehdr *x_ehdrp)
d522 2
a523 1
elf_object_p (bfd *abfd)
d532 1
a532 1
  const struct elf_backend_data *ebd;
d541 2
a542 1
  if (bfd_bread (&x_ehdr, sizeof (x_ehdr), abfd) != sizeof (x_ehdr))
a576 3
  if (!bfd_preserve_save (abfd, &preserve))
    goto got_no_match;

d580 3
a582 1
  if (! (*abfd->xvec->_bfd_set_format[bfd_object]) (abfd))
d584 4
a587 1
  preserve.marker = elf_tdata (abfd);
d634 1
a634 1
	  const struct elf_backend_data *back;
d638 1
a638 1
	  back = (const struct elf_backend_data *) (*target_ptr)->backend_data;
d678 2
a679 1
      if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d701 1
a701 1
      i_shdrp = bfd_alloc (abfd, amt);
d709 1
a709 1
      elf_elfsections (abfd) = bfd_alloc (abfd, amt);
d730 2
a731 1
	  if (bfd_bread (&x_shdr, sizeof x_shdr, abfd) != sizeof (x_shdr))
d762 1
a762 1
      elf_tdata (abfd)->phdr = bfd_alloc (abfd, amt);
d772 2
a773 1
	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
d859 4
a862 1
elf_write_relocs (bfd *abfd, asection *sec, void *data)
d864 1
a864 1
  bfd_boolean *failedp = data;
d867 1
a867 1
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d891 1
a891 1
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d969 4
a972 3
elf_write_out_phdrs (bfd *abfd,
		     const Elf_Internal_Phdr *phdr,
		     unsigned int count)
d978 2
a979 2
      if (bfd_bwrite (&extphdr, sizeof (Elf_External_Phdr), abfd)
	  != sizeof (Elf_External_Phdr))
d989 2
a990 1
elf_write_shdrs_and_ehdr (bfd *abfd)
d1010 1
a1010 1
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)
d1023 1
a1023 1
  x_shdrp = bfd_alloc (abfd, amt);
d1038 1
a1038 1
      || bfd_bwrite (x_shdrp, amt, abfd) != amt)
d1047 4
a1050 1
elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
d1062 1
a1062 1
  const struct elf_backend_data *ebd;
d1110 1
a1110 1
      symbase = bfd_zalloc (abfd, amt);
d1134 1
a1134 1
	  xverbuf = bfd_malloc (verhdr->sh_size);
d1138 2
a1139 1
	  if (bfd_bread (xverbuf, verhdr->sh_size, abfd) != verhdr->sh_size)
d1166 2
a1167 2
	      sym->symbol.section = bfd_section_from_elf_index (abfd,
								isym->st_shndx);
d1192 1
a1192 1
	  /* If this is a relocatable file, then the symbol value is
d1285 9
a1293 7
elf_slurp_reloc_table_from_section (bfd *abfd,
				    asection *asect,
				    Elf_Internal_Shdr *rel_hdr,
				    bfd_size_type reloc_count,
				    arelent *relents,
				    asymbol **symbols,
				    bfd_boolean dynamic)
d1295 2
a1296 2
  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);
  void *allocated = NULL;
d1303 1
a1303 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d1312 1
a1312 1
  native_relocs = allocated;
d1390 5
a1394 4
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
d1439 1
a1439 1
  relents = bfd_alloc (abfd, amt);
d1462 3
a1464 1
elf_debug_section (int num, Elf_Internal_Shdr *hdr)
d1490 2
a1491 1
elf_debug_file (Elf_Internal_Ehdr *ehdrp)
d1503 2
a1504 1
elf_symbol_flags (flagword flags)
a1574 223
/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for a target with the word size and byte order found in the
   remote memory.  */

bfd *
NAME(_bfd_elf,bfd_from_remote_memory)
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  Elf_External_Ehdr x_ehdr;	/* Elf file header, external form */
  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
  Elf_External_Phdr *x_phdrs;
  Elf_Internal_Phdr *i_phdrs, *last_phdr;
  bfd *nbfd;
  struct bfd_in_memory *bim;
  int contents_size;
  char *contents;
  int err;
  unsigned int i;
  bfd_vma loadbase;

  /* Read in the ELF header in external format.  */
  err = target_read_memory (ehdr_vma, (char *) &x_ehdr, sizeof x_ehdr);
  if (err)
    {
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }

  /* Now check to see if we have a valid ELF file, and one that BFD can
     make use of.  The magic number must match, the address size ('class')
     and byte-swapping must match our XVEC entry.  */

  if (! elf_file_p (&x_ehdr)
      || x_ehdr.e_ident[EI_VERSION] != EV_CURRENT
      || x_ehdr.e_ident[EI_CLASS] != ELFCLASS)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Check that file's byte order matches xvec's */
  switch (x_ehdr.e_ident[EI_DATA])
    {
    case ELFDATA2MSB:		/* Big-endian */
      if (! bfd_header_big_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATA2LSB:		/* Little-endian */
      if (! bfd_header_little_endian (templ))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      break;
    case ELFDATANONE:		/* No data encoding specified */
    default:			/* Unknown data encoding specified */
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  elf_swap_ehdr_in (templ, &x_ehdr, &i_ehdr);

  /* The file header tells where to find the program headers.
     These are what we use to actually choose what to read.  */

  if (i_ehdr.e_phentsize != sizeof (Elf_External_Phdr) || i_ehdr.e_phnum == 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  x_phdrs = bfd_malloc (i_ehdr.e_phnum * (sizeof *x_phdrs + sizeof *i_phdrs));
  if (x_phdrs == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (char *) x_phdrs,
			    i_ehdr.e_phnum * sizeof x_phdrs[0]);
  if (err)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_system_call);
      errno = err;
      return NULL;
    }
  i_phdrs = (Elf_Internal_Phdr *) &x_phdrs[i_ehdr.e_phnum];

  contents_size = 0;
  last_phdr = NULL;
  loadbase = ehdr_vma;
  for (i = 0; i < i_ehdr.e_phnum; ++i)
    {
      elf_swap_phdr_in (templ, &x_phdrs[i], &i_phdrs[i]);
      if (i_phdrs[i].p_type == PT_LOAD)
	{
	  bfd_vma segment_end;
	  segment_end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
			 + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	  if (segment_end > (bfd_vma) contents_size)
	    contents_size = segment_end;

	  if ((i_phdrs[i].p_offset & -i_phdrs[i].p_align) == 0)
	    loadbase = ehdr_vma - (i_phdrs[i].p_vaddr & -i_phdrs[i].p_align);

	  last_phdr = &i_phdrs[i];
	}
    }
  if (last_phdr == NULL)
    {
      /* There were no PT_LOAD segments, so we don't have anything to read.  */
      free (x_phdrs);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Trim the last segment so we don't bother with zeros in the last page
     that are off the end of the file.  However, if the extra bit in that
     page includes the section headers, keep them.  */
  if ((bfd_vma) contents_size > last_phdr->p_offset + last_phdr->p_filesz
      && (bfd_vma) contents_size >= (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      contents_size = last_phdr->p_offset + last_phdr->p_filesz;
      if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				     + i_ehdr.e_shnum * i_ehdr.e_shentsize))
	contents_size = i_ehdr.e_shoff + i_ehdr.e_shnum * i_ehdr.e_shentsize;
    }
  else
    contents_size = last_phdr->p_offset + last_phdr->p_filesz;

  /* Now we know the size of the whole image we want read in.  */
  contents = bfd_zmalloc (contents_size);
  if (contents == NULL)
    {
      free (x_phdrs);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  for (i = 0; i < i_ehdr.e_phnum; ++i)
    if (i_phdrs[i].p_type == PT_LOAD)
      {
	bfd_vma start = i_phdrs[i].p_offset & -i_phdrs[i].p_align;
	bfd_vma end = (i_phdrs[i].p_offset + i_phdrs[i].p_filesz
		       + i_phdrs[i].p_align - 1) & -i_phdrs[i].p_align;
	if (end > (bfd_vma) contents_size)
	  end = contents_size;
	err = target_read_memory ((loadbase + i_phdrs[i].p_vaddr)
				  & -i_phdrs[i].p_align,
				  contents + start, end - start);
	if (err)
	  {
	    free (x_phdrs);
	    free (contents);
	    bfd_set_error (bfd_error_system_call);
	    errno = err;
	    return NULL;
	  }
      }
  free (x_phdrs);

  /* If the segments visible in memory didn't include the section headers,
     then clear them from the file header.  */
  if ((bfd_vma) contents_size < (i_ehdr.e_shoff
				 + i_ehdr.e_shnum * i_ehdr.e_shentsize))
    {
      memset (&x_ehdr.e_shoff, 0, sizeof x_ehdr.e_shoff);
      memset (&x_ehdr.e_shnum, 0, sizeof x_ehdr.e_shnum);
      memset (&x_ehdr.e_shstrndx, 0, sizeof x_ehdr.e_shstrndx);
    }

  /* This will normally have been in the first PT_LOAD segment.  But it
     conceivably could be missing, and we might have just changed it.  */
  memcpy (contents, &x_ehdr, sizeof x_ehdr);

  /* Now we have a memory image of the ELF file contents.  Make a BFD.  */
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  if (bim == NULL)
    {
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      free (bim);
      free (contents);
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
  nbfd->filename = "<in-memory>";
  nbfd->xvec = templ->xvec;
  bim->size = contents_size;
  bim->buffer = contents;
  nbfd->iostream = bim;
  nbfd->flags = BFD_IN_MEMORY;
  nbfd->direction = read_direction;
  nbfd->mtime = time (NULL);
  nbfd->mtime_set = TRUE;

  if (loadbasep)
    *loadbasep = loadbase;
  return nbfd;
}

d1576 1
d1590 1
a1590 1
  ARCH_SIZE, LOG_FILE_ALIGN,
@


