head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.50
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	FSF:1.1.1
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.18;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.33.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.01.11;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.05.59;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.05.59;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.38.15;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.12.47;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.19.51;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.47;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.26.21;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.18;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Intel Hex objects.
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor of Cygnus Support <ian@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This is what Intel Hex files look like:

1. INTEL FORMATS

A. Intel 1

   16-bit address-field format, for files 64k bytes in length or less.

   DATA RECORD
   Byte 1	Header = colon(:)
   2..3		The number of data bytes in hex notation
   4..5		High byte of the record load address
   6..7		Low byte of the record load address
   8..9		Record type, must be "00"
   10..x	Data bytes in hex notation:
	x = (number of bytes - 1) * 2 + 11
   x+1..x+2	Checksum in hex notation
   x+3..x+4	Carriage return, line feed

   END RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count, must be "00"
   4..7		Transfer-address (usually "0000")
		the jump-to address, execution start address
   8..9		Record type, must be "01"
   10..11	Checksum, in hex notation
   12..13	Carriage return, line feed

B. INTEL 2

   MCS-86 format, using a 20-bit address for files larger than 64K bytes.

   DATA RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count of this record, hex notation
   4..5		High byte of the record load address
   6..7		Low byte of the record load address
   8..9		Record type, must be "00"
   10..x	The data bytes in hex notation:
	x = (number of data bytes - 1) * 2 + 11
   x+1..x+2	Checksum in hex notation
   x+3..x+4	Carriage return, line feed

   EXTENDED ADDRESS RECORD
   Byte 1	Header = colon(:)
   2..3		The byte count, must be "02"
   4..7		Load address, must be "0000"
   8..9		Record type, must be "02"
   10..11	High byte of the offset address
   12..13	Low byte of the offset address
   14..15	Checksum in hex notation
   16..17	Carriage return, line feed

   The checksums are the two's complement of the 8-bit sum
   without carry of the byte count, offset address, and the
   record type.

   START ADDRESS RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count, must be "04"
   4..7		Load address, must be "0000"
   8..9		Record type, must be "03"
   10..13	8086 CS value
   14..17	8086 IP value
   18..19	Checksum in hex notation
   20..21	Carriage return, line feed

Another document reports these additional types:

   EXTENDED LINEAR ADDRESS RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count, must be "02"
   4..7		Load address, must be "0000"
   8..9		Record type, must be "04"
   10..13	Upper 16 bits of address of subsequent records
   14..15	Checksum in hex notation
   16..17	Carriage return, line feed

   START LINEAR ADDRESS RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count, must be "02"
   4..7		Load address, must be "0000"
   8..9		Record type, must be "05"
   10..13	Upper 16 bits of start address
   14..15	Checksum in hex notation
   16..17	Carriage return, line feed

The MRI compiler uses this, which is a repeat of type 5:

  EXTENDED START RECORD
   Byte 1	Header = colon (:)
   2..3		The byte count, must be "04"
   4..7		Load address, must be "0000"
   8..9		Record type, must be "05"
   10..13	Upper 16 bits of start address
   14..17	Lower 16 bits of start address
   18..19	Checksum in hex notation
   20..21	Carriage return, line feed
*/

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "libiberty.h"
#include "safe-ctype.h"

static void ihex_init
  PARAMS ((void));
static bfd_boolean ihex_mkobject
  PARAMS ((bfd *));
static INLINE int ihex_get_byte
  PARAMS ((bfd *, bfd_boolean *));
static void ihex_bad_byte
  PARAMS ((bfd *, unsigned int, int, bfd_boolean));
static bfd_boolean ihex_scan
  PARAMS ((bfd *));
static const bfd_target *ihex_object_p
  PARAMS ((bfd *));
static bfd_boolean ihex_read_section
  PARAMS ((bfd *, asection *, bfd_byte *));
static bfd_boolean ihex_get_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
static bfd_boolean ihex_set_section_contents
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
static bfd_boolean ihex_write_record
  PARAMS ((bfd *, size_t, unsigned int, unsigned int, bfd_byte *));
static bfd_boolean ihex_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean ihex_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static int ihex_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

/* The number of bytes we put on one line during output.  */

#define CHUNK 16

/* Macros for converting between hex and binary.  */

#define NIBBLE(x)    (hex_value (x))
#define HEX2(buffer) ((NIBBLE ((buffer)[0]) << 4) + NIBBLE ((buffer)[1]))
#define HEX4(buffer) ((HEX2 (buffer) << 8) + HEX2 ((buffer) + 2))
#define ISHEX(x)     (hex_p (x))

/* When we write out an ihex value, the values can not be output as
   they are seen.  Instead, we hold them in memory in this structure.  */

struct ihex_data_list
{
  struct ihex_data_list *next;
  bfd_byte *data;
  bfd_vma where;
  bfd_size_type size;
};

/* The ihex tdata information.  */

struct ihex_data_struct
{
  struct ihex_data_list *head;
  struct ihex_data_list *tail;
};

/* Initialize by filling in the hex conversion array.  */

static void
ihex_init ()
{
  static bfd_boolean inited;

  if (! inited)
    {
      inited = TRUE;
      hex_init ();
    }
}

/* Create an ihex object.  */

static bfd_boolean
ihex_mkobject (abfd)
     bfd *abfd;
{
  struct ihex_data_struct *tdata;
  bfd_size_type amt = sizeof (struct ihex_data_struct);

  tdata = (struct ihex_data_struct *) bfd_alloc (abfd, amt);
  if (tdata == NULL)
    return FALSE;

  abfd->tdata.ihex_data = tdata;
  tdata->head = NULL;
  tdata->tail = NULL;
  return TRUE;
}

/* Read a byte from a BFD.  Set *ERRORPTR if an error occurred.
   Return EOF on error or end of file.  */

static INLINE int
ihex_get_byte (abfd, errorptr)
     bfd *abfd;
     bfd_boolean *errorptr;
{
  bfd_byte c;

  if (bfd_bread (&c, (bfd_size_type) 1, abfd) != 1)
    {
      if (bfd_get_error () != bfd_error_file_truncated)
	*errorptr = TRUE;
      return EOF;
    }

  return (int) (c & 0xff);
}

/* Report a problem in an Intel Hex file.  */

static void
ihex_bad_byte (abfd, lineno, c, error)
     bfd *abfd;
     unsigned int lineno;
     int c;
     bfd_boolean error;
{
  if (c == EOF)
    {
      if (! error)
	bfd_set_error (bfd_error_file_truncated);
    }
  else
    {
      char buf[10];

      if (! ISPRINT (c))
	sprintf (buf, "\\%03o", (unsigned int) c);
      else
	{
	  buf[0] = c;
	  buf[1] = '\0';
	}
      (*_bfd_error_handler)
	(_("%s:%d: unexpected character `%s' in Intel Hex file\n"),
	 bfd_archive_filename (abfd), lineno, buf);
      bfd_set_error (bfd_error_bad_value);
    }
}

/* Read an Intel hex file and turn it into sections.  We create a new
   section for each contiguous set of bytes.  */

static bfd_boolean
ihex_scan (abfd)
     bfd *abfd;
{
  bfd_vma segbase;
  bfd_vma extbase;
  asection *sec;
  unsigned int lineno;
  bfd_boolean error;
  bfd_byte *buf = NULL;
  size_t bufsize;
  int c;

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto error_return;

  abfd->start_address = 0;

  segbase = 0;
  extbase = 0;
  sec = NULL;
  lineno = 1;
  error = FALSE;
  bufsize = 0;

  while ((c = ihex_get_byte (abfd, &error)) != EOF)
    {
      if (c == '\r')
	continue;
      else if (c == '\n')
	{
	  ++lineno;
	  continue;
	}
      else if (c != ':')
	{
	  ihex_bad_byte (abfd, lineno, c, error);
	  goto error_return;
	}
      else
	{
	  file_ptr pos;
	  char hdr[8];
	  unsigned int i;
	  unsigned int len;
	  bfd_vma addr;
	  unsigned int type;
	  unsigned int chars;
	  unsigned int chksum;

	  /* This is a data record.  */
	  pos = bfd_tell (abfd) - 1;

	  /* Read the header bytes.  */
	  if (bfd_bread (hdr, (bfd_size_type) 8, abfd) != 8)
	    goto error_return;

	  for (i = 0; i < 8; i++)
	    {
	      if (! ISHEX (hdr[i]))
		{
		  ihex_bad_byte (abfd, lineno, hdr[i], error);
		  goto error_return;
		}
	    }

	  len = HEX2 (hdr);
	  addr = HEX4 (hdr + 2);
	  type = HEX2 (hdr + 6);

	  /* Read the data bytes.  */
	  chars = len * 2 + 2;
	  if (chars >= bufsize)
	    {
	      buf = (bfd_byte *) bfd_realloc (buf, (bfd_size_type) chars);
	      if (buf == NULL)
		goto error_return;
	      bufsize = chars;
	    }

	  if (bfd_bread (buf, (bfd_size_type) chars, abfd) != chars)
	    goto error_return;

	  for (i = 0; i < chars; i++)
	    {
	      if (! ISHEX (buf[i]))
		{
		  ihex_bad_byte (abfd, lineno, hdr[i], error);
		  goto error_return;
		}
	    }

	  /* Check the checksum.  */
	  chksum = len + addr + (addr >> 8) + type;
	  for (i = 0; i < len; i++)
	    chksum += HEX2 (buf + 2 * i);
	  if (((- chksum) & 0xff) != (unsigned int) HEX2 (buf + 2 * i))
	    {
	      (*_bfd_error_handler)
		(_("%s:%u: bad checksum in Intel Hex file (expected %u, found %u)"),
		 bfd_archive_filename (abfd), lineno,
		 (- chksum) & 0xff, (unsigned int) HEX2 (buf + 2 * i));
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

	  switch (type)
	    {
	    case 0:
	      /* This is a data record.  */
	      if (sec != NULL
		  && sec->vma + sec->_raw_size == extbase + segbase + addr)
		{
		  /* This data goes at the end of the section we are
                     currently building.  */
		  sec->_raw_size += len;
		}
	      else if (len > 0)
		{
		  char secbuf[20];
		  char *secname;
		  bfd_size_type amt;

		  sprintf (secbuf, ".sec%d", bfd_count_sections (abfd) + 1);
		  amt = strlen (secbuf) + 1;
		  secname = (char *) bfd_alloc (abfd, amt);
		  if (secname == NULL)
		    goto error_return;
		  strcpy (secname, secbuf);
		  sec = bfd_make_section (abfd, secname);
		  if (sec == NULL)
		    goto error_return;
		  sec->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC;
		  sec->vma = extbase + segbase + addr;
		  sec->lma = extbase + segbase + addr;
		  sec->_raw_size = len;
		  sec->filepos = pos;
		}
	      break;

	    case 1:
	      /* An end record.  */
	      if (abfd->start_address == 0)
		abfd->start_address = addr;
	      if (buf != NULL)
		free (buf);
	      return TRUE;

	    case 2:
	      /* An extended address record.  */
	      if (len != 2)
		{
		  (*_bfd_error_handler)
		    (_("%s:%u: bad extended address record length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      segbase = HEX4 (buf) << 4;

	      sec = NULL;

	      break;

	    case 3:
	      /* An extended start address record.  */
	      if (len != 4)
		{
		  (*_bfd_error_handler)
		    (_("%s:%u: bad extended start address length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      abfd->start_address += (HEX4 (buf) << 4) + HEX4 (buf + 4);

	      sec = NULL;

	      break;

	    case 4:
	      /* An extended linear address record.  */
	      if (len != 2)
		{
		  (*_bfd_error_handler)
		    (_("%s:%u: bad extended linear address record length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      extbase = HEX4 (buf) << 16;

	      sec = NULL;

	      break;

	    case 5:
	      /* An extended linear start address record.  */
	      if (len != 2 && len != 4)
		{
		  (*_bfd_error_handler)
		    (_("%s:%u: bad extended linear start address length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      if (len == 2)
		abfd->start_address += HEX4 (buf) << 16;
	      else
		abfd->start_address = (HEX4 (buf) << 16) + HEX4 (buf + 4);

	      sec = NULL;

	      break;

	    default:
	      (*_bfd_error_handler)
		(_("%s:%u: unrecognized ihex type %u in Intel Hex file\n"),
		 bfd_archive_filename (abfd), lineno, type);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
	}
    }

  if (error)
    goto error_return;

  if (buf != NULL)
    free (buf);

  return TRUE;

 error_return:
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Try to recognize an Intel Hex file.  */

static const bfd_target *
ihex_object_p (abfd)
     bfd *abfd;
{
  PTR tdata_save;
  bfd_byte b[9];
  unsigned int i;
  unsigned int type;

  ihex_init ();

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return NULL;
  if (bfd_bread (b, (bfd_size_type) 9, abfd) != 9)
    {
      if (bfd_get_error () == bfd_error_file_truncated)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (b[0] != ':')
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  for (i = 1; i < 9; i++)
    {
      if (! ISHEX (b[i]))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
    }

  type = HEX2 (b + 7);
  if (type > 5)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* OK, it looks like it really is an Intel Hex file.  */
  tdata_save = abfd->tdata.any;
  if (! ihex_mkobject (abfd) || ! ihex_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }

  return abfd->xvec;
}

/* Read the contents of a section in an Intel Hex file.  */

static bfd_boolean
ihex_read_section (abfd, section, contents)
     bfd *abfd;
     asection *section;
     bfd_byte *contents;
{
  int c;
  bfd_byte *p;
  bfd_byte *buf = NULL;
  size_t bufsize;
  bfd_boolean error;

  if (bfd_seek (abfd, section->filepos, SEEK_SET) != 0)
    goto error_return;

  p = contents;
  bufsize = 0;
  error = FALSE;
  while ((c = ihex_get_byte (abfd, &error)) != EOF)
    {
      char hdr[8];
      unsigned int len;
      bfd_vma addr;
      unsigned int type;
      unsigned int i;

      if (c == '\r' || c == '\n')
	continue;

      /* This is called after ihex_scan has succeeded, so we ought to
         know the exact format.  */
      BFD_ASSERT (c == ':');

      if (bfd_bread (hdr, (bfd_size_type) 8, abfd) != 8)
	goto error_return;

      len = HEX2 (hdr);
      addr = HEX4 (hdr + 2);
      type = HEX2 (hdr + 6);

      /* We should only see type 0 records here.  */
      if (type != 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: internal error in ihex_read_section"),
	     bfd_archive_filename (abfd));
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}

      if (len * 2 > bufsize)
	{
	  buf = (bfd_byte *) bfd_realloc (buf, (bfd_size_type) len * 2);
	  if (buf == NULL)
	    goto error_return;
	  bufsize = len * 2;
	}

      if (bfd_bread (buf, (bfd_size_type) len * 2, abfd) != len * 2)
	goto error_return;

      for (i = 0; i < len; i++)
	*p++ = HEX2 (buf + 2 * i);
      if ((bfd_size_type) (p - contents) >= section->_raw_size)
	{
	  /* We've read everything in the section.  */
	  if (buf != NULL)
	    free (buf);
	  return TRUE;
	}

      /* Skip the checksum.  */
      if (bfd_bread (buf, (bfd_size_type) 2, abfd) != 2)
	goto error_return;
    }

  if ((bfd_size_type) (p - contents) < section->_raw_size)
    {
      (*_bfd_error_handler)
	(_("%s: bad section length in ihex_read_section"),
	 bfd_archive_filename (abfd));
      bfd_set_error (bfd_error_bad_value);
      goto error_return;
    }

  if (buf != NULL)
    free (buf);

  return TRUE;

 error_return:
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Get the contents of a section in an Intel Hex file.  */

static bfd_boolean
ihex_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (section->used_by_bfd == NULL)
    {
      section->used_by_bfd = bfd_alloc (abfd, section->_raw_size);
      if (section->used_by_bfd == NULL)
	return FALSE;
      if (! ihex_read_section (abfd, section, section->used_by_bfd))
	return FALSE;
    }

  memcpy (location, (bfd_byte *) section->used_by_bfd + offset,
	  (size_t) count);

  return TRUE;
}

/* Set the contents of a section in an Intel Hex file.  */

static bfd_boolean
ihex_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  struct ihex_data_list *n;
  bfd_byte *data;
  struct ihex_data_struct *tdata;
  bfd_size_type amt;

  if (count == 0
      || (section->flags & SEC_ALLOC) == 0
      || (section->flags & SEC_LOAD) == 0)
    return TRUE;

  amt = sizeof (struct ihex_data_list);
  n = (struct ihex_data_list *) bfd_alloc (abfd, amt);
  if (n == NULL)
    return FALSE;

  data = (bfd_byte *) bfd_alloc (abfd, count);
  if (data == NULL)
    return FALSE;
  memcpy (data, location, (size_t) count);

  n->data = data;
  n->where = section->lma + offset;
  n->size = count;

  /* Sort the records by address.  Optimize for the common case of
     adding a record to the end of the list.  */
  tdata = abfd->tdata.ihex_data;
  if (tdata->tail != NULL
      && n->where >= tdata->tail->where)
    {
      tdata->tail->next = n;
      n->next = NULL;
      tdata->tail = n;
    }
  else
    {
      register struct ihex_data_list **pp;

      for (pp = &tdata->head;
	   *pp != NULL && (*pp)->where < n->where;
	   pp = &(*pp)->next)
	;
      n->next = *pp;
      *pp = n;
      if (n->next == NULL)
	tdata->tail = n;
    }

  return TRUE;
}

/* Write a record out to an Intel Hex file.  */

static bfd_boolean
ihex_write_record (abfd, count, addr, type, data)
     bfd *abfd;
     size_t count;
     unsigned int addr;
     unsigned int type;
     bfd_byte *data;
{
  static const char digs[] = "0123456789ABCDEF";
  char buf[9 + CHUNK * 2 + 4];
  char *p;
  unsigned int chksum;
  unsigned int i;
  size_t total;

#define TOHEX(buf, v) \
  ((buf)[0] = digs[((v) >> 4) & 0xf], (buf)[1] = digs[(v) & 0xf])

  buf[0] = ':';
  TOHEX (buf + 1, count);
  TOHEX (buf + 3, (addr >> 8) & 0xff);
  TOHEX (buf + 5, addr & 0xff);
  TOHEX (buf + 7, type);

  chksum = count + addr + (addr >> 8) + type;

  for (i = 0, p = buf + 9; i < count; i++, p += 2, data++)
    {
      TOHEX (p, *data);
      chksum += *data;
    }

  TOHEX (p, (- chksum) & 0xff);
  p[2] = '\r';
  p[3] = '\n';

  total = 9 + count * 2 + 4;
  if (bfd_bwrite (buf, (bfd_size_type) total, abfd) != total)
    return FALSE;

  return TRUE;
}

/* Write out an Intel Hex file.  */

static bfd_boolean
ihex_write_object_contents (abfd)
     bfd *abfd;
{
  bfd_vma segbase;
  bfd_vma extbase;
  struct ihex_data_list *l;

  segbase = 0;
  extbase = 0;
  for (l = abfd->tdata.ihex_data->head; l != NULL; l = l->next)
    {
      bfd_vma where;
      bfd_byte *p;
      bfd_size_type count;

      where = l->where;
      p = l->data;
      count = l->size;
      while (count > 0)
	{
	  size_t now;
	  unsigned int rec_addr;

	  now = count;
	  if (count > CHUNK)
	    now = CHUNK;

	  if (where > segbase + extbase + 0xffff)
	    {
	      bfd_byte addr[2];

	      /* We need a new base address.  */
	      if (where <= 0xfffff)
		{
		  /* The addresses should be sorted.  */
		  BFD_ASSERT (extbase == 0);

		  segbase = where & 0xf0000;
		  addr[0] = (bfd_byte)(segbase >> 12) & 0xff;
		  addr[1] = (bfd_byte)(segbase >> 4) & 0xff;
		  if (! ihex_write_record (abfd, 2, 0, 2, addr))
		    return FALSE;
		}
	      else
		{
		  /* The extended address record and the extended
                     linear address record are combined, at least by
                     some readers.  We need an extended linear address
                     record here, so if we've already written out an
                     extended address record, zero it out to avoid
                     confusion.  */
		  if (segbase != 0)
		    {
		      addr[0] = 0;
		      addr[1] = 0;
		      if (! ihex_write_record (abfd, 2, 0, 2, addr))
			return FALSE;
		      segbase = 0;
		    }

		  extbase = where & 0xffff0000;
		  if (where > extbase + 0xffff)
		    {
		      char buf[20];

		      sprintf_vma (buf, where);
		      (*_bfd_error_handler)
			(_("%s: address 0x%s out of range for Intel Hex file"),
			 bfd_get_filename (abfd), buf);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }
		  addr[0] = (bfd_byte)(extbase >> 24) & 0xff;
		  addr[1] = (bfd_byte)(extbase >> 16) & 0xff;
		  if (! ihex_write_record (abfd, 2, 0, 4, addr))
		    return FALSE;
		}
	    }

	  rec_addr = where - (extbase + segbase);

          /* Output records shouldn't cross 64K boundaries.  */
          if (rec_addr + now > 0xffff)
            now = 0x10000 - rec_addr;

	  if (! ihex_write_record (abfd, now, rec_addr, 0, p))
	    return FALSE;

	  where += now;
	  p += now;
	  count -= now;
	}
    }

  if (abfd->start_address != 0)
    {
      bfd_vma start;
      bfd_byte startbuf[4];

      start = abfd->start_address;

      if (start <= 0xfffff)
	{
	  startbuf[0] = (bfd_byte)((start & 0xf0000) >> 12) & 0xff;
	  startbuf[1] = 0;
	  startbuf[2] = (bfd_byte)(start >> 8) & 0xff;
	  startbuf[3] = (bfd_byte)start & 0xff;
	  if (! ihex_write_record (abfd, 4, 0, 3, startbuf))
	    return FALSE;
	}
      else
	{
	  startbuf[0] = (bfd_byte)(start >> 24) & 0xff;
	  startbuf[1] = (bfd_byte)(start >> 16) & 0xff;
	  startbuf[2] = (bfd_byte)(start >> 8) & 0xff;
	  startbuf[3] = (bfd_byte)start & 0xff;
	  if (! ihex_write_record (abfd, 4, 0, 5, startbuf))
	    return FALSE;
	}
    }

  if (! ihex_write_record (abfd, 0, 0, 1, NULL))
    return FALSE;

  return TRUE;
}

/* Set the architecture for the output file.  The architecture is
   irrelevant, so we ignore errors about unknown architectures.  */

static bfd_boolean
ihex_set_arch_mach (abfd, arch, mach)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long mach;
{
  if (! bfd_default_set_arch_mach (abfd, arch, mach))
    {
      if (arch != bfd_arch_unknown)
	return FALSE;
    }
  return TRUE;
}

/* Get the size of the headers, for the linker.  */

static int
ihex_sizeof_headers (abfd, exec)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean exec ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Some random definitions for the target vector.  */

#define	ihex_close_and_cleanup _bfd_generic_close_and_cleanup
#define ihex_bfd_free_cached_info _bfd_generic_bfd_free_cached_info
#define ihex_new_section_hook _bfd_generic_new_section_hook
#define ihex_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define ihex_get_symtab_upper_bound bfd_0l
#define ihex_canonicalize_symtab \
  ((long (*) PARAMS ((bfd *, asymbol **))) bfd_0l)
#define ihex_make_empty_symbol _bfd_generic_make_empty_symbol
#define ihex_print_symbol _bfd_nosymbols_print_symbol
#define ihex_get_symbol_info _bfd_nosymbols_get_symbol_info
#define ihex_bfd_is_local_label_name _bfd_nosymbols_bfd_is_local_label_name
#define ihex_get_lineno _bfd_nosymbols_get_lineno
#define ihex_find_nearest_line _bfd_nosymbols_find_nearest_line
#define ihex_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define ihex_read_minisymbols _bfd_nosymbols_read_minisymbols
#define ihex_minisymbol_to_symbol _bfd_nosymbols_minisymbol_to_symbol

#define ihex_get_reloc_upper_bound \
  ((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
#define ihex_canonicalize_reloc \
  ((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
#define ihex_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

#define ihex_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define ihex_bfd_relax_section bfd_generic_relax_section
#define ihex_bfd_gc_sections bfd_generic_gc_sections
#define ihex_bfd_merge_sections bfd_generic_merge_sections
#define ihex_bfd_discard_group bfd_generic_discard_group
#define ihex_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define ihex_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define ihex_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define ihex_bfd_link_just_syms _bfd_generic_link_just_syms
#define ihex_bfd_final_link _bfd_generic_final_link
#define ihex_bfd_link_split_section _bfd_generic_link_split_section

/* The Intel Hex target vector.  */

const bfd_target ihex_vec =
{
  "ihex",			/* name */
  bfd_target_ihex_flavour,
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
  0,				/* object flags */
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD),	/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {
    _bfd_dummy_target,
    ihex_object_p,		/* bfd_check_format */
    _bfd_dummy_target,
    _bfd_dummy_target,
  },
  {
    bfd_false,
    ihex_mkobject,
    _bfd_generic_mkarchive,
    bfd_false,
  },
  {				/* bfd_write_contents */
    bfd_false,
    ihex_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (ihex),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
  BFD_JUMP_TABLE_SYMBOLS (ihex),
  BFD_JUMP_TABLE_RELOCS (ihex),
  BFD_JUMP_TABLE_WRITE (ihex),
  BFD_JUMP_TABLE_LINK (ihex),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002
d145 1
a145 1
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
d702 1
a702 1
     PTR location;
a950 1
/*ARGSUSED*/
d968 1
a968 1
#define ihex_get_symtab \
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d126 1
d128 15
a142 10
#include <ctype.h>

static void ihex_init PARAMS ((void));
static boolean ihex_mkobject PARAMS ((bfd *));
static INLINE int ihex_get_byte PARAMS ((bfd *, boolean *));
static void ihex_bad_byte PARAMS ((bfd *, unsigned int, int, boolean));
static boolean ihex_scan PARAMS ((bfd *));
static const bfd_target *ihex_object_p PARAMS ((bfd *));
static boolean ihex_read_section PARAMS ((bfd *, asection *, bfd_byte *));
static boolean ihex_get_section_contents
d144 1
a144 1
static boolean ihex_set_section_contents
d146 5
a150 5
static boolean ihex_write_record
  PARAMS ((bfd *, bfd_size_type, bfd_vma, unsigned int, bfd_byte *));
static boolean ihex_write_object_contents PARAMS ((bfd *));
static asymbol *ihex_make_empty_symbol PARAMS ((bfd *));
static boolean ihex_set_arch_mach
d152 2
a153 1
static int ihex_sizeof_headers PARAMS ((bfd *, boolean));
d159 1
a159 1
/* Macros for converting between hex and binary. */
d161 1
a161 1
#define NIBBLE(x) (hex_value (x))
d164 1
a164 1
#define ISHEX(x) (hex_p (x))
d190 1
a190 1
  static boolean inited;
d194 1
a194 1
      inited = true;
d201 1
a201 1
static boolean
d205 2
a206 3
  if (abfd->tdata.ihex_data == NULL)
    {
      struct ihex_data_struct *tdata;
d208 8
a215 10
      tdata = ((struct ihex_data_struct *)
	       bfd_alloc (abfd, sizeof (struct ihex_data_struct)));
      if (tdata == NULL)
	return false;
      abfd->tdata.ihex_data = tdata;
      tdata->head = NULL;
      tdata->tail = NULL;
    }

  return true;
d224 1
a224 1
     boolean *errorptr;
d228 1
a228 1
  if (bfd_read (&c, 1, 1, abfd) != 1)
d231 1
a231 1
	*errorptr = true;
d245 1
a245 1
     boolean error;
d256 1
a256 1
      if (! isprint (c))
d265 1
a265 1
	 bfd_get_filename (abfd), lineno, buf);
d273 1
a273 1
static boolean
d280 2
a281 2
  int lineno;
  boolean error;
d295 1
a295 1
  error = false;
d297 1
a323 1

d327 1
a327 2

	  if (bfd_read (hdr, 1, 8, abfd) != 8)
a343 1

d347 1
a347 1
	      buf = (bfd_byte *) bfd_realloc (buf, chars);
d353 1
a353 1
	  if (bfd_read (buf, 1, chars, abfd) != chars)
d372 2
a373 2
		(_("%s:%d: bad checksum in Intel Hex file (expected %u, found %u)"),
		 bfd_get_filename (abfd), lineno,
d394 1
d397 2
a398 1
		  secname = (char *) bfd_alloc (abfd, strlen (secbuf) + 1);
d419 1
a419 1
	      return true;
d426 2
a427 2
		    (_("%s:%d: bad extended address record length in Intel Hex file"),
		     bfd_get_filename (abfd), lineno);
d443 2
a444 2
		    (_("%s:%d: bad extended start address length in Intel Hex file"),
		     bfd_get_filename (abfd), lineno);
d460 2
a461 2
		    (_("%s:%d: bad extended linear address record length in Intel Hex file"),
		     bfd_get_filename (abfd), lineno);
d477 2
a478 2
		    (_("%s:%d: bad extended linear start address length in Intel Hex file"),
		     bfd_get_filename (abfd), lineno);
d494 2
a495 2
		(_("%s:%d: unrecognized ihex type %u in Intel Hex file\n"),
		 bfd_get_filename (abfd), lineno, type);
d508 1
a508 1
  return true;
d513 1
a513 1
  return false;
d522 1
d531 1
a531 1
  if (bfd_read (b, 1, 9, abfd) != 9)
d561 8
a568 4

  if (! ihex_mkobject (abfd)
      || ! ihex_scan (abfd))
    return NULL;
d575 1
a575 1
static boolean
d585 1
a585 1
  boolean error;
d592 1
a592 1
  error = false;
d608 1
a608 1
      if (bfd_read (hdr, 1, 8, abfd) != 8)
d620 1
a620 1
	     bfd_get_filename (abfd));
d627 1
a627 1
	  buf = (bfd_byte *) bfd_realloc (buf, len * 2);
d633 1
a633 1
      if (bfd_read (buf, 1, len * 2, abfd) != len * 2)
d643 1
a643 1
	  return true;
d647 1
a647 1
      if (bfd_read (buf, 1, 2, abfd) != 2)
d655 1
a655 1
	 bfd_get_filename (abfd));
d663 1
a663 1
  return true;
d668 1
a668 1
  return false;
d673 1
a673 1
static boolean
d685 1
a685 1
	return false;
d687 1
a687 1
	return false;
d693 1
a693 1
  return true;
d698 1
a698 1
static boolean
d709 1
d714 1
a714 1
    return true;
d716 2
a717 2
  n = ((struct ihex_data_list *)
       bfd_alloc (abfd, sizeof (struct ihex_data_list)));
d719 1
a719 1
    return false;
d723 1
a723 1
    return false;
d754 1
a754 1
  return true;
d759 1
a759 1
static boolean
d762 2
a763 2
     bfd_size_type count;
     bfd_vma addr;
d772 1
d795 3
a797 2
  if (bfd_write (buf, 1, 9 + count * 2 + 4, abfd) != 9 + count * 2 + 4)
    return false;
d799 1
a799 1
  return true;
d804 1
a804 1
static boolean
d825 2
a826 1
	  bfd_size_type now;
d829 1
a829 1
	  if (now > CHUNK)
d846 1
a846 1
		    return false;
d861 1
a861 1
			return false;
d872 1
a872 1
			(_("%s: address 0x%s out of range for Intex Hex file"),
d875 1
a875 1
		      return false;
d880 1
a880 1
		    return false;
d884 8
a891 3
	  if (! ihex_write_record (abfd, now, where - (extbase + segbase),
				   0, p))
	    return false;
d913 1
a913 1
	    return false;
d922 1
a922 1
	    return false;
d927 1
a927 13
    return false;

  return true;
}

/* Make an empty symbol.  This is required only because
   bfd_make_section_anyway wants to create a symbol for the section.  */

static asymbol *
ihex_make_empty_symbol (abfd)
     bfd *abfd;
{
  asymbol *new;
d929 1
a929 4
  new = (asymbol *) bfd_zalloc (abfd, sizeof (asymbol));
  if (new != NULL)
    new->the_bfd = abfd;
  return new;
d935 1
a935 1
static boolean
d944 1
a944 1
	return false;
d946 1
a946 1
  return true;
d955 1
a955 1
     boolean exec ATTRIBUTE_UNUSED;
d971 1
d991 2
d994 1
d996 1
d1050 1
a1050 1
  
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d149 1
a149 1
#define CHUNK (21)
d259 1
a259 1
	("%s:%d: unexpected character `%s' in Intel Hex file\n",
d273 1
d277 1
a277 1
  bfd_byte *buf;
d287 1
a290 1
  buf = NULL;
d369 1
a369 1
		("%s:%d: bad checksum in Intel Hex file (expected %u, found %u)",
d381 1
a381 1
		  && sec->vma + sec->_raw_size == segbase + addr)
d401 2
a402 2
		  sec->vma = segbase + addr;
		  sec->lma = segbase + addr;
d421 1
a421 1
		    ("%s:%d: bad extended address record length in Intel Hex file",
d438 1
a438 1
		    ("%s:%d: bad extended start address length in Intel Hex file",
d455 1
a455 1
		    ("%s:%d: bad extended linear address record length in Intel Hex file",
d461 1
a461 1
	      segbase = HEX4 (buf) << 16;
d472 1
a472 1
		    ("%s:%d: bad extended linear start address length in Intel Hex file",
d489 1
a489 1
		("%s:%d: unrecognized ihex type %u in Intel Hex file\n",
d573 1
a573 1
  bfd_byte *buf;
a580 1
  buf = NULL;
d609 1
a609 1
	    ("%s: internal error in ihex_read_section",
d644 1
a644 1
	("%s: bad section length in ihex_read_section",
d796 1
d800 1
d818 1
a818 1
	  if (where > segbase + 0xffff)
d825 3
d829 2
a830 2
		  addr[0] = (segbase >> 12) & 0xff;
		  addr[1] = (segbase >> 4) & 0xff;
d836 17
a852 2
		  segbase = where & 0xffff0000;
		  if (where > segbase + 0xffff)
d858 1
a858 1
			("%s: address 0x%s out of range for Intex Hex file",
d863 2
a864 2
		  addr[0] = (segbase >> 24) & 0xff;
		  addr[1] = (segbase >> 16) & 0xff;
d870 2
a871 1
	  if (! ihex_write_record (abfd, now, where - segbase, 0, p))
d889 1
a889 1
	  startbuf[0] = ((start & 0xf0000) >> 12) & 0xff;
d891 2
a892 2
	  startbuf[2] = (start >> 8) & 0xff;
	  startbuf[3] = start & 0xff;
d898 4
a901 4
	  startbuf[0] = (start >> 24) & 0xff;
	  startbuf[1] = (start >> 16) & 0xff;
	  startbuf[2] = (start >> 8) & 0xff;
	  startbuf[3] = start & 0xff;
d950 2
a951 2
     bfd *abfd;
     boolean exec;
d969 1
a969 1
#define ihex_bfd_is_local_label _bfd_nosymbols_bfd_is_local_label
d985 1
d1040 2
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d145 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1995 Free Software Foundation, Inc.
a271 1
  bfd_vma extbase;
a283 1
  extbase = 0;
d379 1
a379 1
		  && sec->vma + sec->_raw_size == extbase + segbase + addr)
d399 2
a400 2
		  sec->vma = extbase + segbase + addr;
		  sec->lma = extbase + segbase + addr;
a793 1
  bfd_vma extbase;
a796 1
  extbase = 0;
d815 1
a815 1
	  if (where > extbase + segbase + 0xffff)
d830 2
a831 2
		  extbase = where & 0xffff0000;
		  if (where > extbase + 0xffff)
d842 2
a843 2
		  addr[0] = (extbase >> 24) & 0xff;
		  addr[1] = (extbase >> 16) & 0xff;
d849 1
a849 2
	  if (! ihex_write_record (abfd, now, where - (extbase + segbase),
				   0, p))
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d272 1
d285 1
d381 1
a381 1
		  && sec->vma + sec->_raw_size == segbase + addr)
d401 2
a402 2
		  sec->vma = segbase + addr;
		  sec->lma = segbase + addr;
d796 1
d800 1
d819 1
a819 1
	  if (where > segbase + 0xffff)
d834 2
a835 2
		  segbase = where & 0xffff0000;
		  if (where > segbase + 0xffff)
d846 2
a847 2
		  addr[0] = (segbase >> 24) & 0xff;
		  addr[1] = (segbase >> 16) & 0xff;
d853 2
a854 1
	  if (! ihex_write_record (abfd, now, where - segbase, 0, p))
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a144 1
static int ihex_sizeof_headers PARAMS ((bfd *, boolean));
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
d276 1
a276 1
  bfd_byte *buf = NULL;
d289 1
d572 1
a572 1
  bfd_byte *buf = NULL;
d580 1
d824 2
a825 2
		  addr[0] = (bfd_byte)(segbase >> 12) & 0xff;
		  addr[1] = (bfd_byte)(segbase >> 4) & 0xff;
d843 2
a844 2
		  addr[0] = (bfd_byte)(segbase >> 24) & 0xff;
		  addr[1] = (bfd_byte)(segbase >> 16) & 0xff;
d868 1
a868 1
	  startbuf[0] = (bfd_byte)((start & 0xf0000) >> 12) & 0xff;
d870 2
a871 2
	  startbuf[2] = (bfd_byte)(start >> 8) & 0xff;
	  startbuf[3] = (bfd_byte)start & 0xff;
d877 4
a880 4
	  startbuf[0] = (bfd_byte)(start >> 24) & 0xff;
	  startbuf[1] = (bfd_byte)(start >> 16) & 0xff;
	  startbuf[2] = (bfd_byte)(start >> 8) & 0xff;
	  startbuf[3] = (bfd_byte)start & 0xff;
d948 1
a948 1
#define ihex_bfd_is_local_label_name _bfd_nosymbols_bfd_is_local_label_name
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d149 1
a149 1
#define CHUNK 16
d259 1
a259 1
	(_("%s:%d: unexpected character `%s' in Intel Hex file\n"),
a272 1
  bfd_vma extbase;
a285 1
  extbase = 0;
d367 1
a367 1
		(_("%s:%d: bad checksum in Intel Hex file (expected %u, found %u)"),
d379 1
a379 1
		  && sec->vma + sec->_raw_size == extbase + segbase + addr)
d399 2
a400 2
		  sec->vma = extbase + segbase + addr;
		  sec->lma = extbase + segbase + addr;
d419 1
a419 1
		    (_("%s:%d: bad extended address record length in Intel Hex file"),
d436 1
a436 1
		    (_("%s:%d: bad extended start address length in Intel Hex file"),
d453 1
a453 1
		    (_("%s:%d: bad extended linear address record length in Intel Hex file"),
d459 1
a459 1
	      extbase = HEX4 (buf) << 16;
d470 1
a470 1
		    (_("%s:%d: bad extended linear start address length in Intel Hex file"),
d487 1
a487 1
		(_("%s:%d: unrecognized ihex type %u in Intel Hex file\n"),
d607 1
a607 1
	    (_("%s: internal error in ihex_read_section"),
d642 1
a642 1
	(_("%s: bad section length in ihex_read_section"),
a793 1
  bfd_vma extbase;
a796 1
  extbase = 0;
d814 1
a814 1
	  if (where > segbase + extbase + 0xffff)
a820 3
		  /* The addresses should be sorted.  */
		  BFD_ASSERT (extbase == 0);

d829 2
a830 17
		  /* The extended address record and the extended
                     linear address record are combined, at least by
                     some readers.  We need an extended linear address
                     record here, so if we've already written out an
                     extended address record, zero it out to avoid
                     confusion.  */
		  if (segbase != 0)
		    {
		      addr[0] = 0;
		      addr[1] = 0;
		      if (! ihex_write_record (abfd, 2, 0, 2, addr))
			return false;
		      segbase = 0;
		    }

		  extbase = where & 0xffff0000;
		  if (where > extbase + 0xffff)
d836 1
a836 1
			(_("%s: address 0x%s out of range for Intex Hex file"),
d841 2
a842 2
		  addr[0] = (bfd_byte)(extbase >> 24) & 0xff;
		  addr[1] = (bfd_byte)(extbase >> 16) & 0xff;
d848 1
a848 2
	  if (! ihex_write_record (abfd, now, where - (extbase + segbase),
				   0, p))
d927 2
a928 2
     bfd *abfd ATTRIBUTE_UNUSED;
     boolean exec ATTRIBUTE_UNUSED;
a961 1
#define ihex_bfd_gc_sections bfd_generic_gc_sections
a1015 2
  NULL,
  
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a124 1
#include "safe-ctype.h"
d126 10
a135 15
static void ihex_init
  PARAMS ((void));
static bfd_boolean ihex_mkobject
  PARAMS ((bfd *));
static INLINE int ihex_get_byte
  PARAMS ((bfd *, bfd_boolean *));
static void ihex_bad_byte
  PARAMS ((bfd *, unsigned int, int, bfd_boolean));
static bfd_boolean ihex_scan
  PARAMS ((bfd *));
static const bfd_target *ihex_object_p
  PARAMS ((bfd *));
static bfd_boolean ihex_read_section
  PARAMS ((bfd *, asection *, bfd_byte *));
static bfd_boolean ihex_get_section_contents
d137 1
a137 1
static bfd_boolean ihex_set_section_contents
d139 5
a143 5
static bfd_boolean ihex_write_record
  PARAMS ((bfd *, size_t, unsigned int, unsigned int, bfd_byte *));
static bfd_boolean ihex_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean ihex_set_arch_mach
d145 1
a145 2
static int ihex_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d151 1
a151 1
/* Macros for converting between hex and binary.  */
d153 1
a153 1
#define NIBBLE(x)    (hex_value (x))
d156 1
a156 1
#define ISHEX(x)     (hex_p (x))
d182 1
a182 1
  static bfd_boolean inited;
d186 1
a186 1
      inited = TRUE;
d193 1
a193 1
static bfd_boolean
d197 12
a208 2
  struct ihex_data_struct *tdata;
  bfd_size_type amt = sizeof (struct ihex_data_struct);
d210 1
a210 8
  tdata = (struct ihex_data_struct *) bfd_alloc (abfd, amt);
  if (tdata == NULL)
    return FALSE;

  abfd->tdata.ihex_data = tdata;
  tdata->head = NULL;
  tdata->tail = NULL;
  return TRUE;
d219 1
a219 1
     bfd_boolean *errorptr;
d223 1
a223 1
  if (bfd_bread (&c, (bfd_size_type) 1, abfd) != 1)
d226 1
a226 1
	*errorptr = TRUE;
d240 1
a240 1
     bfd_boolean error;
d251 1
a251 1
      if (! ISPRINT (c))
d260 1
a260 1
	 bfd_archive_filename (abfd), lineno, buf);
d268 1
a268 1
static bfd_boolean
d275 2
a276 2
  unsigned int lineno;
  bfd_boolean error;
d290 1
a290 1
  error = FALSE;
a291 1

d318 1
d322 2
a323 1
	  if (bfd_bread (hdr, (bfd_size_type) 8, abfd) != 8)
d340 1
d344 1
a344 1
	      buf = (bfd_byte *) bfd_realloc (buf, (bfd_size_type) chars);
d350 1
a350 1
	  if (bfd_bread (buf, (bfd_size_type) chars, abfd) != chars)
d369 2
a370 2
		(_("%s:%u: bad checksum in Intel Hex file (expected %u, found %u)"),
		 bfd_archive_filename (abfd), lineno,
a390 1
		  bfd_size_type amt;
d393 1
a393 2
		  amt = strlen (secbuf) + 1;
		  secname = (char *) bfd_alloc (abfd, amt);
d414 1
a414 1
	      return TRUE;
d421 2
a422 2
		    (_("%s:%u: bad extended address record length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
d438 2
a439 2
		    (_("%s:%u: bad extended start address length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
d455 2
a456 2
		    (_("%s:%u: bad extended linear address record length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
d472 2
a473 2
		    (_("%s:%u: bad extended linear start address length in Intel Hex file"),
		     bfd_archive_filename (abfd), lineno);
d489 2
a490 2
		(_("%s:%u: unrecognized ihex type %u in Intel Hex file\n"),
		 bfd_archive_filename (abfd), lineno, type);
d503 1
a503 1
  return TRUE;
d508 1
a508 1
  return FALSE;
a516 1
  PTR tdata_save;
d525 1
a525 1
  if (bfd_bread (b, (bfd_size_type) 9, abfd) != 9)
d555 4
a558 8
  tdata_save = abfd->tdata.any;
  if (! ihex_mkobject (abfd) || ! ihex_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }
d565 1
a565 1
static bfd_boolean
d575 1
a575 1
  bfd_boolean error;
d582 1
a582 1
  error = FALSE;
d598 1
a598 1
      if (bfd_bread (hdr, (bfd_size_type) 8, abfd) != 8)
d610 1
a610 1
	     bfd_archive_filename (abfd));
d617 1
a617 1
	  buf = (bfd_byte *) bfd_realloc (buf, (bfd_size_type) len * 2);
d623 1
a623 1
      if (bfd_bread (buf, (bfd_size_type) len * 2, abfd) != len * 2)
d633 1
a633 1
	  return TRUE;
d637 1
a637 1
      if (bfd_bread (buf, (bfd_size_type) 2, abfd) != 2)
d645 1
a645 1
	 bfd_archive_filename (abfd));
d653 1
a653 1
  return TRUE;
d658 1
a658 1
  return FALSE;
d663 1
a663 1
static bfd_boolean
d675 1
a675 1
	return FALSE;
d677 1
a677 1
	return FALSE;
d683 1
a683 1
  return TRUE;
d688 1
a688 1
static bfd_boolean
a698 1
  bfd_size_type amt;
d703 1
a703 1
    return TRUE;
d705 2
a706 2
  amt = sizeof (struct ihex_data_list);
  n = (struct ihex_data_list *) bfd_alloc (abfd, amt);
d708 1
a708 1
    return FALSE;
d712 1
a712 1
    return FALSE;
d743 1
a743 1
  return TRUE;
d748 1
a748 1
static bfd_boolean
d751 2
a752 2
     size_t count;
     unsigned int addr;
a760 1
  size_t total;
d783 2
a784 3
  total = 9 + count * 2 + 4;
  if (bfd_bwrite (buf, (bfd_size_type) total, abfd) != total)
    return FALSE;
d786 1
a786 1
  return TRUE;
d791 1
a791 1
static bfd_boolean
d812 1
a812 2
	  size_t now;
	  unsigned int rec_addr;
d815 1
a815 1
	  if (count > CHUNK)
d832 1
a832 1
		    return FALSE;
d847 1
a847 1
			return FALSE;
d858 1
a858 1
			(_("%s: address 0x%s out of range for Intel Hex file"),
d861 1
a861 1
		      return FALSE;
d866 1
a866 1
		    return FALSE;
d870 3
a872 8
	  rec_addr = where - (extbase + segbase);

          /* Output records shouldn't cross 64K boundaries.  */
          if (rec_addr + now > 0xffff)
            now = 0x10000 - rec_addr;

	  if (! ihex_write_record (abfd, now, rec_addr, 0, p))
	    return FALSE;
d894 1
a894 1
	    return FALSE;
d903 1
a903 1
	    return FALSE;
d908 13
a920 1
    return FALSE;
d922 4
a925 1
  return TRUE;
d931 1
a931 1
static bfd_boolean
d940 1
a940 1
	return FALSE;
d942 1
a942 1
  return TRUE;
d951 1
a951 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
a966 1
#define ihex_make_empty_symbol _bfd_generic_make_empty_symbol
a985 2
#define ihex_bfd_merge_sections bfd_generic_merge_sections
#define ihex_bfd_discard_group bfd_generic_discard_group
a986 1
#define ihex_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
a987 1
#define ihex_bfd_link_just_syms _bfd_generic_link_just_syms
d1041 1
a1041 1

@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003
d145 1
a145 1
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
d702 1
a702 1
     const PTR location;
d951 1
d969 1
a969 1
#define ihex_canonicalize_symtab \
@


