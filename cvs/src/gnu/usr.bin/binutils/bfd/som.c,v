head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.08.10.03.25.39;	author guenther;	state Exp;
branches;
next	1.7;
commitid	Ks9P0sWl5Nnr4POS;

1.7
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.23;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.49;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.47.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.11;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.11;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.28;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.46;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.20.38;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.56;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.27.48;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Format time_t with %lld after casting to long long
@
text
@/* bfd back-end for HP PA-RISC SOM objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "alloca-conf.h"
#include "bfd.h"
#include "sysdep.h"

#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF) || defined(HOST_HPPAMPEIX)

#include "libbfd.h"
#include "som.h"
#include "safe-ctype.h"

#include <sys/param.h>
#include <signal.h>
#include <machine/reg.h>
#include <sys/file.h>

/* Magic not defined in standard HP-UX header files until 8.0.  */

#ifndef CPU_PA_RISC1_0
#define CPU_PA_RISC1_0 0x20B
#endif /* CPU_PA_RISC1_0 */

#ifndef CPU_PA_RISC1_1
#define CPU_PA_RISC1_1 0x210
#endif /* CPU_PA_RISC1_1 */

#ifndef CPU_PA_RISC2_0
#define CPU_PA_RISC2_0 0x214
#endif /* CPU_PA_RISC2_0 */

#ifndef _PA_RISC1_0_ID
#define _PA_RISC1_0_ID CPU_PA_RISC1_0
#endif /* _PA_RISC1_0_ID */

#ifndef _PA_RISC1_1_ID
#define _PA_RISC1_1_ID CPU_PA_RISC1_1
#endif /* _PA_RISC1_1_ID */

#ifndef _PA_RISC2_0_ID
#define _PA_RISC2_0_ID CPU_PA_RISC2_0
#endif /* _PA_RISC2_0_ID */

#ifndef _PA_RISC_MAXID
#define _PA_RISC_MAXID	0x2FF
#endif /* _PA_RISC_MAXID */

#ifndef _PA_RISC_ID
#define _PA_RISC_ID(__m_num)		\
    (((__m_num) == _PA_RISC1_0_ID) ||	\
     ((__m_num) >= _PA_RISC1_1_ID && (__m_num) <= _PA_RISC_MAXID))
#endif /* _PA_RISC_ID */

/* HIUX in it's infinite stupidity changed the names for several "well
   known" constants.  Work around such braindamage.  Try the HPUX version
   first, then the HIUX version, and finally provide a default.  */
#ifdef HPUX_AUX_ID
#define EXEC_AUX_ID HPUX_AUX_ID
#endif

#if !defined (EXEC_AUX_ID) && defined (HIUX_AUX_ID)
#define EXEC_AUX_ID HIUX_AUX_ID
#endif

#ifndef EXEC_AUX_ID
#define EXEC_AUX_ID 0
#endif

/* Size (in chars) of the temporary buffers used during fixup and string
   table writes.   */

#define SOM_TMP_BUFSIZE 8192

/* Size of the hash table in archives.  */
#define SOM_LST_HASH_SIZE 31

/* Max number of SOMs to be found in an archive.  */
#define SOM_LST_MODULE_LIMIT 1024

/* Generic alignment macro.  */
#define SOM_ALIGN(val, alignment) \
  (((val) + (alignment) - 1) &~ ((unsigned long) (alignment) - 1))

/* SOM allows any one of the four previous relocations to be reused
   with a "R_PREV_FIXUP" relocation entry.  Since R_PREV_FIXUP
   relocations are always a single byte, using a R_PREV_FIXUP instead
   of some multi-byte relocation makes object files smaller.

   Note one side effect of using a R_PREV_FIXUP is the relocation that
   is being repeated moves to the front of the queue.  */
struct reloc_queue {
  unsigned char *reloc;
  unsigned int size;
} reloc_queue[4];

/* This fully describes the symbol types which may be attached to
   an EXPORT or IMPORT directive.  Only SOM uses this formation
   (ELF has no need for it).  */
typedef enum {
  SYMBOL_TYPE_UNKNOWN,
  SYMBOL_TYPE_ABSOLUTE,
  SYMBOL_TYPE_CODE,
  SYMBOL_TYPE_DATA,
  SYMBOL_TYPE_ENTRY,
  SYMBOL_TYPE_MILLICODE,
  SYMBOL_TYPE_PLABEL,
  SYMBOL_TYPE_PRI_PROG,
  SYMBOL_TYPE_SEC_PROG,
} pa_symbol_type;

struct section_to_type {
  char *section;
  char type;
};

/* Assorted symbol information that needs to be derived from the BFD symbol
   and/or the BFD backend private symbol data.  */
struct som_misc_symbol_info {
  unsigned int symbol_type;
  unsigned int symbol_scope;
  unsigned int arg_reloc;
  unsigned int symbol_info;
  unsigned int symbol_value;
  unsigned int priv_level;
  unsigned int secondary_def;
};

/* Forward declarations.  */

static bfd_boolean som_mkobject
  PARAMS ((bfd *));
static const bfd_target * som_object_setup
  PARAMS ((bfd *, struct header *, struct som_exec_auxhdr *, unsigned long));
static bfd_boolean setup_sections
  PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p
  PARAMS ((bfd *));
static bfd_boolean som_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean som_slurp_string_table
  PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table
  PARAMS ((bfd *));
static long som_get_symtab_upper_bound
  PARAMS ((bfd *));
static long som_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static long som_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info
  PARAMS ((unsigned char *, unsigned int, arelent *, asection *,
	   asymbol **, bfd_boolean));
static bfd_boolean som_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long som_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol
  PARAMS ((bfd *));
static void som_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean som_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean som_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean som_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean som_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
#define som_bfd_merge_private_bfd_data _bfd_generic_bfd_merge_private_bfd_data
#define som_bfd_set_private_flags _bfd_generic_bfd_set_private_flags
static bfd_boolean som_bfd_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean som_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean som_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static void som_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol
  PARAMS ((bfd *, struct symbol_dictionary_record *));
static int log2
  PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void som_initialize_reloc_queue
  PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static void som_reloc_queue_fix
  PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * try_prev_fixup
  PARAMS ((bfd *, int *, unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * som_reloc_skip
  PARAMS ((bfd *, unsigned int, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_addend
  PARAMS ((bfd *, bfd_vma, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_call
  PARAMS ((bfd *, unsigned char *, unsigned int *, arelent *, int,
	   struct reloc_queue *));
static unsigned long som_count_spaces
  PARAMS ((bfd *));
static unsigned long som_count_subspaces
  PARAMS ((bfd *));
static int compare_syms
  PARAMS ((const void *, const void *));
static int compare_subspaces
  PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean som_prep_headers
  PARAMS ((bfd *));
static int som_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean som_finish_writing
  PARAMS ((bfd *));
static bfd_boolean som_build_and_write_symbol_table
  PARAMS ((bfd *));
static void som_prep_for_fixups
  PARAMS ((bfd *, asymbol **, unsigned long));
static bfd_boolean som_write_fixups
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_space_strings
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_symbol_strings
  PARAMS ((bfd *, unsigned long, asymbol **, unsigned int, unsigned *,
	   COMPUNIT *));
static bfd_boolean som_begin_writing
  PARAMS ((bfd *));
static reloc_howto_type * som_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type
  PARAMS ((const char *));
static int som_decode_symclass
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_count_ar_symbols
  PARAMS ((bfd *, struct lst_header *, symindex *));
static bfd_boolean som_bfd_fill_in_ar_symbols
  PARAMS ((bfd *, struct lst_header *, carsym **));
static bfd_boolean som_slurp_armap
  PARAMS ((bfd *));
static bfd_boolean som_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static void som_bfd_derive_misc_symbol_info
  PARAMS ((bfd *, asymbol *, struct som_misc_symbol_info *));
static bfd_boolean som_bfd_prep_for_ar_write
  PARAMS ((bfd *, unsigned int *, unsigned int *));
static unsigned int som_bfd_ar_symbol_hash
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_ar_write_symbol_stuff
  PARAMS ((bfd *, unsigned int, unsigned int, struct lst_header,
	   unsigned int));
static bfd_boolean som_is_space
  PARAMS ((asection *));
static bfd_boolean som_is_subspace
  PARAMS ((asection *));
static bfd_boolean som_is_container
  PARAMS ((asection *, asection *));
static bfd_boolean som_bfd_free_cached_info
  PARAMS ((bfd *));
static bfd_boolean som_bfd_link_split_section
  PARAMS ((bfd *, asection *));

/* Map SOM section names to POSIX/BSD single-character symbol types.

   This table includes all the standard subspaces as defined in the
   current "PRO ABI for PA-RISC Systems", $UNWIND$ which for
   some reason was left out, and sections specific to embedded stabs.  */

static const struct section_to_type stt[] = {
  {"$TEXT$", 't'},
  {"$SHLIB_INFO$", 't'},
  {"$MILLICODE$", 't'},
  {"$LIT$", 't'},
  {"$CODE$", 't'},
  {"$UNWIND_START$", 't'},
  {"$UNWIND$", 't'},
  {"$PRIVATE$", 'd'},
  {"$PLT$", 'd'},
  {"$SHLIB_DATA$", 'd'},
  {"$DATA$", 'd'},
  {"$SHORTDATA$", 'g'},
  {"$DLT$", 'd'},
  {"$GLOBAL$", 'g'},
  {"$SHORTBSS$", 's'},
  {"$BSS$", 'b'},
  {"$GDB_STRINGS$", 'N'},
  {"$GDB_SYMBOLS$", 'N'},
  {0, 0}
};

/* About the relocation formatting table...

   There are 256 entries in the table, one for each possible
   relocation opcode available in SOM.  We index the table by
   the relocation opcode.  The names and operations are those
   defined by a.out_800 (4).

   Right now this table is only used to count and perform minimal
   processing on relocation streams so that they can be internalized
   into BFD and symbolically printed by utilities.  To make actual use
   of them would be much more difficult, BFD's concept of relocations
   is far too simple to handle SOM relocations.  The basic assumption
   that a relocation can be completely processed independent of other
   relocations before an object file is written is invalid for SOM.

   The SOM relocations are meant to be processed as a stream, they
   specify copying of data from the input section to the output section
   while possibly modifying the data in some manner.  They also can
   specify that a variable number of zeros or uninitialized data be
   inserted on in the output segment at the current offset.  Some
   relocations specify that some previous relocation be re-applied at
   the current location in the input/output sections.  And finally a number
   of relocations have effects on other sections (R_ENTRY, R_EXIT,
   R_UNWIND_AUX and a variety of others).  There isn't even enough room
   in the BFD relocation data structure to store enough information to
   perform all the relocations.

   Each entry in the table has three fields.

   The first entry is an index into this "class" of relocations.  This
   index can then be used as a variable within the relocation itself.

   The second field is a format string which actually controls processing
   of the relocation.  It uses a simple postfix machine to do calculations
   based on variables/constants found in the string and the relocation
   stream.

   The third field specifys whether or not this relocation may use
   a constant (V) from the previous R_DATA_OVERRIDE rather than a constant
   stored in the instruction.

   Variables:

   L = input space byte count
   D = index into class of relocations
   M = output space byte count
   N = statement number (unused?)
   O = stack operation
   R = parameter relocation bits
   S = symbol index
   T = first 32 bits of stack unwind information
   U = second 32 bits of stack unwind information
   V = a literal constant (usually used in the next relocation)
   P = a previous relocation

   Lower case letters (starting with 'b') refer to following
   bytes in the relocation stream.  'b' is the next 1 byte,
   c is the next 2 bytes, d is the next 3 bytes, etc...
   This is the variable part of the relocation entries that
   makes our life a living hell.

   numerical constants are also used in the format string.  Note
   the constants are represented in decimal.

   '+', "*" and "=" represents the obvious postfix operators.
   '<' represents a left shift.

   Stack Operations:

   Parameter Relocation Bits:

   Unwind Entries:

   Previous Relocations:  The index field represents which in the queue
   of 4 previous fixups should be re-applied.

   Literal Constants:  These are generally used to represent addend
   parts of relocations when these constants are not stored in the
   fields of the instructions themselves.  For example the instruction
   addil foo-$global$-0x1234 would use an override for "0x1234" rather
   than storing it into the addil itself.  */

struct fixup_format {
  int D;
  const char *format;
};

static const struct fixup_format som_fixup_formats[256] = {
  /* R_NO_RELOCATION */
  {  0, "LD1+4*=" },		/* 0x00 */
  {  1, "LD1+4*=" },		/* 0x01 */
  {  2, "LD1+4*=" },		/* 0x02 */
  {  3, "LD1+4*=" },		/* 0x03 */
  {  4, "LD1+4*=" },		/* 0x04 */
  {  5, "LD1+4*=" },		/* 0x05 */
  {  6, "LD1+4*=" },		/* 0x06 */
  {  7, "LD1+4*=" },		/* 0x07 */
  {  8, "LD1+4*=" },		/* 0x08 */
  {  9, "LD1+4*=" },		/* 0x09 */
  { 10, "LD1+4*=" },		/* 0x0a */
  { 11, "LD1+4*=" },		/* 0x0b */
  { 12, "LD1+4*=" },		/* 0x0c */
  { 13, "LD1+4*=" },		/* 0x0d */
  { 14, "LD1+4*=" },		/* 0x0e */
  { 15, "LD1+4*=" },		/* 0x0f */
  { 16, "LD1+4*=" },		/* 0x10 */
  { 17, "LD1+4*=" },		/* 0x11 */
  { 18, "LD1+4*=" },		/* 0x12 */
  { 19, "LD1+4*=" },		/* 0x13 */
  { 20, "LD1+4*=" },		/* 0x14 */
  { 21, "LD1+4*=" },		/* 0x15 */
  { 22, "LD1+4*=" },		/* 0x16 */
  { 23, "LD1+4*=" },		/* 0x17 */
  {  0, "LD8<b+1+4*=" },	/* 0x18 */
  {  1, "LD8<b+1+4*=" },	/* 0x19 */
  {  2, "LD8<b+1+4*=" },	/* 0x1a */
  {  3, "LD8<b+1+4*=" },	/* 0x1b */
  {  0, "LD16<c+1+4*=" },	/* 0x1c */
  {  1, "LD16<c+1+4*=" },	/* 0x1d */
  {  2, "LD16<c+1+4*=" },	/* 0x1e */
  {  0, "Ld1+=" },		/* 0x1f */
  /* R_ZEROES */
  {  0, "Lb1+4*=" },		/* 0x20 */
  {  1, "Ld1+=" },		/* 0x21 */
  /* R_UNINIT */
  {  0, "Lb1+4*=" },		/* 0x22 */
  {  1, "Ld1+=" },		/* 0x23 */
  /* R_RELOCATION */
  {  0, "L4=" },		/* 0x24 */
  /* R_DATA_ONE_SYMBOL */
  {  0, "L4=Sb=" },		/* 0x25 */
  {  1, "L4=Sd=" },		/* 0x26 */
  /* R_DATA_PLEBEL */
  {  0, "L4=Sb=" },		/* 0x27 */
  {  1, "L4=Sd=" },		/* 0x28 */
  /* R_SPACE_REF */
  {  0, "L4=" },		/* 0x29 */
  /* R_REPEATED_INIT */
  {  0, "L4=Mb1+4*=" },		/* 0x2a */
  {  1, "Lb4*=Mb1+L*=" },	/* 0x2b */
  {  2, "Lb4*=Md1+4*=" },	/* 0x2c */
  {  3, "Ld1+=Me1+=" },		/* 0x2d */
  {  0, "" },			/* 0x2e */
  {  0, "" },			/* 0x2f */
  /* R_PCREL_CALL */
  {  0, "L4=RD=Sb=" },		/* 0x30 */
  {  1, "L4=RD=Sb=" },		/* 0x31 */
  {  2, "L4=RD=Sb=" },		/* 0x32 */
  {  3, "L4=RD=Sb=" },		/* 0x33 */
  {  4, "L4=RD=Sb=" },		/* 0x34 */
  {  5, "L4=RD=Sb=" },		/* 0x35 */
  {  6, "L4=RD=Sb=" },		/* 0x36 */
  {  7, "L4=RD=Sb=" },		/* 0x37 */
  {  8, "L4=RD=Sb=" },		/* 0x38 */
  {  9, "L4=RD=Sb=" },		/* 0x39 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x3a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x3b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x3c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x3d */
  /* R_SHORT_PCREL_MODE */
  {  0, "" },			/* 0x3e */
  /* R_LONG_PCREL_MODE */
  {  0, "" },			/* 0x3f */
  /* R_ABS_CALL */
  {  0, "L4=RD=Sb=" },		/* 0x40 */
  {  1, "L4=RD=Sb=" },		/* 0x41 */
  {  2, "L4=RD=Sb=" },		/* 0x42 */
  {  3, "L4=RD=Sb=" },		/* 0x43 */
  {  4, "L4=RD=Sb=" },		/* 0x44 */
  {  5, "L4=RD=Sb=" },		/* 0x45 */
  {  6, "L4=RD=Sb=" },		/* 0x46 */
  {  7, "L4=RD=Sb=" },		/* 0x47 */
  {  8, "L4=RD=Sb=" },		/* 0x48 */
  {  9, "L4=RD=Sb=" },		/* 0x49 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x4a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x4b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x4c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x4d */
  /* R_RESERVED */
  {  0, "" },			/* 0x4e */
  {  0, "" },			/* 0x4f */
  /* R_DP_RELATIVE */
  {  0, "L4=SD=" },		/* 0x50 */
  {  1, "L4=SD=" },		/* 0x51 */
  {  2, "L4=SD=" },		/* 0x52 */
  {  3, "L4=SD=" },		/* 0x53 */
  {  4, "L4=SD=" },		/* 0x54 */
  {  5, "L4=SD=" },		/* 0x55 */
  {  6, "L4=SD=" },		/* 0x56 */
  {  7, "L4=SD=" },		/* 0x57 */
  {  8, "L4=SD=" },		/* 0x58 */
  {  9, "L4=SD=" },		/* 0x59 */
  { 10, "L4=SD=" },		/* 0x5a */
  { 11, "L4=SD=" },		/* 0x5b */
  { 12, "L4=SD=" },		/* 0x5c */
  { 13, "L4=SD=" },		/* 0x5d */
  { 14, "L4=SD=" },		/* 0x5e */
  { 15, "L4=SD=" },		/* 0x5f */
  { 16, "L4=SD=" },		/* 0x60 */
  { 17, "L4=SD=" },		/* 0x61 */
  { 18, "L4=SD=" },		/* 0x62 */
  { 19, "L4=SD=" },		/* 0x63 */
  { 20, "L4=SD=" },		/* 0x64 */
  { 21, "L4=SD=" },		/* 0x65 */
  { 22, "L4=SD=" },		/* 0x66 */
  { 23, "L4=SD=" },		/* 0x67 */
  { 24, "L4=SD=" },		/* 0x68 */
  { 25, "L4=SD=" },		/* 0x69 */
  { 26, "L4=SD=" },		/* 0x6a */
  { 27, "L4=SD=" },		/* 0x6b */
  { 28, "L4=SD=" },		/* 0x6c */
  { 29, "L4=SD=" },		/* 0x6d */
  { 30, "L4=SD=" },		/* 0x6e */
  { 31, "L4=SD=" },		/* 0x6f */
  { 32, "L4=Sb=" },		/* 0x70 */
  { 33, "L4=Sd=" },		/* 0x71 */
  /* R_RESERVED */
  {  0, "" },			/* 0x72 */
  {  0, "" },			/* 0x73 */
  {  0, "" },			/* 0x74 */
  {  0, "" },			/* 0x75 */
  {  0, "" },			/* 0x76 */
  {  0, "" },			/* 0x77 */
  /* R_DLT_REL */
  {  0, "L4=Sb=" },		/* 0x78 */
  {  1, "L4=Sd=" },		/* 0x79 */
  /* R_RESERVED */
  {  0, "" },			/* 0x7a */
  {  0, "" },			/* 0x7b */
  {  0, "" },			/* 0x7c */
  {  0, "" },			/* 0x7d */
  {  0, "" },			/* 0x7e */
  {  0, "" },			/* 0x7f */
  /* R_CODE_ONE_SYMBOL */
  {  0, "L4=SD=" },		/* 0x80 */
  {  1, "L4=SD=" },		/* 0x81 */
  {  2, "L4=SD=" },		/* 0x82 */
  {  3, "L4=SD=" },		/* 0x83 */
  {  4, "L4=SD=" },		/* 0x84 */
  {  5, "L4=SD=" },		/* 0x85 */
  {  6, "L4=SD=" },		/* 0x86 */
  {  7, "L4=SD=" },		/* 0x87 */
  {  8, "L4=SD=" },		/* 0x88 */
  {  9, "L4=SD=" },		/* 0x89 */
  { 10, "L4=SD=" },		/* 0x8q */
  { 11, "L4=SD=" },		/* 0x8b */
  { 12, "L4=SD=" },		/* 0x8c */
  { 13, "L4=SD=" },		/* 0x8d */
  { 14, "L4=SD=" },		/* 0x8e */
  { 15, "L4=SD=" },		/* 0x8f */
  { 16, "L4=SD=" },		/* 0x90 */
  { 17, "L4=SD=" },		/* 0x91 */
  { 18, "L4=SD=" },		/* 0x92 */
  { 19, "L4=SD=" },		/* 0x93 */
  { 20, "L4=SD=" },		/* 0x94 */
  { 21, "L4=SD=" },		/* 0x95 */
  { 22, "L4=SD=" },		/* 0x96 */
  { 23, "L4=SD=" },		/* 0x97 */
  { 24, "L4=SD=" },		/* 0x98 */
  { 25, "L4=SD=" },		/* 0x99 */
  { 26, "L4=SD=" },		/* 0x9a */
  { 27, "L4=SD=" },		/* 0x9b */
  { 28, "L4=SD=" },		/* 0x9c */
  { 29, "L4=SD=" },		/* 0x9d */
  { 30, "L4=SD=" },		/* 0x9e */
  { 31, "L4=SD=" },		/* 0x9f */
  { 32, "L4=Sb=" },		/* 0xa0 */
  { 33, "L4=Sd=" },		/* 0xa1 */
  /* R_RESERVED */
  {  0, "" },			/* 0xa2 */
  {  0, "" },			/* 0xa3 */
  {  0, "" },			/* 0xa4 */
  {  0, "" },			/* 0xa5 */
  {  0, "" },			/* 0xa6 */
  {  0, "" },			/* 0xa7 */
  {  0, "" },			/* 0xa8 */
  {  0, "" },			/* 0xa9 */
  {  0, "" },			/* 0xaa */
  {  0, "" },			/* 0xab */
  {  0, "" },			/* 0xac */
  {  0, "" },			/* 0xad */
  /* R_MILLI_REL */
  {  0, "L4=Sb=" },		/* 0xae */
  {  1, "L4=Sd=" },		/* 0xaf */
  /* R_CODE_PLABEL */
  {  0, "L4=Sb=" },		/* 0xb0 */
  {  1, "L4=Sd=" },		/* 0xb1 */
  /* R_BREAKPOINT */
  {  0, "L4=" },		/* 0xb2 */
  /* R_ENTRY */
  {  0, "Te=Ue=" },		/* 0xb3 */
  {  1, "Uf=" },		/* 0xb4 */
  /* R_ALT_ENTRY */
  {  0, "" },			/* 0xb5 */
  /* R_EXIT */
  {  0, "" },			/* 0xb6 */
  /* R_BEGIN_TRY */
  {  0, "" },			/* 0xb7 */
  /* R_END_TRY */
  {  0, "R0=" },		/* 0xb8 */
  {  1, "Rb4*=" },		/* 0xb9 */
  {  2, "Rd4*=" },		/* 0xba */
  /* R_BEGIN_BRTAB */
  {  0, "" },			/* 0xbb */
  /* R_END_BRTAB */
  {  0, "" },			/* 0xbc */
  /* R_STATEMENT */
  {  0, "Nb=" },		/* 0xbd */
  {  1, "Nc=" },		/* 0xbe */
  {  2, "Nd=" },		/* 0xbf */
  /* R_DATA_EXPR */
  {  0, "L4=" },		/* 0xc0 */
  /* R_CODE_EXPR */
  {  0, "L4=" },		/* 0xc1 */
  /* R_FSEL */
  {  0, "" },			/* 0xc2 */
  /* R_LSEL */
  {  0, "" },			/* 0xc3 */
  /* R_RSEL */
  {  0, "" },			/* 0xc4 */
  /* R_N_MODE */
  {  0, "" },			/* 0xc5 */
  /* R_S_MODE */
  {  0, "" },			/* 0xc6 */
  /* R_D_MODE */
  {  0, "" },			/* 0xc7 */
  /* R_R_MODE */
  {  0, "" },			/* 0xc8 */
  /* R_DATA_OVERRIDE */
  {  0, "V0=" },		/* 0xc9 */
  {  1, "Vb=" },		/* 0xca */
  {  2, "Vc=" },		/* 0xcb */
  {  3, "Vd=" },		/* 0xcc */
  {  4, "Ve=" },		/* 0xcd */
  /* R_TRANSLATED */
  {  0, "" },			/* 0xce */
  /* R_AUX_UNWIND */
  {  0,"Sd=Ve=Ee=" },	       /* 0xcf */
  /* R_COMP1 */
  {  0, "Ob=" },		/* 0xd0 */
  /* R_COMP2 */
  {  0, "Ob=Sd=" },		/* 0xd1 */
  /* R_COMP3 */
  {  0, "Ob=Ve=" },		/* 0xd2 */
  /* R_PREV_FIXUP */
  {  0, "P" },			/* 0xd3 */
  {  1, "P" },			/* 0xd4 */
  {  2, "P" },			/* 0xd5 */
  {  3, "P" },			/* 0xd6 */
  /* R_SEC_STMT */
  {  0, "" },			/* 0xd7 */
  /* R_N0SEL */
  {  0, "" },			/* 0xd8 */
  /* R_N1SEL */
  {  0, "" },			/* 0xd9 */
  /* R_LINETAB */
  {  0, "Eb=Sd=Ve=" },		/* 0xda */
  /* R_LINETAB_ESC */
  {  0, "Eb=Mb=" },		/* 0xdb */
  /* R_LTP_OVERRIDE */
  {  0, "" },			/* 0xdc */
  /* R_COMMENT */
  {  0, "Ob=Vf=" },		/* 0xdd */
  /* R_RESERVED */
  {  0, "" },			/* 0xde */
  {  0, "" },			/* 0xdf */
  {  0, "" },			/* 0xe0 */
  {  0, "" },			/* 0xe1 */
  {  0, "" },			/* 0xe2 */
  {  0, "" },			/* 0xe3 */
  {  0, "" },			/* 0xe4 */
  {  0, "" },			/* 0xe5 */
  {  0, "" },			/* 0xe6 */
  {  0, "" },			/* 0xe7 */
  {  0, "" },			/* 0xe8 */
  {  0, "" },			/* 0xe9 */
  {  0, "" },			/* 0xea */
  {  0, "" },			/* 0xeb */
  {  0, "" },			/* 0xec */
  {  0, "" },			/* 0xed */
  {  0, "" },			/* 0xee */
  {  0, "" },			/* 0xef */
  {  0, "" },			/* 0xf0 */
  {  0, "" },			/* 0xf1 */
  {  0, "" },			/* 0xf2 */
  {  0, "" },			/* 0xf3 */
  {  0, "" },			/* 0xf4 */
  {  0, "" },			/* 0xf5 */
  {  0, "" },			/* 0xf6 */
  {  0, "" },			/* 0xf7 */
  {  0, "" },			/* 0xf8 */
  {  0, "" },			/* 0xf9 */
  {  0, "" },			/* 0xfa */
  {  0, "" },			/* 0xfb */
  {  0, "" },			/* 0xfc */
  {  0, "" },			/* 0xfd */
  {  0, "" },			/* 0xfe */
  {  0, "" },			/* 0xff */
};

static const int comp1_opcodes[] = {
  0x00,
  0x40,
  0x41,
  0x42,
  0x43,
  0x44,
  0x45,
  0x46,
  0x47,
  0x48,
  0x49,
  0x4a,
  0x4b,
  0x60,
  0x80,
  0xa0,
  0xc0,
  -1
};

static const int comp2_opcodes[] = {
  0x00,
  0x80,
  0x82,
  0xc0,
  -1
};

static const int comp3_opcodes[] = {
  0x00,
  0x02,
  -1
};

/* These apparently are not in older versions of hpux reloc.h (hpux7).  */
#ifndef R_DLT_REL
#define R_DLT_REL 0x78
#endif

#ifndef R_AUX_UNWIND
#define R_AUX_UNWIND 0xcf
#endif

#ifndef R_SEC_STMT
#define R_SEC_STMT 0xd7
#endif

/* And these first appeared in hpux10.  */
#ifndef R_SHORT_PCREL_MODE
#define NO_PCREL_MODES
#define R_SHORT_PCREL_MODE 0x3e
#endif

#ifndef R_LONG_PCREL_MODE
#define R_LONG_PCREL_MODE 0x3f
#endif

#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif

#ifndef R_LINETAB
#define R_LINETAB 0xda
#endif

#ifndef R_LINETAB_ESC
#define R_LINETAB_ESC 0xdb
#endif

#ifndef R_LTP_OVERRIDE
#define R_LTP_OVERRIDE 0xdc
#endif

#ifndef R_COMMENT
#define R_COMMENT 0xdd
#endif

#define SOM_HOWTO(TYPE, NAME)	\
  HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)

static reloc_howto_type som_hppa_howto_table[] = {
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_RELOCATION, "R_RELOCATION"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_SPACE_REF, "R_SPACE_REF"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_SHORT_PCREL_MODE, "R_SHORT_PCREL_MODE"),
  SOM_HOWTO (R_LONG_PCREL_MODE, "R_LONG_PCREL_MODE"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_BREAKPOINT, "R_BREAKPOINT"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ALT_ENTRY, "R_ALT_ENTRY"),
  SOM_HOWTO (R_EXIT, "R_EXIT"),
  SOM_HOWTO (R_BEGIN_TRY, "R_BEGIN_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_BEGIN_BRTAB, "R_BEGIN_BRTAB"),
  SOM_HOWTO (R_END_BRTAB, "R_END_BRTAB"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_DATA_EXPR, "R_DATA_EXPR"),
  SOM_HOWTO (R_CODE_EXPR, "R_CODE_EXPR"),
  SOM_HOWTO (R_FSEL, "R_FSEL"),
  SOM_HOWTO (R_LSEL, "R_LSEL"),
  SOM_HOWTO (R_RSEL, "R_RSEL"),
  SOM_HOWTO (R_N_MODE, "R_N_MODE"),
  SOM_HOWTO (R_S_MODE, "R_S_MODE"),
  SOM_HOWTO (R_D_MODE, "R_D_MODE"),
  SOM_HOWTO (R_R_MODE, "R_R_MODE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_TRANSLATED, "R_TRANSLATED"),
  SOM_HOWTO (R_AUX_UNWIND, "R_AUX_UNWIND"),
  SOM_HOWTO (R_COMP1, "R_COMP1"),
  SOM_HOWTO (R_COMP2, "R_COMP2"),
  SOM_HOWTO (R_COMP3, "R_COMP3"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_SEC_STMT, "R_SEC_STMT"),
  SOM_HOWTO (R_N0SEL, "R_N0SEL"),
  SOM_HOWTO (R_N1SEL, "R_N1SEL"),
  SOM_HOWTO (R_LINETAB, "R_LINETAB"),
  SOM_HOWTO (R_LINETAB_ESC, "R_LINETAB_ESC"),
  SOM_HOWTO (R_LTP_OVERRIDE, "R_LTP_OVERRIDE"),
  SOM_HOWTO (R_COMMENT, "R_COMMENT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED")
};

/* Initialize the SOM relocation queue.  By definition the queue holds
   the last four multibyte fixups.  */

static void
som_initialize_reloc_queue (queue)
     struct reloc_queue *queue;
{
  queue[0].reloc = NULL;
  queue[0].size = 0;
  queue[1].reloc = NULL;
  queue[1].size = 0;
  queue[2].reloc = NULL;
  queue[2].size = 0;
  queue[3].reloc = NULL;
  queue[3].size = 0;
}

/* Insert a new relocation into the relocation queue.  */

static void
som_reloc_queue_insert (p, size, queue)
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
{
  queue[3].reloc = queue[2].reloc;
  queue[3].size = queue[2].size;
  queue[2].reloc = queue[1].reloc;
  queue[2].size = queue[1].size;
  queue[1].reloc = queue[0].reloc;
  queue[1].size = queue[0].size;
  queue[0].reloc = p;
  queue[0].size = size;
}

/* When an entry in the relocation queue is reused, the entry moves
   to the front of the queue.  */

static void
som_reloc_queue_fix (queue, index)
     struct reloc_queue *queue;
     unsigned int index;
{
  if (index == 0)
    return;

  if (index == 1)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;
      queue[0].reloc = queue[1].reloc;
      queue[0].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }

  if (index == 2)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;
      queue[0].reloc = queue[2].reloc;
      queue[0].size = queue[2].size;
      queue[2].reloc = queue[1].reloc;
      queue[2].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }

  if (index == 3)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;
      queue[0].reloc = queue[3].reloc;
      queue[0].size = queue[3].size;
      queue[3].reloc = queue[2].reloc;
      queue[3].size = queue[2].size;
      queue[2].reloc = queue[1].reloc;
      queue[2].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }
  abort ();
}

/* Search for a particular relocation in the relocation queue.  */

static int
som_reloc_queue_find (p, size, queue)
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
{
  if (queue[0].reloc && !memcmp (p, queue[0].reloc, size)
      && size == queue[0].size)
    return 0;
  if (queue[1].reloc && !memcmp (p, queue[1].reloc, size)
      && size == queue[1].size)
    return 1;
  if (queue[2].reloc && !memcmp (p, queue[2].reloc, size)
      && size == queue[2].size)
    return 2;
  if (queue[3].reloc && !memcmp (p, queue[3].reloc, size)
      && size == queue[3].size)
    return 3;
  return -1;
}

static unsigned char *
try_prev_fixup (abfd, subspace_reloc_sizep, p, size, queue)
     bfd *abfd ATTRIBUTE_UNUSED;
     int *subspace_reloc_sizep;
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
{
  int queue_index = som_reloc_queue_find (p, size, queue);

  if (queue_index != -1)
    {
      /* Found this in a previous fixup.  Undo the fixup we
	 just built and use R_PREV_FIXUP instead.  We saved
	 a total of size - 1 bytes in the fixup stream.  */
      bfd_put_8 (abfd, R_PREV_FIXUP + queue_index, p);
      p += 1;
      *subspace_reloc_sizep += 1;
      som_reloc_queue_fix (queue, queue_index);
    }
  else
    {
      som_reloc_queue_insert (p, size, queue);
      *subspace_reloc_sizep += size;
      p += size;
    }
  return p;
}

/* Emit the proper R_NO_RELOCATION fixups to map the next SKIP
   bytes without any relocation.  Update the size of the subspace
   relocation stream via SUBSPACE_RELOC_SIZE_P; also return the
   current pointer into the relocation stream.  */

static unsigned char *
som_reloc_skip (abfd, skip, p, subspace_reloc_sizep, queue)
     bfd *abfd;
     unsigned int skip;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     struct reloc_queue *queue;
{
  /* Use a 4 byte R_NO_RELOCATION entry with a maximal value
     then R_PREV_FIXUPs to get the difference down to a
     reasonable size.  */
  if (skip >= 0x1000000)
    {
      skip -= 0x1000000;
      bfd_put_8 (abfd, R_NO_RELOCATION + 31, p);
      bfd_put_8 (abfd, 0xff, p + 1);
      bfd_put_16 (abfd, (bfd_vma) 0xffff, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
      while (skip >= 0x1000000)
	{
	  skip -= 0x1000000;
	  bfd_put_8 (abfd, R_PREV_FIXUP, p);
	  p++;
	  *subspace_reloc_sizep += 1;
	  /* No need to adjust queue here since we are repeating the
	     most recent fixup.  */
	}
    }

  /* The difference must be less than 0x1000000.  Use one
     more R_NO_RELOCATION entry to get to the right difference.  */
  if ((skip & 3) == 0 && skip <= 0xc0000 && skip > 0)
    {
      /* Difference can be handled in a simple single-byte
	 R_NO_RELOCATION entry.  */
      if (skip <= 0x60)
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + (skip >> 2) - 1, p);
	  *subspace_reloc_sizep += 1;
	  p++;
	}
      /* Handle it with a two byte R_NO_RELOCATION entry.  */
      else if (skip <= 0x1000)
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + 24 + (((skip >> 2) - 1) >> 8), p);
	  bfd_put_8 (abfd, (skip >> 2) - 1, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
	}
      /* Handle it with a three byte R_NO_RELOCATION entry.  */
      else
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + 28 + (((skip >> 2) - 1) >> 16), p);
	  bfd_put_16 (abfd, (bfd_vma) (skip >> 2) - 1, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
	}
    }
  /* Ugh.  Punt and use a 4 byte entry.  */
  else if (skip > 0)
    {
      bfd_put_8 (abfd, R_NO_RELOCATION + 31, p);
      bfd_put_8 (abfd, (skip - 1) >> 16, p + 1);
      bfd_put_16 (abfd, (bfd_vma) skip - 1, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
    }
  return p;
}

/* Emit the proper R_DATA_OVERRIDE fixups to handle a nonzero addend
   from a BFD relocation.  Update the size of the subspace relocation
   stream via SUBSPACE_RELOC_SIZE_P; also return the current pointer
   into the relocation stream.  */

static unsigned char *
som_reloc_addend (abfd, addend, p, subspace_reloc_sizep, queue)
     bfd *abfd;
     bfd_vma addend;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     struct reloc_queue *queue;
{
  if (addend + 0x80 < 0x100)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 1, p);
      bfd_put_8 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
    }
  else if (addend + 0x8000 < 0x10000)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 2, p);
      bfd_put_16 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
    }
  else if (addend + 0x800000 < 0x1000000)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 3, p);
      bfd_put_8 (abfd, addend >> 16, p + 1);
      bfd_put_16 (abfd, addend, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
    }
  else
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 4, p);
      bfd_put_32 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 5, queue);
    }
  return p;
}

/* Handle a single function call relocation.  */

static unsigned char *
som_reloc_call (abfd, p, subspace_reloc_sizep, bfd_reloc, sym_num, queue)
     bfd *abfd;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     arelent *bfd_reloc;
     int sym_num;
     struct reloc_queue *queue;
{
  int arg_bits = HPPA_R_ARG_RELOC (bfd_reloc->addend);
  int rtn_bits = arg_bits & 0x3;
  int type, done = 0;

  /* You'll never believe all this is necessary to handle relocations
     for function calls.  Having to compute and pack the argument
     relocation bits is the real nightmare.

     If you're interested in how this works, just forget it.  You really
     do not want to know about this braindamage.  */

  /* First see if this can be done with a "simple" relocation.  Simple
     relocations have a symbol number < 0x100 and have simple encodings
     of argument relocations.  */

  if (sym_num < 0x100)
    {
      switch (arg_bits)
	{
	case 0:
	case 1:
	  type = 0;
	  break;
	case 1 << 8:
	case 1 << 8 | 1:
	  type = 1;
	  break;
	case 1 << 8 | 1 << 6:
	case 1 << 8 | 1 << 6 | 1:
	  type = 2;
	  break;
	case 1 << 8 | 1 << 6 | 1 << 4:
	case 1 << 8 | 1 << 6 | 1 << 4 | 1:
	  type = 3;
	  break;
	case 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2:
	case 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2 | 1:
	  type = 4;
	  break;
	default:
	  /* Not one of the easy encodings.  This will have to be
	     handled by the more complex code below.  */
	  type = -1;
	  break;
	}
      if (type != -1)
	{
	  /* Account for the return value too.  */
	  if (rtn_bits)
	    type += 5;

	  /* Emit a 2 byte relocation.  Then see if it can be handled
	     with a relocation which is already in the relocation queue.  */
	  bfd_put_8 (abfd, bfd_reloc->howto->type + type, p);
	  bfd_put_8 (abfd, sym_num, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
	  done = 1;
	}
    }

  /* If this could not be handled with a simple relocation, then do a hard
     one.  Hard relocations occur if the symbol number was too high or if
     the encoding of argument relocation bits is too complex.  */
  if (! done)
    {
      /* Don't ask about these magic sequences.  I took them straight
	 from gas-1.36 which took them from the a.out man page.  */
      type = rtn_bits;
      if ((arg_bits >> 6 & 0xf) == 0xe)
	type += 9 * 40;
      else
	type += (3 * (arg_bits >> 8 & 3) + (arg_bits >> 6 & 3)) * 40;
      if ((arg_bits >> 2 & 0xf) == 0xe)
	type += 9 * 4;
      else
	type += (3 * (arg_bits >> 4 & 3) + (arg_bits >> 2 & 3)) * 4;

      /* Output the first two bytes of the relocation.  These describe
	 the length of the relocation and encoding style.  */
      bfd_put_8 (abfd, bfd_reloc->howto->type + 10
		 + 2 * (sym_num >= 0x100) + (type >= 0x100),
		 p);
      bfd_put_8 (abfd, type, p + 1);

      /* Now output the symbol index and see if this bizarre relocation
	 just happened to be in the relocation queue.  */
      if (sym_num < 0x100)
	{
	  bfd_put_8 (abfd, sym_num, p + 2);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
	}
      else
	{
	  bfd_put_8 (abfd, sym_num >> 16, p + 2);
	  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 5, queue);
	}
    }
  return p;
}

/* Return the logarithm of X, base 2, considering X unsigned.
   Abort -1 if X is not a power or two or is zero.  */

static int
log2 (x)
     unsigned int x;
{
  int log = 0;

  /* Test for 0 or a power of 2.  */
  if (x == 0 || x != (x & -x))
    return -1;

  while ((x >>= 1) != 0)
    log++;
  return log;
}

static bfd_reloc_status_type
hppa_som_reloc (abfd, reloc_entry, symbol_in, data,
		input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol_in ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  return bfd_reloc_ok;
}

/* Given a generic HPPA relocation type, the instruction format,
   and a field selector, return one or more appropriate SOM relocations.  */

int **
hppa_som_gen_reloc_type (abfd, base_type, format, field, sym_diff, sym)
     bfd *abfd;
     int base_type;
     int format;
     enum hppa_reloc_field_selector_type_alt field;
     int sym_diff;
     asymbol *sym;
{
  int *final_type, **final_types;

  final_types = (int **) bfd_alloc (abfd, (bfd_size_type) sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
  if (!final_types || !final_type)
    return NULL;

  /* The field selector may require additional relocations to be
     generated.  It's impossible to know at this moment if additional
     relocations will be needed, so we make them.  The code to actually
     write the relocation/fixup stream is responsible for removing
     any redundant relocations.  */
  switch (field)
    {
    case e_fsel:
    case e_psel:
    case e_lpsel:
    case e_rpsel:
      final_types[0] = final_type;
      final_types[1] = NULL;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_tsel:
    case e_ltsel:
    case e_rtsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      if (field == e_tsel)
	*final_types[0] = R_FSEL;
      else if (field == e_ltsel)
	*final_types[0] = R_LSEL;
      else
	*final_types[0] = R_RSEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lssel:
    case e_rssel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_S_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lsel:
    case e_rsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_ldsel:
    case e_rdsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_D_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lrsel:
    case e_rrsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_R_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_nsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N1SEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_nlsel:
    case e_nlrsel:
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N0SEL;
      final_types[1] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[1])
	return NULL;
      if (field == e_nlsel)
	*final_types[1] = R_N_MODE;
      else
	*final_types[1] = R_R_MODE;
      final_types[2] = final_type;
      final_types[3] = NULL;
      *final_type = base_type;
      break;
    }

  switch (base_type)
    {
    case R_HPPA:
      /* The difference of two symbols needs *very* special handling.  */
      if (sym_diff)
	{
	  bfd_size_type amt = sizeof (int);
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
	  if (!final_types[0] || !final_types[1] || !final_types[2])
	    return NULL;
	  if (field == e_fsel)
	    *final_types[0] = R_FSEL;
	  else if (field == e_rsel)
	    *final_types[0] = R_RSEL;
	  else if (field == e_lsel)
	    *final_types[0] = R_LSEL;
	  *final_types[1] = R_COMP2;
	  *final_types[2] = R_COMP2;
	  *final_types[3] = R_COMP1;
	  final_types[4] = final_type;
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
	  final_types[5] = NULL;
	  break;
	}
      /* PLABELs get their own relocation type.  */
      else if (field == e_psel
	       || field == e_lpsel
	       || field == e_rpsel)
	{
	  /* A PLABEL relocation that has a size of 32 bits must
	     be a R_DATA_PLABEL.  All others are R_CODE_PLABELs.  */
	  if (format == 32)
	    *final_type = R_DATA_PLABEL;
	  else
	    *final_type = R_CODE_PLABEL;
	}
      /* PIC stuff.  */
      else if (field == e_tsel
	       || field == e_ltsel
	       || field == e_rtsel)
	*final_type = R_DLT_REL;
      /* A relocation in the data space is always a full 32bits.  */
      else if (format == 32)
	{
	  *final_type = R_DATA_ONE_SYMBOL;

	  /* If there's no SOM symbol type associated with this BFD
	     symbol, then set the symbol type to ST_DATA.

	     Only do this if the type is going to default later when
	     we write the object file.

	     This is done so that the linker never encounters an
	     R_DATA_ONE_SYMBOL reloc involving an ST_CODE symbol.

	     This allows the compiler to generate exception handling
	     tables.

	     Note that one day we may need to also emit BEGIN_BRTAB and
	     END_BRTAB to prevent the linker from optimizing away insns
	     in exception handling regions.  */
	  if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
	      && (sym->flags & BSF_SECTION_SYM) == 0
	      && (sym->flags & BSF_FUNCTION) == 0
	      && ! bfd_is_com_section (sym->section))
	    som_symbol_data (sym)->som_type = SYMBOL_TYPE_DATA;
	}
      break;

    case R_HPPA_GOTOFF:
      /* More PLABEL special cases.  */
      if (field == e_psel
	  || field == e_lpsel
	  || field == e_rpsel)
	*final_type = R_DATA_PLABEL;
      break;

    case R_HPPA_COMPLEX:
      /* The difference of two symbols needs *very* special handling.  */
      if (sym_diff)
	{
	  bfd_size_type amt = sizeof (int);
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
	  if (!final_types[0] || !final_types[1] || !final_types[2])
	    return NULL;
	  if (field == e_fsel)
	    *final_types[0] = R_FSEL;
	  else if (field == e_rsel)
	    *final_types[0] = R_RSEL;
	  else if (field == e_lsel)
	    *final_types[0] = R_LSEL;
	  *final_types[1] = R_COMP2;
	  *final_types[2] = R_COMP2;
	  *final_types[3] = R_COMP1;
	  final_types[4] = final_type;
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
	  final_types[5] = NULL;
	  break;
	}
      else
	break;

    case R_HPPA_NONE:
    case R_HPPA_ABS_CALL:
      /* Right now we can default all these.  */
      break;

    case R_HPPA_PCREL_CALL:
      {
#ifndef NO_PCREL_MODES
	/* If we have short and long pcrel modes, then generate the proper
	   mode selector, then the pcrel relocation.  Redundant selectors
	   will be eliminated as the relocs are sized and emitted.  */
	bfd_size_type amt = sizeof (int);
	final_types[0] = (int *) bfd_alloc (abfd, amt);
	if (!final_types[0])
	  return NULL;
	if (format == 17)
	  *final_types[0] = R_SHORT_PCREL_MODE;
	else
	  *final_types[0] = R_LONG_PCREL_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
#endif
	break;
      }
    }
  return final_types;
}

/* Return the address of the correct entry in the PA SOM relocation
   howto table.  */

static reloc_howto_type *
som_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  if ((int) code < (int) R_NO_RELOCATION + 255)
    {
      BFD_ASSERT ((int) som_hppa_howto_table[(int) code].type == (int) code);
      return &som_hppa_howto_table[(int) code];
    }

  return (reloc_howto_type *) 0;
}

/* Perform some initialization for an object.  Save results of this
   initialization in the BFD.  */

static const bfd_target *
som_object_setup (abfd, file_hdrp, aux_hdrp, current_offset)
     bfd *abfd;
     struct header *file_hdrp;
     struct som_exec_auxhdr *aux_hdrp;
     unsigned long current_offset;
{
  asection *section;
  int found;

  /* som_mkobject will set bfd_error if som_mkobject fails.  */
  if (! som_mkobject (abfd))
    return 0;

  /* Set BFD flags based on what information is available in the SOM.  */
  abfd->flags = BFD_NO_FLAGS;
  if (file_hdrp->symbol_total)
    abfd->flags |= HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS;

  switch (file_hdrp->a_magic)
    {
    case DEMAND_MAGIC:
      abfd->flags |= (D_PAGED | WP_TEXT | EXEC_P);
      break;
    case SHARE_MAGIC:
      abfd->flags |= (WP_TEXT | EXEC_P);
      break;
    case EXEC_MAGIC:
      abfd->flags |= (EXEC_P);
      break;
    case RELOC_MAGIC:
      abfd->flags |= HAS_RELOC;
      break;
#ifdef SHL_MAGIC
    case SHL_MAGIC:
#endif
#ifdef DL_MAGIC
    case DL_MAGIC:
#endif
      abfd->flags |= DYNAMIC;
      break;

    default:
      break;
    }

  /* Allocate space to hold the saved exec header information.  */
  obj_som_exec_data (abfd) = (struct som_exec_data *)
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_exec_data));
  if (obj_som_exec_data (abfd) == NULL)
    return NULL;

  /* The braindamaged OSF1 linker switched exec_flags and exec_entry!

     We used to identify OSF1 binaries based on NEW_VERSION_ID, but
     apparently the latest HPUX linker is using NEW_VERSION_ID now.

     It's about time, OSF has used the new id since at least 1992;
     HPUX didn't start till nearly 1995!.

     The new approach examines the entry field.  If it's zero or not 4
     byte aligned then it's not a proper code address and we guess it's
     really the executable flags.  */
  found = 0;
  for (section = abfd->sections; section; section = section->next)
    {
      if ((section->flags & SEC_CODE) == 0)
	continue;
      if (aux_hdrp->exec_entry >= section->vma
	  && aux_hdrp->exec_entry < section->vma + section->_cooked_size)
	found = 1;
    }
  if (aux_hdrp->exec_entry == 0
      || (aux_hdrp->exec_entry & 0x3) != 0
      || ! found)
    {
      bfd_get_start_address (abfd) = aux_hdrp->exec_flags;
      obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_entry;
    }
  else
    {
      bfd_get_start_address (abfd) = aux_hdrp->exec_entry + current_offset;
      obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_flags;
    }

  obj_som_exec_data (abfd)->version_id = file_hdrp->version_id;

  bfd_default_set_arch_mach (abfd, bfd_arch_hppa, pa10);
  bfd_get_symcount (abfd) = file_hdrp->symbol_total;

  /* Initialize the saved symbol table and string table to NULL.
     Save important offsets and sizes from the SOM header into
     the BFD.  */
  obj_som_stringtab (abfd) = (char *) NULL;
  obj_som_symtab (abfd) = (som_symbol_type *) NULL;
  obj_som_sorted_syms (abfd) = NULL;
  obj_som_stringtab_size (abfd) = file_hdrp->symbol_strings_size;
  obj_som_sym_filepos (abfd) = file_hdrp->symbol_location + current_offset;
  obj_som_str_filepos (abfd) = (file_hdrp->symbol_strings_location
				+ current_offset);
  obj_som_reloc_filepos (abfd) = (file_hdrp->fixup_request_location
				  + current_offset);
  obj_som_exec_data (abfd)->system_id = file_hdrp->system_id;

  return abfd->xvec;
}

/* Convert all of the space and subspace info into BFD sections.  Each space
   contains a number of subspaces, which in turn describe the mapping between
   regions of the exec file, and the address space that the program runs in.
   BFD sections which correspond to spaces will overlap the sections for the
   associated subspaces.  */

static bfd_boolean
setup_sections (abfd, file_hdr, current_offset)
     bfd *abfd;
     struct header *file_hdr;
     unsigned long current_offset;
{
  char *space_strings;
  unsigned int space_index, i;
  unsigned int total_subspaces = 0;
  asection **subspace_sections = NULL;
  asection *section;
  bfd_size_type amt;

  /* First, read in space names.  */

  amt = file_hdr->space_strings_size;
  space_strings = bfd_malloc (amt);
  if (!space_strings && amt != 0)
    goto error_return;

  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location,
		SEEK_SET) != 0)
    goto error_return;
  if (bfd_bread (space_strings, amt, abfd) != amt)
    goto error_return;

  /* Loop over all of the space dictionaries, building up sections.  */
  for (space_index = 0; space_index < file_hdr->space_total; space_index++)
    {
      struct space_dictionary_record space;
      struct subspace_dictionary_record subspace, save_subspace;
      int subspace_index;
      asection *space_asect;
      char *newname;

      /* Read the space dictionary element.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->space_location
		     + space_index * sizeof space),
		    SEEK_SET) != 0)
	goto error_return;
      amt = sizeof space;
      if (bfd_bread (&space, amt, abfd) != amt)
	goto error_return;

      /* Setup the space name string.  */
      space.name.n_name = space.name.n_strx + space_strings;

      /* Make a section out of it.  */
      amt = strlen (space.name.n_name) + 1;
      newname = bfd_alloc (abfd, amt);
      if (!newname)
	goto error_return;
      strcpy (newname, space.name.n_name);

      space_asect = bfd_make_section_anyway (abfd, newname);
      if (!space_asect)
	goto error_return;

      if (space.is_loadable == 0)
	space_asect->flags |= SEC_DEBUGGING;

      /* Set up all the attributes for the space.  */
      if (! bfd_som_set_section_attributes (space_asect, space.is_defined,
					    space.is_private, space.sort_key,
					    space.space_number))
	goto error_return;

      /* If the space has no subspaces, then we're done.  */
      if (space.subspace_quantity == 0)
	continue;

      /* Now, read in the first subspace for this space.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof subspace),
		    SEEK_SET) != 0)
	goto error_return;
      amt = sizeof subspace;
      if (bfd_bread (&subspace, amt, abfd) != amt)
	goto error_return;
      /* Seek back to the start of the subspaces for loop below.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof subspace),
		    SEEK_SET) != 0)
	goto error_return;

      /* Setup the start address and file loc from the first subspace
	 record.  */
      space_asect->vma = subspace.subspace_start;
      space_asect->filepos = subspace.file_loc_init_value + current_offset;
      space_asect->alignment_power = log2 (subspace.alignment);
      if (space_asect->alignment_power == (unsigned) -1)
	goto error_return;

      /* Initialize save_subspace so we can reliably determine if this
	 loop placed any useful values into it.  */
      memset (&save_subspace, 0, sizeof (struct subspace_dictionary_record));

      /* Loop over the rest of the subspaces, building up more sections.  */
      for (subspace_index = 0; subspace_index < space.subspace_quantity;
	   subspace_index++)
	{
	  asection *subspace_asect;

	  /* Read in the next subspace.  */
	  amt = sizeof subspace;
	  if (bfd_bread (&subspace, amt, abfd) != amt)
	    goto error_return;

	  /* Setup the subspace name string.  */
	  subspace.name.n_name = subspace.name.n_strx + space_strings;

	  amt = strlen (subspace.name.n_name) + 1;
	  newname = bfd_alloc (abfd, amt);
	  if (!newname)
	    goto error_return;
	  strcpy (newname, subspace.name.n_name);

	  /* Make a section out of this subspace.  */
	  subspace_asect = bfd_make_section_anyway (abfd, newname);
	  if (!subspace_asect)
	    goto error_return;

	  /* Store private information about the section.  */
	  if (! bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						   subspace.access_control_bits,
						   subspace.sort_key,
						   subspace.quadrant))
	    goto error_return;

	  /* Keep an easy mapping between subspaces and sections.
	     Note we do not necessarily read the subspaces in the
	     same order in which they appear in the object file.

	     So to make the target index come out correctly, we
	     store the location of the subspace header in target
	     index, then sort using the location of the subspace
	     header as the key.  Then we can assign correct
	     subspace indices.  */
	  total_subspaces++;
	  subspace_asect->target_index = bfd_tell (abfd) - sizeof (subspace);

	  /* Set SEC_READONLY and SEC_CODE/SEC_DATA as specified
	     by the access_control_bits in the subspace header.  */
	  switch (subspace.access_control_bits >> 4)
	    {
	    /* Readonly data.  */
	    case 0x0:
	      subspace_asect->flags |= SEC_DATA | SEC_READONLY;
	      break;

	    /* Normal data.  */
	    case 0x1:
	      subspace_asect->flags |= SEC_DATA;
	      break;

	    /* Readonly code and the gateways.
	       Gateways have other attributes which do not map
	       into anything BFD knows about.  */
	    case 0x2:
	    case 0x4:
	    case 0x5:
	    case 0x6:
	    case 0x7:
	      subspace_asect->flags |= SEC_CODE | SEC_READONLY;
	      break;

	    /* dynamic (writable) code.  */
	    case 0x3:
	      subspace_asect->flags |= SEC_CODE;
	      break;
	    }

	  if (subspace.dup_common || subspace.is_common)
	    subspace_asect->flags |= SEC_IS_COMMON;
	  else if (subspace.subspace_length > 0)
	    subspace_asect->flags |= SEC_HAS_CONTENTS;

	  if (subspace.is_loadable)
	    subspace_asect->flags |= SEC_ALLOC | SEC_LOAD;
	  else
	    subspace_asect->flags |= SEC_DEBUGGING;

	  if (subspace.code_only)
	    subspace_asect->flags |= SEC_CODE;

	  /* Both file_loc_init_value and initialization_length will
	     be zero for a BSS like subspace.  */
	  if (subspace.file_loc_init_value == 0
	      && subspace.initialization_length == 0)
	    subspace_asect->flags &= ~(SEC_DATA | SEC_LOAD | SEC_HAS_CONTENTS);

	  /* This subspace has relocations.
	     The fixup_request_quantity is a byte count for the number of
	     entries in the relocation stream; it is not the actual number
	     of relocations in the subspace.  */
	  if (subspace.fixup_request_quantity != 0)
	    {
	      subspace_asect->flags |= SEC_RELOC;
	      subspace_asect->rel_filepos = subspace.fixup_request_index;
	      som_section_data (subspace_asect)->reloc_size
		= subspace.fixup_request_quantity;
	      /* We can not determine this yet.  When we read in the
		 relocation table the correct value will be filled in.  */
	      subspace_asect->reloc_count = (unsigned) -1;
	    }

	  /* Update save_subspace if appropriate.  */
	  if (subspace.file_loc_init_value > save_subspace.file_loc_init_value)
	    save_subspace = subspace;

	  subspace_asect->vma = subspace.subspace_start;
	  subspace_asect->_cooked_size = subspace.subspace_length;
	  subspace_asect->_raw_size = subspace.subspace_length;
	  subspace_asect->filepos = (subspace.file_loc_init_value
				     + current_offset);
	  subspace_asect->alignment_power = log2 (subspace.alignment);
	  if (subspace_asect->alignment_power == (unsigned) -1)
	    goto error_return;
	}

      /* This can happen for a .o which defines symbols in otherwise
	 empty subspaces.  */
      if (!save_subspace.file_loc_init_value)
	{
	  space_asect->_cooked_size = 0;
	  space_asect->_raw_size = 0;
	}
      else
	{
	  /* Setup the sizes for the space section based upon the info in the
	     last subspace of the space.  */
	  space_asect->_cooked_size = (save_subspace.subspace_start
				       - space_asect->vma
				       + save_subspace.subspace_length);
	  space_asect->_raw_size = (save_subspace.file_loc_init_value
				    - space_asect->filepos
				    + save_subspace.initialization_length);
	}
    }
  /* Now that we've read in all the subspace records, we need to assign
     a target index to each subspace.  */
  amt = total_subspaces;
  amt *= sizeof (asection *);
  subspace_sections = (asection **) bfd_malloc (amt);
  if (subspace_sections == NULL)
    goto error_return;

  for (i = 0, section = abfd->sections; section; section = section->next)
    {
      if (!som_is_subspace (section))
	continue;

      subspace_sections[i] = section;
      i++;
    }
  qsort (subspace_sections, total_subspaces,
	 sizeof (asection *), compare_subspaces);

  /* subspace_sections is now sorted in the order in which the subspaces
     appear in the object file.  Assign an index to each one now.  */
  for (i = 0; i < total_subspaces; i++)
    subspace_sections[i]->target_index = i;

  if (space_strings != NULL)
    free (space_strings);

  if (subspace_sections != NULL)
    free (subspace_sections);

  return TRUE;

 error_return:
  if (space_strings != NULL)
    free (space_strings);

  if (subspace_sections != NULL)
    free (subspace_sections);
  return FALSE;
}

/* Read in a SOM object and make it into a BFD.  */

static const bfd_target *
som_object_p (abfd)
     bfd *abfd;
{
  struct header file_hdr;
  struct som_exec_auxhdr aux_hdr;
  unsigned long current_offset = 0;
  struct lst_header lst_header;
  struct som_entry som_entry;
  bfd_size_type amt;
#define ENTRY_SIZE sizeof (struct som_entry)

  amt = FILE_HDR_SIZE;
  if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  if (!_PA_RISC_ID (file_hdr.system_id))
    {
      bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  switch (file_hdr.a_magic)
    {
    case RELOC_MAGIC:
    case EXEC_MAGIC:
    case SHARE_MAGIC:
    case DEMAND_MAGIC:
#ifdef DL_MAGIC
    case DL_MAGIC:
#endif
#ifdef SHL_MAGIC
    case SHL_MAGIC:
#endif
#ifdef SHARED_MAGIC_CNX
    case SHARED_MAGIC_CNX:
#endif
      break;

#ifdef EXECLIBMAGIC
    case EXECLIBMAGIC:
      /* Read the lst header and determine where the SOM directory begins.  */

      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      amt = SLSTHDR;
      if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      /* Position to and read the first directory entry.  */

      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      amt = ENTRY_SIZE;
      if (bfd_bread ((PTR) &som_entry, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      /* Now position to the first SOM.  */

      if (bfd_seek (abfd, som_entry.location, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      current_offset = som_entry.location;

      /* And finally, re-read the som header.  */
      amt = FILE_HDR_SIZE;
      if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}

      break;
#endif

    default:
      bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  if (file_hdr.version_id != VERSION_ID
      && file_hdr.version_id != NEW_VERSION_ID)
    {
      bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  /* If the aux_header_size field in the file header is zero, then this
     object is an incomplete executable (a .o file).  Do not try to read
     a non-existant auxiliary header.  */
  memset (&aux_hdr, 0, sizeof (struct som_exec_auxhdr));
  if (file_hdr.aux_header_size != 0)
    {
      amt = AUX_HDR_SIZE;
      if (bfd_bread ((PTR) &aux_hdr, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return 0;
	}
    }

  if (!setup_sections (abfd, &file_hdr, current_offset))
    {
      /* setup_sections does not bubble up a bfd error code.  */
      bfd_set_error (bfd_error_bad_value);
      return 0;
    }

  /* This appears to be a valid SOM object.  Do some initialization.  */
  return som_object_setup (abfd, &file_hdr, &aux_hdr, current_offset);
}

/* Create a SOM object.  */

static bfd_boolean
som_mkobject (abfd)
     bfd *abfd;
{
  /* Allocate memory to hold backend information.  */
  abfd->tdata.som_data = (struct som_data_struct *)
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_data_struct));
  if (abfd->tdata.som_data == NULL)
    return FALSE;
  return TRUE;
}

/* Initialize some information in the file header.  This routine makes
   not attempt at doing the right thing for a full executable; it
   is only meant to handle relocatable objects.  */

static bfd_boolean
som_prep_headers (abfd)
     bfd *abfd;
{
  struct header *file_hdr;
  asection *section;
  bfd_size_type amt = sizeof (struct header);

  /* Make and attach a file header to the BFD.  */
  file_hdr = (struct header *) bfd_zalloc (abfd, amt);
  if (file_hdr == NULL)
    return FALSE;
  obj_som_file_hdr (abfd) = file_hdr;

  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      /* Make and attach an exec header to the BFD.  */
      amt = sizeof (struct som_exec_auxhdr);
      obj_som_exec_hdr (abfd) =
	(struct som_exec_auxhdr *) bfd_zalloc (abfd, amt);
      if (obj_som_exec_hdr (abfd) == NULL)
	return FALSE;

      if (abfd->flags & D_PAGED)
	file_hdr->a_magic = DEMAND_MAGIC;
      else if (abfd->flags & WP_TEXT)
	file_hdr->a_magic = SHARE_MAGIC;
#ifdef SHL_MAGIC
      else if (abfd->flags & DYNAMIC)
	file_hdr->a_magic = SHL_MAGIC;
#endif
      else
	file_hdr->a_magic = EXEC_MAGIC;
    }
  else
    file_hdr->a_magic = RELOC_MAGIC;

  /* These fields are optional, and embedding timestamps is not always
     a wise thing to do, it makes comparing objects during a multi-stage
     bootstrap difficult.  */
  file_hdr->file_time.secs = 0;
  file_hdr->file_time.nanosecs = 0;

  file_hdr->entry_space = 0;
  file_hdr->entry_subspace = 0;
  file_hdr->entry_offset = 0;
  file_hdr->presumed_dp = 0;

  /* Now iterate over the sections translating information from
     BFD sections to SOM spaces/subspaces.  */

  for (section = abfd->sections; section != NULL; section = section->next)
    {
      /* Ignore anything which has not been marked as a space or
	 subspace.  */
      if (!som_is_space (section) && !som_is_subspace (section))
	continue;

      if (som_is_space (section))
	{
	  /* Allocate space for the space dictionary.  */
	  amt = sizeof (struct space_dictionary_record);
	  som_section_data (section)->space_dict =
	    (struct space_dictionary_record *) bfd_zalloc (abfd, amt);
	  if (som_section_data (section)->space_dict == NULL)
	    return FALSE;
	  /* Set space attributes.  Note most attributes of SOM spaces
	     are set based on the subspaces it contains.  */
	  som_section_data (section)->space_dict->loader_fix_index = -1;
	  som_section_data (section)->space_dict->init_pointer_index = -1;

	  /* Set more attributes that were stuffed away in private data.  */
	  som_section_data (section)->space_dict->sort_key =
	    som_section_data (section)->copy_data->sort_key;
	  som_section_data (section)->space_dict->is_defined =
	    som_section_data (section)->copy_data->is_defined;
	  som_section_data (section)->space_dict->is_private =
	    som_section_data (section)->copy_data->is_private;
	  som_section_data (section)->space_dict->space_number =
	    som_section_data (section)->copy_data->space_number;
	}
      else
	{
	  /* Allocate space for the subspace dictionary.  */
	  amt = sizeof (struct subspace_dictionary_record);
	  som_section_data (section)->subspace_dict =
	    (struct subspace_dictionary_record *) bfd_zalloc (abfd, amt);
	  if (som_section_data (section)->subspace_dict == NULL)
	    return FALSE;

	  /* Set subspace attributes.  Basic stuff is done here, additional
	     attributes are filled in later as more information becomes
	     available.  */
	  if (section->flags & SEC_IS_COMMON)
	    {
	      som_section_data (section)->subspace_dict->dup_common = 1;
	      som_section_data (section)->subspace_dict->is_common = 1;
	    }

	  if (section->flags & SEC_ALLOC)
	    som_section_data (section)->subspace_dict->is_loadable = 1;

	  if (section->flags & SEC_CODE)
	    som_section_data (section)->subspace_dict->code_only = 1;

	  som_section_data (section)->subspace_dict->subspace_start =
	    section->vma;
	  som_section_data (section)->subspace_dict->subspace_length =
	    bfd_section_size (abfd, section);
	  som_section_data (section)->subspace_dict->initialization_length =
	    bfd_section_size (abfd, section);
	  som_section_data (section)->subspace_dict->alignment =
	    1 << section->alignment_power;

	  /* Set more attributes that were stuffed away in private data.  */
	  som_section_data (section)->subspace_dict->sort_key =
	    som_section_data (section)->copy_data->sort_key;
	  som_section_data (section)->subspace_dict->access_control_bits =
	    som_section_data (section)->copy_data->access_control_bits;
	  som_section_data (section)->subspace_dict->quadrant =
	    som_section_data (section)->copy_data->quadrant;
	}
    }
  return TRUE;
}

/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */

static bfd_boolean
som_is_space (section)
     asection *section;
{
  /* If no copy data is available, then it's neither a space nor a
     subspace.  */
  if (som_section_data (section)->copy_data == NULL)
    return FALSE;

  /* If the containing space isn't the same as the given section,
     then this isn't a space.  */
  if (som_section_data (section)->copy_data->container != section
      && (som_section_data (section)->copy_data->container->output_section
	  != section))
    return FALSE;

  /* OK.  Must be a space.  */
  return TRUE;
}

/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */

static bfd_boolean
som_is_subspace (section)
     asection *section;
{
  /* If no copy data is available, then it's neither a space nor a
     subspace.  */
  if (som_section_data (section)->copy_data == NULL)
    return FALSE;

  /* If the containing space is the same as the given section,
     then this isn't a subspace.  */
  if (som_section_data (section)->copy_data->container == section
      || (som_section_data (section)->copy_data->container->output_section
	  == section))
    return FALSE;

  /* OK.  Must be a subspace.  */
  return TRUE;
}

/* Return TRUE if the given space contains the given subspace.  It
   is safe to assume space really is a space, and subspace really
   is a subspace.  */

static bfd_boolean
som_is_container (space, subspace)
     asection *space, *subspace;
{
  return (som_section_data (subspace)->copy_data->container == space
	  || (som_section_data (subspace)->copy_data->container->output_section
	      == space));
}

/* Count and return the number of spaces attached to the given BFD.  */

static unsigned long
som_count_spaces (abfd)
     bfd *abfd;
{
  int count = 0;
  asection *section;

  for (section = abfd->sections; section != NULL; section = section->next)
    count += som_is_space (section);

  return count;
}

/* Count the number of subspaces attached to the given BFD.  */

static unsigned long
som_count_subspaces (abfd)
     bfd *abfd;
{
  int count = 0;
  asection *section;

  for (section = abfd->sections; section != NULL; section = section->next)
    count += som_is_subspace (section);

  return count;
}

/* Return -1, 0, 1 indicating the relative ordering of sym1 and sym2.

   We desire symbols to be ordered starting with the symbol with the
   highest relocation count down to the symbol with the lowest relocation
   count.  Doing so compacts the relocation stream.  */

static int
compare_syms (arg1, arg2)
     const PTR arg1;
     const PTR arg2;

{
  asymbol **sym1 = (asymbol **) arg1;
  asymbol **sym2 = (asymbol **) arg2;
  unsigned int count1, count2;

  /* Get relocation count for each symbol.  Note that the count
     is stored in the udata pointer for section symbols!  */
  if ((*sym1)->flags & BSF_SECTION_SYM)
    count1 = (*sym1)->udata.i;
  else
    count1 = som_symbol_data (*sym1)->reloc_count;

  if ((*sym2)->flags & BSF_SECTION_SYM)
    count2 = (*sym2)->udata.i;
  else
    count2 = som_symbol_data (*sym2)->reloc_count;

  /* Return the appropriate value.  */
  if (count1 < count2)
    return 1;
  else if (count1 > count2)
    return -1;
  return 0;
}

/* Return -1, 0, 1 indicating the relative ordering of subspace1
   and subspace.  */

static int
compare_subspaces (arg1, arg2)
     const PTR arg1;
     const PTR arg2;

{
  asection **subspace1 = (asection **) arg1;
  asection **subspace2 = (asection **) arg2;

  if ((*subspace1)->target_index < (*subspace2)->target_index)
    return -1;
  else if ((*subspace2)->target_index < (*subspace1)->target_index)
    return 1;
  else
    return 0;
}

/* Perform various work in preparation for emitting the fixup stream.  */

static void
som_prep_for_fixups (abfd, syms, num_syms)
     bfd *abfd;
     asymbol **syms;
     unsigned long num_syms;
{
  unsigned long i;
  asection *section;
  asymbol **sorted_syms;
  bfd_size_type amt;

  /* Most SOM relocations involving a symbol have a length which is
     dependent on the index of the symbol.  So symbols which are
     used often in relocations should have a small index.  */

  /* First initialize the counters for each symbol.  */
  for (i = 0; i < num_syms; i++)
    {
      /* Handle a section symbol; these have no pointers back to the
	 SOM symbol info.  So we just use the udata field to hold the
	 relocation count.  */
      if (som_symbol_data (syms[i]) == NULL
	  || syms[i]->flags & BSF_SECTION_SYM)
	{
	  syms[i]->flags |= BSF_SECTION_SYM;
	  syms[i]->udata.i = 0;
	}
      else
	som_symbol_data (syms[i])->reloc_count = 0;
    }

  /* Now that the counters are initialized, make a weighted count
     of how often a given symbol is used in a relocation.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      int j;

      /* Does this section have any relocations?  */
      if ((int) section->reloc_count <= 0)
	continue;

      /* Walk through each relocation for this section.  */
      for (j = 1; j < (int) section->reloc_count; j++)
	{
	  arelent *reloc = section->orelocation[j];
	  int scale;

	  /* A relocation against a symbol in the *ABS* section really
	     does not have a symbol.  Likewise if the symbol isn't associated
	     with any section.  */
	  if (reloc->sym_ptr_ptr == NULL
	      || bfd_is_abs_section ((*reloc->sym_ptr_ptr)->section))
	    continue;

	  /* Scaling to encourage symbols involved in R_DP_RELATIVE
	     and R_CODE_ONE_SYMBOL relocations to come first.  These
	     two relocations have single byte versions if the symbol
	     index is very small.  */
	  if (reloc->howto->type == R_DP_RELATIVE
	      || reloc->howto->type == R_CODE_ONE_SYMBOL)
	    scale = 2;
	  else
	    scale = 1;

	  /* Handle section symbols by storing the count in the udata
	     field.  It will not be used and the count is very important
	     for these symbols.  */
	  if ((*reloc->sym_ptr_ptr)->flags & BSF_SECTION_SYM)
	    {
	      (*reloc->sym_ptr_ptr)->udata.i =
		(*reloc->sym_ptr_ptr)->udata.i + scale;
	      continue;
	    }

	  /* A normal symbol.  Increment the count.  */
	  som_symbol_data (*reloc->sym_ptr_ptr)->reloc_count += scale;
	}
    }

  /* Sort a copy of the symbol table, rather than the canonical
     output symbol table.  */
  amt = num_syms;
  amt *= sizeof (asymbol *);
  sorted_syms = (asymbol **) bfd_zalloc (abfd, amt);
  memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));
  qsort (sorted_syms, num_syms, sizeof (asymbol *), compare_syms);
  obj_som_sorted_syms (abfd) = sorted_syms;

  /* Compute the symbol indexes, they will be needed by the relocation
     code.  */
  for (i = 0; i < num_syms; i++)
    {
      /* A section symbol.  Again, there is no pointer to backend symbol
	 information, so we reuse the udata field again.  */
      if (sorted_syms[i]->flags & BSF_SECTION_SYM)
	sorted_syms[i]->udata.i = i;
      else
	som_symbol_data (sorted_syms[i])->index = i;
    }
}

static bfd_boolean
som_write_fixups (abfd, current_offset, total_reloc_sizep)
     bfd *abfd;
     unsigned long current_offset;
     unsigned int *total_reloc_sizep;
{
  unsigned int i, j;
  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
  unsigned int total_reloc_size = 0;
  unsigned int subspace_reloc_size = 0;
  unsigned int num_spaces = obj_som_file_hdr (abfd)->space_total;
  asection *section = abfd->sections;
  bfd_size_type amt;

  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

  /* All the fixups for a particular subspace are emitted in a single
     stream.  All the subspaces for a particular space are emitted
     as a single stream.

     So, to get all the locations correct one must iterate through all the
     spaces, for each space iterate through its subspaces and output a
     fixups stream.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now iterate through each of its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{
	  int reloc_offset;
	  unsigned int current_rounding_mode;
#ifndef NO_PCREL_MODES
	  int current_call_mode;
#endif

	  /* Find a subspace of this space.  */
	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection))
	    continue;

	  /* If this subspace does not have real data, then we are
	     finished with it.  */
	  if ((subsection->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      som_section_data (subsection)->subspace_dict->fixup_request_index
		= -1;
	      continue;
	    }

	  /* This subspace has some relocations.  Put the relocation stream
	     index into the subspace record.  */
	  som_section_data (subsection)->subspace_dict->fixup_request_index
	    = total_reloc_size;

	  /* To make life easier start over with a clean slate for
	     each subspace.  Seek to the start of the relocation stream
	     for this subspace in preparation for writing out its fixup
	     stream.  */
	  if (bfd_seek (abfd, current_offset + total_reloc_size, SEEK_SET) != 0)
	    return FALSE;

	  /* Buffer space has already been allocated.  Just perform some
	     initialization here.  */
	  p = tmp_space;
	  subspace_reloc_size = 0;
	  reloc_offset = 0;
	  som_initialize_reloc_queue (reloc_queue);
	  current_rounding_mode = R_N_MODE;
#ifndef NO_PCREL_MODES
	  current_call_mode = R_SHORT_PCREL_MODE;
#endif

	  /* Translate each BFD relocation into one or more SOM
	     relocations.  */
	  for (j = 0; j < subsection->reloc_count; j++)
	    {
	      arelent *bfd_reloc = subsection->orelocation[j];
	      unsigned int skip;
	      int sym_num;

	      /* Get the symbol number.  Remember it's stored in a
		 special place for section symbols.  */
	      if ((*bfd_reloc->sym_ptr_ptr)->flags & BSF_SECTION_SYM)
		sym_num = (*bfd_reloc->sym_ptr_ptr)->udata.i;
	      else
		sym_num = som_symbol_data (*bfd_reloc->sym_ptr_ptr)->index;

	      /* If there is not enough room for the next couple relocations,
		 then dump the current buffer contents now.  Also reinitialize
		 the relocation queue.

		 No single BFD relocation could ever translate into more
		 than 100 bytes of SOM relocations (20bytes is probably the
		 upper limit, but leave lots of space for growth).  */
	      if (p - tmp_space + 100 > SOM_TMP_BUFSIZE)
		{
		  amt = p - tmp_space;
		  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
		    return FALSE;

		  p = tmp_space;
		  som_initialize_reloc_queue (reloc_queue);
		}

	      /* Emit R_NO_RELOCATION fixups to map any bytes which were
		 skipped.  */
	      skip = bfd_reloc->address - reloc_offset;
	      p = som_reloc_skip (abfd, skip, p,
				  &subspace_reloc_size, reloc_queue);

	      /* Update reloc_offset for the next iteration.

		 Many relocations do not consume input bytes.  They
		 are markers, or set state necessary to perform some
		 later relocation.  */
	      switch (bfd_reloc->howto->type)
		{
		case R_ENTRY:
		case R_ALT_ENTRY:
		case R_EXIT:
		case R_N_MODE:
		case R_S_MODE:
		case R_D_MODE:
		case R_R_MODE:
		case R_FSEL:
		case R_LSEL:
		case R_RSEL:
		case R_COMP1:
		case R_COMP2:
		case R_BEGIN_BRTAB:
		case R_END_BRTAB:
		case R_BEGIN_TRY:
		case R_END_TRY:
		case R_N0SEL:
		case R_N1SEL:
#ifndef NO_PCREL_MODES
		case R_SHORT_PCREL_MODE:
		case R_LONG_PCREL_MODE:
#endif
		  reloc_offset = bfd_reloc->address;
		  break;

		default:
		  reloc_offset = bfd_reloc->address + 4;
		  break;
		}

	      /* Now the actual relocation we care about.  */
	      switch (bfd_reloc->howto->type)
		{
		case R_PCREL_CALL:
		case R_ABS_CALL:
		  p = som_reloc_call (abfd, p, &subspace_reloc_size,
				      bfd_reloc, sym_num, reloc_queue);
		  break;

		case R_CODE_ONE_SYMBOL:
		case R_DP_RELATIVE:
		  /* Account for any addend.  */
		  if (bfd_reloc->addend)
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
					  &subspace_reloc_size, reloc_queue);

		  if (sym_num < 0x20)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + sym_num, p);
		      subspace_reloc_size += 1;
		      p += 1;
		    }
		  else if (sym_num < 0x100)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 32, p);
		      bfd_put_8 (abfd, sym_num, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size, p,
					  2, reloc_queue);
		    }
		  else if (sym_num < 0x10000000)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 33, p);
		      bfd_put_8 (abfd, sym_num >> 16, p + 1);
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  else
		    abort ();
		  break;

		case R_DATA_ONE_SYMBOL:
		case R_DATA_PLABEL:
		case R_CODE_PLABEL:
		case R_DLT_REL:
		  /* Account for any addend using R_DATA_OVERRIDE.  */
		  if (bfd_reloc->howto->type != R_DATA_ONE_SYMBOL
		      && bfd_reloc->addend)
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
					  &subspace_reloc_size, reloc_queue);

		  if (sym_num < 0x100)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      bfd_put_8 (abfd, sym_num, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size, p,
					  2, reloc_queue);
		    }
		  else if (sym_num < 0x10000000)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 1, p);
		      bfd_put_8 (abfd, sym_num >> 16, p + 1);
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  else
		    abort ();
		  break;

		case R_ENTRY:
		  {
		    unsigned int tmp;
		    arelent *tmp_reloc = NULL;
		    bfd_put_8 (abfd, R_ENTRY, p);

		    /* R_ENTRY relocations have 64 bits of associated
		       data.  Unfortunately the addend field of a bfd
		       relocation is only 32 bits.  So, we split up
		       the 64bit unwind information and store part in
		       the R_ENTRY relocation, and the rest in the R_EXIT
		       relocation.  */
		    bfd_put_32 (abfd, bfd_reloc->addend, p + 1);

		    /* Find the next R_EXIT relocation.  */
		    for (tmp = j; tmp < subsection->reloc_count; tmp++)
		      {
			tmp_reloc = subsection->orelocation[tmp];
			if (tmp_reloc->howto->type == R_EXIT)
			  break;
		      }

		    if (tmp == subsection->reloc_count)
		      abort ();

		    bfd_put_32 (abfd, tmp_reloc->addend, p + 5);
		    p = try_prev_fixup (abfd, &subspace_reloc_size,
					p, 9, reloc_queue);
		    break;
		  }

		case R_N_MODE:
		case R_S_MODE:
		case R_D_MODE:
		case R_R_MODE:
		  /* If this relocation requests the current rounding
		     mode, then it is redundant.  */
		  if (bfd_reloc->howto->type != current_rounding_mode)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      subspace_reloc_size += 1;
		      p += 1;
		      current_rounding_mode = bfd_reloc->howto->type;
		    }
		  break;

#ifndef NO_PCREL_MODES
		case R_LONG_PCREL_MODE:
		case R_SHORT_PCREL_MODE:
		  if (bfd_reloc->howto->type != current_call_mode)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      subspace_reloc_size += 1;
		      p += 1;
		      current_call_mode = bfd_reloc->howto->type;
		    }
		  break;
#endif

		case R_EXIT:
		case R_ALT_ENTRY:
		case R_FSEL:
		case R_LSEL:
		case R_RSEL:
		case R_BEGIN_BRTAB:
		case R_END_BRTAB:
		case R_BEGIN_TRY:
		case R_N0SEL:
		case R_N1SEL:
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;

		case R_END_TRY:
		  /* The end of an exception handling region.  The reloc's
		     addend contains the offset of the exception handling
		     code.  */
		  if (bfd_reloc->addend == 0)
		    bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  else if (bfd_reloc->addend < 1024)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 1, p);
		      bfd_put_8 (abfd, bfd_reloc->addend / 4, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 2, reloc_queue);
		    }
		  else
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 2, p);
		      bfd_put_8 (abfd, (bfd_reloc->addend / 4) >> 16, p + 1);
		      bfd_put_16 (abfd, bfd_reloc->addend / 4, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  break;

		case R_COMP1:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  bfd_put_8 (abfd, 0x44, p + 1);
		  p = try_prev_fixup (abfd, &subspace_reloc_size,
				      p, 2, reloc_queue);
		  break;

		case R_COMP2:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  bfd_put_8 (abfd, 0x80, p + 1);
		  bfd_put_8 (abfd, sym_num >> 16, p + 2);
		  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
		  p = try_prev_fixup (abfd, &subspace_reloc_size,
				      p, 5, reloc_queue);
		  break;

		case R_CODE_EXPR:
		case R_DATA_EXPR:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;

		/* Put a "R_RESERVED" relocation in the stream if
		   we hit something we do not understand.  The linker
		   will complain loudly if this ever happens.  */
		default:
		  bfd_put_8 (abfd, 0xff, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;
		}
	    }

	  /* Last BFD relocation for a subspace has been processed.
	     Map the rest of the subspace with R_NO_RELOCATION fixups.  */
	  p = som_reloc_skip (abfd, (bfd_section_size (abfd, subsection)
				     - reloc_offset),
			      p, &subspace_reloc_size, reloc_queue);

	  /* Scribble out the relocations.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
	    return FALSE;
	  p = tmp_space;

	  total_reloc_size += subspace_reloc_size;
	  som_section_data (subsection)->subspace_dict->fixup_request_quantity
	    = subspace_reloc_size;
	}
      section = section->next;
    }
  *total_reloc_sizep = total_reloc_size;
  return TRUE;
}

/* Write out the space/subspace string table.  */

static bfd_boolean
som_write_space_strings (abfd, current_offset, string_sizep)
     bfd *abfd;
     unsigned long current_offset;
     unsigned int *string_sizep;
{
  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;
  unsigned int strings_size = 0;
  asection *section;
  bfd_size_type amt;

  /* Seek to the start of the space strings in preparation for writing
     them out.  */
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;

  /* Walk through all the spaces and subspaces (order is not important)
     building up and writing string table entries for their names.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      size_t length;

      /* Only work with space/subspaces; avoid any other sections
	 which might have been made (.text for example).  */
      if (!som_is_space (section) && !som_is_subspace (section))
	continue;

      /* Get the length of the space/subspace name.  */
      length = strlen (section->name);

      /* If there is not enough room for the next entry, then dump the
	 current buffer contents now and maybe allocate a larger
	 buffer.  Each entry will take 4 bytes to hold the string
	 length + the string itself + null terminator.  */
      if (p - tmp_space + 5 + length > tmp_space_size)
	{
	  /* Flush buffer before refilling or reallocating.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* Ensure a minimum growth factor to avoid O(n**2) space
		 consumption for n strings.  The optimal minimum
		 factor seems to be 2, as no other value can guarantee
		 wasting less than 50% space.  (Note that we cannot
		 deallocate space allocated by `alloca' without
		 returning from this function.)  The same technique is
		 used a few more times below when a buffer is
		 reallocated.  */
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
	  p = tmp_space;
	}

      /* First element in a string table entry is the length of the
	 string.  Alignment issues are already handled.  */
      bfd_put_32 (abfd, (bfd_vma) length, p);
      p += 4;
      strings_size += 4;

      /* Record the index in the space/subspace records.  */
      if (som_is_space (section))
	som_section_data (section)->space_dict->name.n_strx = strings_size;
      else
	som_section_data (section)->subspace_dict->name.n_strx = strings_size;

      /* Next comes the string itself + a null terminator.  */
      strcpy (p, section->name);
      p += length + 1;
      strings_size += length + 1;

      /* Always align up to the next word boundary.  */
      while (strings_size % 4)
	{
	  bfd_put_8 (abfd, 0, p);
	  p++;
	  strings_size++;
	}
    }

  /* Done with the space/subspace strings.  Write out any information
     contained in a partial block.  */
  amt = p - tmp_space;
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
    return FALSE;
  *string_sizep = strings_size;
  return TRUE;
}

/* Write out the symbol string table.  */

static bfd_boolean
som_write_symbol_strings (abfd, current_offset, syms, num_syms, string_sizep,
			  compilation_unit)
     bfd *abfd;
     unsigned long current_offset;
     asymbol **syms;
     unsigned int num_syms;
     unsigned int *string_sizep;
     COMPUNIT *compilation_unit;
{
  unsigned int i;

  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;

  unsigned int strings_size = 0;
  unsigned char *comp[4];
  bfd_size_type amt;

  /* This gets a bit gruesome because of the compilation unit.  The
     strings within the compilation unit are part of the symbol
     strings, but don't have symbol_dictionary entries.  So, manually
     write them and update the compilation unit header.  On input, the
     compilation unit header contains local copies of the strings.
     Move them aside.  */
  if (compilation_unit)
    {
      comp[0] = compilation_unit->name.n_name;
      comp[1] = compilation_unit->language_name.n_name;
      comp[2] = compilation_unit->product_id.n_name;
      comp[3] = compilation_unit->version_id.n_name;
    }

  /* Seek to the start of the space strings in preparation for writing
     them out.  */
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;

  if (compilation_unit)
    {
      for (i = 0; i < 4; i++)
	{
	  size_t length = strlen (comp[i]);

	  /* If there is not enough room for the next entry, then dump
	     the current buffer contents now and maybe allocate a
	     larger buffer.  */
	  if (p - tmp_space + 5 + length > tmp_space_size)
	    {
	      /* Flush buffer before refilling or reallocating.  */
	      amt = p - tmp_space;
	      if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
		return FALSE;

	      /* Reallocate if now empty buffer still too small.  */
	      if (5 + length > tmp_space_size)
		{
		  /* See alloca above for discussion of new size.  */
		  tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
		  tmp_space = alloca (tmp_space_size);
		}

	      /* Reset to beginning of the (possibly new) buffer
		 space.  */
	      p = tmp_space;
	    }

	  /* First element in a string table entry is the length of
	     the string.  This must always be 4 byte aligned.  This is
	     also an appropriate time to fill in the string index
	     field in the symbol table entry.  */
	  bfd_put_32 (abfd, (bfd_vma) length, p);
	  strings_size += 4;
	  p += 4;

	  /* Next comes the string itself + a null terminator.  */
	  strcpy (p, comp[i]);

	  switch (i)
	    {
	    case 0:
	      obj_som_compilation_unit (abfd)->name.n_strx = strings_size;
	      break;
	    case 1:
	      obj_som_compilation_unit (abfd)->language_name.n_strx =
		strings_size;
	      break;
	    case 2:
	      obj_som_compilation_unit (abfd)->product_id.n_strx =
		strings_size;
	      break;
	    case 3:
	      obj_som_compilation_unit (abfd)->version_id.n_strx =
		strings_size;
	      break;
	    }

	  p += length + 1;
	  strings_size += length + 1;

	  /* Always align up to the next word boundary.  */
	  while (strings_size % 4)
	    {
	      bfd_put_8 (abfd, 0, p);
	      strings_size++;
	      p++;
	    }
	}
    }

  for (i = 0; i < num_syms; i++)
    {
      size_t length = strlen (syms[i]->name);

      /* If there is not enough room for the next entry, then dump the
	 current buffer contents now and maybe allocate a larger buffer.  */
     if (p - tmp_space + 5 + length > tmp_space_size)
	{
	  /* Flush buffer before refilling or reallocating.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* See alloca above for discussion of new size.  */
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
	  p = tmp_space;
	}

      /* First element in a string table entry is the length of the
	 string.  This must always be 4 byte aligned.  This is also
	 an appropriate time to fill in the string index field in the
	 symbol table entry.  */
      bfd_put_32 (abfd, (bfd_vma) length, p);
      strings_size += 4;
      p += 4;

      /* Next comes the string itself + a null terminator.  */
      strcpy (p, syms[i]->name);

      som_symbol_data (syms[i])->stringtab_offset = strings_size;
      p += length + 1;
      strings_size += length + 1;

      /* Always align up to the next word boundary.  */
      while (strings_size % 4)
	{
	  bfd_put_8 (abfd, 0, p);
	  strings_size++;
	  p++;
	}
    }

  /* Scribble out any partial block.  */
  amt = p - tmp_space;
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
    return FALSE;

  *string_sizep = strings_size;
  return TRUE;
}

/* Compute variable information to be placed in the SOM headers,
   space/subspace dictionaries, relocation streams, etc.  Begin
   writing parts of the object file.  */

static bfd_boolean
som_begin_writing (abfd)
     bfd *abfd;
{
  unsigned long current_offset = 0;
  int strings_size = 0;
  unsigned long num_spaces, num_subspaces, i;
  asection *section;
  unsigned int total_subspaces = 0;
  struct som_exec_auxhdr *exec_header = NULL;

  /* The file header will always be first in an object file,
     everything else can be in random locations.  To keep things
     "simple" BFD will lay out the object file in the manner suggested
     by the PRO ABI for PA-RISC Systems.  */

  /* Before any output can really begin offsets for all the major
     portions of the object file must be computed.  So, starting
     with the initial file header compute (and sometimes write)
     each portion of the object file.  */

  /* Make room for the file header, it's contents are not complete
     yet, so it can not be written at this time.  */
  current_offset += sizeof (struct header);

  /* Any auxiliary headers will follow the file header.  Right now
     we support only the copyright and version headers.  */
  obj_som_file_hdr (abfd)->aux_header_location = current_offset;
  obj_som_file_hdr (abfd)->aux_header_size = 0;
  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      /* Parts of the exec header will be filled in later, so
	 delay writing the header itself.  Fill in the defaults,
	 and write it later.  */
      current_offset += sizeof (struct som_exec_auxhdr);
      obj_som_file_hdr (abfd)->aux_header_size
	+= sizeof (struct som_exec_auxhdr);
      exec_header = obj_som_exec_hdr (abfd);
      exec_header->som_auxhdr.type = EXEC_AUX_ID;
      exec_header->som_auxhdr.length = 40;
    }
  if (obj_som_version_hdr (abfd) != NULL)
    {
      bfd_size_type len;

      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;

      /* Write the aux_id structure and the string length.  */
      len = sizeof (struct aux_id) + sizeof (unsigned int);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd), len, abfd) != len)
	return FALSE;

      /* Write the version string.  */
      len = obj_som_version_hdr (abfd)->header_id.length - sizeof (int);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd)->user_string, len, abfd)
	  != len)
	return FALSE;
    }

  if (obj_som_copyright_hdr (abfd) != NULL)
    {
      bfd_size_type len;

      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;

      /* Write the aux_id structure and the string length.  */
      len = sizeof (struct aux_id) + sizeof (unsigned int);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd), len, abfd) != len)
	return FALSE;

      /* Write the copyright string.  */
      len = obj_som_copyright_hdr (abfd)->header_id.length - sizeof (int);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd)->copyright, len, abfd)
	  != len)
	return FALSE;
    }

  /* Next comes the initialization pointers; we have no initialization
     pointers, so current offset does not change.  */
  obj_som_file_hdr (abfd)->init_array_location = current_offset;
  obj_som_file_hdr (abfd)->init_array_total = 0;

  /* Next are the space records.  These are fixed length records.

     Count the number of spaces to determine how much room is needed
     in the object file for the space records.

     The names of the spaces are stored in a separate string table,
     and the index for each space into the string table is computed
     below.  Therefore, it is not possible to write the space headers
     at this time.  */
  num_spaces = som_count_spaces (abfd);
  obj_som_file_hdr (abfd)->space_location = current_offset;
  obj_som_file_hdr (abfd)->space_total = num_spaces;
  current_offset += num_spaces * sizeof (struct space_dictionary_record);

  /* Next are the subspace records.  These are fixed length records.

     Count the number of subspaes to determine how much room is needed
     in the object file for the subspace records.

     A variety if fields in the subspace record are still unknown at
     this time (index into string table, fixup stream location/size, etc).  */
  num_subspaces = som_count_subspaces (abfd);
  obj_som_file_hdr (abfd)->subspace_location = current_offset;
  obj_som_file_hdr (abfd)->subspace_total = num_subspaces;
  current_offset += num_subspaces * sizeof (struct subspace_dictionary_record);

  /* Next is the string table for the space/subspace names.  We will
     build and write the string table on the fly.  At the same time
     we will fill in the space/subspace name index fields.  */

  /* The string table needs to be aligned on a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));

  /* Mark the offset of the space/subspace string table in the
     file header.  */
  obj_som_file_hdr (abfd)->space_strings_location = current_offset;

  /* Scribble out the space strings.  */
  if (! som_write_space_strings (abfd, current_offset, &strings_size))
    return FALSE;

  /* Record total string table size in the header and update the
     current offset.  */
  obj_som_file_hdr (abfd)->space_strings_size = strings_size;
  current_offset += strings_size;

  /* Next is the compilation unit.  */
  obj_som_file_hdr (abfd)->compiler_location = current_offset;
  obj_som_file_hdr (abfd)->compiler_total = 0;
  if (obj_som_compilation_unit (abfd))
    {
      obj_som_file_hdr (abfd)->compiler_total = 1;
      current_offset += COMPUNITSZ;
    }

  /* Now compute the file positions for the loadable subspaces, taking
     care to make sure everything stays properly aligned.  */

  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;
      int first_subspace;
      unsigned int subspace_offset = 0;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      first_subspace = 1;
      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) == 0)
	    continue;

	  /* If this is the first subspace in the space, and we are
	     building an executable, then take care to make sure all
	     the alignments are correct and update the exec header.  */
	  if (first_subspace
	      && (abfd->flags & (EXEC_P | DYNAMIC)))
	    {
	      /* Demand paged executables have each space aligned to a
		 page boundary.  Sharable executables (write-protected
		 text) have just the private (aka data & bss) space aligned
		 to a page boundary.  Ugh.  Not true for HPUX.

		 The HPUX kernel requires the text to always be page aligned
		 within the file regardless of the executable's type.  */
	      if (abfd->flags & (D_PAGED | DYNAMIC)
		  || (subsection->flags & SEC_CODE)
		  || ((abfd->flags & WP_TEXT)
		      && (subsection->flags & SEC_DATA)))
		current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

	      /* Update the exec header.  */
	      if (subsection->flags & SEC_CODE && exec_header->exec_tfile == 0)
		{
		  exec_header->exec_tmem = section->vma;
		  exec_header->exec_tfile = current_offset;
		}
	      if (subsection->flags & SEC_DATA && exec_header->exec_dfile == 0)
		{
		  exec_header->exec_dmem = section->vma;
		  exec_header->exec_dfile = current_offset;
		}

	      /* Keep track of exactly where we are within a particular
		 space.  This is necessary as the braindamaged HPUX
		 loader will create holes between subspaces *and*
		 subspace alignments are *NOT* preserved.  What a crock.  */
	      subspace_offset = subsection->vma;

	      /* Only do this for the first subspace within each space.  */
	      first_subspace = 0;
	    }
	  else if (abfd->flags & (EXEC_P | DYNAMIC))
	    {
	      /* The braindamaged HPUX loader may have created a hole
		 between two subspaces.  It is *not* sufficient to use
		 the alignment specifications within the subspaces to
		 account for these holes -- I've run into at least one
		 case where the loader left one code subspace unaligned
		 in a final executable.

		 To combat this we keep a current offset within each space,
		 and use the subspace vma fields to detect and preserve
		 holes.  What a crock!

		 ps.  This is not necessary for unloadable space/subspaces.  */
	      current_offset += subsection->vma - subspace_offset;
	      if (subsection->flags & SEC_CODE)
		exec_header->exec_tsize += subsection->vma - subspace_offset;
	      else
		exec_header->exec_dsize += subsection->vma - subspace_offset;
	      subspace_offset += subsection->vma - subspace_offset;
	    }

	  subsection->target_index = total_subspaces++;
	  /* This is real data to be loaded from the file.  */
	  if (subsection->flags & SEC_LOAD)
	    {
	      /* Update the size of the code & data.  */
	      if (abfd->flags & (EXEC_P | DYNAMIC)
		  && subsection->flags & SEC_CODE)
		exec_header->exec_tsize += subsection->_cooked_size;
	      else if (abfd->flags & (EXEC_P | DYNAMIC)
		       && subsection->flags & SEC_DATA)
		exec_header->exec_dsize += subsection->_cooked_size;
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= current_offset;
	      subsection->filepos = current_offset;
	      current_offset += bfd_section_size (abfd, subsection);
	      subspace_offset += bfd_section_size (abfd, subsection);
	    }
	  /* Looks like uninitialized data.  */
	  else
	    {
	      /* Update the size of the bss section.  */
	      if (abfd->flags & (EXEC_P | DYNAMIC))
		exec_header->exec_bsize += subsection->_cooked_size;

	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= 0;
	      som_section_data (subsection)->subspace_dict->
		initialization_length = 0;
	    }
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* Finally compute the file positions for unloadable subspaces.
     If building an executable, start the unloadable stuff on its
     own page.  */

  if (abfd->flags & (EXEC_P | DYNAMIC))
    current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

  obj_som_file_hdr (abfd)->unloadable_sp_location = current_offset;
  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      if (abfd->flags & (EXEC_P | DYNAMIC))
	current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) != 0)
	    continue;

	  subsection->target_index = total_subspaces++;
	  /* This is real data to be loaded from the file.  */
	  if ((subsection->flags & SEC_LOAD) == 0)
	    {
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= current_offset;
	      subsection->filepos = current_offset;
	      current_offset += bfd_section_size (abfd, subsection);
	    }
	  /* Looks like uninitialized data.  */
	  else
	    {
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= 0;
	      som_section_data (subsection)->subspace_dict->
		initialization_length = bfd_section_size (abfd, subsection);
	    }
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* If building an executable, then make sure to seek to and write
     one byte at the end of the file to make sure any necessary
     zeros are filled in.  Ugh.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);
  if (bfd_seek (abfd, (file_ptr) current_offset - 1, SEEK_SET) != 0)
    return FALSE;
  if (bfd_bwrite ((PTR) "", (bfd_size_type) 1, abfd) != 1)
    return FALSE;

  obj_som_file_hdr (abfd)->unloadable_sp_size
    = current_offset - obj_som_file_hdr (abfd)->unloadable_sp_location;

  /* Loader fixups are not supported in any way shape or form.  */
  obj_som_file_hdr (abfd)->loader_fixup_location = 0;
  obj_som_file_hdr (abfd)->loader_fixup_total = 0;

  /* Done.  Store the total size of the SOM so far.  */
  obj_som_file_hdr (abfd)->som_length = current_offset;

  return TRUE;
}

/* Finally, scribble out the various headers to the disk.  */

static bfd_boolean
som_finish_writing (abfd)
     bfd *abfd;
{
  int num_spaces = som_count_spaces (abfd);
  asymbol **syms = bfd_get_outsymbols (abfd);
  int i, num_syms, strings_size;
  int subspace_index = 0;
  file_ptr location;
  asection *section;
  unsigned long current_offset;
  unsigned int total_reloc_size;
  bfd_size_type amt;

  /* We must set up the version identifier here as objcopy/strip copy
     private BFD data too late for us to handle this in som_begin_writing.  */
  if (obj_som_exec_data (abfd)
      && obj_som_exec_data (abfd)->version_id)
    obj_som_file_hdr (abfd)->version_id = obj_som_exec_data (abfd)->version_id;
  else
    obj_som_file_hdr (abfd)->version_id = NEW_VERSION_ID;

  /* Next is the symbol table.  These are fixed length records.

     Count the number of symbols to determine how much room is needed
     in the object file for the symbol table.

     The names of the symbols are stored in a separate string table,
     and the index for each symbol name into the string table is computed
     below.  Therefore, it is not possible to write the symbol table
     at this time.

     These used to be output before the subspace contents, but they
     were moved here to work around a stupid bug in the hpux linker
     (fixed in hpux10).  */
  current_offset = obj_som_file_hdr (abfd)->som_length;

  /* Make sure we're on a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));

  num_syms = bfd_get_symcount (abfd);
  obj_som_file_hdr (abfd)->symbol_location = current_offset;
  obj_som_file_hdr (abfd)->symbol_total = num_syms;
  current_offset += num_syms * sizeof (struct symbol_dictionary_record);

  /* Next are the symbol strings.
     Align them to a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));
  obj_som_file_hdr (abfd)->symbol_strings_location = current_offset;

  /* Scribble out the symbol strings.  */
  if (! som_write_symbol_strings (abfd, current_offset, syms,
				  num_syms, &strings_size,
				  obj_som_compilation_unit (abfd)))
    return FALSE;

  /* Record total string table size in header and update the
     current offset.  */
  obj_som_file_hdr (abfd)->symbol_strings_size = strings_size;
  current_offset += strings_size;

  /* Do prep work before handling fixups.  */
  som_prep_for_fixups (abfd,
		       bfd_get_outsymbols (abfd),
		       bfd_get_symcount (abfd));

  /* At the end of the file is the fixup stream which starts on a
     word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));
  obj_som_file_hdr (abfd)->fixup_request_location = current_offset;

  /* Write the fixups and update fields in subspace headers which
     relate to the fixup stream.  */
  if (! som_write_fixups (abfd, current_offset, &total_reloc_size))
    return FALSE;

  /* Record the total size of the fixup stream in the file header.  */
  obj_som_file_hdr (abfd)->fixup_request_total = total_reloc_size;

  /* Done.  Store the total size of the SOM.  */
  obj_som_file_hdr (abfd)->som_length = current_offset + total_reloc_size;

  /* Now that the symbol table information is complete, build and
     write the symbol table.  */
  if (! som_build_and_write_symbol_table (abfd))
    return FALSE;

  /* Subspaces are written first so that we can set up information
     about them in their containing spaces as the subspace is written.  */

  /* Seek to the start of the subspace dictionary records.  */
  location = obj_som_file_hdr (abfd)->subspace_location;
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;

  section = abfd->sections;
  /* Now for each loadable space write out records for its subspaces.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  /* Skip any section which does not correspond to a space
	     or subspace.  Or does not have SEC_ALLOC set (and therefore
	     has no real bits on the disk).  */
	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) == 0)
	    continue;

	  /* If this is the first subspace for this space, then save
	     the index of the subspace in its containing space.  Also
	     set "is_loadable" in the containing space.  */

	  if (som_section_data (section)->space_dict->subspace_quantity == 0)
	    {
	      som_section_data (section)->space_dict->is_loadable = 1;
	      som_section_data (section)->space_dict->subspace_index
		= subspace_index;
	    }

	  /* Increment the number of subspaces seen and the number of
	     subspaces contained within the current space.  */
	  subspace_index++;
	  som_section_data (section)->space_dict->subspace_quantity++;

	  /* Mark the index of the current space within the subspace's
	     dictionary record.  */
	  som_section_data (subsection)->subspace_dict->space_index = i;

	  /* Dump the current subspace header.  */
	  amt = sizeof (struct subspace_dictionary_record);
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
	    return FALSE;
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* Now repeat the process for unloadable subspaces.  */
  section = abfd->sections;
  /* Now for each space write out records for its subspaces.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  /* Skip any section which does not correspond to a space or
	     subspace, or which SEC_ALLOC set (and therefore handled
	     in the loadable spaces/subspaces code above).  */

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) != 0)
	    continue;

	  /* If this is the first subspace for this space, then save
	     the index of the subspace in its containing space.  Clear
	     "is_loadable".  */

	  if (som_section_data (section)->space_dict->subspace_quantity == 0)
	    {
	      som_section_data (section)->space_dict->is_loadable = 0;
	      som_section_data (section)->space_dict->subspace_index
		= subspace_index;
	    }

	  /* Increment the number of subspaces seen and the number of
	     subspaces contained within the current space.  */
	  som_section_data (section)->space_dict->subspace_quantity++;
	  subspace_index++;

	  /* Mark the index of the current space within the subspace's
	     dictionary record.  */
	  som_section_data (subsection)->subspace_dict->space_index = i;

	  /* Dump this subspace header.  */
	  amt = sizeof (struct subspace_dictionary_record);
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
	    return FALSE;
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* All the subspace dictionary records are written, and all the
     fields are set up in the space dictionary records.

     Seek to the right location and start writing the space
     dictionary records.  */
  location = obj_som_file_hdr (abfd)->space_location;
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;

  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Dump its header.  */
      amt = sizeof (struct space_dictionary_record);
      if (bfd_bwrite ((PTR) som_section_data (section)->space_dict,
		     amt, abfd) != amt)
	return FALSE;

      /* Goto the next section.  */
      section = section->next;
    }

  /* Write the compilation unit record if there is one.  */
  if (obj_som_compilation_unit (abfd))
    {
      location = obj_som_file_hdr (abfd)->compiler_location;
      if (bfd_seek (abfd, location, SEEK_SET) != 0)
	return FALSE;

      amt = COMPUNITSZ;
      if (bfd_bwrite ((PTR) obj_som_compilation_unit (abfd), amt, abfd) != amt)
	return FALSE;
    }

  /* Setting of the system_id has to happen very late now that copying of
     BFD private data happens *after* section contents are set.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    obj_som_file_hdr (abfd)->system_id = obj_som_exec_data (abfd)->system_id;
  else if (bfd_get_mach (abfd) == pa20)
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC2_0;
  else if (bfd_get_mach (abfd) == pa11)
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_1;
  else
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_0;

  /* Compute the checksum for the file header just before writing
     the header to disk.  */
  obj_som_file_hdr (abfd)->checksum = som_compute_checksum (abfd);

  /* Only thing left to do is write out the file header.  It is always
     at location zero.  Seek there and write it.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  amt = sizeof (struct header);
  if (bfd_bwrite ((PTR) obj_som_file_hdr (abfd), amt, abfd) != amt)
    return FALSE;

  /* Now write the exec header.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      long tmp, som_length;
      struct som_exec_auxhdr *exec_header;

      exec_header = obj_som_exec_hdr (abfd);
      exec_header->exec_entry = bfd_get_start_address (abfd);
      exec_header->exec_flags = obj_som_exec_data (abfd)->exec_flags;

      /* Oh joys.  Ram some of the BSS data into the DATA section
	 to be compatible with how the hp linker makes objects
	 (saves memory space).  */
      tmp = exec_header->exec_dsize;
      tmp = SOM_ALIGN (tmp, PA_PAGESIZE);
      exec_header->exec_bsize -= (tmp - exec_header->exec_dsize);
      if (exec_header->exec_bsize < 0)
	exec_header->exec_bsize = 0;
      exec_header->exec_dsize = tmp;

      /* Now perform some sanity checks.  The idea is to catch bogons now and
	 inform the user, instead of silently generating a bogus file.  */
      som_length = obj_som_file_hdr (abfd)->som_length;
      if (exec_header->exec_tfile + exec_header->exec_tsize > som_length
	  || exec_header->exec_dfile + exec_header->exec_dsize > som_length)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (bfd_seek (abfd, obj_som_file_hdr (abfd)->aux_header_location,
		    SEEK_SET) != 0)
	return FALSE;

      amt = AUX_HDR_SIZE;
      if (bfd_bwrite ((PTR) exec_header, amt, abfd) != amt)
	return FALSE;
    }
  return TRUE;
}

/* Compute and return the checksum for a SOM file header.  */

static unsigned long
som_compute_checksum (abfd)
     bfd *abfd;
{
  unsigned long checksum, count, i;
  unsigned long *buffer = (unsigned long *) obj_som_file_hdr (abfd);

  checksum = 0;
  count = sizeof (struct header) / sizeof (unsigned long);
  for (i = 0; i < count; i++)
    checksum ^= *(buffer + i);

  return checksum;
}

static void
som_bfd_derive_misc_symbol_info (abfd, sym, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
     struct som_misc_symbol_info *info;
{
  /* Initialize.  */
  memset (info, 0, sizeof (struct som_misc_symbol_info));

  /* The HP SOM linker requires detailed type information about
     all symbols (including undefined symbols!).  Unfortunately,
     the type specified in an import/export statement does not
     always match what the linker wants.  Severe braindamage.  */

  /* Section symbols will not have a SOM symbol type assigned to
     them yet.  Assign all section symbols type ST_DATA.  */
  if (sym->flags & BSF_SECTION_SYM)
    info->symbol_type = ST_DATA;
  else
    {
      /* Common symbols must have scope SS_UNSAT and type
	 ST_STORAGE or the linker will choke.  */
      if (bfd_is_com_section (sym->section))
	{
	  info->symbol_scope = SS_UNSAT;
	  info->symbol_type = ST_STORAGE;
	}

      /* It is possible to have a symbol without an associated
	 type.  This happens if the user imported the symbol
	 without a type and the symbol was never defined
	 locally.  If BSF_FUNCTION is set for this symbol, then
	 assign it type ST_CODE (the HP linker requires undefined
	 external functions to have type ST_CODE rather than ST_ENTRY).  */
      else if ((som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
		|| som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE)
	       && bfd_is_und_section (sym->section)
	       && sym->flags & BSF_FUNCTION)
	info->symbol_type = ST_CODE;

      /* Handle function symbols which were defined in this file.
	 They should have type ST_ENTRY.  Also retrieve the argument
	 relocation bits from the SOM backend information.  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_ENTRY
	       || (som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE
		   && (sym->flags & BSF_FUNCTION))
	       || (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
		   && (sym->flags & BSF_FUNCTION)))
	{
	  info->symbol_type = ST_ENTRY;
	  info->arg_reloc = som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc;
	  info->priv_level= som_symbol_data (sym)->tc_data.ap.hppa_priv_level;
	}

      /* For unknown symbols set the symbol's type based on the symbol's
	 section (ST_DATA for DATA sections, ST_CODE for CODE sections).  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN)
	{
	  if (sym->section->flags & SEC_CODE)
	    info->symbol_type = ST_CODE;
	  else
	    info->symbol_type = ST_DATA;
	}

      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN)
	info->symbol_type = ST_DATA;

      /* From now on it's a very simple mapping.  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_ABSOLUTE)
	info->symbol_type = ST_ABSOLUTE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE)
	info->symbol_type = ST_CODE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_DATA)
	info->symbol_type = ST_DATA;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_MILLICODE)
	info->symbol_type = ST_MILLICODE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_PLABEL)
	info->symbol_type = ST_PLABEL;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_PRI_PROG)
	info->symbol_type = ST_PRI_PROG;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_SEC_PROG)
	info->symbol_type = ST_SEC_PROG;
    }

  /* Now handle the symbol's scope.  Exported data which is not
     in the common section has scope SS_UNIVERSAL.  Note scope
     of common symbols was handled earlier!  */
  if (bfd_is_und_section (sym->section))
    info->symbol_scope = SS_UNSAT;
  else if (sym->flags & (BSF_EXPORT | BSF_WEAK)
	   && ! bfd_is_com_section (sym->section))
    info->symbol_scope = SS_UNIVERSAL;
  /* Anything else which is not in the common section has scope
     SS_LOCAL.  */
  else if (! bfd_is_com_section (sym->section))
    info->symbol_scope = SS_LOCAL;

  /* Now set the symbol_info field.  It has no real meaning
     for undefined or common symbols, but the HP linker will
     choke if it's not set to some "reasonable" value.  We
     use zero as a reasonable value.  */
  if (bfd_is_com_section (sym->section)
      || bfd_is_und_section (sym->section)
      || bfd_is_abs_section (sym->section))
    info->symbol_info = 0;
  /* For all other symbols, the symbol_info field contains the
     subspace index of the space this symbol is contained in.  */
  else
    info->symbol_info = sym->section->target_index;

  /* Set the symbol's value.  */
  info->symbol_value = sym->value + sym->section->vma;

  /* The secondary_def field is for weak symbols.  */
  if (sym->flags & BSF_WEAK)
    info->secondary_def = TRUE;
  else
    info->secondary_def = FALSE;

}

/* Build and write, in one big chunk, the entire symbol table for
   this BFD.  */

static bfd_boolean
som_build_and_write_symbol_table (abfd)
     bfd *abfd;
{
  unsigned int num_syms = bfd_get_symcount (abfd);
  file_ptr symtab_location = obj_som_file_hdr (abfd)->symbol_location;
  asymbol **bfd_syms = obj_som_sorted_syms (abfd);
  struct symbol_dictionary_record *som_symtab = NULL;
  unsigned int i;
  bfd_size_type symtab_size;

  /* Compute total symbol table size and allocate a chunk of memory
     to hold the symbol table as we build it.  */
  symtab_size = num_syms;
  symtab_size *= sizeof (struct symbol_dictionary_record);
  som_symtab = (struct symbol_dictionary_record *) bfd_zmalloc (symtab_size);
  if (som_symtab == NULL && symtab_size != 0)
    goto error_return;

  /* Walk over each symbol.  */
  for (i = 0; i < num_syms; i++)
    {
      struct som_misc_symbol_info info;

      /* This is really an index into the symbol strings table.
	 By the time we get here, the index has already been
	 computed and stored into the name field in the BFD symbol.  */
      som_symtab[i].name.n_strx = som_symbol_data(bfd_syms[i])->stringtab_offset;

      /* Derive SOM information from the BFD symbol.  */
      som_bfd_derive_misc_symbol_info (abfd, bfd_syms[i], &info);

      /* Now use it.  */
      som_symtab[i].symbol_type = info.symbol_type;
      som_symtab[i].symbol_scope = info.symbol_scope;
      som_symtab[i].arg_reloc = info.arg_reloc;
      som_symtab[i].symbol_info = info.symbol_info;
      som_symtab[i].xleast = 3;
      som_symtab[i].symbol_value = info.symbol_value | info.priv_level;
      som_symtab[i].secondary_def = info.secondary_def;
    }

  /* Everything is ready, seek to the right location and
     scribble out the symbol table.  */
  if (bfd_seek (abfd, symtab_location, SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite ((PTR) som_symtab, symtab_size, abfd) != symtab_size)
    goto error_return;

  if (som_symtab != NULL)
    free (som_symtab);
  return TRUE;
 error_return:
  if (som_symtab != NULL)
    free (som_symtab);
  return FALSE;
}

/* Write an object in SOM format.  */

static bfd_boolean
som_write_object_contents (abfd)
     bfd *abfd;
{
  if (! abfd->output_has_begun)
    {
      /* Set up fixed parts of the file, space, and subspace headers.
	 Notify the world that output has begun.  */
      som_prep_headers (abfd);
      abfd->output_has_begun = TRUE;
      /* Start writing the object file.  This include all the string
	 tables, fixup streams, and other portions of the object file.  */
      som_begin_writing (abfd);
    }

  return (som_finish_writing (abfd));
}

/* Read and save the string table associated with the given BFD.  */

static bfd_boolean
som_slurp_string_table (abfd)
     bfd *abfd;
{
  char *stringtab;
  bfd_size_type amt;

  /* Use the saved version if its available.  */
  if (obj_som_stringtab (abfd) != NULL)
    return TRUE;

  /* I don't think this can currently happen, and I'm not sure it should
     really be an error, but it's better than getting unpredictable results
     from the host's malloc when passed a size of zero.  */
  if (obj_som_stringtab_size (abfd) == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  /* Allocate and read in the string table.  */
  amt = obj_som_stringtab_size (abfd);
  stringtab = bfd_zmalloc (amt);
  if (stringtab == NULL)
    return FALSE;

  if (bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET) != 0)
    return FALSE;

  if (bfd_bread (stringtab, amt, abfd) != amt)
    return FALSE;

  /* Save our results and return success.  */
  obj_som_stringtab (abfd) = stringtab;
  return TRUE;
}

/* Return the amount of data (in bytes) required to hold the symbol
   table for this object.  */

static long
som_get_symtab_upper_bound (abfd)
     bfd *abfd;
{
  if (!som_slurp_symbol_table (abfd))
    return -1;

  return (bfd_get_symcount (abfd) + 1) * (sizeof (asymbol *));
}

/* Convert from a SOM subspace index to a BFD section.  */

static asection *
bfd_section_from_som_symbol (abfd, symbol)
     bfd *abfd;
     struct symbol_dictionary_record *symbol;
{
  asection *section;

  /* The meaning of the symbol_info field changes for functions
     within executables.  So only use the quick symbol_info mapping for
     incomplete objects and non-function symbols in executables.  */
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      || (symbol->symbol_type != ST_ENTRY
	  && symbol->symbol_type != ST_PRI_PROG
	  && symbol->symbol_type != ST_SEC_PROG
	  && symbol->symbol_type != ST_MILLICODE))
    {
      unsigned int index = symbol->symbol_info;
      for (section = abfd->sections; section != NULL; section = section->next)
	if (section->target_index == index && som_is_subspace (section))
	  return section;

      /* Could be a symbol from an external library (such as an OMOS
	 shared library).  Don't abort.  */
      return bfd_abs_section_ptr;

    }
  else
    {
      unsigned int value = symbol->symbol_value;

      /* For executables we will have to use the symbol's address and
	 find out what section would contain that address.   Yuk.  */
      for (section = abfd->sections; section; section = section->next)
	{
	  if (value >= section->vma
	      && value <= section->vma + section->_cooked_size
	      && som_is_subspace (section))
	    return section;
	}

      /* Could be a symbol from an external library (such as an OMOS
	 shared library).  Don't abort.  */
      return bfd_abs_section_ptr;

    }
}

/* Read and save the symbol table associated with the given BFD.  */

static unsigned int
som_slurp_symbol_table (abfd)
     bfd *abfd;
{
  int symbol_count = bfd_get_symcount (abfd);
  int symsize = sizeof (struct symbol_dictionary_record);
  char *stringtab;
  struct symbol_dictionary_record *buf = NULL, *bufp, *endbufp;
  som_symbol_type *sym, *symbase;
  bfd_size_type amt;

  /* Return saved value if it exists.  */
  if (obj_som_symtab (abfd) != NULL)
    goto successful_return;

  /* Special case.  This is *not* an error.  */
  if (symbol_count == 0)
    goto successful_return;

  if (!som_slurp_string_table (abfd))
    goto error_return;

  stringtab = obj_som_stringtab (abfd);

  amt = symbol_count;
  amt *= sizeof (som_symbol_type);
  symbase = (som_symbol_type *) bfd_zmalloc (amt);
  if (symbase == NULL)
    goto error_return;

  /* Read in the external SOM representation.  */
  amt = symbol_count;
  amt *= symsize;
  buf = bfd_malloc (amt);
  if (buf == NULL && amt != 0)
    goto error_return;
  if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) != 0)
    goto error_return;
  if (bfd_bread (buf, amt, abfd) != amt)
    goto error_return;

  /* Iterate over all the symbols and internalize them.  */
  endbufp = buf + symbol_count;
  for (bufp = buf, sym = symbase; bufp < endbufp; ++bufp)
    {

      /* I don't think we care about these.  */
      if (bufp->symbol_type == ST_SYM_EXT
	  || bufp->symbol_type == ST_ARG_EXT)
	continue;

      /* Set some private data we care about.  */
      if (bufp->symbol_type == ST_NULL)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_UNKNOWN;
      else if (bufp->symbol_type == ST_ABSOLUTE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_ABSOLUTE;
      else if (bufp->symbol_type == ST_DATA)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_DATA;
      else if (bufp->symbol_type == ST_CODE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_CODE;
      else if (bufp->symbol_type == ST_PRI_PROG)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_PRI_PROG;
      else if (bufp->symbol_type == ST_SEC_PROG)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_SEC_PROG;
      else if (bufp->symbol_type == ST_ENTRY)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_ENTRY;
      else if (bufp->symbol_type == ST_MILLICODE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_MILLICODE;
      else if (bufp->symbol_type == ST_PLABEL)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_PLABEL;
      else
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_UNKNOWN;
      som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc = bufp->arg_reloc;

      /* Some reasonable defaults.  */
      sym->symbol.the_bfd = abfd;
      sym->symbol.name = bufp->name.n_strx + stringtab;
      sym->symbol.value = bufp->symbol_value;
      sym->symbol.section = 0;
      sym->symbol.flags = 0;

      switch (bufp->symbol_type)
	{
	case ST_ENTRY:
	case ST_MILLICODE:
	  sym->symbol.flags |= BSF_FUNCTION;
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
	  sym->symbol.value &= ~0x3;
	  break;

	case ST_STUB:
	case ST_CODE:
	case ST_PRI_PROG:
	case ST_SEC_PROG:
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
	  sym->symbol.value &= ~0x3;
	  /* If the symbol's scope is SS_UNSAT, then these are
	     undefined function symbols.  */
	  if (bufp->symbol_scope == SS_UNSAT)
	    sym->symbol.flags |= BSF_FUNCTION;

	default:
	  break;
	}

      /* Handle scoping and section information.  */
      switch (bufp->symbol_scope)
	{
	/* symbol_info field is undefined for SS_EXTERNAL and SS_UNSAT symbols,
	   so the section associated with this symbol can't be known.  */
	case SS_EXTERNAL:
	  if (bufp->symbol_type != ST_STORAGE)
	    sym->symbol.section = bfd_und_section_ptr;
	  else
	    sym->symbol.section = bfd_com_section_ptr;
	  sym->symbol.flags |= (BSF_EXPORT | BSF_GLOBAL);
	  break;

	case SS_UNSAT:
	  if (bufp->symbol_type != ST_STORAGE)
	    sym->symbol.section = bfd_und_section_ptr;
	  else
	    sym->symbol.section = bfd_com_section_ptr;
	  break;

	case SS_UNIVERSAL:
	  sym->symbol.flags |= (BSF_EXPORT | BSF_GLOBAL);
	  sym->symbol.section = bfd_section_from_som_symbol (abfd, bufp);
	  sym->symbol.value -= sym->symbol.section->vma;
	  break;

#if 0
	/* SS_GLOBAL and SS_LOCAL are two names for the same thing.
	   Sound dumb?  It is.  */
	case SS_GLOBAL:
#endif
	case SS_LOCAL:
	  sym->symbol.flags |= BSF_LOCAL;
	  sym->symbol.section = bfd_section_from_som_symbol (abfd, bufp);
	  sym->symbol.value -= sym->symbol.section->vma;
	  break;
	}

      /* Check for a weak symbol.  */
      if (bufp->secondary_def)
	sym->symbol.flags |= BSF_WEAK;

      /* Mark section symbols and symbols used by the debugger.
	 Note $START$ is a magic code symbol, NOT a section symbol.  */
      if (sym->symbol.name[0] == '$'
	  && sym->symbol.name[strlen (sym->symbol.name) - 1] == '$'
	  && !strcmp (sym->symbol.name, sym->symbol.section->name))
	sym->symbol.flags |= BSF_SECTION_SYM;
      else if (!strncmp (sym->symbol.name, "L$0\002", 4))
	{
	  sym->symbol.flags |= BSF_SECTION_SYM;
	  sym->symbol.name = sym->symbol.section->name;
	}
      else if (!strncmp (sym->symbol.name, "L$0\001", 4))
	sym->symbol.flags |= BSF_DEBUGGING;

      /* Note increment at bottom of loop, since we skip some symbols
	 we can not include it as part of the for statement.  */
      sym++;
    }

  /* We modify the symbol count to record the number of BFD symbols we
     created.  */
  bfd_get_symcount (abfd) = sym - symbase;

  /* Save our results and return success.  */
  obj_som_symtab (abfd) = symbase;
 successful_return:
  if (buf != NULL)
    free (buf);
  return (TRUE);

 error_return:
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Canonicalize a SOM symbol table.  Return the number of entries
   in the symbol table.  */

static long
som_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
{
  int i;
  som_symbol_type *symbase;

  if (!som_slurp_symbol_table (abfd))
    return -1;

  i = bfd_get_symcount (abfd);
  symbase = obj_som_symtab (abfd);

  for (; i > 0; i--, location++, symbase++)
    *location = &symbase->symbol;

  /* Final null pointer.  */
  *location = 0;
  return (bfd_get_symcount (abfd));
}

/* Make a SOM symbol.  There is nothing special to do here.  */

static asymbol *
som_make_empty_symbol (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (som_symbol_type);
  som_symbol_type *new = (som_symbol_type *) bfd_zalloc (abfd, amt);
  if (new == NULL)
    return 0;
  new->symbol.the_bfd = abfd;

  return &new->symbol;
}

/* Print symbol information.  */

static void
som_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;
  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file, "som ");
      fprintf_vma (file, symbol->value);
      fprintf (file, " %lx", (long) symbol->flags);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name;
	section_name = symbol->section ? symbol->section->name : "(*none*)";
	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
	fprintf (file, " %s\t%s", section_name, symbol->name);
	break;
      }
    }
}

static bfd_boolean
som_bfd_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return (name[0] == 'L' && name[1] == '$');
}

/* Count or process variable-length SOM fixup records.

   To avoid code duplication we use this code both to compute the number
   of relocations requested by a stream, and to internalize the stream.

   When computing the number of relocations requested by a stream the
   variables rptr, section, and symbols have no meaning.

   Return the number of relocations requested by the fixup stream.  When
   not just counting

   This needs at least two or three more passes to get it cleaned up.  */

static unsigned int
som_set_reloc_info (fixup, end, internal_relocs, section, symbols, just_count)
     unsigned char *fixup;
     unsigned int end;
     arelent *internal_relocs;
     asection *section;
     asymbol **symbols;
     bfd_boolean just_count;
{
  unsigned int op, varname, deallocate_contents = 0;
  unsigned char *end_fixups = &fixup[end];
  const struct fixup_format *fp;
  const char *cp;
  unsigned char *save_fixup;
  int variables[26], stack[20], c, v, count, prev_fixup, *sp, saved_unwind_bits;
  const int *subop;
  arelent *rptr = internal_relocs;
  unsigned int offset = 0;

#define	var(c)		variables[(c) - 'A']
#define	push(v)		(*sp++ = (v))
#define	pop()		(*--sp)
#define	emptystack()	(sp == stack)

  som_initialize_reloc_queue (reloc_queue);
  memset (variables, 0, sizeof (variables));
  memset (stack, 0, sizeof (stack));
  count = 0;
  prev_fixup = 0;
  saved_unwind_bits = 0;
  sp = stack;

  while (fixup < end_fixups)
    {

      /* Save pointer to the start of this fixup.  We'll use
	 it later to determine if it is necessary to put this fixup
	 on the queue.  */
      save_fixup = fixup;

      /* Get the fixup code and its associated format.  */
      op = *fixup++;
      fp = &som_fixup_formats[op];

      /* Handle a request for a previous fixup.  */
      if (*fp->format == 'P')
	{
	  /* Get pointer to the beginning of the prev fixup, move
	     the repeated fixup to the head of the queue.  */
	  fixup = reloc_queue[fp->D].reloc;
	  som_reloc_queue_fix (reloc_queue, fp->D);
	  prev_fixup = 1;

	  /* Get the fixup code and its associated format.  */
	  op = *fixup++;
	  fp = &som_fixup_formats[op];
	}

      /* If this fixup will be passed to BFD, set some reasonable defaults.  */
      if (! just_count
	  && som_hppa_howto_table[op].type != R_NO_RELOCATION
	  && som_hppa_howto_table[op].type != R_DATA_OVERRIDE)
	{
	  rptr->address = offset;
	  rptr->howto = &som_hppa_howto_table[op];
	  rptr->addend = 0;
	  rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	}

      /* Set default input length to 0.  Get the opcode class index
	 into D.  */
      var ('L') = 0;
      var ('D') = fp->D;
      var ('U') = saved_unwind_bits;

      /* Get the opcode format.  */
      cp = fp->format;

      /* Process the format string.  Parsing happens in two phases,
	 parse RHS, then assign to LHS.  Repeat until no more
	 characters in the format string.  */
      while (*cp)
	{
	  /* The variable this pass is going to compute a value for.  */
	  varname = *cp++;

	  /* Start processing RHS.  Continue until a NULL or '=' is found.  */
	  do
	    {
	      c = *cp++;

	      /* If this is a variable, push it on the stack.  */
	      if (ISUPPER (c))
		push (var (c));

	      /* If this is a lower case letter, then it represents
		 additional data from the fixup stream to be pushed onto
		 the stack.  */
	      else if (ISLOWER (c))
		{
		  int bits = (c - 'a') * 8;
		  for (v = 0; c > 'a'; --c)
		    v = (v << 8) | *fixup++;
		  if (varname == 'V')
		    v = sign_extend (v, bits);
		  push (v);
		}

	      /* A decimal constant.  Push it on the stack.  */
	      else if (ISDIGIT (c))
		{
		  v = c - '0';
		  while (ISDIGIT (*cp))
		    v = (v * 10) + (*cp++ - '0');
		  push (v);
		}
	      else
		/* An operator.  Pop two two values from the stack and
		   use them as operands to the given operation.  Push
		   the result of the operation back on the stack.  */
		switch (c)
		  {
		  case '+':
		    v = pop ();
		    v += pop ();
		    push (v);
		    break;
		  case '*':
		    v = pop ();
		    v *= pop ();
		    push (v);
		    break;
		  case '<':
		    v = pop ();
		    v = pop () << v;
		    push (v);
		    break;
		  default:
		    abort ();
		  }
	    }
	  while (*cp && *cp != '=');

	  /* Move over the equal operator.  */
	  cp++;

	  /* Pop the RHS off the stack.  */
	  c = pop ();

	  /* Perform the assignment.  */
	  var (varname) = c;

	  /* Handle side effects. and special 'O' stack cases.  */
	  switch (varname)
	    {
	    /* Consume some bytes from the input space.  */
	    case 'L':
	      offset += c;
	      break;
	    /* A symbol to use in the relocation.  Make a note
	       of this if we are not just counting.  */
	    case 'S':
	      if (! just_count)
		rptr->sym_ptr_ptr = &symbols[c];
	      break;
	    /* Argument relocation bits for a function call.  */
	    case 'R':
	      if (! just_count)
		{
		  unsigned int tmp = var ('R');
		  rptr->addend = 0;

		  if ((som_hppa_howto_table[op].type == R_PCREL_CALL
		       && R_PCREL_CALL + 10 > op)
		      || (som_hppa_howto_table[op].type == R_ABS_CALL
			  && R_ABS_CALL + 10 > op))
		    {
		      /* Simple encoding.  */
		      if (tmp > 4)
			{
			  tmp -= 5;
			  rptr->addend |= 1;
			}
		      if (tmp == 4)
			rptr->addend |= 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2;
		      else if (tmp == 3)
			rptr->addend |= 1 << 8 | 1 << 6 | 1 << 4;
		      else if (tmp == 2)
			rptr->addend |= 1 << 8 | 1 << 6;
		      else if (tmp == 1)
			rptr->addend |= 1 << 8;
		    }
		  else
		    {
		      unsigned int tmp1, tmp2;

		      /* First part is easy -- low order two bits are
			 directly copied, then shifted away.  */
		      rptr->addend = tmp & 0x3;
		      tmp >>= 2;

		      /* Diving the result by 10 gives us the second
			 part.  If it is 9, then the first two words
			 are a double precision paramater, else it is
			 3 * the first arg bits + the 2nd arg bits.  */
		      tmp1 = tmp / 10;
		      tmp -= tmp1 * 10;
		      if (tmp1 == 9)
			rptr->addend += (0xe << 6);
		      else
			{
			  /* Get the two pieces.  */
			  tmp2 = tmp1 / 3;
			  tmp1 -= tmp2 * 3;
			  /* Put them in the addend.  */
			  rptr->addend += (tmp2 << 8) + (tmp1 << 6);
			}

		      /* What's left is the third part.  It's unpacked
			 just like the second.  */
		      if (tmp == 9)
			rptr->addend += (0xe << 2);
		      else
			{
			  tmp2 = tmp / 3;
			  tmp -= tmp2 * 3;
			  rptr->addend += (tmp2 << 4) + (tmp << 2);
			}
		    }
		  rptr->addend = HPPA_R_ADDEND (rptr->addend, 0);
		}
	      break;
	    /* Handle the linker expression stack.  */
	    case 'O':
	      switch (op)
		{
		case R_COMP1:
		  subop = comp1_opcodes;
		  break;
		case R_COMP2:
		  subop = comp2_opcodes;
		  break;
		case R_COMP3:
		  subop = comp3_opcodes;
		  break;
		default:
		  abort ();
		}
	      while (*subop <= (unsigned char) c)
		++subop;
	      --subop;
	      break;
	    /* The lower 32unwind bits must be persistent.  */
	    case 'U':
	      saved_unwind_bits = var ('U');
	      break;

	    default:
	      break;
	    }
	}

      /* If we used a previous fixup, clean up after it.  */
      if (prev_fixup)
	{
	  fixup = save_fixup + 1;
	  prev_fixup = 0;
	}
      /* Queue it.  */
      else if (fixup > save_fixup + 1)
	som_reloc_queue_insert (save_fixup, fixup - save_fixup, reloc_queue);

      /* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION
	 fixups to BFD.  */
      if (som_hppa_howto_table[op].type != R_DATA_OVERRIDE
	  && som_hppa_howto_table[op].type != R_NO_RELOCATION)
	{
	  /* Done with a single reloction. Loop back to the top.  */
	  if (! just_count)
	    {
	      if (som_hppa_howto_table[op].type == R_ENTRY)
		rptr->addend = var ('T');
	      else if (som_hppa_howto_table[op].type == R_EXIT)
		rptr->addend = var ('U');
	      else if (som_hppa_howto_table[op].type == R_PCREL_CALL
		       || som_hppa_howto_table[op].type == R_ABS_CALL)
		;
	      else if (som_hppa_howto_table[op].type == R_DATA_ONE_SYMBOL)
		{
		  /* Try what was specified in R_DATA_OVERRIDE first
		     (if anything).  Then the hard way using the
		     section contents.  */
		  rptr->addend = var ('V');

		  if (rptr->addend == 0 && !section->contents)
		    {
		      /* Got to read the damn contents first.  We don't
			 bother saving the contents (yet).  Add it one
			 day if the need arises.  */
		      section->contents = bfd_malloc (section->_raw_size);
		      if (section->contents == NULL)
			return (unsigned) -1;

		      deallocate_contents = 1;
		      bfd_get_section_contents (section->owner,
						section,
						section->contents,
						(bfd_vma) 0,
						section->_raw_size);
		    }
		  else if (rptr->addend == 0)
		    rptr->addend = bfd_get_32 (section->owner,
					       (section->contents
						+ offset - var ('L')));

		}
	      else
		rptr->addend = var ('V');
	      rptr++;
	    }
	  count++;
	  /* Now that we've handled a "full" relocation, reset
	     some state.  */
	  memset (variables, 0, sizeof (variables));
	  memset (stack, 0, sizeof (stack));
	}
    }
  if (deallocate_contents)
    free (section->contents);

  return count;

#undef var
#undef push
#undef pop
#undef emptystack
}

/* Read in the relocs (aka fixups in SOM terms) for a section.

   som_get_reloc_upper_bound calls this routine with JUST_COUNT
   set to TRUE to indicate it only needs a count of the number
   of actual relocations.  */

static bfd_boolean
som_slurp_reloc_table (abfd, section, symbols, just_count)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_boolean just_count;
{
  char *external_relocs;
  unsigned int fixup_stream_size;
  arelent *internal_relocs;
  unsigned int num_relocs;
  bfd_size_type amt;

  fixup_stream_size = som_section_data (section)->reloc_size;
  /* If there were no relocations, then there is nothing to do.  */
  if (section->reloc_count == 0)
    return TRUE;

  /* If reloc_count is -1, then the relocation stream has not been
     parsed.  We must do so now to know how many relocations exist.  */
  if (section->reloc_count == (unsigned) -1)
    {
      amt = fixup_stream_size;
      external_relocs = (char *) bfd_malloc (amt);
      if (external_relocs == (char *) NULL)
	return FALSE;
      /* Read in the external forms.  */
      if (bfd_seek (abfd,
		    obj_som_reloc_filepos (abfd) + section->rel_filepos,
		    SEEK_SET)
	  != 0)
	return FALSE;
      if (bfd_bread (external_relocs, amt, abfd) != amt)
	return FALSE;

      /* Let callers know how many relocations found.
	 also save the relocation stream as we will
	 need it again.  */
      section->reloc_count = som_set_reloc_info (external_relocs,
						 fixup_stream_size,
						 NULL, NULL, NULL, TRUE);

      som_section_data (section)->reloc_stream = external_relocs;
    }

  /* If the caller only wanted a count, then return now.  */
  if (just_count)
    return TRUE;

  num_relocs = section->reloc_count;
  external_relocs = som_section_data (section)->reloc_stream;
  /* Return saved information about the relocations if it is available.  */
  if (section->relocation != (arelent *) NULL)
    return TRUE;

  amt = num_relocs;
  amt *= sizeof (arelent);
  internal_relocs = (arelent *) bfd_zalloc (abfd, (amt));
  if (internal_relocs == (arelent *) NULL)
    return FALSE;

  /* Process and internalize the relocations.  */
  som_set_reloc_info (external_relocs, fixup_stream_size,
		      internal_relocs, section, symbols, FALSE);

  /* We're done with the external relocations.  Free them.  */
  free (external_relocs);
  som_section_data (section)->reloc_stream = NULL;

  /* Save our results and return success.  */
  section->relocation = internal_relocs;
  return TRUE;
}

/* Return the number of bytes required to store the relocation
   information associated with the given section.  */

static long
som_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
{
  /* If section has relocations, then read in the relocation stream
     and parse it to determine how many relocations exist.  */
  if (asect->flags & SEC_RELOC)
    {
      if (! som_slurp_reloc_table (abfd, asect, NULL, TRUE))
	return -1;
      return (asect->reloc_count + 1) * sizeof (arelent *);
    }
  /* There are no relocations.  */
  return 0;
}

/* Convert relocations from SOM (external) form into BFD internal
   form.  Return the number of relocations.  */

static long
som_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  int count;

  if (! som_slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  count = section->reloc_count;
  tblptr = section->relocation;

  while (count--)
    *relptr++ = tblptr++;

  *relptr = (arelent *) NULL;
  return section->reloc_count;
}

extern const bfd_target som_vec;

/* A hook to set up object file dependent section information.  */

static bfd_boolean
som_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
{
  bfd_size_type amt = sizeof (struct som_section_data_struct);
  newsect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
  if (!newsect->used_by_bfd)
    return FALSE;
  newsect->alignment_power = 3;

  /* We allow more than three sections internally.  */
  return TRUE;
}

/* Copy any private info we understand from the input symbol
   to the output symbol.  */

static bfd_boolean
som_bfd_copy_private_symbol_data (ibfd, isymbol, obfd, osymbol)
     bfd *ibfd;
     asymbol *isymbol;
     bfd *obfd;
     asymbol *osymbol;
{
  struct som_symbol *input_symbol = (struct som_symbol *) isymbol;
  struct som_symbol *output_symbol = (struct som_symbol *) osymbol;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour)
    return FALSE;

  /* The only private information we need to copy is the argument relocation
     bits.  */
  output_symbol->tc_data.ap.hppa_arg_reloc =
    input_symbol->tc_data.ap.hppa_arg_reloc;

  return TRUE;
}

/* Copy any private info we understand from the input section
   to the output section.  */

static bfd_boolean
som_bfd_copy_private_section_data (ibfd, isection, obfd, osection)
     bfd *ibfd;
     asection *isection;
     bfd *obfd;
     asection *osection;
{
  bfd_size_type amt;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour
      || (!som_is_space (isection) && !som_is_subspace (isection)))
    return TRUE;

  amt = sizeof (struct som_copyable_section_data_struct);
  som_section_data (osection)->copy_data =
    (struct som_copyable_section_data_struct *) bfd_zalloc (obfd, amt);
  if (som_section_data (osection)->copy_data == NULL)
    return FALSE;

  memcpy (som_section_data (osection)->copy_data,
	  som_section_data (isection)->copy_data,
	  sizeof (struct som_copyable_section_data_struct));

  /* Reparent if necessary.  */
  if (som_section_data (osection)->copy_data->container)
    som_section_data (osection)->copy_data->container =
      som_section_data (osection)->copy_data->container->output_section;

  return TRUE;
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

static bfd_boolean
som_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour)
    return TRUE;

  /* Allocate some memory to hold the data we need.  */
  obj_som_exec_data (obfd) = (struct som_exec_data *)
    bfd_zalloc (obfd, (bfd_size_type) sizeof (struct som_exec_data));
  if (obj_som_exec_data (obfd) == NULL)
    return FALSE;

  /* Now copy the data.  */
  memcpy (obj_som_exec_data (obfd), obj_som_exec_data (ibfd),
	  sizeof (struct som_exec_data));

  return TRUE;
}

/* Set backend info for sections which can not be described
   in the BFD data structures.  */

bfd_boolean
bfd_som_set_section_attributes (section, defined, private, sort_key, spnum)
     asection *section;
     int defined;
     int private;
     unsigned int sort_key;
     int spnum;
{
  /* Allocate memory to hold the magic information.  */
  if (som_section_data (section)->copy_data == NULL)
    {
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
      if (som_section_data (section)->copy_data == NULL)
	return FALSE;
    }
  som_section_data (section)->copy_data->sort_key = sort_key;
  som_section_data (section)->copy_data->is_defined = defined;
  som_section_data (section)->copy_data->is_private = private;
  som_section_data (section)->copy_data->container = section;
  som_section_data (section)->copy_data->space_number = spnum;
  return TRUE;
}

/* Set backend info for subsections which can not be described
   in the BFD data structures.  */

bfd_boolean
bfd_som_set_subsection_attributes (section, container, access,
				   sort_key, quadrant)
     asection *section;
     asection *container;
     int access;
     unsigned int sort_key;
     int quadrant;
{
  /* Allocate memory to hold the magic information.  */
  if (som_section_data (section)->copy_data == NULL)
    {
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
      if (som_section_data (section)->copy_data == NULL)
	return FALSE;
    }
  som_section_data (section)->copy_data->sort_key = sort_key;
  som_section_data (section)->copy_data->access_control_bits = access;
  som_section_data (section)->copy_data->quadrant = quadrant;
  som_section_data (section)->copy_data->container = container;
  return TRUE;
}

/* Set the full SOM symbol type.  SOM needs far more symbol information
   than any other object file format I'm aware of.  It is mandatory
   to be able to know if a symbol is an entry point, millicode, data,
   code, absolute, storage request, or procedure label.  If you get
   the symbol type wrong your program will not link.  */

void
bfd_som_set_symbol_type (symbol, type)
     asymbol *symbol;
     unsigned int type;
{
  som_symbol_data (symbol)->som_type = type;
}

/* Attach an auxiliary header to the BFD backend so that it may be
   written into the object file.  */

bfd_boolean
bfd_som_attach_aux_hdr (abfd, type, string)
     bfd *abfd;
     int type;
     char *string;
{
  bfd_size_type amt;

  if (type == VERSION_AUX_ID)
    {
      size_t len = strlen (string);
      int pad = 0;

      if (len % 4)
	pad = (4 - (len % 4));
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
      obj_som_version_hdr (abfd) =
	(struct user_string_aux_hdr *) bfd_zalloc (abfd, amt);
      if (!obj_som_version_hdr (abfd))
	return FALSE;
      obj_som_version_hdr (abfd)->header_id.type = VERSION_AUX_ID;
      obj_som_version_hdr (abfd)->header_id.length = len + pad;
      obj_som_version_hdr (abfd)->header_id.length += sizeof (int);
      obj_som_version_hdr (abfd)->string_length = len;
      strncpy (obj_som_version_hdr (abfd)->user_string, string, len);
    }
  else if (type == COPYRIGHT_AUX_ID)
    {
      int len = strlen (string);
      int pad = 0;

      if (len % 4)
	pad = (4 - (len % 4));
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
      obj_som_copyright_hdr (abfd) =
	(struct copyright_aux_hdr *) bfd_zalloc (abfd, amt);
      if (!obj_som_copyright_hdr (abfd))
	return FALSE;
      obj_som_copyright_hdr (abfd)->header_id.type = COPYRIGHT_AUX_ID;
      obj_som_copyright_hdr (abfd)->header_id.length = len + pad;
      obj_som_copyright_hdr (abfd)->header_id.length += sizeof (int);
      obj_som_copyright_hdr (abfd)->string_length = len;
      strcpy (obj_som_copyright_hdr (abfd)->copyright, string);
    }
  return TRUE;
}

/* Attach a compilation unit header to the BFD backend so that it may be
   written into the object file.  */

bfd_boolean
bfd_som_attach_compilation_unit (abfd, name, language_name, product_id,
				 version_id)
     bfd *abfd;
     const char *name;
     const char *language_name;
     const char *product_id;
     const char *version_id;
{
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, (bfd_size_type) COMPUNITSZ);
  if (n == NULL)
    return FALSE;

#define STRDUP(f) \
  if (f != NULL) \
    { \
      n->f.n_name = bfd_alloc (abfd, (bfd_size_type) strlen (f) + 1); \
      if (n->f.n_name == NULL) \
	return FALSE; \
      strcpy (n->f.n_name, f); \
    }

  STRDUP (name);
  STRDUP (language_name);
  STRDUP (product_id);
  STRDUP (version_id);

#undef STRDUP

  obj_som_compilation_unit (abfd) = n;

  return TRUE;
}

static bfd_boolean
som_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (count == 0 || ((section->flags & SEC_HAS_CONTENTS) == 0))
    return TRUE;
  if ((bfd_size_type) (offset+count) > section->_raw_size
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0
      || bfd_bread (location, count, abfd) != count)
    return FALSE; /* On error.  */
  return TRUE;
}

static bfd_boolean
som_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (! abfd->output_has_begun)
    {
      /* Set up fixed parts of the file, space, and subspace headers.
	 Notify the world that output has begun.  */
      som_prep_headers (abfd);
      abfd->output_has_begun = TRUE;
      /* Start writing the object file.  This include all the string
	 tables, fixup streams, and other portions of the object file.  */
      som_begin_writing (abfd);
    }

  /* Only write subspaces which have "real" contents (eg. the contents
     are not generated at run time by the OS).  */
  if (!som_is_subspace (section)
      || ((section->flags & SEC_HAS_CONTENTS) == 0))
    return TRUE;

  /* Seek to the proper offset within the object file and write the
     data.  */
  offset += som_section_data (section)->subspace_dict->file_loc_init_value;
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite ((PTR) location, count, abfd) != count)
    return FALSE;
  return TRUE;
}

static bfd_boolean
som_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
{
  /* Allow any architecture to be supported by the SOM backend.  */
  return bfd_default_set_arch_mach (abfd, arch, machine);
}

static bfd_boolean
som_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
		       functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
{
  return FALSE;
}

static int
som_sizeof_headers (abfd, reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
{
  (*_bfd_error_handler) (_("som_sizeof_headers unimplemented"));
  fflush (stderr);
  abort ();
  return 0;
}

/* Return the single-character symbol type corresponding to
   SOM section S, or '?' for an unknown SOM section.  */

static char
som_section_type (s)
     const char *s;
{
  const struct section_to_type *t;

  for (t = &stt[0]; t->section; t++)
    if (!strcmp (s, t->section))
      return t->type;
  return '?';
}

static int
som_decode_symclass (symbol)
     asymbol *symbol;
{
  char c;

  if (bfd_is_com_section (symbol->section))
    return 'C';
  if (bfd_is_und_section (symbol->section))
    return 'U';
  if (bfd_is_ind_section (symbol->section))
    return 'I';
  if (symbol->flags & BSF_WEAK)
    return 'W';
  if (!(symbol->flags & (BSF_GLOBAL | BSF_LOCAL)))
    return '?';

  if (bfd_is_abs_section (symbol->section)
      || (som_symbol_data (symbol) != NULL
	  && som_symbol_data (symbol)->som_type == SYMBOL_TYPE_ABSOLUTE))
    c = 'a';
  else if (symbol->section)
    c = som_section_type (symbol->section->name);
  else
    return '?';
  if (symbol->flags & BSF_GLOBAL)
    c = TOUPPER (c);
  return c;
}

/* Return information about SOM symbol SYMBOL in RET.  */

static void
som_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  ret->type = som_decode_symclass (symbol);
  if (ret->type != 'U')
    ret->value = symbol->value + symbol->section->vma;
  else
    ret->value = 0;
  ret->name = symbol->name;
}

/* Count the number of symbols in the archive symbol table.  Necessary
   so that we can allocate space for all the carsyms at once.  */

static bfd_boolean
som_bfd_count_ar_symbols (abfd, lst_header, count)
     bfd *abfd;
     struct lst_header *lst_header;
     symindex *count;
{
  unsigned int i;
  unsigned int *hash_table = NULL;
  bfd_size_type amt;
  file_ptr lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);

  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_malloc (amt);
  if (hash_table == NULL && lst_header->hash_size != 0)
    goto error_return;

  /* Don't forget to initialize the counter!  */
  *count = 0;

  /* Read in the hash table.  The has table is an array of 32bit file offsets
     which point to the hash chains.  */
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Walk each chain counting the number of symbols found on that particular
     chain.  */
  for (i = 0; i < lst_header->hash_size; i++)
    {
      struct lst_symbol_record lst_symbol;

      /* An empty chain has zero as it's file offset.  */
      if (hash_table[i] == 0)
	continue;

      /* Seek to the first symbol in this hash chain.  */
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
	goto error_return;

      /* Read in this symbol and update the counter.  */
      amt = sizeof (lst_symbol);
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
	goto error_return;

      (*count)++;

      /* Now iterate through the rest of the symbols on this chain.  */
      while (lst_symbol.next_entry)
	{

	  /* Seek to the next symbol.  */
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET)
	      != 0)
	    goto error_return;

	  /* Read the symbol in and update the counter.  */
	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
	    goto error_return;

	  (*count)++;
	}
    }
  if (hash_table != NULL)
    free (hash_table);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  return FALSE;
}

/* Fill in the canonical archive symbols (SYMS) from the archive described
   by ABFD and LST_HEADER.  */

static bfd_boolean
som_bfd_fill_in_ar_symbols (abfd, lst_header, syms)
     bfd *abfd;
     struct lst_header *lst_header;
     carsym **syms;
{
  unsigned int i, len;
  carsym *set = syms[0];
  unsigned int *hash_table = NULL;
  struct som_entry *som_dict = NULL;
  bfd_size_type amt;
  file_ptr lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);

  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_malloc (amt);
  if (hash_table == NULL && lst_header->hash_size != 0)
    goto error_return;

  /* Read in the hash table.  The has table is an array of 32bit file offsets
     which point to the hash chains.  */
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Seek to and read in the SOM dictionary.  We will need this to fill
     in the carsym's filepos field.  */
  if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) != 0)
    goto error_return;

  amt = lst_header->module_count;
  amt *= sizeof (struct som_entry);
  som_dict = (struct som_entry *) bfd_malloc (amt);
  if (som_dict == NULL && lst_header->module_count != 0)
    goto error_return;

  if (bfd_bread ((PTR) som_dict, amt, abfd) != amt)
    goto error_return;

  /* Walk each chain filling in the carsyms as we go along.  */
  for (i = 0; i < lst_header->hash_size; i++)
    {
      struct lst_symbol_record lst_symbol;

      /* An empty chain has zero as it's file offset.  */
      if (hash_table[i] == 0)
	continue;

      /* Seek to and read the first symbol on the chain.  */
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
	goto error_return;

      amt = sizeof (lst_symbol);
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
	goto error_return;

      /* Get the name of the symbol, first get the length which is stored
	 as a 32bit integer just before the symbol.

	 One might ask why we don't just read in the entire string table
	 and index into it.  Well, according to the SOM ABI the string
	 index can point *anywhere* in the archive to save space, so just
	 using the string table would not be safe.  */
      if (bfd_seek (abfd, lst_filepos + lst_header->string_loc
			    + lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
	goto error_return;

      if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
	goto error_return;

      /* Allocate space for the name and null terminate it too.  */
      set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
      if (!set->name)
	goto error_return;
      if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
	goto error_return;

      set->name[len] = 0;

      /* Fill in the file offset.  Note that the "location" field points
	 to the SOM itself, not the ar_hdr in front of it.  */
      set->file_offset = som_dict[lst_symbol.som_index].location
			  - sizeof (struct ar_hdr);

      /* Go to the next symbol.  */
      set++;

      /* Iterate through the rest of the chain.  */
      while (lst_symbol.next_entry)
	{
	  /* Seek to the next symbol and read it in.  */
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET)
	      != 0)
	    goto error_return;

	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
	    goto error_return;

	  /* Seek to the name length & string and read them in.  */
	  if (bfd_seek (abfd, lst_filepos + lst_header->string_loc
				+ lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
	    goto error_return;

	  if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
	    goto error_return;

	  /* Allocate space for the name and null terminate it too.  */
	  set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
	  if (!set->name)
	    goto error_return;

	  if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
	    goto error_return;
	  set->name[len] = 0;

	  /* Fill in the file offset.  Note that the "location" field points
	     to the SOM itself, not the ar_hdr in front of it.  */
	  set->file_offset = som_dict[lst_symbol.som_index].location
			       - sizeof (struct ar_hdr);

	  /* Go on to the next symbol.  */
	  set++;
	}
    }
  /* If we haven't died by now, then we successfully read the entire
     archive symbol table.  */
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  return FALSE;
}

/* Read in the LST from the archive.  */

static bfd_boolean
som_slurp_armap (abfd)
     bfd *abfd;
{
  struct lst_header lst_header;
  struct ar_hdr ar_header;
  unsigned int parsed_size;
  struct artdata *ardata = bfd_ardata (abfd);
  char nextname[17];
  bfd_size_type amt = 16;
  int i = bfd_bread ((PTR) nextname, amt, abfd);

  /* Special cases.  */
  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  /* For archives without .o files there is no symbol table.  */
  if (strncmp (nextname, "/               ", 16))
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  /* Read in and sanity check the archive header.  */
  amt = sizeof (struct ar_hdr);
  if (bfd_bread ((PTR) &ar_header, amt, abfd) != amt)
    return FALSE;

  if (strncmp (ar_header.ar_fmag, ARFMAG, 2))
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* How big is the archive symbol table entry?  */
  errno = 0;
  parsed_size = strtol (ar_header.ar_size, NULL, 10);
  if (errno != 0)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* Save off the file offset of the first real user data.  */
  ardata->first_file_filepos = bfd_tell (abfd) + parsed_size;

  /* Read in the library symbol table.  We'll make heavy use of this
     in just a minute.  */
  amt = sizeof (struct lst_header);
  if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
    return FALSE;

  /* Sanity check.  */
  if (lst_header.a_magic != LIBMAGIC)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* Count the number of symbols in the library symbol table.  */
  if (! som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count))
    return FALSE;

  /* Get back to the start of the library symbol table.  */
  if (bfd_seek (abfd, (ardata->first_file_filepos - parsed_size
		       + sizeof (struct lst_header)), SEEK_SET) != 0)
    return FALSE;

  /* Initialize the cache and allocate space for the library symbols.  */
  ardata->cache = 0;
  amt = ardata->symdef_count;
  amt *= sizeof (carsym);
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  /* Now fill in the canonical archive symbols.  */
  if (! som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs))
    return FALSE;

  /* Seek back to the "first" file in the archive.  Note the "first"
     file may be the extended name table.  */
  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) != 0)
    return FALSE;

  /* Notify the generic archive code that we have a symbol map.  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/* Begin preparing to write a SOM library symbol table.

   As part of the prep work we need to determine the number of symbols
   and the size of the associated string section.  */

static bfd_boolean
som_bfd_prep_for_ar_write (abfd, num_syms, stringsize)
     bfd *abfd;
     unsigned int *num_syms, *stringsize;
{
  bfd *curr_bfd = abfd->archive_head;

  /* Some initialization.  */
  *num_syms = 0;
  *stringsize = 0;

  /* Iterate over each BFD within this archive.  */
  while (curr_bfd != NULL)
    {
      unsigned int curr_count, i;
      som_symbol_type *sym;

      /* Don't bother for non-SOM objects.  */
      if (curr_bfd->format != bfd_object
	  || curr_bfd->xvec->flavour != bfd_target_som_flavour)
	{
	  curr_bfd = curr_bfd->next;
	  continue;
	}

      /* Make sure the symbol table has been read, then snag a pointer
	 to it.  It's a little slimey to grab the symbols via obj_som_symtab,
	 but doing so avoids allocating lots of extra memory.  */
      if (! som_slurp_symbol_table (curr_bfd))
	return FALSE;

      sym = obj_som_symtab (curr_bfd);
      curr_count = bfd_get_symcount (curr_bfd);

      /* Examine each symbol to determine if it belongs in the
	 library symbol table.  */
      for (i = 0; i < curr_count; i++, sym++)
	{
	  struct som_misc_symbol_info info;

	  /* Derive SOM information from the BFD symbol.  */
	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);

	  /* Should we include this symbol?  */
	  if (info.symbol_type == ST_NULL
	      || info.symbol_type == ST_SYM_EXT
	      || info.symbol_type == ST_ARG_EXT)
	    continue;

	  /* Only global symbols and unsatisfied commons.  */
	  if (info.symbol_scope != SS_UNIVERSAL
	      && info.symbol_type != ST_STORAGE)
	    continue;

	  /* Do no include undefined symbols.  */
	  if (bfd_is_und_section (sym->symbol.section))
	    continue;

	  /* Bump the various counters, being careful to honor
	     alignment considerations in the string table.  */
	  (*num_syms)++;
	  *stringsize = *stringsize + strlen (sym->symbol.name) + 5;
	  while (*stringsize % 4)
	    (*stringsize)++;
	}

      curr_bfd = curr_bfd->next;
    }
  return TRUE;
}

/* Hash a symbol name based on the hashing algorithm presented in the
   SOM ABI.  */

static unsigned int
som_bfd_ar_symbol_hash (symbol)
     asymbol *symbol;
{
  unsigned int len = strlen (symbol->name);

  /* Names with length 1 are special.  */
  if (len == 1)
    return 0x1000100 | (symbol->name[0] << 16) | symbol->name[0];

  return ((len & 0x7f) << 24) | (symbol->name[1] << 16)
	  | (symbol->name[len - 2] << 8) | symbol->name[len - 1];
}

/* Do the bulk of the work required to write the SOM library
   symbol table.  */

static bfd_boolean
som_bfd_ar_write_symbol_stuff (abfd, nsyms, string_size, lst, elength)
     bfd *abfd;
     unsigned int nsyms, string_size;
     struct lst_header lst;
     unsigned elength;
{
  file_ptr lst_filepos;
  char *strings = NULL, *p;
  struct lst_symbol_record *lst_syms = NULL, *curr_lst_sym;
  bfd *curr_bfd;
  unsigned int *hash_table = NULL;
  struct som_entry *som_dict = NULL;
  struct lst_symbol_record **last_hash_entry = NULL;
  unsigned int curr_som_offset, som_index = 0;
  bfd_size_type amt;

  amt = lst.hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_zmalloc (amt);
  if (hash_table == NULL && lst.hash_size != 0)
    goto error_return;

  amt = lst.module_count;
  amt *= sizeof (struct som_entry);
  som_dict = (struct som_entry *) bfd_zmalloc (amt);
  if (som_dict == NULL && lst.module_count != 0)
    goto error_return;

  amt = lst.hash_size;
  amt *= sizeof (struct lst_symbol_record *);
  last_hash_entry = ((struct lst_symbol_record **) bfd_zmalloc (amt));
  if (last_hash_entry == NULL && lst.hash_size != 0)
    goto error_return;

  /* Lots of fields are file positions relative to the start
     of the lst record.  So save its location.  */
  lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);

  /* Symbols have som_index fields, so we have to keep track of the
     index of each SOM in the archive.

     The SOM dictionary has (among other things) the absolute file
     position for the SOM which a particular dictionary entry
     describes.  We have to compute that information as we iterate
     through the SOMs/symbols.  */
  som_index = 0;

  /* We add in the size of the archive header twice as the location
     in the SOM dictionary is the actual offset of the SOM, not the
     archive header before the SOM.  */
  curr_som_offset = 8 + 2 * sizeof (struct ar_hdr) + lst.file_end;

  /* Make room for the archive header and the contents of the
     extended string table.  Note that elength includes the size
     of the archive header for the extended name table!  */
  if (elength)
    curr_som_offset += elength;

  /* Make sure we're properly aligned.  */
  curr_som_offset = (curr_som_offset + 0x1) & ~0x1;

  /* FIXME should be done with buffers just like everything else...  */
  amt = nsyms;
  amt *= sizeof (struct lst_symbol_record);
  lst_syms = bfd_malloc (amt);
  if (lst_syms == NULL && nsyms != 0)
    goto error_return;
  strings = bfd_malloc ((bfd_size_type) string_size);
  if (strings == NULL && string_size != 0)
    goto error_return;

  p = strings;
  curr_lst_sym = lst_syms;

  curr_bfd = abfd->archive_head;
  while (curr_bfd != NULL)
    {
      unsigned int curr_count, i;
      som_symbol_type *sym;

      /* Don't bother for non-SOM objects.  */
      if (curr_bfd->format != bfd_object
	  || curr_bfd->xvec->flavour != bfd_target_som_flavour)
	{
	  curr_bfd = curr_bfd->next;
	  continue;
	}

      /* Make sure the symbol table has been read, then snag a pointer
	 to it.  It's a little slimey to grab the symbols via obj_som_symtab,
	 but doing so avoids allocating lots of extra memory.  */
      if (! som_slurp_symbol_table (curr_bfd))
	goto error_return;

      sym = obj_som_symtab (curr_bfd);
      curr_count = bfd_get_symcount (curr_bfd);

      for (i = 0; i < curr_count; i++, sym++)
	{
	  struct som_misc_symbol_info info;

	  /* Derive SOM information from the BFD symbol.  */
	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);

	  /* Should we include this symbol?  */
	  if (info.symbol_type == ST_NULL
	      || info.symbol_type == ST_SYM_EXT
	      || info.symbol_type == ST_ARG_EXT)
	    continue;

	  /* Only global symbols and unsatisfied commons.  */
	  if (info.symbol_scope != SS_UNIVERSAL
	      && info.symbol_type != ST_STORAGE)
	    continue;

	  /* Do no include undefined symbols.  */
	  if (bfd_is_und_section (sym->symbol.section))
	    continue;

	  /* If this is the first symbol from this SOM, then update
	     the SOM dictionary too.  */
	  if (som_dict[som_index].location == 0)
	    {
	      som_dict[som_index].location = curr_som_offset;
	      som_dict[som_index].length = arelt_size (curr_bfd);
	    }

	  /* Fill in the lst symbol record.  */
	  curr_lst_sym->hidden = 0;
	  curr_lst_sym->secondary_def = info.secondary_def;
	  curr_lst_sym->symbol_type = info.symbol_type;
	  curr_lst_sym->symbol_scope = info.symbol_scope;
	  curr_lst_sym->check_level = 0;
	  curr_lst_sym->must_qualify = 0;
	  curr_lst_sym->initially_frozen = 0;
	  curr_lst_sym->memory_resident = 0;
	  curr_lst_sym->is_common = bfd_is_com_section (sym->symbol.section);
	  curr_lst_sym->dup_common = 0;
	  curr_lst_sym->xleast = 3;
	  curr_lst_sym->arg_reloc = info.arg_reloc;
	  curr_lst_sym->name.n_strx = p - strings + 4;
	  curr_lst_sym->qualifier_name.n_strx = 0;
	  curr_lst_sym->symbol_info = info.symbol_info;
	  curr_lst_sym->symbol_value = info.symbol_value | info.priv_level;
	  curr_lst_sym->symbol_descriptor = 0;
	  curr_lst_sym->reserved = 0;
	  curr_lst_sym->som_index = som_index;
	  curr_lst_sym->symbol_key = som_bfd_ar_symbol_hash (&sym->symbol);
	  curr_lst_sym->next_entry = 0;

	  /* Insert into the hash table.  */
	  if (hash_table[curr_lst_sym->symbol_key % lst.hash_size])
	    {
	      struct lst_symbol_record *tmp;

	      /* There is already something at the head of this hash chain,
		 so tack this symbol onto the end of the chain.  */
	      tmp = last_hash_entry[curr_lst_sym->symbol_key % lst.hash_size];
	      tmp->next_entry
		= (curr_lst_sym - lst_syms) * sizeof (struct lst_symbol_record)
		  + lst.hash_size * 4
		  + lst.module_count * sizeof (struct som_entry)
		  + sizeof (struct lst_header);
	    }
	  else
	    {
	      /* First entry in this hash chain.  */
	      hash_table[curr_lst_sym->symbol_key % lst.hash_size]
		= (curr_lst_sym - lst_syms) * sizeof (struct lst_symbol_record)
		  + lst.hash_size * 4
		  + lst.module_count * sizeof (struct som_entry)
		  + sizeof (struct lst_header);
	    }

	  /* Keep track of the last symbol we added to this chain so we can
	     easily update its next_entry pointer.  */
	  last_hash_entry[curr_lst_sym->symbol_key % lst.hash_size]
	    = curr_lst_sym;

	  /* Update the string table.  */
	  bfd_put_32 (abfd, strlen (sym->symbol.name), p);
	  p += 4;
	  strcpy (p, sym->symbol.name);
	  p += strlen (sym->symbol.name) + 1;
	  while ((int) p % 4)
	    {
	      bfd_put_8 (abfd, 0, p);
	      p++;
	    }

	  /* Head to the next symbol.  */
	  curr_lst_sym++;
	}

      /* Keep track of where each SOM will finally reside; then look
	 at the next BFD.  */
      curr_som_offset += arelt_size (curr_bfd) + sizeof (struct ar_hdr);

      /* A particular object in the archive may have an odd length; the
	 linker requires objects begin on an even boundary.  So round
	 up the current offset as necessary.  */
      curr_som_offset = (curr_som_offset + 0x1) &~ (unsigned) 1;
      curr_bfd = curr_bfd->next;
      som_index++;
    }

  /* Now scribble out the hash table.  */
  amt = lst.hash_size * 4;
  if (bfd_bwrite ((PTR) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Then the SOM dictionary.  */
  amt = lst.module_count * sizeof (struct som_entry);
  if (bfd_bwrite ((PTR) som_dict, amt, abfd) != amt)
    goto error_return;

  /* The library symbols.  */
  amt = nsyms * sizeof (struct lst_symbol_record);
  if (bfd_bwrite ((PTR) lst_syms, amt, abfd) != amt)
    goto error_return;

  /* And finally the strings.  */
  amt = string_size;
  if (bfd_bwrite ((PTR) strings, amt, abfd) != amt)
    goto error_return;

  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  if (last_hash_entry != NULL)
    free (last_hash_entry);
  if (lst_syms != NULL)
    free (lst_syms);
  if (strings != NULL)
    free (strings);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  if (last_hash_entry != NULL)
    free (last_hash_entry);
  if (lst_syms != NULL)
    free (lst_syms);
  if (strings != NULL)
    free (strings);

  return FALSE;
}

/* Write out the LST for the archive.

   You'll never believe this is really how armaps are handled in SOM...  */

static bfd_boolean
som_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength;
     struct orl *map ATTRIBUTE_UNUSED;
     unsigned int orl_count ATTRIBUTE_UNUSED;
     int stridx ATTRIBUTE_UNUSED;
{
  bfd *curr_bfd;
  struct stat statbuf;
  unsigned int i, lst_size, nsyms, stringsize;
  struct ar_hdr hdr;
  struct lst_header lst;
  int *p;
  bfd_size_type amt;

  /* We'll use this for the archive's date and mode later.  */
  if (stat (abfd->filename, &statbuf) != 0)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }
  /* Fudge factor.  */
  bfd_ardata (abfd)->armap_timestamp = statbuf.st_mtime + 60;

  /* Account for the lst header first.  */
  lst_size = sizeof (struct lst_header);

  /* Start building the LST header.  */
  /* FIXME:  Do we need to examine each element to determine the
     largest id number?  */
  lst.system_id = CPU_PA_RISC1_0;
  lst.a_magic = LIBMAGIC;
  lst.version_id = VERSION_ID;
  lst.file_time.secs = 0;
  lst.file_time.nanosecs = 0;

  lst.hash_loc = lst_size;
  lst.hash_size = SOM_LST_HASH_SIZE;

  /* Hash table is a SOM_LST_HASH_SIZE 32bit offsets.  */
  lst_size += 4 * SOM_LST_HASH_SIZE;

  /* We need to count the number of SOMs in this archive.  */
  curr_bfd = abfd->archive_head;
  lst.module_count = 0;
  while (curr_bfd != NULL)
    {
      /* Only true SOM objects count.  */
      if (curr_bfd->format == bfd_object
	  && curr_bfd->xvec->flavour == bfd_target_som_flavour)
	lst.module_count++;
      curr_bfd = curr_bfd->next;
    }
  lst.module_limit = lst.module_count;
  lst.dir_loc = lst_size;
  lst_size += sizeof (struct som_entry) * lst.module_count;

  /* We don't support import/export tables, auxiliary headers,
     or free lists yet.  Make the linker work a little harder
     to make our life easier.  */

  lst.export_loc = 0;
  lst.export_count = 0;
  lst.import_loc = 0;
  lst.aux_loc = 0;
  lst.aux_size = 0;

  /* Count how many symbols we will have on the hash chains and the
     size of the associated string table.  */
  if (! som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize))
    return FALSE;

  lst_size += sizeof (struct lst_symbol_record) * nsyms;

  /* For the string table.  One day we might actually use this info
     to avoid small seeks/reads when reading archives.  */
  lst.string_loc = lst_size;
  lst.string_size = stringsize;
  lst_size += stringsize;

  /* SOM ABI says this must be zero.  */
  lst.free_list = 0;
  lst.file_end = lst_size;

  /* Compute the checksum.  Must happen after the entire lst header
     has filled in.  */
  p = (int *) &lst;
  lst.checksum = 0;
  for (i = 0; i < sizeof (struct lst_header) / sizeof (int) - 1; i++)
    lst.checksum ^= *p++;

  sprintf (hdr.ar_name, "/               ");
  sprintf (hdr.ar_date, "%lld", (long long)bfd_ardata (abfd)->armap_timestamp);
  sprintf (hdr.ar_uid, "%ld", (long) getuid ());
  sprintf (hdr.ar_gid, "%ld", (long) getgid ());
  sprintf (hdr.ar_mode, "%-8o", (unsigned int) statbuf.st_mode);
  sprintf (hdr.ar_size, "%-10d", (int) lst_size);
  hdr.ar_fmag[0] = '`';
  hdr.ar_fmag[1] = '\012';

  /* Turn any nulls into spaces.  */
  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Scribble out the ar header.  */
  amt = sizeof (struct ar_hdr);
  if (bfd_bwrite ((PTR) &hdr, amt, abfd) != amt)
    return FALSE;

  /* Now scribble out the lst header.  */
  amt = sizeof (struct lst_header);
  if (bfd_bwrite ((PTR) &lst, amt, abfd) != amt)
    return FALSE;

  /* Build and write the armap.  */
  if (!som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength))
    return FALSE;

  /* Done.  */
  return TRUE;
}

/* Free all information we have cached for this BFD.  We can always
   read it again later if we need it.  */

static bfd_boolean
som_bfd_free_cached_info (abfd)
     bfd *abfd;
{
  asection *o;

  if (bfd_get_format (abfd) != bfd_object)
    return TRUE;

#define FREE(x) if (x != NULL) { free (x); x = NULL; }
  /* Free the native string and symbol tables.  */
  FREE (obj_som_symtab (abfd));
  FREE (obj_som_stringtab (abfd));
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      /* Free the native relocations.  */
      o->reloc_count = (unsigned) -1;
      FREE (som_section_data (o)->reloc_stream);
      /* Free the generic relocations.  */
      FREE (o->relocation);
    }
#undef FREE

  return TRUE;
}

/* End of miscellaneous support functions.  */

/* Linker support functions.  */

static bfd_boolean
som_bfd_link_split_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
{
  return (som_is_subspace (sec) && sec->_raw_size > 240000);
}

#define	som_close_and_cleanup		som_bfd_free_cached_info

#define som_read_ar_hdr			_bfd_generic_read_ar_hdr
#define som_openr_next_archived_file	bfd_generic_openr_next_archived_file
#define som_get_elt_at_index		_bfd_generic_get_elt_at_index
#define som_generic_stat_arch_elt	bfd_generic_stat_arch_elt
#define som_truncate_arname		bfd_bsd_truncate_arname
#define som_slurp_extended_name_table	_bfd_slurp_extended_name_table
#define som_construct_extended_name_table \
  _bfd_archive_coff_construct_extended_name_table
#define som_update_armap_timestamp	bfd_true
#define som_bfd_print_private_bfd_data  _bfd_generic_bfd_print_private_bfd_data

#define som_get_lineno			_bfd_nosymbols_get_lineno
#define som_bfd_make_debug_symbol	_bfd_nosymbols_bfd_make_debug_symbol
#define som_read_minisymbols		_bfd_generic_read_minisymbols
#define som_minisymbol_to_symbol	_bfd_generic_minisymbol_to_symbol
#define som_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define som_bfd_get_relocated_section_contents \
 bfd_generic_get_relocated_section_contents
#define som_bfd_relax_section bfd_generic_relax_section
#define som_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define som_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define som_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define som_bfd_link_just_syms _bfd_generic_link_just_syms
#define som_bfd_final_link _bfd_generic_final_link

#define som_bfd_gc_sections		bfd_generic_gc_sections
#define som_bfd_merge_sections		bfd_generic_merge_sections
#define som_bfd_discard_group		bfd_generic_discard_group

const bfd_target som_vec = {
  "som",			/* name */
  bfd_target_som_flavour,
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED | DYNAMIC),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),		/* section flags */

/* leading_symbol_char: is the first char of a user symbol
   predictable, and if so what is it.  */
  0,
  '/',				/* ar_pad_char */
  14,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
  {_bfd_dummy_target,
   som_object_p,		/* bfd_check_format */
   bfd_generic_archive_p,
   _bfd_dummy_target
  },
  {
    bfd_false,
    som_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {
    bfd_false,
    som_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },
#undef som

  BFD_JUMP_TABLE_GENERIC (som),
  BFD_JUMP_TABLE_COPY (som),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (som),
  BFD_JUMP_TABLE_SYMBOLS (som),
  BFD_JUMP_TABLE_RELOCS (som),
  BFD_JUMP_TABLE_WRITE (som),
  BFD_JUMP_TABLE_LINK (som),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};

#endif /* HOST_HPPAHPUX || HOST_HPPABSD || HOST_HPPAOSF */
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d6252 1
a6252 1
  sprintf (hdr.ar_date, "%ld", bfd_ardata (abfd)->armap_timestamp);
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d178 1
a178 1
static long som_get_symtab
d1718 1
a1718 1
	   will be eliminted as the relocs are sized and emitted.  */
d2483 1
a2483 1
/* Return TRUE if the given space containins the given subspace.  It
d2737 1
a2737 1
	     finised with it.  */
d3203 1
a3203 1
     write them and update the compliation unit header.  On input, the
d3909 1
a3909 1
  /* All the subspace dictiondary records are written, and all the
d3981 1
a3981 1
	 to be compatable with how the hp linker makes objects
d4523 1
a4523 1
som_get_symtab (abfd, location)
d5783 1
a5783 1
  /* Initializae the cache and allocate space for the library symbols.  */
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d34 1
a39 1
#include <ctype.h>
d41 1
a41 1
/* Magic not defined in standard HP-UX header files until 8.0 */
d105 1
a105 1
  (((val) + (alignment) - 1) & ~((alignment) - 1))
d151 1
a151 1
/* Forward declarations */
d153 39
a191 29
static boolean som_mkobject PARAMS ((bfd *));
static const bfd_target * som_object_setup PARAMS ((bfd *,
						    struct header *,
						    struct som_exec_auxhdr *,
						    unsigned long));
static boolean setup_sections PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p PARAMS ((bfd *));
static boolean som_write_object_contents PARAMS ((bfd *));
static boolean som_slurp_string_table PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table PARAMS ((bfd *));
static long som_get_symtab_upper_bound PARAMS ((bfd *));
static long som_canonicalize_reloc PARAMS ((bfd *, sec_ptr,
					    arelent **, asymbol **));
static long som_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info PARAMS ((unsigned char *, unsigned int,
						arelent *, asection *,
						asymbol **, boolean));
static boolean som_slurp_reloc_table PARAMS ((bfd *, asection *,
					      asymbol **, boolean));
static long som_get_symtab PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol PARAMS ((bfd *));
static void som_print_symbol PARAMS ((bfd *, PTR,
				      asymbol *, bfd_print_symbol_type));
static boolean som_new_section_hook PARAMS ((bfd *, asection *));
static boolean som_bfd_copy_private_symbol_data PARAMS ((bfd *, asymbol *,
							  bfd *, asymbol *));
static boolean som_bfd_copy_private_section_data PARAMS ((bfd *, asection *,
							  bfd *, asection *));
static boolean som_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d194 67
a260 58
static boolean som_bfd_is_local_label_name PARAMS ((bfd *, const char *));
static boolean som_set_section_contents PARAMS ((bfd *, sec_ptr, PTR,
						 file_ptr, bfd_size_type));
static boolean som_get_section_contents PARAMS ((bfd *, sec_ptr, PTR,
						 file_ptr, bfd_size_type));
static boolean som_set_arch_mach PARAMS ((bfd *, enum bfd_architecture,
					  unsigned long));
static boolean som_find_nearest_line PARAMS ((bfd *, asection *,
					      asymbol **, bfd_vma,
					      CONST char **,
					      CONST char **,
					      unsigned int *));
static void som_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol PARAMS ((bfd *,
					struct symbol_dictionary_record *));
static int log2 PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc PARAMS ((bfd *, arelent *,
						     asymbol *, PTR,
						     asection *, bfd *,
						     char **));
static void som_initialize_reloc_queue PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert PARAMS ((unsigned char *, unsigned int,
					    struct reloc_queue *));
static void som_reloc_queue_fix PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find PARAMS ((unsigned char *, unsigned int,
					 struct reloc_queue *));
static unsigned char * try_prev_fixup PARAMS ((bfd *, int *, unsigned char *,
					       unsigned int,
					       struct reloc_queue *));

static unsigned char * som_reloc_skip PARAMS ((bfd *, unsigned int,
					       unsigned char *, unsigned int *,
					       struct reloc_queue *));
static unsigned char * som_reloc_addend PARAMS ((bfd *, int, unsigned char *,
					         unsigned int *,
						 struct reloc_queue *));
static unsigned char * som_reloc_call PARAMS ((bfd *, unsigned char *,
					       unsigned int *,
					       arelent *, int,
					       struct reloc_queue *));
static unsigned long som_count_spaces PARAMS ((bfd *));
static unsigned long som_count_subspaces PARAMS ((bfd *));
static int compare_syms PARAMS ((const void *, const void *));
static int compare_subspaces PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum PARAMS ((bfd *));
static boolean som_prep_headers PARAMS ((bfd *));
static int som_sizeof_headers PARAMS ((bfd *, boolean));
static boolean som_finish_writing PARAMS ((bfd *));
static boolean som_build_and_write_symbol_table PARAMS ((bfd *));
static void som_prep_for_fixups PARAMS ((bfd *, asymbol **, unsigned long));
static boolean som_write_fixups PARAMS ((bfd *, unsigned long, unsigned int *));
static boolean som_write_space_strings PARAMS ((bfd *, unsigned long,
						unsigned int *));
static boolean som_write_symbol_strings PARAMS ((bfd *, unsigned long,
						 asymbol **, unsigned int,
						 unsigned *,
						 COMPUNIT *));
static boolean som_begin_writing PARAMS ((bfd *));
d262 32
a293 25
	PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type PARAMS ((const char *));
static int som_decode_symclass PARAMS ((asymbol *));
static boolean som_bfd_count_ar_symbols PARAMS ((bfd *, struct lst_header *,
						 symindex *));

static boolean som_bfd_fill_in_ar_symbols PARAMS ((bfd *, struct lst_header *,
						   carsym **syms));
static boolean som_slurp_armap PARAMS ((bfd *));
static boolean som_write_armap PARAMS ((bfd *, unsigned int, struct orl *,
					unsigned int, int));
static void som_bfd_derive_misc_symbol_info PARAMS ((bfd *, asymbol *,
					     struct som_misc_symbol_info *));
static boolean som_bfd_prep_for_ar_write PARAMS ((bfd *, unsigned int *,
						  unsigned int *));
static unsigned int som_bfd_ar_symbol_hash PARAMS ((asymbol *));
static boolean som_bfd_ar_write_symbol_stuff PARAMS ((bfd *, unsigned int,
						      unsigned int,
						      struct lst_header,
						      unsigned int));
static boolean som_is_space PARAMS ((asection *));
static boolean som_is_subspace PARAMS ((asection *));
static boolean som_is_container PARAMS ((asection *, asection *));
static boolean som_bfd_free_cached_info PARAMS ((bfd *));
static boolean som_bfd_link_split_section PARAMS ((bfd *, asection *));
d412 32
a443 32
  0,   "LD1+4*=",       /* 0x00 */
  1,   "LD1+4*=",	/* 0x01 */
  2,   "LD1+4*=",	/* 0x02 */
  3,   "LD1+4*=",	/* 0x03 */
  4,   "LD1+4*=",	/* 0x04 */
  5,   "LD1+4*=",	/* 0x05 */
  6,   "LD1+4*=",	/* 0x06 */
  7,   "LD1+4*=",	/* 0x07 */
  8,   "LD1+4*=",	/* 0x08 */
  9,   "LD1+4*=",	/* 0x09 */
  10,  "LD1+4*=",	/* 0x0a */
  11,  "LD1+4*=",	/* 0x0b */
  12,  "LD1+4*=",	/* 0x0c */
  13,  "LD1+4*=",	/* 0x0d */
  14,  "LD1+4*=",	/* 0x0e */
  15,  "LD1+4*=",	/* 0x0f */
  16,  "LD1+4*=",	/* 0x10 */
  17,  "LD1+4*=",	/* 0x11 */
  18,  "LD1+4*=",	/* 0x12 */
  19,  "LD1+4*=",	/* 0x13 */
  20,  "LD1+4*=",	/* 0x14 */
  21,  "LD1+4*=",	/* 0x15 */
  22,  "LD1+4*=",	/* 0x16 */
  23,  "LD1+4*=",	/* 0x17 */
  0,   "LD8<b+1+4*=",	/* 0x18 */
  1,   "LD8<b+1+4*=",	/* 0x19 */
  2,   "LD8<b+1+4*=",	/* 0x1a */
  3,   "LD8<b+1+4*=",	/* 0x1b */
  0,   "LD16<c+1+4*=",	/* 0x1c */
  1,   "LD16<c+1+4*=",	/* 0x1d */
  2,   "LD16<c+1+4*=",	/* 0x1e */
  0,   "Ld1+=",         /* 0x1f */
d445 2
a446 2
  0,    "Lb1+4*=",	/* 0x20 */
  1,    "Ld1+=",	/* 0x21 */
d448 2
a449 2
  0,    "Lb1+4*=",	/* 0x22 */
  1,    "Ld1+=",	/* 0x23 */
d451 1
a451 1
  0,    "L4=",          /* 0x24 */
d453 2
a454 2
  0,    "L4=Sb=",	/* 0x25 */
  1,    "L4=Sd=",	/* 0x26 */
d456 2
a457 2
  0,    "L4=Sb=",	/* 0x27 */
  1,    "L4=Sd=",	/* 0x28 */
d459 1
a459 1
  0,    "L4=",          /* 0x29 */
d461 6
a466 6
  0,    "L4=Mb1+4*=",	/* 0x2a */
  1,    "Lb4*=Mb1+L*=",	/* 0x2b */
  2,    "Lb4*=Md1+4*=",	/* 0x2c */
  3,    "Ld1+=Me1+=",	/* 0x2d */
  0,   	"",	        /* 0x2e */
  0,   	"",	        /* 0x2f */
d468 14
a481 14
  0,    "L4=RD=Sb=",	/* 0x30 */
  1,    "L4=RD=Sb=",	/* 0x31 */
  2,    "L4=RD=Sb=",	/* 0x32 */
  3,    "L4=RD=Sb=",	/* 0x33 */
  4,    "L4=RD=Sb=",	/* 0x34 */
  5,    "L4=RD=Sb=",	/* 0x35 */
  6,    "L4=RD=Sb=",	/* 0x36 */
  7,    "L4=RD=Sb=",	/* 0x37 */
  8,    "L4=RD=Sb=",	/* 0x38 */
  9,    "L4=RD=Sb=",	/* 0x39 */
  0,    "L4=RD8<b+=Sb=",/* 0x3a */
  1,    "L4=RD8<b+=Sb=",/* 0x3b */
  0,    "L4=RD8<b+=Sd=",/* 0x3c */
  1,    "L4=RD8<b+=Sd=",/* 0x3d */
d483 1
a483 1
  0,    "",	        /* 0x3e */
d485 1
a485 1
  0,    "",	        /* 0x3f */
d487 14
a500 14
  0,    "L4=RD=Sb=",	/* 0x40 */
  1,    "L4=RD=Sb=",	/* 0x41 */
  2,    "L4=RD=Sb=",	/* 0x42 */
  3,    "L4=RD=Sb=",	/* 0x43 */
  4,    "L4=RD=Sb=",	/* 0x44 */
  5,    "L4=RD=Sb=",	/* 0x45 */
  6,    "L4=RD=Sb=",	/* 0x46 */
  7,    "L4=RD=Sb=",	/* 0x47 */
  8,    "L4=RD=Sb=",	/* 0x48 */
  9,    "L4=RD=Sb=",	/* 0x49 */
  0,    "L4=RD8<b+=Sb=",/* 0x4a */
  1,    "L4=RD8<b+=Sb=",/* 0x4b */
  0,    "L4=RD8<b+=Sd=",/* 0x4c */
  1,    "L4=RD8<b+=Sd=",/* 0x4d */
d502 2
a503 2
  0,     "",	        /* 0x4e */
  0,     "",	        /* 0x4f */
d505 34
a538 34
  0,    "L4=SD=",	/* 0x50 */
  1,    "L4=SD=",	/* 0x51 */
  2,    "L4=SD=",	/* 0x52 */
  3,    "L4=SD=",	/* 0x53 */
  4,    "L4=SD=",	/* 0x54 */
  5,    "L4=SD=",	/* 0x55 */
  6,    "L4=SD=",	/* 0x56 */
  7,    "L4=SD=",	/* 0x57 */
  8,    "L4=SD=",	/* 0x58 */
  9,    "L4=SD=",	/* 0x59 */
  10,   "L4=SD=",	/* 0x5a */
  11,   "L4=SD=",	/* 0x5b */
  12,   "L4=SD=",	/* 0x5c */
  13,   "L4=SD=",	/* 0x5d */
  14,   "L4=SD=",	/* 0x5e */
  15,   "L4=SD=",	/* 0x5f */
  16,   "L4=SD=",	/* 0x60 */
  17,   "L4=SD=",	/* 0x61 */
  18,   "L4=SD=",	/* 0x62 */
  19,   "L4=SD=",	/* 0x63 */
  20,   "L4=SD=",	/* 0x64 */
  21,   "L4=SD=",	/* 0x65 */
  22,   "L4=SD=",	/* 0x66 */
  23,   "L4=SD=",	/* 0x67 */
  24,   "L4=SD=",	/* 0x68 */
  25,   "L4=SD=",	/* 0x69 */
  26,   "L4=SD=",	/* 0x6a */
  27,   "L4=SD=",	/* 0x6b */
  28,   "L4=SD=",	/* 0x6c */
  29,   "L4=SD=",	/* 0x6d */
  30,   "L4=SD=",	/* 0x6e */
  31,   "L4=SD=",	/* 0x6f */
  32,   "L4=Sb=",	/* 0x70 */
  33,   "L4=Sd=",	/* 0x71 */
d540 6
a545 6
  0,    "",	        /* 0x72 */
  0,    "",	        /* 0x73 */
  0,    "",	        /* 0x74 */
  0,    "",	        /* 0x75 */
  0,    "",	        /* 0x76 */
  0,    "",      	/* 0x77 */
d547 2
a548 2
  0,    "L4=Sb=",	/* 0x78 */
  1,    "L4=Sd=",	/* 0x79 */
d550 6
a555 6
  0,    "",        	/* 0x7a */
  0,    "",	        /* 0x7b */
  0,    "",	        /* 0x7c */
  0,    "",	        /* 0x7d */
  0,    "",	        /* 0x7e */
  0,    "",	        /* 0x7f */
d557 34
a590 34
  0,    "L4=SD=",	/* 0x80 */
  1,    "L4=SD=",	/* 0x81 */
  2,    "L4=SD=",	/* 0x82 */
  3,    "L4=SD=",	/* 0x83 */
  4,    "L4=SD=",	/* 0x84 */
  5,    "L4=SD=",	/* 0x85 */
  6,    "L4=SD=",	/* 0x86 */
  7,    "L4=SD=",	/* 0x87 */
  8,    "L4=SD=",	/* 0x88 */
  9,    "L4=SD=",	/* 0x89 */
  10,   "L4=SD=",	/* 0x8q */
  11,   "L4=SD=",	/* 0x8b */
  12,   "L4=SD=",	/* 0x8c */
  13,   "L4=SD=",	/* 0x8d */
  14,   "L4=SD=",	/* 0x8e */
  15,   "L4=SD=",	/* 0x8f */
  16,   "L4=SD=",	/* 0x90 */
  17,   "L4=SD=",	/* 0x91 */
  18,   "L4=SD=",	/* 0x92 */
  19,   "L4=SD=",	/* 0x93 */
  20,   "L4=SD=",	/* 0x94 */
  21,   "L4=SD=",	/* 0x95 */
  22,   "L4=SD=",	/* 0x96 */
  23,   "L4=SD=",	/* 0x97 */
  24,   "L4=SD=",	/* 0x98 */
  25,   "L4=SD=",	/* 0x99 */
  26,   "L4=SD=",	/* 0x9a */
  27,   "L4=SD=",	/* 0x9b */
  28,   "L4=SD=",	/* 0x9c */
  29,   "L4=SD=",	/* 0x9d */
  30,   "L4=SD=",	/* 0x9e */
  31,   "L4=SD=",	/* 0x9f */
  32,   "L4=Sb=",	/* 0xa0 */
  33,   "L4=Sd=",	/* 0xa1 */
d592 12
a603 12
  0,    "",	        /* 0xa2 */
  0,    "",	        /* 0xa3 */
  0,    "",	        /* 0xa4 */
  0,    "",	        /* 0xa5 */
  0,    "",	        /* 0xa6 */
  0,    "",	        /* 0xa7 */
  0,    "",	        /* 0xa8 */
  0,    "",	        /* 0xa9 */
  0,    "",	        /* 0xaa */
  0,    "",	        /* 0xab */
  0,    "",	        /* 0xac */
  0,    "",	        /* 0xad */
d605 2
a606 2
  0,    "L4=Sb=",	/* 0xae */
  1,    "L4=Sd=",	/* 0xaf */
d608 2
a609 2
  0,    "L4=Sb=",	/* 0xb0 */
  1,    "L4=Sd=",	/* 0xb1 */
d611 1
a611 1
  0,    "L4=",	        /* 0xb2 */
d613 2
a614 2
  0,    "Te=Ue=",       /* 0xb3 */
  1,    "Uf=",	        /* 0xb4 */
d616 1
a616 1
  0,    "",	        /* 0xb5 */
d618 1
a618 1
  0,    "",		/* 0xb6 */
d620 1
a620 1
  0,    "",	        /* 0xb7 */
d622 3
a624 3
  0,    "R0=",	        /* 0xb8 */
  1,    "Rb4*=",	/* 0xb9 */
  2,    "Rd4*=",	/* 0xba */
d626 1
a626 1
  0,    "",	        /* 0xbb */
d628 1
a628 1
  0,    "",	        /* 0xbc */
d630 3
a632 3
  0,    "Nb=",	        /* 0xbd */
  1,    "Nc=",	        /* 0xbe */
  2,    "Nd=",	        /* 0xbf */
d634 1
a634 1
  0,    "L4=",	        /* 0xc0 */
d636 1
a636 1
  0,    "L4=",	        /* 0xc1 */
d638 1
a638 1
  0,    "",		/* 0xc2 */
d640 1
a640 1
  0,    "",		/* 0xc3 */
d642 1
a642 1
  0,    "",		/* 0xc4 */
d644 1
a644 1
  0,    "",		/* 0xc5 */
d646 1
a646 1
  0,    "",		/* 0xc6 */
d648 1
a648 1
  0,    "",		/* 0xc7 */
d650 1
a650 1
  0,    "",		/* 0xc8 */
d652 5
a656 5
  0,    "V0=",	        /* 0xc9 */
  1,    "Vb=",	        /* 0xca */
  2,    "Vc=",	        /* 0xcb */
  3,    "Vd=",	        /* 0xcc */
  4,    "Ve=",	        /* 0xcd */
d658 1
a658 1
  0,    "",	        /* 0xce */
d660 1
a660 1
  0,    "Sd=Vf=Ef=",    /* 0xcf */
d662 1
a662 1
  0,    "Ob=",	        /* 0xd0 */
d664 1
a664 1
  0,    "Ob=Sd=",	/* 0xd1 */
d666 1
a666 1
  0,    "Ob=Ve=",	/* 0xd2 */
d668 4
a671 4
  0,    "P",   	        /* 0xd3 */
  1,    "P",	        /* 0xd4 */
  2,    "P",	        /* 0xd5 */
  3,    "P",	        /* 0xd6 */
d673 1
a673 1
  0,	"",		/* 0xd7 */
d675 1
a675 1
  0,	"",		/* 0xd8 */
d677 1
a677 1
  0,	"",		/* 0xd9 */
d679 1
a679 1
  0,	"Eb=Sd=Ve=",	/* 0xda */
d681 1
a681 1
  0,	"Eb=Mb=",	/* 0xdb */
d683 1
a683 1
  0,	"",		/* 0xdc */
d685 1
a685 1
  0,    "Ob=Ve=",	/* 0xdd */
d687 34
a720 34
  0,	"",		/* 0xde */
  0,	"",		/* 0xdf */
  0,	"",		/* 0xe0 */
  0,	"",		/* 0xe1 */
  0,	"",		/* 0xe2 */
  0,	"",		/* 0xe3 */
  0,	"",		/* 0xe4 */
  0,	"",		/* 0xe5 */
  0,	"",		/* 0xe6 */
  0,	"",		/* 0xe7 */
  0,	"",		/* 0xe8 */
  0,	"",		/* 0xe9 */
  0,	"",		/* 0xea */
  0,	"",		/* 0xeb */
  0,	"",		/* 0xec */
  0,	"",		/* 0xed */
  0,	"",		/* 0xee */
  0,	"",		/* 0xef */
  0,	"",		/* 0xf0 */
  0,	"",		/* 0xf1 */
  0,	"",		/* 0xf2 */
  0,	"",		/* 0xf3 */
  0,	"",		/* 0xf4 */
  0,	"",		/* 0xf5 */
  0,	"",		/* 0xf6 */
  0,	"",		/* 0xf7 */
  0,	"",		/* 0xf8 */
  0,	"",		/* 0xf9 */
  0,	"",		/* 0xfa */
  0,	"",		/* 0xfb */
  0,	"",		/* 0xfc */
  0,	"",		/* 0xfd */
  0,	"",		/* 0xfe */
  0,	"",		/* 0xff */
d806 1
a806 1
  HOWTO(TYPE, 0, 0, 32, false, 0, 0, hppa_som_reloc, NAME, false, 0, 0, false)
d1227 1
a1227 1
      bfd_put_16 (abfd, 0xffff, p + 2);
d1263 1
a1263 1
	  bfd_put_16 (abfd, (skip >> 2) - 1, p + 1);
d1272 1
a1272 1
      bfd_put_16 (abfd, skip - 1, p + 2);
d1286 1
a1286 1
     int addend;
d1291 1
a1291 1
  if ((unsigned) (addend) + 0x80 < 0x100)
d1297 1
a1297 1
  else if ((unsigned) (addend) + 0x8000 < 0x10000)
d1303 1
a1303 1
  else if ((unsigned) (addend) + 0x800000 < 0x1000000)
d1424 1
a1424 1
	  bfd_put_16 (abfd, sym_num, p + 3);
d1482 2
a1483 2
  final_types = (int **) bfd_alloc (abfd, sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, sizeof (int));
d1507 1
a1507 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1523 1
a1523 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1534 1
a1534 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1545 1
a1545 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1556 1
a1556 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1566 1
a1566 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1577 1
a1577 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1581 1
a1581 1
      final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
d1600 5
a1604 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1681 5
a1685 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1719 2
a1720 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1768 1
a1768 1
  if (som_mkobject (abfd) != true)
d1805 1
a1805 1
    bfd_zalloc (abfd, sizeof (struct som_exec_data));
d1842 2
d1870 1
a1870 1
static boolean
d1879 3
a1881 1
  asection **subspace_sections, *section;
d1885 3
a1887 2
  space_strings = bfd_malloc (file_hdr->space_strings_size);
  if (!space_strings && file_hdr->space_strings_size != 0)
d1891 1
a1891 1
		SEEK_SET) < 0)
d1893 1
a1893 2
  if (bfd_read (space_strings, 1, file_hdr->space_strings_size, abfd)
      != file_hdr->space_strings_size)
d1909 1
a1909 1
		    SEEK_SET) < 0)
d1911 2
a1912 1
      if (bfd_read (&space, 1, sizeof space, abfd) != sizeof space)
d1919 2
a1920 1
      newname = bfd_alloc (abfd, strlen (space.name.n_name) + 1);
d1933 3
a1935 3
      if (bfd_som_set_section_attributes (space_asect, space.is_defined,
					  space.is_private, space.sort_key,
					  space.space_number) == false)
d1946 1
a1946 1
		    SEEK_SET) < 0)
d1948 2
a1949 1
      if (bfd_read (&subspace, 1, sizeof subspace, abfd) != sizeof subspace)
d1955 1
a1955 1
		    SEEK_SET) < 0)
d1959 1
a1959 1
         record.  */
d1963 1
a1963 1
      if (space_asect->alignment_power == -1)
d1977 2
a1978 2
	  if (bfd_read (&subspace, 1, sizeof subspace, abfd)
	      != sizeof subspace)
d1984 2
a1985 1
	  newname = bfd_alloc (abfd, strlen (subspace.name.n_name) + 1);
d1996 4
a1999 4
	  if (bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						 subspace.access_control_bits,
						 subspace.sort_key,
						 subspace.quadrant) == false)
d2076 1
a2076 1
	      subspace_asect->reloc_count = -1;
d2089 1
a2089 1
	  if (subspace_asect->alignment_power == -1)
d2094 1
a2094 1
         empty subspaces.  */
d2114 3
a2116 2
  subspace_sections = (asection **) bfd_malloc (total_subspaces
						* sizeof (asection *));
d2142 1
a2142 1
  return true;
d2150 1
a2150 1
  return false;
d2164 1
d2167 2
a2168 1
  if (bfd_read ((PTR) & file_hdr, 1, FILE_HDR_SIZE, abfd) != FILE_HDR_SIZE)
d2202 1
a2202 1
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
d2209 2
a2210 1
      if (bfd_read ((PTR) & lst_header, 1, SLSTHDR, abfd) != SLSTHDR)
d2219 1
a2219 1
      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) < 0)
d2226 2
a2227 1
      if (bfd_read ((PTR) & som_entry, 1, ENTRY_SIZE, abfd) != ENTRY_SIZE)
d2236 1
a2236 1
      if (bfd_seek (abfd, som_entry.location, SEEK_SET) < 0)
d2246 2
a2247 2

      if (bfd_read ((PTR) & file_hdr, 1, FILE_HDR_SIZE, abfd) != FILE_HDR_SIZE)
d2275 2
a2276 1
      if (bfd_read ((PTR) & aux_hdr, 1, AUX_HDR_SIZE, abfd) != AUX_HDR_SIZE)
d2297 1
a2297 1
static boolean
d2303 1
a2303 1
    bfd_zalloc (abfd, sizeof (struct som_data_struct));
d2305 2
a2306 2
    return false;
  return true;
d2313 1
a2313 1
static boolean
d2319 1
d2322 1
a2322 1
  file_hdr = (struct header *) bfd_zalloc (abfd, sizeof (struct header));
d2324 1
a2324 1
    return false;
a2328 1

d2330 3
a2332 2
      obj_som_exec_hdr (abfd) = (struct som_exec_auxhdr *)
	bfd_zalloc (abfd, sizeof (struct som_exec_auxhdr));
d2334 1
a2334 1
	return false;
a2349 3
  /* Only new format SOM is supported.  */
  file_hdr->version_id = NEW_VERSION_ID;

d2374 1
d2376 1
a2376 2
	    (struct space_dictionary_record *)
	    bfd_zalloc (abfd, sizeof (struct space_dictionary_record));
d2378 1
a2378 1
	    return false;
d2397 3
a2399 3
	  som_section_data (section)->subspace_dict
	    = (struct subspace_dictionary_record *)
	      bfd_zalloc (abfd, sizeof (struct subspace_dictionary_record));
d2401 1
a2401 1
	    return false;
d2436 1
a2436 1
  return true;
d2439 1
a2439 1
/* Return true if the given section is a SOM space, false otherwise.  */
d2441 1
a2441 1
static boolean
d2448 1
a2448 1
    return false;
d2455 1
a2455 1
    return false;
d2458 1
a2458 1
  return true;
d2461 1
a2461 1
/* Return true if the given section is a SOM subspace, false otherwise.  */
d2463 1
a2463 1
static boolean
d2470 1
a2470 1
    return false;
d2477 1
a2477 1
    return false;
d2480 1
a2480 1
  return true;
d2483 1
a2483 1
/* Return true if the given space containins the given subspace.  It
d2487 1
a2487 1
static boolean
d2590 1
a2590 1
  int i;
d2593 1
d2619 1
a2619 1
      int i;
d2622 1
a2622 1
      if (section->reloc_count <= 0)
d2626 1
a2626 1
      for (i = 1; i < section->reloc_count; i++)
d2628 1
a2628 1
	  arelent *reloc = section->orelocation[i];
d2665 3
a2667 1
  sorted_syms = (asymbol **) bfd_zalloc (abfd, num_syms * sizeof (asymbol *));
d2685 1
a2685 1
static boolean
d2700 1
d2725 2
a2726 1
	  int reloc_offset, current_rounding_mode;
d2754 2
a2755 2
	  if (bfd_seek (abfd, current_offset + total_reloc_size, SEEK_SET) < 0)
	    return false;
d2792 3
a2794 3
		  if (bfd_write ((PTR) tmp_space, p - tmp_space, 1, abfd)
		      != p - tmp_space)
		    return false;
d2876 1
a2876 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2905 1
a2905 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2915 1
a2915 1
		    int tmp;
d2988 1
a2988 1
		  /* The end of a exception handling region.  The reloc's
d3027 1
a3027 1
		  bfd_put_16 (abfd, sym_num, p + 3);
d3055 2
a3056 2
	  p = som_reloc_skip (abfd, bfd_section_size (abfd, subsection)
			              - reloc_offset,
d3060 3
a3062 3
	  if (bfd_write ((PTR) tmp_space, p - tmp_space, 1, abfd)
	      != p - tmp_space)
	    return false;
d3072 1
a3072 1
  return true;
d3077 1
a3077 1
static boolean
d3090 1
d3094 2
a3095 2
  if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
    return false;
d3112 3
a3114 3
         current buffer contents now and maybe allocate a larger
         buffer.  Each entry will take 4 bytes to hold the string
         length + the string itself + null terminator.  */
d3118 3
a3120 3
	  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
	      != p - tmp_space)
	    return false;
d3126 7
a3132 7
                 consumption for n strings.  The optimal minimum
                 factor seems to be 2, as no other value can guarantee
                 wasting less then 50% space.  (Note that we cannot
                 deallocate space allocated by `alloca' without
                 returning from this function.)  The same technique is
                 used a few more times below when a buffer is
                 reallocated.  */
d3143 1
a3143 1
      bfd_put_32 (abfd, length, p);
d3169 3
a3171 2
  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd) != p - tmp_space)
    return false;
d3173 1
a3173 1
  return true;
d3178 1
a3178 1
static boolean
d3198 1
d3216 2
a3217 2
  if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
    return false;
d3231 3
a3233 3
	      if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
		  != p - tmp_space)
		return false;
d3244 1
a3244 1
                 space.  */
d3252 1
a3252 1
	  bfd_put_32 (abfd, length, p);
d3300 3
a3302 3
	  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
	      != p - tmp_space)
	    return false;
d3320 1
a3320 1
      bfd_put_32 (abfd, length, p);
d3341 3
a3343 2
  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd) != p - tmp_space)
    return false;
d3346 1
a3346 1
  return true;
d3353 1
a3353 1
static boolean
d3396 1
a3396 1
      unsigned int len;
d3398 2
a3399 2
      if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
	return false;
d3405 2
a3406 2
      if (bfd_write ((PTR) obj_som_version_hdr (abfd), len, 1, abfd) != len)
	return false;
d3412 3
a3414 3
      if (bfd_write ((PTR) obj_som_version_hdr (abfd)->user_string,
		     len, 1, abfd) != len)
	return false;
d3419 1
a3419 1
      unsigned int len;
d3421 2
a3422 2
      if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
	return false;
d3428 2
a3429 2
      if (bfd_write ((PTR) obj_som_copyright_hdr (abfd), len, 1, abfd) != len)
	return false;
d3435 3
a3437 3
      if (bfd_write ((PTR) obj_som_copyright_hdr (abfd)->copyright,
		     len, 1, abfd) != len)
	return false;
d3484 2
a3485 2
  if (som_write_space_strings (abfd, current_offset, &strings_size) == false)
    return false;
d3681 4
a3684 4
  if (bfd_seek (abfd, current_offset - 1, SEEK_SET) < 0)
    return false;
  if (bfd_write ((PTR) "", 1, 1, abfd) != 1)
    return false;
d3696 1
a3696 1
  return true;
d3701 1
a3701 1
static boolean
d3713 9
d3754 4
a3757 5
  if (som_write_symbol_strings (abfd, current_offset, syms,
				num_syms, &strings_size,
				obj_som_compilation_unit (abfd))
      == false)
    return false;
d3777 2
a3778 2
  if (som_write_fixups (abfd, current_offset, &total_reloc_size) == false)
    return false;
d3788 2
a3789 2
  if (som_build_and_write_symbol_table (abfd) == false)
    return false;
d3796 2
a3797 2
  if (bfd_seek (abfd, location, SEEK_SET) < 0)
    return false;
d3844 4
a3847 4
	  if (bfd_write ((PTR) som_section_data (subsection)->subspace_dict,
			 sizeof (struct subspace_dictionary_record), 1, abfd)
	      != sizeof (struct subspace_dictionary_record))
	    return false;
d3900 4
a3903 4
	  if (bfd_write ((PTR) som_section_data (subsection)->subspace_dict,
			 sizeof (struct subspace_dictionary_record), 1, abfd)
	      != sizeof (struct subspace_dictionary_record))
	    return false;
d3915 2
a3916 2
  if (bfd_seek (abfd, location, SEEK_SET) < 0)
    return false;
d3926 4
a3929 4
      if (bfd_write ((PTR) som_section_data (section)->space_dict,
		     sizeof (struct space_dictionary_record), 1, abfd)
	  != sizeof (struct space_dictionary_record))
	return false;
d3939 2
a3940 2
      if (bfd_seek (abfd, location, SEEK_SET) < 0)
	return false;
d3942 3
a3944 3
      if (bfd_write ((PTR) obj_som_compilation_unit (abfd),
		     COMPUNITSZ, 1, abfd) != COMPUNITSZ)
	return false;
d3964 5
a3968 6
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
    return false;
  if (bfd_write ((PTR) obj_som_file_hdr (abfd),
		 sizeof (struct header), 1, abfd)
      != sizeof (struct header))
    return false;
d3997 1
a3997 1
	  return false;
d4001 2
a4002 2
		    SEEK_SET) < 0)
	return false;
d4004 3
a4006 3
      if (bfd_write ((PTR) exec_header, AUX_HDR_SIZE, 1, abfd)
	  != AUX_HDR_SIZE)
	return false;
d4008 1
a4008 1
  return true;
d4143 1
a4143 1
    info->secondary_def = true;
d4145 1
a4145 1
    info->secondary_def = false;
d4152 1
a4152 1
static boolean
d4160 2
a4161 1
  int i, symtab_size;
d4165 3
a4167 2
  symtab_size = num_syms * sizeof (struct symbol_dictionary_record);
  som_symtab = (struct symbol_dictionary_record *) bfd_malloc (symtab_size);
a4169 1
  memset (som_symtab, 0, symtab_size);
d4197 1
a4197 1
    return false;
d4199 1
a4199 1
  if (bfd_write ((PTR) som_symtab, symtab_size, 1, abfd) != symtab_size)
d4204 1
a4204 1
  return true;
d4208 1
a4208 1
  return false;
d4213 1
a4213 1
static boolean
d4217 1
a4217 1
  if (abfd->output_has_begun == false)
d4222 1
a4222 1
      abfd->output_has_begun = true;
d4233 1
a4233 1
static boolean
d4238 1
d4242 1
a4242 1
    return true;
d4250 1
a4250 1
      return false;
d4254 2
a4255 1
  stringtab = bfd_malloc (obj_som_stringtab_size (abfd));
d4257 1
a4257 2
    return false;
  memset (stringtab, 0, obj_som_stringtab_size (abfd));
d4259 2
a4260 2
  if (bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET) < 0)
    return false;
d4262 2
a4263 3
  if (bfd_read (stringtab, obj_som_stringtab_size (abfd), 1, abfd)
      != obj_som_stringtab_size (abfd))
    return false;
d4267 1
a4267 1
  return true;
d4343 1
d4358 3
a4360 2
  symbase = ((som_symbol_type *)
	     bfd_malloc (symbol_count * sizeof (som_symbol_type)));
a4362 1
  memset (symbase, 0, symbol_count * sizeof (som_symbol_type));
d4365 4
a4368 2
  buf = bfd_malloc (symbol_count * symsize);
  if (buf == NULL && symbol_count * symsize != 0)
d4370 1
a4370 1
  if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) < 0)
d4372 1
a4372 2
  if (bfd_read (buf, symbol_count * symsize, 1, abfd)
      != symbol_count * symsize)
d4498 1
a4498 1
         we can not include it as part of the for statement.  */
d4511 1
a4511 1
  return (true);
d4516 1
a4516 1
  return false;
d4550 2
a4551 2
  som_symbol_type *new =
    (som_symbol_type *) bfd_zalloc (abfd, sizeof (som_symbol_type));
d4562 2
a4563 2
som_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d4581 1
a4581 1
	CONST char *section_name;
d4583 1
a4583 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
d4590 1
a4590 1
static boolean
d4618 1
a4618 1
     boolean just_count;
d4703 1
a4703 1
	      if (isupper (c))
d4709 1
a4709 1
	      else if (islower (c))
d4720 1
a4720 1
	      else if (isdigit (c))
d4723 1
a4723 1
		  while (isdigit (*cp))
d4908 1
a4908 1
		         bother saving the contents (yet).  Add it one
d4912 1
a4912 1
			return -1;
d4918 1
a4918 1
						0,
d4952 1
a4952 1
   set to true to indicate it only needs a count of the number
d4955 1
a4955 1
static boolean
d4960 1
a4960 1
     boolean just_count;
d4966 1
d4971 1
a4971 1
    return true;
d4975 1
a4975 1
  if (section->reloc_count == -1)
d4977 2
a4978 1
      external_relocs = (char *) bfd_malloc (fixup_stream_size);
d4980 1
a4980 1
	return false;
d4986 3
a4988 4
	return false;
      if (bfd_read (external_relocs, 1, fixup_stream_size, abfd)
	  != fixup_stream_size)
	return false;
d4995 1
a4995 1
						 NULL, NULL, NULL, true);
d5002 1
a5002 1
    return true;
d5008 1
a5008 1
    return true;
d5010 3
a5012 2
  internal_relocs = (arelent *)
    bfd_zalloc (abfd, (num_relocs * sizeof (arelent)));
d5014 1
a5014 1
    return false;
d5018 1
a5018 1
		      internal_relocs, section, symbols, false);
d5026 1
a5026 1
  return (true);
d5041 1
a5041 1
      if (! som_slurp_reloc_table (abfd, asect, NULL, true))
d5062 1
a5062 1
  if (som_slurp_reloc_table (abfd, section, symbols, false) == false)
d5079 1
a5079 1
static boolean
d5084 2
a5085 2
  newsect->used_by_bfd =
    (PTR) bfd_zalloc (abfd, sizeof (struct som_section_data_struct));
d5087 1
a5087 1
    return false;
d5091 1
a5091 1
  return true;
d5097 1
a5097 1
static boolean
d5110 1
a5110 1
    return false;
d5117 1
a5117 1
  return true;
d5123 1
a5123 1
static boolean
d5130 2
d5136 1
a5136 1
    return true;
d5138 1
d5140 1
a5140 2
    (struct som_copyable_section_data_struct *)
    bfd_zalloc (obfd, sizeof (struct som_copyable_section_data_struct));
d5142 1
a5142 1
    return false;
d5153 1
a5153 1
  return true;
d5159 1
a5159 1
static boolean
d5166 1
a5166 1
    return true;
d5170 1
a5170 1
    bfd_zalloc (obfd, sizeof (struct som_exec_data));
d5172 1
a5172 1
    return false;
d5178 1
a5178 1
  return true;
d5184 1
a5184 1
boolean
d5195 1
d5197 2
a5198 3
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
d5200 1
a5200 1
	return false;
d5207 1
a5207 1
  return true;
d5213 1
a5213 1
boolean
d5225 1
d5227 2
a5228 3
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
d5230 1
a5230 1
	return false;
d5236 1
a5236 1
  return true;
d5256 1
a5256 1
boolean
d5262 2
d5266 1
a5266 1
      int len = strlen (string);
d5271 3
a5273 3
      obj_som_version_hdr (abfd) = (struct user_string_aux_hdr *)
	bfd_zalloc (abfd, sizeof (struct aux_id)
			      + sizeof (unsigned int) + len + pad);
d5275 1
a5275 1
	return false;
d5289 3
a5291 3
      obj_som_copyright_hdr (abfd) = (struct copyright_aux_hdr *)
	bfd_zalloc (abfd, sizeof (struct aux_id)
			    + sizeof (unsigned int) + len + pad);
d5293 1
a5293 1
	return false;
d5300 1
a5300 1
  return true;
d5303 1
a5303 1
/* Attach an compilation unit header to the BFD backend so that it may be
d5306 1
a5306 1
boolean
d5315 1
a5315 1
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, COMPUNITSZ);
d5317 1
a5317 1
    return false;
d5322 1
a5322 1
      n->f.n_name = bfd_alloc (abfd, strlen (f) + 1); \
d5324 1
a5324 1
	return false; \
d5337 1
a5337 1
  return true;
d5340 1
a5340 1
static boolean
d5349 1
a5349 1
    return true;
d5351 4
a5354 4
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) == -1
      || bfd_read (location, (bfd_size_type) 1, count, abfd) != count)
    return (false); /* on error */
  return (true);
d5357 1
a5357 1
static boolean
d5365 1
a5365 1
  if (abfd->output_has_begun == false)
d5370 1
a5370 1
      abfd->output_has_begun = true;
d5380 1
a5380 1
    return true;
d5385 2
a5386 2
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
    return false;
d5388 3
a5390 3
  if (bfd_write ((PTR) location, 1, count, abfd) != count)
    return false;
  return true;
d5393 1
a5393 1
static boolean
d5403 1
a5403 1
static boolean
d5410 2
a5411 2
     CONST char **filename_ptr ATTRIBUTE_UNUSED;
     CONST char **functionname_ptr ATTRIBUTE_UNUSED;
d5414 1
a5414 1
  return (false);
d5420 1
a5420 1
     boolean reloc ATTRIBUTE_UNUSED;
d5425 1
a5425 1
  return (0);
d5469 1
a5469 1
    c = toupper (c);
d5492 1
a5492 1
static boolean
d5500 1
d5503 3
a5505 3
  hash_table =
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
d5514 1
a5514 2
  if (bfd_read ((PTR) hash_table, lst_header->hash_size, 4, abfd)
      != lst_header->hash_size * 4)
d5528 1
a5528 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) < 0)
d5532 2
a5533 2
      if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	  != sizeof (lst_symbol))
d5544 1
a5544 1
	      < 0)
d5548 2
a5549 2
	  if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	      != sizeof (lst_symbol))
d5557 1
a5557 1
  return true;
d5562 1
a5562 1
  return false;
d5568 1
a5568 1
static boolean
d5578 1
d5581 3
a5583 3
  hash_table =
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
a5586 6
  som_dict =
    (struct som_entry *) bfd_malloc (lst_header->module_count
				     * sizeof (struct som_entry));
  if (som_dict == NULL && lst_header->module_count != 0)
    goto error_return;

d5589 1
a5589 2
  if (bfd_read ((PTR) hash_table, lst_header->hash_size, 4, abfd)
      != lst_header->hash_size * 4)
d5594 7
a5600 1
  if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) < 0)
d5603 1
a5603 3
  if (bfd_read ((PTR) som_dict, lst_header->module_count,
		sizeof (struct som_entry), abfd)
      != lst_header->module_count * sizeof (struct som_entry))
d5616 1
a5616 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) < 0)
d5619 2
a5620 2
      if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	  != sizeof (lst_symbol))
d5631 1
a5631 1
			    + lst_symbol.name.n_strx - 4, SEEK_SET) < 0)
d5634 1
a5634 1
      if (bfd_read (&len, 1, 4, abfd) != 4)
d5638 1
a5638 1
      set->name = bfd_zalloc (abfd, len + 1);
d5641 1
a5641 1
      if (bfd_read (set->name, 1, len, abfd) != len)
d5658 2
a5659 1
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET) <0)
d5662 2
a5663 2
	  if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	      != sizeof (lst_symbol))
d5668 1
a5668 1
				+ lst_symbol.name.n_strx - 4, SEEK_SET) < 0)
d5671 1
a5671 1
	  if (bfd_read (&len, 1, 4, abfd) != 4)
d5675 1
a5675 1
	  set->name = bfd_zalloc (abfd, len + 1);
d5679 1
a5679 1
	  if (bfd_read (set->name, 1, len, abfd) != len)
d5698 1
a5698 1
  return true;
d5705 1
a5705 1
  return false;
d5710 1
a5710 1
static boolean
d5719 2
a5720 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d5724 1
a5724 1
    return true;
d5726 1
a5726 1
    return false;
d5728 2
a5729 2
  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) < 0)
    return false;
d5734 2
a5735 2
      bfd_has_map (abfd) = false;
      return true;
d5739 3
a5741 3
  if (bfd_read ((PTR) &ar_header, 1, sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
    return false;
d5746 1
a5746 1
      return false;
d5755 1
a5755 1
      return false;
d5763 3
a5765 3
  if (bfd_read ((PTR) & lst_header, 1, sizeof (struct lst_header), abfd)
      != sizeof (struct lst_header))
    return false;
d5771 1
a5771 1
      return false;
d5775 2
a5776 3
  if (som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count)
      == false)
    return false;
d5779 3
a5781 3
  if (bfd_seek (abfd, ardata->first_file_filepos - parsed_size
			+ sizeof (struct lst_header), SEEK_SET) < 0)
    return false;
d5785 3
a5787 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * sizeof (carsym)));
d5789 1
a5789 1
    return false;
d5792 2
a5793 3
  if (som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs)
      == false)
    return false;
d5797 2
a5798 2
  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) < 0)
    return false;
d5801 2
a5802 2
  bfd_has_map (abfd) = true;
  return true;
d5810 1
a5810 1
static boolean
d5838 2
a5839 2
      if (som_slurp_symbol_table (curr_bfd) == false)
	return false;
d5878 1
a5878 1
  return true;
d5901 1
a5901 1
static boolean
d5916 1
d5918 3
a5920 2
  hash_table =
    (unsigned int *) bfd_malloc (lst.hash_size * sizeof (unsigned int));
d5923 4
a5926 3
  som_dict =
    (struct som_entry *) bfd_malloc (lst.module_count
				     * sizeof (struct som_entry));
d5930 3
a5932 3
  last_hash_entry =
    ((struct lst_symbol_record **)
     bfd_malloc (lst.hash_size * sizeof (struct lst_symbol_record *)));
a5939 6
  /* Some initialization.  */
  memset (hash_table, 0, 4 * lst.hash_size);
  memset (som_dict, 0, lst.module_count * sizeof (struct som_entry));
  memset (last_hash_entry, 0,
	  lst.hash_size * sizeof (struct lst_symbol_record *));

d5964 3
a5966 1
  lst_syms = bfd_malloc (nsyms * sizeof (struct lst_symbol_record));
d5969 1
a5969 1
  strings = bfd_malloc (string_size);
d5993 1
a5993 1
      if (som_slurp_symbol_table (curr_bfd) == false)
d6103 1
a6103 1
      curr_som_offset = (curr_som_offset + 0x1) & ~0x1;
d6109 2
a6110 2
  if (bfd_write ((PTR) hash_table, lst.hash_size, 4, abfd)
      != lst.hash_size * 4)
d6114 2
a6115 3
  if (bfd_write ((PTR) som_dict, lst.module_count,
		 sizeof (struct som_entry), abfd)
      != lst.module_count * sizeof (struct som_entry))
d6119 2
a6120 2
  if (bfd_write ((PTR) lst_syms, nsyms, sizeof (struct lst_symbol_record), abfd)
      != nsyms * sizeof (struct lst_symbol_record))
d6124 2
a6125 1
  if (bfd_write ((PTR) strings, string_size, 1, abfd) != string_size)
d6138 1
a6138 1
  return true;
d6152 1
a6152 1
  return false;
d6159 1
a6159 1
static boolean
d6173 1
d6179 1
a6179 1
      return false;
d6229 2
a6230 2
  if (som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize) == false)
    return false;
d6266 3
a6268 3
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
    return false;
d6271 3
a6273 3
  if (bfd_write ((PTR) &lst, 1, sizeof (struct lst_header), abfd)
      != sizeof (struct lst_header))
    return false;
d6276 2
a6277 3
  if (som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength)
      == false)
    return false;
d6280 1
a6280 1
  return true;
d6286 1
a6286 1
static boolean
d6293 1
a6293 1
    return true;
d6302 1
a6302 1
      o->reloc_count = -1;
d6309 1
a6309 1
  return true;
d6316 1
a6316 1
static boolean
d6337 1
a6337 1
#define som_get_lineno                  _bfd_nosymbols_get_lineno
d6348 1
d6350 1
d6354 2
d6369 1
a6369 1
   predictable, and if so what is it */
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d7 1
a7 1
   University of Utah (pa-gdb-bugs@@cs.utah.edu).
d26 1
a76 1

d94 1
a94 1
   
d110 1
a110 1
   of some multi-byte relocation makes object files smaller. 
d114 4
a117 5
struct reloc_queue
  {
    unsigned char *reloc;
    unsigned int size;
  } reloc_queue[4];
d122 1
a122 2
typedef enum
{
d134 1
a134 2
struct section_to_type
{
d141 1
a141 2
struct som_misc_symbol_info
{
d197 1
a197 1
static asection * bfd_section_from_som_symbol PARAMS ((bfd *, 
d268 1
a268 1
	
d271 2
a272 2
   This table includes all the standard subspaces as defined in the 
   current "PRO ABI for PA-RISC Systems", $UNWIND$ which for 
d306 1
a306 1
   into BFD and symbolically printed by utilities.  To make actual use 
d314 1
a314 1
   while possibly modifying the data in some manner.  They also can 
d324 1
a324 1
   Each entry in the table has three fields. 
d332 1
a332 1
   stream.  
d334 1
a334 1
   The third field specifys whether or not this relocation may use 
d338 2
a339 2
   Variables:  
  
d351 2
a352 2
  
   Lower case letters (starting with 'b') refer to following 
d354 1
a354 1
   c is the next 2 bytes, d is the next 3 bytes, etc...  
d359 1
a359 1
   the constants are represented in decimal. 
d362 1
a362 1
   '<' represents a left shift. 
d368 2
a369 2
   Unwind Entries:  
   
d379 1
a379 2
struct fixup_format
{
d381 1
a381 1
  char *format;
d384 1
a384 2
static const struct fixup_format som_fixup_formats[256] =
{
d697 1
a697 2
static const int comp1_opcodes[] =
{
d718 1
a718 2
static const int comp2_opcodes[] =
{
d726 1
a726 2
static const int comp3_opcodes[] =
{
d782 259
a1040 259
static reloc_howto_type som_hppa_howto_table[] =
{
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_ZEROES, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ZEROES"},
  {R_ZEROES, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ZEROES"},
  {R_UNINIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_UNINIT"},
  {R_UNINIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_UNINIT"},
  {R_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RELOCATION"},
  {R_DATA_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_ONE_SYMBOL"},
  {R_DATA_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_ONE_SYMBOL"},
  {R_DATA_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_PLABEL"},
  {R_DATA_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_PLABEL"},
  {R_SPACE_REF, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SPACE_REF"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_SHORT_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SHORT_PCREL_MODE"},
  {R_LONG_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LONG_PCREL_MODE"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_DLT_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DLT_REL"},
  {R_DLT_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DLT_REL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_MILLI_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_MILLI_REL"},
  {R_MILLI_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_MILLI_REL"},
  {R_CODE_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_PLABEL"},
  {R_CODE_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_PLABEL"},
  {R_BREAKPOINT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BREAKPOINT"},
  {R_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ENTRY"},
  {R_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ENTRY"},
  {R_ALT_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ALT_ENTRY"},
  {R_EXIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_EXIT"},
  {R_BEGIN_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BEGIN_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_BEGIN_BRTAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BEGIN_BRTAB"},
  {R_END_BRTAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_BRTAB"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_DATA_EXPR, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_EXPR"},
  {R_CODE_EXPR, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_EXPR"},
  {R_FSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_FSEL"},
  {R_LSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LSEL"},
  {R_RSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RSEL"},
  {R_N_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N_MODE"},
  {R_S_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_S_MODE"},
  {R_D_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_D_MODE"},
  {R_R_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_R_MODE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_TRANSLATED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_TRANSLATED"},
  {R_AUX_UNWIND, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_AUX_UNWIND"},
  {R_COMP1, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP1"},
  {R_COMP2, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP2"},
  {R_COMP3, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP3"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_SEC_STMT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SEC_STMT"},
  {R_N0SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N0SEL"},
  {R_N1SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N1SEL"},
  {R_LINETAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB"},
  {R_LINETAB_ESC, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB_ESC"},
  {R_LTP_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LTP_OVERRIDE"},
  {R_COMMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMMENT"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"}};
  
d1043 1
a1043 1
  
d1125 1
a1125 1
  abort();
d1153 1
a1153 1
     bfd *abfd;
d1164 1
a1164 1
	 just built and use R_PREV_FIXUP instead.  We saved 
d1182 1
a1182 1
   relocation stream via SUBSPACE_RELOC_SIZE_P; also return the 
d1213 2
a1214 2
  
  /* The difference must be less than 0x1000000.  Use one 
d1265 1
a1265 1
  if ((unsigned)(addend) + 0x80 < 0x100)
d1269 1
a1269 1
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue); 
d1307 1
a1307 1
  
d1311 1
a1311 1
     
d1363 1
a1363 1
  
d1380 1
a1380 1
      
d1387 1
a1387 1
      
d1405 1
a1405 2

/* Return the logarithm of X, base 2, considering X unsigned. 
d1426 1
a1426 1
     bfd *abfd;
d1428 2
a1429 2
     asymbol *symbol_in;
     PTR data;
d1432 1
a1432 1
     char **error_message;
d1461 1
a1461 1
  /* The field selector may require additional relocations to be 
d1468 9
a1476 9
      case e_fsel:
      case e_psel:
      case e_lpsel:
      case e_rpsel:
	final_types[0] = final_type;
	final_types[1] = NULL;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1478 16
a1493 16
      case e_tsel:
      case e_ltsel:
      case e_rtsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	if (field == e_tsel)
	  *final_types[0] = R_FSEL;
	else if (field == e_ltsel)
	  *final_types[0] = R_LSEL;
	else
	  *final_types[0] = R_RSEL;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1495 10
a1504 10
      case e_lssel:
      case e_rssel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_S_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1506 10
a1515 10
      case e_lsel:
      case e_rsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1517 10
a1526 10
      case e_ldsel:
      case e_rdsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_D_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1528 10
a1537 10
      case e_lrsel:
      case e_rrsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_R_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1539 9
a1547 9
      case e_nsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N1SEL;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1549 17
a1565 17
      case e_nlsel:
      case e_nlrsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N0SEL;
	final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[1])
	  return NULL;
	if (field == e_nlsel)
	  *final_types[1] = R_N_MODE;
	else
	  *final_types[1] = R_R_MODE;
	final_types[2] = final_type;
	final_types[3] = NULL;
	*final_type = base_type;
	break;
d1567 1
a1567 1
  
d1574 4
a1577 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d1579 1
a1579 1
            return NULL;
d1599 2
a1600 2
	  || field == e_lpsel
	  || field == e_rpsel)
d1611 2
a1612 2
	  || field == e_ltsel
	  || field == e_rtsel)
a1641 1

d1654 4
a1657 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d1659 1
a1659 1
            return NULL;
a1710 1
/*ARGSUSED*/
d1713 1
a1713 1
     bfd *abfd;
d1776 1
a1776 1
    bfd_zalloc (abfd, sizeof (struct som_exec_data ));
d1787 1
a1787 1
    
d1816 1
a1816 1
  /* Initialize the saved symbol table and string table to NULL.  
d1819 1
a1819 1
  obj_som_stringtab (abfd) = (char  *) NULL;
d1850 1
a1850 1
  /* First, read in space names */
d1856 2
a1857 2
  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location, 
  		SEEK_SET) < 0)
d1863 1
a1863 1
  /* Loop over all of the space dictionaries, building up sections */
d1872 1
a1872 1
      /* Read the space dictionary element */
d1881 1
a1881 1
      /* Setup the space name string */
d1884 1
a1884 1
      /* Make a section out of it */
d1889 1
a1889 1
			   
d1894 1
a1894 1
       if (space.is_loadable == 0)
d1907 1
a1907 1
      /* Now, read in the first subspace for this space */
d1915 1
a1915 1
      /* Seek back to the start of the subspaces for loop below */
d1922 2
a1923 1
      /* Setup the start address and file loc from the first subspace record */
d1934 1
a1934 1
      /* Loop over the rest of the subspaces, building up more sections */
d1940 1
a1940 1
	  /* Read in the next subspace */
d1945 1
a1945 1
	  /* Setup the subspace name string */
d1953 1
a1953 1
	  /* Make a section out of this subspace */
d1965 1
a1965 1
	  /* Keep an easy mapping between subspaces and sections. 
d1981 1
a1981 1
	    /* Readonly data.  */  
d1986 1
a1986 1
	    /* Normal data.  */  
d2007 2
a2008 2
	  
	  if (subspace.dup_common || subspace.is_common) 
d2037 1
a2037 1
	      /* We can not determine this yet.  When we read in the 
d2092 1
a2092 1
  
d2126 1
a2126 1
#define ENTRY_SIZE sizeof(struct som_entry)
d2160 1
a2160 1
      /* Read the lst header and determine where the SOM directory begins */
d2163 2
a2164 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2166 2
a2167 2
          return 0;
        }
d2170 2
a2171 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2173 2
a2174 2
          return 0;
        }
d2176 1
a2176 1
      /* Position to and read the first directory entry */
d2179 2
a2180 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2182 2
a2183 2
          return 0;
        }
d2186 2
a2187 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2189 2
a2190 2
          return 0;
        }
d2192 1
a2192 1
      /* Now position to the first SOM */
d2195 2
a2196 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2198 2
a2199 2
          return 0;
        }
d2203 1
a2203 1
      /* And finally, re-read the som header */
d2206 2
a2207 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2209 2
a2210 2
          return 0;
        }
d2313 1
a2313 1
  file_hdr->file_time.nanosecs = 0; 
d2329 1
a2329 1
      
d2333 3
a2335 3
	  som_section_data (section)->space_dict
	    = (struct space_dictionary_record *)
	      bfd_zalloc (abfd, sizeof (struct space_dictionary_record));
d2344 1
a2344 1
	  som_section_data (section)->space_dict->sort_key = 
d2346 1
a2346 1
	  som_section_data (section)->space_dict->is_defined = 
d2348 1
a2348 1
	  som_section_data (section)->space_dict->is_private = 
d2377 1
a2377 1
	  som_section_data (section)->subspace_dict->subspace_start = 
d2383 1
a2383 1
	  som_section_data (section)->subspace_dict->alignment = 
d2465 1
a2465 1
      count += som_is_space (section);
d2500 1
a2500 1
  
d2532 1
a2532 2
  unsigned int count1, count2;
  
d2596 1
a2596 1
	  /* Scaling to encourage symbols involved in R_DP_RELATIVE 
d2637 1
a2637 1
        som_symbol_data (sorted_syms[i])->index = i;
d2682 1
a2682 1
 	  int current_call_mode;
d2704 1
a2704 1
	  /* To make life easier start over with a clean slate for 
d2722 1
a2722 1
	  /* Translate each BFD relocation into one or more SOM 
d2730 1
a2730 1
	      /* Get the symbol number.  Remember it's stored in a 
d2736 1
a2736 1
	      
d2739 1
a2739 1
		 the relocation queue. 
d2810 1
a2810 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p, 
d2830 1
a2830 1
		      bfd_put_16 (abfd, sym_num, p + 2); 
d2845 1
a2845 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p, 
d2859 1
a2859 1
		      bfd_put_16 (abfd, sym_num, p + 2); 
d2880 1
a2880 1
		
d2884 1
a2884 1
		        tmp_reloc = subsection->orelocation[tmp];
d2897 1
a2897 1
		  
d2963 1
a2963 1
		      
d2965 1
a2965 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d2975 1
a2975 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d2988 1
a2988 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d3009 1
a3009 1
	  p = som_reloc_skip (abfd, bfd_section_size (abfd, subsection) 
d3039 3
a3041 2
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
a3044 3
  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

d3054 1
a3054 1
      int length;
d3065 4
a3068 3
	 current buffer contents now.  Each entry will take 4 bytes to
	 hold the string length + the string itself + null terminator.  */
      if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3070 1
d3072 1
a3072 1
	      != p - tmp_space) 
d3074 17
a3090 1
	  /* Reset to beginning of the buffer space.  */
d3141 1
a3141 1
  
d3144 4
a3147 2
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
a3164 3
  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

d3174 1
a3174 1
	  int length = strlen (comp[i]);
d3177 3
a3179 2
	     the current buffer contents now.  */
	  if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3181 1
d3185 11
a3195 1
	      /* Reset to beginning of the buffer space.  */
d3212 1
a3212 1
	    case 0:	
d3216 1
a3216 1
	      obj_som_compilation_unit (abfd)->language_name.n_strx = 
d3220 1
a3220 1
	      obj_som_compilation_unit (abfd)->product_id.n_strx = 
d3224 1
a3224 1
	      obj_som_compilation_unit (abfd)->version_id.n_strx = 
d3244 1
a3244 1
      int length = strlen (syms[i]->name);
d3247 2
a3248 2
	 current buffer contents now.  */
     if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3250 1
d3254 10
a3263 1
	  /* Reset to beginning of the buffer space.  */
d3278 1
a3278 1
      som_symbol_data(syms[i])->stringtab_offset = strings_size;
d3284 1
a3284 1
        {
d3288 1
a3288 1
        }
d3299 1
a3299 1
/* Compute variable information to be placed in the SOM headers, 
d3303 1
a3303 1
static boolean 
a3308 1
  unsigned int total_reloc_size = 0;
d3314 1
a3314 1
  /* The file header will always be first in an object file, 
d3326 1
a3326 1
  current_offset += sizeof (struct header);  
d3429 1
a3429 1
  /* Mark the offset of the space/subspace string table in the 
d3442 1
a3442 1
  /* Next is the compilation unit. */
d3445 1
a3445 1
  if (obj_som_compilation_unit (abfd)) 
d3448 1
a3448 1
      current_offset += COMPUNITSZ; 
d3510 1
a3510 1
		 loader will create holes between subspaces *and* 
a3538 1

d3553 1
a3553 1
	      current_offset += bfd_section_size (abfd, subsection); 
d3570 1
a3570 1
      section = section->next; 
d3598 1
a3598 1
	  
d3611 1
a3611 1
	      current_offset += bfd_section_size (abfd, subsection); 
d3623 1
a3623 1
      section = section->next; 
d3672 1
a3672 1
     at this time. 
d3681 1
a3681 1
    current_offset += (4 - (current_offset % 4)); 
d3714 1
a3714 1
    current_offset += (4 - (current_offset % 4)); 
d3727 1
a3727 1
 
d3756 1
a3756 1
	  
d3784 1
a3784 1
	  
d3792 1
a3792 1
      section = section->next; 
d3811 1
a3811 1
	  
d3835 1
a3835 1
	  subspace_index++; 
d3840 1
a3840 1
	  
d3848 1
a3848 1
      section = section->next; 
a3862 1

d3867 1
a3867 1
      /* Dump its header  */
d3882 1
a3882 1
        return false;
d3886 1
a3886 1
        return false;
d3892 1
a3892 1
    obj_som_file_hdr(abfd)->system_id = obj_som_exec_data (abfd)->system_id;
d3894 1
a3894 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC2_0;
d3896 1
a3896 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC1_1;
d3898 1
a3898 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC1_0;
d3973 1
a3973 1
     bfd *abfd;
d3984 1
a3984 1
	 
d4034 1
a4034 1
  
d4054 1
a4054 1
	
d4060 2
a4061 1
  else if (sym->flags & BSF_EXPORT && ! bfd_is_com_section (sym->section))
d4076 1
a4076 1
  /* For all other symbols, the symbol_info field contains the 
d4118 2
a4119 2
      /* This is really an index into the symbol strings table.  
	 By the time we get here, the index has already been 
d4153 1
a4153 1
/* Write an object in SOM format.  */  
a4171 1

d4202 1
a4202 1
  
d4207 1
a4207 1
  /* Save our results and return success. */
d4311 1
a4311 1
  if (bfd_read (buf, symbol_count * symsize, 1, abfd) 
a4375 1
	     
d4421 1
a4421 1
        sym->symbol.flags |= BSF_WEAK;
d4491 1
a4491 1
  (som_symbol_type *) bfd_zalloc (abfd, sizeof (som_symbol_type));
d4503 1
a4503 1
     bfd *ignore_abfd;
d4532 1
a4532 1
     bfd *abfd;
d4547 1
a4547 1
   not just counting 
d4563 1
a4563 1
  char *cp;
d4567 1
a4567 1
  arelent *rptr= internal_relocs;
d4630 1
a4630 1
	 parse RHS, then assign to LHS.  Repeat until no more 
a4667 1

d4823 1
a4823 1
      /* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION 
a4839 2
		  unsigned addend = var ('V');

d4865 1
a4865 1
			
d4889 1
a4889 1
/* Read in the relocs (aka fixups in SOM terms) for a section. 
d4891 1
a4891 1
   som_get_reloc_upper_bound calls this routine with JUST_COUNT 
d4912 1
a4912 1
  /* If reloc_count is -1, then the relocation stream has not been 
d4919 1
a4919 1
      /* Read in the external forms. */
d4949 1
a4949 1
  internal_relocs = (arelent *) 
d4968 1
a4968 1
   information associated with the given section.  */ 
d5028 1
a5028 1
  /* We allow more than three sections internally */
d5060 1
d5074 3
a5076 3
  som_section_data (osection)->copy_data
    = (struct som_copyable_section_data_struct *)
      bfd_zalloc (obfd, sizeof (struct som_copyable_section_data_struct));
d5131 4
a5134 4
      som_section_data (section)->copy_data
	= (struct som_copyable_section_data_struct *)
	  bfd_zalloc (section->owner,
		      sizeof (struct som_copyable_section_data_struct));
d5146 1
a5146 1
/* Set backend info for subsections which can not be described 
d5161 4
a5164 4
      som_section_data (section)->copy_data
	= (struct som_copyable_section_data_struct *)
	  bfd_zalloc (section->owner,
		      sizeof (struct som_copyable_section_data_struct));
d5191 1
d5242 1
a5242 1
                                 version_id)
d5284 3
a5286 3
  if ((bfd_size_type)(offset+count) > section->_raw_size
      || bfd_seek (abfd, (file_ptr)(section->filepos + offset), SEEK_SET) == -1
      || bfd_read (location, (bfd_size_type)1, count, abfd) != count)
d5318 1
a5318 1
  offset += som_section_data (section)->subspace_dict->file_loc_init_value; 
d5333 1
a5333 1
  /* Allow any architecture to be supported by the SOM backend */
d5339 8
a5346 8
			functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
     unsigned int *line_ptr;
d5353 2
a5354 2
     bfd *abfd;
     boolean reloc;
d5389 3
a5391 1
  if (!(symbol->flags & (BSF_GLOBAL|BSF_LOCAL)))
d5411 1
a5411 1
     bfd *ignore_abfd;
d5417 1
a5417 1
    ret->value = symbol->value+symbol->section->vma;
d5436 1
a5436 1
  hash_table = 
d5514 1
a5514 1
  hash_table = 
d5537 1
a5537 1
  if (bfd_read ((PTR) som_dict, lst_header->module_count, 
d5602 1
a5602 1
	  if (bfd_seek (abfd, lst_filepos + lst_header->string_loc 
d5627 1
a5627 1
  /* If we haven't died by now, then we successfully read the entire 
d5644 1
d5714 1
a5714 1
  if (bfd_seek (abfd, ardata->first_file_filepos - parsed_size 
d5819 1
d5831 1
a5831 1
	  | (symbol->name[len-2] << 8) | symbol->name[len-1];
d5836 1
a5836 1
   
d5876 1
a5876 1
  memset (last_hash_entry, 0, 	
d5902 1
a5902 1
  /* FIXME should be done with buffers just like everything else... */
d5999 1
a5999 1
		  + lst.hash_size * 4 
d6008 1
a6008 1
		  + lst.hash_size * 4 
a6017 1

d6023 1
a6023 1
	  while ((int)p % 4)
d6036 1
a6036 1
 
a6095 1
/*ARGSUSED*/
d6100 3
a6102 3
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d6110 1
a6110 1
 
d6182 1
a6182 1
  p = (int *)&lst;
d6184 1
a6184 1
  for (i = 0; i < sizeof (struct lst_header)/sizeof (int) - 1; i++)
d6215 1
a6215 1
  
d6249 1
a6249 1
/* End of miscellaneous support functions. */
d6252 1
d6255 1
a6255 1
     bfd *abfd;
d6290 1
a6290 3

const bfd_target som_vec =
{
d6342 1
a6342 1
  
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996
d22 2
a23 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF)
a32 2
#include <stdio.h>
#include <sys/types.h>
d37 1
a37 1
#include <errno.h>
d49 4
d61 4
d150 2
d159 3
a161 2
						    struct som_exec_auxhdr *));
static boolean setup_sections PARAMS ((bfd *, struct header *));
d187 1
a187 1
static boolean som_bfd_is_local_label PARAMS ((bfd *, asymbol *));
d242 2
a243 1
						 unsigned *));
d264 2
a265 2
						      struct lst_header));
static CONST char *normalize PARAMS ((CONST char *file));
a443 1
  /* R_SHORT_PCREL_MODE */
a444 1
  /* R_LONG_PCREL_MODE */
d461 1
a461 1
  /* R_RESERVED */
d463 1
d638 2
a639 2
  /* R_RESERVED */
  0,    "",	        /* 0xcf */
d658 1
a658 1
  0,	"",		/* 0xda */
d660 1
a660 1
  0,	"",		/* 0xdb */
d664 1
a664 1
  0,	"",		/* 0xdd */
d755 1
d787 3
d1465 2
a1466 2
  final_types = (int **) bfd_alloc_by_size_t (abfd, sizeof (int *) * 6);
  final_type = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1490 1
a1490 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1506 1
a1506 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1517 1
a1517 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1528 1
a1528 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1539 1
a1539 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1549 1
a1549 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1560 1
a1560 1
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1564 1
a1564 1
	final_types[1] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
d1583 4
a1586 4
	  final_types[0] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
d1599 4
a1602 1
	  *final_types[4] = R_CODE_EXPR;
d1664 4
a1667 4
	  final_types[0] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc_by_size_t (abfd, sizeof (int));
d1680 4
a1683 1
	  *final_types[4] = R_CODE_EXPR;
a1691 1
    case R_HPPA_PCREL_CALL:
d1694 20
d1740 1
a1740 1
som_object_setup (abfd, file_hdrp, aux_hdrp)
d1744 1
d1820 1
a1820 1
      bfd_get_start_address (abfd) = aux_hdrp->exec_entry;
d1834 5
a1838 3
  obj_som_sym_filepos (abfd) = file_hdrp->symbol_location;
  obj_som_str_filepos (abfd) = file_hdrp->symbol_strings_location;
  obj_som_reloc_filepos (abfd) = file_hdrp->fixup_request_location;
d1851 1
a1851 1
setup_sections (abfd, file_hdr)
d1854 1
d1867 2
a1868 1
  if (bfd_seek (abfd, file_hdr->space_strings_location, SEEK_SET) < 0)
d1884 4
a1887 2
      if (bfd_seek (abfd, file_hdr->space_location
		    + space_index * sizeof space, SEEK_SET) < 0)
d1919 3
a1921 2
      if (bfd_seek (abfd, file_hdr->subspace_location
		    + space.subspace_index * sizeof subspace,
d1927 3
a1929 2
      if (bfd_seek (abfd, file_hdr->subspace_location
		    + space.subspace_index * sizeof subspace,
d1935 1
a1935 1
      space_asect->filepos = subspace.file_loc_init_value;
d2059 2
a2060 1
	  subspace_asect->filepos = subspace.file_loc_init_value;
d2066 2
a2067 3
      /* Yow! there is no subspace within the space which actually 
         has initialized information in it; this should never happen
         as far as I know.  */
d2069 15
a2083 8
	goto error_return;

      /* Setup the sizes for the space section based upon the info in the
         last subspace of the space.  */
      space_asect->_cooked_size = save_subspace.subspace_start
	- space_asect->vma + save_subspace.subspace_length;
      space_asect->_raw_size = save_subspace.file_loc_init_value
	- space_asect->filepos + save_subspace.initialization_length;
d2133 4
a2162 3
#ifdef EXECLIBMAGIC
    case EXECLIBMAGIC:
#endif
d2167 58
d2251 1
a2251 1
  if (!setup_sections (abfd, &file_hdr))
d2259 1
a2259 1
  return som_object_setup (abfd, &file_hdr, &aux_hdr);
d2692 3
d2729 3
d2796 4
d2924 13
d2998 1
d3126 2
a3127 1
som_write_symbol_strings (abfd, current_offset, syms, num_syms, string_sizep)
d3133 1
d3142 15
d3166 60
d3417 1
a3417 1
  /* Next is the compiler records.  We do not use these.  */
d3420 5
d3672 2
a3673 1
				num_syms, &strings_size)
d3854 12
d3870 2
d3893 1
a3893 1
      long tmp;
d3910 10
d3998 2
a3999 1
	  info->arg_reloc = som_symbol_data (sym)->tc_data.hppa_arg_reloc;
d4059 7
d4107 3
a4109 1
      som_symtab[i].symbol_value = info.symbol_value;
d4323 1
a4323 1
      som_symbol_data (sym)->tc_data.hppa_arg_reloc = bufp->arg_reloc;
d4337 2
d4346 2
d4349 1
a4349 1
	  /* If the symbol's scope is ST_UNSAT, then these are
d4397 4
d4509 1
a4509 1
som_bfd_is_local_label (abfd, sym)
d4511 1
a4511 1
     asymbol *sym;
d4513 1
a4513 1
  return (sym->name[0] == 'L' && sym->name[1] == '$');
d5033 2
a5034 1
  output_symbol->tc_data.hppa_arg_reloc = input_symbol->tc_data.hppa_arg_reloc;
d5216 37
d5335 1
a5335 1
  (*_bfd_error_handler) ("som_sizeof_headers unimplemented");
a5808 13
static CONST char *
normalize (file)
     CONST char *file;
{
  CONST char *filename = strrchr (file, '/');

  if (filename != NULL)
    filename++;
  else
    filename = file;
  return filename;
}

d5813 1
a5813 1
som_bfd_ar_write_symbol_stuff (abfd, nsyms, string_size, lst)
d5817 1
d5826 1
a5826 2
  unsigned int curr_som_offset, som_index, extended_name_length = 0;
  unsigned int maxname = abfd->xvec->ar_max_namelen;
d5862 4
a5867 16
  /* Yow!  We have to know the size of the extended name table
     too.  */
  for (curr_bfd = abfd->archive_head;
       curr_bfd != NULL;
       curr_bfd = curr_bfd->next)
    {
      CONST char *normal = normalize (curr_bfd->filename);
      unsigned int thislen;

      if (!normal)
	return false;
      thislen = strlen (normal);
      if (thislen > maxname)
	extended_name_length += thislen + 1;
    }

d5869 4
a5872 3
     extended string table.  */
  if (extended_name_length)
    curr_som_offset += extended_name_length + sizeof (struct ar_hdr);
d5943 1
a5943 1
	  curr_lst_sym->secondary_def = 0;
d5952 1
a5952 1
	  curr_lst_sym->xleast = 0;
d5957 1
a5957 1
	  curr_lst_sym->symbol_value = info.symbol_value;
a6067 14
/* SOM almost uses the SVR4 style extended name support, but not
   quite.  */

static boolean
som_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
{
  *name = "//";
  return _bfd_construct_extended_name_table (abfd, false, tabloc, tablen);
}

d6189 2
a6190 1
  if (som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst) == false)
d6245 2
d6264 2
d6319 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d1441 1
a1441 1
hppa_som_gen_reloc_type (abfd, base_type, format, field, sym_diff)
d1447 1
d1608 5
a1612 1
	*final_type = R_DATA_ONE_SYMBOL;
d1614 18
d1634 1
d1714 1
a1714 1
  abfd->flags = NO_FLAGS;
a2657 2
		/* This only needs to handle relocations that may be
		   made by hppa_som_gen_reloc.  */
d2672 2
d2807 1
d2815 23
d3756 2
a3757 3
      /* If the type is unknown at this point, it should be ST_DATA or
	 ST_CODE (function/ST_ENTRY symbols were handled  as special
	 cases above). */
d3765 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995
d433 1
a433 1
  /* R_RESERVED */
d435 1
d641 1
a641 1
  /* R_RESERVED */
d643 1
d645 1
d647 1
d649 1
d651 1
d653 1
d655 1
d730 1
a730 1
/* These apparently are not in older versions of hpux reloc.h.  */
d743 33
d840 2
a841 2
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
d994 6
a999 6
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
d1453 1
a1453 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1477 1
a1477 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return NULL;
	  }
d1493 1
a1493 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return NULL;
	  }
d1504 1
a1504 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return NULL;
	  }
d1515 1
a1515 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return NULL;
	  }
d1526 1
a1526 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return NULL;
	  }
d1532 28
a1572 2
          {
            bfd_set_error (bfd_error_no_memory);
a1573 1
          }
a1627 2
          {
            bfd_set_error (bfd_error_no_memory);
a1628 1
          }
d1725 1
a1725 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1796 1
a1796 1
  space_strings = malloc (file_hdr->space_strings_size);
d1798 1
a1798 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d2008 2
a2009 2
  subspace_sections = (asection **) malloc (total_subspaces
					    * sizeof (asection *));
d2134 1
a2134 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d2152 1
a2152 5

    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d2162 1
a2162 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d2209 1
a2209 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d2232 1
a2232 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d2650 2
d2783 2
d3781 1
a3781 1
  som_symtab = (struct symbol_dictionary_record *) malloc (symtab_size);
d3783 1
a3783 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d3867 1
a3867 2
  stringtab = malloc (obj_som_stringtab_size (abfd));
  bzero (stringtab, obj_som_stringtab_size (abfd));
d3869 2
a3870 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d3971 2
a3972 3
  symbase = (som_symbol_type *)
    malloc (symbol_count * sizeof (som_symbol_type));
  bzero (symbase, symbol_count * sizeof (som_symbol_type));
d3974 2
a3975 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d3978 1
a3978 1
  buf = malloc (symbol_count * symsize);
d3980 1
a3980 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d4107 6
a4112 2
 /* Save our results and return success.  */
 obj_som_symtab (abfd) = symbase;
d4158 1
a4158 4
    {
      bfd_set_error (bfd_error_no_memory);
      return 0;
    }
d4518 1
a4518 1
		      section->contents = malloc (section->_raw_size);
d4584 1
a4584 1
      external_relocs = (char *) malloc (fixup_stream_size);
d4586 1
a4586 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d4620 1
a4620 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d4628 1
d4693 1
a4693 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d4744 1
a4744 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d4774 1
a4774 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d4802 1
a4802 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d4832 1
a4832 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d4874 1
a4874 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d4892 1
a4892 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d5063 2
a5064 1
    (unsigned int *) malloc (lst_header->hash_size * sizeof (unsigned int));
d5066 1
a5066 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5141 2
a5142 1
    (unsigned int *) malloc (lst_header->hash_size * sizeof (unsigned int));
d5144 1
a5144 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5147 2
a5148 2
    (struct som_entry *) malloc (lst_header->module_count
				 * sizeof (struct som_entry));
d5150 1
a5150 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5202 1
a5202 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d5238 1
a5238 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d5349 1
a5349 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d5491 1
a5491 1
    (unsigned int *) malloc (lst.hash_size * sizeof (unsigned int));
d5493 1
a5493 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5495 2
a5496 2
    (struct som_entry *) malloc (lst.module_count
				 * sizeof (struct som_entry));
d5498 1
a5498 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5502 1
a5502 1
     malloc (lst.hash_size * sizeof (struct lst_symbol_record *)));
d5504 1
a5504 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5536 1
a5536 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d5551 1
a5551 1
  lst_syms = malloc (nsyms * sizeof (struct lst_symbol_record));
d5553 2
a5554 5
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
  strings = malloc (string_size);
d5556 1
a5556 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d5927 1
d5953 2
a5954 2
  true,				/* target byte order */
  true,				/* target headers byte order */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996
d433 1
a433 1
  /* R_SHORT_PCREL_MODE */
a434 1
  /* R_LONG_PCREL_MODE */
d640 1
a640 1
  /* R_SEC_STMT */
a641 1
  /* R_N0SEL */
a642 1
  /* R_N1SEL */
a643 1
  /* R_LINETAB */
a644 1
  /* R_LINETAB_ESC */
a645 1
  /* R_LTP_OVERRIDE */
a646 1
  /* R_COMMENT */
a647 1
  /* R_RESERVED */
d722 1
a722 1
/* These apparently are not in older versions of hpux reloc.h (hpux7).  */
a734 33
/* And these first appeared in hpux10.  */
#ifndef R_SHORT_PCREL_MODE
#define R_SHORT_PCREL_MODE 0x3e
#endif

#ifndef R_LONG_PCREL_MODE
#define R_LONG_PCREL_MODE 0x3f
#endif

#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif

#ifndef R_LINETAB
#define R_LINETAB 0xda
#endif

#ifndef R_LINETAB_ESC
#define R_LINETAB_ESC 0xdb
#endif

#ifndef R_LTP_OVERRIDE
#define R_LTP_OVERRIDE 0xdc
#endif

#ifndef R_COMMENT
#define R_COMMENT 0xdd
#endif

d799 2
a800 2
  {R_SHORT_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SHORT_PCREL_MODE"},
  {R_LONG_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LONG_PCREL_MODE"},
d953 6
a958 6
  {R_N0SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N0SEL"},
  {R_N1SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N1SEL"},
  {R_LINETAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB"},
  {R_LINETAB_ESC, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB_ESC"},
  {R_LTP_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LTP_OVERRIDE"},
  {R_COMMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMMENT"},
d1412 4
a1415 1
    return NULL;
d1439 4
a1442 1
	  return NULL;
d1458 4
a1461 1
	  return NULL;
d1472 4
a1475 1
	  return NULL;
d1486 4
a1489 1
	  return NULL;
d1500 4
a1503 1
	  return NULL;
a1508 28

      case e_nsel:
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N1SEL;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;

      case e_nlsel:
      case e_nlrsel:
	final_types[0] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N0SEL;
	final_types[1] = (int *) bfd_alloc_by_size_t (abfd, sizeof (int));
	if (!final_types[1])
	  return NULL;
	if (field == e_nlsel)
	  *final_types[1] = R_N_MODE;
	else
	  *final_types[1] = R_R_MODE;
	final_types[2] = final_type;
	final_types[3] = NULL;
	*final_type = base_type;
	break;
d1522 2
d1525 1
d1580 2
d1583 1
d1680 4
a1683 1
    return NULL;
d1754 1
a1754 1
  space_strings = bfd_malloc (file_hdr->space_strings_size);
d1756 4
a1759 1
    goto error_return;
d1969 2
a1970 2
  subspace_sections = (asection **) bfd_malloc (total_subspaces
						* sizeof (asection *));
d2095 4
a2098 1
    return false;
d2116 5
a2120 1
    return false;
d2130 4
a2133 1
	return false;
d2180 4
a2183 1
	    return false;
d2206 4
a2209 1
	    return false;
a2626 2
		case R_N0SEL:
		case R_N1SEL:
a2757 2
		case R_N0SEL:
		case R_N1SEL:
d3754 1
a3754 1
  som_symtab = (struct symbol_dictionary_record *) bfd_malloc (symtab_size);
d3756 4
a3759 1
    goto error_return;
d3843 2
a3844 1
  stringtab = bfd_malloc (obj_som_stringtab_size (abfd));
d3846 4
a3849 2
    return false;
  memset (stringtab, 0, obj_som_stringtab_size (abfd));
d3950 3
a3952 2
  symbase = ((som_symbol_type *)
	     bfd_malloc (symbol_count * sizeof (som_symbol_type)));
d3954 4
a3957 2
    goto error_return;
  memset (symbase, 0, symbol_count * sizeof (som_symbol_type));
d3960 1
a3960 1
  buf = bfd_malloc (symbol_count * symsize);
d3962 4
a3965 1
    goto error_return;
d4092 2
a4093 6
  /* We modify the symbol count to record the number of BFD symbols we
     created.  */
  bfd_get_symcount (abfd) = sym - symbase;

  /* Save our results and return success.  */
  obj_som_symtab (abfd) = symbase;
d4139 4
a4142 1
    return 0;
d4502 1
a4502 1
		      section->contents = bfd_malloc (section->_raw_size);
d4568 1
a4568 1
      external_relocs = (char *) bfd_malloc (fixup_stream_size);
d4570 4
a4573 1
	return false;
d4607 4
a4610 1
    return false;
a4617 1
  som_section_data (section)->reloc_stream = NULL;
d4682 4
a4685 1
    return false;
d4736 4
a4739 1
    return false;
d4769 4
a4772 1
    return false;
d4800 4
a4803 1
	return false;
d4833 4
a4836 1
	return false;
d4878 4
a4881 1
	return false;
d4899 4
a4902 1
	return false;
d5073 1
a5073 2
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
d5075 4
a5078 1
    goto error_return;
d5153 1
a5153 2
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
d5155 4
a5158 1
    goto error_return;
d5161 2
a5162 2
    (struct som_entry *) bfd_malloc (lst_header->module_count
				     * sizeof (struct som_entry));
d5164 4
a5167 1
    goto error_return;
d5219 4
a5222 1
	goto error_return;
d5258 4
a5261 1
	    goto error_return;
d5372 4
a5375 1
    return false;
d5517 1
a5517 1
    (unsigned int *) bfd_malloc (lst.hash_size * sizeof (unsigned int));
d5519 4
a5522 1
    goto error_return;
d5524 2
a5525 2
    (struct som_entry *) bfd_malloc (lst.module_count
				     * sizeof (struct som_entry));
d5527 4
a5530 1
    goto error_return;
d5534 1
a5534 1
     bfd_malloc (lst.hash_size * sizeof (struct lst_symbol_record *)));
d5536 4
a5539 1
    goto error_return;
d5571 4
a5574 1
	return false;
d5589 1
a5589 1
  lst_syms = bfd_malloc (nsyms * sizeof (struct lst_symbol_record));
d5591 5
a5595 2
    goto error_return;
  strings = bfd_malloc (string_size);
d5597 4
a5600 1
    goto error_return;
a5970 1
#define som_get_elt_at_index		_bfd_generic_get_elt_at_index
d5996 2
a5997 2
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d1441 1
a1441 1
hppa_som_gen_reloc_type (abfd, base_type, format, field, sym_diff, sym)
a1446 1
     asymbol *sym;
d1607 1
a1607 5
	{
	  *final_type = R_DATA_ONE_SYMBOL;

	  /* If there's no SOM symbol type associated with this BFD
	     symbol, then set the symbol type to ST_DATA.
a1608 18
	     Only do this if the type is going to default later when
	     we write the object file.

	     This is done so that the linker never encounters an
	     R_DATA_ONE_SYMBOL reloc involving an ST_CODE symbol.

	     This allows the compiler to generate exception handling
	     tables.

	     Note that one day we may need to also emit BEGIN_BRTAB and
	     END_BRTAB to prevent the linker from optimizing away insns
	     in exception handling regions.  */
	  if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
	      && (sym->flags & BSF_SECTION_SYM) == 0
	      && (sym->flags & BSF_FUNCTION) == 0
	      && ! bfd_is_com_section (sym->section))
	    som_symbol_data (sym)->som_type = SYMBOL_TYPE_DATA;
	}
a1610 1

d1690 1
a1690 1
  abfd->flags = BFD_NO_FLAGS;
d2634 2
a2649 2
		case R_BEGIN_TRY:
		case R_END_TRY:
a2782 1
		case R_BEGIN_TRY:
a2789 23
		case R_END_TRY:
		  /* The end of a exception handling region.  The reloc's
		     addend contains the offset of the exception handling
		     code.  */
		  if (bfd_reloc->addend == 0)
		    bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  else if (bfd_reloc->addend < 1024)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 1, p);
		      bfd_put_8 (abfd, bfd_reloc->addend / 4, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 2, reloc_queue);
		    }
		  else
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 2, p);
		      bfd_put_8 (abfd, (bfd_reloc->addend / 4) >> 16, p + 1);
		      bfd_put_16 (abfd, bfd_reloc->addend / 4, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  break;
		      
d3708 3
a3710 2
      /* For unknown symbols set the symbol's type based on the symbol's
	 section (ST_DATA for DATA sections, ST_CODE for CODE sections).  */
a3717 3
  
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN)
	info->symbol_type = ST_DATA;
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
d177 1
a177 1
static boolean som_bfd_is_local_label_name PARAMS ((bfd *, const char *));
d1451 2
a1452 2
  final_types = (int **) bfd_alloc (abfd, sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, sizeof (int));
d1476 1
a1476 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1492 1
a1492 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1503 1
a1503 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1514 1
a1514 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1525 1
a1525 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1535 1
a1535 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1546 1
a1546 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1550 1
a1550 1
	final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
d1569 4
a1572 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d1647 4
a1650 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d2017 3
a2019 2
      /* This can happen for a .o which defines symbols in otherwise
         empty subspaces.  */
d2021 8
a2028 15
	{
	  space_asect->_cooked_size = 0;
	  space_asect->_raw_size = 0;
	}
      else
	{
	  /* Setup the sizes for the space section based upon the info in the
	     last subspace of the space.  */
	  space_asect->_cooked_size = (save_subspace.subspace_start
				       - space_asect->vma
				       + save_subspace.subspace_length);
	  space_asect->_raw_size = (save_subspace.file_loc_init_value
				    - space_asect->filepos
				    + save_subspace.initialization_length);
	}
d4246 1
a4246 1
som_bfd_is_local_label_name (abfd, name)
d4248 1
a4248 1
     const char *name;
d4250 1
a4250 1
  return (name[0] == 'L' && name[1] == '$');
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d22 1
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d27 1
a27 1
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF) || defined(HOST_HPPAMPEIX)
d32 2
d38 1
a38 1
#include <ctype.h>
a49 4
#ifndef CPU_PA_RISC2_0
#define CPU_PA_RISC2_0 0x214
#endif /* CPU_PA_RISC2_0 */

a57 4
#ifndef _PA_RISC2_0_ID
#define _PA_RISC2_0_ID CPU_PA_RISC2_0
#endif /* _PA_RISC2_0_ID */

a142 2
  unsigned int priv_level;
  unsigned int secondary_def;
d150 2
a151 3
						    struct som_exec_auxhdr *,
						    unsigned long));
static boolean setup_sections PARAMS ((bfd *, struct header *, unsigned long));
d232 1
a232 2
						 unsigned *,
						 COMPUNIT *));
d253 2
a254 2
						      struct lst_header,
						      unsigned int));
d433 1
d435 1
d452 1
a452 1
  /* R_SHORT_PCREL_MODE */
a453 1
  /* R_LONG_PCREL_MODE */
d628 2
a629 2
  /* R_AUX_UNWIND */
  0,    "Sd=Vf=Ef=",    /* 0xcf */
d648 1
a648 1
  0,	"Eb=Sd=Ve=",	/* 0xda */
d650 1
a650 1
  0,	"Eb=Mb=",	/* 0xdb */
d654 1
a654 1
  0,    "Ob=Ve=",	/* 0xdd */
a744 1
#define NO_PCREL_MODES
a775 3
#define SOM_HOWTO(TYPE, NAME)	\
  HOWTO(TYPE, 0, 0, 32, false, 0, 0, hppa_som_reloc, NAME, false, 0, 0, false)

d1585 1
a1585 4
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
d1663 1
a1663 4
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
d1672 1
a1674 20

    case R_HPPA_PCREL_CALL:
      {
#ifndef NO_PCREL_MODES
	/* If we have short and long pcrel modes, then generate the proper
	   mode selector, then the pcrel relocation.  Redundant selectors
	   will be eliminted as the relocs are sized and emitted.  */
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	if (format == 17)
	  *final_types[0] = R_SHORT_PCREL_MODE;
	else
	  *final_types[0] = R_LONG_PCREL_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
#endif
	break;
      }
d1701 1
a1701 1
som_object_setup (abfd, file_hdrp, aux_hdrp, current_offset)
a1704 1
     unsigned long current_offset;
d1780 1
a1780 1
      bfd_get_start_address (abfd) = aux_hdrp->exec_entry + current_offset;
d1794 3
a1796 5
  obj_som_sym_filepos (abfd) = file_hdrp->symbol_location + current_offset;
  obj_som_str_filepos (abfd) = (file_hdrp->symbol_strings_location
				+ current_offset);
  obj_som_reloc_filepos (abfd) = (file_hdrp->fixup_request_location
				  + current_offset);
d1809 1
a1809 1
setup_sections (abfd, file_hdr, current_offset)
a1811 1
     unsigned long current_offset;
d1824 1
a1824 2
  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location, 
  		SEEK_SET) < 0)
d1840 2
a1841 4
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->space_location
		     + space_index * sizeof space),
		    SEEK_SET) < 0)
d1873 2
a1874 3
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof subspace),
d1880 2
a1881 3
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof subspace),
d1887 1
a1887 1
      space_asect->filepos = subspace.file_loc_init_value + current_offset;
d2011 1
a2011 2
	  subspace_asect->filepos = (subspace.file_loc_init_value
				     + current_offset);
a2083 4
  unsigned long current_offset = 0;
  struct lst_header lst_header;
  struct som_entry som_entry;
#define ENTRY_SIZE sizeof(struct som_entry)
d2110 3
a2116 58

#ifdef EXECLIBMAGIC
    case EXECLIBMAGIC:
      /* Read the lst header and determine where the SOM directory begins */

      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      if (bfd_read ((PTR) & lst_header, 1, SLSTHDR, abfd) != SLSTHDR)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      /* Position to and read the first directory entry */

      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) < 0)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      if (bfd_read ((PTR) & som_entry, 1, ENTRY_SIZE, abfd) != ENTRY_SIZE)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      /* Now position to the first SOM */

      if (bfd_seek (abfd, som_entry.location, SEEK_SET) < 0)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      current_offset = som_entry.location;

      /* And finally, re-read the som header */

      if (bfd_read ((PTR) & file_hdr, 1, FILE_HDR_SIZE, abfd) != FILE_HDR_SIZE)
        {
          if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
          return 0;
        }

      break;
#endif

d2143 1
a2143 1
  if (!setup_sections (abfd, &file_hdr, current_offset))
d2151 1
a2151 1
  return som_object_setup (abfd, &file_hdr, &aux_hdr, current_offset);
a2583 3
#ifndef NO_PCREL_MODES
 	  int current_call_mode;
#endif
a2617 3
#ifndef NO_PCREL_MODES
	  current_call_mode = R_SHORT_PCREL_MODE;
#endif
a2681 4
#ifndef NO_PCREL_MODES
		case R_SHORT_PCREL_MODE:
		case R_LONG_PCREL_MODE:
#endif
a2805 13
#ifndef NO_PCREL_MODES
		case R_LONG_PCREL_MODE:
		case R_SHORT_PCREL_MODE:
		  if (bfd_reloc->howto->type != current_call_mode)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      subspace_reloc_size += 1;
		      p += 1;
		      current_call_mode = bfd_reloc->howto->type;
		    }
		  break;
#endif

a2866 1
		case R_DATA_EXPR:
d2994 1
a2994 2
som_write_symbol_strings (abfd, current_offset, syms, num_syms, string_sizep,
			  compilation_unit)
a2999 1
     COMPUNIT *compilation_unit;
a3007 15
  unsigned char *comp[4];

  /* This gets a bit gruesome because of the compilation unit.  The
     strings within the compilation unit are part of the symbol
     strings, but don't have symbol_dictionary entries.  So, manually
     write them and update the compliation unit header.  On input, the
     compilation unit header contains local copies of the strings.
     Move them aside.  */
  if (compilation_unit)
    {
      comp[0] = compilation_unit->name.n_name;
      comp[1] = compilation_unit->language_name.n_name;
      comp[2] = compilation_unit->product_id.n_name;
      comp[3] = compilation_unit->version_id.n_name;
    }
a3016 60
  if (compilation_unit)
    {
      for (i = 0; i < 4; i++)
	{
	  int length = strlen (comp[i]);

	  /* If there is not enough room for the next entry, then dump
	     the current buffer contents now.  */
	  if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
	    {
	      if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
		  != p - tmp_space)
		return false;
	      /* Reset to beginning of the buffer space.  */
	      p = tmp_space;
	    }

	  /* First element in a string table entry is the length of
	     the string.  This must always be 4 byte aligned.  This is
	     also an appropriate time to fill in the string index
	     field in the symbol table entry.  */
	  bfd_put_32 (abfd, length, p);
	  strings_size += 4;
	  p += 4;

	  /* Next comes the string itself + a null terminator.  */
	  strcpy (p, comp[i]);

	  switch (i)
	    {
	    case 0:	
	      obj_som_compilation_unit (abfd)->name.n_strx = strings_size;
	      break;
	    case 1:
	      obj_som_compilation_unit (abfd)->language_name.n_strx = 
		strings_size;
	      break;
	    case 2:
	      obj_som_compilation_unit (abfd)->product_id.n_strx = 
		strings_size;
	      break;
	    case 3:
	      obj_som_compilation_unit (abfd)->version_id.n_strx = 
		strings_size;
	      break;
	    }

	  p += length + 1;
	  strings_size += length + 1;

	  /* Always align up to the next word boundary.  */
	  while (strings_size % 4)
	    {
	      bfd_put_8 (abfd, 0, p);
	      strings_size++;
	      p++;
	    }
	}
    }

d3208 1
a3208 1
  /* Next is the compilation unit. */
a3210 5
  if (obj_som_compilation_unit (abfd)) 
    {
      obj_som_file_hdr (abfd)->compiler_total = 1;
      current_offset += COMPUNITSZ; 
    }
d3458 1
a3458 2
				num_syms, &strings_size,
				obj_som_compilation_unit (abfd))
a3638 12
  /* Write the compilation unit record if there is one.  */
  if (obj_som_compilation_unit (abfd))
    {
      location = obj_som_file_hdr (abfd)->compiler_location;
      if (bfd_seek (abfd, location, SEEK_SET) < 0)
        return false;

      if (bfd_write ((PTR) obj_som_compilation_unit (abfd),
		     COMPUNITSZ, 1, abfd) != COMPUNITSZ)
        return false;
    }

a3642 2
  else if (bfd_get_mach (abfd) == pa20)
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC2_0;
d3664 1
a3664 1
      long tmp, som_length;
a3680 10
      /* Now perform some sanity checks.  The idea is to catch bogons now and
	 inform the user, instead of silently generating a bogus file.  */
      som_length = obj_som_file_hdr (abfd)->som_length;
      if (exec_header->exec_tfile + exec_header->exec_tsize > som_length
	  || exec_header->exec_dfile + exec_header->exec_dsize > som_length)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

d3759 1
a3759 2
	  info->arg_reloc = som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc;
	  info->priv_level= som_symbol_data (sym)->tc_data.ap.hppa_priv_level;
a3818 7

  /* The secondary_def field is for weak symbols.  */
  if (sym->flags & BSF_WEAK)
    info->secondary_def = true;
  else
    info->secondary_def = false;

d3860 1
a3860 3
      som_symtab[i].xleast = 3;
      som_symtab[i].symbol_value = info.symbol_value | info.priv_level;
      som_symtab[i].secondary_def = info.secondary_def;
d4074 1
a4074 1
      som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc = bufp->arg_reloc;
a4087 2
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
a4094 2
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
d4096 1
a4096 1
	  /* If the symbol's scope is SS_UNSAT, then these are
a4143 4
      /* Check for a weak symbol.  */
      if (bufp->secondary_def)
        sym->symbol.flags |= BSF_WEAK;

d4776 1
a4776 2
  output_symbol->tc_data.ap.hppa_arg_reloc =
    input_symbol->tc_data.ap.hppa_arg_reloc;
a4957 37
/* Attach an compilation unit header to the BFD backend so that it may be
   written into the object file.  */

boolean
bfd_som_attach_compilation_unit (abfd, name, language_name, product_id,
                                 version_id)
     bfd *abfd;
     const char *name;
     const char *language_name;
     const char *product_id;
     const char *version_id;
{
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, COMPUNITSZ);
  if (n == NULL)
    return false;

#define STRDUP(f) \
  if (f != NULL) \
    { \
      n->f.n_name = bfd_alloc (abfd, strlen (f) + 1); \
      if (n->f.n_name == NULL) \
	return false; \
      strcpy (n->f.n_name, f); \
    }

  STRDUP (name);
  STRDUP (language_name);
  STRDUP (product_id);
  STRDUP (version_id);

#undef STRDUP

  obj_som_compilation_unit (abfd) = n;

  return true;
}

d5040 1
a5040 1
  (*_bfd_error_handler) (_("som_sizeof_headers unimplemented"));
d5514 13
d5531 1
a5531 1
som_bfd_ar_write_symbol_stuff (abfd, nsyms, string_size, lst, elength)
a5534 1
     unsigned elength;
d5543 2
a5544 1
  unsigned int curr_som_offset, som_index = 0;
d5580 1
d5582 15
a5596 4
  /* We add in the size of the archive header twice as the location
     in the SOM dictionary is the actual offset of the SOM, not the
     archive header before the SOM.  */
  curr_som_offset = 8 + 2 * sizeof (struct ar_hdr) + lst.file_end;
d5599 3
a5601 4
     extended string table.  Note that elength includes the size
     of the archive header for the extended name table!  */
  if (elength)
    curr_som_offset += elength;
d5672 1
a5672 1
	  curr_lst_sym->secondary_def = info.secondary_def;
d5681 1
a5681 1
	  curr_lst_sym->xleast = 3;
d5686 1
a5686 1
	  curr_lst_sym->symbol_value = info.symbol_value | info.priv_level;
d5797 14
d5932 1
a5932 2
  if (som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength)
      == false)
a5986 2
#define som_construct_extended_name_table \
  _bfd_archive_coff_construct_extended_name_table
a6003 2
#define som_bfd_gc_sections		bfd_generic_gc_sections

a6056 2
  NULL,
  
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d6 1
a6 1
   University of Utah.
a24 1
#include "alloca-conf.h"
d75 1
d93 1
a93 1

d109 1
a109 1
   of some multi-byte relocation makes object files smaller.
d113 5
a117 4
struct reloc_queue {
  unsigned char *reloc;
  unsigned int size;
} reloc_queue[4];
d122 2
a123 1
typedef enum {
d135 2
a136 1
struct section_to_type {
d143 2
a144 1
struct som_misc_symbol_info {
d200 1
a200 1
static asection * bfd_section_from_som_symbol PARAMS ((bfd *,
d271 1
a271 1

d274 2
a275 2
   This table includes all the standard subspaces as defined in the
   current "PRO ABI for PA-RISC Systems", $UNWIND$ which for
d309 1
a309 1
   into BFD and symbolically printed by utilities.  To make actual use
d317 1
a317 1
   while possibly modifying the data in some manner.  They also can
d327 1
a327 1
   Each entry in the table has three fields.
d335 1
a335 1
   stream.
d337 1
a337 1
   The third field specifys whether or not this relocation may use
d341 2
a342 2
   Variables:

d354 2
a355 2

   Lower case letters (starting with 'b') refer to following
d357 1
a357 1
   c is the next 2 bytes, d is the next 3 bytes, etc...
d362 1
a362 1
   the constants are represented in decimal.
d365 1
a365 1
   '<' represents a left shift.
d371 2
a372 2
   Unwind Entries:

d382 2
a383 1
struct fixup_format {
d385 1
a385 1
  const char *format;
d388 2
a389 1
static const struct fixup_format som_fixup_formats[256] = {
d702 2
a703 1
static const int comp1_opcodes[] = {
d724 2
a725 1
static const int comp2_opcodes[] = {
d733 2
a734 1
static const int comp3_opcodes[] = {
d790 259
a1048 259
static reloc_howto_type som_hppa_howto_table[] = {
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_RELOCATION, "R_RELOCATION"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_SPACE_REF, "R_SPACE_REF"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_SHORT_PCREL_MODE, "R_SHORT_PCREL_MODE"),
  SOM_HOWTO (R_LONG_PCREL_MODE, "R_LONG_PCREL_MODE"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_BREAKPOINT, "R_BREAKPOINT"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ALT_ENTRY, "R_ALT_ENTRY"),
  SOM_HOWTO (R_EXIT, "R_EXIT"),
  SOM_HOWTO (R_BEGIN_TRY, "R_BEGIN_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_BEGIN_BRTAB, "R_BEGIN_BRTAB"),
  SOM_HOWTO (R_END_BRTAB, "R_END_BRTAB"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_DATA_EXPR, "R_DATA_EXPR"),
  SOM_HOWTO (R_CODE_EXPR, "R_CODE_EXPR"),
  SOM_HOWTO (R_FSEL, "R_FSEL"),
  SOM_HOWTO (R_LSEL, "R_LSEL"),
  SOM_HOWTO (R_RSEL, "R_RSEL"),
  SOM_HOWTO (R_N_MODE, "R_N_MODE"),
  SOM_HOWTO (R_S_MODE, "R_S_MODE"),
  SOM_HOWTO (R_D_MODE, "R_D_MODE"),
  SOM_HOWTO (R_R_MODE, "R_R_MODE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_TRANSLATED, "R_TRANSLATED"),
  SOM_HOWTO (R_AUX_UNWIND, "R_AUX_UNWIND"),
  SOM_HOWTO (R_COMP1, "R_COMP1"),
  SOM_HOWTO (R_COMP2, "R_COMP2"),
  SOM_HOWTO (R_COMP3, "R_COMP3"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_SEC_STMT, "R_SEC_STMT"),
  SOM_HOWTO (R_N0SEL, "R_N0SEL"),
  SOM_HOWTO (R_N1SEL, "R_N1SEL"),
  SOM_HOWTO (R_LINETAB, "R_LINETAB"),
  SOM_HOWTO (R_LINETAB_ESC, "R_LINETAB_ESC"),
  SOM_HOWTO (R_LTP_OVERRIDE, "R_LTP_OVERRIDE"),
  SOM_HOWTO (R_COMMENT, "R_COMMENT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED")
};

d1051 1
a1051 1

d1133 1
a1133 1
  abort ();
d1161 1
a1161 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1172 1
a1172 1
	 just built and use R_PREV_FIXUP instead.  We saved
d1190 1
a1190 1
   relocation stream via SUBSPACE_RELOC_SIZE_P; also return the
d1221 2
a1222 2

  /* The difference must be less than 0x1000000.  Use one
d1273 1
a1273 1
  if ((unsigned) (addend) + 0x80 < 0x100)
d1277 1
a1277 1
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
d1315 1
a1315 1

d1319 1
a1319 1

d1371 1
a1371 1

d1388 1
a1388 1

d1395 1
a1395 1

d1413 2
a1414 1
/* Return the logarithm of X, base 2, considering X unsigned.
d1435 1
a1435 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1437 2
a1438 2
     asymbol *symbol_in ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d1441 1
a1441 1
     char **error_message ATTRIBUTE_UNUSED;
d1470 1
a1470 1
  /* The field selector may require additional relocations to be
d1477 9
a1485 9
    case e_fsel:
    case e_psel:
    case e_lpsel:
    case e_rpsel:
      final_types[0] = final_type;
      final_types[1] = NULL;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1487 16
a1502 16
    case e_tsel:
    case e_ltsel:
    case e_rtsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      if (field == e_tsel)
	*final_types[0] = R_FSEL;
      else if (field == e_ltsel)
	*final_types[0] = R_LSEL;
      else
	*final_types[0] = R_RSEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1504 10
a1513 10
    case e_lssel:
    case e_rssel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_S_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1515 10
a1524 10
    case e_lsel:
    case e_rsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1526 10
a1535 10
    case e_ldsel:
    case e_rdsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_D_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1537 10
a1546 10
    case e_lrsel:
    case e_rrsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_R_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1548 9
a1556 9
    case e_nsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N1SEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;
d1558 17
a1574 17
    case e_nlsel:
    case e_nlrsel:
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N0SEL;
      final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
      if (!final_types[1])
	return NULL;
      if (field == e_nlsel)
	*final_types[1] = R_N_MODE;
      else
	*final_types[1] = R_R_MODE;
      final_types[2] = final_type;
      final_types[3] = NULL;
      *final_type = base_type;
      break;
d1576 1
a1576 1

d1583 4
a1586 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1588 1
a1588 1
	    return NULL;
d1608 2
a1609 2
	       || field == e_lpsel
	       || field == e_rpsel)
d1620 2
a1621 2
	       || field == e_ltsel
	       || field == e_rtsel)
d1651 1
d1664 4
a1667 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1669 1
a1669 1
	    return NULL;
d1721 1
d1724 1
a1724 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1787 1
a1787 1
    bfd_zalloc (abfd, sizeof (struct som_exec_data));
d1798 1
a1798 1

d1827 1
a1827 1
  /* Initialize the saved symbol table and string table to NULL.
d1830 1
a1830 1
  obj_som_stringtab (abfd) = (char *) NULL;
d1861 1
a1861 1
  /* First, read in space names.  */
d1867 2
a1868 2
  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location,
		SEEK_SET) < 0)
d1874 1
a1874 1
  /* Loop over all of the space dictionaries, building up sections.  */
d1883 1
a1883 1
      /* Read the space dictionary element.  */
d1892 1
a1892 1
      /* Setup the space name string.  */
d1895 1
a1895 1
      /* Make a section out of it.  */
d1900 1
a1900 1

d1905 1
a1905 1
      if (space.is_loadable == 0)
d1918 1
a1918 1
      /* Now, read in the first subspace for this space.  */
d1926 1
a1926 1
      /* Seek back to the start of the subspaces for loop below.  */
d1933 1
a1933 2
      /* Setup the start address and file loc from the first subspace
         record.  */
d1944 1
a1944 1
      /* Loop over the rest of the subspaces, building up more sections.  */
d1950 1
a1950 1
	  /* Read in the next subspace.  */
d1955 1
a1955 1
	  /* Setup the subspace name string.  */
d1963 1
a1963 1
	  /* Make a section out of this subspace.  */
d1975 1
a1975 1
	  /* Keep an easy mapping between subspaces and sections.
d1991 1
a1991 1
	    /* Readonly data.  */
d1996 1
a1996 1
	    /* Normal data.  */
d2017 2
a2018 2

	  if (subspace.dup_common || subspace.is_common)
d2047 1
a2047 1
	      /* We can not determine this yet.  When we read in the
d2102 1
a2102 1

d2136 1
a2136 1
#define ENTRY_SIZE sizeof (struct som_entry)
d2170 1
a2170 1
      /* Read the lst header and determine where the SOM directory begins.  */
d2173 2
a2174 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2176 2
a2177 2
	  return 0;
	}
d2180 2
a2181 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2183 2
a2184 2
	  return 0;
	}
d2186 1
a2186 1
      /* Position to and read the first directory entry.  */
d2189 2
a2190 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2192 2
a2193 2
	  return 0;
	}
d2196 2
a2197 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2199 2
a2200 2
	  return 0;
	}
d2202 1
a2202 1
      /* Now position to the first SOM.  */
d2205 2
a2206 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2208 2
a2209 2
	  return 0;
	}
d2213 1
a2213 1
      /* And finally, re-read the som header.  */
d2216 2
a2217 2
	{
	  if (bfd_get_error () != bfd_error_system_call)
d2219 2
a2220 2
	  return 0;
	}
d2323 1
a2323 1
  file_hdr->file_time.nanosecs = 0;
d2339 1
a2339 1

d2343 3
a2345 3
	  som_section_data (section)->space_dict =
	    (struct space_dictionary_record *)
	    bfd_zalloc (abfd, sizeof (struct space_dictionary_record));
d2354 1
a2354 1
	  som_section_data (section)->space_dict->sort_key =
d2356 1
a2356 1
	  som_section_data (section)->space_dict->is_defined =
d2358 1
a2358 1
	  som_section_data (section)->space_dict->is_private =
d2387 1
a2387 1
	  som_section_data (section)->subspace_dict->subspace_start =
d2393 1
a2393 1
	  som_section_data (section)->subspace_dict->alignment =
d2475 1
a2475 1
    count += som_is_space (section);
d2510 1
a2510 1

d2542 2
a2543 1

d2607 1
a2607 1
	  /* Scaling to encourage symbols involved in R_DP_RELATIVE
d2648 1
a2648 1
	som_symbol_data (sorted_syms[i])->index = i;
d2693 1
a2693 1
	  int current_call_mode;
d2715 1
a2715 1
	  /* To make life easier start over with a clean slate for
d2733 1
a2733 1
	  /* Translate each BFD relocation into one or more SOM
d2741 1
a2741 1
	      /* Get the symbol number.  Remember it's stored in a
d2747 1
a2747 1

d2750 1
a2750 1
		 the relocation queue.
d2821 1
a2821 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
d2841 1
a2841 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2856 1
a2856 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
d2870 1
a2870 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2891 1
a2891 1

d2895 1
a2895 1
			tmp_reloc = subsection->orelocation[tmp];
d2908 1
a2908 1

d2974 1
a2974 1

d2976 1
a2976 1
		  /* The only time we generate R_COMP1, R_COMP2 and
d2986 1
a2986 1
		  /* The only time we generate R_COMP1, R_COMP2 and
d2999 1
a2999 1
		  /* The only time we generate R_COMP1, R_COMP2 and
d3020 1
a3020 1
	  p = som_reloc_skip (abfd, bfd_section_size (abfd, subsection)
d3050 2
a3051 3
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;
d3055 3
d3067 1
a3067 1
      size_t length;
d3078 3
a3080 4
         current buffer contents now and maybe allocate a larger
         buffer.  Each entry will take 4 bytes to hold the string
         length + the string itself + null terminator.  */
      if (p - tmp_space + 5 + length > tmp_space_size)
a3081 1
	  /* Flush buffer before refilling or reallocating.  */
d3083 1
a3083 1
	      != p - tmp_space)
d3085 1
a3085 17

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* Ensure a minimum growth factor to avoid O(n**2) space
                 consumption for n strings.  The optimal minimum
                 factor seems to be 2, as no other value can guarantee
                 wasting less then 50% space.  (Note that we cannot
                 deallocate space allocated by `alloca' without
                 returning from this function.)  The same technique is
                 used a few more times below when a buffer is
                 reallocated.  */
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
d3136 1
a3136 1

d3139 2
a3140 4
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;

d3158 3
d3170 1
a3170 1
	  size_t length = strlen (comp[i]);
d3173 2
a3174 3
	     the current buffer contents now and maybe allocate a
	     larger buffer.  */
	  if (p - tmp_space + 5 + length > tmp_space_size)
a3175 1
	      /* Flush buffer before refilling or reallocating.  */
d3179 1
a3179 11

	      /* Reallocate if now empty buffer still too small.  */
	      if (5 + length > tmp_space_size)
		{
		  /* See alloca above for discussion of new size.  */
		  tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
		  tmp_space = alloca (tmp_space_size);
		}

	      /* Reset to beginning of the (possibly new) buffer
                 space.  */
d3196 1
a3196 1
	    case 0:
d3200 1
a3200 1
	      obj_som_compilation_unit (abfd)->language_name.n_strx =
d3204 1
a3204 1
	      obj_som_compilation_unit (abfd)->product_id.n_strx =
d3208 1
a3208 1
	      obj_som_compilation_unit (abfd)->version_id.n_strx =
d3228 1
a3228 1
      size_t length = strlen (syms[i]->name);
d3231 2
a3232 2
	 current buffer contents now and maybe allocate a larger buffer.  */
     if (p - tmp_space + 5 + length > tmp_space_size)
a3233 1
	  /* Flush buffer before refilling or reallocating.  */
d3237 1
a3237 10

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* See alloca above for discussion of new size.  */
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
d3252 1
a3252 1
      som_symbol_data (syms[i])->stringtab_offset = strings_size;
d3258 1
a3258 1
	{
d3262 1
a3262 1
	}
d3273 1
a3273 1
/* Compute variable information to be placed in the SOM headers,
d3277 1
a3277 1
static boolean
d3283 1
d3289 1
a3289 1
  /* The file header will always be first in an object file,
d3301 1
a3301 1
  current_offset += sizeof (struct header);
d3404 1
a3404 1
  /* Mark the offset of the space/subspace string table in the
d3417 1
a3417 1
  /* Next is the compilation unit.  */
d3420 1
a3420 1
  if (obj_som_compilation_unit (abfd))
d3423 1
a3423 1
      current_offset += COMPUNITSZ;
d3485 1
a3485 1
		 loader will create holes between subspaces *and*
d3514 1
d3529 1
a3529 1
	      current_offset += bfd_section_size (abfd, subsection);
d3546 1
a3546 1
      section = section->next;
d3574 1
a3574 1

d3587 1
a3587 1
	      current_offset += bfd_section_size (abfd, subsection);
d3599 1
a3599 1
      section = section->next;
d3648 1
a3648 1
     at this time.
d3657 1
a3657 1
    current_offset += (4 - (current_offset % 4));
d3690 1
a3690 1
    current_offset += (4 - (current_offset % 4));
d3703 1
a3703 1

d3732 1
a3732 1

d3760 1
a3760 1

d3768 1
a3768 1
      section = section->next;
d3787 1
a3787 1

d3811 1
a3811 1
	  subspace_index++;
d3816 1
a3816 1

d3824 1
a3824 1
      section = section->next;
d3839 1
d3844 1
a3844 1
      /* Dump its header.  */
d3859 1
a3859 1
	return false;
d3863 1
a3863 1
	return false;
d3869 1
a3869 1
    obj_som_file_hdr (abfd)->system_id = obj_som_exec_data (abfd)->system_id;
d3871 1
a3871 1
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC2_0;
d3873 1
a3873 1
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_1;
d3875 1
a3875 1
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_0;
d3950 1
a3950 1
     bfd *abfd ATTRIBUTE_UNUSED;
d3961 1
a3961 1

d4011 1
a4011 1

d4031 1
a4031 1

d4037 1
a4037 2
  else if (sym->flags & (BSF_EXPORT | BSF_WEAK)
	   && ! bfd_is_com_section (sym->section))
d4052 1
a4052 1
  /* For all other symbols, the symbol_info field contains the
d4094 2
a4095 2
      /* This is really an index into the symbol strings table.
	 By the time we get here, the index has already been
d4129 1
a4129 1
/* Write an object in SOM format.  */
d4148 1
d4179 1
a4179 1

d4184 1
a4184 1
  /* Save our results and return success.  */
d4288 1
a4288 1
  if (bfd_read (buf, symbol_count * symsize, 1, abfd)
d4353 1
d4399 1
a4399 1
	sym->symbol.flags |= BSF_WEAK;
d4469 1
a4469 1
    (som_symbol_type *) bfd_zalloc (abfd, sizeof (som_symbol_type));
d4481 1
a4481 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d4510 1
a4510 1
     bfd *abfd ATTRIBUTE_UNUSED;
d4525 1
a4525 1
   not just counting
d4541 1
a4541 1
  const char *cp;
d4545 1
a4545 1
  arelent *rptr = internal_relocs;
d4608 1
a4608 1
	 parse RHS, then assign to LHS.  Repeat until no more
d4646 1
d4802 1
a4802 1
      /* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION
d4819 2
d4846 1
a4846 1

d4870 1
a4870 1
/* Read in the relocs (aka fixups in SOM terms) for a section.
d4872 1
a4872 1
   som_get_reloc_upper_bound calls this routine with JUST_COUNT
d4893 1
a4893 1
  /* If reloc_count is -1, then the relocation stream has not been
d4900 1
a4900 1
      /* Read in the external forms.  */
d4930 1
a4930 1
  internal_relocs = (arelent *)
d4949 1
a4949 1
   information associated with the given section.  */
d5009 1
a5009 1
  /* We allow more than three sections internally.  */
a5040 1

d5054 3
a5056 3
  som_section_data (osection)->copy_data =
    (struct som_copyable_section_data_struct *)
    bfd_zalloc (obfd, sizeof (struct som_copyable_section_data_struct));
d5111 4
a5114 4
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
d5126 1
a5126 1
/* Set backend info for subsections which can not be described
d5141 4
a5144 4
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
a5170 1

d5221 1
a5221 1
				 version_id)
d5263 3
a5265 3
  if ((bfd_size_type) (offset+count) > section->_raw_size
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) == -1
      || bfd_read (location, (bfd_size_type) 1, count, abfd) != count)
d5297 1
a5297 1
  offset += som_section_data (section)->subspace_dict->file_loc_init_value;
d5312 1
a5312 1
  /* Allow any architecture to be supported by the SOM backend.  */
d5318 8
a5325 8
		       functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     CONST char **filename_ptr ATTRIBUTE_UNUSED;
     CONST char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
d5332 2
a5333 2
     bfd *abfd ATTRIBUTE_UNUSED;
     boolean reloc ATTRIBUTE_UNUSED;
d5368 1
a5368 3
  if (symbol->flags & BSF_WEAK)
    return 'W';
  if (!(symbol->flags & (BSF_GLOBAL | BSF_LOCAL)))
d5388 1
a5388 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d5394 1
a5394 1
    ret->value = symbol->value + symbol->section->vma;
d5413 1
a5413 1
  hash_table =
d5491 1
a5491 1
  hash_table =
d5514 1
a5514 1
  if (bfd_read ((PTR) som_dict, lst_header->module_count,
d5579 1
a5579 1
	  if (bfd_seek (abfd, lst_filepos + lst_header->string_loc
d5604 1
a5604 1
  /* If we haven't died by now, then we successfully read the entire
a5620 1

d5690 1
a5690 1
  if (bfd_seek (abfd, ardata->first_file_filepos - parsed_size
a5794 1

d5806 1
a5806 1
	  | (symbol->name[len - 2] << 8) | symbol->name[len - 1];
d5811 1
a5811 1

d5851 1
a5851 1
  memset (last_hash_entry, 0,
d5877 1
a5877 1
  /* FIXME should be done with buffers just like everything else...  */
d5974 1
a5974 1
		  + lst.hash_size * 4
d5983 1
a5983 1
		  + lst.hash_size * 4
d5993 1
d5999 1
a5999 1
	  while ((int) p % 4)
d6012 1
a6012 1

d6072 1
d6077 3
a6079 3
     struct orl *map ATTRIBUTE_UNUSED;
     unsigned int orl_count ATTRIBUTE_UNUSED;
     int stridx ATTRIBUTE_UNUSED;
d6087 1
a6087 1

d6159 1
a6159 1
  p = (int *) &lst;
d6161 1
a6161 1
  for (i = 0; i < sizeof (struct lst_header) / sizeof (int) - 1; i++)
d6192 1
a6192 1

d6226 1
a6226 1
/* End of miscellaneous support functions.  */
a6228 1

d6231 1
a6231 1
     bfd *abfd ATTRIBUTE_UNUSED;
d6266 3
a6268 1
const bfd_target som_vec = {
d6320 1
a6320 1

@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
a33 1
#include "safe-ctype.h"
d39 1
d41 1
a41 1
/* Magic not defined in standard HP-UX header files until 8.0.  */
d105 1
a105 1
  (((val) + (alignment) - 1) &~ ((unsigned long) (alignment) - 1))
d151 1
a151 1
/* Forward declarations.  */
d153 29
a181 39
static bfd_boolean som_mkobject
  PARAMS ((bfd *));
static const bfd_target * som_object_setup
  PARAMS ((bfd *, struct header *, struct som_exec_auxhdr *, unsigned long));
static bfd_boolean setup_sections
  PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p
  PARAMS ((bfd *));
static bfd_boolean som_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean som_slurp_string_table
  PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table
  PARAMS ((bfd *));
static long som_get_symtab_upper_bound
  PARAMS ((bfd *));
static long som_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static long som_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info
  PARAMS ((unsigned char *, unsigned int, arelent *, asection *,
	   asymbol **, bfd_boolean));
static bfd_boolean som_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long som_get_symtab
  PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol
  PARAMS ((bfd *));
static void som_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean som_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean som_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean som_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean som_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d184 58
a241 67
static bfd_boolean som_bfd_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean som_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean som_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static void som_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol
  PARAMS ((bfd *, struct symbol_dictionary_record *));
static int log2
  PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void som_initialize_reloc_queue
  PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static void som_reloc_queue_fix
  PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * try_prev_fixup
  PARAMS ((bfd *, int *, unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * som_reloc_skip
  PARAMS ((bfd *, unsigned int, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_addend
  PARAMS ((bfd *, bfd_vma, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_call
  PARAMS ((bfd *, unsigned char *, unsigned int *, arelent *, int,
	   struct reloc_queue *));
static unsigned long som_count_spaces
  PARAMS ((bfd *));
static unsigned long som_count_subspaces
  PARAMS ((bfd *));
static int compare_syms
  PARAMS ((const void *, const void *));
static int compare_subspaces
  PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean som_prep_headers
  PARAMS ((bfd *));
static int som_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean som_finish_writing
  PARAMS ((bfd *));
static bfd_boolean som_build_and_write_symbol_table
  PARAMS ((bfd *));
static void som_prep_for_fixups
  PARAMS ((bfd *, asymbol **, unsigned long));
static bfd_boolean som_write_fixups
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_space_strings
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_symbol_strings
  PARAMS ((bfd *, unsigned long, asymbol **, unsigned int, unsigned *,
	   COMPUNIT *));
static bfd_boolean som_begin_writing
  PARAMS ((bfd *));
d243 25
a267 32
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type
  PARAMS ((const char *));
static int som_decode_symclass
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_count_ar_symbols
  PARAMS ((bfd *, struct lst_header *, symindex *));
static bfd_boolean som_bfd_fill_in_ar_symbols
  PARAMS ((bfd *, struct lst_header *, carsym **));
static bfd_boolean som_slurp_armap
  PARAMS ((bfd *));
static bfd_boolean som_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static void som_bfd_derive_misc_symbol_info
  PARAMS ((bfd *, asymbol *, struct som_misc_symbol_info *));
static bfd_boolean som_bfd_prep_for_ar_write
  PARAMS ((bfd *, unsigned int *, unsigned int *));
static unsigned int som_bfd_ar_symbol_hash
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_ar_write_symbol_stuff
  PARAMS ((bfd *, unsigned int, unsigned int, struct lst_header,
	   unsigned int));
static bfd_boolean som_is_space
  PARAMS ((asection *));
static bfd_boolean som_is_subspace
  PARAMS ((asection *));
static bfd_boolean som_is_container
  PARAMS ((asection *, asection *));
static bfd_boolean som_bfd_free_cached_info
  PARAMS ((bfd *));
static bfd_boolean som_bfd_link_split_section
  PARAMS ((bfd *, asection *));
d386 32
a417 32
  {  0, "LD1+4*=" },		/* 0x00 */
  {  1, "LD1+4*=" },		/* 0x01 */
  {  2, "LD1+4*=" },		/* 0x02 */
  {  3, "LD1+4*=" },		/* 0x03 */
  {  4, "LD1+4*=" },		/* 0x04 */
  {  5, "LD1+4*=" },		/* 0x05 */
  {  6, "LD1+4*=" },		/* 0x06 */
  {  7, "LD1+4*=" },		/* 0x07 */
  {  8, "LD1+4*=" },		/* 0x08 */
  {  9, "LD1+4*=" },		/* 0x09 */
  { 10, "LD1+4*=" },		/* 0x0a */
  { 11, "LD1+4*=" },		/* 0x0b */
  { 12, "LD1+4*=" },		/* 0x0c */
  { 13, "LD1+4*=" },		/* 0x0d */
  { 14, "LD1+4*=" },		/* 0x0e */
  { 15, "LD1+4*=" },		/* 0x0f */
  { 16, "LD1+4*=" },		/* 0x10 */
  { 17, "LD1+4*=" },		/* 0x11 */
  { 18, "LD1+4*=" },		/* 0x12 */
  { 19, "LD1+4*=" },		/* 0x13 */
  { 20, "LD1+4*=" },		/* 0x14 */
  { 21, "LD1+4*=" },		/* 0x15 */
  { 22, "LD1+4*=" },		/* 0x16 */
  { 23, "LD1+4*=" },		/* 0x17 */
  {  0, "LD8<b+1+4*=" },	/* 0x18 */
  {  1, "LD8<b+1+4*=" },	/* 0x19 */
  {  2, "LD8<b+1+4*=" },	/* 0x1a */
  {  3, "LD8<b+1+4*=" },	/* 0x1b */
  {  0, "LD16<c+1+4*=" },	/* 0x1c */
  {  1, "LD16<c+1+4*=" },	/* 0x1d */
  {  2, "LD16<c+1+4*=" },	/* 0x1e */
  {  0, "Ld1+=" },		/* 0x1f */
d419 2
a420 2
  {  0, "Lb1+4*=" },		/* 0x20 */
  {  1, "Ld1+=" },		/* 0x21 */
d422 2
a423 2
  {  0, "Lb1+4*=" },		/* 0x22 */
  {  1, "Ld1+=" },		/* 0x23 */
d425 1
a425 1
  {  0, "L4=" },		/* 0x24 */
d427 2
a428 2
  {  0, "L4=Sb=" },		/* 0x25 */
  {  1, "L4=Sd=" },		/* 0x26 */
d430 2
a431 2
  {  0, "L4=Sb=" },		/* 0x27 */
  {  1, "L4=Sd=" },		/* 0x28 */
d433 1
a433 1
  {  0, "L4=" },		/* 0x29 */
d435 6
a440 6
  {  0, "L4=Mb1+4*=" },		/* 0x2a */
  {  1, "Lb4*=Mb1+L*=" },	/* 0x2b */
  {  2, "Lb4*=Md1+4*=" },	/* 0x2c */
  {  3, "Ld1+=Me1+=" },		/* 0x2d */
  {  0, "" },			/* 0x2e */
  {  0, "" },			/* 0x2f */
d442 14
a455 14
  {  0, "L4=RD=Sb=" },		/* 0x30 */
  {  1, "L4=RD=Sb=" },		/* 0x31 */
  {  2, "L4=RD=Sb=" },		/* 0x32 */
  {  3, "L4=RD=Sb=" },		/* 0x33 */
  {  4, "L4=RD=Sb=" },		/* 0x34 */
  {  5, "L4=RD=Sb=" },		/* 0x35 */
  {  6, "L4=RD=Sb=" },		/* 0x36 */
  {  7, "L4=RD=Sb=" },		/* 0x37 */
  {  8, "L4=RD=Sb=" },		/* 0x38 */
  {  9, "L4=RD=Sb=" },		/* 0x39 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x3a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x3b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x3c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x3d */
d457 1
a457 1
  {  0, "" },			/* 0x3e */
d459 1
a459 1
  {  0, "" },			/* 0x3f */
d461 14
a474 14
  {  0, "L4=RD=Sb=" },		/* 0x40 */
  {  1, "L4=RD=Sb=" },		/* 0x41 */
  {  2, "L4=RD=Sb=" },		/* 0x42 */
  {  3, "L4=RD=Sb=" },		/* 0x43 */
  {  4, "L4=RD=Sb=" },		/* 0x44 */
  {  5, "L4=RD=Sb=" },		/* 0x45 */
  {  6, "L4=RD=Sb=" },		/* 0x46 */
  {  7, "L4=RD=Sb=" },		/* 0x47 */
  {  8, "L4=RD=Sb=" },		/* 0x48 */
  {  9, "L4=RD=Sb=" },		/* 0x49 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x4a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x4b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x4c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x4d */
d476 2
a477 2
  {  0, "" },			/* 0x4e */
  {  0, "" },			/* 0x4f */
d479 34
a512 34
  {  0, "L4=SD=" },		/* 0x50 */
  {  1, "L4=SD=" },		/* 0x51 */
  {  2, "L4=SD=" },		/* 0x52 */
  {  3, "L4=SD=" },		/* 0x53 */
  {  4, "L4=SD=" },		/* 0x54 */
  {  5, "L4=SD=" },		/* 0x55 */
  {  6, "L4=SD=" },		/* 0x56 */
  {  7, "L4=SD=" },		/* 0x57 */
  {  8, "L4=SD=" },		/* 0x58 */
  {  9, "L4=SD=" },		/* 0x59 */
  { 10, "L4=SD=" },		/* 0x5a */
  { 11, "L4=SD=" },		/* 0x5b */
  { 12, "L4=SD=" },		/* 0x5c */
  { 13, "L4=SD=" },		/* 0x5d */
  { 14, "L4=SD=" },		/* 0x5e */
  { 15, "L4=SD=" },		/* 0x5f */
  { 16, "L4=SD=" },		/* 0x60 */
  { 17, "L4=SD=" },		/* 0x61 */
  { 18, "L4=SD=" },		/* 0x62 */
  { 19, "L4=SD=" },		/* 0x63 */
  { 20, "L4=SD=" },		/* 0x64 */
  { 21, "L4=SD=" },		/* 0x65 */
  { 22, "L4=SD=" },		/* 0x66 */
  { 23, "L4=SD=" },		/* 0x67 */
  { 24, "L4=SD=" },		/* 0x68 */
  { 25, "L4=SD=" },		/* 0x69 */
  { 26, "L4=SD=" },		/* 0x6a */
  { 27, "L4=SD=" },		/* 0x6b */
  { 28, "L4=SD=" },		/* 0x6c */
  { 29, "L4=SD=" },		/* 0x6d */
  { 30, "L4=SD=" },		/* 0x6e */
  { 31, "L4=SD=" },		/* 0x6f */
  { 32, "L4=Sb=" },		/* 0x70 */
  { 33, "L4=Sd=" },		/* 0x71 */
d514 6
a519 6
  {  0, "" },			/* 0x72 */
  {  0, "" },			/* 0x73 */
  {  0, "" },			/* 0x74 */
  {  0, "" },			/* 0x75 */
  {  0, "" },			/* 0x76 */
  {  0, "" },			/* 0x77 */
d521 2
a522 2
  {  0, "L4=Sb=" },		/* 0x78 */
  {  1, "L4=Sd=" },		/* 0x79 */
d524 6
a529 6
  {  0, "" },			/* 0x7a */
  {  0, "" },			/* 0x7b */
  {  0, "" },			/* 0x7c */
  {  0, "" },			/* 0x7d */
  {  0, "" },			/* 0x7e */
  {  0, "" },			/* 0x7f */
d531 34
a564 34
  {  0, "L4=SD=" },		/* 0x80 */
  {  1, "L4=SD=" },		/* 0x81 */
  {  2, "L4=SD=" },		/* 0x82 */
  {  3, "L4=SD=" },		/* 0x83 */
  {  4, "L4=SD=" },		/* 0x84 */
  {  5, "L4=SD=" },		/* 0x85 */
  {  6, "L4=SD=" },		/* 0x86 */
  {  7, "L4=SD=" },		/* 0x87 */
  {  8, "L4=SD=" },		/* 0x88 */
  {  9, "L4=SD=" },		/* 0x89 */
  { 10, "L4=SD=" },		/* 0x8q */
  { 11, "L4=SD=" },		/* 0x8b */
  { 12, "L4=SD=" },		/* 0x8c */
  { 13, "L4=SD=" },		/* 0x8d */
  { 14, "L4=SD=" },		/* 0x8e */
  { 15, "L4=SD=" },		/* 0x8f */
  { 16, "L4=SD=" },		/* 0x90 */
  { 17, "L4=SD=" },		/* 0x91 */
  { 18, "L4=SD=" },		/* 0x92 */
  { 19, "L4=SD=" },		/* 0x93 */
  { 20, "L4=SD=" },		/* 0x94 */
  { 21, "L4=SD=" },		/* 0x95 */
  { 22, "L4=SD=" },		/* 0x96 */
  { 23, "L4=SD=" },		/* 0x97 */
  { 24, "L4=SD=" },		/* 0x98 */
  { 25, "L4=SD=" },		/* 0x99 */
  { 26, "L4=SD=" },		/* 0x9a */
  { 27, "L4=SD=" },		/* 0x9b */
  { 28, "L4=SD=" },		/* 0x9c */
  { 29, "L4=SD=" },		/* 0x9d */
  { 30, "L4=SD=" },		/* 0x9e */
  { 31, "L4=SD=" },		/* 0x9f */
  { 32, "L4=Sb=" },		/* 0xa0 */
  { 33, "L4=Sd=" },		/* 0xa1 */
d566 12
a577 12
  {  0, "" },			/* 0xa2 */
  {  0, "" },			/* 0xa3 */
  {  0, "" },			/* 0xa4 */
  {  0, "" },			/* 0xa5 */
  {  0, "" },			/* 0xa6 */
  {  0, "" },			/* 0xa7 */
  {  0, "" },			/* 0xa8 */
  {  0, "" },			/* 0xa9 */
  {  0, "" },			/* 0xaa */
  {  0, "" },			/* 0xab */
  {  0, "" },			/* 0xac */
  {  0, "" },			/* 0xad */
d579 2
a580 2
  {  0, "L4=Sb=" },		/* 0xae */
  {  1, "L4=Sd=" },		/* 0xaf */
d582 2
a583 2
  {  0, "L4=Sb=" },		/* 0xb0 */
  {  1, "L4=Sd=" },		/* 0xb1 */
d585 1
a585 1
  {  0, "L4=" },		/* 0xb2 */
d587 2
a588 2
  {  0, "Te=Ue=" },		/* 0xb3 */
  {  1, "Uf=" },		/* 0xb4 */
d590 1
a590 1
  {  0, "" },			/* 0xb5 */
d592 1
a592 1
  {  0, "" },			/* 0xb6 */
d594 1
a594 1
  {  0, "" },			/* 0xb7 */
d596 3
a598 3
  {  0, "R0=" },		/* 0xb8 */
  {  1, "Rb4*=" },		/* 0xb9 */
  {  2, "Rd4*=" },		/* 0xba */
d600 1
a600 1
  {  0, "" },			/* 0xbb */
d602 1
a602 1
  {  0, "" },			/* 0xbc */
d604 3
a606 3
  {  0, "Nb=" },		/* 0xbd */
  {  1, "Nc=" },		/* 0xbe */
  {  2, "Nd=" },		/* 0xbf */
d608 1
a608 1
  {  0, "L4=" },		/* 0xc0 */
d610 1
a610 1
  {  0, "L4=" },		/* 0xc1 */
d612 1
a612 1
  {  0, "" },			/* 0xc2 */
d614 1
a614 1
  {  0, "" },			/* 0xc3 */
d616 1
a616 1
  {  0, "" },			/* 0xc4 */
d618 1
a618 1
  {  0, "" },			/* 0xc5 */
d620 1
a620 1
  {  0, "" },			/* 0xc6 */
d622 1
a622 1
  {  0, "" },			/* 0xc7 */
d624 1
a624 1
  {  0, "" },			/* 0xc8 */
d626 5
a630 5
  {  0, "V0=" },		/* 0xc9 */
  {  1, "Vb=" },		/* 0xca */
  {  2, "Vc=" },		/* 0xcb */
  {  3, "Vd=" },		/* 0xcc */
  {  4, "Ve=" },		/* 0xcd */
d632 1
a632 1
  {  0, "" },			/* 0xce */
d634 1
a634 1
  {  0,"Sd=Ve=Ee=" },	       /* 0xcf */
d636 1
a636 1
  {  0, "Ob=" },		/* 0xd0 */
d638 1
a638 1
  {  0, "Ob=Sd=" },		/* 0xd1 */
d640 1
a640 1
  {  0, "Ob=Ve=" },		/* 0xd2 */
d642 4
a645 4
  {  0, "P" },			/* 0xd3 */
  {  1, "P" },			/* 0xd4 */
  {  2, "P" },			/* 0xd5 */
  {  3, "P" },			/* 0xd6 */
d647 1
a647 1
  {  0, "" },			/* 0xd7 */
d649 1
a649 1
  {  0, "" },			/* 0xd8 */
d651 1
a651 1
  {  0, "" },			/* 0xd9 */
d653 1
a653 1
  {  0, "Eb=Sd=Ve=" },		/* 0xda */
d655 1
a655 1
  {  0, "Eb=Mb=" },		/* 0xdb */
d657 1
a657 1
  {  0, "" },			/* 0xdc */
d659 1
a659 1
  {  0, "Ob=Vf=" },		/* 0xdd */
d661 34
a694 34
  {  0, "" },			/* 0xde */
  {  0, "" },			/* 0xdf */
  {  0, "" },			/* 0xe0 */
  {  0, "" },			/* 0xe1 */
  {  0, "" },			/* 0xe2 */
  {  0, "" },			/* 0xe3 */
  {  0, "" },			/* 0xe4 */
  {  0, "" },			/* 0xe5 */
  {  0, "" },			/* 0xe6 */
  {  0, "" },			/* 0xe7 */
  {  0, "" },			/* 0xe8 */
  {  0, "" },			/* 0xe9 */
  {  0, "" },			/* 0xea */
  {  0, "" },			/* 0xeb */
  {  0, "" },			/* 0xec */
  {  0, "" },			/* 0xed */
  {  0, "" },			/* 0xee */
  {  0, "" },			/* 0xef */
  {  0, "" },			/* 0xf0 */
  {  0, "" },			/* 0xf1 */
  {  0, "" },			/* 0xf2 */
  {  0, "" },			/* 0xf3 */
  {  0, "" },			/* 0xf4 */
  {  0, "" },			/* 0xf5 */
  {  0, "" },			/* 0xf6 */
  {  0, "" },			/* 0xf7 */
  {  0, "" },			/* 0xf8 */
  {  0, "" },			/* 0xf9 */
  {  0, "" },			/* 0xfa */
  {  0, "" },			/* 0xfb */
  {  0, "" },			/* 0xfc */
  {  0, "" },			/* 0xfd */
  {  0, "" },			/* 0xfe */
  {  0, "" },			/* 0xff */
d780 1
a780 1
  HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)
d1201 1
a1201 1
      bfd_put_16 (abfd, (bfd_vma) 0xffff, p + 2);
d1237 1
a1237 1
	  bfd_put_16 (abfd, (bfd_vma) (skip >> 2) - 1, p + 1);
d1246 1
a1246 1
      bfd_put_16 (abfd, (bfd_vma) skip - 1, p + 2);
d1260 1
a1260 1
     bfd_vma addend;
d1265 1
a1265 1
  if (addend + 0x80 < 0x100)
d1271 1
a1271 1
  else if (addend + 0x8000 < 0x10000)
d1277 1
a1277 1
  else if (addend + 0x800000 < 0x1000000)
d1398 1
a1398 1
	  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
d1456 2
a1457 2
  final_types = (int **) bfd_alloc (abfd, (bfd_size_type) sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1481 1
a1481 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1497 1
a1497 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1508 1
a1508 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1519 1
a1519 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1530 1
a1530 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1540 1
a1540 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1551 1
a1551 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1555 1
a1555 1
      final_types[1] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1574 4
a1577 5
	  bfd_size_type amt = sizeof (int);
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
d1654 4
a1657 5
	  bfd_size_type amt = sizeof (int);
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
d1691 1
a1691 2
	bfd_size_type amt = sizeof (int);
	final_types[0] = (int *) bfd_alloc (abfd, amt);
d1739 1
a1739 1
  if (! som_mkobject (abfd))
d1776 1
a1776 1
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_exec_data));
a1812 2
  obj_som_exec_data (abfd)->version_id = file_hdrp->version_id;

d1839 1
a1839 1
static bfd_boolean
d1848 1
a1848 3
  asection **subspace_sections = NULL;
  asection *section;
  bfd_size_type amt;
d1852 2
a1853 3
  amt = file_hdr->space_strings_size;
  space_strings = bfd_malloc (amt);
  if (!space_strings && amt != 0)
d1857 1
a1857 1
		SEEK_SET) != 0)
d1859 2
a1860 1
  if (bfd_bread (space_strings, amt, abfd) != amt)
d1876 1
a1876 1
		    SEEK_SET) != 0)
d1878 1
a1878 2
      amt = sizeof space;
      if (bfd_bread (&space, amt, abfd) != amt)
d1885 1
a1885 2
      amt = strlen (space.name.n_name) + 1;
      newname = bfd_alloc (abfd, amt);
d1898 3
a1900 3
      if (! bfd_som_set_section_attributes (space_asect, space.is_defined,
					    space.is_private, space.sort_key,
					    space.space_number))
d1911 1
a1911 1
		    SEEK_SET) != 0)
d1913 1
a1913 2
      amt = sizeof subspace;
      if (bfd_bread (&subspace, amt, abfd) != amt)
d1919 1
a1919 1
		    SEEK_SET) != 0)
d1923 1
a1923 1
	 record.  */
d1927 1
a1927 1
      if (space_asect->alignment_power == (unsigned) -1)
d1941 2
a1942 2
	  amt = sizeof subspace;
	  if (bfd_bread (&subspace, amt, abfd) != amt)
d1948 1
a1948 2
	  amt = strlen (subspace.name.n_name) + 1;
	  newname = bfd_alloc (abfd, amt);
d1959 4
a1962 4
	  if (! bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						   subspace.access_control_bits,
						   subspace.sort_key,
						   subspace.quadrant))
d2039 1
a2039 1
	      subspace_asect->reloc_count = (unsigned) -1;
d2052 1
a2052 1
	  if (subspace_asect->alignment_power == (unsigned) -1)
d2057 1
a2057 1
	 empty subspaces.  */
d2077 2
a2078 3
  amt = total_subspaces;
  amt *= sizeof (asection *);
  subspace_sections = (asection **) bfd_malloc (amt);
d2104 1
a2104 1
  return TRUE;
d2112 1
a2112 1
  return FALSE;
a2125 1
  bfd_size_type amt;
d2128 1
a2128 2
  amt = FILE_HDR_SIZE;
  if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
d2162 1
a2162 1
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
d2169 1
a2169 2
      amt = SLSTHDR;
      if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
d2178 1
a2178 1
      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) != 0)
d2185 1
a2185 2
      amt = ENTRY_SIZE;
      if (bfd_bread ((PTR) &som_entry, amt, abfd) != amt)
d2194 1
a2194 1
      if (bfd_seek (abfd, som_entry.location, SEEK_SET) != 0)
d2204 2
a2205 2
      amt = FILE_HDR_SIZE;
      if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
d2233 1
a2233 2
      amt = AUX_HDR_SIZE;
      if (bfd_bread ((PTR) &aux_hdr, amt, abfd) != amt)
d2254 1
a2254 1
static bfd_boolean
d2260 1
a2260 1
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_data_struct));
d2262 2
a2263 2
    return FALSE;
  return TRUE;
d2270 1
a2270 1
static bfd_boolean
a2275 1
  bfd_size_type amt = sizeof (struct header);
d2278 1
a2278 1
  file_hdr = (struct header *) bfd_zalloc (abfd, amt);
d2280 1
a2280 1
    return FALSE;
d2285 1
d2287 2
a2288 3
      amt = sizeof (struct som_exec_auxhdr);
      obj_som_exec_hdr (abfd) =
	(struct som_exec_auxhdr *) bfd_zalloc (abfd, amt);
d2290 1
a2290 1
	return FALSE;
d2306 3
a2332 1
	  amt = sizeof (struct space_dictionary_record);
d2334 2
a2335 1
	    (struct space_dictionary_record *) bfd_zalloc (abfd, amt);
d2337 1
a2337 1
	    return FALSE;
d2356 3
a2358 3
	  amt = sizeof (struct subspace_dictionary_record);
	  som_section_data (section)->subspace_dict =
	    (struct subspace_dictionary_record *) bfd_zalloc (abfd, amt);
d2360 1
a2360 1
	    return FALSE;
d2395 1
a2395 1
  return TRUE;
d2398 1
a2398 1
/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */
d2400 1
a2400 1
static bfd_boolean
d2407 1
a2407 1
    return FALSE;
d2414 1
a2414 1
    return FALSE;
d2417 1
a2417 1
  return TRUE;
d2420 1
a2420 1
/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */
d2422 1
a2422 1
static bfd_boolean
d2429 1
a2429 1
    return FALSE;
d2436 1
a2436 1
    return FALSE;
d2439 1
a2439 1
  return TRUE;
d2442 1
a2442 1
/* Return TRUE if the given space containins the given subspace.  It
d2446 1
a2446 1
static bfd_boolean
d2549 1
a2549 1
  unsigned long i;
a2551 1
  bfd_size_type amt;
d2577 1
a2577 1
      int j;
d2580 1
a2580 1
      if ((int) section->reloc_count <= 0)
d2584 1
a2584 1
      for (j = 1; j < (int) section->reloc_count; j++)
d2586 1
a2586 1
	  arelent *reloc = section->orelocation[j];
d2623 1
a2623 3
  amt = num_syms;
  amt *= sizeof (asymbol *);
  sorted_syms = (asymbol **) bfd_zalloc (abfd, amt);
d2641 1
a2641 1
static bfd_boolean
a2655 1
  bfd_size_type amt;
d2680 1
a2680 2
	  int reloc_offset;
	  unsigned int current_rounding_mode;
d2708 2
a2709 2
	  if (bfd_seek (abfd, current_offset + total_reloc_size, SEEK_SET) != 0)
	    return FALSE;
d2746 3
a2748 3
		  amt = p - tmp_space;
		  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
		    return FALSE;
d2830 1
a2830 1
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
d2859 1
a2859 1
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
d2869 1
a2869 1
		    unsigned int tmp;
d2942 1
a2942 1
		  /* The end of an exception handling region.  The reloc's
d2981 1
a2981 1
		  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
d3009 2
a3010 2
	  p = som_reloc_skip (abfd, (bfd_section_size (abfd, subsection)
				     - reloc_offset),
d3014 3
a3016 3
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
	    return FALSE;
d3026 1
a3026 1
  return TRUE;
d3031 1
a3031 1
static bfd_boolean
a3043 1
  bfd_size_type amt;
d3047 2
a3048 2
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;
d3065 3
a3067 3
	 current buffer contents now and maybe allocate a larger
	 buffer.  Each entry will take 4 bytes to hold the string
	 length + the string itself + null terminator.  */
d3071 3
a3073 3
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;
d3079 7
a3085 7
		 consumption for n strings.  The optimal minimum
		 factor seems to be 2, as no other value can guarantee
		 wasting less than 50% space.  (Note that we cannot
		 deallocate space allocated by `alloca' without
		 returning from this function.)  The same technique is
		 used a few more times below when a buffer is
		 reallocated.  */
d3096 1
a3096 1
      bfd_put_32 (abfd, (bfd_vma) length, p);
d3122 2
a3123 3
  amt = p - tmp_space;
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
    return FALSE;
d3125 1
a3125 1
  return TRUE;
d3130 1
a3130 1
static bfd_boolean
a3149 1
  bfd_size_type amt;
d3167 2
a3168 2
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;
d3182 3
a3184 3
	      amt = p - tmp_space;
	      if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
		return FALSE;
d3195 1
a3195 1
		 space.  */
d3203 1
a3203 1
	  bfd_put_32 (abfd, (bfd_vma) length, p);
d3251 3
a3253 3
	  amt = p - tmp_space;
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;
d3271 1
a3271 1
      bfd_put_32 (abfd, (bfd_vma) length, p);
d3292 2
a3293 3
  amt = p - tmp_space;
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
    return FALSE;
d3296 1
a3296 1
  return TRUE;
d3303 1
a3303 1
static bfd_boolean
d3346 1
a3346 1
      bfd_size_type len;
d3348 2
a3349 2
      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;
d3355 2
a3356 2
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd), len, abfd) != len)
	return FALSE;
d3362 3
a3364 3
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd)->user_string, len, abfd)
	  != len)
	return FALSE;
d3369 1
a3369 1
      bfd_size_type len;
d3371 2
a3372 2
      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;
d3378 2
a3379 2
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd), len, abfd) != len)
	return FALSE;
d3385 3
a3387 3
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd)->copyright, len, abfd)
	  != len)
	return FALSE;
d3434 2
a3435 2
  if (! som_write_space_strings (abfd, current_offset, &strings_size))
    return FALSE;
d3631 4
a3634 4
  if (bfd_seek (abfd, (file_ptr) current_offset - 1, SEEK_SET) != 0)
    return FALSE;
  if (bfd_bwrite ((PTR) "", (bfd_size_type) 1, abfd) != 1)
    return FALSE;
d3646 1
a3646 1
  return TRUE;
d3651 1
a3651 1
static bfd_boolean
a3662 9
  bfd_size_type amt;

  /* We must set up the version identifier here as objcopy/strip copy
     private BFD data too late for us to handle this in som_begin_writing.  */
  if (obj_som_exec_data (abfd)
      && obj_som_exec_data (abfd)->version_id)
    obj_som_file_hdr (abfd)->version_id = obj_som_exec_data (abfd)->version_id;
  else
    obj_som_file_hdr (abfd)->version_id = NEW_VERSION_ID;
d3695 5
a3699 4
  if (! som_write_symbol_strings (abfd, current_offset, syms,
				  num_syms, &strings_size,
				  obj_som_compilation_unit (abfd)))
    return FALSE;
d3719 2
a3720 2
  if (! som_write_fixups (abfd, current_offset, &total_reloc_size))
    return FALSE;
d3730 2
a3731 2
  if (! som_build_and_write_symbol_table (abfd))
    return FALSE;
d3738 2
a3739 2
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;
d3786 4
a3789 4
	  amt = sizeof (struct subspace_dictionary_record);
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
	    return FALSE;
d3842 4
a3845 4
	  amt = sizeof (struct subspace_dictionary_record);
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
	    return FALSE;
d3857 2
a3858 2
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;
d3868 4
a3871 4
      amt = sizeof (struct space_dictionary_record);
      if (bfd_bwrite ((PTR) som_section_data (section)->space_dict,
		     amt, abfd) != amt)
	return FALSE;
d3881 2
a3882 2
      if (bfd_seek (abfd, location, SEEK_SET) != 0)
	return FALSE;
d3884 3
a3886 3
      amt = COMPUNITSZ;
      if (bfd_bwrite ((PTR) obj_som_compilation_unit (abfd), amt, abfd) != amt)
	return FALSE;
d3906 6
a3911 5
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  amt = sizeof (struct header);
  if (bfd_bwrite ((PTR) obj_som_file_hdr (abfd), amt, abfd) != amt)
    return FALSE;
d3940 1
a3940 1
	  return FALSE;
d3944 2
a3945 2
		    SEEK_SET) != 0)
	return FALSE;
d3947 3
a3949 3
      amt = AUX_HDR_SIZE;
      if (bfd_bwrite ((PTR) exec_header, amt, abfd) != amt)
	return FALSE;
d3951 1
a3951 1
  return TRUE;
d4086 1
a4086 1
    info->secondary_def = TRUE;
d4088 1
a4088 1
    info->secondary_def = FALSE;
d4095 1
a4095 1
static bfd_boolean
d4103 1
a4103 2
  unsigned int i;
  bfd_size_type symtab_size;
d4107 2
a4108 3
  symtab_size = num_syms;
  symtab_size *= sizeof (struct symbol_dictionary_record);
  som_symtab = (struct symbol_dictionary_record *) bfd_zmalloc (symtab_size);
d4111 1
d4139 1
a4139 1
    return FALSE;
d4141 1
a4141 1
  if (bfd_bwrite ((PTR) som_symtab, symtab_size, abfd) != symtab_size)
d4146 1
a4146 1
  return TRUE;
d4150 1
a4150 1
  return FALSE;
d4155 1
a4155 1
static bfd_boolean
d4159 1
a4159 1
  if (! abfd->output_has_begun)
d4164 1
a4164 1
      abfd->output_has_begun = TRUE;
d4175 1
a4175 1
static bfd_boolean
a4179 1
  bfd_size_type amt;
d4183 1
a4183 1
    return TRUE;
d4191 1
a4191 1
      return FALSE;
d4195 1
a4195 2
  amt = obj_som_stringtab_size (abfd);
  stringtab = bfd_zmalloc (amt);
d4197 2
a4198 1
    return FALSE;
d4200 2
a4201 2
  if (bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET) != 0)
    return FALSE;
d4203 3
a4205 2
  if (bfd_bread (stringtab, amt, abfd) != amt)
    return FALSE;
d4209 1
a4209 1
  return TRUE;
a4284 1
  bfd_size_type amt;
d4299 2
a4300 3
  amt = symbol_count;
  amt *= sizeof (som_symbol_type);
  symbase = (som_symbol_type *) bfd_zmalloc (amt);
d4303 1
d4306 2
a4307 4
  amt = symbol_count;
  amt *= symsize;
  buf = bfd_malloc (amt);
  if (buf == NULL && amt != 0)
d4309 1
a4309 1
  if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) != 0)
d4311 2
a4312 1
  if (bfd_bread (buf, amt, abfd) != amt)
d4438 1
a4438 1
	 we can not include it as part of the for statement.  */
d4451 1
a4451 1
  return (TRUE);
d4456 1
a4456 1
  return FALSE;
d4490 2
a4491 2
  bfd_size_type amt = sizeof (som_symbol_type);
  som_symbol_type *new = (som_symbol_type *) bfd_zalloc (abfd, amt);
d4502 2
a4503 2
som_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
d4521 1
a4521 1
	const char *section_name;
d4523 1
a4523 1
	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d4530 1
a4530 1
static bfd_boolean
d4558 1
a4558 1
     bfd_boolean just_count;
d4643 1
a4643 1
	      if (ISUPPER (c))
d4649 1
a4649 1
	      else if (ISLOWER (c))
d4660 1
a4660 1
	      else if (ISDIGIT (c))
d4663 1
a4663 1
		  while (ISDIGIT (*cp))
d4848 1
a4848 1
			 bother saving the contents (yet).  Add it one
d4852 1
a4852 1
			return (unsigned) -1;
d4858 1
a4858 1
						(bfd_vma) 0,
d4892 1
a4892 1
   set to TRUE to indicate it only needs a count of the number
d4895 1
a4895 1
static bfd_boolean
d4900 1
a4900 1
     bfd_boolean just_count;
a4905 1
  bfd_size_type amt;
d4910 1
a4910 1
    return TRUE;
d4914 1
a4914 1
  if (section->reloc_count == (unsigned) -1)
d4916 1
a4916 2
      amt = fixup_stream_size;
      external_relocs = (char *) bfd_malloc (amt);
d4918 1
a4918 1
	return FALSE;
d4924 4
a4927 3
	return FALSE;
      if (bfd_bread (external_relocs, amt, abfd) != amt)
	return FALSE;
d4934 1
a4934 1
						 NULL, NULL, NULL, TRUE);
d4941 1
a4941 1
    return TRUE;
d4947 1
a4947 1
    return TRUE;
d4949 2
a4950 3
  amt = num_relocs;
  amt *= sizeof (arelent);
  internal_relocs = (arelent *) bfd_zalloc (abfd, (amt));
d4952 1
a4952 1
    return FALSE;
d4956 1
a4956 1
		      internal_relocs, section, symbols, FALSE);
d4964 1
a4964 1
  return TRUE;
d4979 1
a4979 1
      if (! som_slurp_reloc_table (abfd, asect, NULL, TRUE))
d5000 1
a5000 1
  if (! som_slurp_reloc_table (abfd, section, symbols, FALSE))
d5017 1
a5017 1
static bfd_boolean
d5022 2
a5023 2
  bfd_size_type amt = sizeof (struct som_section_data_struct);
  newsect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d5025 1
a5025 1
    return FALSE;
d5029 1
a5029 1
  return TRUE;
d5035 1
a5035 1
static bfd_boolean
d5048 1
a5048 1
    return FALSE;
d5055 1
a5055 1
  return TRUE;
d5061 1
a5061 1
static bfd_boolean
a5067 2
  bfd_size_type amt;

d5072 1
a5072 1
    return TRUE;
a5073 1
  amt = sizeof (struct som_copyable_section_data_struct);
d5075 2
a5076 1
    (struct som_copyable_section_data_struct *) bfd_zalloc (obfd, amt);
d5078 1
a5078 1
    return FALSE;
d5089 1
a5089 1
  return TRUE;
d5095 1
a5095 1
static bfd_boolean
d5102 1
a5102 1
    return TRUE;
d5106 1
a5106 1
    bfd_zalloc (obfd, (bfd_size_type) sizeof (struct som_exec_data));
d5108 1
a5108 1
    return FALSE;
d5114 1
a5114 1
  return TRUE;
d5120 1
a5120 1
bfd_boolean
a5130 1
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);
d5132 3
a5134 2
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
d5136 1
a5136 1
	return FALSE;
d5143 1
a5143 1
  return TRUE;
d5149 1
a5149 1
bfd_boolean
a5160 1
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);
d5162 3
a5164 2
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
d5166 1
a5166 1
	return FALSE;
d5172 1
a5172 1
  return TRUE;
d5192 1
a5192 1
bfd_boolean
a5197 2
  bfd_size_type amt;

d5200 1
a5200 1
      size_t len = strlen (string);
d5205 3
a5207 3
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
      obj_som_version_hdr (abfd) =
	(struct user_string_aux_hdr *) bfd_zalloc (abfd, amt);
d5209 1
a5209 1
	return FALSE;
d5223 3
a5225 3
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
      obj_som_copyright_hdr (abfd) =
	(struct copyright_aux_hdr *) bfd_zalloc (abfd, amt);
d5227 1
a5227 1
	return FALSE;
d5234 1
a5234 1
  return TRUE;
d5237 1
a5237 1
/* Attach a compilation unit header to the BFD backend so that it may be
d5240 1
a5240 1
bfd_boolean
d5249 1
a5249 1
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, (bfd_size_type) COMPUNITSZ);
d5251 1
a5251 1
    return FALSE;
d5256 1
a5256 1
      n->f.n_name = bfd_alloc (abfd, (bfd_size_type) strlen (f) + 1); \
d5258 1
a5258 1
	return FALSE; \
d5271 1
a5271 1
  return TRUE;
d5274 1
a5274 1
static bfd_boolean
d5283 1
a5283 1
    return TRUE;
d5285 4
a5288 4
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0
      || bfd_bread (location, count, abfd) != count)
    return FALSE; /* On error.  */
  return TRUE;
d5291 1
a5291 1
static bfd_boolean
d5299 1
a5299 1
  if (! abfd->output_has_begun)
d5304 1
a5304 1
      abfd->output_has_begun = TRUE;
d5314 1
a5314 1
    return TRUE;
d5319 2
a5320 2
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;
d5322 3
a5324 3
  if (bfd_bwrite ((PTR) location, count, abfd) != count)
    return FALSE;
  return TRUE;
d5327 1
a5327 1
static bfd_boolean
d5337 1
a5337 1
static bfd_boolean
d5344 2
a5345 2
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
d5348 1
a5348 1
  return FALSE;
d5354 1
a5354 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d5359 1
a5359 1
  return 0;
d5403 1
a5403 1
    c = TOUPPER (c);
d5426 1
a5426 1
static bfd_boolean
a5433 1
  bfd_size_type amt;
d5436 3
a5438 3
  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_malloc (amt);
d5447 2
a5448 1
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
d5462 1
a5462 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
d5466 2
a5467 2
      amt = sizeof (lst_symbol);
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5478 1
a5478 1
	      != 0)
d5482 2
a5483 2
	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5491 1
a5491 1
  return TRUE;
d5496 1
a5496 1
  return FALSE;
d5502 1
a5502 1
static bfd_boolean
a5511 1
  bfd_size_type amt;
d5514 3
a5516 3
  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_malloc (amt);
d5520 6
d5528 2
a5529 1
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
d5534 1
a5534 7
  if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) != 0)
    goto error_return;

  amt = lst_header->module_count;
  amt *= sizeof (struct som_entry);
  som_dict = (struct som_entry *) bfd_malloc (amt);
  if (som_dict == NULL && lst_header->module_count != 0)
d5537 3
a5539 1
  if (bfd_bread ((PTR) som_dict, amt, abfd) != amt)
d5552 1
a5552 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
d5555 2
a5556 2
      amt = sizeof (lst_symbol);
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5567 1
a5567 1
			    + lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
d5570 1
a5570 1
      if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
d5574 1
a5574 1
      set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
d5577 1
a5577 1
      if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
d5594 1
a5594 2
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET)
	      != 0)
d5597 2
a5598 2
	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5603 1
a5603 1
				+ lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
d5606 1
a5606 1
	  if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
d5610 1
a5610 1
	  set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
d5614 1
a5614 1
	  if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
d5633 1
a5633 1
  return TRUE;
d5640 1
a5640 1
  return FALSE;
d5645 1
a5645 1
static bfd_boolean
d5654 1
a5654 2
  bfd_size_type amt = 16;
  int i = bfd_bread ((PTR) nextname, amt, abfd);
d5658 1
a5658 1
    return TRUE;
d5660 1
a5660 1
    return FALSE;
d5662 2
a5663 2
  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;
d5668 2
a5669 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d5673 3
a5675 3
  amt = sizeof (struct ar_hdr);
  if (bfd_bread ((PTR) &ar_header, amt, abfd) != amt)
    return FALSE;
d5680 1
a5680 1
      return FALSE;
d5689 1
a5689 1
      return FALSE;
d5697 3
a5699 3
  amt = sizeof (struct lst_header);
  if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
    return FALSE;
d5705 1
a5705 1
      return FALSE;
d5709 3
a5711 2
  if (! som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count))
    return FALSE;
d5714 3
a5716 3
  if (bfd_seek (abfd, (ardata->first_file_filepos - parsed_size
		       + sizeof (struct lst_header)), SEEK_SET) != 0)
    return FALSE;
d5720 3
a5722 3
  amt = ardata->symdef_count;
  amt *= sizeof (carsym);
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d5724 1
a5724 1
    return FALSE;
d5727 3
a5729 2
  if (! som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs))
    return FALSE;
d5733 2
a5734 2
  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) != 0)
    return FALSE;
d5737 2
a5738 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d5746 1
a5746 1
static bfd_boolean
d5774 2
a5775 2
      if (! som_slurp_symbol_table (curr_bfd))
	return FALSE;
d5814 1
a5814 1
  return TRUE;
d5837 1
a5837 1
static bfd_boolean
a5851 1
  bfd_size_type amt;
d5853 2
a5854 3
  amt = lst.hash_size;
  amt *= sizeof (unsigned int);
  hash_table = (unsigned int *) bfd_zmalloc (amt);
d5857 3
a5859 4

  amt = lst.module_count;
  amt *= sizeof (struct som_entry);
  som_dict = (struct som_entry *) bfd_zmalloc (amt);
d5863 3
a5865 3
  amt = lst.hash_size;
  amt *= sizeof (struct lst_symbol_record *);
  last_hash_entry = ((struct lst_symbol_record **) bfd_zmalloc (amt));
d5873 6
d5903 1
a5903 3
  amt = nsyms;
  amt *= sizeof (struct lst_symbol_record);
  lst_syms = bfd_malloc (amt);
d5906 1
a5906 1
  strings = bfd_malloc ((bfd_size_type) string_size);
d5930 1
a5930 1
      if (! som_slurp_symbol_table (curr_bfd))
d6040 1
a6040 1
      curr_som_offset = (curr_som_offset + 0x1) &~ (unsigned) 1;
d6046 2
a6047 2
  amt = lst.hash_size * 4;
  if (bfd_bwrite ((PTR) hash_table, amt, abfd) != amt)
d6051 3
a6053 2
  amt = lst.module_count * sizeof (struct som_entry);
  if (bfd_bwrite ((PTR) som_dict, amt, abfd) != amt)
d6057 2
a6058 2
  amt = nsyms * sizeof (struct lst_symbol_record);
  if (bfd_bwrite ((PTR) lst_syms, amt, abfd) != amt)
d6062 1
a6062 2
  amt = string_size;
  if (bfd_bwrite ((PTR) strings, amt, abfd) != amt)
d6075 1
a6075 1
  return TRUE;
d6089 1
a6089 1
  return FALSE;
d6096 1
a6096 1
static bfd_boolean
a6109 1
  bfd_size_type amt;
d6115 1
a6115 1
      return FALSE;
d6165 2
a6166 2
  if (! som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize))
    return FALSE;
d6202 3
a6204 3
  amt = sizeof (struct ar_hdr);
  if (bfd_bwrite ((PTR) &hdr, amt, abfd) != amt)
    return FALSE;
d6207 3
a6209 3
  amt = sizeof (struct lst_header);
  if (bfd_bwrite ((PTR) &lst, amt, abfd) != amt)
    return FALSE;
d6212 3
a6214 2
  if (!som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength))
    return FALSE;
d6217 1
a6217 1
  return TRUE;
d6223 1
a6223 1
static bfd_boolean
d6230 1
a6230 1
    return TRUE;
d6239 1
a6239 1
      o->reloc_count = (unsigned) -1;
d6246 1
a6246 1
  return TRUE;
d6253 1
a6253 1
static bfd_boolean
d6274 1
a6274 1
#define som_get_lineno			_bfd_nosymbols_get_lineno
a6284 1
#define som_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
a6285 1
#define som_bfd_link_just_syms _bfd_generic_link_just_syms
a6288 2
#define som_bfd_merge_sections		bfd_generic_merge_sections
#define som_bfd_discard_group		bfd_generic_discard_group
d6302 1
a6302 1
   predictable, and if so what is it.  */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d178 1
a178 1
static long som_canonicalize_symtab
d1718 1
a1718 1
	   will be eliminated as the relocs are sized and emitted.  */
d2483 1
a2483 1
/* Return TRUE if the given space contains the given subspace.  It
d2737 1
a2737 1
	     finished with it.  */
d3203 1
a3203 1
     write them and update the compilation unit header.  On input, the
d3909 1
a3909 1
  /* All the subspace dictionary records are written, and all the
d3981 1
a3981 1
	 to be compatible with how the hp linker makes objects
d4523 1
a4523 1
som_canonicalize_symtab (abfd, location)
d5783 1
a5783 1
  /* Initialize the cache and allocate space for the library symbols.  */
@


