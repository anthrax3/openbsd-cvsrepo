head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.50
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.22;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.10;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.10;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.25;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.42;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.20.34;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.55;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.27.27;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* 8 and 16 bit COFF relocation functions, for BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Most of this hacked by Steve Chamberlain <sac@@cygnus.com>.  */

/* These routines are used by coff-h8300 and coff-z8k to do
   relocation.

   FIXME: This code should be rewritten to support the new COFF
   linker.  Basically, they need to deal with COFF relocs rather than
   BFD generic relocs.  They should store the relocs in some location
   where coff_link_input_bfd can find them (and coff_link_input_bfd
   should be changed to use this location rather than rereading the
   file) (unless info->keep_memory is FALSE, in which case they should
   free up the relocs after dealing with them).  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"
#include "coff/internal.h"
#include "libcoff.h"

bfd_vma
bfd_coff_reloc16_get_value (reloc, link_info, input_section)
     arelent *reloc;
     struct bfd_link_info *link_info;
     asection *input_section;
{
  bfd_vma value;
  asymbol *symbol = *(reloc->sym_ptr_ptr);
  /* A symbol holds a pointer to a section, and an offset from the
     base of the section.  To relocate, we find where the section will
     live in the output and add that in.  */

  if (bfd_is_und_section (symbol->section)
      || bfd_is_com_section (symbol->section))
    {
      struct bfd_link_hash_entry *h;

      /* The symbol is undefined in this BFD.  Look it up in the
	 global linker hash table.  FIXME: This should be changed when
	 we convert this stuff to use a specific final_link function
	 and change the interface to bfd_relax_section to not require
	 the generic symbols.  */
      h = bfd_wrapped_link_hash_lookup (input_section->owner, link_info,
					bfd_asymbol_name (symbol),
					FALSE, FALSE, TRUE);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak))
	value = (h->u.def.value
		 + h->u.def.section->output_section->vma
		 + h->u.def.section->output_offset);
      else if (h != (struct bfd_link_hash_entry *) NULL
	       && h->type == bfd_link_hash_common)
	value = h->u.c.size;
      else
	{
	  if (!((*link_info->callbacks->undefined_symbol)
		(link_info, bfd_asymbol_name (symbol),
		 input_section->owner, input_section, reloc->address,
		 TRUE)))
	    abort ();
	  value = 0;
	}
    }
  else
    {
      value = symbol->value
	+ symbol->section->output_offset
	+ symbol->section->output_section->vma;
    }

  /* Add the value contained in the relocation.  */
  value += reloc->addend;

  return value;
}

void
bfd_perform_slip (abfd, slip, input_section, value)
     bfd *abfd;
     unsigned int slip;
     asection *input_section;
     bfd_vma value;
{
  asymbol **s;

  s = _bfd_generic_link_get_symbols (abfd);
  BFD_ASSERT (s != (asymbol **) NULL);

  /* Find all symbols past this point, and make them know
     what's happened.  */
  while (*s)
    {
      asymbol *p = *s;
      if (p->section == input_section)
	{
	  /* This was pointing into this section, so mangle it.  */
	  if (p->value > value)
	    {
	      p->value -= slip;
	      if (p->udata.p != NULL)
		{
		  struct generic_link_hash_entry *h;

		  h = (struct generic_link_hash_entry *) p->udata.p;
		  BFD_ASSERT (h->root.type == bfd_link_hash_defined
			      || h->root.type == bfd_link_hash_defweak);
		  h->root.u.def.value -= slip;
		  BFD_ASSERT (h->root.u.def.value == p->value);
		}
	    }
	}
      s++;
    }
}

bfd_boolean
bfd_coff_reloc16_relax_section (abfd, input_section, link_info, again)
     bfd *abfd;
     asection *input_section;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  /* Get enough memory to hold the stuff.  */
  bfd *input_bfd = input_section->owner;
  unsigned *shrinks;
  unsigned shrink = 0;
  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  /* We only do global relaxation once.  It is not safe to do it multiple
     times (see discussion of the "shrinks" array below).  */
  *again = FALSE;

  if (reloc_size < 0)
    return FALSE;

  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
  if (!reloc_vector && reloc_size > 0)
    return FALSE;

  /* Get the relocs and think about them.  */
  reloc_count =
    bfd_canonicalize_reloc (input_bfd, input_section, reloc_vector,
			    _bfd_generic_link_get_symbols (input_bfd));
  if (reloc_count < 0)
    {
      free (reloc_vector);
      return FALSE;
    }

  /* The reloc16.c and related relaxing code is very simple, the price
     for that simplicity is we can only call this function once for
     each section.

     So, to get the best results within that limitation, we do multiple
     relaxing passes over each section here.  That involves keeping track
     of the "shrink" at each reloc in the section.  This allows us to
     accurately determine the relative location of two relocs within
     this section.

     In theory, if we kept the "shrinks" array for each section for the
     entire link, we could use the generic relaxing code in the linker
     and get better results, particularly for jsr->bsr and 24->16 bit
     memory reference relaxations.  */

  if (reloc_count > 0)
    {
      int another_pass = 0;
      bfd_size_type amt;

      /* Allocate and initialize the shrinks array for this section.
	 The last element is used as an accumulator of shrinks.  */
      amt = reloc_count + 1;
      amt *= sizeof (unsigned);
      shrinks = (unsigned *) bfd_zmalloc (amt);

      /* Loop until nothing changes in this section.  */
      do
	{
	  arelent **parent;
	  unsigned int i;
	  long j;

	  another_pass = 0;

	  for (i = 0, parent = reloc_vector; *parent; parent++, i++)
	    {
	      /* Let the target/machine dependent code examine each reloc
		 in this section and attempt to shrink it.  */
	      shrink = bfd_coff_reloc16_estimate (abfd, input_section, *parent,
						  shrinks[i], link_info);

	      /* If it shrunk, note it in the shrinks array and set up for
		 another pass.  */
	      if (shrink != shrinks[i])
		{
		  another_pass = 1;
		  for (j = i + 1; j <= reloc_count; j++)
		    shrinks[j] += shrink - shrinks[i];
		}
	    }
	}
      while (another_pass);

      shrink = shrinks[reloc_count];
      free ((char *) shrinks);
    }

  input_section->_cooked_size -= shrink;
  free ((char *) reloc_vector);
  return TRUE;
}

bfd_byte *
bfd_coff_reloc16_get_relocated_section_contents (in_abfd,
						 link_info,
						 link_order,
						 data,
						 relocatable,
						 symbols)
     bfd *in_abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
{
  /* Get enough memory to hold the stuff.  */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;
  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector;
  long reloc_count;

  if (reloc_size < 0)
    return NULL;

  /* If producing relocatable output, don't bother to relax.  */
  if (relocatable)
    return bfd_generic_get_relocated_section_contents (in_abfd, link_info,
						       link_order,
						       data, relocatable,
						       symbols);

  /* Read in the section.  */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 data,
				 (bfd_vma) 0,
				 input_section->_raw_size))
    return NULL;

  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
  if (!reloc_vector && reloc_size != 0)
    return NULL;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    {
      free (reloc_vector);
      return NULL;
    }

  if (reloc_count > 0)
    {
      arelent **parent = reloc_vector;
      arelent *reloc;
      unsigned int dst_address = 0;
      unsigned int src_address = 0;
      unsigned int run;
      unsigned int idx;

      /* Find how long a run we can do.  */
      while (dst_address < link_order->size)
	{
	  reloc = *parent;
	  if (reloc)
	    {
	      /* Note that the relaxing didn't tie up the addresses in the
		 relocation, so we use the original address to work out the
		 run of non-relocated data.  */
	      run = reloc->address - src_address;
	      parent++;
	    }
	  else
	    {
	      run = link_order->size - dst_address;
	    }

	  /* Copy the bytes.  */
	  for (idx = 0; idx < run; idx++)
	    data[dst_address++] = data[src_address++];

	  /* Now do the relocation.  */
	  if (reloc)
	    {
	      bfd_coff_reloc16_extra_cases (input_bfd, link_info, link_order,
					    reloc, data, &src_address,
					    &dst_address);
	    }
	}
    }
  free ((char *) reloc_vector);
  return data;
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d196 1
a196 1
	 The last element is used as an accumlator of shrinks.  */
d243 1
a243 1
						 relocateable,
d249 1
a249 1
     bfd_boolean relocateable;
d262 2
a263 2
  /* If producing relocateable output, don't bother to relax.  */
  if (relocateable)
d266 1
a266 1
						       data, relocateable,
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000
   Free Software Foundation, Inc.
d32 1
a32 1
   file) (unless info->keep_memory is false, in which case they should
d67 1
a67 1
					false, false, true);
d82 1
a82 1
		 true)))
d139 2
a140 2
boolean
bfd_coff_reloc16_relax_section (abfd, i, link_info, again)
d142 1
a142 1
     asection *i;
d144 1
a144 1
     boolean *again;
d147 3
a149 4
  bfd *input_bfd = i->owner;
  asection *input_section = i;
  int *shrinks;
  int shrink = 0;
d156 1
a156 1
  *again = false;
d159 1
a159 1
    return false;
d161 1
a161 1
  reloc_vector = (arelent **) bfd_malloc (reloc_size);
d163 1
a163 1
    return false;
d172 1
a172 1
      return false;
d193 1
d196 4
a199 3
         The last element is used as an accumlator of shrinks.  */
      shrinks = (int *) bfd_malloc ((reloc_count + 1) * sizeof (int));
      memset (shrinks, 0, (reloc_count + 1) * sizeof (int));
d202 25
a226 24
      do {
	arelent **parent;
	unsigned int i;
	long j;

	another_pass = 0;

	for (i = 0, parent = reloc_vector; *parent; parent++, i++)
	  {
	    /* Let the target/machine dependent code examine each reloc
	       in this section and attempt to shrink it.  */
	    shrink = bfd_coff_reloc16_estimate (abfd, input_section, *parent,
						shrinks[i], link_info);

	    /* If it shrunk, note it in the shrinks array and set up for
	       another pass.  */
	    if (shrink != shrinks[i])
	      {
	        another_pass = 1;
		for (j = i + 1; j <= reloc_count; j++)
		  shrinks[j] += shrink - shrinks[i];
	      }
	  }
      }
d235 1
a235 1
  return true;
d239 6
a244 6
bfd_coff_reloc16_get_relocated_section_contents(in_abfd,
						link_info,
						link_order,
						data,
						relocateable,
						symbols)
d249 1
a249 1
     boolean relocateable;
d270 5
a274 5
  if (!bfd_get_section_contents(input_bfd,
				input_section,
				data,
				0,
				input_section->_raw_size))
d277 1
a277 1
  reloc_vector = (arelent **) bfd_malloc ((size_t) reloc_size);
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d22 1
a22 4
/* 
Most of this hacked by  Steve Chamberlain,
			sac@@cygnus.com 
*/
d53 1
a53 1
     live in the output and add that in */
d79 4
a82 4
	  if (! ((*link_info->callbacks->undefined_symbol)
		 (link_info, bfd_asymbol_name (symbol),
		  input_section->owner, input_section, reloc->address,
		  true)))
d87 1
a87 1
  else 
d89 3
a91 3
      value = symbol->value +
	symbol->section->output_offset +
	  symbol->section->output_section->vma;
d93 2
a94 2
  
  /* Add the value contained in the relocation */
d96 1
a96 1
  
d101 1
a101 1
bfd_perform_slip(abfd, slip, input_section, value)
d113 2
a114 2
     what's happened */
  while (*s) 
d117 1
a117 1
      if (p->section == input_section) 
d119 1
a119 1
	  /* This was pointing into this section, so mangle it */
d136 1
a136 1
    }    
d139 1
a139 1
boolean 
d146 1
a146 1
  /* Get enough memory to hold the stuff */
d166 1
a166 1
  /* Get the relocs and think about them */
d190 1
a190 1
     
d208 1
a208 1
	for (i = 0, parent = reloc_vector; *parent; parent++, i++) 
d224 2
a225 2
  
      } while (another_pass);
d228 1
a228 1
      free((char *)shrinks);
d231 2
a232 2
  input_section->_cooked_size -= shrink;  
  free((char *)reloc_vector);
d250 1
a250 1
  /* Get enough memory to hold the stuff */
d267 6
a272 6
  /* read in the section */
  if (! bfd_get_section_contents(input_bfd,
				 input_section,
				 data,
				 0,
				 input_section->_raw_size))
d274 2
a275 3
  
  
  reloc_vector = (arelent **) bfd_malloc((size_t) reloc_size);
d278 2
a279 2
  
  reloc_count = bfd_canonicalize_reloc (input_bfd, 
d288 1
a288 1
    
d292 1
a292 1
      arelent *reloc ;
d297 3
a299 3
    
      /* Find how long a run we can do */
      while (dst_address < link_order->size) 
d302 1
a302 1
	  if (reloc) 
d306 1
a306 1
		 run of non-relocated data */
d310 1
a310 1
	  else 
d314 2
a315 1
	  /* Copy the bytes */
d317 4
a320 7
	    {
	      data[dst_address++] = data[src_address++];
	    }
    
	  /* Now do the relocation */
    
	  if (reloc) 
d325 1
a325 1
	    }    
d328 1
a328 1
  free((char *)reloc_vector);
a330 1

@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a39 1
#include "obstack.h"
d84 2
a85 1
		  input_section->owner, input_section, reloc->address)))
d152 1
a152 1
  unsigned *shrinks;
d198 4
a201 3
      /* Allocate and initialize the shrinks array for this section.  */
      shrinks = (unsigned *)bfd_malloc (reloc_count * sizeof (unsigned));
      memset (shrinks, 0, reloc_count * sizeof (unsigned));
d206 2
a207 1
	unsigned int i, j;
d223 1
a223 1
		for (j = i + 1; j < reloc_count; j++)
d230 1
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d151 2
a152 1
  int shrink = 0 ;
d157 2
a158 2
  /* We only run this relaxation once.  It might work to run it more
     often, but it hasn't been tested.  */
d178 15
d195 33
a227 6
      arelent **parent;
      for (parent = reloc_vector; *parent; parent++) 
	{
	  shrink = bfd_coff_reloc16_estimate (abfd, input_section,
					      *parent, shrink, link_info);
	}
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d58 2
a59 1
  if (bfd_is_und_section (symbol->section))
d68 3
a70 2
      h = bfd_link_hash_lookup (link_info->hash, bfd_asymbol_name (symbol),
				false, false, true);
d163 1
a163 1
  reloc_vector = (arelent **) malloc (reloc_size);
d165 1
a165 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d232 1
a232 1
  reloc_vector = (arelent **)malloc((size_t) reloc_size);
d234 1
a234 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d58 1
a58 2
  if (bfd_is_und_section (symbol->section)
      || bfd_is_com_section (symbol->section))
d67 2
a68 3
      h = bfd_wrapped_link_hash_lookup (input_section->owner, link_info,
					bfd_asymbol_name (symbol),
					false, false, true);
d161 1
a161 1
  reloc_vector = (arelent **) bfd_malloc (reloc_size);
d163 4
a166 1
    return false;
d233 1
a233 1
  reloc_vector = (arelent **) bfd_malloc((size_t) reloc_size);
d235 4
a238 1
    return NULL;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d151 1
a151 2
  unsigned *shrinks;
  int shrink = 0;
d156 2
a157 2
  /* We only do global relaxation once.  It is not safe to do it multiple
     times (see discussion of the "shrinks" array below).  */
a176 15
  /* The reloc16.c and related relaxing code is very simple, the price
     for that simplicity is we can only call this function once for
     each section.

     So, to get the best results within that limitation, we do multiple
     relaxing passes over each section here.  That involves keeping track
     of the "shrink" at each reloc in the section.  This allows us to
     accurately determine the relative location of two relocs within
     this section.

     In theory, if we kept the "shrinks" array for each section for the
     entire link, we could use the generic relaxing code in the linker
     and get better results, particularly for jsr->bsr and 24->16 bit
     memory reference relaxations.  */
     
d179 6
a184 33
      int another_pass = 0;

      /* Allocate and initialize the shrinks array for this section.  */
      shrinks = (unsigned *)bfd_malloc (reloc_count * sizeof (unsigned));
      memset (shrinks, 0, reloc_count * sizeof (unsigned));

      /* Loop until nothing changes in this section.  */
      do {
	arelent **parent;
	unsigned int i, j;

	another_pass = 0;

	for (i = 0, parent = reloc_vector; *parent; parent++, i++) 
	  {
	    /* Let the target/machine dependent code examine each reloc
	       in this section and attempt to shrink it.  */
	    shrink = bfd_coff_reloc16_estimate (abfd, input_section, *parent,
						shrinks[i], link_info);

	    /* If it shrunk, note it in the shrinks array and set up for
	       another pass.  */
	    if (shrink != shrinks[i])
	      {
	        another_pass = 1;
		for (j = i + 1; j < reloc_count; j++)
		  shrinks[j] += shrink - shrinks[i];
	      }
	  }
  
      } while (another_pass);

      free((char *)shrinks);
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d39 1
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
d83 1
a83 2
		  input_section->owner, input_section, reloc->address,
		  true)))
d150 1
a150 1
  int *shrinks;
d196 3
a198 4
      /* Allocate and initialize the shrinks array for this section.
         The last element is used as an accumlator of shrinks.  */
      shrinks = (int *) bfd_malloc ((reloc_count + 1) * sizeof (int));
      memset (shrinks, 0, (reloc_count + 1) * sizeof (int));
d203 1
a203 2
	unsigned int i;
	long j;
d219 1
a219 1
		for (j = i + 1; j <= reloc_count; j++)
a225 1
      shrink = shrinks[reloc_count];
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000
d22 4
a25 1
/* Most of this hacked by Steve Chamberlain <sac@@cygnus.com>.  */
d56 1
a56 1
     live in the output and add that in.  */
d82 4
a85 4
	  if (!((*link_info->callbacks->undefined_symbol)
		(link_info, bfd_asymbol_name (symbol),
		 input_section->owner, input_section, reloc->address,
		 true)))
d90 1
a90 1
  else
d92 3
a94 3
      value = symbol->value
	+ symbol->section->output_offset
	+ symbol->section->output_section->vma;
d96 2
a97 2

  /* Add the value contained in the relocation.  */
d99 1
a99 1

d104 1
a104 1
bfd_perform_slip (abfd, slip, input_section, value)
d116 2
a117 2
     what's happened.  */
  while (*s)
d120 1
a120 1
      if (p->section == input_section)
d122 1
a122 1
	  /* This was pointing into this section, so mangle it.  */
d139 1
a139 1
    }
d142 1
a142 1
boolean
d149 1
a149 1
  /* Get enough memory to hold the stuff.  */
d169 1
a169 1
  /* Get the relocs and think about them.  */
d193 1
a193 1

d211 1
a211 1
	for (i = 0, parent = reloc_vector; *parent; parent++, i++)
d227 2
a228 2
      }
      while (another_pass);
d231 1
a231 1
      free ((char *) shrinks);
d234 2
a235 2
  input_section->_cooked_size -= shrink;
  free ((char *) reloc_vector);
d253 1
a253 1
  /* Get enough memory to hold the stuff.  */
d270 6
a275 6
  /* Read in the section.  */
  if (!bfd_get_section_contents(input_bfd,
				input_section,
				data,
				0,
				input_section->_raw_size))
d277 3
a279 2

  reloc_vector = (arelent **) bfd_malloc ((size_t) reloc_size);
d282 2
a283 2

  reloc_count = bfd_canonicalize_reloc (input_bfd,
d292 1
a292 1

d296 1
a296 1
      arelent *reloc;
d301 3
a303 3

      /* Find how long a run we can do.  */
      while (dst_address < link_order->size)
d306 1
a306 1
	  if (reloc)
d310 1
a310 1
		 run of non-relocated data.  */
d314 1
a314 1
	  else
d318 1
a318 2

	  /* Copy the bytes.  */
d320 7
a326 4
	    data[dst_address++] = data[src_address++];

	  /* Now do the relocation.  */
	  if (reloc)
d331 1
a331 1
	    }
d334 1
a334 1
  free ((char *) reloc_vector);
d337 1
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,
   2002 Free Software Foundation, Inc.
d32 1
a32 1
   file) (unless info->keep_memory is FALSE, in which case they should
d67 1
a67 1
					FALSE, FALSE, TRUE);
d82 1
a82 1
		 TRUE)))
d139 2
a140 2
bfd_boolean
bfd_coff_reloc16_relax_section (abfd, input_section, link_info, again)
d142 1
a142 1
     asection *input_section;
d144 1
a144 1
     bfd_boolean *again;
d147 4
a150 3
  bfd *input_bfd = input_section->owner;
  unsigned *shrinks;
  unsigned shrink = 0;
d157 1
a157 1
  *again = FALSE;
d160 1
a160 1
    return FALSE;
d162 1
a162 1
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d164 1
a164 1
    return FALSE;
d173 1
a173 1
      return FALSE;
a193 1
      bfd_size_type amt;
d196 3
a198 4
	 The last element is used as an accumlator of shrinks.  */
      amt = reloc_count + 1;
      amt *= sizeof (unsigned);
      shrinks = (unsigned *) bfd_zmalloc (amt);
d201 24
a224 25
      do
	{
	  arelent **parent;
	  unsigned int i;
	  long j;

	  another_pass = 0;

	  for (i = 0, parent = reloc_vector; *parent; parent++, i++)
	    {
	      /* Let the target/machine dependent code examine each reloc
		 in this section and attempt to shrink it.  */
	      shrink = bfd_coff_reloc16_estimate (abfd, input_section, *parent,
						  shrinks[i], link_info);

	      /* If it shrunk, note it in the shrinks array and set up for
		 another pass.  */
	      if (shrink != shrinks[i])
		{
		  another_pass = 1;
		  for (j = i + 1; j <= reloc_count; j++)
		    shrinks[j] += shrink - shrinks[i];
		}
	    }
	}
d233 1
a233 1
  return TRUE;
d237 6
a242 6
bfd_coff_reloc16_get_relocated_section_contents (in_abfd,
						 link_info,
						 link_order,
						 data,
						 relocateable,
						 symbols)
d247 1
a247 1
     bfd_boolean relocateable;
d268 5
a272 5
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 data,
				 (bfd_vma) 0,
				 input_section->_raw_size))
d275 1
a275 1
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d196 1
a196 1
	 The last element is used as an accumulator of shrinks.  */
d243 1
a243 1
						 relocatable,
d249 1
a249 1
     bfd_boolean relocatable;
d262 2
a263 2
  /* If producing relocatable output, don't bother to relax.  */
  if (relocatable)
d266 1
a266 1
						       data, relocatable,
@


